/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 99 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 110 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef int OPJ_BOOL;
#line 114 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef char OPJ_CHAR;
#line 115 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef float OPJ_FLOAT32;
#line 116 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef double OPJ_FLOAT64;
#line 117 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef unsigned char OPJ_BYTE;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 122 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef uint8_t OPJ_UINT8;
#line 123 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef int16_t OPJ_INT16;
#line 124 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef uint16_t OPJ_UINT16;
#line 125 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef int32_t OPJ_INT32;
#line 126 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef uint32_t OPJ_UINT32;
#line 127 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_INT64;
#line 128 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef uint64_t OPJ_UINT64;
#line 130 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_OFF_T;
#line 133 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef size_t OPJ_SIZE_T;
#line 246
enum RSIZ_CAPABILITIES {
    OPJ_STD_RSIZ = 0,
    OPJ_CINEMA2K = 3,
    OPJ_CINEMA4K = 4,
    OPJ_MCT = 33024
} ;
#line 251 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 257
enum CINEMA_MODE {
    OPJ_OFF = 0,
    OPJ_CINEMA2K_24 = 1,
    OPJ_CINEMA2K_48 = 2,
    OPJ_CINEMA4K_24 = 3
} ;
#line 262 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 267
enum PROG_ORDER {
    OPJ_PROG_UNKNOWN = -1,
    OPJ_LRCP = 0,
    OPJ_RLCP = 1,
    OPJ_RPCL = 2,
    OPJ_PCRL = 3,
    OPJ_CPRL = 4
} ;
#line 274 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 279
enum COLOR_SPACE {
    OPJ_CLRSPC_UNKNOWN = -1,
    OPJ_CLRSPC_UNSPECIFIED = 0,
    OPJ_CLRSPC_SRGB = 1,
    OPJ_CLRSPC_GRAY = 2,
    OPJ_CLRSPC_SYCC = 3,
    OPJ_CLRSPC_EYCC = 4,
    OPJ_CLRSPC_CMYK = 5
} ;
#line 287 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 292
enum CODEC_FORMAT {
    OPJ_CODEC_UNKNOWN = -1,
    OPJ_CODEC_J2K = 0,
    OPJ_CODEC_JPT = 1,
    OPJ_CODEC_JP2 = 2,
    OPJ_CODEC_JPP = 3,
    OPJ_CODEC_JPX = 4
} ;
#line 299 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 325 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_poc {
   OPJ_UINT32 resno0 ;
   OPJ_UINT32 compno0 ;
   OPJ_UINT32 layno1 ;
   OPJ_UINT32 resno1 ;
   OPJ_UINT32 compno1 ;
   OPJ_UINT32 layno0 ;
   OPJ_UINT32 precno0 ;
   OPJ_UINT32 precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   OPJ_CHAR progorder[5] ;
   OPJ_UINT32 tile ;
   OPJ_INT32 tx0 ;
   OPJ_INT32 tx1 ;
   OPJ_INT32 ty0 ;
   OPJ_INT32 ty1 ;
   OPJ_UINT32 layS ;
   OPJ_UINT32 resS ;
   OPJ_UINT32 compS ;
   OPJ_UINT32 prcS ;
   OPJ_UINT32 layE ;
   OPJ_UINT32 resE ;
   OPJ_UINT32 compE ;
   OPJ_UINT32 prcE ;
   OPJ_UINT32 txS ;
   OPJ_UINT32 txE ;
   OPJ_UINT32 tyS ;
   OPJ_UINT32 tyE ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 lay_t ;
   OPJ_UINT32 res_t ;
   OPJ_UINT32 comp_t ;
   OPJ_UINT32 prc_t ;
   OPJ_UINT32 tx0_t ;
   OPJ_UINT32 ty0_t ;
};
#line 348 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 353 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_cparameters {
   OPJ_BOOL tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   OPJ_UINT32 numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   OPJ_BOOL jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   OPJ_BOOL jpip_on ;
   void *mct_data ;
   int max_cs_size ;
   OPJ_UINT16 rsiz ;
};
#line 504 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 512 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_dparameters {
   OPJ_UINT32 cp_reduce ;
   OPJ_UINT32 cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   OPJ_UINT32 DA_x0 ;
   OPJ_UINT32 DA_x1 ;
   OPJ_UINT32 DA_y0 ;
   OPJ_UINT32 DA_y1 ;
   OPJ_BOOL m_verbose ;
   OPJ_UINT32 tile_index ;
   OPJ_UINT32 nb_tile_to_decode ;
   OPJ_BOOL jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   unsigned int flags ;
};
#line 572 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 578 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef void *opj_codec_t;
#line 626 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef void *opj_stream_t;
#line 637 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_image_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 resno_decoded ;
   OPJ_UINT32 factor ;
   OPJ_INT32 *data ;
   OPJ_UINT16 alpha ;
};
#line 664 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 669 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_image {
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 x1 ;
   OPJ_UINT32 y1 ;
   OPJ_UINT32 numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
};
#line 688 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 694 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_image_comptparm {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
};
#line 713 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 726 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_packet_info {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_ph_pos ;
   OPJ_OFF_T end_pos ;
   double disto ;
};
#line 735 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 742 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_marker_info {
   unsigned short type ;
   OPJ_OFF_T pos ;
   int len ;
};
#line 749 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_marker_info opj_marker_info_t;
#line 755 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 766 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 771 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 806 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 811 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 858 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 866 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_tccp_info {
   OPJ_UINT32 compno ;
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   OPJ_UINT32 stepsizes_mant[97] ;
   OPJ_UINT32 stepsizes_expn[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
};
#line 896 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_tccp_info opj_tccp_info_t;
#line 901 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_tile_v2_info {
   int tileno ;
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 mct ;
   opj_tccp_info_t *tccp_info ;
};
#line 917 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_v2_info opj_tile_info_v2_t;
#line 922 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info_v2 {
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 nbcomps ;
   opj_tile_info_v2_t m_default_tile_info ;
   opj_tile_info_v2_t *tile_info ;
};
#line 946 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info_v2 opj_codestream_info_v2_t;
#line 952 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_tp_index {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_header ;
   OPJ_OFF_T end_pos ;
};
#line 960 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_index opj_tp_index_t;
#line 965 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_tile_index {
   OPJ_UINT32 tileno ;
   OPJ_UINT32 nb_tps ;
   OPJ_UINT32 current_nb_tps ;
   OPJ_UINT32 current_tpsno ;
   opj_tp_index_t *tp_index ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_packet ;
   opj_packet_info_t *packet_index ;
};
#line 992 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_index opj_tile_index_t;
#line 997 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
struct opj_codestream_index {
   OPJ_OFF_T main_head_start ;
   OPJ_OFF_T main_head_end ;
   OPJ_UINT64 codestream_size ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_of_tiles ;
   opj_tile_index_t *tile_index ;
};
#line 1020 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_index opj_codestream_index_t;
#line 217 "/root/patron/new_24/src/lib/openjp2/opj_includes.h"
typedef unsigned int OPJ_BITFIELD;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef long ptrdiff_t;
#line 50 "/root/patron/new_24/src/lib/openjp2/event.h"
struct opj_event_mgr {
   void *m_error_data ;
   void *m_warning_data ;
   void *m_info_data ;
   void (*error_handler)(char const   * , void * ) ;
   void (*warning_handler)(char const   * , void * ) ;
   void (*info_handler)(char const   * , void * ) ;
};
#line 63 "/root/patron/new_24/src/lib/openjp2/event.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 52 "/root/patron/new_24/src/lib/openjp2/function_list.h"
typedef void (*opj_procedure)(void);
#line 57 "/root/patron/new_24/src/lib/openjp2/function_list.h"
struct opj_procedure_list {
   OPJ_UINT32 m_nb_procedures ;
   OPJ_UINT32 m_nb_max_procedures ;
   opj_procedure *m_procedures ;
};
#line 71 "/root/patron/new_24/src/lib/openjp2/function_list.h"
typedef struct opj_procedure_list opj_procedure_list_t;
#line 56 "/root/patron/new_24/src/lib/openjp2/bio.h"
struct opj_bio {
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   OPJ_BYTE *bp ;
   OPJ_UINT32 buf ;
   OPJ_UINT32 ct ;
};
#line 67 "/root/patron/new_24/src/lib/openjp2/bio.h"
typedef struct opj_bio opj_bio_t;
#line 81 "/root/patron/new_24/src/lib/openjp2/cio.h"
struct opj_stream_private {
   void *m_user_data ;
   void (*m_free_user_data_fn)(void * ) ;
   OPJ_UINT64 m_user_data_length ;
   OPJ_SIZE_T (*m_read_fn)(void * , OPJ_SIZE_T  , void * ) ;
   OPJ_SIZE_T (*m_write_fn)(void * , OPJ_SIZE_T  , void * ) ;
   OPJ_OFF_T (*m_skip_fn)(OPJ_OFF_T  , void * ) ;
   OPJ_BOOL (*m_seek_fn)(OPJ_OFF_T  , void * ) ;
   OPJ_BYTE *m_stored_data ;
   OPJ_BYTE *m_current_data ;
   OPJ_OFF_T (*m_opj_skip)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*m_opj_seek)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_SIZE_T m_bytes_in_buffer ;
   OPJ_OFF_T m_byte_offset ;
   OPJ_SIZE_T m_buffer_size ;
   OPJ_UINT32 m_status ;
};
#line 165 "/root/patron/new_24/src/lib/openjp2/cio.h"
typedef struct opj_stream_private opj_stream_private_t;
#line 52 "/root/patron/new_24/src/lib/openjp2/thread.h"
struct opj_mutex_t ;
#line 52 "/root/patron/new_24/src/lib/openjp2/thread.h"
typedef struct opj_mutex_t opj_mutex_t;
#line 81
struct opj_cond_t ;
#line 81 "/root/patron/new_24/src/lib/openjp2/thread.h"
typedef struct opj_cond_t opj_cond_t;
#line 141
struct opj_thread_t ;
#line 141 "/root/patron/new_24/src/lib/openjp2/thread.h"
typedef struct opj_thread_t opj_thread_t;
#line 167
struct opj_tls_t ;
#line 167 "/root/patron/new_24/src/lib/openjp2/thread.h"
typedef struct opj_tls_t opj_tls_t;
#line 195
struct opj_thread_pool_t ;
#line 195 "/root/patron/new_24/src/lib/openjp2/thread.h"
typedef struct opj_thread_pool_t opj_thread_pool_t;
#line 41 "/root/patron/new_24/src/lib/openjp2/image.h"
struct opj_cp ;
#line 134 "/root/patron/new_24/src/lib/openjp2/j2k.h"
enum MCT_ELEMENT_TYPE {
    MCT_TYPE_INT16 = 0,
    MCT_TYPE_INT32 = 1,
    MCT_TYPE_FLOAT = 2,
    MCT_TYPE_DOUBLE = 3
} ;
#line 139 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef enum MCT_ELEMENT_TYPE J2K_MCT_ELEMENT_TYPE;
#line 144
enum MCT_ARRAY_TYPE {
    MCT_TYPE_DEPENDENCY = 0,
    MCT_TYPE_DECORRELATION = 1,
    MCT_TYPE_OFFSET = 2
} ;
#line 148 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef enum MCT_ARRAY_TYPE J2K_MCT_ARRAY_TYPE;
#line 155
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 158 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 163 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_stepsize {
   OPJ_INT32 expn ;
   OPJ_INT32 mant ;
};
#line 168 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 173 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_tccp {
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   opj_stepsize_t stepsizes[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
   OPJ_INT32 m_dc_level_shift ;
};
#line 201 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 208 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_mct_data {
   J2K_MCT_ELEMENT_TYPE m_element_type ;
   J2K_MCT_ARRAY_TYPE m_array_type ;
   OPJ_UINT32 m_index ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
};
#line 215 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_mct_data opj_mct_data_t;
#line 220 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_simple_mcc_decorrelation_data {
   OPJ_UINT32 m_index ;
   OPJ_UINT32 m_nb_comps ;
   opj_mct_data_t *m_decorrelation_array ;
   opj_mct_data_t *m_offset_array ;
   OPJ_BITFIELD m_is_irreversible ;
};
#line 227 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_simple_mcc_decorrelation_data opj_simple_mcc_decorrelation_data_t;
#line 229 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_ppx_struct {
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
};
#line 232 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_ppx_struct opj_ppx;
#line 239 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_tcp {
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 num_layers_to_decode ;
   OPJ_UINT32 mct ;
   OPJ_FLOAT32 rates[100] ;
   OPJ_UINT32 numpocs ;
   opj_poc_t pocs[32] ;
   OPJ_UINT32 ppt_markers_count ;
   opj_ppx *ppt_markers ;
   OPJ_BYTE *ppt_data ;
   OPJ_BYTE *ppt_buffer ;
   OPJ_UINT32 ppt_data_size ;
   OPJ_UINT32 ppt_len ;
   OPJ_FLOAT32 distoratio[100] ;
   opj_tccp_t *tccps ;
   OPJ_INT32 m_current_tile_part_number ;
   OPJ_UINT32 m_nb_tile_parts ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
   OPJ_FLOAT64 *mct_norms ;
   OPJ_FLOAT32 *m_mct_decoding_matrix ;
   OPJ_FLOAT32 *m_mct_coding_matrix ;
   opj_mct_data_t *m_mct_records ;
   OPJ_UINT32 m_nb_mct_records ;
   OPJ_UINT32 m_nb_max_mct_records ;
   opj_simple_mcc_decorrelation_data_t *m_mcc_records ;
   OPJ_UINT32 m_nb_mcc_records ;
   OPJ_UINT32 m_nb_max_mcc_records ;
   OPJ_BITFIELD cod ;
   OPJ_BITFIELD ppt ;
   OPJ_BITFIELD POC ;
};
#line 308 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 313 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_encoding_param {
   OPJ_UINT32 m_max_comp_size ;
   OPJ_INT32 m_tp_pos ;
   OPJ_INT32 *m_matrice ;
   OPJ_BYTE m_tp_flag ;
   OPJ_BITFIELD m_disto_alloc ;
   OPJ_BITFIELD m_fixed_alloc ;
   OPJ_BITFIELD m_fixed_quality ;
   OPJ_BITFIELD m_tp_on ;
};
#line 331 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_encoding_param opj_encoding_param_t;
#line 333 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_decoding_param {
   OPJ_UINT32 m_reduce ;
   OPJ_UINT32 m_layer ;
};
#line 339 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_decoding_param opj_decoding_param_t;
#line 393 "/root/patron/new_24/src/lib/openjp2/j2k.h"
union __anonunion_10 {
   opj_decoding_param_t m_dec ;
   opj_encoding_param_t m_enc ;
};
#line 345 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_cp {
   OPJ_UINT16 rsiz ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_CHAR *comment ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 ppm_markers_count ;
   opj_ppx *ppm_markers ;
   OPJ_BYTE *ppm_data ;
   OPJ_UINT32 ppm_len ;
   OPJ_UINT32 ppm_data_read ;
   OPJ_BYTE *ppm_data_current ;
   OPJ_BYTE *ppm_buffer ;
   OPJ_BYTE *ppm_data_first ;
   OPJ_UINT32 ppm_data_size ;
   OPJ_INT32 ppm_store ;
   OPJ_INT32 ppm_previous ;
   opj_tcp_t *tcps ;
   union __anonunion_10 m_specific_param ;
   OPJ_BITFIELD ppm ;
   OPJ_BITFIELD m_is_decoder ;
   OPJ_BITFIELD allow_different_bit_depth_sign ;
};
#line 452 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 455 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_j2k_dec {
   OPJ_UINT32 m_state ;
   opj_tcp_t *m_default_tcp ;
   OPJ_BYTE *m_header_data ;
   OPJ_UINT32 m_header_data_size ;
   OPJ_UINT32 m_sot_length ;
   OPJ_UINT32 m_start_tile_x ;
   OPJ_UINT32 m_start_tile_y ;
   OPJ_UINT32 m_end_tile_x ;
   OPJ_UINT32 m_end_tile_y ;
   OPJ_INT32 m_tile_ind_to_dec ;
   OPJ_OFF_T m_last_sot_read_pos ;
   OPJ_BOOL m_last_tile_part ;
   OPJ_BITFIELD m_can_decode ;
   OPJ_BITFIELD m_discard_tiles ;
   OPJ_BITFIELD m_skip_data ;
   OPJ_BITFIELD m_nb_tile_parts_correction_checked ;
   OPJ_BITFIELD m_nb_tile_parts_correction ;
};
#line 491 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_dec opj_j2k_dec_t;
#line 493 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_j2k_enc {
   OPJ_UINT32 m_current_poc_tile_part_number ;
   OPJ_UINT32 m_current_tile_part_number ;
   OPJ_OFF_T m_tlm_start ;
   OPJ_BYTE *m_tlm_sot_offsets_buffer ;
   OPJ_BYTE *m_tlm_sot_offsets_current ;
   OPJ_UINT32 m_total_tile_parts ;
   OPJ_BYTE *m_encoded_tile_data ;
   OPJ_UINT32 m_encoded_tile_size ;
   OPJ_BYTE *m_header_tile_data ;
   OPJ_UINT32 m_header_tile_data_size ;
};
#line 531 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_enc opj_j2k_enc_t;
#line 535
struct opj_tcd ;
#line 544 "/root/patron/new_24/src/lib/openjp2/j2k.h"
union __anonunion_11 {
   opj_j2k_dec_t m_decoder ;
   opj_j2k_enc_t m_encoder ;
};
#line 539 "/root/patron/new_24/src/lib/openjp2/j2k.h"
struct opj_j2k {
   OPJ_BOOL m_is_decoder ;
   union __anonunion_11 m_specific_param ;
   opj_image_t *m_private_image ;
   opj_image_t *m_output_image ;
   opj_cp_t m_cp ;
   opj_procedure_list_t *m_procedure_list ;
   opj_procedure_list_t *m_validation_list ;
   opj_codestream_index_t *cstr_index ;
   OPJ_UINT32 m_current_tile_number ;
   struct opj_tcd *m_tcd ;
   int m_num_threads ;
   opj_thread_pool_t *m_tp ;
   OPJ_UINT32 ihdr_w ;
   OPJ_UINT32 ihdr_h ;
   OPJ_UINT32 enumcs ;
   unsigned int dump_state ;
};
#line 585 "/root/patron/new_24/src/lib/openjp2/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 93 "/root/patron/new_24/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef_info {
   OPJ_UINT16 cn ;
   OPJ_UINT16 typ ;
   OPJ_UINT16 asoc ;
};
#line 95 "/root/patron/new_24/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 100 "/root/patron/new_24/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   OPJ_UINT16 n ;
};
#line 103 "/root/patron/new_24/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 108 "/root/patron/new_24/src/lib/openjp2/jp2.h"
struct opj_jp2_cmap_comp {
   OPJ_UINT16 cmp ;
   OPJ_BYTE mtyp ;
   OPJ_BYTE pcol ;
};
#line 111 "/root/patron/new_24/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 116 "/root/patron/new_24/src/lib/openjp2/jp2.h"
struct opj_jp2_pclr {
   OPJ_UINT32 *entries ;
   OPJ_BYTE *channel_sign ;
   OPJ_BYTE *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   OPJ_UINT16 nr_entries ;
   OPJ_BYTE nr_channels ;
};
#line 123 "/root/patron/new_24/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 128 "/root/patron/new_24/src/lib/openjp2/jp2.h"
struct opj_jp2_color {
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   OPJ_BYTE jp2_has_colr ;
};
#line 135 "/root/patron/new_24/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 140 "/root/patron/new_24/src/lib/openjp2/jp2.h"
struct opj_jp2_comps {
   OPJ_UINT32 depth ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 bpcc ;
};
#line 144 "/root/patron/new_24/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 149 "/root/patron/new_24/src/lib/openjp2/jp2.h"
struct opj_jp2 {
   opj_j2k_t *j2k ;
   struct opj_procedure_list *m_validation_list ;
   struct opj_procedure_list *m_procedure_list ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 numcomps ;
   OPJ_UINT32 bpc ;
   OPJ_UINT32 C ;
   OPJ_UINT32 UnkC ;
   OPJ_UINT32 IPR ;
   OPJ_UINT32 meth ;
   OPJ_UINT32 approx ;
   OPJ_UINT32 enumcs ;
   OPJ_UINT32 precedence ;
   OPJ_UINT32 brand ;
   OPJ_UINT32 minversion ;
   OPJ_UINT32 numcl ;
   OPJ_UINT32 *cl ;
   opj_jp2_comps_t *comps ;
   OPJ_OFF_T j2k_codestream_offset ;
   OPJ_OFF_T jpip_iptr_offset ;
   OPJ_BOOL jpip_on ;
   OPJ_UINT32 jp2_state ;
   OPJ_UINT32 jp2_img_state ;
   opj_jp2_color_t color ;
   OPJ_BOOL ignore_pclr_cmap_cdef ;
   OPJ_BYTE has_jp2h ;
   OPJ_BYTE has_ihdr ;
};
#line 193 "/root/patron/new_24/src/lib/openjp2/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 198 "/root/patron/new_24/src/lib/openjp2/jp2.h"
struct opj_jp2_box {
   OPJ_UINT32 length ;
   OPJ_UINT32 type ;
   OPJ_INT32 init_pos ;
};
#line 202 "/root/patron/new_24/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 204 "/root/patron/new_24/src/lib/openjp2/jp2.h"
struct opj_jp2_header_handler {
   OPJ_UINT32 id ;
   OPJ_BOOL (*handler)(opj_jp2_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 213 "/root/patron/new_24/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_header_handler opj_jp2_header_handler_t;
#line 216 "/root/patron/new_24/src/lib/openjp2/jp2.h"
struct opj_jp2_img_header_writer_handler {
   OPJ_BYTE *(*handler)(opj_jp2_t * , OPJ_UINT32 * ) ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_size ;
};
#line 224 "/root/patron/new_24/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_img_header_writer_handler opj_jp2_img_header_writer_handler_t;
#line 58 "/root/patron/new_24/src/lib/openjp2/mqc.h"
struct opj_mqc_state {
   OPJ_UINT32 qeval ;
   OPJ_UINT32 mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 67 "/root/patron/new_24/src/lib/openjp2/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 74 "/root/patron/new_24/src/lib/openjp2/mqc.h"
struct opj_mqc {
   OPJ_UINT32 c ;
   OPJ_UINT32 a ;
   OPJ_UINT32 ct ;
   OPJ_UINT32 end_of_byte_stream_counter ;
   OPJ_BYTE *bp ;
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
   OPJ_BYTE *lut_ctxno_zc_orient ;
   OPJ_BYTE backup[2] ;
};
#line 97 "/root/patron/new_24/src/lib/openjp2/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 55 "/root/patron/new_24/src/lib/openjp2/pi.h"
struct opj_pi_resolution {
   OPJ_UINT32 pdx ;
   OPJ_UINT32 pdy ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
};
#line 58 "/root/patron/new_24/src/lib/openjp2/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 63 "/root/patron/new_24/src/lib/openjp2/pi.h"
struct opj_pi_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 68 "/root/patron/new_24/src/lib/openjp2/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 73 "/root/patron/new_24/src/lib/openjp2/pi.h"
struct opj_pi_iterator {
   OPJ_BYTE tp_on ;
   OPJ_INT16 *include ;
   OPJ_UINT32 include_size ;
   OPJ_UINT32 step_l ;
   OPJ_UINT32 step_r ;
   OPJ_UINT32 step_c ;
   OPJ_UINT32 step_p ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 resno ;
   OPJ_UINT32 precno ;
   OPJ_UINT32 layno ;
   OPJ_BOOL first ;
   opj_poc_t poc ;
   OPJ_UINT32 numcomps ;
   opj_pi_comp_t *comps ;
   OPJ_INT32 tx0 ;
   OPJ_INT32 ty0 ;
   OPJ_INT32 tx1 ;
   OPJ_INT32 ty1 ;
   OPJ_INT32 x ;
   OPJ_INT32 y ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
};
#line 110 "/root/patron/new_24/src/lib/openjp2/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 57 "/root/patron/new_24/src/lib/openjp2/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   OPJ_INT32 value ;
   OPJ_INT32 low ;
   OPJ_UINT32 known ;
};
#line 62 "/root/patron/new_24/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 67 "/root/patron/new_24/src/lib/openjp2/tgt.h"
struct opj_tgt_tree {
   OPJ_UINT32 numleafsh ;
   OPJ_UINT32 numleafsv ;
   OPJ_UINT32 numnodes ;
   opj_tgt_node_t *nodes ;
   OPJ_UINT32 nodes_size ;
};
#line 73 "/root/patron/new_24/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 57 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_pass {
   OPJ_UINT32 rate ;
   OPJ_FLOAT64 distortiondec ;
   OPJ_UINT32 len ;
   OPJ_BITFIELD term ;
};
#line 62 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 67 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_layer {
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 len ;
   OPJ_FLOAT64 disto ;
   OPJ_BYTE *data ;
};
#line 72 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 77 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_enc {
   OPJ_BYTE *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 data_size ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 numpassesinlayers ;
   OPJ_UINT32 totalpasses ;
};
#line 90 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 94 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_seg_data_chunk {
   OPJ_BYTE *data ;
   OPJ_UINT32 len ;
};
#line 100 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_seg_data_chunk opj_tcd_seg_data_chunk_t;
#line 105 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_seg {
   OPJ_UINT32 len ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 real_num_passes ;
   OPJ_UINT32 maxpasses ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 newlen ;
};
#line 117 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 120 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_dec {
   opj_tcd_seg_t *segs ;
   opj_tcd_seg_data_chunk_t *chunks ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 numsegs ;
   OPJ_UINT32 real_num_segs ;
   OPJ_UINT32 m_current_max_segs ;
   OPJ_UINT32 numchunks ;
   OPJ_UINT32 numchunksalloc ;
   OPJ_INT32 *decoded_data ;
};
#line 139 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 146 "/root/patron/new_24/src/lib/openjp2/tcd.h"
union __anonunion_14 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
   void *blocks ;
};
#line 142 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_precinct {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 cw ;
   OPJ_UINT32 ch ;
   union __anonunion_14 cblks ;
   OPJ_UINT32 block_size ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 154 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 157 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_band {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 bandno ;
   opj_tcd_precinct_t *precincts ;
   OPJ_UINT32 precincts_data_size ;
   OPJ_INT32 numbps ;
   OPJ_FLOAT32 stepsize ;
};
#line 168 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 171 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_resolution {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
   OPJ_UINT32 numbands ;
   opj_tcd_band_t bands[3] ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
};
#line 186 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 189 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_tilecomp {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 minimum_num_resolutions ;
   opj_tcd_resolution_t *resolutions ;
   OPJ_UINT32 resolutions_size ;
   OPJ_INT32 *data ;
   OPJ_BOOL ownsData ;
   size_t data_size_needed ;
   size_t data_size ;
   OPJ_INT32 *data_win ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
   OPJ_INT32 numpix ;
};
#line 222 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 228 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_tile {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numcomps ;
   opj_tcd_tilecomp_t *comps ;
   OPJ_INT32 numpix ;
   OPJ_FLOAT64 distotile ;
   OPJ_FLOAT64 distolayer[100] ;
   OPJ_UINT32 packno ;
};
#line 237 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 242 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd_image {
   opj_tcd_tile_t *tiles ;
};
#line 245 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 251 "/root/patron/new_24/src/lib/openjp2/tcd.h"
struct opj_tcd {
   OPJ_INT32 tp_pos ;
   OPJ_UINT32 tp_num ;
   OPJ_UINT32 cur_tp_num ;
   OPJ_UINT32 cur_totnum_tp ;
   OPJ_UINT32 cur_pino ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcp_t *tcp ;
   OPJ_UINT32 tcd_tileno ;
   OPJ_BITFIELD m_is_decoder ;
   opj_thread_pool_t *thread_pool ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
   OPJ_BOOL whole_tile_decoding ;
};
#line 283 "/root/patron/new_24/src/lib/openjp2/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 179 "/root/patron/new_24/src/lib/openjp2/t1.h"
typedef OPJ_UINT32 opj_flag_t;
#line 184 "/root/patron/new_24/src/lib/openjp2/t1.h"
struct opj_t1 {
   opj_mqc_t mqc ;
   OPJ_INT32 *data ;
   opj_flag_t *flags ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 datasize ;
   OPJ_UINT32 flagssize ;
   OPJ_UINT32 data_stride ;
   OPJ_BOOL encoder ;
   OPJ_BOOL mustuse_cblkdatabuffer ;
   OPJ_BYTE *cblkdatabuffer ;
   OPJ_UINT32 cblkdatabuffersize ;
};
#line 211 "/root/patron/new_24/src/lib/openjp2/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 54 "/root/patron/new_24/src/lib/openjp2/t2.h"
struct opj_t2 {
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 60 "/root/patron/new_24/src/lib/openjp2/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 53 "/root/patron/new_24/src/lib/openjp2/sparse_array.h"
struct opj_sparse_array_int32 ;
#line 53 "/root/patron/new_24/src/lib/openjp2/sparse_array.h"
typedef struct opj_sparse_array_int32 opj_sparse_array_int32_t;
#line 48 "/root/patron/new_24/src/lib/openjp2/opj_codec.h"
struct opj_decompression {
   OPJ_BOOL (*opj_read_header)(struct opj_stream_private * , void * , opj_image_t ** ,
                               struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode)(void * , struct opj_stream_private * , opj_image_t * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_read_tile_header)(void * , OPJ_UINT32 * , OPJ_UINT32 * , OPJ_INT32 * ,
                                    OPJ_INT32 * , OPJ_INT32 * , OPJ_INT32 * , OPJ_UINT32 * ,
                                    OPJ_BOOL * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode_tile_data)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  ,
                                    struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_decompress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   void (*opj_setup_decoder)(void * , opj_dparameters_t * ) ;
   OPJ_BOOL (*opj_set_decode_area)(void * , opj_image_t * , OPJ_INT32  , OPJ_INT32  ,
                                   OPJ_INT32  , OPJ_INT32  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_get_decoded_tile)(void * , opj_stream_private_t * , opj_image_t * ,
                                    struct opj_event_mgr * , OPJ_UINT32  ) ;
   OPJ_BOOL (*opj_set_decoded_resolution_factor)(void * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 119 "/root/patron/new_24/src/lib/openjp2/opj_codec.h"
struct opj_compression {
   OPJ_BOOL (*opj_start_compress)(void * , struct opj_stream_private * , struct opj_image * ,
                                  struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encode)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_write_tile)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  , struct opj_stream_private * ,
                              struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_compress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   OPJ_BOOL (*opj_setup_encoder)(void * , opj_cparameters_t * , struct opj_image * ,
                                 struct opj_event_mgr * ) ;
};
#line 44 "/root/patron/new_24/src/lib/openjp2/opj_codec.h"
union __anonunion_15 {
   struct opj_decompression m_decompression ;
   struct opj_compression m_compression ;
};
#line 42 "/root/patron/new_24/src/lib/openjp2/opj_codec.h"
struct opj_codec_private {
   union __anonunion_15 m_codec_data ;
   void *m_codec ;
   opj_event_mgr_t m_event_mgr ;
   OPJ_BOOL is_decompressor ;
   void (*opj_dump_codec)(void * , OPJ_INT32  , FILE * ) ;
   opj_codestream_info_v2_t *(*opj_get_codec_info)(void * ) ;
   opj_codestream_index_t *(*opj_get_codec_index)(void * ) ;
   OPJ_BOOL (*opj_set_threads)(void * , OPJ_UINT32  ) ;
};
#line 162 "/root/patron/new_24/src/lib/openjp2/opj_codec.h"
typedef struct opj_codec_private opj_codec_private_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_18 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_17 {
   unsigned long long __wseq ;
   struct __anonstruct_18 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_20 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_19 {
   unsigned long long __g1_start ;
   struct __anonstruct_20 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_17 __annonCompField1 ;
   unsigned long long __wseq ;
   struct __anonstruct_18 __wseq32 ;
   union __anonunion_19 __annonCompField2 ;
   unsigned long long __g1_start ;
   struct __anonstruct_20 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_21 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_21 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_22 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_22 pthread_condattr_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_23 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_23 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_24 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_24 pthread_cond_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 718 "/usr/include/pthread.h"
struct __jmp_buf_tag ;
#line 306 "/root/patron/new_24/src/lib/openjp2/thread.c"
struct opj_mutex_t {
   pthread_mutex_t mutex ;
};
#line 341 "/root/patron/new_24/src/lib/openjp2/thread.c"
struct opj_cond_t {
   pthread_cond_t cond ;
};
#line 380 "/root/patron/new_24/src/lib/openjp2/thread.c"
struct opj_thread_t {
   void (*thread_fn)(void * ) ;
   void *user_data ;
   pthread_t thread ;
};
#line 493 "/root/patron/new_24/src/lib/openjp2/thread.c"
struct __anonstruct_44 {
   int key ;
   void *value ;
   void (*opj_free_func)(void * ) ;
};
#line 497 "/root/patron/new_24/src/lib/openjp2/thread.c"
typedef struct __anonstruct_44 opj_tls_key_val_t;
#line 499 "/root/patron/new_24/src/lib/openjp2/thread.c"
struct opj_tls_t {
   opj_tls_key_val_t *key_val ;
   int key_val_count ;
};
#line 568 "/root/patron/new_24/src/lib/openjp2/thread.c"
struct __anonstruct_45 {
   void (*job_fn)(void * , opj_tls_t * ) ;
   void *user_data ;
};
#line 571 "/root/patron/new_24/src/lib/openjp2/thread.c"
typedef struct __anonstruct_45 opj_worker_thread_job_t;
#line 573 "/root/patron/new_24/src/lib/openjp2/thread.c"
struct __anonstruct_46 {
   opj_thread_pool_t *tp ;
   opj_thread_t *thread ;
   int marked_as_waiting ;
   opj_mutex_t *mutex ;
   opj_cond_t *cond ;
};
#line 580 "/root/patron/new_24/src/lib/openjp2/thread.c"
typedef struct __anonstruct_46 opj_worker_thread_t;
#line 582
enum __anonenum__47 {
    OPJWTS_OK = 0,
    OPJWTS_STOP = 1,
    OPJWTS_ERROR = 2
} ;
#line 586 "/root/patron/new_24/src/lib/openjp2/thread.c"
typedef enum __anonenum__47 opj_worker_thread_state;
#line 588 "/root/patron/new_24/src/lib/openjp2/thread.c"
struct opj_job_list_t {
   opj_worker_thread_job_t *job ;
   struct opj_job_list_t *next ;
};
#line 592 "/root/patron/new_24/src/lib/openjp2/thread.c"
typedef struct opj_job_list_t opj_job_list_t;
#line 594 "/root/patron/new_24/src/lib/openjp2/thread.c"
struct opj_worker_thread_list_t {
   opj_worker_thread_t *worker_thread ;
   struct opj_worker_thread_list_t *next ;
};
#line 598 "/root/patron/new_24/src/lib/openjp2/thread.c"
typedef struct opj_worker_thread_list_t opj_worker_thread_list_t;
#line 600 "/root/patron/new_24/src/lib/openjp2/thread.c"
struct opj_thread_pool_t {
   opj_worker_thread_t *worker_threads ;
   int worker_threads_count ;
   opj_cond_t *cond ;
   opj_mutex_t *mutex ;
   opj_worker_thread_state state ;
   opj_job_list_t *job_queue ;
   int pending_jobs_count ;
   opj_worker_thread_list_t *waiting_worker_thread_list ;
   int waiting_worker_thread_count ;
   opj_tls_t *tls ;
   int signaling_threshold ;
};
#line 42 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __m64;
#line 48 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v2si;
#line 49 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v4hi;
#line 50 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v8qi;
#line 69 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __m128;
#line 72 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __m128_u;
#line 75 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __v4sf;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2df;
#line 41 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2di;
#line 42 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2du;
#line 43 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v4si;
#line 44 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v4su;
#line 45 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v8hi;
#line 46 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v8hu;
#line 47 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v16qi;
#line 49 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v16qu;
#line 53 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128i;
#line 54 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128d;
#line 57 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128i_u;
#line 58 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128d_u;
#line 1578 "/root/patron/new_24/src/lib/openjp2/t1.c"
struct __anonstruct_48 {
   OPJ_BOOL whole_tile_decoding ;
   OPJ_UINT32 resno ;
   opj_tcd_cblk_dec_t *cblk ;
   opj_tcd_band_t *band ;
   opj_tcd_tilecomp_t *tilec ;
   opj_tccp_t *tccp ;
   OPJ_BOOL mustuse_cblkdatabuffer ;
   OPJ_BOOL *pret ;
   opj_event_mgr_t *p_manager ;
   opj_mutex_t *p_manager_mutex ;
   OPJ_BOOL check_pterm ;
};
#line 1590 "/root/patron/new_24/src/lib/openjp2/t1.c"
typedef struct __anonstruct_48 opj_t1_cblk_decode_processing_job_t;
#line 35 "/root/patron/new_24/src/lib/openjp2/sparse_array.c"
struct opj_sparse_array_int32 {
   OPJ_UINT32 width ;
   OPJ_UINT32 height ;
   OPJ_UINT32 block_width ;
   OPJ_UINT32 block_height ;
   OPJ_UINT32 block_count_hor ;
   OPJ_UINT32 block_count_ver ;
   OPJ_INT32 **data_blocks ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_49 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_49 __sigset_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_51 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_52 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_53 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_54 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_55 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_56 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_57 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_58 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_59 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_60 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_61 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_62 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_63 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_64 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_51 __annonCompField3 ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_52 __annonCompField4 ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_53 __annonCompField5 ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_54 __annonCompField6 ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_55 __annonCompField7 ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_56 __annonCompField8 ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_57 __annonCompField9 ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_58 __annonCompField10 ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_59 __annonCompField11 ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_60 __annonCompField12 ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_61 __annonCompField13 ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_62 __annonCompField14 ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_63 __annonCompField15 ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_64 __annonCompField16 ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 197 "/root/patron/new_24/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler ;
#line 1304 "/root/patron/new_24/src/lib/openjp2/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 1307 "/root/patron/new_24/src/lib/openjp2/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1328 "/root/patron/new_24/src/lib/openjp2/j2k.c"
typedef void (*opj_j2k_mct_function)(void const   * , void * , OPJ_UINT32  );
#line 1352 "/root/patron/new_24/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler {
   OPJ_UINT32 id ;
   OPJ_UINT32 states ;
   OPJ_BOOL (*handler)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 1363 "/root/patron/new_24/src/lib/openjp2/j2k.c"
typedef struct opj_dec_memory_marker_handler opj_dec_memory_marker_handler_t;
#line 83 "/root/patron/new_24/src/lib/openjp2/dwt.c"
struct dwt_local {
   OPJ_INT32 *mem ;
   OPJ_INT32 dn ;
   OPJ_INT32 sn ;
   OPJ_INT32 cas ;
};
#line 88 "/root/patron/new_24/src/lib/openjp2/dwt.c"
typedef struct dwt_local opj_dwt_t;
#line 90 "/root/patron/new_24/src/lib/openjp2/dwt.c"
union __anonunion_127 {
   OPJ_FLOAT32 f[4] ;
};
#line 92 "/root/patron/new_24/src/lib/openjp2/dwt.c"
typedef union __anonunion_127 opj_v4_t;
#line 94 "/root/patron/new_24/src/lib/openjp2/dwt.c"
struct v4dwt_local {
   opj_v4_t *wavelet ;
   OPJ_INT32 dn ;
   OPJ_INT32 sn ;
   OPJ_INT32 cas ;
   OPJ_UINT32 win_l_x0 ;
   OPJ_UINT32 win_l_x1 ;
   OPJ_UINT32 win_h_x0 ;
   OPJ_UINT32 win_h_x1 ;
};
#line 103 "/root/patron/new_24/src/lib/openjp2/dwt.c"
typedef struct v4dwt_local opj_v4dwt_t;
#line 1304 "/root/patron/new_24/src/lib/openjp2/dwt.c"
struct __anonstruct_128 {
   opj_dwt_t h ;
   OPJ_UINT32 rw ;
   OPJ_UINT32 w ;
   OPJ_INT32 *tiledp ;
   OPJ_UINT32 min_j ;
   OPJ_UINT32 max_j ;
};
#line 1311 "/root/patron/new_24/src/lib/openjp2/dwt.c"
typedef struct __anonstruct_128 opj_dwd_decode_h_job_t;
#line 1328 "/root/patron/new_24/src/lib/openjp2/dwt.c"
struct __anonstruct_129 {
   opj_dwt_t v ;
   OPJ_UINT32 rh ;
   OPJ_UINT32 w ;
   OPJ_INT32 *tiledp ;
   OPJ_UINT32 min_j ;
   OPJ_UINT32 max_j ;
};
#line 1335 "/root/patron/new_24/src/lib/openjp2/dwt.c"
typedef struct __anonstruct_129 opj_dwd_decode_v_job_t;
#line 70 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned short uint16;
#line 73 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned int uint32;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct tiff ;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct tiff TIFF;
#line 65 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef long tmsize_t;
#line 72 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 tstrile_t;
#line 73 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tstrile_t tstrip_t;
#line 75 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tmsize_t tsize_t;
#line 76 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void *tdata_t;
#line 42 "/root/patron/new_24/src/bin/jp2/convert.h"
struct raw_comp_cparameters {
   int dx ;
   int dy ;
};
#line 48 "/root/patron/new_24/src/bin/jp2/convert.h"
typedef struct raw_comp_cparameters raw_comp_cparameters_t;
#line 52 "/root/patron/new_24/src/bin/jp2/convert.h"
struct raw_cparameters {
   int rawWidth ;
   int rawHeight ;
   int rawComp ;
   int rawBitDepth ;
   OPJ_BOOL rawSigned ;
   raw_comp_cparameters_t *rawComps ;
};
#line 66 "/root/patron/new_24/src/bin/jp2/convert.h"
typedef struct raw_cparameters raw_cparameters_t;
#line 74 "/root/patron/new_24/src/bin/jp2/convert.h"
typedef void (*convert_32s_CXPX)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  );
#line 77 "/root/patron/new_24/src/bin/jp2/convert.h"
typedef void (*convert_32s_PXCX)(OPJ_INT32 * const  * , OPJ_INT32 * , OPJ_SIZE_T  ,
                                 OPJ_INT32  );
#line 81 "/root/patron/new_24/src/bin/jp2/convert.h"
typedef void (*convert_XXx32s_C1R)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  );
#line 84 "/root/patron/new_24/src/bin/jp2/convert.h"
typedef void (*convert_32sXXx_C1R)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  );
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 481 "/usr/include/pngconf.h"
typedef unsigned char png_byte;
#line 511 "/usr/include/pngconf.h"
typedef unsigned int png_uint_32;
#line 523 "/usr/include/pngconf.h"
typedef size_t png_size_t;
#line 577 "/usr/include/pngconf.h"
typedef void *png_voidp;
#line 579 "/usr/include/pngconf.h"
typedef png_byte *png_bytep;
#line 580 "/usr/include/pngconf.h"
typedef png_byte *png_const_bytep;
#line 590 "/usr/include/pngconf.h"
typedef char const   *png_const_charp;
#line 597 "/usr/include/pngconf.h"
typedef FILE *png_FILE_p;
#line 606 "/usr/include/pngconf.h"
typedef png_byte **png_bytepp;
#line 454 "/usr/include/png.h"
struct png_struct_def ;
#line 454 "/usr/include/png.h"
typedef struct png_struct_def png_struct;
#line 456 "/usr/include/png.h"
typedef png_struct *png_structp;
#line 457 "/usr/include/png.h"
typedef png_struct **png_structpp;
#line 468
struct png_info_def ;
#line 468 "/usr/include/png.h"
typedef struct png_info_def png_info;
#line 469 "/usr/include/png.h"
typedef png_info *png_infop;
#line 471 "/usr/include/png.h"
typedef png_info **png_infopp;
#line 484 "/usr/include/png.h"
typedef png_struct *png_structrp;
#line 485 "/usr/include/png.h"
typedef png_struct *png_const_structrp;
#line 486 "/usr/include/png.h"
typedef png_info *png_inforp;
#line 487 "/usr/include/png.h"
typedef png_info *png_const_inforp;
#line 515 "/usr/include/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 522 "/usr/include/png.h"
typedef struct png_color_8_struct png_color_8;
#line 524 "/usr/include/png.h"
typedef png_color_8 *png_const_color_8p;
#line 48 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
struct __anonstruct_169 {
   OPJ_UINT16 bfType ;
   OPJ_UINT32 bfSize ;
   OPJ_UINT16 bfReserved1 ;
   OPJ_UINT16 bfReserved2 ;
   OPJ_UINT32 bfOffBits ;
};
#line 54 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
typedef struct __anonstruct_169 OPJ_BITMAPFILEHEADER;
#line 56 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
struct __anonstruct_170 {
   OPJ_UINT32 biSize ;
   OPJ_UINT32 biWidth ;
   OPJ_UINT32 biHeight ;
   OPJ_UINT16 biPlanes ;
   OPJ_UINT16 biBitCount ;
   OPJ_UINT32 biCompression ;
   OPJ_UINT32 biSizeImage ;
   OPJ_UINT32 biXpelsPerMeter ;
   OPJ_UINT32 biYpelsPerMeter ;
   OPJ_UINT32 biClrUsed ;
   OPJ_UINT32 biClrImportant ;
   OPJ_UINT32 biRedMask ;
   OPJ_UINT32 biGreenMask ;
   OPJ_UINT32 biBlueMask ;
   OPJ_UINT32 biAlphaMask ;
   OPJ_UINT32 biColorSpaceType ;
   OPJ_UINT8 biColorSpaceEP[36] ;
   OPJ_UINT32 biRedGamma ;
   OPJ_UINT32 biGreenGamma ;
   OPJ_UINT32 biBlueGamma ;
   OPJ_UINT32 biIntent ;
   OPJ_UINT32 biIccProfileData ;
   OPJ_UINT32 biIccProfileSize ;
   OPJ_UINT32 biReserved ;
};
#line 81 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
typedef struct __anonstruct_170 OPJ_BITMAPINFOHEADER;
#line 1489 "/root/patron/new_24/src/bin/jp2/convert.c"
struct pnm_header {
   int width ;
   int height ;
   int maxval ;
   int depth ;
   int format ;
   char rgb ;
   char rgba ;
   char gray ;
   char graya ;
   char bw ;
   char ok ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 6 "/root/patron/new_24/src/bin/common/opj_getopt.h"
struct opj_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 11 "/root/patron/new_24/src/bin/common/opj_getopt.h"
typedef struct opj_option opj_option_t;
#line 81 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 86 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
typedef struct dircnt dircnt_t;
#line 89 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
struct img_folder {
   char *imgdirpath ;
   char const   *out_format ;
   char set_imgdir ;
   char set_out_format ;
};
#line 99 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
typedef struct img_folder img_fol_t;
#line 101
enum opj_prec_mode {
    OPJ_PREC_MODE_CLIP = 0,
    OPJ_PREC_MODE_SCALE = 1
} ;
#line 104 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
typedef enum opj_prec_mode opj_precision_mode;
#line 106 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
struct opj_prec {
   OPJ_UINT32 prec ;
   opj_precision_mode mode ;
};
#line 109 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
typedef struct opj_prec opj_precision;
#line 111 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
struct opj_decompress_params {
   opj_dparameters_t core ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   char indexfilename[4096] ;
   OPJ_UINT32 DA_x0 ;
   OPJ_UINT32 DA_x1 ;
   OPJ_UINT32 DA_y0 ;
   OPJ_UINT32 DA_y1 ;
   OPJ_BOOL m_verbose ;
   OPJ_UINT32 tile_index ;
   OPJ_UINT32 nb_tile_to_decode ;
   opj_precision *precision ;
   OPJ_UINT32 nb_precision ;
   int force_rgb ;
   int upsample ;
   int split_pnm ;
   int num_threads ;
   int quiet ;
};
#line 155 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
typedef struct opj_decompress_params opj_decompress_parameters;
#line 2443 "/root/patron/new_24/src/bin/jp2/convert.c"
union __anonunion_171 ;
#line 2448
union __anonunion_172 ;
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                  size_t __n ) ;
#line 61
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 122
extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src ) ;
#line 125
extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 140 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 138 "/usr/include/stdio.h"
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 326
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 332
extern int printf(char const   *__format  , ...) ;
#line 334
extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__format 
                                                 , ...) ;
#line 358
extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __maxlen , char const   *__format ,
                                                   __gnuc_va_list __arg ) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 564
extern char *fgets(char *__s , int __n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 646
extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 1062 "/root/patron/new_24/src/lib/openjp2/openjpeg.h"
char const   *opj_version(void) ;
#line 1078
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) ;
#line 1086
void opj_image_destroy(opj_image_t *image ) ;
#line 1097
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                                   OPJ_COLOR_SPACE clrspc ) ;
#line 1109
void *opj_image_data_alloc(OPJ_SIZE_T size ) ;
#line 1119
void opj_image_data_free(void *ptr ) ;
#line 1134
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input ) ;
#line 1145
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) ;
#line 1154
void opj_stream_destroy(opj_stream_t *p_stream ) ;
#line 1161
void opj_stream_set_read_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                    OPJ_SIZE_T  ,
                                                                                    void * ) ) ;
#line 1169
void opj_stream_set_write_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                     OPJ_SIZE_T  ,
                                                                                     void * ) ) ;
#line 1177
void opj_stream_set_skip_function(opj_stream_t *p_stream , OPJ_OFF_T (*p_function)(OPJ_OFF_T  ,
                                                                                   void * ) ) ;
#line 1185
void opj_stream_set_seek_function(opj_stream_t *p_stream , OPJ_BOOL (*p_function)(OPJ_OFF_T  ,
                                                                                  void * ) ) ;
#line 1194
void opj_stream_set_user_data(opj_stream_t *p_stream , void *p_data , void (*p_function)(void * ) ) ;
#line 1203
void opj_stream_set_user_data_length(opj_stream_t *p_stream , OPJ_UINT64 data_length ) ;
#line 1211
opj_stream_t *opj_stream_create_default_file_stream(char const   *fname , OPJ_BOOL p_is_read_stream ) ;
#line 1219
opj_stream_t *opj_stream_create_file_stream(char const   *fname , OPJ_SIZE_T p_size ,
                                            OPJ_BOOL p_is_read_stream ) ;
#line 1235
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                        void * ) ,
                              void *p_user_data ) ;
#line 1244
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                           void * ) ,
                                 void *p_user_data ) ;
#line 1253
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                         void * ) ,
                               void *p_user_data ) ;
#line 1269
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) ;
#line 1277
void opj_destroy_codec(opj_codec_t *p_codec ) ;
#line 1284
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1292
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 1304
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec , opj_dparameters_t *parameters ) ;
#line 1323
OPJ_BOOL opj_codec_set_threads(opj_codec_t *p_codec , int num_threads ) ;
#line 1335
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec , opj_image_t **p_image ) ;
#line 1361
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                             OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ) ;
#line 1374
OPJ_BOOL opj_decode(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ) ;
#line 1388
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ,
                              OPJ_UINT32 tile_index ) ;
#line 1400
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec , OPJ_UINT32 res_factor ) ;
#line 1415
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                        OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1442
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec , opj_stream_t *p_stream , OPJ_UINT32 *p_tile_index ,
                              OPJ_UINT32 *p_data_size , OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 ,
                              OPJ_INT32 *p_tile_x1 , OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                              OPJ_BOOL *p_should_go_on ) ;
#line 1463
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                              OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1476
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format ) ;
#line 1499
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 1508
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec , opj_cparameters_t *parameters ,
                           opj_image_t *p_image ) ;
#line 1518
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec , opj_image_t *p_image , opj_stream_t *p_stream ) ;
#line 1527
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1537
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream ) ;
#line 1550
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) ;
#line 1562
void opj_dump_codec(opj_codec_t *p_codec , OPJ_INT32 info_flag , FILE *output_stream ) ;
#line 1574
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec ) ;
#line 1585
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec ) ;
#line 1588
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) ;
#line 1630
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) ;
#line 1644
OPJ_BOOL opj_has_thread_support(void) ;
#line 1647
int opj_get_num_cpus(void) ;
#line 174 "/root/patron/new_24/src/lib/openjp2/opj_includes.h"
__inline static long opj_lrintf(float f ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 176
  __cil_tmp2 = lrintf(f);
  }
#line 176
  return (__cil_tmp2);
}
}
#line 51 "/root/patron/new_24/src/lib/openjp2/opj_clock.h"
OPJ_FLOAT64 opj_clock(void) ;
#line 55 "/root/patron/new_24/src/lib/openjp2/opj_malloc.h"
void *opj_malloc(size_t size ) ;
#line 63
void *opj_calloc(size_t num , size_t size ) ;
#line 70
void *opj_aligned_malloc(size_t size ) ;
#line 71
void *opj_aligned_realloc(void *ptr , size_t size ) ;
#line 72
void opj_aligned_free(void *ptr ) ;
#line 79
void *opj_aligned_32_malloc(size_t size ) ;
#line 80
void *opj_aligned_32_realloc(void *ptr , size_t size ) ;
#line 88
void *opj_realloc(void *ptr , size_t new_size ) ;
#line 94
void opj_free(void *ptr ) ;
#line 89 "/root/patron/new_24/src/lib/openjp2/event.h"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) ;
#line 96
void opj_set_default_event_handler(opj_event_mgr_t *p_manager ) ;
#line 80 "/root/patron/new_24/src/lib/openjp2/function_list.h"
opj_procedure_list_t *opj_procedure_list_create(void) ;
#line 87
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) ;
#line 98
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          void (*p_procedure)(void) , opj_event_mgr_t *p_manager ) ;
#line 108
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list ) ;
#line 120
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list ) ;
#line 130
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list ) ;
#line 76 "/root/patron/new_24/src/lib/openjp2/bio.h"
opj_bio_t *opj_bio_create(void) ;
#line 81
void opj_bio_destroy(opj_bio_t *bio ) ;
#line 87
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) ;
#line 94
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 101
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 108
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) ;
#line 115
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 121
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) ;
#line 127
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) ;
#line 176 "/root/patron/new_24/src/lib/openjp2/cio.h"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 186
void opj_read_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 196
void opj_write_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 206
void opj_read_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 215
void opj_write_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 222
void opj_write_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 229
void opj_read_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 236
void opj_read_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 243
void opj_read_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 250
void opj_read_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 257
void opj_write_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 264
void opj_write_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 274
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 285
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                 OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 295
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream , opj_event_mgr_t *p_event_mgr ) ;
#line 305
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 315
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream ) ;
#line 325
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream ) ;
#line 335
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                                opj_event_mgr_t *p_event_mgr ) ;
#line 345
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) ;
#line 355
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                              opj_event_mgr_t *p_event_mgr ) ;
#line 365
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) ;
#line 375
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) ;
#line 381
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream ) ;
#line 386
OPJ_SIZE_T opj_stream_default_read(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 392
OPJ_SIZE_T opj_stream_default_write(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 398
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 403
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 58 "/root/patron/new_24/src/lib/openjp2/thread.h"
opj_mutex_t *opj_mutex_create(void) ;
#line 63
void opj_mutex_lock(opj_mutex_t *mutex ) ;
#line 68
void opj_mutex_unlock(opj_mutex_t *mutex ) ;
#line 73
void opj_mutex_destroy(opj_mutex_t *mutex ) ;
#line 87
opj_cond_t *opj_cond_create(void) ;
#line 120
void opj_cond_wait(opj_cond_t *cond , opj_mutex_t *mutex ) ;
#line 128
void opj_cond_signal(opj_cond_t *cond ) ;
#line 133
void opj_cond_destroy(opj_cond_t *cond ) ;
#line 154
opj_thread_t *opj_thread_create(void (*thread_fn)(void * ) , void *user_data ) ;
#line 160
void opj_thread_join(opj_thread_t *thread ) ;
#line 174
void *opj_tls_get(opj_tls_t *tls , int key ) ;
#line 186
OPJ_BOOL opj_tls_set(opj_tls_t *tls , int key , void *value , void (*opj_free_func)(void * ) ) ;
#line 207
opj_thread_pool_t *opj_thread_pool_create(int num_threads ) ;
#line 225
OPJ_BOOL opj_thread_pool_submit_job(opj_thread_pool_t *tp , void (*job_fn)(void * ,
                                                                           opj_tls_t * ) ,
                                    void *user_data ) ;
#line 237
void opj_thread_pool_wait_completion(opj_thread_pool_t *tp , int max_remaining_jobs ) ;
#line 245
int opj_thread_pool_get_thread_count(opj_thread_pool_t *tp ) ;
#line 250
void opj_thread_pool_destroy(opj_thread_pool_t *tp ) ;
#line 51 "/root/patron/new_24/src/lib/openjp2/image.h"
opj_image_t *opj_image_create0(void) ;
#line 61
void opj_image_comp_header_update(opj_image_t *p_image_header , struct opj_cp *p_cp ) ;
#line 64
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) ;
#line 56 "/root/patron/new_24/src/lib/openjp2/invert.h"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) ;
#line 600 "/root/patron/new_24/src/lib/openjp2/j2k.h"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 602
OPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k , OPJ_UINT32 num_threads ) ;
#line 609
opj_j2k_t *opj_j2k_create_compress(void) ;
#line 612
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters ,
                               opj_image_t *image , opj_event_mgr_t *p_manager ) ;
#line 620
char const   *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 631
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 645
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 656
void opj_j2k_destroy(opj_j2k_t *p_j2k ) ;
#line 663
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) ;
#line 674
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 695
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 721
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 732
opj_j2k_t *opj_j2k_create_decompress(void) ;
#line 743
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) ;
#line 754
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) ;
#line 764
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) ;
#line 774
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) ;
#line 783
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) ;
#line 793
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 799
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 805
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 819
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 829
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 843
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) ;
#line 852
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) ;
#line 856
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) ;
#line 236 "/root/patron/new_24/src/lib/openjp2/jp2.h"
void opj_jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 238
OPJ_BOOL opj_jp2_set_threads(opj_jp2_t *jp2 , OPJ_UINT32 num_threads ) ;
#line 249
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 264
OPJ_BOOL opj_jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ,
                               opj_event_mgr_t *p_manager ) ;
#line 276
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 291
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_image_t *p_image ,
                                opj_event_mgr_t *p_manager ) ;
#line 301
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 311
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 325
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream , opj_jp2_t *jp2 , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 344
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 366
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 384
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 396
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) ;
#line 402
void opj_jp2_destroy(opj_jp2_t *jp2 ) ;
#line 418
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2 , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 427
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 437
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2 , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 451
void jp2_dump(opj_jp2_t *p_jp2 , OPJ_INT32 flag , FILE *out_stream ) ;
#line 460
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2 ) ;
#line 469
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2 ) ;
#line 74 "/root/patron/new_24/src/lib/openjp2/mqc_inl.h"
__inline static OPJ_UINT32 opj_mqc_raw_decode(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 d ;
  OPJ_UINT32 __cil_tmp5 ;

  {
#line 77
  if (mqc->ct == 0U) {
#line 80
    if (mqc->c == 255U) {
#line 81
      if ((int )*(mqc->bp) > 143) {
#line 82
        mqc->c = (OPJ_UINT32 )255;
#line 83
        mqc->ct = (OPJ_UINT32 )8;
      } else {
#line 85
        mqc->c = (OPJ_UINT32 )*(mqc->bp);
#line 86
        (mqc->bp) ++;
#line 87
        mqc->ct = (OPJ_UINT32 )7;
      }
    } else {
#line 90
      mqc->c = (OPJ_UINT32 )*(mqc->bp);
#line 91
      (mqc->bp) ++;
#line 92
      mqc->ct = (OPJ_UINT32 )8;
    }
  }
#line 95
  __cil_tmp5 = mqc->ct;
#line 95
  (mqc->ct) --;
#line 96
  d = (mqc->c >> mqc->ct) & 1U;
#line 98
  return (d);
}
}
#line 175 "/root/patron/new_24/src/lib/openjp2/mqc_inl.h"
__inline static void opj_mqc_bytein(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 l_c ;

  {
#line 177
  l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 177
  if ((int )*(mqc->bp) == 255) {
#line 177
    if (l_c > 143U) {
#line 177
      mqc->c += 65280U;
#line 177
      mqc->ct = (OPJ_UINT32 )8;
#line 177
      (mqc->end_of_byte_stream_counter) ++;
    } else {
#line 177
      (mqc->bp) ++;
#line 177
      mqc->c += l_c << 9;
#line 177
      mqc->ct = (OPJ_UINT32 )7;
    }
  } else {
#line 177
    (mqc->bp) ++;
#line 177
    mqc->c += l_c << 8;
#line 177
    mqc->ct = (OPJ_UINT32 )8;
  }
#line 180
  return;
}
}
#line 110 "/root/patron/new_24/src/lib/openjp2/mqc.h"
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc ) ;
#line 116
void opj_mqc_resetstates(opj_mqc_t *mqc ) ;
#line 124
void opj_mqc_setstate(opj_mqc_t *mqc , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) ;
#line 131
void opj_mqc_init_enc(opj_mqc_t *mqc , OPJ_BYTE *bp ) ;
#line 143
void opj_mqc_encode(opj_mqc_t *mqc , OPJ_UINT32 d ) ;
#line 148
void opj_mqc_flush(opj_mqc_t *mqc ) ;
#line 154
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 161
OPJ_UINT32 opj_mqc_bypass_get_extra_bytes(opj_mqc_t *mqc , OPJ_BOOL erterm ) ;
#line 169
void opj_mqc_bypass_enc(opj_mqc_t *mqc , OPJ_UINT32 d ) ;
#line 175
void opj_mqc_bypass_flush_enc(opj_mqc_t *mqc , OPJ_BOOL erterm ) ;
#line 180
void opj_mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 195
void opj_mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 200
void opj_mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 205
void opj_mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 225
void opj_mqc_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len , OPJ_UINT32 extra_writable_bytes ) ;
#line 246
void opj_mqc_raw_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len , OPJ_UINT32 extra_writable_bytes ) ;
#line 258
void opq_mqc_finish_dec(opj_mqc_t *mqc ) ;
#line 125 "/root/patron/new_24/src/lib/openjp2/pi.h"
opj_pi_iterator_t *opj_pi_initialise_encode(opj_image_t *p_image , opj_cp_t *p_cp ,
                                            OPJ_UINT32 p_tile_no , J2K_T2_MODE p_t2_mode ) ;
#line 137
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 151
void opj_pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) ;
#line 167
opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 176
void opj_pi_destroy(opj_pi_iterator_t *p_pi , OPJ_UINT32 p_nb_elements ) ;
#line 184
OPJ_BOOL opj_pi_next(opj_pi_iterator_t *pi ) ;
#line 86 "/root/patron/new_24/src/lib/openjp2/tgt.h"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv , opj_event_mgr_t *p_manager ) ;
#line 98
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ,
                             opj_event_mgr_t *p_manager ) ;
#line 105
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) ;
#line 110
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) ;
#line 117
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) ;
#line 127
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) ;
#line 139
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) ;
#line 299 "/root/patron/new_24/src/lib/openjp2/tcd.h"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) ;
#line 305
void opj_tcd_destroy(opj_tcd_t *tcd ) ;
#line 316
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp , opj_thread_pool_t *p_tp ) ;
#line 331
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) ;
#line 334
void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) ;
#line 337
void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd ) ;
#line 339
void opj_tcd_makelayer(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_FLOAT64 thresh , OPJ_UINT32 final ) ;
#line 344
OPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 len , opj_codestream_info_t *cstr_info ,
                              opj_event_mgr_t *p_manager ) ;
#line 354
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd , OPJ_BOOL take_into_account_partial_decoding ) ;
#line 368
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info , opj_event_mgr_t *p_manager ) ;
#line 390
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 win_x0 , OPJ_UINT32 win_y0 ,
                             OPJ_UINT32 win_x1 , OPJ_UINT32 win_y1 , OPJ_BYTE *p_src ,
                             OPJ_UINT32 p_max_length , OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ,
                             opj_event_mgr_t *p_manager ) ;
#line 405
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) ;
#line 412
OPJ_SIZE_T opj_tcd_get_encoded_tile_size(opj_tcd_t *p_tcd ) ;
#line 423
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) ;
#line 429
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_SIZE_T p_src_length ) ;
#line 438
OPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec ) ;
#line 444
OPJ_BOOL opj_tcd_is_band_empty(opj_tcd_band_t *band ) ;
#line 447
void opj_tcd_reinit_segment(opj_tcd_seg_t *seg ) ;
#line 464
OPJ_BOOL opj_tcd_is_subband_area_of_interest(opj_tcd_t *tcd , OPJ_UINT32 compno ,
                                             OPJ_UINT32 resno , OPJ_UINT32 bandno ,
                                             OPJ_UINT32 band_x0 , OPJ_UINT32 band_y0 ,
                                             OPJ_UINT32 band_x1 , OPJ_UINT32 band_y1 ) ;
#line 225 "/root/patron/new_24/src/lib/openjp2/t1.h"
OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                             OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) ;
#line 241
void opj_t1_decode_cblks(opj_tcd_t *tcd , OPJ_BOOL *pret , opj_tcd_tilecomp_t *tilec ,
                         opj_tccp_t *tccp , opj_event_mgr_t *p_manager , opj_mutex_t *p_manager_mutex ,
                         OPJ_BOOL check_pterm ) ;
#line 256
opj_t1_t *opj_t1_create(OPJ_BOOL isEncoder ) ;
#line 263
void opj_t1_destroy(opj_t1_t *p_t1 ) ;
#line 61 "/root/patron/new_24/src/lib/openjp2/dwt.h"
OPJ_BOOL opj_dwt_encode(opj_tcd_tilecomp_t *tilec ) ;
#line 70
OPJ_BOOL opj_dwt_decode(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 79
OPJ_UINT32 opj_dwt_getgain(OPJ_UINT32 orient ) ;
#line 86
OPJ_FLOAT64 opj_dwt_getnorm(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 92
OPJ_BOOL opj_dwt_encode_real(opj_tcd_tilecomp_t *tilec ) ;
#line 100
OPJ_BOOL opj_dwt_decode_real(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 109
OPJ_UINT32 opj_dwt_getgain_real(OPJ_UINT32 orient ) ;
#line 116
OPJ_FLOAT64 opj_dwt_getnorm_real(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 122
void opj_dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , OPJ_UINT32 prec ) ;
#line 82 "/root/patron/new_24/src/lib/openjp2/t2.h"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               OPJ_UINT32 p_tp_num , OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino ,
                               J2K_T2_MODE p_t2_mode , opj_event_mgr_t *p_manager ) ;
#line 110
OPJ_BOOL opj_t2_decode_packets(opj_tcd_t *tcd , opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no ,
                               opj_tcd_tile_t *p_tile , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                               OPJ_UINT32 p_max_len , opj_codestream_index_t *p_cstr_index ,
                               opj_event_mgr_t *p_manager ) ;
#line 127
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) ;
#line 133
void opj_t2_destroy(opj_t2_t *t2 ) ;
#line 63 "/root/patron/new_24/src/lib/openjp2/mct.h"
void opj_mct_encode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) ;
#line 72
void opj_mct_decode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) ;
#line 79
OPJ_FLOAT64 opj_mct_getnorm(OPJ_UINT32 compno ) ;
#line 88
void opj_mct_encode_real(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) ;
#line 97
void opj_mct_decode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 , OPJ_SIZE_T n ) ;
#line 104
OPJ_FLOAT64 opj_mct_getnorm_real(OPJ_UINT32 compno ) ;
#line 115
OPJ_BOOL opj_mct_encode_custom(OPJ_BYTE *pCodingdata , OPJ_SIZE_T n , OPJ_BYTE **pData ,
                               OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) ;
#line 130
OPJ_BOOL opj_mct_decode_custom(OPJ_BYTE *pDecodingData , OPJ_SIZE_T n , OPJ_BYTE **pData ,
                               OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) ;
#line 143
void opj_calculate_norms(OPJ_FLOAT64 *pNorms , OPJ_UINT32 pNbComps , OPJ_FLOAT32 *pMatrix ) ;
#line 149
OPJ_FLOAT64 *opj_mct_get_mct_norms(void) ;
#line 153
OPJ_FLOAT64 *opj_mct_get_mct_norms_real(void) ;
#line 56 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_min(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 58
  if (a < b) {
#line 58
    tmp = a;
  } else {
#line 58
    tmp = b;
  }
#line 58
  return (tmp);
}
}
#line 65 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_min(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 67
  if (a < b) {
#line 67
    tmp = a;
  } else {
#line 67
    tmp = b;
  }
#line 67
  return (tmp);
}
}
#line 74 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_max(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 76
  if (a > b) {
#line 76
    tmp = a;
  } else {
#line 76
    tmp = b;
  }
#line 76
  return (tmp);
}
}
#line 83 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_max(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 85
  if (a > b) {
#line 85
    tmp = a;
  } else {
#line 85
    tmp = b;
  }
#line 85
  return (tmp);
}
}
#line 92 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_adds(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT64 sum ;

  {
#line 94
  sum = (OPJ_UINT64 )a + (OPJ_UINT64 )b;
#line 95
  return ((OPJ_UINT32 )(- ((OPJ_INT32 )(sum >> 32))) | (OPJ_UINT32 )sum);
}
}
#line 102 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_subs(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 104
  if (a >= b) {
#line 104
    tmp = a - b;
  } else {
#line 104
    tmp = 0U;
  }
#line 104
  return (tmp);
}
}
#line 116 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_clamp(OPJ_INT32 a , OPJ_INT32 min , OPJ_INT32 max ) 
{ 


  {
#line 119
  if (a < min) {
#line 120
    return (min);
  }
#line 122
  if (a > max) {
#line 123
    return (max);
  }
#line 125
  return (a);
}
}
#line 137 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT64 opj_int64_clamp(OPJ_INT64 a , OPJ_INT64 min , OPJ_INT64 max ) 
{ 


  {
#line 140
  if (a < min) {
#line 141
    return (min);
  }
#line 143
  if (a > max) {
#line 144
    return (max);
  }
#line 146
  return (a);
}
}
#line 152 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_abs(OPJ_INT32 a ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 154
  if (a < 0) {
#line 154
    tmp = - a;
  } else {
#line 154
    tmp = a;
  }
#line 154
  return (tmp);
}
}
#line 160 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildiv(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 163
  return ((OPJ_INT32 )((((OPJ_INT64 )a + (long )b) - 1L) / (long )b));
}
}
#line 170 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_ceildiv(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 173
  return (((a + b) - 1U) / b);
}
}
#line 180 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 182
  return ((OPJ_INT32 )((((long )a + (1L << b)) - 1L) >> b));
}
}
#line 189 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int64_ceildivpow2(OPJ_INT64 a , OPJ_INT32 b ) 
{ 


  {
#line 191
  return ((OPJ_INT32 )(((a + (1L << b)) - 1L) >> b));
}
}
#line 198 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_ceildivpow2(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 200
  return ((OPJ_UINT32 )((((unsigned long )a + (1UL << b)) - 1UL) >> b));
}
}
#line 207 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floordivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 209
  return (a >> b);
}
}
#line 215 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floorlog2(OPJ_INT32 a ) 
{ 
  OPJ_INT32 l ;

  {
#line 218
  l = 0;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;

#line 218
    if (! (a > 1)) {
#line 218
      goto while_break;
    }
#line 219
    a >>= 1;
#line 218
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 221
  return (l);
}
}
#line 227 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_floorlog2(OPJ_UINT32 a ) 
{ 
  OPJ_UINT32 l ;

  {
#line 230
  l = (OPJ_UINT32 )0;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;

#line 230
    if (! (a > 1U)) {
#line 230
      goto while_break;
    }
#line 231
    a >>= 1;
#line 230
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 233
  return (l);
}
}
#line 242 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_fix_mul(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT64 temp ;

  {
#line 247
  temp = (OPJ_INT64 )a * (OPJ_INT64 )b;
#line 249
  temp += 4096L;
#line 252
  return ((OPJ_INT32 )(temp >> 13));
}
}
#line 255 "/root/patron/new_24/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_fix_mul_t1(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT64 temp ;

  {
#line 260
  temp = (OPJ_INT64 )a * (OPJ_INT64 )b;
#line 262
  temp += 4096L;
#line 266
  return ((OPJ_INT32 )(temp >> 18));
}
}
#line 62 "/root/patron/new_24/src/lib/openjp2/sparse_array.h"
opj_sparse_array_int32_t *opj_sparse_array_int32_create(OPJ_UINT32 width , OPJ_UINT32 height ,
                                                        OPJ_UINT32 block_width , OPJ_UINT32 block_height ) ;
#line 70
void opj_sparse_array_int32_free(opj_sparse_array_int32_t *sa ) ;
#line 80
OPJ_BOOL opj_sparse_array_is_region_valid(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                          OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ) ;
#line 102
OPJ_BOOL opj_sparse_array_int32_read(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                     OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                     OPJ_INT32 *dest , OPJ_UINT32 dest_col_stride ,
                                     OPJ_UINT32 dest_line_stride , OPJ_BOOL forgiving ) ;
#line 129
OPJ_BOOL opj_sparse_array_int32_write(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                      OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                      OPJ_INT32 *src , OPJ_UINT32 src_col_stride ,
                                      OPJ_UINT32 src_line_stride , OPJ_BOOL forgiving ) ;
#line 198 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 215
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 263
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 275
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 725
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 730
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 738
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 756
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 965
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 970
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 974
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 986
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 292 "/root/patron/new_24/src/lib/openjp2/thread.c"
OPJ_BOOL opj_has_thread_support(void) 
{ 


  {
#line 294
  return (1);
}
}
#line 297 "/root/patron/new_24/src/lib/openjp2/thread.c"
int opj_get_num_cpus(void) 
{ 
  long __cil_tmp1 ;

  {
  {
#line 300
  __cil_tmp1 = sysconf(84);
  }
#line 300
  return ((int )__cil_tmp1);
}
}
#line 310 "/root/patron/new_24/src/lib/openjp2/thread.c"
opj_mutex_t *opj_mutex_create(void) 
{ 
  opj_mutex_t *mutex ;
  void *__cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 312
  __cil_tmp2 = opj_calloc((size_t )1U, sizeof(opj_mutex_t ));
#line 312
  mutex = (opj_mutex_t *)__cil_tmp2;
  }
#line 313
  if ((unsigned long )mutex != (unsigned long )((void *)0)) {
    {
#line 314
    __cil_tmp3 = pthread_mutex_init(& mutex->mutex, (pthread_mutexattr_t *)((void *)0));
    }
#line 314
    if (__cil_tmp3 != 0) {
      {
#line 315
      opj_free((void *)mutex);
#line 316
      mutex = (opj_mutex_t *)((void *)0);
      }
    }
  }
#line 319
  return (mutex);
}
}
#line 322 "/root/patron/new_24/src/lib/openjp2/thread.c"
void opj_mutex_lock(opj_mutex_t *mutex ) 
{ 


  {
  {
#line 324
  pthread_mutex_lock(& mutex->mutex);
  }
#line 326
  return;
}
}
#line 327 "/root/patron/new_24/src/lib/openjp2/thread.c"
void opj_mutex_unlock(opj_mutex_t *mutex ) 
{ 


  {
  {
#line 329
  pthread_mutex_unlock(& mutex->mutex);
  }
#line 331
  return;
}
}
#line 332 "/root/patron/new_24/src/lib/openjp2/thread.c"
void opj_mutex_destroy(opj_mutex_t *mutex ) 
{ 


  {
#line 334
  if (! mutex) {
#line 335
    return;
  }
  {
#line 337
  pthread_mutex_destroy(& mutex->mutex);
#line 338
  opj_free((void *)mutex);
  }
#line 340
  return;
}
}
#line 345 "/root/patron/new_24/src/lib/openjp2/thread.c"
opj_cond_t *opj_cond_create(void) 
{ 
  opj_cond_t *cond ;
  void *__cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 347
  __cil_tmp2 = opj_malloc(sizeof(opj_cond_t ));
#line 347
  cond = (opj_cond_t *)__cil_tmp2;
  }
#line 348
  if (! cond) {
#line 349
    return ((opj_cond_t *)((void *)0));
  }
  {
#line 351
  __cil_tmp3 = pthread_cond_init(& cond->cond, (pthread_condattr_t *)((void *)0));
  }
#line 351
  if (__cil_tmp3 != 0) {
    {
#line 352
    opj_free((void *)cond);
    }
#line 353
    return ((opj_cond_t *)((void *)0));
  }
#line 355
  return (cond);
}
}
#line 358 "/root/patron/new_24/src/lib/openjp2/thread.c"
void opj_cond_wait(opj_cond_t *cond , opj_mutex_t *mutex ) 
{ 


  {
  {
#line 360
  pthread_cond_wait(& cond->cond, & mutex->mutex);
  }
#line 362
  return;
}
}
#line 363 "/root/patron/new_24/src/lib/openjp2/thread.c"
void opj_cond_signal(opj_cond_t *cond ) 
{ 
  int ret ;
  int __cil_tmp3 ;

  {
  {
#line 365
  __cil_tmp3 = pthread_cond_signal(& cond->cond);
#line 365
  ret = __cil_tmp3;
  }
#line 367
  return;
}
}
#line 370 "/root/patron/new_24/src/lib/openjp2/thread.c"
void opj_cond_destroy(opj_cond_t *cond ) 
{ 


  {
#line 372
  if (! cond) {
#line 373
    return;
  }
  {
#line 375
  pthread_cond_destroy(& cond->cond);
#line 376
  opj_free((void *)cond);
  }
#line 378
  return;
}
}
#line 386 "/root/patron/new_24/src/lib/openjp2/thread.c"
static void *opj_thread_callback_adapter(void *info ) 
{ 
  opj_thread_t *thread ;

  {
  {
#line 388
  thread = (opj_thread_t *)info;
#line 389
  (*(thread->thread_fn))(thread->user_data);
  }
#line 390
  return ((void *)0);
}
}
#line 393 "/root/patron/new_24/src/lib/openjp2/thread.c"
opj_thread_t *opj_thread_create(void (*thread_fn)(void * ) , void *user_data ) 
{ 
  pthread_attr_t attr ;
  opj_thread_t *thread ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 400
  __cil_tmp6 = opj_malloc(sizeof(opj_thread_t ));
#line 400
  thread = (opj_thread_t *)__cil_tmp6;
  }
#line 401
  if (! thread) {
#line 402
    return ((opj_thread_t *)((void *)0));
  }
  {
#line 404
  thread->thread_fn = thread_fn;
#line 405
  thread->user_data = user_data;
#line 407
  pthread_attr_init(& attr);
#line 408
  pthread_attr_setdetachstate(& attr, 0);
#line 409
  __cil_tmp7 = pthread_create(& thread->thread, & attr, & opj_thread_callback_adapter,
                              (void *)thread);
  }
#line 409
  if (__cil_tmp7 != 0) {
    {
#line 411
    opj_free((void *)thread);
    }
#line 412
    return ((opj_thread_t *)((void *)0));
  }
#line 414
  return (thread);
}
}
#line 417 "/root/patron/new_24/src/lib/openjp2/thread.c"
void opj_thread_join(opj_thread_t *thread ) 
{ 
  void *status ;

  {
  {
#line 420
  pthread_join(thread->thread, & status);
#line 422
  opj_free((void *)thread);
  }
#line 424
  return;
}
}
#line 504 "/root/patron/new_24/src/lib/openjp2/thread.c"
static opj_tls_t *opj_tls_new(void) 
{ 
  void *__cil_tmp1 ;

  {
  {
#line 506
  __cil_tmp1 = opj_calloc((size_t )1, sizeof(opj_tls_t ));
  }
#line 506
  return ((opj_tls_t *)__cil_tmp1);
}
}
#line 509 "/root/patron/new_24/src/lib/openjp2/thread.c"
static void opj_tls_destroy(opj_tls_t *tls ) 
{ 
  int i ;

  {
#line 512
  if (! tls) {
#line 513
    return;
  }
#line 515
  i = 0;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;

#line 515
    if (! (i < tls->key_val_count)) {
#line 515
      goto while_break;
    }
#line 516
    if ((tls->key_val + i)->opj_free_func) {
      {
#line 517
      (*((tls->key_val + i)->opj_free_func))((tls->key_val + i)->value);
      }
    }
#line 515
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 520
  opj_free((void *)tls->key_val);
#line 521
  opj_free((void *)tls);
  }
#line 523
  return;
}
}
#line 524 "/root/patron/new_24/src/lib/openjp2/thread.c"
void *opj_tls_get(opj_tls_t *tls , int key ) 
{ 
  int i ;

  {
#line 527
  i = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;

#line 527
    if (! (i < tls->key_val_count)) {
#line 527
      goto while_break;
    }
#line 528
    if ((tls->key_val + i)->key == key) {
#line 529
      return ((tls->key_val + i)->value);
    }
#line 527
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 532
  return ((void *)0);
}
}
#line 535 "/root/patron/new_24/src/lib/openjp2/thread.c"
OPJ_BOOL opj_tls_set(opj_tls_t *tls , int key , void *value , void (*opj_free_func)(void * ) ) 
{ 
  opj_tls_key_val_t *new_key_val ;
  int i ;
  void *__cil_tmp8 ;

  {
#line 541
  if (tls->key_val_count == 2147483647) {
#line 542
    return (0);
  }
#line 544
  i = 0;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;

#line 544
    if (! (i < tls->key_val_count)) {
#line 544
      goto while_break;
    }
#line 545
    if ((tls->key_val + i)->key == key) {
#line 546
      if ((tls->key_val + i)->opj_free_func) {
        {
#line 547
        (*((tls->key_val + i)->opj_free_func))((tls->key_val + i)->value);
        }
      }
#line 549
      (tls->key_val + i)->value = value;
#line 550
      (tls->key_val + i)->opj_free_func = opj_free_func;
#line 551
      return (1);
    }
#line 544
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 554
  __cil_tmp8 = opj_realloc((void *)tls->key_val, ((size_t )tls->key_val_count + 1UL) * sizeof(opj_tls_key_val_t ));
#line 554
  new_key_val = (opj_tls_key_val_t *)__cil_tmp8;
  }
#line 556
  if (! new_key_val) {
#line 557
    return (0);
  }
#line 559
  tls->key_val = new_key_val;
#line 560
  (new_key_val + tls->key_val_count)->key = key;
#line 561
  (new_key_val + tls->key_val_count)->value = value;
#line 562
  (new_key_val + tls->key_val_count)->opj_free_func = opj_free_func;
#line 563
  (tls->key_val_count) ++;
#line 564
  return (1);
}
}
#line 614
static OPJ_BOOL opj_thread_pool_setup(opj_thread_pool_t *tp , int num_threads ) ;
#line 615
static opj_worker_thread_job_t *opj_thread_pool_get_next_job(opj_thread_pool_t *tp ,
                                                             opj_worker_thread_t *worker_thread ,
                                                             OPJ_BOOL signal_job_finished ) ;
#line 620 "/root/patron/new_24/src/lib/openjp2/thread.c"
opj_thread_pool_t *opj_thread_pool_create(int num_threads ) 
{ 
  opj_thread_pool_t *tp ;
  void *__cil_tmp3 ;
  OPJ_BOOL __cil_tmp6 ;

  {
  {
#line 624
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_thread_pool_t ));
#line 624
  tp = (opj_thread_pool_t *)__cil_tmp3;
  }
#line 625
  if (! tp) {
#line 626
    return ((opj_thread_pool_t *)((void *)0));
  }
#line 628
  tp->state = (opj_worker_thread_state )0;
#line 630
  if (num_threads <= 0) {
    {
#line 631
    tp->tls = opj_tls_new();
    }
#line 632
    if (! tp->tls) {
      {
#line 633
      opj_free((void *)tp);
#line 634
      tp = (opj_thread_pool_t *)((void *)0);
      }
    }
#line 636
    return (tp);
  }
  {
#line 639
  tp->mutex = opj_mutex_create();
  }
#line 640
  if (! tp->mutex) {
    {
#line 641
    opj_free((void *)tp);
    }
#line 642
    return ((opj_thread_pool_t *)((void *)0));
  }
  {
#line 644
  __cil_tmp6 = opj_thread_pool_setup(tp, num_threads);
  }
#line 644
  if (! __cil_tmp6) {
    {
#line 645
    opj_thread_pool_destroy(tp);
    }
#line 646
    return ((opj_thread_pool_t *)((void *)0));
  }
#line 648
  return (tp);
}
}
#line 651 "/root/patron/new_24/src/lib/openjp2/thread.c"
static void opj_worker_thread_function(void *user_data ) 
{ 
  opj_worker_thread_t *worker_thread ;
  opj_thread_pool_t *tp ;
  opj_tls_t *tls ;
  OPJ_BOOL job_finished ;
  opj_worker_thread_job_t *job ;
  opj_worker_thread_job_t *__cil_tmp8 ;

  {
  {
#line 656
  job_finished = 0;
#line 658
  worker_thread = (opj_worker_thread_t *)user_data;
#line 659
  tp = worker_thread->tp;
#line 660
  tls = opj_tls_new();
  }
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 663
    __cil_tmp8 = opj_thread_pool_get_next_job(tp, worker_thread, job_finished);
#line 663
    job = __cil_tmp8;
    }
#line 665
    if ((unsigned long )job == (unsigned long )((void *)0)) {
#line 666
      goto while_break;
    }
#line 669
    if (job->job_fn) {
      {
#line 670
      (*(job->job_fn))(job->user_data, tls);
      }
    }
    {
#line 672
    opj_free((void *)job);
#line 673
    job_finished = 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 676
  opj_tls_destroy(tls);
  }
#line 678
  return;
}
}
#line 679 "/root/patron/new_24/src/lib/openjp2/thread.c"
static OPJ_BOOL opj_thread_pool_setup(opj_thread_pool_t *tp , int num_threads ) 
{ 
  int i ;
  OPJ_BOOL bRet ;
  void *__cil_tmp7 ;

  {
  {
#line 682
  bRet = 1;
#line 686
  tp->cond = opj_cond_create();
  }
#line 687
  if ((unsigned long )tp->cond == (unsigned long )((void *)0)) {
#line 688
    return (0);
  }
  {
#line 691
  __cil_tmp7 = opj_calloc((size_t )num_threads, sizeof(opj_worker_thread_t ));
#line 691
  tp->worker_threads = (opj_worker_thread_t *)__cil_tmp7;
  }
#line 693
  if ((unsigned long )tp->worker_threads == (unsigned long )((void *)0)) {
#line 694
    return (0);
  }
#line 696
  tp->worker_threads_count = num_threads;
#line 698
  i = 0;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;

#line 698
    if (! (i < num_threads)) {
#line 698
      goto while_break;
    }
    {
#line 699
    (tp->worker_threads + i)->tp = tp;
#line 701
    (tp->worker_threads + i)->mutex = opj_mutex_create();
    }
#line 702
    if ((unsigned long )(tp->worker_threads + i)->mutex == (unsigned long )((void *)0)) {
#line 703
      tp->worker_threads_count = i;
#line 704
      bRet = 0;
#line 705
      goto while_break;
    }
    {
#line 708
    (tp->worker_threads + i)->cond = opj_cond_create();
    }
#line 709
    if ((unsigned long )(tp->worker_threads + i)->cond == (unsigned long )((void *)0)) {
      {
#line 710
      opj_mutex_destroy((tp->worker_threads + i)->mutex);
#line 711
      tp->worker_threads_count = i;
#line 712
      bRet = 0;
      }
#line 713
      goto while_break;
    }
    {
#line 716
    (tp->worker_threads + i)->marked_as_waiting = 0;
#line 718
    (tp->worker_threads + i)->thread = opj_thread_create(& opj_worker_thread_function,
                                                         (void *)(tp->worker_threads + i));
    }
#line 720
    if ((unsigned long )(tp->worker_threads + i)->thread == (unsigned long )((void *)0)) {
#line 721
      tp->worker_threads_count = i;
#line 722
      bRet = 0;
#line 723
      goto while_break;
    }
#line 698
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 729
  opj_mutex_lock(tp->mutex);
  }
  {
#line 730
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 730
    if (! (tp->waiting_worker_thread_count < num_threads)) {
#line 730
      goto while_break___0;
    }
    {
#line 731
    opj_cond_wait(tp->cond, tp->mutex);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 733
  opj_mutex_unlock(tp->mutex);
  }
#line 736
  if ((unsigned int )tp->state == 2U) {
#line 737
    bRet = 0;
  }
#line 740
  return (bRet);
}
}
#line 750 "/root/patron/new_24/src/lib/openjp2/thread.c"
static opj_worker_thread_job_t *opj_thread_pool_get_next_job(opj_thread_pool_t *tp ,
                                                             opj_worker_thread_t *worker_thread ,
                                                             OPJ_BOOL signal_job_finished ) 
{ 
  opj_job_list_t *top_job_iter ;
  int __cil_tmp5 ;
  opj_worker_thread_job_t *job ;
  opj_worker_thread_list_t *item ;
  void *__cil_tmp10 ;

  {
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 758
    opj_mutex_lock(tp->mutex);
    }
#line 760
    if (signal_job_finished) {
#line 761
      signal_job_finished = 0;
#line 762
      __cil_tmp5 = tp->pending_jobs_count;
#line 762
      (tp->pending_jobs_count) --;
#line 764
      if (tp->pending_jobs_count <= tp->signaling_threshold) {
        {
#line 765
        opj_cond_signal(tp->cond);
        }
      }
    }
#line 769
    if ((unsigned int )tp->state == 1U) {
      {
#line 770
      opj_mutex_unlock(tp->mutex);
      }
#line 771
      return ((opj_worker_thread_job_t *)((void *)0));
    }
#line 773
    top_job_iter = tp->job_queue;
#line 774
    if (top_job_iter) {
      {
#line 776
      tp->job_queue = top_job_iter->next;
#line 778
      job = top_job_iter->job;
#line 779
      opj_mutex_unlock(tp->mutex);
#line 780
      opj_free((void *)top_job_iter);
      }
#line 781
      return (job);
    }
#line 785
    if (! worker_thread->marked_as_waiting) {
      {
#line 788
      worker_thread->marked_as_waiting = 1;
#line 789
      (tp->waiting_worker_thread_count) ++;
#line 792
      __cil_tmp10 = opj_malloc(sizeof(opj_worker_thread_list_t ));
#line 792
      item = (opj_worker_thread_list_t *)__cil_tmp10;
      }
#line 793
      if ((unsigned long )item == (unsigned long )((void *)0)) {
        {
#line 794
        tp->state = (opj_worker_thread_state )2;
#line 795
        opj_cond_signal(tp->cond);
#line 797
        opj_mutex_unlock(tp->mutex);
        }
#line 798
        return ((opj_worker_thread_job_t *)((void *)0));
      }
#line 801
      item->worker_thread = worker_thread;
#line 802
      item->next = tp->waiting_worker_thread_list;
#line 803
      tp->waiting_worker_thread_list = item;
    }
    {
#line 807
    opj_cond_signal(tp->cond);
#line 809
    opj_mutex_lock(worker_thread->mutex);
#line 810
    opj_mutex_unlock(tp->mutex);
#line 813
    opj_cond_wait(worker_thread->cond, worker_thread->mutex);
#line 815
    opj_mutex_unlock(worker_thread->mutex);
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 821
  return ((opj_worker_thread_job_t *)0);
}
}
#line 820 "/root/patron/new_24/src/lib/openjp2/thread.c"
OPJ_BOOL opj_thread_pool_submit_job(opj_thread_pool_t *tp , void (*job_fn)(void * ,
                                                                           opj_tls_t * ) ,
                                    void *user_data ) 
{ 
  opj_worker_thread_job_t *job ;
  opj_job_list_t *item ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_worker_thread_t *worker_thread ;
  opj_worker_thread_list_t *next ;
  opj_worker_thread_list_t *to_opj_free ;
  int __cil_tmp13 ;

  {
#line 827
  if ((unsigned long )tp->mutex == (unsigned long )((void *)0)) {
    {
#line 828
    (*job_fn)(user_data, tp->tls);
    }
#line 829
    return (1);
  }
  {
#line 832
  __cil_tmp6 = opj_malloc(sizeof(opj_worker_thread_job_t ));
#line 832
  job = (opj_worker_thread_job_t *)__cil_tmp6;
  }
#line 833
  if ((unsigned long )job == (unsigned long )((void *)0)) {
#line 834
    return (0);
  }
  {
#line 836
  job->job_fn = job_fn;
#line 837
  job->user_data = user_data;
#line 839
  __cil_tmp7 = opj_malloc(sizeof(opj_job_list_t ));
#line 839
  item = (opj_job_list_t *)__cil_tmp7;
  }
#line 840
  if ((unsigned long )item == (unsigned long )((void *)0)) {
    {
#line 841
    opj_free((void *)job);
    }
#line 842
    return (0);
  }
  {
#line 844
  item->job = job;
#line 846
  opj_mutex_lock(tp->mutex);
#line 848
  tp->signaling_threshold = 100 * tp->worker_threads_count;
  }
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;

#line 849
    if (! (tp->pending_jobs_count > tp->signaling_threshold)) {
#line 849
      goto while_break;
    }
    {
#line 851
    opj_cond_wait(tp->cond, tp->mutex);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 855
  item->next = tp->job_queue;
#line 856
  tp->job_queue = item;
#line 857
  (tp->pending_jobs_count) ++;
#line 859
  if (tp->waiting_worker_thread_list) {
    {
#line 864
    worker_thread = (tp->waiting_worker_thread_list)->worker_thread;
#line 867
    worker_thread->marked_as_waiting = 0;
#line 869
    next = (tp->waiting_worker_thread_list)->next;
#line 870
    to_opj_free = tp->waiting_worker_thread_list;
#line 871
    tp->waiting_worker_thread_list = next;
#line 872
    __cil_tmp13 = tp->waiting_worker_thread_count;
#line 872
    (tp->waiting_worker_thread_count) --;
#line 874
    opj_mutex_lock(worker_thread->mutex);
#line 875
    opj_mutex_unlock(tp->mutex);
#line 876
    opj_cond_signal(worker_thread->cond);
#line 877
    opj_mutex_unlock(worker_thread->mutex);
#line 879
    opj_free((void *)to_opj_free);
    }
  } else {
    {
#line 881
    opj_mutex_unlock(tp->mutex);
    }
  }
#line 884
  return (1);
}
}
#line 887 "/root/patron/new_24/src/lib/openjp2/thread.c"
void opj_thread_pool_wait_completion(opj_thread_pool_t *tp , int max_remaining_jobs ) 
{ 


  {
#line 890
  if ((unsigned long )tp->mutex == (unsigned long )((void *)0)) {
#line 891
    return;
  }
#line 894
  if (max_remaining_jobs < 0) {
#line 895
    max_remaining_jobs = 0;
  }
  {
#line 897
  opj_mutex_lock(tp->mutex);
#line 898
  tp->signaling_threshold = max_remaining_jobs;
  }
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;

#line 899
    if (! (tp->pending_jobs_count > max_remaining_jobs)) {
#line 899
      goto while_break;
    }
    {
#line 901
    opj_cond_wait(tp->cond, tp->mutex);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 904
  opj_mutex_unlock(tp->mutex);
  }
#line 906
  return;
}
}
#line 907 "/root/patron/new_24/src/lib/openjp2/thread.c"
int opj_thread_pool_get_thread_count(opj_thread_pool_t *tp ) 
{ 


  {
#line 909
  return (tp->worker_threads_count);
}
}
#line 912 "/root/patron/new_24/src/lib/openjp2/thread.c"
void opj_thread_pool_destroy(opj_thread_pool_t *tp ) 
{ 
  int i ;
  opj_worker_thread_list_t *next ;

  {
#line 914
  if (! tp) {
#line 915
    return;
  }
#line 917
  if (tp->cond) {
    {
#line 919
    opj_thread_pool_wait_completion(tp, 0);
#line 921
    opj_mutex_lock(tp->mutex);
#line 922
    tp->state = (opj_worker_thread_state )1;
#line 923
    opj_mutex_unlock(tp->mutex);
#line 925
    i = 0;
    }
    {
#line 925
    while (1) {
      while_continue: /* CIL Label */ ;

#line 925
      if (! (i < tp->worker_threads_count)) {
#line 925
        goto while_break;
      }
      {
#line 926
      opj_mutex_lock((tp->worker_threads + i)->mutex);
#line 927
      opj_cond_signal((tp->worker_threads + i)->cond);
#line 928
      opj_mutex_unlock((tp->worker_threads + i)->mutex);
#line 929
      opj_thread_join((tp->worker_threads + i)->thread);
#line 930
      opj_cond_destroy((tp->worker_threads + i)->cond);
#line 931
      opj_mutex_destroy((tp->worker_threads + i)->mutex);
#line 925
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 934
    opj_free((void *)tp->worker_threads);
    }
    {
#line 936
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 936
      if (! ((unsigned long )tp->waiting_worker_thread_list != (unsigned long )((void *)0))) {
#line 936
        goto while_break___0;
      }
      {
#line 937
      next = (tp->waiting_worker_thread_list)->next;
#line 938
      opj_free((void *)tp->waiting_worker_thread_list);
#line 939
      tp->waiting_worker_thread_list = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 942
    opj_cond_destroy(tp->cond);
    }
  }
  {
#line 944
  opj_mutex_destroy(tp->mutex);
#line 945
  opj_tls_destroy(tp->tls);
#line 946
  opj_free((void *)tp);
  }
#line 948
  return;
}
}
#line 48 "/root/patron/new_24/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_INT32 nplh[32] ;
  OPJ_INT32 nplv[32] ;
  opj_tgt_node_t *node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  opj_tgt_tree_t *tree ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 numlvls ;
  OPJ_UINT32 n ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  {
#line 53
  node = (opj_tgt_node_t *)0;
#line 54
  l_parent_node = (opj_tgt_node_t *)0;
#line 55
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 56
  tree = (opj_tgt_tree_t *)0;
#line 62
  __cil_tmp15 = opj_calloc((size_t )1, sizeof(opj_tgt_tree_t ));
#line 62
  tree = (opj_tgt_tree_t *)__cil_tmp15;
  }
#line 63
  if (! tree) {
    {
#line 64
    opj_event_msg(p_manager, 1, "Not enough memory to create Tag-tree\n");
    }
#line 65
    return ((opj_tgt_tree_t *)0);
  }
#line 68
  tree->numleafsh = numleafsh;
#line 69
  tree->numleafsv = numleafsv;
#line 71
  numlvls = (OPJ_UINT32 )0;
#line 72
  nplh[0] = (OPJ_INT32 )numleafsh;
#line 73
  nplv[0] = (OPJ_INT32 )numleafsv;
#line 74
  tree->numnodes = (OPJ_UINT32 )0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    n = (OPJ_UINT32 )(nplh[numlvls] * nplv[numlvls]);
#line 77
    nplh[numlvls + 1U] = (nplh[numlvls] + 1) / 2;
#line 78
    nplv[numlvls + 1U] = (nplv[numlvls] + 1) / 2;
#line 79
    tree->numnodes += n;
#line 80
    numlvls ++;
#line 75
    if (! (n > 1U)) {
#line 75
      goto while_break;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 84
  if (tree->numnodes == 0U) {
    {
#line 85
    opj_free((void *)tree);
    }
#line 86
    return ((opj_tgt_tree_t *)0);
  }
  {
#line 89
  __cil_tmp16 = opj_calloc((size_t )tree->numnodes, sizeof(opj_tgt_node_t ));
#line 89
  tree->nodes = (opj_tgt_node_t *)__cil_tmp16;
  }
#line 91
  if (! tree->nodes) {
    {
#line 92
    opj_event_msg(p_manager, 1, "Not enough memory to create Tag-tree nodes\n");
#line 94
    opj_free((void *)tree);
    }
#line 95
    return ((opj_tgt_tree_t *)0);
  }
#line 97
  tree->nodes_size = tree->numnodes * (OPJ_UINT32 )sizeof(opj_tgt_node_t );
#line 99
  node = tree->nodes;
#line 100
  l_parent_node = tree->nodes + tree->numleafsh * tree->numleafsv;
#line 101
  l_parent_node0 = l_parent_node;
#line 103
  i = (OPJ_UINT32 )0;
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 103
    if (! (i < numlvls - 1U)) {
#line 103
      goto while_break___0;
    }
#line 104
    j = 0;
    {
#line 104
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 104
      if (! (j < nplv[i])) {
#line 104
        goto while_break___1;
      }
#line 105
      k = nplh[i];
      {
#line 106
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 106
        k --;
#line 106
        if (! (k >= 0)) {
#line 106
          goto while_break___2;
        }
#line 107
        node->parent = l_parent_node;
#line 108
        node ++;
#line 109
        k --;
#line 109
        if (k >= 0) {
#line 110
          node->parent = l_parent_node;
#line 111
          node ++;
        }
#line 113
        l_parent_node ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: ;
#line 115
      if (j & 1) {
#line 116
        l_parent_node0 = l_parent_node;
      } else
#line 115
      if (j == nplv[i] - 1) {
#line 116
        l_parent_node0 = l_parent_node;
      } else {
#line 118
        l_parent_node = l_parent_node0;
#line 119
        l_parent_node0 += nplh[i];
      }
#line 104
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 103
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 123
  node->parent = (struct opj_tgt_node *)0;
#line 124
  opj_tgt_reset(tree);
  }
#line 125
  return (tree);
}
}
#line 136 "/root/patron/new_24/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_INT32 l_nplh[32] ;
  OPJ_INT32 l_nplv[32] ;
  opj_tgt_node_t *l_node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 l_num_levels ;
  OPJ_UINT32 n ;
  OPJ_UINT32 l_node_size ;
  opj_tgt_node_t *new_nodes ;
  void *__cil_tmp17 ;

  {
#line 141
  l_node = (opj_tgt_node_t *)0;
#line 142
  l_parent_node = (opj_tgt_node_t *)0;
#line 143
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 150
  if (! p_tree) {
#line 151
    return ((opj_tgt_tree_t *)0);
  }
#line 154
  if (p_tree->numleafsh != p_num_leafs_h) {
    _L: 
#line 156
    p_tree->numleafsh = p_num_leafs_h;
#line 157
    p_tree->numleafsv = p_num_leafs_v;
#line 159
    l_num_levels = (OPJ_UINT32 )0;
#line 160
    l_nplh[0] = (OPJ_INT32 )p_num_leafs_h;
#line 161
    l_nplv[0] = (OPJ_INT32 )p_num_leafs_v;
#line 162
    p_tree->numnodes = (OPJ_UINT32 )0;
    {
#line 163
    while (1) {
      while_continue: /* CIL Label */ ;
#line 164
      n = (OPJ_UINT32 )(l_nplh[l_num_levels] * l_nplv[l_num_levels]);
#line 165
      l_nplh[l_num_levels + 1U] = (l_nplh[l_num_levels] + 1) / 2;
#line 166
      l_nplv[l_num_levels + 1U] = (l_nplv[l_num_levels] + 1) / 2;
#line 167
      p_tree->numnodes += n;
#line 168
      l_num_levels ++;
#line 163
      if (! (n > 1U)) {
#line 163
        goto while_break;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
#line 172
    if (p_tree->numnodes == 0U) {
      {
#line 173
      opj_tgt_destroy(p_tree);
      }
#line 174
      return ((opj_tgt_tree_t *)0);
    }
#line 176
    l_node_size = p_tree->numnodes * (OPJ_UINT32 )sizeof(opj_tgt_node_t );
#line 178
    if (l_node_size > p_tree->nodes_size) {
      {
#line 179
      __cil_tmp17 = opj_realloc((void *)p_tree->nodes, (size_t )l_node_size);
#line 179
      new_nodes = (opj_tgt_node_t *)__cil_tmp17;
      }
#line 181
      if (! new_nodes) {
        {
#line 182
        opj_event_msg(p_manager, 1, "Not enough memory to reinitialize the tag tree\n");
#line 184
        opj_tgt_destroy(p_tree);
        }
#line 185
        return ((opj_tgt_tree_t *)0);
      }
      {
#line 187
      p_tree->nodes = new_nodes;
#line 188
      memset((void *)((char *)p_tree->nodes + p_tree->nodes_size), 0, (unsigned long )(l_node_size - p_tree->nodes_size));
#line 190
      p_tree->nodes_size = l_node_size;
      }
    }
#line 192
    l_node = p_tree->nodes;
#line 193
    l_parent_node = p_tree->nodes + p_tree->numleafsh * p_tree->numleafsv;
#line 194
    l_parent_node0 = l_parent_node;
#line 196
    i = (OPJ_UINT32 )0;
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 196
      if (! (i < l_num_levels - 1U)) {
#line 196
        goto while_break___0;
      }
#line 197
      j = 0;
      {
#line 197
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 197
        if (! (j < l_nplv[i])) {
#line 197
          goto while_break___1;
        }
#line 198
        k = l_nplh[i];
        {
#line 199
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 199
          k --;
#line 199
          if (! (k >= 0)) {
#line 199
            goto while_break___2;
          }
#line 200
          l_node->parent = l_parent_node;
#line 201
          l_node ++;
#line 202
          k --;
#line 202
          if (k >= 0) {
#line 203
            l_node->parent = l_parent_node;
#line 204
            l_node ++;
          }
#line 206
          l_parent_node ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: ;
#line 208
        if (j & 1) {
#line 209
          l_parent_node0 = l_parent_node;
        } else
#line 208
        if (j == l_nplv[i] - 1) {
#line 209
          l_parent_node0 = l_parent_node;
        } else {
#line 211
          l_parent_node = l_parent_node0;
#line 212
          l_parent_node0 += l_nplh[i];
        }
#line 197
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 196
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 216
    l_node->parent = (struct opj_tgt_node *)0;
  } else
#line 154
  if (p_tree->numleafsv != p_num_leafs_v) {
#line 154
    goto _L;
  }
  {
#line 218
  opj_tgt_reset(p_tree);
  }
#line 220
  return (p_tree);
}
}
#line 223 "/root/patron/new_24/src/lib/openjp2/tgt.c"
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) 
{ 


  {
#line 225
  if (! p_tree) {
#line 226
    return;
  }
#line 229
  if (p_tree->nodes) {
    {
#line 230
    opj_free((void *)p_tree->nodes);
#line 231
    p_tree->nodes = (opj_tgt_node_t *)0;
    }
  }
  {
#line 233
  opj_free((void *)p_tree);
  }
#line 235
  return;
}
}
#line 236 "/root/patron/new_24/src/lib/openjp2/tgt.c"
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) 
{ 
  OPJ_UINT32 i ;
  opj_tgt_node_t *l_current_node ;

  {
#line 239
  l_current_node = (opj_tgt_node_t *)0;
#line 241
  if (! p_tree) {
#line 242
    return;
  }
#line 245
  l_current_node = p_tree->nodes;
#line 246
  i = (OPJ_UINT32 )0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;

#line 246
    if (! (i < p_tree->numnodes)) {
#line 246
      goto while_break;
    }
#line 247
    l_current_node->value = 999;
#line 248
    l_current_node->low = 0;
#line 249
    l_current_node->known = (OPJ_UINT32 )0;
#line 250
    l_current_node ++;
#line 246
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 250
  return;
}
}
#line 254 "/root/patron/new_24/src/lib/openjp2/tgt.c"
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) 
{ 
  opj_tgt_node_t *node ;

  {
#line 257
  node = tree->nodes + leafno;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;

#line 258
    if (node) {
#line 258
      if (! (node->value > value)) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 259
    node->value = value;
#line 260
    node = node->parent;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 264
  return;
}
}
#line 264 "/root/patron/new_24/src/lib/openjp2/tgt.c"
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;

  {
#line 272
  stkptr = stk;
#line 273
  node = tree->nodes + leafno;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;

#line 274
    if (! node->parent) {
#line 274
      goto while_break;
    }
#line 275
    __cil_tmp9 = stkptr;
#line 275
    stkptr ++;
#line 275
    *__cil_tmp9 = node;
#line 276
    node = node->parent;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 279
  low = 0;
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 281
    if (low > node->low) {
#line 282
      node->low = low;
    } else {
#line 284
      low = node->low;
    }
    {
#line 287
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 287
      if (! (low < threshold)) {
#line 287
        goto while_break___1;
      }
#line 288
      if (low >= node->value) {
#line 289
        if (! node->known) {
          {
#line 290
          opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 291
          node->known = (OPJ_UINT32 )1;
          }
        }
#line 293
        goto while_break___1;
      }
      {
#line 295
      opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 296
      low ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 299
    node->low = low;
#line 300
    if ((unsigned long )stkptr == (unsigned long )(stk)) {
#line 301
      goto while_break___0;
    }
#line 303
    stkptr --;
#line 303
    node = *stkptr;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 307
  return;
}
}
#line 307 "/root/patron/new_24/src/lib/openjp2/tgt.c"
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;
  int tmp ;

  {
#line 315
  stkptr = stk;
#line 316
  node = tree->nodes + leafno;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;

#line 317
    if (! node->parent) {
#line 317
      goto while_break;
    }
#line 318
    __cil_tmp9 = stkptr;
#line 318
    stkptr ++;
#line 318
    *__cil_tmp9 = node;
#line 319
    node = node->parent;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 322
  low = 0;
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 324
    if (low > node->low) {
#line 325
      node->low = low;
    } else {
#line 327
      low = node->low;
    }
    {
#line 329
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 329
      if (low < threshold) {
#line 329
        if (! (low < node->value)) {
#line 329
          goto while_break___1;
        }
      } else {
#line 329
        goto while_break___1;
      }
      {
#line 330
      __cil_tmp10 = opj_bio_read(bio, (OPJ_UINT32 )1);
      }
#line 330
      if (__cil_tmp10) {
#line 331
        node->value = low;
      } else {
#line 333
        low ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 336
    node->low = low;
#line 337
    if ((unsigned long )stkptr == (unsigned long )(stk)) {
#line 338
      goto while_break___0;
    }
#line 340
    stkptr --;
#line 340
    node = *stkptr;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 343
  if (node->value < threshold) {
#line 343
    tmp = 1;
  } else {
#line 343
    tmp = 0;
  }
#line 343
  return ((OPJ_UINT32 )tmp);
}
}
#line 114 "/root/patron/new_24/src/lib/openjp2/tcd.c"
__inline static OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ,
                                           OPJ_BOOL isEncoder , OPJ_FLOAT32 fraction ,
                                           OPJ_SIZE_T sizeof_block , opj_event_mgr_t *manager ) ;
#line 121
static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) ;
#line 127
static void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 132
static OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) ;
#line 138
static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *p_code_block ) ;
#line 144
static void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 151
static void opj_tcd_free_tile(opj_tcd_t *p_tcd ) ;
#line 154
static OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                  OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ,
                                  opj_event_mgr_t *p_manager ) ;
#line 161
static OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) ;
#line 164
static OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) ;
#line 166
static OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) ;
#line 169
static OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) ;
#line 172
static OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) ;
#line 174
static OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) ;
#line 176
static OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) ;
#line 178
static OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) ;
#line 180
static OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                                  OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                  opj_event_mgr_t *p_manager ) ;
#line 187
static OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data ,
                                             OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                             opj_event_mgr_t *p_manager ) ;
#line 194
static OPJ_BOOL opj_tcd_is_whole_tilecomp_decoding(opj_tcd_t *p_tcd , OPJ_UINT32 compno ) ;
#line 202 "/root/patron/new_24/src/lib/openjp2/tcd.c"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_tcd_t *l_tcd ;
  void *__cil_tmp3 ;
  int tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 204
  l_tcd = (opj_tcd_t *)0;
#line 207
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_tcd_t ));
#line 207
  l_tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 208
  if (! l_tcd) {
#line 209
    return ((opj_tcd_t *)0);
  }
#line 212
  if (p_is_decoder) {
#line 212
    tmp = 1;
  } else {
#line 212
    tmp = 0;
  }
  {
#line 212
  l_tcd->m_is_decoder = (OPJ_BITFIELD )tmp;
#line 214
  __cil_tmp5 = opj_calloc((size_t )1, sizeof(opj_tcd_image_t ));
#line 214
  l_tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp5;
  }
#line 215
  if (! l_tcd->tcd_image) {
    {
#line 216
    opj_free((void *)l_tcd);
    }
#line 217
    return ((opj_tcd_t *)0);
  }
#line 220
  return (l_tcd);
}
}
#line 226 "/root/patron/new_24/src/lib/openjp2/tcd.c"
void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  OPJ_UINT32 layno ;

  {
#line 230
  layno = (OPJ_UINT32 )0;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;

#line 230
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 230
      goto while_break;
    }
    {
#line 231
    opj_tcd_makelayer_fixed(tcd, layno, (OPJ_UINT32 )1);
#line 230
    layno ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 234
  return;
}
}
#line 236 "/root/patron/new_24/src/lib/openjp2/tcd.c"
void opj_tcd_makelayer(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_FLOAT64 thresh , OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 passno ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_BOOL __cil_tmp15 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_UINT32 dr ;
  OPJ_FLOAT64 dd ;
  opj_tcd_pass_t *pass ;

  {
#line 244
  tcd_tile = (tcd->tcd_image)->tiles;
#line 246
  tcd_tile->distolayer[layno] = (OPJ_FLOAT64 )0;
#line 248
  compno = (OPJ_UINT32 )0;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;

#line 248
    if (! (compno < tcd_tile->numcomps)) {
#line 248
      goto while_break;
    }
#line 249
    tilec = tcd_tile->comps + compno;
#line 251
    resno = (OPJ_UINT32 )0;
    {
#line 251
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 251
      if (! (resno < tilec->numresolutions)) {
#line 251
        goto while_break___0;
      }
#line 252
      res = tilec->resolutions + resno;
#line 254
      bandno = (OPJ_UINT32 )0;
      {
#line 254
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: ;
#line 254
        if (! (bandno < res->numbands)) {
#line 254
          goto while_break___1;
        }
        {
#line 255
        band = & res->bands[bandno];
#line 258
        __cil_tmp15 = opj_tcd_is_band_empty(band);
        }
#line 258
        if (__cil_tmp15) {
#line 259
          goto while_continue___1;
        }
#line 262
        precno = (OPJ_UINT32 )0;
        {
#line 262
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 262
          if (! (precno < res->pw * res->ph)) {
#line 262
            goto while_break___2;
          }
#line 263
          prc = band->precincts + precno;
#line 265
          cblkno = (OPJ_UINT32 )0;
          {
#line 265
          while (1) {
            while_continue___8: /* CIL Label */ ;
            while_continue___3: ;
#line 265
            if (! (cblkno < prc->cw * prc->ch)) {
#line 265
              goto while_break___3;
            }
#line 266
            cblk = prc->cblks.enc + cblkno;
#line 267
            layer = cblk->layers + layno;
#line 270
            if (layno == 0U) {
#line 271
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 274
            n = cblk->numpassesinlayers;
#line 276
            if (thresh < (double )0) {
#line 278
              n = cblk->totalpasses;
            } else {
#line 280
              passno = cblk->numpassesinlayers;
              {
#line 280
              while (1) {
                while_continue___9: /* CIL Label */ ;
                while_continue___4: ;
#line 280
                if (! (passno < cblk->totalpasses)) {
#line 280
                  goto while_break___4;
                }
#line 283
                pass = cblk->passes + passno;
#line 285
                if (n == 0U) {
#line 286
                  dr = pass->rate;
#line 287
                  dd = pass->distortiondec;
                } else {
#line 289
                  dr = pass->rate - (cblk->passes + (n - 1U))->rate;
#line 290
                  dd = pass->distortiondec - (cblk->passes + (n - 1U))->distortiondec;
                }
#line 293
                if (! dr) {
#line 294
                  if (dd != (double )0) {
#line 295
                    n = passno + 1U;
                  }
#line 297
                  goto while_continue___4;
                }
#line 299
                if (thresh - dd / (double )dr < (double )2.22044604926e-16L) {
#line 301
                  n = passno + 1U;
                }
#line 280
                passno ++;
              }
              while_break___10: /* CIL Label */ ;
              }
              while_break___4: ;
            }
#line 306
            layer->numpasses = n - cblk->numpassesinlayers;
#line 308
            if (! layer->numpasses) {
#line 309
              layer->disto = (OPJ_FLOAT64 )0;
#line 310
              goto while_continue___3;
            }
#line 313
            if (cblk->numpassesinlayers == 0U) {
#line 314
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 315
              layer->data = cblk->data;
#line 316
              layer->disto = (cblk->passes + (n - 1U))->distortiondec;
            } else {
#line 318
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 320
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 321
              layer->disto = (cblk->passes + (n - 1U))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1U))->distortiondec;
            }
#line 325
            tcd_tile->distolayer[layno] += layer->disto;
#line 327
            if (final) {
#line 328
              cblk->numpassesinlayers = n;
            }
#line 265
            cblkno ++;
          }
          while_break___9: /* CIL Label */ ;
          }
          while_break___3: 
#line 262
          precno ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: 
#line 254
        bandno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
#line 251
      resno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: 
#line 248
    compno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 252
  return;
}
}
#line 337 "/root/patron/new_24/src/lib/openjp2/tcd.c"
void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_INT32 value ;
  OPJ_INT32 matrice[10][10][3] ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_BOOL __cil_tmp23 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_INT32 imsb ;

  {
#line 345
  cp = tcd->cp;
#line 346
  tcd_tile = (tcd->tcd_image)->tiles;
#line 347
  tcd_tcp = tcd->tcp;
#line 349
  compno = (OPJ_UINT32 )0;
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;

#line 349
    if (! (compno < tcd_tile->numcomps)) {
#line 349
      goto while_break;
    }
#line 350
    tilec = tcd_tile->comps + compno;
#line 352
    i = (OPJ_UINT32 )0;
    {
#line 352
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 352
      if (! (i < tcd_tcp->numlayers)) {
#line 352
        goto while_break___0;
      }
#line 353
      j = (OPJ_UINT32 )0;
      {
#line 353
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 353
        if (! (j < tilec->numresolutions)) {
#line 353
          goto while_break___1;
        }
#line 354
        k = (OPJ_UINT32 )0;
        {
#line 354
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 354
          if (! (k < 3U)) {
#line 354
            goto while_break___2;
          }
#line 355
          matrice[i][j][k] = (OPJ_INT32 )((OPJ_FLOAT32 )*(cp->m_specific_param.m_enc.m_matrice + (((i * tilec->numresolutions) * 3U + j * 3U) + k)) * (OPJ_FLOAT32 )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 354
          k ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 353
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 352
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 363
    resno = (OPJ_UINT32 )0;
    {
#line 363
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 363
      if (! (resno < tilec->numresolutions)) {
#line 363
        goto while_break___3;
      }
#line 364
      res = tilec->resolutions + resno;
#line 366
      bandno = (OPJ_UINT32 )0;
      {
#line 366
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___4: ;
#line 366
        if (! (bandno < res->numbands)) {
#line 366
          goto while_break___4;
        }
        {
#line 367
        band = & res->bands[bandno];
#line 370
        __cil_tmp23 = opj_tcd_is_band_empty(band);
        }
#line 370
        if (__cil_tmp23) {
#line 371
          goto while_continue___4;
        }
#line 374
        precno = (OPJ_UINT32 )0;
        {
#line 374
        while (1) {
          while_continue___12: /* CIL Label */ ;

#line 374
          if (! (precno < res->pw * res->ph)) {
#line 374
            goto while_break___5;
          }
#line 375
          prc = band->precincts + precno;
#line 377
          cblkno = (OPJ_UINT32 )0;
          {
#line 377
          while (1) {
            while_continue___13: /* CIL Label */ ;
            while_continue___6: ;
#line 377
            if (! (cblkno < prc->cw * prc->ch)) {
#line 377
              goto while_break___6;
            }
#line 378
            cblk = prc->cblks.enc + cblkno;
#line 379
            layer = cblk->layers + layno;
#line 381
            imsb = (OPJ_INT32 )(((tcd->image)->comps + compno)->prec - cblk->numbps);
#line 385
            if (layno == 0U) {
#line 386
              value = matrice[layno][resno][bandno];
#line 387
              if (imsb >= value) {
#line 388
                value = 0;
              } else {
#line 390
                value -= imsb;
              }
            } else {
#line 393
              value = matrice[layno][resno][bandno] - matrice[layno - 1U][resno][bandno];
#line 394
              if (imsb >= matrice[layno - 1U][resno][bandno]) {
#line 395
                value -= imsb - matrice[layno - 1U][resno][bandno];
#line 396
                if (value < 0) {
#line 397
                  value = 0;
                }
              }
            }
#line 402
            if (layno == 0U) {
#line 403
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 406
            n = cblk->numpassesinlayers;
#line 407
            if (cblk->numpassesinlayers == 0U) {
#line 408
              if (value != 0) {
#line 409
                n = (3U * (OPJ_UINT32 )value - 2U) + cblk->numpassesinlayers;
              } else {
#line 411
                n = cblk->numpassesinlayers;
              }
            } else {
#line 414
              n = 3U * (OPJ_UINT32 )value + cblk->numpassesinlayers;
            }
#line 417
            layer->numpasses = n - cblk->numpassesinlayers;
#line 419
            if (! layer->numpasses) {
#line 420
              goto while_continue___6;
            }
#line 423
            if (cblk->numpassesinlayers == 0U) {
#line 424
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 425
              layer->data = cblk->data;
            } else {
#line 427
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 429
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
            }
#line 432
            if (final) {
#line 433
              cblk->numpassesinlayers = n;
            }
#line 377
            cblkno ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___6: 
#line 374
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: 
#line 366
        bandno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: 
#line 363
      resno ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: 
#line 349
    compno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 353
  return;
}
}
#line 442 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 len , opj_codestream_info_t *cstr_info ,
                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 passno ;
  OPJ_FLOAT64 min ;
  OPJ_FLOAT64 max ;
  OPJ_FLOAT64 cumdisto[100] ;
  OPJ_FLOAT64 K ;
  OPJ_FLOAT64 maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_BOOL __cil_tmp25 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  OPJ_INT32 dr ;
  OPJ_FLOAT64 dd ;
  OPJ_FLOAT64 rdslope ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp39 ;
  OPJ_FLOAT64 lo ;
  OPJ_FLOAT64 hi ;
  OPJ_UINT32 maxlen ;
  double __cil_tmp43 ;
  OPJ_UINT32 __cil_tmp44 ;
  OPJ_UINT32 tmp ;
  OPJ_FLOAT64 goodthresh ;
  OPJ_FLOAT64 stable_thresh ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 distotarget ;
  double __cil_tmp50 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp52 ;
  OPJ_FLOAT64 thresh ;
  OPJ_FLOAT64 distoachieved ;
  OPJ_BOOL __cil_tmp55 ;
  OPJ_FLOAT64 tmp___0 ;
  OPJ_FLOAT64 tmp___1 ;
  OPJ_BOOL __cil_tmp58 ;
  OPJ_FLOAT64 tmp___2 ;
  OPJ_FLOAT64 tmp___3 ;

  {
#line 453
  K = (OPJ_FLOAT64 )1;
#line 454
  maxSE = (OPJ_FLOAT64 )0;
#line 456
  cp = tcd->cp;
#line 457
  tcd_tile = (tcd->tcd_image)->tiles;
#line 458
  tcd_tcp = tcd->tcp;
#line 460
  min = (double )1.79769313487e+308L;
#line 461
  max = (OPJ_FLOAT64 )0;
#line 463
  tcd_tile->numpix = 0;
#line 465
  compno = (OPJ_UINT32 )0;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;

#line 465
    if (! (compno < tcd_tile->numcomps)) {
#line 465
      goto while_break;
    }
#line 466
    tilec = tcd_tile->comps + compno;
#line 467
    tilec->numpix = 0;
#line 469
    resno = (OPJ_UINT32 )0;
    {
#line 469
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 469
      if (! (resno < tilec->numresolutions)) {
#line 469
        goto while_break___0;
      }
#line 470
      res = tilec->resolutions + resno;
#line 472
      bandno = (OPJ_UINT32 )0;
      {
#line 472
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___1: ;
#line 472
        if (! (bandno < res->numbands)) {
#line 472
          goto while_break___1;
        }
        {
#line 473
        band = & res->bands[bandno];
#line 476
        __cil_tmp25 = opj_tcd_is_band_empty(band);
        }
#line 476
        if (__cil_tmp25) {
#line 477
          goto while_continue___1;
        }
#line 480
        precno = (OPJ_UINT32 )0;
        {
#line 480
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 480
          if (! (precno < res->pw * res->ph)) {
#line 480
            goto while_break___2;
          }
#line 481
          prc = band->precincts + precno;
#line 483
          cblkno = (OPJ_UINT32 )0;
          {
#line 483
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 483
            if (! (cblkno < prc->cw * prc->ch)) {
#line 483
              goto while_break___3;
            }
#line 484
            cblk = prc->cblks.enc + cblkno;
#line 486
            passno = (OPJ_UINT32 )0;
            {
#line 486
            while (1) {
              while_continue___11: /* CIL Label */ ;
              while_continue___4: ;
#line 486
              if (! (passno < cblk->totalpasses)) {
#line 486
                goto while_break___4;
              }
#line 487
              pass = cblk->passes + passno;
#line 491
              if (passno == 0U) {
#line 492
                dr = (OPJ_INT32 )pass->rate;
#line 493
                dd = pass->distortiondec;
              } else {
#line 495
                dr = (OPJ_INT32 )(pass->rate - (cblk->passes + (passno - 1U))->rate);
#line 496
                dd = pass->distortiondec - (cblk->passes + (passno - 1U))->distortiondec;
              }
#line 499
              if (dr == 0) {
#line 500
                goto while_continue___4;
              }
#line 503
              rdslope = dd / (double )dr;
#line 504
              if (rdslope < min) {
#line 505
                min = rdslope;
              }
#line 508
              if (rdslope > max) {
#line 509
                max = rdslope;
              }
#line 486
              passno ++;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: 
#line 514
            tcd_tile->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 515
            tilec->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 483
            cblkno ++;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: 
#line 480
          precno ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 472
        bandno ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 469
      resno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 521
    maxSE += (((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (OPJ_FLOAT64 )tilec->numpix;
#line 465
    compno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 527
  if (cstr_info) {
    {
#line 528
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 529
    tile_info->numpix = tcd_tile->numpix;
#line 530
    tile_info->distotile = tcd_tile->distotile;
#line 531
    __cil_tmp39 = opj_malloc((unsigned long )tcd_tcp->numlayers * sizeof(OPJ_FLOAT64 ));
#line 531
    tile_info->thresh = (OPJ_FLOAT64 *)__cil_tmp39;
    }
#line 533
    if (! tile_info->thresh) {
#line 535
      return (0);
    }
  }
#line 539
  layno = (OPJ_UINT32 )0;
  {
#line 539
  while (1) {
    while_continue___12: /* CIL Label */ ;

#line 539
    if (! (layno < tcd_tcp->numlayers)) {
#line 539
      goto while_break___5;
    }
#line 540
    lo = min;
#line 541
    hi = max;
#line 542
    if (tcd_tcp->rates[layno] > 0.f) {
      {
#line 542
      __cil_tmp43 = ceil((double )tcd_tcp->rates[layno]);
#line 542
      __cil_tmp44 = opj_uint_min((OPJ_UINT32 )__cil_tmp43, len);
#line 542
      tmp = __cil_tmp44;
      }
    } else {
#line 542
      tmp = len;
    }
    {
#line 542
    maxlen = tmp;
#line 544
    goodthresh = (OPJ_FLOAT64 )0;
#line 545
    stable_thresh = (OPJ_FLOAT64 )0;
#line 550
    __cil_tmp50 = pow((double )((OPJ_FLOAT32 )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 550
    distotarget = tcd_tile->distotile - (K * maxSE) / __cil_tmp50;
    }
#line 557
    if ((int )cp->m_specific_param.m_enc.m_disto_alloc == 1) {
#line 557
      if (tcd_tcp->rates[layno] > 0.f) {
        _L___0: 
        {
#line 561
        __cil_tmp52 = opj_t2_create(tcd->image, cp);
#line 561
        t2 = __cil_tmp52;
#line 562
        thresh = (OPJ_FLOAT64 )0;
        }
#line 564
        if ((unsigned long )t2 == (unsigned long )((opj_t2_t *)0)) {
#line 565
          return (0);
        }
#line 568
        i = (OPJ_UINT32 )0;
        {
#line 568
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___6: ;
#line 568
          if (! (i < 128U)) {
#line 568
            goto while_break___6;
          }
          {
#line 569
          distoachieved = (OPJ_FLOAT64 )0;
#line 571
          thresh = (lo + hi) / (double )2;
#line 573
          opj_tcd_makelayer(tcd, layno, thresh, (OPJ_UINT32 )0);
          }
#line 575
          if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 576
            if ((int )cp->rsiz >= 3) {
#line 576
              if ((int )cp->rsiz <= 6) {
                {
#line 577
                __cil_tmp55 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile,
                                                    layno + 1U, dest, p_data_written,
                                                    maxlen, cstr_info, tcd->cur_tp_num,
                                                    tcd->tp_pos, tcd->cur_pino, (J2K_T2_MODE )0,
                                                    p_manager);
                }
#line 577
                if (! __cil_tmp55) {
#line 581
                  lo = thresh;
#line 582
                  goto while_continue___6;
                } else {
#line 584
                  if (layno == 0U) {
#line 584
                    tmp___0 = tcd_tile->distolayer[0];
                  } else {
#line 584
                    tmp___0 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
                  }
#line 584
                  distoachieved = tmp___0;
#line 587
                  if (distoachieved < distotarget) {
#line 588
                    hi = thresh;
#line 589
                    stable_thresh = thresh;
#line 590
                    goto while_continue___6;
                  } else {
#line 592
                    lo = thresh;
                  }
                }
              } else {
#line 576
                goto _L;
              }
            } else {
              _L: 
#line 596
              if (layno == 0U) {
#line 596
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 596
                tmp___1 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
              }
#line 596
              distoachieved = tmp___1;
#line 599
              if (distoachieved < distotarget) {
#line 600
                hi = thresh;
#line 601
                stable_thresh = thresh;
#line 602
                goto while_continue___6;
              }
#line 604
              lo = thresh;
            }
          } else {
            {
#line 607
            __cil_tmp58 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1U,
                                                dest, p_data_written, maxlen, cstr_info,
                                                tcd->cur_tp_num, tcd->tp_pos, tcd->cur_pino,
                                                (J2K_T2_MODE )0, p_manager);
            }
#line 607
            if (! __cil_tmp58) {
#line 612
              lo = thresh;
#line 613
              goto while_continue___6;
            }
#line 616
            hi = thresh;
#line 617
            stable_thresh = thresh;
          }
#line 568
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: ;
#line 621
        if (stable_thresh == (double )0) {
#line 621
          tmp___2 = thresh;
        } else {
#line 621
          tmp___2 = stable_thresh;
        }
        {
#line 621
        goodthresh = tmp___2;
#line 623
        opj_t2_destroy(t2);
        }
      } else {
#line 557
        goto _L___1;
      }
    } else
    _L___1: 
#line 557
    if ((int )cp->m_specific_param.m_enc.m_fixed_quality == 1) {
#line 557
      if ((double )tcd_tcp->distoratio[layno] > 0.) {
#line 557
        goto _L___0;
      } else {
#line 626
        goodthresh = (OPJ_FLOAT64 )-1;
      }
    } else {
#line 626
      goodthresh = (OPJ_FLOAT64 )-1;
    }
#line 629
    if (cstr_info) {
#line 630
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 633
    opj_tcd_makelayer(tcd, layno, goodthresh, (OPJ_UINT32 )1);
    }
#line 636
    if (layno == 0U) {
#line 636
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 636
      tmp___3 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
    }
#line 636
    cumdisto[layno] = tmp___3;
#line 539
    layno ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: ;
#line 640
  return (1);
}
}
#line 643 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp , opj_thread_pool_t *p_tp ) 
{ 
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 648
  p_tcd->image = p_image;
#line 649
  p_tcd->cp = p_cp;
#line 651
  __cil_tmp5 = opj_calloc((size_t )1, sizeof(opj_tcd_tile_t ));
#line 651
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp5;
  }
#line 653
  if (! (p_tcd->tcd_image)->tiles) {
#line 654
    return (0);
  }
  {
#line 657
  __cil_tmp6 = opj_calloc((size_t )p_image->numcomps, sizeof(opj_tcd_tilecomp_t ));
#line 657
  ((p_tcd->tcd_image)->tiles)->comps = (opj_tcd_tilecomp_t *)__cil_tmp6;
  }
#line 659
  if (! ((p_tcd->tcd_image)->tiles)->comps) {
#line 660
    return (0);
  }
#line 663
  ((p_tcd->tcd_image)->tiles)->numcomps = p_image->numcomps;
#line 664
  p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;
#line 665
  p_tcd->thread_pool = p_tp;
#line 667
  return (1);
}
}
#line 673 "/root/patron/new_24/src/lib/openjp2/tcd.c"
void opj_tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 675
  if (tcd) {
    {
#line 676
    opj_tcd_free_tile(tcd);
    }
#line 678
    if (tcd->tcd_image) {
      {
#line 679
      opj_free((void *)tcd->tcd_image);
#line 680
      tcd->tcd_image = (opj_tcd_image_t *)0;
      }
    }
    {
#line 682
    opj_free((void *)tcd);
    }
  }
#line 685
  return;
}
}
#line 686 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
#line 688
  if ((unsigned long )l_tilec->data == (unsigned long )((OPJ_INT32 *)0)) {
    _L: 
    {
#line 691
    __cil_tmp2 = opj_image_data_alloc(l_tilec->data_size_needed);
#line 691
    l_tilec->data = (OPJ_INT32 *)__cil_tmp2;
    }
#line 692
    if (! l_tilec->data) {
#line 692
      if (l_tilec->data_size_needed != 0UL) {
#line 693
        return (0);
      }
    }
#line 696
    l_tilec->data_size = l_tilec->data_size_needed;
#line 697
    l_tilec->ownsData = 1;
  } else
#line 688
  if (l_tilec->data_size_needed > l_tilec->data_size) {
#line 688
    if (l_tilec->ownsData == 0) {
#line 688
      goto _L;
    } else {
#line 688
      goto _L___2;
    }
  } else
  _L___2: 
#line 698
  if (l_tilec->data_size_needed > l_tilec->data_size) {
    {
#line 700
    opj_image_data_free((void *)l_tilec->data);
#line 701
    __cil_tmp3 = opj_image_data_alloc(l_tilec->data_size_needed);
#line 701
    l_tilec->data = (OPJ_INT32 *)__cil_tmp3;
    }
#line 702
    if (! l_tilec->data) {
#line 703
      l_tilec->data_size = (size_t )0;
#line 704
      l_tilec->data_size_needed = (size_t )0;
#line 705
      l_tilec->ownsData = 0;
#line 706
      return (0);
    }
#line 709
    l_tilec->data_size = l_tilec->data_size_needed;
#line 710
    l_tilec->ownsData = 1;
  }
#line 712
  return (1);
}
}
#line 717 "/root/patron/new_24/src/lib/openjp2/tcd.c"
__inline static OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ,
                                           OPJ_BOOL isEncoder , OPJ_FLOAT32 fraction ,
                                           OPJ_SIZE_T sizeof_block , opj_event_mgr_t *manager ) 
{ 
  OPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32  ) ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcp_t *l_tcp ;
  opj_cp_t *l_cp ;
  opj_tcd_tile_t *l_tile ;
  opj_tccp_t *l_tccp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_image_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_stepsize_t *l_step_size ;
  opj_tcd_precinct_t *l_current_precinct ;
  opj_image_t *l_image ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_gain ;
  OPJ_INT32 l_x0b ;
  OPJ_INT32 l_y0b ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_INT32 l_tl_prc_x_start ;
  OPJ_INT32 l_tl_prc_y_start ;
  OPJ_INT32 l_br_prc_x_end ;
  OPJ_INT32 l_br_prc_y_end ;
  OPJ_UINT32 l_nb_precincts ;
  OPJ_UINT32 l_nb_precinct_size ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_nb_code_blocks_size ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_UINT32 __cil_tmp44 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_UINT32 __cil_tmp47 ;
  OPJ_UINT32 __cil_tmp48 ;
  OPJ_SIZE_T l_tile_data_size ;
  OPJ_SIZE_T w ;
  OPJ_SIZE_T h ;
  void *__cil_tmp56 ;
  opj_tcd_resolution_t *new_resolutions ;
  void *__cil_tmp58 ;
  OPJ_INT32 tlcbgxstart ;
  OPJ_INT32 tlcbgystart ;
  OPJ_UINT32 cbgwidthexpn ;
  OPJ_UINT32 cbgheightexpn ;
  OPJ_UINT32 cblkwidthexpn ;
  OPJ_UINT32 cblkheightexpn ;
  OPJ_INT32 __cil_tmp69 ;
  OPJ_INT32 __cil_tmp70 ;
  OPJ_INT32 __cil_tmp71 ;
  OPJ_INT32 __cil_tmp72 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  OPJ_INT32 numbps ;
  OPJ_BOOL __cil_tmp88 ;
  double __cil_tmp90 ;
  void *__cil_tmp91 ;
  opj_tcd_precinct_t *new_precincts ;
  void *__cil_tmp93 ;
  OPJ_INT32 tlcblkxstart ;
  OPJ_INT32 tlcblkystart ;
  OPJ_INT32 brcblkxend ;
  OPJ_INT32 brcblkyend ;
  OPJ_INT32 cbgxstart ;
  OPJ_INT32 cbgystart ;
  OPJ_INT32 cbgxend ;
  OPJ_INT32 cbgyend ;
  OPJ_INT32 __cil_tmp106 ;
  OPJ_INT32 __cil_tmp107 ;
  OPJ_INT32 __cil_tmp108 ;
  OPJ_INT32 __cil_tmp109 ;
  void *new_blocks ;
  void *__cil_tmp112 ;
  OPJ_INT32 cblkxstart ;
  OPJ_INT32 cblkystart ;
  OPJ_INT32 cblkxend ;
  OPJ_INT32 cblkyend ;
  opj_tcd_cblk_enc_t *l_code_block ;
  OPJ_BOOL __cil_tmp122 ;
  OPJ_BOOL __cil_tmp127 ;
  opj_tcd_cblk_dec_t *l_code_block___0 ;
  OPJ_BOOL __cil_tmp129 ;

  {
  {
#line 721
  l_gain_ptr = (OPJ_UINT32 (*)(OPJ_UINT32  ))0;
#line 723
  l_tcp = (opj_tcp_t *)0;
#line 724
  l_cp = (opj_cp_t *)0;
#line 725
  l_tile = (opj_tcd_tile_t *)0;
#line 726
  l_tccp = (opj_tccp_t *)0;
#line 727
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 728
  l_image_comp = (opj_image_comp_t *)0;
#line 729
  l_res = (opj_tcd_resolution_t *)0;
#line 730
  l_band = (opj_tcd_band_t *)0;
#line 731
  l_step_size = (opj_stepsize_t *)0;
#line 732
  l_current_precinct = (opj_tcd_precinct_t *)0;
#line 733
  l_image = (opj_image_t *)0;
#line 753
  l_cp = p_tcd->cp;
#line 754
  l_tcp = l_cp->tcps + p_tile_no;
#line 755
  l_tile = (p_tcd->tcd_image)->tiles;
#line 756
  l_tccp = l_tcp->tccps;
#line 757
  l_tilec = l_tile->comps;
#line 758
  l_image = p_tcd->image;
#line 759
  l_image_comp = (p_tcd->image)->comps;
#line 761
  p = p_tile_no % l_cp->tw;
#line 762
  q = p_tile_no / l_cp->tw;
#line 766
  l_tx0 = l_cp->tx0 + p * l_cp->tdx;
#line 768
  __cil_tmp43 = opj_uint_max(l_tx0, l_image->x0);
#line 768
  l_tile->x0 = (OPJ_INT32 )__cil_tmp43;
#line 769
  __cil_tmp44 = opj_uint_adds(l_tx0, l_cp->tdx);
#line 769
  __cil_tmp45 = opj_uint_min(__cil_tmp44, l_image->x1);
#line 769
  l_tile->x1 = (OPJ_INT32 )__cil_tmp45;
  }
#line 772
  if (l_tile->x0 < 0) {
    {
#line 773
    opj_event_msg(manager, 1, "Tile X coordinates are not supported\n");
    }
#line 774
    return (0);
  } else
#line 772
  if (l_tile->x1 <= l_tile->x0) {
    {
#line 773
    opj_event_msg(manager, 1, "Tile X coordinates are not supported\n");
    }
#line 774
    return (0);
  }
  {
#line 776
  l_ty0 = l_cp->ty0 + q * l_cp->tdy;
#line 778
  __cil_tmp46 = opj_uint_max(l_ty0, l_image->y0);
#line 778
  l_tile->y0 = (OPJ_INT32 )__cil_tmp46;
#line 779
  __cil_tmp47 = opj_uint_adds(l_ty0, l_cp->tdy);
#line 779
  __cil_tmp48 = opj_uint_min(__cil_tmp47, l_image->y1);
#line 779
  l_tile->y1 = (OPJ_INT32 )__cil_tmp48;
  }
#line 782
  if (l_tile->y0 < 0) {
    {
#line 783
    opj_event_msg(manager, 1, "Tile Y coordinates are not supported\n");
    }
#line 784
    return (0);
  } else
#line 782
  if (l_tile->y1 <= l_tile->y0) {
    {
#line 783
    opj_event_msg(manager, 1, "Tile Y coordinates are not supported\n");
    }
#line 784
    return (0);
  }
#line 789
  if (l_tccp->numresolutions == 0U) {
    {
#line 790
    opj_event_msg(manager, 1, "tiles require at least one resolution\n");
    }
#line 791
    return (0);
  }
#line 796
  compno = (OPJ_UINT32 )0;
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;

#line 796
    if (! (compno < l_tile->numcomps)) {
#line 796
      goto while_break;
    }
    {
#line 798
    l_image_comp->resno_decoded = (OPJ_UINT32 )0;
#line 800
    l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32 )l_image_comp->dx);
#line 801
    l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32 )l_image_comp->dy);
#line 802
    l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32 )l_image_comp->dx);
#line 803
    l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32 )l_image_comp->dy);
#line 804
    l_tilec->compno = compno;
#line 807
    l_tilec->numresolutions = l_tccp->numresolutions;
    }
#line 808
    if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {
#line 809
      l_tilec->minimum_num_resolutions = (OPJ_UINT32 )1;
    } else {
#line 811
      l_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;
    }
#line 815
    if (isEncoder) {
#line 819
      w = (OPJ_SIZE_T )(l_tilec->x1 - l_tilec->x0);
#line 820
      h = (OPJ_SIZE_T )(l_tilec->y1 - l_tilec->y0);
#line 823
      if (h > 0UL) {
#line 823
        if (w > 0xffffffffffffffffUL / h) {
          {
#line 824
          opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
          }
#line 825
          return (0);
        }
      }
#line 827
      l_tile_data_size = w * h;
#line 829
      if (0xffffffffffffffffUL / sizeof(OPJ_UINT32 ) < l_tile_data_size) {
        {
#line 830
        opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 831
        return (0);
      }
#line 833
      l_tile_data_size *= sizeof(OPJ_UINT32 );
#line 835
      l_tilec->data_size_needed = l_tile_data_size;
    }
    {
#line 838
    l_data_size = l_tilec->numresolutions * (OPJ_UINT32 )sizeof(opj_tcd_resolution_t );
#line 841
    opj_image_data_free((void *)l_tilec->data_win);
#line 842
    l_tilec->data_win = (OPJ_INT32 *)((void *)0);
#line 843
    l_tilec->win_x0 = (OPJ_UINT32 )0;
#line 844
    l_tilec->win_y0 = (OPJ_UINT32 )0;
#line 845
    l_tilec->win_x1 = (OPJ_UINT32 )0;
#line 846
    l_tilec->win_y1 = (OPJ_UINT32 )0;
    }
#line 848
    if ((unsigned long )l_tilec->resolutions == (unsigned long )((opj_tcd_resolution_t *)0)) {
      {
#line 849
      __cil_tmp56 = opj_malloc((size_t )l_data_size);
#line 849
      l_tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp56;
      }
#line 850
      if (! l_tilec->resolutions) {
#line 851
        return (0);
      }
      {
#line 854
      l_tilec->resolutions_size = l_data_size;
#line 855
      memset((void *)l_tilec->resolutions, 0, (unsigned long )l_data_size);
      }
    } else
#line 856
    if (l_data_size > l_tilec->resolutions_size) {
      {
#line 857
      __cil_tmp58 = opj_realloc((void *)l_tilec->resolutions, (size_t )l_data_size);
#line 857
      new_resolutions = (opj_tcd_resolution_t *)__cil_tmp58;
      }
#line 859
      if (! new_resolutions) {
        {
#line 860
        opj_event_msg(manager, 1, "Not enough memory for tile resolutions\n");
#line 861
        opj_free((void *)l_tilec->resolutions);
#line 862
        l_tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
#line 863
        l_tilec->resolutions_size = (OPJ_UINT32 )0;
        }
#line 864
        return (0);
      }
      {
#line 866
      l_tilec->resolutions = new_resolutions;
#line 868
      memset((void *)((OPJ_BYTE *)l_tilec->resolutions + l_tilec->resolutions_size),
             0, (unsigned long )(l_data_size - l_tilec->resolutions_size));
#line 870
      l_tilec->resolutions_size = l_data_size;
      }
    }
#line 873
    l_level_no = l_tilec->numresolutions;
#line 874
    l_res = l_tilec->resolutions;
#line 875
    l_step_size = l_tccp->stepsizes;
#line 876
    if (l_tccp->qmfbid == 0U) {
#line 877
      l_gain_ptr = & opj_dwt_getgain_real;
    } else {
#line 879
      l_gain_ptr = & opj_dwt_getgain;
    }
#line 883
    resno = (OPJ_UINT32 )0;
    {
#line 883
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 883
      if (! (resno < l_tilec->numresolutions)) {
#line 883
        goto while_break___0;
      }
      {
#line 889
      l_level_no --;
#line 892
      l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 893
      l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 894
      l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 895
      l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
#line 899
      l_pdx = l_tccp->prcw[resno];
#line 900
      l_pdy = l_tccp->prch[resno];
#line 903
      __cil_tmp69 = opj_int_floordivpow2(l_res->x0, (OPJ_INT32 )l_pdx);
#line 903
      l_tl_prc_x_start = __cil_tmp69 << l_pdx;
#line 904
      __cil_tmp70 = opj_int_floordivpow2(l_res->y0, (OPJ_INT32 )l_pdy);
#line 904
      l_tl_prc_y_start = __cil_tmp70 << l_pdy;
#line 905
      __cil_tmp71 = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32 )l_pdx);
#line 905
      l_br_prc_x_end = __cil_tmp71 << l_pdx;
#line 906
      __cil_tmp72 = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32 )l_pdy);
#line 906
      l_br_prc_y_end = __cil_tmp72 << l_pdy;
      }
#line 909
      if (l_res->x0 == l_res->x1) {
#line 909
        tmp = 0U;
      } else {
#line 909
        tmp = (OPJ_UINT32 )((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);
      }
#line 909
      l_res->pw = tmp;
#line 911
      if (l_res->y0 == l_res->y1) {
#line 911
        tmp___0 = 0U;
      } else {
#line 911
        tmp___0 = (OPJ_UINT32 )((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);
      }
#line 911
      l_res->ph = tmp___0;
#line 915
      if (l_res->pw != 0U) {
#line 915
        if (4294967295U / l_res->pw < l_res->ph) {
          {
#line 916
          opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
          }
#line 917
          return (0);
        }
      }
#line 919
      l_nb_precincts = l_res->pw * l_res->ph;
#line 921
      if (4294967295U / (OPJ_UINT32 )sizeof(opj_tcd_precinct_t ) < l_nb_precincts) {
        {
#line 923
        opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 924
        return (0);
      }
#line 926
      l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32 )sizeof(opj_tcd_precinct_t );
#line 928
      if (resno == 0U) {
#line 929
        tlcbgxstart = l_tl_prc_x_start;
#line 930
        tlcbgystart = l_tl_prc_y_start;
#line 933
        cbgwidthexpn = l_pdx;
#line 934
        cbgheightexpn = l_pdy;
#line 935
        l_res->numbands = (OPJ_UINT32 )1;
      } else {
        {
#line 937
        tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);
#line 938
        tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);
#line 941
        cbgwidthexpn = l_pdx - 1U;
#line 942
        cbgheightexpn = l_pdy - 1U;
#line 943
        l_res->numbands = (OPJ_UINT32 )3;
        }
      }
      {
#line 946
      cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);
#line 947
      cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);
#line 948
      l_band = l_res->bands;
#line 950
      bandno = (OPJ_UINT32 )0;
      }
      {
#line 950
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 950
        if (! (bandno < l_res->numbands)) {
#line 950
          goto while_break___1;
        }
#line 954
        if (resno == 0U) {
          {
#line 955
          l_band->bandno = (OPJ_UINT32 )0;
#line 956
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 957
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 958
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 959
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
          }
        } else {
          {
#line 961
          l_band->bandno = bandno + 1U;
#line 963
          l_x0b = (OPJ_INT32 )(l_band->bandno & 1U);
#line 965
          l_y0b = (OPJ_INT32 )(l_band->bandno >> 1);
#line 967
          l_band->x0 = opj_int64_ceildivpow2((long )l_tilec->x0 - ((OPJ_INT64 )l_x0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
#line 969
          l_band->y0 = opj_int64_ceildivpow2((long )l_tilec->y0 - ((OPJ_INT64 )l_y0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
#line 971
          l_band->x1 = opj_int64_ceildivpow2((long )l_tilec->x1 - ((OPJ_INT64 )l_x0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
#line 973
          l_band->y1 = opj_int64_ceildivpow2((long )l_tilec->y1 - ((OPJ_INT64 )l_y0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
          }
        }
#line 977
        if (isEncoder) {
          {
#line 979
          __cil_tmp88 = opj_tcd_is_band_empty(l_band);
          }
#line 979
          if (__cil_tmp88) {
#line 983
            goto while_continue___1;
          }
        }
        {
#line 988
        l_gain = (*l_gain_ptr)(l_band->bandno);
#line 989
        numbps = (OPJ_INT32 )(l_image_comp->prec + l_gain);
#line 990
        __cil_tmp90 = pow(2., (double )(numbps - l_step_size->expn));
#line 990
        l_band->stepsize = (OPJ_FLOAT32 )((1. + (double )l_step_size->mant / 2048.) * __cil_tmp90) * fraction;
#line 994
        l_band->numbps = (l_step_size->expn + (OPJ_INT32 )l_tccp->numgbits) - 1;
        }
#line 997
        if (! l_band->precincts) {
#line 997
          if (l_nb_precincts > 0U) {
            {
#line 998
            __cil_tmp91 = opj_malloc((size_t )l_nb_precinct_size);
#line 998
            l_band->precincts = (opj_tcd_precinct_t *)__cil_tmp91;
            }
#line 1000
            if (! l_band->precincts) {
              {
#line 1001
              opj_event_msg(manager, 1, "Not enough memory to handle band precints\n");
              }
#line 1003
              return (0);
            }
            {
#line 1006
            memset((void *)l_band->precincts, 0, (unsigned long )l_nb_precinct_size);
#line 1007
            l_band->precincts_data_size = l_nb_precinct_size;
            }
          } else {
#line 997
            goto _L;
          }
        } else
        _L: 
#line 1008
        if (l_band->precincts_data_size < l_nb_precinct_size) {
          {
#line 1010
          __cil_tmp93 = opj_realloc((void *)l_band->precincts, (size_t )l_nb_precinct_size);
#line 1010
          new_precincts = (opj_tcd_precinct_t *)__cil_tmp93;
          }
#line 1012
          if (! new_precincts) {
            {
#line 1013
            opj_event_msg(manager, 1, "Not enough memory to handle band precints\n");
#line 1015
            opj_free((void *)l_band->precincts);
#line 1016
            l_band->precincts = (opj_tcd_precinct_t *)((void *)0);
#line 1017
            l_band->precincts_data_size = (OPJ_UINT32 )0;
            }
#line 1018
            return (0);
          }
          {
#line 1020
          l_band->precincts = new_precincts;
#line 1022
          memset((void *)((OPJ_BYTE *)l_band->precincts + l_band->precincts_data_size),
                 0, (unsigned long )(l_nb_precinct_size - l_band->precincts_data_size));
#line 1024
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        }
#line 1027
        l_current_precinct = l_band->precincts;
#line 1028
        precno = (OPJ_UINT32 )0;
        {
#line 1028
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 1028
          if (! (precno < l_nb_precincts)) {
#line 1028
            goto while_break___2;
          }
          {
#line 1030
          cbgxstart = tlcbgxstart + (OPJ_INT32 )(precno % l_res->pw) * (1 << cbgwidthexpn);
#line 1032
          cbgystart = tlcbgystart + (OPJ_INT32 )(precno / l_res->pw) * (1 << cbgheightexpn);
#line 1034
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 1035
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 1042
          l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);
#line 1043
          l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);
#line 1044
          l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);
#line 1045
          l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);
#line 1048
          __cil_tmp106 = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32 )cblkwidthexpn);
#line 1048
          tlcblkxstart = __cil_tmp106 << cblkwidthexpn;
#line 1051
          __cil_tmp107 = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32 )cblkheightexpn);
#line 1051
          tlcblkystart = __cil_tmp107 << cblkheightexpn;
#line 1054
          __cil_tmp108 = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32 )cblkwidthexpn);
#line 1054
          brcblkxend = __cil_tmp108 << cblkwidthexpn;
#line 1057
          __cil_tmp109 = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32 )cblkheightexpn);
#line 1057
          brcblkyend = __cil_tmp109 << cblkheightexpn;
#line 1060
          l_current_precinct->cw = (OPJ_UINT32 )((brcblkxend - tlcblkxstart) >> cblkwidthexpn);
#line 1062
          l_current_precinct->ch = (OPJ_UINT32 )((brcblkyend - tlcblkystart) >> cblkheightexpn);
#line 1065
          l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;
#line 1067
          l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32 )sizeof_block;
          }
#line 1069
          if (! l_current_precinct->cblks.blocks) {
#line 1069
            if (l_nb_code_blocks > 0U) {
              {
#line 1070
              l_current_precinct->cblks.blocks = opj_malloc((size_t )l_nb_code_blocks_size);
              }
#line 1071
              if (! l_current_precinct->cblks.blocks) {
#line 1072
                return (0);
              }
              {
#line 1076
              memset(l_current_precinct->cblks.blocks, 0, (unsigned long )l_nb_code_blocks_size);
#line 1078
              l_current_precinct->block_size = l_nb_code_blocks_size;
              }
            } else {
#line 1069
              goto _L___3;
            }
          } else
          _L___3: 
#line 1079
          if (l_nb_code_blocks_size > l_current_precinct->block_size) {
            {
#line 1080
            __cil_tmp112 = opj_realloc(l_current_precinct->cblks.blocks, (size_t )l_nb_code_blocks_size);
#line 1080
            new_blocks = __cil_tmp112;
            }
#line 1082
            if (! new_blocks) {
              {
#line 1083
              opj_free(l_current_precinct->cblks.blocks);
#line 1084
              l_current_precinct->cblks.blocks = (void *)0;
#line 1085
              l_current_precinct->block_size = (OPJ_UINT32 )0;
#line 1086
              opj_event_msg(manager, 1, "Not enough memory for current precinct codeblock element\n");
              }
#line 1088
              return (0);
            }
            {
#line 1090
            l_current_precinct->cblks.blocks = new_blocks;
#line 1093
            memset((void *)((OPJ_BYTE *)l_current_precinct->cblks.blocks + l_current_precinct->block_size),
                   0, (unsigned long )(l_nb_code_blocks_size - l_current_precinct->block_size));
#line 1098
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          }
#line 1101
          if (! l_current_precinct->incltree) {
            {
#line 1102
            l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch,
                                                          manager);
            }
          } else {
            {
#line 1105
            l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,
                                                        l_current_precinct->cw, l_current_precinct->ch,
                                                        manager);
            }
          }
#line 1109
          if (! l_current_precinct->imsbtree) {
            {
#line 1110
            l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch,
                                                          manager);
            }
          } else {
            {
#line 1113
            l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,
                                                        l_current_precinct->cw, l_current_precinct->ch,
                                                        manager);
            }
          }
#line 1117
          cblkno = (OPJ_UINT32 )0;
          {
#line 1117
          while (1) {
            while_continue___5: /* CIL Label */ ;

#line 1117
            if (! (cblkno < l_nb_code_blocks)) {
#line 1117
              goto while_break___3;
            }
#line 1118
            cblkxstart = tlcblkxstart + (OPJ_INT32 )(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);
#line 1120
            cblkystart = tlcblkystart + (OPJ_INT32 )(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);
#line 1122
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 1123
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 1125
            if (isEncoder) {
              {
#line 1126
              l_code_block = l_current_precinct->cblks.enc + cblkno;
#line 1128
              __cil_tmp122 = opj_tcd_code_block_enc_allocate(l_code_block);
              }
#line 1128
              if (! __cil_tmp122) {
#line 1129
                return (0);
              }
              {
#line 1132
              l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 1133
              l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 1134
              l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 1135
              l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
#line 1137
              __cil_tmp127 = opj_tcd_code_block_enc_allocate_data(l_code_block);
              }
#line 1137
              if (! __cil_tmp127) {
#line 1138
                return (0);
              }
            } else {
              {
#line 1141
              l_code_block___0 = l_current_precinct->cblks.dec + cblkno;
#line 1143
              __cil_tmp129 = opj_tcd_code_block_dec_allocate(l_code_block___0);
              }
#line 1143
              if (! __cil_tmp129) {
#line 1144
                return (0);
              }
              {
#line 1147
              l_code_block___0->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 1148
              l_code_block___0->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 1149
              l_code_block___0->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 1150
              l_code_block___0->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
              }
            }
#line 1117
            cblkno ++;
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: 
#line 1153
          l_current_precinct ++;
#line 1028
          precno ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: 
#line 950
        l_step_size ++;
#line 950
        l_band ++;
#line 950
        bandno ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 1156
      l_res ++;
#line 883
      resno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 1158
    l_tccp ++;
#line 1159
    l_tilec ++;
#line 1160
    l_image_comp ++;
#line 796
    compno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 1162
  return (1);
}
}
#line 1165 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 1168
  __cil_tmp4 = opj_tcd_init_tile(p_tcd, p_tile_no, 1, 1.f, sizeof(opj_tcd_cblk_enc_t ),
                                 p_manager);
  }
#line 1168
  return (__cil_tmp4);
}
}
#line 1172 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 1175
  __cil_tmp4 = opj_tcd_init_tile(p_tcd, p_tile_no, 0, 0.5f, sizeof(opj_tcd_cblk_dec_t ),
                                 p_manager);
  }
#line 1175
  return (__cil_tmp4);
}
}
#line 1182 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
#line 1185
  if (! p_code_block->layers) {
    {
#line 1187
    __cil_tmp2 = opj_calloc((size_t )100, sizeof(opj_tcd_layer_t ));
#line 1187
    p_code_block->layers = (opj_tcd_layer_t *)__cil_tmp2;
    }
#line 1189
    if (! p_code_block->layers) {
#line 1190
      return (0);
    }
  }
#line 1193
  if (! p_code_block->passes) {
    {
#line 1194
    __cil_tmp3 = opj_calloc((size_t )100, sizeof(opj_tcd_pass_t ));
#line 1194
    p_code_block->passes = (opj_tcd_pass_t *)__cil_tmp3;
    }
#line 1196
    if (! p_code_block->passes) {
#line 1197
      return (0);
    }
  }
#line 1200
  return (1);
}
}
#line 1206 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *p_code_block ) 
{ 
  OPJ_UINT32 l_data_size ;
  void *__cil_tmp3 ;

  {
#line 1215
  l_data_size = 2U + (OPJ_UINT32 )(((p_code_block->x1 - p_code_block->x0) * (p_code_block->y1 - p_code_block->y0)) * (OPJ_INT32 )sizeof(OPJ_UINT32 ));
#line 1218
  if (l_data_size > p_code_block->data_size) {
#line 1219
    if (p_code_block->data) {
      {
#line 1221
      opj_free((void *)(p_code_block->data - 1));
      }
    }
    {
#line 1223
    __cil_tmp3 = opj_malloc((size_t )(l_data_size + 1U));
#line 1223
    p_code_block->data = (OPJ_BYTE *)__cil_tmp3;
    }
#line 1224
    if (! p_code_block->data) {
#line 1225
      p_code_block->data_size = 0U;
#line 1226
      return (0);
    }
#line 1228
    p_code_block->data_size = l_data_size;
#line 1234
    *(p_code_block->data + 0) = (OPJ_BYTE )0;
#line 1235
    (p_code_block->data) ++;
  }
#line 1237
  return (1);
}
}
#line 1241 "/root/patron/new_24/src/lib/openjp2/tcd.c"
void opj_tcd_reinit_segment(opj_tcd_seg_t *seg ) 
{ 


  {
  {
#line 1243
  memset((void *)seg, 0, sizeof(opj_tcd_seg_t ));
  }
#line 1245
  return;
}
}
#line 1249 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) 
{ 
  void *__cil_tmp2 ;
  opj_tcd_seg_t *l_segs ;
  OPJ_UINT32 l_current_max_segs ;
  opj_tcd_seg_data_chunk_t *l_chunks ;
  OPJ_UINT32 l_numchunksalloc ;
  OPJ_UINT32 i ;

  {
#line 1252
  if (! p_code_block->segs) {
    {
#line 1254
    __cil_tmp2 = opj_calloc((size_t )10, sizeof(opj_tcd_seg_t ));
#line 1254
    p_code_block->segs = (opj_tcd_seg_t *)__cil_tmp2;
    }
#line 1256
    if (! p_code_block->segs) {
#line 1257
      return (0);
    }
#line 1261
    p_code_block->m_current_max_segs = (OPJ_UINT32 )10;
  } else {
    {
#line 1265
    l_segs = p_code_block->segs;
#line 1266
    l_current_max_segs = p_code_block->m_current_max_segs;
#line 1267
    l_chunks = p_code_block->chunks;
#line 1268
    l_numchunksalloc = p_code_block->numchunksalloc;
#line 1271
    opj_aligned_free((void *)p_code_block->decoded_data);
#line 1272
    p_code_block->decoded_data = (OPJ_INT32 *)0;
#line 1274
    memset((void *)p_code_block, 0, sizeof(opj_tcd_cblk_dec_t ));
#line 1275
    p_code_block->segs = l_segs;
#line 1276
    p_code_block->m_current_max_segs = l_current_max_segs;
#line 1277
    i = (OPJ_UINT32 )0;
    }
    {
#line 1277
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1277
      if (! (i < l_current_max_segs)) {
#line 1277
        goto while_break;
      }
      {
#line 1278
      opj_tcd_reinit_segment(l_segs + i);
#line 1277
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 1280
    p_code_block->chunks = l_chunks;
#line 1281
    p_code_block->numchunksalloc = l_numchunksalloc;
  }
#line 1284
  return (1);
}
}
#line 1287 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd , OPJ_BOOL take_into_account_partial_decoding ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_temp ;
  OPJ_UINT32 w ;
  OPJ_UINT32 h ;

  {
#line 1291
  l_data_size = (OPJ_UINT32 )0;
#line 1292
  l_img_comp = (opj_image_comp_t *)0;
#line 1293
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1294
  l_res = (opj_tcd_resolution_t *)0;
#line 1298
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1299
  l_img_comp = (p_tcd->image)->comps;
#line 1301
  i = (OPJ_UINT32 )0;
  {
#line 1301
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1301
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1301
      goto while_break;
    }
#line 1303
    l_size_comp = l_img_comp->prec >> 3;
#line 1304
    l_remaining = l_img_comp->prec & 7U;
#line 1306
    if (l_remaining) {
#line 1307
      l_size_comp ++;
    }
#line 1310
    if (l_size_comp == 3U) {
#line 1311
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1314
    l_res = (l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 1315
    if (take_into_account_partial_decoding) {
#line 1315
      if (! p_tcd->whole_tile_decoding) {
#line 1316
        w = l_res->win_x1 - l_res->win_x0;
#line 1317
        h = l_res->win_y1 - l_res->win_y0;
      } else {
#line 1319
        w = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1320
        h = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
      }
    } else {
#line 1319
      w = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1320
      h = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
    }
#line 1322
    if (h > 0U) {
#line 1322
      if (4294967295U / w < h) {
#line 1323
        return (4294967295U);
      }
    }
#line 1325
    l_temp = w * h;
#line 1326
    if (l_size_comp) {
#line 1326
      if (4294967295U / l_size_comp < l_temp) {
#line 1327
        return (4294967295U);
      }
    }
#line 1329
    l_temp *= l_size_comp;
#line 1331
    if (l_temp > 4294967295U - l_data_size) {
#line 1332
      return (4294967295U);
    }
#line 1334
    l_data_size += l_temp;
#line 1335
    l_img_comp ++;
#line 1336
    l_tile_comp ++;
#line 1301
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1339
  return (l_data_size);
}
}
#line 1342 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_num_packs ;
  OPJ_UINT32 i ;
  opj_tcd_tilecomp_t *l_tilec_idx ;
  opj_tccp_t *l_tccp ;
  opj_tcd_resolution_t *l_res_idx ;
  void *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;

  {
#line 1351
  if (p_tcd->cur_tp_num == 0U) {
#line 1353
    p_tcd->tcd_tileno = p_tile_no;
#line 1354
    p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1357
    if (p_cstr_info) {
#line 1358
      l_num_packs = (OPJ_UINT32 )0;
#line 1360
      l_tilec_idx = ((p_tcd->tcd_image)->tiles)->comps + 0;
#line 1362
      l_tccp = (p_tcd->tcp)->tccps;
#line 1364
      i = (OPJ_UINT32 )0;
      {
#line 1364
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1364
        if (! (i < l_tilec_idx->numresolutions)) {
#line 1364
          goto while_break;
        }
#line 1365
        l_res_idx = l_tilec_idx->resolutions + i;
#line 1367
        (p_cstr_info->tile + p_tile_no)->pw[i] = (int )l_res_idx->pw;
#line 1368
        (p_cstr_info->tile + p_tile_no)->ph[i] = (int )l_res_idx->ph;
#line 1370
        l_num_packs += l_res_idx->pw * l_res_idx->ph;
#line 1371
        (p_cstr_info->tile + p_tile_no)->pdx[i] = (int )l_tccp->prcw[i];
#line 1372
        (p_cstr_info->tile + p_tile_no)->pdy[i] = (int )l_tccp->prch[i];
#line 1364
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 1374
      __cil_tmp14 = opj_calloc(((OPJ_SIZE_T )p_cstr_info->numcomps * (OPJ_SIZE_T )p_cstr_info->numlayers) * (unsigned long )l_num_packs,
                               sizeof(opj_packet_info_t ));
#line 1374
      (p_cstr_info->tile + p_tile_no)->packet = (opj_packet_info_t *)__cil_tmp14;
      }
#line 1378
      if (! (p_cstr_info->tile + p_tile_no)->packet) {
#line 1380
        return (0);
      }
    }
    {
#line 1387
    __cil_tmp15 = opj_tcd_dc_level_shift_encode(p_tcd);
    }
#line 1387
    if (! __cil_tmp15) {
#line 1388
      return (0);
    }
    {
#line 1393
    __cil_tmp16 = opj_tcd_mct_encode(p_tcd);
    }
#line 1393
    if (! __cil_tmp16) {
#line 1394
      return (0);
    }
    {
#line 1399
    __cil_tmp17 = opj_tcd_dwt_encode(p_tcd);
    }
#line 1399
    if (! __cil_tmp17) {
#line 1400
      return (0);
    }
    {
#line 1405
    __cil_tmp18 = opj_tcd_t1_encode(p_tcd);
    }
#line 1405
    if (! __cil_tmp18) {
#line 1406
      return (0);
    }
    {
#line 1411
    __cil_tmp19 = opj_tcd_rate_allocate_encode(p_tcd, p_dest, p_max_length, p_cstr_info,
                                               p_manager);
    }
#line 1411
    if (! __cil_tmp19) {
#line 1413
      return (0);
    }
  }
#line 1421
  if (p_cstr_info) {
#line 1422
    p_cstr_info->index_write = 1;
  }
  {
#line 1426
  __cil_tmp20 = opj_tcd_t2_encode(p_tcd, p_dest, p_data_written, p_max_length, p_cstr_info,
                                  p_manager);
  }
#line 1426
  if (! __cil_tmp20) {
#line 1428
    return (0);
  }
#line 1434
  return (1);
}
}
#line 1437 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 win_x0 , OPJ_UINT32 win_y0 ,
                             OPJ_UINT32 win_x1 , OPJ_UINT32 win_y1 , OPJ_BYTE *p_src ,
                             OPJ_UINT32 p_max_length , OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_data_read ;
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp13 ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *l_res ;
  OPJ_SIZE_T l_data_size ;
  OPJ_SIZE_T res_w ;
  OPJ_SIZE_T res_h ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_UINT32 resno ;
  opj_tcd_tilecomp_t *tilec___0 ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  opj_tcd_resolution_t *res ;
  OPJ_BOOL __cil_tmp39 ;
  OPJ_BOOL __cil_tmp40 ;
  opj_tcd_tilecomp_t *tilec___1 ;
  opj_image_comp_t *image_comp___0 ;
  opj_tcd_resolution_t *res___0 ;
  OPJ_SIZE_T w ;
  OPJ_SIZE_T h ;
  OPJ_SIZE_T l_data_size___0 ;
  OPJ_BOOL __cil_tmp49 ;
  OPJ_BOOL __cil_tmp50 ;
  OPJ_BOOL __cil_tmp51 ;
  void *tmp ;

  {
#line 1452
  p_tcd->tcd_tileno = p_tile_no;
#line 1453
  p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1454
  p_tcd->win_x0 = win_x0;
#line 1455
  p_tcd->win_y0 = win_y0;
#line 1456
  p_tcd->win_x1 = win_x1;
#line 1457
  p_tcd->win_y1 = win_y1;
#line 1458
  p_tcd->whole_tile_decoding = 1;
#line 1460
  compno = (OPJ_UINT32 )0;
  {
#line 1460
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1460
    if (! (compno < (p_tcd->image)->numcomps)) {
#line 1460
      goto while_break;
    }
    {
#line 1461
    __cil_tmp13 = opj_tcd_is_whole_tilecomp_decoding(p_tcd, compno);
    }
#line 1461
    if (! __cil_tmp13) {
#line 1462
      p_tcd->whole_tile_decoding = 0;
#line 1463
      goto while_break;
    }
#line 1460
    compno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 1467
  if (p_tcd->whole_tile_decoding) {
#line 1468
    compno = (OPJ_UINT32 )0;
    {
#line 1468
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1468
      if (! (compno < (p_tcd->image)->numcomps)) {
#line 1468
        goto while_break___0;
      }
#line 1469
      tilec = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 1470
      l_res = tilec->resolutions + (tilec->minimum_num_resolutions - 1U);
#line 1475
      res_w = (OPJ_SIZE_T )(l_res->x1 - l_res->x0);
#line 1476
      res_h = (OPJ_SIZE_T )(l_res->y1 - l_res->y0);
#line 1479
      if (res_h > 0UL) {
#line 1479
        if (res_w > 0xffffffffffffffffUL / res_h) {
          {
#line 1480
          opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
          }
#line 1482
          return (0);
        }
      }
#line 1484
      l_data_size = res_w * res_h;
#line 1486
      if (0xffffffffffffffffUL / sizeof(OPJ_UINT32 ) < l_data_size) {
        {
#line 1487
        opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 1489
        return (0);
      }
      {
#line 1491
      l_data_size *= sizeof(OPJ_UINT32 );
#line 1493
      tilec->data_size_needed = l_data_size;
#line 1495
      __cil_tmp20 = opj_alloc_tile_component_data(tilec);
      }
#line 1495
      if (! __cil_tmp20) {
        {
#line 1496
        opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 1498
        return (0);
      }
#line 1468
      compno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 1505
    compno = (OPJ_UINT32 )0;
    {
#line 1505
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1505
      if (! (compno < (p_tcd->image)->numcomps)) {
#line 1505
        goto while_break___1;
      }
      {
#line 1507
      tilec___0 = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 1508
      image_comp = (p_tcd->image)->comps + compno;
#line 1511
      __cil_tmp25 = opj_uint_ceildiv(p_tcd->win_x0, image_comp->dx);
#line 1511
      __cil_tmp26 = opj_uint_max((OPJ_UINT32 )tilec___0->x0, __cil_tmp25);
#line 1511
      tilec___0->win_x0 = __cil_tmp26;
#line 1514
      __cil_tmp27 = opj_uint_ceildiv(p_tcd->win_y0, image_comp->dy);
#line 1514
      __cil_tmp28 = opj_uint_max((OPJ_UINT32 )tilec___0->y0, __cil_tmp27);
#line 1514
      tilec___0->win_y0 = __cil_tmp28;
#line 1517
      __cil_tmp29 = opj_uint_ceildiv(p_tcd->win_x1, image_comp->dx);
#line 1517
      __cil_tmp30 = opj_uint_min((OPJ_UINT32 )tilec___0->x1, __cil_tmp29);
#line 1517
      tilec___0->win_x1 = __cil_tmp30;
#line 1520
      __cil_tmp31 = opj_uint_ceildiv(p_tcd->win_y1, image_comp->dy);
#line 1520
      __cil_tmp32 = opj_uint_min((OPJ_UINT32 )tilec___0->y1, __cil_tmp31);
#line 1520
      tilec___0->win_y1 = __cil_tmp32;
#line 1524
      resno = (OPJ_UINT32 )0;
      }
      {
#line 1524
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1524
        if (! (resno < tilec___0->numresolutions)) {
#line 1524
          goto while_break___2;
        }
        {
#line 1525
        res = tilec___0->resolutions + resno;
#line 1526
        res->win_x0 = opj_uint_ceildivpow2(tilec___0->win_x0, (tilec___0->numresolutions - 1U) - resno);
#line 1528
        res->win_y0 = opj_uint_ceildivpow2(tilec___0->win_y0, (tilec___0->numresolutions - 1U) - resno);
#line 1530
        res->win_x1 = opj_uint_ceildivpow2(tilec___0->win_x1, (tilec___0->numresolutions - 1U) - resno);
#line 1532
        res->win_y1 = opj_uint_ceildivpow2(tilec___0->win_y1, (tilec___0->numresolutions - 1U) - resno);
#line 1524
        resno ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: 
#line 1505
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: ;
  }
  {
#line 1564
  l_data_read = (OPJ_UINT32 )0;
#line 1565
  __cil_tmp39 = opj_tcd_t2_decode(p_tcd, p_src, & l_data_read, p_max_length, p_cstr_index,
                                  p_manager);
  }
#line 1565
  if (! __cil_tmp39) {
#line 1567
    return (0);
  }
  {
#line 1574
  __cil_tmp40 = opj_tcd_t1_decode(p_tcd, p_manager);
  }
#line 1574
  if (! __cil_tmp40) {
#line 1575
    return (0);
  }
#line 1582
  if (! p_tcd->whole_tile_decoding) {
#line 1583
    compno = (OPJ_UINT32 )0;
    {
#line 1583
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1583
      if (! (compno < (p_tcd->image)->numcomps)) {
#line 1583
        goto while_break___3;
      }
      {
#line 1584
      tilec___1 = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 1585
      image_comp___0 = (p_tcd->image)->comps + compno;
#line 1586
      res___0 = tilec___1->resolutions + image_comp___0->resno_decoded;
#line 1587
      w = (OPJ_SIZE_T )(res___0->win_x1 - res___0->win_x0);
#line 1588
      h = (OPJ_SIZE_T )(res___0->win_y1 - res___0->win_y0);
#line 1591
      opj_image_data_free((void *)tilec___1->data_win);
#line 1592
      tilec___1->data_win = (OPJ_INT32 *)((void *)0);
      }
#line 1594
      if (w > 0UL) {
#line 1594
        if (h > 0UL) {
#line 1595
          if (w > 0xffffffffffffffffUL / h) {
            {
#line 1596
            opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
            }
#line 1598
            return (0);
          }
#line 1600
          l_data_size___0 = w * h;
#line 1601
          if (l_data_size___0 > 0xffffffffffffffffUL / sizeof(OPJ_INT32 )) {
            {
#line 1602
            opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
            }
#line 1604
            return (0);
          }
          {
#line 1606
          l_data_size___0 *= sizeof(OPJ_INT32 );
#line 1608
          tmp = opj_image_data_alloc(l_data_size___0);
#line 1608
          tilec___1->data_win = (OPJ_INT32 *)tmp;
          }
#line 1609
          if ((unsigned long )tilec___1->data_win == (unsigned long )((void *)0)) {
            {
#line 1610
            opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
            }
#line 1612
            return (0);
          }
        }
      }
#line 1583
      compno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: ;
  }
  {
#line 1621
  __cil_tmp49 = opj_tcd_dwt_decode(p_tcd);
  }
#line 1621
  if (! __cil_tmp49) {
#line 1623
    return (0);
  }
  {
#line 1629
  __cil_tmp50 = opj_tcd_mct_decode(p_tcd, p_manager);
  }
#line 1629
  if (! __cil_tmp50) {
#line 1631
    return (0);
  }
  {
#line 1636
  __cil_tmp51 = opj_tcd_dc_level_shift_decode(p_tcd);
  }
#line 1636
  if (! __cil_tmp51) {
#line 1638
    return (0);
  }
#line 1644
  return (1);
}
}
#line 1647 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_INT32 *l_src_data ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_CHAR *__cil_tmp20 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_CHAR *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT32 *l_src_ptr___0 ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 val ;
  OPJ_INT32 *__cil_tmp27 ;
  OPJ_INT16 val___0 ;
  OPJ_INT32 *__cil_tmp30 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *l_src_ptr___1 ;

  {
  {
#line 1652
  l_data_size = (OPJ_UINT32 )0;
#line 1653
  l_img_comp = (opj_image_comp_t *)0;
#line 1654
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 1659
  l_data_size = opj_tcd_get_decoded_tile_size(p_tcd, 1);
  }
#line 1660
  if (l_data_size == 4294967295U) {
#line 1661
    return (0);
  } else
#line 1660
  if (l_data_size > p_dest_length) {
#line 1661
    return (0);
  }
#line 1664
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 1665
  l_img_comp = (p_tcd->image)->comps;
#line 1667
  i = (OPJ_UINT32 )0;
  {
#line 1667
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1667
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1667
      goto while_break;
    }
#line 1669
    l_size_comp = l_img_comp->prec >> 3;
#line 1670
    l_remaining = l_img_comp->prec & 7U;
#line 1671
    l_res = l_tilec->resolutions + l_img_comp->resno_decoded;
#line 1672
    if (p_tcd->whole_tile_decoding) {
#line 1673
      l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1674
      l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 1675
      l_stride = (OPJ_UINT32 )((l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x1 - (l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x0) - l_width;
#line 1678
      l_src_data = l_tilec->data;
    } else {
#line 1680
      l_width = l_res->win_x1 - l_res->win_x0;
#line 1681
      l_height = l_res->win_y1 - l_res->win_y0;
#line 1682
      l_stride = (OPJ_UINT32 )0;
#line 1683
      l_src_data = l_tilec->data_win;
    }
#line 1686
    if (l_remaining) {
#line 1687
      l_size_comp ++;
    }
#line 1690
    if (l_size_comp == 3U) {
#line 1691
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1695
    if (l_size_comp == 1U) {
#line 1695
      goto case_1;
    }
#line 1718
    if (l_size_comp == 2U) {
#line 1718
      goto case_2;
    }
#line 1745
    if (l_size_comp == 4U) {
#line 1745
      goto case_4;
    }
#line 1694
    goto switch_break;
    case_1: 
#line 1696
    l_dest_ptr = (OPJ_CHAR *)p_dest;
#line 1697
    l_src_ptr = l_src_data;
#line 1699
    if (l_img_comp->sgnd) {
#line 1700
      j = (OPJ_UINT32 )0;
      {
#line 1700
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1700
        if (! (j < l_height)) {
#line 1700
          goto while_break___0;
        }
#line 1701
        k = (OPJ_UINT32 )0;
        {
#line 1701
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1701
          if (! (k < l_width)) {
#line 1701
            goto while_break___1;
          }
#line 1702
          __cil_tmp21 = l_src_ptr;
#line 1702
          l_src_ptr ++;
#line 1702
          __cil_tmp20 = l_dest_ptr;
#line 1702
          l_dest_ptr ++;
#line 1702
          *__cil_tmp20 = (OPJ_CHAR )*__cil_tmp21;
#line 1701
          k ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___1: 
#line 1704
        l_src_ptr += l_stride;
#line 1700
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 1707
      j = (OPJ_UINT32 )0;
      {
#line 1707
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1707
        if (! (j < l_height)) {
#line 1707
          goto while_break___2;
        }
#line 1708
        k = (OPJ_UINT32 )0;
        {
#line 1708
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1708
          if (! (k < l_width)) {
#line 1708
            goto while_break___3;
          }
#line 1709
          __cil_tmp23 = l_src_ptr;
#line 1709
          l_src_ptr ++;
#line 1709
          __cil_tmp22 = l_dest_ptr;
#line 1709
          l_dest_ptr ++;
#line 1709
          *__cil_tmp22 = (OPJ_CHAR )(*__cil_tmp23 & 255);
#line 1708
          k ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___3: 
#line 1711
        l_src_ptr += l_stride;
#line 1707
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 1715
    p_dest = (OPJ_BYTE *)l_dest_ptr;
#line 1717
    goto switch_break;
    case_2: 
#line 1719
    l_src_ptr___0 = l_src_data;
#line 1720
    l_dest_ptr___0 = (OPJ_INT16 *)p_dest;
#line 1722
    if (l_img_comp->sgnd) {
#line 1723
      j = (OPJ_UINT32 )0;
      {
#line 1723
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1723
        if (! (j < l_height)) {
#line 1723
          goto while_break___4;
        }
#line 1724
        k = (OPJ_UINT32 )0;
        {
#line 1724
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 1724
          if (! (k < l_width)) {
#line 1724
            goto while_break___5;
          }
          {
#line 1725
          __cil_tmp27 = l_src_ptr___0;
#line 1725
          l_src_ptr___0 ++;
#line 1725
          val = (OPJ_INT16 )*__cil_tmp27;
#line 1726
          memcpy((void *)l_dest_ptr___0, (void const   *)(& val), sizeof(val));
#line 1727
          l_dest_ptr___0 ++;
#line 1724
          k ++;
          }
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___5: 
#line 1729
        l_src_ptr___0 += l_stride;
#line 1723
        j ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___4: ;
    } else {
#line 1732
      j = (OPJ_UINT32 )0;
      {
#line 1732
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 1732
        if (! (j < l_height)) {
#line 1732
          goto while_break___6;
        }
#line 1733
        k = (OPJ_UINT32 )0;
        {
#line 1733
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 1733
          if (! (k < l_width)) {
#line 1733
            goto while_break___7;
          }
          {
#line 1734
          __cil_tmp30 = l_src_ptr___0;
#line 1734
          l_src_ptr___0 ++;
#line 1734
          val___0 = (OPJ_INT16 )(*__cil_tmp30 & 65535);
#line 1735
          memcpy((void *)l_dest_ptr___0, (void const   *)(& val___0), sizeof(val___0));
#line 1736
          l_dest_ptr___0 ++;
#line 1733
          k ++;
          }
        }
        while_break___17: /* CIL Label */ ;
        }
        while_break___7: 
#line 1738
        l_src_ptr___0 += l_stride;
#line 1732
        j ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___6: ;
    }
#line 1742
    p_dest = (OPJ_BYTE *)l_dest_ptr___0;
#line 1744
    goto switch_break;
    case_4: 
#line 1746
    l_dest_ptr___1 = (OPJ_INT32 *)p_dest;
#line 1747
    l_src_ptr___1 = l_src_data;
#line 1749
    j = (OPJ_UINT32 )0;
    {
#line 1749
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 1749
      if (! (j < l_height)) {
#line 1749
        goto while_break___8;
      }
      {
#line 1750
      memcpy((void *)l_dest_ptr___1, (void const   *)l_src_ptr___1, (unsigned long )l_width * sizeof(OPJ_INT32 ));
#line 1751
      l_dest_ptr___1 += l_width;
#line 1752
      l_src_ptr___1 += l_width + l_stride;
#line 1749
      j ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___8: 
#line 1755
    p_dest = (OPJ_BYTE *)l_dest_ptr___1;
#line 1757
    goto switch_break;
    switch_break: 
#line 1760
    l_img_comp ++;
#line 1761
    l_tilec ++;
#line 1667
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: ;
#line 1764
  return (1);
}
}
#line 1770 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static void opj_tcd_free_tile(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_tcd_precinct_t *l_precinct ;
  OPJ_UINT32 l_nb_resolutions ;
  OPJ_UINT32 l_nb_precincts ;
  void (*l_tcd_code_block_deallocate)(opj_tcd_precinct_t * ) ;

  {
#line 1773
  l_tile = (opj_tcd_tile_t *)0;
#line 1774
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1775
  l_res = (opj_tcd_resolution_t *)0;
#line 1776
  l_band = (opj_tcd_band_t *)0;
#line 1777
  l_precinct = (opj_tcd_precinct_t *)0;
#line 1779
  l_tcd_code_block_deallocate = (void (*)(opj_tcd_precinct_t * ))0;
#line 1781
  if (! p_tcd) {
#line 1782
    return;
  }
#line 1785
  if (! p_tcd->tcd_image) {
#line 1786
    return;
  }
#line 1789
  if (p_tcd->m_is_decoder) {
#line 1790
    l_tcd_code_block_deallocate = & opj_tcd_code_block_dec_deallocate;
  } else {
#line 1792
    l_tcd_code_block_deallocate = & opj_tcd_code_block_enc_deallocate;
  }
#line 1795
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1796
  if (! l_tile) {
#line 1797
    return;
  }
#line 1800
  l_tile_comp = l_tile->comps;
#line 1802
  compno = (OPJ_UINT32 )0;
  {
#line 1802
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1802
    if (! (compno < l_tile->numcomps)) {
#line 1802
      goto while_break;
    }
#line 1803
    l_res = l_tile_comp->resolutions;
#line 1804
    if (l_res) {
#line 1806
      l_nb_resolutions = (OPJ_UINT32 )((unsigned long )l_tile_comp->resolutions_size / sizeof(opj_tcd_resolution_t ));
#line 1807
      resno = (OPJ_UINT32 )0;
      {
#line 1807
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1807
        if (! (resno < l_nb_resolutions)) {
#line 1807
          goto while_break___0;
        }
#line 1808
        l_band = l_res->bands;
#line 1809
        bandno = (OPJ_UINT32 )0;
        {
#line 1809
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1809
          if (! (bandno < 3U)) {
#line 1809
            goto while_break___1;
          }
#line 1810
          l_precinct = l_band->precincts;
#line 1811
          if (l_precinct) {
#line 1813
            l_nb_precincts = (OPJ_UINT32 )((unsigned long )l_band->precincts_data_size / sizeof(opj_tcd_precinct_t ));
#line 1814
            precno = (OPJ_UINT32 )0;
            {
#line 1814
            while (1) {
              while_continue___2: /* CIL Label */ ;

#line 1814
              if (! (precno < l_nb_precincts)) {
#line 1814
                goto while_break___2;
              }
              {
#line 1815
              opj_tgt_destroy(l_precinct->incltree);
#line 1816
              l_precinct->incltree = (opj_tgt_tree_t *)0;
#line 1817
              opj_tgt_destroy(l_precinct->imsbtree);
#line 1818
              l_precinct->imsbtree = (opj_tgt_tree_t *)0;
#line 1819
              (*l_tcd_code_block_deallocate)(l_precinct);
#line 1820
              l_precinct ++;
#line 1814
              precno ++;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
            while_break___2: 
            {
#line 1823
            opj_free((void *)l_band->precincts);
#line 1824
            l_band->precincts = (opj_tcd_precinct_t *)0;
            }
          }
#line 1826
          l_band ++;
#line 1809
          bandno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: 
#line 1828
        l_res ++;
#line 1807
        resno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 1831
      opj_free((void *)l_tile_comp->resolutions);
#line 1832
      l_tile_comp->resolutions = (opj_tcd_resolution_t *)0;
      }
    }
#line 1835
    if (l_tile_comp->data) {
#line 1835
      if (l_tile_comp->ownsData) {
        {
#line 1836
        opj_image_data_free((void *)l_tile_comp->data);
#line 1837
        l_tile_comp->data = (OPJ_INT32 *)0;
#line 1838
        l_tile_comp->ownsData = 0;
#line 1839
        l_tile_comp->data_size = (size_t )0;
#line 1840
        l_tile_comp->data_size_needed = (size_t )0;
        }
      }
    }
    {
#line 1843
    opj_image_data_free((void *)l_tile_comp->data_win);
#line 1845
    l_tile_comp ++;
#line 1802
    compno ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1848
  opj_free((void *)l_tile->comps);
#line 1849
  l_tile->comps = (opj_tcd_tilecomp_t *)0;
#line 1850
  opj_free((void *)(p_tcd->tcd_image)->tiles);
#line 1851
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)0;
  }
#line 1853
  return;
}
}
#line 1855 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                  OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  opj_t2_t *l_t2 ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 1865
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 1866
  if ((unsigned long )l_t2 == (unsigned long )((opj_t2_t *)0)) {
#line 1867
    return (0);
  }
  {
#line 1870
  __cil_tmp9 = opj_t2_decode_packets(p_tcd, l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                     p_src_data, p_data_read, p_max_src_size, p_cstr_index,
                                     p_manager);
  }
#line 1870
  if (! __cil_tmp9) {
    {
#line 1880
    opj_t2_destroy(l_t2);
    }
#line 1881
    return (0);
  }
  {
#line 1884
  opj_t2_destroy(l_t2);
  }
#line 1887
  return (1);
}
}
#line 1890 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  OPJ_BOOL ret ;
  OPJ_BOOL check_pterm ;
  opj_mutex_t *p_manager_mutex ;

  {
  {
#line 1893
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1894
  l_tile_comp = l_tile->comps;
#line 1895
  l_tccp = (p_tcd->tcp)->tccps;
#line 1896
  ret = 1;
#line 1897
  check_pterm = 0;
#line 1898
  p_manager_mutex = (opj_mutex_t *)((void *)0);
#line 1900
  p_manager_mutex = opj_mutex_create();
  }
#line 1903
  if ((p_tcd->tcp)->num_layers_to_decode == (p_tcd->tcp)->numlayers) {
#line 1903
    if ((l_tccp->cblksty & 16U) != 0U) {
#line 1905
      check_pterm = 1;
    }
  }
#line 1908
  compno = (OPJ_UINT32 )0;
  {
#line 1908
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1908
    if (! (compno < l_tile->numcomps)) {
#line 1908
      goto while_break;
    }
    {
#line 1909
    opj_t1_decode_cblks(p_tcd, & ret, l_tile_comp, l_tccp, p_manager, p_manager_mutex,
                        check_pterm);
    }
#line 1911
    if (! ret) {
#line 1912
      goto while_break;
    }
#line 1914
    l_tile_comp ++;
#line 1915
    l_tccp ++;
#line 1908
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1918
  opj_thread_pool_wait_completion(p_tcd->thread_pool, 0);
  }
#line 1919
  if (p_manager_mutex) {
    {
#line 1920
    opj_mutex_destroy(p_manager_mutex);
    }
  }
#line 1922
  return (ret);
}
}
#line 1926 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 1929
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1930
  l_tile_comp = l_tile->comps;
#line 1931
  l_tccp = (p_tcd->tcp)->tccps;
#line 1932
  l_img_comp = (p_tcd->image)->comps;
#line 1934
  compno = (OPJ_UINT32 )0;
  {
#line 1934
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1934
    if (! (compno < l_tile->numcomps)) {
#line 1934
      goto while_break;
    }
#line 1936
    if (l_tccp->qmfbid == 1U) {
      {
#line 1937
      __cil_tmp7 = opj_dwt_decode(p_tcd, l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 1937
      if (! __cil_tmp7) {
#line 1939
        return (0);
      }
    } else {
      {
#line 1942
      __cil_tmp8 = opj_dwt_decode_real(p_tcd, l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 1942
      if (! __cil_tmp8) {
#line 1944
        return (0);
      }
    }
#line 1948
    l_tile_comp ++;
#line 1949
    l_img_comp ++;
#line 1950
    l_tccp ++;
#line 1934
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1953
  return (1);
}
}
#line 1956 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcp_t *l_tcp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_UINT32 l_samples ;
  OPJ_UINT32 i ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_resolution_t *res_comp0 ;
  opj_tcd_resolution_t *res_comp1 ;
  opj_tcd_resolution_t *res_comp2 ;
  OPJ_SIZE_T l_res_samples ;
  OPJ_BYTE **l_data ;
  void *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 1958
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1959
  l_tcp = p_tcd->tcp;
#line 1960
  l_tile_comp = l_tile->comps;
#line 1963
  if (! l_tcp->mct) {
#line 1964
    return (1);
  }
#line 1967
  if (p_tcd->whole_tile_decoding) {
#line 1971
    l_samples = (OPJ_UINT32 )(((l_tile_comp->resolutions + (l_tile_comp->minimum_num_resolutions - 1U))->x1 - (l_tile_comp->resolutions + (l_tile_comp->minimum_num_resolutions - 1U))->x0) * ((l_tile_comp->resolutions + (l_tile_comp->minimum_num_resolutions - 1U))->y1 - (l_tile_comp->resolutions + (l_tile_comp->minimum_num_resolutions - 1U))->y0));
  } else {
#line 1978
    l_res = l_tile_comp->resolutions + ((p_tcd->image)->comps + 0)->resno_decoded;
#line 1979
    l_samples = (l_res->win_x1 - l_res->win_x0) * (l_res->win_y1 - l_res->win_y0);
  }
#line 1983
  if (l_tile->numcomps >= 3U) {
#line 1984
    res_comp0 = (l_tile->comps + 0)->resolutions + ((p_tcd->image)->comps + 0)->resno_decoded;
#line 1986
    res_comp1 = (l_tile->comps + 1)->resolutions + ((p_tcd->image)->comps + 1)->resno_decoded;
#line 1988
    res_comp2 = (l_tile->comps + 2)->resolutions + ((p_tcd->image)->comps + 2)->resno_decoded;
#line 1990
    l_res_samples = (OPJ_SIZE_T )(res_comp0->x1 - res_comp0->x0) * (OPJ_SIZE_T )(res_comp0->y1 - res_comp0->y0);
#line 1993
    if (((p_tcd->image)->comps + 0)->resno_decoded != ((p_tcd->image)->comps + 1)->resno_decoded) {
      {
#line 2001
      opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
      }
#line 2003
      return (0);
    } else
#line 1993
    if (((p_tcd->image)->comps + 0)->resno_decoded != ((p_tcd->image)->comps + 2)->resno_decoded) {
      {
#line 2001
      opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
      }
#line 2003
      return (0);
    } else
#line 1993
    if ((OPJ_SIZE_T )(res_comp1->x1 - res_comp1->x0) * (OPJ_SIZE_T )(res_comp1->y1 - res_comp1->y0) != l_res_samples) {
      {
#line 2001
      opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
      }
#line 2003
      return (0);
    } else
#line 1993
    if ((OPJ_SIZE_T )(res_comp2->x1 - res_comp2->x0) * (OPJ_SIZE_T )(res_comp2->y1 - res_comp2->y0) != l_res_samples) {
      {
#line 2001
      opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
      }
#line 2003
      return (0);
    } else
#line 2004
    if (l_tcp->mct == 2U) {
#line 2007
      if (! l_tcp->m_mct_decoding_matrix) {
#line 2008
        return (1);
      }
      {
#line 2011
      __cil_tmp14 = opj_malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 2011
      l_data = (OPJ_BYTE **)__cil_tmp14;
      }
#line 2012
      if (! l_data) {
#line 2013
        return (0);
      }
#line 2016
      i = (OPJ_UINT32 )0;
      {
#line 2016
      while (1) {
        while_continue: /* CIL Label */ ;

#line 2016
        if (! (i < l_tile->numcomps)) {
#line 2016
          goto while_break;
        }
#line 2017
        if (p_tcd->whole_tile_decoding) {
#line 2018
          *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
        } else {
#line 2020
          *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data_win;
        }
#line 2022
        l_tile_comp ++;
#line 2016
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 2025
      __cil_tmp15 = opj_mct_decode_custom((OPJ_BYTE *)l_tcp->m_mct_decoding_matrix,
                                          (OPJ_SIZE_T )l_samples, l_data, l_tile->numcomps,
                                          ((p_tcd->image)->comps)->sgnd);
      }
#line 2025
      if (! __cil_tmp15) {
        {
#line 2035
        opj_free((void *)l_data);
        }
#line 2036
        return (0);
      }
      {
#line 2039
      opj_free((void *)l_data);
      }
    } else
#line 2041
    if ((l_tcp->tccps)->qmfbid == 1U) {
#line 2042
      if (p_tcd->whole_tile_decoding) {
        {
#line 2043
        opj_mct_decode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                       (OPJ_SIZE_T )l_samples);
        }
      } else {
        {
#line 2048
        opj_mct_decode((l_tile->comps + 0)->data_win, (l_tile->comps + 1)->data_win,
                       (l_tile->comps + 2)->data_win, (OPJ_SIZE_T )l_samples);
        }
      }
    } else
#line 2054
    if (p_tcd->whole_tile_decoding) {
      {
#line 2055
      opj_mct_decode_real((OPJ_FLOAT32 *)(l_tile->comps + 0)->data, (OPJ_FLOAT32 *)(l_tile->comps + 1)->data,
                          (OPJ_FLOAT32 *)(l_tile->comps + 2)->data, (OPJ_SIZE_T )l_samples);
      }
    } else {
      {
#line 2060
      opj_mct_decode_real((OPJ_FLOAT32 *)(l_tile->comps + 0)->data_win, (OPJ_FLOAT32 *)(l_tile->comps + 1)->data_win,
                          (OPJ_FLOAT32 *)(l_tile->comps + 2)->data_win, (OPJ_SIZE_T )l_samples);
      }
    }
  } else {
    {
#line 2068
    opj_event_msg(p_manager, 1, "Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n",
                  l_tile->numcomps);
    }
  }
#line 2073
  return (1);
}
}
#line 2077 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_tile_t *l_tile ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_INT32 *l_current_ptr ;
  OPJ_INT32 l_min ;
  OPJ_INT32 l_max ;
  OPJ_UINT32 l_stride ;
  OPJ_FLOAT32 l_value ;
  OPJ_INT64 l_value_int ;
  long __cil_tmp20 ;
  OPJ_INT64 __cil_tmp21 ;

  {
#line 2080
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 2081
  l_tccp = (opj_tccp_t *)0;
#line 2082
  l_img_comp = (opj_image_comp_t *)0;
#line 2083
  l_res = (opj_tcd_resolution_t *)0;
#line 2090
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2091
  l_tile_comp = l_tile->comps;
#line 2092
  l_tccp = (p_tcd->tcp)->tccps;
#line 2093
  l_img_comp = (p_tcd->image)->comps;
#line 2095
  compno = (OPJ_UINT32 )0;
  {
#line 2095
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2095
    if (! (compno < l_tile->numcomps)) {
#line 2095
      goto while_break;
    }
#line 2096
    l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;
#line 2098
    if (! p_tcd->whole_tile_decoding) {
#line 2099
      l_width = l_res->win_x1 - l_res->win_x0;
#line 2100
      l_height = l_res->win_y1 - l_res->win_y0;
#line 2101
      l_stride = (OPJ_UINT32 )0;
#line 2102
      l_current_ptr = l_tile_comp->data_win;
    } else {
#line 2104
      l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 2105
      l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 2106
      l_stride = (OPJ_UINT32 )((l_tile_comp->resolutions + (l_tile_comp->minimum_num_resolutions - 1U))->x1 - (l_tile_comp->resolutions + (l_tile_comp->minimum_num_resolutions - 1U))->x0) - l_width;
#line 2110
      l_current_ptr = l_tile_comp->data;
    }
#line 2116
    if (l_img_comp->sgnd) {
#line 2117
      l_min = - (1 << (l_img_comp->prec - 1U));
#line 2118
      l_max = (1 << (l_img_comp->prec - 1U)) - 1;
    } else {
#line 2120
      l_min = 0;
#line 2121
      l_max = (OPJ_INT32 )((1U << l_img_comp->prec) - 1U);
    }
#line 2125
    if (l_tccp->qmfbid == 1U) {
#line 2126
      j = (OPJ_UINT32 )0;
      {
#line 2126
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 2126
        if (! (j < l_height)) {
#line 2126
          goto while_break___0;
        }
#line 2127
        i = (OPJ_UINT32 )0;
        {
#line 2127
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 2127
          if (! (i < l_width)) {
#line 2127
            goto while_break___1;
          }
          {
#line 2129
          *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift,
                                         l_min, l_max);
#line 2131
          l_current_ptr ++;
#line 2127
          i ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: 
#line 2133
        l_current_ptr += l_stride;
#line 2126
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 2136
      j = (OPJ_UINT32 )0;
      {
#line 2136
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 2136
        if (! (j < l_height)) {
#line 2136
          goto while_break___2;
        }
#line 2137
        i = (OPJ_UINT32 )0;
        {
#line 2137
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 2137
          if (! (i < l_width)) {
#line 2137
            goto while_break___3;
          }
#line 2138
          l_value = *((OPJ_FLOAT32 *)l_current_ptr);
#line 2139
          if (l_value > (float )2147483647) {
#line 2140
            *l_current_ptr = l_max;
          } else
#line 2141
          if (l_value < (float )(-0x7FFFFFFF-1)) {
#line 2142
            *l_current_ptr = l_min;
          } else {
            {
#line 2145
            __cil_tmp20 = opj_lrintf(l_value);
#line 2145
            l_value_int = __cil_tmp20;
#line 2146
            __cil_tmp21 = opj_int64_clamp(l_value_int + (long )l_tccp->m_dc_level_shift,
                                          (OPJ_INT64 )l_min, (OPJ_INT64 )l_max);
#line 2146
            *l_current_ptr = (OPJ_INT32 )__cil_tmp21;
            }
          }
#line 2149
          l_current_ptr ++;
#line 2137
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: 
#line 2151
        l_current_ptr += l_stride;
#line 2136
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 2155
    l_img_comp ++;
#line 2156
    l_tccp ++;
#line 2157
    l_tile_comp ++;
#line 2095
    compno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 2160
  return (1);
}
}
#line 2168 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_dec_t *l_code_block ;

  {
#line 2172
  l_code_block = p_precinct->cblks.dec;
#line 2173
  if (l_code_block) {
#line 2180
    l_nb_code_blocks = (OPJ_UINT32 )((unsigned long )p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t ));
#line 2183
    cblkno = (OPJ_UINT32 )0;
    {
#line 2183
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2183
      if (! (cblkno < l_nb_code_blocks)) {
#line 2183
        goto while_break;
      }
#line 2185
      if (l_code_block->segs) {
        {
#line 2186
        opj_free((void *)l_code_block->segs);
#line 2187
        l_code_block->segs = (opj_tcd_seg_t *)0;
        }
      }
#line 2190
      if (l_code_block->chunks) {
        {
#line 2191
        opj_free((void *)l_code_block->chunks);
#line 2192
        l_code_block->chunks = (opj_tcd_seg_data_chunk_t *)0;
        }
      }
      {
#line 2195
      opj_aligned_free((void *)l_code_block->decoded_data);
#line 2196
      l_code_block->decoded_data = (OPJ_INT32 *)((void *)0);
#line 2198
      l_code_block ++;
#line 2183
      cblkno ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 2201
    opj_free((void *)p_precinct->cblks.dec);
#line 2202
    p_precinct->cblks.dec = (opj_tcd_cblk_dec_t *)0;
    }
  }
#line 2205
  return;
}
}
#line 2209 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_enc_t *l_code_block ;

  {
#line 2213
  l_code_block = p_precinct->cblks.enc;
#line 2214
  if (l_code_block) {
#line 2215
    l_nb_code_blocks = (OPJ_UINT32 )((unsigned long )p_precinct->block_size / sizeof(opj_tcd_cblk_enc_t ));
#line 2217
    cblkno = (OPJ_UINT32 )0;
    {
#line 2217
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2217
      if (! (cblkno < l_nb_code_blocks)) {
#line 2217
        goto while_break;
      }
#line 2218
      if (l_code_block->data) {
        {
#line 2221
        opj_free((void *)(l_code_block->data - 1));
#line 2222
        l_code_block->data = (OPJ_BYTE *)0;
        }
      }
#line 2225
      if (l_code_block->layers) {
        {
#line 2226
        opj_free((void *)l_code_block->layers);
#line 2227
        l_code_block->layers = (opj_tcd_layer_t *)0;
        }
      }
#line 2230
      if (l_code_block->passes) {
        {
#line 2231
        opj_free((void *)l_code_block->passes);
#line 2232
        l_code_block->passes = (opj_tcd_pass_t *)0;
        }
      }
#line 2234
      l_code_block ++;
#line 2217
      cblkno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 2237
    opj_free((void *)p_precinct->cblks.enc);
#line 2239
    p_precinct->cblks.enc = (opj_tcd_cblk_enc_t *)0;
    }
  }
#line 2242
  return;
}
}
#line 2243 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_SIZE_T opj_tcd_get_encoded_tile_size(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 i ;
  OPJ_SIZE_T l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;

  {
#line 2246
  l_data_size = (OPJ_SIZE_T )0;
#line 2247
  l_img_comp = (opj_image_comp_t *)0;
#line 2248
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 2251
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 2252
  l_img_comp = (p_tcd->image)->comps;
#line 2253
  i = (OPJ_UINT32 )0;
  {
#line 2253
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2253
    if (! (i < (p_tcd->image)->numcomps)) {
#line 2253
      goto while_break;
    }
#line 2254
    l_size_comp = l_img_comp->prec >> 3;
#line 2255
    l_remaining = l_img_comp->prec & 7U;
#line 2257
    if (l_remaining) {
#line 2258
      l_size_comp ++;
    }
#line 2261
    if (l_size_comp == 3U) {
#line 2262
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 2265
    l_data_size += (unsigned long )l_size_comp * ((OPJ_SIZE_T )(l_tilec->x1 - l_tilec->x0) * (OPJ_SIZE_T )(l_tilec->y1 - l_tilec->y0));
#line 2267
    l_img_comp ++;
#line 2268
    l_tilec ++;
#line 2253
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2271
  return (l_data_size);
}
}
#line 2274 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tile_t *l_tile ;
  OPJ_SIZE_T l_nb_elem ;
  OPJ_SIZE_T i ;
  OPJ_INT32 *l_current_ptr ;

  {
#line 2277
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 2278
  l_tccp = (opj_tccp_t *)0;
#line 2279
  l_img_comp = (opj_image_comp_t *)0;
#line 2284
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2285
  l_tile_comp = l_tile->comps;
#line 2286
  l_tccp = (p_tcd->tcp)->tccps;
#line 2287
  l_img_comp = (p_tcd->image)->comps;
#line 2289
  compno = (OPJ_UINT32 )0;
  {
#line 2289
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2289
    if (! (compno < l_tile->numcomps)) {
#line 2289
      goto while_break;
    }
#line 2290
    l_current_ptr = l_tile_comp->data;
#line 2291
    l_nb_elem = (OPJ_SIZE_T )(l_tile_comp->x1 - l_tile_comp->x0) * (OPJ_SIZE_T )(l_tile_comp->y1 - l_tile_comp->y0);
#line 2294
    if (l_tccp->qmfbid == 1U) {
#line 2295
      i = (OPJ_SIZE_T )0;
      {
#line 2295
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 2295
        if (! (i < l_nb_elem)) {
#line 2295
          goto while_break___0;
        }
#line 2296
        *l_current_ptr -= l_tccp->m_dc_level_shift;
#line 2297
        l_current_ptr ++;
#line 2295
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 2300
      i = (OPJ_SIZE_T )0;
      {
#line 2300
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2300
        if (! (i < l_nb_elem)) {
#line 2300
          goto while_break___1;
        }
#line 2301
        *l_current_ptr = (*l_current_ptr - l_tccp->m_dc_level_shift) * (1 << 11);
#line 2302
        l_current_ptr ++;
#line 2300
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 2306
    l_img_comp ++;
#line 2307
    l_tccp ++;
#line 2308
    l_tile_comp ++;
#line 2289
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 2311
  return (1);
}
}
#line 2314 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_SIZE_T samples ;
  OPJ_UINT32 i ;
  OPJ_BYTE **l_data ;
  opj_tcp_t *l_tcp ;
  void *__cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 2316
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2317
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 2318
  samples = (OPJ_SIZE_T )(l_tile_comp->x1 - l_tile_comp->x0) * (OPJ_SIZE_T )(l_tile_comp->y1 - l_tile_comp->y0);
#line 2321
  l_data = (OPJ_BYTE **)0;
#line 2322
  l_tcp = p_tcd->tcp;
#line 2324
  if (! (p_tcd->tcp)->mct) {
#line 2325
    return (1);
  }
#line 2328
  if ((p_tcd->tcp)->mct == 2U) {
#line 2329
    if (! (p_tcd->tcp)->m_mct_coding_matrix) {
#line 2330
      return (1);
    }
    {
#line 2333
    __cil_tmp8 = opj_malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 2333
    l_data = (OPJ_BYTE **)__cil_tmp8;
    }
#line 2334
    if (! l_data) {
#line 2335
      return (0);
    }
#line 2338
    i = (OPJ_UINT32 )0;
    {
#line 2338
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2338
      if (! (i < l_tile->numcomps)) {
#line 2338
        goto while_break;
      }
#line 2339
      *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
#line 2340
      l_tile_comp ++;
#line 2338
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 2343
    __cil_tmp9 = opj_mct_encode_custom((OPJ_BYTE *)(p_tcd->tcp)->m_mct_coding_matrix,
                                       samples, l_data, l_tile->numcomps, ((p_tcd->image)->comps)->sgnd);
    }
#line 2343
    if (! __cil_tmp9) {
      {
#line 2353
      opj_free((void *)l_data);
      }
#line 2354
      return (0);
    }
    {
#line 2357
    opj_free((void *)l_data);
    }
  } else
#line 2358
  if ((l_tcp->tccps)->qmfbid == 0U) {
    {
#line 2359
    opj_mct_encode_real((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                        samples);
    }
  } else {
    {
#line 2362
    opj_mct_encode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                   samples);
    }
  }
#line 2366
  return (1);
}
}
#line 2369 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 2371
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2372
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 2373
  l_tccp = (p_tcd->tcp)->tccps;
#line 2376
  compno = (OPJ_UINT32 )0;
  {
#line 2376
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2376
    if (! (compno < l_tile->numcomps)) {
#line 2376
      goto while_break;
    }
#line 2377
    if (l_tccp->qmfbid == 1U) {
      {
#line 2378
      __cil_tmp6 = opj_dwt_encode(l_tile_comp);
      }
#line 2378
      if (! __cil_tmp6) {
#line 2379
        return (0);
      }
    } else
#line 2381
    if (l_tccp->qmfbid == 0U) {
      {
#line 2382
      __cil_tmp7 = opj_dwt_encode_real(l_tile_comp);
      }
#line 2382
      if (! __cil_tmp7) {
#line 2383
        return (0);
      }
    }
#line 2387
    l_tile_comp ++;
#line 2388
    l_tccp ++;
#line 2376
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2391
  return (1);
}
}
#line 2394 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_t1_t *l_t1 ;
  OPJ_FLOAT64 *l_mct_norms ;
  OPJ_UINT32 l_mct_numcomps ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 2398
  l_mct_numcomps = 0U;
#line 2399
  l_tcp = p_tcd->tcp;
#line 2401
  l_t1 = opj_t1_create(1);
  }
#line 2402
  if ((unsigned long )l_t1 == (unsigned long )((opj_t1_t *)0)) {
#line 2403
    return (0);
  }
#line 2406
  if (l_tcp->mct == 1U) {
#line 2407
    l_mct_numcomps = 3U;
#line 2409
    if ((l_tcp->tccps)->qmfbid == 0U) {
      {
#line 2410
      l_mct_norms = opj_mct_get_mct_norms_real();
      }
    } else {
      {
#line 2412
      l_mct_norms = opj_mct_get_mct_norms();
      }
    }
  } else {
#line 2415
    l_mct_numcomps = (p_tcd->image)->numcomps;
#line 2416
    l_mct_norms = l_tcp->mct_norms;
  }
  {
#line 2419
  __cil_tmp9 = opj_t1_encode_cblks(l_t1, (p_tcd->tcd_image)->tiles, l_tcp, l_mct_norms,
                                   l_mct_numcomps);
  }
#line 2419
  if (! __cil_tmp9) {
    {
#line 2421
    opj_t1_destroy(l_t1);
    }
#line 2422
    return (0);
  }
  {
#line 2425
  opj_t1_destroy(l_t1);
  }
#line 2427
  return (1);
}
}
#line 2430 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                                  OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  opj_t2_t *l_t2 ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 2439
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 2440
  if ((unsigned long )l_t2 == (unsigned long )((opj_t2_t *)0)) {
#line 2441
    return (0);
  }
  {
#line 2444
  __cil_tmp9 = opj_t2_encode_packets(l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                     (p_tcd->tcp)->numlayers, p_dest_data, p_data_written,
                                     p_max_dest_size, p_cstr_info, p_tcd->tp_num,
                                     p_tcd->tp_pos, p_tcd->cur_pino, (J2K_T2_MODE )1,
                                     p_manager);
  }
#line 2444
  if (! __cil_tmp9) {
    {
#line 2458
    opj_t2_destroy(l_t2);
    }
#line 2459
    return (0);
  }
  {
#line 2462
  opj_t2_destroy(l_t2);
  }
#line 2465
  return (1);
}
}
#line 2469 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data ,
                                             OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                             opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_nb_written ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 2475
  l_cp = p_tcd->cp;
#line 2476
  l_nb_written = (OPJ_UINT32 )0;
#line 2478
  if (p_cstr_info) {
#line 2479
    p_cstr_info->index_write = 0;
  }
#line 2482
  if ((int )l_cp->m_specific_param.m_enc.m_disto_alloc) {
    _L: 
    {
#line 2486
    __cil_tmp8 = opj_tcd_rateallocate(p_tcd, p_dest_data, & l_nb_written, p_max_dest_size,
                                      p_cstr_info, p_manager);
    }
#line 2486
    if (! __cil_tmp8) {
#line 2488
      return (0);
    }
  } else
#line 2482
  if ((int )l_cp->m_specific_param.m_enc.m_fixed_quality) {
#line 2482
    goto _L;
  } else {
    {
#line 2492
    opj_tcd_rateallocate_fixed(p_tcd);
    }
  }
#line 2495
  return (1);
}
}
#line 2499 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_SIZE_T p_src_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_SIZE_T j ;
  OPJ_SIZE_T l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_SIZE_T l_nb_elem ;
  OPJ_CHAR *l_src_ptr ;
  OPJ_INT32 *l_dest_ptr ;
  OPJ_INT32 *__cil_tmp15 ;
  OPJ_CHAR *__cil_tmp16 ;
  OPJ_INT32 *__cil_tmp17 ;
  OPJ_CHAR *__cil_tmp18 ;
  OPJ_INT32 *l_dest_ptr___0 ;
  OPJ_INT16 *l_src_ptr___0 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_INT16 *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT16 *__cil_tmp24 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp27 ;
  OPJ_INT32 *__cil_tmp28 ;

  {
  {
#line 2505
  l_data_size = (OPJ_SIZE_T )0;
#line 2506
  l_img_comp = (opj_image_comp_t *)0;
#line 2507
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 2511
  l_data_size = opj_tcd_get_encoded_tile_size(p_tcd);
  }
#line 2512
  if (l_data_size != p_src_length) {
#line 2513
    return (0);
  }
#line 2516
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 2517
  l_img_comp = (p_tcd->image)->comps;
#line 2518
  i = (OPJ_UINT32 )0;
  {
#line 2518
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2518
    if (! (i < (p_tcd->image)->numcomps)) {
#line 2518
      goto while_break;
    }
#line 2519
    l_size_comp = l_img_comp->prec >> 3;
#line 2520
    l_remaining = l_img_comp->prec & 7U;
#line 2521
    l_nb_elem = (OPJ_SIZE_T )(l_tilec->x1 - l_tilec->x0) * (OPJ_SIZE_T )(l_tilec->y1 - l_tilec->y0);
#line 2524
    if (l_remaining) {
#line 2525
      l_size_comp ++;
    }
#line 2528
    if (l_size_comp == 3U) {
#line 2529
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 2533
    if (l_size_comp == 1U) {
#line 2533
      goto case_1;
    }
#line 2550
    if (l_size_comp == 2U) {
#line 2550
      goto case_2;
    }
#line 2567
    if (l_size_comp == 4U) {
#line 2567
      goto case_4;
    }
#line 2532
    goto switch_break;
    case_1: 
#line 2534
    l_src_ptr = (OPJ_CHAR *)p_src;
#line 2535
    l_dest_ptr = l_tilec->data;
#line 2537
    if (l_img_comp->sgnd) {
#line 2538
      j = (OPJ_SIZE_T )0;
      {
#line 2538
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 2538
        if (! (j < l_nb_elem)) {
#line 2538
          goto while_break___0;
        }
#line 2539
        __cil_tmp16 = l_src_ptr;
#line 2539
        l_src_ptr ++;
#line 2539
        __cil_tmp15 = l_dest_ptr;
#line 2539
        l_dest_ptr ++;
#line 2539
        *__cil_tmp15 = (OPJ_INT32 )*__cil_tmp16;
#line 2538
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 2542
      j = (OPJ_SIZE_T )0;
      {
#line 2542
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2542
        if (! (j < l_nb_elem)) {
#line 2542
          goto while_break___1;
        }
#line 2543
        __cil_tmp18 = l_src_ptr;
#line 2543
        l_src_ptr ++;
#line 2543
        __cil_tmp17 = l_dest_ptr;
#line 2543
        l_dest_ptr ++;
#line 2543
        *__cil_tmp17 = (int )*__cil_tmp18 & 255;
#line 2542
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 2547
    p_src = (OPJ_BYTE *)l_src_ptr;
#line 2549
    goto switch_break;
    case_2: 
#line 2551
    l_dest_ptr___0 = l_tilec->data;
#line 2552
    l_src_ptr___0 = (OPJ_INT16 *)p_src;
#line 2554
    if (l_img_comp->sgnd) {
#line 2555
      j = (OPJ_SIZE_T )0;
      {
#line 2555
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 2555
        if (! (j < l_nb_elem)) {
#line 2555
          goto while_break___2;
        }
#line 2556
        __cil_tmp22 = l_src_ptr___0;
#line 2556
        l_src_ptr___0 ++;
#line 2556
        __cil_tmp21 = l_dest_ptr___0;
#line 2556
        l_dest_ptr___0 ++;
#line 2556
        *__cil_tmp21 = (OPJ_INT32 )*__cil_tmp22;
#line 2555
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: ;
    } else {
#line 2559
      j = (OPJ_SIZE_T )0;
      {
#line 2559
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 2559
        if (! (j < l_nb_elem)) {
#line 2559
          goto while_break___3;
        }
#line 2560
        __cil_tmp24 = l_src_ptr___0;
#line 2560
        l_src_ptr___0 ++;
#line 2560
        __cil_tmp23 = l_dest_ptr___0;
#line 2560
        l_dest_ptr___0 ++;
#line 2560
        *__cil_tmp23 = (int )*__cil_tmp24 & 65535;
#line 2559
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: ;
    }
#line 2564
    p_src = (OPJ_BYTE *)l_src_ptr___0;
#line 2566
    goto switch_break;
    case_4: 
#line 2568
    l_src_ptr___1 = (OPJ_INT32 *)p_src;
#line 2569
    l_dest_ptr___1 = l_tilec->data;
#line 2571
    j = (OPJ_SIZE_T )0;
    {
#line 2571
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 2571
      if (! (j < l_nb_elem)) {
#line 2571
        goto while_break___4;
      }
#line 2572
      __cil_tmp28 = l_src_ptr___1;
#line 2572
      l_src_ptr___1 ++;
#line 2572
      __cil_tmp27 = l_dest_ptr___1;
#line 2572
      l_dest_ptr___1 ++;
#line 2572
      *__cil_tmp27 = *__cil_tmp28;
#line 2571
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: 
#line 2575
    p_src = (OPJ_BYTE *)l_src_ptr___1;
#line 2577
    goto switch_break;
    switch_break: 
#line 2580
    l_img_comp ++;
#line 2581
    l_tilec ++;
#line 2518
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 2584
  return (1);
}
}
#line 2587 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_is_band_empty(opj_tcd_band_t *band ) 
{ 
  int tmp ;

  {
#line 2589
  if (band->x1 - band->x0 == 0) {
#line 2589
    tmp = 1;
  } else
#line 2589
  if (band->y1 - band->y0 == 0) {
#line 2589
    tmp = 1;
  } else {
#line 2589
    tmp = 0;
  }
#line 2589
  return (tmp);
}
}
#line 2592 "/root/patron/new_24/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_is_subband_area_of_interest(opj_tcd_t *tcd , OPJ_UINT32 compno ,
                                             OPJ_UINT32 resno , OPJ_UINT32 bandno ,
                                             OPJ_UINT32 band_x0 , OPJ_UINT32 band_y0 ,
                                             OPJ_UINT32 band_x1 , OPJ_UINT32 band_y1 ) 
{ 
  OPJ_UINT32 filter_margin ;
  int tmp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 tcx0 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 tcy0 ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT32 __cil_tmp18 ;
  OPJ_UINT32 tcx1 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_UINT32 __cil_tmp21 ;
  OPJ_UINT32 tcy1 ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 nb ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 x0b ;
  OPJ_UINT32 y0b ;
  OPJ_UINT32 tbx0 ;
  OPJ_UINT32 __cil_tmp30 ;
  unsigned int tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  OPJ_UINT32 tby0 ;
  OPJ_UINT32 __cil_tmp34 ;
  unsigned int tmp___3 ;
  OPJ_UINT32 tmp___4 ;
  OPJ_UINT32 tbx1 ;
  OPJ_UINT32 __cil_tmp38 ;
  unsigned int tmp___5 ;
  OPJ_UINT32 tmp___6 ;
  OPJ_UINT32 tby1 ;
  OPJ_UINT32 __cil_tmp42 ;
  unsigned int tmp___7 ;
  OPJ_UINT32 tmp___8 ;
  OPJ_BOOL intersects ;
  int tmp___9 ;

  {
#line 2609
  if (((tcd->tcp)->tccps + compno)->qmfbid == 1U) {
#line 2609
    tmp = 2;
  } else {
#line 2609
    tmp = 3;
  }
  {
#line 2609
  filter_margin = (OPJ_UINT32 )tmp;
#line 2610
  tilec = ((tcd->tcd_image)->tiles)->comps + compno;
#line 2611
  image_comp = (tcd->image)->comps + compno;
#line 2614
  __cil_tmp14 = opj_uint_ceildiv(tcd->win_x0, image_comp->dx);
#line 2614
  __cil_tmp15 = opj_uint_max((OPJ_UINT32 )tilec->x0, __cil_tmp14);
#line 2614
  tcx0 = __cil_tmp15;
#line 2617
  __cil_tmp17 = opj_uint_ceildiv(tcd->win_y0, image_comp->dy);
#line 2617
  __cil_tmp18 = opj_uint_max((OPJ_UINT32 )tilec->y0, __cil_tmp17);
#line 2617
  tcy0 = __cil_tmp18;
#line 2620
  __cil_tmp20 = opj_uint_ceildiv(tcd->win_x1, image_comp->dx);
#line 2620
  __cil_tmp21 = opj_uint_min((OPJ_UINT32 )tilec->x1, __cil_tmp20);
#line 2620
  tcx1 = __cil_tmp21;
#line 2623
  __cil_tmp23 = opj_uint_ceildiv(tcd->win_y1, image_comp->dy);
#line 2623
  __cil_tmp24 = opj_uint_min((OPJ_UINT32 )tilec->y1, __cil_tmp23);
#line 2623
  tcy1 = __cil_tmp24;
  }
#line 2627
  if (resno == 0U) {
#line 2627
    tmp___0 = tilec->numresolutions - 1U;
  } else {
#line 2627
    tmp___0 = tilec->numresolutions - resno;
  }
#line 2627
  nb = tmp___0;
#line 2632
  x0b = bandno & 1U;
#line 2633
  y0b = bandno >> 1;
#line 2634
  if (nb == 0U) {
#line 2634
    tmp___2 = tcx0;
  } else {
#line 2634
    if (tcx0 <= (1U << (nb - 1U)) * x0b) {
#line 2634
      tmp___1 = 0U;
    } else {
      {
#line 2634
      __cil_tmp30 = opj_uint_ceildivpow2(tcx0 - (1U << (nb - 1U)) * x0b, nb);
#line 2634
      tmp___1 = __cil_tmp30;
      }
    }
#line 2634
    tmp___2 = tmp___1;
  }
#line 2634
  tbx0 = tmp___2;
#line 2637
  if (nb == 0U) {
#line 2637
    tmp___4 = tcy0;
  } else {
#line 2637
    if (tcy0 <= (1U << (nb - 1U)) * y0b) {
#line 2637
      tmp___3 = 0U;
    } else {
      {
#line 2637
      __cil_tmp34 = opj_uint_ceildivpow2(tcy0 - (1U << (nb - 1U)) * y0b, nb);
#line 2637
      tmp___3 = __cil_tmp34;
      }
    }
#line 2637
    tmp___4 = tmp___3;
  }
#line 2637
  tby0 = tmp___4;
#line 2640
  if (nb == 0U) {
#line 2640
    tmp___6 = tcx1;
  } else {
#line 2640
    if (tcx1 <= (1U << (nb - 1U)) * x0b) {
#line 2640
      tmp___5 = 0U;
    } else {
      {
#line 2640
      __cil_tmp38 = opj_uint_ceildivpow2(tcx1 - (1U << (nb - 1U)) * x0b, nb);
#line 2640
      tmp___5 = __cil_tmp38;
      }
    }
#line 2640
    tmp___6 = tmp___5;
  }
#line 2640
  tbx1 = tmp___6;
#line 2643
  if (nb == 0U) {
#line 2643
    tmp___8 = tcy1;
  } else {
#line 2643
    if (tcy1 <= (1U << (nb - 1U)) * y0b) {
#line 2643
      tmp___7 = 0U;
    } else {
      {
#line 2643
      __cil_tmp42 = opj_uint_ceildivpow2(tcy1 - (1U << (nb - 1U)) * y0b, nb);
#line 2643
      tmp___7 = __cil_tmp42;
      }
    }
#line 2643
    tmp___8 = tmp___7;
  }
#line 2643
  tby1 = tmp___8;
#line 2648
  if (tbx0 < filter_margin) {
#line 2649
    tbx0 = (OPJ_UINT32 )0;
  } else {
#line 2651
    tbx0 -= filter_margin;
  }
#line 2653
  if (tby0 < filter_margin) {
#line 2654
    tby0 = (OPJ_UINT32 )0;
  } else {
#line 2656
    tby0 -= filter_margin;
  }
  {
#line 2658
  tbx1 = opj_uint_adds(tbx1, filter_margin);
#line 2659
  tby1 = opj_uint_adds(tby1, filter_margin);
  }
#line 2661
  if (band_x0 < tbx1) {
#line 2661
    if (band_y0 < tby1) {
#line 2661
      if (band_x1 > tbx0) {
#line 2661
        if (band_y1 > tby0) {
#line 2661
          tmp___9 = 1;
        } else {
#line 2661
          tmp___9 = 0;
        }
      } else {
#line 2661
        tmp___9 = 0;
      }
    } else {
#line 2661
      tmp___9 = 0;
    }
  } else {
#line 2661
    tmp___9 = 0;
  }
#line 2661
  intersects = tmp___9;
#line 2670
  return (intersects);
}
}
#line 2680 "/root/patron/new_24/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_is_whole_tilecomp_decoding(opj_tcd_t *p_tcd , OPJ_UINT32 compno ) 
{ 
  opj_tcd_tilecomp_t *tilec ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 tcx0 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 tcy0 ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_UINT32 tcx1 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 tcy1 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 __cil_tmp16 ;
  OPJ_UINT32 shift ;
  int tmp ;

  {
  {
#line 2683
  tilec = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 2684
  image_comp = (p_tcd->image)->comps + compno;
#line 2687
  __cil_tmp6 = opj_uint_ceildiv(p_tcd->win_x0, image_comp->dx);
#line 2687
  __cil_tmp7 = opj_uint_max((OPJ_UINT32 )tilec->x0, __cil_tmp6);
#line 2687
  tcx0 = __cil_tmp7;
#line 2690
  __cil_tmp9 = opj_uint_ceildiv(p_tcd->win_y0, image_comp->dy);
#line 2690
  __cil_tmp10 = opj_uint_max((OPJ_UINT32 )tilec->y0, __cil_tmp9);
#line 2690
  tcy0 = __cil_tmp10;
#line 2693
  __cil_tmp12 = opj_uint_ceildiv(p_tcd->win_x1, image_comp->dx);
#line 2693
  __cil_tmp13 = opj_uint_min((OPJ_UINT32 )tilec->x1, __cil_tmp12);
#line 2693
  tcx1 = __cil_tmp13;
#line 2696
  __cil_tmp15 = opj_uint_ceildiv(p_tcd->win_y1, image_comp->dy);
#line 2696
  __cil_tmp16 = opj_uint_min((OPJ_UINT32 )tilec->y1, __cil_tmp15);
#line 2696
  tcy1 = __cil_tmp16;
#line 2700
  shift = tilec->numresolutions - tilec->minimum_num_resolutions;
  }
#line 2703
  if (tcx0 >= (OPJ_UINT32 )tilec->x0) {
#line 2703
    if (tcy0 >= (OPJ_UINT32 )tilec->y0) {
#line 2703
      if (tcx1 <= (OPJ_UINT32 )tilec->x1) {
#line 2703
        if (tcy1 <= (OPJ_UINT32 )tilec->y1) {
#line 2703
          if (shift >= 32U) {
#line 2703
            tmp = 1;
          } else
#line 2703
          if ((tcx0 - (OPJ_UINT32 )tilec->x0) >> shift == 0U) {
#line 2703
            if ((tcy0 - (OPJ_UINT32 )tilec->y0) >> shift == 0U) {
#line 2703
              if (((OPJ_UINT32 )tilec->x1 - tcx1) >> shift == 0U) {
#line 2703
                if (((OPJ_UINT32 )tilec->y1 - tcy1) >> shift == 0U) {
#line 2703
                  tmp = 1;
                } else {
#line 2703
                  tmp = 0;
                }
              } else {
#line 2703
                tmp = 0;
              }
            } else {
#line 2703
              tmp = 0;
            }
          } else {
#line 2703
            tmp = 0;
          }
        } else {
#line 2703
          tmp = 0;
        }
      } else {
#line 2703
        tmp = 0;
      }
    } else {
#line 2703
      tmp = 0;
    }
  } else {
#line 2703
    tmp = 0;
  }
#line 2703
  return (tmp);
}
}
#line 51 "/root/patron/new_24/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) ;
#line 53
static OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) ;
#line 59
static void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 60
static OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) ;
#line 76
static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                                     opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                                     OPJ_UINT32 length , opj_codestream_info_t *cstr_info ,
                                     J2K_T2_MODE p_t2_mode , opj_event_mgr_t *p_manager ) ;
#line 101
static OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                     opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                     OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                     opj_event_mgr_t *p_manager ) ;
#line 111
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                   opj_event_mgr_t *p_manager ) ;
#line 121
static OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                          opj_tcp_t *p_tcp , opj_pi_iterator_t *p_pi ,
                                          OPJ_BOOL *p_is_data_present , OPJ_BYTE *p_src_data ,
                                          OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                          opj_packet_info_t *p_pack_info , opj_event_mgr_t *p_manager ) ;
#line 132
static OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src_data ,
                                        OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                        opj_packet_info_t *pack_info , opj_event_mgr_t *p_manager ) ;
#line 141
static OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_UINT32 *p_data_read ,
                                        OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ,
                                        opj_event_mgr_t *p_manager ) ;
#line 155
static OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 ,
                                OPJ_UINT32 cblksty , OPJ_UINT32 first ) ;
#line 167 "/root/patron/new_24/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) 
{ 


  {
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    n --;
#line 169
    if (! (n >= 0)) {
#line 169
      goto while_break;
    }
    {
#line 170
    opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 172
  opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
  }
#line 174
  return;
}
}
#line 175 "/root/patron/new_24/src/lib/openjp2/t2.c"
static OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 177
  n = (OPJ_UINT32 )0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 178
    __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
    }
#line 178
    if (! __cil_tmp3) {
#line 178
      goto while_break;
    }
#line 179
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 181
  return (n);
}
}
#line 184 "/root/patron/new_24/src/lib/openjp2/t2.c"
static void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 


  {
#line 186
  if (n == 1U) {
    {
#line 187
    opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
    }
  } else
#line 188
  if (n == 2U) {
    {
#line 189
    opj_bio_write(bio, (OPJ_UINT32 )2, (OPJ_UINT32 )2);
    }
  } else
#line 190
  if (n <= 5U) {
    {
#line 191
    opj_bio_write(bio, 12U | (n - 3U), (OPJ_UINT32 )4);
    }
  } else
#line 192
  if (n <= 36U) {
    {
#line 193
    opj_bio_write(bio, 480U | (n - 6U), (OPJ_UINT32 )9);
    }
  } else
#line 194
  if (n <= 164U) {
    {
#line 195
    opj_bio_write(bio, 65408U | (n - 37U), (OPJ_UINT32 )16);
    }
  }
#line 198
  return;
}
}
#line 199 "/root/patron/new_24/src/lib/openjp2/t2.c"
static OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_UINT32 __cil_tmp4 ;
  OPJ_UINT32 __cil_tmp7 ;

  {
  {
#line 202
  __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 202
  if (! __cil_tmp3) {
#line 203
    return ((OPJ_UINT32 )1);
  }
  {
#line 205
  __cil_tmp4 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 205
  if (! __cil_tmp4) {
#line 206
    return ((OPJ_UINT32 )2);
  }
  {
#line 208
  n = opj_bio_read(bio, (OPJ_UINT32 )2);
  }
#line 208
  if (n != 3U) {
#line 209
    return (3U + n);
  }
  {
#line 211
  n = opj_bio_read(bio, (OPJ_UINT32 )5);
  }
#line 211
  if (n != 31U) {
#line 212
    return (6U + n);
  }
  {
#line 214
  __cil_tmp7 = opj_bio_read(bio, (OPJ_UINT32 )7);
  }
#line 214
  return (37U + __cil_tmp7);
}
}
#line 219 "/root/patron/new_24/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               OPJ_UINT32 p_tp_num , OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino ,
                               J2K_T2_MODE p_t2_mode , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 poc ;
  opj_pi_iterator_t *l_pi ;
  opj_pi_iterator_t *l_current_pi ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 pocno ;
  int tmp ;
  OPJ_UINT32 l_max_comp ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 l_nb_pocs ;
  OPJ_UINT32 l_comp_len ;
  OPJ_UINT32 l_tp_num ;
  OPJ_BOOL __cil_tmp31 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_BOOL __cil_tmp33 ;
  OPJ_BOOL __cil_tmp34 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  OPJ_OFF_T tmp___1 ;

  {
#line 233
  l_current_data = p_dest;
#line 234
  l_nb_bytes = (OPJ_UINT32 )0;
#line 237
  l_pi = (opj_pi_iterator_t *)0;
#line 238
  l_current_pi = (opj_pi_iterator_t *)0;
#line 239
  l_image = p_t2->image;
#line 240
  l_cp = p_t2->cp;
#line 241
  l_tcp = l_cp->tcps + p_tile_no;
#line 242
  if ((int )l_cp->rsiz == 4) {
#line 242
    tmp = 2;
  } else {
#line 242
    tmp = 1;
  }
#line 242
  pocno = (OPJ_UINT32 )tmp;
#line 243
  if (l_cp->m_specific_param.m_enc.m_max_comp_size > 0U) {
#line 243
    tmp___0 = l_image->numcomps;
  } else {
#line 243
    tmp___0 = 1U;
  }
  {
#line 243
  l_max_comp = tmp___0;
#line 245
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 247
  l_pi = opj_pi_initialise_encode(l_image, l_cp, p_tile_no, p_t2_mode);
  }
#line 248
  if (! l_pi) {
#line 249
    return (0);
  }
#line 252
  *p_data_written = (OPJ_UINT32 )0;
#line 254
  if ((unsigned int )p_t2_mode == 0U) {
#line 255
    l_current_pi = l_pi;
#line 257
    compno = (OPJ_UINT32 )0;
    {
#line 257
    while (1) {
      while_continue: /* CIL Label */ ;

#line 257
      if (! (compno < l_max_comp)) {
#line 257
        goto while_break;
      }
#line 258
      l_comp_len = (OPJ_UINT32 )0;
#line 259
      l_current_pi = l_pi;
#line 261
      poc = (OPJ_UINT32 )0;
      {
#line 261
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 261
        if (! (poc < pocno)) {
#line 261
          goto while_break___0;
        }
        {
#line 262
        l_tp_num = compno;
#line 265
        opj_pi_create_encode(l_pi, l_cp, p_tile_no, poc, l_tp_num, p_tp_pos, p_t2_mode);
        }
#line 267
        if ((int )l_current_pi->poc.prg == -1) {
          {
#line 269
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 270
          return (0);
        }
        {
#line 272
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 272
          __cil_tmp31 = opj_pi_next(l_current_pi);
          }
#line 272
          if (! __cil_tmp31) {
#line 272
            goto while_break___1;
          }
#line 273
          if (l_current_pi->layno < p_maxlayers) {
            {
#line 274
            l_nb_bytes = (OPJ_UINT32 )0;
#line 276
            __cil_tmp32 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                               l_current_data, & l_nb_bytes, p_max_len,
                                               cstr_info, p_t2_mode, p_manager);
            }
#line 276
            if (! __cil_tmp32) {
              {
#line 281
              opj_pi_destroy(l_pi, l_nb_pocs);
              }
#line 282
              return (0);
            }
#line 285
            l_comp_len += l_nb_bytes;
#line 286
            l_current_data += l_nb_bytes;
#line 287
            p_max_len -= l_nb_bytes;
#line 289
            *p_data_written += l_nb_bytes;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: ;
#line 293
        if (l_cp->m_specific_param.m_enc.m_max_comp_size) {
#line 294
          if (l_comp_len > l_cp->m_specific_param.m_enc.m_max_comp_size) {
            {
#line 295
            opj_pi_destroy(l_pi, l_nb_pocs);
            }
#line 296
            return (0);
          }
        }
#line 300
        l_current_pi ++;
#line 261
        poc ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
#line 257
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 304
    opj_pi_create_encode(l_pi, l_cp, p_tile_no, p_pino, p_tp_num, p_tp_pos, p_t2_mode);
#line 307
    l_current_pi = l_pi + p_pino;
    }
#line 308
    if ((int )l_current_pi->poc.prg == -1) {
      {
#line 310
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 311
      return (0);
    }
    {
#line 313
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 313
      __cil_tmp33 = opj_pi_next(l_current_pi);
      }
#line 313
      if (! __cil_tmp33) {
#line 313
        goto while_break___2;
      }
#line 314
      if (l_current_pi->layno < p_maxlayers) {
        {
#line 315
        l_nb_bytes = (OPJ_UINT32 )0;
#line 317
        __cil_tmp34 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                           l_current_data, & l_nb_bytes, p_max_len,
                                           cstr_info, p_t2_mode, p_manager);
        }
#line 317
        if (! __cil_tmp34) {
          {
#line 320
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 321
          return (0);
        }
#line 324
        l_current_data += l_nb_bytes;
#line 325
        p_max_len -= l_nb_bytes;
#line 327
        *p_data_written += l_nb_bytes;
#line 330
        if (cstr_info) {
#line 331
          if (cstr_info->index_write) {
#line 332
            info_TL = cstr_info->tile + p_tile_no;
#line 333
            info_PK = info_TL->packet + cstr_info->packno;
#line 334
            if (! cstr_info->packno) {
#line 335
              info_PK->start_pos = (OPJ_OFF_T )(info_TL->end_header + 1);
            } else {
#line 337
              if ((int )l_cp->m_specific_param.m_enc.m_tp_on | (int )l_tcp->POC) {
#line 337
                if (info_PK->start_pos) {
#line 337
                  tmp___1 = info_PK->start_pos;
                } else {
#line 337
                  tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1L;
                }
              } else {
#line 337
                tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1L;
              }
#line 337
              info_PK->start_pos = tmp___1;
            }
#line 341
            info_PK->end_pos = (info_PK->start_pos + (long )l_nb_bytes) - 1L;
#line 342
            info_PK->end_ph_pos += info_PK->start_pos - 1L;
          }
#line 347
          (cstr_info->packno) ++;
        }
#line 350
        (p_tile->packno) ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
  {
#line 355
  opj_pi_destroy(l_pi, l_nb_pocs);
  }
#line 357
  return (1);
}
}
#line 365 "/root/patron/new_24/src/lib/openjp2/t2.c"
static void opj_null_jas_fprintf(FILE *file , char const   *format  , ...) 
{ 


  {
#line 370
  return;
}
}
#line 373 "/root/patron/new_24/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_decode_packets(opj_tcd_t *tcd , opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no ,
                               opj_tcd_tile_t *p_tile , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                               OPJ_UINT32 p_max_len , opj_codestream_index_t *p_cstr_index ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  opj_pi_iterator_t *l_pi ;
  OPJ_UINT32 pino ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_pocs ;
  opj_pi_iterator_t *l_current_pi ;
  opj_packet_info_t *l_pack_info ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL *first_pass_failed ;
  void *__cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;
  OPJ_BOOL skip_packet ;
  OPJ_UINT32 bandno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  OPJ_BOOL __cil_tmp31 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_BOOL __cil_tmp34 ;

  {
  {
#line 383
  l_current_data = p_src;
#line 384
  l_pi = (opj_pi_iterator_t *)0;
#line 386
  l_image = p_t2->image;
#line 387
  l_cp = p_t2->cp;
#line 388
  l_tcp = (p_t2->cp)->tcps + p_tile_no;
#line 390
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 391
  l_current_pi = (opj_pi_iterator_t *)0;
#line 396
  l_pack_info = (opj_packet_info_t *)0;
#line 397
  l_img_comp = (opj_image_comp_t *)0;
#line 408
  l_pi = opj_pi_create_decode(l_image, l_cp, p_tile_no);
  }
#line 409
  if (! l_pi) {
#line 410
    return (0);
  }
#line 414
  l_current_pi = l_pi;
#line 416
  pino = (OPJ_UINT32 )0;
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;

#line 416
    if (! (pino <= l_tcp->numpocs)) {
#line 416
      goto while_break;
    }
#line 423
    first_pass_failed = (OPJ_BOOL *)((void *)0);
#line 425
    if ((int )l_current_pi->poc.prg == -1) {
      {
#line 427
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 428
      return (0);
    }
    {
#line 431
    __cil_tmp23 = opj_malloc((unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
#line 431
    first_pass_failed = (OPJ_BOOL *)__cil_tmp23;
    }
#line 432
    if (! first_pass_failed) {
      {
#line 433
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 434
      return (0);
    }
    {
#line 436
    memset((void *)first_pass_failed, 1, (unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
    }
    {
#line 438
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 438
      __cil_tmp24 = opj_pi_next(l_current_pi);
      }
#line 438
      if (! __cil_tmp24) {
#line 438
        goto while_break___0;
      }
      {
#line 439
      skip_packet = 0;
#line 440
      opj_null_jas_fprintf(stderr, "packet offset=00000166 prg=%d cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d\n\n",
                           (int )l_current_pi->poc.prg1, l_current_pi->compno, l_current_pi->resno,
                           l_current_pi->precno, l_current_pi->layno);
      }
#line 447
      if (l_current_pi->layno >= l_tcp->num_layers_to_decode) {
#line 448
        skip_packet = 1;
      } else
#line 452
      if (l_current_pi->resno >= (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions) {
#line 454
        skip_packet = 1;
      } else {
#line 459
        tilec = p_tile->comps + l_current_pi->compno;
#line 460
        res = tilec->resolutions + l_current_pi->resno;
#line 462
        skip_packet = 1;
#line 463
        bandno = (OPJ_UINT32 )0;
        {
#line 463
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 463
          if (! (bandno < res->numbands)) {
#line 463
            goto while_break___1;
          }
          {
#line 464
          band = & res->bands[bandno];
#line 465
          prec = band->precincts + l_current_pi->precno;
#line 467
          __cil_tmp31 = opj_tcd_is_subband_area_of_interest(tcd, l_current_pi->compno,
                                                            l_current_pi->resno, band->bandno,
                                                            (OPJ_UINT32 )prec->x0,
                                                            (OPJ_UINT32 )prec->y0,
                                                            (OPJ_UINT32 )prec->x1,
                                                            (OPJ_UINT32 )prec->y1);
          }
#line 467
          if (__cil_tmp31) {
#line 475
            skip_packet = 0;
#line 476
            goto while_break___1;
          }
#line 463
          bandno ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: ;
      }
#line 486
      if (! skip_packet) {
        {
#line 487
        l_nb_bytes_read = (OPJ_UINT32 )0;
#line 489
        *(first_pass_failed + l_current_pi->compno) = 0;
#line 491
        __cil_tmp32 = opj_t2_decode_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                           & l_nb_bytes_read, p_max_len, l_pack_info,
                                           p_manager);
        }
#line 491
        if (! __cil_tmp32) {
          {
#line 493
          opj_pi_destroy(l_pi, l_nb_pocs);
#line 494
          opj_free((void *)first_pass_failed);
          }
#line 495
          return (0);
        }
        {
#line 498
        l_img_comp = l_image->comps + l_current_pi->compno;
#line 499
        l_img_comp->resno_decoded = opj_uint_max(l_current_pi->resno, l_img_comp->resno_decoded);
        }
      } else {
        {
#line 502
        l_nb_bytes_read = (OPJ_UINT32 )0;
#line 503
        __cil_tmp34 = opj_t2_skip_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                         & l_nb_bytes_read, p_max_len, l_pack_info,
                                         p_manager);
        }
#line 503
        if (! __cil_tmp34) {
          {
#line 505
          opj_pi_destroy(l_pi, l_nb_pocs);
#line 506
          opj_free((void *)first_pass_failed);
          }
#line 507
          return (0);
        }
      }
#line 511
      if (*(first_pass_failed + l_current_pi->compno)) {
#line 512
        l_img_comp = l_image->comps + l_current_pi->compno;
#line 513
        if (l_img_comp->resno_decoded == 0U) {
#line 514
          l_img_comp->resno_decoded = (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions - 1U;
        }
      }
#line 519
      l_current_data += l_nb_bytes_read;
#line 520
      p_max_len -= l_nb_bytes_read;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 551
    l_current_pi ++;
#line 553
    opj_free((void *)first_pass_failed);
#line 416
    pino ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 566
  opj_pi_destroy(l_pi, l_nb_pocs);
#line 567
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src);
  }
#line 568
  return (1);
}
}
#line 580 "/root/patron/new_24/src/lib/openjp2/t2.c"
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) 
{ 
  opj_t2_t *l_t2 ;
  void *__cil_tmp4 ;

  {
  {
#line 583
  __cil_tmp4 = opj_calloc((size_t )1, sizeof(opj_t2_t ));
#line 583
  l_t2 = (opj_t2_t *)__cil_tmp4;
  }
#line 584
  if (! l_t2) {
#line 585
    return ((opj_t2_t *)((void *)0));
  }
#line 588
  l_t2->image = p_image;
#line 589
  l_t2->cp = p_cp;
#line 591
  return (l_t2);
}
}
#line 594 "/root/patron/new_24/src/lib/openjp2/t2.c"
void opj_t2_destroy(opj_t2_t *t2 ) 
{ 


  {
#line 596
  if (t2) {
    {
#line 597
    opj_free((void *)t2);
    }
  }
#line 600
  return;
}
}
#line 601 "/root/patron/new_24/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                     opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                     OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 612
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 613
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 615
  *p_data_read = (OPJ_UINT32 )0;
#line 617
  __cil_tmp13 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info, p_manager);
  }
#line 617
  if (! __cil_tmp13) {
#line 619
    return (0);
  }
#line 622
  p_src += l_nb_bytes_read;
#line 623
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 624
  p_max_length -= l_nb_bytes_read;
#line 627
  if (l_read_data) {
    {
#line 628
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 630
    __cil_tmp14 = opj_t2_read_packet_data(p_t2, p_tile, p_pi, p_src, & l_nb_bytes_read,
                                          p_max_length, p_pack_info, p_manager);
    }
#line 630
    if (! __cil_tmp14) {
#line 632
      return (0);
    }
#line 635
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 638
  *p_data_read = l_nb_total_bytes_read;
#line 640
  return (1);
}
}
#line 643 "/root/patron/new_24/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                                     opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                                     OPJ_UINT32 length , opj_codestream_info_t *cstr_info ,
                                     J2K_T2_MODE p_t2_mode , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_BYTE *c ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 l_nb_blocks ;
  opj_tcd_band_t *band ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_bio_t *bio ;
  OPJ_BOOL packet_empty ;
  opj_tcd_precinct_t *prc ;
  OPJ_BOOL __cil_tmp28 ;
  opj_tcd_precinct_t *prc___0 ;
  OPJ_BOOL __cil_tmp31 ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 __cil_tmp33 ;
  int tmp ;
  opj_tcd_precinct_t *prc___1 ;
  OPJ_BOOL __cil_tmp36 ;
  opj_tcd_layer_t *layer___0 ;
  opj_tcd_layer_t *layer___1 ;
  OPJ_UINT32 increment ;
  OPJ_UINT32 nump ;
  OPJ_UINT32 len ;
  OPJ_UINT32 passno ;
  OPJ_UINT32 l_nb_passes ;
  OPJ_INT32 __cil_tmp44 ;
  OPJ_INT32 __cil_tmp45 ;
  OPJ_INT32 __cil_tmp46 ;
  OPJ_INT32 __cil_tmp48 ;
  OPJ_BOOL __cil_tmp50 ;
  ptrdiff_t __cil_tmp51 ;
  opj_packet_info_t *info_PK ;
  opj_tcd_precinct_t *prc___2 ;
  OPJ_BOOL __cil_tmp54 ;
  opj_tcd_layer_t *layer___2 ;
  opj_packet_info_t *info_PK___0 ;
  OPJ_UINT32 __cil_tmp57 ;

  {
#line 655
  c = dest;
#line 657
  compno = pi->compno;
#line 658
  resno = pi->resno;
#line 659
  precno = pi->precno;
#line 660
  layno = pi->layno;
#line 662
  band = (opj_tcd_band_t *)0;
#line 663
  cblk = (opj_tcd_cblk_enc_t *)0;
#line 664
  pass = (opj_tcd_pass_t *)0;
#line 666
  tilec = tile->comps + compno;
#line 667
  res = tilec->resolutions + resno;
#line 669
  bio = (opj_bio_t *)0;
#line 670
  packet_empty = 1;
#line 673
  if (tcp->csty & 2U) {
#line 674
    if (length < 6U) {
#line 675
      if ((unsigned int )p_t2_mode == 1U) {
        {
#line 676
        opj_event_msg(p_manager, 1, "opj_t2_encode_packet(): only %u bytes remaining in output buffer. %u needed.\n\017\2400 V",
                      length, 6);
        }
      }
#line 681
      return (0);
    }
#line 683
    *(c + 0) = (OPJ_BYTE )255;
#line 684
    *(c + 1) = (OPJ_BYTE )145;
#line 685
    *(c + 2) = (OPJ_BYTE )0;
#line 686
    *(c + 3) = (OPJ_BYTE )4;
#line 691
    *(c + 4) = (OPJ_BYTE )((tile->packno >> 8) & 255U);
#line 692
    *(c + 5) = (OPJ_BYTE )(tile->packno & 255U);
#line 694
    c += 6;
#line 695
    length -= 6U;
  }
#line 699
  if (! layno) {
#line 700
    band = res->bands;
#line 702
    bandno = (OPJ_UINT32 )0;
    {
#line 702
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue: ;
#line 702
      if (! (bandno < res->numbands)) {
#line 702
        goto while_break;
      }
      {
#line 706
      __cil_tmp28 = opj_tcd_is_band_empty(band);
      }
#line 706
      if (__cil_tmp28) {
#line 707
        goto while_continue;
      }
      {
#line 710
      prc = band->precincts + precno;
#line 711
      opj_tgt_reset(prc->incltree);
#line 712
      opj_tgt_reset(prc->imsbtree);
#line 714
      l_nb_blocks = prc->cw * prc->ch;
#line 715
      cblkno = (OPJ_UINT32 )0;
      }
      {
#line 715
      while (1) {
        while_continue___11: /* CIL Label */ ;

#line 715
        if (! (cblkno < l_nb_blocks)) {
#line 715
          goto while_break___0;
        }
        {
#line 716
        cblk = prc->cblks.enc + cblkno;
#line 718
        cblk->numpasses = (OPJ_UINT32 )0;
#line 719
        opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32 )cblk->numbps);
#line 715
        cblkno ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___0: 
#line 702
      band ++;
#line 702
      bandno ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 724
  bio = opj_bio_create();
  }
#line 725
  if (! bio) {
#line 727
    return (0);
  }
  {
#line 729
  opj_bio_init_enc(bio, c, length);
#line 733
  band = res->bands;
#line 734
  bandno = (OPJ_UINT32 )0;
  }
  {
#line 734
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___1: ;
#line 734
    if (! (bandno < res->numbands)) {
#line 734
      goto while_break___1;
    }
    {
#line 737
    __cil_tmp31 = opj_tcd_is_band_empty(band);
    }
#line 737
    if (__cil_tmp31) {
#line 738
      goto while_continue___1;
    }
#line 741
    prc___0 = band->precincts + precno;
#line 742
    l_nb_blocks = prc___0->cw * prc___0->ch;
#line 743
    cblk = prc___0->cblks.enc;
#line 744
    cblkno = (OPJ_UINT32 )0;
    {
#line 744
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___2: ;
#line 744
      if (! (cblkno < l_nb_blocks)) {
#line 744
        goto while_break___2;
      }
#line 745
      layer = cblk->layers + layno;
#line 748
      if (! layer->numpasses) {
#line 749
        goto while_continue___2;
      }
#line 751
      packet_empty = 0;
#line 752
      goto while_break___2;
#line 744
      cblk ++;
#line 744
      __cil_tmp33 = cblkno;
#line 744
      cblkno ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___2: ;
#line 754
    if (! packet_empty) {
#line 755
      goto while_break___1;
    }
#line 734
    band ++;
#line 734
    bandno ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___1: ;
#line 759
  if (packet_empty) {
#line 759
    tmp = 0;
  } else {
#line 759
    tmp = 1;
  }
  {
#line 759
  opj_bio_write(bio, (OPJ_UINT32 )tmp, (OPJ_UINT32 )1);
#line 763
  band = res->bands;
#line 764
  bandno = (OPJ_UINT32 )0;
  }
  {
#line 764
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___3: ;
#line 764
    if (! packet_empty) {
#line 764
      if (! (bandno < res->numbands)) {
#line 764
        goto while_break___3;
      }
    } else {
#line 764
      goto while_break___3;
    }
    {
#line 769
    __cil_tmp36 = opj_tcd_is_band_empty(band);
    }
#line 769
    if (__cil_tmp36) {
#line 770
      goto while_continue___3;
    }
#line 773
    prc___1 = band->precincts + precno;
#line 774
    l_nb_blocks = prc___1->cw * prc___1->ch;
#line 775
    cblk = prc___1->cblks.enc;
#line 777
    cblkno = (OPJ_UINT32 )0;
    {
#line 777
    while (1) {
      while_continue___15: /* CIL Label */ ;

#line 777
      if (! (cblkno < l_nb_blocks)) {
#line 777
        goto while_break___4;
      }
#line 778
      layer___0 = cblk->layers + layno;
#line 780
      if (! cblk->numpasses) {
#line 780
        if (layer___0->numpasses) {
          {
#line 781
          opj_tgt_setvalue(prc___1->incltree, cblkno, (OPJ_INT32 )layno);
          }
        }
      }
#line 784
      cblk ++;
#line 777
      cblkno ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___4: 
#line 787
    cblk = prc___1->cblks.enc;
#line 788
    cblkno = (OPJ_UINT32 )0;
    {
#line 788
    while (1) {
      while_continue___16: /* CIL Label */ ;
      while_continue___5: ;
#line 788
      if (! (cblkno < l_nb_blocks)) {
#line 788
        goto while_break___5;
      }
#line 789
      layer___1 = cblk->layers + layno;
#line 790
      increment = (OPJ_UINT32 )0;
#line 791
      nump = (OPJ_UINT32 )0;
#line 792
      len = (OPJ_UINT32 )0;
#line 796
      if (! cblk->numpasses) {
        {
#line 797
        opj_tgt_encode(bio, prc___1->incltree, cblkno, (OPJ_INT32 )(layno + 1U));
        }
      } else {
        {
#line 799
        opj_bio_write(bio, (OPJ_UINT32 )(layer___1->numpasses != 0U), (OPJ_UINT32 )1);
        }
      }
#line 803
      if (! layer___1->numpasses) {
#line 804
        cblk ++;
#line 805
        goto while_continue___5;
      }
#line 809
      if (! cblk->numpasses) {
        {
#line 810
        cblk->numlenbits = (OPJ_UINT32 )3;
#line 811
        opj_tgt_encode(bio, prc___1->imsbtree, cblkno, 999);
        }
      }
      {
#line 815
      opj_t2_putnumpasses(bio, layer___1->numpasses);
#line 816
      l_nb_passes = cblk->numpasses + layer___1->numpasses;
#line 817
      pass = cblk->passes + cblk->numpasses;
#line 820
      passno = cblk->numpasses;
      }
      {
#line 820
      while (1) {
        while_continue___17: /* CIL Label */ ;

#line 820
        if (! (passno < l_nb_passes)) {
#line 820
          goto while_break___6;
        }
#line 821
        nump ++;
#line 822
        len += pass->len;
#line 824
        if ((int )pass->term) {
          _L: 
          {
#line 825
          __cil_tmp45 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 825
          __cil_tmp44 = opj_int_floorlog2((OPJ_INT32 )len);
#line 825
          __cil_tmp46 = opj_int_max((OPJ_INT32 )increment, (__cil_tmp44 + 1) - ((OPJ_INT32 )cblk->numlenbits + __cil_tmp45));
#line 825
          increment = (OPJ_UINT32 )__cil_tmp46;
#line 828
          len = (OPJ_UINT32 )0;
#line 829
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 824
        if (passno == (cblk->numpasses + layer___1->numpasses) - 1U) {
#line 824
          goto _L;
        }
#line 832
        pass ++;
#line 820
        passno ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: 
      {
#line 834
      opj_t2_putcommacode(bio, (OPJ_INT32 )increment);
#line 837
      cblk->numlenbits += increment;
#line 839
      pass = cblk->passes + cblk->numpasses;
#line 841
      passno = cblk->numpasses;
      }
      {
#line 841
      while (1) {
        while_continue___18: /* CIL Label */ ;

#line 841
        if (! (passno < l_nb_passes)) {
#line 841
          goto while_break___7;
        }
#line 842
        nump ++;
#line 843
        len += pass->len;
#line 845
        if ((int )pass->term) {
          {
#line 846
          __cil_tmp48 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 846
          opj_bio_write(bio, len, cblk->numlenbits + (OPJ_UINT32 )__cil_tmp48);
#line 848
          len = (OPJ_UINT32 )0;
#line 849
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 845
        if (passno == (cblk->numpasses + layer___1->numpasses) - 1U) {
          {
#line 846
          __cil_tmp48 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 846
          opj_bio_write(bio, len, cblk->numlenbits + (OPJ_UINT32 )__cil_tmp48);
#line 848
          len = (OPJ_UINT32 )0;
#line 849
          nump = (OPJ_UINT32 )0;
          }
        }
#line 851
        pass ++;
#line 841
        passno ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___7: 
#line 854
      cblk ++;
#line 788
      cblkno ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___5: 
#line 765
    band ++;
#line 765
    bandno ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___3: 
  {
#line 858
  __cil_tmp50 = opj_bio_flush(bio);
  }
#line 858
  if (! __cil_tmp50) {
    {
#line 859
    opj_bio_destroy(bio);
    }
#line 860
    return (0);
  }
  {
#line 863
  __cil_tmp51 = opj_bio_numbytes(bio);
#line 863
  l_nb_bytes = (OPJ_UINT32 )__cil_tmp51;
#line 864
  c += l_nb_bytes;
#line 865
  length -= l_nb_bytes;
#line 867
  opj_bio_destroy(bio);
  }
#line 870
  if (tcp->csty & 4U) {
#line 871
    if (length < 2U) {
#line 872
      if ((unsigned int )p_t2_mode == 1U) {
        {
#line 873
        opj_event_msg(p_manager, 1, "opj_t2_encode_packet(): only %u bytes remaining in output buffer. %u needed.\n",
                      length, 2);
        }
      }
#line 878
      return (0);
    }
#line 880
    *(c + 0) = (OPJ_BYTE )255;
#line 881
    *(c + 1) = (OPJ_BYTE )146;
#line 882
    c += 2;
#line 883
    length -= 2U;
  }
#line 890
  if (cstr_info) {
#line 890
    if (cstr_info->index_write) {
#line 891
      info_PK = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 892
      info_PK->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(c - dest));
    }
  }
#line 897
  band = res->bands;
#line 898
  bandno = (OPJ_UINT32 )0;
  {
#line 898
  while (1) {
    while_continue___19: /* CIL Label */ ;
    while_continue___8: ;
#line 898
    if (! packet_empty) {
#line 898
      if (! (bandno < res->numbands)) {
#line 898
        goto while_break___8;
      }
    } else {
#line 898
      goto while_break___8;
    }
    {
#line 902
    __cil_tmp54 = opj_tcd_is_band_empty(band);
    }
#line 902
    if (__cil_tmp54) {
#line 903
      goto while_continue___8;
    }
#line 906
    prc___2 = band->precincts + precno;
#line 907
    l_nb_blocks = prc___2->cw * prc___2->ch;
#line 908
    cblk = prc___2->cblks.enc;
#line 910
    cblkno = (OPJ_UINT32 )0;
    {
#line 910
    while (1) {
      while_continue___20: /* CIL Label */ ;
      while_continue___9: ;
#line 910
      if (! (cblkno < l_nb_blocks)) {
#line 910
        goto while_break___9;
      }
#line 911
      layer___2 = cblk->layers + layno;
#line 913
      if (! layer___2->numpasses) {
#line 914
        cblk ++;
#line 915
        goto while_continue___9;
      }
#line 918
      if (layer___2->len > length) {
#line 919
        if ((unsigned int )p_t2_mode == 1U) {
          {
#line 920
          opj_event_msg(p_manager, 1, "opj_t2_encode_packet(): only %u bytes remaining in output buffer. %u needed.\n",
                        length, layer___2->len);
          }
        }
#line 925
        return (0);
      }
      {
#line 928
      memcpy((void *)c, (void const   *)layer___2->data, (unsigned long )layer___2->len);
#line 929
      cblk->numpasses += layer___2->numpasses;
#line 930
      c += layer___2->len;
#line 931
      length -= layer___2->len;
      }
#line 934
      if (cstr_info) {
#line 934
        if (cstr_info->index_write) {
#line 935
          info_PK___0 = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 936
          info_PK___0->disto += layer___2->disto;
#line 937
          if (cstr_info->D_max < info_PK___0->disto) {
#line 938
            cstr_info->D_max = info_PK___0->disto;
          }
        }
      }
#line 942
      cblk ++;
#line 910
      cblkno ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___9: 
#line 898
    band ++;
#line 898
    __cil_tmp57 = bandno;
#line 898
    bandno ++;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___8: 
#line 948
  *p_data_written += (OPJ_UINT32 )(c - dest);
#line 950
  return (1);
}
}
#line 953 "/root/patron/new_24/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 964
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 965
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 967
  *p_data_read = (OPJ_UINT32 )0;
#line 969
  __cil_tmp13 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info, p_manager);
  }
#line 969
  if (! __cil_tmp13) {
#line 971
    return (0);
  }
#line 974
  p_src += l_nb_bytes_read;
#line 975
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 976
  p_max_length -= l_nb_bytes_read;
#line 979
  if (l_read_data) {
    {
#line 980
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 982
    __cil_tmp14 = opj_t2_skip_packet_data(p_t2, p_tile, p_pi, & l_nb_bytes_read, p_max_length,
                                          p_pack_info, p_manager);
    }
#line 982
    if (! __cil_tmp14) {
#line 984
      return (0);
    }
#line 987
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 989
  *p_data_read = l_nb_total_bytes_read;
#line 991
  return (1);
}
}
#line 995 "/root/patron/new_24/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                          opj_tcp_t *p_tcp , opj_pi_iterator_t *p_pi ,
                                          OPJ_BOOL *p_is_data_present , OPJ_BYTE *p_src_data ,
                                          OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                          opj_packet_info_t *p_pack_info , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_remaining_length ;
  OPJ_UINT32 l_header_length ;
  OPJ_UINT32 *l_modified_length_ptr ;
  OPJ_BYTE *l_current_data ;
  opj_cp_t *l_cp ;
  opj_bio_t *l_bio ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  OPJ_BYTE *l_header_data ;
  OPJ_BYTE **l_header_data_start ;
  OPJ_UINT32 l_present ;
  OPJ_BOOL __cil_tmp26 ;
  opj_tcd_precinct_t *l_prc ;
  ptrdiff_t __cil_tmp30 ;
  opj_tcd_precinct_t *l_prc___0 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_UINT32 l_included ;
  OPJ_UINT32 l_increment ;
  OPJ_UINT32 l_segno ;
  OPJ_INT32 n ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp40 ;
  OPJ_BOOL __cil_tmp43 ;
  OPJ_BOOL __cil_tmp44 ;
  OPJ_UINT32 bit_number ;
  OPJ_INT32 __cil_tmp46 ;
  OPJ_UINT32 __cil_tmp47 ;
  OPJ_BOOL __cil_tmp49 ;
  OPJ_BOOL __cil_tmp51 ;
  ptrdiff_t __cil_tmp52 ;

  {
#line 1012
  l_modified_length_ptr = (OPJ_UINT32 *)0;
#line 1013
  l_current_data = p_src_data;
#line 1014
  l_cp = p_t2->cp;
#line 1015
  l_bio = (opj_bio_t *)0;
#line 1016
  l_band = (opj_tcd_band_t *)0;
#line 1017
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1018
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1021
  l_header_data = (OPJ_BYTE *)0;
#line 1022
  l_header_data_start = (OPJ_BYTE **)0;
#line 1026
  if (p_pi->layno == 0U) {
#line 1027
    l_band = l_res->bands;
#line 1030
    bandno = (OPJ_UINT32 )0;
    {
#line 1030
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1030
      if (! (bandno < l_res->numbands)) {
#line 1030
        goto while_break;
      }
      {
#line 1031
      __cil_tmp26 = opj_tcd_is_band_empty(l_band);
      }
#line 1031
      if (! __cil_tmp26) {
#line 1032
        l_prc = l_band->precincts + p_pi->precno;
#line 1033
        if (! ((unsigned long )p_pi->precno < (unsigned long )l_band->precincts_data_size / sizeof(opj_tcd_precinct_t ))) {
          {
#line 1035
          opj_event_msg(p_manager, 1, "Invalid precinct\n\355\2400 V");
          }
#line 1036
          return (0);
        }
        {
#line 1040
        opj_tgt_reset(l_prc->incltree);
#line 1041
        opj_tgt_reset(l_prc->imsbtree);
#line 1042
        l_cblk = l_prc->cblks.dec;
#line 1044
        l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1045
        cblkno = (OPJ_UINT32 )0;
        }
        {
#line 1045
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1045
          if (! (cblkno < l_nb_code_blocks)) {
#line 1045
            goto while_break___0;
          }
#line 1046
          l_cblk->numsegs = (OPJ_UINT32 )0;
#line 1047
          l_cblk->real_num_segs = (OPJ_UINT32 )0;
#line 1048
          l_cblk ++;
#line 1045
          cblkno ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___0: ;
      }
#line 1052
      l_band ++;
#line 1030
      bandno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 1058
  if (p_tcp->csty & 2U) {
#line 1059
    if (p_max_length < 6U) {
      {
#line 1060
      opj_event_msg(p_manager, 2, "Not enough space for expected SOP marker\n");
      }
    } else
#line 1062
    if ((int )*l_current_data != 255) {
      {
#line 1063
      opj_event_msg(p_manager, 2, "Expected SOP marker\n V");
      }
    } else
#line 1062
    if ((int )*(l_current_data + 1) != 145) {
      {
#line 1063
      opj_event_msg(p_manager, 2, "Expected SOP marker\n V");
      }
    } else {
#line 1065
      l_current_data += 6;
    }
  }
  {
#line 1078
  l_bio = opj_bio_create();
  }
#line 1079
  if (! l_bio) {
#line 1080
    return (0);
  }
#line 1083
  if ((int )l_cp->ppm == 1) {
#line 1084
    l_header_data_start = & l_cp->ppm_data;
#line 1085
    l_header_data = *l_header_data_start;
#line 1086
    l_modified_length_ptr = & l_cp->ppm_len;
  } else
#line 1088
  if ((int )p_tcp->ppt == 1) {
#line 1089
    l_header_data_start = & p_tcp->ppt_data;
#line 1090
    l_header_data = *l_header_data_start;
#line 1091
    l_modified_length_ptr = & p_tcp->ppt_len;
  } else {
#line 1093
    l_header_data_start = & l_current_data;
#line 1094
    l_header_data = *l_header_data_start;
#line 1095
    l_remaining_length = (OPJ_UINT32 )((p_src_data + p_max_length) - l_header_data);
#line 1096
    l_modified_length_ptr = & l_remaining_length;
  }
  {
#line 1099
  opj_bio_init_dec(l_bio, l_header_data, *l_modified_length_ptr);
#line 1101
  l_present = opj_bio_read(l_bio, (OPJ_UINT32 )1);
#line 1102
  opj_null_jas_fprintf(stderr, "present=%d \n V", l_present);
  }
#line 1103
  if (! l_present) {
    {
#line 1105
    opj_bio_inalign(l_bio);
#line 1106
    __cil_tmp30 = opj_bio_numbytes(l_bio);
#line 1106
    l_header_data += __cil_tmp30;
#line 1107
    opj_bio_destroy(l_bio);
    }
#line 1110
    if (p_tcp->csty & 4U) {
#line 1111
      if (*l_modified_length_ptr - (OPJ_UINT32 )(l_header_data - *l_header_data_start) < 2U) {
        {
#line 1113
        opj_event_msg(p_manager, 2, "Not enough space for expected EPH marker\n");
        }
      } else
#line 1115
      if ((int )*l_header_data != 255) {
        {
#line 1116
        opj_event_msg(p_manager, 2, "Expected EPH marker\n");
        }
      } else
#line 1115
      if ((int )*(l_header_data + 1) != 146) {
        {
#line 1116
        opj_event_msg(p_manager, 2, "Expected EPH marker\n");
        }
      } else {
#line 1118
        l_header_data += 2;
      }
    }
#line 1122
    l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 1123
    *l_modified_length_ptr -= l_header_length;
#line 1124
    *l_header_data_start += l_header_length;
#line 1129
    if (p_pack_info) {
#line 1130
      p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
    }
#line 1134
    *p_is_data_present = 0;
#line 1135
    *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1136
    return (1);
  }
#line 1139
  l_band = l_res->bands;
#line 1140
  bandno = (OPJ_UINT32 )0;
  {
#line 1140
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: ;
#line 1140
    if (! (bandno < l_res->numbands)) {
#line 1140
      goto while_break___1;
    }
    {
#line 1141
    l_prc___0 = l_band->precincts + p_pi->precno;
#line 1143
    __cil_tmp32 = opj_tcd_is_band_empty(l_band);
    }
#line 1143
    if (__cil_tmp32) {
#line 1144
      goto while_continue___1;
    }
#line 1147
    l_nb_code_blocks = l_prc___0->cw * l_prc___0->ch;
#line 1148
    l_cblk = l_prc___0->cblks.dec;
#line 1149
    cblkno = (OPJ_UINT32 )0;
    {
#line 1149
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___2: ;
#line 1149
      if (! (cblkno < l_nb_code_blocks)) {
#line 1149
        goto while_break___2;
      }
#line 1154
      if (! l_cblk->numsegs) {
        {
#line 1155
        l_included = opj_tgt_decode(l_bio, l_prc___0->incltree, cblkno, (OPJ_INT32 )(p_pi->layno + 1U));
        }
      } else {
        {
#line 1159
        l_included = opj_bio_read(l_bio, (OPJ_UINT32 )1);
        }
      }
#line 1163
      if (! l_included) {
        {
#line 1164
        l_cblk->numnewpasses = (OPJ_UINT32 )0;
#line 1165
        l_cblk ++;
#line 1166
        opj_null_jas_fprintf(stderr, "included=%d \n", l_included);
        }
#line 1167
        goto while_continue___2;
      }
#line 1171
      if (! l_cblk->numsegs) {
#line 1172
        i = (OPJ_UINT32 )0;
        {
#line 1174
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 1174
          __cil_tmp40 = opj_tgt_decode(l_bio, l_prc___0->imsbtree, cblkno, (OPJ_INT32 )i);
          }
#line 1174
          if (! (! __cil_tmp40)) {
#line 1174
            goto while_break___3;
          }
#line 1175
          i ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: 
#line 1178
        l_cblk->numbps = ((OPJ_UINT32 )l_band->numbps + 1U) - i;
#line 1179
        l_cblk->numlenbits = (OPJ_UINT32 )3;
      }
      {
#line 1183
      l_cblk->numnewpasses = opj_t2_getnumpasses(l_bio);
#line 1184
      l_increment = opj_t2_getcommacode(l_bio);
#line 1187
      l_cblk->numlenbits += l_increment;
#line 1188
      l_segno = (OPJ_UINT32 )0;
      }
#line 1190
      if (! l_cblk->numsegs) {
        {
#line 1191
        __cil_tmp43 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                      (OPJ_UINT32 )1);
        }
#line 1191
        if (! __cil_tmp43) {
          {
#line 1192
          opj_bio_destroy(l_bio);
          }
#line 1193
          return (0);
        }
      } else {
#line 1196
        l_segno = l_cblk->numsegs - 1U;
#line 1197
        if ((l_cblk->segs + l_segno)->numpasses == (l_cblk->segs + l_segno)->maxpasses) {
          {
#line 1198
          l_segno ++;
#line 1199
          __cil_tmp44 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                        (OPJ_UINT32 )0);
          }
#line 1199
          if (! __cil_tmp44) {
            {
#line 1200
            opj_bio_destroy(l_bio);
            }
#line 1201
            return (0);
          }
        }
      }
#line 1205
      n = (OPJ_INT32 )l_cblk->numnewpasses;
      {
#line 1207
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 1209
        __cil_tmp46 = opj_int_min((OPJ_INT32 )((l_cblk->segs + l_segno)->maxpasses - (l_cblk->segs + l_segno)->numpasses),
                                  n);
#line 1209
        (l_cblk->segs + l_segno)->numnewpasses = (OPJ_UINT32 )__cil_tmp46;
#line 1211
        __cil_tmp47 = opj_uint_floorlog2((l_cblk->segs + l_segno)->numnewpasses);
#line 1211
        bit_number = l_cblk->numlenbits + __cil_tmp47;
        }
#line 1213
        if (bit_number > 32U) {
          {
#line 1214
          opj_event_msg(p_manager, 1, "Invalid bit number %d in opj_t2_read_packet_header()\n",
                        bit_number);
#line 1217
          opj_bio_destroy(l_bio);
          }
#line 1218
          return (0);
        }
        {
#line 1220
        (l_cblk->segs + l_segno)->newlen = opj_bio_read(l_bio, bit_number);
#line 1221
        opj_null_jas_fprintf(stderr, "included=%d numnewpasses=%d increment=%d len=%d \n",
                             l_included, (l_cblk->segs + l_segno)->numnewpasses, l_increment,
                             (l_cblk->segs + l_segno)->newlen);
#line 1225
        n -= (OPJ_INT32 )(l_cblk->segs + l_segno)->numnewpasses;
        }
#line 1226
        if (n > 0) {
          {
#line 1227
          l_segno ++;
#line 1229
          __cil_tmp49 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                        (OPJ_UINT32 )0);
          }
#line 1229
          if (! __cil_tmp49) {
            {
#line 1230
            opj_bio_destroy(l_bio);
            }
#line 1231
            return (0);
          }
        }
#line 1207
        if (! (n > 0)) {
#line 1207
          goto while_break___4;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 1236
      l_cblk ++;
#line 1149
      cblkno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
#line 1140
    l_band ++;
#line 1140
    bandno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 1240
  __cil_tmp51 = opj_bio_inalign(l_bio);
  }
#line 1240
  if (! __cil_tmp51) {
    {
#line 1241
    opj_bio_destroy(l_bio);
    }
#line 1242
    return (0);
  }
  {
#line 1245
  __cil_tmp52 = opj_bio_numbytes(l_bio);
#line 1245
  l_header_data += __cil_tmp52;
#line 1246
  opj_bio_destroy(l_bio);
  }
#line 1249
  if (p_tcp->csty & 4U) {
#line 1250
    if (*l_modified_length_ptr - (OPJ_UINT32 )(l_header_data - *l_header_data_start) < 2U) {
      {
#line 1252
      opj_event_msg(p_manager, 2, "Not enough space for expected EPH marker\n\277\2410 V");
      }
    } else
#line 1254
    if ((int )*l_header_data != 255) {
      {
#line 1255
      opj_event_msg(p_manager, 2, "Expected EPH marker\n V");
      }
    } else
#line 1254
    if ((int )*(l_header_data + 1) != 146) {
      {
#line 1255
      opj_event_msg(p_manager, 2, "Expected EPH marker\n V");
      }
    } else {
#line 1257
      l_header_data += 2;
    }
  }
  {
#line 1261
  l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 1262
  opj_null_jas_fprintf(stderr, "hdrlen=%d \n0 V", l_header_length);
#line 1263
  opj_null_jas_fprintf(stderr, "packet body\n V");
#line 1264
  *l_modified_length_ptr -= l_header_length;
#line 1265
  *l_header_data_start += l_header_length;
  }
#line 1270
  if (p_pack_info) {
#line 1271
    p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
  }
#line 1275
  *p_is_data_present = 1;
#line 1276
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1278
  return (1);
}
}
#line 1281 "/root/patron/new_24/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src_data ,
                                        OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                        opj_packet_info_t *pack_info , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_BYTE *l_current_data ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;
  OPJ_UINT32 l_numchunksalloc ;
  opj_tcd_seg_data_chunk_t *l_chunks ;
  void *__cil_tmp20 ;

  {
#line 1292
  l_current_data = p_src_data;
#line 1293
  l_band = (opj_tcd_band_t *)0;
#line 1294
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1295
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1301
  l_band = l_res->bands;
#line 1302
  bandno = (OPJ_UINT32 )0;
  {
#line 1302
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: ;
#line 1302
    if (! (bandno < l_res->numbands)) {
#line 1302
      goto while_break;
    }
#line 1303
    l_prc = l_band->precincts + p_pi->precno;
#line 1305
    if (l_band->x1 - l_band->x0 == 0) {
#line 1306
      l_band ++;
#line 1307
      goto while_continue;
    } else
#line 1305
    if (l_band->y1 - l_band->y0 == 0) {
#line 1306
      l_band ++;
#line 1307
      goto while_continue;
    }
#line 1310
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1311
    l_cblk = l_prc->cblks.dec;
#line 1313
    cblkno = (OPJ_UINT32 )0;
    {
#line 1313
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: ;
#line 1313
      if (! (cblkno < l_nb_code_blocks)) {
#line 1313
        goto while_break___0;
      }
#line 1314
      l_seg = (opj_tcd_seg_t *)0;
#line 1316
      if (! l_cblk->numnewpasses) {
#line 1318
        l_cblk ++;
#line 1319
        goto while_continue___0;
      }
#line 1322
      if (! l_cblk->numsegs) {
#line 1323
        l_seg = l_cblk->segs;
#line 1324
        (l_cblk->numsegs) ++;
      } else {
#line 1326
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1328
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1329
          l_seg ++;
#line 1330
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1334
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1336
        if ((unsigned long )(l_current_data + l_seg->newlen) > (unsigned long )(p_src_data + p_max_length)) {
          {
#line 1339
          opj_event_msg(p_manager, 1, "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n V",
                        l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                        p_pi->resno, p_pi->compno);
          }
#line 1343
          return (0);
        } else
#line 1336
        if ((OPJ_SIZE_T )l_current_data + (OPJ_SIZE_T )l_seg->newlen < (OPJ_SIZE_T )l_current_data) {
          {
#line 1339
          opj_event_msg(p_manager, 1, "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n V",
                        l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                        p_pi->resno, p_pi->compno);
          }
#line 1343
          return (0);
        }
#line 1367
        if (l_cblk->numchunks == l_cblk->numchunksalloc) {
          {
#line 1368
          l_numchunksalloc = l_cblk->numchunksalloc * 2U + 1U;
#line 1369
          __cil_tmp20 = opj_realloc((void *)l_cblk->chunks, (unsigned long )l_numchunksalloc * sizeof(opj_tcd_seg_data_chunk_t ));
#line 1369
          l_chunks = (opj_tcd_seg_data_chunk_t *)__cil_tmp20;
          }
#line 1372
          if ((unsigned long )l_chunks == (unsigned long )((void *)0)) {
            {
#line 1373
            opj_event_msg(p_manager, 1, "cannot allocate opj_tcd_seg_data_chunk_t* array");
            }
#line 1375
            return (0);
          }
#line 1377
          l_cblk->chunks = l_chunks;
#line 1378
          l_cblk->numchunksalloc = l_numchunksalloc;
        }
#line 1381
        (l_cblk->chunks + l_cblk->numchunks)->data = l_current_data;
#line 1382
        (l_cblk->chunks + l_cblk->numchunks)->len = l_seg->newlen;
#line 1383
        (l_cblk->numchunks) ++;
#line 1385
        l_current_data += l_seg->newlen;
#line 1386
        l_seg->len += l_seg->newlen;
#line 1387
        l_seg->numpasses += l_seg->numnewpasses;
#line 1388
        l_cblk->numnewpasses -= l_seg->numnewpasses;
#line 1390
        l_seg->real_num_passes = l_seg->numpasses;
#line 1392
        if (l_cblk->numnewpasses > 0U) {
#line 1393
          l_seg ++;
#line 1394
          (l_cblk->numsegs) ++;
        }
#line 1334
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1334
          goto while_break___1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 1398
      l_cblk->real_num_segs = l_cblk->numsegs;
#line 1399
      l_cblk ++;
#line 1313
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 1402
    l_band ++;
#line 1302
    bandno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 1405
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1408
  return (1);
}
}
#line 1411 "/root/patron/new_24/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_UINT32 *p_data_read ,
                                        OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;

  {
#line 1421
  l_band = (opj_tcd_band_t *)0;
#line 1422
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1423
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1429
  *p_data_read = (OPJ_UINT32 )0;
#line 1430
  l_band = l_res->bands;
#line 1432
  bandno = (OPJ_UINT32 )0;
  {
#line 1432
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: ;
#line 1432
    if (! (bandno < l_res->numbands)) {
#line 1432
      goto while_break;
    }
#line 1433
    l_prc = l_band->precincts + p_pi->precno;
#line 1435
    if (l_band->x1 - l_band->x0 == 0) {
#line 1436
      l_band ++;
#line 1437
      goto while_continue;
    } else
#line 1435
    if (l_band->y1 - l_band->y0 == 0) {
#line 1436
      l_band ++;
#line 1437
      goto while_continue;
    }
#line 1440
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1441
    l_cblk = l_prc->cblks.dec;
#line 1443
    cblkno = (OPJ_UINT32 )0;
    {
#line 1443
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: ;
#line 1443
      if (! (cblkno < l_nb_code_blocks)) {
#line 1443
        goto while_break___0;
      }
#line 1444
      l_seg = (opj_tcd_seg_t *)0;
#line 1446
      if (! l_cblk->numnewpasses) {
#line 1448
        l_cblk ++;
#line 1449
        goto while_continue___0;
      }
#line 1452
      if (! l_cblk->numsegs) {
#line 1453
        l_seg = l_cblk->segs;
#line 1454
        (l_cblk->numsegs) ++;
      } else {
#line 1456
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1458
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1459
          l_seg ++;
#line 1460
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1464
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1466
        if (*p_data_read + l_seg->newlen < *p_data_read) {
          {
#line 1468
          opj_event_msg(p_manager, 1, "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
                        l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                        p_pi->resno, p_pi->compno);
          }
#line 1472
          return (0);
        } else
#line 1466
        if (*p_data_read + l_seg->newlen > p_max_length) {
          {
#line 1468
          opj_event_msg(p_manager, 1, "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
                        l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                        p_pi->resno, p_pi->compno);
          }
#line 1472
          return (0);
        }
        {
#line 1495
        opj_null_jas_fprintf(stderr, "p_data_read (%d) newlen (%d) \n", *p_data_read,
                             l_seg->newlen);
#line 1497
        *p_data_read += l_seg->newlen;
#line 1499
        l_seg->numpasses += l_seg->numnewpasses;
#line 1500
        l_cblk->numnewpasses -= l_seg->numnewpasses;
        }
#line 1501
        if (l_cblk->numnewpasses > 0U) {
#line 1502
          l_seg ++;
#line 1503
          (l_cblk->numsegs) ++;
        }
#line 1464
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1464
          goto while_break___1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 1507
      l_cblk ++;
#line 1443
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 1510
    l_band ++;
#line 1432
    bandno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 1513
  return (1);
}
}
#line 1517 "/root/patron/new_24/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 ,
                                OPJ_UINT32 cblksty , OPJ_UINT32 first ) 
{ 
  opj_tcd_seg_t *seg ;
  OPJ_UINT32 l_nb_segs ;
  opj_tcd_seg_t *new_segs ;
  OPJ_UINT32 l_m_current_max_segs ;
  void *__cil_tmp9 ;
  int tmp ;

  {
#line 1522
  seg = (opj_tcd_seg_t *)0;
#line 1523
  l_nb_segs = index___0 + 1U;
#line 1525
  if (l_nb_segs > cblk->m_current_max_segs) {
    {
#line 1527
    l_m_current_max_segs = cblk->m_current_max_segs + 10U;
#line 1530
    __cil_tmp9 = opj_realloc((void *)cblk->segs, (unsigned long )l_m_current_max_segs * sizeof(opj_tcd_seg_t ));
#line 1530
    new_segs = (opj_tcd_seg_t *)__cil_tmp9;
    }
#line 1532
    if (! new_segs) {
#line 1534
      return (0);
    }
    {
#line 1536
    cblk->segs = new_segs;
#line 1537
    memset((void *)(new_segs + cblk->m_current_max_segs), 0, 10UL * sizeof(opj_tcd_seg_t ));
#line 1539
    cblk->m_current_max_segs = l_m_current_max_segs;
    }
  }
  {
#line 1542
  seg = cblk->segs + index___0;
#line 1543
  opj_tcd_reinit_segment(seg);
  }
#line 1545
  if (cblksty & 4U) {
#line 1546
    seg->maxpasses = (OPJ_UINT32 )1;
  } else
#line 1547
  if (cblksty & 1U) {
#line 1548
    if (first) {
#line 1549
      seg->maxpasses = (OPJ_UINT32 )10;
    } else {
#line 1551
      if ((seg - 1)->maxpasses == 1U) {
#line 1551
        tmp = 2;
      } else
#line 1551
      if ((seg - 1)->maxpasses == 10U) {
#line 1551
        tmp = 2;
      } else {
#line 1551
        tmp = 1;
      }
#line 1551
      seg->maxpasses = (OPJ_UINT32 )tmp;
    }
  } else {
#line 1559
    seg->maxpasses = (OPJ_UINT32 )109;
  }
#line 1562
  return (1);
}
}
#line 56 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_empty)(void) ;
#line 58
extern int ( /* missing proto */  __builtin_ia32_emms)() ;
#line 56 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_empty)(void) 
{ 


  {
  {
#line 58
  __builtin_ia32_emms();
  }
#line 60
  return;
}
}
#line 62
__inline extern void ( __attribute__((__gnu_inline__)) _m_empty)(void) ;
#line 62 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _m_empty)(void) 
{ 


  {
  {
#line 64
  _mm_empty();
  }
#line 66
  return;
}
}
#line 69
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si64)(int __i ) ;
#line 71
extern int ( /* missing proto */  __builtin_ia32_vec_init_v2si)() ;
#line 69 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si64)(int __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 71
  __cil_tmp2 = __builtin_ia32_vec_init_v2si(__i, 0);
  }
#line 71
  return (__cil_tmp2);
}
}
#line 75
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int)(int __i ) ;
#line 75 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int)(int __i ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 77
  __cil_tmp2 = _mm_cvtsi32_si64(__i);
  }
#line 77
  return (__cil_tmp2);
}
}
#line 85
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int64)(long long __i ) ;
#line 85 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int64)(long long __i ) 
{ 


  {
#line 87
  return ((__m64 )__i);
}
}
#line 112
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si32)(__m64 __i ) ;
#line 114
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v2si)() ;
#line 112 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si32)(__m64 __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 114
  __cil_tmp2 = __builtin_ia32_vec_ext_v2si(__i, 0);
  }
#line 114
  return (__cil_tmp2);
}
}
#line 118
__inline extern int ( __attribute__((__gnu_inline__)) _m_to_int)(__m64 __i ) ;
#line 118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _m_to_int)(__m64 __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 120
  __cil_tmp2 = _mm_cvtsi64_si32(__i);
  }
#line 120
  return (__cil_tmp2);
}
}
#line 128
__inline extern long long ( __attribute__((__gnu_inline__)) _m_to_int64)(__m64 __i ) ;
#line 128 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _m_to_int64)(__m64 __i ) 
{ 


  {
#line 130
  return ((long long )__i);
}
}
#line 151
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 153
extern int ( /* missing proto */  __builtin_ia32_packsswb)() ;
#line 151 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 153
  __cil_tmp3 = __builtin_ia32_packsswb(__m1, __m2);
  }
#line 153
  return (__cil_tmp3);
}
}
#line 157
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packsswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 157 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packsswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 159
  __cil_tmp3 = _mm_packs_pi16(__m1, __m2);
  }
#line 159
  return (__cil_tmp3);
}
}
#line 166
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 168
extern int ( /* missing proto */  __builtin_ia32_packssdw)() ;
#line 166 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 168
  __cil_tmp3 = __builtin_ia32_packssdw(__m1, __m2);
  }
#line 168
  return (__cil_tmp3);
}
}
#line 172
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packssdw)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 172 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packssdw)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 174
  __cil_tmp3 = _mm_packs_pi32(__m1, __m2);
  }
#line 174
  return (__cil_tmp3);
}
}
#line 181
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pu16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 183
extern int ( /* missing proto */  __builtin_ia32_packuswb)() ;
#line 181 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pu16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 183
  __cil_tmp3 = __builtin_ia32_packuswb(__m1, __m2);
  }
#line 183
  return (__cil_tmp3);
}
}
#line 187
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packuswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 187 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packuswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 189
  __cil_tmp3 = _mm_packs_pu16(__m1, __m2);
  }
#line 189
  return (__cil_tmp3);
}
}
#line 195
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) ;
#line 197
extern int ( /* missing proto */  __builtin_ia32_punpckhbw)() ;
#line 195 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 197
  __cil_tmp3 = __builtin_ia32_punpckhbw(__m1, __m2);
  }
#line 197
  return (__cil_tmp3);
}
}
#line 201
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 201 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 203
  __cil_tmp3 = _mm_unpackhi_pi8(__m1, __m2);
  }
#line 203
  return (__cil_tmp3);
}
}
#line 209
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 211
extern int ( /* missing proto */  __builtin_ia32_punpckhwd)() ;
#line 209 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 211
  __cil_tmp3 = __builtin_ia32_punpckhwd(__m1, __m2);
  }
#line 211
  return (__cil_tmp3);
}
}
#line 215
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 215 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 217
  __cil_tmp3 = _mm_unpackhi_pi16(__m1, __m2);
  }
#line 217
  return (__cil_tmp3);
}
}
#line 223
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 225
extern int ( /* missing proto */  __builtin_ia32_punpckhdq)() ;
#line 223 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 225
  __cil_tmp3 = __builtin_ia32_punpckhdq(__m1, __m2);
  }
#line 225
  return (__cil_tmp3);
}
}
#line 229
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhdq)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 229 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhdq)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 231
  __cil_tmp3 = _mm_unpackhi_pi32(__m1, __m2);
  }
#line 231
  return (__cil_tmp3);
}
}
#line 237
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) ;
#line 239
extern int ( /* missing proto */  __builtin_ia32_punpcklbw)() ;
#line 237 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 239
  __cil_tmp3 = __builtin_ia32_punpcklbw(__m1, __m2);
  }
#line 239
  return (__cil_tmp3);
}
}
#line 243
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 243 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 245
  __cil_tmp3 = _mm_unpacklo_pi8(__m1, __m2);
  }
#line 245
  return (__cil_tmp3);
}
}
#line 251
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 253
extern int ( /* missing proto */  __builtin_ia32_punpcklwd)() ;
#line 251 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 253
  __cil_tmp3 = __builtin_ia32_punpcklwd(__m1, __m2);
  }
#line 253
  return (__cil_tmp3);
}
}
#line 257
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 257 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 259
  __cil_tmp3 = _mm_unpacklo_pi16(__m1, __m2);
  }
#line 259
  return (__cil_tmp3);
}
}
#line 265
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 267
extern int ( /* missing proto */  __builtin_ia32_punpckldq)() ;
#line 265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_ia32_punpckldq(__m1, __m2);
  }
#line 267
  return (__cil_tmp3);
}
}
#line 271
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckldq)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 271 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckldq)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 273
  __cil_tmp3 = _mm_unpacklo_pi32(__m1, __m2);
  }
#line 273
  return (__cil_tmp3);
}
}
#line 278
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 280
extern int ( /* missing proto */  __builtin_ia32_paddb)() ;
#line 278 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 280
  __cil_tmp3 = __builtin_ia32_paddb(__m1, __m2);
  }
#line 280
  return (__cil_tmp3);
}
}
#line 284
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddb)(__m64 __m1 , __m64 __m2 ) ;
#line 284 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 286
  __cil_tmp3 = _mm_add_pi8(__m1, __m2);
  }
#line 286
  return (__cil_tmp3);
}
}
#line 291
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 293
extern int ( /* missing proto */  __builtin_ia32_paddw)() ;
#line 291 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 293
  __cil_tmp3 = __builtin_ia32_paddw(__m1, __m2);
  }
#line 293
  return (__cil_tmp3);
}
}
#line 297
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddw)(__m64 __m1 , __m64 __m2 ) ;
#line 297 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 299
  __cil_tmp3 = _mm_add_pi16(__m1, __m2);
  }
#line 299
  return (__cil_tmp3);
}
}
#line 304
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 306
extern int ( /* missing proto */  __builtin_ia32_paddd)() ;
#line 304 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 306
  __cil_tmp3 = __builtin_ia32_paddd(__m1, __m2);
  }
#line 306
  return (__cil_tmp3);
}
}
#line 310
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddd)(__m64 __m1 , __m64 __m2 ) ;
#line 310 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 312
  __cil_tmp3 = _mm_add_pi32(__m1, __m2);
  }
#line 312
  return (__cil_tmp3);
}
}
#line 323
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 325
extern int ( /* missing proto */  __builtin_ia32_paddq)() ;
#line 323 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 325
  __cil_tmp3 = __builtin_ia32_paddq(__m1, __m2);
  }
#line 325
  return (__cil_tmp3);
}
}
#line 335
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 337
extern int ( /* missing proto */  __builtin_ia32_paddsb)() ;
#line 335 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 337
  __cil_tmp3 = __builtin_ia32_paddsb(__m1, __m2);
  }
#line 337
  return (__cil_tmp3);
}
}
#line 341
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsb)(__m64 __m1 , __m64 __m2 ) ;
#line 341 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 343
  __cil_tmp3 = _mm_adds_pi8(__m1, __m2);
  }
#line 343
  return (__cil_tmp3);
}
}
#line 349
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 351
extern int ( /* missing proto */  __builtin_ia32_paddsw)() ;
#line 349 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 351
  __cil_tmp3 = __builtin_ia32_paddsw(__m1, __m2);
  }
#line 351
  return (__cil_tmp3);
}
}
#line 355
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsw)(__m64 __m1 , __m64 __m2 ) ;
#line 355 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 357
  __cil_tmp3 = _mm_adds_pi16(__m1, __m2);
  }
#line 357
  return (__cil_tmp3);
}
}
#line 363
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 365
extern int ( /* missing proto */  __builtin_ia32_paddusb)() ;
#line 363 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 365
  __cil_tmp3 = __builtin_ia32_paddusb(__m1, __m2);
  }
#line 365
  return (__cil_tmp3);
}
}
#line 369
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusb)(__m64 __m1 , __m64 __m2 ) ;
#line 369 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 371
  __cil_tmp3 = _mm_adds_pu8(__m1, __m2);
  }
#line 371
  return (__cil_tmp3);
}
}
#line 377
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 379
extern int ( /* missing proto */  __builtin_ia32_paddusw)() ;
#line 377 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 379
  __cil_tmp3 = __builtin_ia32_paddusw(__m1, __m2);
  }
#line 379
  return (__cil_tmp3);
}
}
#line 383
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusw)(__m64 __m1 , __m64 __m2 ) ;
#line 383 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 385
  __cil_tmp3 = _mm_adds_pu16(__m1, __m2);
  }
#line 385
  return (__cil_tmp3);
}
}
#line 390
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 392
extern int ( /* missing proto */  __builtin_ia32_psubb)() ;
#line 390 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 392
  __cil_tmp3 = __builtin_ia32_psubb(__m1, __m2);
  }
#line 392
  return (__cil_tmp3);
}
}
#line 396
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubb)(__m64 __m1 , __m64 __m2 ) ;
#line 396 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 398
  __cil_tmp3 = _mm_sub_pi8(__m1, __m2);
  }
#line 398
  return (__cil_tmp3);
}
}
#line 403
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 405
extern int ( /* missing proto */  __builtin_ia32_psubw)() ;
#line 403 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 405
  __cil_tmp3 = __builtin_ia32_psubw(__m1, __m2);
  }
#line 405
  return (__cil_tmp3);
}
}
#line 409
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubw)(__m64 __m1 , __m64 __m2 ) ;
#line 409 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 411
  __cil_tmp3 = _mm_sub_pi16(__m1, __m2);
  }
#line 411
  return (__cil_tmp3);
}
}
#line 416
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 418
extern int ( /* missing proto */  __builtin_ia32_psubd)() ;
#line 416 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 418
  __cil_tmp3 = __builtin_ia32_psubd(__m1, __m2);
  }
#line 418
  return (__cil_tmp3);
}
}
#line 422
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubd)(__m64 __m1 , __m64 __m2 ) ;
#line 422 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 424
  __cil_tmp3 = _mm_sub_pi32(__m1, __m2);
  }
#line 424
  return (__cil_tmp3);
}
}
#line 435
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 437
extern int ( /* missing proto */  __builtin_ia32_psubq)() ;
#line 435 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 437
  __cil_tmp3 = __builtin_ia32_psubq(__m1, __m2);
  }
#line 437
  return (__cil_tmp3);
}
}
#line 447
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 449
extern int ( /* missing proto */  __builtin_ia32_psubsb)() ;
#line 447 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 449
  __cil_tmp3 = __builtin_ia32_psubsb(__m1, __m2);
  }
#line 449
  return (__cil_tmp3);
}
}
#line 453
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsb)(__m64 __m1 , __m64 __m2 ) ;
#line 453 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = _mm_subs_pi8(__m1, __m2);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 461
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 463
extern int ( /* missing proto */  __builtin_ia32_psubsw)() ;
#line 461 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 463
  __cil_tmp3 = __builtin_ia32_psubsw(__m1, __m2);
  }
#line 463
  return (__cil_tmp3);
}
}
#line 467
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsw)(__m64 __m1 , __m64 __m2 ) ;
#line 467 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 469
  __cil_tmp3 = _mm_subs_pi16(__m1, __m2);
  }
#line 469
  return (__cil_tmp3);
}
}
#line 475
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 477
extern int ( /* missing proto */  __builtin_ia32_psubusb)() ;
#line 475 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 477
  __cil_tmp3 = __builtin_ia32_psubusb(__m1, __m2);
  }
#line 477
  return (__cil_tmp3);
}
}
#line 481
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusb)(__m64 __m1 , __m64 __m2 ) ;
#line 481 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 483
  __cil_tmp3 = _mm_subs_pu8(__m1, __m2);
  }
#line 483
  return (__cil_tmp3);
}
}
#line 489
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 491
extern int ( /* missing proto */  __builtin_ia32_psubusw)() ;
#line 489 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 491
  __cil_tmp3 = __builtin_ia32_psubusw(__m1, __m2);
  }
#line 491
  return (__cil_tmp3);
}
}
#line 495
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusw)(__m64 __m1 , __m64 __m2 ) ;
#line 495 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 497
  __cil_tmp3 = _mm_subs_pu16(__m1, __m2);
  }
#line 497
  return (__cil_tmp3);
}
}
#line 504
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_madd_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 506
extern int ( /* missing proto */  __builtin_ia32_pmaddwd)() ;
#line 504 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_madd_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 506
  __cil_tmp3 = __builtin_ia32_pmaddwd(__m1, __m2);
  }
#line 506
  return (__cil_tmp3);
}
}
#line 510
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaddwd)(__m64 __m1 , __m64 __m2 ) ;
#line 510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaddwd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 512
  __cil_tmp3 = _mm_madd_pi16(__m1, __m2);
  }
#line 512
  return (__cil_tmp3);
}
}
#line 518
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 520
extern int ( /* missing proto */  __builtin_ia32_pmulhw)() ;
#line 518 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 520
  __cil_tmp3 = __builtin_ia32_pmulhw(__m1, __m2);
  }
#line 520
  return (__cil_tmp3);
}
}
#line 524
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhw)(__m64 __m1 , __m64 __m2 ) ;
#line 524 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 526
  __cil_tmp3 = _mm_mulhi_pi16(__m1, __m2);
  }
#line 526
  return (__cil_tmp3);
}
}
#line 532
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mullo_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 534
extern int ( /* missing proto */  __builtin_ia32_pmullw)() ;
#line 532 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mullo_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 534
  __cil_tmp3 = __builtin_ia32_pmullw(__m1, __m2);
  }
#line 534
  return (__cil_tmp3);
}
}
#line 538
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmullw)(__m64 __m1 , __m64 __m2 ) ;
#line 538 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmullw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 540
  __cil_tmp3 = _mm_mullo_pi16(__m1, __m2);
  }
#line 540
  return (__cil_tmp3);
}
}
#line 545
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 547
extern int ( /* missing proto */  __builtin_ia32_psllw)() ;
#line 545 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 547
  __cil_tmp3 = __builtin_ia32_psllw(__m, __count);
  }
#line 547
  return (__cil_tmp3);
}
}
#line 551
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllw)(__m64 __m , __m64 __count ) ;
#line 551 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 553
  __cil_tmp3 = _mm_sll_pi16(__m, __count);
  }
#line 553
  return (__cil_tmp3);
}
}
#line 557
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 559
extern int ( /* missing proto */  __builtin_ia32_psllwi)() ;
#line 557 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 559
  __cil_tmp3 = __builtin_ia32_psllwi(__m, __count);
  }
#line 559
  return (__cil_tmp3);
}
}
#line 563
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllwi)(__m64 __m , int __count ) ;
#line 563 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllwi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 565
  __cil_tmp3 = _mm_slli_pi16(__m, __count);
  }
#line 565
  return (__cil_tmp3);
}
}
#line 570
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 572
extern int ( /* missing proto */  __builtin_ia32_pslld)() ;
#line 570 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 572
  __cil_tmp3 = __builtin_ia32_pslld(__m, __count);
  }
#line 572
  return (__cil_tmp3);
}
}
#line 576
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslld)(__m64 __m , __m64 __count ) ;
#line 576 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslld)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 578
  __cil_tmp3 = _mm_sll_pi32(__m, __count);
  }
#line 578
  return (__cil_tmp3);
}
}
#line 582
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 584
extern int ( /* missing proto */  __builtin_ia32_pslldi)() ;
#line 582 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 584
  __cil_tmp3 = __builtin_ia32_pslldi(__m, __count);
  }
#line 584
  return (__cil_tmp3);
}
}
#line 588
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslldi)(__m64 __m , int __count ) ;
#line 588 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslldi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 590
  __cil_tmp3 = _mm_slli_pi32(__m, __count);
  }
#line 590
  return (__cil_tmp3);
}
}
#line 595
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_si64)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 597
extern int ( /* missing proto */  __builtin_ia32_psllq)() ;
#line 595 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_si64)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 597
  __cil_tmp3 = __builtin_ia32_psllq(__m, __count);
  }
#line 597
  return (__cil_tmp3);
}
}
#line 601
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllq)(__m64 __m , __m64 __count ) ;
#line 601 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllq)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 603
  __cil_tmp3 = _mm_sll_si64(__m, __count);
  }
#line 603
  return (__cil_tmp3);
}
}
#line 607
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_si64)(__m64 __m ,
                                                                       int __count ) ;
#line 609
extern int ( /* missing proto */  __builtin_ia32_psllqi)() ;
#line 607 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_si64)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 609
  __cil_tmp3 = __builtin_ia32_psllqi(__m, __count);
  }
#line 609
  return (__cil_tmp3);
}
}
#line 613
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllqi)(__m64 __m , int __count ) ;
#line 613 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllqi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 615
  __cil_tmp3 = _mm_slli_si64(__m, __count);
  }
#line 615
  return (__cil_tmp3);
}
}
#line 620
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 622
extern int ( /* missing proto */  __builtin_ia32_psraw)() ;
#line 620 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 622
  __cil_tmp3 = __builtin_ia32_psraw(__m, __count);
  }
#line 622
  return (__cil_tmp3);
}
}
#line 626
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psraw)(__m64 __m , __m64 __count ) ;
#line 626 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psraw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 628
  __cil_tmp3 = _mm_sra_pi16(__m, __count);
  }
#line 628
  return (__cil_tmp3);
}
}
#line 632
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 634
extern int ( /* missing proto */  __builtin_ia32_psrawi)() ;
#line 632 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 634
  __cil_tmp3 = __builtin_ia32_psrawi(__m, __count);
  }
#line 634
  return (__cil_tmp3);
}
}
#line 638
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrawi)(__m64 __m , int __count ) ;
#line 638 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrawi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 640
  __cil_tmp3 = _mm_srai_pi16(__m, __count);
  }
#line 640
  return (__cil_tmp3);
}
}
#line 645
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 647
extern int ( /* missing proto */  __builtin_ia32_psrad)() ;
#line 645 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 647
  __cil_tmp3 = __builtin_ia32_psrad(__m, __count);
  }
#line 647
  return (__cil_tmp3);
}
}
#line 651
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrad)(__m64 __m , __m64 __count ) ;
#line 651 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrad)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 653
  __cil_tmp3 = _mm_sra_pi32(__m, __count);
  }
#line 653
  return (__cil_tmp3);
}
}
#line 657
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 659
extern int ( /* missing proto */  __builtin_ia32_psradi)() ;
#line 657 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 659
  __cil_tmp3 = __builtin_ia32_psradi(__m, __count);
  }
#line 659
  return (__cil_tmp3);
}
}
#line 663
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psradi)(__m64 __m , int __count ) ;
#line 663 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psradi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 665
  __cil_tmp3 = _mm_srai_pi32(__m, __count);
  }
#line 665
  return (__cil_tmp3);
}
}
#line 670
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 672
extern int ( /* missing proto */  __builtin_ia32_psrlw)() ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 672
  __cil_tmp3 = __builtin_ia32_psrlw(__m, __count);
  }
#line 672
  return (__cil_tmp3);
}
}
#line 676
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlw)(__m64 __m , __m64 __count ) ;
#line 676 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 678
  __cil_tmp3 = _mm_srl_pi16(__m, __count);
  }
#line 678
  return (__cil_tmp3);
}
}
#line 682
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 684
extern int ( /* missing proto */  __builtin_ia32_psrlwi)() ;
#line 682 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 684
  __cil_tmp3 = __builtin_ia32_psrlwi(__m, __count);
  }
#line 684
  return (__cil_tmp3);
}
}
#line 688
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlwi)(__m64 __m , int __count ) ;
#line 688 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlwi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 690
  __cil_tmp3 = _mm_srli_pi16(__m, __count);
  }
#line 690
  return (__cil_tmp3);
}
}
#line 695
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 697
extern int ( /* missing proto */  __builtin_ia32_psrld)() ;
#line 695 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 697
  __cil_tmp3 = __builtin_ia32_psrld(__m, __count);
  }
#line 697
  return (__cil_tmp3);
}
}
#line 701
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrld)(__m64 __m , __m64 __count ) ;
#line 701 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrld)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 703
  __cil_tmp3 = _mm_srl_pi32(__m, __count);
  }
#line 703
  return (__cil_tmp3);
}
}
#line 707
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 709
extern int ( /* missing proto */  __builtin_ia32_psrldi)() ;
#line 707 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 709
  __cil_tmp3 = __builtin_ia32_psrldi(__m, __count);
  }
#line 709
  return (__cil_tmp3);
}
}
#line 713
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrldi)(__m64 __m , int __count ) ;
#line 713 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrldi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 715
  __cil_tmp3 = _mm_srli_pi32(__m, __count);
  }
#line 715
  return (__cil_tmp3);
}
}
#line 720
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_si64)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 722
extern int ( /* missing proto */  __builtin_ia32_psrlq)() ;
#line 720 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_si64)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 722
  __cil_tmp3 = __builtin_ia32_psrlq(__m, __count);
  }
#line 722
  return (__cil_tmp3);
}
}
#line 726
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlq)(__m64 __m , __m64 __count ) ;
#line 726 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlq)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 728
  __cil_tmp3 = _mm_srl_si64(__m, __count);
  }
#line 728
  return (__cil_tmp3);
}
}
#line 732
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_si64)(__m64 __m ,
                                                                       int __count ) ;
#line 734
extern int ( /* missing proto */  __builtin_ia32_psrlqi)() ;
#line 732 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_si64)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 734
  __cil_tmp3 = __builtin_ia32_psrlqi(__m, __count);
  }
#line 734
  return (__cil_tmp3);
}
}
#line 738
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlqi)(__m64 __m , int __count ) ;
#line 738 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlqi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 740
  __cil_tmp3 = _mm_srli_si64(__m, __count);
  }
#line 740
  return (__cil_tmp3);
}
}
#line 745
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_and_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 747
extern int ( /* missing proto */  __builtin_ia32_pand)() ;
#line 745 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_and_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 747
  __cil_tmp3 = __builtin_ia32_pand(__m1, __m2);
  }
#line 747
  return (__cil_tmp3);
}
}
#line 751
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pand)(__m64 __m1 , __m64 __m2 ) ;
#line 751 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pand)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 753
  __cil_tmp3 = _mm_and_si64(__m1, __m2);
  }
#line 753
  return (__cil_tmp3);
}
}
#line 759
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_andnot_si64)(__m64 __m1 ,
                                                                         __m64 __m2 ) ;
#line 761
extern int ( /* missing proto */  __builtin_ia32_pandn)() ;
#line 759 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_andnot_si64)(__m64 __m1 ,
                                                                         __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 761
  __cil_tmp3 = __builtin_ia32_pandn(__m1, __m2);
  }
#line 761
  return (__cil_tmp3);
}
}
#line 765
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pandn)(__m64 __m1 , __m64 __m2 ) ;
#line 765 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pandn)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 767
  __cil_tmp3 = _mm_andnot_si64(__m1, __m2);
  }
#line 767
  return (__cil_tmp3);
}
}
#line 772
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_or_si64)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 774
extern int ( /* missing proto */  __builtin_ia32_por)() ;
#line 772 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_or_si64)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 774
  __cil_tmp3 = __builtin_ia32_por(__m1, __m2);
  }
#line 774
  return (__cil_tmp3);
}
}
#line 778
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_por)(__m64 __m1 , __m64 __m2 ) ;
#line 778 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_por)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 780
  __cil_tmp3 = _mm_or_si64(__m1, __m2);
  }
#line 780
  return (__cil_tmp3);
}
}
#line 785
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_xor_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 787
extern int ( /* missing proto */  __builtin_ia32_pxor)() ;
#line 785 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_xor_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 787
  __cil_tmp3 = __builtin_ia32_pxor(__m1, __m2);
  }
#line 787
  return (__cil_tmp3);
}
}
#line 791
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pxor)(__m64 __m1 , __m64 __m2 ) ;
#line 791 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pxor)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 793
  __cil_tmp3 = _mm_xor_si64(__m1, __m2);
  }
#line 793
  return (__cil_tmp3);
}
}
#line 799
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 801
extern int ( /* missing proto */  __builtin_ia32_pcmpeqb)() ;
#line 799 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 801
  __cil_tmp3 = __builtin_ia32_pcmpeqb(__m1, __m2);
  }
#line 801
  return (__cil_tmp3);
}
}
#line 805
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqb)(__m64 __m1 , __m64 __m2 ) ;
#line 805 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 807
  __cil_tmp3 = _mm_cmpeq_pi8(__m1, __m2);
  }
#line 807
  return (__cil_tmp3);
}
}
#line 811
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 813
extern int ( /* missing proto */  __builtin_ia32_pcmpgtb)() ;
#line 811 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 813
  __cil_tmp3 = __builtin_ia32_pcmpgtb(__m1, __m2);
  }
#line 813
  return (__cil_tmp3);
}
}
#line 817
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtb)(__m64 __m1 , __m64 __m2 ) ;
#line 817 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 819
  __cil_tmp3 = _mm_cmpgt_pi8(__m1, __m2);
  }
#line 819
  return (__cil_tmp3);
}
}
#line 825
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 827
extern int ( /* missing proto */  __builtin_ia32_pcmpeqw)() ;
#line 825 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 827
  __cil_tmp3 = __builtin_ia32_pcmpeqw(__m1, __m2);
  }
#line 827
  return (__cil_tmp3);
}
}
#line 831
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqw)(__m64 __m1 , __m64 __m2 ) ;
#line 831 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 833
  __cil_tmp3 = _mm_cmpeq_pi16(__m1, __m2);
  }
#line 833
  return (__cil_tmp3);
}
}
#line 837
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 839
extern int ( /* missing proto */  __builtin_ia32_pcmpgtw)() ;
#line 837 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 839
  __cil_tmp3 = __builtin_ia32_pcmpgtw(__m1, __m2);
  }
#line 839
  return (__cil_tmp3);
}
}
#line 843
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtw)(__m64 __m1 , __m64 __m2 ) ;
#line 843 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 845
  __cil_tmp3 = _mm_cmpgt_pi16(__m1, __m2);
  }
#line 845
  return (__cil_tmp3);
}
}
#line 851
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 853
extern int ( /* missing proto */  __builtin_ia32_pcmpeqd)() ;
#line 851 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 853
  __cil_tmp3 = __builtin_ia32_pcmpeqd(__m1, __m2);
  }
#line 853
  return (__cil_tmp3);
}
}
#line 857
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqd)(__m64 __m1 , __m64 __m2 ) ;
#line 857 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 859
  __cil_tmp3 = _mm_cmpeq_pi32(__m1, __m2);
  }
#line 859
  return (__cil_tmp3);
}
}
#line 863
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 865
extern int ( /* missing proto */  __builtin_ia32_pcmpgtd)() ;
#line 863 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 865
  __cil_tmp3 = __builtin_ia32_pcmpgtd(__m1, __m2);
  }
#line 865
  return (__cil_tmp3);
}
}
#line 869
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtd)(__m64 __m1 , __m64 __m2 ) ;
#line 869 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 871
  __cil_tmp3 = _mm_cmpgt_pi32(__m1, __m2);
  }
#line 871
  return (__cil_tmp3);
}
}
#line 876
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setzero_si64)(void) ;
#line 876 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setzero_si64)(void) 
{ 


  {
#line 878
  return ((__m64 )0LL);
}
}
#line 883
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi32)(int __i1 , int __i0 ) ;
#line 883 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi32)(int __i1 , int __i0 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 885
  __cil_tmp3 = __builtin_ia32_vec_init_v2si(__i0, __i1);
  }
#line 885
  return (__cil_tmp3);
}
}
#line 890
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi16)(short __w3 ,
                                                                      short __w2 ,
                                                                      short __w1 ,
                                                                      short __w0 ) ;
#line 892
extern int ( /* missing proto */  __builtin_ia32_vec_init_v4hi)() ;
#line 890 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi16)(short __w3 ,
                                                                      short __w2 ,
                                                                      short __w1 ,
                                                                      short __w0 ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 892
  __cil_tmp5 = __builtin_ia32_vec_init_v4hi((int )__w0, (int )__w1, (int )__w2, (int )__w3);
  }
#line 892
  return (__cil_tmp5);
}
}
#line 897
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi8)(char __b7 , char __b6 ,
                                                                     char __b5 , char __b4 ,
                                                                     char __b3 , char __b2 ,
                                                                     char __b1 , char __b0 ) ;
#line 900
extern int ( /* missing proto */  __builtin_ia32_vec_init_v8qi)() ;
#line 897 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi8)(char __b7 , char __b6 ,
                                                                     char __b5 , char __b4 ,
                                                                     char __b3 , char __b2 ,
                                                                     char __b1 , char __b0 ) 
{ 
  int __cil_tmp9 ;

  {
  {
#line 900
  __cil_tmp9 = __builtin_ia32_vec_init_v8qi((int )__b0, (int )__b1, (int )__b2, (int )__b3,
                                            (int )__b4, (int )__b5, (int )__b6, (int )__b7);
  }
#line 900
  return (__cil_tmp9);
}
}
#line 906
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi32)(int __i0 ,
                                                                       int __i1 ) ;
#line 906 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi32)(int __i0 ,
                                                                       int __i1 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 908
  __cil_tmp3 = _mm_set_pi32(__i1, __i0);
  }
#line 908
  return (__cil_tmp3);
}
}
#line 912
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi16)(short __w0 ,
                                                                       short __w1 ,
                                                                       short __w2 ,
                                                                       short __w3 ) ;
#line 912 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi16)(short __w0 ,
                                                                       short __w1 ,
                                                                       short __w2 ,
                                                                       short __w3 ) 
{ 
  __m64 __cil_tmp5 ;

  {
  {
#line 914
  __cil_tmp5 = _mm_set_pi16(__w3, __w2, __w1, __w0);
  }
#line 914
  return (__cil_tmp5);
}
}
#line 918
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi8)(char __b0 ,
                                                                      char __b1 ,
                                                                      char __b2 ,
                                                                      char __b3 ,
                                                                      char __b4 ,
                                                                      char __b5 ,
                                                                      char __b6 ,
                                                                      char __b7 ) ;
#line 918 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi8)(char __b0 ,
                                                                      char __b1 ,
                                                                      char __b2 ,
                                                                      char __b3 ,
                                                                      char __b4 ,
                                                                      char __b5 ,
                                                                      char __b6 ,
                                                                      char __b7 ) 
{ 
  __m64 __cil_tmp9 ;

  {
  {
#line 921
  __cil_tmp9 = _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
  }
#line 921
  return (__cil_tmp9);
}
}
#line 926
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi32)(int __i ) ;
#line 926 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi32)(int __i ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 928
  __cil_tmp2 = _mm_set_pi32(__i, __i);
  }
#line 928
  return (__cil_tmp2);
}
}
#line 933
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi16)(short __w ) ;
#line 933 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi16)(short __w ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 935
  __cil_tmp2 = _mm_set_pi16(__w, __w, __w, __w);
  }
#line 935
  return (__cil_tmp2);
}
}
#line 940
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi8)(char __b ) ;
#line 940 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi8)(char __b ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 942
  __cil_tmp2 = _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
  }
#line 942
  return (__cil_tmp2);
}
}
#line 110 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_undefined_ps)(void) ;
#line 110 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_undefined_ps)(void) 
{ 
  __m128 __Y ;

  {
#line 112
  __Y = __Y;
#line 113
  return (__Y);
}
}
#line 118
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_setzero_ps)(void) ;
#line 118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_setzero_ps)(void) 
{ 
  __m128 tmp ;

  {
#line 120
  return (tmp);
}
}
#line 128
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 128 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 133
  return;
}
}
#line 152
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ss)(__m128 __A ) ;
#line 154
extern int ( /* missing proto */  __builtin_ia32_sqrtss)() ;
#line 152 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 154
  __cil_tmp2 = __builtin_ia32_sqrtss(__A);
  }
#line 154
  return (__cil_tmp2);
}
}
#line 158
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ss)(__m128 __A ) ;
#line 160
extern int ( /* missing proto */  __builtin_ia32_rcpss)() ;
#line 158 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 160
  __cil_tmp2 = __builtin_ia32_rcpss(__A);
  }
#line 160
  return (__cil_tmp2);
}
}
#line 164
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ss)(__m128 __A ) ;
#line 166
extern int ( /* missing proto */  __builtin_ia32_rsqrtss)() ;
#line 164 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 166
  __cil_tmp2 = __builtin_ia32_rsqrtss(__A);
  }
#line 166
  return (__cil_tmp2);
}
}
#line 170
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 172
extern int ( /* missing proto */  __builtin_ia32_minss)() ;
#line 170 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 172
  __cil_tmp3 = __builtin_ia32_minss(__A, __B);
  }
#line 172
  return (__cil_tmp3);
}
}
#line 176
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 178
extern int ( /* missing proto */  __builtin_ia32_maxss)() ;
#line 176 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 178
  __cil_tmp3 = __builtin_ia32_maxss(__A, __B);
  }
#line 178
  return (__cil_tmp3);
}
}
#line 184
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 184 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 186
  return (__A + __B);
}
}
#line 190
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sub_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 190 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sub_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 192
  return (__A - __B);
}
}
#line 196
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_mul_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 196 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_mul_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 198
  return (__A * __B);
}
}
#line 202
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_div_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 202 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_div_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 204
  return (__A / __B);
}
}
#line 208
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ps)(__m128 __A ) ;
#line 210
extern int ( /* missing proto */  __builtin_ia32_sqrtps)() ;
#line 208 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 210
  __cil_tmp2 = __builtin_ia32_sqrtps(__A);
  }
#line 210
  return (__cil_tmp2);
}
}
#line 214
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ps)(__m128 __A ) ;
#line 216
extern int ( /* missing proto */  __builtin_ia32_rcpps)() ;
#line 214 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 216
  __cil_tmp2 = __builtin_ia32_rcpps(__A);
  }
#line 216
  return (__cil_tmp2);
}
}
#line 220
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ps)(__m128 __A ) ;
#line 222
extern int ( /* missing proto */  __builtin_ia32_rsqrtps)() ;
#line 220 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 222
  __cil_tmp2 = __builtin_ia32_rsqrtps(__A);
  }
#line 222
  return (__cil_tmp2);
}
}
#line 226
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 228
extern int ( /* missing proto */  __builtin_ia32_minps)() ;
#line 226 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 228
  __cil_tmp3 = __builtin_ia32_minps(__A, __B);
  }
#line 228
  return (__cil_tmp3);
}
}
#line 232
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  float __attribute__((__vector_size__(16)))  __cil_tmp3 ;
  float __attribute__((____vector_size____(16)))  tmp ;

  {
  {
#line 234
  tmp = __builtin_ia32_maxps((float __attribute__((____vector_size____(16)))  )__A,
                             (float __attribute__((____vector_size____(16)))  )__B);
#line 234
  __cil_tmp3 = (float __attribute__((__vector_size__(16)))  )tmp;
  }
#line 234
  return ((__m128 )__cil_tmp3);
}
}
#line 268
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 270
extern int ( /* missing proto */  __builtin_ia32_cmpeqss)() ;
#line 268 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 270
  __cil_tmp3 = __builtin_ia32_cmpeqss(__A, __B);
  }
#line 270
  return (__cil_tmp3);
}
}
#line 274
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 276
extern int ( /* missing proto */  __builtin_ia32_cmpltss)() ;
#line 274 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 276
  __cil_tmp3 = __builtin_ia32_cmpltss(__A, __B);
  }
#line 276
  return (__cil_tmp3);
}
}
#line 280
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 282
extern int ( /* missing proto */  __builtin_ia32_cmpless)() ;
#line 280 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 282
  __cil_tmp3 = __builtin_ia32_cmpless(__A, __B);
  }
#line 282
  return (__cil_tmp3);
}
}
#line 306
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 308
extern int ( /* missing proto */  __builtin_ia32_cmpneqss)() ;
#line 306 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 308
  __cil_tmp3 = __builtin_ia32_cmpneqss(__A, __B);
  }
#line 308
  return (__cil_tmp3);
}
}
#line 312
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 314
extern int ( /* missing proto */  __builtin_ia32_cmpnltss)() ;
#line 312 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 314
  __cil_tmp3 = __builtin_ia32_cmpnltss(__A, __B);
  }
#line 314
  return (__cil_tmp3);
}
}
#line 318
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 320
extern int ( /* missing proto */  __builtin_ia32_cmpnless)() ;
#line 318 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 320
  __cil_tmp3 = __builtin_ia32_cmpnless(__A, __B);
  }
#line 320
  return (__cil_tmp3);
}
}
#line 344
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 346
extern int ( /* missing proto */  __builtin_ia32_cmpordss)() ;
#line 344 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_ia32_cmpordss(__A, __B);
  }
#line 346
  return (__cil_tmp3);
}
}
#line 350
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ss)(__m128 __A ,
                                                                          __m128 __B ) ;
#line 352
extern int ( /* missing proto */  __builtin_ia32_cmpunordss)() ;
#line 350 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ss)(__m128 __A ,
                                                                          __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 352
  __cil_tmp3 = __builtin_ia32_cmpunordss(__A, __B);
  }
#line 352
  return (__cil_tmp3);
}
}
#line 360
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 362
extern int ( /* missing proto */  __builtin_ia32_cmpeqps)() ;
#line 360 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 362
  __cil_tmp3 = __builtin_ia32_cmpeqps(__A, __B);
  }
#line 362
  return (__cil_tmp3);
}
}
#line 366
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 368
extern int ( /* missing proto */  __builtin_ia32_cmpltps)() ;
#line 366 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 368
  __cil_tmp3 = __builtin_ia32_cmpltps(__A, __B);
  }
#line 368
  return (__cil_tmp3);
}
}
#line 372
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 374
extern int ( /* missing proto */  __builtin_ia32_cmpleps)() ;
#line 372 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 374
  __cil_tmp3 = __builtin_ia32_cmpleps(__A, __B);
  }
#line 374
  return (__cil_tmp3);
}
}
#line 390
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 392
extern int ( /* missing proto */  __builtin_ia32_cmpneqps)() ;
#line 390 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 392
  __cil_tmp3 = __builtin_ia32_cmpneqps(__A, __B);
  }
#line 392
  return (__cil_tmp3);
}
}
#line 396
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 398
extern int ( /* missing proto */  __builtin_ia32_cmpnltps)() ;
#line 396 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 398
  __cil_tmp3 = __builtin_ia32_cmpnltps(__A, __B);
  }
#line 398
  return (__cil_tmp3);
}
}
#line 402
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 404
extern int ( /* missing proto */  __builtin_ia32_cmpnleps)() ;
#line 402 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 404
  __cil_tmp3 = __builtin_ia32_cmpnleps(__A, __B);
  }
#line 404
  return (__cil_tmp3);
}
}
#line 420
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 422
extern int ( /* missing proto */  __builtin_ia32_cmpordps)() ;
#line 420 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 422
  __cil_tmp3 = __builtin_ia32_cmpordps(__A, __B);
  }
#line 422
  return (__cil_tmp3);
}
}
#line 426
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ps)(__m128 __A ,
                                                                          __m128 __B ) ;
#line 428
extern int ( /* missing proto */  __builtin_ia32_cmpunordps)() ;
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ps)(__m128 __A ,
                                                                          __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 428
  __cil_tmp3 = __builtin_ia32_cmpunordps(__A, __B);
  }
#line 428
  return (__cil_tmp3);
}
}
#line 435
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 437
extern int ( /* missing proto */  __builtin_ia32_comieq)() ;
#line 435 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 437
  __cil_tmp3 = __builtin_ia32_comieq(__A, __B);
  }
#line 437
  return (__cil_tmp3);
}
}
#line 441
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 443
extern int ( /* missing proto */  __builtin_ia32_comilt)() ;
#line 441 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 443
  __cil_tmp3 = __builtin_ia32_comilt(__A, __B);
  }
#line 443
  return (__cil_tmp3);
}
}
#line 447
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 449
extern int ( /* missing proto */  __builtin_ia32_comile)() ;
#line 447 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 449
  __cil_tmp3 = __builtin_ia32_comile(__A, __B);
  }
#line 449
  return (__cil_tmp3);
}
}
#line 453
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 455
extern int ( /* missing proto */  __builtin_ia32_comigt)() ;
#line 453 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = __builtin_ia32_comigt(__A, __B);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 459
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 461
extern int ( /* missing proto */  __builtin_ia32_comige)() ;
#line 459 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 461
  __cil_tmp3 = __builtin_ia32_comige(__A, __B);
  }
#line 461
  return (__cil_tmp3);
}
}
#line 465
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 467
extern int ( /* missing proto */  __builtin_ia32_comineq)() ;
#line 465 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 467
  __cil_tmp3 = __builtin_ia32_comineq(__A, __B);
  }
#line 467
  return (__cil_tmp3);
}
}
#line 471
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 473
extern int ( /* missing proto */  __builtin_ia32_ucomieq)() ;
#line 471 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 473
  __cil_tmp3 = __builtin_ia32_ucomieq(__A, __B);
  }
#line 473
  return (__cil_tmp3);
}
}
#line 477
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 479
extern int ( /* missing proto */  __builtin_ia32_ucomilt)() ;
#line 477 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 479
  __cil_tmp3 = __builtin_ia32_ucomilt(__A, __B);
  }
#line 479
  return (__cil_tmp3);
}
}
#line 483
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 485
extern int ( /* missing proto */  __builtin_ia32_ucomile)() ;
#line 483 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 485
  __cil_tmp3 = __builtin_ia32_ucomile(__A, __B);
  }
#line 485
  return (__cil_tmp3);
}
}
#line 489
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 491
extern int ( /* missing proto */  __builtin_ia32_ucomigt)() ;
#line 489 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 491
  __cil_tmp3 = __builtin_ia32_ucomigt(__A, __B);
  }
#line 491
  return (__cil_tmp3);
}
}
#line 495
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 497
extern int ( /* missing proto */  __builtin_ia32_ucomige)() ;
#line 495 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 497
  __cil_tmp3 = __builtin_ia32_ucomige(__A, __B);
  }
#line 497
  return (__cil_tmp3);
}
}
#line 501
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 503
extern int ( /* missing proto */  __builtin_ia32_ucomineq)() ;
#line 501 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 503
  __cil_tmp3 = __builtin_ia32_ucomineq(__A, __B);
  }
#line 503
  return (__cil_tmp3);
}
}
#line 509
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtss_si32)(__m128 __A ) ;
#line 511
extern int ( /* missing proto */  __builtin_ia32_cvtss2si)() ;
#line 509 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtss_si32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 511
  __cil_tmp2 = __builtin_ia32_cvtss2si(__A);
  }
#line 511
  return (__cil_tmp2);
}
}
#line 515
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvt_ss2si)(__m128 __A ) ;
#line 515 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvt_ss2si)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 517
  __cil_tmp2 = _mm_cvtss_si32(__A);
  }
#line 517
  return (__cil_tmp2);
}
}
#line 526
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtss_si64)(__m128 __A ) ;
#line 528
extern int ( /* missing proto */  __builtin_ia32_cvtss2si64)() ;
#line 526 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtss_si64)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 528
  __cil_tmp2 = __builtin_ia32_cvtss2si64(__A);
  }
#line 528
  return ((long long )__cil_tmp2);
}
}
#line 542
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi32)(__m128 __A ) ;
#line 544
extern int ( /* missing proto */  __builtin_ia32_cvtps2pi)() ;
#line 542 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 544
  __cil_tmp2 = __builtin_ia32_cvtps2pi(__A);
  }
#line 544
  return (__cil_tmp2);
}
}
#line 548
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvt_ps2pi)(__m128 __A ) ;
#line 548 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvt_ps2pi)(__m128 __A ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 550
  __cil_tmp2 = _mm_cvtps_pi32(__A);
  }
#line 550
  return (__cil_tmp2);
}
}
#line 555
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttss_si32)(__m128 __A ) ;
#line 557
extern int ( /* missing proto */  __builtin_ia32_cvttss2si)() ;
#line 555 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttss_si32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 557
  __cil_tmp2 = __builtin_ia32_cvttss2si(__A);
  }
#line 557
  return (__cil_tmp2);
}
}
#line 561
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtt_ss2si)(__m128 __A ) ;
#line 561 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtt_ss2si)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 563
  __cil_tmp2 = _mm_cvttss_si32(__A);
  }
#line 563
  return (__cil_tmp2);
}
}
#line 571
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttss_si64)(__m128 __A ) ;
#line 573
extern int ( /* missing proto */  __builtin_ia32_cvttss2si64)() ;
#line 571 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttss_si64)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 573
  __cil_tmp2 = __builtin_ia32_cvttss2si64(__A);
  }
#line 573
  return ((long long )__cil_tmp2);
}
}
#line 587
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttps_pi32)(__m128 __A ) ;
#line 589
extern int ( /* missing proto */  __builtin_ia32_cvttps2pi)() ;
#line 587 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttps_pi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 589
  __cil_tmp2 = __builtin_ia32_cvttps2pi(__A);
  }
#line 589
  return (__cil_tmp2);
}
}
#line 593
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtt_ps2pi)(__m128 __A ) ;
#line 593 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtt_ps2pi)(__m128 __A ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 595
  __cil_tmp2 = _mm_cvttps_pi32(__A);
  }
#line 595
  return (__cil_tmp2);
}
}
#line 600
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_ss)(__m128 __A ,
                                                                         int __B ) ;
#line 600 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_ss)(__m128 __A ,
                                                                         int __B ) 
{ 


  {
#line 605
  return;
}
}
#line 606
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_si2ss)(__m128 __A ,
                                                                        int __B ) ;
#line 606 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_si2ss)(__m128 __A ,
                                                                        int __B ) 
{ 
  __m128 __cil_tmp3 ;

  {
  {
#line 608
  __cil_tmp3 = _mm_cvtsi32_ss(__A, __B);
  }
#line 608
  return (__cil_tmp3);
}
}
#line 616
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi64_ss)(__m128 __A ,
                                                                         long long __B ) ;
#line 616 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi64_ss)(__m128 __A ,
                                                                         long long __B ) 
{ 


  {
#line 621
  return;
}
}
#line 632
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32_ps)(__m128 __A ,
                                                                         __m64 __B ) ;
#line 634
extern int ( /* missing proto */  __builtin_ia32_cvtpi2ps)() ;
#line 632 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32_ps)(__m128 __A ,
                                                                         __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 634
  __cil_tmp3 = __builtin_ia32_cvtpi2ps(__A, __B);
  }
#line 634
  return (__cil_tmp3);
}
}
#line 638
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_pi2ps)(__m128 __A ,
                                                                        __m64 __B ) ;
#line 638 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_pi2ps)(__m128 __A ,
                                                                        __m64 __B ) 
{ 
  __m128 __cil_tmp3 ;

  {
  {
#line 640
  __cil_tmp3 = _mm_cvtpi32_ps(__A, __B);
  }
#line 640
  return (__cil_tmp3);
}
}
#line 645
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi16_ps)(__m64 __A ) ;
#line 645 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi16_ps)(__m64 __A ) 
{ 
  __v4hi __sign ;
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  __m128 __cil_tmp11 ;

  {
  {
#line 654
  __sign = __builtin_ia32_pcmpgtw((__v4hi )0LL, __A);
#line 657
  __cil_tmp9 = __builtin_ia32_punpcklwd(__A, __sign);
#line 657
  __losi = __cil_tmp9;
#line 658
  __cil_tmp10 = __builtin_ia32_punpckhwd(__A, __sign);
#line 658
  __hisi = __cil_tmp10;
#line 661
  __cil_tmp11 = _mm_setzero_ps();
#line 661
  __zero = __cil_tmp11;
#line 662
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
#line 663
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  }
#line 665
  return;
}
}
#line 670
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu16_ps)(__m64 __A ) ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu16_ps)(__m64 __A ) 
{ 
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  __m128 __cil_tmp9 ;

  {
  {
#line 676
  __cil_tmp7 = __builtin_ia32_punpcklwd(__A, (__v4hi )0LL);
#line 676
  __losi = __cil_tmp7;
#line 677
  __cil_tmp8 = __builtin_ia32_punpckhwd(__A, (__v4hi )0LL);
#line 677
  __hisi = __cil_tmp8;
#line 680
  __cil_tmp9 = _mm_setzero_ps();
#line 680
  __zero = __cil_tmp9;
#line 681
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
#line 682
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  }
#line 684
  return;
}
}
#line 689
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi8_ps)(__m64 __A ) ;
#line 689 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi8_ps)(__m64 __A ) 
{ 
  __v8qi __sign ;
  int __cil_tmp4 ;
  __m128 __cil_tmp5 ;

  {
  {
#line 696
  __sign = __builtin_ia32_pcmpgtb((__v8qi )0LL, __A);
#line 699
  __cil_tmp4 = __builtin_ia32_punpcklbw(__A, __sign);
#line 699
  __A = __cil_tmp4;
#line 701
  __cil_tmp5 = _mm_cvtpi16_ps(__A);
  }
#line 701
  return (__cil_tmp5);
}
}
#line 706
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu8_ps)(__m64 __A ) ;
#line 706 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu8_ps)(__m64 __A ) 
{ 
  int __cil_tmp2 ;
  __m128 __cil_tmp3 ;

  {
  {
#line 708
  __cil_tmp2 = __builtin_ia32_punpcklbw(__A, (__v8qi )0LL);
#line 708
  __A = __cil_tmp2;
#line 709
  __cil_tmp3 = _mm_cvtpu16_ps(__A);
  }
#line 709
  return (__cil_tmp3);
}
}
#line 714
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32x2_ps)(__m64 __A ,
                                                                           __m64 __B ) ;
#line 714 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32x2_ps)(__m64 __A ,
                                                                           __m64 __B ) 
{ 
  __v4sf __zero ;
  __m128 __cil_tmp4 ;
  __v4sf __sfa ;
  int __cil_tmp6 ;
  __v4sf __sfb ;
  int __cil_tmp8 ;

  {
  {
#line 716
  __cil_tmp4 = _mm_setzero_ps();
#line 716
  __zero = __cil_tmp4;
#line 717
  __cil_tmp6 = __builtin_ia32_cvtpi2ps(__zero, __A);
#line 717
  __sfa = __cil_tmp6;
#line 718
  __cil_tmp8 = __builtin_ia32_cvtpi2ps(__sfa, __B);
#line 718
  __sfb = __cil_tmp8;
  }
#line 720
  return;
}
}
#line 724
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi16)(__m128 __A ) ;
#line 724 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi16)(__m128 __A ) 
{ 
  __v4sf __hisf ;
  __v4sf __losf ;
  __v2si __hisi ;
  int __cil_tmp5 ;
  __v2si __losi ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 726
  __hisf = __A;
#line 727
  __losf = 0;
#line 728
  __cil_tmp5 = __builtin_ia32_cvtps2pi(__hisf);
#line 728
  __hisi = __cil_tmp5;
#line 729
  __cil_tmp7 = __builtin_ia32_cvtps2pi(__losf);
#line 729
  __losi = __cil_tmp7;
#line 730
  __cil_tmp8 = __builtin_ia32_packssdw(__hisi, __losi);
  }
#line 730
  return (__cil_tmp8);
}
}
#line 735
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi8)(__m128 __A ) ;
#line 735 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi8)(__m128 __A ) 
{ 
  __v4hi __tmp ;
  __m64 __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 737
  __cil_tmp3 = _mm_cvtps_pi16(__A);
#line 737
  __tmp = __cil_tmp3;
#line 738
  __cil_tmp4 = __builtin_ia32_packsswb(__tmp, (__v4hi )0LL);
  }
#line 738
  return (__cil_tmp4);
}
}
#line 771
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadh_pi)(__m128 __A ,
                                                                       __m64 *__P ) ;
#line 771 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadh_pi)(__m128 __A ,
                                                                       __m64 *__P ) 
{ 


  {
#line 776
  return;
}
}
#line 778
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeh_pi)(__m64 *__P ,
                                                                      __m128 __A ) ;
#line 780
extern int ( /* missing proto */  __builtin_ia32_storehps)() ;
#line 778 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeh_pi)(__m64 *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 780
  __builtin_ia32_storehps(__P, __A);
  }
#line 782
  return;
}
}
#line 807
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pi)(__m64 *__P ,
                                                                      __m128 __A ) ;
#line 809
extern int ( /* missing proto */  __builtin_ia32_storelps)() ;
#line 807 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pi)(__m64 *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 809
  __builtin_ia32_storelps(__P, __A);
  }
#line 811
  return;
}
}
#line 814
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_ps)(__m128 __A ) ;
#line 816
extern int ( /* missing proto */  __builtin_ia32_movmskps)() ;
#line 814 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 816
  __cil_tmp2 = __builtin_ia32_movmskps(__A);
  }
#line 816
  return (__cil_tmp2);
}
}
#line 821
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) ;
#line 823
extern int ( /* missing proto */  __builtin_ia32_stmxcsr)() ;
#line 821
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) ;
#line 821 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 823
  __cil_tmp1 = __builtin_ia32_stmxcsr();
  }
#line 823
  return ((unsigned int )__cil_tmp1);
}
}
#line 828
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _MM_GET_EXCEPTION_STATE)(void) ;
#line 828 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _MM_GET_EXCEPTION_STATE)(void) 
{ 


  {
#line 833
  return (0U);
}
}
#line 853
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) ;
#line 855
extern int ( /* missing proto */  __builtin_ia32_ldmxcsr)() ;
#line 853
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) ;
#line 853 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) 
{ 


  {
  {
#line 855
  __builtin_ia32_ldmxcsr(__I);
  }
#line 857
  return;
}
}
#line 860
__inline extern void ( __attribute__((__gnu_inline__)) _MM_SET_EXCEPTION_STATE)(unsigned int __mask ) ;
#line 860 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _MM_SET_EXCEPTION_STATE)(unsigned int __mask ) 
{ 


  {
#line 865
  return;
}
}
#line 885
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ss)(float __F ) ;
#line 885 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ss)(float __F ) 
{ 
  __v4sf tmp ;

  {
#line 887
  return (tmp);
}
}
#line 898
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps1)(float __F ) ;
#line 898 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps1)(float __F ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 900
  __cil_tmp2 = _mm_set_ss(__F);
  }
#line 900
  return (__cil_tmp2);
}
}
#line 905
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ss)(float const   *__P ) ;
#line 905 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ss)(float const   *__P ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 907
  __cil_tmp2 = _mm_set_ss((float )*__P);
  }
#line 907
  return (__cil_tmp2);
}
}
#line 918
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps1)(float const   *__P ) ;
#line 918 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps1)(float const   *__P ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 920
  __cil_tmp2 = _mm_load_ss(__P);
  }
#line 920
  return (__cil_tmp2);
}
}
#line 925
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps)(float const   *__P ) ;
#line 925 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps)(float const   *__P ) 
{ 


  {
#line 927
  return (*((__m128 *)__P));
}
}
#line 932
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadu_ps)(float const   *__P ) ;
#line 932 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadu_ps)(float const   *__P ) 
{ 


  {
#line 934
  return (*((__m128_u *)__P));
}
}
#line 939
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadr_ps)(float const   *__P ) ;
#line 942
extern int ( /* missing proto */  __builtin_ia32_shufps)() ;
#line 939 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadr_ps)(float const   *__P ) 
{ 
  __v4sf __tmp ;
  int __cil_tmp3 ;

  {
  {
#line 941
  __tmp = *((__v4sf *)__P);
#line 942
  __cil_tmp3 = __builtin_ia32_shufps(__tmp, __tmp, ((1 << 4) | (2 << 2)) | 3);
  }
#line 942
  return (__cil_tmp3);
}
}
#line 947
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps)(float __Z , float __Y ,
                                                                     float __X , float __W ) ;
#line 947 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps)(float __Z , float __Y ,
                                                                     float __X , float __W ) 
{ 
  __v4sf tmp ;

  {
#line 949
  return (tmp);
}
}
#line 961
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ss)(float *__P ,
                                                                     __m128 __A ) ;
#line 961 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ss)(float *__P ,
                                                                     __m128 __A ) 
{ 
  int __cil_tmp3 ;

  {
#line 963
  *__P = (float )__cil_tmp3;
#line 964
  return;
}
}
#line 967
__inline extern float ( __attribute__((__gnu_inline__)) _mm_cvtss_f32)(__m128 __A ) ;
#line 967 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern float ( __attribute__((__gnu_inline__)) _mm_cvtss_f32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 969
  return ((float )__cil_tmp2);
}
}
#line 974
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps)(float *__P ,
                                                                     __m128 __A ) ;
#line 974 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps)(float *__P ,
                                                                     __m128 __A ) 
{ 


  {
#line 976
  *((__m128 *)__P) = __A;
#line 977
  return;
}
}
#line 981
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 981 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
#line 983
  *((__m128_u *)__P) = __A;
#line 984
  return;
}
}
#line 988
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 988 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int __cil_tmp5 ;

  {
  {
#line 990
  __va = __A;
#line 991
  __cil_tmp5 = __builtin_ia32_shufps(__va, __va, 0);
#line 991
  __tmp = __cil_tmp5;
#line 992
  _mm_storeu_ps(__P, __tmp);
  }
#line 994
  return;
}
}
#line 996
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps1)(float *__P ,
                                                                      __m128 __A ) ;
#line 996 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps1)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 998
  _mm_store1_ps(__P, __A);
  }
#line 1000
  return;
}
}
#line 1003
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 1003 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int __cil_tmp5 ;

  {
  {
#line 1005
  __va = __A;
#line 1006
  __cil_tmp5 = __builtin_ia32_shufps(__va, __va, ((1 << 4) | (2 << 2)) | 3);
#line 1006
  __tmp = __cil_tmp5;
#line 1007
  _mm_store_ps(__P, __tmp);
  }
#line 1009
  return;
}
}
#line 1061
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pi16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1063
extern int ( /* missing proto */  __builtin_ia32_pmaxsw)() ;
#line 1061 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pi16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1063
  __cil_tmp3 = __builtin_ia32_pmaxsw(__A, __B);
  }
#line 1063
  return (__cil_tmp3);
}
}
#line 1067
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxsw)(__m64 __A , __m64 __B ) ;
#line 1067 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxsw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1069
  __cil_tmp3 = _mm_max_pi16(__A, __B);
  }
#line 1069
  return (__cil_tmp3);
}
}
#line 1074
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pu8)(__m64 __A , __m64 __B ) ;
#line 1076
extern int ( /* missing proto */  __builtin_ia32_pmaxub)() ;
#line 1074 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1076
  __cil_tmp3 = __builtin_ia32_pmaxub(__A, __B);
  }
#line 1076
  return (__cil_tmp3);
}
}
#line 1080
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxub)(__m64 __A , __m64 __B ) ;
#line 1080 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxub)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1082
  __cil_tmp3 = _mm_max_pu8(__A, __B);
  }
#line 1082
  return (__cil_tmp3);
}
}
#line 1087
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pi16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1089
extern int ( /* missing proto */  __builtin_ia32_pminsw)() ;
#line 1087 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pi16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1089
  __cil_tmp3 = __builtin_ia32_pminsw(__A, __B);
  }
#line 1089
  return (__cil_tmp3);
}
}
#line 1093
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminsw)(__m64 __A , __m64 __B ) ;
#line 1093 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminsw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1095
  __cil_tmp3 = _mm_min_pi16(__A, __B);
  }
#line 1095
  return (__cil_tmp3);
}
}
#line 1100
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pu8)(__m64 __A , __m64 __B ) ;
#line 1102
extern int ( /* missing proto */  __builtin_ia32_pminub)() ;
#line 1100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1102
  __cil_tmp3 = __builtin_ia32_pminub(__A, __B);
  }
#line 1102
  return (__cil_tmp3);
}
}
#line 1106
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminub)(__m64 __A , __m64 __B ) ;
#line 1106 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminub)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1108
  __cil_tmp3 = _mm_min_pu8(__A, __B);
  }
#line 1108
  return (__cil_tmp3);
}
}
#line 1113
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pi8)(__m64 __A ) ;
#line 1115
extern int ( /* missing proto */  __builtin_ia32_pmovmskb)() ;
#line 1113 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pi8)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1115
  __cil_tmp2 = __builtin_ia32_pmovmskb(__A);
  }
#line 1115
  return (__cil_tmp2);
}
}
#line 1119
__inline extern int ( __attribute__((__gnu_inline__)) _m_pmovmskb)(__m64 __A ) ;
#line 1119 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _m_pmovmskb)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1121
  __cil_tmp2 = _mm_movemask_pi8(__A);
  }
#line 1121
  return (__cil_tmp2);
}
}
#line 1127
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pu16)(__m64 __A ,
                                                                        __m64 __B ) ;
#line 1129
extern int ( /* missing proto */  __builtin_ia32_pmulhuw)() ;
#line 1127 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pu16)(__m64 __A ,
                                                                        __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1129
  __cil_tmp3 = __builtin_ia32_pmulhuw(__A, __B);
  }
#line 1129
  return (__cil_tmp3);
}
}
#line 1133
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhuw)(__m64 __A , __m64 __B ) ;
#line 1133 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhuw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1135
  __cil_tmp3 = _mm_mulhi_pu16(__A, __B);
  }
#line 1135
  return (__cil_tmp3);
}
}
#line 1163
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmove_si64)(__m64 __A ,
                                                                          __m64 __N ,
                                                                          char *__P ) ;
#line 1165
extern int ( /* missing proto */  __builtin_ia32_maskmovq)() ;
#line 1163 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmove_si64)(__m64 __A ,
                                                                          __m64 __N ,
                                                                          char *__P ) 
{ 


  {
  {
#line 1165
  __builtin_ia32_maskmovq(__A, __N, __P);
  }
#line 1167
  return;
}
}
#line 1169
__inline extern void ( __attribute__((__gnu_inline__)) _m_maskmovq)(__m64 __A , __m64 __N ,
                                                                    char *__P ) ;
#line 1169 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _m_maskmovq)(__m64 __A , __m64 __N ,
                                                                    char *__P ) 
{ 


  {
  {
#line 1171
  _mm_maskmove_si64(__A, __N, __P);
  }
#line 1173
  return;
}
}
#line 1176
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu8)(__m64 __A , __m64 __B ) ;
#line 1178
extern int ( /* missing proto */  __builtin_ia32_pavgb)() ;
#line 1176 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1178
  __cil_tmp3 = __builtin_ia32_pavgb(__A, __B);
  }
#line 1178
  return (__cil_tmp3);
}
}
#line 1182
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgb)(__m64 __A , __m64 __B ) ;
#line 1182 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgb)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1184
  __cil_tmp3 = _mm_avg_pu8(__A, __B);
  }
#line 1184
  return (__cil_tmp3);
}
}
#line 1189
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1191
extern int ( /* missing proto */  __builtin_ia32_pavgw)() ;
#line 1189 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1191
  __cil_tmp3 = __builtin_ia32_pavgw(__A, __B);
  }
#line 1191
  return (__cil_tmp3);
}
}
#line 1195
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgw)(__m64 __A , __m64 __B ) ;
#line 1195 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1197
  __cil_tmp3 = _mm_avg_pu16(__A, __B);
  }
#line 1197
  return (__cil_tmp3);
}
}
#line 1204
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sad_pu8)(__m64 __A , __m64 __B ) ;
#line 1206
extern int ( /* missing proto */  __builtin_ia32_psadbw)() ;
#line 1204 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sad_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1206
  __cil_tmp3 = __builtin_ia32_psadbw(__A, __B);
  }
#line 1206
  return (__cil_tmp3);
}
}
#line 1210
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psadbw)(__m64 __A , __m64 __B ) ;
#line 1210 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psadbw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1212
  __cil_tmp3 = _mm_sad_pu8(__A, __B);
  }
#line 1212
  return (__cil_tmp3);
}
}
#line 1217
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pi)(__m64 *__P ,
                                                                      __m64 __A ) ;
#line 1217 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pi)(__m64 *__P ,
                                                                      __m64 __A ) 
{ 


  {
#line 1222
  return;
}
}
#line 1224
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 1226
extern int ( /* missing proto */  __builtin_ia32_movntps)() ;
#line 1224 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 1226
  __builtin_ia32_movntps(__P, __A);
  }
#line 1228
  return;
}
}
#line 1232
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) ;
#line 1234
extern int ( /* missing proto */  __builtin_ia32_sfence)() ;
#line 1232
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) ;
#line 1232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) 
{ 


  {
  {
#line 1234
  __builtin_ia32_sfence();
  }
#line 1236
  return;
}
}
#line 66 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_sd)(double __F ) ;
#line 66 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_sd)(double __F ) 
{ 
  __m128d tmp ;

  {
#line 68
  return (tmp);
}
}
#line 79
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd1)(double __F ) ;
#line 79 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd1)(double __F ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 81
  __cil_tmp2 = _mm_set_sd(__F);
  }
#line 81
  return (__cil_tmp2);
}
}
#line 86
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd)(double __W ,
                                                                      double __X ) ;
#line 86 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd)(double __W ,
                                                                      double __X ) 
{ 
  __m128d tmp ;

  {
#line 88
  return (tmp);
}
}
#line 100
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_undefined_pd)(void) ;
#line 100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_undefined_pd)(void) 
{ 
  __m128d __Y ;

  {
#line 102
  __Y = __Y;
#line 103
  return (__Y);
}
}
#line 108
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_setzero_pd)(void) ;
#line 108 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_setzero_pd)(void) 
{ 
  __m128d tmp ;

  {
#line 110
  return (tmp);
}
}
#line 115
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_move_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 115 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_move_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 


  {
#line 120
  return;
}
}
#line 122
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd)(double const   *__P ) ;
#line 122 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd)(double const   *__P ) 
{ 


  {
#line 124
  return (*((__m128d *)__P));
}
}
#line 129
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadu_pd)(double const   *__P ) ;
#line 129 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadu_pd)(double const   *__P ) 
{ 


  {
#line 131
  return (*((__m128d_u *)__P));
}
}
#line 136
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load1_pd)(double const   *__P ) ;
#line 136 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load1_pd)(double const   *__P ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 138
  __cil_tmp2 = _mm_set_sd((double )*__P);
  }
#line 138
  return (__cil_tmp2);
}
}
#line 149
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd1)(double const   *__P ) ;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd1)(double const   *__P ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 151
  __cil_tmp2 = _mm_load1_pd(__P);
  }
#line 151
  return (__cil_tmp2);
}
}
#line 156
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadr_pd)(double const   *__P ) ;
#line 159
extern int ( /* missing proto */  __builtin_ia32_shufpd)() ;
#line 156 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadr_pd)(double const   *__P ) 
{ 
  __m128d __tmp ;
  __m128d __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 158
  __cil_tmp3 = _mm_load_pd(__P);
#line 158
  __tmp = __cil_tmp3;
#line 159
  __cil_tmp4 = __builtin_ia32_shufpd(__tmp, __tmp, 1);
  }
#line 159
  return (__cil_tmp4);
}
}
#line 164
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd)(double *__P ,
                                                                     __m128d __A ) ;
#line 164 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd)(double *__P ,
                                                                     __m128d __A ) 
{ 


  {
#line 166
  *((__m128d *)__P) = __A;
#line 167
  return;
}
}
#line 171
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 171 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
#line 173
  *((__m128d_u *)__P) = __A;
#line 174
  return;
}
}
#line 178
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_sd)(double *__P ,
                                                                     __m128d __A ) ;
#line 178 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_sd)(double *__P ,
                                                                     __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
#line 180
  *__P = (double )__cil_tmp3;
#line 181
  return;
}
}
#line 184
__inline extern double ( __attribute__((__gnu_inline__)) _mm_cvtsd_f64)(__m128d __A ) ;
#line 184 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern double ( __attribute__((__gnu_inline__)) _mm_cvtsd_f64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 186
  return ((double )__cil_tmp2);
}
}
#line 190
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 190 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
  {
#line 192
  _mm_store_sd(__P, __A);
  }
#line 194
  return;
}
}
#line 205
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 205 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 207
  __cil_tmp3 = __builtin_ia32_shufpd(__A, __A, 0);
#line 207
  _mm_store_pd(__P, __cil_tmp3);
  }
#line 209
  return;
}
}
#line 211
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd1)(double *__P ,
                                                                      __m128d __A ) ;
#line 211 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd1)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
  {
#line 213
  _mm_store1_pd(__P, __A);
  }
#line 215
  return;
}
}
#line 218
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 218 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 220
  __cil_tmp3 = __builtin_ia32_shufpd(__A, __A, 1);
#line 220
  _mm_store_pd(__P, __cil_tmp3);
  }
#line 222
  return;
}
}
#line 224
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si32)(__m128i __A ) ;
#line 226
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v4si)() ;
#line 224 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si32)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 226
  __cil_tmp2 = __builtin_ia32_vec_ext_v4si(__A, 0);
  }
#line 226
  return (__cil_tmp2);
}
}
#line 232
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si64)(__m128i __A ) ;
#line 232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si64)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 234
  return ((long long )__cil_tmp2);
}
}
#line 246
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_add_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 246 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_add_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 248
  return (__A + __B);
}
}
#line 258
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sub_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 258 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sub_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 260
  return (__A - __B);
}
}
#line 270
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_mul_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 270 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_mul_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 272
  return (__A * __B);
}
}
#line 282
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_div_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 282 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_div_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 284
  return (__A / __B);
}
}
#line 294
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_pd)(__m128d __A ) ;
#line 296
extern int ( /* missing proto */  __builtin_ia32_sqrtpd)() ;
#line 294 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_pd)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 296
  __cil_tmp2 = __builtin_ia32_sqrtpd(__A);
  }
#line 296
  return (__cil_tmp2);
}
}
#line 301
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 304
extern int ( /* missing proto */  __builtin_ia32_sqrtsd)() ;
#line 301 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 
  __v2df __tmp ;
  int __cil_tmp4 ;

  {
  {
#line 303
  __tmp = 0;
#line 304
  __cil_tmp4 = __builtin_ia32_sqrtsd(__tmp);
  }
#line 304
  return (__cil_tmp4);
}
}
#line 308
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 310
extern int ( /* missing proto */  __builtin_ia32_minpd)() ;
#line 308 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 310
  __cil_tmp3 = __builtin_ia32_minpd(__A, __B);
  }
#line 310
  return (__cil_tmp3);
}
}
#line 314
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 316
extern int ( /* missing proto */  __builtin_ia32_minsd)() ;
#line 314 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 316
  __cil_tmp3 = __builtin_ia32_minsd(__A, __B);
  }
#line 316
  return (__cil_tmp3);
}
}
#line 320
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 322
extern int ( /* missing proto */  __builtin_ia32_maxpd)() ;
#line 320 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 322
  __cil_tmp3 = __builtin_ia32_maxpd(__A, __B);
  }
#line 322
  return (__cil_tmp3);
}
}
#line 326
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 328
extern int ( /* missing proto */  __builtin_ia32_maxsd)() ;
#line 326 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 328
  __cil_tmp3 = __builtin_ia32_maxsd(__A, __B);
  }
#line 328
  return (__cil_tmp3);
}
}
#line 356
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 358
extern int ( /* missing proto */  __builtin_ia32_cmpeqpd)() ;
#line 356 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 358
  __cil_tmp3 = __builtin_ia32_cmpeqpd(__A, __B);
  }
#line 358
  return (__cil_tmp3);
}
}
#line 362
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 364
extern int ( /* missing proto */  __builtin_ia32_cmpltpd)() ;
#line 362 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 364
  __cil_tmp3 = __builtin_ia32_cmpltpd(__A, __B);
  }
#line 364
  return (__cil_tmp3);
}
}
#line 368
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 370
extern int ( /* missing proto */  __builtin_ia32_cmplepd)() ;
#line 368 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 370
  __cil_tmp3 = __builtin_ia32_cmplepd(__A, __B);
  }
#line 370
  return (__cil_tmp3);
}
}
#line 386
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 388
extern int ( /* missing proto */  __builtin_ia32_cmpneqpd)() ;
#line 386 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 388
  __cil_tmp3 = __builtin_ia32_cmpneqpd(__A, __B);
  }
#line 388
  return (__cil_tmp3);
}
}
#line 392
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 394
extern int ( /* missing proto */  __builtin_ia32_cmpnltpd)() ;
#line 392 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 394
  __cil_tmp3 = __builtin_ia32_cmpnltpd(__A, __B);
  }
#line 394
  return (__cil_tmp3);
}
}
#line 398
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 400
extern int ( /* missing proto */  __builtin_ia32_cmpnlepd)() ;
#line 398 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 400
  __cil_tmp3 = __builtin_ia32_cmpnlepd(__A, __B);
  }
#line 400
  return (__cil_tmp3);
}
}
#line 416
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 418
extern int ( /* missing proto */  __builtin_ia32_cmpordpd)() ;
#line 416 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 418
  __cil_tmp3 = __builtin_ia32_cmpordpd(__A, __B);
  }
#line 418
  return (__cil_tmp3);
}
}
#line 422
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_pd)(__m128d __A ,
                                                                           __m128d __B ) ;
#line 424
extern int ( /* missing proto */  __builtin_ia32_cmpunordpd)() ;
#line 422 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_pd)(__m128d __A ,
                                                                           __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 424
  __cil_tmp3 = __builtin_ia32_cmpunordpd(__A, __B);
  }
#line 424
  return (__cil_tmp3);
}
}
#line 428
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 430
extern int ( /* missing proto */  __builtin_ia32_cmpeqsd)() ;
#line 428 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 430
  __cil_tmp3 = __builtin_ia32_cmpeqsd(__A, __B);
  }
#line 430
  return (__cil_tmp3);
}
}
#line 434
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 436
extern int ( /* missing proto */  __builtin_ia32_cmpltsd)() ;
#line 434 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 436
  __cil_tmp3 = __builtin_ia32_cmpltsd(__A, __B);
  }
#line 436
  return (__cil_tmp3);
}
}
#line 440
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 442
extern int ( /* missing proto */  __builtin_ia32_cmplesd)() ;
#line 440 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 442
  __cil_tmp3 = __builtin_ia32_cmplesd(__A, __B);
  }
#line 442
  return (__cil_tmp3);
}
}
#line 466
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 468
extern int ( /* missing proto */  __builtin_ia32_cmpneqsd)() ;
#line 466 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 468
  __cil_tmp3 = __builtin_ia32_cmpneqsd(__A, __B);
  }
#line 468
  return (__cil_tmp3);
}
}
#line 472
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 474
extern int ( /* missing proto */  __builtin_ia32_cmpnltsd)() ;
#line 472 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 474
  __cil_tmp3 = __builtin_ia32_cmpnltsd(__A, __B);
  }
#line 474
  return (__cil_tmp3);
}
}
#line 478
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 480
extern int ( /* missing proto */  __builtin_ia32_cmpnlesd)() ;
#line 478 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 480
  __cil_tmp3 = __builtin_ia32_cmpnlesd(__A, __B);
  }
#line 480
  return (__cil_tmp3);
}
}
#line 504
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 506
extern int ( /* missing proto */  __builtin_ia32_cmpordsd)() ;
#line 504 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 506
  __cil_tmp3 = __builtin_ia32_cmpordsd(__A, __B);
  }
#line 506
  return (__cil_tmp3);
}
}
#line 510
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_sd)(__m128d __A ,
                                                                           __m128d __B ) ;
#line 512
extern int ( /* missing proto */  __builtin_ia32_cmpunordsd)() ;
#line 510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_sd)(__m128d __A ,
                                                                           __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 512
  __cil_tmp3 = __builtin_ia32_cmpunordsd(__A, __B);
  }
#line 512
  return (__cil_tmp3);
}
}
#line 516
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 518
extern int ( /* missing proto */  __builtin_ia32_comisdeq)() ;
#line 516 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 518
  __cil_tmp3 = __builtin_ia32_comisdeq(__A, __B);
  }
#line 518
  return (__cil_tmp3);
}
}
#line 522
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 524
extern int ( /* missing proto */  __builtin_ia32_comisdlt)() ;
#line 522 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 524
  __cil_tmp3 = __builtin_ia32_comisdlt(__A, __B);
  }
#line 524
  return (__cil_tmp3);
}
}
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 530
extern int ( /* missing proto */  __builtin_ia32_comisdle)() ;
#line 528 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 530
  __cil_tmp3 = __builtin_ia32_comisdle(__A, __B);
  }
#line 530
  return (__cil_tmp3);
}
}
#line 534
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 536
extern int ( /* missing proto */  __builtin_ia32_comisdgt)() ;
#line 534 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 536
  __cil_tmp3 = __builtin_ia32_comisdgt(__A, __B);
  }
#line 536
  return (__cil_tmp3);
}
}
#line 540
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 542
extern int ( /* missing proto */  __builtin_ia32_comisdge)() ;
#line 540 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 542
  __cil_tmp3 = __builtin_ia32_comisdge(__A, __B);
  }
#line 542
  return (__cil_tmp3);
}
}
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 548
extern int ( /* missing proto */  __builtin_ia32_comisdneq)() ;
#line 546 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 548
  __cil_tmp3 = __builtin_ia32_comisdneq(__A, __B);
  }
#line 548
  return (__cil_tmp3);
}
}
#line 552
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 554
extern int ( /* missing proto */  __builtin_ia32_ucomisdeq)() ;
#line 552 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 554
  __cil_tmp3 = __builtin_ia32_ucomisdeq(__A, __B);
  }
#line 554
  return (__cil_tmp3);
}
}
#line 558
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 560
extern int ( /* missing proto */  __builtin_ia32_ucomisdlt)() ;
#line 558 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 560
  __cil_tmp3 = __builtin_ia32_ucomisdlt(__A, __B);
  }
#line 560
  return (__cil_tmp3);
}
}
#line 564
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 566
extern int ( /* missing proto */  __builtin_ia32_ucomisdle)() ;
#line 564 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 566
  __cil_tmp3 = __builtin_ia32_ucomisdle(__A, __B);
  }
#line 566
  return (__cil_tmp3);
}
}
#line 570
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 572
extern int ( /* missing proto */  __builtin_ia32_ucomisdgt)() ;
#line 570 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 572
  __cil_tmp3 = __builtin_ia32_ucomisdgt(__A, __B);
  }
#line 572
  return (__cil_tmp3);
}
}
#line 576
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 578
extern int ( /* missing proto */  __builtin_ia32_ucomisdge)() ;
#line 576 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 578
  __cil_tmp3 = __builtin_ia32_ucomisdge(__A, __B);
  }
#line 578
  return (__cil_tmp3);
}
}
#line 582
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 584
extern int ( /* missing proto */  __builtin_ia32_ucomisdneq)() ;
#line 582 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 584
  __cil_tmp3 = __builtin_ia32_ucomisdneq(__A, __B);
  }
#line 584
  return (__cil_tmp3);
}
}
#line 590
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64x)(long long __q1 ,
                                                                          long long __q0 ) ;
#line 590 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64x)(long long __q1 ,
                                                                          long long __q0 ) 
{ 
  __v2di tmp ;

  {
#line 592
  return (tmp);
}
}
#line 596
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64)(__m64 __q1 ,
                                                                         __m64 __q0 ) ;
#line 596 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64)(__m64 __q1 ,
                                                                         __m64 __q0 ) 
{ 
  __m128i __cil_tmp3 ;

  {
  {
#line 598
  __cil_tmp3 = _mm_set_epi64x((long long )__q1, (long long )__q0);
  }
#line 598
  return (__cil_tmp3);
}
}
#line 602
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi32)(int __q3 ,
                                                                         int __q2 ,
                                                                         int __q1 ,
                                                                         int __q0 ) ;
#line 602 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi32)(int __q3 ,
                                                                         int __q2 ,
                                                                         int __q1 ,
                                                                         int __q0 ) 
{ 
  __v4si tmp ;

  {
#line 604
  return (tmp);
}
}
#line 608
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi16)(short __q7 ,
                                                                         short __q6 ,
                                                                         short __q5 ,
                                                                         short __q4 ,
                                                                         short __q3 ,
                                                                         short __q2 ,
                                                                         short __q1 ,
                                                                         short __q0 ) ;
#line 608 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi16)(short __q7 ,
                                                                         short __q6 ,
                                                                         short __q5 ,
                                                                         short __q4 ,
                                                                         short __q3 ,
                                                                         short __q2 ,
                                                                         short __q1 ,
                                                                         short __q0 ) 
{ 
  __v8hi tmp ;

  {
#line 611
  return (tmp);
}
}
#line 616
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi8)(char __q15 ,
                                                                        char __q14 ,
                                                                        char __q13 ,
                                                                        char __q12 ,
                                                                        char __q11 ,
                                                                        char __q10 ,
                                                                        char __q09 ,
                                                                        char __q08 ,
                                                                        char __q07 ,
                                                                        char __q06 ,
                                                                        char __q05 ,
                                                                        char __q04 ,
                                                                        char __q03 ,
                                                                        char __q02 ,
                                                                        char __q01 ,
                                                                        char __q00 ) ;
#line 616 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi8)(char __q15 ,
                                                                        char __q14 ,
                                                                        char __q13 ,
                                                                        char __q12 ,
                                                                        char __q11 ,
                                                                        char __q10 ,
                                                                        char __q09 ,
                                                                        char __q08 ,
                                                                        char __q07 ,
                                                                        char __q06 ,
                                                                        char __q05 ,
                                                                        char __q04 ,
                                                                        char __q03 ,
                                                                        char __q02 ,
                                                                        char __q01 ,
                                                                        char __q00 ) 
{ 
  __v16qi tmp ;

  {
#line 621
  return (tmp);
}
}
#line 630
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64x)(long long __A ) ;
#line 630 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64x)(long long __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 632
  __cil_tmp2 = _mm_set_epi64x(__A, __A);
  }
#line 632
  return (__cil_tmp2);
}
}
#line 636
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64)(__m64 __A ) ;
#line 636 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64)(__m64 __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 638
  __cil_tmp2 = _mm_set_epi64(__A, __A);
  }
#line 638
  return (__cil_tmp2);
}
}
#line 642
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi32)(int __A ) ;
#line 642 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi32)(int __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 644
  __cil_tmp2 = _mm_set_epi32(__A, __A, __A, __A);
  }
#line 644
  return (__cil_tmp2);
}
}
#line 648
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi16)(short __A ) ;
#line 648 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi16)(short __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 650
  __cil_tmp2 = _mm_set_epi16(__A, __A, __A, __A, __A, __A, __A, __A);
  }
#line 650
  return (__cil_tmp2);
}
}
#line 654
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi8)(char __A ) ;
#line 654 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi8)(char __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 656
  __cil_tmp2 = _mm_set_epi8(__A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A,
                            __A, __A, __A, __A, __A);
  }
#line 656
  return (__cil_tmp2);
}
}
#line 664
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi64)(__m64 __q0 ,
                                                                          __m64 __q1 ) ;
#line 664 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi64)(__m64 __q0 ,
                                                                          __m64 __q1 ) 
{ 
  __m128i __cil_tmp3 ;

  {
  {
#line 666
  __cil_tmp3 = _mm_set_epi64(__q1, __q0);
  }
#line 666
  return (__cil_tmp3);
}
}
#line 670
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi32)(int __q0 ,
                                                                          int __q1 ,
                                                                          int __q2 ,
                                                                          int __q3 ) ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi32)(int __q0 ,
                                                                          int __q1 ,
                                                                          int __q2 ,
                                                                          int __q3 ) 
{ 
  __m128i __cil_tmp5 ;

  {
  {
#line 672
  __cil_tmp5 = _mm_set_epi32(__q3, __q2, __q1, __q0);
  }
#line 672
  return (__cil_tmp5);
}
}
#line 676
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi16)(short __q0 ,
                                                                          short __q1 ,
                                                                          short __q2 ,
                                                                          short __q3 ,
                                                                          short __q4 ,
                                                                          short __q5 ,
                                                                          short __q6 ,
                                                                          short __q7 ) ;
#line 676 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi16)(short __q0 ,
                                                                          short __q1 ,
                                                                          short __q2 ,
                                                                          short __q3 ,
                                                                          short __q4 ,
                                                                          short __q5 ,
                                                                          short __q6 ,
                                                                          short __q7 ) 
{ 
  __m128i __cil_tmp9 ;

  {
  {
#line 679
  __cil_tmp9 = _mm_set_epi16(__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
  }
#line 679
  return (__cil_tmp9);
}
}
#line 683
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi8)(char __q00 ,
                                                                         char __q01 ,
                                                                         char __q02 ,
                                                                         char __q03 ,
                                                                         char __q04 ,
                                                                         char __q05 ,
                                                                         char __q06 ,
                                                                         char __q07 ,
                                                                         char __q08 ,
                                                                         char __q09 ,
                                                                         char __q10 ,
                                                                         char __q11 ,
                                                                         char __q12 ,
                                                                         char __q13 ,
                                                                         char __q14 ,
                                                                         char __q15 ) ;
#line 683 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi8)(char __q00 ,
                                                                         char __q01 ,
                                                                         char __q02 ,
                                                                         char __q03 ,
                                                                         char __q04 ,
                                                                         char __q05 ,
                                                                         char __q06 ,
                                                                         char __q07 ,
                                                                         char __q08 ,
                                                                         char __q09 ,
                                                                         char __q10 ,
                                                                         char __q11 ,
                                                                         char __q12 ,
                                                                         char __q13 ,
                                                                         char __q14 ,
                                                                         char __q15 ) 
{ 
  __m128i __cil_tmp17 ;

  {
  {
#line 688
  __cil_tmp17 = _mm_set_epi8(__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,
                             __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
  }
#line 688
  return (__cil_tmp17);
}
}
#line 695
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_load_si128)(__m128i *__P ) ;
#line 695 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_load_si128)(__m128i *__P ) 
{ 


  {
#line 697
  return (*__P);
}
}
#line 701
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadu_si128)(__m128i_u *__P ) ;
#line 701 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadu_si128)(__m128i_u *__P ) 
{ 


  {
#line 703
  return (*__P);
}
}
#line 707
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadl_epi64)(__m128i_u *__P ) ;
#line 707 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadl_epi64)(__m128i_u *__P ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 709
  __cil_tmp2 = _mm_set_epi64((__m64 )0LL, *__P);
  }
#line 709
  return (__cil_tmp2);
}
}
#line 713
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_si128)(__m128i *__P ,
                                                                        __m128i __B ) ;
#line 713 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_si128)(__m128i *__P ,
                                                                        __m128i __B ) 
{ 


  {
#line 715
  *__P = __B;
#line 716
  return;
}
}
#line 719
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_si128)(__m128i_u *__P ,
                                                                         __m128i __B ) ;
#line 719 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_si128)(__m128i_u *__P ,
                                                                         __m128i __B ) 
{ 


  {
#line 721
  *__P = __B;
#line 722
  return;
}
}
#line 725
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_epi64)(__m128i_u *__P ,
                                                                         __m128i __B ) ;
#line 725 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_epi64)(__m128i_u *__P ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
#line 727
  *__P = __cil_tmp3;
#line 728
  return;
}
}
#line 731
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_movepi64_pi64)(__m128i __B ) ;
#line 731 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_movepi64_pi64)(__m128i __B ) 
{ 
  int __cil_tmp2 ;

  {
#line 733
  return (__cil_tmp2);
}
}
#line 737
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_movpi64_epi64)(__m64 __A ) ;
#line 737 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_movpi64_epi64)(__m64 __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 739
  __cil_tmp2 = _mm_set_epi64((__m64 )0LL, __A);
  }
#line 739
  return (__cil_tmp2);
}
}
#line 743
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_move_epi64)(__m128i __A ) ;
#line 743 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_move_epi64)(__m128i __A ) 
{ 


  {
#line 748
  return;
}
}
#line 750
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_undefined_si128)(void) ;
#line 750 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_undefined_si128)(void) 
{ 
  __m128i __Y ;

  {
#line 752
  __Y = __Y;
#line 753
  return (__Y);
}
}
#line 758
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setzero_si128)(void) ;
#line 758 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setzero_si128)(void) 
{ 
  __v4si tmp ;

  {
#line 760
  return (tmp);
}
}
#line 764
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtepi32_pd)(__m128i __A ) ;
#line 764 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtepi32_pd)(__m128i __A ) 
{ 


  {
#line 769
  return;
}
}
#line 770
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtepi32_ps)(__m128i __A ) ;
#line 770 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtepi32_ps)(__m128i __A ) 
{ 


  {
#line 775
  return;
}
}
#line 776
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtpd_epi32)(__m128d __A ) ;
#line 778
extern int ( /* missing proto */  __builtin_ia32_cvtpd2dq)() ;
#line 776 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtpd_epi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 778
  __cil_tmp2 = __builtin_ia32_cvtpd2dq(__A);
  }
#line 778
  return (__cil_tmp2);
}
}
#line 782
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtpd_pi32)(__m128d __A ) ;
#line 784
extern int ( /* missing proto */  __builtin_ia32_cvtpd2pi)() ;
#line 782 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtpd_pi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 784
  __cil_tmp2 = __builtin_ia32_cvtpd2pi(__A);
  }
#line 784
  return (__cil_tmp2);
}
}
#line 788
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpd_ps)(__m128d __A ) ;
#line 790
extern int ( /* missing proto */  __builtin_ia32_cvtpd2ps)() ;
#line 788 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpd_ps)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 790
  __cil_tmp2 = __builtin_ia32_cvtpd2ps(__A);
  }
#line 790
  return (__cil_tmp2);
}
}
#line 794
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttpd_epi32)(__m128d __A ) ;
#line 796
extern int ( /* missing proto */  __builtin_ia32_cvttpd2dq)() ;
#line 794 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttpd_epi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 796
  __cil_tmp2 = __builtin_ia32_cvttpd2dq(__A);
  }
#line 796
  return (__cil_tmp2);
}
}
#line 800
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttpd_pi32)(__m128d __A ) ;
#line 802
extern int ( /* missing proto */  __builtin_ia32_cvttpd2pi)() ;
#line 800 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttpd_pi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 802
  __cil_tmp2 = __builtin_ia32_cvttpd2pi(__A);
  }
#line 802
  return (__cil_tmp2);
}
}
#line 806
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtpi32_pd)(__m64 __A ) ;
#line 808
extern int ( /* missing proto */  __builtin_ia32_cvtpi2pd)() ;
#line 806 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtpi32_pd)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 808
  __cil_tmp2 = __builtin_ia32_cvtpi2pd(__A);
  }
#line 808
  return (__cil_tmp2);
}
}
#line 812
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtps_epi32)(__m128 __A ) ;
#line 814
extern int ( /* missing proto */  __builtin_ia32_cvtps2dq)() ;
#line 812 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtps_epi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 814
  __cil_tmp2 = __builtin_ia32_cvtps2dq(__A);
  }
#line 814
  return (__cil_tmp2);
}
}
#line 818
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttps_epi32)(__m128 __A ) ;
#line 820
extern int ( /* missing proto */  __builtin_ia32_cvttps2dq)() ;
#line 818 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttps_epi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 820
  __cil_tmp2 = __builtin_ia32_cvttps2dq(__A);
  }
#line 820
  return (__cil_tmp2);
}
}
#line 824
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtps_pd)(__m128 __A ) ;
#line 824 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtps_pd)(__m128 __A ) 
{ 


  {
#line 829
  return;
}
}
#line 830
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsd_si32)(__m128d __A ) ;
#line 832
extern int ( /* missing proto */  __builtin_ia32_cvtsd2si)() ;
#line 830 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsd_si32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 832
  __cil_tmp2 = __builtin_ia32_cvtsd2si(__A);
  }
#line 832
  return (__cil_tmp2);
}
}
#line 838
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsd_si64)(__m128d __A ) ;
#line 840
extern int ( /* missing proto */  __builtin_ia32_cvtsd2si64)() ;
#line 838 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsd_si64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 840
  __cil_tmp2 = __builtin_ia32_cvtsd2si64(__A);
  }
#line 840
  return ((long long )__cil_tmp2);
}
}
#line 852
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttsd_si32)(__m128d __A ) ;
#line 854
extern int ( /* missing proto */  __builtin_ia32_cvttsd2si)() ;
#line 852 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttsd_si32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 854
  __cil_tmp2 = __builtin_ia32_cvttsd2si(__A);
  }
#line 854
  return (__cil_tmp2);
}
}
#line 860
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttsd_si64)(__m128d __A ) ;
#line 862
extern int ( /* missing proto */  __builtin_ia32_cvttsd2si64)() ;
#line 860 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttsd_si64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 862
  __cil_tmp2 = __builtin_ia32_cvttsd2si64(__A);
  }
#line 862
  return ((long long )__cil_tmp2);
}
}
#line 874
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsd_ss)(__m128 __A ,
                                                                       __m128d __B ) ;
#line 876
extern int ( /* missing proto */  __builtin_ia32_cvtsd2ss)() ;
#line 874 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsd_ss)(__m128 __A ,
                                                                       __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 876
  __cil_tmp3 = __builtin_ia32_cvtsd2ss(__A, __B);
  }
#line 876
  return (__cil_tmp3);
}
}
#line 880
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi32_sd)(__m128d __A ,
                                                                          int __B ) ;
#line 880 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi32_sd)(__m128d __A ,
                                                                          int __B ) 
{ 


  {
#line 885
  return;
}
}
#line 888
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi64_sd)(__m128d __A ,
                                                                          long long __B ) ;
#line 888 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi64_sd)(__m128d __A ,
                                                                          long long __B ) 
{ 


  {
#line 893
  return;
}
}
#line 902
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtss_sd)(__m128d __A ,
                                                                        __m128 __B ) ;
#line 902 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtss_sd)(__m128d __A ,
                                                                        __m128 __B ) 
{ 


  {
#line 907
  return;
}
}
#line 932
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadh_pd)(__m128d __A ,
                                                                        double const   *__B ) ;
#line 932 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadh_pd)(__m128d __A ,
                                                                        double const   *__B ) 
{ 


  {
#line 937
  return;
}
}
#line 944
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pd)(__m128d __A ) ;
#line 946
extern int ( /* missing proto */  __builtin_ia32_movmskpd)() ;
#line 944 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pd)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 946
  __cil_tmp2 = __builtin_ia32_movmskpd(__A);
  }
#line 946
  return (__cil_tmp2);
}
}
#line 950
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 952
extern int ( /* missing proto */  __builtin_ia32_packsswb128)() ;
#line 950 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 952
  __cil_tmp3 = __builtin_ia32_packsswb128(__A, __B);
  }
#line 952
  return (__cil_tmp3);
}
}
#line 956
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 958
extern int ( /* missing proto */  __builtin_ia32_packssdw128)() ;
#line 956 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 958
  __cil_tmp3 = __builtin_ia32_packssdw128(__A, __B);
  }
#line 958
  return (__cil_tmp3);
}
}
#line 962
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packus_epi16)(__m128i __A ,
                                                                            __m128i __B ) ;
#line 964
extern int ( /* missing proto */  __builtin_ia32_packuswb128)() ;
#line 962 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packus_epi16)(__m128i __A ,
                                                                            __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 964
  __cil_tmp3 = __builtin_ia32_packuswb128(__A, __B);
  }
#line 964
  return (__cil_tmp3);
}
}
#line 968
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_unpackhi_epi8)(__m128i __A ,
                                                                             __m128i __B ) ;
#line 968 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_unpackhi_epi8)(__m128i __A ,
                                                                             __m128i __B ) 
{ 


  {
#line 973
  return;
}
}
#line 1016
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1016 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1018
  return (__A + __B);
}
}
#line 1022
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1022 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1024
  return (__A + __B);
}
}
#line 1028
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1028 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1030
  return (__A + __B);
}
}
#line 1034
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1034 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1036
  return (__A + __B);
}
}
#line 1040
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1042
extern int ( /* missing proto */  __builtin_ia32_paddsb128)() ;
#line 1040 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1042
  __cil_tmp3 = __builtin_ia32_paddsb128(__A, __B);
  }
#line 1042
  return (__cil_tmp3);
}
}
#line 1046
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1048
extern int ( /* missing proto */  __builtin_ia32_paddsw128)() ;
#line 1046 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1048
  __cil_tmp3 = __builtin_ia32_paddsw128(__A, __B);
  }
#line 1048
  return (__cil_tmp3);
}
}
#line 1052
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1054
extern int ( /* missing proto */  __builtin_ia32_paddusb128)() ;
#line 1052 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1054
  __cil_tmp3 = __builtin_ia32_paddusb128(__A, __B);
  }
#line 1054
  return (__cil_tmp3);
}
}
#line 1058
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1060
extern int ( /* missing proto */  __builtin_ia32_paddusw128)() ;
#line 1058 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1060
  __cil_tmp3 = __builtin_ia32_paddusw128(__A, __B);
  }
#line 1060
  return (__cil_tmp3);
}
}
#line 1064
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1064 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1066
  return (__A - __B);
}
}
#line 1070
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1070 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1072
  return (__A - __B);
}
}
#line 1076
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1076 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1078
  return (__A - __B);
}
}
#line 1082
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1082 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1084
  return (__A - __B);
}
}
#line 1088
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1090
extern int ( /* missing proto */  __builtin_ia32_psubsb128)() ;
#line 1088 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1090
  __cil_tmp3 = __builtin_ia32_psubsb128(__A, __B);
  }
#line 1090
  return (__cil_tmp3);
}
}
#line 1094
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1096
extern int ( /* missing proto */  __builtin_ia32_psubsw128)() ;
#line 1094 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1096
  __cil_tmp3 = __builtin_ia32_psubsw128(__A, __B);
  }
#line 1096
  return (__cil_tmp3);
}
}
#line 1100
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1102
extern int ( /* missing proto */  __builtin_ia32_psubusb128)() ;
#line 1100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1102
  __cil_tmp3 = __builtin_ia32_psubusb128(__A, __B);
  }
#line 1102
  return (__cil_tmp3);
}
}
#line 1106
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1108
extern int ( /* missing proto */  __builtin_ia32_psubusw128)() ;
#line 1106 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1108
  __cil_tmp3 = __builtin_ia32_psubusw128(__A, __B);
  }
#line 1108
  return (__cil_tmp3);
}
}
#line 1112
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_madd_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1114
extern int ( /* missing proto */  __builtin_ia32_pmaddwd128)() ;
#line 1112 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_madd_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1114
  __cil_tmp3 = __builtin_ia32_pmaddwd128(__A, __B);
  }
#line 1114
  return (__cil_tmp3);
}
}
#line 1118
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1120
extern int ( /* missing proto */  __builtin_ia32_pmulhw128)() ;
#line 1118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1120
  __cil_tmp3 = __builtin_ia32_pmulhw128(__A, __B);
  }
#line 1120
  return (__cil_tmp3);
}
}
#line 1124
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mullo_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1124 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mullo_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1126
  return (__A * __B);
}
}
#line 1130
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mul_su32)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1132
extern int ( /* missing proto */  __builtin_ia32_pmuludq)() ;
#line 1130 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mul_su32)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1132
  __cil_tmp3 = __builtin_ia32_pmuludq(__A, __B);
  }
#line 1132
  return (__cil_tmp3);
}
}
#line 1136
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mul_epu32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1138
extern int ( /* missing proto */  __builtin_ia32_pmuludq128)() ;
#line 1136 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mul_epu32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1138
  __cil_tmp3 = __builtin_ia32_pmuludq128(__A, __B);
  }
#line 1138
  return (__cil_tmp3);
}
}
#line 1142
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1144
extern int ( /* missing proto */  __builtin_ia32_psllwi128)() ;
#line 1142 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1144
  __cil_tmp3 = __builtin_ia32_psllwi128(__A, __B);
  }
#line 1144
  return (__cil_tmp3);
}
}
#line 1148
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1150
extern int ( /* missing proto */  __builtin_ia32_pslldi128)() ;
#line 1148 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1150
  __cil_tmp3 = __builtin_ia32_pslldi128(__A, __B);
  }
#line 1150
  return (__cil_tmp3);
}
}
#line 1154
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi64)(__m128i __A ,
                                                                          int __B ) ;
#line 1156
extern int ( /* missing proto */  __builtin_ia32_psllqi128)() ;
#line 1154 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi64)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1156
  __cil_tmp3 = __builtin_ia32_psllqi128(__A, __B);
  }
#line 1156
  return (__cil_tmp3);
}
}
#line 1160
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1162
extern int ( /* missing proto */  __builtin_ia32_psrawi128)() ;
#line 1160 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1162
  __cil_tmp3 = __builtin_ia32_psrawi128(__A, __B);
  }
#line 1162
  return (__cil_tmp3);
}
}
#line 1166
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1168
extern int ( /* missing proto */  __builtin_ia32_psradi128)() ;
#line 1166 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1168
  __cil_tmp3 = __builtin_ia32_psradi128(__A, __B);
  }
#line 1168
  return (__cil_tmp3);
}
}
#line 1207
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1209
extern int ( /* missing proto */  __builtin_ia32_psrlwi128)() ;
#line 1207 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1209
  __cil_tmp3 = __builtin_ia32_psrlwi128(__A, __B);
  }
#line 1209
  return (__cil_tmp3);
}
}
#line 1213
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1215
extern int ( /* missing proto */  __builtin_ia32_psrldi128)() ;
#line 1213 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1215
  __cil_tmp3 = __builtin_ia32_psrldi128(__A, __B);
  }
#line 1215
  return (__cil_tmp3);
}
}
#line 1219
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi64)(__m128i __A ,
                                                                          int __B ) ;
#line 1221
extern int ( /* missing proto */  __builtin_ia32_psrlqi128)() ;
#line 1219 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi64)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1221
  __cil_tmp3 = __builtin_ia32_psrlqi128(__A, __B);
  }
#line 1221
  return (__cil_tmp3);
}
}
#line 1225
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1227
extern int ( /* missing proto */  __builtin_ia32_psllw128)() ;
#line 1225 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1227
  __cil_tmp3 = __builtin_ia32_psllw128(__A, __B);
  }
#line 1227
  return (__cil_tmp3);
}
}
#line 1231
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1233
extern int ( /* missing proto */  __builtin_ia32_pslld128)() ;
#line 1231 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1233
  __cil_tmp3 = __builtin_ia32_pslld128(__A, __B);
  }
#line 1233
  return (__cil_tmp3);
}
}
#line 1237
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1239
extern int ( /* missing proto */  __builtin_ia32_psllq128)() ;
#line 1237 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1239
  __cil_tmp3 = __builtin_ia32_psllq128(__A, __B);
  }
#line 1239
  return (__cil_tmp3);
}
}
#line 1243
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1245
extern int ( /* missing proto */  __builtin_ia32_psraw128)() ;
#line 1243 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1245
  __cil_tmp3 = __builtin_ia32_psraw128(__A, __B);
  }
#line 1245
  return (__cil_tmp3);
}
}
#line 1249
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1251
extern int ( /* missing proto */  __builtin_ia32_psrad128)() ;
#line 1249 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1251
  __cil_tmp3 = __builtin_ia32_psrad128(__A, __B);
  }
#line 1251
  return (__cil_tmp3);
}
}
#line 1255
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1257
extern int ( /* missing proto */  __builtin_ia32_psrlw128)() ;
#line 1255 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1257
  __cil_tmp3 = __builtin_ia32_psrlw128(__A, __B);
  }
#line 1257
  return (__cil_tmp3);
}
}
#line 1261
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1263
extern int ( /* missing proto */  __builtin_ia32_psrld128)() ;
#line 1261 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1263
  __cil_tmp3 = __builtin_ia32_psrld128(__A, __B);
  }
#line 1263
  return (__cil_tmp3);
}
}
#line 1267
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1269
extern int ( /* missing proto */  __builtin_ia32_psrlq128)() ;
#line 1267 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1269
  __cil_tmp3 = __builtin_ia32_psrlq128(__A, __B);
  }
#line 1269
  return (__cil_tmp3);
}
}
#line 1273
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_and_si128)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1273 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_and_si128)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1275
  return (__A & __B);
}
}
#line 1285
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_or_si128)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1285 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_or_si128)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1287
  return (__A | __B);
}
}
#line 1291
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_xor_si128)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1291 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_xor_si128)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1293
  return (__A ^ __B);
}
}
#line 1297
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1297 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1299
  return (__A == __B);
}
}
#line 1303
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1303 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1305
  return (__A == __B);
}
}
#line 1309
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1309 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1311
  return (__A == __B);
}
}
#line 1315
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1315 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1317
  return (__A < __B);
}
}
#line 1321
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1321 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1323
  return (__A < __B);
}
}
#line 1327
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1327 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1329
  return (__A < __B);
}
}
#line 1333
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1333 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1335
  return (__A > __B);
}
}
#line 1339
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1339 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1341
  return (__A > __B);
}
}
#line 1345
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1345 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1347
  return (__A > __B);
}
}
#line 1371
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1373
extern int ( /* missing proto */  __builtin_ia32_pmaxsw128)() ;
#line 1371 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1373
  __cil_tmp3 = __builtin_ia32_pmaxsw128(__A, __B);
  }
#line 1373
  return (__cil_tmp3);
}
}
#line 1377
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1379
extern int ( /* missing proto */  __builtin_ia32_pmaxub128)() ;
#line 1377 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1379
  __cil_tmp3 = __builtin_ia32_pmaxub128(__A, __B);
  }
#line 1379
  return (__cil_tmp3);
}
}
#line 1383
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1385
extern int ( /* missing proto */  __builtin_ia32_pminsw128)() ;
#line 1383 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1385
  __cil_tmp3 = __builtin_ia32_pminsw128(__A, __B);
  }
#line 1385
  return (__cil_tmp3);
}
}
#line 1389
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1391
extern int ( /* missing proto */  __builtin_ia32_pminub128)() ;
#line 1389 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1391
  __cil_tmp3 = __builtin_ia32_pminub128(__A, __B);
  }
#line 1391
  return (__cil_tmp3);
}
}
#line 1395
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_epi8)(__m128i __A ) ;
#line 1397
extern int ( /* missing proto */  __builtin_ia32_pmovmskb128)() ;
#line 1395 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_epi8)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1397
  __cil_tmp2 = __builtin_ia32_pmovmskb128(__A);
  }
#line 1397
  return (__cil_tmp2);
}
}
#line 1401
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epu16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1403
extern int ( /* missing proto */  __builtin_ia32_pmulhuw128)() ;
#line 1401 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epu16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1403
  __cil_tmp3 = __builtin_ia32_pmulhuw128(__A, __B);
  }
#line 1403
  return (__cil_tmp3);
}
}
#line 1434
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmoveu_si128)(__m128i __A ,
                                                                            __m128i __B ,
                                                                            char *__C ) ;
#line 1436
extern int ( /* missing proto */  __builtin_ia32_maskmovdqu)() ;
#line 1434 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmoveu_si128)(__m128i __A ,
                                                                            __m128i __B ,
                                                                            char *__C ) 
{ 


  {
  {
#line 1436
  __builtin_ia32_maskmovdqu(__A, __B, __C);
  }
#line 1438
  return;
}
}
#line 1440
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1442
extern int ( /* missing proto */  __builtin_ia32_pavgb128)() ;
#line 1440 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1442
  __cil_tmp3 = __builtin_ia32_pavgb128(__A, __B);
  }
#line 1442
  return (__cil_tmp3);
}
}
#line 1446
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1448
extern int ( /* missing proto */  __builtin_ia32_pavgw128)() ;
#line 1446 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1448
  __cil_tmp3 = __builtin_ia32_pavgw128(__A, __B);
  }
#line 1448
  return (__cil_tmp3);
}
}
#line 1452
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sad_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1454
extern int ( /* missing proto */  __builtin_ia32_psadbw128)() ;
#line 1452 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sad_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1454
  __cil_tmp3 = __builtin_ia32_psadbw128(__A, __B);
  }
#line 1454
  return (__cil_tmp3);
}
}
#line 1458
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si32)(int *__A ,
                                                                        int __B ) ;
#line 1460
extern int ( /* missing proto */  __builtin_ia32_movnti)() ;
#line 1458 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si32)(int *__A ,
                                                                        int __B ) 
{ 


  {
  {
#line 1460
  __builtin_ia32_movnti(__A, __B);
  }
#line 1462
  return;
}
}
#line 1465
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si64)(long long *__A ,
                                                                        long long __B ) ;
#line 1467
extern int ( /* missing proto */  __builtin_ia32_movnti64)() ;
#line 1465 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si64)(long long *__A ,
                                                                        long long __B ) 
{ 


  {
  {
#line 1467
  __builtin_ia32_movnti64(__A, __B);
  }
#line 1469
  return;
}
}
#line 1472
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si128)(__m128i *__A ,
                                                                         __m128i __B ) ;
#line 1474
extern int ( /* missing proto */  __builtin_ia32_movntdq)() ;
#line 1472 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si128)(__m128i *__A ,
                                                                         __m128i __B ) 
{ 


  {
  {
#line 1474
  __builtin_ia32_movntdq(__A, __B);
  }
#line 1476
  return;
}
}
#line 1478
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pd)(double *__A ,
                                                                      __m128d __B ) ;
#line 1480
extern int ( /* missing proto */  __builtin_ia32_movntpd)() ;
#line 1478 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pd)(double *__A ,
                                                                      __m128d __B ) 
{ 


  {
  {
#line 1480
  __builtin_ia32_movntpd(__A, __B);
  }
#line 1482
  return;
}
}
#line 1484
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) ;
#line 1486
extern int ( /* missing proto */  __builtin_ia32_clflush)() ;
#line 1484
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) ;
#line 1484 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) 
{ 


  {
  {
#line 1486
  __builtin_ia32_clflush(__A);
  }
#line 1488
  return;
}
}
#line 1490
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) ;
#line 1492
extern int ( /* missing proto */  __builtin_ia32_lfence)() ;
#line 1490
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) ;
#line 1490 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) 
{ 


  {
  {
#line 1492
  __builtin_ia32_lfence();
  }
#line 1494
  return;
}
}
#line 1496
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) ;
#line 1498
extern int ( /* missing proto */  __builtin_ia32_mfence)() ;
#line 1496
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) ;
#line 1496 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) 
{ 


  {
  {
#line 1498
  __builtin_ia32_mfence();
  }
#line 1500
  return;
}
}
#line 1502
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si128)(int __A ) ;
#line 1502 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si128)(int __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 1504
  __cil_tmp2 = _mm_set_epi32(0, 0, 0, __A);
  }
#line 1504
  return (__cil_tmp2);
}
}
#line 1510
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si128)(long long __A ) ;
#line 1510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si128)(long long __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 1512
  __cil_tmp2 = _mm_set_epi64x(0LL, __A);
  }
#line 1512
  return (__cil_tmp2);
}
}
#line 1526
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castpd_ps)(__m128d __A ) ;
#line 1526 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castpd_ps)(__m128d __A ) 
{ 


  {
#line 1528
  return (__A);
}
}
#line 1532
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castpd_si128)(__m128d __A ) ;
#line 1532 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castpd_si128)(__m128d __A ) 
{ 


  {
#line 1534
  return (__A);
}
}
#line 1538
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castps_pd)(__m128 __A ) ;
#line 1538 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castps_pd)(__m128 __A ) 
{ 


  {
#line 1540
  return (__A);
}
}
#line 1544
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castps_si128)(__m128 __A ) ;
#line 1544 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castps_si128)(__m128 __A ) 
{ 


  {
#line 1546
  return (__A);
}
}
#line 1550
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castsi128_ps)(__m128i __A ) ;
#line 1550 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castsi128_ps)(__m128i __A ) 
{ 


  {
#line 1552
  return (__A);
}
}
#line 1556
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castsi128_pd)(__m128i __A ) ;
#line 1556 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castsi128_pd)(__m128i __A ) 
{ 


  {
#line 1558
  return (__A);
}
}
#line 1265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_pause)(void) ;
#line 1267
extern int ( /* missing proto */  __builtin_ia32_pause)() ;
#line 1265
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_pause)(void) ;
#line 1265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_pause)(void) 
{ 


  {
  {
#line 1267
  __builtin_ia32_pause();
  }
#line 1269
  return;
}
}
#line 3 "/root/patron/new_24/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_ctxno_zc[2048]  = 
#line 3 "/root/patron/new_24/src/lib/openjp2/t1_luts.h"
  {      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )5,      (OPJ_BYTE )6, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )5,      (OPJ_BYTE )6, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )3,      (OPJ_BYTE )1,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )0,      (OPJ_BYTE )3,      (OPJ_BYTE )1,      (OPJ_BYTE )4, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )2,      (OPJ_BYTE )5, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8};
#line 70 "/root/patron/new_24/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_ctxno_sc[256]  = 
#line 70
  {      (OPJ_BYTE )9,      (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )11, 
        (OPJ_BYTE )9,      (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )13, 
        (OPJ_BYTE )9,      (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )11, 
        (OPJ_BYTE )9,      (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )11,      (OPJ_BYTE )13,      (OPJ_BYTE )11, 
        (OPJ_BYTE )13,      (OPJ_BYTE )11,      (OPJ_BYTE )13,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )9, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )9, 
        (OPJ_BYTE )13,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )12, 
        (OPJ_BYTE )13,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )12, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )13,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )10, 
        (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )10,      (OPJ_BYTE )11, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )12, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )12, 
        (OPJ_BYTE )13,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )9, 
        (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )12, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )9, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )9, 
        (OPJ_BYTE )11,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )12, 
        (OPJ_BYTE )11,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )12, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )13,      (OPJ_BYTE )11,      (OPJ_BYTE )13, 
        (OPJ_BYTE )11,      (OPJ_BYTE )13,      (OPJ_BYTE )11,      (OPJ_BYTE )13, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )12, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )12, 
        (OPJ_BYTE )11,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )9, 
        (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )12, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )11,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )10, 
        (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )10,      (OPJ_BYTE )13};
#line 89 "/root/patron/new_24/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_spb[256]  = 
#line 89
  {      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1};
#line 100 "/root/patron/new_24/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_sig[128]  = 
#line 100
  {      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )384,      (OPJ_INT16 )768,      (OPJ_INT16 )1152, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1920,      (OPJ_INT16 )2304,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )3456,      (OPJ_INT16 )3840,      (OPJ_INT16 )4224, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4992,      (OPJ_INT16 )5376,      (OPJ_INT16 )5760, 
        (OPJ_INT16 )6144,      (OPJ_INT16 )6528,      (OPJ_INT16 )6912,      (OPJ_INT16 )7296, 
        (OPJ_INT16 )7680,      (OPJ_INT16 )8064,      (OPJ_INT16 )8448,      (OPJ_INT16 )8832, 
        (OPJ_INT16 )9216,      (OPJ_INT16 )9600,      (OPJ_INT16 )9984,      (OPJ_INT16 )10368, 
        (OPJ_INT16 )10752,      (OPJ_INT16 )11136,      (OPJ_INT16 )11520,      (OPJ_INT16 )11904, 
        (OPJ_INT16 )12288,      (OPJ_INT16 )12672,      (OPJ_INT16 )13056,      (OPJ_INT16 )13440, 
        (OPJ_INT16 )13824,      (OPJ_INT16 )14208,      (OPJ_INT16 )14592,      (OPJ_INT16 )14976, 
        (OPJ_INT16 )15360,      (OPJ_INT16 )15744,      (OPJ_INT16 )16128,      (OPJ_INT16 )16512, 
        (OPJ_INT16 )16896,      (OPJ_INT16 )17280,      (OPJ_INT16 )17664,      (OPJ_INT16 )18048, 
        (OPJ_INT16 )18432,      (OPJ_INT16 )18816,      (OPJ_INT16 )19200,      (OPJ_INT16 )19584, 
        (OPJ_INT16 )19968,      (OPJ_INT16 )20352,      (OPJ_INT16 )20736,      (OPJ_INT16 )21120, 
        (OPJ_INT16 )21504,      (OPJ_INT16 )21888,      (OPJ_INT16 )22272,      (OPJ_INT16 )22656, 
        (OPJ_INT16 )23040,      (OPJ_INT16 )23424,      (OPJ_INT16 )23808,      (OPJ_INT16 )24192, 
        (OPJ_INT16 )24576,      (OPJ_INT16 )24960,      (OPJ_INT16 )25344,      (OPJ_INT16 )25728, 
        (OPJ_INT16 )26112,      (OPJ_INT16 )26496,      (OPJ_INT16 )26880,      (OPJ_INT16 )27264, 
        (OPJ_INT16 )27648,      (OPJ_INT16 )28032,      (OPJ_INT16 )28416,      (OPJ_INT16 )28800, 
        (OPJ_INT16 )29184,      (OPJ_INT16 )29568,      (OPJ_INT16 )29952,      (OPJ_INT16 )30336};
#line 119 "/root/patron/new_24/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_sig0[128]  = 
#line 119
  {      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )256, 
        (OPJ_INT16 )256,      (OPJ_INT16 )384,      (OPJ_INT16 )384,      (OPJ_INT16 )512, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )640,      (OPJ_INT16 )768, 
        (OPJ_INT16 )768,      (OPJ_INT16 )896,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2944,      (OPJ_INT16 )3072, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3584,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5632,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6528,      (OPJ_INT16 )6784,      (OPJ_INT16 )6912, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )7424,      (OPJ_INT16 )7680,      (OPJ_INT16 )7936, 
        (OPJ_INT16 )8192,      (OPJ_INT16 )8448,      (OPJ_INT16 )8704,      (OPJ_INT16 )8960, 
        (OPJ_INT16 )9216,      (OPJ_INT16 )9472,      (OPJ_INT16 )9856,      (OPJ_INT16 )10112, 
        (OPJ_INT16 )10368,      (OPJ_INT16 )10624,      (OPJ_INT16 )11008,      (OPJ_INT16 )11264, 
        (OPJ_INT16 )11520,      (OPJ_INT16 )11904,      (OPJ_INT16 )12160,      (OPJ_INT16 )12544, 
        (OPJ_INT16 )12800,      (OPJ_INT16 )13184,      (OPJ_INT16 )13440,      (OPJ_INT16 )13824, 
        (OPJ_INT16 )14080,      (OPJ_INT16 )14464,      (OPJ_INT16 )14848,      (OPJ_INT16 )15104, 
        (OPJ_INT16 )15488,      (OPJ_INT16 )15872,      (OPJ_INT16 )16256,      (OPJ_INT16 )16512, 
        (OPJ_INT16 )16896,      (OPJ_INT16 )17280,      (OPJ_INT16 )17664,      (OPJ_INT16 )18048, 
        (OPJ_INT16 )18432,      (OPJ_INT16 )18816,      (OPJ_INT16 )19200,      (OPJ_INT16 )19584, 
        (OPJ_INT16 )19968,      (OPJ_INT16 )20352,      (OPJ_INT16 )20864,      (OPJ_INT16 )21248, 
        (OPJ_INT16 )21632,      (OPJ_INT16 )22016,      (OPJ_INT16 )22528,      (OPJ_INT16 )22912, 
        (OPJ_INT16 )23296,      (OPJ_INT16 )23808,      (OPJ_INT16 )24192,      (OPJ_INT16 )24704, 
        (OPJ_INT16 )25088,      (OPJ_INT16 )25600,      (OPJ_INT16 )25984,      (OPJ_INT16 )26496, 
        (OPJ_INT16 )26880,      (OPJ_INT16 )27392,      (OPJ_INT16 )27904,      (OPJ_INT16 )28288, 
        (OPJ_INT16 )28800,      (OPJ_INT16 )29312,      (OPJ_INT16 )29824,      (OPJ_INT16 )30208, 
        (OPJ_INT16 )30720,      (OPJ_INT16 )31232,      (OPJ_INT16 )31744,      (OPJ_INT16 )32256};
#line 138 "/root/patron/new_24/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_ref[128]  = 
#line 138
  {      (OPJ_INT16 )6144,      (OPJ_INT16 )6016,      (OPJ_INT16 )5888,      (OPJ_INT16 )5760, 
        (OPJ_INT16 )5632,      (OPJ_INT16 )5504,      (OPJ_INT16 )5376,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5120,      (OPJ_INT16 )4992,      (OPJ_INT16 )4864,      (OPJ_INT16 )4736, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4480,      (OPJ_INT16 )4352,      (OPJ_INT16 )4224, 
        (OPJ_INT16 )4096,      (OPJ_INT16 )3968,      (OPJ_INT16 )3840,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3584,      (OPJ_INT16 )3456,      (OPJ_INT16 )3328,      (OPJ_INT16 )3200, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )2944,      (OPJ_INT16 )2816,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2432,      (OPJ_INT16 )2304,      (OPJ_INT16 )2176, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )1920,      (OPJ_INT16 )1792,      (OPJ_INT16 )1664, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1408,      (OPJ_INT16 )1280,      (OPJ_INT16 )1152, 
        (OPJ_INT16 )1024,      (OPJ_INT16 )896,      (OPJ_INT16 )768,      (OPJ_INT16 )640, 
        (OPJ_INT16 )512,      (OPJ_INT16 )384,      (OPJ_INT16 )256,      (OPJ_INT16 )128, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )384, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )768,      (OPJ_INT16 )896, 
        (OPJ_INT16 )1024,      (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2816,      (OPJ_INT16 )2944, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3456, 
        (OPJ_INT16 )3584,      (OPJ_INT16 )3712,      (OPJ_INT16 )3840,      (OPJ_INT16 )3968, 
        (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4352,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4736,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992, 
        (OPJ_INT16 )5120,      (OPJ_INT16 )5248,      (OPJ_INT16 )5376,      (OPJ_INT16 )5504, 
        (OPJ_INT16 )5632,      (OPJ_INT16 )5760,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016};
#line 157 "/root/patron/new_24/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_ref0[128]  = 
#line 157
  {      (OPJ_INT16 )8192,      (OPJ_INT16 )7936,      (OPJ_INT16 )7680,      (OPJ_INT16 )7424, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )6912,      (OPJ_INT16 )6784,      (OPJ_INT16 )6528, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6016,      (OPJ_INT16 )5888,      (OPJ_INT16 )5632, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5248,      (OPJ_INT16 )4992,      (OPJ_INT16 )4864, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4480,      (OPJ_INT16 )4224,      (OPJ_INT16 )4096, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )3712,      (OPJ_INT16 )3584,      (OPJ_INT16 )3328, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3072,      (OPJ_INT16 )2944,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2432,      (OPJ_INT16 )2304,      (OPJ_INT16 )2176, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )1920,      (OPJ_INT16 )1792,      (OPJ_INT16 )1664, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408,      (OPJ_INT16 )1280, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024,      (OPJ_INT16 )896, 
        (OPJ_INT16 )768,      (OPJ_INT16 )768,      (OPJ_INT16 )640,      (OPJ_INT16 )640, 
        (OPJ_INT16 )512,      (OPJ_INT16 )512,      (OPJ_INT16 )384,      (OPJ_INT16 )384, 
        (OPJ_INT16 )256,      (OPJ_INT16 )256,      (OPJ_INT16 )256,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )256, 
        (OPJ_INT16 )256,      (OPJ_INT16 )384,      (OPJ_INT16 )384,      (OPJ_INT16 )512, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )640,      (OPJ_INT16 )768, 
        (OPJ_INT16 )768,      (OPJ_INT16 )896,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2944,      (OPJ_INT16 )3072, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3584,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5632,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6528,      (OPJ_INT16 )6784,      (OPJ_INT16 )6912, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )7424,      (OPJ_INT16 )7680,      (OPJ_INT16 )7936};
#line 67 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static OPJ_BYTE opj_t1_getctxno_zc(opj_mqc_t *mqc , OPJ_UINT32 f ) ;
#line 68
__inline static OPJ_UINT32 opj_t1_getctxno_mag(OPJ_UINT32 f ) ;
#line 69
static OPJ_INT16 opj_t1_getnmsedec_sig(OPJ_UINT32 x , OPJ_UINT32 bitpos ) ;
#line 70
static OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x , OPJ_UINT32 bitpos ) ;
#line 71
__inline static void opj_t1_update_flags(opj_flag_t *flagsp , OPJ_UINT32 ci , OPJ_UINT32 s ,
                                         OPJ_UINT32 stride , OPJ_UINT32 vsc ) ;
#line 80
__inline static void opj_t1_dec_sigpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 oneplushalf ,
                                                 OPJ_UINT32 vsc , OPJ_UINT32 ci ) ;
#line 87
__inline static void opj_t1_dec_sigpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 oneplushalf ,
                                                 OPJ_UINT32 ci , OPJ_UINT32 flags_stride ,
                                                 OPJ_UINT32 vsc ) ;
#line 99
static void opj_t1_enc_sigpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec ,
                               OPJ_BYTE type , OPJ_UINT32 cblksty ) ;
#line 108
static void opj_t1_dec_sigpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 cblksty ) ;
#line 116
static void opj_t1_enc_refpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec ,
                               OPJ_BYTE type ) ;
#line 124
static void opj_t1_dec_refpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno ) ;
#line 133
__inline static void opj_t1_dec_refpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 poshalf ,
                                                 OPJ_UINT32 ci ) ;
#line 139
__inline static void opj_t1_dec_refpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 poshalf ,
                                                 OPJ_UINT32 ci ) ;
#line 151
static void opj_t1_dec_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                    OPJ_INT32 oneplushalf , OPJ_UINT32 ci , OPJ_UINT32 vsc ) ;
#line 162
static void opj_t1_enc_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec ,
                               OPJ_UINT32 cblksty ) ;
#line 168
static OPJ_FLOAT64 opj_t1_getwmsedec(OPJ_INT32 nmsedec , OPJ_UINT32 compno , OPJ_UINT32 level ,
                                     OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_UINT32 qmfbid ,
                                     OPJ_FLOAT64 stepsize , OPJ_UINT32 numcomps ,
                                     OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) ;
#line 180
static void opj_t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , OPJ_UINT32 orient ,
                               OPJ_UINT32 compno , OPJ_UINT32 level , OPJ_UINT32 qmfbid ,
                               OPJ_FLOAT64 stepsize , OPJ_UINT32 cblksty , OPJ_UINT32 numcomps ,
                               opj_tcd_tile_t *tile , OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) ;
#line 204
static OPJ_BOOL opj_t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 orient ,
                                   OPJ_UINT32 roishift , OPJ_UINT32 cblksty , opj_event_mgr_t *p_manager ,
                                   opj_mutex_t *p_manager_mutex , OPJ_BOOL check_pterm ) ;
#line 213
static OPJ_BOOL opj_t1_allocate_buffers(opj_t1_t *t1 , OPJ_UINT32 w , OPJ_UINT32 h ) ;
#line 223 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static OPJ_BYTE opj_t1_getctxno_zc(opj_mqc_t *mqc , OPJ_UINT32 f ) 
{ 


  {
#line 225
  return (*(mqc->lut_ctxno_zc_orient + (f & (((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)))));
}
}
#line 228 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static OPJ_UINT32 opj_t1_getctxtno_sc_or_spb_index(OPJ_UINT32 fX , OPJ_UINT32 pfX ,
                                                            OPJ_UINT32 nfX , OPJ_UINT32 ci ) 
{ 
  OPJ_UINT32 lu ;

  {
#line 244
  lu = (fX >> ci * 3U) & ((((1U << 1) | (1U << 3)) | (1U << 5)) | (1U << 7));
#line 247
  lu |= (pfX >> (19U + ci * 3U)) & 1U;
#line 248
  lu |= (nfX >> (17U + ci * 3U)) & (1U << 2);
#line 249
  if (ci == 0U) {
#line 250
    lu |= (fX >> 14U) & (1U << 4);
  } else {
#line 252
    lu |= (fX >> (15U + (ci - 1U) * 3U)) & (1U << 4);
  }
#line 254
  lu |= (fX >> (16U + ci * 3U)) & (1U << 6);
#line 255
  return (lu);
}
}
#line 258 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static OPJ_BYTE opj_t1_getctxno_sc(OPJ_UINT32 lu ) 
{ 


  {
#line 260
  return (lut_ctxno_sc[lu]);
}
}
#line 263 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static OPJ_UINT32 opj_t1_getctxno_mag(OPJ_UINT32 f ) 
{ 
  OPJ_UINT32 tmp ;
  int tmp___4 ;
  OPJ_UINT32 tmp2 ;
  unsigned int tmp___5 ;

  {
#line 265
  if (f & (((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8))) {
#line 265
    tmp___4 = 15;
  } else {
#line 265
    tmp___4 = 14;
  }
#line 265
  tmp = (OPJ_UINT32 )tmp___4;
#line 266
  if (f & (1U << 20)) {
#line 266
    tmp___5 = 16U;
  } else {
#line 266
    tmp___5 = tmp;
  }
#line 266
  tmp2 = tmp___5;
#line 267
  return (tmp2);
}
}
#line 270 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static OPJ_BYTE opj_t1_getspb(OPJ_UINT32 lu ) 
{ 


  {
#line 272
  return (lut_spb[lu]);
}
}
#line 275 "/root/patron/new_24/src/lib/openjp2/t1.c"
static OPJ_INT16 opj_t1_getnmsedec_sig(OPJ_UINT32 x , OPJ_UINT32 bitpos ) 
{ 


  {
#line 277
  if (bitpos > 0U) {
#line 278
    return (lut_nmsedec_sig[(x >> bitpos) & (unsigned int )((1 << 7) - 1)]);
  }
#line 281
  return (lut_nmsedec_sig0[x & (unsigned int )((1 << 7) - 1)]);
}
}
#line 284 "/root/patron/new_24/src/lib/openjp2/t1.c"
static OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x , OPJ_UINT32 bitpos ) 
{ 


  {
#line 286
  if (bitpos > 0U) {
#line 287
    return (lut_nmsedec_ref[(x >> bitpos) & (unsigned int )((1 << 7) - 1)]);
  }
#line 290
  return (lut_nmsedec_ref0[x & (unsigned int )((1 << 7) - 1)]);
}
}
#line 322 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static void opj_t1_update_flags(opj_flag_t *flagsp , OPJ_UINT32 ci , OPJ_UINT32 s ,
                                         OPJ_UINT32 stride , OPJ_UINT32 vsc ) 
{ 
  opj_flag_t *north ;
  opj_flag_t *south ;

  {
#line 326
  *(flagsp + -1) |= (1U << 5) << 3U * ci;
#line 326
  *flagsp |= ((s << 19) | (1U << 4)) << 3U * ci;
#line 326
  *(flagsp + 1) |= (1U << 3) << 3U * ci;
#line 326
  if (ci == 0U) {
#line 326
    if (! vsc) {
#line 326
      north = flagsp - stride;
#line 326
      *north |= (s << 31) | (1U << 16);
#line 326
      *(north + -1) |= 1U << 17;
#line 326
      *(north + 1) |= 1U << 15;
    }
  }
#line 326
  if (ci == 3U) {
#line 326
    south = flagsp + stride;
#line 326
    *south |= (s << 18) | (1U << 1);
#line 326
    *(south + -1) |= 1U << 2;
#line 326
    *(south + 1) |= 1U;
  }
#line 329
  return;
}
}
#line 332 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static void opj_t1_enc_sigpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                             OPJ_INT32 bpno , OPJ_INT32 one , OPJ_INT32 *nmsedec ,
                                             OPJ_BYTE type , OPJ_UINT32 ci , OPJ_UINT32 vsc ) 
{ 
  OPJ_UINT32 v ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 flags ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  int tmp ;
  OPJ_UINT32 lu ;
  OPJ_UINT32 __cil_tmp18 ;
  OPJ_UINT32 ctxt2 ;
  OPJ_BYTE __cil_tmp20 ;
  unsigned int tmp___0 ;
  OPJ_INT32 __cil_tmp22 ;
  OPJ_INT16 __cil_tmp23 ;
  OPJ_UINT32 spb ;
  OPJ_BYTE __cil_tmp25 ;

  {
#line 344
  mqc = & t1->mqc;
#line 346
  flags = *flagsp;
#line 348
  if ((flags & (((1U << 4) | (1U << 21)) << ci * 3U)) == 0U) {
#line 348
    if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << ci * 3U)) != 0U) {
      {
#line 350
      __cil_tmp14 = opj_t1_getctxno_zc(mqc, flags >> ci * 3U);
#line 350
      ctxt1 = (OPJ_UINT32 )__cil_tmp14;
#line 351
      __cil_tmp15 = opj_int_abs(*datap);
      }
#line 351
      if (__cil_tmp15 & one) {
#line 351
        tmp = 1;
      } else {
#line 351
        tmp = 0;
      }
#line 351
      v = (OPJ_UINT32 )tmp;
#line 355
      mqc->curctx = & mqc->ctxs[ctxt1];
#line 356
      if ((int )type == 1) {
        {
#line 357
        opj_mqc_bypass_enc(mqc, v);
        }
      } else {
        {
#line 359
        opj_mqc_encode(mqc, v);
        }
      }
#line 361
      if (v) {
        {
#line 362
        __cil_tmp18 = opj_t1_getctxtno_sc_or_spb_index(*flagsp, *(flagsp + -1), *(flagsp + 1),
                                                       ci);
#line 362
        lu = __cil_tmp18;
#line 366
        __cil_tmp20 = opj_t1_getctxno_sc(lu);
#line 366
        ctxt2 = (OPJ_UINT32 )__cil_tmp20;
        }
#line 367
        if (*datap < 0) {
#line 367
          tmp___0 = 1U;
        } else {
#line 367
          tmp___0 = 0U;
        }
        {
#line 367
        v = tmp___0;
#line 368
        __cil_tmp22 = opj_int_abs(*datap);
#line 368
        __cil_tmp23 = opj_t1_getnmsedec_sig((OPJ_UINT32 )__cil_tmp22, (OPJ_UINT32 )bpno);
#line 368
        *nmsedec += (int )__cil_tmp23;
#line 373
        mqc->curctx = & mqc->ctxs[ctxt2];
        }
#line 374
        if ((int )type == 1) {
          {
#line 375
          opj_mqc_bypass_enc(mqc, v);
          }
        } else {
          {
#line 377
          __cil_tmp25 = opj_t1_getspb(lu);
#line 377
          spb = (OPJ_UINT32 )__cil_tmp25;
#line 381
          opj_mqc_encode(mqc, v ^ spb);
          }
        }
        {
#line 383
        opj_t1_update_flags(flagsp, ci, v, t1->w + 2U, vsc);
        }
      }
#line 385
      *flagsp |= (1U << 21) << ci * 3U;
    }
  }
#line 388
  return;
}
}
#line 389 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static void opj_t1_dec_sigpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 oneplushalf ,
                                                 OPJ_UINT32 vsc , OPJ_UINT32 ci ) 
{ 
  OPJ_UINT32 v ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 flags ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_INT32 tmp ;

  {
#line 398
  mqc = & t1->mqc;
#line 400
  flags = *flagsp;
#line 402
  if ((flags & (((1U << 4) | (1U << 21)) << ci * 3U)) == 0U) {
#line 402
    if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << ci * 3U)) != 0U) {
      {
#line 404
      __cil_tmp10 = opj_mqc_raw_decode(mqc);
      }
#line 404
      if (__cil_tmp10) {
        {
#line 405
        v = opj_mqc_raw_decode(mqc);
        }
#line 406
        if (v) {
#line 406
          tmp = - oneplushalf;
        } else {
#line 406
          tmp = oneplushalf;
        }
        {
#line 406
        *datap = tmp;
#line 407
        opj_t1_update_flags(flagsp, ci, v, t1->w + 2U, vsc);
        }
      }
#line 409
      *flagsp |= (1U << 21) << ci * 3U;
    }
  }
#line 412
  return;
}
}
#line 439 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static void opj_t1_dec_sigpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 oneplushalf ,
                                                 OPJ_UINT32 ci , OPJ_UINT32 flags_stride ,
                                                 OPJ_UINT32 vsc ) 
{ 
  OPJ_UINT32 v ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp16 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp21 ;
  OPJ_UINT32 lu ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 ctxt2 ;
  OPJ_BYTE __cil_tmp25 ;
  OPJ_UINT32 spb ;
  OPJ_BYTE __cil_tmp27 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp37 ;
  OPJ_INT32 tmp ;
  opj_flag_t *north ;
  opj_flag_t *south ;

  {
#line 450
  mqc = & t1->mqc;
#line 451
  if ((*flagsp & (((1U << 4) | (1U << 21)) << ci * 3U)) == 0U) {
#line 451
    if ((*flagsp & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << ci * 3U)) != 0U) {
      {
#line 451
      __cil_tmp11 = opj_t1_getctxno_zc(mqc, *flagsp >> ci * 3U);
#line 451
      ctxt1 = (OPJ_UINT32 )__cil_tmp11;
#line 451
      mqc->curctx = & mqc->ctxs[ctxt1];
#line 451
      mqc->a -= (*(mqc->curctx))->qeval;
      }
#line 451
      if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
#line 451
        if (mqc->a < (*(mqc->curctx))->qeval) {
#line 451
          mqc->a = (*(mqc->curctx))->qeval;
#line 451
          v = (*(mqc->curctx))->mps;
#line 451
          *(mqc->curctx) = (*(mqc->curctx))->nmps;
        } else {
#line 451
          mqc->a = (*(mqc->curctx))->qeval;
#line 451
          v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 451
          *(mqc->curctx) = (*(mqc->curctx))->nlps;
        }
        {
#line 451
        while (1) {
          while_continue: /* CIL Label */ ;

#line 451
          if (mqc->ct == 0U) {
#line 451
            l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 451
            if ((int )*(mqc->bp) == 255) {
#line 451
              if (l_c > 143U) {
#line 451
                mqc->c += 65280U;
#line 451
                mqc->ct = (OPJ_UINT32 )8;
#line 451
                (mqc->end_of_byte_stream_counter) ++;
              } else {
#line 451
                (mqc->bp) ++;
#line 451
                mqc->c += l_c << 9;
#line 451
                mqc->ct = (OPJ_UINT32 )7;
              }
            } else {
#line 451
              (mqc->bp) ++;
#line 451
              mqc->c += l_c << 8;
#line 451
              mqc->ct = (OPJ_UINT32 )8;
            }
          }
#line 451
          mqc->a <<= 1;
#line 451
          mqc->c <<= 1;
#line 451
          __cil_tmp16 = mqc->ct;
#line 451
          (mqc->ct) --;
#line 451
          if (! (mqc->a < 32768U)) {
#line 451
            goto while_break;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break: ;
      } else {
#line 451
        mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 451
        if ((mqc->a & 32768U) == 0U) {
#line 451
          if (mqc->a < (*(mqc->curctx))->qeval) {
#line 451
            v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 451
            *(mqc->curctx) = (*(mqc->curctx))->nlps;
          } else {
#line 451
            v = (*(mqc->curctx))->mps;
#line 451
            *(mqc->curctx) = (*(mqc->curctx))->nmps;
          }
          {
#line 451
          while (1) {
            while_continue___0: /* CIL Label */ ;

#line 451
            if (mqc->ct == 0U) {
#line 451
              l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 451
              if ((int )*(mqc->bp) == 255) {
#line 451
                if (l_c___0 > 143U) {
#line 451
                  mqc->c += 65280U;
#line 451
                  mqc->ct = (OPJ_UINT32 )8;
#line 451
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 451
                  (mqc->bp) ++;
#line 451
                  mqc->c += l_c___0 << 9;
#line 451
                  mqc->ct = (OPJ_UINT32 )7;
                }
              } else {
#line 451
                (mqc->bp) ++;
#line 451
                mqc->c += l_c___0 << 8;
#line 451
                mqc->ct = (OPJ_UINT32 )8;
              }
            }
#line 451
            mqc->a <<= 1;
#line 451
            mqc->c <<= 1;
#line 451
            __cil_tmp21 = mqc->ct;
#line 451
            (mqc->ct) --;
#line 451
            if (! (mqc->a < 32768U)) {
#line 451
              goto while_break___0;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          while_break___0: ;
        } else {
#line 451
          v = (*(mqc->curctx))->mps;
        }
      }
#line 451
      if (v) {
        {
#line 451
        __cil_tmp23 = opj_t1_getctxtno_sc_or_spb_index(*flagsp, *(flagsp + -1), *(flagsp + 1),
                                                       ci);
#line 451
        lu = __cil_tmp23;
#line 451
        __cil_tmp25 = opj_t1_getctxno_sc(lu);
#line 451
        ctxt2 = (OPJ_UINT32 )__cil_tmp25;
#line 451
        __cil_tmp27 = opj_t1_getspb(lu);
#line 451
        spb = (OPJ_UINT32 )__cil_tmp27;
#line 451
        mqc->curctx = & mqc->ctxs[ctxt2];
#line 451
        mqc->a -= (*(mqc->curctx))->qeval;
        }
#line 451
        if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
#line 451
          if (mqc->a < (*(mqc->curctx))->qeval) {
#line 451
            mqc->a = (*(mqc->curctx))->qeval;
#line 451
            v = (*(mqc->curctx))->mps;
#line 451
            *(mqc->curctx) = (*(mqc->curctx))->nmps;
          } else {
#line 451
            mqc->a = (*(mqc->curctx))->qeval;
#line 451
            v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 451
            *(mqc->curctx) = (*(mqc->curctx))->nlps;
          }
          {
#line 451
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 451
            if (mqc->ct == 0U) {
#line 451
              l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 451
              if ((int )*(mqc->bp) == 255) {
#line 451
                if (l_c___1 > 143U) {
#line 451
                  mqc->c += 65280U;
#line 451
                  mqc->ct = (OPJ_UINT32 )8;
#line 451
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 451
                  (mqc->bp) ++;
#line 451
                  mqc->c += l_c___1 << 9;
#line 451
                  mqc->ct = (OPJ_UINT32 )7;
                }
              } else {
#line 451
                (mqc->bp) ++;
#line 451
                mqc->c += l_c___1 << 8;
#line 451
                mqc->ct = (OPJ_UINT32 )8;
              }
            }
#line 451
            mqc->a <<= 1;
#line 451
            mqc->c <<= 1;
#line 451
            __cil_tmp32 = mqc->ct;
#line 451
            (mqc->ct) --;
#line 451
            if (! (mqc->a < 32768U)) {
#line 451
              goto while_break___1;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          while_break___1: ;
        } else {
#line 451
          mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 451
          if ((mqc->a & 32768U) == 0U) {
#line 451
            if (mqc->a < (*(mqc->curctx))->qeval) {
#line 451
              v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 451
              *(mqc->curctx) = (*(mqc->curctx))->nlps;
            } else {
#line 451
              v = (*(mqc->curctx))->mps;
#line 451
              *(mqc->curctx) = (*(mqc->curctx))->nmps;
            }
            {
#line 451
            while (1) {
              while_continue___2: /* CIL Label */ ;

#line 451
              if (mqc->ct == 0U) {
#line 451
                l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 451
                if ((int )*(mqc->bp) == 255) {
#line 451
                  if (l_c___2 > 143U) {
#line 451
                    mqc->c += 65280U;
#line 451
                    mqc->ct = (OPJ_UINT32 )8;
#line 451
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 451
                    (mqc->bp) ++;
#line 451
                    mqc->c += l_c___2 << 9;
#line 451
                    mqc->ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 451
                  (mqc->bp) ++;
#line 451
                  mqc->c += l_c___2 << 8;
#line 451
                  mqc->ct = (OPJ_UINT32 )8;
                }
              }
#line 451
              mqc->a <<= 1;
#line 451
              mqc->c <<= 1;
#line 451
              __cil_tmp37 = mqc->ct;
#line 451
              (mqc->ct) --;
#line 451
              if (! (mqc->a < 32768U)) {
#line 451
                goto while_break___2;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
            while_break___2: ;
          } else {
#line 451
            v = (*(mqc->curctx))->mps;
          }
        }
#line 451
        v ^= spb;
#line 451
        if (v) {
#line 451
          tmp = - oneplushalf;
        } else {
#line 451
          tmp = oneplushalf;
        }
#line 451
        *(datap + 0U) = tmp;
#line 451
        *(flagsp + -1) |= (1U << 5) << 3U * ci;
#line 451
        *flagsp |= ((v << 19) | (1U << 4)) << 3U * ci;
#line 451
        *(flagsp + 1) |= (1U << 3) << 3U * ci;
#line 451
        if (ci == 0U) {
#line 451
          if (! vsc) {
#line 451
            north = flagsp - flags_stride;
#line 451
            *north |= (v << 31) | (1U << 16);
#line 451
            *(north + -1) |= 1U << 17;
#line 451
            *(north + 1) |= 1U << 15;
          }
        }
#line 451
        if (ci == 3U) {
#line 451
          south = flagsp + flags_stride;
#line 451
          *south |= (v << 18) | (1U << 1);
#line 451
          *(south + -1) |= 1U << 2;
#line 451
          *(south + 1) |= 1U;
        }
      }
#line 451
      *flagsp |= (1U << 21) << ci * 3U;
    }
  }
#line 455
  return;
}
}
#line 456 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_enc_sigpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec ,
                               OPJ_BYTE type , OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 k ;
  OPJ_INT32 one ;
  opj_flag_t *f ;
  OPJ_UINT32 extra ;
  OPJ_UINT32 j ;
  int tmp ;

  {
#line 464
  one = 1 << (bpno + 6);
#line 465
  f = t1->flags + (1U + (t1->w + 2U));
#line 466
  extra = (OPJ_UINT32 )2;
#line 468
  *nmsedec = 0;
#line 472
  k = (OPJ_UINT32 )0;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;

#line 472
    if (! (k < (t1->h & 4294967292U))) {
#line 472
      goto while_break;
    }
#line 476
    i = (OPJ_UINT32 )0;
    {
#line 476
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: ;
#line 476
      if (! (i < t1->w)) {
#line 476
        goto while_break___0;
      }
#line 480
      if (*f == 0U) {
#line 482
        f ++;
#line 483
        goto while_continue___0;
      }
      {
#line 485
      opj_t1_enc_sigpass_step(t1, f, t1->data + (k * t1->data_stride + i), bpno, one,
                              nmsedec, type, (OPJ_UINT32 )0, cblksty & 8U);
#line 494
      opj_t1_enc_sigpass_step(t1, f, t1->data + ((k + 1U) * t1->data_stride + i),
                              bpno, one, nmsedec, type, (OPJ_UINT32 )1, (OPJ_UINT32 )0);
#line 503
      opj_t1_enc_sigpass_step(t1, f, t1->data + ((k + 2U) * t1->data_stride + i),
                              bpno, one, nmsedec, type, (OPJ_UINT32 )2, (OPJ_UINT32 )0);
#line 512
      opj_t1_enc_sigpass_step(t1, f, t1->data + ((k + 3U) * t1->data_stride + i),
                              bpno, one, nmsedec, type, (OPJ_UINT32 )3, (OPJ_UINT32 )0);
#line 521
      f ++;
#line 476
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 523
    f += extra;
#line 472
    k += 4U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 526
  if (k < t1->h) {
#line 531
    i = (OPJ_UINT32 )0;
    {
#line 531
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___1: ;
#line 531
      if (! (i < t1->w)) {
#line 531
        goto while_break___1;
      }
#line 535
      if (*f == 0U) {
#line 537
        f ++;
#line 538
        goto while_continue___1;
      }
#line 540
      j = k;
      {
#line 540
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 540
        if (! (j < t1->h)) {
#line 540
          goto while_break___2;
        }
#line 541
        if (j == k) {
#line 541
          if ((cblksty & 8U) != 0U) {
#line 541
            tmp = 1;
          } else {
#line 541
            tmp = 0;
          }
        } else {
#line 541
          tmp = 0;
        }
        {
#line 541
        opj_t1_enc_sigpass_step(t1, f, t1->data + (j * t1->data_stride + i), bpno,
                                one, nmsedec, type, j - k, (OPJ_UINT32 )tmp);
#line 540
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 552
      f ++;
#line 531
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 536
  return;
}
}
#line 557 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_sigpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 cblksty ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 *data ;
  opj_flag_t *flagsp ;
  OPJ_UINT32 l_w ;
  opj_flag_t flags ;

  {
#line 564
  data = t1->data;
#line 565
  flagsp = t1->flags + (1U + (t1->w + 2U));
#line 566
  l_w = t1->w;
#line 567
  one = 1 << bpno;
#line 568
  half = one >> 1;
#line 569
  oneplushalf = one | half;
#line 571
  k = (OPJ_UINT32 )0;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;

#line 571
    if (! (k < (t1->h & 4294967292U))) {
#line 571
      goto while_break;
    }
#line 572
    i = (OPJ_UINT32 )0;
    {
#line 572
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 572
      if (! (i < l_w)) {
#line 572
        goto while_break___0;
      }
#line 573
      flags = *flagsp;
#line 574
      if (flags != 0U) {
        {
#line 575
        opj_t1_dec_sigpass_step_raw(t1, flagsp, data, oneplushalf, (OPJ_UINT32 )(cblksty & 8),
                                    0U);
#line 582
        opj_t1_dec_sigpass_step_raw(t1, flagsp, data + l_w, oneplushalf, (OPJ_UINT32 )0,
                                    1U);
#line 589
        opj_t1_dec_sigpass_step_raw(t1, flagsp, data + 2U * l_w, oneplushalf, (OPJ_UINT32 )0,
                                    2U);
#line 596
        opj_t1_dec_sigpass_step_raw(t1, flagsp, data + 3U * l_w, oneplushalf, (OPJ_UINT32 )0,
                                    3U);
        }
      }
#line 572
      data ++;
#line 572
      flagsp ++;
#line 572
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 571
    data += 3U * l_w;
#line 571
    flagsp += 2;
#line 571
    k += 4U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 606
  if (k < t1->h) {
#line 607
    i = (OPJ_UINT32 )0;
    {
#line 607
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 607
      if (! (i < l_w)) {
#line 607
        goto while_break___1;
      }
#line 608
      j = (OPJ_UINT32 )0;
      {
#line 608
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 608
        if (! (j < t1->h - k)) {
#line 608
          goto while_break___2;
        }
        {
#line 609
        opj_t1_dec_sigpass_step_raw(t1, flagsp, data + j * l_w, oneplushalf, (OPJ_UINT32 )(cblksty & 8),
                                    j);
#line 608
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 607
      data ++;
#line 607
      flagsp ++;
#line 607
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 612
  return;
}
}
#line 665 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_sigpass_mqc_64x64_novsc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  register OPJ_INT32 *data ;
  register opj_flag_t *flagsp ;
  OPJ_UINT32 l_w ;
  opj_mqc_t *mqc ;
  register opj_mqc_state_t **curctx ;
  register OPJ_UINT32 c ;
  register OPJ_UINT32 a ;
  register OPJ_UINT32 ct ;
  register OPJ_UINT32 v ;
  opj_flag_t flags ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp20 ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 lu ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 ctxt2 ;
  OPJ_BYTE __cil_tmp34 ;
  OPJ_UINT32 spb ;
  OPJ_BYTE __cil_tmp36 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp41 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_INT32 tmp ;
  opj_flag_t *north ;
  OPJ_UINT32 ctxt1___0 ;
  OPJ_BYTE __cil_tmp51 ;
  OPJ_UINT32 l_c___3 ;
  OPJ_UINT32 __cil_tmp56 ;
  OPJ_UINT32 l_c___4 ;
  OPJ_UINT32 __cil_tmp61 ;
  OPJ_UINT32 lu___0 ;
  OPJ_UINT32 __cil_tmp63 ;
  OPJ_UINT32 ctxt2___0 ;
  OPJ_BYTE __cil_tmp65 ;
  OPJ_UINT32 spb___0 ;
  OPJ_BYTE __cil_tmp67 ;
  OPJ_UINT32 l_c___5 ;
  OPJ_UINT32 __cil_tmp72 ;
  OPJ_UINT32 l_c___6 ;
  OPJ_UINT32 __cil_tmp77 ;
  OPJ_INT32 tmp___0 ;
  OPJ_UINT32 ctxt1___1 ;
  OPJ_BYTE __cil_tmp82 ;
  OPJ_UINT32 l_c___7 ;
  OPJ_UINT32 __cil_tmp87 ;
  OPJ_UINT32 l_c___8 ;
  OPJ_UINT32 __cil_tmp92 ;
  OPJ_UINT32 lu___1 ;
  OPJ_UINT32 __cil_tmp94 ;
  OPJ_UINT32 ctxt2___1 ;
  OPJ_BYTE __cil_tmp96 ;
  OPJ_UINT32 spb___1 ;
  OPJ_BYTE __cil_tmp98 ;
  OPJ_UINT32 l_c___9 ;
  OPJ_UINT32 __cil_tmp103 ;
  OPJ_UINT32 l_c___10 ;
  OPJ_UINT32 __cil_tmp108 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 ctxt1___2 ;
  OPJ_BYTE __cil_tmp113 ;
  OPJ_UINT32 l_c___11 ;
  OPJ_UINT32 __cil_tmp118 ;
  OPJ_UINT32 l_c___12 ;
  OPJ_UINT32 __cil_tmp123 ;
  OPJ_UINT32 lu___2 ;
  OPJ_UINT32 __cil_tmp125 ;
  OPJ_UINT32 ctxt2___2 ;
  OPJ_BYTE __cil_tmp127 ;
  OPJ_UINT32 spb___2 ;
  OPJ_BYTE __cil_tmp129 ;
  OPJ_UINT32 l_c___13 ;
  OPJ_UINT32 __cil_tmp134 ;
  OPJ_UINT32 l_c___14 ;
  OPJ_UINT32 __cil_tmp139 ;
  OPJ_INT32 tmp___2 ;
  opj_flag_t *south___2 ;

  {
#line 669
  data = t1->data;
#line 669
  flagsp = t1->flags + 67;
#line 669
  l_w = (OPJ_UINT32 )64;
#line 669
  mqc = & t1->mqc;
#line 669
  curctx = mqc->curctx;
#line 669
  c = mqc->c;
#line 669
  a = mqc->a;
#line 669
  ct = mqc->ct;
#line 669
  one = 1 << bpno;
#line 669
  half = one >> 1;
#line 669
  oneplushalf = one | half;
#line 669
  k = (OPJ_UINT32 )0;
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;

#line 669
    if (! (k < 64U)) {
#line 669
      goto while_break;
    }
#line 669
    i = (OPJ_UINT32 )0;
    {
#line 669
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 669
      if (! (i < l_w)) {
#line 669
        goto while_break___0;
      }
#line 669
      flags = *flagsp;
#line 669
      if (flags != 0U) {
#line 669
        if ((flags & ((1U << 4) | (1U << 21))) == 0U) {
#line 669
          if ((flags & (((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8))) != 0U) {
            {
#line 669
            __cil_tmp20 = opj_t1_getctxno_zc(mqc, flags);
#line 669
            ctxt1 = (OPJ_UINT32 )__cil_tmp20;
#line 669
            curctx = & mqc->ctxs[ctxt1];
#line 669
            a -= (*curctx)->qeval;
            }
#line 669
            if (c >> 16 < (*curctx)->qeval) {
#line 669
              if (a < (*curctx)->qeval) {
#line 669
                a = (*curctx)->qeval;
#line 669
                v = (*curctx)->mps;
#line 669
                *curctx = (*curctx)->nmps;
              } else {
#line 669
                a = (*curctx)->qeval;
#line 669
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                *curctx = (*curctx)->nlps;
              }
              {
#line 669
              while (1) {
                while_continue___1: /* CIL Label */ ;

#line 669
                if (ct == 0U) {
#line 669
                  l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                  if ((int )*(mqc->bp) == 255) {
#line 669
                    if (l_c > 143U) {
#line 669
                      c += 65280U;
#line 669
                      ct = (OPJ_UINT32 )8;
#line 669
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c << 9;
#line 669
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 669
                    (mqc->bp) ++;
#line 669
                    c += l_c << 8;
#line 669
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 669
                a <<= 1;
#line 669
                c <<= 1;
#line 669
                __cil_tmp25 = ct;
#line 669
                ct --;
#line 669
                if (! (a < 32768U)) {
#line 669
                  goto while_break___1;
                }
              }
              while_break___21: /* CIL Label */ ;
              }
              while_break___1: ;
            } else {
#line 669
              c -= (*curctx)->qeval << 16;
#line 669
              if ((a & 32768U) == 0U) {
#line 669
                if (a < (*curctx)->qeval) {
#line 669
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                  *curctx = (*curctx)->nlps;
                } else {
#line 669
                  v = (*curctx)->mps;
#line 669
                  *curctx = (*curctx)->nmps;
                }
                {
#line 669
                while (1) {
                  while_continue___2: /* CIL Label */ ;

#line 669
                  if (ct == 0U) {
#line 669
                    l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                    if ((int )*(mqc->bp) == 255) {
#line 669
                      if (l_c___0 > 143U) {
#line 669
                        c += 65280U;
#line 669
                        ct = (OPJ_UINT32 )8;
#line 669
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___0 << 9;
#line 669
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c___0 << 8;
#line 669
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 669
                  a <<= 1;
#line 669
                  c <<= 1;
#line 669
                  __cil_tmp30 = ct;
#line 669
                  ct --;
#line 669
                  if (! (a < 32768U)) {
#line 669
                    goto while_break___2;
                  }
                }
                while_break___22: /* CIL Label */ ;
                }
                while_break___2: ;
              } else {
#line 669
                v = (*curctx)->mps;
              }
            }
#line 669
            if (v) {
              {
#line 669
              __cil_tmp32 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )0);
#line 669
              lu = __cil_tmp32;
#line 669
              __cil_tmp34 = opj_t1_getctxno_sc(lu);
#line 669
              ctxt2 = (OPJ_UINT32 )__cil_tmp34;
#line 669
              __cil_tmp36 = opj_t1_getspb(lu);
#line 669
              spb = (OPJ_UINT32 )__cil_tmp36;
#line 669
              curctx = & mqc->ctxs[ctxt2];
#line 669
              a -= (*curctx)->qeval;
              }
#line 669
              if (c >> 16 < (*curctx)->qeval) {
#line 669
                if (a < (*curctx)->qeval) {
#line 669
                  a = (*curctx)->qeval;
#line 669
                  v = (*curctx)->mps;
#line 669
                  *curctx = (*curctx)->nmps;
                } else {
#line 669
                  a = (*curctx)->qeval;
#line 669
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                  *curctx = (*curctx)->nlps;
                }
                {
#line 669
                while (1) {
                  while_continue___3: /* CIL Label */ ;

#line 669
                  if (ct == 0U) {
#line 669
                    l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                    if ((int )*(mqc->bp) == 255) {
#line 669
                      if (l_c___1 > 143U) {
#line 669
                        c += 65280U;
#line 669
                        ct = (OPJ_UINT32 )8;
#line 669
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___1 << 9;
#line 669
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c___1 << 8;
#line 669
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 669
                  a <<= 1;
#line 669
                  c <<= 1;
#line 669
                  __cil_tmp41 = ct;
#line 669
                  ct --;
#line 669
                  if (! (a < 32768U)) {
#line 669
                    goto while_break___3;
                  }
                }
                while_break___23: /* CIL Label */ ;
                }
                while_break___3: ;
              } else {
#line 669
                c -= (*curctx)->qeval << 16;
#line 669
                if ((a & 32768U) == 0U) {
#line 669
                  if (a < (*curctx)->qeval) {
#line 669
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                    *curctx = (*curctx)->nlps;
                  } else {
#line 669
                    v = (*curctx)->mps;
#line 669
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 669
                  while (1) {
                    while_continue___4: /* CIL Label */ ;

#line 669
                    if (ct == 0U) {
#line 669
                      l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                      if ((int )*(mqc->bp) == 255) {
#line 669
                        if (l_c___2 > 143U) {
#line 669
                          c += 65280U;
#line 669
                          ct = (OPJ_UINT32 )8;
#line 669
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 669
                          (mqc->bp) ++;
#line 669
                          c += l_c___2 << 9;
#line 669
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___2 << 8;
#line 669
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 669
                    a <<= 1;
#line 669
                    c <<= 1;
#line 669
                    __cil_tmp46 = ct;
#line 669
                    ct --;
#line 669
                    if (! (a < 32768U)) {
#line 669
                      goto while_break___4;
                    }
                  }
                  while_break___24: /* CIL Label */ ;
                  }
                  while_break___4: ;
                } else {
#line 669
                  v = (*curctx)->mps;
                }
              }
#line 669
              v ^= spb;
#line 669
              if (v) {
#line 669
                tmp = - oneplushalf;
              } else {
#line 669
                tmp = oneplushalf;
              }
#line 669
              *(data + 0U) = tmp;
#line 669
              *(flagsp + -1) |= 1U << 5;
#line 669
              flags |= (v << 19) | (1U << 4);
#line 669
              *(flagsp + 1) |= 1U << 3;
#line 669
              north = flagsp - 66;
#line 669
              *north |= (v << 31) | (1U << 16);
#line 669
              *(north + -1) |= 1U << 17;
#line 669
              *(north + 1) |= 1U << 15;
            }
#line 669
            flags |= 1U << 21;
          }
        }
#line 669
        if ((flags & (((1U << 4) | (1U << 21)) << 3U)) == 0U) {
#line 669
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 3U)) != 0U) {
            {
#line 669
            __cil_tmp51 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 669
            ctxt1___0 = (OPJ_UINT32 )__cil_tmp51;
#line 669
            curctx = & mqc->ctxs[ctxt1___0];
#line 669
            a -= (*curctx)->qeval;
            }
#line 669
            if (c >> 16 < (*curctx)->qeval) {
#line 669
              if (a < (*curctx)->qeval) {
#line 669
                a = (*curctx)->qeval;
#line 669
                v = (*curctx)->mps;
#line 669
                *curctx = (*curctx)->nmps;
              } else {
#line 669
                a = (*curctx)->qeval;
#line 669
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                *curctx = (*curctx)->nlps;
              }
              {
#line 669
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 669
                if (ct == 0U) {
#line 669
                  l_c___3 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                  if ((int )*(mqc->bp) == 255) {
#line 669
                    if (l_c___3 > 143U) {
#line 669
                      c += 65280U;
#line 669
                      ct = (OPJ_UINT32 )8;
#line 669
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c___3 << 9;
#line 669
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 669
                    (mqc->bp) ++;
#line 669
                    c += l_c___3 << 8;
#line 669
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 669
                a <<= 1;
#line 669
                c <<= 1;
#line 669
                __cil_tmp56 = ct;
#line 669
                ct --;
#line 669
                if (! (a < 32768U)) {
#line 669
                  goto while_break___5;
                }
              }
              while_break___25: /* CIL Label */ ;
              }
              while_break___5: ;
            } else {
#line 669
              c -= (*curctx)->qeval << 16;
#line 669
              if ((a & 32768U) == 0U) {
#line 669
                if (a < (*curctx)->qeval) {
#line 669
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                  *curctx = (*curctx)->nlps;
                } else {
#line 669
                  v = (*curctx)->mps;
#line 669
                  *curctx = (*curctx)->nmps;
                }
                {
#line 669
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 669
                  if (ct == 0U) {
#line 669
                    l_c___4 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                    if ((int )*(mqc->bp) == 255) {
#line 669
                      if (l_c___4 > 143U) {
#line 669
                        c += 65280U;
#line 669
                        ct = (OPJ_UINT32 )8;
#line 669
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___4 << 9;
#line 669
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c___4 << 8;
#line 669
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 669
                  a <<= 1;
#line 669
                  c <<= 1;
#line 669
                  __cil_tmp61 = ct;
#line 669
                  ct --;
#line 669
                  if (! (a < 32768U)) {
#line 669
                    goto while_break___6;
                  }
                }
                while_break___26: /* CIL Label */ ;
                }
                while_break___6: ;
              } else {
#line 669
                v = (*curctx)->mps;
              }
            }
#line 669
            if (v) {
              {
#line 669
              __cil_tmp63 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )1);
#line 669
              lu___0 = __cil_tmp63;
#line 669
              __cil_tmp65 = opj_t1_getctxno_sc(lu___0);
#line 669
              ctxt2___0 = (OPJ_UINT32 )__cil_tmp65;
#line 669
              __cil_tmp67 = opj_t1_getspb(lu___0);
#line 669
              spb___0 = (OPJ_UINT32 )__cil_tmp67;
#line 669
              curctx = & mqc->ctxs[ctxt2___0];
#line 669
              a -= (*curctx)->qeval;
              }
#line 669
              if (c >> 16 < (*curctx)->qeval) {
#line 669
                if (a < (*curctx)->qeval) {
#line 669
                  a = (*curctx)->qeval;
#line 669
                  v = (*curctx)->mps;
#line 669
                  *curctx = (*curctx)->nmps;
                } else {
#line 669
                  a = (*curctx)->qeval;
#line 669
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                  *curctx = (*curctx)->nlps;
                }
                {
#line 669
                while (1) {
                  while_continue___7: /* CIL Label */ ;

#line 669
                  if (ct == 0U) {
#line 669
                    l_c___5 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                    if ((int )*(mqc->bp) == 255) {
#line 669
                      if (l_c___5 > 143U) {
#line 669
                        c += 65280U;
#line 669
                        ct = (OPJ_UINT32 )8;
#line 669
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___5 << 9;
#line 669
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c___5 << 8;
#line 669
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 669
                  a <<= 1;
#line 669
                  c <<= 1;
#line 669
                  __cil_tmp72 = ct;
#line 669
                  ct --;
#line 669
                  if (! (a < 32768U)) {
#line 669
                    goto while_break___7;
                  }
                }
                while_break___27: /* CIL Label */ ;
                }
                while_break___7: ;
              } else {
#line 669
                c -= (*curctx)->qeval << 16;
#line 669
                if ((a & 32768U) == 0U) {
#line 669
                  if (a < (*curctx)->qeval) {
#line 669
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                    *curctx = (*curctx)->nlps;
                  } else {
#line 669
                    v = (*curctx)->mps;
#line 669
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 669
                  while (1) {
                    while_continue___8: /* CIL Label */ ;

#line 669
                    if (ct == 0U) {
#line 669
                      l_c___6 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                      if ((int )*(mqc->bp) == 255) {
#line 669
                        if (l_c___6 > 143U) {
#line 669
                          c += 65280U;
#line 669
                          ct = (OPJ_UINT32 )8;
#line 669
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 669
                          (mqc->bp) ++;
#line 669
                          c += l_c___6 << 9;
#line 669
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___6 << 8;
#line 669
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 669
                    a <<= 1;
#line 669
                    c <<= 1;
#line 669
                    __cil_tmp77 = ct;
#line 669
                    ct --;
#line 669
                    if (! (a < 32768U)) {
#line 669
                      goto while_break___8;
                    }
                  }
                  while_break___28: /* CIL Label */ ;
                  }
                  while_break___8: ;
                } else {
#line 669
                  v = (*curctx)->mps;
                }
              }
#line 669
              v ^= spb___0;
#line 669
              if (v) {
#line 669
                tmp___0 = - oneplushalf;
              } else {
#line 669
                tmp___0 = oneplushalf;
              }
#line 669
              *(data + l_w) = tmp___0;
#line 669
              *(flagsp + -1) |= (1U << 5) << 3U;
#line 669
              flags |= ((v << 19) | (1U << 4)) << 3U;
#line 669
              *(flagsp + 1) |= (1U << 3) << 3U;
            }
#line 669
            flags |= (1U << 21) << 3U;
          }
        }
#line 669
        if ((flags & (((1U << 4) | (1U << 21)) << 6U)) == 0U) {
#line 669
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 6U)) != 0U) {
            {
#line 669
            __cil_tmp82 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 669
            ctxt1___1 = (OPJ_UINT32 )__cil_tmp82;
#line 669
            curctx = & mqc->ctxs[ctxt1___1];
#line 669
            a -= (*curctx)->qeval;
            }
#line 669
            if (c >> 16 < (*curctx)->qeval) {
#line 669
              if (a < (*curctx)->qeval) {
#line 669
                a = (*curctx)->qeval;
#line 669
                v = (*curctx)->mps;
#line 669
                *curctx = (*curctx)->nmps;
              } else {
#line 669
                a = (*curctx)->qeval;
#line 669
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                *curctx = (*curctx)->nlps;
              }
              {
#line 669
              while (1) {
                while_continue___9: /* CIL Label */ ;

#line 669
                if (ct == 0U) {
#line 669
                  l_c___7 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                  if ((int )*(mqc->bp) == 255) {
#line 669
                    if (l_c___7 > 143U) {
#line 669
                      c += 65280U;
#line 669
                      ct = (OPJ_UINT32 )8;
#line 669
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c___7 << 9;
#line 669
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 669
                    (mqc->bp) ++;
#line 669
                    c += l_c___7 << 8;
#line 669
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 669
                a <<= 1;
#line 669
                c <<= 1;
#line 669
                __cil_tmp87 = ct;
#line 669
                ct --;
#line 669
                if (! (a < 32768U)) {
#line 669
                  goto while_break___9;
                }
              }
              while_break___29: /* CIL Label */ ;
              }
              while_break___9: ;
            } else {
#line 669
              c -= (*curctx)->qeval << 16;
#line 669
              if ((a & 32768U) == 0U) {
#line 669
                if (a < (*curctx)->qeval) {
#line 669
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                  *curctx = (*curctx)->nlps;
                } else {
#line 669
                  v = (*curctx)->mps;
#line 669
                  *curctx = (*curctx)->nmps;
                }
                {
#line 669
                while (1) {
                  while_continue___10: /* CIL Label */ ;

#line 669
                  if (ct == 0U) {
#line 669
                    l_c___8 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                    if ((int )*(mqc->bp) == 255) {
#line 669
                      if (l_c___8 > 143U) {
#line 669
                        c += 65280U;
#line 669
                        ct = (OPJ_UINT32 )8;
#line 669
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___8 << 9;
#line 669
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c___8 << 8;
#line 669
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 669
                  a <<= 1;
#line 669
                  c <<= 1;
#line 669
                  __cil_tmp92 = ct;
#line 669
                  ct --;
#line 669
                  if (! (a < 32768U)) {
#line 669
                    goto while_break___10;
                  }
                }
                while_break___30: /* CIL Label */ ;
                }
                while_break___10: ;
              } else {
#line 669
                v = (*curctx)->mps;
              }
            }
#line 669
            if (v) {
              {
#line 669
              __cil_tmp94 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )2);
#line 669
              lu___1 = __cil_tmp94;
#line 669
              __cil_tmp96 = opj_t1_getctxno_sc(lu___1);
#line 669
              ctxt2___1 = (OPJ_UINT32 )__cil_tmp96;
#line 669
              __cil_tmp98 = opj_t1_getspb(lu___1);
#line 669
              spb___1 = (OPJ_UINT32 )__cil_tmp98;
#line 669
              curctx = & mqc->ctxs[ctxt2___1];
#line 669
              a -= (*curctx)->qeval;
              }
#line 669
              if (c >> 16 < (*curctx)->qeval) {
#line 669
                if (a < (*curctx)->qeval) {
#line 669
                  a = (*curctx)->qeval;
#line 669
                  v = (*curctx)->mps;
#line 669
                  *curctx = (*curctx)->nmps;
                } else {
#line 669
                  a = (*curctx)->qeval;
#line 669
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                  *curctx = (*curctx)->nlps;
                }
                {
#line 669
                while (1) {
                  while_continue___11: /* CIL Label */ ;

#line 669
                  if (ct == 0U) {
#line 669
                    l_c___9 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                    if ((int )*(mqc->bp) == 255) {
#line 669
                      if (l_c___9 > 143U) {
#line 669
                        c += 65280U;
#line 669
                        ct = (OPJ_UINT32 )8;
#line 669
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___9 << 9;
#line 669
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c___9 << 8;
#line 669
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 669
                  a <<= 1;
#line 669
                  c <<= 1;
#line 669
                  __cil_tmp103 = ct;
#line 669
                  ct --;
#line 669
                  if (! (a < 32768U)) {
#line 669
                    goto while_break___11;
                  }
                }
                while_break___31: /* CIL Label */ ;
                }
                while_break___11: ;
              } else {
#line 669
                c -= (*curctx)->qeval << 16;
#line 669
                if ((a & 32768U) == 0U) {
#line 669
                  if (a < (*curctx)->qeval) {
#line 669
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                    *curctx = (*curctx)->nlps;
                  } else {
#line 669
                    v = (*curctx)->mps;
#line 669
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 669
                  while (1) {
                    while_continue___12: /* CIL Label */ ;

#line 669
                    if (ct == 0U) {
#line 669
                      l_c___10 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                      if ((int )*(mqc->bp) == 255) {
#line 669
                        if (l_c___10 > 143U) {
#line 669
                          c += 65280U;
#line 669
                          ct = (OPJ_UINT32 )8;
#line 669
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 669
                          (mqc->bp) ++;
#line 669
                          c += l_c___10 << 9;
#line 669
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___10 << 8;
#line 669
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 669
                    a <<= 1;
#line 669
                    c <<= 1;
#line 669
                    __cil_tmp108 = ct;
#line 669
                    ct --;
#line 669
                    if (! (a < 32768U)) {
#line 669
                      goto while_break___12;
                    }
                  }
                  while_break___32: /* CIL Label */ ;
                  }
                  while_break___12: ;
                } else {
#line 669
                  v = (*curctx)->mps;
                }
              }
#line 669
              v ^= spb___1;
#line 669
              if (v) {
#line 669
                tmp___1 = - oneplushalf;
              } else {
#line 669
                tmp___1 = oneplushalf;
              }
#line 669
              *(data + 2U * l_w) = tmp___1;
#line 669
              *(flagsp + -1) |= (1U << 5) << 6U;
#line 669
              flags |= ((v << 19) | (1U << 4)) << 6U;
#line 669
              *(flagsp + 1) |= (1U << 3) << 6U;
            }
#line 669
            flags |= (1U << 21) << 6U;
          }
        }
#line 669
        if ((flags & (((1U << 4) | (1U << 21)) << 9U)) == 0U) {
#line 669
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 9U)) != 0U) {
            {
#line 669
            __cil_tmp113 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 669
            ctxt1___2 = (OPJ_UINT32 )__cil_tmp113;
#line 669
            curctx = & mqc->ctxs[ctxt1___2];
#line 669
            a -= (*curctx)->qeval;
            }
#line 669
            if (c >> 16 < (*curctx)->qeval) {
#line 669
              if (a < (*curctx)->qeval) {
#line 669
                a = (*curctx)->qeval;
#line 669
                v = (*curctx)->mps;
#line 669
                *curctx = (*curctx)->nmps;
              } else {
#line 669
                a = (*curctx)->qeval;
#line 669
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                *curctx = (*curctx)->nlps;
              }
              {
#line 669
              while (1) {
                while_continue___13: /* CIL Label */ ;

#line 669
                if (ct == 0U) {
#line 669
                  l_c___11 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                  if ((int )*(mqc->bp) == 255) {
#line 669
                    if (l_c___11 > 143U) {
#line 669
                      c += 65280U;
#line 669
                      ct = (OPJ_UINT32 )8;
#line 669
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c___11 << 9;
#line 669
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 669
                    (mqc->bp) ++;
#line 669
                    c += l_c___11 << 8;
#line 669
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 669
                a <<= 1;
#line 669
                c <<= 1;
#line 669
                __cil_tmp118 = ct;
#line 669
                ct --;
#line 669
                if (! (a < 32768U)) {
#line 669
                  goto while_break___13;
                }
              }
              while_break___33: /* CIL Label */ ;
              }
              while_break___13: ;
            } else {
#line 669
              c -= (*curctx)->qeval << 16;
#line 669
              if ((a & 32768U) == 0U) {
#line 669
                if (a < (*curctx)->qeval) {
#line 669
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                  *curctx = (*curctx)->nlps;
                } else {
#line 669
                  v = (*curctx)->mps;
#line 669
                  *curctx = (*curctx)->nmps;
                }
                {
#line 669
                while (1) {
                  while_continue___14: /* CIL Label */ ;

#line 669
                  if (ct == 0U) {
#line 669
                    l_c___12 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                    if ((int )*(mqc->bp) == 255) {
#line 669
                      if (l_c___12 > 143U) {
#line 669
                        c += 65280U;
#line 669
                        ct = (OPJ_UINT32 )8;
#line 669
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___12 << 9;
#line 669
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c___12 << 8;
#line 669
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 669
                  a <<= 1;
#line 669
                  c <<= 1;
#line 669
                  __cil_tmp123 = ct;
#line 669
                  ct --;
#line 669
                  if (! (a < 32768U)) {
#line 669
                    goto while_break___14;
                  }
                }
                while_break___34: /* CIL Label */ ;
                }
                while_break___14: ;
              } else {
#line 669
                v = (*curctx)->mps;
              }
            }
#line 669
            if (v) {
              {
#line 669
              __cil_tmp125 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                              *(flagsp + 1), (OPJ_UINT32 )3);
#line 669
              lu___2 = __cil_tmp125;
#line 669
              __cil_tmp127 = opj_t1_getctxno_sc(lu___2);
#line 669
              ctxt2___2 = (OPJ_UINT32 )__cil_tmp127;
#line 669
              __cil_tmp129 = opj_t1_getspb(lu___2);
#line 669
              spb___2 = (OPJ_UINT32 )__cil_tmp129;
#line 669
              curctx = & mqc->ctxs[ctxt2___2];
#line 669
              a -= (*curctx)->qeval;
              }
#line 669
              if (c >> 16 < (*curctx)->qeval) {
#line 669
                if (a < (*curctx)->qeval) {
#line 669
                  a = (*curctx)->qeval;
#line 669
                  v = (*curctx)->mps;
#line 669
                  *curctx = (*curctx)->nmps;
                } else {
#line 669
                  a = (*curctx)->qeval;
#line 669
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                  *curctx = (*curctx)->nlps;
                }
                {
#line 669
                while (1) {
                  while_continue___15: /* CIL Label */ ;

#line 669
                  if (ct == 0U) {
#line 669
                    l_c___13 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                    if ((int )*(mqc->bp) == 255) {
#line 669
                      if (l_c___13 > 143U) {
#line 669
                        c += 65280U;
#line 669
                        ct = (OPJ_UINT32 )8;
#line 669
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___13 << 9;
#line 669
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 669
                      (mqc->bp) ++;
#line 669
                      c += l_c___13 << 8;
#line 669
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 669
                  a <<= 1;
#line 669
                  c <<= 1;
#line 669
                  __cil_tmp134 = ct;
#line 669
                  ct --;
#line 669
                  if (! (a < 32768U)) {
#line 669
                    goto while_break___15;
                  }
                }
                while_break___35: /* CIL Label */ ;
                }
                while_break___15: ;
              } else {
#line 669
                c -= (*curctx)->qeval << 16;
#line 669
                if ((a & 32768U) == 0U) {
#line 669
                  if (a < (*curctx)->qeval) {
#line 669
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 669
                    *curctx = (*curctx)->nlps;
                  } else {
#line 669
                    v = (*curctx)->mps;
#line 669
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 669
                  while (1) {
                    while_continue___16: /* CIL Label */ ;

#line 669
                    if (ct == 0U) {
#line 669
                      l_c___14 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 669
                      if ((int )*(mqc->bp) == 255) {
#line 669
                        if (l_c___14 > 143U) {
#line 669
                          c += 65280U;
#line 669
                          ct = (OPJ_UINT32 )8;
#line 669
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 669
                          (mqc->bp) ++;
#line 669
                          c += l_c___14 << 9;
#line 669
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 669
                        (mqc->bp) ++;
#line 669
                        c += l_c___14 << 8;
#line 669
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 669
                    a <<= 1;
#line 669
                    c <<= 1;
#line 669
                    __cil_tmp139 = ct;
#line 669
                    ct --;
#line 669
                    if (! (a < 32768U)) {
#line 669
                      goto while_break___16;
                    }
                  }
                  while_break___36: /* CIL Label */ ;
                  }
                  while_break___16: ;
                } else {
#line 669
                  v = (*curctx)->mps;
                }
              }
#line 669
              v ^= spb___2;
#line 669
              if (v) {
#line 669
                tmp___2 = - oneplushalf;
              } else {
#line 669
                tmp___2 = oneplushalf;
              }
#line 669
              *(data + 3U * l_w) = tmp___2;
#line 669
              *(flagsp + -1) |= (1U << 5) << 9U;
#line 669
              flags |= ((v << 19) | (1U << 4)) << 9U;
#line 669
              *(flagsp + 1) |= (1U << 3) << 9U;
#line 669
              south___2 = flagsp + 66;
#line 669
              *south___2 |= (v << 18) | (1U << 1);
#line 669
              *(south___2 + -1) |= 1U << 2;
#line 669
              *(south___2 + 1) |= 1U;
            }
#line 669
            flags |= (1U << 21) << 9U;
          }
        }
#line 669
        *flagsp = flags;
      }
#line 669
      flagsp ++;
#line 669
      data ++;
#line 669
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___0: 
#line 669
    flagsp += 2;
#line 669
    data += 3U * l_w;
#line 669
    k += 4U;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break: 
#line 669
  mqc->curctx = curctx;
#line 669
  mqc->c = c;
#line 669
  mqc->a = a;
#line 669
  mqc->ct = ct;
#line 669
  if (k < 64U) {
#line 669
    i = (OPJ_UINT32 )0;
    {
#line 669
    while (1) {
      while_continue___17: /* CIL Label */ ;

#line 669
      if (! (i < l_w)) {
#line 669
        goto while_break___17;
      }
#line 669
      j = (OPJ_UINT32 )0;
      {
#line 669
      while (1) {
        while_continue___18: /* CIL Label */ ;

#line 669
        if (! (j < 64U - k)) {
#line 669
          goto while_break___18;
        }
        {
#line 669
        opj_t1_dec_sigpass_step_mqc(t1, flagsp, data + j * l_w, oneplushalf, j, (OPJ_UINT32 )66,
                                    (OPJ_UINT32 )0);
#line 669
        j ++;
        }
      }
      while_break___38: /* CIL Label */ ;
      }
      while_break___18: 
#line 669
      flagsp ++;
#line 669
      data ++;
#line 669
      i ++;
    }
    while_break___37: /* CIL Label */ ;
    }
    while_break___17: ;
  }
#line 675
  return;
}
}
#line 672 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_sigpass_mqc_64x64_vsc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  register OPJ_INT32 *data ;
  register opj_flag_t *flagsp ;
  OPJ_UINT32 l_w ;
  opj_mqc_t *mqc ;
  register opj_mqc_state_t **curctx ;
  register OPJ_UINT32 c ;
  register OPJ_UINT32 a ;
  register OPJ_UINT32 ct ;
  register OPJ_UINT32 v ;
  opj_flag_t flags ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp20 ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 lu ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 ctxt2 ;
  OPJ_BYTE __cil_tmp34 ;
  OPJ_UINT32 spb ;
  OPJ_BYTE __cil_tmp36 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp41 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_INT32 tmp ;
  OPJ_UINT32 ctxt1___0 ;
  OPJ_BYTE __cil_tmp51 ;
  OPJ_UINT32 l_c___3 ;
  OPJ_UINT32 __cil_tmp56 ;
  OPJ_UINT32 l_c___4 ;
  OPJ_UINT32 __cil_tmp61 ;
  OPJ_UINT32 lu___0 ;
  OPJ_UINT32 __cil_tmp63 ;
  OPJ_UINT32 ctxt2___0 ;
  OPJ_BYTE __cil_tmp65 ;
  OPJ_UINT32 spb___0 ;
  OPJ_BYTE __cil_tmp67 ;
  OPJ_UINT32 l_c___5 ;
  OPJ_UINT32 __cil_tmp72 ;
  OPJ_UINT32 l_c___6 ;
  OPJ_UINT32 __cil_tmp77 ;
  OPJ_INT32 tmp___0 ;
  OPJ_UINT32 ctxt1___1 ;
  OPJ_BYTE __cil_tmp82 ;
  OPJ_UINT32 l_c___7 ;
  OPJ_UINT32 __cil_tmp87 ;
  OPJ_UINT32 l_c___8 ;
  OPJ_UINT32 __cil_tmp92 ;
  OPJ_UINT32 lu___1 ;
  OPJ_UINT32 __cil_tmp94 ;
  OPJ_UINT32 ctxt2___1 ;
  OPJ_BYTE __cil_tmp96 ;
  OPJ_UINT32 spb___1 ;
  OPJ_BYTE __cil_tmp98 ;
  OPJ_UINT32 l_c___9 ;
  OPJ_UINT32 __cil_tmp103 ;
  OPJ_UINT32 l_c___10 ;
  OPJ_UINT32 __cil_tmp108 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 ctxt1___2 ;
  OPJ_BYTE __cil_tmp113 ;
  OPJ_UINT32 l_c___11 ;
  OPJ_UINT32 __cil_tmp118 ;
  OPJ_UINT32 l_c___12 ;
  OPJ_UINT32 __cil_tmp123 ;
  OPJ_UINT32 lu___2 ;
  OPJ_UINT32 __cil_tmp125 ;
  OPJ_UINT32 ctxt2___2 ;
  OPJ_BYTE __cil_tmp127 ;
  OPJ_UINT32 spb___2 ;
  OPJ_BYTE __cil_tmp129 ;
  OPJ_UINT32 l_c___13 ;
  OPJ_UINT32 __cil_tmp134 ;
  OPJ_UINT32 l_c___14 ;
  OPJ_UINT32 __cil_tmp139 ;
  OPJ_INT32 tmp___2 ;
  opj_flag_t *south___2 ;

  {
#line 676
  data = t1->data;
#line 676
  flagsp = t1->flags + 67;
#line 676
  l_w = (OPJ_UINT32 )64;
#line 676
  mqc = & t1->mqc;
#line 676
  curctx = mqc->curctx;
#line 676
  c = mqc->c;
#line 676
  a = mqc->a;
#line 676
  ct = mqc->ct;
#line 676
  one = 1 << bpno;
#line 676
  half = one >> 1;
#line 676
  oneplushalf = one | half;
#line 676
  k = (OPJ_UINT32 )0;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;

#line 676
    if (! (k < 64U)) {
#line 676
      goto while_break;
    }
#line 676
    i = (OPJ_UINT32 )0;
    {
#line 676
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 676
      if (! (i < l_w)) {
#line 676
        goto while_break___0;
      }
#line 676
      flags = *flagsp;
#line 676
      if (flags != 0U) {
#line 676
        if ((flags & ((1U << 4) | (1U << 21))) == 0U) {
#line 676
          if ((flags & (((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8))) != 0U) {
            {
#line 676
            __cil_tmp20 = opj_t1_getctxno_zc(mqc, flags);
#line 676
            ctxt1 = (OPJ_UINT32 )__cil_tmp20;
#line 676
            curctx = & mqc->ctxs[ctxt1];
#line 676
            a -= (*curctx)->qeval;
            }
#line 676
            if (c >> 16 < (*curctx)->qeval) {
#line 676
              if (a < (*curctx)->qeval) {
#line 676
                a = (*curctx)->qeval;
#line 676
                v = (*curctx)->mps;
#line 676
                *curctx = (*curctx)->nmps;
              } else {
#line 676
                a = (*curctx)->qeval;
#line 676
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                *curctx = (*curctx)->nlps;
              }
              {
#line 676
              while (1) {
                while_continue___1: /* CIL Label */ ;

#line 676
                if (ct == 0U) {
#line 676
                  l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                  if ((int )*(mqc->bp) == 255) {
#line 676
                    if (l_c > 143U) {
#line 676
                      c += 65280U;
#line 676
                      ct = (OPJ_UINT32 )8;
#line 676
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c << 9;
#line 676
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 676
                    (mqc->bp) ++;
#line 676
                    c += l_c << 8;
#line 676
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 676
                a <<= 1;
#line 676
                c <<= 1;
#line 676
                __cil_tmp25 = ct;
#line 676
                ct --;
#line 676
                if (! (a < 32768U)) {
#line 676
                  goto while_break___1;
                }
              }
              while_break___21: /* CIL Label */ ;
              }
              while_break___1: ;
            } else {
#line 676
              c -= (*curctx)->qeval << 16;
#line 676
              if ((a & 32768U) == 0U) {
#line 676
                if (a < (*curctx)->qeval) {
#line 676
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                  *curctx = (*curctx)->nlps;
                } else {
#line 676
                  v = (*curctx)->mps;
#line 676
                  *curctx = (*curctx)->nmps;
                }
                {
#line 676
                while (1) {
                  while_continue___2: /* CIL Label */ ;

#line 676
                  if (ct == 0U) {
#line 676
                    l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                    if ((int )*(mqc->bp) == 255) {
#line 676
                      if (l_c___0 > 143U) {
#line 676
                        c += 65280U;
#line 676
                        ct = (OPJ_UINT32 )8;
#line 676
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___0 << 9;
#line 676
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c___0 << 8;
#line 676
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 676
                  a <<= 1;
#line 676
                  c <<= 1;
#line 676
                  __cil_tmp30 = ct;
#line 676
                  ct --;
#line 676
                  if (! (a < 32768U)) {
#line 676
                    goto while_break___2;
                  }
                }
                while_break___22: /* CIL Label */ ;
                }
                while_break___2: ;
              } else {
#line 676
                v = (*curctx)->mps;
              }
            }
#line 676
            if (v) {
              {
#line 676
              __cil_tmp32 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )0);
#line 676
              lu = __cil_tmp32;
#line 676
              __cil_tmp34 = opj_t1_getctxno_sc(lu);
#line 676
              ctxt2 = (OPJ_UINT32 )__cil_tmp34;
#line 676
              __cil_tmp36 = opj_t1_getspb(lu);
#line 676
              spb = (OPJ_UINT32 )__cil_tmp36;
#line 676
              curctx = & mqc->ctxs[ctxt2];
#line 676
              a -= (*curctx)->qeval;
              }
#line 676
              if (c >> 16 < (*curctx)->qeval) {
#line 676
                if (a < (*curctx)->qeval) {
#line 676
                  a = (*curctx)->qeval;
#line 676
                  v = (*curctx)->mps;
#line 676
                  *curctx = (*curctx)->nmps;
                } else {
#line 676
                  a = (*curctx)->qeval;
#line 676
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                  *curctx = (*curctx)->nlps;
                }
                {
#line 676
                while (1) {
                  while_continue___3: /* CIL Label */ ;

#line 676
                  if (ct == 0U) {
#line 676
                    l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                    if ((int )*(mqc->bp) == 255) {
#line 676
                      if (l_c___1 > 143U) {
#line 676
                        c += 65280U;
#line 676
                        ct = (OPJ_UINT32 )8;
#line 676
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___1 << 9;
#line 676
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c___1 << 8;
#line 676
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 676
                  a <<= 1;
#line 676
                  c <<= 1;
#line 676
                  __cil_tmp41 = ct;
#line 676
                  ct --;
#line 676
                  if (! (a < 32768U)) {
#line 676
                    goto while_break___3;
                  }
                }
                while_break___23: /* CIL Label */ ;
                }
                while_break___3: ;
              } else {
#line 676
                c -= (*curctx)->qeval << 16;
#line 676
                if ((a & 32768U) == 0U) {
#line 676
                  if (a < (*curctx)->qeval) {
#line 676
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                    *curctx = (*curctx)->nlps;
                  } else {
#line 676
                    v = (*curctx)->mps;
#line 676
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 676
                  while (1) {
                    while_continue___4: /* CIL Label */ ;

#line 676
                    if (ct == 0U) {
#line 676
                      l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                      if ((int )*(mqc->bp) == 255) {
#line 676
                        if (l_c___2 > 143U) {
#line 676
                          c += 65280U;
#line 676
                          ct = (OPJ_UINT32 )8;
#line 676
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 676
                          (mqc->bp) ++;
#line 676
                          c += l_c___2 << 9;
#line 676
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___2 << 8;
#line 676
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 676
                    a <<= 1;
#line 676
                    c <<= 1;
#line 676
                    __cil_tmp46 = ct;
#line 676
                    ct --;
#line 676
                    if (! (a < 32768U)) {
#line 676
                      goto while_break___4;
                    }
                  }
                  while_break___24: /* CIL Label */ ;
                  }
                  while_break___4: ;
                } else {
#line 676
                  v = (*curctx)->mps;
                }
              }
#line 676
              v ^= spb;
#line 676
              if (v) {
#line 676
                tmp = - oneplushalf;
              } else {
#line 676
                tmp = oneplushalf;
              }
#line 676
              *(data + 0U) = tmp;
#line 676
              *(flagsp + -1) |= 1U << 5;
#line 676
              flags |= (v << 19) | (1U << 4);
#line 676
              *(flagsp + 1) |= 1U << 3;
            }
#line 676
            flags |= 1U << 21;
          }
        }
#line 676
        if ((flags & (((1U << 4) | (1U << 21)) << 3U)) == 0U) {
#line 676
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 3U)) != 0U) {
            {
#line 676
            __cil_tmp51 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 676
            ctxt1___0 = (OPJ_UINT32 )__cil_tmp51;
#line 676
            curctx = & mqc->ctxs[ctxt1___0];
#line 676
            a -= (*curctx)->qeval;
            }
#line 676
            if (c >> 16 < (*curctx)->qeval) {
#line 676
              if (a < (*curctx)->qeval) {
#line 676
                a = (*curctx)->qeval;
#line 676
                v = (*curctx)->mps;
#line 676
                *curctx = (*curctx)->nmps;
              } else {
#line 676
                a = (*curctx)->qeval;
#line 676
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                *curctx = (*curctx)->nlps;
              }
              {
#line 676
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 676
                if (ct == 0U) {
#line 676
                  l_c___3 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                  if ((int )*(mqc->bp) == 255) {
#line 676
                    if (l_c___3 > 143U) {
#line 676
                      c += 65280U;
#line 676
                      ct = (OPJ_UINT32 )8;
#line 676
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c___3 << 9;
#line 676
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 676
                    (mqc->bp) ++;
#line 676
                    c += l_c___3 << 8;
#line 676
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 676
                a <<= 1;
#line 676
                c <<= 1;
#line 676
                __cil_tmp56 = ct;
#line 676
                ct --;
#line 676
                if (! (a < 32768U)) {
#line 676
                  goto while_break___5;
                }
              }
              while_break___25: /* CIL Label */ ;
              }
              while_break___5: ;
            } else {
#line 676
              c -= (*curctx)->qeval << 16;
#line 676
              if ((a & 32768U) == 0U) {
#line 676
                if (a < (*curctx)->qeval) {
#line 676
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                  *curctx = (*curctx)->nlps;
                } else {
#line 676
                  v = (*curctx)->mps;
#line 676
                  *curctx = (*curctx)->nmps;
                }
                {
#line 676
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 676
                  if (ct == 0U) {
#line 676
                    l_c___4 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                    if ((int )*(mqc->bp) == 255) {
#line 676
                      if (l_c___4 > 143U) {
#line 676
                        c += 65280U;
#line 676
                        ct = (OPJ_UINT32 )8;
#line 676
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___4 << 9;
#line 676
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c___4 << 8;
#line 676
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 676
                  a <<= 1;
#line 676
                  c <<= 1;
#line 676
                  __cil_tmp61 = ct;
#line 676
                  ct --;
#line 676
                  if (! (a < 32768U)) {
#line 676
                    goto while_break___6;
                  }
                }
                while_break___26: /* CIL Label */ ;
                }
                while_break___6: ;
              } else {
#line 676
                v = (*curctx)->mps;
              }
            }
#line 676
            if (v) {
              {
#line 676
              __cil_tmp63 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )1);
#line 676
              lu___0 = __cil_tmp63;
#line 676
              __cil_tmp65 = opj_t1_getctxno_sc(lu___0);
#line 676
              ctxt2___0 = (OPJ_UINT32 )__cil_tmp65;
#line 676
              __cil_tmp67 = opj_t1_getspb(lu___0);
#line 676
              spb___0 = (OPJ_UINT32 )__cil_tmp67;
#line 676
              curctx = & mqc->ctxs[ctxt2___0];
#line 676
              a -= (*curctx)->qeval;
              }
#line 676
              if (c >> 16 < (*curctx)->qeval) {
#line 676
                if (a < (*curctx)->qeval) {
#line 676
                  a = (*curctx)->qeval;
#line 676
                  v = (*curctx)->mps;
#line 676
                  *curctx = (*curctx)->nmps;
                } else {
#line 676
                  a = (*curctx)->qeval;
#line 676
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                  *curctx = (*curctx)->nlps;
                }
                {
#line 676
                while (1) {
                  while_continue___7: /* CIL Label */ ;

#line 676
                  if (ct == 0U) {
#line 676
                    l_c___5 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                    if ((int )*(mqc->bp) == 255) {
#line 676
                      if (l_c___5 > 143U) {
#line 676
                        c += 65280U;
#line 676
                        ct = (OPJ_UINT32 )8;
#line 676
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___5 << 9;
#line 676
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c___5 << 8;
#line 676
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 676
                  a <<= 1;
#line 676
                  c <<= 1;
#line 676
                  __cil_tmp72 = ct;
#line 676
                  ct --;
#line 676
                  if (! (a < 32768U)) {
#line 676
                    goto while_break___7;
                  }
                }
                while_break___27: /* CIL Label */ ;
                }
                while_break___7: ;
              } else {
#line 676
                c -= (*curctx)->qeval << 16;
#line 676
                if ((a & 32768U) == 0U) {
#line 676
                  if (a < (*curctx)->qeval) {
#line 676
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                    *curctx = (*curctx)->nlps;
                  } else {
#line 676
                    v = (*curctx)->mps;
#line 676
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 676
                  while (1) {
                    while_continue___8: /* CIL Label */ ;

#line 676
                    if (ct == 0U) {
#line 676
                      l_c___6 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                      if ((int )*(mqc->bp) == 255) {
#line 676
                        if (l_c___6 > 143U) {
#line 676
                          c += 65280U;
#line 676
                          ct = (OPJ_UINT32 )8;
#line 676
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 676
                          (mqc->bp) ++;
#line 676
                          c += l_c___6 << 9;
#line 676
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___6 << 8;
#line 676
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 676
                    a <<= 1;
#line 676
                    c <<= 1;
#line 676
                    __cil_tmp77 = ct;
#line 676
                    ct --;
#line 676
                    if (! (a < 32768U)) {
#line 676
                      goto while_break___8;
                    }
                  }
                  while_break___28: /* CIL Label */ ;
                  }
                  while_break___8: ;
                } else {
#line 676
                  v = (*curctx)->mps;
                }
              }
#line 676
              v ^= spb___0;
#line 676
              if (v) {
#line 676
                tmp___0 = - oneplushalf;
              } else {
#line 676
                tmp___0 = oneplushalf;
              }
#line 676
              *(data + l_w) = tmp___0;
#line 676
              *(flagsp + -1) |= (1U << 5) << 3U;
#line 676
              flags |= ((v << 19) | (1U << 4)) << 3U;
#line 676
              *(flagsp + 1) |= (1U << 3) << 3U;
            }
#line 676
            flags |= (1U << 21) << 3U;
          }
        }
#line 676
        if ((flags & (((1U << 4) | (1U << 21)) << 6U)) == 0U) {
#line 676
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 6U)) != 0U) {
            {
#line 676
            __cil_tmp82 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 676
            ctxt1___1 = (OPJ_UINT32 )__cil_tmp82;
#line 676
            curctx = & mqc->ctxs[ctxt1___1];
#line 676
            a -= (*curctx)->qeval;
            }
#line 676
            if (c >> 16 < (*curctx)->qeval) {
#line 676
              if (a < (*curctx)->qeval) {
#line 676
                a = (*curctx)->qeval;
#line 676
                v = (*curctx)->mps;
#line 676
                *curctx = (*curctx)->nmps;
              } else {
#line 676
                a = (*curctx)->qeval;
#line 676
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                *curctx = (*curctx)->nlps;
              }
              {
#line 676
              while (1) {
                while_continue___9: /* CIL Label */ ;

#line 676
                if (ct == 0U) {
#line 676
                  l_c___7 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                  if ((int )*(mqc->bp) == 255) {
#line 676
                    if (l_c___7 > 143U) {
#line 676
                      c += 65280U;
#line 676
                      ct = (OPJ_UINT32 )8;
#line 676
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c___7 << 9;
#line 676
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 676
                    (mqc->bp) ++;
#line 676
                    c += l_c___7 << 8;
#line 676
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 676
                a <<= 1;
#line 676
                c <<= 1;
#line 676
                __cil_tmp87 = ct;
#line 676
                ct --;
#line 676
                if (! (a < 32768U)) {
#line 676
                  goto while_break___9;
                }
              }
              while_break___29: /* CIL Label */ ;
              }
              while_break___9: ;
            } else {
#line 676
              c -= (*curctx)->qeval << 16;
#line 676
              if ((a & 32768U) == 0U) {
#line 676
                if (a < (*curctx)->qeval) {
#line 676
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                  *curctx = (*curctx)->nlps;
                } else {
#line 676
                  v = (*curctx)->mps;
#line 676
                  *curctx = (*curctx)->nmps;
                }
                {
#line 676
                while (1) {
                  while_continue___10: /* CIL Label */ ;

#line 676
                  if (ct == 0U) {
#line 676
                    l_c___8 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                    if ((int )*(mqc->bp) == 255) {
#line 676
                      if (l_c___8 > 143U) {
#line 676
                        c += 65280U;
#line 676
                        ct = (OPJ_UINT32 )8;
#line 676
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___8 << 9;
#line 676
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c___8 << 8;
#line 676
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 676
                  a <<= 1;
#line 676
                  c <<= 1;
#line 676
                  __cil_tmp92 = ct;
#line 676
                  ct --;
#line 676
                  if (! (a < 32768U)) {
#line 676
                    goto while_break___10;
                  }
                }
                while_break___30: /* CIL Label */ ;
                }
                while_break___10: ;
              } else {
#line 676
                v = (*curctx)->mps;
              }
            }
#line 676
            if (v) {
              {
#line 676
              __cil_tmp94 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )2);
#line 676
              lu___1 = __cil_tmp94;
#line 676
              __cil_tmp96 = opj_t1_getctxno_sc(lu___1);
#line 676
              ctxt2___1 = (OPJ_UINT32 )__cil_tmp96;
#line 676
              __cil_tmp98 = opj_t1_getspb(lu___1);
#line 676
              spb___1 = (OPJ_UINT32 )__cil_tmp98;
#line 676
              curctx = & mqc->ctxs[ctxt2___1];
#line 676
              a -= (*curctx)->qeval;
              }
#line 676
              if (c >> 16 < (*curctx)->qeval) {
#line 676
                if (a < (*curctx)->qeval) {
#line 676
                  a = (*curctx)->qeval;
#line 676
                  v = (*curctx)->mps;
#line 676
                  *curctx = (*curctx)->nmps;
                } else {
#line 676
                  a = (*curctx)->qeval;
#line 676
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                  *curctx = (*curctx)->nlps;
                }
                {
#line 676
                while (1) {
                  while_continue___11: /* CIL Label */ ;

#line 676
                  if (ct == 0U) {
#line 676
                    l_c___9 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                    if ((int )*(mqc->bp) == 255) {
#line 676
                      if (l_c___9 > 143U) {
#line 676
                        c += 65280U;
#line 676
                        ct = (OPJ_UINT32 )8;
#line 676
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___9 << 9;
#line 676
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c___9 << 8;
#line 676
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 676
                  a <<= 1;
#line 676
                  c <<= 1;
#line 676
                  __cil_tmp103 = ct;
#line 676
                  ct --;
#line 676
                  if (! (a < 32768U)) {
#line 676
                    goto while_break___11;
                  }
                }
                while_break___31: /* CIL Label */ ;
                }
                while_break___11: ;
              } else {
#line 676
                c -= (*curctx)->qeval << 16;
#line 676
                if ((a & 32768U) == 0U) {
#line 676
                  if (a < (*curctx)->qeval) {
#line 676
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                    *curctx = (*curctx)->nlps;
                  } else {
#line 676
                    v = (*curctx)->mps;
#line 676
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 676
                  while (1) {
                    while_continue___12: /* CIL Label */ ;

#line 676
                    if (ct == 0U) {
#line 676
                      l_c___10 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                      if ((int )*(mqc->bp) == 255) {
#line 676
                        if (l_c___10 > 143U) {
#line 676
                          c += 65280U;
#line 676
                          ct = (OPJ_UINT32 )8;
#line 676
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 676
                          (mqc->bp) ++;
#line 676
                          c += l_c___10 << 9;
#line 676
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___10 << 8;
#line 676
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 676
                    a <<= 1;
#line 676
                    c <<= 1;
#line 676
                    __cil_tmp108 = ct;
#line 676
                    ct --;
#line 676
                    if (! (a < 32768U)) {
#line 676
                      goto while_break___12;
                    }
                  }
                  while_break___32: /* CIL Label */ ;
                  }
                  while_break___12: ;
                } else {
#line 676
                  v = (*curctx)->mps;
                }
              }
#line 676
              v ^= spb___1;
#line 676
              if (v) {
#line 676
                tmp___1 = - oneplushalf;
              } else {
#line 676
                tmp___1 = oneplushalf;
              }
#line 676
              *(data + 2U * l_w) = tmp___1;
#line 676
              *(flagsp + -1) |= (1U << 5) << 6U;
#line 676
              flags |= ((v << 19) | (1U << 4)) << 6U;
#line 676
              *(flagsp + 1) |= (1U << 3) << 6U;
            }
#line 676
            flags |= (1U << 21) << 6U;
          }
        }
#line 676
        if ((flags & (((1U << 4) | (1U << 21)) << 9U)) == 0U) {
#line 676
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 9U)) != 0U) {
            {
#line 676
            __cil_tmp113 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 676
            ctxt1___2 = (OPJ_UINT32 )__cil_tmp113;
#line 676
            curctx = & mqc->ctxs[ctxt1___2];
#line 676
            a -= (*curctx)->qeval;
            }
#line 676
            if (c >> 16 < (*curctx)->qeval) {
#line 676
              if (a < (*curctx)->qeval) {
#line 676
                a = (*curctx)->qeval;
#line 676
                v = (*curctx)->mps;
#line 676
                *curctx = (*curctx)->nmps;
              } else {
#line 676
                a = (*curctx)->qeval;
#line 676
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                *curctx = (*curctx)->nlps;
              }
              {
#line 676
              while (1) {
                while_continue___13: /* CIL Label */ ;

#line 676
                if (ct == 0U) {
#line 676
                  l_c___11 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                  if ((int )*(mqc->bp) == 255) {
#line 676
                    if (l_c___11 > 143U) {
#line 676
                      c += 65280U;
#line 676
                      ct = (OPJ_UINT32 )8;
#line 676
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c___11 << 9;
#line 676
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 676
                    (mqc->bp) ++;
#line 676
                    c += l_c___11 << 8;
#line 676
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 676
                a <<= 1;
#line 676
                c <<= 1;
#line 676
                __cil_tmp118 = ct;
#line 676
                ct --;
#line 676
                if (! (a < 32768U)) {
#line 676
                  goto while_break___13;
                }
              }
              while_break___33: /* CIL Label */ ;
              }
              while_break___13: ;
            } else {
#line 676
              c -= (*curctx)->qeval << 16;
#line 676
              if ((a & 32768U) == 0U) {
#line 676
                if (a < (*curctx)->qeval) {
#line 676
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                  *curctx = (*curctx)->nlps;
                } else {
#line 676
                  v = (*curctx)->mps;
#line 676
                  *curctx = (*curctx)->nmps;
                }
                {
#line 676
                while (1) {
                  while_continue___14: /* CIL Label */ ;

#line 676
                  if (ct == 0U) {
#line 676
                    l_c___12 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                    if ((int )*(mqc->bp) == 255) {
#line 676
                      if (l_c___12 > 143U) {
#line 676
                        c += 65280U;
#line 676
                        ct = (OPJ_UINT32 )8;
#line 676
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___12 << 9;
#line 676
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c___12 << 8;
#line 676
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 676
                  a <<= 1;
#line 676
                  c <<= 1;
#line 676
                  __cil_tmp123 = ct;
#line 676
                  ct --;
#line 676
                  if (! (a < 32768U)) {
#line 676
                    goto while_break___14;
                  }
                }
                while_break___34: /* CIL Label */ ;
                }
                while_break___14: ;
              } else {
#line 676
                v = (*curctx)->mps;
              }
            }
#line 676
            if (v) {
              {
#line 676
              __cil_tmp125 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                              *(flagsp + 1), (OPJ_UINT32 )3);
#line 676
              lu___2 = __cil_tmp125;
#line 676
              __cil_tmp127 = opj_t1_getctxno_sc(lu___2);
#line 676
              ctxt2___2 = (OPJ_UINT32 )__cil_tmp127;
#line 676
              __cil_tmp129 = opj_t1_getspb(lu___2);
#line 676
              spb___2 = (OPJ_UINT32 )__cil_tmp129;
#line 676
              curctx = & mqc->ctxs[ctxt2___2];
#line 676
              a -= (*curctx)->qeval;
              }
#line 676
              if (c >> 16 < (*curctx)->qeval) {
#line 676
                if (a < (*curctx)->qeval) {
#line 676
                  a = (*curctx)->qeval;
#line 676
                  v = (*curctx)->mps;
#line 676
                  *curctx = (*curctx)->nmps;
                } else {
#line 676
                  a = (*curctx)->qeval;
#line 676
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                  *curctx = (*curctx)->nlps;
                }
                {
#line 676
                while (1) {
                  while_continue___15: /* CIL Label */ ;

#line 676
                  if (ct == 0U) {
#line 676
                    l_c___13 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                    if ((int )*(mqc->bp) == 255) {
#line 676
                      if (l_c___13 > 143U) {
#line 676
                        c += 65280U;
#line 676
                        ct = (OPJ_UINT32 )8;
#line 676
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___13 << 9;
#line 676
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 676
                      (mqc->bp) ++;
#line 676
                      c += l_c___13 << 8;
#line 676
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 676
                  a <<= 1;
#line 676
                  c <<= 1;
#line 676
                  __cil_tmp134 = ct;
#line 676
                  ct --;
#line 676
                  if (! (a < 32768U)) {
#line 676
                    goto while_break___15;
                  }
                }
                while_break___35: /* CIL Label */ ;
                }
                while_break___15: ;
              } else {
#line 676
                c -= (*curctx)->qeval << 16;
#line 676
                if ((a & 32768U) == 0U) {
#line 676
                  if (a < (*curctx)->qeval) {
#line 676
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 676
                    *curctx = (*curctx)->nlps;
                  } else {
#line 676
                    v = (*curctx)->mps;
#line 676
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 676
                  while (1) {
                    while_continue___16: /* CIL Label */ ;

#line 676
                    if (ct == 0U) {
#line 676
                      l_c___14 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 676
                      if ((int )*(mqc->bp) == 255) {
#line 676
                        if (l_c___14 > 143U) {
#line 676
                          c += 65280U;
#line 676
                          ct = (OPJ_UINT32 )8;
#line 676
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 676
                          (mqc->bp) ++;
#line 676
                          c += l_c___14 << 9;
#line 676
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 676
                        (mqc->bp) ++;
#line 676
                        c += l_c___14 << 8;
#line 676
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 676
                    a <<= 1;
#line 676
                    c <<= 1;
#line 676
                    __cil_tmp139 = ct;
#line 676
                    ct --;
#line 676
                    if (! (a < 32768U)) {
#line 676
                      goto while_break___16;
                    }
                  }
                  while_break___36: /* CIL Label */ ;
                  }
                  while_break___16: ;
                } else {
#line 676
                  v = (*curctx)->mps;
                }
              }
#line 676
              v ^= spb___2;
#line 676
              if (v) {
#line 676
                tmp___2 = - oneplushalf;
              } else {
#line 676
                tmp___2 = oneplushalf;
              }
#line 676
              *(data + 3U * l_w) = tmp___2;
#line 676
              *(flagsp + -1) |= (1U << 5) << 9U;
#line 676
              flags |= ((v << 19) | (1U << 4)) << 9U;
#line 676
              *(flagsp + 1) |= (1U << 3) << 9U;
#line 676
              south___2 = flagsp + 66;
#line 676
              *south___2 |= (v << 18) | (1U << 1);
#line 676
              *(south___2 + -1) |= 1U << 2;
#line 676
              *(south___2 + 1) |= 1U;
            }
#line 676
            flags |= (1U << 21) << 9U;
          }
        }
#line 676
        *flagsp = flags;
      }
#line 676
      flagsp ++;
#line 676
      data ++;
#line 676
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___0: 
#line 676
    flagsp += 2;
#line 676
    data += 3U * l_w;
#line 676
    k += 4U;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break: 
#line 676
  mqc->curctx = curctx;
#line 676
  mqc->c = c;
#line 676
  mqc->a = a;
#line 676
  mqc->ct = ct;
#line 676
  if (k < 64U) {
#line 676
    i = (OPJ_UINT32 )0;
    {
#line 676
    while (1) {
      while_continue___17: /* CIL Label */ ;

#line 676
      if (! (i < l_w)) {
#line 676
        goto while_break___17;
      }
#line 676
      j = (OPJ_UINT32 )0;
      {
#line 676
      while (1) {
        while_continue___18: /* CIL Label */ ;

#line 676
        if (! (j < 64U - k)) {
#line 676
          goto while_break___18;
        }
        {
#line 676
        opj_t1_dec_sigpass_step_mqc(t1, flagsp, data + j * l_w, oneplushalf, j, (OPJ_UINT32 )66,
                                    (OPJ_UINT32 )1);
#line 676
        j ++;
        }
      }
      while_break___38: /* CIL Label */ ;
      }
      while_break___18: 
#line 676
      flagsp ++;
#line 676
      data ++;
#line 676
      i ++;
    }
    while_break___37: /* CIL Label */ ;
    }
    while_break___17: ;
  }
#line 682
  return;
}
}
#line 679 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_sigpass_mqc_generic_novsc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  register OPJ_INT32 *data ;
  register opj_flag_t *flagsp ;
  OPJ_UINT32 l_w ;
  opj_mqc_t *mqc ;
  register opj_mqc_state_t **curctx ;
  register OPJ_UINT32 c ;
  register OPJ_UINT32 a ;
  register OPJ_UINT32 ct ;
  register OPJ_UINT32 v ;
  opj_flag_t flags ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp20 ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 lu ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 ctxt2 ;
  OPJ_BYTE __cil_tmp34 ;
  OPJ_UINT32 spb ;
  OPJ_BYTE __cil_tmp36 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp41 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_INT32 tmp ;
  opj_flag_t *north ;
  OPJ_UINT32 ctxt1___0 ;
  OPJ_BYTE __cil_tmp51 ;
  OPJ_UINT32 l_c___3 ;
  OPJ_UINT32 __cil_tmp56 ;
  OPJ_UINT32 l_c___4 ;
  OPJ_UINT32 __cil_tmp61 ;
  OPJ_UINT32 lu___0 ;
  OPJ_UINT32 __cil_tmp63 ;
  OPJ_UINT32 ctxt2___0 ;
  OPJ_BYTE __cil_tmp65 ;
  OPJ_UINT32 spb___0 ;
  OPJ_BYTE __cil_tmp67 ;
  OPJ_UINT32 l_c___5 ;
  OPJ_UINT32 __cil_tmp72 ;
  OPJ_UINT32 l_c___6 ;
  OPJ_UINT32 __cil_tmp77 ;
  OPJ_INT32 tmp___0 ;
  OPJ_UINT32 ctxt1___1 ;
  OPJ_BYTE __cil_tmp82 ;
  OPJ_UINT32 l_c___7 ;
  OPJ_UINT32 __cil_tmp87 ;
  OPJ_UINT32 l_c___8 ;
  OPJ_UINT32 __cil_tmp92 ;
  OPJ_UINT32 lu___1 ;
  OPJ_UINT32 __cil_tmp94 ;
  OPJ_UINT32 ctxt2___1 ;
  OPJ_BYTE __cil_tmp96 ;
  OPJ_UINT32 spb___1 ;
  OPJ_BYTE __cil_tmp98 ;
  OPJ_UINT32 l_c___9 ;
  OPJ_UINT32 __cil_tmp103 ;
  OPJ_UINT32 l_c___10 ;
  OPJ_UINT32 __cil_tmp108 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 ctxt1___2 ;
  OPJ_BYTE __cil_tmp113 ;
  OPJ_UINT32 l_c___11 ;
  OPJ_UINT32 __cil_tmp118 ;
  OPJ_UINT32 l_c___12 ;
  OPJ_UINT32 __cil_tmp123 ;
  OPJ_UINT32 lu___2 ;
  OPJ_UINT32 __cil_tmp125 ;
  OPJ_UINT32 ctxt2___2 ;
  OPJ_BYTE __cil_tmp127 ;
  OPJ_UINT32 spb___2 ;
  OPJ_BYTE __cil_tmp129 ;
  OPJ_UINT32 l_c___13 ;
  OPJ_UINT32 __cil_tmp134 ;
  OPJ_UINT32 l_c___14 ;
  OPJ_UINT32 __cil_tmp139 ;
  OPJ_INT32 tmp___2 ;
  opj_flag_t *south___2 ;

  {
#line 683
  data = t1->data;
#line 683
  flagsp = t1->flags + ((t1->w + 2U) + 1U);
#line 683
  l_w = t1->w;
#line 683
  mqc = & t1->mqc;
#line 683
  curctx = mqc->curctx;
#line 683
  c = mqc->c;
#line 683
  a = mqc->a;
#line 683
  ct = mqc->ct;
#line 683
  one = 1 << bpno;
#line 683
  half = one >> 1;
#line 683
  oneplushalf = one | half;
#line 683
  k = (OPJ_UINT32 )0;
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;

#line 683
    if (! (k < (t1->h & 4294967292U))) {
#line 683
      goto while_break;
    }
#line 683
    i = (OPJ_UINT32 )0;
    {
#line 683
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 683
      if (! (i < l_w)) {
#line 683
        goto while_break___0;
      }
#line 683
      flags = *flagsp;
#line 683
      if (flags != 0U) {
#line 683
        if ((flags & ((1U << 4) | (1U << 21))) == 0U) {
#line 683
          if ((flags & (((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8))) != 0U) {
            {
#line 683
            __cil_tmp20 = opj_t1_getctxno_zc(mqc, flags);
#line 683
            ctxt1 = (OPJ_UINT32 )__cil_tmp20;
#line 683
            curctx = & mqc->ctxs[ctxt1];
#line 683
            a -= (*curctx)->qeval;
            }
#line 683
            if (c >> 16 < (*curctx)->qeval) {
#line 683
              if (a < (*curctx)->qeval) {
#line 683
                a = (*curctx)->qeval;
#line 683
                v = (*curctx)->mps;
#line 683
                *curctx = (*curctx)->nmps;
              } else {
#line 683
                a = (*curctx)->qeval;
#line 683
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                *curctx = (*curctx)->nlps;
              }
              {
#line 683
              while (1) {
                while_continue___1: /* CIL Label */ ;

#line 683
                if (ct == 0U) {
#line 683
                  l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                  if ((int )*(mqc->bp) == 255) {
#line 683
                    if (l_c > 143U) {
#line 683
                      c += 65280U;
#line 683
                      ct = (OPJ_UINT32 )8;
#line 683
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c << 9;
#line 683
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 683
                    (mqc->bp) ++;
#line 683
                    c += l_c << 8;
#line 683
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 683
                a <<= 1;
#line 683
                c <<= 1;
#line 683
                __cil_tmp25 = ct;
#line 683
                ct --;
#line 683
                if (! (a < 32768U)) {
#line 683
                  goto while_break___1;
                }
              }
              while_break___21: /* CIL Label */ ;
              }
              while_break___1: ;
            } else {
#line 683
              c -= (*curctx)->qeval << 16;
#line 683
              if ((a & 32768U) == 0U) {
#line 683
                if (a < (*curctx)->qeval) {
#line 683
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                  *curctx = (*curctx)->nlps;
                } else {
#line 683
                  v = (*curctx)->mps;
#line 683
                  *curctx = (*curctx)->nmps;
                }
                {
#line 683
                while (1) {
                  while_continue___2: /* CIL Label */ ;

#line 683
                  if (ct == 0U) {
#line 683
                    l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                    if ((int )*(mqc->bp) == 255) {
#line 683
                      if (l_c___0 > 143U) {
#line 683
                        c += 65280U;
#line 683
                        ct = (OPJ_UINT32 )8;
#line 683
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___0 << 9;
#line 683
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c___0 << 8;
#line 683
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 683
                  a <<= 1;
#line 683
                  c <<= 1;
#line 683
                  __cil_tmp30 = ct;
#line 683
                  ct --;
#line 683
                  if (! (a < 32768U)) {
#line 683
                    goto while_break___2;
                  }
                }
                while_break___22: /* CIL Label */ ;
                }
                while_break___2: ;
              } else {
#line 683
                v = (*curctx)->mps;
              }
            }
#line 683
            if (v) {
              {
#line 683
              __cil_tmp32 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )0);
#line 683
              lu = __cil_tmp32;
#line 683
              __cil_tmp34 = opj_t1_getctxno_sc(lu);
#line 683
              ctxt2 = (OPJ_UINT32 )__cil_tmp34;
#line 683
              __cil_tmp36 = opj_t1_getspb(lu);
#line 683
              spb = (OPJ_UINT32 )__cil_tmp36;
#line 683
              curctx = & mqc->ctxs[ctxt2];
#line 683
              a -= (*curctx)->qeval;
              }
#line 683
              if (c >> 16 < (*curctx)->qeval) {
#line 683
                if (a < (*curctx)->qeval) {
#line 683
                  a = (*curctx)->qeval;
#line 683
                  v = (*curctx)->mps;
#line 683
                  *curctx = (*curctx)->nmps;
                } else {
#line 683
                  a = (*curctx)->qeval;
#line 683
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                  *curctx = (*curctx)->nlps;
                }
                {
#line 683
                while (1) {
                  while_continue___3: /* CIL Label */ ;

#line 683
                  if (ct == 0U) {
#line 683
                    l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                    if ((int )*(mqc->bp) == 255) {
#line 683
                      if (l_c___1 > 143U) {
#line 683
                        c += 65280U;
#line 683
                        ct = (OPJ_UINT32 )8;
#line 683
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___1 << 9;
#line 683
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c___1 << 8;
#line 683
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 683
                  a <<= 1;
#line 683
                  c <<= 1;
#line 683
                  __cil_tmp41 = ct;
#line 683
                  ct --;
#line 683
                  if (! (a < 32768U)) {
#line 683
                    goto while_break___3;
                  }
                }
                while_break___23: /* CIL Label */ ;
                }
                while_break___3: ;
              } else {
#line 683
                c -= (*curctx)->qeval << 16;
#line 683
                if ((a & 32768U) == 0U) {
#line 683
                  if (a < (*curctx)->qeval) {
#line 683
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                    *curctx = (*curctx)->nlps;
                  } else {
#line 683
                    v = (*curctx)->mps;
#line 683
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 683
                  while (1) {
                    while_continue___4: /* CIL Label */ ;

#line 683
                    if (ct == 0U) {
#line 683
                      l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                      if ((int )*(mqc->bp) == 255) {
#line 683
                        if (l_c___2 > 143U) {
#line 683
                          c += 65280U;
#line 683
                          ct = (OPJ_UINT32 )8;
#line 683
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 683
                          (mqc->bp) ++;
#line 683
                          c += l_c___2 << 9;
#line 683
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___2 << 8;
#line 683
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 683
                    a <<= 1;
#line 683
                    c <<= 1;
#line 683
                    __cil_tmp46 = ct;
#line 683
                    ct --;
#line 683
                    if (! (a < 32768U)) {
#line 683
                      goto while_break___4;
                    }
                  }
                  while_break___24: /* CIL Label */ ;
                  }
                  while_break___4: ;
                } else {
#line 683
                  v = (*curctx)->mps;
                }
              }
#line 683
              v ^= spb;
#line 683
              if (v) {
#line 683
                tmp = - oneplushalf;
              } else {
#line 683
                tmp = oneplushalf;
              }
#line 683
              *(data + 0U) = tmp;
#line 683
              *(flagsp + -1) |= 1U << 5;
#line 683
              flags |= (v << 19) | (1U << 4);
#line 683
              *(flagsp + 1) |= 1U << 3;
#line 683
              north = flagsp - (t1->w + 2U);
#line 683
              *north |= (v << 31) | (1U << 16);
#line 683
              *(north + -1) |= 1U << 17;
#line 683
              *(north + 1) |= 1U << 15;
            }
#line 683
            flags |= 1U << 21;
          }
        }
#line 683
        if ((flags & (((1U << 4) | (1U << 21)) << 3U)) == 0U) {
#line 683
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 3U)) != 0U) {
            {
#line 683
            __cil_tmp51 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 683
            ctxt1___0 = (OPJ_UINT32 )__cil_tmp51;
#line 683
            curctx = & mqc->ctxs[ctxt1___0];
#line 683
            a -= (*curctx)->qeval;
            }
#line 683
            if (c >> 16 < (*curctx)->qeval) {
#line 683
              if (a < (*curctx)->qeval) {
#line 683
                a = (*curctx)->qeval;
#line 683
                v = (*curctx)->mps;
#line 683
                *curctx = (*curctx)->nmps;
              } else {
#line 683
                a = (*curctx)->qeval;
#line 683
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                *curctx = (*curctx)->nlps;
              }
              {
#line 683
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 683
                if (ct == 0U) {
#line 683
                  l_c___3 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                  if ((int )*(mqc->bp) == 255) {
#line 683
                    if (l_c___3 > 143U) {
#line 683
                      c += 65280U;
#line 683
                      ct = (OPJ_UINT32 )8;
#line 683
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c___3 << 9;
#line 683
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 683
                    (mqc->bp) ++;
#line 683
                    c += l_c___3 << 8;
#line 683
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 683
                a <<= 1;
#line 683
                c <<= 1;
#line 683
                __cil_tmp56 = ct;
#line 683
                ct --;
#line 683
                if (! (a < 32768U)) {
#line 683
                  goto while_break___5;
                }
              }
              while_break___25: /* CIL Label */ ;
              }
              while_break___5: ;
            } else {
#line 683
              c -= (*curctx)->qeval << 16;
#line 683
              if ((a & 32768U) == 0U) {
#line 683
                if (a < (*curctx)->qeval) {
#line 683
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                  *curctx = (*curctx)->nlps;
                } else {
#line 683
                  v = (*curctx)->mps;
#line 683
                  *curctx = (*curctx)->nmps;
                }
                {
#line 683
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 683
                  if (ct == 0U) {
#line 683
                    l_c___4 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                    if ((int )*(mqc->bp) == 255) {
#line 683
                      if (l_c___4 > 143U) {
#line 683
                        c += 65280U;
#line 683
                        ct = (OPJ_UINT32 )8;
#line 683
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___4 << 9;
#line 683
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c___4 << 8;
#line 683
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 683
                  a <<= 1;
#line 683
                  c <<= 1;
#line 683
                  __cil_tmp61 = ct;
#line 683
                  ct --;
#line 683
                  if (! (a < 32768U)) {
#line 683
                    goto while_break___6;
                  }
                }
                while_break___26: /* CIL Label */ ;
                }
                while_break___6: ;
              } else {
#line 683
                v = (*curctx)->mps;
              }
            }
#line 683
            if (v) {
              {
#line 683
              __cil_tmp63 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )1);
#line 683
              lu___0 = __cil_tmp63;
#line 683
              __cil_tmp65 = opj_t1_getctxno_sc(lu___0);
#line 683
              ctxt2___0 = (OPJ_UINT32 )__cil_tmp65;
#line 683
              __cil_tmp67 = opj_t1_getspb(lu___0);
#line 683
              spb___0 = (OPJ_UINT32 )__cil_tmp67;
#line 683
              curctx = & mqc->ctxs[ctxt2___0];
#line 683
              a -= (*curctx)->qeval;
              }
#line 683
              if (c >> 16 < (*curctx)->qeval) {
#line 683
                if (a < (*curctx)->qeval) {
#line 683
                  a = (*curctx)->qeval;
#line 683
                  v = (*curctx)->mps;
#line 683
                  *curctx = (*curctx)->nmps;
                } else {
#line 683
                  a = (*curctx)->qeval;
#line 683
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                  *curctx = (*curctx)->nlps;
                }
                {
#line 683
                while (1) {
                  while_continue___7: /* CIL Label */ ;

#line 683
                  if (ct == 0U) {
#line 683
                    l_c___5 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                    if ((int )*(mqc->bp) == 255) {
#line 683
                      if (l_c___5 > 143U) {
#line 683
                        c += 65280U;
#line 683
                        ct = (OPJ_UINT32 )8;
#line 683
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___5 << 9;
#line 683
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c___5 << 8;
#line 683
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 683
                  a <<= 1;
#line 683
                  c <<= 1;
#line 683
                  __cil_tmp72 = ct;
#line 683
                  ct --;
#line 683
                  if (! (a < 32768U)) {
#line 683
                    goto while_break___7;
                  }
                }
                while_break___27: /* CIL Label */ ;
                }
                while_break___7: ;
              } else {
#line 683
                c -= (*curctx)->qeval << 16;
#line 683
                if ((a & 32768U) == 0U) {
#line 683
                  if (a < (*curctx)->qeval) {
#line 683
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                    *curctx = (*curctx)->nlps;
                  } else {
#line 683
                    v = (*curctx)->mps;
#line 683
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 683
                  while (1) {
                    while_continue___8: /* CIL Label */ ;

#line 683
                    if (ct == 0U) {
#line 683
                      l_c___6 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                      if ((int )*(mqc->bp) == 255) {
#line 683
                        if (l_c___6 > 143U) {
#line 683
                          c += 65280U;
#line 683
                          ct = (OPJ_UINT32 )8;
#line 683
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 683
                          (mqc->bp) ++;
#line 683
                          c += l_c___6 << 9;
#line 683
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___6 << 8;
#line 683
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 683
                    a <<= 1;
#line 683
                    c <<= 1;
#line 683
                    __cil_tmp77 = ct;
#line 683
                    ct --;
#line 683
                    if (! (a < 32768U)) {
#line 683
                      goto while_break___8;
                    }
                  }
                  while_break___28: /* CIL Label */ ;
                  }
                  while_break___8: ;
                } else {
#line 683
                  v = (*curctx)->mps;
                }
              }
#line 683
              v ^= spb___0;
#line 683
              if (v) {
#line 683
                tmp___0 = - oneplushalf;
              } else {
#line 683
                tmp___0 = oneplushalf;
              }
#line 683
              *(data + l_w) = tmp___0;
#line 683
              *(flagsp + -1) |= (1U << 5) << 3U;
#line 683
              flags |= ((v << 19) | (1U << 4)) << 3U;
#line 683
              *(flagsp + 1) |= (1U << 3) << 3U;
            }
#line 683
            flags |= (1U << 21) << 3U;
          }
        }
#line 683
        if ((flags & (((1U << 4) | (1U << 21)) << 6U)) == 0U) {
#line 683
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 6U)) != 0U) {
            {
#line 683
            __cil_tmp82 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 683
            ctxt1___1 = (OPJ_UINT32 )__cil_tmp82;
#line 683
            curctx = & mqc->ctxs[ctxt1___1];
#line 683
            a -= (*curctx)->qeval;
            }
#line 683
            if (c >> 16 < (*curctx)->qeval) {
#line 683
              if (a < (*curctx)->qeval) {
#line 683
                a = (*curctx)->qeval;
#line 683
                v = (*curctx)->mps;
#line 683
                *curctx = (*curctx)->nmps;
              } else {
#line 683
                a = (*curctx)->qeval;
#line 683
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                *curctx = (*curctx)->nlps;
              }
              {
#line 683
              while (1) {
                while_continue___9: /* CIL Label */ ;

#line 683
                if (ct == 0U) {
#line 683
                  l_c___7 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                  if ((int )*(mqc->bp) == 255) {
#line 683
                    if (l_c___7 > 143U) {
#line 683
                      c += 65280U;
#line 683
                      ct = (OPJ_UINT32 )8;
#line 683
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c___7 << 9;
#line 683
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 683
                    (mqc->bp) ++;
#line 683
                    c += l_c___7 << 8;
#line 683
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 683
                a <<= 1;
#line 683
                c <<= 1;
#line 683
                __cil_tmp87 = ct;
#line 683
                ct --;
#line 683
                if (! (a < 32768U)) {
#line 683
                  goto while_break___9;
                }
              }
              while_break___29: /* CIL Label */ ;
              }
              while_break___9: ;
            } else {
#line 683
              c -= (*curctx)->qeval << 16;
#line 683
              if ((a & 32768U) == 0U) {
#line 683
                if (a < (*curctx)->qeval) {
#line 683
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                  *curctx = (*curctx)->nlps;
                } else {
#line 683
                  v = (*curctx)->mps;
#line 683
                  *curctx = (*curctx)->nmps;
                }
                {
#line 683
                while (1) {
                  while_continue___10: /* CIL Label */ ;

#line 683
                  if (ct == 0U) {
#line 683
                    l_c___8 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                    if ((int )*(mqc->bp) == 255) {
#line 683
                      if (l_c___8 > 143U) {
#line 683
                        c += 65280U;
#line 683
                        ct = (OPJ_UINT32 )8;
#line 683
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___8 << 9;
#line 683
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c___8 << 8;
#line 683
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 683
                  a <<= 1;
#line 683
                  c <<= 1;
#line 683
                  __cil_tmp92 = ct;
#line 683
                  ct --;
#line 683
                  if (! (a < 32768U)) {
#line 683
                    goto while_break___10;
                  }
                }
                while_break___30: /* CIL Label */ ;
                }
                while_break___10: ;
              } else {
#line 683
                v = (*curctx)->mps;
              }
            }
#line 683
            if (v) {
              {
#line 683
              __cil_tmp94 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )2);
#line 683
              lu___1 = __cil_tmp94;
#line 683
              __cil_tmp96 = opj_t1_getctxno_sc(lu___1);
#line 683
              ctxt2___1 = (OPJ_UINT32 )__cil_tmp96;
#line 683
              __cil_tmp98 = opj_t1_getspb(lu___1);
#line 683
              spb___1 = (OPJ_UINT32 )__cil_tmp98;
#line 683
              curctx = & mqc->ctxs[ctxt2___1];
#line 683
              a -= (*curctx)->qeval;
              }
#line 683
              if (c >> 16 < (*curctx)->qeval) {
#line 683
                if (a < (*curctx)->qeval) {
#line 683
                  a = (*curctx)->qeval;
#line 683
                  v = (*curctx)->mps;
#line 683
                  *curctx = (*curctx)->nmps;
                } else {
#line 683
                  a = (*curctx)->qeval;
#line 683
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                  *curctx = (*curctx)->nlps;
                }
                {
#line 683
                while (1) {
                  while_continue___11: /* CIL Label */ ;

#line 683
                  if (ct == 0U) {
#line 683
                    l_c___9 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                    if ((int )*(mqc->bp) == 255) {
#line 683
                      if (l_c___9 > 143U) {
#line 683
                        c += 65280U;
#line 683
                        ct = (OPJ_UINT32 )8;
#line 683
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___9 << 9;
#line 683
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c___9 << 8;
#line 683
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 683
                  a <<= 1;
#line 683
                  c <<= 1;
#line 683
                  __cil_tmp103 = ct;
#line 683
                  ct --;
#line 683
                  if (! (a < 32768U)) {
#line 683
                    goto while_break___11;
                  }
                }
                while_break___31: /* CIL Label */ ;
                }
                while_break___11: ;
              } else {
#line 683
                c -= (*curctx)->qeval << 16;
#line 683
                if ((a & 32768U) == 0U) {
#line 683
                  if (a < (*curctx)->qeval) {
#line 683
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                    *curctx = (*curctx)->nlps;
                  } else {
#line 683
                    v = (*curctx)->mps;
#line 683
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 683
                  while (1) {
                    while_continue___12: /* CIL Label */ ;

#line 683
                    if (ct == 0U) {
#line 683
                      l_c___10 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                      if ((int )*(mqc->bp) == 255) {
#line 683
                        if (l_c___10 > 143U) {
#line 683
                          c += 65280U;
#line 683
                          ct = (OPJ_UINT32 )8;
#line 683
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 683
                          (mqc->bp) ++;
#line 683
                          c += l_c___10 << 9;
#line 683
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___10 << 8;
#line 683
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 683
                    a <<= 1;
#line 683
                    c <<= 1;
#line 683
                    __cil_tmp108 = ct;
#line 683
                    ct --;
#line 683
                    if (! (a < 32768U)) {
#line 683
                      goto while_break___12;
                    }
                  }
                  while_break___32: /* CIL Label */ ;
                  }
                  while_break___12: ;
                } else {
#line 683
                  v = (*curctx)->mps;
                }
              }
#line 683
              v ^= spb___1;
#line 683
              if (v) {
#line 683
                tmp___1 = - oneplushalf;
              } else {
#line 683
                tmp___1 = oneplushalf;
              }
#line 683
              *(data + 2U * l_w) = tmp___1;
#line 683
              *(flagsp + -1) |= (1U << 5) << 6U;
#line 683
              flags |= ((v << 19) | (1U << 4)) << 6U;
#line 683
              *(flagsp + 1) |= (1U << 3) << 6U;
            }
#line 683
            flags |= (1U << 21) << 6U;
          }
        }
#line 683
        if ((flags & (((1U << 4) | (1U << 21)) << 9U)) == 0U) {
#line 683
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 9U)) != 0U) {
            {
#line 683
            __cil_tmp113 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 683
            ctxt1___2 = (OPJ_UINT32 )__cil_tmp113;
#line 683
            curctx = & mqc->ctxs[ctxt1___2];
#line 683
            a -= (*curctx)->qeval;
            }
#line 683
            if (c >> 16 < (*curctx)->qeval) {
#line 683
              if (a < (*curctx)->qeval) {
#line 683
                a = (*curctx)->qeval;
#line 683
                v = (*curctx)->mps;
#line 683
                *curctx = (*curctx)->nmps;
              } else {
#line 683
                a = (*curctx)->qeval;
#line 683
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                *curctx = (*curctx)->nlps;
              }
              {
#line 683
              while (1) {
                while_continue___13: /* CIL Label */ ;

#line 683
                if (ct == 0U) {
#line 683
                  l_c___11 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                  if ((int )*(mqc->bp) == 255) {
#line 683
                    if (l_c___11 > 143U) {
#line 683
                      c += 65280U;
#line 683
                      ct = (OPJ_UINT32 )8;
#line 683
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c___11 << 9;
#line 683
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 683
                    (mqc->bp) ++;
#line 683
                    c += l_c___11 << 8;
#line 683
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 683
                a <<= 1;
#line 683
                c <<= 1;
#line 683
                __cil_tmp118 = ct;
#line 683
                ct --;
#line 683
                if (! (a < 32768U)) {
#line 683
                  goto while_break___13;
                }
              }
              while_break___33: /* CIL Label */ ;
              }
              while_break___13: ;
            } else {
#line 683
              c -= (*curctx)->qeval << 16;
#line 683
              if ((a & 32768U) == 0U) {
#line 683
                if (a < (*curctx)->qeval) {
#line 683
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                  *curctx = (*curctx)->nlps;
                } else {
#line 683
                  v = (*curctx)->mps;
#line 683
                  *curctx = (*curctx)->nmps;
                }
                {
#line 683
                while (1) {
                  while_continue___14: /* CIL Label */ ;

#line 683
                  if (ct == 0U) {
#line 683
                    l_c___12 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                    if ((int )*(mqc->bp) == 255) {
#line 683
                      if (l_c___12 > 143U) {
#line 683
                        c += 65280U;
#line 683
                        ct = (OPJ_UINT32 )8;
#line 683
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___12 << 9;
#line 683
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c___12 << 8;
#line 683
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 683
                  a <<= 1;
#line 683
                  c <<= 1;
#line 683
                  __cil_tmp123 = ct;
#line 683
                  ct --;
#line 683
                  if (! (a < 32768U)) {
#line 683
                    goto while_break___14;
                  }
                }
                while_break___34: /* CIL Label */ ;
                }
                while_break___14: ;
              } else {
#line 683
                v = (*curctx)->mps;
              }
            }
#line 683
            if (v) {
              {
#line 683
              __cil_tmp125 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                              *(flagsp + 1), (OPJ_UINT32 )3);
#line 683
              lu___2 = __cil_tmp125;
#line 683
              __cil_tmp127 = opj_t1_getctxno_sc(lu___2);
#line 683
              ctxt2___2 = (OPJ_UINT32 )__cil_tmp127;
#line 683
              __cil_tmp129 = opj_t1_getspb(lu___2);
#line 683
              spb___2 = (OPJ_UINT32 )__cil_tmp129;
#line 683
              curctx = & mqc->ctxs[ctxt2___2];
#line 683
              a -= (*curctx)->qeval;
              }
#line 683
              if (c >> 16 < (*curctx)->qeval) {
#line 683
                if (a < (*curctx)->qeval) {
#line 683
                  a = (*curctx)->qeval;
#line 683
                  v = (*curctx)->mps;
#line 683
                  *curctx = (*curctx)->nmps;
                } else {
#line 683
                  a = (*curctx)->qeval;
#line 683
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                  *curctx = (*curctx)->nlps;
                }
                {
#line 683
                while (1) {
                  while_continue___15: /* CIL Label */ ;

#line 683
                  if (ct == 0U) {
#line 683
                    l_c___13 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                    if ((int )*(mqc->bp) == 255) {
#line 683
                      if (l_c___13 > 143U) {
#line 683
                        c += 65280U;
#line 683
                        ct = (OPJ_UINT32 )8;
#line 683
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___13 << 9;
#line 683
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 683
                      (mqc->bp) ++;
#line 683
                      c += l_c___13 << 8;
#line 683
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 683
                  a <<= 1;
#line 683
                  c <<= 1;
#line 683
                  __cil_tmp134 = ct;
#line 683
                  ct --;
#line 683
                  if (! (a < 32768U)) {
#line 683
                    goto while_break___15;
                  }
                }
                while_break___35: /* CIL Label */ ;
                }
                while_break___15: ;
              } else {
#line 683
                c -= (*curctx)->qeval << 16;
#line 683
                if ((a & 32768U) == 0U) {
#line 683
                  if (a < (*curctx)->qeval) {
#line 683
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 683
                    *curctx = (*curctx)->nlps;
                  } else {
#line 683
                    v = (*curctx)->mps;
#line 683
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 683
                  while (1) {
                    while_continue___16: /* CIL Label */ ;

#line 683
                    if (ct == 0U) {
#line 683
                      l_c___14 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 683
                      if ((int )*(mqc->bp) == 255) {
#line 683
                        if (l_c___14 > 143U) {
#line 683
                          c += 65280U;
#line 683
                          ct = (OPJ_UINT32 )8;
#line 683
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 683
                          (mqc->bp) ++;
#line 683
                          c += l_c___14 << 9;
#line 683
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 683
                        (mqc->bp) ++;
#line 683
                        c += l_c___14 << 8;
#line 683
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 683
                    a <<= 1;
#line 683
                    c <<= 1;
#line 683
                    __cil_tmp139 = ct;
#line 683
                    ct --;
#line 683
                    if (! (a < 32768U)) {
#line 683
                      goto while_break___16;
                    }
                  }
                  while_break___36: /* CIL Label */ ;
                  }
                  while_break___16: ;
                } else {
#line 683
                  v = (*curctx)->mps;
                }
              }
#line 683
              v ^= spb___2;
#line 683
              if (v) {
#line 683
                tmp___2 = - oneplushalf;
              } else {
#line 683
                tmp___2 = oneplushalf;
              }
#line 683
              *(data + 3U * l_w) = tmp___2;
#line 683
              *(flagsp + -1) |= (1U << 5) << 9U;
#line 683
              flags |= ((v << 19) | (1U << 4)) << 9U;
#line 683
              *(flagsp + 1) |= (1U << 3) << 9U;
#line 683
              south___2 = flagsp + (t1->w + 2U);
#line 683
              *south___2 |= (v << 18) | (1U << 1);
#line 683
              *(south___2 + -1) |= 1U << 2;
#line 683
              *(south___2 + 1) |= 1U;
            }
#line 683
            flags |= (1U << 21) << 9U;
          }
        }
#line 683
        *flagsp = flags;
      }
#line 683
      flagsp ++;
#line 683
      data ++;
#line 683
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___0: 
#line 683
    flagsp += 2;
#line 683
    data += 3U * l_w;
#line 683
    k += 4U;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break: 
#line 683
  mqc->curctx = curctx;
#line 683
  mqc->c = c;
#line 683
  mqc->a = a;
#line 683
  mqc->ct = ct;
#line 683
  if (k < t1->h) {
#line 683
    i = (OPJ_UINT32 )0;
    {
#line 683
    while (1) {
      while_continue___17: /* CIL Label */ ;

#line 683
      if (! (i < l_w)) {
#line 683
        goto while_break___17;
      }
#line 683
      j = (OPJ_UINT32 )0;
      {
#line 683
      while (1) {
        while_continue___18: /* CIL Label */ ;

#line 683
        if (! (j < t1->h - k)) {
#line 683
          goto while_break___18;
        }
        {
#line 683
        opj_t1_dec_sigpass_step_mqc(t1, flagsp, data + j * l_w, oneplushalf, j, t1->w + 2U,
                                    (OPJ_UINT32 )0);
#line 683
        j ++;
        }
      }
      while_break___38: /* CIL Label */ ;
      }
      while_break___18: 
#line 683
      flagsp ++;
#line 683
      data ++;
#line 683
      i ++;
    }
    while_break___37: /* CIL Label */ ;
    }
    while_break___17: ;
  }
#line 689
  return;
}
}
#line 687 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_sigpass_mqc_generic_vsc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  register OPJ_INT32 *data ;
  register opj_flag_t *flagsp ;
  OPJ_UINT32 l_w ;
  opj_mqc_t *mqc ;
  register opj_mqc_state_t **curctx ;
  register OPJ_UINT32 c ;
  register OPJ_UINT32 a ;
  register OPJ_UINT32 ct ;
  register OPJ_UINT32 v ;
  opj_flag_t flags ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp20 ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 lu ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 ctxt2 ;
  OPJ_BYTE __cil_tmp34 ;
  OPJ_UINT32 spb ;
  OPJ_BYTE __cil_tmp36 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp41 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_INT32 tmp ;
  OPJ_UINT32 ctxt1___0 ;
  OPJ_BYTE __cil_tmp51 ;
  OPJ_UINT32 l_c___3 ;
  OPJ_UINT32 __cil_tmp56 ;
  OPJ_UINT32 l_c___4 ;
  OPJ_UINT32 __cil_tmp61 ;
  OPJ_UINT32 lu___0 ;
  OPJ_UINT32 __cil_tmp63 ;
  OPJ_UINT32 ctxt2___0 ;
  OPJ_BYTE __cil_tmp65 ;
  OPJ_UINT32 spb___0 ;
  OPJ_BYTE __cil_tmp67 ;
  OPJ_UINT32 l_c___5 ;
  OPJ_UINT32 __cil_tmp72 ;
  OPJ_UINT32 l_c___6 ;
  OPJ_UINT32 __cil_tmp77 ;
  OPJ_INT32 tmp___0 ;
  OPJ_UINT32 ctxt1___1 ;
  OPJ_BYTE __cil_tmp82 ;
  OPJ_UINT32 l_c___7 ;
  OPJ_UINT32 __cil_tmp87 ;
  OPJ_UINT32 l_c___8 ;
  OPJ_UINT32 __cil_tmp92 ;
  OPJ_UINT32 lu___1 ;
  OPJ_UINT32 __cil_tmp94 ;
  OPJ_UINT32 ctxt2___1 ;
  OPJ_BYTE __cil_tmp96 ;
  OPJ_UINT32 spb___1 ;
  OPJ_BYTE __cil_tmp98 ;
  OPJ_UINT32 l_c___9 ;
  OPJ_UINT32 __cil_tmp103 ;
  OPJ_UINT32 l_c___10 ;
  OPJ_UINT32 __cil_tmp108 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 ctxt1___2 ;
  OPJ_BYTE __cil_tmp113 ;
  OPJ_UINT32 l_c___11 ;
  OPJ_UINT32 __cil_tmp118 ;
  OPJ_UINT32 l_c___12 ;
  OPJ_UINT32 __cil_tmp123 ;
  OPJ_UINT32 lu___2 ;
  OPJ_UINT32 __cil_tmp125 ;
  OPJ_UINT32 ctxt2___2 ;
  OPJ_BYTE __cil_tmp127 ;
  OPJ_UINT32 spb___2 ;
  OPJ_BYTE __cil_tmp129 ;
  OPJ_UINT32 l_c___13 ;
  OPJ_UINT32 __cil_tmp134 ;
  OPJ_UINT32 l_c___14 ;
  OPJ_UINT32 __cil_tmp139 ;
  OPJ_INT32 tmp___2 ;
  opj_flag_t *south___2 ;

  {
#line 691
  data = t1->data;
#line 691
  flagsp = t1->flags + ((t1->w + 2U) + 1U);
#line 691
  l_w = t1->w;
#line 691
  mqc = & t1->mqc;
#line 691
  curctx = mqc->curctx;
#line 691
  c = mqc->c;
#line 691
  a = mqc->a;
#line 691
  ct = mqc->ct;
#line 691
  one = 1 << bpno;
#line 691
  half = one >> 1;
#line 691
  oneplushalf = one | half;
#line 691
  k = (OPJ_UINT32 )0;
  {
#line 691
  while (1) {
    while_continue: /* CIL Label */ ;

#line 691
    if (! (k < (t1->h & 4294967292U))) {
#line 691
      goto while_break;
    }
#line 691
    i = (OPJ_UINT32 )0;
    {
#line 691
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 691
      if (! (i < l_w)) {
#line 691
        goto while_break___0;
      }
#line 691
      flags = *flagsp;
#line 691
      if (flags != 0U) {
#line 691
        if ((flags & ((1U << 4) | (1U << 21))) == 0U) {
#line 691
          if ((flags & (((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8))) != 0U) {
            {
#line 691
            __cil_tmp20 = opj_t1_getctxno_zc(mqc, flags);
#line 691
            ctxt1 = (OPJ_UINT32 )__cil_tmp20;
#line 691
            curctx = & mqc->ctxs[ctxt1];
#line 691
            a -= (*curctx)->qeval;
            }
#line 691
            if (c >> 16 < (*curctx)->qeval) {
#line 691
              if (a < (*curctx)->qeval) {
#line 691
                a = (*curctx)->qeval;
#line 691
                v = (*curctx)->mps;
#line 691
                *curctx = (*curctx)->nmps;
              } else {
#line 691
                a = (*curctx)->qeval;
#line 691
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                *curctx = (*curctx)->nlps;
              }
              {
#line 691
              while (1) {
                while_continue___1: /* CIL Label */ ;

#line 691
                if (ct == 0U) {
#line 691
                  l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                  if ((int )*(mqc->bp) == 255) {
#line 691
                    if (l_c > 143U) {
#line 691
                      c += 65280U;
#line 691
                      ct = (OPJ_UINT32 )8;
#line 691
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c << 9;
#line 691
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 691
                    (mqc->bp) ++;
#line 691
                    c += l_c << 8;
#line 691
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 691
                a <<= 1;
#line 691
                c <<= 1;
#line 691
                __cil_tmp25 = ct;
#line 691
                ct --;
#line 691
                if (! (a < 32768U)) {
#line 691
                  goto while_break___1;
                }
              }
              while_break___21: /* CIL Label */ ;
              }
              while_break___1: ;
            } else {
#line 691
              c -= (*curctx)->qeval << 16;
#line 691
              if ((a & 32768U) == 0U) {
#line 691
                if (a < (*curctx)->qeval) {
#line 691
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                  *curctx = (*curctx)->nlps;
                } else {
#line 691
                  v = (*curctx)->mps;
#line 691
                  *curctx = (*curctx)->nmps;
                }
                {
#line 691
                while (1) {
                  while_continue___2: /* CIL Label */ ;

#line 691
                  if (ct == 0U) {
#line 691
                    l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                    if ((int )*(mqc->bp) == 255) {
#line 691
                      if (l_c___0 > 143U) {
#line 691
                        c += 65280U;
#line 691
                        ct = (OPJ_UINT32 )8;
#line 691
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___0 << 9;
#line 691
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c___0 << 8;
#line 691
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 691
                  a <<= 1;
#line 691
                  c <<= 1;
#line 691
                  __cil_tmp30 = ct;
#line 691
                  ct --;
#line 691
                  if (! (a < 32768U)) {
#line 691
                    goto while_break___2;
                  }
                }
                while_break___22: /* CIL Label */ ;
                }
                while_break___2: ;
              } else {
#line 691
                v = (*curctx)->mps;
              }
            }
#line 691
            if (v) {
              {
#line 691
              __cil_tmp32 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )0);
#line 691
              lu = __cil_tmp32;
#line 691
              __cil_tmp34 = opj_t1_getctxno_sc(lu);
#line 691
              ctxt2 = (OPJ_UINT32 )__cil_tmp34;
#line 691
              __cil_tmp36 = opj_t1_getspb(lu);
#line 691
              spb = (OPJ_UINT32 )__cil_tmp36;
#line 691
              curctx = & mqc->ctxs[ctxt2];
#line 691
              a -= (*curctx)->qeval;
              }
#line 691
              if (c >> 16 < (*curctx)->qeval) {
#line 691
                if (a < (*curctx)->qeval) {
#line 691
                  a = (*curctx)->qeval;
#line 691
                  v = (*curctx)->mps;
#line 691
                  *curctx = (*curctx)->nmps;
                } else {
#line 691
                  a = (*curctx)->qeval;
#line 691
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                  *curctx = (*curctx)->nlps;
                }
                {
#line 691
                while (1) {
                  while_continue___3: /* CIL Label */ ;

#line 691
                  if (ct == 0U) {
#line 691
                    l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                    if ((int )*(mqc->bp) == 255) {
#line 691
                      if (l_c___1 > 143U) {
#line 691
                        c += 65280U;
#line 691
                        ct = (OPJ_UINT32 )8;
#line 691
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___1 << 9;
#line 691
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c___1 << 8;
#line 691
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 691
                  a <<= 1;
#line 691
                  c <<= 1;
#line 691
                  __cil_tmp41 = ct;
#line 691
                  ct --;
#line 691
                  if (! (a < 32768U)) {
#line 691
                    goto while_break___3;
                  }
                }
                while_break___23: /* CIL Label */ ;
                }
                while_break___3: ;
              } else {
#line 691
                c -= (*curctx)->qeval << 16;
#line 691
                if ((a & 32768U) == 0U) {
#line 691
                  if (a < (*curctx)->qeval) {
#line 691
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                    *curctx = (*curctx)->nlps;
                  } else {
#line 691
                    v = (*curctx)->mps;
#line 691
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 691
                  while (1) {
                    while_continue___4: /* CIL Label */ ;

#line 691
                    if (ct == 0U) {
#line 691
                      l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                      if ((int )*(mqc->bp) == 255) {
#line 691
                        if (l_c___2 > 143U) {
#line 691
                          c += 65280U;
#line 691
                          ct = (OPJ_UINT32 )8;
#line 691
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 691
                          (mqc->bp) ++;
#line 691
                          c += l_c___2 << 9;
#line 691
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___2 << 8;
#line 691
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 691
                    a <<= 1;
#line 691
                    c <<= 1;
#line 691
                    __cil_tmp46 = ct;
#line 691
                    ct --;
#line 691
                    if (! (a < 32768U)) {
#line 691
                      goto while_break___4;
                    }
                  }
                  while_break___24: /* CIL Label */ ;
                  }
                  while_break___4: ;
                } else {
#line 691
                  v = (*curctx)->mps;
                }
              }
#line 691
              v ^= spb;
#line 691
              if (v) {
#line 691
                tmp = - oneplushalf;
              } else {
#line 691
                tmp = oneplushalf;
              }
#line 691
              *(data + 0U) = tmp;
#line 691
              *(flagsp + -1) |= 1U << 5;
#line 691
              flags |= (v << 19) | (1U << 4);
#line 691
              *(flagsp + 1) |= 1U << 3;
            }
#line 691
            flags |= 1U << 21;
          }
        }
#line 691
        if ((flags & (((1U << 4) | (1U << 21)) << 3U)) == 0U) {
#line 691
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 3U)) != 0U) {
            {
#line 691
            __cil_tmp51 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 691
            ctxt1___0 = (OPJ_UINT32 )__cil_tmp51;
#line 691
            curctx = & mqc->ctxs[ctxt1___0];
#line 691
            a -= (*curctx)->qeval;
            }
#line 691
            if (c >> 16 < (*curctx)->qeval) {
#line 691
              if (a < (*curctx)->qeval) {
#line 691
                a = (*curctx)->qeval;
#line 691
                v = (*curctx)->mps;
#line 691
                *curctx = (*curctx)->nmps;
              } else {
#line 691
                a = (*curctx)->qeval;
#line 691
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                *curctx = (*curctx)->nlps;
              }
              {
#line 691
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 691
                if (ct == 0U) {
#line 691
                  l_c___3 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                  if ((int )*(mqc->bp) == 255) {
#line 691
                    if (l_c___3 > 143U) {
#line 691
                      c += 65280U;
#line 691
                      ct = (OPJ_UINT32 )8;
#line 691
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c___3 << 9;
#line 691
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 691
                    (mqc->bp) ++;
#line 691
                    c += l_c___3 << 8;
#line 691
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 691
                a <<= 1;
#line 691
                c <<= 1;
#line 691
                __cil_tmp56 = ct;
#line 691
                ct --;
#line 691
                if (! (a < 32768U)) {
#line 691
                  goto while_break___5;
                }
              }
              while_break___25: /* CIL Label */ ;
              }
              while_break___5: ;
            } else {
#line 691
              c -= (*curctx)->qeval << 16;
#line 691
              if ((a & 32768U) == 0U) {
#line 691
                if (a < (*curctx)->qeval) {
#line 691
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                  *curctx = (*curctx)->nlps;
                } else {
#line 691
                  v = (*curctx)->mps;
#line 691
                  *curctx = (*curctx)->nmps;
                }
                {
#line 691
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 691
                  if (ct == 0U) {
#line 691
                    l_c___4 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                    if ((int )*(mqc->bp) == 255) {
#line 691
                      if (l_c___4 > 143U) {
#line 691
                        c += 65280U;
#line 691
                        ct = (OPJ_UINT32 )8;
#line 691
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___4 << 9;
#line 691
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c___4 << 8;
#line 691
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 691
                  a <<= 1;
#line 691
                  c <<= 1;
#line 691
                  __cil_tmp61 = ct;
#line 691
                  ct --;
#line 691
                  if (! (a < 32768U)) {
#line 691
                    goto while_break___6;
                  }
                }
                while_break___26: /* CIL Label */ ;
                }
                while_break___6: ;
              } else {
#line 691
                v = (*curctx)->mps;
              }
            }
#line 691
            if (v) {
              {
#line 691
              __cil_tmp63 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )1);
#line 691
              lu___0 = __cil_tmp63;
#line 691
              __cil_tmp65 = opj_t1_getctxno_sc(lu___0);
#line 691
              ctxt2___0 = (OPJ_UINT32 )__cil_tmp65;
#line 691
              __cil_tmp67 = opj_t1_getspb(lu___0);
#line 691
              spb___0 = (OPJ_UINT32 )__cil_tmp67;
#line 691
              curctx = & mqc->ctxs[ctxt2___0];
#line 691
              a -= (*curctx)->qeval;
              }
#line 691
              if (c >> 16 < (*curctx)->qeval) {
#line 691
                if (a < (*curctx)->qeval) {
#line 691
                  a = (*curctx)->qeval;
#line 691
                  v = (*curctx)->mps;
#line 691
                  *curctx = (*curctx)->nmps;
                } else {
#line 691
                  a = (*curctx)->qeval;
#line 691
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                  *curctx = (*curctx)->nlps;
                }
                {
#line 691
                while (1) {
                  while_continue___7: /* CIL Label */ ;

#line 691
                  if (ct == 0U) {
#line 691
                    l_c___5 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                    if ((int )*(mqc->bp) == 255) {
#line 691
                      if (l_c___5 > 143U) {
#line 691
                        c += 65280U;
#line 691
                        ct = (OPJ_UINT32 )8;
#line 691
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___5 << 9;
#line 691
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c___5 << 8;
#line 691
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 691
                  a <<= 1;
#line 691
                  c <<= 1;
#line 691
                  __cil_tmp72 = ct;
#line 691
                  ct --;
#line 691
                  if (! (a < 32768U)) {
#line 691
                    goto while_break___7;
                  }
                }
                while_break___27: /* CIL Label */ ;
                }
                while_break___7: ;
              } else {
#line 691
                c -= (*curctx)->qeval << 16;
#line 691
                if ((a & 32768U) == 0U) {
#line 691
                  if (a < (*curctx)->qeval) {
#line 691
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                    *curctx = (*curctx)->nlps;
                  } else {
#line 691
                    v = (*curctx)->mps;
#line 691
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 691
                  while (1) {
                    while_continue___8: /* CIL Label */ ;

#line 691
                    if (ct == 0U) {
#line 691
                      l_c___6 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                      if ((int )*(mqc->bp) == 255) {
#line 691
                        if (l_c___6 > 143U) {
#line 691
                          c += 65280U;
#line 691
                          ct = (OPJ_UINT32 )8;
#line 691
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 691
                          (mqc->bp) ++;
#line 691
                          c += l_c___6 << 9;
#line 691
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___6 << 8;
#line 691
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 691
                    a <<= 1;
#line 691
                    c <<= 1;
#line 691
                    __cil_tmp77 = ct;
#line 691
                    ct --;
#line 691
                    if (! (a < 32768U)) {
#line 691
                      goto while_break___8;
                    }
                  }
                  while_break___28: /* CIL Label */ ;
                  }
                  while_break___8: ;
                } else {
#line 691
                  v = (*curctx)->mps;
                }
              }
#line 691
              v ^= spb___0;
#line 691
              if (v) {
#line 691
                tmp___0 = - oneplushalf;
              } else {
#line 691
                tmp___0 = oneplushalf;
              }
#line 691
              *(data + l_w) = tmp___0;
#line 691
              *(flagsp + -1) |= (1U << 5) << 3U;
#line 691
              flags |= ((v << 19) | (1U << 4)) << 3U;
#line 691
              *(flagsp + 1) |= (1U << 3) << 3U;
            }
#line 691
            flags |= (1U << 21) << 3U;
          }
        }
#line 691
        if ((flags & (((1U << 4) | (1U << 21)) << 6U)) == 0U) {
#line 691
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 6U)) != 0U) {
            {
#line 691
            __cil_tmp82 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 691
            ctxt1___1 = (OPJ_UINT32 )__cil_tmp82;
#line 691
            curctx = & mqc->ctxs[ctxt1___1];
#line 691
            a -= (*curctx)->qeval;
            }
#line 691
            if (c >> 16 < (*curctx)->qeval) {
#line 691
              if (a < (*curctx)->qeval) {
#line 691
                a = (*curctx)->qeval;
#line 691
                v = (*curctx)->mps;
#line 691
                *curctx = (*curctx)->nmps;
              } else {
#line 691
                a = (*curctx)->qeval;
#line 691
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                *curctx = (*curctx)->nlps;
              }
              {
#line 691
              while (1) {
                while_continue___9: /* CIL Label */ ;

#line 691
                if (ct == 0U) {
#line 691
                  l_c___7 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                  if ((int )*(mqc->bp) == 255) {
#line 691
                    if (l_c___7 > 143U) {
#line 691
                      c += 65280U;
#line 691
                      ct = (OPJ_UINT32 )8;
#line 691
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c___7 << 9;
#line 691
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 691
                    (mqc->bp) ++;
#line 691
                    c += l_c___7 << 8;
#line 691
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 691
                a <<= 1;
#line 691
                c <<= 1;
#line 691
                __cil_tmp87 = ct;
#line 691
                ct --;
#line 691
                if (! (a < 32768U)) {
#line 691
                  goto while_break___9;
                }
              }
              while_break___29: /* CIL Label */ ;
              }
              while_break___9: ;
            } else {
#line 691
              c -= (*curctx)->qeval << 16;
#line 691
              if ((a & 32768U) == 0U) {
#line 691
                if (a < (*curctx)->qeval) {
#line 691
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                  *curctx = (*curctx)->nlps;
                } else {
#line 691
                  v = (*curctx)->mps;
#line 691
                  *curctx = (*curctx)->nmps;
                }
                {
#line 691
                while (1) {
                  while_continue___10: /* CIL Label */ ;

#line 691
                  if (ct == 0U) {
#line 691
                    l_c___8 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                    if ((int )*(mqc->bp) == 255) {
#line 691
                      if (l_c___8 > 143U) {
#line 691
                        c += 65280U;
#line 691
                        ct = (OPJ_UINT32 )8;
#line 691
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___8 << 9;
#line 691
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c___8 << 8;
#line 691
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 691
                  a <<= 1;
#line 691
                  c <<= 1;
#line 691
                  __cil_tmp92 = ct;
#line 691
                  ct --;
#line 691
                  if (! (a < 32768U)) {
#line 691
                    goto while_break___10;
                  }
                }
                while_break___30: /* CIL Label */ ;
                }
                while_break___10: ;
              } else {
#line 691
                v = (*curctx)->mps;
              }
            }
#line 691
            if (v) {
              {
#line 691
              __cil_tmp94 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                             *(flagsp + 1), (OPJ_UINT32 )2);
#line 691
              lu___1 = __cil_tmp94;
#line 691
              __cil_tmp96 = opj_t1_getctxno_sc(lu___1);
#line 691
              ctxt2___1 = (OPJ_UINT32 )__cil_tmp96;
#line 691
              __cil_tmp98 = opj_t1_getspb(lu___1);
#line 691
              spb___1 = (OPJ_UINT32 )__cil_tmp98;
#line 691
              curctx = & mqc->ctxs[ctxt2___1];
#line 691
              a -= (*curctx)->qeval;
              }
#line 691
              if (c >> 16 < (*curctx)->qeval) {
#line 691
                if (a < (*curctx)->qeval) {
#line 691
                  a = (*curctx)->qeval;
#line 691
                  v = (*curctx)->mps;
#line 691
                  *curctx = (*curctx)->nmps;
                } else {
#line 691
                  a = (*curctx)->qeval;
#line 691
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                  *curctx = (*curctx)->nlps;
                }
                {
#line 691
                while (1) {
                  while_continue___11: /* CIL Label */ ;

#line 691
                  if (ct == 0U) {
#line 691
                    l_c___9 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                    if ((int )*(mqc->bp) == 255) {
#line 691
                      if (l_c___9 > 143U) {
#line 691
                        c += 65280U;
#line 691
                        ct = (OPJ_UINT32 )8;
#line 691
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___9 << 9;
#line 691
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c___9 << 8;
#line 691
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 691
                  a <<= 1;
#line 691
                  c <<= 1;
#line 691
                  __cil_tmp103 = ct;
#line 691
                  ct --;
#line 691
                  if (! (a < 32768U)) {
#line 691
                    goto while_break___11;
                  }
                }
                while_break___31: /* CIL Label */ ;
                }
                while_break___11: ;
              } else {
#line 691
                c -= (*curctx)->qeval << 16;
#line 691
                if ((a & 32768U) == 0U) {
#line 691
                  if (a < (*curctx)->qeval) {
#line 691
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                    *curctx = (*curctx)->nlps;
                  } else {
#line 691
                    v = (*curctx)->mps;
#line 691
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 691
                  while (1) {
                    while_continue___12: /* CIL Label */ ;

#line 691
                    if (ct == 0U) {
#line 691
                      l_c___10 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                      if ((int )*(mqc->bp) == 255) {
#line 691
                        if (l_c___10 > 143U) {
#line 691
                          c += 65280U;
#line 691
                          ct = (OPJ_UINT32 )8;
#line 691
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 691
                          (mqc->bp) ++;
#line 691
                          c += l_c___10 << 9;
#line 691
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___10 << 8;
#line 691
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 691
                    a <<= 1;
#line 691
                    c <<= 1;
#line 691
                    __cil_tmp108 = ct;
#line 691
                    ct --;
#line 691
                    if (! (a < 32768U)) {
#line 691
                      goto while_break___12;
                    }
                  }
                  while_break___32: /* CIL Label */ ;
                  }
                  while_break___12: ;
                } else {
#line 691
                  v = (*curctx)->mps;
                }
              }
#line 691
              v ^= spb___1;
#line 691
              if (v) {
#line 691
                tmp___1 = - oneplushalf;
              } else {
#line 691
                tmp___1 = oneplushalf;
              }
#line 691
              *(data + 2U * l_w) = tmp___1;
#line 691
              *(flagsp + -1) |= (1U << 5) << 6U;
#line 691
              flags |= ((v << 19) | (1U << 4)) << 6U;
#line 691
              *(flagsp + 1) |= (1U << 3) << 6U;
            }
#line 691
            flags |= (1U << 21) << 6U;
          }
        }
#line 691
        if ((flags & (((1U << 4) | (1U << 21)) << 9U)) == 0U) {
#line 691
          if ((flags & ((((((((1U | (1U << 1)) | (1U << 2)) | (1U << 3)) | (1U << 5)) | (1U << 6)) | (1U << 7)) | (1U << 8)) << 9U)) != 0U) {
            {
#line 691
            __cil_tmp113 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 691
            ctxt1___2 = (OPJ_UINT32 )__cil_tmp113;
#line 691
            curctx = & mqc->ctxs[ctxt1___2];
#line 691
            a -= (*curctx)->qeval;
            }
#line 691
            if (c >> 16 < (*curctx)->qeval) {
#line 691
              if (a < (*curctx)->qeval) {
#line 691
                a = (*curctx)->qeval;
#line 691
                v = (*curctx)->mps;
#line 691
                *curctx = (*curctx)->nmps;
              } else {
#line 691
                a = (*curctx)->qeval;
#line 691
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                *curctx = (*curctx)->nlps;
              }
              {
#line 691
              while (1) {
                while_continue___13: /* CIL Label */ ;

#line 691
                if (ct == 0U) {
#line 691
                  l_c___11 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                  if ((int )*(mqc->bp) == 255) {
#line 691
                    if (l_c___11 > 143U) {
#line 691
                      c += 65280U;
#line 691
                      ct = (OPJ_UINT32 )8;
#line 691
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c___11 << 9;
#line 691
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 691
                    (mqc->bp) ++;
#line 691
                    c += l_c___11 << 8;
#line 691
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 691
                a <<= 1;
#line 691
                c <<= 1;
#line 691
                __cil_tmp118 = ct;
#line 691
                ct --;
#line 691
                if (! (a < 32768U)) {
#line 691
                  goto while_break___13;
                }
              }
              while_break___33: /* CIL Label */ ;
              }
              while_break___13: ;
            } else {
#line 691
              c -= (*curctx)->qeval << 16;
#line 691
              if ((a & 32768U) == 0U) {
#line 691
                if (a < (*curctx)->qeval) {
#line 691
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                  *curctx = (*curctx)->nlps;
                } else {
#line 691
                  v = (*curctx)->mps;
#line 691
                  *curctx = (*curctx)->nmps;
                }
                {
#line 691
                while (1) {
                  while_continue___14: /* CIL Label */ ;

#line 691
                  if (ct == 0U) {
#line 691
                    l_c___12 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                    if ((int )*(mqc->bp) == 255) {
#line 691
                      if (l_c___12 > 143U) {
#line 691
                        c += 65280U;
#line 691
                        ct = (OPJ_UINT32 )8;
#line 691
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___12 << 9;
#line 691
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c___12 << 8;
#line 691
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 691
                  a <<= 1;
#line 691
                  c <<= 1;
#line 691
                  __cil_tmp123 = ct;
#line 691
                  ct --;
#line 691
                  if (! (a < 32768U)) {
#line 691
                    goto while_break___14;
                  }
                }
                while_break___34: /* CIL Label */ ;
                }
                while_break___14: ;
              } else {
#line 691
                v = (*curctx)->mps;
              }
            }
#line 691
            if (v) {
              {
#line 691
              __cil_tmp125 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                              *(flagsp + 1), (OPJ_UINT32 )3);
#line 691
              lu___2 = __cil_tmp125;
#line 691
              __cil_tmp127 = opj_t1_getctxno_sc(lu___2);
#line 691
              ctxt2___2 = (OPJ_UINT32 )__cil_tmp127;
#line 691
              __cil_tmp129 = opj_t1_getspb(lu___2);
#line 691
              spb___2 = (OPJ_UINT32 )__cil_tmp129;
#line 691
              curctx = & mqc->ctxs[ctxt2___2];
#line 691
              a -= (*curctx)->qeval;
              }
#line 691
              if (c >> 16 < (*curctx)->qeval) {
#line 691
                if (a < (*curctx)->qeval) {
#line 691
                  a = (*curctx)->qeval;
#line 691
                  v = (*curctx)->mps;
#line 691
                  *curctx = (*curctx)->nmps;
                } else {
#line 691
                  a = (*curctx)->qeval;
#line 691
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                  *curctx = (*curctx)->nlps;
                }
                {
#line 691
                while (1) {
                  while_continue___15: /* CIL Label */ ;

#line 691
                  if (ct == 0U) {
#line 691
                    l_c___13 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                    if ((int )*(mqc->bp) == 255) {
#line 691
                      if (l_c___13 > 143U) {
#line 691
                        c += 65280U;
#line 691
                        ct = (OPJ_UINT32 )8;
#line 691
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___13 << 9;
#line 691
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 691
                      (mqc->bp) ++;
#line 691
                      c += l_c___13 << 8;
#line 691
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 691
                  a <<= 1;
#line 691
                  c <<= 1;
#line 691
                  __cil_tmp134 = ct;
#line 691
                  ct --;
#line 691
                  if (! (a < 32768U)) {
#line 691
                    goto while_break___15;
                  }
                }
                while_break___35: /* CIL Label */ ;
                }
                while_break___15: ;
              } else {
#line 691
                c -= (*curctx)->qeval << 16;
#line 691
                if ((a & 32768U) == 0U) {
#line 691
                  if (a < (*curctx)->qeval) {
#line 691
                    v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 691
                    *curctx = (*curctx)->nlps;
                  } else {
#line 691
                    v = (*curctx)->mps;
#line 691
                    *curctx = (*curctx)->nmps;
                  }
                  {
#line 691
                  while (1) {
                    while_continue___16: /* CIL Label */ ;

#line 691
                    if (ct == 0U) {
#line 691
                      l_c___14 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 691
                      if ((int )*(mqc->bp) == 255) {
#line 691
                        if (l_c___14 > 143U) {
#line 691
                          c += 65280U;
#line 691
                          ct = (OPJ_UINT32 )8;
#line 691
                          (mqc->end_of_byte_stream_counter) ++;
                        } else {
#line 691
                          (mqc->bp) ++;
#line 691
                          c += l_c___14 << 9;
#line 691
                          ct = (OPJ_UINT32 )7;
                        }
                      } else {
#line 691
                        (mqc->bp) ++;
#line 691
                        c += l_c___14 << 8;
#line 691
                        ct = (OPJ_UINT32 )8;
                      }
                    }
#line 691
                    a <<= 1;
#line 691
                    c <<= 1;
#line 691
                    __cil_tmp139 = ct;
#line 691
                    ct --;
#line 691
                    if (! (a < 32768U)) {
#line 691
                      goto while_break___16;
                    }
                  }
                  while_break___36: /* CIL Label */ ;
                  }
                  while_break___16: ;
                } else {
#line 691
                  v = (*curctx)->mps;
                }
              }
#line 691
              v ^= spb___2;
#line 691
              if (v) {
#line 691
                tmp___2 = - oneplushalf;
              } else {
#line 691
                tmp___2 = oneplushalf;
              }
#line 691
              *(data + 3U * l_w) = tmp___2;
#line 691
              *(flagsp + -1) |= (1U << 5) << 9U;
#line 691
              flags |= ((v << 19) | (1U << 4)) << 9U;
#line 691
              *(flagsp + 1) |= (1U << 3) << 9U;
#line 691
              south___2 = flagsp + (t1->w + 2U);
#line 691
              *south___2 |= (v << 18) | (1U << 1);
#line 691
              *(south___2 + -1) |= 1U << 2;
#line 691
              *(south___2 + 1) |= 1U;
            }
#line 691
            flags |= (1U << 21) << 9U;
          }
        }
#line 691
        *flagsp = flags;
      }
#line 691
      flagsp ++;
#line 691
      data ++;
#line 691
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___0: 
#line 691
    flagsp += 2;
#line 691
    data += 3U * l_w;
#line 691
    k += 4U;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break: 
#line 691
  mqc->curctx = curctx;
#line 691
  mqc->c = c;
#line 691
  mqc->a = a;
#line 691
  mqc->ct = ct;
#line 691
  if (k < t1->h) {
#line 691
    i = (OPJ_UINT32 )0;
    {
#line 691
    while (1) {
      while_continue___17: /* CIL Label */ ;

#line 691
      if (! (i < l_w)) {
#line 691
        goto while_break___17;
      }
#line 691
      j = (OPJ_UINT32 )0;
      {
#line 691
      while (1) {
        while_continue___18: /* CIL Label */ ;

#line 691
        if (! (j < t1->h - k)) {
#line 691
          goto while_break___18;
        }
        {
#line 691
        opj_t1_dec_sigpass_step_mqc(t1, flagsp, data + j * l_w, oneplushalf, j, t1->w + 2U,
                                    (OPJ_UINT32 )1);
#line 691
        j ++;
        }
      }
      while_break___38: /* CIL Label */ ;
      }
      while_break___18: 
#line 691
      flagsp ++;
#line 691
      data ++;
#line 691
      i ++;
    }
    while_break___37: /* CIL Label */ ;
    }
    while_break___17: ;
  }
#line 697
  return;
}
}
#line 695 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_sigpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 cblksty ) 
{ 


  {
#line 700
  if (t1->w == 64U) {
#line 700
    if (t1->h == 64U) {
#line 701
      if (cblksty & 8) {
        {
#line 702
        opj_t1_dec_sigpass_mqc_64x64_vsc(t1, bpno);
        }
      } else {
        {
#line 704
        opj_t1_dec_sigpass_mqc_64x64_novsc(t1, bpno);
        }
      }
    } else {
#line 700
      goto _L;
    }
  } else
  _L: 
#line 707
  if (cblksty & 8) {
    {
#line 708
    opj_t1_dec_sigpass_mqc_generic_vsc(t1, bpno);
    }
  } else {
    {
#line 710
    opj_t1_dec_sigpass_mqc_generic_novsc(t1, bpno);
    }
  }
#line 713
  return;
}
}
#line 718 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static void opj_t1_enc_refpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                             OPJ_INT32 bpno , OPJ_INT32 one , OPJ_INT32 *nmsedec ,
                                             OPJ_BYTE type , OPJ_UINT32 ci ) 
{ 
  OPJ_UINT32 v ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 shift_flags ;
  OPJ_UINT32 ctxt ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT16 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  int tmp ;

  {
#line 729
  mqc = & t1->mqc;
#line 731
  shift_flags = *flagsp >> ci * 3U;
#line 734
  if ((shift_flags & ((1U << 4) | (1U << 21))) == 1U << 4) {
    {
#line 735
    __cil_tmp13 = opj_t1_getctxno_mag(shift_flags);
#line 735
    ctxt = __cil_tmp13;
#line 736
    __cil_tmp14 = opj_int_abs(*datap);
#line 736
    __cil_tmp15 = opj_t1_getnmsedec_ref((OPJ_UINT32 )__cil_tmp14, (OPJ_UINT32 )bpno);
#line 736
    *nmsedec += (int )__cil_tmp15;
#line 738
    __cil_tmp16 = opj_int_abs(*datap);
    }
#line 738
    if (__cil_tmp16 & one) {
#line 738
      tmp = 1;
    } else {
#line 738
      tmp = 0;
    }
#line 738
    v = (OPJ_UINT32 )tmp;
#line 742
    mqc->curctx = & mqc->ctxs[ctxt];
#line 743
    if ((int )type == 1) {
      {
#line 744
      opj_mqc_bypass_enc(mqc, v);
      }
    } else {
      {
#line 746
      opj_mqc_encode(mqc, v);
      }
    }
#line 748
    *flagsp |= (1U << 20) << ci * 3U;
  }
#line 750
  return;
}
}
#line 753 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static void opj_t1_dec_refpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 poshalf ,
                                                 OPJ_UINT32 ci ) 
{ 
  OPJ_UINT32 v ;
  opj_mqc_t *mqc ;
  OPJ_INT32 tmp ;

  {
#line 762
  mqc = & t1->mqc;
#line 764
  if ((*flagsp & (((1U << 4) | (1U << 21)) << ci * 3U)) == (1U << 4) << ci * 3U) {
    {
#line 766
    v = opj_mqc_raw_decode(mqc);
    }
#line 767
    if (v ^ (unsigned int )(*datap < 0)) {
#line 767
      tmp = poshalf;
    } else {
#line 767
      tmp = - poshalf;
    }
#line 767
    *datap += tmp;
#line 768
    *flagsp |= (1U << 20) << ci * 3U;
  }
#line 770
  return;
}
}
#line 785 "/root/patron/new_24/src/lib/openjp2/t1.c"
__inline static void opj_t1_dec_refpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 poshalf ,
                                                 OPJ_UINT32 ci ) 
{ 
  OPJ_UINT32 v ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 ctxt ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_INT32 tmp ;

  {
#line 794
  mqc = & t1->mqc;
#line 795
  if ((*flagsp & (((1U << 4) | (1U << 21)) << ci * 3U)) == (1U << 4) << ci * 3U) {
    {
#line 795
    __cil_tmp9 = opj_t1_getctxno_mag(*flagsp >> ci * 3U);
#line 795
    ctxt = __cil_tmp9;
#line 795
    mqc->curctx = & mqc->ctxs[ctxt];
#line 795
    mqc->a -= (*(mqc->curctx))->qeval;
    }
#line 795
    if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
#line 795
      if (mqc->a < (*(mqc->curctx))->qeval) {
#line 795
        mqc->a = (*(mqc->curctx))->qeval;
#line 795
        v = (*(mqc->curctx))->mps;
#line 795
        *(mqc->curctx) = (*(mqc->curctx))->nmps;
      } else {
#line 795
        mqc->a = (*(mqc->curctx))->qeval;
#line 795
        v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 795
        *(mqc->curctx) = (*(mqc->curctx))->nlps;
      }
      {
#line 795
      while (1) {
        while_continue: /* CIL Label */ ;

#line 795
        if (mqc->ct == 0U) {
#line 795
          l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 795
          if ((int )*(mqc->bp) == 255) {
#line 795
            if (l_c > 143U) {
#line 795
              mqc->c += 65280U;
#line 795
              mqc->ct = (OPJ_UINT32 )8;
#line 795
              (mqc->end_of_byte_stream_counter) ++;
            } else {
#line 795
              (mqc->bp) ++;
#line 795
              mqc->c += l_c << 9;
#line 795
              mqc->ct = (OPJ_UINT32 )7;
            }
          } else {
#line 795
            (mqc->bp) ++;
#line 795
            mqc->c += l_c << 8;
#line 795
            mqc->ct = (OPJ_UINT32 )8;
          }
        }
#line 795
        mqc->a <<= 1;
#line 795
        mqc->c <<= 1;
#line 795
        __cil_tmp14 = mqc->ct;
#line 795
        (mqc->ct) --;
#line 795
        if (! (mqc->a < 32768U)) {
#line 795
          goto while_break;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 795
      mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 795
      if ((mqc->a & 32768U) == 0U) {
#line 795
        if (mqc->a < (*(mqc->curctx))->qeval) {
#line 795
          v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 795
          *(mqc->curctx) = (*(mqc->curctx))->nlps;
        } else {
#line 795
          v = (*(mqc->curctx))->mps;
#line 795
          *(mqc->curctx) = (*(mqc->curctx))->nmps;
        }
        {
#line 795
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 795
          if (mqc->ct == 0U) {
#line 795
            l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 795
            if ((int )*(mqc->bp) == 255) {
#line 795
              if (l_c___0 > 143U) {
#line 795
                mqc->c += 65280U;
#line 795
                mqc->ct = (OPJ_UINT32 )8;
#line 795
                (mqc->end_of_byte_stream_counter) ++;
              } else {
#line 795
                (mqc->bp) ++;
#line 795
                mqc->c += l_c___0 << 9;
#line 795
                mqc->ct = (OPJ_UINT32 )7;
              }
            } else {
#line 795
              (mqc->bp) ++;
#line 795
              mqc->c += l_c___0 << 8;
#line 795
              mqc->ct = (OPJ_UINT32 )8;
            }
          }
#line 795
          mqc->a <<= 1;
#line 795
          mqc->c <<= 1;
#line 795
          __cil_tmp19 = mqc->ct;
#line 795
          (mqc->ct) --;
#line 795
          if (! (mqc->a < 32768U)) {
#line 795
            goto while_break___0;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
      } else {
#line 795
        v = (*(mqc->curctx))->mps;
      }
    }
#line 795
    if (v ^ (unsigned int )(*(datap + 0U) < 0)) {
#line 795
      tmp = poshalf;
    } else {
#line 795
      tmp = - poshalf;
    }
#line 795
    *(datap + 0U) += tmp;
#line 795
    *flagsp |= (1U << 20) << ci * 3U;
  }
#line 798
  return;
}
}
#line 800 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_enc_refpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec ,
                               OPJ_BYTE type ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 k ;
  OPJ_INT32 one ;
  opj_flag_t *f ;
  OPJ_UINT32 extra ;
  OPJ_UINT32 j ;

  {
#line 807
  one = 1 << (bpno + 6);
#line 808
  f = t1->flags + (1U + (t1->w + 2U));
#line 809
  extra = 2U;
#line 811
  *nmsedec = 0;
#line 815
  k = (OPJ_UINT32 )0;
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;

#line 815
    if (! (k < (t1->h & 4294967292U))) {
#line 815
      goto while_break;
    }
#line 819
    i = (OPJ_UINT32 )0;
    {
#line 819
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: ;
#line 819
      if (! (i < t1->w)) {
#line 819
        goto while_break___0;
      }
#line 823
      if ((*f & ((((1U << 4) | (1U << 7)) | (1U << 10)) | (1U << 13))) == 0U) {
#line 825
        f ++;
#line 826
        goto while_continue___0;
      }
#line 828
      if ((*f & ((((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30))) == ((((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30))) {
#line 831
        f ++;
#line 832
        goto while_continue___0;
      }
      {
#line 835
      opj_t1_enc_refpass_step(t1, f, t1->data + (k * t1->data_stride + i), bpno, one,
                              nmsedec, type, (OPJ_UINT32 )0);
#line 844
      opj_t1_enc_refpass_step(t1, f, t1->data + ((k + 1U) * t1->data_stride + i),
                              bpno, one, nmsedec, type, (OPJ_UINT32 )1);
#line 853
      opj_t1_enc_refpass_step(t1, f, t1->data + ((k + 2U) * t1->data_stride + i),
                              bpno, one, nmsedec, type, (OPJ_UINT32 )2);
#line 862
      opj_t1_enc_refpass_step(t1, f, t1->data + ((k + 3U) * t1->data_stride + i),
                              bpno, one, nmsedec, type, (OPJ_UINT32 )3);
#line 871
      f ++;
#line 819
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 873
    f += extra;
#line 815
    k += 4U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 876
  if (k < t1->h) {
#line 881
    i = (OPJ_UINT32 )0;
    {
#line 881
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___1: ;
#line 881
      if (! (i < t1->w)) {
#line 881
        goto while_break___1;
      }
#line 885
      if ((*f & ((((1U << 4) | (1U << 7)) | (1U << 10)) | (1U << 13))) == 0U) {
#line 887
        f ++;
#line 888
        goto while_continue___1;
      }
#line 890
      j = k;
      {
#line 890
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 890
        if (! (j < t1->h)) {
#line 890
          goto while_break___2;
        }
        {
#line 891
        opj_t1_enc_refpass_step(t1, f, t1->data + (j * t1->data_stride + i), bpno,
                                one, nmsedec, type, j - k);
#line 890
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 901
      f ++;
#line 881
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 886
  return;
}
}
#line 907 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_refpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 *data ;
  opj_flag_t *flagsp ;
  OPJ_UINT32 l_w ;
  opj_flag_t flags ;

  {
#line 913
  data = t1->data;
#line 914
  flagsp = t1->flags + (1U + (t1->w + 2U));
#line 915
  l_w = t1->w;
#line 916
  one = 1 << bpno;
#line 917
  poshalf = one >> 1;
#line 918
  k = (OPJ_UINT32 )0;
  {
#line 918
  while (1) {
    while_continue: /* CIL Label */ ;

#line 918
    if (! (k < (t1->h & 4294967292U))) {
#line 918
      goto while_break;
    }
#line 919
    i = (OPJ_UINT32 )0;
    {
#line 919
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 919
      if (! (i < l_w)) {
#line 919
        goto while_break___0;
      }
#line 920
      flags = *flagsp;
#line 921
      if (flags != 0U) {
        {
#line 922
        opj_t1_dec_refpass_step_raw(t1, flagsp, data, poshalf, 0U);
#line 928
        opj_t1_dec_refpass_step_raw(t1, flagsp, data + l_w, poshalf, 1U);
#line 934
        opj_t1_dec_refpass_step_raw(t1, flagsp, data + 2U * l_w, poshalf, 2U);
#line 940
        opj_t1_dec_refpass_step_raw(t1, flagsp, data + 3U * l_w, poshalf, 3U);
        }
      }
#line 919
      data ++;
#line 919
      flagsp ++;
#line 919
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 918
    data += 3U * l_w;
#line 918
    flagsp += 2;
#line 918
    k += 4U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 949
  if (k < t1->h) {
#line 950
    i = (OPJ_UINT32 )0;
    {
#line 950
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 950
      if (! (i < l_w)) {
#line 950
        goto while_break___1;
      }
#line 951
      j = (OPJ_UINT32 )0;
      {
#line 951
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 951
        if (! (j < t1->h - k)) {
#line 951
          goto while_break___2;
        }
        {
#line 952
        opj_t1_dec_refpass_step_raw(t1, flagsp, data + j * l_w, poshalf, j);
#line 951
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 950
      data ++;
#line 950
      flagsp ++;
#line 950
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 955
  return;
}
}
#line 1005 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_refpass_mqc_64x64(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  register OPJ_INT32 *data ;
  register opj_flag_t *flagsp ;
  OPJ_UINT32 l_w ;
  opj_mqc_t *mqc ;
  register opj_mqc_state_t **curctx ;
  register OPJ_UINT32 c ;
  register OPJ_UINT32 a ;
  register OPJ_UINT32 ct ;
  register OPJ_UINT32 v ;
  opj_flag_t flags ;
  OPJ_UINT32 ctxt ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_INT32 tmp ;
  OPJ_UINT32 ctxt___0 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp37 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp42 ;
  OPJ_INT32 tmp___0 ;
  OPJ_UINT32 ctxt___1 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 l_c___3 ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 l_c___4 ;
  OPJ_UINT32 __cil_tmp55 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 ctxt___2 ;
  OPJ_UINT32 __cil_tmp58 ;
  OPJ_UINT32 l_c___5 ;
  OPJ_UINT32 __cil_tmp63 ;
  OPJ_UINT32 l_c___6 ;
  OPJ_UINT32 __cil_tmp68 ;
  OPJ_INT32 tmp___2 ;

  {
#line 1009
  data = t1->data;
#line 1009
  flagsp = t1->flags + 67;
#line 1009
  l_w = (OPJ_UINT32 )64;
#line 1009
  mqc = & t1->mqc;
#line 1009
  curctx = mqc->curctx;
#line 1009
  c = mqc->c;
#line 1009
  a = mqc->a;
#line 1009
  ct = mqc->ct;
#line 1009
  one = 1 << bpno;
#line 1009
  poshalf = one >> 1;
#line 1009
  k = (OPJ_UINT32 )0;
  {
#line 1009
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1009
    if (! (k < 64U)) {
#line 1009
      goto while_break;
    }
#line 1009
    i = (OPJ_UINT32 )0;
    {
#line 1009
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1009
      if (! (i < l_w)) {
#line 1009
        goto while_break___0;
      }
#line 1009
      flags = *flagsp;
#line 1009
      if (flags != 0U) {
#line 1009
        if ((flags & ((1U << 4) | (1U << 21))) == 1U << 4) {
          {
#line 1009
          __cil_tmp19 = opj_t1_getctxno_mag(flags);
#line 1009
          ctxt = __cil_tmp19;
#line 1009
          curctx = & mqc->ctxs[ctxt];
#line 1009
          a -= (*curctx)->qeval;
          }
#line 1009
          if (c >> 16 < (*curctx)->qeval) {
#line 1009
            if (a < (*curctx)->qeval) {
#line 1009
              a = (*curctx)->qeval;
#line 1009
              v = (*curctx)->mps;
#line 1009
              *curctx = (*curctx)->nmps;
            } else {
#line 1009
              a = (*curctx)->qeval;
#line 1009
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1009
              *curctx = (*curctx)->nlps;
            }
            {
#line 1009
            while (1) {
              while_continue___1: /* CIL Label */ ;

#line 1009
              if (ct == 0U) {
#line 1009
                l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1009
                if ((int )*(mqc->bp) == 255) {
#line 1009
                  if (l_c > 143U) {
#line 1009
                    c += 65280U;
#line 1009
                    ct = (OPJ_UINT32 )8;
#line 1009
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1009
                    (mqc->bp) ++;
#line 1009
                    c += l_c << 9;
#line 1009
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1009
                  (mqc->bp) ++;
#line 1009
                  c += l_c << 8;
#line 1009
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1009
              a <<= 1;
#line 1009
              c <<= 1;
#line 1009
              __cil_tmp24 = ct;
#line 1009
              ct --;
#line 1009
              if (! (a < 32768U)) {
#line 1009
                goto while_break___1;
              }
            }
            while_break___13: /* CIL Label */ ;
            }
            while_break___1: ;
          } else {
#line 1009
            c -= (*curctx)->qeval << 16;
#line 1009
            if ((a & 32768U) == 0U) {
#line 1009
              if (a < (*curctx)->qeval) {
#line 1009
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1009
                *curctx = (*curctx)->nlps;
              } else {
#line 1009
                v = (*curctx)->mps;
#line 1009
                *curctx = (*curctx)->nmps;
              }
              {
#line 1009
              while (1) {
                while_continue___2: /* CIL Label */ ;

#line 1009
                if (ct == 0U) {
#line 1009
                  l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1009
                  if ((int )*(mqc->bp) == 255) {
#line 1009
                    if (l_c___0 > 143U) {
#line 1009
                      c += 65280U;
#line 1009
                      ct = (OPJ_UINT32 )8;
#line 1009
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1009
                      (mqc->bp) ++;
#line 1009
                      c += l_c___0 << 9;
#line 1009
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1009
                    (mqc->bp) ++;
#line 1009
                    c += l_c___0 << 8;
#line 1009
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1009
                a <<= 1;
#line 1009
                c <<= 1;
#line 1009
                __cil_tmp29 = ct;
#line 1009
                ct --;
#line 1009
                if (! (a < 32768U)) {
#line 1009
                  goto while_break___2;
                }
              }
              while_break___14: /* CIL Label */ ;
              }
              while_break___2: ;
            } else {
#line 1009
              v = (*curctx)->mps;
            }
          }
#line 1009
          if (v ^ (unsigned int )(*(data + 0U) < 0)) {
#line 1009
            tmp = poshalf;
          } else {
#line 1009
            tmp = - poshalf;
          }
#line 1009
          *(data + 0U) += tmp;
#line 1009
          flags |= 1U << 20;
        }
#line 1009
        if ((flags & (((1U << 4) | (1U << 21)) << 3U)) == (1U << 4) << 3U) {
          {
#line 1009
          __cil_tmp32 = opj_t1_getctxno_mag(flags >> 3U);
#line 1009
          ctxt___0 = __cil_tmp32;
#line 1009
          curctx = & mqc->ctxs[ctxt___0];
#line 1009
          a -= (*curctx)->qeval;
          }
#line 1009
          if (c >> 16 < (*curctx)->qeval) {
#line 1009
            if (a < (*curctx)->qeval) {
#line 1009
              a = (*curctx)->qeval;
#line 1009
              v = (*curctx)->mps;
#line 1009
              *curctx = (*curctx)->nmps;
            } else {
#line 1009
              a = (*curctx)->qeval;
#line 1009
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1009
              *curctx = (*curctx)->nlps;
            }
            {
#line 1009
            while (1) {
              while_continue___3: /* CIL Label */ ;

#line 1009
              if (ct == 0U) {
#line 1009
                l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1009
                if ((int )*(mqc->bp) == 255) {
#line 1009
                  if (l_c___1 > 143U) {
#line 1009
                    c += 65280U;
#line 1009
                    ct = (OPJ_UINT32 )8;
#line 1009
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1009
                    (mqc->bp) ++;
#line 1009
                    c += l_c___1 << 9;
#line 1009
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1009
                  (mqc->bp) ++;
#line 1009
                  c += l_c___1 << 8;
#line 1009
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1009
              a <<= 1;
#line 1009
              c <<= 1;
#line 1009
              __cil_tmp37 = ct;
#line 1009
              ct --;
#line 1009
              if (! (a < 32768U)) {
#line 1009
                goto while_break___3;
              }
            }
            while_break___15: /* CIL Label */ ;
            }
            while_break___3: ;
          } else {
#line 1009
            c -= (*curctx)->qeval << 16;
#line 1009
            if ((a & 32768U) == 0U) {
#line 1009
              if (a < (*curctx)->qeval) {
#line 1009
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1009
                *curctx = (*curctx)->nlps;
              } else {
#line 1009
                v = (*curctx)->mps;
#line 1009
                *curctx = (*curctx)->nmps;
              }
              {
#line 1009
              while (1) {
                while_continue___4: /* CIL Label */ ;

#line 1009
                if (ct == 0U) {
#line 1009
                  l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1009
                  if ((int )*(mqc->bp) == 255) {
#line 1009
                    if (l_c___2 > 143U) {
#line 1009
                      c += 65280U;
#line 1009
                      ct = (OPJ_UINT32 )8;
#line 1009
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1009
                      (mqc->bp) ++;
#line 1009
                      c += l_c___2 << 9;
#line 1009
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1009
                    (mqc->bp) ++;
#line 1009
                    c += l_c___2 << 8;
#line 1009
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1009
                a <<= 1;
#line 1009
                c <<= 1;
#line 1009
                __cil_tmp42 = ct;
#line 1009
                ct --;
#line 1009
                if (! (a < 32768U)) {
#line 1009
                  goto while_break___4;
                }
              }
              while_break___16: /* CIL Label */ ;
              }
              while_break___4: ;
            } else {
#line 1009
              v = (*curctx)->mps;
            }
          }
#line 1009
          if (v ^ (unsigned int )(*(data + l_w) < 0)) {
#line 1009
            tmp___0 = poshalf;
          } else {
#line 1009
            tmp___0 = - poshalf;
          }
#line 1009
          *(data + l_w) += tmp___0;
#line 1009
          flags |= (1U << 20) << 3U;
        }
#line 1009
        if ((flags & (((1U << 4) | (1U << 21)) << 6U)) == (1U << 4) << 6U) {
          {
#line 1009
          __cil_tmp45 = opj_t1_getctxno_mag(flags >> 6U);
#line 1009
          ctxt___1 = __cil_tmp45;
#line 1009
          curctx = & mqc->ctxs[ctxt___1];
#line 1009
          a -= (*curctx)->qeval;
          }
#line 1009
          if (c >> 16 < (*curctx)->qeval) {
#line 1009
            if (a < (*curctx)->qeval) {
#line 1009
              a = (*curctx)->qeval;
#line 1009
              v = (*curctx)->mps;
#line 1009
              *curctx = (*curctx)->nmps;
            } else {
#line 1009
              a = (*curctx)->qeval;
#line 1009
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1009
              *curctx = (*curctx)->nlps;
            }
            {
#line 1009
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 1009
              if (ct == 0U) {
#line 1009
                l_c___3 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1009
                if ((int )*(mqc->bp) == 255) {
#line 1009
                  if (l_c___3 > 143U) {
#line 1009
                    c += 65280U;
#line 1009
                    ct = (OPJ_UINT32 )8;
#line 1009
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1009
                    (mqc->bp) ++;
#line 1009
                    c += l_c___3 << 9;
#line 1009
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1009
                  (mqc->bp) ++;
#line 1009
                  c += l_c___3 << 8;
#line 1009
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1009
              a <<= 1;
#line 1009
              c <<= 1;
#line 1009
              __cil_tmp50 = ct;
#line 1009
              ct --;
#line 1009
              if (! (a < 32768U)) {
#line 1009
                goto while_break___5;
              }
            }
            while_break___17: /* CIL Label */ ;
            }
            while_break___5: ;
          } else {
#line 1009
            c -= (*curctx)->qeval << 16;
#line 1009
            if ((a & 32768U) == 0U) {
#line 1009
              if (a < (*curctx)->qeval) {
#line 1009
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1009
                *curctx = (*curctx)->nlps;
              } else {
#line 1009
                v = (*curctx)->mps;
#line 1009
                *curctx = (*curctx)->nmps;
              }
              {
#line 1009
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 1009
                if (ct == 0U) {
#line 1009
                  l_c___4 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1009
                  if ((int )*(mqc->bp) == 255) {
#line 1009
                    if (l_c___4 > 143U) {
#line 1009
                      c += 65280U;
#line 1009
                      ct = (OPJ_UINT32 )8;
#line 1009
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1009
                      (mqc->bp) ++;
#line 1009
                      c += l_c___4 << 9;
#line 1009
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1009
                    (mqc->bp) ++;
#line 1009
                    c += l_c___4 << 8;
#line 1009
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1009
                a <<= 1;
#line 1009
                c <<= 1;
#line 1009
                __cil_tmp55 = ct;
#line 1009
                ct --;
#line 1009
                if (! (a < 32768U)) {
#line 1009
                  goto while_break___6;
                }
              }
              while_break___18: /* CIL Label */ ;
              }
              while_break___6: ;
            } else {
#line 1009
              v = (*curctx)->mps;
            }
          }
#line 1009
          if (v ^ (unsigned int )(*(data + 2U * l_w) < 0)) {
#line 1009
            tmp___1 = poshalf;
          } else {
#line 1009
            tmp___1 = - poshalf;
          }
#line 1009
          *(data + 2U * l_w) += tmp___1;
#line 1009
          flags |= (1U << 20) << 6U;
        }
#line 1009
        if ((flags & (((1U << 4) | (1U << 21)) << 9U)) == (1U << 4) << 9U) {
          {
#line 1009
          __cil_tmp58 = opj_t1_getctxno_mag(flags >> 9U);
#line 1009
          ctxt___2 = __cil_tmp58;
#line 1009
          curctx = & mqc->ctxs[ctxt___2];
#line 1009
          a -= (*curctx)->qeval;
          }
#line 1009
          if (c >> 16 < (*curctx)->qeval) {
#line 1009
            if (a < (*curctx)->qeval) {
#line 1009
              a = (*curctx)->qeval;
#line 1009
              v = (*curctx)->mps;
#line 1009
              *curctx = (*curctx)->nmps;
            } else {
#line 1009
              a = (*curctx)->qeval;
#line 1009
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1009
              *curctx = (*curctx)->nlps;
            }
            {
#line 1009
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 1009
              if (ct == 0U) {
#line 1009
                l_c___5 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1009
                if ((int )*(mqc->bp) == 255) {
#line 1009
                  if (l_c___5 > 143U) {
#line 1009
                    c += 65280U;
#line 1009
                    ct = (OPJ_UINT32 )8;
#line 1009
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1009
                    (mqc->bp) ++;
#line 1009
                    c += l_c___5 << 9;
#line 1009
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1009
                  (mqc->bp) ++;
#line 1009
                  c += l_c___5 << 8;
#line 1009
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1009
              a <<= 1;
#line 1009
              c <<= 1;
#line 1009
              __cil_tmp63 = ct;
#line 1009
              ct --;
#line 1009
              if (! (a < 32768U)) {
#line 1009
                goto while_break___7;
              }
            }
            while_break___19: /* CIL Label */ ;
            }
            while_break___7: ;
          } else {
#line 1009
            c -= (*curctx)->qeval << 16;
#line 1009
            if ((a & 32768U) == 0U) {
#line 1009
              if (a < (*curctx)->qeval) {
#line 1009
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1009
                *curctx = (*curctx)->nlps;
              } else {
#line 1009
                v = (*curctx)->mps;
#line 1009
                *curctx = (*curctx)->nmps;
              }
              {
#line 1009
              while (1) {
                while_continue___8: /* CIL Label */ ;

#line 1009
                if (ct == 0U) {
#line 1009
                  l_c___6 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1009
                  if ((int )*(mqc->bp) == 255) {
#line 1009
                    if (l_c___6 > 143U) {
#line 1009
                      c += 65280U;
#line 1009
                      ct = (OPJ_UINT32 )8;
#line 1009
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1009
                      (mqc->bp) ++;
#line 1009
                      c += l_c___6 << 9;
#line 1009
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1009
                    (mqc->bp) ++;
#line 1009
                    c += l_c___6 << 8;
#line 1009
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1009
                a <<= 1;
#line 1009
                c <<= 1;
#line 1009
                __cil_tmp68 = ct;
#line 1009
                ct --;
#line 1009
                if (! (a < 32768U)) {
#line 1009
                  goto while_break___8;
                }
              }
              while_break___20: /* CIL Label */ ;
              }
              while_break___8: ;
            } else {
#line 1009
              v = (*curctx)->mps;
            }
          }
#line 1009
          if (v ^ (unsigned int )(*(data + 3U * l_w) < 0)) {
#line 1009
            tmp___2 = poshalf;
          } else {
#line 1009
            tmp___2 = - poshalf;
          }
#line 1009
          *(data + 3U * l_w) += tmp___2;
#line 1009
          flags |= (1U << 20) << 9U;
        }
#line 1009
        *flagsp = flags;
      }
#line 1009
      flagsp ++;
#line 1009
      data ++;
#line 1009
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___0: 
#line 1009
    flagsp += 2;
#line 1009
    data += 3U * l_w;
#line 1009
    k += 4U;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break: 
#line 1009
  mqc->curctx = curctx;
#line 1009
  mqc->c = c;
#line 1009
  mqc->a = a;
#line 1009
  mqc->ct = ct;
#line 1009
  if (k < 64U) {
#line 1009
    i = (OPJ_UINT32 )0;
    {
#line 1009
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 1009
      if (! (i < l_w)) {
#line 1009
        goto while_break___9;
      }
#line 1009
      j = (OPJ_UINT32 )0;
      {
#line 1009
      while (1) {
        while_continue___10: /* CIL Label */ ;

#line 1009
        if (! (j < 64U - k)) {
#line 1009
          goto while_break___10;
        }
        {
#line 1009
        opj_t1_dec_refpass_step_mqc(t1, flagsp, data + j * l_w, poshalf, j);
#line 1009
        j ++;
        }
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___10: 
#line 1009
      flagsp ++;
#line 1009
      data ++;
#line 1009
      i ++;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___9: ;
  }
#line 1015
  return;
}
}
#line 1012 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_refpass_mqc_generic(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  register OPJ_INT32 *data ;
  register opj_flag_t *flagsp ;
  OPJ_UINT32 l_w ;
  opj_mqc_t *mqc ;
  register opj_mqc_state_t **curctx ;
  register OPJ_UINT32 c ;
  register OPJ_UINT32 a ;
  register OPJ_UINT32 ct ;
  register OPJ_UINT32 v ;
  opj_flag_t flags ;
  OPJ_UINT32 ctxt ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_INT32 tmp ;
  OPJ_UINT32 ctxt___0 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp37 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp42 ;
  OPJ_INT32 tmp___0 ;
  OPJ_UINT32 ctxt___1 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 l_c___3 ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 l_c___4 ;
  OPJ_UINT32 __cil_tmp55 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 ctxt___2 ;
  OPJ_UINT32 __cil_tmp58 ;
  OPJ_UINT32 l_c___5 ;
  OPJ_UINT32 __cil_tmp63 ;
  OPJ_UINT32 l_c___6 ;
  OPJ_UINT32 __cil_tmp68 ;
  OPJ_INT32 tmp___2 ;

  {
#line 1016
  data = t1->data;
#line 1016
  flagsp = t1->flags + ((t1->w + 2U) + 1U);
#line 1016
  l_w = t1->w;
#line 1016
  mqc = & t1->mqc;
#line 1016
  curctx = mqc->curctx;
#line 1016
  c = mqc->c;
#line 1016
  a = mqc->a;
#line 1016
  ct = mqc->ct;
#line 1016
  one = 1 << bpno;
#line 1016
  poshalf = one >> 1;
#line 1016
  k = (OPJ_UINT32 )0;
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1016
    if (! (k < (t1->h & 4294967292U))) {
#line 1016
      goto while_break;
    }
#line 1016
    i = (OPJ_UINT32 )0;
    {
#line 1016
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1016
      if (! (i < l_w)) {
#line 1016
        goto while_break___0;
      }
#line 1016
      flags = *flagsp;
#line 1016
      if (flags != 0U) {
#line 1016
        if ((flags & ((1U << 4) | (1U << 21))) == 1U << 4) {
          {
#line 1016
          __cil_tmp19 = opj_t1_getctxno_mag(flags);
#line 1016
          ctxt = __cil_tmp19;
#line 1016
          curctx = & mqc->ctxs[ctxt];
#line 1016
          a -= (*curctx)->qeval;
          }
#line 1016
          if (c >> 16 < (*curctx)->qeval) {
#line 1016
            if (a < (*curctx)->qeval) {
#line 1016
              a = (*curctx)->qeval;
#line 1016
              v = (*curctx)->mps;
#line 1016
              *curctx = (*curctx)->nmps;
            } else {
#line 1016
              a = (*curctx)->qeval;
#line 1016
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1016
              *curctx = (*curctx)->nlps;
            }
            {
#line 1016
            while (1) {
              while_continue___1: /* CIL Label */ ;

#line 1016
              if (ct == 0U) {
#line 1016
                l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1016
                if ((int )*(mqc->bp) == 255) {
#line 1016
                  if (l_c > 143U) {
#line 1016
                    c += 65280U;
#line 1016
                    ct = (OPJ_UINT32 )8;
#line 1016
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1016
                    (mqc->bp) ++;
#line 1016
                    c += l_c << 9;
#line 1016
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1016
                  (mqc->bp) ++;
#line 1016
                  c += l_c << 8;
#line 1016
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1016
              a <<= 1;
#line 1016
              c <<= 1;
#line 1016
              __cil_tmp24 = ct;
#line 1016
              ct --;
#line 1016
              if (! (a < 32768U)) {
#line 1016
                goto while_break___1;
              }
            }
            while_break___13: /* CIL Label */ ;
            }
            while_break___1: ;
          } else {
#line 1016
            c -= (*curctx)->qeval << 16;
#line 1016
            if ((a & 32768U) == 0U) {
#line 1016
              if (a < (*curctx)->qeval) {
#line 1016
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1016
                *curctx = (*curctx)->nlps;
              } else {
#line 1016
                v = (*curctx)->mps;
#line 1016
                *curctx = (*curctx)->nmps;
              }
              {
#line 1016
              while (1) {
                while_continue___2: /* CIL Label */ ;

#line 1016
                if (ct == 0U) {
#line 1016
                  l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1016
                  if ((int )*(mqc->bp) == 255) {
#line 1016
                    if (l_c___0 > 143U) {
#line 1016
                      c += 65280U;
#line 1016
                      ct = (OPJ_UINT32 )8;
#line 1016
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1016
                      (mqc->bp) ++;
#line 1016
                      c += l_c___0 << 9;
#line 1016
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1016
                    (mqc->bp) ++;
#line 1016
                    c += l_c___0 << 8;
#line 1016
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1016
                a <<= 1;
#line 1016
                c <<= 1;
#line 1016
                __cil_tmp29 = ct;
#line 1016
                ct --;
#line 1016
                if (! (a < 32768U)) {
#line 1016
                  goto while_break___2;
                }
              }
              while_break___14: /* CIL Label */ ;
              }
              while_break___2: ;
            } else {
#line 1016
              v = (*curctx)->mps;
            }
          }
#line 1016
          if (v ^ (unsigned int )(*(data + 0U) < 0)) {
#line 1016
            tmp = poshalf;
          } else {
#line 1016
            tmp = - poshalf;
          }
#line 1016
          *(data + 0U) += tmp;
#line 1016
          flags |= 1U << 20;
        }
#line 1016
        if ((flags & (((1U << 4) | (1U << 21)) << 3U)) == (1U << 4) << 3U) {
          {
#line 1016
          __cil_tmp32 = opj_t1_getctxno_mag(flags >> 3U);
#line 1016
          ctxt___0 = __cil_tmp32;
#line 1016
          curctx = & mqc->ctxs[ctxt___0];
#line 1016
          a -= (*curctx)->qeval;
          }
#line 1016
          if (c >> 16 < (*curctx)->qeval) {
#line 1016
            if (a < (*curctx)->qeval) {
#line 1016
              a = (*curctx)->qeval;
#line 1016
              v = (*curctx)->mps;
#line 1016
              *curctx = (*curctx)->nmps;
            } else {
#line 1016
              a = (*curctx)->qeval;
#line 1016
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1016
              *curctx = (*curctx)->nlps;
            }
            {
#line 1016
            while (1) {
              while_continue___3: /* CIL Label */ ;

#line 1016
              if (ct == 0U) {
#line 1016
                l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1016
                if ((int )*(mqc->bp) == 255) {
#line 1016
                  if (l_c___1 > 143U) {
#line 1016
                    c += 65280U;
#line 1016
                    ct = (OPJ_UINT32 )8;
#line 1016
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1016
                    (mqc->bp) ++;
#line 1016
                    c += l_c___1 << 9;
#line 1016
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1016
                  (mqc->bp) ++;
#line 1016
                  c += l_c___1 << 8;
#line 1016
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1016
              a <<= 1;
#line 1016
              c <<= 1;
#line 1016
              __cil_tmp37 = ct;
#line 1016
              ct --;
#line 1016
              if (! (a < 32768U)) {
#line 1016
                goto while_break___3;
              }
            }
            while_break___15: /* CIL Label */ ;
            }
            while_break___3: ;
          } else {
#line 1016
            c -= (*curctx)->qeval << 16;
#line 1016
            if ((a & 32768U) == 0U) {
#line 1016
              if (a < (*curctx)->qeval) {
#line 1016
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1016
                *curctx = (*curctx)->nlps;
              } else {
#line 1016
                v = (*curctx)->mps;
#line 1016
                *curctx = (*curctx)->nmps;
              }
              {
#line 1016
              while (1) {
                while_continue___4: /* CIL Label */ ;

#line 1016
                if (ct == 0U) {
#line 1016
                  l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1016
                  if ((int )*(mqc->bp) == 255) {
#line 1016
                    if (l_c___2 > 143U) {
#line 1016
                      c += 65280U;
#line 1016
                      ct = (OPJ_UINT32 )8;
#line 1016
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1016
                      (mqc->bp) ++;
#line 1016
                      c += l_c___2 << 9;
#line 1016
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1016
                    (mqc->bp) ++;
#line 1016
                    c += l_c___2 << 8;
#line 1016
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1016
                a <<= 1;
#line 1016
                c <<= 1;
#line 1016
                __cil_tmp42 = ct;
#line 1016
                ct --;
#line 1016
                if (! (a < 32768U)) {
#line 1016
                  goto while_break___4;
                }
              }
              while_break___16: /* CIL Label */ ;
              }
              while_break___4: ;
            } else {
#line 1016
              v = (*curctx)->mps;
            }
          }
#line 1016
          if (v ^ (unsigned int )(*(data + l_w) < 0)) {
#line 1016
            tmp___0 = poshalf;
          } else {
#line 1016
            tmp___0 = - poshalf;
          }
#line 1016
          *(data + l_w) += tmp___0;
#line 1016
          flags |= (1U << 20) << 3U;
        }
#line 1016
        if ((flags & (((1U << 4) | (1U << 21)) << 6U)) == (1U << 4) << 6U) {
          {
#line 1016
          __cil_tmp45 = opj_t1_getctxno_mag(flags >> 6U);
#line 1016
          ctxt___1 = __cil_tmp45;
#line 1016
          curctx = & mqc->ctxs[ctxt___1];
#line 1016
          a -= (*curctx)->qeval;
          }
#line 1016
          if (c >> 16 < (*curctx)->qeval) {
#line 1016
            if (a < (*curctx)->qeval) {
#line 1016
              a = (*curctx)->qeval;
#line 1016
              v = (*curctx)->mps;
#line 1016
              *curctx = (*curctx)->nmps;
            } else {
#line 1016
              a = (*curctx)->qeval;
#line 1016
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1016
              *curctx = (*curctx)->nlps;
            }
            {
#line 1016
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 1016
              if (ct == 0U) {
#line 1016
                l_c___3 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1016
                if ((int )*(mqc->bp) == 255) {
#line 1016
                  if (l_c___3 > 143U) {
#line 1016
                    c += 65280U;
#line 1016
                    ct = (OPJ_UINT32 )8;
#line 1016
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1016
                    (mqc->bp) ++;
#line 1016
                    c += l_c___3 << 9;
#line 1016
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1016
                  (mqc->bp) ++;
#line 1016
                  c += l_c___3 << 8;
#line 1016
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1016
              a <<= 1;
#line 1016
              c <<= 1;
#line 1016
              __cil_tmp50 = ct;
#line 1016
              ct --;
#line 1016
              if (! (a < 32768U)) {
#line 1016
                goto while_break___5;
              }
            }
            while_break___17: /* CIL Label */ ;
            }
            while_break___5: ;
          } else {
#line 1016
            c -= (*curctx)->qeval << 16;
#line 1016
            if ((a & 32768U) == 0U) {
#line 1016
              if (a < (*curctx)->qeval) {
#line 1016
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1016
                *curctx = (*curctx)->nlps;
              } else {
#line 1016
                v = (*curctx)->mps;
#line 1016
                *curctx = (*curctx)->nmps;
              }
              {
#line 1016
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 1016
                if (ct == 0U) {
#line 1016
                  l_c___4 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1016
                  if ((int )*(mqc->bp) == 255) {
#line 1016
                    if (l_c___4 > 143U) {
#line 1016
                      c += 65280U;
#line 1016
                      ct = (OPJ_UINT32 )8;
#line 1016
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1016
                      (mqc->bp) ++;
#line 1016
                      c += l_c___4 << 9;
#line 1016
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1016
                    (mqc->bp) ++;
#line 1016
                    c += l_c___4 << 8;
#line 1016
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1016
                a <<= 1;
#line 1016
                c <<= 1;
#line 1016
                __cil_tmp55 = ct;
#line 1016
                ct --;
#line 1016
                if (! (a < 32768U)) {
#line 1016
                  goto while_break___6;
                }
              }
              while_break___18: /* CIL Label */ ;
              }
              while_break___6: ;
            } else {
#line 1016
              v = (*curctx)->mps;
            }
          }
#line 1016
          if (v ^ (unsigned int )(*(data + 2U * l_w) < 0)) {
#line 1016
            tmp___1 = poshalf;
          } else {
#line 1016
            tmp___1 = - poshalf;
          }
#line 1016
          *(data + 2U * l_w) += tmp___1;
#line 1016
          flags |= (1U << 20) << 6U;
        }
#line 1016
        if ((flags & (((1U << 4) | (1U << 21)) << 9U)) == (1U << 4) << 9U) {
          {
#line 1016
          __cil_tmp58 = opj_t1_getctxno_mag(flags >> 9U);
#line 1016
          ctxt___2 = __cil_tmp58;
#line 1016
          curctx = & mqc->ctxs[ctxt___2];
#line 1016
          a -= (*curctx)->qeval;
          }
#line 1016
          if (c >> 16 < (*curctx)->qeval) {
#line 1016
            if (a < (*curctx)->qeval) {
#line 1016
              a = (*curctx)->qeval;
#line 1016
              v = (*curctx)->mps;
#line 1016
              *curctx = (*curctx)->nmps;
            } else {
#line 1016
              a = (*curctx)->qeval;
#line 1016
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1016
              *curctx = (*curctx)->nlps;
            }
            {
#line 1016
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 1016
              if (ct == 0U) {
#line 1016
                l_c___5 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1016
                if ((int )*(mqc->bp) == 255) {
#line 1016
                  if (l_c___5 > 143U) {
#line 1016
                    c += 65280U;
#line 1016
                    ct = (OPJ_UINT32 )8;
#line 1016
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1016
                    (mqc->bp) ++;
#line 1016
                    c += l_c___5 << 9;
#line 1016
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1016
                  (mqc->bp) ++;
#line 1016
                  c += l_c___5 << 8;
#line 1016
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1016
              a <<= 1;
#line 1016
              c <<= 1;
#line 1016
              __cil_tmp63 = ct;
#line 1016
              ct --;
#line 1016
              if (! (a < 32768U)) {
#line 1016
                goto while_break___7;
              }
            }
            while_break___19: /* CIL Label */ ;
            }
            while_break___7: ;
          } else {
#line 1016
            c -= (*curctx)->qeval << 16;
#line 1016
            if ((a & 32768U) == 0U) {
#line 1016
              if (a < (*curctx)->qeval) {
#line 1016
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1016
                *curctx = (*curctx)->nlps;
              } else {
#line 1016
                v = (*curctx)->mps;
#line 1016
                *curctx = (*curctx)->nmps;
              }
              {
#line 1016
              while (1) {
                while_continue___8: /* CIL Label */ ;

#line 1016
                if (ct == 0U) {
#line 1016
                  l_c___6 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1016
                  if ((int )*(mqc->bp) == 255) {
#line 1016
                    if (l_c___6 > 143U) {
#line 1016
                      c += 65280U;
#line 1016
                      ct = (OPJ_UINT32 )8;
#line 1016
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1016
                      (mqc->bp) ++;
#line 1016
                      c += l_c___6 << 9;
#line 1016
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1016
                    (mqc->bp) ++;
#line 1016
                    c += l_c___6 << 8;
#line 1016
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1016
                a <<= 1;
#line 1016
                c <<= 1;
#line 1016
                __cil_tmp68 = ct;
#line 1016
                ct --;
#line 1016
                if (! (a < 32768U)) {
#line 1016
                  goto while_break___8;
                }
              }
              while_break___20: /* CIL Label */ ;
              }
              while_break___8: ;
            } else {
#line 1016
              v = (*curctx)->mps;
            }
          }
#line 1016
          if (v ^ (unsigned int )(*(data + 3U * l_w) < 0)) {
#line 1016
            tmp___2 = poshalf;
          } else {
#line 1016
            tmp___2 = - poshalf;
          }
#line 1016
          *(data + 3U * l_w) += tmp___2;
#line 1016
          flags |= (1U << 20) << 9U;
        }
#line 1016
        *flagsp = flags;
      }
#line 1016
      flagsp ++;
#line 1016
      data ++;
#line 1016
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___0: 
#line 1016
    flagsp += 2;
#line 1016
    data += 3U * l_w;
#line 1016
    k += 4U;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break: 
#line 1016
  mqc->curctx = curctx;
#line 1016
  mqc->c = c;
#line 1016
  mqc->a = a;
#line 1016
  mqc->ct = ct;
#line 1016
  if (k < t1->h) {
#line 1016
    i = (OPJ_UINT32 )0;
    {
#line 1016
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 1016
      if (! (i < l_w)) {
#line 1016
        goto while_break___9;
      }
#line 1016
      j = (OPJ_UINT32 )0;
      {
#line 1016
      while (1) {
        while_continue___10: /* CIL Label */ ;

#line 1016
        if (! (j < t1->h - k)) {
#line 1016
          goto while_break___10;
        }
        {
#line 1016
        opj_t1_dec_refpass_step_mqc(t1, flagsp, data + j * l_w, poshalf, j);
#line 1016
        j ++;
        }
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___10: 
#line 1016
      flagsp ++;
#line 1016
      data ++;
#line 1016
      i ++;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___9: ;
  }
#line 1022
  return;
}
}
#line 1019 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_refpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 


  {
#line 1023
  if (t1->w == 64U) {
#line 1023
    if (t1->h == 64U) {
      {
#line 1024
      opj_t1_dec_refpass_mqc_64x64(t1, bpno);
      }
    } else {
      {
#line 1026
      opj_t1_dec_refpass_mqc_generic(t1, bpno);
      }
    }
  } else {
    {
#line 1026
    opj_t1_dec_refpass_mqc_generic(t1, bpno);
    }
  }
#line 1030
  return;
}
}
#line 1033 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_enc_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                    OPJ_INT32 bpno , OPJ_INT32 one , OPJ_INT32 *nmsedec ,
                                    OPJ_UINT32 agg , OPJ_UINT32 runlen , OPJ_UINT32 lim ,
                                    OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 v ;
  OPJ_UINT32 ci ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 check ;
  OPJ_UINT32 vsc ;
  opj_flag_t flags ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  int tmp ;
  OPJ_UINT32 ctxt2 ;
  OPJ_UINT32 spb ;
  OPJ_UINT32 lu ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT16 __cil_tmp26 ;
  OPJ_BYTE __cil_tmp27 ;
  unsigned int tmp___0 ;
  OPJ_BYTE __cil_tmp29 ;
  int tmp___1 ;

  {
#line 1047
  mqc = & t1->mqc;
#line 1049
  check = (((((((1U << 4) | (1U << 7)) | (1U << 10)) | (1U << 13)) | (1U << 21)) | (1U << 24)) | (1U << 27)) | (1U << 30);
#line 1052
  if ((*flagsp & check) == check) {
#line 1053
    if (runlen == 0U) {
#line 1054
      *flagsp &= ~ ((((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30));
    } else
#line 1055
    if (runlen == 1U) {
#line 1056
      *flagsp &= ~ (((1U << 24) | (1U << 27)) | (1U << 30));
    } else
#line 1057
    if (runlen == 2U) {
#line 1058
      *flagsp &= ~ ((1U << 27) | (1U << 30));
    } else
#line 1059
    if (runlen == 3U) {
#line 1060
      *flagsp &= ~ (1U << 30);
    }
#line 1062
    return;
  }
#line 1065
  ci = runlen;
  {
#line 1065
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1065
    if (! (ci < lim)) {
#line 1065
      goto while_break;
    }
#line 1069
    flags = *flagsp;
#line 1071
    if (agg != 0U) {
#line 1071
      if (ci == runlen) {
#line 1072
        goto LABEL_PARTIAL;
      }
    }
#line 1075
    if (! (flags & (((1U << 4) | (1U << 21)) << ci * 3U))) {
      {
#line 1076
      __cil_tmp18 = opj_t1_getctxno_zc(mqc, flags >> ci * 3U);
#line 1076
      ctxt1 = (OPJ_UINT32 )__cil_tmp18;
#line 1080
      mqc->curctx = & mqc->ctxs[ctxt1];
#line 1081
      __cil_tmp19 = opj_int_abs(*datap);
      }
#line 1081
      if (__cil_tmp19 & one) {
#line 1081
        tmp = 1;
      } else {
#line 1081
        tmp = 0;
      }
      {
#line 1081
      v = (OPJ_UINT32 )tmp;
#line 1082
      opj_mqc_encode(mqc, v);
      }
#line 1083
      if (v) {
        LABEL_PARTIAL: 
        {
#line 1087
        lu = opj_t1_getctxtno_sc_or_spb_index(*flagsp, *(flagsp + -1), *(flagsp + 1),
                                              ci);
#line 1091
        __cil_tmp25 = opj_int_abs(*datap);
#line 1091
        __cil_tmp26 = opj_t1_getnmsedec_sig((OPJ_UINT32 )__cil_tmp25, (OPJ_UINT32 )bpno);
#line 1091
        *nmsedec += (int )__cil_tmp26;
#line 1093
        __cil_tmp27 = opj_t1_getctxno_sc(lu);
#line 1093
        ctxt2 = (OPJ_UINT32 )__cil_tmp27;
#line 1097
        mqc->curctx = & mqc->ctxs[ctxt2];
        }
#line 1099
        if (*datap < 0) {
#line 1099
          tmp___0 = 1U;
        } else {
#line 1099
          tmp___0 = 0U;
        }
        {
#line 1099
        v = tmp___0;
#line 1100
        __cil_tmp29 = opj_t1_getspb(lu);
#line 1100
        spb = (OPJ_UINT32 )__cil_tmp29;
#line 1104
        opj_mqc_encode(mqc, v ^ spb);
        }
#line 1105
        if (cblksty & 8U) {
#line 1105
          if (ci == 0U) {
#line 1105
            tmp___1 = 1;
          } else {
#line 1105
            tmp___1 = 0;
          }
        } else {
#line 1105
          tmp___1 = 0;
        }
        {
#line 1105
        vsc = (OPJ_UINT32 )tmp___1;
#line 1106
        opj_t1_update_flags(flagsp, ci, v, t1->w + 2U, vsc);
        }
      }
    }
#line 1109
    *flagsp &= ~ ((1U << 21) << 3U * ci);
#line 1110
    datap += t1->data_stride;
#line 1065
    ci ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1069
  return;
}
}
#line 1142 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                    OPJ_INT32 oneplushalf , OPJ_UINT32 ci , OPJ_UINT32 vsc ) 
{ 
  OPJ_UINT32 v ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp10 ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_UINT32 lu ;
  OPJ_UINT32 __cil_tmp22 ;
  OPJ_BYTE __cil_tmp23 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_BYTE __cil_tmp34 ;
  OPJ_INT32 tmp ;
  opj_flag_t *north ;
  opj_flag_t *south ;

  {
#line 1152
  mqc = & t1->mqc;
#line 1153
  if (! (*flagsp & (((1U << 4) | (1U << 21)) << ci * 3U))) {
    {
#line 1153
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1153
      __cil_tmp10 = opj_t1_getctxno_zc(mqc, *flagsp >> ci * 3U);
#line 1153
      ctxt1 = (OPJ_UINT32 )__cil_tmp10;
#line 1153
      mqc->curctx = & mqc->ctxs[ctxt1];
#line 1153
      mqc->a -= (*(mqc->curctx))->qeval;
      }
#line 1153
      if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
#line 1153
        if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1153
          mqc->a = (*(mqc->curctx))->qeval;
#line 1153
          v = (*(mqc->curctx))->mps;
#line 1153
          *(mqc->curctx) = (*(mqc->curctx))->nmps;
        } else {
#line 1153
          mqc->a = (*(mqc->curctx))->qeval;
#line 1153
          v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1153
          *(mqc->curctx) = (*(mqc->curctx))->nlps;
        }
        {
#line 1153
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 1153
          if (mqc->ct == 0U) {
#line 1153
            l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1153
            if ((int )*(mqc->bp) == 255) {
#line 1153
              if (l_c > 143U) {
#line 1153
                mqc->c += 65280U;
#line 1153
                mqc->ct = (OPJ_UINT32 )8;
#line 1153
                (mqc->end_of_byte_stream_counter) ++;
              } else {
#line 1153
                (mqc->bp) ++;
#line 1153
                mqc->c += l_c << 9;
#line 1153
                mqc->ct = (OPJ_UINT32 )7;
              }
            } else {
#line 1153
              (mqc->bp) ++;
#line 1153
              mqc->c += l_c << 8;
#line 1153
              mqc->ct = (OPJ_UINT32 )8;
            }
          }
#line 1153
          mqc->a <<= 1;
#line 1153
          mqc->c <<= 1;
#line 1153
          __cil_tmp15 = mqc->ct;
#line 1153
          (mqc->ct) --;
#line 1153
          if (! (mqc->a < 32768U)) {
#line 1153
            goto while_break___0;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___0: ;
      } else {
#line 1153
        mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 1153
        if ((mqc->a & 32768U) == 0U) {
#line 1153
          if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1153
            v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1153
            *(mqc->curctx) = (*(mqc->curctx))->nlps;
          } else {
#line 1153
            v = (*(mqc->curctx))->mps;
#line 1153
            *(mqc->curctx) = (*(mqc->curctx))->nmps;
          }
          {
#line 1153
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 1153
            if (mqc->ct == 0U) {
#line 1153
              l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1153
              if ((int )*(mqc->bp) == 255) {
#line 1153
                if (l_c___0 > 143U) {
#line 1153
                  mqc->c += 65280U;
#line 1153
                  mqc->ct = (OPJ_UINT32 )8;
#line 1153
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1153
                  (mqc->bp) ++;
#line 1153
                  mqc->c += l_c___0 << 9;
#line 1153
                  mqc->ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1153
                (mqc->bp) ++;
#line 1153
                mqc->c += l_c___0 << 8;
#line 1153
                mqc->ct = (OPJ_UINT32 )8;
              }
            }
#line 1153
            mqc->a <<= 1;
#line 1153
            mqc->c <<= 1;
#line 1153
            __cil_tmp20 = mqc->ct;
#line 1153
            (mqc->ct) --;
#line 1153
            if (! (mqc->a < 32768U)) {
#line 1153
              goto while_break___1;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          while_break___1: ;
        } else {
#line 1153
          v = (*(mqc->curctx))->mps;
        }
      }
#line 1153
      if (! v) {
#line 1153
        goto while_break;
      }
      {
#line 1153
      __cil_tmp22 = opj_t1_getctxtno_sc_or_spb_index(*flagsp, *(flagsp + -1), *(flagsp + 1),
                                                     ci);
#line 1153
      lu = __cil_tmp22;
#line 1153
      __cil_tmp23 = opj_t1_getctxno_sc(lu);
#line 1153
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp23];
#line 1153
      mqc->a -= (*(mqc->curctx))->qeval;
      }
#line 1153
      if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
#line 1153
        if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1153
          mqc->a = (*(mqc->curctx))->qeval;
#line 1153
          v = (*(mqc->curctx))->mps;
#line 1153
          *(mqc->curctx) = (*(mqc->curctx))->nmps;
        } else {
#line 1153
          mqc->a = (*(mqc->curctx))->qeval;
#line 1153
          v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1153
          *(mqc->curctx) = (*(mqc->curctx))->nlps;
        }
        {
#line 1153
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1153
          if (mqc->ct == 0U) {
#line 1153
            l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1153
            if ((int )*(mqc->bp) == 255) {
#line 1153
              if (l_c___1 > 143U) {
#line 1153
                mqc->c += 65280U;
#line 1153
                mqc->ct = (OPJ_UINT32 )8;
#line 1153
                (mqc->end_of_byte_stream_counter) ++;
              } else {
#line 1153
                (mqc->bp) ++;
#line 1153
                mqc->c += l_c___1 << 9;
#line 1153
                mqc->ct = (OPJ_UINT32 )7;
              }
            } else {
#line 1153
              (mqc->bp) ++;
#line 1153
              mqc->c += l_c___1 << 8;
#line 1153
              mqc->ct = (OPJ_UINT32 )8;
            }
          }
#line 1153
          mqc->a <<= 1;
#line 1153
          mqc->c <<= 1;
#line 1153
          __cil_tmp28 = mqc->ct;
#line 1153
          (mqc->ct) --;
#line 1153
          if (! (mqc->a < 32768U)) {
#line 1153
            goto while_break___2;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: ;
      } else {
#line 1153
        mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 1153
        if ((mqc->a & 32768U) == 0U) {
#line 1153
          if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1153
            v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1153
            *(mqc->curctx) = (*(mqc->curctx))->nlps;
          } else {
#line 1153
            v = (*(mqc->curctx))->mps;
#line 1153
            *(mqc->curctx) = (*(mqc->curctx))->nmps;
          }
          {
#line 1153
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 1153
            if (mqc->ct == 0U) {
#line 1153
              l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1153
              if ((int )*(mqc->bp) == 255) {
#line 1153
                if (l_c___2 > 143U) {
#line 1153
                  mqc->c += 65280U;
#line 1153
                  mqc->ct = (OPJ_UINT32 )8;
#line 1153
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1153
                  (mqc->bp) ++;
#line 1153
                  mqc->c += l_c___2 << 9;
#line 1153
                  mqc->ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1153
                (mqc->bp) ++;
#line 1153
                mqc->c += l_c___2 << 8;
#line 1153
                mqc->ct = (OPJ_UINT32 )8;
              }
            }
#line 1153
            mqc->a <<= 1;
#line 1153
            mqc->c <<= 1;
#line 1153
            __cil_tmp33 = mqc->ct;
#line 1153
            (mqc->ct) --;
#line 1153
            if (! (mqc->a < 32768U)) {
#line 1153
              goto while_break___3;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: ;
        } else {
#line 1153
          v = (*(mqc->curctx))->mps;
        }
      }
      {
#line 1153
      __cil_tmp34 = opj_t1_getspb(lu);
#line 1153
      v ^= (unsigned int )__cil_tmp34;
      }
#line 1153
      if (v) {
#line 1153
        tmp = - oneplushalf;
      } else {
#line 1153
        tmp = oneplushalf;
      }
#line 1153
      *(datap + 0U) = tmp;
#line 1153
      *(flagsp + -1) |= (1U << 5) << 3U * ci;
#line 1153
      *flagsp |= ((v << 19) | (1U << 4)) << 3U * ci;
#line 1153
      *(flagsp + 1) |= (1U << 3) << 3U * ci;
#line 1153
      if (ci == 0U) {
#line 1153
        if (! vsc) {
#line 1153
          north = flagsp - (t1->w + 2U);
#line 1153
          *north |= (v << 31) | (1U << 16);
#line 1153
          *(north + -1) |= 1U << 17;
#line 1153
          *(north + 1) |= 1U << 15;
        }
      }
#line 1153
      if (ci == 3U) {
#line 1153
        south = flagsp + (t1->w + 2U);
#line 1153
        *south |= (v << 18) | (1U << 1);
#line 1153
        *(south + -1) |= 1U << 2;
#line 1153
        *(south + 1) |= 1U;
      }
#line 1153
      goto while_break;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 1159
  return;
}
}
#line 1159 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_enc_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec ,
                               OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 k ;
  OPJ_INT32 one ;
  OPJ_UINT32 agg ;
  OPJ_UINT32 runlen ;
  opj_mqc_t *mqc ;
  OPJ_INT32 __cil_tmp11 ;

  {
#line 1166
  one = 1 << (bpno + 6);
#line 1169
  mqc = & t1->mqc;
#line 1171
  *nmsedec = 0;
#line 1175
  k = (OPJ_UINT32 )0;
  {
#line 1175
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1175
    if (! (k < (t1->h & 4294967292U))) {
#line 1175
      goto while_break;
    }
#line 1179
    i = (OPJ_UINT32 )0;
    {
#line 1179
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 1179
      if (! (i < t1->w)) {
#line 1179
        goto while_break___0;
      }
#line 1183
      agg = (OPJ_UINT32 )(! *(t1->flags + ((i + 1U) + (k / 4U + 1U) * (t1->w + 2U))));
#line 1187
      if (agg) {
#line 1188
        runlen = (OPJ_UINT32 )0;
        {
#line 1188
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1188
          if (! (runlen < 4U)) {
#line 1188
            goto while_break___1;
          }
          {
#line 1189
          __cil_tmp11 = opj_int_abs(*(t1->data + ((k + runlen) * t1->data_stride + i)));
          }
#line 1189
          if (__cil_tmp11 & one) {
#line 1190
            goto while_break___1;
          }
#line 1188
          runlen ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: 
        {
#line 1193
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 1194
        opj_mqc_encode(mqc, (OPJ_UINT32 )(runlen != 4U));
        }
#line 1195
        if (runlen == 4U) {
#line 1196
          goto while_continue___0;
        }
        {
#line 1198
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1199
        opj_mqc_encode(mqc, runlen >> 1);
#line 1200
        opj_mqc_encode(mqc, runlen & 1U);
        }
      } else {
#line 1202
        runlen = (OPJ_UINT32 )0;
      }
      {
#line 1204
      opj_t1_enc_clnpass_step(t1, t1->flags + ((i + 1U) + (k / 4U + 1U) * (t1->w + 2U)),
                              t1->data + ((k + runlen) * t1->data_stride + i), bpno,
                              one, nmsedec, agg, runlen, 4U, cblksty);
#line 1179
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 1175
    k += 4U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 1217
  if (k < t1->h) {
#line 1218
    agg = (OPJ_UINT32 )0;
#line 1219
    runlen = (OPJ_UINT32 )0;
#line 1223
    i = (OPJ_UINT32 )0;
    {
#line 1223
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1223
      if (! (i < t1->w)) {
#line 1223
        goto while_break___2;
      }
      {
#line 1228
      opj_t1_enc_clnpass_step(t1, t1->flags + ((i + 1U) + (k / 4U + 1U) * (t1->w + 2U)),
                              t1->data + ((k + runlen) * t1->data_stride + i), bpno,
                              one, nmsedec, agg, runlen, t1->h - k, cblksty);
#line 1223
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 1228
  return;
}
}
#line 1332 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_check_segsym(opj_t1_t *t1 , OPJ_INT32 cblksty ) 
{ 
  opj_mqc_t *mqc ;
  OPJ_UINT32 v ;
  OPJ_UINT32 v2 ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 l_c___3 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 l_c___4 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 l_c___5 ;
  OPJ_UINT32 __cil_tmp40 ;
  OPJ_UINT32 l_c___6 ;
  OPJ_UINT32 __cil_tmp45 ;

  {
#line 1334
  if (cblksty & 32) {
#line 1335
    mqc = & t1->mqc;
#line 1337
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1338
    mqc->a -= (*(mqc->curctx))->qeval;
#line 1338
    if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
#line 1338
      if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1338
        mqc->a = (*(mqc->curctx))->qeval;
#line 1338
        v = (*(mqc->curctx))->mps;
#line 1338
        *(mqc->curctx) = (*(mqc->curctx))->nmps;
      } else {
#line 1338
        mqc->a = (*(mqc->curctx))->qeval;
#line 1338
        v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1338
        *(mqc->curctx) = (*(mqc->curctx))->nlps;
      }
      {
#line 1338
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1338
        if (mqc->ct == 0U) {
#line 1338
          l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1338
          if ((int )*(mqc->bp) == 255) {
#line 1338
            if (l_c > 143U) {
#line 1338
              mqc->c += 65280U;
#line 1338
              mqc->ct = (OPJ_UINT32 )8;
#line 1338
              (mqc->end_of_byte_stream_counter) ++;
            } else {
#line 1338
              (mqc->bp) ++;
#line 1338
              mqc->c += l_c << 9;
#line 1338
              mqc->ct = (OPJ_UINT32 )7;
            }
          } else {
#line 1338
            (mqc->bp) ++;
#line 1338
            mqc->c += l_c << 8;
#line 1338
            mqc->ct = (OPJ_UINT32 )8;
          }
        }
#line 1338
        mqc->a <<= 1;
#line 1338
        mqc->c <<= 1;
#line 1338
        __cil_tmp10 = mqc->ct;
#line 1338
        (mqc->ct) --;
#line 1338
        if (! (mqc->a < 32768U)) {
#line 1338
          goto while_break;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 1338
      mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 1338
      if ((mqc->a & 32768U) == 0U) {
#line 1338
        if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1338
          v = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1338
          *(mqc->curctx) = (*(mqc->curctx))->nlps;
        } else {
#line 1338
          v = (*(mqc->curctx))->mps;
#line 1338
          *(mqc->curctx) = (*(mqc->curctx))->nmps;
        }
        {
#line 1338
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 1338
          if (mqc->ct == 0U) {
#line 1338
            l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1338
            if ((int )*(mqc->bp) == 255) {
#line 1338
              if (l_c___0 > 143U) {
#line 1338
                mqc->c += 65280U;
#line 1338
                mqc->ct = (OPJ_UINT32 )8;
#line 1338
                (mqc->end_of_byte_stream_counter) ++;
              } else {
#line 1338
                (mqc->bp) ++;
#line 1338
                mqc->c += l_c___0 << 9;
#line 1338
                mqc->ct = (OPJ_UINT32 )7;
              }
            } else {
#line 1338
              (mqc->bp) ++;
#line 1338
              mqc->c += l_c___0 << 8;
#line 1338
              mqc->ct = (OPJ_UINT32 )8;
            }
          }
#line 1338
          mqc->a <<= 1;
#line 1338
          mqc->c <<= 1;
#line 1338
          __cil_tmp15 = mqc->ct;
#line 1338
          (mqc->ct) --;
#line 1338
          if (! (mqc->a < 32768U)) {
#line 1338
            goto while_break___0;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___0: ;
      } else {
#line 1338
        v = (*(mqc->curctx))->mps;
      }
    }
#line 1339
    mqc->a -= (*(mqc->curctx))->qeval;
#line 1339
    if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
#line 1339
      if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1339
        mqc->a = (*(mqc->curctx))->qeval;
#line 1339
        v2 = (*(mqc->curctx))->mps;
#line 1339
        *(mqc->curctx) = (*(mqc->curctx))->nmps;
      } else {
#line 1339
        mqc->a = (*(mqc->curctx))->qeval;
#line 1339
        v2 = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1339
        *(mqc->curctx) = (*(mqc->curctx))->nlps;
      }
      {
#line 1339
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1339
        if (mqc->ct == 0U) {
#line 1339
          l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1339
          if ((int )*(mqc->bp) == 255) {
#line 1339
            if (l_c___1 > 143U) {
#line 1339
              mqc->c += 65280U;
#line 1339
              mqc->ct = (OPJ_UINT32 )8;
#line 1339
              (mqc->end_of_byte_stream_counter) ++;
            } else {
#line 1339
              (mqc->bp) ++;
#line 1339
              mqc->c += l_c___1 << 9;
#line 1339
              mqc->ct = (OPJ_UINT32 )7;
            }
          } else {
#line 1339
            (mqc->bp) ++;
#line 1339
            mqc->c += l_c___1 << 8;
#line 1339
            mqc->ct = (OPJ_UINT32 )8;
          }
        }
#line 1339
        mqc->a <<= 1;
#line 1339
        mqc->c <<= 1;
#line 1339
        __cil_tmp20 = mqc->ct;
#line 1339
        (mqc->ct) --;
#line 1339
        if (! (mqc->a < 32768U)) {
#line 1339
          goto while_break___1;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: ;
    } else {
#line 1339
      mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 1339
      if ((mqc->a & 32768U) == 0U) {
#line 1339
        if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1339
          v2 = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1339
          *(mqc->curctx) = (*(mqc->curctx))->nlps;
        } else {
#line 1339
          v2 = (*(mqc->curctx))->mps;
#line 1339
          *(mqc->curctx) = (*(mqc->curctx))->nmps;
        }
        {
#line 1339
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1339
          if (mqc->ct == 0U) {
#line 1339
            l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1339
            if ((int )*(mqc->bp) == 255) {
#line 1339
              if (l_c___2 > 143U) {
#line 1339
                mqc->c += 65280U;
#line 1339
                mqc->ct = (OPJ_UINT32 )8;
#line 1339
                (mqc->end_of_byte_stream_counter) ++;
              } else {
#line 1339
                (mqc->bp) ++;
#line 1339
                mqc->c += l_c___2 << 9;
#line 1339
                mqc->ct = (OPJ_UINT32 )7;
              }
            } else {
#line 1339
              (mqc->bp) ++;
#line 1339
              mqc->c += l_c___2 << 8;
#line 1339
              mqc->ct = (OPJ_UINT32 )8;
            }
          }
#line 1339
          mqc->a <<= 1;
#line 1339
          mqc->c <<= 1;
#line 1339
          __cil_tmp25 = mqc->ct;
#line 1339
          (mqc->ct) --;
#line 1339
          if (! (mqc->a < 32768U)) {
#line 1339
            goto while_break___2;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: ;
      } else {
#line 1339
        v2 = (*(mqc->curctx))->mps;
      }
    }
#line 1340
    v = (v << 1) | v2;
#line 1341
    mqc->a -= (*(mqc->curctx))->qeval;
#line 1341
    if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
#line 1341
      if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1341
        mqc->a = (*(mqc->curctx))->qeval;
#line 1341
        v2 = (*(mqc->curctx))->mps;
#line 1341
        *(mqc->curctx) = (*(mqc->curctx))->nmps;
      } else {
#line 1341
        mqc->a = (*(mqc->curctx))->qeval;
#line 1341
        v2 = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1341
        *(mqc->curctx) = (*(mqc->curctx))->nlps;
      }
      {
#line 1341
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1341
        if (mqc->ct == 0U) {
#line 1341
          l_c___3 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1341
          if ((int )*(mqc->bp) == 255) {
#line 1341
            if (l_c___3 > 143U) {
#line 1341
              mqc->c += 65280U;
#line 1341
              mqc->ct = (OPJ_UINT32 )8;
#line 1341
              (mqc->end_of_byte_stream_counter) ++;
            } else {
#line 1341
              (mqc->bp) ++;
#line 1341
              mqc->c += l_c___3 << 9;
#line 1341
              mqc->ct = (OPJ_UINT32 )7;
            }
          } else {
#line 1341
            (mqc->bp) ++;
#line 1341
            mqc->c += l_c___3 << 8;
#line 1341
            mqc->ct = (OPJ_UINT32 )8;
          }
        }
#line 1341
        mqc->a <<= 1;
#line 1341
        mqc->c <<= 1;
#line 1341
        __cil_tmp30 = mqc->ct;
#line 1341
        (mqc->ct) --;
#line 1341
        if (! (mqc->a < 32768U)) {
#line 1341
          goto while_break___3;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___3: ;
    } else {
#line 1341
      mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 1341
      if ((mqc->a & 32768U) == 0U) {
#line 1341
        if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1341
          v2 = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1341
          *(mqc->curctx) = (*(mqc->curctx))->nlps;
        } else {
#line 1341
          v2 = (*(mqc->curctx))->mps;
#line 1341
          *(mqc->curctx) = (*(mqc->curctx))->nmps;
        }
        {
#line 1341
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 1341
          if (mqc->ct == 0U) {
#line 1341
            l_c___4 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1341
            if ((int )*(mqc->bp) == 255) {
#line 1341
              if (l_c___4 > 143U) {
#line 1341
                mqc->c += 65280U;
#line 1341
                mqc->ct = (OPJ_UINT32 )8;
#line 1341
                (mqc->end_of_byte_stream_counter) ++;
              } else {
#line 1341
                (mqc->bp) ++;
#line 1341
                mqc->c += l_c___4 << 9;
#line 1341
                mqc->ct = (OPJ_UINT32 )7;
              }
            } else {
#line 1341
              (mqc->bp) ++;
#line 1341
              mqc->c += l_c___4 << 8;
#line 1341
              mqc->ct = (OPJ_UINT32 )8;
            }
          }
#line 1341
          mqc->a <<= 1;
#line 1341
          mqc->c <<= 1;
#line 1341
          __cil_tmp35 = mqc->ct;
#line 1341
          (mqc->ct) --;
#line 1341
          if (! (mqc->a < 32768U)) {
#line 1341
            goto while_break___4;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___4: ;
      } else {
#line 1341
        v2 = (*(mqc->curctx))->mps;
      }
    }
#line 1342
    v = (v << 1) | v2;
#line 1343
    mqc->a -= (*(mqc->curctx))->qeval;
#line 1343
    if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
#line 1343
      if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1343
        mqc->a = (*(mqc->curctx))->qeval;
#line 1343
        v2 = (*(mqc->curctx))->mps;
#line 1343
        *(mqc->curctx) = (*(mqc->curctx))->nmps;
      } else {
#line 1343
        mqc->a = (*(mqc->curctx))->qeval;
#line 1343
        v2 = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1343
        *(mqc->curctx) = (*(mqc->curctx))->nlps;
      }
      {
#line 1343
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 1343
        if (mqc->ct == 0U) {
#line 1343
          l_c___5 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1343
          if ((int )*(mqc->bp) == 255) {
#line 1343
            if (l_c___5 > 143U) {
#line 1343
              mqc->c += 65280U;
#line 1343
              mqc->ct = (OPJ_UINT32 )8;
#line 1343
              (mqc->end_of_byte_stream_counter) ++;
            } else {
#line 1343
              (mqc->bp) ++;
#line 1343
              mqc->c += l_c___5 << 9;
#line 1343
              mqc->ct = (OPJ_UINT32 )7;
            }
          } else {
#line 1343
            (mqc->bp) ++;
#line 1343
            mqc->c += l_c___5 << 8;
#line 1343
            mqc->ct = (OPJ_UINT32 )8;
          }
        }
#line 1343
        mqc->a <<= 1;
#line 1343
        mqc->c <<= 1;
#line 1343
        __cil_tmp40 = mqc->ct;
#line 1343
        (mqc->ct) --;
#line 1343
        if (! (mqc->a < 32768U)) {
#line 1343
          goto while_break___5;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___5: ;
    } else {
#line 1343
      mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 1343
      if ((mqc->a & 32768U) == 0U) {
#line 1343
        if (mqc->a < (*(mqc->curctx))->qeval) {
#line 1343
          v2 = (OPJ_UINT32 )(! (*(mqc->curctx))->mps);
#line 1343
          *(mqc->curctx) = (*(mqc->curctx))->nlps;
        } else {
#line 1343
          v2 = (*(mqc->curctx))->mps;
#line 1343
          *(mqc->curctx) = (*(mqc->curctx))->nmps;
        }
        {
#line 1343
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 1343
          if (mqc->ct == 0U) {
#line 1343
            l_c___6 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1343
            if ((int )*(mqc->bp) == 255) {
#line 1343
              if (l_c___6 > 143U) {
#line 1343
                mqc->c += 65280U;
#line 1343
                mqc->ct = (OPJ_UINT32 )8;
#line 1343
                (mqc->end_of_byte_stream_counter) ++;
              } else {
#line 1343
                (mqc->bp) ++;
#line 1343
                mqc->c += l_c___6 << 9;
#line 1343
                mqc->ct = (OPJ_UINT32 )7;
              }
            } else {
#line 1343
              (mqc->bp) ++;
#line 1343
              mqc->c += l_c___6 << 8;
#line 1343
              mqc->ct = (OPJ_UINT32 )8;
            }
          }
#line 1343
          mqc->a <<= 1;
#line 1343
          mqc->c <<= 1;
#line 1343
          __cil_tmp45 = mqc->ct;
#line 1343
          (mqc->ct) --;
#line 1343
          if (! (mqc->a < 32768U)) {
#line 1343
            goto while_break___6;
          }
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: ;
      } else {
#line 1343
        v2 = (*(mqc->curctx))->mps;
      }
    }
#line 1344
    v = (v << 1) | v2;
  }
#line 1346
  return;
}
}
#line 1353 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_64x64_novsc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 runlen ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_w ;
  opj_mqc_t *mqc ;
  register OPJ_INT32 *data ;
  register opj_flag_t *flagsp ;
  register opj_mqc_state_t **curctx ;
  register OPJ_UINT32 c ;
  register OPJ_UINT32 a ;
  register OPJ_UINT32 ct ;
  register OPJ_UINT32 v ;
  opj_flag_t flags ;
  OPJ_UINT32 partial ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp40 ;
  OPJ_UINT32 l_c___3 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 l_c___4 ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp52 ;
  OPJ_UINT32 l_c___5 ;
  OPJ_UINT32 __cil_tmp57 ;
  OPJ_UINT32 l_c___6 ;
  OPJ_UINT32 __cil_tmp62 ;
  OPJ_UINT32 lu ;
  OPJ_UINT32 __cil_tmp64 ;
  OPJ_BYTE __cil_tmp65 ;
  OPJ_UINT32 l_c___7 ;
  OPJ_UINT32 __cil_tmp70 ;
  OPJ_UINT32 l_c___8 ;
  OPJ_UINT32 __cil_tmp75 ;
  OPJ_BYTE __cil_tmp76 ;
  OPJ_INT32 tmp ;
  opj_flag_t *north ;
  OPJ_UINT32 ctxt1___0 ;
  OPJ_BYTE __cil_tmp81 ;
  OPJ_UINT32 l_c___9 ;
  OPJ_UINT32 __cil_tmp86 ;
  OPJ_UINT32 l_c___10 ;
  OPJ_UINT32 __cil_tmp91 ;
  OPJ_UINT32 lu___0 ;
  OPJ_UINT32 __cil_tmp93 ;
  OPJ_BYTE __cil_tmp94 ;
  OPJ_UINT32 l_c___11 ;
  OPJ_UINT32 __cil_tmp99 ;
  OPJ_UINT32 l_c___12 ;
  OPJ_UINT32 __cil_tmp104 ;
  OPJ_BYTE __cil_tmp105 ;
  OPJ_INT32 tmp___0 ;
  OPJ_UINT32 ctxt1___1 ;
  OPJ_BYTE __cil_tmp110 ;
  OPJ_UINT32 l_c___13 ;
  OPJ_UINT32 __cil_tmp115 ;
  OPJ_UINT32 l_c___14 ;
  OPJ_UINT32 __cil_tmp120 ;
  OPJ_UINT32 lu___1 ;
  OPJ_UINT32 __cil_tmp122 ;
  OPJ_BYTE __cil_tmp123 ;
  OPJ_UINT32 l_c___15 ;
  OPJ_UINT32 __cil_tmp128 ;
  OPJ_UINT32 l_c___16 ;
  OPJ_UINT32 __cil_tmp133 ;
  OPJ_BYTE __cil_tmp134 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 ctxt1___2 ;
  OPJ_BYTE __cil_tmp139 ;
  OPJ_UINT32 l_c___17 ;
  OPJ_UINT32 __cil_tmp144 ;
  OPJ_UINT32 l_c___18 ;
  OPJ_UINT32 __cil_tmp149 ;
  OPJ_UINT32 lu___2 ;
  OPJ_UINT32 __cil_tmp151 ;
  OPJ_BYTE __cil_tmp152 ;
  OPJ_UINT32 l_c___19 ;
  OPJ_UINT32 __cil_tmp157 ;
  OPJ_UINT32 l_c___20 ;
  OPJ_UINT32 __cil_tmp162 ;
  OPJ_BYTE __cil_tmp163 ;
  OPJ_INT32 tmp___2 ;
  opj_flag_t *south___2 ;
  OPJ_UINT32 ctxt1___3 ;
  OPJ_BYTE __cil_tmp168 ;
  OPJ_UINT32 l_c___21 ;
  OPJ_UINT32 __cil_tmp173 ;
  OPJ_UINT32 l_c___22 ;
  OPJ_UINT32 __cil_tmp178 ;
  OPJ_UINT32 lu___3 ;
  OPJ_UINT32 __cil_tmp180 ;
  OPJ_BYTE __cil_tmp181 ;
  OPJ_UINT32 l_c___23 ;
  OPJ_UINT32 __cil_tmp186 ;
  OPJ_UINT32 l_c___24 ;
  OPJ_UINT32 __cil_tmp191 ;
  OPJ_BYTE __cil_tmp192 ;
  OPJ_INT32 tmp___3 ;
  opj_flag_t *north___3 ;
  OPJ_UINT32 ctxt1___4 ;
  OPJ_BYTE __cil_tmp197 ;
  OPJ_UINT32 l_c___25 ;
  OPJ_UINT32 __cil_tmp202 ;
  OPJ_UINT32 l_c___26 ;
  OPJ_UINT32 __cil_tmp207 ;
  OPJ_UINT32 lu___4 ;
  OPJ_UINT32 __cil_tmp209 ;
  OPJ_BYTE __cil_tmp210 ;
  OPJ_UINT32 l_c___27 ;
  OPJ_UINT32 __cil_tmp215 ;
  OPJ_UINT32 l_c___28 ;
  OPJ_UINT32 __cil_tmp220 ;
  OPJ_BYTE __cil_tmp221 ;
  OPJ_INT32 tmp___4 ;
  OPJ_UINT32 ctxt1___5 ;
  OPJ_BYTE __cil_tmp226 ;
  OPJ_UINT32 l_c___29 ;
  OPJ_UINT32 __cil_tmp231 ;
  OPJ_UINT32 l_c___30 ;
  OPJ_UINT32 __cil_tmp236 ;
  OPJ_UINT32 lu___5 ;
  OPJ_UINT32 __cil_tmp238 ;
  OPJ_BYTE __cil_tmp239 ;
  OPJ_UINT32 l_c___31 ;
  OPJ_UINT32 __cil_tmp244 ;
  OPJ_UINT32 l_c___32 ;
  OPJ_UINT32 __cil_tmp249 ;
  OPJ_BYTE __cil_tmp250 ;
  OPJ_INT32 tmp___5 ;
  OPJ_UINT32 ctxt1___6 ;
  OPJ_BYTE __cil_tmp255 ;
  OPJ_UINT32 l_c___33 ;
  OPJ_UINT32 __cil_tmp260 ;
  OPJ_UINT32 l_c___34 ;
  OPJ_UINT32 __cil_tmp265 ;
  OPJ_UINT32 lu___6 ;
  OPJ_UINT32 __cil_tmp267 ;
  OPJ_BYTE __cil_tmp268 ;
  OPJ_UINT32 l_c___35 ;
  OPJ_UINT32 __cil_tmp273 ;
  OPJ_UINT32 l_c___36 ;
  OPJ_UINT32 __cil_tmp278 ;
  OPJ_BYTE __cil_tmp279 ;
  OPJ_INT32 tmp___6 ;
  opj_flag_t *south___6 ;

  {
#line 1357
  l_w = (OPJ_UINT32 )64;
#line 1357
  mqc = & t1->mqc;
#line 1357
  data = t1->data;
#line 1357
  flagsp = t1->flags + 67;
#line 1357
  curctx = mqc->curctx;
#line 1357
  c = mqc->c;
#line 1357
  a = mqc->a;
#line 1357
  ct = mqc->ct;
#line 1357
  one = 1 << bpno;
#line 1357
  half = one >> 1;
#line 1357
  oneplushalf = one | half;
#line 1357
  k = (OPJ_UINT32 )0;
  {
#line 1357
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1357
    if (! (k < 64U)) {
#line 1357
      goto while_break;
    }
#line 1357
    i = (OPJ_UINT32 )0;
    {
#line 1357
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 1357
      if (! (i < l_w)) {
#line 1357
        goto while_break___0;
      }
#line 1357
      flags = *flagsp;
#line 1357
      if (flags == 0U) {
#line 1357
        partial = (OPJ_UINT32 )1;
#line 1357
        curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 1357
        a -= (*curctx)->qeval;
#line 1357
        if (c >> 16 < (*curctx)->qeval) {
#line 1357
          if (a < (*curctx)->qeval) {
#line 1357
            a = (*curctx)->qeval;
#line 1357
            v = (*curctx)->mps;
#line 1357
            *curctx = (*curctx)->nmps;
          } else {
#line 1357
            a = (*curctx)->qeval;
#line 1357
            v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
            *curctx = (*curctx)->nlps;
          }
          {
#line 1357
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 1357
            if (ct == 0U) {
#line 1357
              l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
              if ((int )*(mqc->bp) == 255) {
#line 1357
                if (l_c > 143U) {
#line 1357
                  c += 65280U;
#line 1357
                  ct = (OPJ_UINT32 )8;
#line 1357
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1357
                  (mqc->bp) ++;
#line 1357
                  c += l_c << 9;
#line 1357
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1357
                (mqc->bp) ++;
#line 1357
                c += l_c << 8;
#line 1357
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1357
            a <<= 1;
#line 1357
            c <<= 1;
#line 1357
            __cil_tmp25 = ct;
#line 1357
            ct --;
#line 1357
            if (! (a < 32768U)) {
#line 1357
              goto while_break___1;
            }
          }
          while_break___51: /* CIL Label */ ;
          }
          while_break___1: ;
        } else {
#line 1357
          c -= (*curctx)->qeval << 16;
#line 1357
          if ((a & 32768U) == 0U) {
#line 1357
            if (a < (*curctx)->qeval) {
#line 1357
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
              *curctx = (*curctx)->nlps;
            } else {
#line 1357
              v = (*curctx)->mps;
#line 1357
              *curctx = (*curctx)->nmps;
            }
            {
#line 1357
            while (1) {
              while_continue___3: /* CIL Label */ ;

#line 1357
              if (ct == 0U) {
#line 1357
                l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                if ((int )*(mqc->bp) == 255) {
#line 1357
                  if (l_c___0 > 143U) {
#line 1357
                    c += 65280U;
#line 1357
                    ct = (OPJ_UINT32 )8;
#line 1357
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___0 << 9;
#line 1357
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1357
                  (mqc->bp) ++;
#line 1357
                  c += l_c___0 << 8;
#line 1357
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1357
              a <<= 1;
#line 1357
              c <<= 1;
#line 1357
              __cil_tmp30 = ct;
#line 1357
              ct --;
#line 1357
              if (! (a < 32768U)) {
#line 1357
                goto while_break___2;
              }
            }
            while_break___52: /* CIL Label */ ;
            }
            while_break___2: ;
          } else {
#line 1357
            v = (*curctx)->mps;
          }
        }
#line 1357
        if (! v) {
#line 1357
          goto while_continue___0;
        }
#line 1357
        curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1357
        a -= (*curctx)->qeval;
#line 1357
        if (c >> 16 < (*curctx)->qeval) {
#line 1357
          if (a < (*curctx)->qeval) {
#line 1357
            a = (*curctx)->qeval;
#line 1357
            runlen = (*curctx)->mps;
#line 1357
            *curctx = (*curctx)->nmps;
          } else {
#line 1357
            a = (*curctx)->qeval;
#line 1357
            runlen = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
            *curctx = (*curctx)->nlps;
          }
          {
#line 1357
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 1357
            if (ct == 0U) {
#line 1357
              l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
              if ((int )*(mqc->bp) == 255) {
#line 1357
                if (l_c___1 > 143U) {
#line 1357
                  c += 65280U;
#line 1357
                  ct = (OPJ_UINT32 )8;
#line 1357
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1357
                  (mqc->bp) ++;
#line 1357
                  c += l_c___1 << 9;
#line 1357
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1357
                (mqc->bp) ++;
#line 1357
                c += l_c___1 << 8;
#line 1357
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1357
            a <<= 1;
#line 1357
            c <<= 1;
#line 1357
            __cil_tmp35 = ct;
#line 1357
            ct --;
#line 1357
            if (! (a < 32768U)) {
#line 1357
              goto while_break___3;
            }
          }
          while_break___53: /* CIL Label */ ;
          }
          while_break___3: ;
        } else {
#line 1357
          c -= (*curctx)->qeval << 16;
#line 1357
          if ((a & 32768U) == 0U) {
#line 1357
            if (a < (*curctx)->qeval) {
#line 1357
              runlen = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
              *curctx = (*curctx)->nlps;
            } else {
#line 1357
              runlen = (*curctx)->mps;
#line 1357
              *curctx = (*curctx)->nmps;
            }
            {
#line 1357
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 1357
              if (ct == 0U) {
#line 1357
                l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                if ((int )*(mqc->bp) == 255) {
#line 1357
                  if (l_c___2 > 143U) {
#line 1357
                    c += 65280U;
#line 1357
                    ct = (OPJ_UINT32 )8;
#line 1357
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___2 << 9;
#line 1357
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1357
                  (mqc->bp) ++;
#line 1357
                  c += l_c___2 << 8;
#line 1357
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1357
              a <<= 1;
#line 1357
              c <<= 1;
#line 1357
              __cil_tmp40 = ct;
#line 1357
              ct --;
#line 1357
              if (! (a < 32768U)) {
#line 1357
                goto while_break___4;
              }
            }
            while_break___54: /* CIL Label */ ;
            }
            while_break___4: ;
          } else {
#line 1357
            runlen = (*curctx)->mps;
          }
        }
#line 1357
        a -= (*curctx)->qeval;
#line 1357
        if (c >> 16 < (*curctx)->qeval) {
#line 1357
          if (a < (*curctx)->qeval) {
#line 1357
            a = (*curctx)->qeval;
#line 1357
            v = (*curctx)->mps;
#line 1357
            *curctx = (*curctx)->nmps;
          } else {
#line 1357
            a = (*curctx)->qeval;
#line 1357
            v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
            *curctx = (*curctx)->nlps;
          }
          {
#line 1357
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 1357
            if (ct == 0U) {
#line 1357
              l_c___3 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
              if ((int )*(mqc->bp) == 255) {
#line 1357
                if (l_c___3 > 143U) {
#line 1357
                  c += 65280U;
#line 1357
                  ct = (OPJ_UINT32 )8;
#line 1357
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1357
                  (mqc->bp) ++;
#line 1357
                  c += l_c___3 << 9;
#line 1357
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1357
                (mqc->bp) ++;
#line 1357
                c += l_c___3 << 8;
#line 1357
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1357
            a <<= 1;
#line 1357
            c <<= 1;
#line 1357
            __cil_tmp45 = ct;
#line 1357
            ct --;
#line 1357
            if (! (a < 32768U)) {
#line 1357
              goto while_break___5;
            }
          }
          while_break___55: /* CIL Label */ ;
          }
          while_break___5: ;
        } else {
#line 1357
          c -= (*curctx)->qeval << 16;
#line 1357
          if ((a & 32768U) == 0U) {
#line 1357
            if (a < (*curctx)->qeval) {
#line 1357
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
              *curctx = (*curctx)->nlps;
            } else {
#line 1357
              v = (*curctx)->mps;
#line 1357
              *curctx = (*curctx)->nmps;
            }
            {
#line 1357
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 1357
              if (ct == 0U) {
#line 1357
                l_c___4 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                if ((int )*(mqc->bp) == 255) {
#line 1357
                  if (l_c___4 > 143U) {
#line 1357
                    c += 65280U;
#line 1357
                    ct = (OPJ_UINT32 )8;
#line 1357
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___4 << 9;
#line 1357
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1357
                  (mqc->bp) ++;
#line 1357
                  c += l_c___4 << 8;
#line 1357
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1357
              a <<= 1;
#line 1357
              c <<= 1;
#line 1357
              __cil_tmp50 = ct;
#line 1357
              ct --;
#line 1357
              if (! (a < 32768U)) {
#line 1357
                goto while_break___6;
              }
            }
            while_break___56: /* CIL Label */ ;
            }
            while_break___6: ;
          } else {
#line 1357
            v = (*curctx)->mps;
          }
        }
#line 1357
        runlen = (runlen << 1) | v;
#line 1357
        if (runlen == 0U) {
#line 1357
          goto case_0;
        }
#line 1357
        if (runlen == 1U) {
#line 1357
          goto case_1;
        }
#line 1357
        if (runlen == 2U) {
#line 1357
          goto case_2;
        }
#line 1357
        if (runlen == 3U) {
#line 1357
          goto case_3;
        }
#line 1357
        goto switch_break;
        case_0: 
        {
#line 1357
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 1357
          if (0) {
            {
#line 1357
            __cil_tmp52 = opj_t1_getctxno_zc(mqc, flags);
#line 1357
            ctxt1 = (OPJ_UINT32 )__cil_tmp52;
#line 1357
            curctx = & mqc->ctxs[ctxt1];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___9: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___5 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___5 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___5 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___5 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp57 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___8;
                }
              }
              while_break___58: /* CIL Label */ ;
              }
              while_break___8: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___10: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___6 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___6 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___6 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___6 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp62 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___9;
                  }
                }
                while_break___59: /* CIL Label */ ;
                }
                while_break___9: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
#line 1357
            if (! v) {
#line 1357
              goto while_break___7;
            }
          }
          {
#line 1357
          __cil_tmp64 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                         (OPJ_UINT32 )0);
#line 1357
          lu = __cil_tmp64;
#line 1357
          __cil_tmp65 = opj_t1_getctxno_sc(lu);
#line 1357
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp65];
#line 1357
          a -= (*curctx)->qeval;
          }
#line 1357
          if (c >> 16 < (*curctx)->qeval) {
#line 1357
            if (a < (*curctx)->qeval) {
#line 1357
              a = (*curctx)->qeval;
#line 1357
              v = (*curctx)->mps;
#line 1357
              *curctx = (*curctx)->nmps;
            } else {
#line 1357
              a = (*curctx)->qeval;
#line 1357
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
              *curctx = (*curctx)->nlps;
            }
            {
#line 1357
            while (1) {
              while_continue___11: /* CIL Label */ ;

#line 1357
              if (ct == 0U) {
#line 1357
                l_c___7 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                if ((int )*(mqc->bp) == 255) {
#line 1357
                  if (l_c___7 > 143U) {
#line 1357
                    c += 65280U;
#line 1357
                    ct = (OPJ_UINT32 )8;
#line 1357
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___7 << 9;
#line 1357
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1357
                  (mqc->bp) ++;
#line 1357
                  c += l_c___7 << 8;
#line 1357
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1357
              a <<= 1;
#line 1357
              c <<= 1;
#line 1357
              __cil_tmp70 = ct;
#line 1357
              ct --;
#line 1357
              if (! (a < 32768U)) {
#line 1357
                goto while_break___10;
              }
            }
            while_break___60: /* CIL Label */ ;
            }
            while_break___10: ;
          } else {
#line 1357
            c -= (*curctx)->qeval << 16;
#line 1357
            if ((a & 32768U) == 0U) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              } else {
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              }
              {
#line 1357
              while (1) {
                while_continue___12: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___8 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___8 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___8 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___8 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp75 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___11;
                }
              }
              while_break___61: /* CIL Label */ ;
              }
              while_break___11: ;
            } else {
#line 1357
              v = (*curctx)->mps;
            }
          }
          {
#line 1357
          __cil_tmp76 = opj_t1_getspb(lu);
#line 1357
          v ^= (unsigned int )__cil_tmp76;
          }
#line 1357
          if (v) {
#line 1357
            tmp = - oneplushalf;
          } else {
#line 1357
            tmp = oneplushalf;
          }
#line 1357
          *(data + 0U) = tmp;
#line 1357
          *(flagsp + -1) |= 1U << 5;
#line 1357
          flags |= (v << 19) | (1U << 4);
#line 1357
          *(flagsp + 1) |= 1U << 3;
#line 1357
          north = flagsp - 66;
#line 1357
          *north |= (v << 31) | (1U << 16);
#line 1357
          *(north + -1) |= 1U << 17;
#line 1357
          *(north + 1) |= 1U << 15;
#line 1357
          goto while_break___7;
        }
        while_break___57: /* CIL Label */ ;
        }
        while_break___7: 
#line 1357
        partial = (OPJ_UINT32 )0;
        case_1: 
        {
#line 1357
        while (1) {
          while_continue___13: /* CIL Label */ ;

#line 1357
          if (! partial) {
            {
#line 1357
            __cil_tmp81 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 1357
            ctxt1___0 = (OPJ_UINT32 )__cil_tmp81;
#line 1357
            curctx = & mqc->ctxs[ctxt1___0];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___14: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___9 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___9 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___9 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___9 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp86 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___13;
                }
              }
              while_break___63: /* CIL Label */ ;
              }
              while_break___13: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___15: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___10 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___10 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___10 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___10 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp91 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___14;
                  }
                }
                while_break___64: /* CIL Label */ ;
                }
                while_break___14: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
#line 1357
            if (! v) {
#line 1357
              goto while_break___12;
            }
          }
          {
#line 1357
          __cil_tmp93 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                         (OPJ_UINT32 )1);
#line 1357
          lu___0 = __cil_tmp93;
#line 1357
          __cil_tmp94 = opj_t1_getctxno_sc(lu___0);
#line 1357
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp94];
#line 1357
          a -= (*curctx)->qeval;
          }
#line 1357
          if (c >> 16 < (*curctx)->qeval) {
#line 1357
            if (a < (*curctx)->qeval) {
#line 1357
              a = (*curctx)->qeval;
#line 1357
              v = (*curctx)->mps;
#line 1357
              *curctx = (*curctx)->nmps;
            } else {
#line 1357
              a = (*curctx)->qeval;
#line 1357
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
              *curctx = (*curctx)->nlps;
            }
            {
#line 1357
            while (1) {
              while_continue___16: /* CIL Label */ ;

#line 1357
              if (ct == 0U) {
#line 1357
                l_c___11 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                if ((int )*(mqc->bp) == 255) {
#line 1357
                  if (l_c___11 > 143U) {
#line 1357
                    c += 65280U;
#line 1357
                    ct = (OPJ_UINT32 )8;
#line 1357
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___11 << 9;
#line 1357
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1357
                  (mqc->bp) ++;
#line 1357
                  c += l_c___11 << 8;
#line 1357
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1357
              a <<= 1;
#line 1357
              c <<= 1;
#line 1357
              __cil_tmp99 = ct;
#line 1357
              ct --;
#line 1357
              if (! (a < 32768U)) {
#line 1357
                goto while_break___15;
              }
            }
            while_break___65: /* CIL Label */ ;
            }
            while_break___15: ;
          } else {
#line 1357
            c -= (*curctx)->qeval << 16;
#line 1357
            if ((a & 32768U) == 0U) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              } else {
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              }
              {
#line 1357
              while (1) {
                while_continue___17: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___12 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___12 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___12 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___12 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp104 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___16;
                }
              }
              while_break___66: /* CIL Label */ ;
              }
              while_break___16: ;
            } else {
#line 1357
              v = (*curctx)->mps;
            }
          }
          {
#line 1357
          __cil_tmp105 = opj_t1_getspb(lu___0);
#line 1357
          v ^= (unsigned int )__cil_tmp105;
          }
#line 1357
          if (v) {
#line 1357
            tmp___0 = - oneplushalf;
          } else {
#line 1357
            tmp___0 = oneplushalf;
          }
#line 1357
          *(data + l_w) = tmp___0;
#line 1357
          *(flagsp + -1) |= (1U << 5) << 3U;
#line 1357
          flags |= ((v << 19) | (1U << 4)) << 3U;
#line 1357
          *(flagsp + 1) |= (1U << 3) << 3U;
#line 1357
          goto while_break___12;
        }
        while_break___62: /* CIL Label */ ;
        }
        while_break___12: 
#line 1357
        partial = (OPJ_UINT32 )0;
        case_2: 
        {
#line 1357
        while (1) {
          while_continue___18: /* CIL Label */ ;

#line 1357
          if (! partial) {
            {
#line 1357
            __cil_tmp110 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 1357
            ctxt1___1 = (OPJ_UINT32 )__cil_tmp110;
#line 1357
            curctx = & mqc->ctxs[ctxt1___1];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___19: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___13 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___13 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___13 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___13 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp115 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___18;
                }
              }
              while_break___68: /* CIL Label */ ;
              }
              while_break___18: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___20: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___14 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___14 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___14 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___14 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp120 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___19;
                  }
                }
                while_break___69: /* CIL Label */ ;
                }
                while_break___19: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
#line 1357
            if (! v) {
#line 1357
              goto while_break___17;
            }
          }
          {
#line 1357
          __cil_tmp122 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                          (OPJ_UINT32 )2);
#line 1357
          lu___1 = __cil_tmp122;
#line 1357
          __cil_tmp123 = opj_t1_getctxno_sc(lu___1);
#line 1357
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp123];
#line 1357
          a -= (*curctx)->qeval;
          }
#line 1357
          if (c >> 16 < (*curctx)->qeval) {
#line 1357
            if (a < (*curctx)->qeval) {
#line 1357
              a = (*curctx)->qeval;
#line 1357
              v = (*curctx)->mps;
#line 1357
              *curctx = (*curctx)->nmps;
            } else {
#line 1357
              a = (*curctx)->qeval;
#line 1357
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
              *curctx = (*curctx)->nlps;
            }
            {
#line 1357
            while (1) {
              while_continue___21: /* CIL Label */ ;

#line 1357
              if (ct == 0U) {
#line 1357
                l_c___15 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                if ((int )*(mqc->bp) == 255) {
#line 1357
                  if (l_c___15 > 143U) {
#line 1357
                    c += 65280U;
#line 1357
                    ct = (OPJ_UINT32 )8;
#line 1357
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___15 << 9;
#line 1357
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1357
                  (mqc->bp) ++;
#line 1357
                  c += l_c___15 << 8;
#line 1357
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1357
              a <<= 1;
#line 1357
              c <<= 1;
#line 1357
              __cil_tmp128 = ct;
#line 1357
              ct --;
#line 1357
              if (! (a < 32768U)) {
#line 1357
                goto while_break___20;
              }
            }
            while_break___70: /* CIL Label */ ;
            }
            while_break___20: ;
          } else {
#line 1357
            c -= (*curctx)->qeval << 16;
#line 1357
            if ((a & 32768U) == 0U) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              } else {
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              }
              {
#line 1357
              while (1) {
                while_continue___22: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___16 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___16 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___16 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___16 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp133 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___21;
                }
              }
              while_break___71: /* CIL Label */ ;
              }
              while_break___21: ;
            } else {
#line 1357
              v = (*curctx)->mps;
            }
          }
          {
#line 1357
          __cil_tmp134 = opj_t1_getspb(lu___1);
#line 1357
          v ^= (unsigned int )__cil_tmp134;
          }
#line 1357
          if (v) {
#line 1357
            tmp___1 = - oneplushalf;
          } else {
#line 1357
            tmp___1 = oneplushalf;
          }
#line 1357
          *(data + 2U * l_w) = tmp___1;
#line 1357
          *(flagsp + -1) |= (1U << 5) << 6U;
#line 1357
          flags |= ((v << 19) | (1U << 4)) << 6U;
#line 1357
          *(flagsp + 1) |= (1U << 3) << 6U;
#line 1357
          goto while_break___17;
        }
        while_break___67: /* CIL Label */ ;
        }
        while_break___17: 
#line 1357
        partial = (OPJ_UINT32 )0;
        case_3: 
        {
#line 1357
        while (1) {
          while_continue___23: /* CIL Label */ ;

#line 1357
          if (! partial) {
            {
#line 1357
            __cil_tmp139 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 1357
            ctxt1___2 = (OPJ_UINT32 )__cil_tmp139;
#line 1357
            curctx = & mqc->ctxs[ctxt1___2];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___24: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___17 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___17 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___17 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___17 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp144 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___23;
                }
              }
              while_break___73: /* CIL Label */ ;
              }
              while_break___23: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___25: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___18 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___18 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___18 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___18 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp149 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___24;
                  }
                }
                while_break___74: /* CIL Label */ ;
                }
                while_break___24: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
#line 1357
            if (! v) {
#line 1357
              goto while_break___22;
            }
          }
          {
#line 1357
          __cil_tmp151 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                          (OPJ_UINT32 )3);
#line 1357
          lu___2 = __cil_tmp151;
#line 1357
          __cil_tmp152 = opj_t1_getctxno_sc(lu___2);
#line 1357
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp152];
#line 1357
          a -= (*curctx)->qeval;
          }
#line 1357
          if (c >> 16 < (*curctx)->qeval) {
#line 1357
            if (a < (*curctx)->qeval) {
#line 1357
              a = (*curctx)->qeval;
#line 1357
              v = (*curctx)->mps;
#line 1357
              *curctx = (*curctx)->nmps;
            } else {
#line 1357
              a = (*curctx)->qeval;
#line 1357
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
              *curctx = (*curctx)->nlps;
            }
            {
#line 1357
            while (1) {
              while_continue___26: /* CIL Label */ ;

#line 1357
              if (ct == 0U) {
#line 1357
                l_c___19 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                if ((int )*(mqc->bp) == 255) {
#line 1357
                  if (l_c___19 > 143U) {
#line 1357
                    c += 65280U;
#line 1357
                    ct = (OPJ_UINT32 )8;
#line 1357
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___19 << 9;
#line 1357
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1357
                  (mqc->bp) ++;
#line 1357
                  c += l_c___19 << 8;
#line 1357
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1357
              a <<= 1;
#line 1357
              c <<= 1;
#line 1357
              __cil_tmp157 = ct;
#line 1357
              ct --;
#line 1357
              if (! (a < 32768U)) {
#line 1357
                goto while_break___25;
              }
            }
            while_break___75: /* CIL Label */ ;
            }
            while_break___25: ;
          } else {
#line 1357
            c -= (*curctx)->qeval << 16;
#line 1357
            if ((a & 32768U) == 0U) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              } else {
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              }
              {
#line 1357
              while (1) {
                while_continue___27: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___20 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___20 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___20 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___20 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp162 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___26;
                }
              }
              while_break___76: /* CIL Label */ ;
              }
              while_break___26: ;
            } else {
#line 1357
              v = (*curctx)->mps;
            }
          }
          {
#line 1357
          __cil_tmp163 = opj_t1_getspb(lu___2);
#line 1357
          v ^= (unsigned int )__cil_tmp163;
          }
#line 1357
          if (v) {
#line 1357
            tmp___2 = - oneplushalf;
          } else {
#line 1357
            tmp___2 = oneplushalf;
          }
#line 1357
          *(data + 3U * l_w) = tmp___2;
#line 1357
          *(flagsp + -1) |= (1U << 5) << 9U;
#line 1357
          flags |= ((v << 19) | (1U << 4)) << 9U;
#line 1357
          *(flagsp + 1) |= (1U << 3) << 9U;
#line 1357
          south___2 = flagsp + 66;
#line 1357
          *south___2 |= (v << 18) | (1U << 1);
#line 1357
          *(south___2 + -1) |= 1U << 2;
#line 1357
          *(south___2 + 1) |= 1U;
#line 1357
          goto while_break___22;
        }
        while_break___72: /* CIL Label */ ;
        }
        while_break___22: ;
#line 1357
        goto switch_break;
        switch_break: ;
      } else {
#line 1357
        if (! (flags & ((1U << 4) | (1U << 21)))) {
          {
#line 1357
          while (1) {
            while_continue___28: /* CIL Label */ ;
            {
#line 1357
            __cil_tmp168 = opj_t1_getctxno_zc(mqc, flags);
#line 1357
            ctxt1___3 = (OPJ_UINT32 )__cil_tmp168;
#line 1357
            curctx = & mqc->ctxs[ctxt1___3];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___29: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___21 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___21 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___21 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___21 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp173 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___28;
                }
              }
              while_break___78: /* CIL Label */ ;
              }
              while_break___28: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___30: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___22 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___22 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___22 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___22 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp178 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___29;
                  }
                }
                while_break___79: /* CIL Label */ ;
                }
                while_break___29: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
#line 1357
            if (! v) {
#line 1357
              goto while_break___27;
            }
            {
#line 1357
            __cil_tmp180 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )0);
#line 1357
            lu___3 = __cil_tmp180;
#line 1357
            __cil_tmp181 = opj_t1_getctxno_sc(lu___3);
#line 1357
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp181];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___31: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___23 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___23 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___23 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___23 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp186 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___30;
                }
              }
              while_break___80: /* CIL Label */ ;
              }
              while_break___30: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___32: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___24 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___24 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___24 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___24 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp191 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___31;
                  }
                }
                while_break___81: /* CIL Label */ ;
                }
                while_break___31: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
            {
#line 1357
            __cil_tmp192 = opj_t1_getspb(lu___3);
#line 1357
            v ^= (unsigned int )__cil_tmp192;
            }
#line 1357
            if (v) {
#line 1357
              tmp___3 = - oneplushalf;
            } else {
#line 1357
              tmp___3 = oneplushalf;
            }
#line 1357
            *(data + 0U) = tmp___3;
#line 1357
            *(flagsp + -1) |= 1U << 5;
#line 1357
            flags |= (v << 19) | (1U << 4);
#line 1357
            *(flagsp + 1) |= 1U << 3;
#line 1357
            north___3 = flagsp - 66;
#line 1357
            *north___3 |= (v << 31) | (1U << 16);
#line 1357
            *(north___3 + -1) |= 1U << 17;
#line 1357
            *(north___3 + 1) |= 1U << 15;
#line 1357
            goto while_break___27;
          }
          while_break___77: /* CIL Label */ ;
          }
          while_break___27: ;
        }
#line 1357
        if (! (flags & (((1U << 4) | (1U << 21)) << 3U))) {
          {
#line 1357
          while (1) {
            while_continue___33: /* CIL Label */ ;
            {
#line 1357
            __cil_tmp197 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 1357
            ctxt1___4 = (OPJ_UINT32 )__cil_tmp197;
#line 1357
            curctx = & mqc->ctxs[ctxt1___4];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___34: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___25 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___25 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___25 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___25 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp202 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___33;
                }
              }
              while_break___83: /* CIL Label */ ;
              }
              while_break___33: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___35: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___26 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___26 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___26 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___26 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp207 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___34;
                  }
                }
                while_break___84: /* CIL Label */ ;
                }
                while_break___34: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
#line 1357
            if (! v) {
#line 1357
              goto while_break___32;
            }
            {
#line 1357
            __cil_tmp209 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )1);
#line 1357
            lu___4 = __cil_tmp209;
#line 1357
            __cil_tmp210 = opj_t1_getctxno_sc(lu___4);
#line 1357
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp210];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___36: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___27 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___27 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___27 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___27 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp215 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___35;
                }
              }
              while_break___85: /* CIL Label */ ;
              }
              while_break___35: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___37: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___28 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___28 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___28 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___28 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp220 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___36;
                  }
                }
                while_break___86: /* CIL Label */ ;
                }
                while_break___36: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
            {
#line 1357
            __cil_tmp221 = opj_t1_getspb(lu___4);
#line 1357
            v ^= (unsigned int )__cil_tmp221;
            }
#line 1357
            if (v) {
#line 1357
              tmp___4 = - oneplushalf;
            } else {
#line 1357
              tmp___4 = oneplushalf;
            }
#line 1357
            *(data + l_w) = tmp___4;
#line 1357
            *(flagsp + -1) |= (1U << 5) << 3U;
#line 1357
            flags |= ((v << 19) | (1U << 4)) << 3U;
#line 1357
            *(flagsp + 1) |= (1U << 3) << 3U;
#line 1357
            goto while_break___32;
          }
          while_break___82: /* CIL Label */ ;
          }
          while_break___32: ;
        }
#line 1357
        if (! (flags & (((1U << 4) | (1U << 21)) << 6U))) {
          {
#line 1357
          while (1) {
            while_continue___38: /* CIL Label */ ;
            {
#line 1357
            __cil_tmp226 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 1357
            ctxt1___5 = (OPJ_UINT32 )__cil_tmp226;
#line 1357
            curctx = & mqc->ctxs[ctxt1___5];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___39: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___29 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___29 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___29 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___29 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp231 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___38;
                }
              }
              while_break___88: /* CIL Label */ ;
              }
              while_break___38: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___40: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___30 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___30 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___30 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___30 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp236 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___39;
                  }
                }
                while_break___89: /* CIL Label */ ;
                }
                while_break___39: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
#line 1357
            if (! v) {
#line 1357
              goto while_break___37;
            }
            {
#line 1357
            __cil_tmp238 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )2);
#line 1357
            lu___5 = __cil_tmp238;
#line 1357
            __cil_tmp239 = opj_t1_getctxno_sc(lu___5);
#line 1357
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp239];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___41: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___31 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___31 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___31 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___31 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp244 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___40;
                }
              }
              while_break___90: /* CIL Label */ ;
              }
              while_break___40: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___42: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___32 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___32 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___32 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___32 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp249 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___41;
                  }
                }
                while_break___91: /* CIL Label */ ;
                }
                while_break___41: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
            {
#line 1357
            __cil_tmp250 = opj_t1_getspb(lu___5);
#line 1357
            v ^= (unsigned int )__cil_tmp250;
            }
#line 1357
            if (v) {
#line 1357
              tmp___5 = - oneplushalf;
            } else {
#line 1357
              tmp___5 = oneplushalf;
            }
#line 1357
            *(data + 2U * l_w) = tmp___5;
#line 1357
            *(flagsp + -1) |= (1U << 5) << 6U;
#line 1357
            flags |= ((v << 19) | (1U << 4)) << 6U;
#line 1357
            *(flagsp + 1) |= (1U << 3) << 6U;
#line 1357
            goto while_break___37;
          }
          while_break___87: /* CIL Label */ ;
          }
          while_break___37: ;
        }
#line 1357
        if (! (flags & (((1U << 4) | (1U << 21)) << 9U))) {
          {
#line 1357
          while (1) {
            while_continue___43: /* CIL Label */ ;
            {
#line 1357
            __cil_tmp255 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 1357
            ctxt1___6 = (OPJ_UINT32 )__cil_tmp255;
#line 1357
            curctx = & mqc->ctxs[ctxt1___6];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___44: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___33 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___33 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___33 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___33 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp260 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___43;
                }
              }
              while_break___93: /* CIL Label */ ;
              }
              while_break___43: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___45: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___34 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___34 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___34 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___34 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp265 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___44;
                  }
                }
                while_break___94: /* CIL Label */ ;
                }
                while_break___44: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
#line 1357
            if (! v) {
#line 1357
              goto while_break___42;
            }
            {
#line 1357
            __cil_tmp267 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )3);
#line 1357
            lu___6 = __cil_tmp267;
#line 1357
            __cil_tmp268 = opj_t1_getctxno_sc(lu___6);
#line 1357
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp268];
#line 1357
            a -= (*curctx)->qeval;
            }
#line 1357
            if (c >> 16 < (*curctx)->qeval) {
#line 1357
              if (a < (*curctx)->qeval) {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (*curctx)->mps;
#line 1357
                *curctx = (*curctx)->nmps;
              } else {
#line 1357
                a = (*curctx)->qeval;
#line 1357
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                *curctx = (*curctx)->nlps;
              }
              {
#line 1357
              while (1) {
                while_continue___46: /* CIL Label */ ;

#line 1357
                if (ct == 0U) {
#line 1357
                  l_c___35 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                  if ((int )*(mqc->bp) == 255) {
#line 1357
                    if (l_c___35 > 143U) {
#line 1357
                      c += 65280U;
#line 1357
                      ct = (OPJ_UINT32 )8;
#line 1357
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___35 << 9;
#line 1357
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1357
                    (mqc->bp) ++;
#line 1357
                    c += l_c___35 << 8;
#line 1357
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1357
                a <<= 1;
#line 1357
                c <<= 1;
#line 1357
                __cil_tmp273 = ct;
#line 1357
                ct --;
#line 1357
                if (! (a < 32768U)) {
#line 1357
                  goto while_break___45;
                }
              }
              while_break___95: /* CIL Label */ ;
              }
              while_break___45: ;
            } else {
#line 1357
              c -= (*curctx)->qeval << 16;
#line 1357
              if ((a & 32768U) == 0U) {
#line 1357
                if (a < (*curctx)->qeval) {
#line 1357
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1357
                  *curctx = (*curctx)->nlps;
                } else {
#line 1357
                  v = (*curctx)->mps;
#line 1357
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1357
                while (1) {
                  while_continue___47: /* CIL Label */ ;

#line 1357
                  if (ct == 0U) {
#line 1357
                    l_c___36 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1357
                    if ((int )*(mqc->bp) == 255) {
#line 1357
                      if (l_c___36 > 143U) {
#line 1357
                        c += 65280U;
#line 1357
                        ct = (OPJ_UINT32 )8;
#line 1357
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1357
                        (mqc->bp) ++;
#line 1357
                        c += l_c___36 << 9;
#line 1357
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1357
                      (mqc->bp) ++;
#line 1357
                      c += l_c___36 << 8;
#line 1357
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1357
                  a <<= 1;
#line 1357
                  c <<= 1;
#line 1357
                  __cil_tmp278 = ct;
#line 1357
                  ct --;
#line 1357
                  if (! (a < 32768U)) {
#line 1357
                    goto while_break___46;
                  }
                }
                while_break___96: /* CIL Label */ ;
                }
                while_break___46: ;
              } else {
#line 1357
                v = (*curctx)->mps;
              }
            }
            {
#line 1357
            __cil_tmp279 = opj_t1_getspb(lu___6);
#line 1357
            v ^= (unsigned int )__cil_tmp279;
            }
#line 1357
            if (v) {
#line 1357
              tmp___6 = - oneplushalf;
            } else {
#line 1357
              tmp___6 = oneplushalf;
            }
#line 1357
            *(data + 3U * l_w) = tmp___6;
#line 1357
            *(flagsp + -1) |= (1U << 5) << 9U;
#line 1357
            flags |= ((v << 19) | (1U << 4)) << 9U;
#line 1357
            *(flagsp + 1) |= (1U << 3) << 9U;
#line 1357
            south___6 = flagsp + 66;
#line 1357
            *south___6 |= (v << 18) | (1U << 1);
#line 1357
            *(south___6 + -1) |= 1U << 2;
#line 1357
            *(south___6 + 1) |= 1U;
#line 1357
            goto while_break___42;
          }
          while_break___92: /* CIL Label */ ;
          }
          while_break___42: ;
        }
      }
#line 1357
      *flagsp = flags & ~ ((((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30));
#line 1357
      flagsp ++;
#line 1357
      data ++;
#line 1357
      i ++;
    }
    while_break___50: /* CIL Label */ ;
    }
    while_break___0: 
#line 1357
    flagsp += 2;
#line 1357
    data += 3U * l_w;
#line 1357
    k += 4U;
  }
  while_break___49: /* CIL Label */ ;
  }
  while_break: 
#line 1357
  mqc->curctx = curctx;
#line 1357
  mqc->c = c;
#line 1357
  mqc->a = a;
#line 1357
  mqc->ct = ct;
#line 1357
  if (k < 64U) {
#line 1357
    i = (OPJ_UINT32 )0;
    {
#line 1357
    while (1) {
      while_continue___48: /* CIL Label */ ;

#line 1357
      if (! (i < l_w)) {
#line 1357
        goto while_break___47;
      }
#line 1357
      j = (OPJ_UINT32 )0;
      {
#line 1357
      while (1) {
        while_continue___49: /* CIL Label */ ;

#line 1357
        if (! (j < 64U - k)) {
#line 1357
          goto while_break___48;
        }
        {
#line 1357
        opj_t1_dec_clnpass_step(t1, flagsp, data + j * l_w, oneplushalf, j, (OPJ_UINT32 )0);
#line 1357
        j ++;
        }
      }
      while_break___98: /* CIL Label */ ;
      }
      while_break___48: 
#line 1357
      *flagsp &= ~ ((((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30));
#line 1357
      data ++;
#line 1357
      flagsp ++;
#line 1357
      i ++;
    }
    while_break___97: /* CIL Label */ ;
    }
    while_break___47: ;
  }
#line 1363
  return;
}
}
#line 1360 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_64x64_vsc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 runlen ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_w ;
  opj_mqc_t *mqc ;
  register OPJ_INT32 *data ;
  register opj_flag_t *flagsp ;
  register opj_mqc_state_t **curctx ;
  register OPJ_UINT32 c ;
  register OPJ_UINT32 a ;
  register OPJ_UINT32 ct ;
  register OPJ_UINT32 v ;
  opj_flag_t flags ;
  OPJ_UINT32 partial ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp40 ;
  OPJ_UINT32 l_c___3 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 l_c___4 ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp52 ;
  OPJ_UINT32 l_c___5 ;
  OPJ_UINT32 __cil_tmp57 ;
  OPJ_UINT32 l_c___6 ;
  OPJ_UINT32 __cil_tmp62 ;
  OPJ_UINT32 lu ;
  OPJ_UINT32 __cil_tmp64 ;
  OPJ_BYTE __cil_tmp65 ;
  OPJ_UINT32 l_c___7 ;
  OPJ_UINT32 __cil_tmp70 ;
  OPJ_UINT32 l_c___8 ;
  OPJ_UINT32 __cil_tmp75 ;
  OPJ_BYTE __cil_tmp76 ;
  OPJ_INT32 tmp ;
  OPJ_UINT32 ctxt1___0 ;
  OPJ_BYTE __cil_tmp81 ;
  OPJ_UINT32 l_c___9 ;
  OPJ_UINT32 __cil_tmp86 ;
  OPJ_UINT32 l_c___10 ;
  OPJ_UINT32 __cil_tmp91 ;
  OPJ_UINT32 lu___0 ;
  OPJ_UINT32 __cil_tmp93 ;
  OPJ_BYTE __cil_tmp94 ;
  OPJ_UINT32 l_c___11 ;
  OPJ_UINT32 __cil_tmp99 ;
  OPJ_UINT32 l_c___12 ;
  OPJ_UINT32 __cil_tmp104 ;
  OPJ_BYTE __cil_tmp105 ;
  OPJ_INT32 tmp___0 ;
  OPJ_UINT32 ctxt1___1 ;
  OPJ_BYTE __cil_tmp110 ;
  OPJ_UINT32 l_c___13 ;
  OPJ_UINT32 __cil_tmp115 ;
  OPJ_UINT32 l_c___14 ;
  OPJ_UINT32 __cil_tmp120 ;
  OPJ_UINT32 lu___1 ;
  OPJ_UINT32 __cil_tmp122 ;
  OPJ_BYTE __cil_tmp123 ;
  OPJ_UINT32 l_c___15 ;
  OPJ_UINT32 __cil_tmp128 ;
  OPJ_UINT32 l_c___16 ;
  OPJ_UINT32 __cil_tmp133 ;
  OPJ_BYTE __cil_tmp134 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 ctxt1___2 ;
  OPJ_BYTE __cil_tmp139 ;
  OPJ_UINT32 l_c___17 ;
  OPJ_UINT32 __cil_tmp144 ;
  OPJ_UINT32 l_c___18 ;
  OPJ_UINT32 __cil_tmp149 ;
  OPJ_UINT32 lu___2 ;
  OPJ_UINT32 __cil_tmp151 ;
  OPJ_BYTE __cil_tmp152 ;
  OPJ_UINT32 l_c___19 ;
  OPJ_UINT32 __cil_tmp157 ;
  OPJ_UINT32 l_c___20 ;
  OPJ_UINT32 __cil_tmp162 ;
  OPJ_BYTE __cil_tmp163 ;
  OPJ_INT32 tmp___2 ;
  opj_flag_t *south___2 ;
  OPJ_UINT32 ctxt1___3 ;
  OPJ_BYTE __cil_tmp168 ;
  OPJ_UINT32 l_c___21 ;
  OPJ_UINT32 __cil_tmp173 ;
  OPJ_UINT32 l_c___22 ;
  OPJ_UINT32 __cil_tmp178 ;
  OPJ_UINT32 lu___3 ;
  OPJ_UINT32 __cil_tmp180 ;
  OPJ_BYTE __cil_tmp181 ;
  OPJ_UINT32 l_c___23 ;
  OPJ_UINT32 __cil_tmp186 ;
  OPJ_UINT32 l_c___24 ;
  OPJ_UINT32 __cil_tmp191 ;
  OPJ_BYTE __cil_tmp192 ;
  OPJ_INT32 tmp___3 ;
  OPJ_UINT32 ctxt1___4 ;
  OPJ_BYTE __cil_tmp197 ;
  OPJ_UINT32 l_c___25 ;
  OPJ_UINT32 __cil_tmp202 ;
  OPJ_UINT32 l_c___26 ;
  OPJ_UINT32 __cil_tmp207 ;
  OPJ_UINT32 lu___4 ;
  OPJ_UINT32 __cil_tmp209 ;
  OPJ_BYTE __cil_tmp210 ;
  OPJ_UINT32 l_c___27 ;
  OPJ_UINT32 __cil_tmp215 ;
  OPJ_UINT32 l_c___28 ;
  OPJ_UINT32 __cil_tmp220 ;
  OPJ_BYTE __cil_tmp221 ;
  OPJ_INT32 tmp___4 ;
  OPJ_UINT32 ctxt1___5 ;
  OPJ_BYTE __cil_tmp226 ;
  OPJ_UINT32 l_c___29 ;
  OPJ_UINT32 __cil_tmp231 ;
  OPJ_UINT32 l_c___30 ;
  OPJ_UINT32 __cil_tmp236 ;
  OPJ_UINT32 lu___5 ;
  OPJ_UINT32 __cil_tmp238 ;
  OPJ_BYTE __cil_tmp239 ;
  OPJ_UINT32 l_c___31 ;
  OPJ_UINT32 __cil_tmp244 ;
  OPJ_UINT32 l_c___32 ;
  OPJ_UINT32 __cil_tmp249 ;
  OPJ_BYTE __cil_tmp250 ;
  OPJ_INT32 tmp___5 ;
  OPJ_UINT32 ctxt1___6 ;
  OPJ_BYTE __cil_tmp255 ;
  OPJ_UINT32 l_c___33 ;
  OPJ_UINT32 __cil_tmp260 ;
  OPJ_UINT32 l_c___34 ;
  OPJ_UINT32 __cil_tmp265 ;
  OPJ_UINT32 lu___6 ;
  OPJ_UINT32 __cil_tmp267 ;
  OPJ_BYTE __cil_tmp268 ;
  OPJ_UINT32 l_c___35 ;
  OPJ_UINT32 __cil_tmp273 ;
  OPJ_UINT32 l_c___36 ;
  OPJ_UINT32 __cil_tmp278 ;
  OPJ_BYTE __cil_tmp279 ;
  OPJ_INT32 tmp___6 ;
  opj_flag_t *south___6 ;

  {
#line 1364
  l_w = (OPJ_UINT32 )64;
#line 1364
  mqc = & t1->mqc;
#line 1364
  data = t1->data;
#line 1364
  flagsp = t1->flags + 67;
#line 1364
  curctx = mqc->curctx;
#line 1364
  c = mqc->c;
#line 1364
  a = mqc->a;
#line 1364
  ct = mqc->ct;
#line 1364
  one = 1 << bpno;
#line 1364
  half = one >> 1;
#line 1364
  oneplushalf = one | half;
#line 1364
  k = (OPJ_UINT32 )0;
  {
#line 1364
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1364
    if (! (k < 64U)) {
#line 1364
      goto while_break;
    }
#line 1364
    i = (OPJ_UINT32 )0;
    {
#line 1364
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 1364
      if (! (i < l_w)) {
#line 1364
        goto while_break___0;
      }
#line 1364
      flags = *flagsp;
#line 1364
      if (flags == 0U) {
#line 1364
        partial = (OPJ_UINT32 )1;
#line 1364
        curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 1364
        a -= (*curctx)->qeval;
#line 1364
        if (c >> 16 < (*curctx)->qeval) {
#line 1364
          if (a < (*curctx)->qeval) {
#line 1364
            a = (*curctx)->qeval;
#line 1364
            v = (*curctx)->mps;
#line 1364
            *curctx = (*curctx)->nmps;
          } else {
#line 1364
            a = (*curctx)->qeval;
#line 1364
            v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
            *curctx = (*curctx)->nlps;
          }
          {
#line 1364
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 1364
            if (ct == 0U) {
#line 1364
              l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
              if ((int )*(mqc->bp) == 255) {
#line 1364
                if (l_c > 143U) {
#line 1364
                  c += 65280U;
#line 1364
                  ct = (OPJ_UINT32 )8;
#line 1364
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1364
                  (mqc->bp) ++;
#line 1364
                  c += l_c << 9;
#line 1364
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1364
                (mqc->bp) ++;
#line 1364
                c += l_c << 8;
#line 1364
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1364
            a <<= 1;
#line 1364
            c <<= 1;
#line 1364
            __cil_tmp25 = ct;
#line 1364
            ct --;
#line 1364
            if (! (a < 32768U)) {
#line 1364
              goto while_break___1;
            }
          }
          while_break___51: /* CIL Label */ ;
          }
          while_break___1: ;
        } else {
#line 1364
          c -= (*curctx)->qeval << 16;
#line 1364
          if ((a & 32768U) == 0U) {
#line 1364
            if (a < (*curctx)->qeval) {
#line 1364
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
              *curctx = (*curctx)->nlps;
            } else {
#line 1364
              v = (*curctx)->mps;
#line 1364
              *curctx = (*curctx)->nmps;
            }
            {
#line 1364
            while (1) {
              while_continue___3: /* CIL Label */ ;

#line 1364
              if (ct == 0U) {
#line 1364
                l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                if ((int )*(mqc->bp) == 255) {
#line 1364
                  if (l_c___0 > 143U) {
#line 1364
                    c += 65280U;
#line 1364
                    ct = (OPJ_UINT32 )8;
#line 1364
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___0 << 9;
#line 1364
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1364
                  (mqc->bp) ++;
#line 1364
                  c += l_c___0 << 8;
#line 1364
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1364
              a <<= 1;
#line 1364
              c <<= 1;
#line 1364
              __cil_tmp30 = ct;
#line 1364
              ct --;
#line 1364
              if (! (a < 32768U)) {
#line 1364
                goto while_break___2;
              }
            }
            while_break___52: /* CIL Label */ ;
            }
            while_break___2: ;
          } else {
#line 1364
            v = (*curctx)->mps;
          }
        }
#line 1364
        if (! v) {
#line 1364
          goto while_continue___0;
        }
#line 1364
        curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1364
        a -= (*curctx)->qeval;
#line 1364
        if (c >> 16 < (*curctx)->qeval) {
#line 1364
          if (a < (*curctx)->qeval) {
#line 1364
            a = (*curctx)->qeval;
#line 1364
            runlen = (*curctx)->mps;
#line 1364
            *curctx = (*curctx)->nmps;
          } else {
#line 1364
            a = (*curctx)->qeval;
#line 1364
            runlen = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
            *curctx = (*curctx)->nlps;
          }
          {
#line 1364
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 1364
            if (ct == 0U) {
#line 1364
              l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
              if ((int )*(mqc->bp) == 255) {
#line 1364
                if (l_c___1 > 143U) {
#line 1364
                  c += 65280U;
#line 1364
                  ct = (OPJ_UINT32 )8;
#line 1364
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1364
                  (mqc->bp) ++;
#line 1364
                  c += l_c___1 << 9;
#line 1364
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1364
                (mqc->bp) ++;
#line 1364
                c += l_c___1 << 8;
#line 1364
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1364
            a <<= 1;
#line 1364
            c <<= 1;
#line 1364
            __cil_tmp35 = ct;
#line 1364
            ct --;
#line 1364
            if (! (a < 32768U)) {
#line 1364
              goto while_break___3;
            }
          }
          while_break___53: /* CIL Label */ ;
          }
          while_break___3: ;
        } else {
#line 1364
          c -= (*curctx)->qeval << 16;
#line 1364
          if ((a & 32768U) == 0U) {
#line 1364
            if (a < (*curctx)->qeval) {
#line 1364
              runlen = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
              *curctx = (*curctx)->nlps;
            } else {
#line 1364
              runlen = (*curctx)->mps;
#line 1364
              *curctx = (*curctx)->nmps;
            }
            {
#line 1364
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 1364
              if (ct == 0U) {
#line 1364
                l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                if ((int )*(mqc->bp) == 255) {
#line 1364
                  if (l_c___2 > 143U) {
#line 1364
                    c += 65280U;
#line 1364
                    ct = (OPJ_UINT32 )8;
#line 1364
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___2 << 9;
#line 1364
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1364
                  (mqc->bp) ++;
#line 1364
                  c += l_c___2 << 8;
#line 1364
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1364
              a <<= 1;
#line 1364
              c <<= 1;
#line 1364
              __cil_tmp40 = ct;
#line 1364
              ct --;
#line 1364
              if (! (a < 32768U)) {
#line 1364
                goto while_break___4;
              }
            }
            while_break___54: /* CIL Label */ ;
            }
            while_break___4: ;
          } else {
#line 1364
            runlen = (*curctx)->mps;
          }
        }
#line 1364
        a -= (*curctx)->qeval;
#line 1364
        if (c >> 16 < (*curctx)->qeval) {
#line 1364
          if (a < (*curctx)->qeval) {
#line 1364
            a = (*curctx)->qeval;
#line 1364
            v = (*curctx)->mps;
#line 1364
            *curctx = (*curctx)->nmps;
          } else {
#line 1364
            a = (*curctx)->qeval;
#line 1364
            v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
            *curctx = (*curctx)->nlps;
          }
          {
#line 1364
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 1364
            if (ct == 0U) {
#line 1364
              l_c___3 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
              if ((int )*(mqc->bp) == 255) {
#line 1364
                if (l_c___3 > 143U) {
#line 1364
                  c += 65280U;
#line 1364
                  ct = (OPJ_UINT32 )8;
#line 1364
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1364
                  (mqc->bp) ++;
#line 1364
                  c += l_c___3 << 9;
#line 1364
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1364
                (mqc->bp) ++;
#line 1364
                c += l_c___3 << 8;
#line 1364
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1364
            a <<= 1;
#line 1364
            c <<= 1;
#line 1364
            __cil_tmp45 = ct;
#line 1364
            ct --;
#line 1364
            if (! (a < 32768U)) {
#line 1364
              goto while_break___5;
            }
          }
          while_break___55: /* CIL Label */ ;
          }
          while_break___5: ;
        } else {
#line 1364
          c -= (*curctx)->qeval << 16;
#line 1364
          if ((a & 32768U) == 0U) {
#line 1364
            if (a < (*curctx)->qeval) {
#line 1364
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
              *curctx = (*curctx)->nlps;
            } else {
#line 1364
              v = (*curctx)->mps;
#line 1364
              *curctx = (*curctx)->nmps;
            }
            {
#line 1364
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 1364
              if (ct == 0U) {
#line 1364
                l_c___4 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                if ((int )*(mqc->bp) == 255) {
#line 1364
                  if (l_c___4 > 143U) {
#line 1364
                    c += 65280U;
#line 1364
                    ct = (OPJ_UINT32 )8;
#line 1364
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___4 << 9;
#line 1364
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1364
                  (mqc->bp) ++;
#line 1364
                  c += l_c___4 << 8;
#line 1364
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1364
              a <<= 1;
#line 1364
              c <<= 1;
#line 1364
              __cil_tmp50 = ct;
#line 1364
              ct --;
#line 1364
              if (! (a < 32768U)) {
#line 1364
                goto while_break___6;
              }
            }
            while_break___56: /* CIL Label */ ;
            }
            while_break___6: ;
          } else {
#line 1364
            v = (*curctx)->mps;
          }
        }
#line 1364
        runlen = (runlen << 1) | v;
#line 1364
        if (runlen == 0U) {
#line 1364
          goto case_0;
        }
#line 1364
        if (runlen == 1U) {
#line 1364
          goto case_1;
        }
#line 1364
        if (runlen == 2U) {
#line 1364
          goto case_2;
        }
#line 1364
        if (runlen == 3U) {
#line 1364
          goto case_3;
        }
#line 1364
        goto switch_break;
        case_0: 
        {
#line 1364
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 1364
          if (0) {
            {
#line 1364
            __cil_tmp52 = opj_t1_getctxno_zc(mqc, flags);
#line 1364
            ctxt1 = (OPJ_UINT32 )__cil_tmp52;
#line 1364
            curctx = & mqc->ctxs[ctxt1];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___9: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___5 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___5 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___5 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___5 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp57 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___8;
                }
              }
              while_break___58: /* CIL Label */ ;
              }
              while_break___8: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___10: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___6 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___6 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___6 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___6 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp62 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___9;
                  }
                }
                while_break___59: /* CIL Label */ ;
                }
                while_break___9: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
#line 1364
            if (! v) {
#line 1364
              goto while_break___7;
            }
          }
          {
#line 1364
          __cil_tmp64 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                         (OPJ_UINT32 )0);
#line 1364
          lu = __cil_tmp64;
#line 1364
          __cil_tmp65 = opj_t1_getctxno_sc(lu);
#line 1364
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp65];
#line 1364
          a -= (*curctx)->qeval;
          }
#line 1364
          if (c >> 16 < (*curctx)->qeval) {
#line 1364
            if (a < (*curctx)->qeval) {
#line 1364
              a = (*curctx)->qeval;
#line 1364
              v = (*curctx)->mps;
#line 1364
              *curctx = (*curctx)->nmps;
            } else {
#line 1364
              a = (*curctx)->qeval;
#line 1364
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
              *curctx = (*curctx)->nlps;
            }
            {
#line 1364
            while (1) {
              while_continue___11: /* CIL Label */ ;

#line 1364
              if (ct == 0U) {
#line 1364
                l_c___7 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                if ((int )*(mqc->bp) == 255) {
#line 1364
                  if (l_c___7 > 143U) {
#line 1364
                    c += 65280U;
#line 1364
                    ct = (OPJ_UINT32 )8;
#line 1364
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___7 << 9;
#line 1364
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1364
                  (mqc->bp) ++;
#line 1364
                  c += l_c___7 << 8;
#line 1364
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1364
              a <<= 1;
#line 1364
              c <<= 1;
#line 1364
              __cil_tmp70 = ct;
#line 1364
              ct --;
#line 1364
              if (! (a < 32768U)) {
#line 1364
                goto while_break___10;
              }
            }
            while_break___60: /* CIL Label */ ;
            }
            while_break___10: ;
          } else {
#line 1364
            c -= (*curctx)->qeval << 16;
#line 1364
            if ((a & 32768U) == 0U) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              } else {
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              }
              {
#line 1364
              while (1) {
                while_continue___12: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___8 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___8 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___8 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___8 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp75 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___11;
                }
              }
              while_break___61: /* CIL Label */ ;
              }
              while_break___11: ;
            } else {
#line 1364
              v = (*curctx)->mps;
            }
          }
          {
#line 1364
          __cil_tmp76 = opj_t1_getspb(lu);
#line 1364
          v ^= (unsigned int )__cil_tmp76;
          }
#line 1364
          if (v) {
#line 1364
            tmp = - oneplushalf;
          } else {
#line 1364
            tmp = oneplushalf;
          }
#line 1364
          *(data + 0U) = tmp;
#line 1364
          *(flagsp + -1) |= 1U << 5;
#line 1364
          flags |= (v << 19) | (1U << 4);
#line 1364
          *(flagsp + 1) |= 1U << 3;
#line 1364
          goto while_break___7;
        }
        while_break___57: /* CIL Label */ ;
        }
        while_break___7: 
#line 1364
        partial = (OPJ_UINT32 )0;
        case_1: 
        {
#line 1364
        while (1) {
          while_continue___13: /* CIL Label */ ;

#line 1364
          if (! partial) {
            {
#line 1364
            __cil_tmp81 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 1364
            ctxt1___0 = (OPJ_UINT32 )__cil_tmp81;
#line 1364
            curctx = & mqc->ctxs[ctxt1___0];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___14: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___9 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___9 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___9 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___9 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp86 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___13;
                }
              }
              while_break___63: /* CIL Label */ ;
              }
              while_break___13: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___15: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___10 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___10 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___10 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___10 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp91 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___14;
                  }
                }
                while_break___64: /* CIL Label */ ;
                }
                while_break___14: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
#line 1364
            if (! v) {
#line 1364
              goto while_break___12;
            }
          }
          {
#line 1364
          __cil_tmp93 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                         (OPJ_UINT32 )1);
#line 1364
          lu___0 = __cil_tmp93;
#line 1364
          __cil_tmp94 = opj_t1_getctxno_sc(lu___0);
#line 1364
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp94];
#line 1364
          a -= (*curctx)->qeval;
          }
#line 1364
          if (c >> 16 < (*curctx)->qeval) {
#line 1364
            if (a < (*curctx)->qeval) {
#line 1364
              a = (*curctx)->qeval;
#line 1364
              v = (*curctx)->mps;
#line 1364
              *curctx = (*curctx)->nmps;
            } else {
#line 1364
              a = (*curctx)->qeval;
#line 1364
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
              *curctx = (*curctx)->nlps;
            }
            {
#line 1364
            while (1) {
              while_continue___16: /* CIL Label */ ;

#line 1364
              if (ct == 0U) {
#line 1364
                l_c___11 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                if ((int )*(mqc->bp) == 255) {
#line 1364
                  if (l_c___11 > 143U) {
#line 1364
                    c += 65280U;
#line 1364
                    ct = (OPJ_UINT32 )8;
#line 1364
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___11 << 9;
#line 1364
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1364
                  (mqc->bp) ++;
#line 1364
                  c += l_c___11 << 8;
#line 1364
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1364
              a <<= 1;
#line 1364
              c <<= 1;
#line 1364
              __cil_tmp99 = ct;
#line 1364
              ct --;
#line 1364
              if (! (a < 32768U)) {
#line 1364
                goto while_break___15;
              }
            }
            while_break___65: /* CIL Label */ ;
            }
            while_break___15: ;
          } else {
#line 1364
            c -= (*curctx)->qeval << 16;
#line 1364
            if ((a & 32768U) == 0U) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              } else {
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              }
              {
#line 1364
              while (1) {
                while_continue___17: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___12 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___12 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___12 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___12 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp104 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___16;
                }
              }
              while_break___66: /* CIL Label */ ;
              }
              while_break___16: ;
            } else {
#line 1364
              v = (*curctx)->mps;
            }
          }
          {
#line 1364
          __cil_tmp105 = opj_t1_getspb(lu___0);
#line 1364
          v ^= (unsigned int )__cil_tmp105;
          }
#line 1364
          if (v) {
#line 1364
            tmp___0 = - oneplushalf;
          } else {
#line 1364
            tmp___0 = oneplushalf;
          }
#line 1364
          *(data + l_w) = tmp___0;
#line 1364
          *(flagsp + -1) |= (1U << 5) << 3U;
#line 1364
          flags |= ((v << 19) | (1U << 4)) << 3U;
#line 1364
          *(flagsp + 1) |= (1U << 3) << 3U;
#line 1364
          goto while_break___12;
        }
        while_break___62: /* CIL Label */ ;
        }
        while_break___12: 
#line 1364
        partial = (OPJ_UINT32 )0;
        case_2: 
        {
#line 1364
        while (1) {
          while_continue___18: /* CIL Label */ ;

#line 1364
          if (! partial) {
            {
#line 1364
            __cil_tmp110 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 1364
            ctxt1___1 = (OPJ_UINT32 )__cil_tmp110;
#line 1364
            curctx = & mqc->ctxs[ctxt1___1];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___19: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___13 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___13 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___13 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___13 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp115 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___18;
                }
              }
              while_break___68: /* CIL Label */ ;
              }
              while_break___18: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___20: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___14 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___14 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___14 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___14 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp120 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___19;
                  }
                }
                while_break___69: /* CIL Label */ ;
                }
                while_break___19: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
#line 1364
            if (! v) {
#line 1364
              goto while_break___17;
            }
          }
          {
#line 1364
          __cil_tmp122 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                          (OPJ_UINT32 )2);
#line 1364
          lu___1 = __cil_tmp122;
#line 1364
          __cil_tmp123 = opj_t1_getctxno_sc(lu___1);
#line 1364
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp123];
#line 1364
          a -= (*curctx)->qeval;
          }
#line 1364
          if (c >> 16 < (*curctx)->qeval) {
#line 1364
            if (a < (*curctx)->qeval) {
#line 1364
              a = (*curctx)->qeval;
#line 1364
              v = (*curctx)->mps;
#line 1364
              *curctx = (*curctx)->nmps;
            } else {
#line 1364
              a = (*curctx)->qeval;
#line 1364
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
              *curctx = (*curctx)->nlps;
            }
            {
#line 1364
            while (1) {
              while_continue___21: /* CIL Label */ ;

#line 1364
              if (ct == 0U) {
#line 1364
                l_c___15 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                if ((int )*(mqc->bp) == 255) {
#line 1364
                  if (l_c___15 > 143U) {
#line 1364
                    c += 65280U;
#line 1364
                    ct = (OPJ_UINT32 )8;
#line 1364
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___15 << 9;
#line 1364
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1364
                  (mqc->bp) ++;
#line 1364
                  c += l_c___15 << 8;
#line 1364
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1364
              a <<= 1;
#line 1364
              c <<= 1;
#line 1364
              __cil_tmp128 = ct;
#line 1364
              ct --;
#line 1364
              if (! (a < 32768U)) {
#line 1364
                goto while_break___20;
              }
            }
            while_break___70: /* CIL Label */ ;
            }
            while_break___20: ;
          } else {
#line 1364
            c -= (*curctx)->qeval << 16;
#line 1364
            if ((a & 32768U) == 0U) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              } else {
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              }
              {
#line 1364
              while (1) {
                while_continue___22: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___16 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___16 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___16 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___16 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp133 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___21;
                }
              }
              while_break___71: /* CIL Label */ ;
              }
              while_break___21: ;
            } else {
#line 1364
              v = (*curctx)->mps;
            }
          }
          {
#line 1364
          __cil_tmp134 = opj_t1_getspb(lu___1);
#line 1364
          v ^= (unsigned int )__cil_tmp134;
          }
#line 1364
          if (v) {
#line 1364
            tmp___1 = - oneplushalf;
          } else {
#line 1364
            tmp___1 = oneplushalf;
          }
#line 1364
          *(data + 2U * l_w) = tmp___1;
#line 1364
          *(flagsp + -1) |= (1U << 5) << 6U;
#line 1364
          flags |= ((v << 19) | (1U << 4)) << 6U;
#line 1364
          *(flagsp + 1) |= (1U << 3) << 6U;
#line 1364
          goto while_break___17;
        }
        while_break___67: /* CIL Label */ ;
        }
        while_break___17: 
#line 1364
        partial = (OPJ_UINT32 )0;
        case_3: 
        {
#line 1364
        while (1) {
          while_continue___23: /* CIL Label */ ;

#line 1364
          if (! partial) {
            {
#line 1364
            __cil_tmp139 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 1364
            ctxt1___2 = (OPJ_UINT32 )__cil_tmp139;
#line 1364
            curctx = & mqc->ctxs[ctxt1___2];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___24: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___17 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___17 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___17 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___17 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp144 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___23;
                }
              }
              while_break___73: /* CIL Label */ ;
              }
              while_break___23: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___25: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___18 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___18 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___18 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___18 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp149 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___24;
                  }
                }
                while_break___74: /* CIL Label */ ;
                }
                while_break___24: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
#line 1364
            if (! v) {
#line 1364
              goto while_break___22;
            }
          }
          {
#line 1364
          __cil_tmp151 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                          (OPJ_UINT32 )3);
#line 1364
          lu___2 = __cil_tmp151;
#line 1364
          __cil_tmp152 = opj_t1_getctxno_sc(lu___2);
#line 1364
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp152];
#line 1364
          a -= (*curctx)->qeval;
          }
#line 1364
          if (c >> 16 < (*curctx)->qeval) {
#line 1364
            if (a < (*curctx)->qeval) {
#line 1364
              a = (*curctx)->qeval;
#line 1364
              v = (*curctx)->mps;
#line 1364
              *curctx = (*curctx)->nmps;
            } else {
#line 1364
              a = (*curctx)->qeval;
#line 1364
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
              *curctx = (*curctx)->nlps;
            }
            {
#line 1364
            while (1) {
              while_continue___26: /* CIL Label */ ;

#line 1364
              if (ct == 0U) {
#line 1364
                l_c___19 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                if ((int )*(mqc->bp) == 255) {
#line 1364
                  if (l_c___19 > 143U) {
#line 1364
                    c += 65280U;
#line 1364
                    ct = (OPJ_UINT32 )8;
#line 1364
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___19 << 9;
#line 1364
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1364
                  (mqc->bp) ++;
#line 1364
                  c += l_c___19 << 8;
#line 1364
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1364
              a <<= 1;
#line 1364
              c <<= 1;
#line 1364
              __cil_tmp157 = ct;
#line 1364
              ct --;
#line 1364
              if (! (a < 32768U)) {
#line 1364
                goto while_break___25;
              }
            }
            while_break___75: /* CIL Label */ ;
            }
            while_break___25: ;
          } else {
#line 1364
            c -= (*curctx)->qeval << 16;
#line 1364
            if ((a & 32768U) == 0U) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              } else {
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              }
              {
#line 1364
              while (1) {
                while_continue___27: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___20 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___20 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___20 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___20 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp162 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___26;
                }
              }
              while_break___76: /* CIL Label */ ;
              }
              while_break___26: ;
            } else {
#line 1364
              v = (*curctx)->mps;
            }
          }
          {
#line 1364
          __cil_tmp163 = opj_t1_getspb(lu___2);
#line 1364
          v ^= (unsigned int )__cil_tmp163;
          }
#line 1364
          if (v) {
#line 1364
            tmp___2 = - oneplushalf;
          } else {
#line 1364
            tmp___2 = oneplushalf;
          }
#line 1364
          *(data + 3U * l_w) = tmp___2;
#line 1364
          *(flagsp + -1) |= (1U << 5) << 9U;
#line 1364
          flags |= ((v << 19) | (1U << 4)) << 9U;
#line 1364
          *(flagsp + 1) |= (1U << 3) << 9U;
#line 1364
          south___2 = flagsp + 66;
#line 1364
          *south___2 |= (v << 18) | (1U << 1);
#line 1364
          *(south___2 + -1) |= 1U << 2;
#line 1364
          *(south___2 + 1) |= 1U;
#line 1364
          goto while_break___22;
        }
        while_break___72: /* CIL Label */ ;
        }
        while_break___22: ;
#line 1364
        goto switch_break;
        switch_break: ;
      } else {
#line 1364
        if (! (flags & ((1U << 4) | (1U << 21)))) {
          {
#line 1364
          while (1) {
            while_continue___28: /* CIL Label */ ;
            {
#line 1364
            __cil_tmp168 = opj_t1_getctxno_zc(mqc, flags);
#line 1364
            ctxt1___3 = (OPJ_UINT32 )__cil_tmp168;
#line 1364
            curctx = & mqc->ctxs[ctxt1___3];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___29: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___21 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___21 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___21 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___21 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp173 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___28;
                }
              }
              while_break___78: /* CIL Label */ ;
              }
              while_break___28: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___30: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___22 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___22 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___22 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___22 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp178 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___29;
                  }
                }
                while_break___79: /* CIL Label */ ;
                }
                while_break___29: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
#line 1364
            if (! v) {
#line 1364
              goto while_break___27;
            }
            {
#line 1364
            __cil_tmp180 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )0);
#line 1364
            lu___3 = __cil_tmp180;
#line 1364
            __cil_tmp181 = opj_t1_getctxno_sc(lu___3);
#line 1364
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp181];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___31: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___23 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___23 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___23 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___23 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp186 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___30;
                }
              }
              while_break___80: /* CIL Label */ ;
              }
              while_break___30: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___32: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___24 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___24 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___24 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___24 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp191 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___31;
                  }
                }
                while_break___81: /* CIL Label */ ;
                }
                while_break___31: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
            {
#line 1364
            __cil_tmp192 = opj_t1_getspb(lu___3);
#line 1364
            v ^= (unsigned int )__cil_tmp192;
            }
#line 1364
            if (v) {
#line 1364
              tmp___3 = - oneplushalf;
            } else {
#line 1364
              tmp___3 = oneplushalf;
            }
#line 1364
            *(data + 0U) = tmp___3;
#line 1364
            *(flagsp + -1) |= 1U << 5;
#line 1364
            flags |= (v << 19) | (1U << 4);
#line 1364
            *(flagsp + 1) |= 1U << 3;
#line 1364
            goto while_break___27;
          }
          while_break___77: /* CIL Label */ ;
          }
          while_break___27: ;
        }
#line 1364
        if (! (flags & (((1U << 4) | (1U << 21)) << 3U))) {
          {
#line 1364
          while (1) {
            while_continue___33: /* CIL Label */ ;
            {
#line 1364
            __cil_tmp197 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 1364
            ctxt1___4 = (OPJ_UINT32 )__cil_tmp197;
#line 1364
            curctx = & mqc->ctxs[ctxt1___4];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___34: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___25 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___25 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___25 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___25 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp202 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___33;
                }
              }
              while_break___83: /* CIL Label */ ;
              }
              while_break___33: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___35: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___26 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___26 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___26 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___26 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp207 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___34;
                  }
                }
                while_break___84: /* CIL Label */ ;
                }
                while_break___34: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
#line 1364
            if (! v) {
#line 1364
              goto while_break___32;
            }
            {
#line 1364
            __cil_tmp209 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )1);
#line 1364
            lu___4 = __cil_tmp209;
#line 1364
            __cil_tmp210 = opj_t1_getctxno_sc(lu___4);
#line 1364
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp210];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___36: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___27 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___27 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___27 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___27 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp215 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___35;
                }
              }
              while_break___85: /* CIL Label */ ;
              }
              while_break___35: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___37: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___28 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___28 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___28 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___28 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp220 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___36;
                  }
                }
                while_break___86: /* CIL Label */ ;
                }
                while_break___36: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
            {
#line 1364
            __cil_tmp221 = opj_t1_getspb(lu___4);
#line 1364
            v ^= (unsigned int )__cil_tmp221;
            }
#line 1364
            if (v) {
#line 1364
              tmp___4 = - oneplushalf;
            } else {
#line 1364
              tmp___4 = oneplushalf;
            }
#line 1364
            *(data + l_w) = tmp___4;
#line 1364
            *(flagsp + -1) |= (1U << 5) << 3U;
#line 1364
            flags |= ((v << 19) | (1U << 4)) << 3U;
#line 1364
            *(flagsp + 1) |= (1U << 3) << 3U;
#line 1364
            goto while_break___32;
          }
          while_break___82: /* CIL Label */ ;
          }
          while_break___32: ;
        }
#line 1364
        if (! (flags & (((1U << 4) | (1U << 21)) << 6U))) {
          {
#line 1364
          while (1) {
            while_continue___38: /* CIL Label */ ;
            {
#line 1364
            __cil_tmp226 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 1364
            ctxt1___5 = (OPJ_UINT32 )__cil_tmp226;
#line 1364
            curctx = & mqc->ctxs[ctxt1___5];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___39: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___29 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___29 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___29 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___29 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp231 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___38;
                }
              }
              while_break___88: /* CIL Label */ ;
              }
              while_break___38: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___40: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___30 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___30 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___30 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___30 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp236 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___39;
                  }
                }
                while_break___89: /* CIL Label */ ;
                }
                while_break___39: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
#line 1364
            if (! v) {
#line 1364
              goto while_break___37;
            }
            {
#line 1364
            __cil_tmp238 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )2);
#line 1364
            lu___5 = __cil_tmp238;
#line 1364
            __cil_tmp239 = opj_t1_getctxno_sc(lu___5);
#line 1364
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp239];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___41: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___31 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___31 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___31 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___31 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp244 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___40;
                }
              }
              while_break___90: /* CIL Label */ ;
              }
              while_break___40: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___42: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___32 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___32 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___32 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___32 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp249 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___41;
                  }
                }
                while_break___91: /* CIL Label */ ;
                }
                while_break___41: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
            {
#line 1364
            __cil_tmp250 = opj_t1_getspb(lu___5);
#line 1364
            v ^= (unsigned int )__cil_tmp250;
            }
#line 1364
            if (v) {
#line 1364
              tmp___5 = - oneplushalf;
            } else {
#line 1364
              tmp___5 = oneplushalf;
            }
#line 1364
            *(data + 2U * l_w) = tmp___5;
#line 1364
            *(flagsp + -1) |= (1U << 5) << 6U;
#line 1364
            flags |= ((v << 19) | (1U << 4)) << 6U;
#line 1364
            *(flagsp + 1) |= (1U << 3) << 6U;
#line 1364
            goto while_break___37;
          }
          while_break___87: /* CIL Label */ ;
          }
          while_break___37: ;
        }
#line 1364
        if (! (flags & (((1U << 4) | (1U << 21)) << 9U))) {
          {
#line 1364
          while (1) {
            while_continue___43: /* CIL Label */ ;
            {
#line 1364
            __cil_tmp255 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 1364
            ctxt1___6 = (OPJ_UINT32 )__cil_tmp255;
#line 1364
            curctx = & mqc->ctxs[ctxt1___6];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___44: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___33 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___33 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___33 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___33 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp260 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___43;
                }
              }
              while_break___93: /* CIL Label */ ;
              }
              while_break___43: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___45: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___34 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___34 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___34 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___34 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp265 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___44;
                  }
                }
                while_break___94: /* CIL Label */ ;
                }
                while_break___44: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
#line 1364
            if (! v) {
#line 1364
              goto while_break___42;
            }
            {
#line 1364
            __cil_tmp267 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )3);
#line 1364
            lu___6 = __cil_tmp267;
#line 1364
            __cil_tmp268 = opj_t1_getctxno_sc(lu___6);
#line 1364
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp268];
#line 1364
            a -= (*curctx)->qeval;
            }
#line 1364
            if (c >> 16 < (*curctx)->qeval) {
#line 1364
              if (a < (*curctx)->qeval) {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (*curctx)->mps;
#line 1364
                *curctx = (*curctx)->nmps;
              } else {
#line 1364
                a = (*curctx)->qeval;
#line 1364
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                *curctx = (*curctx)->nlps;
              }
              {
#line 1364
              while (1) {
                while_continue___46: /* CIL Label */ ;

#line 1364
                if (ct == 0U) {
#line 1364
                  l_c___35 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                  if ((int )*(mqc->bp) == 255) {
#line 1364
                    if (l_c___35 > 143U) {
#line 1364
                      c += 65280U;
#line 1364
                      ct = (OPJ_UINT32 )8;
#line 1364
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___35 << 9;
#line 1364
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1364
                    (mqc->bp) ++;
#line 1364
                    c += l_c___35 << 8;
#line 1364
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1364
                a <<= 1;
#line 1364
                c <<= 1;
#line 1364
                __cil_tmp273 = ct;
#line 1364
                ct --;
#line 1364
                if (! (a < 32768U)) {
#line 1364
                  goto while_break___45;
                }
              }
              while_break___95: /* CIL Label */ ;
              }
              while_break___45: ;
            } else {
#line 1364
              c -= (*curctx)->qeval << 16;
#line 1364
              if ((a & 32768U) == 0U) {
#line 1364
                if (a < (*curctx)->qeval) {
#line 1364
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1364
                  *curctx = (*curctx)->nlps;
                } else {
#line 1364
                  v = (*curctx)->mps;
#line 1364
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1364
                while (1) {
                  while_continue___47: /* CIL Label */ ;

#line 1364
                  if (ct == 0U) {
#line 1364
                    l_c___36 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1364
                    if ((int )*(mqc->bp) == 255) {
#line 1364
                      if (l_c___36 > 143U) {
#line 1364
                        c += 65280U;
#line 1364
                        ct = (OPJ_UINT32 )8;
#line 1364
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1364
                        (mqc->bp) ++;
#line 1364
                        c += l_c___36 << 9;
#line 1364
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1364
                      (mqc->bp) ++;
#line 1364
                      c += l_c___36 << 8;
#line 1364
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1364
                  a <<= 1;
#line 1364
                  c <<= 1;
#line 1364
                  __cil_tmp278 = ct;
#line 1364
                  ct --;
#line 1364
                  if (! (a < 32768U)) {
#line 1364
                    goto while_break___46;
                  }
                }
                while_break___96: /* CIL Label */ ;
                }
                while_break___46: ;
              } else {
#line 1364
                v = (*curctx)->mps;
              }
            }
            {
#line 1364
            __cil_tmp279 = opj_t1_getspb(lu___6);
#line 1364
            v ^= (unsigned int )__cil_tmp279;
            }
#line 1364
            if (v) {
#line 1364
              tmp___6 = - oneplushalf;
            } else {
#line 1364
              tmp___6 = oneplushalf;
            }
#line 1364
            *(data + 3U * l_w) = tmp___6;
#line 1364
            *(flagsp + -1) |= (1U << 5) << 9U;
#line 1364
            flags |= ((v << 19) | (1U << 4)) << 9U;
#line 1364
            *(flagsp + 1) |= (1U << 3) << 9U;
#line 1364
            south___6 = flagsp + 66;
#line 1364
            *south___6 |= (v << 18) | (1U << 1);
#line 1364
            *(south___6 + -1) |= 1U << 2;
#line 1364
            *(south___6 + 1) |= 1U;
#line 1364
            goto while_break___42;
          }
          while_break___92: /* CIL Label */ ;
          }
          while_break___42: ;
        }
      }
#line 1364
      *flagsp = flags & ~ ((((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30));
#line 1364
      flagsp ++;
#line 1364
      data ++;
#line 1364
      i ++;
    }
    while_break___50: /* CIL Label */ ;
    }
    while_break___0: 
#line 1364
    flagsp += 2;
#line 1364
    data += 3U * l_w;
#line 1364
    k += 4U;
  }
  while_break___49: /* CIL Label */ ;
  }
  while_break: 
#line 1364
  mqc->curctx = curctx;
#line 1364
  mqc->c = c;
#line 1364
  mqc->a = a;
#line 1364
  mqc->ct = ct;
#line 1364
  if (k < 64U) {
#line 1364
    i = (OPJ_UINT32 )0;
    {
#line 1364
    while (1) {
      while_continue___48: /* CIL Label */ ;

#line 1364
      if (! (i < l_w)) {
#line 1364
        goto while_break___47;
      }
#line 1364
      j = (OPJ_UINT32 )0;
      {
#line 1364
      while (1) {
        while_continue___49: /* CIL Label */ ;

#line 1364
        if (! (j < 64U - k)) {
#line 1364
          goto while_break___48;
        }
        {
#line 1364
        opj_t1_dec_clnpass_step(t1, flagsp, data + j * l_w, oneplushalf, j, (OPJ_UINT32 )1);
#line 1364
        j ++;
        }
      }
      while_break___98: /* CIL Label */ ;
      }
      while_break___48: 
#line 1364
      *flagsp &= ~ ((((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30));
#line 1364
      data ++;
#line 1364
      flagsp ++;
#line 1364
      i ++;
    }
    while_break___97: /* CIL Label */ ;
    }
    while_break___47: ;
  }
#line 1370
  return;
}
}
#line 1367 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_generic_novsc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 runlen ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_w ;
  opj_mqc_t *mqc ;
  register OPJ_INT32 *data ;
  register opj_flag_t *flagsp ;
  register opj_mqc_state_t **curctx ;
  register OPJ_UINT32 c ;
  register OPJ_UINT32 a ;
  register OPJ_UINT32 ct ;
  register OPJ_UINT32 v ;
  opj_flag_t flags ;
  OPJ_UINT32 partial ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp40 ;
  OPJ_UINT32 l_c___3 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 l_c___4 ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp52 ;
  OPJ_UINT32 l_c___5 ;
  OPJ_UINT32 __cil_tmp57 ;
  OPJ_UINT32 l_c___6 ;
  OPJ_UINT32 __cil_tmp62 ;
  OPJ_UINT32 lu ;
  OPJ_UINT32 __cil_tmp64 ;
  OPJ_BYTE __cil_tmp65 ;
  OPJ_UINT32 l_c___7 ;
  OPJ_UINT32 __cil_tmp70 ;
  OPJ_UINT32 l_c___8 ;
  OPJ_UINT32 __cil_tmp75 ;
  OPJ_BYTE __cil_tmp76 ;
  OPJ_INT32 tmp ;
  opj_flag_t *north ;
  OPJ_UINT32 ctxt1___0 ;
  OPJ_BYTE __cil_tmp81 ;
  OPJ_UINT32 l_c___9 ;
  OPJ_UINT32 __cil_tmp86 ;
  OPJ_UINT32 l_c___10 ;
  OPJ_UINT32 __cil_tmp91 ;
  OPJ_UINT32 lu___0 ;
  OPJ_UINT32 __cil_tmp93 ;
  OPJ_BYTE __cil_tmp94 ;
  OPJ_UINT32 l_c___11 ;
  OPJ_UINT32 __cil_tmp99 ;
  OPJ_UINT32 l_c___12 ;
  OPJ_UINT32 __cil_tmp104 ;
  OPJ_BYTE __cil_tmp105 ;
  OPJ_INT32 tmp___0 ;
  OPJ_UINT32 ctxt1___1 ;
  OPJ_BYTE __cil_tmp110 ;
  OPJ_UINT32 l_c___13 ;
  OPJ_UINT32 __cil_tmp115 ;
  OPJ_UINT32 l_c___14 ;
  OPJ_UINT32 __cil_tmp120 ;
  OPJ_UINT32 lu___1 ;
  OPJ_UINT32 __cil_tmp122 ;
  OPJ_BYTE __cil_tmp123 ;
  OPJ_UINT32 l_c___15 ;
  OPJ_UINT32 __cil_tmp128 ;
  OPJ_UINT32 l_c___16 ;
  OPJ_UINT32 __cil_tmp133 ;
  OPJ_BYTE __cil_tmp134 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 ctxt1___2 ;
  OPJ_BYTE __cil_tmp139 ;
  OPJ_UINT32 l_c___17 ;
  OPJ_UINT32 __cil_tmp144 ;
  OPJ_UINT32 l_c___18 ;
  OPJ_UINT32 __cil_tmp149 ;
  OPJ_UINT32 lu___2 ;
  OPJ_UINT32 __cil_tmp151 ;
  OPJ_BYTE __cil_tmp152 ;
  OPJ_UINT32 l_c___19 ;
  OPJ_UINT32 __cil_tmp157 ;
  OPJ_UINT32 l_c___20 ;
  OPJ_UINT32 __cil_tmp162 ;
  OPJ_BYTE __cil_tmp163 ;
  OPJ_INT32 tmp___2 ;
  opj_flag_t *south___2 ;
  OPJ_UINT32 ctxt1___3 ;
  OPJ_BYTE __cil_tmp168 ;
  OPJ_UINT32 l_c___21 ;
  OPJ_UINT32 __cil_tmp173 ;
  OPJ_UINT32 l_c___22 ;
  OPJ_UINT32 __cil_tmp178 ;
  OPJ_UINT32 lu___3 ;
  OPJ_UINT32 __cil_tmp180 ;
  OPJ_BYTE __cil_tmp181 ;
  OPJ_UINT32 l_c___23 ;
  OPJ_UINT32 __cil_tmp186 ;
  OPJ_UINT32 l_c___24 ;
  OPJ_UINT32 __cil_tmp191 ;
  OPJ_BYTE __cil_tmp192 ;
  OPJ_INT32 tmp___3 ;
  opj_flag_t *north___3 ;
  OPJ_UINT32 ctxt1___4 ;
  OPJ_BYTE __cil_tmp197 ;
  OPJ_UINT32 l_c___25 ;
  OPJ_UINT32 __cil_tmp202 ;
  OPJ_UINT32 l_c___26 ;
  OPJ_UINT32 __cil_tmp207 ;
  OPJ_UINT32 lu___4 ;
  OPJ_UINT32 __cil_tmp209 ;
  OPJ_BYTE __cil_tmp210 ;
  OPJ_UINT32 l_c___27 ;
  OPJ_UINT32 __cil_tmp215 ;
  OPJ_UINT32 l_c___28 ;
  OPJ_UINT32 __cil_tmp220 ;
  OPJ_BYTE __cil_tmp221 ;
  OPJ_INT32 tmp___4 ;
  OPJ_UINT32 ctxt1___5 ;
  OPJ_BYTE __cil_tmp226 ;
  OPJ_UINT32 l_c___29 ;
  OPJ_UINT32 __cil_tmp231 ;
  OPJ_UINT32 l_c___30 ;
  OPJ_UINT32 __cil_tmp236 ;
  OPJ_UINT32 lu___5 ;
  OPJ_UINT32 __cil_tmp238 ;
  OPJ_BYTE __cil_tmp239 ;
  OPJ_UINT32 l_c___31 ;
  OPJ_UINT32 __cil_tmp244 ;
  OPJ_UINT32 l_c___32 ;
  OPJ_UINT32 __cil_tmp249 ;
  OPJ_BYTE __cil_tmp250 ;
  OPJ_INT32 tmp___5 ;
  OPJ_UINT32 ctxt1___6 ;
  OPJ_BYTE __cil_tmp255 ;
  OPJ_UINT32 l_c___33 ;
  OPJ_UINT32 __cil_tmp260 ;
  OPJ_UINT32 l_c___34 ;
  OPJ_UINT32 __cil_tmp265 ;
  OPJ_UINT32 lu___6 ;
  OPJ_UINT32 __cil_tmp267 ;
  OPJ_BYTE __cil_tmp268 ;
  OPJ_UINT32 l_c___35 ;
  OPJ_UINT32 __cil_tmp273 ;
  OPJ_UINT32 l_c___36 ;
  OPJ_UINT32 __cil_tmp278 ;
  OPJ_BYTE __cil_tmp279 ;
  OPJ_INT32 tmp___6 ;
  opj_flag_t *south___6 ;

  {
#line 1371
  l_w = t1->w;
#line 1371
  mqc = & t1->mqc;
#line 1371
  data = t1->data;
#line 1371
  flagsp = t1->flags + ((t1->w + 2U) + 1U);
#line 1371
  curctx = mqc->curctx;
#line 1371
  c = mqc->c;
#line 1371
  a = mqc->a;
#line 1371
  ct = mqc->ct;
#line 1371
  one = 1 << bpno;
#line 1371
  half = one >> 1;
#line 1371
  oneplushalf = one | half;
#line 1371
  k = (OPJ_UINT32 )0;
  {
#line 1371
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1371
    if (! (k < (t1->h & 4294967292U))) {
#line 1371
      goto while_break;
    }
#line 1371
    i = (OPJ_UINT32 )0;
    {
#line 1371
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 1371
      if (! (i < l_w)) {
#line 1371
        goto while_break___0;
      }
#line 1371
      flags = *flagsp;
#line 1371
      if (flags == 0U) {
#line 1371
        partial = (OPJ_UINT32 )1;
#line 1371
        curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 1371
        a -= (*curctx)->qeval;
#line 1371
        if (c >> 16 < (*curctx)->qeval) {
#line 1371
          if (a < (*curctx)->qeval) {
#line 1371
            a = (*curctx)->qeval;
#line 1371
            v = (*curctx)->mps;
#line 1371
            *curctx = (*curctx)->nmps;
          } else {
#line 1371
            a = (*curctx)->qeval;
#line 1371
            v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
            *curctx = (*curctx)->nlps;
          }
          {
#line 1371
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 1371
            if (ct == 0U) {
#line 1371
              l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
              if ((int )*(mqc->bp) == 255) {
#line 1371
                if (l_c > 143U) {
#line 1371
                  c += 65280U;
#line 1371
                  ct = (OPJ_UINT32 )8;
#line 1371
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1371
                  (mqc->bp) ++;
#line 1371
                  c += l_c << 9;
#line 1371
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1371
                (mqc->bp) ++;
#line 1371
                c += l_c << 8;
#line 1371
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1371
            a <<= 1;
#line 1371
            c <<= 1;
#line 1371
            __cil_tmp25 = ct;
#line 1371
            ct --;
#line 1371
            if (! (a < 32768U)) {
#line 1371
              goto while_break___1;
            }
          }
          while_break___51: /* CIL Label */ ;
          }
          while_break___1: ;
        } else {
#line 1371
          c -= (*curctx)->qeval << 16;
#line 1371
          if ((a & 32768U) == 0U) {
#line 1371
            if (a < (*curctx)->qeval) {
#line 1371
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
              *curctx = (*curctx)->nlps;
            } else {
#line 1371
              v = (*curctx)->mps;
#line 1371
              *curctx = (*curctx)->nmps;
            }
            {
#line 1371
            while (1) {
              while_continue___3: /* CIL Label */ ;

#line 1371
              if (ct == 0U) {
#line 1371
                l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                if ((int )*(mqc->bp) == 255) {
#line 1371
                  if (l_c___0 > 143U) {
#line 1371
                    c += 65280U;
#line 1371
                    ct = (OPJ_UINT32 )8;
#line 1371
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___0 << 9;
#line 1371
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1371
                  (mqc->bp) ++;
#line 1371
                  c += l_c___0 << 8;
#line 1371
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1371
              a <<= 1;
#line 1371
              c <<= 1;
#line 1371
              __cil_tmp30 = ct;
#line 1371
              ct --;
#line 1371
              if (! (a < 32768U)) {
#line 1371
                goto while_break___2;
              }
            }
            while_break___52: /* CIL Label */ ;
            }
            while_break___2: ;
          } else {
#line 1371
            v = (*curctx)->mps;
          }
        }
#line 1371
        if (! v) {
#line 1371
          goto while_continue___0;
        }
#line 1371
        curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1371
        a -= (*curctx)->qeval;
#line 1371
        if (c >> 16 < (*curctx)->qeval) {
#line 1371
          if (a < (*curctx)->qeval) {
#line 1371
            a = (*curctx)->qeval;
#line 1371
            runlen = (*curctx)->mps;
#line 1371
            *curctx = (*curctx)->nmps;
          } else {
#line 1371
            a = (*curctx)->qeval;
#line 1371
            runlen = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
            *curctx = (*curctx)->nlps;
          }
          {
#line 1371
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 1371
            if (ct == 0U) {
#line 1371
              l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
              if ((int )*(mqc->bp) == 255) {
#line 1371
                if (l_c___1 > 143U) {
#line 1371
                  c += 65280U;
#line 1371
                  ct = (OPJ_UINT32 )8;
#line 1371
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1371
                  (mqc->bp) ++;
#line 1371
                  c += l_c___1 << 9;
#line 1371
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1371
                (mqc->bp) ++;
#line 1371
                c += l_c___1 << 8;
#line 1371
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1371
            a <<= 1;
#line 1371
            c <<= 1;
#line 1371
            __cil_tmp35 = ct;
#line 1371
            ct --;
#line 1371
            if (! (a < 32768U)) {
#line 1371
              goto while_break___3;
            }
          }
          while_break___53: /* CIL Label */ ;
          }
          while_break___3: ;
        } else {
#line 1371
          c -= (*curctx)->qeval << 16;
#line 1371
          if ((a & 32768U) == 0U) {
#line 1371
            if (a < (*curctx)->qeval) {
#line 1371
              runlen = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
              *curctx = (*curctx)->nlps;
            } else {
#line 1371
              runlen = (*curctx)->mps;
#line 1371
              *curctx = (*curctx)->nmps;
            }
            {
#line 1371
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 1371
              if (ct == 0U) {
#line 1371
                l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                if ((int )*(mqc->bp) == 255) {
#line 1371
                  if (l_c___2 > 143U) {
#line 1371
                    c += 65280U;
#line 1371
                    ct = (OPJ_UINT32 )8;
#line 1371
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___2 << 9;
#line 1371
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1371
                  (mqc->bp) ++;
#line 1371
                  c += l_c___2 << 8;
#line 1371
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1371
              a <<= 1;
#line 1371
              c <<= 1;
#line 1371
              __cil_tmp40 = ct;
#line 1371
              ct --;
#line 1371
              if (! (a < 32768U)) {
#line 1371
                goto while_break___4;
              }
            }
            while_break___54: /* CIL Label */ ;
            }
            while_break___4: ;
          } else {
#line 1371
            runlen = (*curctx)->mps;
          }
        }
#line 1371
        a -= (*curctx)->qeval;
#line 1371
        if (c >> 16 < (*curctx)->qeval) {
#line 1371
          if (a < (*curctx)->qeval) {
#line 1371
            a = (*curctx)->qeval;
#line 1371
            v = (*curctx)->mps;
#line 1371
            *curctx = (*curctx)->nmps;
          } else {
#line 1371
            a = (*curctx)->qeval;
#line 1371
            v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
            *curctx = (*curctx)->nlps;
          }
          {
#line 1371
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 1371
            if (ct == 0U) {
#line 1371
              l_c___3 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
              if ((int )*(mqc->bp) == 255) {
#line 1371
                if (l_c___3 > 143U) {
#line 1371
                  c += 65280U;
#line 1371
                  ct = (OPJ_UINT32 )8;
#line 1371
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1371
                  (mqc->bp) ++;
#line 1371
                  c += l_c___3 << 9;
#line 1371
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1371
                (mqc->bp) ++;
#line 1371
                c += l_c___3 << 8;
#line 1371
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1371
            a <<= 1;
#line 1371
            c <<= 1;
#line 1371
            __cil_tmp45 = ct;
#line 1371
            ct --;
#line 1371
            if (! (a < 32768U)) {
#line 1371
              goto while_break___5;
            }
          }
          while_break___55: /* CIL Label */ ;
          }
          while_break___5: ;
        } else {
#line 1371
          c -= (*curctx)->qeval << 16;
#line 1371
          if ((a & 32768U) == 0U) {
#line 1371
            if (a < (*curctx)->qeval) {
#line 1371
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
              *curctx = (*curctx)->nlps;
            } else {
#line 1371
              v = (*curctx)->mps;
#line 1371
              *curctx = (*curctx)->nmps;
            }
            {
#line 1371
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 1371
              if (ct == 0U) {
#line 1371
                l_c___4 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                if ((int )*(mqc->bp) == 255) {
#line 1371
                  if (l_c___4 > 143U) {
#line 1371
                    c += 65280U;
#line 1371
                    ct = (OPJ_UINT32 )8;
#line 1371
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___4 << 9;
#line 1371
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1371
                  (mqc->bp) ++;
#line 1371
                  c += l_c___4 << 8;
#line 1371
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1371
              a <<= 1;
#line 1371
              c <<= 1;
#line 1371
              __cil_tmp50 = ct;
#line 1371
              ct --;
#line 1371
              if (! (a < 32768U)) {
#line 1371
                goto while_break___6;
              }
            }
            while_break___56: /* CIL Label */ ;
            }
            while_break___6: ;
          } else {
#line 1371
            v = (*curctx)->mps;
          }
        }
#line 1371
        runlen = (runlen << 1) | v;
#line 1371
        if (runlen == 0U) {
#line 1371
          goto case_0;
        }
#line 1371
        if (runlen == 1U) {
#line 1371
          goto case_1;
        }
#line 1371
        if (runlen == 2U) {
#line 1371
          goto case_2;
        }
#line 1371
        if (runlen == 3U) {
#line 1371
          goto case_3;
        }
#line 1371
        goto switch_break;
        case_0: 
        {
#line 1371
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 1371
          if (0) {
            {
#line 1371
            __cil_tmp52 = opj_t1_getctxno_zc(mqc, flags);
#line 1371
            ctxt1 = (OPJ_UINT32 )__cil_tmp52;
#line 1371
            curctx = & mqc->ctxs[ctxt1];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___9: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___5 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___5 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___5 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___5 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp57 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___8;
                }
              }
              while_break___58: /* CIL Label */ ;
              }
              while_break___8: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___10: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___6 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___6 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___6 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___6 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp62 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___9;
                  }
                }
                while_break___59: /* CIL Label */ ;
                }
                while_break___9: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
#line 1371
            if (! v) {
#line 1371
              goto while_break___7;
            }
          }
          {
#line 1371
          __cil_tmp64 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                         (OPJ_UINT32 )0);
#line 1371
          lu = __cil_tmp64;
#line 1371
          __cil_tmp65 = opj_t1_getctxno_sc(lu);
#line 1371
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp65];
#line 1371
          a -= (*curctx)->qeval;
          }
#line 1371
          if (c >> 16 < (*curctx)->qeval) {
#line 1371
            if (a < (*curctx)->qeval) {
#line 1371
              a = (*curctx)->qeval;
#line 1371
              v = (*curctx)->mps;
#line 1371
              *curctx = (*curctx)->nmps;
            } else {
#line 1371
              a = (*curctx)->qeval;
#line 1371
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
              *curctx = (*curctx)->nlps;
            }
            {
#line 1371
            while (1) {
              while_continue___11: /* CIL Label */ ;

#line 1371
              if (ct == 0U) {
#line 1371
                l_c___7 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                if ((int )*(mqc->bp) == 255) {
#line 1371
                  if (l_c___7 > 143U) {
#line 1371
                    c += 65280U;
#line 1371
                    ct = (OPJ_UINT32 )8;
#line 1371
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___7 << 9;
#line 1371
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1371
                  (mqc->bp) ++;
#line 1371
                  c += l_c___7 << 8;
#line 1371
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1371
              a <<= 1;
#line 1371
              c <<= 1;
#line 1371
              __cil_tmp70 = ct;
#line 1371
              ct --;
#line 1371
              if (! (a < 32768U)) {
#line 1371
                goto while_break___10;
              }
            }
            while_break___60: /* CIL Label */ ;
            }
            while_break___10: ;
          } else {
#line 1371
            c -= (*curctx)->qeval << 16;
#line 1371
            if ((a & 32768U) == 0U) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              } else {
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              }
              {
#line 1371
              while (1) {
                while_continue___12: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___8 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___8 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___8 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___8 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp75 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___11;
                }
              }
              while_break___61: /* CIL Label */ ;
              }
              while_break___11: ;
            } else {
#line 1371
              v = (*curctx)->mps;
            }
          }
          {
#line 1371
          __cil_tmp76 = opj_t1_getspb(lu);
#line 1371
          v ^= (unsigned int )__cil_tmp76;
          }
#line 1371
          if (v) {
#line 1371
            tmp = - oneplushalf;
          } else {
#line 1371
            tmp = oneplushalf;
          }
#line 1371
          *(data + 0U) = tmp;
#line 1371
          *(flagsp + -1) |= 1U << 5;
#line 1371
          flags |= (v << 19) | (1U << 4);
#line 1371
          *(flagsp + 1) |= 1U << 3;
#line 1371
          north = flagsp - (t1->w + 2U);
#line 1371
          *north |= (v << 31) | (1U << 16);
#line 1371
          *(north + -1) |= 1U << 17;
#line 1371
          *(north + 1) |= 1U << 15;
#line 1371
          goto while_break___7;
        }
        while_break___57: /* CIL Label */ ;
        }
        while_break___7: 
#line 1371
        partial = (OPJ_UINT32 )0;
        case_1: 
        {
#line 1371
        while (1) {
          while_continue___13: /* CIL Label */ ;

#line 1371
          if (! partial) {
            {
#line 1371
            __cil_tmp81 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 1371
            ctxt1___0 = (OPJ_UINT32 )__cil_tmp81;
#line 1371
            curctx = & mqc->ctxs[ctxt1___0];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___14: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___9 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___9 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___9 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___9 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp86 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___13;
                }
              }
              while_break___63: /* CIL Label */ ;
              }
              while_break___13: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___15: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___10 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___10 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___10 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___10 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp91 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___14;
                  }
                }
                while_break___64: /* CIL Label */ ;
                }
                while_break___14: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
#line 1371
            if (! v) {
#line 1371
              goto while_break___12;
            }
          }
          {
#line 1371
          __cil_tmp93 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                         (OPJ_UINT32 )1);
#line 1371
          lu___0 = __cil_tmp93;
#line 1371
          __cil_tmp94 = opj_t1_getctxno_sc(lu___0);
#line 1371
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp94];
#line 1371
          a -= (*curctx)->qeval;
          }
#line 1371
          if (c >> 16 < (*curctx)->qeval) {
#line 1371
            if (a < (*curctx)->qeval) {
#line 1371
              a = (*curctx)->qeval;
#line 1371
              v = (*curctx)->mps;
#line 1371
              *curctx = (*curctx)->nmps;
            } else {
#line 1371
              a = (*curctx)->qeval;
#line 1371
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
              *curctx = (*curctx)->nlps;
            }
            {
#line 1371
            while (1) {
              while_continue___16: /* CIL Label */ ;

#line 1371
              if (ct == 0U) {
#line 1371
                l_c___11 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                if ((int )*(mqc->bp) == 255) {
#line 1371
                  if (l_c___11 > 143U) {
#line 1371
                    c += 65280U;
#line 1371
                    ct = (OPJ_UINT32 )8;
#line 1371
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___11 << 9;
#line 1371
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1371
                  (mqc->bp) ++;
#line 1371
                  c += l_c___11 << 8;
#line 1371
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1371
              a <<= 1;
#line 1371
              c <<= 1;
#line 1371
              __cil_tmp99 = ct;
#line 1371
              ct --;
#line 1371
              if (! (a < 32768U)) {
#line 1371
                goto while_break___15;
              }
            }
            while_break___65: /* CIL Label */ ;
            }
            while_break___15: ;
          } else {
#line 1371
            c -= (*curctx)->qeval << 16;
#line 1371
            if ((a & 32768U) == 0U) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              } else {
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              }
              {
#line 1371
              while (1) {
                while_continue___17: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___12 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___12 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___12 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___12 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp104 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___16;
                }
              }
              while_break___66: /* CIL Label */ ;
              }
              while_break___16: ;
            } else {
#line 1371
              v = (*curctx)->mps;
            }
          }
          {
#line 1371
          __cil_tmp105 = opj_t1_getspb(lu___0);
#line 1371
          v ^= (unsigned int )__cil_tmp105;
          }
#line 1371
          if (v) {
#line 1371
            tmp___0 = - oneplushalf;
          } else {
#line 1371
            tmp___0 = oneplushalf;
          }
#line 1371
          *(data + l_w) = tmp___0;
#line 1371
          *(flagsp + -1) |= (1U << 5) << 3U;
#line 1371
          flags |= ((v << 19) | (1U << 4)) << 3U;
#line 1371
          *(flagsp + 1) |= (1U << 3) << 3U;
#line 1371
          goto while_break___12;
        }
        while_break___62: /* CIL Label */ ;
        }
        while_break___12: 
#line 1371
        partial = (OPJ_UINT32 )0;
        case_2: 
        {
#line 1371
        while (1) {
          while_continue___18: /* CIL Label */ ;

#line 1371
          if (! partial) {
            {
#line 1371
            __cil_tmp110 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 1371
            ctxt1___1 = (OPJ_UINT32 )__cil_tmp110;
#line 1371
            curctx = & mqc->ctxs[ctxt1___1];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___19: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___13 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___13 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___13 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___13 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp115 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___18;
                }
              }
              while_break___68: /* CIL Label */ ;
              }
              while_break___18: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___20: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___14 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___14 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___14 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___14 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp120 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___19;
                  }
                }
                while_break___69: /* CIL Label */ ;
                }
                while_break___19: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
#line 1371
            if (! v) {
#line 1371
              goto while_break___17;
            }
          }
          {
#line 1371
          __cil_tmp122 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                          (OPJ_UINT32 )2);
#line 1371
          lu___1 = __cil_tmp122;
#line 1371
          __cil_tmp123 = opj_t1_getctxno_sc(lu___1);
#line 1371
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp123];
#line 1371
          a -= (*curctx)->qeval;
          }
#line 1371
          if (c >> 16 < (*curctx)->qeval) {
#line 1371
            if (a < (*curctx)->qeval) {
#line 1371
              a = (*curctx)->qeval;
#line 1371
              v = (*curctx)->mps;
#line 1371
              *curctx = (*curctx)->nmps;
            } else {
#line 1371
              a = (*curctx)->qeval;
#line 1371
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
              *curctx = (*curctx)->nlps;
            }
            {
#line 1371
            while (1) {
              while_continue___21: /* CIL Label */ ;

#line 1371
              if (ct == 0U) {
#line 1371
                l_c___15 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                if ((int )*(mqc->bp) == 255) {
#line 1371
                  if (l_c___15 > 143U) {
#line 1371
                    c += 65280U;
#line 1371
                    ct = (OPJ_UINT32 )8;
#line 1371
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___15 << 9;
#line 1371
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1371
                  (mqc->bp) ++;
#line 1371
                  c += l_c___15 << 8;
#line 1371
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1371
              a <<= 1;
#line 1371
              c <<= 1;
#line 1371
              __cil_tmp128 = ct;
#line 1371
              ct --;
#line 1371
              if (! (a < 32768U)) {
#line 1371
                goto while_break___20;
              }
            }
            while_break___70: /* CIL Label */ ;
            }
            while_break___20: ;
          } else {
#line 1371
            c -= (*curctx)->qeval << 16;
#line 1371
            if ((a & 32768U) == 0U) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              } else {
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              }
              {
#line 1371
              while (1) {
                while_continue___22: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___16 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___16 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___16 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___16 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp133 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___21;
                }
              }
              while_break___71: /* CIL Label */ ;
              }
              while_break___21: ;
            } else {
#line 1371
              v = (*curctx)->mps;
            }
          }
          {
#line 1371
          __cil_tmp134 = opj_t1_getspb(lu___1);
#line 1371
          v ^= (unsigned int )__cil_tmp134;
          }
#line 1371
          if (v) {
#line 1371
            tmp___1 = - oneplushalf;
          } else {
#line 1371
            tmp___1 = oneplushalf;
          }
#line 1371
          *(data + 2U * l_w) = tmp___1;
#line 1371
          *(flagsp + -1) |= (1U << 5) << 6U;
#line 1371
          flags |= ((v << 19) | (1U << 4)) << 6U;
#line 1371
          *(flagsp + 1) |= (1U << 3) << 6U;
#line 1371
          goto while_break___17;
        }
        while_break___67: /* CIL Label */ ;
        }
        while_break___17: 
#line 1371
        partial = (OPJ_UINT32 )0;
        case_3: 
        {
#line 1371
        while (1) {
          while_continue___23: /* CIL Label */ ;

#line 1371
          if (! partial) {
            {
#line 1371
            __cil_tmp139 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 1371
            ctxt1___2 = (OPJ_UINT32 )__cil_tmp139;
#line 1371
            curctx = & mqc->ctxs[ctxt1___2];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___24: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___17 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___17 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___17 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___17 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp144 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___23;
                }
              }
              while_break___73: /* CIL Label */ ;
              }
              while_break___23: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___25: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___18 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___18 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___18 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___18 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp149 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___24;
                  }
                }
                while_break___74: /* CIL Label */ ;
                }
                while_break___24: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
#line 1371
            if (! v) {
#line 1371
              goto while_break___22;
            }
          }
          {
#line 1371
          __cil_tmp151 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                          (OPJ_UINT32 )3);
#line 1371
          lu___2 = __cil_tmp151;
#line 1371
          __cil_tmp152 = opj_t1_getctxno_sc(lu___2);
#line 1371
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp152];
#line 1371
          a -= (*curctx)->qeval;
          }
#line 1371
          if (c >> 16 < (*curctx)->qeval) {
#line 1371
            if (a < (*curctx)->qeval) {
#line 1371
              a = (*curctx)->qeval;
#line 1371
              v = (*curctx)->mps;
#line 1371
              *curctx = (*curctx)->nmps;
            } else {
#line 1371
              a = (*curctx)->qeval;
#line 1371
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
              *curctx = (*curctx)->nlps;
            }
            {
#line 1371
            while (1) {
              while_continue___26: /* CIL Label */ ;

#line 1371
              if (ct == 0U) {
#line 1371
                l_c___19 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                if ((int )*(mqc->bp) == 255) {
#line 1371
                  if (l_c___19 > 143U) {
#line 1371
                    c += 65280U;
#line 1371
                    ct = (OPJ_UINT32 )8;
#line 1371
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___19 << 9;
#line 1371
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1371
                  (mqc->bp) ++;
#line 1371
                  c += l_c___19 << 8;
#line 1371
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1371
              a <<= 1;
#line 1371
              c <<= 1;
#line 1371
              __cil_tmp157 = ct;
#line 1371
              ct --;
#line 1371
              if (! (a < 32768U)) {
#line 1371
                goto while_break___25;
              }
            }
            while_break___75: /* CIL Label */ ;
            }
            while_break___25: ;
          } else {
#line 1371
            c -= (*curctx)->qeval << 16;
#line 1371
            if ((a & 32768U) == 0U) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              } else {
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              }
              {
#line 1371
              while (1) {
                while_continue___27: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___20 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___20 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___20 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___20 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp162 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___26;
                }
              }
              while_break___76: /* CIL Label */ ;
              }
              while_break___26: ;
            } else {
#line 1371
              v = (*curctx)->mps;
            }
          }
          {
#line 1371
          __cil_tmp163 = opj_t1_getspb(lu___2);
#line 1371
          v ^= (unsigned int )__cil_tmp163;
          }
#line 1371
          if (v) {
#line 1371
            tmp___2 = - oneplushalf;
          } else {
#line 1371
            tmp___2 = oneplushalf;
          }
#line 1371
          *(data + 3U * l_w) = tmp___2;
#line 1371
          *(flagsp + -1) |= (1U << 5) << 9U;
#line 1371
          flags |= ((v << 19) | (1U << 4)) << 9U;
#line 1371
          *(flagsp + 1) |= (1U << 3) << 9U;
#line 1371
          south___2 = flagsp + (t1->w + 2U);
#line 1371
          *south___2 |= (v << 18) | (1U << 1);
#line 1371
          *(south___2 + -1) |= 1U << 2;
#line 1371
          *(south___2 + 1) |= 1U;
#line 1371
          goto while_break___22;
        }
        while_break___72: /* CIL Label */ ;
        }
        while_break___22: ;
#line 1371
        goto switch_break;
        switch_break: ;
      } else {
#line 1371
        if (! (flags & ((1U << 4) | (1U << 21)))) {
          {
#line 1371
          while (1) {
            while_continue___28: /* CIL Label */ ;
            {
#line 1371
            __cil_tmp168 = opj_t1_getctxno_zc(mqc, flags);
#line 1371
            ctxt1___3 = (OPJ_UINT32 )__cil_tmp168;
#line 1371
            curctx = & mqc->ctxs[ctxt1___3];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___29: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___21 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___21 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___21 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___21 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp173 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___28;
                }
              }
              while_break___78: /* CIL Label */ ;
              }
              while_break___28: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___30: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___22 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___22 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___22 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___22 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp178 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___29;
                  }
                }
                while_break___79: /* CIL Label */ ;
                }
                while_break___29: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
#line 1371
            if (! v) {
#line 1371
              goto while_break___27;
            }
            {
#line 1371
            __cil_tmp180 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )0);
#line 1371
            lu___3 = __cil_tmp180;
#line 1371
            __cil_tmp181 = opj_t1_getctxno_sc(lu___3);
#line 1371
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp181];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___31: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___23 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___23 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___23 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___23 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp186 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___30;
                }
              }
              while_break___80: /* CIL Label */ ;
              }
              while_break___30: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___32: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___24 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___24 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___24 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___24 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp191 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___31;
                  }
                }
                while_break___81: /* CIL Label */ ;
                }
                while_break___31: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
            {
#line 1371
            __cil_tmp192 = opj_t1_getspb(lu___3);
#line 1371
            v ^= (unsigned int )__cil_tmp192;
            }
#line 1371
            if (v) {
#line 1371
              tmp___3 = - oneplushalf;
            } else {
#line 1371
              tmp___3 = oneplushalf;
            }
#line 1371
            *(data + 0U) = tmp___3;
#line 1371
            *(flagsp + -1) |= 1U << 5;
#line 1371
            flags |= (v << 19) | (1U << 4);
#line 1371
            *(flagsp + 1) |= 1U << 3;
#line 1371
            north___3 = flagsp - (t1->w + 2U);
#line 1371
            *north___3 |= (v << 31) | (1U << 16);
#line 1371
            *(north___3 + -1) |= 1U << 17;
#line 1371
            *(north___3 + 1) |= 1U << 15;
#line 1371
            goto while_break___27;
          }
          while_break___77: /* CIL Label */ ;
          }
          while_break___27: ;
        }
#line 1371
        if (! (flags & (((1U << 4) | (1U << 21)) << 3U))) {
          {
#line 1371
          while (1) {
            while_continue___33: /* CIL Label */ ;
            {
#line 1371
            __cil_tmp197 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 1371
            ctxt1___4 = (OPJ_UINT32 )__cil_tmp197;
#line 1371
            curctx = & mqc->ctxs[ctxt1___4];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___34: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___25 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___25 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___25 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___25 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp202 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___33;
                }
              }
              while_break___83: /* CIL Label */ ;
              }
              while_break___33: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___35: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___26 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___26 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___26 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___26 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp207 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___34;
                  }
                }
                while_break___84: /* CIL Label */ ;
                }
                while_break___34: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
#line 1371
            if (! v) {
#line 1371
              goto while_break___32;
            }
            {
#line 1371
            __cil_tmp209 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )1);
#line 1371
            lu___4 = __cil_tmp209;
#line 1371
            __cil_tmp210 = opj_t1_getctxno_sc(lu___4);
#line 1371
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp210];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___36: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___27 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___27 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___27 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___27 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp215 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___35;
                }
              }
              while_break___85: /* CIL Label */ ;
              }
              while_break___35: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___37: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___28 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___28 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___28 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___28 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp220 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___36;
                  }
                }
                while_break___86: /* CIL Label */ ;
                }
                while_break___36: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
            {
#line 1371
            __cil_tmp221 = opj_t1_getspb(lu___4);
#line 1371
            v ^= (unsigned int )__cil_tmp221;
            }
#line 1371
            if (v) {
#line 1371
              tmp___4 = - oneplushalf;
            } else {
#line 1371
              tmp___4 = oneplushalf;
            }
#line 1371
            *(data + l_w) = tmp___4;
#line 1371
            *(flagsp + -1) |= (1U << 5) << 3U;
#line 1371
            flags |= ((v << 19) | (1U << 4)) << 3U;
#line 1371
            *(flagsp + 1) |= (1U << 3) << 3U;
#line 1371
            goto while_break___32;
          }
          while_break___82: /* CIL Label */ ;
          }
          while_break___32: ;
        }
#line 1371
        if (! (flags & (((1U << 4) | (1U << 21)) << 6U))) {
          {
#line 1371
          while (1) {
            while_continue___38: /* CIL Label */ ;
            {
#line 1371
            __cil_tmp226 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 1371
            ctxt1___5 = (OPJ_UINT32 )__cil_tmp226;
#line 1371
            curctx = & mqc->ctxs[ctxt1___5];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___39: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___29 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___29 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___29 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___29 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp231 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___38;
                }
              }
              while_break___88: /* CIL Label */ ;
              }
              while_break___38: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___40: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___30 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___30 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___30 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___30 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp236 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___39;
                  }
                }
                while_break___89: /* CIL Label */ ;
                }
                while_break___39: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
#line 1371
            if (! v) {
#line 1371
              goto while_break___37;
            }
            {
#line 1371
            __cil_tmp238 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )2);
#line 1371
            lu___5 = __cil_tmp238;
#line 1371
            __cil_tmp239 = opj_t1_getctxno_sc(lu___5);
#line 1371
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp239];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___41: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___31 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___31 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___31 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___31 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp244 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___40;
                }
              }
              while_break___90: /* CIL Label */ ;
              }
              while_break___40: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___42: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___32 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___32 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___32 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___32 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp249 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___41;
                  }
                }
                while_break___91: /* CIL Label */ ;
                }
                while_break___41: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
            {
#line 1371
            __cil_tmp250 = opj_t1_getspb(lu___5);
#line 1371
            v ^= (unsigned int )__cil_tmp250;
            }
#line 1371
            if (v) {
#line 1371
              tmp___5 = - oneplushalf;
            } else {
#line 1371
              tmp___5 = oneplushalf;
            }
#line 1371
            *(data + 2U * l_w) = tmp___5;
#line 1371
            *(flagsp + -1) |= (1U << 5) << 6U;
#line 1371
            flags |= ((v << 19) | (1U << 4)) << 6U;
#line 1371
            *(flagsp + 1) |= (1U << 3) << 6U;
#line 1371
            goto while_break___37;
          }
          while_break___87: /* CIL Label */ ;
          }
          while_break___37: ;
        }
#line 1371
        if (! (flags & (((1U << 4) | (1U << 21)) << 9U))) {
          {
#line 1371
          while (1) {
            while_continue___43: /* CIL Label */ ;
            {
#line 1371
            __cil_tmp255 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 1371
            ctxt1___6 = (OPJ_UINT32 )__cil_tmp255;
#line 1371
            curctx = & mqc->ctxs[ctxt1___6];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___44: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___33 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___33 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___33 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___33 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp260 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___43;
                }
              }
              while_break___93: /* CIL Label */ ;
              }
              while_break___43: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___45: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___34 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___34 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___34 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___34 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp265 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___44;
                  }
                }
                while_break___94: /* CIL Label */ ;
                }
                while_break___44: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
#line 1371
            if (! v) {
#line 1371
              goto while_break___42;
            }
            {
#line 1371
            __cil_tmp267 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )3);
#line 1371
            lu___6 = __cil_tmp267;
#line 1371
            __cil_tmp268 = opj_t1_getctxno_sc(lu___6);
#line 1371
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp268];
#line 1371
            a -= (*curctx)->qeval;
            }
#line 1371
            if (c >> 16 < (*curctx)->qeval) {
#line 1371
              if (a < (*curctx)->qeval) {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (*curctx)->mps;
#line 1371
                *curctx = (*curctx)->nmps;
              } else {
#line 1371
                a = (*curctx)->qeval;
#line 1371
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                *curctx = (*curctx)->nlps;
              }
              {
#line 1371
              while (1) {
                while_continue___46: /* CIL Label */ ;

#line 1371
                if (ct == 0U) {
#line 1371
                  l_c___35 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                  if ((int )*(mqc->bp) == 255) {
#line 1371
                    if (l_c___35 > 143U) {
#line 1371
                      c += 65280U;
#line 1371
                      ct = (OPJ_UINT32 )8;
#line 1371
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___35 << 9;
#line 1371
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1371
                    (mqc->bp) ++;
#line 1371
                    c += l_c___35 << 8;
#line 1371
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1371
                a <<= 1;
#line 1371
                c <<= 1;
#line 1371
                __cil_tmp273 = ct;
#line 1371
                ct --;
#line 1371
                if (! (a < 32768U)) {
#line 1371
                  goto while_break___45;
                }
              }
              while_break___95: /* CIL Label */ ;
              }
              while_break___45: ;
            } else {
#line 1371
              c -= (*curctx)->qeval << 16;
#line 1371
              if ((a & 32768U) == 0U) {
#line 1371
                if (a < (*curctx)->qeval) {
#line 1371
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1371
                  *curctx = (*curctx)->nlps;
                } else {
#line 1371
                  v = (*curctx)->mps;
#line 1371
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1371
                while (1) {
                  while_continue___47: /* CIL Label */ ;

#line 1371
                  if (ct == 0U) {
#line 1371
                    l_c___36 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1371
                    if ((int )*(mqc->bp) == 255) {
#line 1371
                      if (l_c___36 > 143U) {
#line 1371
                        c += 65280U;
#line 1371
                        ct = (OPJ_UINT32 )8;
#line 1371
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1371
                        (mqc->bp) ++;
#line 1371
                        c += l_c___36 << 9;
#line 1371
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1371
                      (mqc->bp) ++;
#line 1371
                      c += l_c___36 << 8;
#line 1371
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1371
                  a <<= 1;
#line 1371
                  c <<= 1;
#line 1371
                  __cil_tmp278 = ct;
#line 1371
                  ct --;
#line 1371
                  if (! (a < 32768U)) {
#line 1371
                    goto while_break___46;
                  }
                }
                while_break___96: /* CIL Label */ ;
                }
                while_break___46: ;
              } else {
#line 1371
                v = (*curctx)->mps;
              }
            }
            {
#line 1371
            __cil_tmp279 = opj_t1_getspb(lu___6);
#line 1371
            v ^= (unsigned int )__cil_tmp279;
            }
#line 1371
            if (v) {
#line 1371
              tmp___6 = - oneplushalf;
            } else {
#line 1371
              tmp___6 = oneplushalf;
            }
#line 1371
            *(data + 3U * l_w) = tmp___6;
#line 1371
            *(flagsp + -1) |= (1U << 5) << 9U;
#line 1371
            flags |= ((v << 19) | (1U << 4)) << 9U;
#line 1371
            *(flagsp + 1) |= (1U << 3) << 9U;
#line 1371
            south___6 = flagsp + (t1->w + 2U);
#line 1371
            *south___6 |= (v << 18) | (1U << 1);
#line 1371
            *(south___6 + -1) |= 1U << 2;
#line 1371
            *(south___6 + 1) |= 1U;
#line 1371
            goto while_break___42;
          }
          while_break___92: /* CIL Label */ ;
          }
          while_break___42: ;
        }
      }
#line 1371
      *flagsp = flags & ~ ((((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30));
#line 1371
      flagsp ++;
#line 1371
      data ++;
#line 1371
      i ++;
    }
    while_break___50: /* CIL Label */ ;
    }
    while_break___0: 
#line 1371
    flagsp += 2;
#line 1371
    data += 3U * l_w;
#line 1371
    k += 4U;
  }
  while_break___49: /* CIL Label */ ;
  }
  while_break: 
#line 1371
  mqc->curctx = curctx;
#line 1371
  mqc->c = c;
#line 1371
  mqc->a = a;
#line 1371
  mqc->ct = ct;
#line 1371
  if (k < t1->h) {
#line 1371
    i = (OPJ_UINT32 )0;
    {
#line 1371
    while (1) {
      while_continue___48: /* CIL Label */ ;

#line 1371
      if (! (i < l_w)) {
#line 1371
        goto while_break___47;
      }
#line 1371
      j = (OPJ_UINT32 )0;
      {
#line 1371
      while (1) {
        while_continue___49: /* CIL Label */ ;

#line 1371
        if (! (j < t1->h - k)) {
#line 1371
          goto while_break___48;
        }
        {
#line 1371
        opj_t1_dec_clnpass_step(t1, flagsp, data + j * l_w, oneplushalf, j, (OPJ_UINT32 )0);
#line 1371
        j ++;
        }
      }
      while_break___98: /* CIL Label */ ;
      }
      while_break___48: 
#line 1371
      *flagsp &= ~ ((((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30));
#line 1371
      data ++;
#line 1371
      flagsp ++;
#line 1371
      i ++;
    }
    while_break___97: /* CIL Label */ ;
    }
    while_break___47: ;
  }
#line 1377
  return;
}
}
#line 1375 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_generic_vsc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 runlen ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_w ;
  opj_mqc_t *mqc ;
  register OPJ_INT32 *data ;
  register opj_flag_t *flagsp ;
  register opj_mqc_state_t **curctx ;
  register OPJ_UINT32 c ;
  register OPJ_UINT32 a ;
  register OPJ_UINT32 ct ;
  register OPJ_UINT32 v ;
  opj_flag_t flags ;
  OPJ_UINT32 partial ;
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 l_c___0 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 l_c___1 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 l_c___2 ;
  OPJ_UINT32 __cil_tmp40 ;
  OPJ_UINT32 l_c___3 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 l_c___4 ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 ctxt1 ;
  OPJ_BYTE __cil_tmp52 ;
  OPJ_UINT32 l_c___5 ;
  OPJ_UINT32 __cil_tmp57 ;
  OPJ_UINT32 l_c___6 ;
  OPJ_UINT32 __cil_tmp62 ;
  OPJ_UINT32 lu ;
  OPJ_UINT32 __cil_tmp64 ;
  OPJ_BYTE __cil_tmp65 ;
  OPJ_UINT32 l_c___7 ;
  OPJ_UINT32 __cil_tmp70 ;
  OPJ_UINT32 l_c___8 ;
  OPJ_UINT32 __cil_tmp75 ;
  OPJ_BYTE __cil_tmp76 ;
  OPJ_INT32 tmp ;
  OPJ_UINT32 ctxt1___0 ;
  OPJ_BYTE __cil_tmp81 ;
  OPJ_UINT32 l_c___9 ;
  OPJ_UINT32 __cil_tmp86 ;
  OPJ_UINT32 l_c___10 ;
  OPJ_UINT32 __cil_tmp91 ;
  OPJ_UINT32 lu___0 ;
  OPJ_UINT32 __cil_tmp93 ;
  OPJ_BYTE __cil_tmp94 ;
  OPJ_UINT32 l_c___11 ;
  OPJ_UINT32 __cil_tmp99 ;
  OPJ_UINT32 l_c___12 ;
  OPJ_UINT32 __cil_tmp104 ;
  OPJ_BYTE __cil_tmp105 ;
  OPJ_INT32 tmp___0 ;
  OPJ_UINT32 ctxt1___1 ;
  OPJ_BYTE __cil_tmp110 ;
  OPJ_UINT32 l_c___13 ;
  OPJ_UINT32 __cil_tmp115 ;
  OPJ_UINT32 l_c___14 ;
  OPJ_UINT32 __cil_tmp120 ;
  OPJ_UINT32 lu___1 ;
  OPJ_UINT32 __cil_tmp122 ;
  OPJ_BYTE __cil_tmp123 ;
  OPJ_UINT32 l_c___15 ;
  OPJ_UINT32 __cil_tmp128 ;
  OPJ_UINT32 l_c___16 ;
  OPJ_UINT32 __cil_tmp133 ;
  OPJ_BYTE __cil_tmp134 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 ctxt1___2 ;
  OPJ_BYTE __cil_tmp139 ;
  OPJ_UINT32 l_c___17 ;
  OPJ_UINT32 __cil_tmp144 ;
  OPJ_UINT32 l_c___18 ;
  OPJ_UINT32 __cil_tmp149 ;
  OPJ_UINT32 lu___2 ;
  OPJ_UINT32 __cil_tmp151 ;
  OPJ_BYTE __cil_tmp152 ;
  OPJ_UINT32 l_c___19 ;
  OPJ_UINT32 __cil_tmp157 ;
  OPJ_UINT32 l_c___20 ;
  OPJ_UINT32 __cil_tmp162 ;
  OPJ_BYTE __cil_tmp163 ;
  OPJ_INT32 tmp___2 ;
  opj_flag_t *south___2 ;
  OPJ_UINT32 ctxt1___3 ;
  OPJ_BYTE __cil_tmp168 ;
  OPJ_UINT32 l_c___21 ;
  OPJ_UINT32 __cil_tmp173 ;
  OPJ_UINT32 l_c___22 ;
  OPJ_UINT32 __cil_tmp178 ;
  OPJ_UINT32 lu___3 ;
  OPJ_UINT32 __cil_tmp180 ;
  OPJ_BYTE __cil_tmp181 ;
  OPJ_UINT32 l_c___23 ;
  OPJ_UINT32 __cil_tmp186 ;
  OPJ_UINT32 l_c___24 ;
  OPJ_UINT32 __cil_tmp191 ;
  OPJ_BYTE __cil_tmp192 ;
  OPJ_INT32 tmp___3 ;
  OPJ_UINT32 ctxt1___4 ;
  OPJ_BYTE __cil_tmp197 ;
  OPJ_UINT32 l_c___25 ;
  OPJ_UINT32 __cil_tmp202 ;
  OPJ_UINT32 l_c___26 ;
  OPJ_UINT32 __cil_tmp207 ;
  OPJ_UINT32 lu___4 ;
  OPJ_UINT32 __cil_tmp209 ;
  OPJ_BYTE __cil_tmp210 ;
  OPJ_UINT32 l_c___27 ;
  OPJ_UINT32 __cil_tmp215 ;
  OPJ_UINT32 l_c___28 ;
  OPJ_UINT32 __cil_tmp220 ;
  OPJ_BYTE __cil_tmp221 ;
  OPJ_INT32 tmp___4 ;
  OPJ_UINT32 ctxt1___5 ;
  OPJ_BYTE __cil_tmp226 ;
  OPJ_UINT32 l_c___29 ;
  OPJ_UINT32 __cil_tmp231 ;
  OPJ_UINT32 l_c___30 ;
  OPJ_UINT32 __cil_tmp236 ;
  OPJ_UINT32 lu___5 ;
  OPJ_UINT32 __cil_tmp238 ;
  OPJ_BYTE __cil_tmp239 ;
  OPJ_UINT32 l_c___31 ;
  OPJ_UINT32 __cil_tmp244 ;
  OPJ_UINT32 l_c___32 ;
  OPJ_UINT32 __cil_tmp249 ;
  OPJ_BYTE __cil_tmp250 ;
  OPJ_INT32 tmp___5 ;
  OPJ_UINT32 ctxt1___6 ;
  OPJ_BYTE __cil_tmp255 ;
  OPJ_UINT32 l_c___33 ;
  OPJ_UINT32 __cil_tmp260 ;
  OPJ_UINT32 l_c___34 ;
  OPJ_UINT32 __cil_tmp265 ;
  OPJ_UINT32 lu___6 ;
  OPJ_UINT32 __cil_tmp267 ;
  OPJ_BYTE __cil_tmp268 ;
  OPJ_UINT32 l_c___35 ;
  OPJ_UINT32 __cil_tmp273 ;
  OPJ_UINT32 l_c___36 ;
  OPJ_UINT32 __cil_tmp278 ;
  OPJ_BYTE __cil_tmp279 ;
  OPJ_INT32 tmp___6 ;
  opj_flag_t *south___6 ;

  {
#line 1379
  l_w = t1->w;
#line 1379
  mqc = & t1->mqc;
#line 1379
  data = t1->data;
#line 1379
  flagsp = t1->flags + ((t1->w + 2U) + 1U);
#line 1379
  curctx = mqc->curctx;
#line 1379
  c = mqc->c;
#line 1379
  a = mqc->a;
#line 1379
  ct = mqc->ct;
#line 1379
  one = 1 << bpno;
#line 1379
  half = one >> 1;
#line 1379
  oneplushalf = one | half;
#line 1379
  k = (OPJ_UINT32 )0;
  {
#line 1379
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1379
    if (! (k < (t1->h & 4294967292U))) {
#line 1379
      goto while_break;
    }
#line 1379
    i = (OPJ_UINT32 )0;
    {
#line 1379
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 1379
      if (! (i < l_w)) {
#line 1379
        goto while_break___0;
      }
#line 1379
      flags = *flagsp;
#line 1379
      if (flags == 0U) {
#line 1379
        partial = (OPJ_UINT32 )1;
#line 1379
        curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 1379
        a -= (*curctx)->qeval;
#line 1379
        if (c >> 16 < (*curctx)->qeval) {
#line 1379
          if (a < (*curctx)->qeval) {
#line 1379
            a = (*curctx)->qeval;
#line 1379
            v = (*curctx)->mps;
#line 1379
            *curctx = (*curctx)->nmps;
          } else {
#line 1379
            a = (*curctx)->qeval;
#line 1379
            v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
            *curctx = (*curctx)->nlps;
          }
          {
#line 1379
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 1379
            if (ct == 0U) {
#line 1379
              l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
              if ((int )*(mqc->bp) == 255) {
#line 1379
                if (l_c > 143U) {
#line 1379
                  c += 65280U;
#line 1379
                  ct = (OPJ_UINT32 )8;
#line 1379
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1379
                  (mqc->bp) ++;
#line 1379
                  c += l_c << 9;
#line 1379
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1379
                (mqc->bp) ++;
#line 1379
                c += l_c << 8;
#line 1379
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1379
            a <<= 1;
#line 1379
            c <<= 1;
#line 1379
            __cil_tmp25 = ct;
#line 1379
            ct --;
#line 1379
            if (! (a < 32768U)) {
#line 1379
              goto while_break___1;
            }
          }
          while_break___51: /* CIL Label */ ;
          }
          while_break___1: ;
        } else {
#line 1379
          c -= (*curctx)->qeval << 16;
#line 1379
          if ((a & 32768U) == 0U) {
#line 1379
            if (a < (*curctx)->qeval) {
#line 1379
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
              *curctx = (*curctx)->nlps;
            } else {
#line 1379
              v = (*curctx)->mps;
#line 1379
              *curctx = (*curctx)->nmps;
            }
            {
#line 1379
            while (1) {
              while_continue___3: /* CIL Label */ ;

#line 1379
              if (ct == 0U) {
#line 1379
                l_c___0 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                if ((int )*(mqc->bp) == 255) {
#line 1379
                  if (l_c___0 > 143U) {
#line 1379
                    c += 65280U;
#line 1379
                    ct = (OPJ_UINT32 )8;
#line 1379
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___0 << 9;
#line 1379
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1379
                  (mqc->bp) ++;
#line 1379
                  c += l_c___0 << 8;
#line 1379
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1379
              a <<= 1;
#line 1379
              c <<= 1;
#line 1379
              __cil_tmp30 = ct;
#line 1379
              ct --;
#line 1379
              if (! (a < 32768U)) {
#line 1379
                goto while_break___2;
              }
            }
            while_break___52: /* CIL Label */ ;
            }
            while_break___2: ;
          } else {
#line 1379
            v = (*curctx)->mps;
          }
        }
#line 1379
        if (! v) {
#line 1379
          goto while_continue___0;
        }
#line 1379
        curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1379
        a -= (*curctx)->qeval;
#line 1379
        if (c >> 16 < (*curctx)->qeval) {
#line 1379
          if (a < (*curctx)->qeval) {
#line 1379
            a = (*curctx)->qeval;
#line 1379
            runlen = (*curctx)->mps;
#line 1379
            *curctx = (*curctx)->nmps;
          } else {
#line 1379
            a = (*curctx)->qeval;
#line 1379
            runlen = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
            *curctx = (*curctx)->nlps;
          }
          {
#line 1379
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 1379
            if (ct == 0U) {
#line 1379
              l_c___1 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
              if ((int )*(mqc->bp) == 255) {
#line 1379
                if (l_c___1 > 143U) {
#line 1379
                  c += 65280U;
#line 1379
                  ct = (OPJ_UINT32 )8;
#line 1379
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1379
                  (mqc->bp) ++;
#line 1379
                  c += l_c___1 << 9;
#line 1379
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1379
                (mqc->bp) ++;
#line 1379
                c += l_c___1 << 8;
#line 1379
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1379
            a <<= 1;
#line 1379
            c <<= 1;
#line 1379
            __cil_tmp35 = ct;
#line 1379
            ct --;
#line 1379
            if (! (a < 32768U)) {
#line 1379
              goto while_break___3;
            }
          }
          while_break___53: /* CIL Label */ ;
          }
          while_break___3: ;
        } else {
#line 1379
          c -= (*curctx)->qeval << 16;
#line 1379
          if ((a & 32768U) == 0U) {
#line 1379
            if (a < (*curctx)->qeval) {
#line 1379
              runlen = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
              *curctx = (*curctx)->nlps;
            } else {
#line 1379
              runlen = (*curctx)->mps;
#line 1379
              *curctx = (*curctx)->nmps;
            }
            {
#line 1379
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 1379
              if (ct == 0U) {
#line 1379
                l_c___2 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                if ((int )*(mqc->bp) == 255) {
#line 1379
                  if (l_c___2 > 143U) {
#line 1379
                    c += 65280U;
#line 1379
                    ct = (OPJ_UINT32 )8;
#line 1379
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___2 << 9;
#line 1379
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1379
                  (mqc->bp) ++;
#line 1379
                  c += l_c___2 << 8;
#line 1379
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1379
              a <<= 1;
#line 1379
              c <<= 1;
#line 1379
              __cil_tmp40 = ct;
#line 1379
              ct --;
#line 1379
              if (! (a < 32768U)) {
#line 1379
                goto while_break___4;
              }
            }
            while_break___54: /* CIL Label */ ;
            }
            while_break___4: ;
          } else {
#line 1379
            runlen = (*curctx)->mps;
          }
        }
#line 1379
        a -= (*curctx)->qeval;
#line 1379
        if (c >> 16 < (*curctx)->qeval) {
#line 1379
          if (a < (*curctx)->qeval) {
#line 1379
            a = (*curctx)->qeval;
#line 1379
            v = (*curctx)->mps;
#line 1379
            *curctx = (*curctx)->nmps;
          } else {
#line 1379
            a = (*curctx)->qeval;
#line 1379
            v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
            *curctx = (*curctx)->nlps;
          }
          {
#line 1379
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 1379
            if (ct == 0U) {
#line 1379
              l_c___3 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
              if ((int )*(mqc->bp) == 255) {
#line 1379
                if (l_c___3 > 143U) {
#line 1379
                  c += 65280U;
#line 1379
                  ct = (OPJ_UINT32 )8;
#line 1379
                  (mqc->end_of_byte_stream_counter) ++;
                } else {
#line 1379
                  (mqc->bp) ++;
#line 1379
                  c += l_c___3 << 9;
#line 1379
                  ct = (OPJ_UINT32 )7;
                }
              } else {
#line 1379
                (mqc->bp) ++;
#line 1379
                c += l_c___3 << 8;
#line 1379
                ct = (OPJ_UINT32 )8;
              }
            }
#line 1379
            a <<= 1;
#line 1379
            c <<= 1;
#line 1379
            __cil_tmp45 = ct;
#line 1379
            ct --;
#line 1379
            if (! (a < 32768U)) {
#line 1379
              goto while_break___5;
            }
          }
          while_break___55: /* CIL Label */ ;
          }
          while_break___5: ;
        } else {
#line 1379
          c -= (*curctx)->qeval << 16;
#line 1379
          if ((a & 32768U) == 0U) {
#line 1379
            if (a < (*curctx)->qeval) {
#line 1379
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
              *curctx = (*curctx)->nlps;
            } else {
#line 1379
              v = (*curctx)->mps;
#line 1379
              *curctx = (*curctx)->nmps;
            }
            {
#line 1379
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 1379
              if (ct == 0U) {
#line 1379
                l_c___4 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                if ((int )*(mqc->bp) == 255) {
#line 1379
                  if (l_c___4 > 143U) {
#line 1379
                    c += 65280U;
#line 1379
                    ct = (OPJ_UINT32 )8;
#line 1379
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___4 << 9;
#line 1379
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1379
                  (mqc->bp) ++;
#line 1379
                  c += l_c___4 << 8;
#line 1379
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1379
              a <<= 1;
#line 1379
              c <<= 1;
#line 1379
              __cil_tmp50 = ct;
#line 1379
              ct --;
#line 1379
              if (! (a < 32768U)) {
#line 1379
                goto while_break___6;
              }
            }
            while_break___56: /* CIL Label */ ;
            }
            while_break___6: ;
          } else {
#line 1379
            v = (*curctx)->mps;
          }
        }
#line 1379
        runlen = (runlen << 1) | v;
#line 1379
        if (runlen == 0U) {
#line 1379
          goto case_0;
        }
#line 1379
        if (runlen == 1U) {
#line 1379
          goto case_1;
        }
#line 1379
        if (runlen == 2U) {
#line 1379
          goto case_2;
        }
#line 1379
        if (runlen == 3U) {
#line 1379
          goto case_3;
        }
#line 1379
        goto switch_break;
        case_0: 
        {
#line 1379
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 1379
          if (0) {
            {
#line 1379
            __cil_tmp52 = opj_t1_getctxno_zc(mqc, flags);
#line 1379
            ctxt1 = (OPJ_UINT32 )__cil_tmp52;
#line 1379
            curctx = & mqc->ctxs[ctxt1];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___9: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___5 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___5 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___5 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___5 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp57 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___8;
                }
              }
              while_break___58: /* CIL Label */ ;
              }
              while_break___8: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___10: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___6 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___6 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___6 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___6 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp62 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___9;
                  }
                }
                while_break___59: /* CIL Label */ ;
                }
                while_break___9: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
#line 1379
            if (! v) {
#line 1379
              goto while_break___7;
            }
          }
          {
#line 1379
          __cil_tmp64 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                         (OPJ_UINT32 )0);
#line 1379
          lu = __cil_tmp64;
#line 1379
          __cil_tmp65 = opj_t1_getctxno_sc(lu);
#line 1379
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp65];
#line 1379
          a -= (*curctx)->qeval;
          }
#line 1379
          if (c >> 16 < (*curctx)->qeval) {
#line 1379
            if (a < (*curctx)->qeval) {
#line 1379
              a = (*curctx)->qeval;
#line 1379
              v = (*curctx)->mps;
#line 1379
              *curctx = (*curctx)->nmps;
            } else {
#line 1379
              a = (*curctx)->qeval;
#line 1379
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
              *curctx = (*curctx)->nlps;
            }
            {
#line 1379
            while (1) {
              while_continue___11: /* CIL Label */ ;

#line 1379
              if (ct == 0U) {
#line 1379
                l_c___7 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                if ((int )*(mqc->bp) == 255) {
#line 1379
                  if (l_c___7 > 143U) {
#line 1379
                    c += 65280U;
#line 1379
                    ct = (OPJ_UINT32 )8;
#line 1379
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___7 << 9;
#line 1379
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1379
                  (mqc->bp) ++;
#line 1379
                  c += l_c___7 << 8;
#line 1379
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1379
              a <<= 1;
#line 1379
              c <<= 1;
#line 1379
              __cil_tmp70 = ct;
#line 1379
              ct --;
#line 1379
              if (! (a < 32768U)) {
#line 1379
                goto while_break___10;
              }
            }
            while_break___60: /* CIL Label */ ;
            }
            while_break___10: ;
          } else {
#line 1379
            c -= (*curctx)->qeval << 16;
#line 1379
            if ((a & 32768U) == 0U) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              } else {
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              }
              {
#line 1379
              while (1) {
                while_continue___12: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___8 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___8 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___8 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___8 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp75 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___11;
                }
              }
              while_break___61: /* CIL Label */ ;
              }
              while_break___11: ;
            } else {
#line 1379
              v = (*curctx)->mps;
            }
          }
          {
#line 1379
          __cil_tmp76 = opj_t1_getspb(lu);
#line 1379
          v ^= (unsigned int )__cil_tmp76;
          }
#line 1379
          if (v) {
#line 1379
            tmp = - oneplushalf;
          } else {
#line 1379
            tmp = oneplushalf;
          }
#line 1379
          *(data + 0U) = tmp;
#line 1379
          *(flagsp + -1) |= 1U << 5;
#line 1379
          flags |= (v << 19) | (1U << 4);
#line 1379
          *(flagsp + 1) |= 1U << 3;
#line 1379
          goto while_break___7;
        }
        while_break___57: /* CIL Label */ ;
        }
        while_break___7: 
#line 1379
        partial = (OPJ_UINT32 )0;
        case_1: 
        {
#line 1379
        while (1) {
          while_continue___13: /* CIL Label */ ;

#line 1379
          if (! partial) {
            {
#line 1379
            __cil_tmp81 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 1379
            ctxt1___0 = (OPJ_UINT32 )__cil_tmp81;
#line 1379
            curctx = & mqc->ctxs[ctxt1___0];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___14: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___9 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___9 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___9 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___9 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp86 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___13;
                }
              }
              while_break___63: /* CIL Label */ ;
              }
              while_break___13: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___15: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___10 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___10 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___10 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___10 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp91 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___14;
                  }
                }
                while_break___64: /* CIL Label */ ;
                }
                while_break___14: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
#line 1379
            if (! v) {
#line 1379
              goto while_break___12;
            }
          }
          {
#line 1379
          __cil_tmp93 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                         (OPJ_UINT32 )1);
#line 1379
          lu___0 = __cil_tmp93;
#line 1379
          __cil_tmp94 = opj_t1_getctxno_sc(lu___0);
#line 1379
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp94];
#line 1379
          a -= (*curctx)->qeval;
          }
#line 1379
          if (c >> 16 < (*curctx)->qeval) {
#line 1379
            if (a < (*curctx)->qeval) {
#line 1379
              a = (*curctx)->qeval;
#line 1379
              v = (*curctx)->mps;
#line 1379
              *curctx = (*curctx)->nmps;
            } else {
#line 1379
              a = (*curctx)->qeval;
#line 1379
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
              *curctx = (*curctx)->nlps;
            }
            {
#line 1379
            while (1) {
              while_continue___16: /* CIL Label */ ;

#line 1379
              if (ct == 0U) {
#line 1379
                l_c___11 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                if ((int )*(mqc->bp) == 255) {
#line 1379
                  if (l_c___11 > 143U) {
#line 1379
                    c += 65280U;
#line 1379
                    ct = (OPJ_UINT32 )8;
#line 1379
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___11 << 9;
#line 1379
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1379
                  (mqc->bp) ++;
#line 1379
                  c += l_c___11 << 8;
#line 1379
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1379
              a <<= 1;
#line 1379
              c <<= 1;
#line 1379
              __cil_tmp99 = ct;
#line 1379
              ct --;
#line 1379
              if (! (a < 32768U)) {
#line 1379
                goto while_break___15;
              }
            }
            while_break___65: /* CIL Label */ ;
            }
            while_break___15: ;
          } else {
#line 1379
            c -= (*curctx)->qeval << 16;
#line 1379
            if ((a & 32768U) == 0U) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              } else {
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              }
              {
#line 1379
              while (1) {
                while_continue___17: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___12 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___12 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___12 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___12 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp104 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___16;
                }
              }
              while_break___66: /* CIL Label */ ;
              }
              while_break___16: ;
            } else {
#line 1379
              v = (*curctx)->mps;
            }
          }
          {
#line 1379
          __cil_tmp105 = opj_t1_getspb(lu___0);
#line 1379
          v ^= (unsigned int )__cil_tmp105;
          }
#line 1379
          if (v) {
#line 1379
            tmp___0 = - oneplushalf;
          } else {
#line 1379
            tmp___0 = oneplushalf;
          }
#line 1379
          *(data + l_w) = tmp___0;
#line 1379
          *(flagsp + -1) |= (1U << 5) << 3U;
#line 1379
          flags |= ((v << 19) | (1U << 4)) << 3U;
#line 1379
          *(flagsp + 1) |= (1U << 3) << 3U;
#line 1379
          goto while_break___12;
        }
        while_break___62: /* CIL Label */ ;
        }
        while_break___12: 
#line 1379
        partial = (OPJ_UINT32 )0;
        case_2: 
        {
#line 1379
        while (1) {
          while_continue___18: /* CIL Label */ ;

#line 1379
          if (! partial) {
            {
#line 1379
            __cil_tmp110 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 1379
            ctxt1___1 = (OPJ_UINT32 )__cil_tmp110;
#line 1379
            curctx = & mqc->ctxs[ctxt1___1];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___19: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___13 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___13 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___13 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___13 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp115 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___18;
                }
              }
              while_break___68: /* CIL Label */ ;
              }
              while_break___18: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___20: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___14 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___14 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___14 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___14 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp120 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___19;
                  }
                }
                while_break___69: /* CIL Label */ ;
                }
                while_break___19: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
#line 1379
            if (! v) {
#line 1379
              goto while_break___17;
            }
          }
          {
#line 1379
          __cil_tmp122 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                          (OPJ_UINT32 )2);
#line 1379
          lu___1 = __cil_tmp122;
#line 1379
          __cil_tmp123 = opj_t1_getctxno_sc(lu___1);
#line 1379
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp123];
#line 1379
          a -= (*curctx)->qeval;
          }
#line 1379
          if (c >> 16 < (*curctx)->qeval) {
#line 1379
            if (a < (*curctx)->qeval) {
#line 1379
              a = (*curctx)->qeval;
#line 1379
              v = (*curctx)->mps;
#line 1379
              *curctx = (*curctx)->nmps;
            } else {
#line 1379
              a = (*curctx)->qeval;
#line 1379
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
              *curctx = (*curctx)->nlps;
            }
            {
#line 1379
            while (1) {
              while_continue___21: /* CIL Label */ ;

#line 1379
              if (ct == 0U) {
#line 1379
                l_c___15 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                if ((int )*(mqc->bp) == 255) {
#line 1379
                  if (l_c___15 > 143U) {
#line 1379
                    c += 65280U;
#line 1379
                    ct = (OPJ_UINT32 )8;
#line 1379
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___15 << 9;
#line 1379
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1379
                  (mqc->bp) ++;
#line 1379
                  c += l_c___15 << 8;
#line 1379
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1379
              a <<= 1;
#line 1379
              c <<= 1;
#line 1379
              __cil_tmp128 = ct;
#line 1379
              ct --;
#line 1379
              if (! (a < 32768U)) {
#line 1379
                goto while_break___20;
              }
            }
            while_break___70: /* CIL Label */ ;
            }
            while_break___20: ;
          } else {
#line 1379
            c -= (*curctx)->qeval << 16;
#line 1379
            if ((a & 32768U) == 0U) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              } else {
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              }
              {
#line 1379
              while (1) {
                while_continue___22: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___16 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___16 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___16 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___16 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp133 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___21;
                }
              }
              while_break___71: /* CIL Label */ ;
              }
              while_break___21: ;
            } else {
#line 1379
              v = (*curctx)->mps;
            }
          }
          {
#line 1379
          __cil_tmp134 = opj_t1_getspb(lu___1);
#line 1379
          v ^= (unsigned int )__cil_tmp134;
          }
#line 1379
          if (v) {
#line 1379
            tmp___1 = - oneplushalf;
          } else {
#line 1379
            tmp___1 = oneplushalf;
          }
#line 1379
          *(data + 2U * l_w) = tmp___1;
#line 1379
          *(flagsp + -1) |= (1U << 5) << 6U;
#line 1379
          flags |= ((v << 19) | (1U << 4)) << 6U;
#line 1379
          *(flagsp + 1) |= (1U << 3) << 6U;
#line 1379
          goto while_break___17;
        }
        while_break___67: /* CIL Label */ ;
        }
        while_break___17: 
#line 1379
        partial = (OPJ_UINT32 )0;
        case_3: 
        {
#line 1379
        while (1) {
          while_continue___23: /* CIL Label */ ;

#line 1379
          if (! partial) {
            {
#line 1379
            __cil_tmp139 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 1379
            ctxt1___2 = (OPJ_UINT32 )__cil_tmp139;
#line 1379
            curctx = & mqc->ctxs[ctxt1___2];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___24: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___17 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___17 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___17 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___17 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp144 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___23;
                }
              }
              while_break___73: /* CIL Label */ ;
              }
              while_break___23: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___25: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___18 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___18 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___18 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___18 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp149 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___24;
                  }
                }
                while_break___74: /* CIL Label */ ;
                }
                while_break___24: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
#line 1379
            if (! v) {
#line 1379
              goto while_break___22;
            }
          }
          {
#line 1379
          __cil_tmp151 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1), *(flagsp + 1),
                                                          (OPJ_UINT32 )3);
#line 1379
          lu___2 = __cil_tmp151;
#line 1379
          __cil_tmp152 = opj_t1_getctxno_sc(lu___2);
#line 1379
          curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp152];
#line 1379
          a -= (*curctx)->qeval;
          }
#line 1379
          if (c >> 16 < (*curctx)->qeval) {
#line 1379
            if (a < (*curctx)->qeval) {
#line 1379
              a = (*curctx)->qeval;
#line 1379
              v = (*curctx)->mps;
#line 1379
              *curctx = (*curctx)->nmps;
            } else {
#line 1379
              a = (*curctx)->qeval;
#line 1379
              v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
              *curctx = (*curctx)->nlps;
            }
            {
#line 1379
            while (1) {
              while_continue___26: /* CIL Label */ ;

#line 1379
              if (ct == 0U) {
#line 1379
                l_c___19 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                if ((int )*(mqc->bp) == 255) {
#line 1379
                  if (l_c___19 > 143U) {
#line 1379
                    c += 65280U;
#line 1379
                    ct = (OPJ_UINT32 )8;
#line 1379
                    (mqc->end_of_byte_stream_counter) ++;
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___19 << 9;
#line 1379
                    ct = (OPJ_UINT32 )7;
                  }
                } else {
#line 1379
                  (mqc->bp) ++;
#line 1379
                  c += l_c___19 << 8;
#line 1379
                  ct = (OPJ_UINT32 )8;
                }
              }
#line 1379
              a <<= 1;
#line 1379
              c <<= 1;
#line 1379
              __cil_tmp157 = ct;
#line 1379
              ct --;
#line 1379
              if (! (a < 32768U)) {
#line 1379
                goto while_break___25;
              }
            }
            while_break___75: /* CIL Label */ ;
            }
            while_break___25: ;
          } else {
#line 1379
            c -= (*curctx)->qeval << 16;
#line 1379
            if ((a & 32768U) == 0U) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              } else {
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              }
              {
#line 1379
              while (1) {
                while_continue___27: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___20 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___20 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___20 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___20 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp162 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___26;
                }
              }
              while_break___76: /* CIL Label */ ;
              }
              while_break___26: ;
            } else {
#line 1379
              v = (*curctx)->mps;
            }
          }
          {
#line 1379
          __cil_tmp163 = opj_t1_getspb(lu___2);
#line 1379
          v ^= (unsigned int )__cil_tmp163;
          }
#line 1379
          if (v) {
#line 1379
            tmp___2 = - oneplushalf;
          } else {
#line 1379
            tmp___2 = oneplushalf;
          }
#line 1379
          *(data + 3U * l_w) = tmp___2;
#line 1379
          *(flagsp + -1) |= (1U << 5) << 9U;
#line 1379
          flags |= ((v << 19) | (1U << 4)) << 9U;
#line 1379
          *(flagsp + 1) |= (1U << 3) << 9U;
#line 1379
          south___2 = flagsp + (t1->w + 2U);
#line 1379
          *south___2 |= (v << 18) | (1U << 1);
#line 1379
          *(south___2 + -1) |= 1U << 2;
#line 1379
          *(south___2 + 1) |= 1U;
#line 1379
          goto while_break___22;
        }
        while_break___72: /* CIL Label */ ;
        }
        while_break___22: ;
#line 1379
        goto switch_break;
        switch_break: ;
      } else {
#line 1379
        if (! (flags & ((1U << 4) | (1U << 21)))) {
          {
#line 1379
          while (1) {
            while_continue___28: /* CIL Label */ ;
            {
#line 1379
            __cil_tmp168 = opj_t1_getctxno_zc(mqc, flags);
#line 1379
            ctxt1___3 = (OPJ_UINT32 )__cil_tmp168;
#line 1379
            curctx = & mqc->ctxs[ctxt1___3];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___29: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___21 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___21 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___21 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___21 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp173 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___28;
                }
              }
              while_break___78: /* CIL Label */ ;
              }
              while_break___28: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___30: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___22 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___22 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___22 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___22 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp178 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___29;
                  }
                }
                while_break___79: /* CIL Label */ ;
                }
                while_break___29: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
#line 1379
            if (! v) {
#line 1379
              goto while_break___27;
            }
            {
#line 1379
            __cil_tmp180 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )0);
#line 1379
            lu___3 = __cil_tmp180;
#line 1379
            __cil_tmp181 = opj_t1_getctxno_sc(lu___3);
#line 1379
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp181];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___31: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___23 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___23 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___23 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___23 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp186 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___30;
                }
              }
              while_break___80: /* CIL Label */ ;
              }
              while_break___30: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___32: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___24 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___24 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___24 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___24 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp191 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___31;
                  }
                }
                while_break___81: /* CIL Label */ ;
                }
                while_break___31: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
            {
#line 1379
            __cil_tmp192 = opj_t1_getspb(lu___3);
#line 1379
            v ^= (unsigned int )__cil_tmp192;
            }
#line 1379
            if (v) {
#line 1379
              tmp___3 = - oneplushalf;
            } else {
#line 1379
              tmp___3 = oneplushalf;
            }
#line 1379
            *(data + 0U) = tmp___3;
#line 1379
            *(flagsp + -1) |= 1U << 5;
#line 1379
            flags |= (v << 19) | (1U << 4);
#line 1379
            *(flagsp + 1) |= 1U << 3;
#line 1379
            goto while_break___27;
          }
          while_break___77: /* CIL Label */ ;
          }
          while_break___27: ;
        }
#line 1379
        if (! (flags & (((1U << 4) | (1U << 21)) << 3U))) {
          {
#line 1379
          while (1) {
            while_continue___33: /* CIL Label */ ;
            {
#line 1379
            __cil_tmp197 = opj_t1_getctxno_zc(mqc, flags >> 3U);
#line 1379
            ctxt1___4 = (OPJ_UINT32 )__cil_tmp197;
#line 1379
            curctx = & mqc->ctxs[ctxt1___4];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___34: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___25 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___25 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___25 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___25 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp202 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___33;
                }
              }
              while_break___83: /* CIL Label */ ;
              }
              while_break___33: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___35: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___26 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___26 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___26 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___26 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp207 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___34;
                  }
                }
                while_break___84: /* CIL Label */ ;
                }
                while_break___34: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
#line 1379
            if (! v) {
#line 1379
              goto while_break___32;
            }
            {
#line 1379
            __cil_tmp209 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )1);
#line 1379
            lu___4 = __cil_tmp209;
#line 1379
            __cil_tmp210 = opj_t1_getctxno_sc(lu___4);
#line 1379
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp210];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___36: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___27 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___27 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___27 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___27 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp215 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___35;
                }
              }
              while_break___85: /* CIL Label */ ;
              }
              while_break___35: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___37: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___28 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___28 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___28 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___28 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp220 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___36;
                  }
                }
                while_break___86: /* CIL Label */ ;
                }
                while_break___36: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
            {
#line 1379
            __cil_tmp221 = opj_t1_getspb(lu___4);
#line 1379
            v ^= (unsigned int )__cil_tmp221;
            }
#line 1379
            if (v) {
#line 1379
              tmp___4 = - oneplushalf;
            } else {
#line 1379
              tmp___4 = oneplushalf;
            }
#line 1379
            *(data + l_w) = tmp___4;
#line 1379
            *(flagsp + -1) |= (1U << 5) << 3U;
#line 1379
            flags |= ((v << 19) | (1U << 4)) << 3U;
#line 1379
            *(flagsp + 1) |= (1U << 3) << 3U;
#line 1379
            goto while_break___32;
          }
          while_break___82: /* CIL Label */ ;
          }
          while_break___32: ;
        }
#line 1379
        if (! (flags & (((1U << 4) | (1U << 21)) << 6U))) {
          {
#line 1379
          while (1) {
            while_continue___38: /* CIL Label */ ;
            {
#line 1379
            __cil_tmp226 = opj_t1_getctxno_zc(mqc, flags >> 6U);
#line 1379
            ctxt1___5 = (OPJ_UINT32 )__cil_tmp226;
#line 1379
            curctx = & mqc->ctxs[ctxt1___5];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___39: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___29 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___29 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___29 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___29 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp231 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___38;
                }
              }
              while_break___88: /* CIL Label */ ;
              }
              while_break___38: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___40: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___30 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___30 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___30 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___30 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp236 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___39;
                  }
                }
                while_break___89: /* CIL Label */ ;
                }
                while_break___39: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
#line 1379
            if (! v) {
#line 1379
              goto while_break___37;
            }
            {
#line 1379
            __cil_tmp238 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )2);
#line 1379
            lu___5 = __cil_tmp238;
#line 1379
            __cil_tmp239 = opj_t1_getctxno_sc(lu___5);
#line 1379
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp239];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___41: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___31 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___31 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___31 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___31 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp244 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___40;
                }
              }
              while_break___90: /* CIL Label */ ;
              }
              while_break___40: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___42: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___32 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___32 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___32 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___32 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp249 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___41;
                  }
                }
                while_break___91: /* CIL Label */ ;
                }
                while_break___41: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
            {
#line 1379
            __cil_tmp250 = opj_t1_getspb(lu___5);
#line 1379
            v ^= (unsigned int )__cil_tmp250;
            }
#line 1379
            if (v) {
#line 1379
              tmp___5 = - oneplushalf;
            } else {
#line 1379
              tmp___5 = oneplushalf;
            }
#line 1379
            *(data + 2U * l_w) = tmp___5;
#line 1379
            *(flagsp + -1) |= (1U << 5) << 6U;
#line 1379
            flags |= ((v << 19) | (1U << 4)) << 6U;
#line 1379
            *(flagsp + 1) |= (1U << 3) << 6U;
#line 1379
            goto while_break___37;
          }
          while_break___87: /* CIL Label */ ;
          }
          while_break___37: ;
        }
#line 1379
        if (! (flags & (((1U << 4) | (1U << 21)) << 9U))) {
          {
#line 1379
          while (1) {
            while_continue___43: /* CIL Label */ ;
            {
#line 1379
            __cil_tmp255 = opj_t1_getctxno_zc(mqc, flags >> 9U);
#line 1379
            ctxt1___6 = (OPJ_UINT32 )__cil_tmp255;
#line 1379
            curctx = & mqc->ctxs[ctxt1___6];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___44: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___33 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___33 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___33 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___33 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp260 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___43;
                }
              }
              while_break___93: /* CIL Label */ ;
              }
              while_break___43: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___45: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___34 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___34 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___34 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___34 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp265 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___44;
                  }
                }
                while_break___94: /* CIL Label */ ;
                }
                while_break___44: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
#line 1379
            if (! v) {
#line 1379
              goto while_break___42;
            }
            {
#line 1379
            __cil_tmp267 = opj_t1_getctxtno_sc_or_spb_index(flags, *(flagsp + -1),
                                                            *(flagsp + 1), (OPJ_UINT32 )3);
#line 1379
            lu___6 = __cil_tmp267;
#line 1379
            __cil_tmp268 = opj_t1_getctxno_sc(lu___6);
#line 1379
            curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp268];
#line 1379
            a -= (*curctx)->qeval;
            }
#line 1379
            if (c >> 16 < (*curctx)->qeval) {
#line 1379
              if (a < (*curctx)->qeval) {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (*curctx)->mps;
#line 1379
                *curctx = (*curctx)->nmps;
              } else {
#line 1379
                a = (*curctx)->qeval;
#line 1379
                v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                *curctx = (*curctx)->nlps;
              }
              {
#line 1379
              while (1) {
                while_continue___46: /* CIL Label */ ;

#line 1379
                if (ct == 0U) {
#line 1379
                  l_c___35 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                  if ((int )*(mqc->bp) == 255) {
#line 1379
                    if (l_c___35 > 143U) {
#line 1379
                      c += 65280U;
#line 1379
                      ct = (OPJ_UINT32 )8;
#line 1379
                      (mqc->end_of_byte_stream_counter) ++;
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___35 << 9;
#line 1379
                      ct = (OPJ_UINT32 )7;
                    }
                  } else {
#line 1379
                    (mqc->bp) ++;
#line 1379
                    c += l_c___35 << 8;
#line 1379
                    ct = (OPJ_UINT32 )8;
                  }
                }
#line 1379
                a <<= 1;
#line 1379
                c <<= 1;
#line 1379
                __cil_tmp273 = ct;
#line 1379
                ct --;
#line 1379
                if (! (a < 32768U)) {
#line 1379
                  goto while_break___45;
                }
              }
              while_break___95: /* CIL Label */ ;
              }
              while_break___45: ;
            } else {
#line 1379
              c -= (*curctx)->qeval << 16;
#line 1379
              if ((a & 32768U) == 0U) {
#line 1379
                if (a < (*curctx)->qeval) {
#line 1379
                  v = (OPJ_UINT32 )(! (*curctx)->mps);
#line 1379
                  *curctx = (*curctx)->nlps;
                } else {
#line 1379
                  v = (*curctx)->mps;
#line 1379
                  *curctx = (*curctx)->nmps;
                }
                {
#line 1379
                while (1) {
                  while_continue___47: /* CIL Label */ ;

#line 1379
                  if (ct == 0U) {
#line 1379
                    l_c___36 = (OPJ_UINT32 )*(mqc->bp + 1);
#line 1379
                    if ((int )*(mqc->bp) == 255) {
#line 1379
                      if (l_c___36 > 143U) {
#line 1379
                        c += 65280U;
#line 1379
                        ct = (OPJ_UINT32 )8;
#line 1379
                        (mqc->end_of_byte_stream_counter) ++;
                      } else {
#line 1379
                        (mqc->bp) ++;
#line 1379
                        c += l_c___36 << 9;
#line 1379
                        ct = (OPJ_UINT32 )7;
                      }
                    } else {
#line 1379
                      (mqc->bp) ++;
#line 1379
                      c += l_c___36 << 8;
#line 1379
                      ct = (OPJ_UINT32 )8;
                    }
                  }
#line 1379
                  a <<= 1;
#line 1379
                  c <<= 1;
#line 1379
                  __cil_tmp278 = ct;
#line 1379
                  ct --;
#line 1379
                  if (! (a < 32768U)) {
#line 1379
                    goto while_break___46;
                  }
                }
                while_break___96: /* CIL Label */ ;
                }
                while_break___46: ;
              } else {
#line 1379
                v = (*curctx)->mps;
              }
            }
            {
#line 1379
            __cil_tmp279 = opj_t1_getspb(lu___6);
#line 1379
            v ^= (unsigned int )__cil_tmp279;
            }
#line 1379
            if (v) {
#line 1379
              tmp___6 = - oneplushalf;
            } else {
#line 1379
              tmp___6 = oneplushalf;
            }
#line 1379
            *(data + 3U * l_w) = tmp___6;
#line 1379
            *(flagsp + -1) |= (1U << 5) << 9U;
#line 1379
            flags |= ((v << 19) | (1U << 4)) << 9U;
#line 1379
            *(flagsp + 1) |= (1U << 3) << 9U;
#line 1379
            south___6 = flagsp + (t1->w + 2U);
#line 1379
            *south___6 |= (v << 18) | (1U << 1);
#line 1379
            *(south___6 + -1) |= 1U << 2;
#line 1379
            *(south___6 + 1) |= 1U;
#line 1379
            goto while_break___42;
          }
          while_break___92: /* CIL Label */ ;
          }
          while_break___42: ;
        }
      }
#line 1379
      *flagsp = flags & ~ ((((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30));
#line 1379
      flagsp ++;
#line 1379
      data ++;
#line 1379
      i ++;
    }
    while_break___50: /* CIL Label */ ;
    }
    while_break___0: 
#line 1379
    flagsp += 2;
#line 1379
    data += 3U * l_w;
#line 1379
    k += 4U;
  }
  while_break___49: /* CIL Label */ ;
  }
  while_break: 
#line 1379
  mqc->curctx = curctx;
#line 1379
  mqc->c = c;
#line 1379
  mqc->a = a;
#line 1379
  mqc->ct = ct;
#line 1379
  if (k < t1->h) {
#line 1379
    i = (OPJ_UINT32 )0;
    {
#line 1379
    while (1) {
      while_continue___48: /* CIL Label */ ;

#line 1379
      if (! (i < l_w)) {
#line 1379
        goto while_break___47;
      }
#line 1379
      j = (OPJ_UINT32 )0;
      {
#line 1379
      while (1) {
        while_continue___49: /* CIL Label */ ;

#line 1379
        if (! (j < t1->h - k)) {
#line 1379
          goto while_break___48;
        }
        {
#line 1379
        opj_t1_dec_clnpass_step(t1, flagsp, data + j * l_w, oneplushalf, j, (OPJ_UINT32 )1);
#line 1379
        j ++;
        }
      }
      while_break___98: /* CIL Label */ ;
      }
      while_break___48: 
#line 1379
      *flagsp &= ~ ((((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30));
#line 1379
      data ++;
#line 1379
      flagsp ++;
#line 1379
      i ++;
    }
    while_break___97: /* CIL Label */ ;
    }
    while_break___47: ;
  }
#line 1385
  return;
}
}
#line 1383 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 cblksty ) 
{ 


  {
#line 1388
  if (t1->w == 64U) {
#line 1388
    if (t1->h == 64U) {
#line 1389
      if (cblksty & 8) {
        {
#line 1390
        opj_t1_dec_clnpass_64x64_vsc(t1, bpno);
        }
      } else {
        {
#line 1392
        opj_t1_dec_clnpass_64x64_novsc(t1, bpno);
        }
      }
    } else {
#line 1388
      goto _L;
    }
  } else
  _L: 
#line 1395
  if (cblksty & 8) {
    {
#line 1396
    opj_t1_dec_clnpass_generic_vsc(t1, bpno);
    }
  } else {
    {
#line 1398
    opj_t1_dec_clnpass_generic_novsc(t1, bpno);
    }
  }
  {
#line 1401
  opj_t1_dec_clnpass_check_segsym(t1, cblksty);
  }
#line 1403
  return;
}
}
#line 1406 "/root/patron/new_24/src/lib/openjp2/t1.c"
static OPJ_FLOAT64 opj_t1_getwmsedec(OPJ_INT32 nmsedec , OPJ_UINT32 compno , OPJ_UINT32 level ,
                                     OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_UINT32 qmfbid ,
                                     OPJ_FLOAT64 stepsize , OPJ_UINT32 numcomps ,
                                     OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) 
{ 
  OPJ_FLOAT64 w1 ;
  OPJ_FLOAT64 w2 ;
  OPJ_FLOAT64 wmsedec ;

  {
#line 1418
  w1 = (OPJ_FLOAT64 )1;
#line 1421
  if (mct_norms) {
#line 1421
    if (compno < mct_numcomps) {
#line 1422
      w1 = *(mct_norms + compno);
    }
  }
#line 1425
  if (qmfbid == 1U) {
    {
#line 1426
    w2 = opj_dwt_getnorm(level, orient);
    }
  } else {
    {
#line 1428
    w2 = opj_dwt_getnorm_real(level, orient);
    }
  }
#line 1431
  wmsedec = ((w1 * w2) * stepsize) * (double )(1 << bpno);
#line 1432
  wmsedec *= (wmsedec * (double )nmsedec) / 8192.;
#line 1434
  return (wmsedec);
}
}
#line 1437 "/root/patron/new_24/src/lib/openjp2/t1.c"
static OPJ_BOOL opj_t1_allocate_buffers(opj_t1_t *t1 , OPJ_UINT32 w , OPJ_UINT32 h ) 
{ 
  OPJ_UINT32 flagssize ;
  OPJ_UINT32 flags_stride ;
  OPJ_UINT32 datasize ;
  void *__cil_tmp10 ;
  opj_flag_t *p ;
  OPJ_UINT32 x ;
  OPJ_UINT32 flags_height ;
  void *__cil_tmp14 ;
  opj_flag_t *__cil_tmp15 ;
  opj_flag_t *__cil_tmp16 ;
  OPJ_UINT32 v ;
  opj_flag_t *__cil_tmp18 ;

  {
#line 1452
  if (! t1->encoder) {
#line 1453
    datasize = w * h;
#line 1455
    if (datasize > t1->datasize) {
      {
#line 1456
      opj_aligned_free((void *)t1->data);
#line 1457
      __cil_tmp10 = opj_aligned_malloc((unsigned long )datasize * sizeof(OPJ_INT32 ));
#line 1457
      t1->data = (OPJ_INT32 *)__cil_tmp10;
      }
#line 1458
      if (! t1->data) {
#line 1460
        return (0);
      }
#line 1462
      t1->datasize = datasize;
    }
#line 1465
    if ((unsigned long )t1->data != (unsigned long )((void *)0)) {
      {
#line 1466
      memset((void *)t1->data, 0, (unsigned long )datasize * sizeof(OPJ_INT32 ));
      }
    }
  }
#line 1470
  flags_stride = w + 2U;
#line 1472
  flagssize = (h + 3U) / 4U + 2U;
#line 1474
  flagssize *= flags_stride;
#line 1478
  flags_height = (h + 3U) / 4U;
#line 1480
  if (flagssize > t1->flagssize) {
    {
#line 1482
    opj_aligned_free((void *)t1->flags);
#line 1483
    __cil_tmp14 = opj_aligned_malloc((unsigned long )flagssize * sizeof(opj_flag_t ));
#line 1483
    t1->flags = (opj_flag_t *)__cil_tmp14;
    }
#line 1485
    if (! t1->flags) {
#line 1487
      return (0);
    }
  }
  {
#line 1490
  t1->flagssize = flagssize;
#line 1492
  memset((void *)t1->flags, 0, (unsigned long )flagssize * sizeof(opj_flag_t ));
#line 1494
  p = t1->flags + 0;
#line 1495
  x = (OPJ_UINT32 )0;
  }
  {
#line 1495
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1495
    if (! (x < flags_stride)) {
#line 1495
      goto while_break;
    }
#line 1497
    __cil_tmp15 = p;
#line 1497
    p ++;
#line 1497
    *__cil_tmp15 = (((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30);
#line 1495
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 1500
  p = t1->flags + (flags_height + 1U) * flags_stride;
#line 1501
  x = (OPJ_UINT32 )0;
  {
#line 1501
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1501
    if (! (x < flags_stride)) {
#line 1501
      goto while_break___0;
    }
#line 1503
    __cil_tmp16 = p;
#line 1503
    p ++;
#line 1503
    *__cil_tmp16 = (((1U << 21) | (1U << 24)) | (1U << 27)) | (1U << 30);
#line 1501
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1506
  if (h % 4U) {
#line 1507
    v = (OPJ_UINT32 )0;
#line 1508
    p = t1->flags + flags_height * flags_stride;
#line 1509
    if (h % 4U == 1U) {
#line 1510
      v |= ((1U << 24) | (1U << 27)) | (1U << 30);
    } else
#line 1511
    if (h % 4U == 2U) {
#line 1512
      v |= (1U << 27) | (1U << 30);
    } else
#line 1513
    if (h % 4U == 3U) {
#line 1514
      v |= 1U << 30;
    }
#line 1516
    x = (OPJ_UINT32 )0;
    {
#line 1516
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1516
      if (! (x < flags_stride)) {
#line 1516
        goto while_break___1;
      }
#line 1517
      __cil_tmp18 = p;
#line 1517
      p ++;
#line 1517
      *__cil_tmp18 = v;
#line 1516
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 1522
  t1->w = w;
#line 1523
  t1->h = h;
#line 1525
  return (1);
}
}
#line 1536 "/root/patron/new_24/src/lib/openjp2/t1.c"
opj_t1_t *opj_t1_create(OPJ_BOOL isEncoder ) 
{ 
  opj_t1_t *l_t1 ;
  void *__cil_tmp3 ;

  {
  {
#line 1538
  l_t1 = (opj_t1_t *)0;
#line 1540
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_t1_t ));
#line 1540
  l_t1 = (opj_t1_t *)__cil_tmp3;
  }
#line 1541
  if (! l_t1) {
#line 1542
    return ((opj_t1_t *)0);
  }
#line 1545
  l_t1->encoder = isEncoder;
#line 1547
  return (l_t1);
}
}
#line 1556 "/root/patron/new_24/src/lib/openjp2/t1.c"
void opj_t1_destroy(opj_t1_t *p_t1 ) 
{ 


  {
#line 1558
  if (! p_t1) {
#line 1559
    return;
  }
#line 1563
  if (p_t1->data) {
#line 1563
    if (! p_t1->encoder) {
      {
#line 1564
      opj_aligned_free((void *)p_t1->data);
#line 1565
      p_t1->data = (OPJ_INT32 *)0;
      }
    }
  }
#line 1568
  if (p_t1->flags) {
    {
#line 1569
    opj_aligned_free((void *)p_t1->flags);
#line 1570
    p_t1->flags = (opj_flag_t *)0;
    }
  }
  {
#line 1573
  opj_free((void *)p_t1->cblkdatabuffer);
#line 1575
  opj_free((void *)p_t1);
  }
#line 1577
  return;
}
}
#line 1592 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_destroy_wrapper(void *t1 ) 
{ 


  {
  {
#line 1594
  opj_t1_destroy((opj_t1_t *)t1);
  }
#line 1596
  return;
}
}
#line 1597 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_clbl_decode_processor(void *user_data , opj_tls_t *tls ) 
{ 
  opj_tcd_cblk_dec_t *cblk ;
  opj_tcd_band_t *band ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tccp_t *tccp ;
  OPJ_INT32 *datap ;
  OPJ_UINT32 cblk_w ;
  OPJ_UINT32 cblk_h ;
  OPJ_INT32 x ;
  OPJ_INT32 y ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  opj_t1_cblk_decode_processing_job_t *job ;
  opj_t1_t *t1 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 tile_w ;
  void *__cil_tmp19 ;
  OPJ_BOOL __cil_tmp21 ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  OPJ_INT32 *tmp ;
  OPJ_INT32 thresh ;
  OPJ_INT32 val ;
  OPJ_INT32 mag ;
  int __cil_tmp28 ;
  OPJ_INT32 tmp___0 ;
  OPJ_UINT32 cblk_size ;
  __m128 xmm_stepsize ;
  __m128 __cil_tmp33 ;
  __m128 xmm0_data ;
  __m128i __cil_tmp35 ;
  __m128 __cil_tmp36 ;
  __m128 xmm1_data ;
  __m128i __cil_tmp38 ;
  __m128 __cil_tmp39 ;
  __m128 xmm2_data ;
  __m128i __cil_tmp41 ;
  __m128 __cil_tmp42 ;
  __m128 xmm3_data ;
  __m128i __cil_tmp44 ;
  __m128 __cil_tmp45 ;
  __m128 __cil_tmp46 ;
  __m128 __cil_tmp47 ;
  __m128 __cil_tmp48 ;
  __m128 __cil_tmp49 ;
  OPJ_FLOAT32 tmp___2 ;
  OPJ_INT32 *tiledp ;
  OPJ_INT32 tmp0 ;
  OPJ_INT32 tmp1 ;
  OPJ_INT32 tmp2 ;
  OPJ_INT32 tmp3 ;
  OPJ_INT32 tmp___3 ;
  OPJ_FLOAT32 *tiledp___0 ;
  OPJ_FLOAT32 *tiledp2 ;
  OPJ_FLOAT32 tmp___4 ;
  void *tmp___5 ;

  {
#line 1612
  job = (opj_t1_cblk_decode_processing_job_t *)user_data;
#line 1614
  cblk = job->cblk;
#line 1616
  if (! job->whole_tile_decoding) {
    {
#line 1617
    cblk_w = (OPJ_UINT32 )(cblk->x1 - cblk->x0);
#line 1618
    cblk_h = (OPJ_UINT32 )(cblk->y1 - cblk->y0);
#line 1620
    tmp___5 = opj_aligned_malloc((unsigned long )(cblk_w * cblk_h) * sizeof(OPJ_INT32 ));
#line 1620
    cblk->decoded_data = (OPJ_INT32 *)tmp___5;
    }
#line 1621
    if ((unsigned long )cblk->decoded_data == (unsigned long )((void *)0)) {
#line 1622
      if (job->p_manager_mutex) {
        {
#line 1623
        opj_mutex_lock(job->p_manager_mutex);
        }
      }
      {
#line 1625
      opj_event_msg(job->p_manager, 1, "Cannot allocate cblk->decoded_data\n");
      }
#line 1627
      if (job->p_manager_mutex) {
        {
#line 1628
        opj_mutex_unlock(job->p_manager_mutex);
        }
      }
      {
#line 1630
      *(job->pret) = 0;
#line 1631
      opj_free((void *)job);
      }
#line 1632
      return;
    }
    {
#line 1635
    memset((void *)cblk->decoded_data, 0, (unsigned long )(cblk_w * cblk_h) * sizeof(OPJ_INT32 ));
    }
  } else
#line 1636
  if (cblk->decoded_data) {
    {
#line 1639
    opj_aligned_free((void *)cblk->decoded_data);
#line 1640
    cblk->decoded_data = (OPJ_INT32 *)((void *)0);
    }
  }
#line 1643
  resno = job->resno;
#line 1644
  band = job->band;
#line 1645
  tilec = job->tilec;
#line 1646
  tccp = job->tccp;
#line 1647
  tile_w = (OPJ_UINT32 )((tilec->resolutions + (tilec->minimum_num_resolutions - 1U))->x1 - (tilec->resolutions + (tilec->minimum_num_resolutions - 1U))->x0);
#line 1651
  if (! *(job->pret)) {
    {
#line 1652
    opj_free((void *)job);
    }
#line 1653
    return;
  }
  {
#line 1656
  __cil_tmp19 = opj_tls_get(tls, 0);
#line 1656
  t1 = (opj_t1_t *)__cil_tmp19;
  }
#line 1657
  if ((unsigned long )t1 == (unsigned long )((void *)0)) {
    {
#line 1658
    t1 = opj_t1_create(0);
#line 1659
    opj_tls_set(tls, 0, (void *)t1, & opj_t1_destroy_wrapper);
    }
  }
  {
#line 1661
  t1->mustuse_cblkdatabuffer = job->mustuse_cblkdatabuffer;
#line 1663
  __cil_tmp21 = opj_t1_decode_cblk(t1, cblk, band->bandno, (OPJ_UINT32 )tccp->roishift,
                                   tccp->cblksty, job->p_manager, job->p_manager_mutex,
                                   job->check_pterm);
  }
#line 1663
  if (0 == __cil_tmp21) {
    {
#line 1672
    *(job->pret) = 0;
#line 1673
    opj_free((void *)job);
    }
#line 1674
    return;
  }
#line 1677
  x = cblk->x0 - band->x0;
#line 1678
  y = cblk->y0 - band->y0;
#line 1679
  if (band->bandno & 1U) {
#line 1680
    pres = tilec->resolutions + (resno - 1U);
#line 1681
    x += pres->x1 - pres->x0;
  }
#line 1683
  if (band->bandno & 2U) {
#line 1684
    pres___0 = tilec->resolutions + (resno - 1U);
#line 1685
    y += pres___0->y1 - pres___0->y0;
  }
#line 1688
  if (cblk->decoded_data) {
#line 1688
    tmp = cblk->decoded_data;
  } else {
#line 1688
    tmp = t1->data;
  }
#line 1688
  datap = tmp;
#line 1689
  cblk_w = t1->w;
#line 1690
  cblk_h = t1->h;
#line 1692
  if (tccp->roishift) {
#line 1693
    if (tccp->roishift >= 31) {
#line 1694
      j = (OPJ_UINT32 )0;
      {
#line 1694
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1694
        if (! (j < cblk_h)) {
#line 1694
          goto while_break;
        }
#line 1695
        i = (OPJ_UINT32 )0;
        {
#line 1695
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 1695
          if (! (i < cblk_w)) {
#line 1695
            goto while_break___0;
          }
#line 1696
          *(datap + (j * cblk_w + i)) = 0;
#line 1695
          i ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___0: 
#line 1694
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 1700
      thresh = 1 << tccp->roishift;
#line 1701
      j = (OPJ_UINT32 )0;
      {
#line 1701
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1701
        if (! (j < cblk_h)) {
#line 1701
          goto while_break___1;
        }
#line 1702
        i = (OPJ_UINT32 )0;
        {
#line 1702
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1702
          if (! (i < cblk_w)) {
#line 1702
            goto while_break___2;
          }
          {
#line 1703
          val = *(datap + (j * cblk_w + i));
#line 1704
          __cil_tmp28 = abs(val);
#line 1704
          mag = __cil_tmp28;
          }
#line 1705
          if (mag >= thresh) {
#line 1706
            mag >>= tccp->roishift;
#line 1707
            if (val < 0) {
#line 1707
              tmp___0 = - mag;
            } else {
#line 1707
              tmp___0 = mag;
            }
#line 1707
            *(datap + (j * cblk_w + i)) = tmp___0;
          }
#line 1702
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___2: 
#line 1701
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___1: ;
    }
  }
#line 1719
  if (cblk->decoded_data) {
#line 1720
    cblk_size = cblk_w * cblk_h;
#line 1721
    if (tccp->qmfbid == 1U) {
#line 1722
      i = (OPJ_UINT32 )0;
      {
#line 1722
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1722
        if (! (i < cblk_size)) {
#line 1722
          goto while_break___3;
        }
#line 1723
        *(datap + i) /= 2;
#line 1722
        i ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___3: ;
    } else {
      {
#line 1726
      i = (OPJ_UINT32 )0;
#line 1729
      __cil_tmp33 = _mm_set_ss(band->stepsize);
#line 1729
      xmm_stepsize = __cil_tmp33;
      }
      {
#line 1730
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1730
        if (! (i < (cblk_size & 4294967280U))) {
#line 1730
          goto while_break___4;
        }
        {
#line 1731
        __cil_tmp35 = _mm_load_si128(datap + 0);
#line 1731
        __cil_tmp36 = _mm_cvtepi32_ps(__cil_tmp35);
#line 1731
        xmm0_data = __cil_tmp36;
#line 1733
        __cil_tmp38 = _mm_load_si128(datap + 4);
#line 1733
        __cil_tmp39 = _mm_cvtepi32_ps(__cil_tmp38);
#line 1733
        xmm1_data = __cil_tmp39;
#line 1735
        __cil_tmp41 = _mm_load_si128(datap + 8);
#line 1735
        __cil_tmp42 = _mm_cvtepi32_ps(__cil_tmp41);
#line 1735
        xmm2_data = __cil_tmp42;
#line 1737
        __cil_tmp44 = _mm_load_si128(datap + 12);
#line 1737
        __cil_tmp45 = _mm_cvtepi32_ps(__cil_tmp44);
#line 1737
        xmm3_data = __cil_tmp45;
#line 1739
        __cil_tmp46 = _mm_mul_ps(xmm0_data, xmm_stepsize);
#line 1739
        _mm_store_ps((float *)(datap + 0), __cil_tmp46);
#line 1740
        __cil_tmp47 = _mm_mul_ps(xmm1_data, xmm_stepsize);
#line 1740
        _mm_store_ps((float *)(datap + 4), __cil_tmp47);
#line 1741
        __cil_tmp48 = _mm_mul_ps(xmm2_data, xmm_stepsize);
#line 1741
        _mm_store_ps((float *)(datap + 8), __cil_tmp48);
#line 1742
        __cil_tmp49 = _mm_mul_ps(xmm3_data, xmm_stepsize);
#line 1742
        _mm_store_ps((float *)(datap + 12), __cil_tmp49);
#line 1743
        datap += 16;
#line 1730
        i += 16U;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___4: ;
      {
#line 1747
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 1747
        if (! (i < cblk_size)) {
#line 1747
          goto while_break___5;
        }
        {
#line 1748
        tmp___2 = (OPJ_FLOAT32 )*datap * band->stepsize;
#line 1749
        memcpy((void *)datap, (void const   *)(& tmp___2), sizeof(tmp___2));
#line 1750
        datap ++;
#line 1747
        i ++;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___5: ;
    }
  } else
#line 1753
  if (tccp->qmfbid == 1U) {
#line 1754
    tiledp = tilec->data + ((OPJ_SIZE_T )y * (unsigned long )tile_w + (OPJ_SIZE_T )x);
#line 1756
    j = (OPJ_UINT32 )0;
    {
#line 1756
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 1756
      if (! (j < cblk_h)) {
#line 1756
        goto while_break___6;
      }
#line 1757
      i = (OPJ_UINT32 )0;
      {
#line 1758
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 1758
        if (! (i < (cblk_w & 4294967292U))) {
#line 1758
          goto while_break___7;
        }
#line 1759
        tmp0 = *(datap + (j * cblk_w + i));
#line 1760
        tmp1 = *(datap + ((j * cblk_w + i) + 1U));
#line 1761
        tmp2 = *(datap + ((j * cblk_w + i) + 2U));
#line 1762
        tmp3 = *(datap + ((j * cblk_w + i) + 3U));
#line 1763
        *(tiledp + ((unsigned long )j * (OPJ_SIZE_T )tile_w + (unsigned long )i)) = tmp0 / 2;
#line 1764
        *(tiledp + (((unsigned long )j * (OPJ_SIZE_T )tile_w + (unsigned long )i) + 1UL)) = tmp1 / 2;
#line 1765
        *(tiledp + (((unsigned long )j * (OPJ_SIZE_T )tile_w + (unsigned long )i) + 2UL)) = tmp2 / 2;
#line 1766
        *(tiledp + (((unsigned long )j * (OPJ_SIZE_T )tile_w + (unsigned long )i) + 3UL)) = tmp3 / 2;
#line 1758
        i += 4U;
      }
      while_break___19: /* CIL Label */ ;
      }
      while_break___7: ;
      {
#line 1768
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 1768
        if (! (i < cblk_w)) {
#line 1768
          goto while_break___8;
        }
#line 1769
        tmp___3 = *(datap + (j * cblk_w + i));
#line 1770
        *(tiledp + ((unsigned long )j * (OPJ_SIZE_T )tile_w + (unsigned long )i)) = tmp___3 / 2;
#line 1768
        i ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___8: 
#line 1756
      j ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___6: ;
  } else {
#line 1774
    tiledp___0 = (OPJ_FLOAT32 *)(tilec->data + ((OPJ_SIZE_T )y * (unsigned long )tile_w + (OPJ_SIZE_T )x));
#line 1776
    j = (OPJ_UINT32 )0;
    {
#line 1776
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 1776
      if (! (j < cblk_h)) {
#line 1776
        goto while_break___9;
      }
#line 1777
      tiledp2 = tiledp___0;
#line 1778
      i = (OPJ_UINT32 )0;
      {
#line 1778
      while (1) {
        while_continue___10: /* CIL Label */ ;

#line 1778
        if (! (i < cblk_w)) {
#line 1778
          goto while_break___10;
        }
#line 1779
        tmp___4 = (OPJ_FLOAT32 )*datap * band->stepsize;
#line 1780
        *tiledp2 = tmp___4;
#line 1781
        datap ++;
#line 1782
        tiledp2 ++;
#line 1778
        i ++;
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___10: 
#line 1784
      tiledp___0 += tile_w;
#line 1776
      j ++;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___9: ;
  }
  {
#line 1788
  opj_free((void *)job);
  }
#line 1790
  return;
}
}
#line 1792 "/root/patron/new_24/src/lib/openjp2/t1.c"
void opj_t1_decode_cblks(opj_tcd_t *tcd , OPJ_BOOL *pret , opj_tcd_tilecomp_t *tilec ,
                         opj_tccp_t *tccp , opj_event_mgr_t *p_manager , opj_mutex_t *p_manager_mutex ,
                         OPJ_BOOL check_pterm ) 
{ 
  opj_thread_pool_t *tp ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *precinct ;
  OPJ_BOOL __cil_tmp16 ;
  opj_tcd_cblk_dec_t *cblk ;
  opj_tcd_cblk_dec_t *cblk___0 ;
  opj_t1_cblk_decode_processing_job_t *job ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_UINT32 cblk_w ;
  OPJ_UINT32 cblk_h ;
  void *__cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 1801
  tp = tcd->thread_pool;
#line 1809
  resno = (OPJ_UINT32 )0;
  {
#line 1809
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1809
    if (! (resno < tilec->minimum_num_resolutions)) {
#line 1809
      goto while_break;
    }
#line 1810
    res = tilec->resolutions + resno;
#line 1812
    bandno = (OPJ_UINT32 )0;
    {
#line 1812
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 1812
      if (! (bandno < res->numbands)) {
#line 1812
        goto while_break___0;
      }
#line 1813
      band = & res->bands[bandno];
#line 1815
      precno = (OPJ_UINT32 )0;
      {
#line 1815
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: ;
#line 1815
        if (! (precno < res->pw * res->ph)) {
#line 1815
          goto while_break___1;
        }
        {
#line 1816
        precinct = band->precincts + precno;
#line 1818
        __cil_tmp16 = opj_tcd_is_subband_area_of_interest(tcd, tilec->compno, resno,
                                                          band->bandno, (OPJ_UINT32 )precinct->x0,
                                                          (OPJ_UINT32 )precinct->y0,
                                                          (OPJ_UINT32 )precinct->x1,
                                                          (OPJ_UINT32 )precinct->y1);
        }
#line 1818
        if (! __cil_tmp16) {
#line 1826
          cblkno = (OPJ_UINT32 )0;
          {
#line 1826
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 1826
            if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1826
              goto while_break___2;
            }
#line 1827
            cblk = precinct->cblks.dec + cblkno;
#line 1828
            if (cblk->decoded_data) {
              {
#line 1833
              opj_aligned_free((void *)cblk->decoded_data);
#line 1834
              cblk->decoded_data = (OPJ_INT32 *)((void *)0);
              }
            }
#line 1826
            cblkno ++;
          }
          while_break___7: /* CIL Label */ ;
          }
          while_break___2: ;
#line 1837
          goto while_continue___1;
        }
#line 1840
        cblkno = (OPJ_UINT32 )0;
        {
#line 1840
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___3: ;
#line 1840
          if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1840
            goto while_break___3;
          }
          {
#line 1841
          cblk___0 = precinct->cblks.dec + cblkno;
#line 1844
          __cil_tmp20 = opj_tcd_is_subband_area_of_interest(tcd, tilec->compno, resno,
                                                            band->bandno, (OPJ_UINT32 )cblk___0->x0,
                                                            (OPJ_UINT32 )cblk___0->y0,
                                                            (OPJ_UINT32 )cblk___0->x1,
                                                            (OPJ_UINT32 )cblk___0->y1);
          }
#line 1844
          if (! __cil_tmp20) {
#line 1852
            if (cblk___0->decoded_data) {
              {
#line 1857
              opj_aligned_free((void *)cblk___0->decoded_data);
#line 1858
              cblk___0->decoded_data = (OPJ_INT32 *)((void *)0);
              }
            }
#line 1860
            goto while_continue___3;
          }
#line 1863
          if (! tcd->whole_tile_decoding) {
#line 1864
            cblk_w = (OPJ_UINT32 )(cblk___0->x1 - cblk___0->x0);
#line 1865
            cblk_h = (OPJ_UINT32 )(cblk___0->y1 - cblk___0->y0);
#line 1866
            if ((unsigned long )cblk___0->decoded_data != (unsigned long )((void *)0)) {
#line 1871
              goto while_continue___3;
            }
#line 1873
            if (cblk_w == 0U) {
#line 1874
              goto while_continue___3;
            } else
#line 1873
            if (cblk_h == 0U) {
#line 1874
              goto while_continue___3;
            }
          }
          {
#line 1882
          __cil_tmp23 = opj_calloc((size_t )1, sizeof(opj_t1_cblk_decode_processing_job_t ));
#line 1882
          job = (opj_t1_cblk_decode_processing_job_t *)__cil_tmp23;
          }
#line 1884
          if (! job) {
#line 1885
            *pret = 0;
#line 1886
            return;
          }
          {
#line 1888
          job->whole_tile_decoding = tcd->whole_tile_decoding;
#line 1889
          job->resno = resno;
#line 1890
          job->cblk = cblk___0;
#line 1891
          job->band = band;
#line 1892
          job->tilec = tilec;
#line 1893
          job->tccp = tccp;
#line 1894
          job->pret = pret;
#line 1895
          job->p_manager_mutex = p_manager_mutex;
#line 1896
          job->p_manager = p_manager;
#line 1897
          job->check_pterm = check_pterm;
#line 1898
          __cil_tmp24 = opj_thread_pool_get_thread_count(tp);
#line 1898
          job->mustuse_cblkdatabuffer = __cil_tmp24 > 1;
#line 1899
          opj_thread_pool_submit_job(tp, & opj_t1_clbl_decode_processor, (void *)job);
          }
#line 1903
          if (! *pret) {
#line 1904
            return;
          }
#line 1840
          cblkno ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: 
#line 1815
        precno ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 1812
      bandno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 1809
    resno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 1914
  return;
}
}
#line 1918 "/root/patron/new_24/src/lib/openjp2/t1.c"
static OPJ_BOOL opj_t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 orient ,
                                   OPJ_UINT32 roishift , OPJ_UINT32 cblksty , opj_event_mgr_t *p_manager ,
                                   opj_mutex_t *p_manager_mutex , OPJ_BOOL check_pterm ) 
{ 
  opj_mqc_t *mqc ;
  OPJ_INT32 bpno_plus_one ;
  OPJ_UINT32 passtype ;
  OPJ_UINT32 segno ;
  OPJ_UINT32 passno ;
  OPJ_BYTE *cblkdata ;
  OPJ_UINT32 cblkdataindex ;
  OPJ_BYTE type ;
  OPJ_INT32 *original_t1_data ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_UINT32 i ;
  OPJ_UINT32 cblk_len ;
  void *__cil_tmp22 ;
  opj_tcd_seg_t *seg ;
  int tmp ;
  OPJ_INT32 __cil_tmp26 ;

  {
  {
#line 1927
  mqc = & t1->mqc;
#line 1932
  cblkdata = (OPJ_BYTE *)((void *)0);
#line 1933
  cblkdataindex = (OPJ_UINT32 )0;
#line 1934
  type = (OPJ_BYTE )0;
#line 1935
  original_t1_data = (OPJ_INT32 *)((void *)0);
#line 1937
  mqc->lut_ctxno_zc_orient = lut_ctxno_zc + (orient << 9);
#line 1939
  __cil_tmp18 = opj_t1_allocate_buffers(t1, (OPJ_UINT32 )(cblk->x1 - cblk->x0), (OPJ_UINT32 )(cblk->y1 - cblk->y0));
  }
#line 1939
  if (! __cil_tmp18) {
#line 1943
    return (0);
  }
#line 1946
  bpno_plus_one = (OPJ_INT32 )(roishift + cblk->numbps);
#line 1947
  if (bpno_plus_one >= 31) {
#line 1948
    if (p_manager_mutex) {
      {
#line 1949
      opj_mutex_lock(p_manager_mutex);
      }
    }
    {
#line 1951
    opj_event_msg(p_manager, 2, "opj_t1_decode_cblk(): unsupported bpno_plus_one = %d >= 31\n",
                  bpno_plus_one);
    }
#line 1954
    if (p_manager_mutex) {
      {
#line 1955
      opj_mutex_unlock(p_manager_mutex);
      }
    }
#line 1957
    return (0);
  }
  {
#line 1959
  passtype = (OPJ_UINT32 )2;
#line 1961
  opj_mqc_resetstates(mqc);
#line 1962
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 1963
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 1964
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
  }
#line 1969
  if (cblk->numchunks > 1U) {
    _L: 
#line 1974
    cblk_len = (OPJ_UINT32 )0;
#line 1975
    i = (OPJ_UINT32 )0;
    {
#line 1975
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1975
      if (! (i < cblk->numchunks)) {
#line 1975
        goto while_break;
      }
#line 1976
      cblk_len += (cblk->chunks + i)->len;
#line 1975
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
#line 1980
    if (cblk_len + 2U > t1->cblkdatabuffersize) {
      {
#line 1981
      __cil_tmp22 = opj_realloc((void *)t1->cblkdatabuffer, (size_t )(cblk_len + 2U));
#line 1981
      cblkdata = (OPJ_BYTE *)__cil_tmp22;
      }
#line 1983
      if ((unsigned long )cblkdata == (unsigned long )((void *)0)) {
#line 1984
        return (0);
      }
      {
#line 1986
      t1->cblkdatabuffer = cblkdata;
#line 1987
      memset((void *)(t1->cblkdatabuffer + cblk_len), 0, 2UL);
#line 1988
      t1->cblkdatabuffersize = cblk_len + 2U;
      }
    }
#line 1992
    cblkdata = t1->cblkdatabuffer;
#line 1993
    cblk_len = (OPJ_UINT32 )0;
#line 1994
    i = (OPJ_UINT32 )0;
    {
#line 1994
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1994
      if (! (i < cblk->numchunks)) {
#line 1994
        goto while_break___0;
      }
      {
#line 1995
      memcpy((void *)(cblkdata + cblk_len), (void const   *)(cblk->chunks + i)->data,
             (unsigned long )(cblk->chunks + i)->len);
#line 1996
      cblk_len += (cblk->chunks + i)->len;
#line 1994
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: ;
  } else
#line 1969
  if (t1->mustuse_cblkdatabuffer) {
#line 1969
    goto _L;
  } else
#line 1998
  if (cblk->numchunks == 1U) {
#line 1999
    cblkdata = (cblk->chunks + 0)->data;
  }
#line 2004
  if (cblk->decoded_data) {
#line 2005
    original_t1_data = t1->data;
#line 2006
    t1->data = cblk->decoded_data;
  }
#line 2009
  segno = (OPJ_UINT32 )0;
  {
#line 2009
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 2009
    if (! (segno < cblk->real_num_segs)) {
#line 2009
      goto while_break___1;
    }
#line 2010
    seg = cblk->segs + segno;
#line 2013
    if (bpno_plus_one <= (OPJ_INT32 )cblk->numbps - 4) {
#line 2013
      if (passtype < 2U) {
#line 2013
        if (cblksty & 1U) {
#line 2013
          tmp = 1;
        } else {
#line 2013
          tmp = 0;
        }
      } else {
#line 2013
        tmp = 0;
      }
    } else {
#line 2013
      tmp = 0;
    }
#line 2013
    type = (OPJ_BYTE )tmp;
#line 2016
    if ((int )type == 1) {
      {
#line 2017
      opj_mqc_raw_init_dec(mqc, cblkdata + cblkdataindex, seg->len, (OPJ_UINT32 )2);
      }
    } else {
      {
#line 2020
      opj_mqc_init_dec(mqc, cblkdata + cblkdataindex, seg->len, (OPJ_UINT32 )2);
      }
    }
#line 2023
    cblkdataindex += seg->len;
#line 2025
    passno = (OPJ_UINT32 )0;
    {
#line 2025
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 2025
      if (passno < seg->real_num_passes) {
#line 2025
        if (! (bpno_plus_one >= 1)) {
#line 2025
          goto while_break___2;
        }
      } else {
#line 2025
        goto while_break___2;
      }
#line 2028
      if (passtype == 0U) {
#line 2028
        goto case_0;
      }
#line 2035
      if (passtype == 1U) {
#line 2035
        goto case_1;
      }
#line 2042
      if (passtype == 2U) {
#line 2042
        goto case_2;
      }
#line 2027
      goto switch_break;
      case_0: 
#line 2029
      if ((int )type == 1) {
        {
#line 2030
        opj_t1_dec_sigpass_raw(t1, bpno_plus_one, (OPJ_INT32 )cblksty);
        }
      } else {
        {
#line 2032
        opj_t1_dec_sigpass_mqc(t1, bpno_plus_one, (OPJ_INT32 )cblksty);
        }
      }
#line 2034
      goto switch_break;
      case_1: 
#line 2036
      if ((int )type == 1) {
        {
#line 2037
        opj_t1_dec_refpass_raw(t1, bpno_plus_one);
        }
      } else {
        {
#line 2039
        opj_t1_dec_refpass_mqc(t1, bpno_plus_one);
        }
      }
#line 2041
      goto switch_break;
      case_2: 
      {
#line 2043
      opj_t1_dec_clnpass(t1, bpno_plus_one, (OPJ_INT32 )cblksty);
      }
#line 2044
      goto switch_break;
      switch_break: ;
#line 2047
      if (cblksty & 2U) {
#line 2047
        if ((int )type == 0) {
          {
#line 2048
          opj_mqc_resetstates(mqc);
#line 2049
          opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 2050
          opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 2051
          opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
          }
        }
      }
#line 2053
      passtype ++;
#line 2053
      if (passtype == 3U) {
#line 2054
        passtype = (OPJ_UINT32 )0;
#line 2055
        __cil_tmp26 = bpno_plus_one;
#line 2055
        bpno_plus_one --;
      }
#line 2026
      passno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 2059
    opq_mqc_finish_dec(mqc);
#line 2009
    segno ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 2062
  if (check_pterm) {
#line 2063
    if ((unsigned long )(mqc->bp + 2) < (unsigned long )mqc->end) {
#line 2064
      if (p_manager_mutex) {
        {
#line 2065
        opj_mutex_lock(p_manager_mutex);
        }
      }
      {
#line 2067
      opj_event_msg(p_manager, 2, "PTERM check failure: %d remaining bytes in code block (%d used / %d)\n",
                    (int )(mqc->end - mqc->bp) - 2, (int )(mqc->bp - mqc->start),
                    (int )(mqc->end - mqc->start));
      }
#line 2072
      if (p_manager_mutex) {
        {
#line 2073
        opj_mutex_unlock(p_manager_mutex);
        }
      }
    } else
#line 2075
    if (mqc->end_of_byte_stream_counter > 2U) {
#line 2076
      if (p_manager_mutex) {
        {
#line 2077
        opj_mutex_lock(p_manager_mutex);
        }
      }
      {
#line 2079
      opj_event_msg(p_manager, 2, "PTERM check failure: %d synthetized 0xFF markers read\n",
                    mqc->end_of_byte_stream_counter);
      }
#line 2082
      if (p_manager_mutex) {
        {
#line 2083
        opj_mutex_unlock(p_manager_mutex);
        }
      }
    }
  }
#line 2089
  if (cblk->decoded_data) {
#line 2090
    t1->data = original_t1_data;
  }
#line 2093
  return (1);
}
}
#line 2099 "/root/patron/new_24/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                             OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tccp_t *tccp ;
  OPJ_UINT32 tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_INT32 bandconst ;
  OPJ_BOOL __cil_tmp17 ;
  double __cil_tmp18 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  OPJ_INT32 *tiledp ;
  OPJ_UINT32 cblk_w ;
  OPJ_UINT32 cblk_h ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 tileLineAdvance ;
  OPJ_SIZE_T tileIndex ;
  OPJ_INT32 x ;
  OPJ_INT32 y ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_INT32 tmp ;

  {
#line 2108
  tile->distotile = (OPJ_FLOAT64 )0;
#line 2110
  compno = (OPJ_UINT32 )0;
  {
#line 2110
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2110
    if (! (compno < tile->numcomps)) {
#line 2110
      goto while_break;
    }
#line 2111
    tilec = tile->comps + compno;
#line 2112
    tccp = tcp->tccps + compno;
#line 2113
    tile_w = (OPJ_UINT32 )(tilec->x1 - tilec->x0);
#line 2115
    resno = (OPJ_UINT32 )0;
    {
#line 2115
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 2115
      if (! (resno < tilec->numresolutions)) {
#line 2115
        goto while_break___0;
      }
#line 2116
      res = tilec->resolutions + resno;
#line 2118
      bandno = (OPJ_UINT32 )0;
      {
#line 2118
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 2118
        if (! (bandno < res->numbands)) {
#line 2118
          goto while_break___1;
        }
        {
#line 2119
        band = & res->bands[bandno];
#line 2123
        __cil_tmp17 = opj_tcd_is_band_empty(band);
        }
#line 2123
        if (__cil_tmp17) {
#line 2124
          goto while_continue___1;
        }
        {
#line 2127
        __cil_tmp18 = floor((double )(band->stepsize * (float )8192));
#line 2127
        bandconst = 67108864 / (OPJ_INT32 )__cil_tmp18;
#line 2128
        precno = (OPJ_UINT32 )0;
        }
        {
#line 2128
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 2128
          if (! (precno < res->pw * res->ph)) {
#line 2128
            goto while_break___2;
          }
#line 2129
          prc = band->precincts + precno;
#line 2131
          cblkno = (OPJ_UINT32 )0;
          {
#line 2131
          while (1) {
            while_continue___5: /* CIL Label */ ;

#line 2131
            if (! (cblkno < prc->cw * prc->ch)) {
#line 2131
              goto while_break___3;
            }
#line 2132
            cblk = prc->cblks.enc + cblkno;
#line 2137
            tileIndex = (OPJ_SIZE_T )0;
#line 2139
            x = cblk->x0 - band->x0;
#line 2140
            y = cblk->y0 - band->y0;
#line 2141
            if (band->bandno & 1U) {
#line 2142
              pres = tilec->resolutions + (resno - 1U);
#line 2143
              x += pres->x1 - pres->x0;
            }
#line 2145
            if (band->bandno & 2U) {
#line 2146
              pres___0 = tilec->resolutions + (resno - 1U);
#line 2147
              y += pres___0->y1 - pres___0->y0;
            }
            {
#line 2150
            __cil_tmp32 = opj_t1_allocate_buffers(t1, (OPJ_UINT32 )(cblk->x1 - cblk->x0),
                                                  (OPJ_UINT32 )(cblk->y1 - cblk->y0));
            }
#line 2150
            if (! __cil_tmp32) {
#line 2154
              return (0);
            }
#line 2157
            cblk_w = t1->w;
#line 2158
            cblk_h = t1->h;
#line 2159
            tileLineAdvance = tile_w - cblk_w;
#line 2161
            tiledp = tilec->data + ((OPJ_SIZE_T )y * (unsigned long )tile_w + (OPJ_SIZE_T )x);
#line 2162
            t1->data = tiledp;
#line 2163
            t1->data_stride = tile_w;
#line 2164
            if (tccp->qmfbid == 1U) {
#line 2165
              j = (OPJ_UINT32 )0;
              {
#line 2165
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 2165
                if (! (j < cblk_h)) {
#line 2165
                  goto while_break___4;
                }
#line 2166
                i = (OPJ_UINT32 )0;
                {
#line 2166
                while (1) {
                  while_continue___7: /* CIL Label */ ;

#line 2166
                  if (! (i < cblk_w)) {
#line 2166
                    goto while_break___5;
                  }
#line 2167
                  *(tiledp + tileIndex) *= 1 << 6;
#line 2168
                  tileIndex ++;
#line 2166
                  i ++;
                }
                while_break___14: /* CIL Label */ ;
                }
                while_break___5: 
#line 2170
                tileIndex += (unsigned long )tileLineAdvance;
#line 2165
                j ++;
              }
              while_break___13: /* CIL Label */ ;
              }
              while_break___4: ;
            } else {
#line 2173
              j = (OPJ_UINT32 )0;
              {
#line 2173
              while (1) {
                while_continue___8: /* CIL Label */ ;

#line 2173
                if (! (j < cblk_h)) {
#line 2173
                  goto while_break___6;
                }
#line 2174
                i = (OPJ_UINT32 )0;
                {
#line 2174
                while (1) {
                  while_continue___9: /* CIL Label */ ;

#line 2174
                  if (! (i < cblk_w)) {
#line 2174
                    goto while_break___7;
                  }
                  {
#line 2175
                  tmp = *(tiledp + tileIndex);
#line 2176
                  *(tiledp + tileIndex) = opj_int_fix_mul_t1(tmp, bandconst);
#line 2180
                  tileIndex ++;
#line 2174
                  i ++;
                  }
                }
                while_break___16: /* CIL Label */ ;
                }
                while_break___7: 
#line 2182
                tileIndex += (unsigned long )tileLineAdvance;
#line 2173
                j ++;
              }
              while_break___15: /* CIL Label */ ;
              }
              while_break___6: ;
            }
            {
#line 2186
            opj_t1_encode_cblk(t1, cblk, band->bandno, compno, (tilec->numresolutions - 1U) - resno,
                               tccp->qmfbid, (OPJ_FLOAT64 )band->stepsize, tccp->cblksty,
                               tile->numcomps, tile, mct_norms, mct_numcomps);
#line 2131
            cblkno ++;
            }
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___3: 
#line 2128
          precno ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___2: 
#line 2118
        bandno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___1: 
#line 2115
      resno ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: 
#line 2110
    compno ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: ;
#line 2205
  return (1);
}
}
#line 2209 "/root/patron/new_24/src/lib/openjp2/t1.c"
static int opj_t1_enc_is_term_pass(opj_tcd_cblk_enc_t *cblk , OPJ_UINT32 cblksty ,
                                   OPJ_INT32 bpno , OPJ_UINT32 passtype ) 
{ 


  {
#line 2215
  if (passtype == 2U) {
#line 2215
    if (bpno == 0) {
#line 2216
      return (1);
    }
  }
#line 2219
  if (cblksty & 4U) {
#line 2220
    return (1);
  }
#line 2223
  if (cblksty & 1U) {
#line 2225
    if (bpno == (OPJ_INT32 )cblk->numbps - 4) {
#line 2225
      if (passtype == 2U) {
#line 2226
        return (1);
      }
    }
#line 2230
    if (bpno < (OPJ_INT32 )cblk->numbps - 4) {
#line 2230
      if (passtype > 0U) {
#line 2231
        return (1);
      }
    }
  }
#line 2235
  return (0);
}
}
#line 2240 "/root/patron/new_24/src/lib/openjp2/t1.c"
static void opj_t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , OPJ_UINT32 orient ,
                               OPJ_UINT32 compno , OPJ_UINT32 level , OPJ_UINT32 qmfbid ,
                               OPJ_FLOAT64 stepsize , OPJ_UINT32 cblksty , OPJ_UINT32 numcomps ,
                               opj_tcd_tile_t *tile , OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) 
{ 
  OPJ_FLOAT64 cumwmsedec ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 passno ;
  OPJ_INT32 bpno ;
  OPJ_UINT32 passtype ;
  OPJ_INT32 nmsedec ;
  OPJ_INT32 max ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_BYTE type ;
  OPJ_FLOAT64 tempwmsedec ;
  OPJ_INT32 tmp ;
  int __cil_tmp25 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_UINT32 tmp___0 ;
  opj_tcd_pass_t *pass ;
  int tmp___1 ;
  int __cil_tmp32 ;
  OPJ_UINT32 rate_extra_bytes ;
  OPJ_UINT32 __cil_tmp36 ;
  OPJ_INT32 __cil_tmp37 ;
  OPJ_UINT32 last_pass_rate ;
  OPJ_UINT32 __cil_tmp39 ;
  opj_tcd_pass_t *pass___0 ;
  opj_tcd_pass_t *pass___1 ;
  OPJ_UINT32 __cil_tmp43 ;
  unsigned int tmp___3 ;

  {
#line 2253
  cumwmsedec = 0.;
#line 2255
  mqc = & t1->mqc;
#line 2260
  nmsedec = 0;
#line 2263
  type = (OPJ_BYTE )0;
#line 2271
  mqc->lut_ctxno_zc_orient = lut_ctxno_zc + (orient << 9);
#line 2273
  max = 0;
#line 2274
  i = (OPJ_UINT32 )0;
  {
#line 2274
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2274
    if (! (i < t1->w)) {
#line 2274
      goto while_break;
    }
#line 2275
    j = (OPJ_UINT32 )0;
    {
#line 2275
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2275
      if (! (j < t1->h)) {
#line 2275
        goto while_break___0;
      }
      {
#line 2276
      __cil_tmp25 = abs(*(t1->data + (i + j * t1->data_stride)));
#line 2276
      tmp = __cil_tmp25;
#line 2277
      max = opj_int_max(max, tmp);
#line 2275
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 2274
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 2281
  if (max) {
    {
#line 2281
    __cil_tmp27 = opj_int_floorlog2(max);
#line 2281
    tmp___0 = (OPJ_UINT32 )((__cil_tmp27 + 1) - 6);
    }
  } else {
#line 2281
    tmp___0 = 0U;
  }
#line 2281
  cblk->numbps = tmp___0;
#line 2283
  if (cblk->numbps == 0U) {
#line 2284
    cblk->totalpasses = (OPJ_UINT32 )0;
#line 2285
    return;
  }
  {
#line 2288
  bpno = (OPJ_INT32 )(cblk->numbps - 1U);
#line 2289
  passtype = (OPJ_UINT32 )2;
#line 2291
  opj_mqc_resetstates(mqc);
#line 2292
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 2293
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 2294
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
#line 2295
  opj_mqc_init_enc(mqc, cblk->data);
#line 2297
  passno = (OPJ_UINT32 )0;
  }
  {
#line 2297
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 2297
    if (! (bpno >= 0)) {
#line 2297
      goto while_break___1;
    }
#line 2298
    pass = cblk->passes + passno;
#line 2299
    if (bpno < (OPJ_INT32 )cblk->numbps - 4) {
#line 2299
      if (passtype < 2U) {
#line 2299
        if (cblksty & 1U) {
#line 2299
          tmp___1 = 1;
        } else {
#line 2299
          tmp___1 = 0;
        }
      } else {
#line 2299
        tmp___1 = 0;
      }
    } else {
#line 2299
      tmp___1 = 0;
    }
#line 2299
    type = (OPJ_BYTE )tmp___1;
#line 2303
    if (passno > 0U) {
#line 2303
      if ((int )(cblk->passes + (passno - 1U))->term) {
#line 2304
        if ((int )type == 1) {
          {
#line 2305
          opj_mqc_bypass_init_enc(mqc);
          }
        } else {
          {
#line 2307
          opj_mqc_restart_init_enc(mqc);
          }
        }
      }
    }
#line 2312
    if (passtype == 0U) {
#line 2312
      goto case_0;
    }
#line 2315
    if (passtype == 1U) {
#line 2315
      goto case_1;
    }
#line 2318
    if (passtype == 2U) {
#line 2318
      goto case_2;
    }
#line 2311
    goto switch_break;
    case_0: 
    {
#line 2313
    opj_t1_enc_sigpass(t1, bpno, & nmsedec, type, cblksty);
    }
#line 2314
    goto switch_break;
    case_1: 
    {
#line 2316
    opj_t1_enc_refpass(t1, bpno, & nmsedec, type);
    }
#line 2317
    goto switch_break;
    case_2: 
    {
#line 2319
    opj_t1_enc_clnpass(t1, bpno, & nmsedec, cblksty);
    }
#line 2321
    if (cblksty & 32U) {
      {
#line 2322
      opj_mqc_segmark_enc(mqc);
      }
    }
#line 2324
    goto switch_break;
    switch_break: 
    {
#line 2328
    tempwmsedec = opj_t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid,
                                    stepsize, numcomps, mct_norms, mct_numcomps);
#line 2330
    cumwmsedec += tempwmsedec;
#line 2331
    tile->distotile += tempwmsedec;
#line 2332
    pass->distortiondec = cumwmsedec;
#line 2334
    __cil_tmp32 = opj_t1_enc_is_term_pass(cblk, cblksty, bpno, passtype);
    }
#line 2334
    if (__cil_tmp32) {
#line 2336
      if ((int )type == 1) {
        {
#line 2337
        opj_mqc_bypass_flush_enc(mqc, (OPJ_BOOL )(cblksty & 16U));
        }
      } else
#line 2339
      if (cblksty & 16U) {
        {
#line 2340
        opj_mqc_erterm_enc(mqc);
        }
      } else {
        {
#line 2342
        opj_mqc_flush(mqc);
        }
      }
      {
#line 2345
      pass->term = (OPJ_BITFIELD )1;
#line 2346
      pass->rate = opj_mqc_numbytes(mqc);
      }
    } else {
#line 2350
      if ((int )type == 1) {
        {
#line 2351
        rate_extra_bytes = opj_mqc_bypass_get_extra_bytes(mqc, (OPJ_BOOL )(cblksty & 16U));
        }
      } else {
#line 2354
        rate_extra_bytes = (OPJ_UINT32 )3;
      }
      {
#line 2356
      pass->term = (OPJ_BITFIELD )0;
#line 2357
      __cil_tmp36 = opj_mqc_numbytes(mqc);
#line 2357
      pass->rate = __cil_tmp36 + rate_extra_bytes;
      }
    }
#line 2360
    passtype ++;
#line 2360
    if (passtype == 3U) {
#line 2361
      passtype = (OPJ_UINT32 )0;
#line 2362
      __cil_tmp37 = bpno;
#line 2362
      bpno --;
    }
#line 2366
    if (cblksty & 2U) {
      {
#line 2367
      opj_mqc_reset_enc(mqc);
      }
    }
#line 2297
    passno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
#line 2371
  cblk->totalpasses = passno;
#line 2373
  if (cblk->totalpasses) {
    {
#line 2375
    __cil_tmp39 = opj_mqc_numbytes(mqc);
#line 2375
    last_pass_rate = __cil_tmp39;
#line 2376
    passno = cblk->totalpasses;
    }
    {
#line 2376
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 2376
      if (! (passno > 0U)) {
#line 2376
        goto while_break___2;
      }
#line 2377
      passno --;
#line 2377
      pass___0 = cblk->passes + passno;
#line 2378
      if (pass___0->rate > last_pass_rate) {
#line 2379
        pass___0->rate = last_pass_rate;
      } else {
#line 2381
        last_pass_rate = pass___0->rate;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 2386
  passno = (OPJ_UINT32 )0;
  {
#line 2386
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 2386
    if (! (passno < cblk->totalpasses)) {
#line 2386
      goto while_break___3;
    }
#line 2387
    pass___1 = cblk->passes + passno;
#line 2392
    if ((int )*(cblk->data + (pass___1->rate - 1U)) == 255) {
#line 2393
      __cil_tmp43 = pass___1->rate;
#line 2393
      (pass___1->rate) --;
    }
#line 2395
    if (passno == 0U) {
#line 2395
      tmp___3 = 0U;
    } else {
#line 2395
      tmp___3 = (cblk->passes + (passno - 1U))->rate;
    }
#line 2395
    pass___1->len = pass___1->rate - tmp___3;
#line 2386
    passno ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: ;
#line 2390
  return;
}
}
#line 45 "/root/patron/new_24/src/lib/openjp2/sparse_array.c"
opj_sparse_array_int32_t *opj_sparse_array_int32_create(OPJ_UINT32 width , OPJ_UINT32 height ,
                                                        OPJ_UINT32 block_width , OPJ_UINT32 block_height ) 
{ 
  opj_sparse_array_int32_t *sa ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 52
  if (width == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  } else
#line 52
  if (height == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  } else
#line 52
  if (block_width == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  } else
#line 52
  if (block_height == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
#line 55
  if ((unsigned long )block_width > (unsigned long )(4294967295U / block_height) / sizeof(OPJ_INT32 )) {
#line 56
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
  {
#line 59
  tmp = opj_calloc((size_t )1, sizeof(opj_sparse_array_int32_t ));
#line 59
  sa = (opj_sparse_array_int32_t *)tmp;
#line 60
  sa->width = width;
#line 61
  sa->height = height;
#line 62
  sa->block_width = block_width;
#line 63
  sa->block_height = block_height;
#line 64
  sa->block_count_hor = opj_uint_ceildiv(width, block_width);
#line 65
  sa->block_count_ver = opj_uint_ceildiv(height, block_height);
  }
#line 66
  if (sa->block_count_hor > 4294967295U / sa->block_count_ver) {
    {
#line 67
    opj_free((void *)sa);
    }
#line 68
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
  {
#line 70
  tmp___0 = opj_calloc(sizeof(OPJ_INT32 *), (size_t )(sa->block_count_hor * sa->block_count_ver));
#line 70
  sa->data_blocks = (OPJ_INT32 **)tmp___0;
  }
#line 72
  if ((unsigned long )sa->data_blocks == (unsigned long )((void *)0)) {
    {
#line 73
    opj_free((void *)sa);
    }
#line 74
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
#line 77
  return (sa);
}
}
#line 80 "/root/patron/new_24/src/lib/openjp2/sparse_array.c"
void opj_sparse_array_int32_free(opj_sparse_array_int32_t *sa ) 
{ 
  OPJ_UINT32 i ;

  {
#line 82
  if (sa) {
#line 84
    i = (OPJ_UINT32 )0;
    {
#line 84
    while (1) {
      while_continue: /* CIL Label */ ;

#line 84
      if (! (i < sa->block_count_hor * sa->block_count_ver)) {
#line 84
        goto while_break;
      }
#line 85
      if (*(sa->data_blocks + i)) {
        {
#line 86
        opj_free((void *)*(sa->data_blocks + i));
        }
      }
#line 84
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 89
    opj_free((void *)sa->data_blocks);
#line 90
    opj_free((void *)sa);
    }
  }
#line 93
  return;
}
}
#line 94 "/root/patron/new_24/src/lib/openjp2/sparse_array.c"
OPJ_BOOL opj_sparse_array_is_region_valid(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                          OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ) 
{ 
  int tmp ;

  {
#line 100
  if (x0 >= sa->width) {
#line 100
    tmp = 0;
  } else
#line 100
  if (x1 <= x0) {
#line 100
    tmp = 0;
  } else
#line 100
  if (x1 > sa->width) {
#line 100
    tmp = 0;
  } else
#line 100
  if (y0___0 >= sa->height) {
#line 100
    tmp = 0;
  } else
#line 100
  if (y1___0 <= y0___0) {
#line 100
    tmp = 0;
  } else
#line 100
  if (y1___0 > sa->height) {
#line 100
    tmp = 0;
  } else {
#line 100
    tmp = 1;
  }
#line 100
  return (tmp);
}
}
#line 104 "/root/patron/new_24/src/lib/openjp2/sparse_array.c"
static OPJ_BOOL opj_sparse_array_int32_read_or_write(opj_sparse_array_int32_t *sa ,
                                                     OPJ_UINT32 x0 , OPJ_UINT32 y0___0 ,
                                                     OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                                     OPJ_INT32 *buf , OPJ_UINT32 buf_col_stride ,
                                                     OPJ_UINT32 buf_line_stride ,
                                                     OPJ_BOOL forgiving , OPJ_BOOL is_read_op ) 
{ 
  OPJ_UINT32 y ;
  OPJ_UINT32 block_y ;
  OPJ_UINT32 y_incr ;
  OPJ_UINT32 block_width ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_UINT32 x ;
  OPJ_UINT32 block_x ;
  OPJ_UINT32 x_incr ;
  OPJ_UINT32 block_y_offset ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 j ;
  OPJ_UINT32 block_x_offset ;
  OPJ_INT32 *src_block ;
  OPJ_UINT32 tmp___0 ;
  OPJ_INT32 *dest_ptr ;
  OPJ_INT32 *dest_ptr___0 ;
  OPJ_UINT32 k ;
  OPJ_INT32 *src_ptr ;
  OPJ_INT32 *dest_ptr___1 ;
  OPJ_INT32 *dest_ptr___2 ;
  OPJ_UINT32 k___0 ;
  OPJ_UINT32 k___1 ;
  OPJ_UINT32 k___2 ;
  OPJ_INT32 *dest_ptr___3 ;
  OPJ_INT32 *src_ptr___0 ;
  OPJ_INT32 *dest_ptr___4 ;
  OPJ_INT32 *src_ptr___1 ;
  OPJ_UINT32 k___3 ;
  OPJ_UINT32 k___4 ;
  OPJ_UINT32 __cil_tmp61 ;
  OPJ_UINT32 __cil_tmp62 ;
  void *tmp___1 ;

  {
  {
#line 117
  y_incr = (OPJ_UINT32 )0;
#line 118
  block_width = sa->block_width;
#line 120
  __cil_tmp15 = opj_sparse_array_is_region_valid(sa, x0, y0___0, x1, y1___0);
  }
#line 120
  if (! __cil_tmp15) {
#line 121
    return (forgiving);
  }
#line 124
  block_y = y0___0 / sa->block_height;
#line 125
  y = y0___0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;

#line 125
    if (! (y < y1___0)) {
#line 125
      goto while_break;
    }
#line 127
    x_incr = (OPJ_UINT32 )0;
#line 129
    if (y == y0___0) {
#line 129
      tmp = sa->block_height - y0___0 % sa->block_height;
    } else {
#line 129
      tmp = sa->block_height;
    }
    {
#line 129
    y_incr = tmp;
#line 131
    block_y_offset = sa->block_height - y_incr;
#line 132
    y_incr = opj_uint_min(y_incr, y1___0 - y);
#line 133
    block_x = x0 / block_width;
#line 134
    x = x0;
    }
    {
#line 134
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 134
      if (! (x < x1)) {
#line 134
        goto while_break___0;
      }
#line 138
      if (x == x0) {
#line 138
        tmp___0 = block_width - x0 % block_width;
      } else {
#line 138
        tmp___0 = block_width;
      }
      {
#line 138
      x_incr = tmp___0;
#line 139
      block_x_offset = block_width - x_incr;
#line 140
      x_incr = opj_uint_min(x_incr, x1 - x);
#line 141
      src_block = *(sa->data_blocks + (block_y * sa->block_count_hor + block_x));
      }
#line 142
      if (is_read_op) {
#line 143
        if ((unsigned long )src_block == (unsigned long )((void *)0)) {
#line 144
          if (buf_col_stride == 1U) {
#line 145
            dest_ptr = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 147
            j = (OPJ_UINT32 )0;
            {
#line 147
            while (1) {
              while_continue___1: /* CIL Label */ ;

#line 147
              if (! (j < y_incr)) {
#line 147
                goto while_break___1;
              }
              {
#line 148
              memset((void *)dest_ptr, 0, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 149
              dest_ptr += buf_line_stride;
#line 147
              j ++;
              }
            }
            while_break___24: /* CIL Label */ ;
            }
            while_break___1: ;
          } else {
#line 152
            dest_ptr___0 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 154
            j = (OPJ_UINT32 )0;
            {
#line 154
            while (1) {
              while_continue___2: /* CIL Label */ ;

#line 154
              if (! (j < y_incr)) {
#line 154
                goto while_break___2;
              }
#line 156
              k = (OPJ_UINT32 )0;
              {
#line 156
              while (1) {
                while_continue___3: /* CIL Label */ ;

#line 156
                if (! (k < x_incr)) {
#line 156
                  goto while_break___3;
                }
#line 157
                *(dest_ptr___0 + k * buf_col_stride) = 0;
#line 156
                k ++;
              }
              while_break___26: /* CIL Label */ ;
              }
              while_break___3: 
#line 159
              dest_ptr___0 += buf_line_stride;
#line 154
              j ++;
            }
            while_break___25: /* CIL Label */ ;
            }
            while_break___2: ;
          }
        } else {
#line 163
          src_ptr = (src_block + (unsigned long )block_y_offset * (OPJ_SIZE_T )block_width) + block_x_offset;
#line 165
          if (buf_col_stride == 1U) {
#line 166
            dest_ptr___1 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 169
            if (x_incr == 4U) {
#line 172
              j = (OPJ_UINT32 )0;
              {
#line 172
              while (1) {
                while_continue___4: /* CIL Label */ ;

#line 172
                if (! (j < y_incr)) {
#line 172
                  goto while_break___4;
                }
                {
#line 173
                memcpy((void *)dest_ptr___1, (void const   *)src_ptr, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 174
                dest_ptr___1 += buf_line_stride;
#line 175
                src_ptr += block_width;
#line 172
                j ++;
                }
              }
              while_break___27: /* CIL Label */ ;
              }
              while_break___4: ;
            } else {
#line 178
              j = (OPJ_UINT32 )0;
              {
#line 178
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 178
                if (! (j < y_incr)) {
#line 178
                  goto while_break___5;
                }
                {
#line 179
                memcpy((void *)dest_ptr___1, (void const   *)src_ptr, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 180
                dest_ptr___1 += buf_line_stride;
#line 181
                src_ptr += block_width;
#line 178
                j ++;
                }
              }
              while_break___28: /* CIL Label */ ;
              }
              while_break___5: ;
            }
          } else {
#line 185
            dest_ptr___2 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 188
            if (x_incr == 1U) {
#line 189
              j = (OPJ_UINT32 )0;
              {
#line 189
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 189
                if (! (j < y_incr)) {
#line 189
                  goto while_break___6;
                }
#line 190
                *dest_ptr___2 = *src_ptr;
#line 191
                dest_ptr___2 += buf_line_stride;
#line 192
                src_ptr += block_width;
#line 189
                j ++;
              }
              while_break___29: /* CIL Label */ ;
              }
              while_break___6: ;
            } else
#line 194
            if (y_incr == 1U) {
#line 194
              if (buf_col_stride == 2U) {
#line 196
                k___0 = (OPJ_UINT32 )0;
                {
#line 196
                while (1) {
                  while_continue___7: /* CIL Label */ ;

#line 196
                  if (! (k___0 < (x_incr & 4294967292U))) {
#line 196
                    goto while_break___7;
                  }
#line 197
                  *(dest_ptr___2 + k___0 * buf_col_stride) = *(src_ptr + k___0);
#line 198
                  *(dest_ptr___2 + (k___0 + 1U) * buf_col_stride) = *(src_ptr + (k___0 + 1U));
#line 199
                  *(dest_ptr___2 + (k___0 + 2U) * buf_col_stride) = *(src_ptr + (k___0 + 2U));
#line 200
                  *(dest_ptr___2 + (k___0 + 3U) * buf_col_stride) = *(src_ptr + (k___0 + 3U));
#line 196
                  k___0 += 4U;
                }
                while_break___30: /* CIL Label */ ;
                }
                while_break___7: ;
                {
#line 202
                while (1) {
                  while_continue___8: /* CIL Label */ ;

#line 202
                  if (! (k___0 < x_incr)) {
#line 202
                    goto while_break___8;
                  }
#line 203
                  *(dest_ptr___2 + k___0 * buf_col_stride) = *(src_ptr + k___0);
#line 202
                  k___0 ++;
                }
                while_break___31: /* CIL Label */ ;
                }
                while_break___8: ;
              } else {
#line 194
                goto _L___6;
              }
            } else
            _L___6: 
#line 205
            if (x_incr >= 8U) {
#line 205
              if (buf_col_stride == 8U) {
#line 206
                j = (OPJ_UINT32 )0;
                {
#line 206
                while (1) {
                  while_continue___9: /* CIL Label */ ;

#line 206
                  if (! (j < y_incr)) {
#line 206
                    goto while_break___9;
                  }
#line 208
                  k___1 = (OPJ_UINT32 )0;
                  {
#line 208
                  while (1) {
                    while_continue___10: /* CIL Label */ ;

#line 208
                    if (! (k___1 < (x_incr & 4294967292U))) {
#line 208
                      goto while_break___10;
                    }
#line 209
                    *(dest_ptr___2 + k___1 * buf_col_stride) = *(src_ptr + k___1);
#line 210
                    *(dest_ptr___2 + (k___1 + 1U) * buf_col_stride) = *(src_ptr + (k___1 + 1U));
#line 211
                    *(dest_ptr___2 + (k___1 + 2U) * buf_col_stride) = *(src_ptr + (k___1 + 2U));
#line 212
                    *(dest_ptr___2 + (k___1 + 3U) * buf_col_stride) = *(src_ptr + (k___1 + 3U));
#line 208
                    k___1 += 4U;
                  }
                  while_break___33: /* CIL Label */ ;
                  }
                  while_break___10: ;
                  {
#line 214
                  while (1) {
                    while_continue___11: /* CIL Label */ ;

#line 214
                    if (! (k___1 < x_incr)) {
#line 214
                      goto while_break___11;
                    }
#line 215
                    *(dest_ptr___2 + k___1 * buf_col_stride) = *(src_ptr + k___1);
#line 214
                    k___1 ++;
                  }
                  while_break___34: /* CIL Label */ ;
                  }
                  while_break___11: 
#line 217
                  dest_ptr___2 += buf_line_stride;
#line 218
                  src_ptr += block_width;
#line 206
                  j ++;
                }
                while_break___32: /* CIL Label */ ;
                }
                while_break___9: ;
              } else {
#line 205
                goto _L;
              }
            } else {
              _L: 
#line 222
              j = (OPJ_UINT32 )0;
              {
#line 222
              while (1) {
                while_continue___12: /* CIL Label */ ;

#line 222
                if (! (j < y_incr)) {
#line 222
                  goto while_break___12;
                }
#line 224
                k___2 = (OPJ_UINT32 )0;
                {
#line 224
                while (1) {
                  while_continue___13: /* CIL Label */ ;

#line 224
                  if (! (k___2 < x_incr)) {
#line 224
                    goto while_break___13;
                  }
#line 225
                  *(dest_ptr___2 + k___2 * buf_col_stride) = *(src_ptr + k___2);
#line 224
                  k___2 ++;
                }
                while_break___36: /* CIL Label */ ;
                }
                while_break___13: 
#line 227
                dest_ptr___2 += buf_line_stride;
#line 228
                src_ptr += block_width;
#line 222
                j ++;
              }
              while_break___35: /* CIL Label */ ;
              }
              while_break___12: ;
            }
          }
        }
      } else {
#line 234
        if ((unsigned long )src_block == (unsigned long )((void *)0)) {
          {
#line 235
          tmp___1 = opj_calloc((size_t )1, (unsigned long )(sa->block_width * sa->block_height) * sizeof(OPJ_INT32 ));
#line 235
          src_block = (OPJ_INT32 *)tmp___1;
          }
#line 237
          if ((unsigned long )src_block == (unsigned long )((void *)0)) {
#line 238
            return (0);
          }
#line 240
          *(sa->data_blocks + (block_y * sa->block_count_hor + block_x)) = src_block;
        }
#line 243
        if (buf_col_stride == 1U) {
#line 244
          dest_ptr___3 = (src_block + (unsigned long )block_y_offset * (OPJ_SIZE_T )block_width) + block_x_offset;
#line 246
          src_ptr___0 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 248
          if (x_incr == 4U) {
#line 251
            j = (OPJ_UINT32 )0;
            {
#line 251
            while (1) {
              while_continue___14: /* CIL Label */ ;

#line 251
              if (! (j < y_incr)) {
#line 251
                goto while_break___14;
              }
              {
#line 252
              memcpy((void *)dest_ptr___3, (void const   *)src_ptr___0, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 253
              dest_ptr___3 += block_width;
#line 254
              src_ptr___0 += buf_line_stride;
#line 251
              j ++;
              }
            }
            while_break___37: /* CIL Label */ ;
            }
            while_break___14: ;
          } else {
#line 257
            j = (OPJ_UINT32 )0;
            {
#line 257
            while (1) {
              while_continue___15: /* CIL Label */ ;

#line 257
              if (! (j < y_incr)) {
#line 257
                goto while_break___15;
              }
              {
#line 258
              memcpy((void *)dest_ptr___3, (void const   *)src_ptr___0, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 259
              dest_ptr___3 += block_width;
#line 260
              src_ptr___0 += buf_line_stride;
#line 257
              j ++;
              }
            }
            while_break___38: /* CIL Label */ ;
            }
            while_break___15: ;
          }
        } else {
#line 264
          dest_ptr___4 = (src_block + (unsigned long )block_y_offset * (OPJ_SIZE_T )block_width) + block_x_offset;
#line 266
          src_ptr___1 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 268
          if (x_incr == 1U) {
#line 269
            j = (OPJ_UINT32 )0;
            {
#line 269
            while (1) {
              while_continue___16: /* CIL Label */ ;

#line 269
              if (! (j < y_incr)) {
#line 269
                goto while_break___16;
              }
#line 270
              *dest_ptr___4 = *src_ptr___1;
#line 271
              src_ptr___1 += buf_line_stride;
#line 272
              dest_ptr___4 += block_width;
#line 269
              j ++;
            }
            while_break___39: /* CIL Label */ ;
            }
            while_break___16: ;
          } else
#line 274
          if (x_incr >= 8U) {
#line 274
            if (buf_col_stride == 8U) {
#line 275
              j = (OPJ_UINT32 )0;
              {
#line 275
              while (1) {
                while_continue___17: /* CIL Label */ ;

#line 275
                if (! (j < y_incr)) {
#line 275
                  goto while_break___17;
                }
#line 277
                k___3 = (OPJ_UINT32 )0;
                {
#line 277
                while (1) {
                  while_continue___18: /* CIL Label */ ;

#line 277
                  if (! (k___3 < (x_incr & 4294967292U))) {
#line 277
                    goto while_break___18;
                  }
#line 278
                  *(dest_ptr___4 + k___3) = *(src_ptr___1 + k___3 * buf_col_stride);
#line 279
                  *(dest_ptr___4 + (k___3 + 1U)) = *(src_ptr___1 + (k___3 + 1U) * buf_col_stride);
#line 280
                  *(dest_ptr___4 + (k___3 + 2U)) = *(src_ptr___1 + (k___3 + 2U) * buf_col_stride);
#line 281
                  *(dest_ptr___4 + (k___3 + 3U)) = *(src_ptr___1 + (k___3 + 3U) * buf_col_stride);
#line 277
                  k___3 += 4U;
                }
                while_break___41: /* CIL Label */ ;
                }
                while_break___18: ;
                {
#line 283
                while (1) {
                  while_continue___19: /* CIL Label */ ;

#line 283
                  if (! (k___3 < x_incr)) {
#line 283
                    goto while_break___19;
                  }
#line 284
                  *(dest_ptr___4 + k___3) = *(src_ptr___1 + k___3 * buf_col_stride);
#line 283
                  k___3 ++;
                }
                while_break___42: /* CIL Label */ ;
                }
                while_break___19: 
#line 286
                src_ptr___1 += buf_line_stride;
#line 287
                dest_ptr___4 += block_width;
#line 275
                j ++;
              }
              while_break___40: /* CIL Label */ ;
              }
              while_break___17: ;
            } else {
#line 274
              goto _L___7;
            }
          } else {
            _L___7: 
#line 291
            j = (OPJ_UINT32 )0;
            {
#line 291
            while (1) {
              while_continue___20: /* CIL Label */ ;

#line 291
              if (! (j < y_incr)) {
#line 291
                goto while_break___20;
              }
#line 293
              k___4 = (OPJ_UINT32 )0;
              {
#line 293
              while (1) {
                while_continue___21: /* CIL Label */ ;

#line 293
                if (! (k___4 < x_incr)) {
#line 293
                  goto while_break___21;
                }
#line 294
                *(dest_ptr___4 + k___4) = *(src_ptr___1 + k___4 * buf_col_stride);
#line 293
                k___4 ++;
              }
              while_break___44: /* CIL Label */ ;
              }
              while_break___21: 
#line 296
              src_ptr___1 += buf_line_stride;
#line 297
              dest_ptr___4 += block_width;
#line 291
              j ++;
            }
            while_break___43: /* CIL Label */ ;
            }
            while_break___20: ;
          }
        }
      }
#line 134
      x += x_incr;
#line 134
      __cil_tmp61 = block_x;
#line 134
      block_x ++;
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break___0: 
#line 125
    y += y_incr;
#line 125
    __cil_tmp62 = block_y;
#line 125
    block_y ++;
  }
  while_break___22: /* CIL Label */ ;
  }
  while_break: ;
#line 305
  return (1);
}
}
#line 308 "/root/patron/new_24/src/lib/openjp2/sparse_array.c"
OPJ_BOOL opj_sparse_array_int32_read(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                     OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                     OPJ_INT32 *dest , OPJ_UINT32 dest_col_stride ,
                                     OPJ_UINT32 dest_line_stride , OPJ_BOOL forgiving ) 
{ 
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 318
  __cil_tmp10 = opj_sparse_array_int32_read_or_write(sa, x0, y0___0, x1, y1___0, dest,
                                                     dest_col_stride, dest_line_stride,
                                                     forgiving, 1);
  }
#line 318
  return (__cil_tmp10);
}
}
#line 327 "/root/patron/new_24/src/lib/openjp2/sparse_array.c"
OPJ_BOOL opj_sparse_array_int32_write(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                      OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                      OPJ_INT32 *src , OPJ_UINT32 src_col_stride ,
                                      OPJ_UINT32 src_line_stride , OPJ_BOOL forgiving ) 
{ 
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 337
  __cil_tmp10 = opj_sparse_array_int32_read_or_write(sa, x0, y0___0, x1, y1___0, src,
                                                     src_col_stride, src_line_stride,
                                                     forgiving, 0);
  }
#line 337
  return (__cil_tmp10);
}
}
#line 52 "/root/patron/new_24/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t *pi ) ;
#line 58
static OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t *pi ) ;
#line 64
static OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t *pi ) ;
#line 70
static OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t *pi ) ;
#line 76
static OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t *pi ) ;
#line 92
static void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp , OPJ_UINT32 p_tileno ,
                                               OPJ_INT32 p_tx0 , OPJ_INT32 p_tx1 ,
                                               OPJ_INT32 p_ty0 , OPJ_INT32 p_ty1 ,
                                               OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                               OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) ;
#line 118
static void opj_pi_update_encode_not_poc(opj_cp_t *p_cp , OPJ_UINT32 p_num_comps ,
                                         OPJ_UINT32 p_tileno , OPJ_INT32 p_tx0 , OPJ_INT32 p_tx1 ,
                                         OPJ_INT32 p_ty0 , OPJ_INT32 p_ty1 , OPJ_UINT32 p_max_prec ,
                                         OPJ_UINT32 p_max_res , OPJ_UINT32 p_dx_min ,
                                         OPJ_UINT32 p_dy_min ) ;
#line 144
static void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tileno ,
                                        OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                        OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min ,
                                        OPJ_UINT32 *p_dy_min , OPJ_UINT32 *p_max_prec ,
                                        OPJ_UINT32 *p_max_res ) ;
#line 176
static void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp ,
                                            OPJ_UINT32 tileno , OPJ_INT32 *p_tx0 ,
                                            OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                            OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min ,
                                            OPJ_UINT32 *p_dy_min , OPJ_UINT32 *p_max_prec ,
                                            OPJ_UINT32 *p_max_res , OPJ_UINT32 **p_resolutions ) ;
#line 196
static opj_pi_iterator_t *opj_pi_create(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ) ;
#line 202
static void opj_pi_update_decode_not_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp ,
                                         OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) ;
#line 209
static void opj_pi_update_decode_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp ,
                                     OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) ;
#line 217
static OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                        OPJ_UINT32 pino , OPJ_CHAR *prog ) ;
#line 233 "/root/patron/new_24/src/lib/openjp2/pi.c"
static void opj_pi_emit_error(opj_pi_iterator_t *pi , char const   *msg ) 
{ 


  {
#line 238
  return;
}
}
#line 239 "/root/patron/new_24/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___0 ;

  {
#line 241
  comp = (opj_pi_comp_t *)((void *)0);
#line 242
  res = (opj_pi_resolution_t *)((void *)0);
#line 243
  index___0 = (OPJ_UINT32 )0;
#line 245
  if (! pi->first) {
#line 246
    comp = pi->comps + pi->compno;
#line 247
    res = comp->resolutions + pi->resno;
#line 248
    goto LABEL_SKIP;
  } else {
#line 250
    pi->first = 0;
  }
#line 253
  pi->layno = pi->poc.layno0;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;

#line 253
    if (! (pi->layno < pi->poc.layno1)) {
#line 253
      goto while_break;
    }
#line 254
    pi->resno = pi->poc.resno0;
    {
#line 254
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 254
      if (! (pi->resno < pi->poc.resno1)) {
#line 254
        goto while_break___0;
      }
#line 256
      pi->compno = pi->poc.compno0;
      {
#line 256
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 256
        if (! (pi->compno < pi->poc.compno1)) {
#line 256
          goto while_break___1;
        }
#line 257
        comp = pi->comps + pi->compno;
#line 258
        if (pi->resno >= comp->numresolutions) {
#line 259
          goto while_continue___1;
        }
#line 261
        res = comp->resolutions + pi->resno;
#line 262
        if (! pi->tp_on) {
#line 263
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 265
        pi->precno = pi->poc.precno0;
        {
#line 265
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 265
          if (! (pi->precno < pi->poc.precno1)) {
#line 265
            goto while_break___2;
          }
#line 266
          index___0 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 274
          if (index___0 >= pi->include_size) {
            {
#line 275
            opj_pi_emit_error(pi, "Invalid access to pi->include");
            }
#line 276
            return (0);
          }
#line 278
          if (! *(pi->include + index___0)) {
#line 279
            *(pi->include + index___0) = (OPJ_INT16 )1;
#line 280
            return (1);
          }
          LABEL_SKIP: 
#line 265
          (pi->precno) ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 256
        (pi->compno) ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 255
      (pi->resno) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 253
    (pi->layno) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 289
  return (0);
}
}
#line 292 "/root/patron/new_24/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___0 ;

  {
#line 294
  comp = (opj_pi_comp_t *)((void *)0);
#line 295
  res = (opj_pi_resolution_t *)((void *)0);
#line 296
  index___0 = (OPJ_UINT32 )0;
#line 298
  if (! pi->first) {
#line 299
    comp = pi->comps + pi->compno;
#line 300
    res = comp->resolutions + pi->resno;
#line 301
    goto LABEL_SKIP;
  } else {
#line 303
    pi->first = 0;
  }
#line 306
  pi->resno = pi->poc.resno0;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;

#line 306
    if (! (pi->resno < pi->poc.resno1)) {
#line 306
      goto while_break;
    }
#line 307
    pi->layno = pi->poc.layno0;
    {
#line 307
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 307
      if (! (pi->layno < pi->poc.layno1)) {
#line 307
        goto while_break___0;
      }
#line 308
      pi->compno = pi->poc.compno0;
      {
#line 308
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 308
        if (! (pi->compno < pi->poc.compno1)) {
#line 308
          goto while_break___1;
        }
#line 309
        comp = pi->comps + pi->compno;
#line 310
        if (pi->resno >= comp->numresolutions) {
#line 311
          goto while_continue___1;
        }
#line 313
        res = comp->resolutions + pi->resno;
#line 314
        if (! pi->tp_on) {
#line 315
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 317
        pi->precno = pi->poc.precno0;
        {
#line 317
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 317
          if (! (pi->precno < pi->poc.precno1)) {
#line 317
            goto while_break___2;
          }
#line 318
          index___0 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 320
          if (index___0 >= pi->include_size) {
            {
#line 321
            opj_pi_emit_error(pi, "Invalid access to pi->includeV");
            }
#line 322
            return (0);
          }
#line 324
          if (! *(pi->include + index___0)) {
#line 325
            *(pi->include + index___0) = (OPJ_INT16 )1;
#line 326
            return (1);
          }
          LABEL_SKIP: 
#line 317
          (pi->precno) ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 308
        (pi->compno) ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 307
      (pi->layno) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 306
    (pi->resno) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 335
  return (0);
}
}
#line 338 "/root/patron/new_24/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_INT32 __cil_tmp33 ;

  {
#line 340
  comp = (opj_pi_comp_t *)((void *)0);
#line 341
  res = (opj_pi_resolution_t *)((void *)0);
#line 342
  index___0 = (OPJ_UINT32 )0;
#line 344
  if (! pi->first) {
#line 345
    goto LABEL_SKIP;
  } else {
#line 348
    pi->first = 0;
#line 349
    pi->dx = (OPJ_UINT32 )0;
#line 350
    pi->dy = (OPJ_UINT32 )0;
#line 351
    compno = (OPJ_UINT32 )0;
    {
#line 351
    while (1) {
      while_continue: /* CIL Label */ ;

#line 351
      if (! (compno < pi->numcomps)) {
#line 351
        goto while_break;
      }
#line 352
      comp = pi->comps + compno;
#line 353
      resno = (OPJ_UINT32 )0;
      {
#line 353
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 353
        if (! (resno < comp->numresolutions)) {
#line 353
          goto while_break___0;
        }
#line 355
        res = comp->resolutions + resno;
#line 356
        if (((res->pdx + comp->numresolutions) - 1U) - resno < 32U) {
#line 356
          if (comp->dx <= 4294967295U / (1U << (((res->pdx + comp->numresolutions) - 1U) - resno))) {
#line 358
            dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 359
            if (! pi->dx) {
#line 359
              tmp = dx;
            } else {
              {
#line 359
              __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 359
              tmp = __cil_tmp9;
              }
            }
#line 359
            pi->dx = tmp;
          }
        }
#line 361
        if (((res->pdy + comp->numresolutions) - 1U) - resno < 32U) {
#line 361
          if (comp->dy <= 4294967295U / (1U << (((res->pdy + comp->numresolutions) - 1U) - resno))) {
#line 363
            dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 364
            if (! pi->dy) {
#line 364
              tmp___0 = dy;
            } else {
              {
#line 364
              __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 364
              tmp___0 = __cil_tmp11;
              }
            }
#line 364
            pi->dy = tmp___0;
          }
        }
#line 353
        resno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: 
#line 351
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: ;
#line 368
    if (pi->dx == 0U) {
#line 369
      return (0);
    } else
#line 368
    if (pi->dy == 0U) {
#line 369
      return (0);
    }
  }
#line 372
  if (! pi->tp_on) {
#line 373
    pi->poc.ty0 = pi->ty0;
#line 374
    pi->poc.tx0 = pi->tx0;
#line 375
    pi->poc.ty1 = pi->ty1;
#line 376
    pi->poc.tx1 = pi->tx1;
  }
#line 378
  pi->resno = pi->poc.resno0;
  {
#line 378
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 378
    if (! (pi->resno < pi->poc.resno1)) {
#line 378
      goto while_break___1;
    }
#line 379
    pi->y = pi->poc.ty0;
    {
#line 379
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 379
      if (! (pi->y < pi->poc.ty1)) {
#line 379
        goto while_break___2;
      }
#line 381
      pi->x = pi->poc.tx0;
      {
#line 381
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 381
        if (! (pi->x < pi->poc.tx1)) {
#line 381
          goto while_break___3;
        }
#line 383
        pi->compno = pi->poc.compno0;
        {
#line 383
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___4: ;
#line 383
          if (! (pi->compno < pi->poc.compno1)) {
#line 383
            goto while_break___4;
          }
#line 389
          comp = pi->comps + pi->compno;
#line 390
          if (pi->resno >= comp->numresolutions) {
#line 391
            goto while_continue___4;
          }
#line 393
          res = comp->resolutions + pi->resno;
#line 394
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 398
          if (levelno >= 32U) {
#line 401
            goto while_continue___4;
          } else
#line 398
          if ((comp->dx << levelno) >> levelno != comp->dx) {
#line 401
            goto while_continue___4;
          } else
#line 398
          if ((comp->dy << levelno) >> levelno != comp->dy) {
#line 401
            goto while_continue___4;
          }
#line 403
          if (comp->dx << levelno > 2147483647U) {
#line 405
            goto while_continue___4;
          } else
#line 403
          if (comp->dy << levelno > 2147483647U) {
#line 405
            goto while_continue___4;
          }
          {
#line 407
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 408
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 409
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 410
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 411
          rpx = res->pdx + levelno;
#line 412
          rpy = res->pdy + levelno;
          }
#line 418
          if (rpx >= 31U) {
#line 420
            goto while_continue___4;
          } else
#line 418
          if ((comp->dx << rpx) >> rpx != comp->dx) {
#line 420
            goto while_continue___4;
          } else
#line 418
          if (rpy >= 31U) {
#line 420
            goto while_continue___4;
          } else
#line 418
          if ((comp->dy << rpy) >> rpy != comp->dy) {
#line 420
            goto while_continue___4;
          }
#line 424
          if (! (pi->y % (OPJ_INT32 )(comp->dy << rpy) == 0)) {
#line 424
            if (pi->y == pi->ty0) {
#line 424
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 426
                goto while_continue___4;
              }
            } else {
#line 426
              goto while_continue___4;
            }
          }
#line 428
          if (! (pi->x % (OPJ_INT32 )(comp->dx << rpx) == 0)) {
#line 428
            if (pi->x == pi->tx0) {
#line 428
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 430
                goto while_continue___4;
              }
            } else {
#line 430
              goto while_continue___4;
            }
          }
#line 433
          if (res->pw == 0U) {
#line 434
            goto while_continue___4;
          } else
#line 433
          if (res->ph == 0U) {
#line 434
            goto while_continue___4;
          }
#line 437
          if (trx0 == trx1) {
#line 438
            goto while_continue___4;
          } else
#line 437
          if (try0 == try1) {
#line 438
            goto while_continue___4;
          }
          {
#line 441
          __cil_tmp30 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
#line 441
          __cil_tmp28 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 441
          __cil_tmp29 = opj_int_floordivpow2(__cil_tmp28, (OPJ_INT32 )res->pdx);
#line 441
          prci = __cil_tmp29 - __cil_tmp30;
#line 444
          __cil_tmp33 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
#line 444
          __cil_tmp31 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 444
          __cil_tmp32 = opj_int_floordivpow2(__cil_tmp31, (OPJ_INT32 )res->pdy);
#line 444
          prcj = __cil_tmp32 - __cil_tmp33;
#line 447
          pi->precno = (OPJ_UINT32 )(prci + prcj * (OPJ_INT32 )res->pw);
#line 448
          pi->layno = pi->poc.layno0;
          }
          {
#line 448
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 448
            if (! (pi->layno < pi->poc.layno1)) {
#line 448
              goto while_break___5;
            }
#line 449
            index___0 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 451
            if (index___0 >= pi->include_size) {
              {
#line 452
              opj_pi_emit_error(pi, "Invalid access to pi->include");
              }
#line 453
              return (0);
            }
#line 455
            if (! *(pi->include + index___0)) {
#line 456
              *(pi->include + index___0) = (OPJ_INT16 )1;
#line 457
              return (1);
            }
            LABEL_SKIP: 
#line 448
            (pi->layno) ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___5: 
#line 383
          (pi->compno) ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___4: 
#line 382
        pi->x += (OPJ_INT32 )(pi->dx - (OPJ_UINT32 )(pi->x % (OPJ_INT32 )pi->dx));
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: 
#line 380
      pi->y += (OPJ_INT32 )(pi->dy - (OPJ_UINT32 )(pi->y % (OPJ_INT32 )pi->dy));
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: 
#line 378
    (pi->resno) ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: ;
#line 467
  return (0);
}
}
#line 470 "/root/patron/new_24/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_INT32 __cil_tmp33 ;
  OPJ_INT32 __cil_tmp34 ;

  {
#line 472
  comp = (opj_pi_comp_t *)((void *)0);
#line 473
  res = (opj_pi_resolution_t *)((void *)0);
#line 474
  index___0 = (OPJ_UINT32 )0;
#line 476
  if (! pi->first) {
#line 477
    comp = pi->comps + pi->compno;
#line 478
    goto LABEL_SKIP;
  } else {
#line 481
    pi->first = 0;
#line 482
    pi->dx = (OPJ_UINT32 )0;
#line 483
    pi->dy = (OPJ_UINT32 )0;
#line 484
    compno = (OPJ_UINT32 )0;
    {
#line 484
    while (1) {
      while_continue: /* CIL Label */ ;

#line 484
      if (! (compno < pi->numcomps)) {
#line 484
        goto while_break;
      }
#line 485
      comp = pi->comps + compno;
#line 486
      resno = (OPJ_UINT32 )0;
      {
#line 486
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 486
        if (! (resno < comp->numresolutions)) {
#line 486
          goto while_break___0;
        }
#line 488
        res = comp->resolutions + resno;
#line 489
        if (((res->pdx + comp->numresolutions) - 1U) - resno < 32U) {
#line 489
          if (comp->dx <= 4294967295U / (1U << (((res->pdx + comp->numresolutions) - 1U) - resno))) {
#line 491
            dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 492
            if (! pi->dx) {
#line 492
              tmp = dx;
            } else {
              {
#line 492
              __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 492
              tmp = __cil_tmp9;
              }
            }
#line 492
            pi->dx = tmp;
          }
        }
#line 494
        if (((res->pdy + comp->numresolutions) - 1U) - resno < 32U) {
#line 494
          if (comp->dy <= 4294967295U / (1U << (((res->pdy + comp->numresolutions) - 1U) - resno))) {
#line 496
            dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 497
            if (! pi->dy) {
#line 497
              tmp___0 = dy;
            } else {
              {
#line 497
              __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 497
              tmp___0 = __cil_tmp11;
              }
            }
#line 497
            pi->dy = tmp___0;
          }
        }
#line 486
        resno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: 
#line 484
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: ;
#line 501
    if (pi->dx == 0U) {
#line 502
      return (0);
    } else
#line 501
    if (pi->dy == 0U) {
#line 502
      return (0);
    }
  }
#line 505
  if (! pi->tp_on) {
#line 506
    pi->poc.ty0 = pi->ty0;
#line 507
    pi->poc.tx0 = pi->tx0;
#line 508
    pi->poc.ty1 = pi->ty1;
#line 509
    pi->poc.tx1 = pi->tx1;
  }
#line 511
  pi->y = pi->poc.ty0;
  {
#line 511
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 511
    if (! (pi->y < pi->poc.ty1)) {
#line 511
      goto while_break___1;
    }
#line 513
    pi->x = pi->poc.tx0;
    {
#line 513
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 513
      if (! (pi->x < pi->poc.tx1)) {
#line 513
        goto while_break___2;
      }
#line 515
      pi->compno = pi->poc.compno0;
      {
#line 515
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 515
        if (! (pi->compno < pi->poc.compno1)) {
#line 515
          goto while_break___3;
        }
#line 516
        comp = pi->comps + pi->compno;
#line 517
        pi->resno = pi->poc.resno0;
        {
#line 517
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___4: ;
#line 517
          if (! (pi->resno < __cil_tmp15)) {
#line 517
            goto while_break___4;
          }
#line 524
          res = comp->resolutions + pi->resno;
#line 525
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 529
          if (levelno >= 32U) {
#line 532
            goto while_continue___4;
          } else
#line 529
          if ((comp->dx << levelno) >> levelno != comp->dx) {
#line 532
            goto while_continue___4;
          } else
#line 529
          if ((comp->dy << levelno) >> levelno != comp->dy) {
#line 532
            goto while_continue___4;
          }
#line 534
          if (comp->dx << levelno > 2147483647U) {
#line 536
            goto while_continue___4;
          } else
#line 534
          if (comp->dy << levelno > 2147483647U) {
#line 536
            goto while_continue___4;
          }
          {
#line 538
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 539
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 540
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 541
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 542
          rpx = res->pdx + levelno;
#line 543
          rpy = res->pdy + levelno;
          }
#line 549
          if (rpx >= 31U) {
#line 551
            goto while_continue___4;
          } else
#line 549
          if ((comp->dx << rpx) >> rpx != comp->dx) {
#line 551
            goto while_continue___4;
          } else
#line 549
          if (rpy >= 31U) {
#line 551
            goto while_continue___4;
          } else
#line 549
          if ((comp->dy << rpy) >> rpy != comp->dy) {
#line 551
            goto while_continue___4;
          }
#line 555
          if (! (pi->y % (OPJ_INT32 )(comp->dy << rpy) == 0)) {
#line 555
            if (pi->y == pi->ty0) {
#line 555
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 557
                goto while_continue___4;
              }
            } else {
#line 557
              goto while_continue___4;
            }
          }
#line 559
          if (! (pi->x % (OPJ_INT32 )(comp->dx << rpx) == 0)) {
#line 559
            if (pi->x == pi->tx0) {
#line 559
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 561
                goto while_continue___4;
              }
            } else {
#line 561
              goto while_continue___4;
            }
          }
#line 564
          if (res->pw == 0U) {
#line 565
            goto while_continue___4;
          } else
#line 564
          if (res->ph == 0U) {
#line 565
            goto while_continue___4;
          }
#line 568
          if (trx0 == trx1) {
#line 569
            goto while_continue___4;
          } else
#line 568
          if (try0 == try1) {
#line 569
            goto while_continue___4;
          }
          {
#line 572
          __cil_tmp31 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
#line 572
          __cil_tmp29 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 572
          __cil_tmp30 = opj_int_floordivpow2(__cil_tmp29, (OPJ_INT32 )res->pdx);
#line 572
          prci = __cil_tmp30 - __cil_tmp31;
#line 575
          __cil_tmp34 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
#line 575
          __cil_tmp32 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 575
          __cil_tmp33 = opj_int_floordivpow2(__cil_tmp32, (OPJ_INT32 )res->pdy);
#line 575
          prcj = __cil_tmp33 - __cil_tmp34;
#line 578
          pi->precno = (OPJ_UINT32 )(prci + prcj * (OPJ_INT32 )res->pw);
#line 579
          pi->layno = pi->poc.layno0;
          }
          {
#line 579
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 579
            if (! (pi->layno < pi->poc.layno1)) {
#line 579
              goto while_break___5;
            }
#line 580
            index___0 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 582
            if (index___0 >= pi->include_size) {
              {
#line 583
              opj_pi_emit_error(pi, "Invalid access to pi->includeV");
              }
#line 584
              return (0);
            }
#line 586
            if (! *(pi->include + index___0)) {
#line 587
              *(pi->include + index___0) = (OPJ_INT16 )1;
#line 588
              return (1);
            }
            LABEL_SKIP: 
#line 579
            (pi->layno) ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___5: 
#line 518
          (pi->resno) ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___4: 
#line 515
        (pi->compno) ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: 
#line 514
      pi->x += (OPJ_INT32 )(pi->dx - (OPJ_UINT32 )(pi->x % (OPJ_INT32 )pi->dx));
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: 
#line 512
    pi->y += (OPJ_INT32 )(pi->dy - (OPJ_UINT32 )(pi->y % (OPJ_INT32 )pi->dy));
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: ;
#line 598
  return (0);
}
}
#line 601 "/root/patron/new_24/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;

  {
#line 603
  comp = (opj_pi_comp_t *)((void *)0);
#line 604
  res = (opj_pi_resolution_t *)((void *)0);
#line 605
  index___0 = (OPJ_UINT32 )0;
#line 607
  if (! pi->first) {
#line 608
    comp = pi->comps + pi->compno;
#line 609
    goto LABEL_SKIP;
  } else {
#line 611
    pi->first = 0;
  }
#line 614
  pi->compno = pi->poc.compno0;
  {
#line 614
  while (1) {
    while_continue: /* CIL Label */ ;

#line 614
    if (! (pi->compno < pi->poc.compno1)) {
#line 614
      goto while_break;
    }
#line 616
    comp = pi->comps + pi->compno;
#line 617
    pi->dx = (OPJ_UINT32 )0;
#line 618
    pi->dy = (OPJ_UINT32 )0;
#line 619
    resno = (OPJ_UINT32 )0;
    {
#line 619
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 619
      if (! (resno < comp->numresolutions)) {
#line 619
        goto while_break___0;
      }
#line 621
      res = comp->resolutions + resno;
#line 622
      if (((res->pdx + comp->numresolutions) - 1U) - resno < 32U) {
#line 622
        if (comp->dx <= 4294967295U / (1U << (((res->pdx + comp->numresolutions) - 1U) - resno))) {
#line 624
          dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 625
          if (! pi->dx) {
#line 625
            tmp = dx;
          } else {
            {
#line 625
            __cil_tmp8 = opj_uint_min(pi->dx, dx);
#line 625
            tmp = __cil_tmp8;
            }
          }
#line 625
          pi->dx = tmp;
        }
      }
#line 627
      if (((res->pdy + comp->numresolutions) - 1U) - resno < 32U) {
#line 627
        if (comp->dy <= 4294967295U / (1U << (((res->pdy + comp->numresolutions) - 1U) - resno))) {
#line 629
          dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 630
          if (! pi->dy) {
#line 630
            tmp___0 = dy;
          } else {
            {
#line 630
            __cil_tmp10 = opj_uint_min(pi->dy, dy);
#line 630
            tmp___0 = __cil_tmp10;
            }
          }
#line 630
          pi->dy = tmp___0;
        }
      }
#line 619
      resno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: ;
#line 633
    if (pi->dx == 0U) {
#line 634
      return (0);
    } else
#line 633
    if (pi->dy == 0U) {
#line 634
      return (0);
    }
#line 636
    if (! pi->tp_on) {
#line 637
      pi->poc.ty0 = pi->ty0;
#line 638
      pi->poc.tx0 = pi->tx0;
#line 639
      pi->poc.ty1 = pi->ty1;
#line 640
      pi->poc.tx1 = pi->tx1;
    }
#line 642
    pi->y = pi->poc.ty0;
    {
#line 642
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 642
      if (! (pi->y < pi->poc.ty1)) {
#line 642
        goto while_break___1;
      }
#line 644
      pi->x = pi->poc.tx0;
      {
#line 644
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 644
        if (! (pi->x < pi->poc.tx1)) {
#line 644
          goto while_break___2;
        }
#line 646
        pi->resno = pi->poc.resno0;
        {
#line 646
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___3: ;
#line 646
          if (! (pi->resno < __cil_tmp13)) {
#line 646
            goto while_break___3;
          }
#line 653
          res = comp->resolutions + pi->resno;
#line 654
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 657
          if (levelno >= 32U) {
#line 660
            goto while_continue___3;
          } else
#line 657
          if ((comp->dx << levelno) >> levelno != comp->dx) {
#line 660
            goto while_continue___3;
          } else
#line 657
          if ((comp->dy << levelno) >> levelno != comp->dy) {
#line 660
            goto while_continue___3;
          }
#line 662
          if (comp->dx << levelno > 2147483647U) {
#line 664
            goto while_continue___3;
          } else
#line 662
          if (comp->dy << levelno > 2147483647U) {
#line 664
            goto while_continue___3;
          }
          {
#line 666
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 667
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 668
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 669
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 670
          rpx = res->pdx + levelno;
#line 671
          rpy = res->pdy + levelno;
          }
#line 677
          if (rpx >= 31U) {
#line 679
            goto while_continue___3;
          } else
#line 677
          if ((comp->dx << rpx) >> rpx != comp->dx) {
#line 679
            goto while_continue___3;
          } else
#line 677
          if (rpy >= 31U) {
#line 679
            goto while_continue___3;
          } else
#line 677
          if ((comp->dy << rpy) >> rpy != comp->dy) {
#line 679
            goto while_continue___3;
          }
#line 683
          if (! (pi->y % (OPJ_INT32 )(comp->dy << rpy) == 0)) {
#line 683
            if (pi->y == pi->ty0) {
#line 683
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 685
                goto while_continue___3;
              }
            } else {
#line 685
              goto while_continue___3;
            }
          }
#line 687
          if (! (pi->x % (OPJ_INT32 )(comp->dx << rpx) == 0)) {
#line 687
            if (pi->x == pi->tx0) {
#line 687
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 689
                goto while_continue___3;
              }
            } else {
#line 689
              goto while_continue___3;
            }
          }
#line 692
          if (res->pw == 0U) {
#line 693
            goto while_continue___3;
          } else
#line 692
          if (res->ph == 0U) {
#line 693
            goto while_continue___3;
          }
#line 696
          if (trx0 == trx1) {
#line 697
            goto while_continue___3;
          } else
#line 696
          if (try0 == try1) {
#line 697
            goto while_continue___3;
          }
          {
#line 700
          __cil_tmp29 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
#line 700
          __cil_tmp27 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 700
          __cil_tmp28 = opj_int_floordivpow2(__cil_tmp27, (OPJ_INT32 )res->pdx);
#line 700
          prci = __cil_tmp28 - __cil_tmp29;
#line 703
          __cil_tmp32 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
#line 703
          __cil_tmp30 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 703
          __cil_tmp31 = opj_int_floordivpow2(__cil_tmp30, (OPJ_INT32 )res->pdy);
#line 703
          prcj = __cil_tmp31 - __cil_tmp32;
#line 706
          pi->precno = (OPJ_UINT32 )(prci + prcj * (OPJ_INT32 )res->pw);
#line 707
          pi->layno = pi->poc.layno0;
          }
          {
#line 707
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 707
            if (! (pi->layno < pi->poc.layno1)) {
#line 707
              goto while_break___4;
            }
#line 708
            index___0 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 710
            if (index___0 >= pi->include_size) {
              {
#line 711
              opj_pi_emit_error(pi, "Invalid access to pi->includeV");
              }
#line 712
              return (0);
            }
#line 714
            if (! *(pi->include + index___0)) {
#line 715
              *(pi->include + index___0) = (OPJ_INT16 )1;
#line 716
              return (1);
            }
            LABEL_SKIP: 
#line 707
            (pi->layno) ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___4: 
#line 647
          (pi->resno) ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: 
#line 645
        pi->x += (OPJ_INT32 )(pi->dx - (OPJ_UINT32 )(pi->x % (OPJ_INT32 )pi->dx));
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
#line 643
      pi->y += (OPJ_INT32 )(pi->dy - (OPJ_UINT32 )(pi->y % (OPJ_INT32 )pi->dy));
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
#line 614
    (pi->compno) ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 726
  return (0);
}
}
#line 729 "/root/patron/new_24/src/lib/openjp2/pi.c"
static void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tileno ,
                                        OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                        OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min ,
                                        OPJ_UINT32 *p_dy_min , OPJ_UINT32 *p_max_prec ,
                                        OPJ_UINT32 *p_max_res ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_INT32 l_rx0 ;
  OPJ_INT32 l_ry0 ;
  OPJ_INT32 l_rx1 ;
  OPJ_INT32 l_ry1 ;
  OPJ_INT32 l_px0 ;
  OPJ_INT32 l_py0 ;
  OPJ_INT32 l_px1 ;
  OPJ_INT32 py1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_UINT32 l_product ;
  OPJ_INT32 l_tcx0 ;
  OPJ_INT32 l_tcy0 ;
  OPJ_INT32 l_tcx1 ;
  OPJ_INT32 l_tcy1 ;
  OPJ_UINT32 l_dx ;
  OPJ_UINT32 l_dy ;
  OPJ_INT32 __cil_tmp56 ;
  OPJ_INT32 __cil_tmp57 ;
  OPJ_INT32 __cil_tmp58 ;
  OPJ_INT32 __cil_tmp59 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 744
  l_tcp = (opj_tcp_t *)0;
#line 745
  l_tccp = (opj_tccp_t *)0;
#line 746
  l_img_comp = (opj_image_comp_t *)0;
#line 757
  l_tcp = p_cp->tcps + p_tileno;
#line 758
  l_img_comp = p_image->comps;
#line 759
  l_tccp = l_tcp->tccps;
#line 762
  p = p_tileno % p_cp->tw;
#line 763
  q = p_tileno / p_cp->tw;
#line 766
  *p_tx0 = opj_int_max((OPJ_INT32 )(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32 )p_image->x0);
#line 768
  *p_tx1 = opj_int_min((OPJ_INT32 )(p_cp->tx0 + (p + 1U) * p_cp->tdx), (OPJ_INT32 )p_image->x1);
#line 770
  *p_ty0 = opj_int_max((OPJ_INT32 )(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32 )p_image->y0);
#line 772
  *p_ty1 = opj_int_min((OPJ_INT32 )(p_cp->ty0 + (q + 1U) * p_cp->tdy), (OPJ_INT32 )p_image->y1);
#line 776
  *p_max_prec = (OPJ_UINT32 )0;
#line 777
  *p_max_res = (OPJ_UINT32 )0;
#line 780
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 781
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 783
  compno = (OPJ_UINT32 )0;
  }
  {
#line 783
  while (1) {
    while_continue: /* CIL Label */ ;

#line 783
    if (! (compno < p_image->numcomps)) {
#line 783
      goto while_break;
    }
    {
#line 793
    l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32 )l_img_comp->dx);
#line 794
    l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32 )l_img_comp->dy);
#line 795
    l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32 )l_img_comp->dx);
#line 796
    l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32 )l_img_comp->dy);
    }
#line 798
    if (l_tccp->numresolutions > *p_max_res) {
#line 799
      *p_max_res = l_tccp->numresolutions;
    }
#line 803
    resno = (OPJ_UINT32 )0;
    {
#line 803
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 803
      if (! (resno < l_tccp->numresolutions)) {
#line 803
        goto while_break___0;
      }
      {
#line 807
      l_pdx = l_tccp->prcw[resno];
#line 808
      l_pdy = l_tccp->prch[resno];
#line 810
      l_dx = l_img_comp->dx * (1U << (((l_pdx + l_tccp->numresolutions) - 1U) - resno));
#line 811
      l_dy = l_img_comp->dy * (1U << (((l_pdy + l_tccp->numresolutions) - 1U) - resno));
#line 814
      *p_dx_min = opj_uint_min(*p_dx_min, l_dx);
#line 815
      *p_dy_min = opj_uint_min(*p_dy_min, l_dy);
#line 818
      l_level_no = (l_tccp->numresolutions - 1U) - resno;
#line 820
      l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32 )l_level_no);
#line 821
      l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32 )l_level_no);
#line 822
      l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32 )l_level_no);
#line 823
      l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32 )l_level_no);
#line 825
      __cil_tmp56 = opj_int_floordivpow2(l_rx0, (OPJ_INT32 )l_pdx);
#line 825
      l_px0 = __cil_tmp56 << l_pdx;
#line 826
      __cil_tmp57 = opj_int_floordivpow2(l_ry0, (OPJ_INT32 )l_pdy);
#line 826
      l_py0 = __cil_tmp57 << l_pdy;
#line 827
      __cil_tmp58 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32 )l_pdx);
#line 827
      l_px1 = __cil_tmp58 << l_pdx;
#line 829
      __cil_tmp59 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32 )l_pdy);
#line 829
      py1 = __cil_tmp59 << l_pdy;
      }
#line 831
      if (l_rx0 == l_rx1) {
#line 831
        tmp___2 = 0U;
      } else {
#line 831
        tmp___2 = (OPJ_UINT32 )((l_px1 - l_px0) >> l_pdx);
      }
#line 831
      l_pw = tmp___2;
#line 832
      if (l_ry0 == l_ry1) {
#line 832
        tmp___3 = 0U;
      } else {
#line 832
        tmp___3 = (OPJ_UINT32 )((py1 - l_py0) >> l_pdy);
      }
#line 832
      l_ph = tmp___3;
#line 834
      l_product = l_pw * l_ph;
#line 837
      if (l_product > *p_max_prec) {
#line 838
        *p_max_prec = l_product;
      }
#line 803
      resno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 841
    l_img_comp ++;
#line 842
    l_tccp ++;
#line 783
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 787
  return;
}
}
#line 847 "/root/patron/new_24/src/lib/openjp2/pi.c"
static void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp ,
                                            OPJ_UINT32 tileno , OPJ_INT32 *p_tx0 ,
                                            OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                            OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min ,
                                            OPJ_UINT32 *p_dy_min , OPJ_UINT32 *p_max_prec ,
                                            OPJ_UINT32 *p_max_res , OPJ_UINT32 **p_resolutions ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t *tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 *lResolutionPtr ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 l_level_no ;
  OPJ_INT32 l_rx0 ;
  OPJ_INT32 l_ry0 ;
  OPJ_INT32 l_rx1 ;
  OPJ_INT32 l_ry1 ;
  OPJ_INT32 l_px0 ;
  OPJ_INT32 l_py0 ;
  OPJ_INT32 l_px1 ;
  OPJ_INT32 py1 ;
  OPJ_UINT32 l_product ;
  OPJ_INT32 l_tcx0 ;
  OPJ_INT32 l_tcy0 ;
  OPJ_INT32 l_tcx1 ;
  OPJ_INT32 l_tcy1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_UINT32 l_dx ;
  OPJ_UINT32 l_dy ;
  OPJ_UINT32 *__cil_tmp56 ;
  OPJ_UINT32 *__cil_tmp57 ;
  OPJ_INT32 __cil_tmp58 ;
  OPJ_INT32 __cil_tmp59 ;
  OPJ_INT32 __cil_tmp64 ;
  OPJ_INT32 __cil_tmp65 ;
  OPJ_INT32 __cil_tmp66 ;
  OPJ_INT32 __cil_tmp67 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  OPJ_UINT32 *__cil_tmp70 ;
  OPJ_UINT32 *__cil_tmp71 ;

  {
  {
#line 864
  tcp = (opj_tcp_t *)0;
#line 865
  l_tccp = (opj_tccp_t *)0;
#line 866
  l_img_comp = (opj_image_comp_t *)0;
#line 883
  tcp = p_cp->tcps + tileno;
#line 884
  l_tccp = tcp->tccps;
#line 885
  l_img_comp = p_image->comps;
#line 888
  p = tileno % p_cp->tw;
#line 889
  q = tileno / p_cp->tw;
#line 892
  l_tx0 = p_cp->tx0 + p * p_cp->tdx;
#line 894
  __cil_tmp26 = opj_uint_max(l_tx0, p_image->x0);
#line 894
  *p_tx0 = (OPJ_INT32 )__cil_tmp26;
#line 895
  __cil_tmp27 = opj_uint_adds(l_tx0, p_cp->tdx);
#line 895
  __cil_tmp28 = opj_uint_min(__cil_tmp27, p_image->x1);
#line 895
  *p_tx1 = (OPJ_INT32 )__cil_tmp28;
#line 896
  l_ty0 = p_cp->ty0 + q * p_cp->tdy;
#line 898
  __cil_tmp29 = opj_uint_max(l_ty0, p_image->y0);
#line 898
  *p_ty0 = (OPJ_INT32 )__cil_tmp29;
#line 899
  __cil_tmp30 = opj_uint_adds(l_ty0, p_cp->tdy);
#line 899
  __cil_tmp31 = opj_uint_min(__cil_tmp30, p_image->y1);
#line 899
  *p_ty1 = (OPJ_INT32 )__cil_tmp31;
#line 902
  *p_max_prec = (OPJ_UINT32 )0;
#line 903
  *p_max_res = (OPJ_UINT32 )0;
#line 906
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 907
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 909
  compno = (OPJ_UINT32 )0;
  }
  {
#line 909
  while (1) {
    while_continue: /* CIL Label */ ;

#line 909
    if (! (compno < p_image->numcomps)) {
#line 909
      goto while_break;
    }
    {
#line 918
    lResolutionPtr = *(p_resolutions + compno);
#line 920
    l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32 )l_img_comp->dx);
#line 921
    l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32 )l_img_comp->dy);
#line 922
    l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32 )l_img_comp->dx);
#line 923
    l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32 )l_img_comp->dy);
    }
#line 925
    if (l_tccp->numresolutions > *p_max_res) {
#line 926
      *p_max_res = l_tccp->numresolutions;
    }
#line 930
    l_level_no = l_tccp->numresolutions;
#line 931
    resno = (OPJ_UINT32 )0;
    {
#line 931
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 931
      if (! (resno < l_tccp->numresolutions)) {
#line 931
        goto while_break___0;
      }
#line 934
      l_level_no --;
#line 937
      l_pdx = l_tccp->prcw[resno];
#line 938
      l_pdy = l_tccp->prch[resno];
#line 939
      __cil_tmp56 = lResolutionPtr;
#line 939
      lResolutionPtr ++;
#line 939
      *__cil_tmp56 = l_pdx;
#line 940
      __cil_tmp57 = lResolutionPtr;
#line 940
      lResolutionPtr ++;
#line 940
      *__cil_tmp57 = l_pdy;
#line 941
      if (l_pdx + l_level_no < 32U) {
#line 941
        if (l_img_comp->dx <= 4294967295U / (1U << (l_pdx + l_level_no))) {
          {
#line 943
          l_dx = l_img_comp->dx * (1U << (l_pdx + l_level_no));
#line 945
          __cil_tmp58 = opj_int_min((OPJ_INT32 )*p_dx_min, (OPJ_INT32 )l_dx);
#line 945
          *p_dx_min = (OPJ_UINT32 )__cil_tmp58;
          }
        }
      }
#line 947
      if (l_pdy + l_level_no < 32U) {
#line 947
        if (l_img_comp->dy <= 4294967295U / (1U << (l_pdy + l_level_no))) {
          {
#line 949
          l_dy = l_img_comp->dy * (1U << (l_pdy + l_level_no));
#line 950
          __cil_tmp59 = opj_int_min((OPJ_INT32 )*p_dy_min, (OPJ_INT32 )l_dy);
#line 950
          *p_dy_min = (OPJ_UINT32 )__cil_tmp59;
          }
        }
      }
      {
#line 954
      l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32 )l_level_no);
#line 955
      l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32 )l_level_no);
#line 956
      l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32 )l_level_no);
#line 957
      l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32 )l_level_no);
#line 958
      __cil_tmp64 = opj_int_floordivpow2(l_rx0, (OPJ_INT32 )l_pdx);
#line 958
      l_px0 = __cil_tmp64 << l_pdx;
#line 959
      __cil_tmp65 = opj_int_floordivpow2(l_ry0, (OPJ_INT32 )l_pdy);
#line 959
      l_py0 = __cil_tmp65 << l_pdy;
#line 960
      __cil_tmp66 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32 )l_pdx);
#line 960
      l_px1 = __cil_tmp66 << l_pdx;
#line 961
      __cil_tmp67 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32 )l_pdy);
#line 961
      py1 = __cil_tmp67 << l_pdy;
      }
#line 962
      if (l_rx0 == l_rx1) {
#line 962
        tmp___2 = 0U;
      } else {
#line 962
        tmp___2 = (OPJ_UINT32 )((l_px1 - l_px0) >> l_pdx);
      }
#line 962
      l_pw = tmp___2;
#line 963
      if (l_ry0 == l_ry1) {
#line 963
        tmp___3 = 0U;
      } else {
#line 963
        tmp___3 = (OPJ_UINT32 )((py1 - l_py0) >> l_pdy);
      }
#line 963
      l_ph = tmp___3;
#line 964
      __cil_tmp70 = lResolutionPtr;
#line 964
      lResolutionPtr ++;
#line 964
      *__cil_tmp70 = l_pw;
#line 965
      __cil_tmp71 = lResolutionPtr;
#line 965
      lResolutionPtr ++;
#line 965
      *__cil_tmp71 = l_ph;
#line 966
      l_product = l_pw * l_ph;
#line 969
      if (l_product > *p_max_prec) {
#line 970
        *p_max_prec = l_product;
      }
#line 931
      resno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 974
    l_tccp ++;
#line 975
    l_img_comp ++;
#line 909
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 913
  return;
}
}
#line 979 "/root/patron/new_24/src/lib/openjp2/pi.c"
static opj_pi_iterator_t *opj_pi_create(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_poc_bound ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_pi_iterator_t *l_current_pi ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp17 ;

  {
  {
#line 989
  l_pi = (opj_pi_iterator_t *)0;
#line 990
  tcp = (opj_tcp_t *)0;
#line 991
  tccp = (opj_tccp_t *)0;
#line 994
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1002
  tcp = cp->tcps + tileno;
#line 1003
  l_poc_bound = tcp->numpocs + 1U;
#line 1006
  __cil_tmp14 = opj_calloc((size_t )l_poc_bound, sizeof(opj_pi_iterator_t ));
#line 1006
  l_pi = (opj_pi_iterator_t *)__cil_tmp14;
  }
#line 1008
  if (! l_pi) {
#line 1009
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 1012
  l_current_pi = l_pi;
#line 1013
  pino = (OPJ_UINT32 )0;
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1013
    if (! (pino < l_poc_bound)) {
#line 1013
      goto while_break;
    }
    {
#line 1015
    __cil_tmp15 = opj_calloc((size_t )image->numcomps, sizeof(opj_pi_comp_t ));
#line 1015
    l_current_pi->comps = (opj_pi_comp_t *)__cil_tmp15;
    }
#line 1017
    if (! l_current_pi->comps) {
      {
#line 1018
      opj_pi_destroy(l_pi, l_poc_bound);
      }
#line 1019
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 1022
    l_current_pi->numcomps = image->numcomps;
#line 1024
    compno = (OPJ_UINT32 )0;
    {
#line 1024
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1024
      if (! (compno < image->numcomps)) {
#line 1024
        goto while_break___0;
      }
      {
#line 1025
      comp = l_current_pi->comps + compno;
#line 1027
      tccp = tcp->tccps + compno;
#line 1029
      __cil_tmp17 = opj_calloc((size_t )tccp->numresolutions, sizeof(opj_pi_resolution_t ));
#line 1029
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp17;
      }
#line 1031
      if (! comp->resolutions) {
        {
#line 1032
        opj_pi_destroy(l_pi, l_poc_bound);
        }
#line 1033
        return ((opj_pi_iterator_t *)0);
      }
#line 1036
      comp->numresolutions = tccp->numresolutions;
#line 1024
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 1038
    l_current_pi ++;
#line 1013
    pino ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1040
  return (l_pi);
}
}
#line 1043 "/root/patron/new_24/src/lib/openjp2/pi.c"
static void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp , OPJ_UINT32 p_tileno ,
                                               OPJ_INT32 p_tx0 , OPJ_INT32 p_tx1 ,
                                               OPJ_INT32 p_ty0 , OPJ_INT32 p_ty1 ,
                                               OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                               OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;
  OPJ_UINT32 tmp___1 ;

  {
#line 1057
  l_tcp = (opj_tcp_t *)0;
#line 1059
  l_current_poc = (opj_poc_t *)0;
#line 1071
  l_tcp = p_cp->tcps + p_tileno;
#line 1073
  l_poc_bound = l_tcp->numpocs + 1U;
#line 1077
  l_current_poc = l_tcp->pocs;
#line 1079
  l_current_poc->compS = l_current_poc->compno0;
#line 1080
  l_current_poc->compE = l_current_poc->compno1;
#line 1081
  l_current_poc->resS = l_current_poc->resno0;
#line 1082
  l_current_poc->resE = l_current_poc->resno1;
#line 1083
  l_current_poc->layE = l_current_poc->layno1;
#line 1086
  l_current_poc->layS = (OPJ_UINT32 )0;
#line 1087
  l_current_poc->prg = l_current_poc->prg1;
#line 1088
  l_current_poc->prcS = (OPJ_UINT32 )0;
#line 1090
  l_current_poc->prcE = p_max_prec;
#line 1091
  l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 1092
  l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 1093
  l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 1094
  l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 1095
  l_current_poc->dx = p_dx_min;
#line 1096
  l_current_poc->dy = p_dy_min;
#line 1098
  l_current_poc ++;
#line 1099
  pino = (OPJ_UINT32 )1;
  {
#line 1099
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1099
    if (! (pino < l_poc_bound)) {
#line 1099
      goto while_break;
    }
#line 1100
    l_current_poc->compS = l_current_poc->compno0;
#line 1101
    l_current_poc->compE = l_current_poc->compno1;
#line 1102
    l_current_poc->resS = l_current_poc->resno0;
#line 1103
    l_current_poc->resE = l_current_poc->resno1;
#line 1104
    l_current_poc->layE = l_current_poc->layno1;
#line 1105
    l_current_poc->prg = l_current_poc->prg1;
#line 1106
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 1108
    if (l_current_poc->layE > (l_current_poc - 1)->layE) {
#line 1108
      tmp___1 = l_current_poc->layE;
    } else {
#line 1108
      tmp___1 = 0U;
    }
#line 1108
    l_current_poc->layS = tmp___1;
#line 1111
    l_current_poc->prcE = p_max_prec;
#line 1112
    l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 1113
    l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 1114
    l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 1115
    l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 1116
    l_current_poc->dx = p_dx_min;
#line 1117
    l_current_poc->dy = p_dy_min;
#line 1118
    l_current_poc ++;
#line 1099
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1103
  return;
}
}
#line 1122 "/root/patron/new_24/src/lib/openjp2/pi.c"
static void opj_pi_update_encode_not_poc(opj_cp_t *p_cp , OPJ_UINT32 p_num_comps ,
                                         OPJ_UINT32 p_tileno , OPJ_INT32 p_tx0 , OPJ_INT32 p_tx1 ,
                                         OPJ_INT32 p_ty0 , OPJ_INT32 p_ty1 , OPJ_UINT32 p_max_prec ,
                                         OPJ_UINT32 p_max_res , OPJ_UINT32 p_dx_min ,
                                         OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;

  {
#line 1137
  l_tcp = (opj_tcp_t *)0;
#line 1139
  l_current_poc = (opj_poc_t *)0;
#line 1148
  l_tcp = p_cp->tcps + p_tileno;
#line 1151
  l_poc_bound = l_tcp->numpocs + 1U;
#line 1155
  l_current_poc = l_tcp->pocs;
#line 1157
  pino = (OPJ_UINT32 )0;
  {
#line 1157
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1157
    if (! (pino < l_poc_bound)) {
#line 1157
      goto while_break;
    }
#line 1158
    l_current_poc->compS = (OPJ_UINT32 )0;
#line 1159
    l_current_poc->compE = p_num_comps;
#line 1160
    l_current_poc->resS = (OPJ_UINT32 )0;
#line 1161
    l_current_poc->resE = p_max_res;
#line 1162
    l_current_poc->layS = (OPJ_UINT32 )0;
#line 1163
    l_current_poc->layE = l_tcp->numlayers;
#line 1164
    l_current_poc->prg = l_tcp->prg;
#line 1165
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 1166
    l_current_poc->prcE = p_max_prec;
#line 1167
    l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 1168
    l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 1169
    l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 1170
    l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 1171
    l_current_poc->dx = p_dx_min;
#line 1172
    l_current_poc->dy = p_dy_min;
#line 1173
    l_current_poc ++;
#line 1157
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1161
  return;
}
}
#line 1177 "/root/patron/new_24/src/lib/openjp2/pi.c"
static void opj_pi_update_decode_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp ,
                                     OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t *l_current_pi ;
  opj_poc_t *l_current_poc ;

  {
#line 1188
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1189
  l_current_poc = (opj_poc_t *)0;
#line 1198
  l_bound = p_tcp->numpocs + 1U;
#line 1199
  l_current_pi = p_pi;
#line 1200
  l_current_poc = p_tcp->pocs;
#line 1202
  pino = (OPJ_UINT32 )0;
  {
#line 1202
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1202
    if (! (pino < l_bound)) {
#line 1202
      goto while_break;
    }
    {
#line 1203
    l_current_pi->poc.prg = l_current_poc->prg;
#line 1204
    l_current_pi->first = 1;
#line 1206
    l_current_pi->poc.resno0 = l_current_poc->resno0;
#line 1208
    l_current_pi->poc.compno0 = l_current_poc->compno0;
#line 1210
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1211
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1212
    l_current_pi->poc.resno1 = l_current_poc->resno1;
#line 1214
    l_current_pi->poc.compno1 = l_current_poc->compno1;
#line 1216
    l_current_pi->poc.layno1 = opj_uint_min(l_current_poc->layno1, p_tcp->numlayers);
#line 1218
    l_current_pi->poc.precno1 = p_max_precision;
#line 1219
    l_current_pi ++;
#line 1220
    l_current_poc ++;
#line 1202
    pino ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1206
  return;
}
}
#line 1224 "/root/patron/new_24/src/lib/openjp2/pi.c"
static void opj_pi_update_decode_not_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp ,
                                         OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t *l_current_pi ;

  {
#line 1235
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1241
  l_bound = p_tcp->numpocs + 1U;
#line 1242
  l_current_pi = p_pi;
#line 1244
  pino = (OPJ_UINT32 )0;
  {
#line 1244
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1244
    if (! (pino < l_bound)) {
#line 1244
      goto while_break;
    }
#line 1245
    l_current_pi->poc.prg = p_tcp->prg;
#line 1246
    l_current_pi->first = 1;
#line 1247
    l_current_pi->poc.resno0 = (OPJ_UINT32 )0;
#line 1248
    l_current_pi->poc.compno0 = (OPJ_UINT32 )0;
#line 1249
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1250
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1251
    l_current_pi->poc.resno1 = p_max_res;
#line 1252
    l_current_pi->poc.compno1 = l_current_pi->numcomps;
#line 1253
    l_current_pi->poc.layno1 = p_tcp->numlayers;
#line 1254
    l_current_pi->poc.precno1 = p_max_precision;
#line 1255
    l_current_pi ++;
#line 1244
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1248
  return;
}
}
#line 1261 "/root/patron/new_24/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                        OPJ_UINT32 pino , OPJ_CHAR *prog ) 
{ 
  OPJ_INT32 i ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;

  {
#line 1268
  tcps = cp->tcps + tileno;
#line 1269
  tcp = & tcps->pocs[pino];
#line 1271
  if (pos >= 0) {
#line 1272
    i = pos;
    {
#line 1272
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1272
      if (! (pos >= 0)) {
#line 1272
        goto while_break;
      }
#line 1274
      if ((int )*(prog + i) == 82) {
#line 1274
        goto case_82;
      }
#line 1285
      if ((int )*(prog + i) == 67) {
#line 1285
        goto case_67;
      }
#line 1296
      if ((int )*(prog + i) == 76) {
#line 1296
        goto case_76;
      }
#line 1307
      if ((int )*(prog + i) == 80) {
#line 1307
        goto case_80;
      }
#line 1310
      if ((int )*(prog + i) == 1) {
#line 1310
        goto case_1;
      }
#line 1310
      if ((int )*(prog + i) == 0) {
#line 1310
        goto case_1;
      }
#line 1321
      goto switch_default;
      case_82: 
#line 1275
      if (tcp->res_t == tcp->resE) {
        {
#line 1276
        __cil_tmp9 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1276
        if (__cil_tmp9) {
#line 1277
          return (1);
        } else {
#line 1279
          return (0);
        }
      } else {
#line 1282
        return (1);
      }
#line 1284
      goto switch_break;
      case_67: 
#line 1286
      if (tcp->comp_t == tcp->compE) {
        {
#line 1287
        __cil_tmp10 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1287
        if (__cil_tmp10) {
#line 1288
          return (1);
        } else {
#line 1290
          return (0);
        }
      } else {
#line 1293
        return (1);
      }
#line 1295
      goto switch_break;
      case_76: 
#line 1297
      if (tcp->lay_t == tcp->layE) {
        {
#line 1298
        __cil_tmp11 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1298
        if (__cil_tmp11) {
#line 1299
          return (1);
        } else {
#line 1301
          return (0);
        }
      } else {
#line 1304
        return (1);
      }
#line 1306
      goto switch_break;
      case_80: 
#line 1310
      if ((int )tcp->prg == 1) {
#line 1310
        goto case_1;
      }
#line 1310
      if ((int )tcp->prg == 0) {
#line 1310
        goto case_1;
      }
#line 1321
      goto switch_default;
      case_1: 
#line 1311
      if (tcp->prc_t == tcp->prcE) {
        {
#line 1312
        __cil_tmp12 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
        }
#line 1312
        if (__cil_tmp12) {
#line 1313
          return (1);
        } else {
#line 1315
          return (0);
        }
      } else {
#line 1318
        return (1);
      }
#line 1320
      goto switch_break___0;
      switch_default: 
#line 1322
      if (tcp->tx0_t == tcp->txE) {
#line 1324
        if (tcp->ty0_t == tcp->tyE) {
          {
#line 1325
          __cil_tmp13 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
          }
#line 1325
          if (__cil_tmp13) {
#line 1326
            return (1);
          } else {
#line 1328
            return (0);
          }
        } else {
#line 1331
          return (1);
        }
      } else {
#line 1334
        return (1);
      }
#line 1336
      goto switch_break___0;
      switch_break___0: ;
      switch_break: 
#line 1272
      __cil_tmp14 = i;
#line 1272
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 1341
  return (0);
}
}
#line 1350 "/root/patron/new_24/src/lib/openjp2/pi.c"
opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 numcomps ;
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp37 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp39 ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 *__cil_tmp41 ;
  OPJ_UINT32 *__cil_tmp42 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp45 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 *__cil_tmp47 ;
  OPJ_UINT32 *__cil_tmp48 ;

  {
  {
#line 1354
  numcomps = p_image->numcomps;
#line 1374
  l_pi = (opj_pi_iterator_t *)0;
#line 1375
  l_tcp = (opj_tcp_t *)0;
#line 1376
  l_tccp = (opj_tccp_t *)0;
#line 1377
  l_current_comp = (opj_pi_comp_t *)0;
#line 1378
  l_img_comp = (opj_image_comp_t *)0;
#line 1379
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1380
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1388
  l_tcp = p_cp->tcps + p_tile_no;
#line 1389
  l_bound = l_tcp->numpocs + 1U;
#line 1391
  l_data_stride = (OPJ_UINT32 )132;
#line 1392
  __cil_tmp34 = opj_malloc((unsigned long )(l_data_stride * numcomps) * sizeof(OPJ_UINT32 ));
#line 1392
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp34;
  }
#line 1394
  if (! l_tmp_data) {
#line 1396
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1398
  __cil_tmp35 = opj_malloc((unsigned long )numcomps * sizeof(OPJ_UINT32 *));
#line 1398
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp35;
  }
#line 1400
  if (! l_tmp_ptr) {
    {
#line 1402
    opj_free((void *)l_tmp_data);
    }
#line 1403
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1407
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no);
  }
#line 1408
  if (! l_pi) {
    {
#line 1409
    opj_free((void *)l_tmp_data);
#line 1410
    opj_free((void *)l_tmp_ptr);
    }
#line 1411
    return ((opj_pi_iterator_t *)0);
  }
#line 1414
  l_encoding_value_ptr = l_tmp_data;
#line 1417
  compno = (OPJ_UINT32 )0;
  {
#line 1416
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1416
    if (! (compno < numcomps)) {
#line 1416
      goto while_break;
    }
#line 1418
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1419
    l_encoding_value_ptr += l_data_stride;
#line 1417
    compno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1422
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1426
  l_step_p = (OPJ_UINT32 )1;
#line 1427
  l_step_c = l_max_prec * l_step_p;
#line 1428
  l_step_r = numcomps * l_step_c;
#line 1429
  l_step_l = l_max_res * l_step_r;
#line 1432
  l_current_pi = l_pi;
#line 1437
  l_current_pi->include = (OPJ_INT16 *)0;
  }
#line 1438
  if (l_step_l <= 4294967295U / (l_tcp->numlayers + 1U)) {
    {
#line 1439
    l_current_pi->include_size = (l_tcp->numlayers + 1U) * l_step_l;
#line 1440
    __cil_tmp37 = opj_calloc((size_t )l_current_pi->include_size, sizeof(OPJ_INT16 ));
#line 1440
    l_current_pi->include = (OPJ_INT16 *)__cil_tmp37;
    }
  }
#line 1444
  if (! l_current_pi->include) {
    {
#line 1445
    opj_free((void *)l_tmp_data);
#line 1446
    opj_free((void *)l_tmp_ptr);
#line 1447
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1448
    return ((opj_pi_iterator_t *)0);
  }
#line 1452
  l_current_comp = l_current_pi->comps;
#line 1453
  l_img_comp = p_image->comps;
#line 1454
  l_tccp = l_tcp->tccps;
#line 1456
  l_current_pi->tx0 = l_tx0;
#line 1457
  l_current_pi->ty0 = l_ty0;
#line 1458
  l_current_pi->tx1 = l_tx1;
#line 1459
  l_current_pi->ty1 = l_ty1;
#line 1464
  l_current_pi->step_p = l_step_p;
#line 1465
  l_current_pi->step_c = l_step_c;
#line 1466
  l_current_pi->step_r = l_step_r;
#line 1467
  l_current_pi->step_l = l_step_l;
#line 1471
  compno = (OPJ_UINT32 )0;
  {
#line 1470
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1470
    if (! (compno < numcomps)) {
#line 1470
      goto while_break___0;
    }
#line 1472
    l_res = l_current_comp->resolutions;
#line 1473
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1475
    l_current_comp->dx = l_img_comp->dx;
#line 1476
    l_current_comp->dy = l_img_comp->dy;
#line 1479
    resno = (OPJ_UINT32 )0;
    {
#line 1478
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1478
      if (! (resno < l_current_comp->numresolutions)) {
#line 1478
        goto while_break___1;
      }
#line 1480
      __cil_tmp39 = l_encoding_value_ptr;
#line 1480
      l_encoding_value_ptr ++;
#line 1480
      l_res->pdx = *__cil_tmp39;
#line 1481
      __cil_tmp40 = l_encoding_value_ptr;
#line 1481
      l_encoding_value_ptr ++;
#line 1481
      l_res->pdy = *__cil_tmp40;
#line 1482
      __cil_tmp41 = l_encoding_value_ptr;
#line 1482
      l_encoding_value_ptr ++;
#line 1482
      l_res->pw = *__cil_tmp41;
#line 1483
      __cil_tmp42 = l_encoding_value_ptr;
#line 1483
      l_encoding_value_ptr ++;
#line 1483
      l_res->ph = *__cil_tmp42;
#line 1484
      l_res ++;
#line 1479
      resno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
#line 1486
    l_current_comp ++;
#line 1487
    l_img_comp ++;
#line 1488
    l_tccp ++;
#line 1471
    compno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 1490
  l_current_pi ++;
#line 1492
  pino = (OPJ_UINT32 )1;
  {
#line 1492
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1492
    if (! (pino < l_bound)) {
#line 1492
      goto while_break___2;
    }
#line 1493
    l_current_comp = l_current_pi->comps;
#line 1494
    l_img_comp = p_image->comps;
#line 1495
    l_tccp = l_tcp->tccps;
#line 1497
    l_current_pi->tx0 = l_tx0;
#line 1498
    l_current_pi->ty0 = l_ty0;
#line 1499
    l_current_pi->tx1 = l_tx1;
#line 1500
    l_current_pi->ty1 = l_ty1;
#line 1503
    l_current_pi->step_p = l_step_p;
#line 1504
    l_current_pi->step_c = l_step_c;
#line 1505
    l_current_pi->step_r = l_step_r;
#line 1506
    l_current_pi->step_l = l_step_l;
#line 1510
    compno = (OPJ_UINT32 )0;
    {
#line 1509
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1509
      if (! (compno < numcomps)) {
#line 1509
        goto while_break___3;
      }
#line 1511
      l_res___0 = l_current_comp->resolutions;
#line 1512
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1514
      l_current_comp->dx = l_img_comp->dx;
#line 1515
      l_current_comp->dy = l_img_comp->dy;
#line 1518
      resno = (OPJ_UINT32 )0;
      {
#line 1517
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1517
        if (! (resno < l_current_comp->numresolutions)) {
#line 1517
          goto while_break___4;
        }
#line 1519
        __cil_tmp45 = l_encoding_value_ptr;
#line 1519
        l_encoding_value_ptr ++;
#line 1519
        l_res___0->pdx = *__cil_tmp45;
#line 1520
        __cil_tmp46 = l_encoding_value_ptr;
#line 1520
        l_encoding_value_ptr ++;
#line 1520
        l_res___0->pdy = *__cil_tmp46;
#line 1521
        __cil_tmp47 = l_encoding_value_ptr;
#line 1521
        l_encoding_value_ptr ++;
#line 1521
        l_res___0->pw = *__cil_tmp47;
#line 1522
        __cil_tmp48 = l_encoding_value_ptr;
#line 1522
        l_encoding_value_ptr ++;
#line 1522
        l_res___0->ph = *__cil_tmp48;
#line 1523
        l_res___0 ++;
#line 1518
        resno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 1525
      l_current_comp ++;
#line 1526
      l_img_comp ++;
#line 1527
      l_tccp ++;
#line 1510
      compno ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 1530
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1531
    l_current_pi->include_size = (l_current_pi - 1)->include_size;
#line 1532
    l_current_pi ++;
#line 1492
    pino ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 1534
  opj_free((void *)l_tmp_data);
#line 1535
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1536
  opj_free((void *)l_tmp_ptr);
#line 1537
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1538
  if (l_tcp->POC) {
    {
#line 1540
    opj_pi_update_decode_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  } else {
    {
#line 1542
    opj_pi_update_decode_not_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  }
#line 1544
  return (l_pi);
}
}
#line 1549 "/root/patron/new_24/src/lib/openjp2/pi.c"
opj_pi_iterator_t *opj_pi_initialise_encode(opj_image_t *p_image , opj_cp_t *p_cp ,
                                            OPJ_UINT32 p_tile_no , J2K_T2_MODE p_t2_mode ) 
{ 
  OPJ_UINT32 numcomps ;
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp38 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 *__cil_tmp41 ;
  OPJ_UINT32 *__cil_tmp42 ;
  OPJ_UINT32 *__cil_tmp43 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 *__cil_tmp47 ;
  OPJ_UINT32 *__cil_tmp48 ;
  OPJ_UINT32 *__cil_tmp49 ;

  {
  {
#line 1554
  numcomps = p_image->numcomps;
#line 1574
  l_pi = (opj_pi_iterator_t *)0;
#line 1575
  l_tcp = (opj_tcp_t *)0;
#line 1576
  l_tccp = (opj_tccp_t *)0;
#line 1577
  l_current_comp = (opj_pi_comp_t *)0;
#line 1578
  l_img_comp = (opj_image_comp_t *)0;
#line 1579
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1580
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1588
  l_tcp = p_cp->tcps + p_tile_no;
#line 1589
  l_bound = l_tcp->numpocs + 1U;
#line 1591
  l_data_stride = (OPJ_UINT32 )132;
#line 1592
  __cil_tmp35 = opj_malloc((unsigned long )(l_data_stride * numcomps) * sizeof(OPJ_UINT32 ));
#line 1592
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp35;
  }
#line 1594
  if (! l_tmp_data) {
#line 1595
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1598
  __cil_tmp36 = opj_malloc((unsigned long )numcomps * sizeof(OPJ_UINT32 *));
#line 1598
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp36;
  }
#line 1600
  if (! l_tmp_ptr) {
    {
#line 1601
    opj_free((void *)l_tmp_data);
    }
#line 1602
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1606
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no);
  }
#line 1607
  if (! l_pi) {
    {
#line 1608
    opj_free((void *)l_tmp_data);
#line 1609
    opj_free((void *)l_tmp_ptr);
    }
#line 1610
    return ((opj_pi_iterator_t *)0);
  }
#line 1613
  l_encoding_value_ptr = l_tmp_data;
#line 1615
  compno = (OPJ_UINT32 )0;
  {
#line 1615
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1615
    if (! (compno < numcomps)) {
#line 1615
      goto while_break;
    }
#line 1616
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1617
    l_encoding_value_ptr += l_data_stride;
#line 1615
    compno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1621
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1625
  l_step_p = (OPJ_UINT32 )1;
#line 1626
  l_step_c = l_max_prec * l_step_p;
#line 1627
  l_step_r = numcomps * l_step_c;
#line 1628
  l_step_l = l_max_res * l_step_r;
#line 1631
  l_pi->tp_on = (OPJ_BYTE )p_cp->m_specific_param.m_enc.m_tp_on;
#line 1632
  l_current_pi = l_pi;
#line 1635
  l_current_pi->include_size = l_tcp->numlayers * l_step_l;
#line 1636
  __cil_tmp38 = opj_calloc((size_t )l_current_pi->include_size, sizeof(OPJ_INT16 ));
#line 1636
  l_current_pi->include = (OPJ_INT16 *)__cil_tmp38;
  }
#line 1638
  if (! l_current_pi->include) {
    {
#line 1639
    opj_free((void *)l_tmp_data);
#line 1640
    opj_free((void *)l_tmp_ptr);
#line 1641
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1642
    return ((opj_pi_iterator_t *)0);
  }
#line 1646
  l_current_comp = l_current_pi->comps;
#line 1647
  l_img_comp = p_image->comps;
#line 1648
  l_tccp = l_tcp->tccps;
#line 1649
  l_current_pi->tx0 = l_tx0;
#line 1650
  l_current_pi->ty0 = l_ty0;
#line 1651
  l_current_pi->tx1 = l_tx1;
#line 1652
  l_current_pi->ty1 = l_ty1;
#line 1653
  l_current_pi->dx = l_dx_min;
#line 1654
  l_current_pi->dy = l_dy_min;
#line 1655
  l_current_pi->step_p = l_step_p;
#line 1656
  l_current_pi->step_c = l_step_c;
#line 1657
  l_current_pi->step_r = l_step_r;
#line 1658
  l_current_pi->step_l = l_step_l;
#line 1661
  compno = (OPJ_UINT32 )0;
  {
#line 1661
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1661
    if (! (compno < numcomps)) {
#line 1661
      goto while_break___0;
    }
#line 1662
    l_res = l_current_comp->resolutions;
#line 1663
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1665
    l_current_comp->dx = l_img_comp->dx;
#line 1666
    l_current_comp->dy = l_img_comp->dy;
#line 1669
    resno = (OPJ_UINT32 )0;
    {
#line 1669
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1669
      if (! (resno < l_current_comp->numresolutions)) {
#line 1669
        goto while_break___1;
      }
#line 1670
      __cil_tmp40 = l_encoding_value_ptr;
#line 1670
      l_encoding_value_ptr ++;
#line 1670
      l_res->pdx = *__cil_tmp40;
#line 1671
      __cil_tmp41 = l_encoding_value_ptr;
#line 1671
      l_encoding_value_ptr ++;
#line 1671
      l_res->pdy = *__cil_tmp41;
#line 1672
      __cil_tmp42 = l_encoding_value_ptr;
#line 1672
      l_encoding_value_ptr ++;
#line 1672
      l_res->pw = *__cil_tmp42;
#line 1673
      __cil_tmp43 = l_encoding_value_ptr;
#line 1673
      l_encoding_value_ptr ++;
#line 1673
      l_res->ph = *__cil_tmp43;
#line 1674
      l_res ++;
#line 1669
      resno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
#line 1677
    l_current_comp ++;
#line 1678
    l_img_comp ++;
#line 1679
    l_tccp ++;
#line 1661
    compno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 1681
  l_current_pi ++;
#line 1683
  pino = (OPJ_UINT32 )1;
  {
#line 1683
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1683
    if (! (pino < l_bound)) {
#line 1683
      goto while_break___2;
    }
#line 1684
    l_current_comp = l_current_pi->comps;
#line 1685
    l_img_comp = p_image->comps;
#line 1686
    l_tccp = l_tcp->tccps;
#line 1688
    l_current_pi->tx0 = l_tx0;
#line 1689
    l_current_pi->ty0 = l_ty0;
#line 1690
    l_current_pi->tx1 = l_tx1;
#line 1691
    l_current_pi->ty1 = l_ty1;
#line 1692
    l_current_pi->dx = l_dx_min;
#line 1693
    l_current_pi->dy = l_dy_min;
#line 1694
    l_current_pi->step_p = l_step_p;
#line 1695
    l_current_pi->step_c = l_step_c;
#line 1696
    l_current_pi->step_r = l_step_r;
#line 1697
    l_current_pi->step_l = l_step_l;
#line 1700
    compno = (OPJ_UINT32 )0;
    {
#line 1700
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1700
      if (! (compno < numcomps)) {
#line 1700
        goto while_break___3;
      }
#line 1701
      l_res___0 = l_current_comp->resolutions;
#line 1702
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1704
      l_current_comp->dx = l_img_comp->dx;
#line 1705
      l_current_comp->dy = l_img_comp->dy;
#line 1707
      resno = (OPJ_UINT32 )0;
      {
#line 1707
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1707
        if (! (resno < l_current_comp->numresolutions)) {
#line 1707
          goto while_break___4;
        }
#line 1708
        __cil_tmp46 = l_encoding_value_ptr;
#line 1708
        l_encoding_value_ptr ++;
#line 1708
        l_res___0->pdx = *__cil_tmp46;
#line 1709
        __cil_tmp47 = l_encoding_value_ptr;
#line 1709
        l_encoding_value_ptr ++;
#line 1709
        l_res___0->pdy = *__cil_tmp47;
#line 1710
        __cil_tmp48 = l_encoding_value_ptr;
#line 1710
        l_encoding_value_ptr ++;
#line 1710
        l_res___0->pw = *__cil_tmp48;
#line 1711
        __cil_tmp49 = l_encoding_value_ptr;
#line 1711
        l_encoding_value_ptr ++;
#line 1711
        l_res___0->ph = *__cil_tmp49;
#line 1712
        l_res___0 ++;
#line 1707
        resno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 1714
      l_current_comp ++;
#line 1715
      l_img_comp ++;
#line 1716
      l_tccp ++;
#line 1700
      compno ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 1720
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1721
    l_current_pi->include_size = (l_current_pi - 1)->include_size;
#line 1722
    l_current_pi ++;
#line 1683
    pino ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 1725
  opj_free((void *)l_tmp_data);
#line 1726
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1727
  opj_free((void *)l_tmp_ptr);
#line 1728
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1730
  if ((int )l_tcp->POC) {
#line 1730
    if ((int )p_cp->rsiz >= 3) {
#line 1730
      if ((int )p_cp->rsiz <= 6) {
        {
#line 1731
        opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                           l_max_prec, l_max_res, l_dx_min, l_dy_min);
        }
      } else {
#line 1730
        goto _L;
      }
    } else
    _L: 
#line 1730
    if ((unsigned int )p_t2_mode == 1U) {
      {
#line 1731
      opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                         l_max_prec, l_max_res, l_dx_min, l_dy_min);
      }
    } else {
      {
#line 1734
      opj_pi_update_encode_not_poc(p_cp, numcomps, p_tile_no, l_tx0, l_tx1, l_ty0,
                                   l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
      }
    }
  } else {
    {
#line 1734
    opj_pi_update_encode_not_poc(p_cp, numcomps, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                 l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  }
#line 1738
  return (l_pi);
}
}
#line 1741 "/root/patron/new_24/src/lib/openjp2/pi.c"
void opj_pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i ;
  OPJ_UINT32 incr_top ;
  OPJ_UINT32 resetX ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_INT32 __cil_tmp22 ;
  char const   *tmp ;

  {
  {
#line 1751
  incr_top = (OPJ_UINT32 )1;
#line 1751
  resetX = (OPJ_UINT32 )0;
#line 1752
  tcps = cp->tcps + tileno;
#line 1753
  tcp = & tcps->pocs[pino];
#line 1755
  tmp = opj_j2k_convert_progression_order(tcp->prg);
#line 1755
  prog = (OPJ_CHAR *)tmp;
#line 1757
  (pi + pino)->first = 1;
#line 1758
  (pi + pino)->poc.prg = tcp->prg;
  }
#line 1760
  if ((int )cp->m_specific_param.m_enc.m_tp_on) {
#line 1760
    if ((int )cp->rsiz >= 3) {
#line 1760
      if ((int )cp->rsiz <= 6) {
        _L___10: /* CIL Label */ 
#line 1760
        if ((int )cp->rsiz >= 3) {
#line 1760
          if ((int )cp->rsiz <= 6) {
            _L___9: /* CIL Label */ 
#line 1775
            i = tppos + 1;
            {
#line 1775
            while (1) {
              while_continue: /* CIL Label */ ;

#line 1775
              if (! (i < 4)) {
#line 1775
                goto while_break;
              }
#line 1777
              if ((int )*(prog + i) == 82) {
#line 1777
                goto case_82;
              }
#line 1781
              if ((int )*(prog + i) == 67) {
#line 1781
                goto case_67;
              }
#line 1785
              if ((int )*(prog + i) == 76) {
#line 1785
                goto case_76;
              }
#line 1789
              if ((int )*(prog + i) == 80) {
#line 1789
                goto case_80;
              }
#line 1792
              if ((int )*(prog + i) == 1) {
#line 1792
                goto case_1;
              }
#line 1792
              if ((int )*(prog + i) == 0) {
#line 1792
                goto case_1;
              }
#line 1796
              goto switch_default;
              case_82: 
#line 1778
              (pi + pino)->poc.resno0 = tcp->resS;
#line 1779
              (pi + pino)->poc.resno1 = tcp->resE;
#line 1780
              goto switch_break;
              case_67: 
#line 1782
              (pi + pino)->poc.compno0 = tcp->compS;
#line 1783
              (pi + pino)->poc.compno1 = tcp->compE;
#line 1784
              goto switch_break;
              case_76: 
#line 1786
              (pi + pino)->poc.layno0 = tcp->layS;
#line 1787
              (pi + pino)->poc.layno1 = tcp->layE;
#line 1788
              goto switch_break;
              case_80: 
#line 1792
              if ((int )tcp->prg == 1) {
#line 1792
                goto case_1;
              }
#line 1792
              if ((int )tcp->prg == 0) {
#line 1792
                goto case_1;
              }
#line 1796
              goto switch_default;
              case_1: 
#line 1793
              (pi + pino)->poc.precno0 = tcp->prcS;
#line 1794
              (pi + pino)->poc.precno1 = tcp->prcE;
#line 1795
              goto switch_break___0;
              switch_default: 
#line 1797
              (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->txS;
#line 1798
              (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->tyS;
#line 1799
              (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->txE;
#line 1800
              (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->tyE;
#line 1801
              goto switch_break___0;
              switch_break___0: ;
#line 1803
              goto switch_break;
              switch_break: 
#line 1775
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
            while_break: ;
#line 1807
            if (tpnum == 0U) {
#line 1808
              i = tppos;
              {
#line 1808
              while (1) {
                while_continue___0: /* CIL Label */ ;

#line 1808
                if (! (i >= 0)) {
#line 1808
                  goto while_break___0;
                }
#line 1810
                if ((int )*(prog + i) == 67) {
#line 1810
                  goto case_67___0;
                }
#line 1816
                if ((int )*(prog + i) == 82) {
#line 1816
                  goto case_82___0;
                }
#line 1822
                if ((int )*(prog + i) == 76) {
#line 1822
                  goto case_76___0;
                }
#line 1828
                if ((int )*(prog + i) == 80) {
#line 1828
                  goto case_80___0;
                }
#line 1831
                if ((int )*(prog + i) == 1) {
#line 1831
                  goto case_1___0;
                }
#line 1831
                if ((int )*(prog + i) == 0) {
#line 1831
                  goto case_1___0;
                }
#line 1837
                goto switch_default___0;
                case_67___0: 
#line 1811
                tcp->comp_t = tcp->compS;
#line 1812
                (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1813
                (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1814
                (tcp->comp_t) ++;
#line 1815
                goto switch_break___1;
                case_82___0: 
#line 1817
                tcp->res_t = tcp->resS;
#line 1818
                (pi + pino)->poc.resno0 = tcp->res_t;
#line 1819
                (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1820
                (tcp->res_t) ++;
#line 1821
                goto switch_break___1;
                case_76___0: 
#line 1823
                tcp->lay_t = tcp->layS;
#line 1824
                (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1825
                (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1826
                (tcp->lay_t) ++;
#line 1827
                goto switch_break___1;
                case_80___0: 
#line 1831
                if ((int )tcp->prg == 1) {
#line 1831
                  goto case_1___0;
                }
#line 1831
                if ((int )tcp->prg == 0) {
#line 1831
                  goto case_1___0;
                }
#line 1837
                goto switch_default___0;
                case_1___0: 
#line 1832
                tcp->prc_t = tcp->prcS;
#line 1833
                (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1834
                (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1835
                (tcp->prc_t) ++;
#line 1836
                goto switch_break___2;
                switch_default___0: 
#line 1838
                tcp->tx0_t = tcp->txS;
#line 1839
                tcp->ty0_t = tcp->tyS;
#line 1840
                (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1841
                (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1842
                (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1843
                (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1844
                tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 1845
                tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1846
                goto switch_break___2;
                switch_break___2: ;
#line 1848
                goto switch_break___1;
                switch_break___1: 
#line 1808
                __cil_tmp16 = i;
#line 1808
                i --;
              }
              while_break___3: /* CIL Label */ ;
              }
              while_break___0: 
#line 1851
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1853
              i = tppos;
              {
#line 1853
              while (1) {
                while_continue___1: /* CIL Label */ ;

#line 1853
                if (! (i >= 0)) {
#line 1853
                  goto while_break___1;
                }
#line 1855
                if ((int )*(prog + i) == 67) {
#line 1855
                  goto case_67___1;
                }
#line 1859
                if ((int )*(prog + i) == 82) {
#line 1859
                  goto case_82___1;
                }
#line 1863
                if ((int )*(prog + i) == 76) {
#line 1863
                  goto case_76___1;
                }
#line 1867
                if ((int )*(prog + i) == 80) {
#line 1867
                  goto case_80___1;
                }
#line 1870
                if ((int )*(prog + i) == 1) {
#line 1870
                  goto case_1___1;
                }
#line 1870
                if ((int )*(prog + i) == 0) {
#line 1870
                  goto case_1___1;
                }
#line 1874
                goto switch_default___1;
                case_67___1: 
#line 1856
                (pi + pino)->poc.compno0 = tcp->comp_t - 1U;
#line 1857
                (pi + pino)->poc.compno1 = tcp->comp_t;
#line 1858
                goto switch_break___3;
                case_82___1: 
#line 1860
                (pi + pino)->poc.resno0 = tcp->res_t - 1U;
#line 1861
                (pi + pino)->poc.resno1 = tcp->res_t;
#line 1862
                goto switch_break___3;
                case_76___1: 
#line 1864
                (pi + pino)->poc.layno0 = tcp->lay_t - 1U;
#line 1865
                (pi + pino)->poc.layno1 = tcp->lay_t;
#line 1866
                goto switch_break___3;
                case_80___1: 
#line 1870
                if ((int )tcp->prg == 1) {
#line 1870
                  goto case_1___1;
                }
#line 1870
                if ((int )tcp->prg == 0) {
#line 1870
                  goto case_1___1;
                }
#line 1874
                goto switch_default___1;
                case_1___1: 
#line 1871
                (pi + pino)->poc.precno0 = tcp->prc_t - 1U;
#line 1872
                (pi + pino)->poc.precno1 = tcp->prc_t;
#line 1873
                goto switch_break___4;
                switch_default___1: 
#line 1875
                (pi + pino)->poc.tx0 = (OPJ_INT32 )((tcp->tx0_t - tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1876
                (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->tx0_t;
#line 1877
                (pi + pino)->poc.ty0 = (OPJ_INT32 )((tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1878
                (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->ty0_t;
#line 1879
                goto switch_break___4;
                switch_break___4: ;
#line 1881
                goto switch_break___3;
                switch_break___3: ;
#line 1883
                if (incr_top == 1U) {
#line 1885
                  if ((int )*(prog + i) == 82) {
#line 1885
                    goto case_82___2;
                  }
#line 1903
                  if ((int )*(prog + i) == 67) {
#line 1903
                    goto case_67___2;
                  }
#line 1921
                  if ((int )*(prog + i) == 76) {
#line 1921
                    goto case_76___2;
                  }
#line 1939
                  if ((int )*(prog + i) == 80) {
#line 1939
                    goto case_80___2;
                  }
#line 1942
                  if ((int )*(prog + i) == 1) {
#line 1942
                    goto case_1___2;
                  }
#line 1942
                  if ((int )*(prog + i) == 0) {
#line 1942
                    goto case_1___2;
                  }
#line 1960
                  goto switch_default___2;
                  case_82___2: 
#line 1886
                  if (tcp->res_t == tcp->resE) {
                    {
#line 1887
                    __cil_tmp17 = opj_pi_check_next_level(i - 1, cp, tileno, pino,
                                                          prog);
                    }
#line 1887
                    if (__cil_tmp17) {
#line 1888
                      tcp->res_t = tcp->resS;
#line 1889
                      (pi + pino)->poc.resno0 = tcp->res_t;
#line 1890
                      (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1891
                      (tcp->res_t) ++;
#line 1892
                      incr_top = (OPJ_UINT32 )1;
                    } else {
#line 1894
                      incr_top = (OPJ_UINT32 )0;
                    }
                  } else {
#line 1897
                    (pi + pino)->poc.resno0 = tcp->res_t;
#line 1898
                    (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1899
                    (tcp->res_t) ++;
#line 1900
                    incr_top = (OPJ_UINT32 )0;
                  }
#line 1902
                  goto switch_break___5;
                  case_67___2: 
#line 1904
                  if (tcp->comp_t == tcp->compE) {
                    {
#line 1905
                    __cil_tmp18 = opj_pi_check_next_level(i - 1, cp, tileno, pino,
                                                          prog);
                    }
#line 1905
                    if (__cil_tmp18) {
#line 1906
                      tcp->comp_t = tcp->compS;
#line 1907
                      (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1908
                      (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1909
                      (tcp->comp_t) ++;
#line 1910
                      incr_top = (OPJ_UINT32 )1;
                    } else {
#line 1912
                      incr_top = (OPJ_UINT32 )0;
                    }
                  } else {
#line 1915
                    (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1916
                    (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1917
                    (tcp->comp_t) ++;
#line 1918
                    incr_top = (OPJ_UINT32 )0;
                  }
#line 1920
                  goto switch_break___5;
                  case_76___2: 
#line 1922
                  if (tcp->lay_t == tcp->layE) {
                    {
#line 1923
                    __cil_tmp19 = opj_pi_check_next_level(i - 1, cp, tileno, pino,
                                                          prog);
                    }
#line 1923
                    if (__cil_tmp19) {
#line 1924
                      tcp->lay_t = tcp->layS;
#line 1925
                      (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1926
                      (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1927
                      (tcp->lay_t) ++;
#line 1928
                      incr_top = (OPJ_UINT32 )1;
                    } else {
#line 1930
                      incr_top = (OPJ_UINT32 )0;
                    }
                  } else {
#line 1933
                    (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1934
                    (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1935
                    (tcp->lay_t) ++;
#line 1936
                    incr_top = (OPJ_UINT32 )0;
                  }
#line 1938
                  goto switch_break___5;
                  case_80___2: 
#line 1942
                  if ((int )tcp->prg == 1) {
#line 1942
                    goto case_1___2;
                  }
#line 1942
                  if ((int )tcp->prg == 0) {
#line 1942
                    goto case_1___2;
                  }
#line 1960
                  goto switch_default___2;
                  case_1___2: 
#line 1943
                  if (tcp->prc_t == tcp->prcE) {
                    {
#line 1944
                    __cil_tmp20 = opj_pi_check_next_level(i - 1, cp, tileno, pino,
                                                          prog);
                    }
#line 1944
                    if (__cil_tmp20) {
#line 1945
                      tcp->prc_t = tcp->prcS;
#line 1946
                      (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1947
                      (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1948
                      (tcp->prc_t) ++;
#line 1949
                      incr_top = (OPJ_UINT32 )1;
                    } else {
#line 1951
                      incr_top = (OPJ_UINT32 )0;
                    }
                  } else {
#line 1954
                    (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1955
                    (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1956
                    (tcp->prc_t) ++;
#line 1957
                    incr_top = (OPJ_UINT32 )0;
                  }
#line 1959
                  goto switch_break___6;
                  switch_default___2: 
#line 1961
                  if (tcp->tx0_t >= tcp->txE) {
#line 1962
                    if (tcp->ty0_t >= tcp->tyE) {
                      {
#line 1963
                      __cil_tmp21 = opj_pi_check_next_level(i - 1, cp, tileno, pino,
                                                            prog);
                      }
#line 1963
                      if (__cil_tmp21) {
#line 1964
                        tcp->ty0_t = tcp->tyS;
#line 1965
                        (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1966
                        (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1967
                        tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1968
                        incr_top = (OPJ_UINT32 )1;
#line 1969
                        resetX = (OPJ_UINT32 )1;
                      } else {
#line 1971
                        incr_top = (OPJ_UINT32 )0;
#line 1972
                        resetX = (OPJ_UINT32 )0;
                      }
                    } else {
#line 1975
                      (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1976
                      (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1977
                      tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1978
                      incr_top = (OPJ_UINT32 )0;
#line 1979
                      resetX = (OPJ_UINT32 )1;
                    }
#line 1981
                    if (resetX == 1U) {
#line 1982
                      tcp->tx0_t = tcp->txS;
#line 1983
                      (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1984
                      (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1985
                      tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
                    }
                  } else {
#line 1988
                    (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1989
                    (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1990
                    tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 1991
                    incr_top = (OPJ_UINT32 )0;
                  }
#line 1993
                  goto switch_break___6;
                  switch_break___6: ;
#line 1995
                  goto switch_break___5;
                  switch_break___5: ;
                }
#line 1853
                __cil_tmp22 = i;
#line 1853
                i --;
              }
              while_break___4: /* CIL Label */ ;
              }
              while_break___1: ;
            }
          } else {
#line 1760
            goto _L___8;
          }
        } else {
#line 1760
          goto _L___8;
        }
      } else {
#line 1760
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 1760
    if ((unsigned int )t2_mode == 1U) {
#line 1760
      goto _L___9;
    } else {
#line 1760
      goto _L___10;
    }
  } else {
    _L___8: /* CIL Label */ 
#line 1762
    (pi + pino)->poc.resno0 = tcp->resS;
#line 1763
    (pi + pino)->poc.resno1 = tcp->resE;
#line 1764
    (pi + pino)->poc.compno0 = tcp->compS;
#line 1765
    (pi + pino)->poc.compno1 = tcp->compE;
#line 1766
    (pi + pino)->poc.layno0 = tcp->layS;
#line 1767
    (pi + pino)->poc.layno1 = tcp->layE;
#line 1768
    (pi + pino)->poc.precno0 = tcp->prcS;
#line 1769
    (pi + pino)->poc.precno1 = tcp->prcE;
#line 1770
    (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->txS;
#line 1771
    (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->tyS;
#line 1772
    (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->txE;
#line 1773
    (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->tyE;
  }
#line 1859
  return;
}
}
#line 2003 "/root/patron/new_24/src/lib/openjp2/pi.c"
void opj_pi_destroy(opj_pi_iterator_t *p_pi , OPJ_UINT32 p_nb_elements ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 pino ;
  opj_pi_iterator_t *l_current_pi ;
  opj_pi_comp_t *l_current_component ;

  {
#line 2007
  l_current_pi = p_pi;
#line 2008
  if (p_pi) {
#line 2009
    if (p_pi->include) {
      {
#line 2010
      opj_free((void *)p_pi->include);
#line 2011
      p_pi->include = (OPJ_INT16 *)0;
      }
    }
#line 2013
    pino = (OPJ_UINT32 )0;
    {
#line 2013
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2013
      if (! (pino < p_nb_elements)) {
#line 2013
        goto while_break;
      }
#line 2014
      if (l_current_pi->comps) {
#line 2015
        l_current_component = l_current_pi->comps;
#line 2016
        compno = (OPJ_UINT32 )0;
        {
#line 2016
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 2016
          if (! (compno < l_current_pi->numcomps)) {
#line 2016
            goto while_break___0;
          }
#line 2017
          if (l_current_component->resolutions) {
            {
#line 2018
            opj_free((void *)l_current_component->resolutions);
#line 2019
            l_current_component->resolutions = (opj_pi_resolution_t *)0;
            }
          }
#line 2022
          l_current_component ++;
#line 2016
          compno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: 
        {
#line 2024
        opj_free((void *)l_current_pi->comps);
#line 2025
        l_current_pi->comps = (opj_pi_comp_t *)0;
        }
      }
#line 2027
      l_current_pi ++;
#line 2013
      pino ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 2029
    opj_free((void *)p_pi);
    }
  }
#line 2032
  return;
}
}
#line 2035 "/root/patron/new_24/src/lib/openjp2/pi.c"
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  opj_tcp_t *l_tcp ;

  {
  {
#line 2046
  l_tcp = (opj_tcp_t *)0;
#line 2053
  l_tcp = p_cp->tcps + p_tile_no;
#line 2056
  opj_get_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                              & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res);
  }
#line 2059
  if (l_tcp->POC) {
    {
#line 2060
    opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                       l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  } else {
    {
#line 2063
    opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                 l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  }
#line 2067
  return;
}
}
#line 2068 "/root/patron/new_24/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next(opj_pi_iterator_t *pi ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 2071
  if ((int )pi->poc.prg == 0) {
#line 2071
    goto case_0;
  }
#line 2073
  if ((int )pi->poc.prg == 1) {
#line 2073
    goto case_1;
  }
#line 2075
  if ((int )pi->poc.prg == 2) {
#line 2075
    goto case_2;
  }
#line 2077
  if ((int )pi->poc.prg == 3) {
#line 2077
    goto case_3;
  }
#line 2079
  if ((int )pi->poc.prg == 4) {
#line 2079
    goto case_4;
  }
#line 2081
  if ((int )pi->poc.prg == -1) {
#line 2081
    goto case_neg_1;
  }
#line 2070
  goto switch_break;
  case_0: 
  {
#line 2072
  __cil_tmp2 = opj_pi_next_lrcp(pi);
  }
#line 2072
  return (__cil_tmp2);
  case_1: 
  {
#line 2074
  __cil_tmp3 = opj_pi_next_rlcp(pi);
  }
#line 2074
  return (__cil_tmp3);
  case_2: 
  {
#line 2076
  __cil_tmp4 = opj_pi_next_rpcl(pi);
  }
#line 2076
  return (__cil_tmp4);
  case_3: 
  {
#line 2078
  __cil_tmp5 = opj_pi_next_pcrl(pi);
  }
#line 2078
  return (__cil_tmp5);
  case_4: 
  {
#line 2080
  __cil_tmp6 = opj_pi_next_cprl(pi);
  }
#line 2080
  return (__cil_tmp6);
  case_neg_1: 
#line 2082
  return (0);
  switch_break: ;
#line 2085
  return (0);
}
}
#line 43 "/root/patron/new_24/src/lib/openjp2/opj_malloc.c"
__inline static void *opj_aligned_alloc_n(size_t alignment , size_t size ) 
{ 
  void *ptr ;
  int __cil_tmp6 ;

  {
#line 52
  if (size == 0UL) {
#line 53
    return ((void *)0);
  }
  {
#line 61
  __cil_tmp6 = posix_memalign(& ptr, alignment, size);
  }
#line 61
  if (__cil_tmp6) {
#line 62
    ptr = (void *)0;
  }
#line 105
  return (ptr);
}
}
#line 107 "/root/patron/new_24/src/lib/openjp2/opj_malloc.c"
__inline static void *opj_aligned_realloc_n(void *ptr , size_t alignment , size_t new_size ) 
{ 
  void *r_ptr ;
  void *a_ptr ;
  void *__cil_tmp9 ;

  {
#line 117
  if (new_size == 0UL) {
#line 118
    return ((void *)0);
  }
  {
#line 124
  r_ptr = realloc(ptr, new_size);
  }
#line 127
  if (((size_t )r_ptr & (alignment - 1UL)) != 0UL) {
    {
#line 132
    __cil_tmp9 = opj_aligned_alloc_n(alignment, new_size);
#line 132
    a_ptr = __cil_tmp9;
    }
#line 133
    if ((unsigned long )a_ptr != (unsigned long )((void *)0)) {
      {
#line 134
      memcpy(a_ptr, (void const   *)r_ptr, new_size);
      }
    }
    {
#line 136
    free(r_ptr);
#line 137
    r_ptr = a_ptr;
    }
  }
#line 189
  return (r_ptr);
}
}
#line 191 "/root/patron/new_24/src/lib/openjp2/opj_malloc.c"
void *opj_malloc(size_t size ) 
{ 
  void *__cil_tmp2 ;

  {
#line 193
  if (size == 0UL) {
#line 194
    return ((void *)0);
  }
  {
#line 196
  __cil_tmp2 = malloc(size);
  }
#line 196
  return (__cil_tmp2);
}
}
#line 198 "/root/patron/new_24/src/lib/openjp2/opj_malloc.c"
void *opj_calloc(size_t num , size_t size ) 
{ 
  void *__cil_tmp3 ;

  {
#line 200
  if (num == 0UL) {
#line 202
    return ((void *)0);
  } else
#line 200
  if (size == 0UL) {
#line 202
    return ((void *)0);
  }
  {
#line 204
  __cil_tmp3 = calloc(num, size);
  }
#line 204
  return (__cil_tmp3);
}
}
#line 207 "/root/patron/new_24/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_malloc(size_t size ) 
{ 
  void *__cil_tmp2 ;

  {
  {
#line 209
  __cil_tmp2 = opj_aligned_alloc_n((size_t )16U, size);
  }
#line 209
  return (__cil_tmp2);
}
}
#line 211 "/root/patron/new_24/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_realloc(void *ptr , size_t size ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 213
  __cil_tmp3 = opj_aligned_realloc_n(ptr, (size_t )16U, size);
  }
#line 213
  return (__cil_tmp3);
}
}
#line 216 "/root/patron/new_24/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_32_malloc(size_t size ) 
{ 
  void *__cil_tmp2 ;

  {
  {
#line 218
  __cil_tmp2 = opj_aligned_alloc_n((size_t )32U, size);
  }
#line 218
  return (__cil_tmp2);
}
}
#line 220 "/root/patron/new_24/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_32_realloc(void *ptr , size_t size ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 222
  __cil_tmp3 = opj_aligned_realloc_n(ptr, (size_t )32U, size);
  }
#line 222
  return (__cil_tmp3);
}
}
#line 225 "/root/patron/new_24/src/lib/openjp2/opj_malloc.c"
void opj_aligned_free(void *ptr ) 
{ 


  {
  {
#line 228
  free(ptr);
  }
#line 230
  return;
}
}
#line 239 "/root/patron/new_24/src/lib/openjp2/opj_malloc.c"
void *opj_realloc(void *ptr , size_t new_size ) 
{ 
  void *__cil_tmp3 ;

  {
#line 241
  if (new_size == 0UL) {
#line 242
    return ((void *)0);
  }
  {
#line 244
  __cil_tmp3 = realloc(ptr, new_size);
  }
#line 244
  return (__cil_tmp3);
}
}
#line 246 "/root/patron/new_24/src/lib/openjp2/opj_malloc.c"
void opj_free(void *ptr ) 
{ 


  {
  {
#line 248
  free(ptr);
  }
#line 250
  return;
}
}
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 42 "/root/patron/new_24/src/lib/openjp2/opj_clock.c"
OPJ_FLOAT64 opj_clock(void) 
{ 
  struct rusage t ;
  OPJ_FLOAT64 procTime ;

  {
  {
#line 58
  getrusage(0, & t);
#line 61
  procTime = (OPJ_FLOAT64 )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 63
  return (procTime + (OPJ_FLOAT64 )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 44 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                        void * ) ,
                              void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 48
  l_codec = (opj_codec_private_t *)p_codec;
#line 49
  if (! l_codec) {
#line 50
    return (0);
  }
#line 53
  l_codec->m_event_mgr.info_handler = p_callback;
#line 54
  l_codec->m_event_mgr.m_info_data = p_user_data;
#line 56
  return (1);
}
}
#line 59 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                           void * ) ,
                                 void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 63
  l_codec = (opj_codec_private_t *)p_codec;
#line 64
  if (! l_codec) {
#line 65
    return (0);
  }
#line 68
  l_codec->m_event_mgr.warning_handler = p_callback;
#line 69
  l_codec->m_event_mgr.m_warning_data = p_user_data;
#line 71
  return (1);
}
}
#line 74 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                         void * ) ,
                               void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 78
  l_codec = (opj_codec_private_t *)p_codec;
#line 79
  if (! l_codec) {
#line 80
    return (0);
  }
#line 83
  l_codec->m_event_mgr.error_handler = p_callback;
#line 84
  l_codec->m_event_mgr.m_error_data = p_user_data;
#line 86
  return (1);
}
}
#line 91 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_read_from_file(void *p_buffer , OPJ_SIZE_T p_nb_bytes , FILE *p_file ) 
{ 
  OPJ_SIZE_T l_nb_read ;
  unsigned long __cil_tmp5 ;
  OPJ_SIZE_T tmp ;

  {
  {
#line 94
  __cil_tmp5 = fread(p_buffer, 1UL, p_nb_bytes, p_file);
#line 94
  l_nb_read = __cil_tmp5;
  }
#line 95
  if (l_nb_read) {
#line 95
    tmp = l_nb_read;
  } else {
#line 95
    tmp = (OPJ_SIZE_T )-1;
  }
#line 95
  return (tmp);
}
}
#line 98 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
static OPJ_UINT64 opj_get_data_length_from_file(FILE *p_file ) 
{ 
  OPJ_OFF_T file_length ;
  __off_t __cil_tmp3 ;

  {
  {
#line 100
  file_length = (OPJ_OFF_T )0;
#line 102
  fseeko(p_file, (__off_t )0, 2);
#line 103
  __cil_tmp3 = ftello(p_file);
#line 103
  file_length = __cil_tmp3;
#line 104
  fseeko(p_file, (__off_t )0, 0);
  }
#line 106
  return ((OPJ_UINT64 )file_length);
}
}
#line 109 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_write_from_file(void *p_buffer , OPJ_SIZE_T p_nb_bytes , FILE *p_file ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 112
  __cil_tmp4 = fwrite((void const   *)p_buffer, 1UL, p_nb_bytes, p_file);
  }
#line 112
  return (__cil_tmp4);
}
}
#line 115 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
static OPJ_OFF_T opj_skip_from_file(OPJ_OFF_T p_nb_bytes , FILE *p_user_data ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 117
  __cil_tmp3 = fseeko(p_user_data, p_nb_bytes, 1);
  }
#line 117
  if (__cil_tmp3) {
#line 118
    return ((OPJ_OFF_T )-1);
  }
#line 121
  return (p_nb_bytes);
}
}
#line 124 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
static OPJ_BOOL opj_seek_from_file(OPJ_OFF_T p_nb_bytes , FILE *p_user_data ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 126
  __cil_tmp3 = fseeko(p_user_data, p_nb_bytes, 0);
  }
#line 126
  if (__cil_tmp3) {
#line 127
    return (0);
  }
#line 130
  return (1);
}
}
#line 160 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
char const   *opj_version(void) 
{ 


  {
#line 162
  return ("2.2.0");
}
}
#line 168 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) 
{ 
  opj_codec_private_t *l_codec ;
  void *__cil_tmp3 ;
  opj_j2k_t *tmp ;
  opj_jp2_t *tmp___0 ;

  {
  {
#line 170
  l_codec = (opj_codec_private_t *)0;
#line 172
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_codec_private_t ));
#line 172
  l_codec = (opj_codec_private_t *)__cil_tmp3;
  }
#line 173
  if (! l_codec) {
#line 174
    return ((opj_codec_t *)0);
  }
#line 177
  l_codec->is_decompressor = 1;
#line 180
  if ((int )p_format == 0) {
#line 180
    goto case_0;
  }
#line 260
  if ((int )p_format == 2) {
#line 260
    goto case_2;
  }
#line 343
  goto switch_default;
  case_0: 
  {
#line 181
  l_codec->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& j2k_dump);
#line 183
  l_codec->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& j2k_get_cstr_info);
#line 186
  l_codec->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& j2k_get_cstr_index);
#line 189
  l_codec->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                   opj_image_t * ,
                                                                   struct opj_event_mgr * ))(& opj_j2k_decode);
#line 194
  l_codec->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                           struct opj_stream_private * ,
                                                                           struct opj_event_mgr * ))(& opj_j2k_end_decompress);
#line 199
  l_codec->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                        void * , opj_image_t ** ,
                                                                        struct opj_event_mgr * ))(& opj_j2k_read_header);
#line 205
  l_codec->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 208
  l_codec->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * , opj_dparameters_t * ))(& opj_j2k_setup_decoder);
#line 211
  l_codec->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_BOOL * ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_j2k_read_tile_header);
#line 222
  l_codec->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32  ,
                                                                             OPJ_BYTE * ,
                                                                             OPJ_UINT32  ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_j2k_decode_tile);
#line 230
  l_codec->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                            opj_image_t * ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            struct opj_event_mgr * ))(& opj_j2k_set_decode_area);
#line 236
  l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                             opj_stream_private_t * ,
                                                                             opj_image_t * ,
                                                                             struct opj_event_mgr * ,
                                                                             OPJ_UINT32  ))(& opj_j2k_get_tile);
#line 243
  l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                          OPJ_UINT32  ,
                                                                                          struct opj_event_mgr * ))(& opj_j2k_set_decoded_resolution_factor);
#line 248
  l_codec->opj_set_threads = (OPJ_BOOL (*)(void * , OPJ_UINT32  ))(& opj_j2k_set_threads);
#line 251
  tmp = opj_j2k_create_decompress();
#line 251
  l_codec->m_codec = (void *)tmp;
  }
#line 253
  if (! l_codec->m_codec) {
    {
#line 254
    opj_free((void *)l_codec);
    }
#line 255
    return ((opj_codec_t *)((void *)0));
  }
#line 258
  goto switch_break;
  case_2: 
  {
#line 262
  l_codec->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& jp2_dump);
#line 264
  l_codec->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& jp2_get_cstr_info);
#line 267
  l_codec->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& jp2_get_cstr_index);
#line 270
  l_codec->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                   opj_image_t * ,
                                                                   struct opj_event_mgr * ))(& opj_jp2_decode);
#line 276
  l_codec->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                           struct opj_stream_private * ,
                                                                           struct opj_event_mgr * ))(& opj_jp2_end_decompress);
#line 281
  l_codec->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                        void * , opj_image_t ** ,
                                                                        struct opj_event_mgr * ))(& opj_jp2_read_header);
#line 287
  l_codec->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_BOOL * ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_jp2_read_tile_header);
#line 300
  l_codec->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32  ,
                                                                             OPJ_BYTE * ,
                                                                             OPJ_UINT32  ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_jp2_decode_tile);
#line 306
  l_codec->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 309
  l_codec->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * , opj_dparameters_t * ))(& opj_jp2_setup_decoder);
#line 312
  l_codec->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                            opj_image_t * ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            struct opj_event_mgr * ))(& opj_jp2_set_decode_area);
#line 318
  l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                             opj_stream_private_t * ,
                                                                             opj_image_t * ,
                                                                             struct opj_event_mgr * ,
                                                                             OPJ_UINT32  ))(& opj_jp2_get_tile);
#line 325
  l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                          OPJ_UINT32  ,
                                                                                          opj_event_mgr_t * ))(& opj_jp2_set_decoded_resolution_factor);
#line 330
  l_codec->opj_set_threads = (OPJ_BOOL (*)(void * , OPJ_UINT32  ))(& opj_jp2_set_threads);
#line 333
  tmp___0 = opj_jp2_create(1);
#line 333
  l_codec->m_codec = (void *)tmp___0;
  }
#line 335
  if (! l_codec->m_codec) {
    {
#line 336
    opj_free((void *)l_codec);
    }
#line 337
    return ((opj_codec_t *)0);
  }
#line 340
  goto switch_break;
  switch_default: 
  {
#line 344
  opj_free((void *)l_codec);
  }
#line 345
  return ((opj_codec_t *)0);
  switch_break: 
  {
#line 348
  opj_set_default_event_handler(& l_codec->m_event_mgr);
  }
#line 349
  return ((opj_codec_t *)l_codec);
}
}
#line 352 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) 
{ 


  {
#line 355
  if (parameters) {
    {
#line 356
    memset((void *)parameters, 0, sizeof(opj_dparameters_t ));
#line 358
    parameters->cp_layer = (OPJ_UINT32 )0;
#line 359
    parameters->cp_reduce = (OPJ_UINT32 )0;
#line 361
    parameters->decod_format = -1;
#line 362
    parameters->cod_format = -1;
#line 363
    parameters->flags = 0U;
    }
  }
#line 366
  return;
}
}
#line 375 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_codec_set_threads(opj_codec_t *p_codec , int num_threads ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp4 ;

  {
#line 378
  if (p_codec) {
#line 378
    if (num_threads >= 0) {
      {
#line 379
      l_codec = (opj_codec_private_t *)p_codec;
#line 381
      __cil_tmp4 = (*(l_codec->opj_set_threads))(l_codec->m_codec, (OPJ_UINT32 )num_threads);
      }
#line 381
      return (__cil_tmp4);
    }
  }
#line 383
  return (0);
}
}
#line 386 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec , opj_dparameters_t *parameters ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 390
  if (p_codec) {
#line 390
    if (parameters) {
#line 391
      l_codec = (opj_codec_private_t *)p_codec;
#line 393
      if (! l_codec->is_decompressor) {
        {
#line 394
        opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_setup_decoder function is not a decompressor handler.\n\240\241\2011 V");
        }
#line 396
        return (0);
      }
      {
#line 399
      (*(l_codec->m_codec_data.m_decompression.opj_setup_decoder))(l_codec->m_codec,
                                                                   parameters);
      }
#line 401
      return (1);
    }
  }
#line 403
  return (0);
}
}
#line 406 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec , opj_image_t **p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 410
  if (p_codec) {
#line 410
    if (p_stream) {
#line 411
      l_codec = (opj_codec_private_t *)p_codec;
#line 412
      l_stream = (opj_stream_private_t *)p_stream;
#line 414
      if (! l_codec->is_decompressor) {
        {
#line 415
        opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_read_header function is not a decompressor handler.\n");
        }
#line 417
        return (0);
      }
      {
#line 420
      __cil_tmp6 = (*(l_codec->m_codec_data.m_decompression.opj_read_header))(l_stream,
                                                                              l_codec->m_codec,
                                                                              p_image,
                                                                              & l_codec->m_event_mgr);
      }
#line 420
      return (__cil_tmp6);
    }
  }
#line 426
  return (0);
}
}
#line 429 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 433
  if (p_codec) {
#line 433
    if (p_stream) {
#line 434
      l_codec = (opj_codec_private_t *)p_codec;
#line 435
      l_stream = (opj_stream_private_t *)p_stream;
#line 437
      if (! l_codec->is_decompressor) {
#line 438
        return (0);
      }
      {
#line 441
      __cil_tmp6 = (*(l_codec->m_codec_data.m_decompression.opj_decode))(l_codec->m_codec,
                                                                         l_stream,
                                                                         p_image,
                                                                         & l_codec->m_event_mgr);
      }
#line 441
      return (__cil_tmp6);
    }
  }
#line 447
  return (0);
}
}
#line 450 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                             OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 456
  if (p_codec) {
#line 457
    l_codec = (opj_codec_private_t *)p_codec;
#line 459
    if (! l_codec->is_decompressor) {
#line 460
      return (0);
    }
    {
#line 463
    __cil_tmp8 = (*(l_codec->m_codec_data.m_decompression.opj_set_decode_area))(l_codec->m_codec,
                                                                                p_image,
                                                                                p_start_x,
                                                                                p_start_y,
                                                                                p_end_x,
                                                                                p_end_y,
                                                                                & l_codec->m_event_mgr);
    }
#line 463
    return (__cil_tmp8);
  }
#line 470
  return (0);
}
}
#line 473 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec , opj_stream_t *p_stream , OPJ_UINT32 *p_tile_index ,
                              OPJ_UINT32 *p_data_size , OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 ,
                              OPJ_INT32 *p_tile_x1 , OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                              OPJ_BOOL *p_should_go_on ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp13 ;

  {
#line 482
  if (p_codec) {
#line 482
    if (p_stream) {
#line 482
      if (p_data_size) {
#line 482
        if (p_tile_index) {
#line 483
          l_codec = (opj_codec_private_t *)p_codec;
#line 484
          l_stream = (opj_stream_private_t *)p_stream;
#line 486
          if (! l_codec->is_decompressor) {
#line 487
            return (0);
          }
          {
#line 490
          __cil_tmp13 = (*(l_codec->m_codec_data.m_decompression.opj_read_tile_header))(l_codec->m_codec,
                                                                                        p_tile_index,
                                                                                        p_data_size,
                                                                                        p_tile_x0,
                                                                                        p_tile_y0,
                                                                                        p_tile_x1,
                                                                                        p_tile_y1,
                                                                                        p_nb_comps,
                                                                                        p_should_go_on,
                                                                                        l_stream,
                                                                                        & l_codec->m_event_mgr);
          }
#line 490
          return (__cil_tmp13);
        }
      }
    }
  }
#line 501
  return (0);
}
}
#line 504 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                              OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 511
  if (p_codec) {
#line 511
    if (p_data) {
#line 511
      if (p_stream) {
#line 512
        l_codec = (opj_codec_private_t *)p_codec;
#line 513
        l_stream = (opj_stream_private_t *)p_stream;
#line 515
        if (! l_codec->is_decompressor) {
#line 516
          return (0);
        }
        {
#line 519
        __cil_tmp8 = (*(l_codec->m_codec_data.m_decompression.opj_decode_tile_data))(l_codec->m_codec,
                                                                                     p_tile_index,
                                                                                     p_data,
                                                                                     p_data_size,
                                                                                     l_stream,
                                                                                     & l_codec->m_event_mgr);
        }
#line 519
        return (__cil_tmp8);
      }
    }
  }
#line 527
  return (0);
}
}
#line 530 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ,
                              OPJ_UINT32 tile_index ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 535
  if (p_codec) {
#line 535
    if (p_stream) {
#line 536
      l_codec = (opj_codec_private_t *)p_codec;
#line 537
      l_stream = (opj_stream_private_t *)p_stream;
#line 539
      if (! l_codec->is_decompressor) {
#line 540
        return (0);
      }
      {
#line 543
      __cil_tmp7 = (*(l_codec->m_codec_data.m_decompression.opj_get_decoded_tile))(l_codec->m_codec,
                                                                                   l_stream,
                                                                                   p_image,
                                                                                   & l_codec->m_event_mgr,
                                                                                   tile_index);
      }
#line 543
      return (__cil_tmp7);
    }
  }
#line 551
  return (0);
}
}
#line 554 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec , OPJ_UINT32 res_factor ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp4 ;

  {
#line 557
  l_codec = (opj_codec_private_t *)p_codec;
#line 559
  if (! l_codec) {
#line 560
    return (0);
  }
  {
#line 563
  __cil_tmp4 = (*(l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor))(l_codec->m_codec,
                                                                                            res_factor,
                                                                                            & l_codec->m_event_mgr);
  }
#line 563
  return (__cil_tmp4);
}
}
#line 572 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format ) 
{ 
  opj_codec_private_t *l_codec ;
  void *__cil_tmp3 ;
  opj_j2k_t *tmp ;
  opj_jp2_t *tmp___0 ;

  {
  {
#line 574
  l_codec = (opj_codec_private_t *)0;
#line 576
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_codec_private_t ));
#line 576
  l_codec = (opj_codec_private_t *)__cil_tmp3;
  }
#line 577
  if (! l_codec) {
#line 578
    return ((opj_codec_t *)0);
  }
#line 581
  l_codec->is_decompressor = 0;
#line 584
  if ((int )p_format == 0) {
#line 584
    goto case_0;
  }
#line 621
  if ((int )p_format == 2) {
#line 621
    goto case_2;
  }
#line 661
  goto switch_default;
  case_0: 
  {
#line 585
  l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                 struct opj_event_mgr * ))(& opj_j2k_encode);
#line 589
  l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       struct opj_event_mgr * ))(& opj_j2k_end_compress);
#line 593
  l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                         struct opj_stream_private * ,
                                                                         struct opj_image * ,
                                                                         struct opj_event_mgr * ))(& opj_j2k_start_compress);
#line 598
  l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * , OPJ_UINT32  ,
                                                                     OPJ_BYTE * ,
                                                                     OPJ_UINT32  ,
                                                                     struct opj_stream_private * ,
                                                                     struct opj_event_mgr * ))(& opj_j2k_write_tile);
#line 605
  l_codec->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 608
  l_codec->m_codec_data.m_compression.opj_setup_encoder = (OPJ_BOOL (*)(void * , opj_cparameters_t * ,
                                                                        struct opj_image * ,
                                                                        struct opj_event_mgr * ))(& opj_j2k_setup_encoder);
#line 613
  tmp = opj_j2k_create_compress();
#line 613
  l_codec->m_codec = (void *)tmp;
  }
#line 614
  if (! l_codec->m_codec) {
    {
#line 615
    opj_free((void *)l_codec);
    }
#line 616
    return ((opj_codec_t *)0);
  }
#line 619
  goto switch_break;
  case_2: 
  {
#line 623
  l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                 struct opj_event_mgr * ))(& opj_jp2_encode);
#line 627
  l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       struct opj_event_mgr * ))(& opj_jp2_end_compress);
#line 631
  l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                         struct opj_stream_private * ,
                                                                         struct opj_image * ,
                                                                         struct opj_event_mgr * ))(& opj_jp2_start_compress);
#line 636
  l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * , OPJ_UINT32  ,
                                                                     OPJ_BYTE * ,
                                                                     OPJ_UINT32  ,
                                                                     struct opj_stream_private * ,
                                                                     struct opj_event_mgr * ))(& opj_jp2_write_tile);
#line 643
  l_codec->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 646
  l_codec->m_codec_data.m_compression.opj_setup_encoder = (OPJ_BOOL (*)(void * , opj_cparameters_t * ,
                                                                        struct opj_image * ,
                                                                        struct opj_event_mgr * ))(& opj_jp2_setup_encoder);
#line 651
  tmp___0 = opj_jp2_create(0);
#line 651
  l_codec->m_codec = (void *)tmp___0;
  }
#line 652
  if (! l_codec->m_codec) {
    {
#line 653
    opj_free((void *)l_codec);
    }
#line 654
    return ((opj_codec_t *)0);
  }
#line 657
  goto switch_break;
  switch_default: 
  {
#line 662
  opj_free((void *)l_codec);
  }
#line 663
  return ((opj_codec_t *)0);
  switch_break: 
  {
#line 666
  opj_set_default_event_handler(& l_codec->m_event_mgr);
  }
#line 667
  return ((opj_codec_t *)l_codec);
}
}
#line 670 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 673
  if (parameters) {
    {
#line 674
    memset((void *)parameters, 0, sizeof(opj_cparameters_t ));
#line 676
    parameters->cp_cinema = (OPJ_CINEMA_MODE )0;
#line 677
    parameters->rsiz = (OPJ_UINT16 )0;
#line 678
    parameters->max_comp_size = 0;
#line 679
    parameters->numresolution = 6;
#line 680
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 681
    parameters->cblockw_init = 64;
#line 682
    parameters->cblockh_init = 64;
#line 683
    parameters->prog_order = (OPJ_PROG_ORDER )0;
#line 684
    parameters->roi_compno = -1;
#line 685
    parameters->subsampling_dx = 1;
#line 686
    parameters->subsampling_dy = 1;
#line 687
    parameters->tp_on = (char)0;
#line 688
    parameters->decod_format = -1;
#line 689
    parameters->cod_format = -1;
#line 690
    parameters->tcp_rates[0] = (float )0;
#line 691
    parameters->tcp_numlayers = 0;
#line 692
    parameters->cp_disto_alloc = 0;
#line 693
    parameters->cp_fixed_alloc = 0;
#line 694
    parameters->cp_fixed_quality = 0;
#line 695
    parameters->jpip_on = 0;
    }
  }
#line 698
  return;
}
}
#line 731 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec , opj_cparameters_t *parameters ,
                           opj_image_t *p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 735
  if (p_codec) {
#line 735
    if (parameters) {
#line 735
      if (p_image) {
#line 736
        l_codec = (opj_codec_private_t *)p_codec;
#line 738
        if (! l_codec->is_decompressor) {
          {
#line 739
          __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_setup_encoder))(l_codec->m_codec,
                                                                                  parameters,
                                                                                  p_image,
                                                                                  & l_codec->m_event_mgr);
          }
#line 739
          return (__cil_tmp5);
        }
      }
    }
  }
#line 746
  return (0);
}
}
#line 749 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec , opj_image_t *p_image , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 753
  if (p_codec) {
#line 753
    if (p_stream) {
#line 754
      l_codec = (opj_codec_private_t *)p_codec;
#line 755
      l_stream = (opj_stream_private_t *)p_stream;
#line 757
      if (! l_codec->is_decompressor) {
        {
#line 758
        __cil_tmp6 = (*(l_codec->m_codec_data.m_compression.opj_start_compress))(l_codec->m_codec,
                                                                                 l_stream,
                                                                                 p_image,
                                                                                 & l_codec->m_event_mgr);
        }
#line 758
        return (__cil_tmp6);
      }
    }
  }
#line 765
  return (0);
}
}
#line 768 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 770
  if (p_info) {
#line 770
    if (p_stream) {
#line 771
      l_codec = (opj_codec_private_t *)p_info;
#line 772
      l_stream = (opj_stream_private_t *)p_stream;
#line 774
      if (! l_codec->is_decompressor) {
        {
#line 775
        __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_encode))(l_codec->m_codec,
                                                                         l_stream,
                                                                         & l_codec->m_event_mgr);
        }
#line 775
        return (__cil_tmp5);
      }
    }
  }
#line 781
  return (0);
}
}
#line 785 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 788
  if (p_codec) {
#line 788
    if (p_stream) {
#line 789
      l_codec = (opj_codec_private_t *)p_codec;
#line 790
      l_stream = (opj_stream_private_t *)p_stream;
#line 792
      if (! l_codec->is_decompressor) {
        {
#line 793
        __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_end_compress))(l_codec->m_codec,
                                                                               l_stream,
                                                                               & l_codec->m_event_mgr);
        }
#line 793
        return (__cil_tmp5);
      }
    }
  }
#line 798
  return (0);
}
}
#line 802 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 805
  if (p_codec) {
#line 805
    if (p_stream) {
#line 806
      l_codec = (opj_codec_private_t *)p_codec;
#line 807
      l_stream = (opj_stream_private_t *)p_stream;
#line 809
      if (! l_codec->is_decompressor) {
#line 810
        return (0);
      }
      {
#line 813
      __cil_tmp5 = (*(l_codec->m_codec_data.m_decompression.opj_end_decompress))(l_codec->m_codec,
                                                                                 l_stream,
                                                                                 & l_codec->m_event_mgr);
      }
#line 813
      return (__cil_tmp5);
    }
  }
#line 819
  return (0);
}
}
#line 822 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) 
{ 
  OPJ_UINT32 l_matrix_size ;
  OPJ_UINT32 l_dc_shift_size ;
  OPJ_UINT32 l_mct_total_size ;

  {
#line 826
  l_matrix_size = (pNbComp * pNbComp) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 827
  l_dc_shift_size = pNbComp * (OPJ_UINT32 )sizeof(OPJ_INT32 );
#line 828
  l_mct_total_size = l_matrix_size + l_dc_shift_size;
#line 831
  if ((int )parameters->rsiz & 32768) {
#line 832
    parameters->rsiz = (OPJ_UINT16 )((int )parameters->rsiz | 256);
  } else {
#line 834
    parameters->rsiz = (OPJ_UINT16 )33024;
  }
  {
#line 836
  parameters->irreversible = 1;
#line 839
  parameters->tcp_mct = (char)2;
#line 840
  parameters->mct_data = opj_malloc((size_t )l_mct_total_size);
  }
#line 841
  if (! parameters->mct_data) {
#line 842
    return (0);
  }
  {
#line 845
  memcpy(parameters->mct_data, (void const   *)pEncodingMatrix, (unsigned long )l_matrix_size);
#line 846
  memcpy((void *)((OPJ_BYTE *)parameters->mct_data + l_matrix_size), (void const   *)p_dc_shift,
         (unsigned long )l_dc_shift_size);
  }
#line 849
  return (1);
}
}
#line 852 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                        OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 858
  if (p_codec) {
#line 858
    if (p_stream) {
#line 858
      if (p_data) {
#line 859
        l_codec = (opj_codec_private_t *)p_codec;
#line 860
        l_stream = (opj_stream_private_t *)p_stream;
#line 862
        if (l_codec->is_decompressor) {
#line 863
          return (0);
        }
        {
#line 866
        __cil_tmp8 = (*(l_codec->m_codec_data.m_compression.opj_write_tile))(l_codec->m_codec,
                                                                             p_tile_index,
                                                                             p_data,
                                                                             p_data_size,
                                                                             l_stream,
                                                                             & l_codec->m_event_mgr);
        }
#line 866
        return (__cil_tmp8);
      }
    }
  }
#line 874
  return (0);
}
}
#line 879 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
void opj_destroy_codec(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 881
  if (p_codec) {
#line 882
    l_codec = (opj_codec_private_t *)p_codec;
#line 884
    if (l_codec->is_decompressor) {
      {
#line 885
      (*(l_codec->m_codec_data.m_decompression.opj_destroy))(l_codec->m_codec);
      }
    } else {
      {
#line 887
      (*(l_codec->m_codec_data.m_compression.opj_destroy))(l_codec->m_codec);
      }
    }
    {
#line 890
    l_codec->m_codec = (void *)0;
#line 891
    opj_free((void *)l_codec);
    }
  }
#line 894
  return;
}
}
#line 897 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
void opj_dump_codec(opj_codec_t *p_codec , OPJ_INT32 info_flag , FILE *output_stream ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 901
  if (p_codec) {
    {
#line 902
    l_codec = (opj_codec_private_t *)p_codec;
#line 904
    (*(l_codec->opj_dump_codec))(l_codec->m_codec, info_flag, output_stream);
    }
#line 905
    return;
  }
#line 910
  return;
}
}
#line 913 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_codestream_info_v2_t *__cil_tmp3 ;

  {
#line 915
  if (p_codec) {
    {
#line 916
    l_codec = (opj_codec_private_t *)p_codec;
#line 918
    __cil_tmp3 = (*(l_codec->opj_get_codec_info))(l_codec->m_codec);
    }
#line 918
    return (__cil_tmp3);
  }
#line 921
  return ((opj_codestream_info_v2_t *)((void *)0));
}
}
#line 924 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) 
{ 


  {
#line 926
  if (cstr_info) {
#line 928
    if ((*cstr_info)->m_default_tile_info.tccp_info) {
      {
#line 929
      opj_free((void *)(*cstr_info)->m_default_tile_info.tccp_info);
      }
    }
    {
#line 936
    opj_free((void *)*cstr_info);
#line 937
    *cstr_info = (opj_codestream_info_v2_t *)((void *)0);
    }
  }
#line 940
  return;
}
}
#line 941 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_codestream_index_t *__cil_tmp3 ;

  {
#line 943
  if (p_codec) {
    {
#line 944
    l_codec = (opj_codec_private_t *)p_codec;
#line 946
    __cil_tmp3 = (*(l_codec->opj_get_codec_index))(l_codec->m_codec);
    }
#line 946
    return (__cil_tmp3);
  }
#line 949
  return ((opj_codestream_index_t *)((void *)0));
}
}
#line 952 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) 
{ 


  {
#line 954
  if (*p_cstr_index) {
    {
#line 955
    j2k_destroy_cstr_index(*p_cstr_index);
#line 956
    *p_cstr_index = (opj_codestream_index_t *)((void *)0);
    }
  }
#line 959
  return;
}
}
#line 960 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_default_file_stream(char const   *fname , OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *__cil_tmp3 ;

  {
  {
#line 963
  __cil_tmp3 = opj_stream_create_file_stream(fname, (OPJ_SIZE_T )1048576, p_is_read_stream);
  }
#line 963
  return (__cil_tmp3);
}
}
#line 967 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_file_stream(char const   *fname , OPJ_SIZE_T p_size ,
                                            OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *l_stream ;
  FILE *p_file ;
  char const   *mode ;
  OPJ_UINT64 __cil_tmp9 ;

  {
#line 972
  l_stream = (opj_stream_t *)0;
#line 976
  if (! fname) {
#line 977
    return ((opj_stream_t *)((void *)0));
  }
#line 980
  if (p_is_read_stream) {
    {
#line 981
    strcpy((char *)mode, "rb");
    }
  } else {
    {
#line 983
    strcpy((char *)mode, "wbg1 V");
    }
  }
  {
#line 986
  p_file = fopen(fname, mode);
  }
#line 988
  if (! p_file) {
#line 989
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 992
  l_stream = opj_stream_create(p_size, p_is_read_stream);
  }
#line 993
  if (! l_stream) {
    {
#line 994
    fclose(p_file);
    }
#line 995
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 998
  opj_stream_set_user_data(l_stream, (void *)p_file, (void (*)(void * ))(& fclose));
#line 1000
  __cil_tmp9 = opj_get_data_length_from_file(p_file);
#line 1000
  opj_stream_set_user_data_length(l_stream, __cil_tmp9);
#line 1002
  opj_stream_set_read_function(l_stream, (OPJ_SIZE_T (*)(void * , OPJ_SIZE_T  , void * ))(& opj_read_from_file));
#line 1003
  opj_stream_set_write_function(l_stream, (OPJ_SIZE_T (*)(void * , OPJ_SIZE_T  , void * ))(& opj_write_from_file));
#line 1005
  opj_stream_set_skip_function(l_stream, (OPJ_OFF_T (*)(OPJ_OFF_T  , void * ))(& opj_skip_from_file));
#line 1006
  opj_stream_set_seek_function(l_stream, (OPJ_BOOL (*)(OPJ_OFF_T  , void * ))(& opj_seek_from_file));
  }
#line 1008
  return (l_stream);
}
}
#line 1012 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
void *opj_image_data_alloc(OPJ_SIZE_T size ) 
{ 
  void *ret ;
  void *__cil_tmp3 ;

  {
  {
#line 1014
  __cil_tmp3 = opj_aligned_malloc(size);
#line 1014
  ret = __cil_tmp3;
  }
#line 1016
  return (ret);
}
}
#line 1019 "/root/patron/new_24/src/lib/openjp2/openjpeg.c"
void opj_image_data_free(void *ptr ) 
{ 


  {
  {
#line 1022
  opj_aligned_free(ptr);
  }
#line 1024
  return;
}
}
#line 54 "/root/patron/new_24/src/lib/openjp2/mqc.c"
static void opj_mqc_byteout(opj_mqc_t *mqc ) ;
#line 59
static void opj_mqc_renorme(opj_mqc_t *mqc ) ;
#line 64
static void opj_mqc_codemps(opj_mqc_t *mqc ) ;
#line 69
static void opj_mqc_codelps(opj_mqc_t *mqc ) ;
#line 74
static void opj_mqc_setbits(opj_mqc_t *mqc ) ;
#line 82 "/root/patron/new_24/src/lib/openjp2/mqc.c"
static opj_mqc_state_t mqc_states[94]  = 
#line 82
  {      {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[2], & mqc_states[3]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[3], & mqc_states[2]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[4], & mqc_states[12]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[5], & mqc_states[13]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[6], & mqc_states[18]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[7], & mqc_states[19]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[8], & mqc_states[24]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[9], & mqc_states[25]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[10], & mqc_states[58]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[11], & mqc_states[59]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[66]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[67]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[14], & mqc_states[13]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[15], & mqc_states[12]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[16], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[17], & mqc_states[29]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[18], & mqc_states[28]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[19], & mqc_states[29]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[20], & mqc_states[28]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[21], & mqc_states[29]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[22], & mqc_states[34]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[23], & mqc_states[35]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[24], & mqc_states[36]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[25], & mqc_states[37]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[26], & mqc_states[40]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[27], & mqc_states[41]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[42]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[43]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[30], & mqc_states[29]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[31], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[32], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[33], & mqc_states[29]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )0, & mqc_states[34], & mqc_states[30]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )1, & mqc_states[35], & mqc_states[31]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[36], & mqc_states[32]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[37], & mqc_states[33]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[38], & mqc_states[34]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[39], & mqc_states[35]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[40], & mqc_states[36]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[41], & mqc_states[37]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[42], & mqc_states[38]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[43], & mqc_states[39]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )0, & mqc_states[44], & mqc_states[38]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )1, & mqc_states[45], & mqc_states[39]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[46], & mqc_states[40]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[47], & mqc_states[41]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )0, & mqc_states[48], & mqc_states[42]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )1, & mqc_states[49], & mqc_states[43]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[50], & mqc_states[44]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[51], & mqc_states[45]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[52], & mqc_states[46]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[53], & mqc_states[47]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[54], & mqc_states[48]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[55], & mqc_states[49]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )0, & mqc_states[56], & mqc_states[50]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )1, & mqc_states[57], & mqc_states[51]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[52]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[53]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )0, & mqc_states[60], & mqc_states[54]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )1, & mqc_states[61], & mqc_states[55]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[62], & mqc_states[56]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[63], & mqc_states[57]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )0, & mqc_states[64], & mqc_states[58]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )1, & mqc_states[65], & mqc_states[59]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )0, & mqc_states[66], & mqc_states[60]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )1, & mqc_states[67], & mqc_states[61]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[68], & mqc_states[62]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[69], & mqc_states[63]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )0, & mqc_states[70], & mqc_states[64]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )1, & mqc_states[71], & mqc_states[65]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )0, & mqc_states[72], & mqc_states[66]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )1, & mqc_states[73], & mqc_states[67]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[74], & mqc_states[68]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[75], & mqc_states[69]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[70]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[71]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )0, & mqc_states[78], & mqc_states[72]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )1, & mqc_states[79], & mqc_states[73]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )0, & mqc_states[80], & mqc_states[74]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )1, & mqc_states[81], & mqc_states[75]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )0, & mqc_states[82], & mqc_states[76]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )1, & mqc_states[83], & mqc_states[77]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )0, & mqc_states[84], & mqc_states[78]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )1, & mqc_states[85], & mqc_states[79]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )0, & mqc_states[86], & mqc_states[80]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )1, & mqc_states[87], & mqc_states[81]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )0, & mqc_states[88], & mqc_states[82]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )1, & mqc_states[89], & mqc_states[83]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[84]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[85]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[86]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[87]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[92], & mqc_states[92]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[93], & mqc_states[93]}};
#line 185 "/root/patron/new_24/src/lib/openjp2/mqc.c"
static void opj_mqc_byteout(opj_mqc_t *mqc ) 
{ 


  {
#line 190
  if ((int )*(mqc->bp) == 255) {
#line 191
    (mqc->bp) ++;
#line 192
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 193
    mqc->c &= 1048575U;
#line 194
    mqc->ct = (OPJ_UINT32 )7;
  } else
#line 196
  if ((mqc->c & 134217728U) == 0U) {
#line 197
    (mqc->bp) ++;
#line 198
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 199
    mqc->c &= 524287U;
#line 200
    mqc->ct = (OPJ_UINT32 )8;
  } else {
#line 202
    *(mqc->bp) = (OPJ_BYTE )((int )*(mqc->bp) + 1);
#line 203
    if ((int )*(mqc->bp) == 255) {
#line 204
      mqc->c &= 134217727U;
#line 205
      (mqc->bp) ++;
#line 206
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 207
      mqc->c &= 1048575U;
#line 208
      mqc->ct = (OPJ_UINT32 )7;
    } else {
#line 210
      (mqc->bp) ++;
#line 211
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 212
      mqc->c &= 524287U;
#line 213
      mqc->ct = (OPJ_UINT32 )8;
    }
  }
#line 216
  return;
}
}
#line 219 "/root/patron/new_24/src/lib/openjp2/mqc.c"
static void opj_mqc_renorme(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    mqc->a <<= 1;
#line 223
    mqc->c <<= 1;
#line 224
    __cil_tmp2 = mqc->ct;
#line 224
    (mqc->ct) --;
#line 225
    if (mqc->ct == 0U) {
      {
#line 226
      opj_mqc_byteout(mqc);
      }
    }
#line 221
    if (! ((mqc->a & 32768U) == 0U)) {
#line 221
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 226
  return;
}
}
#line 231 "/root/patron/new_24/src/lib/openjp2/mqc.c"
static void opj_mqc_codemps(opj_mqc_t *mqc ) 
{ 


  {
#line 233
  mqc->a -= (*(mqc->curctx))->qeval;
#line 234
  if ((mqc->a & 32768U) == 0U) {
#line 235
    if (mqc->a < (*(mqc->curctx))->qeval) {
#line 236
      mqc->a = (*(mqc->curctx))->qeval;
    } else {
#line 238
      mqc->c += (*(mqc->curctx))->qeval;
    }
    {
#line 240
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
#line 241
    opj_mqc_renorme(mqc);
    }
  } else {
#line 243
    mqc->c += (*(mqc->curctx))->qeval;
  }
#line 245
  return;
}
}
#line 247 "/root/patron/new_24/src/lib/openjp2/mqc.c"
static void opj_mqc_codelps(opj_mqc_t *mqc ) 
{ 


  {
#line 249
  mqc->a -= (*(mqc->curctx))->qeval;
#line 250
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 251
    mqc->c += (*(mqc->curctx))->qeval;
  } else {
#line 253
    mqc->a = (*(mqc->curctx))->qeval;
  }
  {
#line 255
  *(mqc->curctx) = (*(mqc->curctx))->nlps;
#line 256
  opj_mqc_renorme(mqc);
  }
#line 258
  return;
}
}
#line 259 "/root/patron/new_24/src/lib/openjp2/mqc.c"
static void opj_mqc_setbits(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 tempc ;

  {
#line 261
  tempc = mqc->c + mqc->a;
#line 262
  mqc->c |= 65535U;
#line 263
  if (mqc->c >= tempc) {
#line 264
    mqc->c -= 32768U;
  }
#line 266
  return;
}
}
#line 274 "/root/patron/new_24/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc ) 
{ 
  ptrdiff_t diff ;

  {
#line 276
  diff = mqc->bp - mqc->start;
#line 280
  return ((OPJ_UINT32 )diff);
}
}
#line 283 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_init_enc(opj_mqc_t *mqc , OPJ_BYTE *bp ) 
{ 


  {
#line 287
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 291
  mqc->a = (OPJ_UINT32 )32768;
#line 292
  mqc->c = (OPJ_UINT32 )0;
#line 295
  mqc->bp = bp - 1;
#line 296
  mqc->ct = (OPJ_UINT32 )12;
#line 302
  mqc->start = bp;
#line 303
  mqc->end_of_byte_stream_counter = (OPJ_UINT32 )0;
#line 304
  return;
}
}
#line 306 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_encode(opj_mqc_t *mqc , OPJ_UINT32 d ) 
{ 


  {
#line 308
  if ((*(mqc->curctx))->mps == d) {
    {
#line 309
    opj_mqc_codemps(mqc);
    }
  } else {
    {
#line 311
    opj_mqc_codelps(mqc);
    }
  }
#line 314
  return;
}
}
#line 315 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_flush(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 319
  opj_mqc_setbits(mqc);
#line 320
  mqc->c <<= mqc->ct;
#line 321
  opj_mqc_byteout(mqc);
#line 322
  mqc->c <<= mqc->ct;
#line 323
  opj_mqc_byteout(mqc);
  }
#line 326
  if ((int )*(mqc->bp) != 255) {
#line 328
    (mqc->bp) ++;
  }
#line 330
  return;
}
}
#line 334 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc ) 
{ 


  {
#line 340
  mqc->c = (OPJ_UINT32 )0;
#line 346
  mqc->ct = 3735928559U;
#line 347
  return;
}
}
#line 352 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_enc(opj_mqc_t *mqc , OPJ_UINT32 d ) 
{ 
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 354
  if (mqc->ct == 3735928559U) {
#line 355
    mqc->ct = (OPJ_UINT32 )8;
  }
#line 357
  __cil_tmp3 = mqc->ct;
#line 357
  (mqc->ct) --;
#line 358
  mqc->c += d << mqc->ct;
#line 359
  if (mqc->ct == 0U) {
#line 360
    *(mqc->bp) = (OPJ_BYTE )mqc->c;
#line 361
    mqc->ct = (OPJ_UINT32 )8;
#line 363
    if ((int )*(mqc->bp) == 255) {
#line 364
      mqc->ct = (OPJ_UINT32 )7;
    }
#line 366
    (mqc->bp) ++;
#line 367
    mqc->c = (OPJ_UINT32 )0;
  }
#line 369
  return;
}
}
#line 371 "/root/patron/new_24/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_bypass_get_extra_bytes(opj_mqc_t *mqc , OPJ_BOOL erterm ) 
{ 
  int tmp ;

  {
#line 373
  if (mqc->ct < 7U) {
#line 373
    tmp = 1;
  } else
#line 373
  if (mqc->ct == 7U) {
#line 373
    if (erterm) {
#line 373
      tmp = 1;
    } else
#line 373
    if ((int )*(mqc->bp + -1) != 255) {
#line 373
      tmp = 1;
    } else {
#line 373
      tmp = 0;
    }
  } else {
#line 373
    tmp = 0;
  }
#line 373
  return ((OPJ_UINT32 )tmp);
}
}
#line 377 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_flush_enc(opj_mqc_t *mqc , OPJ_BOOL erterm ) 
{ 
  OPJ_BYTE bit_value ;
  OPJ_UINT32 __cil_tmp4 ;
  OPJ_BYTE *__cil_tmp7 ;

  {
#line 385
  if (mqc->ct < 7U) {
    _L___8: 
#line 386
    bit_value = (OPJ_BYTE )0;
    {
#line 391
    while (1) {
      while_continue: /* CIL Label */ ;

#line 391
      if (! (mqc->ct > 0U)) {
#line 391
        goto while_break;
      }
#line 392
      __cil_tmp4 = mqc->ct;
#line 392
      (mqc->ct) --;
#line 393
      mqc->c += (OPJ_UINT32 )((int )bit_value << mqc->ct);
#line 394
      bit_value = (OPJ_BYTE )(1U - (unsigned int )bit_value);
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 396
    *(mqc->bp) = (OPJ_BYTE )mqc->c;
#line 398
    (mqc->bp) ++;
  } else
#line 385
  if (mqc->ct == 7U) {
#line 385
    if (erterm) {
#line 385
      goto _L___8;
    } else
#line 385
    if ((int )*(mqc->bp + -1) != 255) {
#line 385
      goto _L___8;
    } else {
#line 385
      goto _L___9;
    }
  } else
  _L___9: 
#line 399
  if (mqc->ct == 7U) {
#line 399
    if ((int )*(mqc->bp + -1) == 255) {
#line 402
      __cil_tmp7 = mqc->bp;
#line 402
      (mqc->bp) --;
    } else {
#line 399
      goto _L;
    }
  } else
  _L: 
#line 403
  if (mqc->ct == 8U) {
#line 403
    if (! erterm) {
#line 403
      if ((int )*(mqc->bp + -1) == 127) {
#line 403
        if ((int )*(mqc->bp + -2) == 255) {
#line 409
          mqc->bp -= 2;
        }
      }
    }
  }
#line 414
  return;
}
}
#line 415 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_reset_enc(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 417
  opj_mqc_resetstates(mqc);
#line 418
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 419
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 420
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
  }
#line 422
  return;
}
}
#line 442 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_restart_init_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE *__cil_tmp2 ;

  {
#line 448
  mqc->a = (OPJ_UINT32 )32768;
#line 449
  mqc->c = (OPJ_UINT32 )0;
#line 450
  mqc->ct = (OPJ_UINT32 )12;
#line 454
  __cil_tmp2 = mqc->bp;
#line 454
  (mqc->bp) --;
#line 457
  if ((int )*(mqc->bp) == 255) {
#line 458
    mqc->ct = (OPJ_UINT32 )13;
  }
#line 460
  return;
}
}
#line 462 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_erterm_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 k ;

  {
#line 464
  k = (OPJ_INT32 )((11U - mqc->ct) + 1U);
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;

#line 466
    if (! (k > 0)) {
#line 466
      goto while_break;
    }
    {
#line 467
    mqc->c <<= mqc->ct;
#line 468
    mqc->ct = (OPJ_UINT32 )0;
#line 469
    opj_mqc_byteout(mqc);
#line 470
    k -= (OPJ_INT32 )mqc->ct;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 473
  if ((int )*(mqc->bp) != 255) {
    {
#line 474
    opj_mqc_byteout(mqc);
    }
  }
#line 477
  return;
}
}
#line 478 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_segmark_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 i ;

  {
#line 481
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 483
  i = (OPJ_UINT32 )1;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;

#line 483
    if (! (i < 5U)) {
#line 483
      goto while_break;
    }
    {
#line 484
    opj_mqc_encode(mqc, i % 2U);
#line 483
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 487
  return;
}
}
#line 488 "/root/patron/new_24/src/lib/openjp2/mqc.c"
static void opj_mqc_init_dec_common(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len ,
                                    OPJ_UINT32 extra_writable_bytes ) 
{ 


  {
  {
#line 496
  mqc->start = bp;
#line 497
  mqc->end = bp + len;
#line 502
  memcpy((void *)(mqc->backup), (void const   *)mqc->end, 2UL);
#line 503
  *(mqc->end + 0) = (OPJ_BYTE )255;
#line 504
  *(mqc->end + 1) = (OPJ_BYTE )255;
#line 505
  mqc->bp = bp;
  }
#line 507
  return;
}
}
#line 507 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len , OPJ_UINT32 extra_writable_bytes ) 
{ 


  {
  {
#line 515
  opj_mqc_init_dec_common(mqc, bp, len, extra_writable_bytes);
#line 516
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 517
  mqc->end_of_byte_stream_counter = (OPJ_UINT32 )0;
  }
#line 518
  if (len == 0U) {
#line 519
    mqc->c = (OPJ_UINT32 )(255 << 16);
  } else {
#line 521
    mqc->c = (OPJ_UINT32 )((int )*(mqc->bp) << 16);
  }
  {
#line 524
  opj_mqc_bytein(mqc);
#line 525
  mqc->c <<= 7;
#line 526
  mqc->ct -= 7U;
#line 527
  mqc->a = (OPJ_UINT32 )32768;
  }
#line 529
  return;
}
}
#line 531 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_raw_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len , OPJ_UINT32 extra_writable_bytes ) 
{ 


  {
  {
#line 534
  opj_mqc_init_dec_common(mqc, bp, len, extra_writable_bytes);
#line 535
  mqc->c = (OPJ_UINT32 )0;
#line 536
  mqc->ct = (OPJ_UINT32 )0;
  }
#line 538
  return;
}
}
#line 540 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opq_mqc_finish_dec(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 543
  memcpy((void *)mqc->end, (void const   *)(mqc->backup), 2UL);
  }
#line 545
  return;
}
}
#line 546 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_resetstates(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 i ;

  {
#line 549
  i = (OPJ_UINT32 )0;
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;

#line 549
    if (! (i < 19U)) {
#line 549
      goto while_break;
    }
#line 550
    mqc->ctxs[i] = mqc_states;
#line 549
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 553
  return;
}
}
#line 554 "/root/patron/new_24/src/lib/openjp2/mqc.c"
void opj_mqc_setstate(opj_mqc_t *mqc , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) 
{ 


  {
#line 557
  mqc->ctxs[ctxno] = & mqc_states[msb + (OPJ_UINT32 )(prob << 1)];
#line 558
  return;
}
}
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 55 "/root/patron/new_24/src/lib/openjp2/mct.c"
static OPJ_FLOAT64 opj_mct_norms[3]  = {      1.732,      0.829200000001,      0.829200000001};
#line 60 "/root/patron/new_24/src/lib/openjp2/mct.c"
static OPJ_FLOAT64 opj_mct_norms_real[3]  = {      1.732,      1.805,      1.573};
#line 62 "/root/patron/new_24/src/lib/openjp2/mct.c"
OPJ_FLOAT64 *opj_mct_get_mct_norms(void) 
{ 


  {
#line 64
  return (opj_mct_norms);
}
}
#line 67 "/root/patron/new_24/src/lib/openjp2/mct.c"
OPJ_FLOAT64 *opj_mct_get_mct_norms_real(void) 
{ 


  {
#line 69
  return (opj_mct_norms_real);
}
}
#line 76 "/root/patron/new_24/src/lib/openjp2/mct.c"
void opj_mct_encode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  __m128i y ;
  __m128i u ;
  __m128i v ;
  __m128i r ;
  __m128i __cil_tmp14 ;
  __m128i g ;
  __m128i __cil_tmp16 ;
  __m128i b ;
  __m128i __cil_tmp18 ;
  OPJ_INT32 r___0 ;
  OPJ_INT32 g___0 ;
  OPJ_INT32 b___0 ;
  OPJ_INT32 y___0 ;
  OPJ_INT32 u___0 ;
  OPJ_INT32 v___0 ;

  {
#line 83
  len = n;
#line 89
  i = (OPJ_SIZE_T )0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;

#line 89
    if (! (i < (len & 4294967292UL))) {
#line 89
      goto while_break;
    }
    {
#line 91
    __cil_tmp14 = _mm_load_si128(c0 + i);
#line 91
    r = __cil_tmp14;
#line 92
    __cil_tmp16 = _mm_load_si128(c1 + i);
#line 92
    g = __cil_tmp16;
#line 93
    __cil_tmp18 = _mm_load_si128(c2 + i);
#line 93
    b = __cil_tmp18;
#line 94
    y = _mm_add_epi32(g, g);
#line 95
    y = _mm_add_epi32(y, b);
#line 96
    y = _mm_add_epi32(y, r);
#line 97
    y = _mm_srai_epi32(y, 2);
#line 98
    u = _mm_sub_epi32(b, g);
#line 99
    v = _mm_sub_epi32(r, g);
#line 100
    _mm_store_si128(c0 + i, y);
#line 101
    _mm_store_si128(c1 + i, u);
#line 102
    _mm_store_si128(c2 + i, v);
#line 89
    i += 4UL;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 105
    if (! (i < len)) {
#line 105
      goto while_break___0;
    }
#line 106
    r___0 = *(c0 + i);
#line 107
    g___0 = *(c1 + i);
#line 108
    b___0 = *(c2 + i);
#line 109
    y___0 = ((r___0 + g___0 * 2) + b___0) >> 2;
#line 110
    u___0 = b___0 - g___0;
#line 111
    v___0 = r___0 - g___0;
#line 112
    *(c0 + i) = y___0;
#line 113
    *(c1 + i) = u___0;
#line 114
    *(c2 + i) = v___0;
#line 105
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 109
  return;
}
}
#line 145 "/root/patron/new_24/src/lib/openjp2/mct.c"
void opj_mct_decode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  __m128i r ;
  __m128i g ;
  __m128i b ;
  __m128i y ;
  __m128i __cil_tmp11 ;
  __m128i u ;
  __m128i __cil_tmp13 ;
  __m128i v ;
  __m128i __cil_tmp15 ;
  __m128i __cil_tmp16 ;
  __m128i __cil_tmp17 ;
  __m128i __cil_tmp18 ;
  OPJ_INT32 y___0 ;
  OPJ_INT32 u___0 ;
  OPJ_INT32 v___0 ;
  OPJ_INT32 g___0 ;
  OPJ_INT32 r___0 ;
  OPJ_INT32 b___0 ;

  {
#line 152
  len = n;
#line 154
  i = (OPJ_SIZE_T )0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;

#line 154
    if (! (i < (len & 4294967292UL))) {
#line 154
      goto while_break;
    }
    {
#line 156
    __cil_tmp11 = _mm_load_si128(c0 + i);
#line 156
    y = __cil_tmp11;
#line 157
    __cil_tmp13 = _mm_load_si128(c1 + i);
#line 157
    u = __cil_tmp13;
#line 158
    __cil_tmp15 = _mm_load_si128(c2 + i);
#line 158
    v = __cil_tmp15;
#line 159
    g = y;
#line 160
    __cil_tmp16 = _mm_add_epi32(u, v);
#line 160
    __cil_tmp17 = _mm_srai_epi32(__cil_tmp16, 2);
#line 160
    __cil_tmp18 = _mm_sub_epi32(g, __cil_tmp17);
#line 160
    g = __cil_tmp18;
#line 161
    r = _mm_add_epi32(v, g);
#line 162
    b = _mm_add_epi32(u, g);
#line 163
    _mm_store_si128(c0 + i, r);
#line 164
    _mm_store_si128(c1 + i, g);
#line 165
    _mm_store_si128(c2 + i, b);
#line 154
    i += 4UL;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 167
    if (! (i < len)) {
#line 167
      goto while_break___0;
    }
#line 168
    y___0 = *(c0 + i);
#line 169
    u___0 = *(c1 + i);
#line 170
    v___0 = *(c2 + i);
#line 171
    g___0 = y___0 - ((u___0 + v___0) >> 2);
#line 172
    r___0 = v___0 + g___0;
#line 173
    b___0 = u___0 + g___0;
#line 174
    *(c0 + i) = r___0;
#line 175
    *(c1 + i) = g___0;
#line 176
    *(c2 + i) = b___0;
#line 167
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 171
  return;
}
}
#line 204 "/root/patron/new_24/src/lib/openjp2/mct.c"
OPJ_FLOAT64 opj_mct_getnorm(OPJ_UINT32 compno ) 
{ 


  {
#line 206
  return (opj_mct_norms[compno]);
}
}
#line 358 "/root/patron/new_24/src/lib/openjp2/mct.c"
void opj_mct_encode_real(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) 
{ 
  OPJ_UINT32 i ;
  OPJ_INT32 r ;
  OPJ_INT32 g ;
  OPJ_INT32 b ;
  OPJ_INT32 y ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_INT32 __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 u ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 v ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_INT32 __cil_tmp20 ;

  {
#line 365
  i = (OPJ_UINT32 )0;
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;

#line 365
    if (! ((unsigned long )i < n)) {
#line 365
      goto while_break;
    }
    {
#line 366
    r = *(c0 + i);
#line 367
    g = *(c1 + i);
#line 368
    b = *(c2 + i);
#line 369
    __cil_tmp12 = opj_int_fix_mul(b, 934);
#line 369
    __cil_tmp11 = opj_int_fix_mul(g, 4809);
#line 369
    __cil_tmp10 = opj_int_fix_mul(r, 2449);
#line 369
    y = (__cil_tmp10 + __cil_tmp11) + __cil_tmp12;
#line 371
    __cil_tmp16 = opj_int_fix_mul(b, 4096);
#line 371
    __cil_tmp15 = opj_int_fix_mul(g, 2714);
#line 371
    __cil_tmp14 = opj_int_fix_mul(r, 1382);
#line 371
    u = (- __cil_tmp14 - __cil_tmp15) + __cil_tmp16;
#line 373
    __cil_tmp20 = opj_int_fix_mul(b, 666);
#line 373
    __cil_tmp19 = opj_int_fix_mul(g, 3430);
#line 373
    __cil_tmp18 = opj_int_fix_mul(r, 4096);
#line 373
    v = (__cil_tmp18 - __cil_tmp19) - __cil_tmp20;
#line 375
    *(c0 + i) = y;
#line 376
    *(c1 + i) = u;
#line 377
    *(c2 + i) = v;
#line 365
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 369
  return;
}
}
#line 385 "/root/patron/new_24/src/lib/openjp2/mct.c"
void opj_mct_decode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 , OPJ_SIZE_T n ) 
{ 
  OPJ_UINT32 i ;
  __m128 vrv ;
  __m128 vgu ;
  __m128 vgv ;
  __m128 vbu ;
  __m128 vy ;
  __m128 vu ;
  __m128 vv ;
  __m128 vr ;
  __m128 vg ;
  __m128 vb ;
  __m128 __cil_tmp23 ;
  __m128 __cil_tmp24 ;
  __m128 __cil_tmp25 ;
  __m128 __cil_tmp26 ;
  __m128 __cil_tmp27 ;
  __m128 __cil_tmp28 ;
  __m128 __cil_tmp29 ;
  __m128 __cil_tmp30 ;
  __m128 __cil_tmp34 ;
  __m128 __cil_tmp35 ;
  __m128 __cil_tmp36 ;
  __m128 __cil_tmp37 ;
  __m128 __cil_tmp38 ;
  __m128 __cil_tmp39 ;
  __m128 __cil_tmp40 ;
  __m128 __cil_tmp41 ;
  OPJ_FLOAT32 y ;
  OPJ_FLOAT32 u ;
  OPJ_FLOAT32 v ;
  OPJ_FLOAT32 r ;
  OPJ_FLOAT32 g ;
  OPJ_FLOAT32 b ;

  {
  {
#line 394
  vrv = _mm_set_ss(1.40199995041f);
#line 395
  vgu = _mm_set_ss(0.344130009413f);
#line 396
  vgv = _mm_set_ss(0.71413999796f);
#line 397
  vbu = _mm_set_ss(1.77199995518f);
#line 398
  i = (OPJ_UINT32 )0;
  }
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;

#line 398
    if (! ((unsigned long )i < n >> 3)) {
#line 398
      goto while_break;
    }
    {
#line 402
    vy = _mm_load_ps((float const   *)c0);
#line 403
    vu = _mm_load_ps((float const   *)c1);
#line 404
    vv = _mm_load_ps((float const   *)c2);
#line 405
    __cil_tmp23 = _mm_mul_ps(vv, vrv);
#line 405
    __cil_tmp24 = _mm_add_ps(vy, __cil_tmp23);
#line 405
    vr = __cil_tmp24;
#line 406
    __cil_tmp25 = _mm_mul_ps(vu, vgu);
#line 406
    __cil_tmp26 = _mm_sub_ps(vy, __cil_tmp25);
#line 406
    __cil_tmp27 = _mm_mul_ps(vv, vgv);
#line 406
    __cil_tmp28 = _mm_sub_ps(__cil_tmp26, __cil_tmp27);
#line 406
    vg = __cil_tmp28;
#line 407
    __cil_tmp29 = _mm_mul_ps(vu, vbu);
#line 407
    __cil_tmp30 = _mm_add_ps(vy, __cil_tmp29);
#line 407
    vb = __cil_tmp30;
#line 408
    _mm_store_ps(c0, vr);
#line 409
    _mm_store_ps(c1, vg);
#line 410
    _mm_store_ps(c2, vb);
#line 411
    c0 += 4;
#line 412
    c1 += 4;
#line 413
    c2 += 4;
#line 415
    vy = _mm_load_ps((float const   *)c0);
#line 416
    vu = _mm_load_ps((float const   *)c1);
#line 417
    vv = _mm_load_ps((float const   *)c2);
#line 418
    __cil_tmp34 = _mm_mul_ps(vv, vrv);
#line 418
    __cil_tmp35 = _mm_add_ps(vy, __cil_tmp34);
#line 418
    vr = __cil_tmp35;
#line 419
    __cil_tmp36 = _mm_mul_ps(vu, vgu);
#line 419
    __cil_tmp37 = _mm_sub_ps(vy, __cil_tmp36);
#line 419
    __cil_tmp38 = _mm_mul_ps(vv, vgv);
#line 419
    __cil_tmp39 = _mm_sub_ps(__cil_tmp37, __cil_tmp38);
#line 419
    vg = __cil_tmp39;
#line 420
    __cil_tmp40 = _mm_mul_ps(vu, vbu);
#line 420
    __cil_tmp41 = _mm_add_ps(vy, __cil_tmp40);
#line 420
    vb = __cil_tmp41;
#line 421
    _mm_store_ps(c0, vr);
#line 422
    _mm_store_ps(c1, vg);
#line 423
    _mm_store_ps(c2, vb);
#line 424
    c0 += 4;
#line 425
    c1 += 4;
#line 426
    c2 += 4;
#line 398
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 428
  n &= 7UL;
#line 430
  i = (OPJ_UINT32 )0;
  {
#line 430
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 430
    if (! ((unsigned long )i < n)) {
#line 430
      goto while_break___0;
    }
#line 431
    y = *(c0 + i);
#line 432
    u = *(c1 + i);
#line 433
    v = *(c2 + i);
#line 434
    r = y + v * 1.40199995041f;
#line 435
    g = (y - u * 0.344130009413f) - v * 0.71413999796f;
#line 436
    b = y + u * 1.77199995518f;
#line 437
    *(c0 + i) = r;
#line 438
    *(c1 + i) = g;
#line 439
    *(c2 + i) = b;
#line 430
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 434
  return;
}
}
#line 446 "/root/patron/new_24/src/lib/openjp2/mct.c"
OPJ_FLOAT64 opj_mct_getnorm_real(OPJ_UINT32 compno ) 
{ 


  {
#line 448
  return (opj_mct_norms_real[compno]);
}
}
#line 452 "/root/patron/new_24/src/lib/openjp2/mct.c"
OPJ_BOOL opj_mct_encode_custom(OPJ_BYTE *pCodingdata , OPJ_SIZE_T n , OPJ_BYTE **pData ,
                               OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) 
{ 
  OPJ_FLOAT32 *lMct ;
  OPJ_SIZE_T i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 lNbMatCoeff ;
  OPJ_INT32 *lCurrentData ;
  OPJ_INT32 *lCurrentMatrix ;
  OPJ_INT32 **lData ;
  OPJ_UINT32 lMultiplicator ;
  OPJ_INT32 *lMctPtr ;
  void *__cil_tmp16 ;
  OPJ_FLOAT32 *__cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;

  {
  {
#line 459
  lMct = (OPJ_FLOAT32 *)pCodingdata;
#line 463
  lNbMatCoeff = pNbComp * pNbComp;
#line 464
  lCurrentData = (OPJ_INT32 *)0;
#line 465
  lCurrentMatrix = (OPJ_INT32 *)0;
#line 466
  lData = (OPJ_INT32 **)pData;
#line 467
  lMultiplicator = (OPJ_UINT32 )(1 << 13);
#line 472
  __cil_tmp16 = opj_malloc((unsigned long )(pNbComp + lNbMatCoeff) * sizeof(OPJ_INT32 ));
#line 472
  lCurrentData = (OPJ_INT32 *)__cil_tmp16;
  }
#line 474
  if (! lCurrentData) {
#line 475
    return (0);
  }
#line 478
  lCurrentMatrix = lCurrentData + pNbComp;
#line 480
  i = (OPJ_SIZE_T )0;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;

#line 480
    if (! (i < (unsigned long )lNbMatCoeff)) {
#line 480
      goto while_break;
    }
#line 481
    __cil_tmp17 = lMct;
#line 481
    lMct ++;
#line 481
    *(lCurrentMatrix + i) = (OPJ_INT32 )(*__cil_tmp17 * (OPJ_FLOAT32 )lMultiplicator);
#line 480
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 484
  i = (OPJ_SIZE_T )0;
  {
#line 484
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 484
    if (! (i < n)) {
#line 484
      goto while_break___0;
    }
#line 485
    lMctPtr = lCurrentMatrix;
#line 486
    j = (OPJ_UINT32 )0;
    {
#line 486
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 486
      if (! (j < pNbComp)) {
#line 486
        goto while_break___1;
      }
#line 487
      *(lCurrentData + j) = *(*(lData + j));
#line 486
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
#line 490
    j = (OPJ_UINT32 )0;
    {
#line 490
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 490
      if (! (j < pNbComp)) {
#line 490
        goto while_break___2;
      }
#line 491
      *(*(lData + j)) = 0;
#line 492
      k = (OPJ_UINT32 )0;
      {
#line 492
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 492
        if (! (k < pNbComp)) {
#line 492
          goto while_break___3;
        }
        {
#line 493
        __cil_tmp18 = opj_int_fix_mul(*lMctPtr, *(lCurrentData + k));
#line 493
        *(*(lData + j)) += __cil_tmp18;
#line 494
        lMctPtr ++;
#line 492
        k ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 497
      (*(lData + j)) ++;
#line 490
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 484
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 501
  opj_free((void *)lCurrentData);
  }
#line 503
  return (1);
}
}
#line 506 "/root/patron/new_24/src/lib/openjp2/mct.c"
OPJ_BOOL opj_mct_decode_custom(OPJ_BYTE *pDecodingData , OPJ_SIZE_T n , OPJ_BYTE **pData ,
                               OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) 
{ 
  OPJ_FLOAT32 *lMct ;
  OPJ_SIZE_T i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_FLOAT32 *lCurrentData ;
  OPJ_FLOAT32 *lCurrentResult ;
  OPJ_FLOAT32 **lData ;
  void *__cil_tmp13 ;
  OPJ_FLOAT32 *__cil_tmp14 ;
  OPJ_FLOAT32 *__cil_tmp15 ;

  {
  {
#line 518
  lCurrentData = (OPJ_FLOAT32 *)0;
#line 519
  lCurrentResult = (OPJ_FLOAT32 *)0;
#line 520
  lData = (OPJ_FLOAT32 **)pData;
#line 524
  __cil_tmp13 = opj_malloc((unsigned long )(2U * pNbComp) * sizeof(OPJ_FLOAT32 ));
#line 524
  lCurrentData = (OPJ_FLOAT32 *)__cil_tmp13;
  }
#line 525
  if (! lCurrentData) {
#line 526
    return (0);
  }
#line 528
  lCurrentResult = lCurrentData + pNbComp;
#line 530
  i = (OPJ_SIZE_T )0;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;

#line 530
    if (! (i < n)) {
#line 530
      goto while_break;
    }
#line 531
    lMct = (OPJ_FLOAT32 *)pDecodingData;
#line 532
    j = (OPJ_UINT32 )0;
    {
#line 532
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 532
      if (! (j < pNbComp)) {
#line 532
        goto while_break___0;
      }
#line 533
      *(lCurrentData + j) = *(*(lData + j));
#line 532
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 535
    j = (OPJ_UINT32 )0;
    {
#line 535
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 535
      if (! (j < pNbComp)) {
#line 535
        goto while_break___1;
      }
#line 536
      *(lCurrentResult + j) = (OPJ_FLOAT32 )0;
#line 537
      k = (OPJ_UINT32 )0;
      {
#line 537
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 537
        if (! (k < pNbComp)) {
#line 537
          goto while_break___2;
        }
#line 538
        __cil_tmp14 = lMct;
#line 538
        lMct ++;
#line 538
        *(lCurrentResult + j) += *__cil_tmp14 * *(lCurrentData + k);
#line 537
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 540
      __cil_tmp15 = *(lData + j);
#line 540
      (*(lData + j)) ++;
#line 540
      *__cil_tmp15 = *(lCurrentResult + j);
#line 535
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 530
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 543
  opj_free((void *)lCurrentData);
  }
#line 544
  return (1);
}
}
#line 547 "/root/patron/new_24/src/lib/openjp2/mct.c"
void opj_calculate_norms(OPJ_FLOAT64 *pNorms , OPJ_UINT32 pNbComps , OPJ_FLOAT32 *pMatrix ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 lIndex ;
  OPJ_FLOAT32 lCurrentValue ;
  OPJ_FLOAT64 *lNorms ;
  OPJ_FLOAT32 *lMatrix ;

  {
#line 553
  lNorms = pNorms;
#line 554
  lMatrix = pMatrix;
#line 556
  i = (OPJ_UINT32 )0;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;

#line 556
    if (! (i < pNbComps)) {
#line 556
      goto while_break;
    }
#line 557
    *(lNorms + i) = (OPJ_FLOAT64 )0;
#line 558
    lIndex = i;
#line 560
    j = (OPJ_UINT32 )0;
    {
#line 560
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 560
      if (! (j < pNbComps)) {
#line 560
        goto while_break___0;
      }
#line 561
      lCurrentValue = *(lMatrix + lIndex);
#line 562
      lIndex += pNbComps;
#line 563
      *(lNorms + i) += (double )(lCurrentValue * lCurrentValue);
#line 560
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 565
    *(lNorms + i) = sqrt(*(lNorms + i));
#line 556
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 560
  return;
}
}
#line 64 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data ,
                                  OPJ_UINT32 p_image_header_size , opj_event_mgr_t *p_manager ) ;
#line 77
static OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 88
static OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 101
static OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2 , OPJ_BYTE *p_bpc_header_data , OPJ_UINT32 p_bpc_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 106
static OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2 , OPJ_BYTE *p_cdef_header_data ,
                                  OPJ_UINT32 p_cdef_header_size , opj_event_mgr_t *p_manager ) ;
#line 111
static void opj_jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color , opj_event_mgr_t *manager ) ;
#line 122
static OPJ_BYTE *opj_jp2_write_cdef(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 133
static OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 145
static OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 159
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 164
static OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 178
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 192
static OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                   opj_event_mgr_t *p_manager ) ;
#line 205
static OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 251
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager ) ;
#line 265
static OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 276
static OPJ_BOOL opj_jp2_apply_pclr(opj_image_t *image , opj_jp2_color_t *color , opj_event_mgr_t *p_manager ) ;
#line 280
static void opj_jp2_free_pclr(opj_jp2_color_t *color ) ;
#line 292
static OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2 , OPJ_BYTE *p_pclr_header_data ,
                                  OPJ_UINT32 p_pclr_header_size , opj_event_mgr_t *p_manager ) ;
#line 308
static OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2 , OPJ_BYTE *p_cmap_header_data ,
                                  OPJ_UINT32 p_cmap_header_size , opj_event_mgr_t *p_manager ) ;
#line 323
static OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2 , OPJ_BYTE *p_colr_header_data ,
                                  OPJ_UINT32 p_colr_header_size , opj_event_mgr_t *p_manager ) ;
#line 336
static OPJ_BOOL opj_jp2_setup_end_header_writing(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 343
static OPJ_BOOL opj_jp2_setup_end_header_reading(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 355
static OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                              opj_event_mgr_t *p_manager ) ;
#line 369
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 384
static OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                                    opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 393
static OPJ_BOOL opj_jp2_setup_encoding_validation(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 399
static OPJ_BOOL opj_jp2_setup_header_writing(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 402
static OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2 , opj_stream_private_t *cio ,
                                           opj_event_mgr_t *p_manager ) ;
#line 413
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id ) ;
#line 423
static opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) ;
#line 425 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t jp2_header[3]  = {      {(OPJ_UINT32 )1783636000, & opj_jp2_read_jp}, 
        {(OPJ_UINT32 )1718909296, & opj_jp2_read_ftyp}, 
        {(OPJ_UINT32 )1785737832, & opj_jp2_read_jp2h}};
#line 431 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t jp2_img_header[6]  = {      {(OPJ_UINT32 )1768449138, & opj_jp2_read_ihdr}, 
        {(OPJ_UINT32 )1668246642, & opj_jp2_read_colr}, 
        {(OPJ_UINT32 )1651532643, & opj_jp2_read_bpcc}, 
        {(OPJ_UINT32 )1885564018, & opj_jp2_read_pclr}, 
        {(OPJ_UINT32 )1668112752, & opj_jp2_read_cmap}, 
        {(OPJ_UINT32 )1667523942, & opj_jp2_read_cdef}};
#line 452
static OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box , OPJ_BYTE *p_data , OPJ_UINT32 *p_number_bytes_read ,
                                         OPJ_UINT32 p_box_max_size , opj_event_mgr_t *p_manager ) ;
#line 462
static OPJ_BOOL opj_jp2_setup_decoding_validation(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 469
static OPJ_BOOL opj_jp2_setup_header_reading(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 473 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                                    opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data_header[8] ;
  OPJ_SIZE_T __cil_tmp10 ;
  OPJ_OFF_T bleft ;
  OPJ_OFF_T __cil_tmp12 ;
  OPJ_UINT32 l_xl_part_size ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
  {
#line 487
  __cil_tmp10 = opj_stream_read_data(cio, l_data_header, (OPJ_SIZE_T )8, p_manager);
#line 487
  *p_number_bytes_read = (OPJ_UINT32 )__cil_tmp10;
  }
#line 489
  if (*p_number_bytes_read != 8U) {
#line 490
    return (0);
  }
  {
#line 494
  opj_read_bytes_LE(l_data_header, & box->length, (OPJ_UINT32 )4);
#line 495
  opj_read_bytes_LE(l_data_header + 4, & box->type, (OPJ_UINT32 )4);
  }
#line 497
  if (box->length == 0U) {
    {
#line 498
    __cil_tmp12 = opj_stream_get_number_byte_left(cio);
#line 498
    bleft = __cil_tmp12;
    }
#line 499
    if (bleft > 4294967287L) {
      {
#line 500
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 502
      return (0);
    }
#line 504
    box->length = (OPJ_UINT32 )bleft + 8U;
#line 506
    return (1);
  }
#line 511
  if (box->length == 1U) {
    {
#line 514
    __cil_tmp16 = opj_stream_read_data(cio, l_data_header, (OPJ_SIZE_T )8, p_manager);
#line 514
    l_nb_bytes_read = (OPJ_UINT32 )__cil_tmp16;
    }
#line 516
    if (l_nb_bytes_read != 8U) {
#line 517
      if (l_nb_bytes_read > 0U) {
#line 518
        *p_number_bytes_read += l_nb_bytes_read;
      }
#line 521
      return (0);
    }
    {
#line 524
    *p_number_bytes_read = (OPJ_UINT32 )16;
#line 525
    opj_read_bytes_LE(l_data_header, & l_xl_part_size, (OPJ_UINT32 )4);
    }
#line 526
    if (l_xl_part_size != 0U) {
      {
#line 527
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 529
      return (0);
    }
    {
#line 531
    opj_read_bytes_LE(l_data_header + 4, & box->length, (OPJ_UINT32 )4);
    }
  }
#line 533
  return (1);
}
}
#line 561 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data ,
                                  OPJ_UINT32 p_image_header_size , opj_event_mgr_t *p_manager ) 
{ 
  void *__cil_tmp8 ;

  {
#line 571
  if ((unsigned long )jp2->comps != (unsigned long )((void *)0)) {
    {
#line 572
    opj_event_msg(p_manager, 2, "Ignoring ihdr box. First ihdr box already read\n");
    }
#line 574
    return (1);
  }
#line 577
  if (p_image_header_size != 14U) {
    {
#line 578
    opj_event_msg(p_manager, 1, "Bad image header box (bad size)\n\220");
    }
#line 579
    return (0);
  }
  {
#line 582
  opj_read_bytes_LE(p_image_header_data, & jp2->h, (OPJ_UINT32 )4);
#line 583
  p_image_header_data += 4;
#line 584
  opj_read_bytes_LE(p_image_header_data, & jp2->w, (OPJ_UINT32 )4);
#line 585
  p_image_header_data += 4;
#line 586
  opj_read_bytes_LE(p_image_header_data, & jp2->numcomps, (OPJ_UINT32 )2);
#line 587
  p_image_header_data += 2;
  }
#line 589
  if (jp2->numcomps - 1U >= 16384U) {
    {
#line 591
    opj_event_msg(p_manager, 1, "Invalid number of components (ihdr)\n V");
    }
#line 592
    return (0);
  }
  {
#line 596
  __cil_tmp8 = opj_calloc((size_t )jp2->numcomps, sizeof(opj_jp2_comps_t ));
#line 596
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8;
  }
#line 598
  if ((unsigned long )jp2->comps == (unsigned long )((opj_jp2_comps_t *)0)) {
    {
#line 599
    opj_event_msg(p_manager, 1, "Not enough memory to handle image header (ihdr)\n\220");
    }
#line 601
    return (0);
  }
  {
#line 604
  opj_read_bytes_LE(p_image_header_data, & jp2->bpc, (OPJ_UINT32 )1);
#line 605
  p_image_header_data ++;
#line 607
  opj_read_bytes_LE(p_image_header_data, & jp2->C, (OPJ_UINT32 )1);
#line 608
  p_image_header_data ++;
  }
#line 611
  if (jp2->C != 7U) {
    {
#line 612
    opj_event_msg(p_manager, 4, "JP2 IHDR box: compression type indicate that the file is not a conforming JP2 file (%d) \n\354\3441 V",
                  jp2->C);
    }
  }
  {
#line 617
  opj_read_bytes_LE(p_image_header_data, & jp2->UnkC, (OPJ_UINT32 )1);
#line 618
  p_image_header_data ++;
#line 619
  opj_read_bytes_LE(p_image_header_data, & jp2->IPR, (OPJ_UINT32 )1);
#line 620
  p_image_header_data ++;
#line 622
  (jp2->j2k)->m_cp.allow_different_bit_depth_sign = (OPJ_BITFIELD )(jp2->bpc == 255U);
#line 623
  (jp2->j2k)->ihdr_w = jp2->w;
#line 624
  (jp2->j2k)->ihdr_h = jp2->h;
#line 625
  jp2->has_ihdr = (OPJ_BYTE )1;
  }
#line 627
  return (1);
}
}
#line 630 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_BYTE *l_ihdr_data ;
  OPJ_BYTE *l_current_ihdr_ptr ;
  void *__cil_tmp7 ;

  {
  {
#line 641
  __cil_tmp7 = opj_calloc((size_t )1, (size_t )22);
#line 641
  l_ihdr_data = (OPJ_BYTE *)__cil_tmp7;
  }
#line 642
  if ((unsigned long )l_ihdr_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 643
    return ((OPJ_BYTE *)0);
  }
  {
#line 646
  l_current_ihdr_ptr = l_ihdr_data;
#line 648
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )22, (OPJ_UINT32 )4);
#line 649
  l_current_ihdr_ptr += 4;
#line 651
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )1768449138, (OPJ_UINT32 )4);
#line 652
  l_current_ihdr_ptr += 4;
#line 654
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->h, (OPJ_UINT32 )4);
#line 655
  l_current_ihdr_ptr += 4;
#line 657
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->w, (OPJ_UINT32 )4);
#line 658
  l_current_ihdr_ptr += 4;
#line 660
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->numcomps, (OPJ_UINT32 )2);
#line 661
  l_current_ihdr_ptr += 2;
#line 663
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->bpc, (OPJ_UINT32 )1);
#line 664
  l_current_ihdr_ptr ++;
#line 666
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->C, (OPJ_UINT32 )1);
#line 667
  l_current_ihdr_ptr ++;
#line 669
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->UnkC, (OPJ_UINT32 )1);
#line 671
  l_current_ihdr_ptr ++;
#line 673
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->IPR, (OPJ_UINT32 )1);
#line 675
  l_current_ihdr_ptr ++;
#line 677
  *p_nb_bytes_written = (OPJ_UINT32 )22;
  }
#line 679
  return (l_ihdr_data);
}
}
#line 682 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_bpcc_size ;
  OPJ_BYTE *l_bpcc_data ;
  OPJ_BYTE *l_current_bpcc_ptr ;
  void *__cil_tmp9 ;

  {
  {
#line 694
  l_bpcc_size = 8U + jp2->numcomps;
#line 696
  __cil_tmp9 = opj_calloc((size_t )1, (size_t )l_bpcc_size);
#line 696
  l_bpcc_data = (OPJ_BYTE *)__cil_tmp9;
  }
#line 697
  if ((unsigned long )l_bpcc_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 698
    return ((OPJ_BYTE *)0);
  }
  {
#line 701
  l_current_bpcc_ptr = l_bpcc_data;
#line 703
  opj_write_bytes_LE(l_current_bpcc_ptr, l_bpcc_size, (OPJ_UINT32 )4);
#line 705
  l_current_bpcc_ptr += 4;
#line 707
  opj_write_bytes_LE(l_current_bpcc_ptr, (OPJ_UINT32 )1651532643, (OPJ_UINT32 )4);
#line 708
  l_current_bpcc_ptr += 4;
#line 710
  i = (OPJ_UINT32 )0;
  }
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;

#line 710
    if (! (i < jp2->numcomps)) {
#line 710
      goto while_break;
    }
    {
#line 711
    opj_write_bytes_LE(l_current_bpcc_ptr, (jp2->comps + i)->bpcc, (OPJ_UINT32 )1);
#line 713
    l_current_bpcc_ptr ++;
#line 710
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 716
  *p_nb_bytes_written = l_bpcc_size;
#line 718
  return (l_bpcc_data);
}
}
#line 721 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2 , OPJ_BYTE *p_bpc_header_data , OPJ_UINT32 p_bpc_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;

  {
#line 735
  if (jp2->bpc != 255U) {
    {
#line 736
    opj_event_msg(p_manager, 2, "A BPCC header box is available although BPC given by the IHDR box (%d) indicate components bit depth is constant\n",
                  jp2->bpc);
    }
  }
#line 742
  if (p_bpc_header_size != jp2->numcomps) {
    {
#line 743
    opj_event_msg(p_manager, 1, "Bad BPCC header box (bad size)\n");
    }
#line 744
    return (0);
  }
#line 748
  i = (OPJ_UINT32 )0;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;

#line 748
    if (! (i < jp2->numcomps)) {
#line 748
      goto while_break;
    }
    {
#line 749
    opj_read_bytes_LE(p_bpc_header_data, & (jp2->comps + i)->bpcc, (OPJ_UINT32 )1);
#line 751
    p_bpc_header_data ++;
#line 748
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 754
  return (1);
}
}
#line 756 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_cdef(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 l_cdef_size ;
  OPJ_BYTE *l_cdef_data ;
  OPJ_BYTE *l_current_cdef_ptr ;
  OPJ_UINT32 l_value ;
  OPJ_UINT16 i ;
  void *__cil_tmp13 ;

  {
  {
#line 760
  l_cdef_size = (OPJ_UINT32 )10;
#line 772
  l_cdef_size += 6U * (unsigned int )(jp2->color.jp2_cdef)->n;
#line 774
  __cil_tmp13 = opj_malloc((size_t )l_cdef_size);
#line 774
  l_cdef_data = (OPJ_BYTE *)__cil_tmp13;
  }
#line 775
  if ((unsigned long )l_cdef_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 776
    return ((OPJ_BYTE *)0);
  }
  {
#line 779
  l_current_cdef_ptr = l_cdef_data;
#line 781
  opj_write_bytes_LE(l_current_cdef_ptr, l_cdef_size, (OPJ_UINT32 )4);
#line 782
  l_current_cdef_ptr += 4;
#line 784
  opj_write_bytes_LE(l_current_cdef_ptr, (OPJ_UINT32 )1667523942, (OPJ_UINT32 )4);
#line 785
  l_current_cdef_ptr += 4;
#line 787
  l_value = (OPJ_UINT32 )(jp2->color.jp2_cdef)->n;
#line 788
  opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 789
  l_current_cdef_ptr += 2;
#line 791
  i = (OPJ_UINT16 )0U;
  }
  {
#line 791
  while (1) {
    while_continue: /* CIL Label */ ;

#line 791
    if (! ((int )i < (int )(jp2->color.jp2_cdef)->n)) {
#line 791
      goto while_break;
    }
    {
#line 792
    l_value = (OPJ_UINT32 )((jp2->color.jp2_cdef)->info + (int )i)->cn;
#line 793
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 794
    l_current_cdef_ptr += 2;
#line 795
    l_value = (OPJ_UINT32 )((jp2->color.jp2_cdef)->info + (int )i)->typ;
#line 796
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 797
    l_current_cdef_ptr += 2;
#line 798
    l_value = (OPJ_UINT32 )((jp2->color.jp2_cdef)->info + (int )i)->asoc;
#line 799
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 800
    l_current_cdef_ptr += 2;
#line 791
    i = (OPJ_UINT16 )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 802
  *p_nb_bytes_written = l_cdef_size;
#line 804
  return (l_cdef_data);
}
}
#line 807 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 l_colr_size ;
  OPJ_BYTE *l_colr_data ;
  OPJ_BYTE *l_current_colr_ptr ;
  void *__cil_tmp10 ;
  OPJ_UINT32 i ;

  {
#line 812
  l_colr_size = (OPJ_UINT32 )11;
#line 821
  if (jp2->meth == 1U) {
#line 821
    goto case_1;
  }
#line 828
  goto switch_default;
  case_1: 
#line 822
  l_colr_size += 4U;
#line 823
  goto switch_break;
#line 826
  l_colr_size += jp2->color.icc_profile_len;
#line 827
  goto switch_break;
  switch_default: 
#line 829
  return ((OPJ_BYTE *)0);
  switch_break: 
  {
#line 832
  __cil_tmp10 = opj_calloc((size_t )1, (size_t )l_colr_size);
#line 832
  l_colr_data = (OPJ_BYTE *)__cil_tmp10;
  }
#line 833
  if ((unsigned long )l_colr_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 834
    return ((OPJ_BYTE *)0);
  }
  {
#line 837
  l_current_colr_ptr = l_colr_data;
#line 839
  opj_write_bytes_LE(l_current_colr_ptr, l_colr_size, (OPJ_UINT32 )4);
#line 841
  l_current_colr_ptr += 4;
#line 843
  opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )1668246642, (OPJ_UINT32 )4);
#line 844
  l_current_colr_ptr += 4;
#line 846
  opj_write_bytes_LE(l_current_colr_ptr, jp2->meth, (OPJ_UINT32 )1);
#line 847
  l_current_colr_ptr ++;
#line 849
  opj_write_bytes_LE(l_current_colr_ptr, jp2->precedence, (OPJ_UINT32 )1);
#line 850
  l_current_colr_ptr ++;
#line 852
  opj_write_bytes_LE(l_current_colr_ptr, jp2->approx, (OPJ_UINT32 )1);
#line 853
  l_current_colr_ptr ++;
  }
#line 855
  if (jp2->meth == 1U) {
    {
#line 857
    opj_write_bytes_LE(l_current_colr_ptr, jp2->enumcs, (OPJ_UINT32 )4);
    }
  } else
#line 860
  if (jp2->meth == 2U) {
#line 862
    i = (OPJ_UINT32 )0;
    {
#line 862
    while (1) {
      while_continue: /* CIL Label */ ;

#line 862
      if (! (i < jp2->color.icc_profile_len)) {
#line 862
        goto while_break;
      }
      {
#line 863
      opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )*(jp2->color.icc_profile_buf + i),
                         (OPJ_UINT32 )1);
#line 864
      l_current_colr_ptr ++;
#line 862
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 869
  *p_nb_bytes_written = l_colr_size;
#line 871
  return (l_colr_data);
}
}
#line 874 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static void opj_jp2_free_pclr(opj_jp2_color_t *color ) 
{ 


  {
  {
#line 876
  opj_free((void *)(color->jp2_pclr)->channel_sign);
#line 877
  opj_free((void *)(color->jp2_pclr)->channel_size);
#line 878
  opj_free((void *)(color->jp2_pclr)->entries);
  }
#line 880
  if ((color->jp2_pclr)->cmap) {
    {
#line 881
    opj_free((void *)(color->jp2_pclr)->cmap);
    }
  }
  {
#line 884
  opj_free((void *)color->jp2_pclr);
#line 885
  color->jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
  }
#line 887
  return;
}
}
#line 888 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_check_color(opj_image_t *image , opj_jp2_color_t *color ,
                                    opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT16 i ;
  opj_jp2_cdef_info_t *info ;
  OPJ_UINT16 n ;
  OPJ_UINT32 nr_channels ;
  OPJ_UINT16 nr_channels___0 ;
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_BOOL *pcol_usage ;
  OPJ_BOOL is_sane ;
  void *__cil_tmp14 ;
  OPJ_BYTE mtyp ;
  OPJ_BYTE pcol ;

  {
#line 894
  if (color->jp2_cdef) {
#line 895
    info = (color->jp2_cdef)->info;
#line 896
    n = (color->jp2_cdef)->n;
#line 897
    nr_channels = image->numcomps;
#line 901
    if (color->jp2_pclr) {
#line 901
      if ((color->jp2_pclr)->cmap) {
#line 902
        nr_channels = (OPJ_UINT32 )(color->jp2_pclr)->nr_channels;
      }
    }
#line 905
    i = (OPJ_UINT16 )0;
    {
#line 905
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: ;
#line 905
      if (! ((int )i < (int )n)) {
#line 905
        goto while_break;
      }
#line 906
      if ((unsigned int )(info + (int )i)->cn >= nr_channels) {
        {
#line 907
        opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\n", (int )(info + (int )i)->cn,
                      nr_channels);
        }
#line 909
        return (0);
      }
#line 911
      if ((unsigned int )(info + (int )i)->asoc == 65535U) {
#line 912
        goto while_continue;
      }
#line 915
      if ((int )(info + (int )i)->asoc > 0) {
#line 915
        if ((OPJ_UINT32 )((int )(info + (int )i)->asoc - 1) >= nr_channels) {
          {
#line 916
          opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\n", (int )(info + (int )i)->asoc - 1,
                        nr_channels);
          }
#line 918
          return (0);
        }
      }
#line 905
      i = (OPJ_UINT16 )((int )i + 1);
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: ;
    {
#line 924
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 924
      if (! (nr_channels > 0U)) {
#line 924
        goto while_break___0;
      }
#line 925
      i = (OPJ_UINT16 )0;
      {
#line 925
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 925
        if (! ((int )i < (int )n)) {
#line 925
          goto while_break___1;
        }
#line 926
        if ((OPJ_UINT32 )(info + (int )i)->cn == nr_channels - 1U) {
#line 927
          goto while_break___1;
        }
#line 925
        i = (OPJ_UINT16 )((int )i + 1);
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: ;
#line 930
      if ((int )i == (int )n) {
        {
#line 931
        opj_event_msg(p_manager, 1, "Incomplete channel definitions.\n\220");
        }
#line 932
        return (0);
      }
#line 934
      nr_channels --;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 940
  if (color->jp2_pclr) {
#line 940
    if ((color->jp2_pclr)->cmap) {
#line 941
      nr_channels___0 = (OPJ_UINT16 )(color->jp2_pclr)->nr_channels;
#line 942
      cmap = (color->jp2_pclr)->cmap;
#line 943
      is_sane = 1;
#line 946
      i = (OPJ_UINT16 )0;
      {
#line 946
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 946
        if (! ((int )i < (int )nr_channels___0)) {
#line 946
          goto while_break___2;
        }
#line 947
        if ((unsigned int )(cmap + (int )i)->cmp >= image->numcomps) {
          {
#line 948
          opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\n V", (int )(cmap + (int )i)->cmp,
                        image->numcomps);
#line 950
          is_sane = 0;
          }
        }
#line 946
        i = (OPJ_UINT16 )((int )i + 1);
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___2: 
      {
#line 954
      __cil_tmp14 = opj_calloc((size_t )nr_channels___0, sizeof(OPJ_BOOL ));
#line 954
      pcol_usage = (OPJ_BOOL *)__cil_tmp14;
      }
#line 955
      if (! pcol_usage) {
        {
#line 956
        opj_event_msg(p_manager, 1, "Unexpected OOM.\n\220");
        }
#line 957
        return (0);
      }
#line 960
      i = (OPJ_UINT16 )0;
      {
#line 960
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 960
        if (! ((int )i < (int )nr_channels___0)) {
#line 960
          goto while_break___3;
        }
#line 961
        mtyp = (cmap + (int )i)->mtyp;
#line 962
        pcol = (cmap + (int )i)->pcol;
#line 964
        if ((int )mtyp != 0) {
#line 964
          if ((int )mtyp != 1) {
            {
#line 965
            opj_event_msg(p_manager, 1, "Invalid value for cmap[%d].mtyp = %d.\n",
                          (int )i, (int )mtyp);
#line 968
            is_sane = 0;
            }
          } else {
#line 964
            goto _L___11;
          }
        } else
        _L___11: 
#line 969
        if ((int )pcol >= (int )nr_channels___0) {
          {
#line 970
          opj_event_msg(p_manager, 1, "Invalid component/palette index for direct mapping %d.\n",
                        (int )pcol);
#line 972
          is_sane = 0;
          }
        } else
#line 973
        if (*(pcol_usage + (int )pcol)) {
#line 973
          if ((int )mtyp == 1) {
            {
#line 974
            opj_event_msg(p_manager, 1, "Component %d is mapped twice.\n", (int )pcol);
#line 975
            is_sane = 0;
            }
          } else {
#line 973
            goto _L___10;
          }
        } else
        _L___10: 
#line 976
        if ((int )mtyp == 0) {
#line 976
          if ((int )pcol != 0) {
            {
#line 979
            opj_event_msg(p_manager, 1, "Direct use at #%d however pcol=%d.\n", (int )i,
                          (int )pcol);
#line 981
            is_sane = 0;
            }
          } else {
#line 976
            goto _L;
          }
        } else
        _L: 
#line 982
        if ((int )mtyp == 1) {
#line 982
          if ((int )pcol != (int )i) {
            {
#line 985
            opj_event_msg(p_manager, 1, "Implementation limitation: for palette mapping, pcol[%d] should be equal to %d, but is equal to %d.\n",
                          (int )i, (int )i, (int )pcol);
#line 989
            is_sane = 0;
            }
          } else {
#line 991
            *(pcol_usage + (int )pcol) = 1;
          }
        } else {
#line 991
          *(pcol_usage + (int )pcol) = 1;
        }
#line 960
        i = (OPJ_UINT16 )((int )i + 1);
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___3: 
#line 995
      i = (OPJ_UINT16 )0;
      {
#line 995
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 995
        if (! ((int )i < (int )nr_channels___0)) {
#line 995
          goto while_break___4;
        }
#line 996
        if (! *(pcol_usage + (int )i)) {
#line 996
          if ((int )(cmap + (int )i)->mtyp != 0) {
            {
#line 997
            opj_event_msg(p_manager, 1, "Component %d doesn\'t have a mapping.\n",
                          (int )i);
#line 999
            is_sane = 0;
            }
          }
        }
#line 995
        i = (OPJ_UINT16 )((int )i + 1);
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: ;
#line 1003
      if (is_sane) {
#line 1003
        if (image->numcomps == 1U) {
#line 1004
          i = (OPJ_UINT16 )0;
          {
#line 1004
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 1004
            if (! ((int )i < (int )nr_channels___0)) {
#line 1004
              goto while_break___5;
            }
#line 1005
            if (! *(pcol_usage + (int )i)) {
              {
#line 1006
              is_sane = (OPJ_BOOL )0U;
#line 1007
              opj_event_msg(p_manager, 2, "Component mapping seems wrong. Trying to correct.\n",
                            (int )i);
              }
#line 1009
              goto while_break___5;
            }
#line 1004
            i = (OPJ_UINT16 )((int )i + 1);
          }
          while_break___13: /* CIL Label */ ;
          }
          while_break___5: ;
#line 1012
          if (! is_sane) {
#line 1013
            is_sane = 1;
#line 1014
            i = (OPJ_UINT16 )0;
            {
#line 1014
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 1014
              if (! ((int )i < (int )nr_channels___0)) {
#line 1014
                goto while_break___6;
              }
#line 1015
              (cmap + (int )i)->mtyp = (OPJ_BYTE )1U;
#line 1016
              (cmap + (int )i)->pcol = (OPJ_BYTE )i;
#line 1014
              i = (OPJ_UINT16 )((int )i + 1);
            }
            while_break___14: /* CIL Label */ ;
            }
            while_break___6: ;
          }
        }
      }
      {
#line 1020
      opj_free((void *)pcol_usage);
      }
#line 1021
      if (! is_sane) {
#line 1022
        return (0);
      }
    }
  }
#line 1026
  return (1);
}
}
#line 1030 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_apply_pclr(opj_image_t *image , opj_jp2_color_t *color , opj_event_mgr_t *p_manager ) 
{ 
  opj_image_comp_t *old_comps ;
  opj_image_comp_t *new_comps ;
  OPJ_BYTE *channel_size ;
  OPJ_BYTE *channel_sign ;
  OPJ_UINT32 *entries ;
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_INT32 *src ;
  OPJ_INT32 *dst ;
  OPJ_UINT32 j ;
  OPJ_UINT32 max ;
  OPJ_UINT16 i ;
  OPJ_UINT16 nr_channels ;
  OPJ_UINT16 cmp ;
  OPJ_UINT16 pcol ;
  OPJ_INT32 k ;
  OPJ_INT32 top_k ;
  void *__cil_tmp20 ;
  void *__cil_tmp23 ;

  {
#line 1043
  channel_size = (color->jp2_pclr)->channel_size;
#line 1044
  channel_sign = (color->jp2_pclr)->channel_sign;
#line 1045
  entries = (color->jp2_pclr)->entries;
#line 1046
  cmap = (color->jp2_pclr)->cmap;
#line 1047
  nr_channels = (OPJ_UINT16 )(color->jp2_pclr)->nr_channels;
#line 1049
  i = (OPJ_UINT16 )0;
  {
#line 1049
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1049
    if (! ((int )i < (int )nr_channels)) {
#line 1049
      goto while_break;
    }
#line 1051
    cmp = (cmap + (int )i)->cmp;
#line 1052
    if ((unsigned long )(image->comps + (int )cmp)->data == (unsigned long )((void *)0)) {
      {
#line 1053
      opj_event_msg(p_manager, 1, "image->comps[%d].data == NULL in opj_jp2_apply_pclr().\n",
                    (int )i);
      }
#line 1055
      return (0);
    }
#line 1049
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1059
  old_comps = image->comps;
#line 1060
  __cil_tmp20 = opj_malloc((unsigned long )nr_channels * sizeof(opj_image_comp_t ));
#line 1060
  new_comps = (opj_image_comp_t *)__cil_tmp20;
  }
#line 1062
  if (! new_comps) {
    {
#line 1063
    opj_event_msg(p_manager, 1, "Memory allocation failure in opj_jp2_apply_pclr().\n1 V");
    }
#line 1065
    return (0);
  }
#line 1067
  i = (OPJ_UINT16 )0;
  {
#line 1067
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1067
    if (! ((int )i < (int )nr_channels)) {
#line 1067
      goto while_break___0;
    }
#line 1068
    pcol = (OPJ_UINT16 )(cmap + (int )i)->pcol;
#line 1069
    cmp = (cmap + (int )i)->cmp;
#line 1072
    if ((int )(cmap + (int )i)->mtyp == 0) {
#line 1074
      *(new_comps + (int )i) = *(old_comps + (int )cmp);
    } else {
#line 1077
      *(new_comps + (int )pcol) = *(old_comps + (int )cmp);
    }
    {
#line 1081
    __cil_tmp23 = opj_image_data_alloc((unsigned long )((old_comps + (int )cmp)->w * (old_comps + (int )cmp)->h) * sizeof(OPJ_INT32 ));
#line 1081
    (new_comps + (int )i)->data = (OPJ_INT32 *)__cil_tmp23;
    }
#line 1083
    if (! (new_comps + (int )i)->data) {
      {
#line 1084
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1084
        if (! ((int )i > 0)) {
#line 1084
          goto while_break___1;
        }
        {
#line 1085
        i = (OPJ_UINT16 )((int )i - 1);
#line 1086
        opj_free((void *)(new_comps + (int )i)->data);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 1088
      opj_free((void *)new_comps);
#line 1089
      opj_event_msg(p_manager, 1, "Memory allocation failure in opj_jp2_apply_pclr().\n");
      }
#line 1091
      return (0);
    }
#line 1093
    (new_comps + (int )i)->prec = (OPJ_UINT32 )*(channel_size + (int )i);
#line 1094
    (new_comps + (int )i)->sgnd = (OPJ_UINT32 )*(channel_sign + (int )i);
#line 1067
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___0: 
#line 1097
  top_k = (int )(color->jp2_pclr)->nr_entries - 1;
#line 1099
  i = (OPJ_UINT16 )0;
  {
#line 1099
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1099
    if (! ((int )i < (int )nr_channels)) {
#line 1099
      goto while_break___2;
    }
#line 1101
    cmp = (cmap + (int )i)->cmp;
#line 1102
    pcol = (OPJ_UINT16 )(cmap + (int )i)->pcol;
#line 1103
    src = (old_comps + (int )cmp)->data;
#line 1105
    max = (new_comps + (int )pcol)->w * (new_comps + (int )pcol)->h;
#line 1108
    if ((int )(cmap + (int )i)->mtyp == 0) {
#line 1110
      dst = (new_comps + (int )i)->data;
#line 1112
      j = (OPJ_UINT32 )0;
      {
#line 1112
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1112
        if (! (j < max)) {
#line 1112
          goto while_break___3;
        }
#line 1113
        *(dst + j) = *(src + j);
#line 1112
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: ;
    } else {
#line 1117
      dst = (new_comps + (int )pcol)->data;
#line 1119
      j = (OPJ_UINT32 )0;
      {
#line 1119
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1119
        if (! (j < max)) {
#line 1119
          goto while_break___4;
        }
#line 1121
        k = *(src + j);
#line 1121
        if (k < 0) {
#line 1122
          k = 0;
        } else
#line 1123
        if (k > top_k) {
#line 1124
          k = top_k;
        }
#line 1128
        *(dst + j) = (OPJ_INT32 )*(entries + (k * (int )nr_channels + (int )pcol));
#line 1119
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: ;
    }
#line 1099
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___2: 
#line 1133
  max = image->numcomps;
#line 1134
  i = (OPJ_UINT16 )0;
  {
#line 1134
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 1134
    if (! ((unsigned int )i < max)) {
#line 1134
      goto while_break___5;
    }
#line 1135
    if ((old_comps + (int )i)->data) {
      {
#line 1136
      opj_image_data_free((void *)(old_comps + (int )i)->data);
      }
    }
#line 1134
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___5: 
  {
#line 1140
  opj_free((void *)old_comps);
#line 1141
  image->comps = new_comps;
#line 1142
  image->numcomps = (OPJ_UINT32 )nr_channels;
#line 1144
  opj_jp2_free_pclr(color);
  }
#line 1146
  return (1);
}
}
#line 1149 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2 , OPJ_BYTE *p_pclr_header_data ,
                                  OPJ_UINT32 p_pclr_header_size , opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_pclr_t *jp2_pclr ;
  OPJ_BYTE *channel_size ;
  OPJ_BYTE *channel_sign ;
  OPJ_UINT32 *entries ;
  OPJ_UINT16 nr_entries ;
  OPJ_UINT16 nr_channels ;
  OPJ_UINT16 i ;
  OPJ_UINT16 j ;
  OPJ_UINT32 l_value ;
  OPJ_BYTE *orig_header_data ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  int tmp___2 ;
  OPJ_UINT32 bytes_to_read ;

  {
#line 1161
  orig_header_data = p_pclr_header_data;
#line 1169
  if (jp2->color.jp2_pclr) {
#line 1170
    return (0);
  }
#line 1173
  if (p_pclr_header_size < 3U) {
#line 1174
    return (0);
  }
  {
#line 1177
  opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )2);
#line 1178
  p_pclr_header_data += 2;
#line 1179
  nr_entries = (OPJ_UINT16 )l_value;
  }
#line 1180
  if ((unsigned int )nr_entries == 0U) {
    {
#line 1181
    opj_event_msg(p_manager, 1, "Invalid PCLR box. Reports %d entries\n", (int )nr_entries);
    }
#line 1183
    return (0);
  } else
#line 1180
  if ((unsigned int )nr_entries > 1024U) {
    {
#line 1181
    opj_event_msg(p_manager, 1, "Invalid PCLR box. Reports %d entries\n", (int )nr_entries);
    }
#line 1183
    return (0);
  }
  {
#line 1186
  opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1187
  p_pclr_header_data ++;
#line 1188
  nr_channels = (OPJ_UINT16 )l_value;
  }
#line 1189
  if ((unsigned int )nr_channels == 0U) {
    {
#line 1190
    opj_event_msg(p_manager, 1, "Invalid PCLR box. Reports 0 palette columns\n V");
    }
#line 1192
    return (0);
  }
#line 1195
  if (p_pclr_header_size < 3U + (OPJ_UINT32 )nr_channels) {
#line 1196
    return (0);
  }
  {
#line 1199
  __cil_tmp18 = opj_malloc(((size_t )nr_channels * (unsigned long )nr_entries) * sizeof(OPJ_UINT32 ));
#line 1199
  entries = (OPJ_UINT32 *)__cil_tmp18;
  }
#line 1201
  if (! entries) {
#line 1202
    return (0);
  }
  {
#line 1204
  __cil_tmp19 = opj_malloc((size_t )nr_channels);
#line 1204
  channel_size = (OPJ_BYTE *)__cil_tmp19;
  }
#line 1205
  if (! channel_size) {
    {
#line 1206
    opj_free((void *)entries);
    }
#line 1207
    return (0);
  }
  {
#line 1209
  __cil_tmp20 = opj_malloc((size_t )nr_channels);
#line 1209
  channel_sign = (OPJ_BYTE *)__cil_tmp20;
  }
#line 1210
  if (! channel_sign) {
    {
#line 1211
    opj_free((void *)entries);
#line 1212
    opj_free((void *)channel_size);
    }
#line 1213
    return (0);
  }
  {
#line 1216
  __cil_tmp21 = opj_malloc(sizeof(opj_jp2_pclr_t ));
#line 1216
  jp2_pclr = (opj_jp2_pclr_t *)__cil_tmp21;
  }
#line 1217
  if (! jp2_pclr) {
    {
#line 1218
    opj_free((void *)entries);
#line 1219
    opj_free((void *)channel_size);
#line 1220
    opj_free((void *)channel_sign);
    }
#line 1221
    return (0);
  }
#line 1224
  jp2_pclr->channel_sign = channel_sign;
#line 1225
  jp2_pclr->channel_size = channel_size;
#line 1226
  jp2_pclr->entries = entries;
#line 1227
  jp2_pclr->nr_entries = nr_entries;
#line 1228
  jp2_pclr->nr_channels = (OPJ_BYTE )l_value;
#line 1229
  jp2_pclr->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
#line 1231
  jp2->color.jp2_pclr = jp2_pclr;
#line 1233
  i = (OPJ_UINT16 )0;
  {
#line 1233
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1233
    if (! ((int )i < (int )nr_channels)) {
#line 1233
      goto while_break;
    }
    {
#line 1234
    opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1235
    p_pclr_header_data ++;
#line 1237
    *(channel_size + (int )i) = (OPJ_BYTE )((l_value & 127U) + 1U);
    }
#line 1238
    if (l_value & 128U) {
#line 1238
      tmp___2 = 1;
    } else {
#line 1238
      tmp___2 = 0;
    }
#line 1238
    *(channel_sign + (int )i) = (OPJ_BYTE )tmp___2;
#line 1233
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 1241
  j = (OPJ_UINT16 )0;
  {
#line 1241
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1241
    if (! ((int )j < (int )nr_entries)) {
#line 1241
      goto while_break___0;
    }
#line 1242
    i = (OPJ_UINT16 )0;
    {
#line 1242
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1242
      if (! ((int )i < (int )nr_channels)) {
#line 1242
        goto while_break___1;
      }
#line 1243
      bytes_to_read = (OPJ_UINT32 )(((int )*(channel_size + (int )i) + 7) >> 3);
#line 1245
      if ((unsigned long )bytes_to_read > sizeof(OPJ_UINT32 )) {
#line 1246
        bytes_to_read = (OPJ_UINT32 )sizeof(OPJ_UINT32 );
      }
#line 1248
      if ((ptrdiff_t )p_pclr_header_size < (p_pclr_header_data - orig_header_data) + (ptrdiff_t )bytes_to_read) {
#line 1250
        return (0);
      }
      {
#line 1253
      opj_read_bytes_LE(p_pclr_header_data, & l_value, bytes_to_read);
#line 1254
      p_pclr_header_data += bytes_to_read;
#line 1255
      *entries = l_value;
#line 1256
      entries ++;
#line 1242
      i = (OPJ_UINT16 )((int )i + 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 1241
    j = (OPJ_UINT16 )((int )j + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1260
  return (1);
}
}
#line 1263 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2 , OPJ_BYTE *p_cmap_header_data ,
                                  OPJ_UINT32 p_cmap_header_size , opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_BYTE i ;
  OPJ_BYTE nr_channels ;
  OPJ_UINT32 l_value ;
  void *__cil_tmp12 ;

  {
#line 1280
  if ((unsigned long )jp2->color.jp2_pclr == (unsigned long )((void *)0)) {
    {
#line 1281
    opj_event_msg(p_manager, 1, "Need to read a PCLR box before the CMAP box.\nV");
    }
#line 1283
    return (0);
  }
#line 1289
  if ((jp2->color.jp2_pclr)->cmap) {
    {
#line 1290
    opj_event_msg(p_manager, 1, "Only one CMAP box is allowed.\n");
    }
#line 1291
    return (0);
  }
#line 1294
  nr_channels = (jp2->color.jp2_pclr)->nr_channels;
#line 1295
  if (p_cmap_header_size < (OPJ_UINT32 )nr_channels * 4U) {
    {
#line 1296
    opj_event_msg(p_manager, 1, "Insufficient data for CMAP box.\n\220");
    }
#line 1297
    return (0);
  }
  {
#line 1300
  __cil_tmp12 = opj_malloc((unsigned long )nr_channels * sizeof(opj_jp2_cmap_comp_t ));
#line 1300
  cmap = (opj_jp2_cmap_comp_t *)__cil_tmp12;
  }
#line 1302
  if (! cmap) {
#line 1303
    return (0);
  }
#line 1307
  i = (OPJ_BYTE )0;
  {
#line 1307
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1307
    if (! ((int )i < (int )nr_channels)) {
#line 1307
      goto while_break;
    }
    {
#line 1308
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )2);
#line 1309
    p_cmap_header_data += 2;
#line 1310
    (cmap + (int )i)->cmp = (OPJ_UINT16 )l_value;
#line 1312
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )1);
#line 1313
    p_cmap_header_data ++;
#line 1314
    (cmap + (int )i)->mtyp = (OPJ_BYTE )l_value;
#line 1316
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )1);
#line 1317
    p_cmap_header_data ++;
#line 1318
    (cmap + (int )i)->pcol = (OPJ_BYTE )l_value;
#line 1307
    i = (OPJ_BYTE )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1321
  (jp2->color.jp2_pclr)->cmap = cmap;
#line 1323
  return (1);
}
}
#line 1326 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static void opj_jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color , opj_event_mgr_t *manager ) 
{ 
  opj_jp2_cdef_info_t *info ;
  OPJ_UINT16 i ;
  OPJ_UINT16 n ;
  OPJ_UINT16 cn ;
  OPJ_UINT16 asoc ;
  OPJ_UINT16 acn ;
  opj_image_comp_t saved ;
  OPJ_UINT16 j ;

  {
#line 1332
  info = (color->jp2_cdef)->info;
#line 1333
  n = (color->jp2_cdef)->n;
#line 1335
  i = (OPJ_UINT16 )0;
  {
#line 1335
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1335
    if (! ((int )i < (int )n)) {
#line 1335
      goto while_break;
    }
#line 1337
    asoc = (info + (int )i)->asoc;
#line 1338
    cn = (info + (int )i)->cn;
#line 1340
    if ((unsigned int )cn >= image->numcomps) {
      {
#line 1341
      opj_event_msg(manager, 2, "opj_jp2_apply_cdef: cn=%d, numcomps=%d\n", (int )cn,
                    image->numcomps);
      }
#line 1343
      goto while_continue;
    }
#line 1345
    if ((int )asoc == 0) {
#line 1346
      (image->comps + (int )cn)->alpha = (info + (int )i)->typ;
#line 1347
      goto while_continue;
    } else
#line 1345
    if ((int )asoc == 65535) {
#line 1346
      (image->comps + (int )cn)->alpha = (info + (int )i)->typ;
#line 1347
      goto while_continue;
    }
#line 1350
    acn = (OPJ_UINT16 )((int )asoc - 1);
#line 1351
    if ((unsigned int )acn >= image->numcomps) {
      {
#line 1352
      opj_event_msg(manager, 2, "opj_jp2_apply_cdef: acn=%d, numcomps=%d\n\230\001",
                    (int )acn, image->numcomps);
      }
#line 1354
      goto while_continue;
    }
#line 1358
    if ((int )cn != (int )acn) {
#line 1358
      if ((int )(info + (int )i)->typ == 0) {
        {
#line 1362
        memcpy((void *)(& saved), (void const   *)(image->comps + (int )cn), sizeof(opj_image_comp_t ));
#line 1363
        memcpy((void *)(image->comps + (int )cn), (void const   *)(image->comps + (int )acn),
               sizeof(opj_image_comp_t ));
#line 1364
        memcpy((void *)(image->comps + (int )acn), (void const   *)(& saved), sizeof(opj_image_comp_t ));
#line 1367
        j = (OPJ_UINT16 )((unsigned int )i + 1U);
        }
        {
#line 1367
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1367
          if (! ((int )j < (int )n)) {
#line 1367
            goto while_break___0;
          }
#line 1368
          if ((int )(info + (int )j)->cn == (int )cn) {
#line 1369
            (info + (int )j)->cn = acn;
          } else
#line 1370
          if ((int )(info + (int )j)->cn == (int )acn) {
#line 1371
            (info + (int )j)->cn = cn;
          }
#line 1367
          j = (OPJ_UINT16 )((int )j + 1);
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
      }
    }
#line 1377
    (image->comps + (int )cn)->alpha = (info + (int )i)->typ;
#line 1335
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1380
  if ((color->jp2_cdef)->info) {
    {
#line 1381
    opj_free((void *)(color->jp2_cdef)->info);
    }
  }
  {
#line 1384
  opj_free((void *)color->jp2_cdef);
#line 1385
  color->jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
  }
#line 1387
  return;
}
}
#line 1389 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2 , OPJ_BYTE *p_cdef_header_data ,
                                  OPJ_UINT32 p_cdef_header_size , opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_cdef_info_t *cdef_info ;
  OPJ_UINT16 i ;
  OPJ_UINT32 l_value ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
#line 1407
  if (jp2->color.jp2_cdef) {
#line 1408
    return (0);
  }
#line 1411
  if (p_cdef_header_size < 2U) {
    {
#line 1412
    opj_event_msg(p_manager, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1413
    return (0);
  }
  {
#line 1416
  opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1417
  p_cdef_header_data += 2;
  }
#line 1419
  if ((int )((OPJ_UINT16 )l_value) == 0) {
    {
#line 1420
    opj_event_msg(p_manager, 1, "Number of channel description is equal to zero in CDEF box.\n");
    }
#line 1422
    return (0);
  }
#line 1425
  if (p_cdef_header_size < 2U + (OPJ_UINT32 )((OPJ_UINT16 )l_value) * 6U) {
    {
#line 1426
    opj_event_msg(p_manager, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1427
    return (0);
  }
  {
#line 1430
  __cil_tmp11 = opj_malloc((unsigned long )l_value * sizeof(opj_jp2_cdef_info_t ));
#line 1430
  cdef_info = (opj_jp2_cdef_info_t *)__cil_tmp11;
  }
#line 1432
  if (! cdef_info) {
#line 1433
    return (0);
  }
  {
#line 1436
  __cil_tmp12 = opj_malloc(sizeof(opj_jp2_cdef_t ));
#line 1436
  jp2->color.jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp12;
  }
#line 1437
  if (! jp2->color.jp2_cdef) {
    {
#line 1438
    opj_free((void *)cdef_info);
    }
#line 1439
    return (0);
  }
#line 1441
  (jp2->color.jp2_cdef)->info = cdef_info;
#line 1442
  (jp2->color.jp2_cdef)->n = (OPJ_UINT16 )l_value;
#line 1444
  i = (OPJ_UINT16 )0;
  {
#line 1444
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1444
    if (! ((int )i < (int )(jp2->color.jp2_cdef)->n)) {
#line 1444
      goto while_break;
    }
    {
#line 1445
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1446
    p_cdef_header_data += 2;
#line 1447
    (cdef_info + (int )i)->cn = (OPJ_UINT16 )l_value;
#line 1449
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1450
    p_cdef_header_data += 2;
#line 1451
    (cdef_info + (int )i)->typ = (OPJ_UINT16 )l_value;
#line 1453
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1454
    p_cdef_header_data += 2;
#line 1455
    (cdef_info + (int )i)->asoc = (OPJ_UINT16 )l_value;
#line 1444
    i = (OPJ_UINT16 )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1458
  return (1);
}
}
#line 1461 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2 , OPJ_BYTE *p_colr_header_data ,
                                  OPJ_UINT32 p_colr_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_value ;
  OPJ_UINT32 *cielab ;
  OPJ_UINT32 rl ;
  OPJ_UINT32 ol ;
  OPJ_UINT32 ra ;
  OPJ_UINT32 oa ;
  OPJ_UINT32 rb ;
  OPJ_UINT32 ob ;
  OPJ_UINT32 il ;
  void *__cil_tmp17 ;
  OPJ_INT32 it_icc_value ;
  OPJ_INT32 icc_len ;
  void *__cil_tmp20 ;

  {
#line 1474
  if (p_colr_header_size < 3U) {
    {
#line 1475
    opj_event_msg(p_manager, 1, "Bad COLR header box (bad size)\n");
    }
#line 1476
    return (0);
  }
#line 1482
  if (jp2->color.jp2_has_colr) {
    {
#line 1483
    opj_event_msg(p_manager, 4, "A conforming JP2 reader shall ignore all Colour Specification boxes after the first, so we ignore this one.\n");
#line 1485
    p_colr_header_data += p_colr_header_size;
    }
#line 1486
    return (1);
  }
  {
#line 1489
  opj_read_bytes_LE(p_colr_header_data, & jp2->meth, (OPJ_UINT32 )1);
#line 1490
  p_colr_header_data ++;
#line 1492
  opj_read_bytes_LE(p_colr_header_data, & jp2->precedence, (OPJ_UINT32 )1);
#line 1493
  p_colr_header_data ++;
#line 1495
  opj_read_bytes_LE(p_colr_header_data, & jp2->approx, (OPJ_UINT32 )1);
#line 1496
  p_colr_header_data ++;
  }
#line 1498
  if (jp2->meth == 1U) {
#line 1499
    if (p_colr_header_size < 7U) {
      {
#line 1500
      opj_event_msg(p_manager, 1, "Bad COLR header box (bad size: %d)\n1 V", p_colr_header_size);
      }
#line 1502
      return (0);
    }
#line 1504
    if (p_colr_header_size > 7U) {
#line 1504
      if (jp2->enumcs != 14U) {
        {
#line 1507
        opj_event_msg(p_manager, 2, "Bad COLR header box (bad size: %d)\n1 V", p_colr_header_size);
        }
      }
    }
    {
#line 1511
    opj_read_bytes_LE(p_colr_header_data, & jp2->enumcs, (OPJ_UINT32 )4);
#line 1513
    p_colr_header_data += 4;
    }
#line 1515
    if (jp2->enumcs == 14U) {
      {
#line 1519
      __cil_tmp17 = opj_malloc(9UL * sizeof(OPJ_UINT32 ));
#line 1519
      cielab = (OPJ_UINT32 *)__cil_tmp17;
      }
#line 1520
      if ((unsigned long )cielab == (unsigned long )((void *)0)) {
        {
#line 1521
        opj_event_msg(p_manager, 1, "Not enough memory for cielab\nV");
        }
#line 1522
        return (0);
      }
#line 1524
      *(cielab + 0) = (OPJ_UINT32 )14;
#line 1527
      ob = (OPJ_UINT32 )0;
#line 1527
      oa = ob;
#line 1527
      ol = oa;
#line 1527
      rb = ol;
#line 1527
      ra = rb;
#line 1527
      rl = ra;
#line 1528
      il = (OPJ_UINT32 )4470064;
#line 1529
      *(cielab + 1) = (OPJ_UINT32 )1145390592;
#line 1531
      if (p_colr_header_size == 35U) {
        {
#line 1532
        opj_read_bytes_LE(p_colr_header_data, & rl, (OPJ_UINT32 )4);
#line 1533
        p_colr_header_data += 4;
#line 1534
        opj_read_bytes_LE(p_colr_header_data, & ol, (OPJ_UINT32 )4);
#line 1535
        p_colr_header_data += 4;
#line 1536
        opj_read_bytes_LE(p_colr_header_data, & ra, (OPJ_UINT32 )4);
#line 1537
        p_colr_header_data += 4;
#line 1538
        opj_read_bytes_LE(p_colr_header_data, & oa, (OPJ_UINT32 )4);
#line 1539
        p_colr_header_data += 4;
#line 1540
        opj_read_bytes_LE(p_colr_header_data, & rb, (OPJ_UINT32 )4);
#line 1541
        p_colr_header_data += 4;
#line 1542
        opj_read_bytes_LE(p_colr_header_data, & ob, (OPJ_UINT32 )4);
#line 1543
        p_colr_header_data += 4;
#line 1544
        opj_read_bytes_LE(p_colr_header_data, & il, (OPJ_UINT32 )4);
#line 1545
        p_colr_header_data += 4;
#line 1547
        *(cielab + 1) = (OPJ_UINT32 )0;
        }
      } else
#line 1548
      if (p_colr_header_size != 7U) {
        {
#line 1549
        opj_event_msg(p_manager, 2, "Bad COLR header box (CIELab, bad size: %d)\n1 V",
                      p_colr_header_size);
        }
      }
#line 1552
      *(cielab + 2) = rl;
#line 1553
      *(cielab + 4) = ra;
#line 1554
      *(cielab + 6) = rb;
#line 1555
      *(cielab + 3) = ol;
#line 1556
      *(cielab + 5) = oa;
#line 1557
      *(cielab + 7) = ob;
#line 1558
      *(cielab + 8) = il;
#line 1560
      jp2->color.icc_profile_buf = (OPJ_BYTE *)cielab;
#line 1561
      jp2->color.icc_profile_len = (OPJ_UINT32 )0;
    }
#line 1563
    jp2->color.jp2_has_colr = (OPJ_BYTE )1;
  } else
#line 1564
  if (jp2->meth == 2U) {
    {
#line 1566
    it_icc_value = 0;
#line 1567
    icc_len = (OPJ_INT32 )p_colr_header_size - 3;
#line 1569
    jp2->color.icc_profile_len = (OPJ_UINT32 )icc_len;
#line 1570
    __cil_tmp20 = opj_calloc((size_t )1, (size_t )icc_len);
#line 1570
    jp2->color.icc_profile_buf = (OPJ_BYTE *)__cil_tmp20;
    }
#line 1571
    if (! jp2->color.icc_profile_buf) {
#line 1572
      jp2->color.icc_profile_len = (OPJ_UINT32 )0;
#line 1573
      return (0);
    }
#line 1576
    it_icc_value = 0;
    {
#line 1576
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1576
      if (! (it_icc_value < icc_len)) {
#line 1576
        goto while_break;
      }
      {
#line 1577
      opj_read_bytes_LE(p_colr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1578
      p_colr_header_data ++;
#line 1579
      *(jp2->color.icc_profile_buf + it_icc_value) = (OPJ_BYTE )l_value;
#line 1576
      it_icc_value ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 1582
    jp2->color.jp2_has_colr = (OPJ_BYTE )1;
  } else
#line 1583
  if (jp2->meth > 2U) {
    {
#line 1586
    opj_event_msg(p_manager, 4, "COLR BOX meth value is not a regular value (%d), so we will ignore the entire Colour Specification box. \n",
                  jp2->meth);
    }
  }
#line 1590
  if (jp2->color.jp2_has_colr) {
#line 1591
    (jp2->j2k)->enumcs = jp2->enumcs;
  }
#line 1593
  return (1);
}
}
#line 1596 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 1601
  if (! p_image) {
#line 1602
    return (0);
  }
  {
#line 1606
  __cil_tmp5 = opj_j2k_decode(jp2->j2k, p_stream, p_image, p_manager);
  }
#line 1606
  if (! __cil_tmp5) {
    {
#line 1607
    opj_event_msg(p_manager, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 1609
    return (0);
  }
#line 1612
  if (! jp2->ignore_pclr_cmap_cdef) {
    {
#line 1613
    __cil_tmp6 = opj_jp2_check_color(p_image, & jp2->color, p_manager);
    }
#line 1613
    if (! __cil_tmp6) {
#line 1614
      return (0);
    }
#line 1618
    if (jp2->enumcs == 16U) {
#line 1619
      p_image->color_space = (OPJ_COLOR_SPACE )1;
    } else
#line 1620
    if (jp2->enumcs == 17U) {
#line 1621
      p_image->color_space = (OPJ_COLOR_SPACE )2;
    } else
#line 1622
    if (jp2->enumcs == 18U) {
#line 1623
      p_image->color_space = (OPJ_COLOR_SPACE )3;
    } else
#line 1624
    if (jp2->enumcs == 24U) {
#line 1625
      p_image->color_space = (OPJ_COLOR_SPACE )4;
    } else
#line 1626
    if (jp2->enumcs == 12U) {
#line 1627
      p_image->color_space = (OPJ_COLOR_SPACE )5;
    } else {
#line 1629
      p_image->color_space = (OPJ_COLOR_SPACE )-1;
    }
#line 1632
    if (jp2->color.jp2_pclr) {
#line 1634
      if (! (jp2->color.jp2_pclr)->cmap) {
        {
#line 1635
        opj_jp2_free_pclr(& jp2->color);
        }
      } else {
        {
#line 1637
        __cil_tmp7 = opj_jp2_apply_pclr(p_image, & jp2->color, p_manager);
        }
#line 1637
        if (! __cil_tmp7) {
#line 1638
          return (0);
        }
      }
    }
#line 1644
    if (jp2->color.jp2_cdef) {
      {
#line 1645
      opj_jp2_apply_cdef(p_image, & jp2->color, p_manager);
      }
    }
#line 1648
    if (jp2->color.icc_profile_buf) {
#line 1649
      p_image->icc_profile_buf = jp2->color.icc_profile_buf;
#line 1650
      p_image->icc_profile_len = jp2->color.icc_profile_len;
#line 1651
      jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
    }
  }
#line 1655
  return (1);
}
}
#line 1658 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_img_header_writer_handler_t l_writers[4] ;
  opj_jp2_img_header_writer_handler_t *l_current_writer ;
  OPJ_INT32 i ;
  OPJ_INT32 l_nb_pass ;
  OPJ_UINT32 l_jp2h_size ;
  OPJ_BOOL l_result ;
  OPJ_BYTE l_jp2h_data[8] ;
  OPJ_SIZE_T __cil_tmp16 ;
  OPJ_SIZE_T __cil_tmp17 ;

  {
  {
#line 1668
  l_jp2h_size = (OPJ_UINT32 )8;
#line 1669
  l_result = 1;
#line 1679
  memset((void *)(l_writers), 0, sizeof(l_writers));
  }
#line 1681
  if (jp2->bpc == 255U) {
#line 1682
    l_nb_pass = 3;
#line 1683
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1684
    l_writers[1].handler = & opj_jp2_write_bpcc;
#line 1685
    l_writers[2].handler = & opj_jp2_write_colr;
  } else {
#line 1687
    l_nb_pass = 2;
#line 1688
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1689
    l_writers[1].handler = & opj_jp2_write_colr;
  }
#line 1692
  if ((unsigned long )jp2->color.jp2_cdef != (unsigned long )((void *)0)) {
#line 1693
    l_writers[l_nb_pass].handler = & opj_jp2_write_cdef;
#line 1694
    l_nb_pass ++;
  }
  {
#line 1699
  opj_write_bytes_LE(l_jp2h_data + 4, (OPJ_UINT32 )1785737832, (OPJ_UINT32 )4);
#line 1701
  l_current_writer = l_writers;
#line 1702
  i = 0;
  }
  {
#line 1702
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1702
    if (! (i < l_nb_pass)) {
#line 1702
      goto while_break;
    }
    {
#line 1703
    l_current_writer->m_data = (*(l_current_writer->handler))(jp2, & l_current_writer->m_size);
    }
#line 1705
    if ((unsigned long )l_current_writer->m_data == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 1706
      opj_event_msg(p_manager, 1, "Not enough memory to hold JP2 Header data\n\3501 V");
#line 1708
      l_result = 0;
      }
#line 1709
      goto while_break;
    }
#line 1712
    l_jp2h_size += l_current_writer->m_size;
#line 1713
    l_current_writer ++;
#line 1702
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 1716
  if (! l_result) {
#line 1717
    l_current_writer = l_writers;
#line 1718
    i = 0;
    {
#line 1718
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1718
      if (! (i < l_nb_pass)) {
#line 1718
        goto while_break___0;
      }
#line 1719
      if ((unsigned long )l_current_writer->m_data != (unsigned long )((OPJ_BYTE *)0)) {
        {
#line 1720
        opj_free((void *)l_current_writer->m_data);
        }
      }
#line 1722
      l_current_writer ++;
#line 1718
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: ;
#line 1725
    return (0);
  }
  {
#line 1729
  opj_write_bytes_LE(l_jp2h_data, l_jp2h_size, (OPJ_UINT32 )4);
#line 1732
  __cil_tmp16 = opj_stream_write_data(stream, l_jp2h_data, (OPJ_SIZE_T )8, p_manager);
  }
#line 1732
  if (__cil_tmp16 != 8UL) {
    {
#line 1733
    opj_event_msg(p_manager, 1, "Stream error while writing JP2 Header box\n");
#line 1735
    l_result = 0;
    }
  }
#line 1738
  if (l_result) {
#line 1739
    l_current_writer = l_writers;
#line 1740
    i = 0;
    {
#line 1740
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1740
      if (! (i < l_nb_pass)) {
#line 1740
        goto while_break___1;
      }
      {
#line 1741
      __cil_tmp17 = opj_stream_write_data(stream, l_current_writer->m_data, (OPJ_SIZE_T )l_current_writer->m_size,
                                          p_manager);
      }
#line 1741
      if (__cil_tmp17 != (unsigned long )l_current_writer->m_size) {
        {
#line 1743
        opj_event_msg(p_manager, 1, "Stream error while writing JP2 Header box\n");
#line 1745
        l_result = 0;
        }
#line 1746
        goto while_break___1;
      }
#line 1748
      l_current_writer ++;
#line 1740
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 1752
  l_current_writer = l_writers;
#line 1755
  i = 0;
  {
#line 1755
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1755
    if (! (i < l_nb_pass)) {
#line 1755
      goto while_break___2;
    }
#line 1756
    if ((unsigned long )l_current_writer->m_data != (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 1757
      opj_free((void *)l_current_writer->m_data);
      }
    }
#line 1759
    l_current_writer ++;
#line 1755
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 1762
  return (l_result);
}
}
#line 1765 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_ftyp_size ;
  OPJ_BYTE *l_ftyp_data ;
  OPJ_BYTE *l_current_data_ptr ;
  OPJ_BOOL l_result ;
  void *__cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 1778
  l_ftyp_size = 16U + 4U * jp2->numcl;
#line 1780
  __cil_tmp12 = opj_calloc((size_t )1, (size_t )l_ftyp_size);
#line 1780
  l_ftyp_data = (OPJ_BYTE *)__cil_tmp12;
  }
#line 1782
  if ((unsigned long )l_ftyp_data == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 1783
    opj_event_msg(p_manager, 1, "Not enough memory to handle ftyp data\n\002");
    }
#line 1784
    return (0);
  }
  {
#line 1787
  l_current_data_ptr = l_ftyp_data;
#line 1789
  opj_write_bytes_LE(l_current_data_ptr, l_ftyp_size, (OPJ_UINT32 )4);
#line 1790
  l_current_data_ptr += 4;
#line 1792
  opj_write_bytes_LE(l_current_data_ptr, (OPJ_UINT32 )1718909296, (OPJ_UINT32 )4);
#line 1793
  l_current_data_ptr += 4;
#line 1795
  opj_write_bytes_LE(l_current_data_ptr, jp2->brand, (OPJ_UINT32 )4);
#line 1796
  l_current_data_ptr += 4;
#line 1798
  opj_write_bytes_LE(l_current_data_ptr, jp2->minversion, (OPJ_UINT32 )4);
#line 1799
  l_current_data_ptr += 4;
#line 1801
  i = (OPJ_UINT32 )0;
  }
  {
#line 1801
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1801
    if (! (i < jp2->numcl)) {
#line 1801
      goto while_break;
    }
    {
#line 1802
    opj_write_bytes_LE(l_current_data_ptr, *(jp2->cl + i), (OPJ_UINT32 )4);
#line 1801
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1805
  __cil_tmp14 = opj_stream_write_data(cio, l_ftyp_data, (OPJ_SIZE_T )l_ftyp_size,
                                      p_manager);
#line 1805
  l_result = __cil_tmp14 == (unsigned long )l_ftyp_size;
  }
#line 1807
  if (! l_result) {
    {
#line 1808
    opj_event_msg(p_manager, 1, "Error while writing ftyp data to stream\n\220");
    }
  }
  {
#line 1812
  opj_free((void *)l_ftyp_data);
  }
#line 1814
  return (l_result);
}
}
#line 1817 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T j2k_codestream_exit ;
  OPJ_BYTE l_data_header[8] ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 1830
  j2k_codestream_exit = opj_stream_tell(cio);
#line 1831
  opj_write_bytes_LE(l_data_header, (OPJ_UINT32 )(j2k_codestream_exit - jp2->j2k_codestream_offset),
                     (OPJ_UINT32 )4);
#line 1834
  opj_write_bytes_LE(l_data_header + 4, (OPJ_UINT32 )1785737827, (OPJ_UINT32 )4);
#line 1837
  __cil_tmp12 = opj_stream_seek(cio, jp2->j2k_codestream_offset, p_manager);
  }
#line 1837
  if (! __cil_tmp12) {
    {
#line 1838
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1839
    return (0);
  }
  {
#line 1842
  __cil_tmp13 = opj_stream_write_data(cio, l_data_header, (OPJ_SIZE_T )8, p_manager);
  }
#line 1842
  if (__cil_tmp13 != 8UL) {
    {
#line 1843
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1844
    return (0);
  }
  {
#line 1847
  __cil_tmp14 = opj_stream_seek(cio, j2k_codestream_exit, p_manager);
  }
#line 1847
  if (! __cil_tmp14) {
    {
#line 1848
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1849
    return (0);
  }
#line 1852
  return (1);
}
}
#line 1855 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_signature_data[12] ;
  OPJ_SIZE_T __cil_tmp8 ;

  {
  {
#line 1870
  opj_write_bytes_LE(l_signature_data, (OPJ_UINT32 )12, (OPJ_UINT32 )4);
#line 1872
  opj_write_bytes_LE(l_signature_data + 4, (OPJ_UINT32 )1783636000, (OPJ_UINT32 )4);
#line 1874
  opj_write_bytes_LE(l_signature_data + 8, (OPJ_UINT32 )218793738, (OPJ_UINT32 )4);
#line 1876
  __cil_tmp8 = opj_stream_write_data(cio, l_signature_data, (OPJ_SIZE_T )12, p_manager);
  }
#line 1876
  if (__cil_tmp8 != 12UL) {
#line 1877
    return (0);
  }
#line 1880
  return (1);
}
}
#line 1887 "/root/patron/new_24/src/lib/openjp2/jp2.c"
void opj_jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) 
{ 


  {
  {
#line 1890
  opj_j2k_setup_decoder(jp2->j2k, parameters);
#line 1893
  jp2->color.jp2_has_colr = (OPJ_BYTE )0;
#line 1894
  jp2->ignore_pclr_cmap_cdef = (OPJ_BOOL )(parameters->flags & 1U);
  }
#line 1896
  return;
}
}
#line 1898 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_threads(opj_jp2_t *jp2 , OPJ_UINT32 num_threads ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 1900
  __cil_tmp3 = opj_j2k_set_threads(jp2->j2k, num_threads);
  }
#line 1900
  return (__cil_tmp3);
}
}
#line 1907 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 depth_0 ;
  OPJ_UINT32 sign ;
  OPJ_UINT32 alpha_count ;
  OPJ_UINT32 color_channels ;
  OPJ_UINT32 alpha_channel ;
  OPJ_BOOL __cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  OPJ_UINT32 depth ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
#line 1916
  color_channels = 0U;
#line 1917
  alpha_channel = 0U;
#line 1920
  if (! jp2) {
#line 1921
    return (0);
  } else
#line 1920
  if (! parameters) {
#line 1921
    return (0);
  } else
#line 1920
  if (! image) {
#line 1921
    return (0);
  }
#line 1928
  if (image->numcomps < 1U) {
    {
#line 1929
    opj_event_msg(p_manager, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
#line 1931
    return (0);
  } else
#line 1928
  if (image->numcomps > 16384U) {
    {
#line 1929
    opj_event_msg(p_manager, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
#line 1931
    return (0);
  }
  {
#line 1934
  __cil_tmp11 = opj_j2k_setup_encoder(jp2->j2k, parameters, image, p_manager);
  }
#line 1934
  if (__cil_tmp11 == 0) {
#line 1936
    return (0);
  }
  {
#line 1944
  jp2->brand = (OPJ_UINT32 )1785737760;
#line 1945
  jp2->minversion = (OPJ_UINT32 )0;
#line 1946
  jp2->numcl = (OPJ_UINT32 )1;
#line 1947
  __cil_tmp12 = opj_malloc((unsigned long )jp2->numcl * sizeof(OPJ_UINT32 ));
#line 1947
  jp2->cl = (OPJ_UINT32 *)__cil_tmp12;
  }
#line 1948
  if (! jp2->cl) {
    {
#line 1949
    opj_event_msg(p_manager, 1, "Not enough memory when setup the JP2 encoder\nV");
    }
#line 1951
    return (0);
  }
  {
#line 1953
  *(jp2->cl + 0) = (OPJ_UINT32 )1785737760;
#line 1957
  jp2->numcomps = image->numcomps;
#line 1958
  __cil_tmp13 = opj_malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 1958
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp13;
  }
#line 1960
  if (! jp2->comps) {
    {
#line 1961
    opj_event_msg(p_manager, 1, "Not enough memory when setup the JP2 encoder\n");
    }
#line 1964
    return (0);
  }
#line 1967
  jp2->h = image->y1 - image->y0;
#line 1968
  jp2->w = image->x1 - image->x0;
#line 1970
  depth_0 = (image->comps + 0)->prec - 1U;
#line 1971
  sign = (image->comps + 0)->sgnd;
#line 1972
  jp2->bpc = depth_0 + (sign << 7);
#line 1973
  i = (OPJ_UINT32 )1;
  {
#line 1973
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1973
    if (! (i < image->numcomps)) {
#line 1973
      goto while_break;
    }
#line 1974
    depth = (image->comps + i)->prec - 1U;
#line 1975
    sign = (image->comps + i)->sgnd;
#line 1976
    if (depth_0 != depth) {
#line 1977
      jp2->bpc = (OPJ_UINT32 )255;
    }
#line 1973
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 1980
  jp2->C = (OPJ_UINT32 )7;
#line 1981
  jp2->UnkC = (OPJ_UINT32 )0;
#line 1982
  jp2->IPR = (OPJ_UINT32 )0;
#line 1985
  i = (OPJ_UINT32 )0;
  {
#line 1985
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1985
    if (! (i < image->numcomps)) {
#line 1985
      goto while_break___0;
    }
#line 1986
    (jp2->comps + i)->bpcc = ((image->comps + i)->prec - 1U) + ((image->comps + i)->sgnd << 7);
#line 1985
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1990
  if (image->icc_profile_len) {
#line 1991
    jp2->meth = (OPJ_UINT32 )2;
#line 1992
    jp2->enumcs = (OPJ_UINT32 )0;
  } else {
#line 1994
    jp2->meth = (OPJ_UINT32 )1;
#line 1995
    if ((int )image->color_space == 1) {
#line 1996
      jp2->enumcs = (OPJ_UINT32 )16;
    } else
#line 1997
    if ((int )image->color_space == 2) {
#line 1998
      jp2->enumcs = (OPJ_UINT32 )17;
    } else
#line 1999
    if ((int )image->color_space == 3) {
#line 2000
      jp2->enumcs = (OPJ_UINT32 )18;
    }
  }
#line 2007
  alpha_count = 0U;
#line 2008
  i = (OPJ_UINT32 )0;
  {
#line 2008
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 2008
    if (! (i < image->numcomps)) {
#line 2008
      goto while_break___1;
    }
#line 2009
    if ((int )(image->comps + i)->alpha != 0) {
#line 2010
      alpha_count ++;
#line 2011
      alpha_channel = i;
    }
#line 2008
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: ;
#line 2014
  if (alpha_count == 1U) {
#line 2017
    if (jp2->enumcs == 18U) {
#line 2017
      goto case_18;
    }
#line 2017
    if (jp2->enumcs == 16U) {
#line 2017
      goto case_18;
    }
#line 2020
    if (jp2->enumcs == 17U) {
#line 2020
      goto case_17;
    }
#line 2023
    goto switch_default;
    case_18: 
#line 2018
    color_channels = (OPJ_UINT32 )3;
#line 2019
    goto switch_break;
    case_17: 
#line 2021
    color_channels = (OPJ_UINT32 )1;
#line 2022
    goto switch_break;
    switch_default: 
#line 2024
    alpha_count = 0U;
#line 2025
    goto switch_break;
    switch_break: ;
#line 2027
    if (alpha_count == 0U) {
      {
#line 2028
      opj_event_msg(p_manager, 2, "Alpha channel specified but unknown enumcs. No cdef box will be created.\n");
      }
    } else
#line 2030
    if (image->numcomps < color_channels + 1U) {
      {
#line 2031
      opj_event_msg(p_manager, 2, "Alpha channel specified but not enough image components for an automatic cdef box creation.\n");
#line 2033
      alpha_count = 0U;
      }
    } else
#line 2034
    if (alpha_channel < color_channels) {
      {
#line 2035
      opj_event_msg(p_manager, 2, "Alpha channel position conflicts with color channel. No cdef box will be created.\n");
#line 2037
      alpha_count = 0U;
      }
    }
  } else
#line 2039
  if (alpha_count > 1U) {
    {
#line 2040
    opj_event_msg(p_manager, 2, "Multiple alpha channels specified. No cdef box will be created.\n\220");
    }
  }
#line 2043
  if (alpha_count == 1U) {
    {
#line 2044
    __cil_tmp19 = opj_malloc(sizeof(opj_jp2_cdef_t ));
#line 2044
    jp2->color.jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp19;
    }
#line 2045
    if (! jp2->color.jp2_cdef) {
      {
#line 2046
      opj_event_msg(p_manager, 1, "Not enough memory to setup the JP2 encoder\n");
      }
#line 2048
      return (0);
    }
    {
#line 2052
    __cil_tmp20 = opj_malloc((unsigned long )image->numcomps * sizeof(opj_jp2_cdef_info_t ));
#line 2052
    (jp2->color.jp2_cdef)->info = (opj_jp2_cdef_info_t *)__cil_tmp20;
    }
#line 2054
    if (! (jp2->color.jp2_cdef)->info) {
      {
#line 2056
      opj_event_msg(p_manager, 1, "Not enough memory to setup the JP2 encoder\n");
      }
#line 2058
      return (0);
    }
#line 2060
    (jp2->color.jp2_cdef)->n = (OPJ_UINT16 )image->numcomps;
#line 2062
    i = 0U;
    {
#line 2062
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 2062
      if (! (i < color_channels)) {
#line 2062
        goto while_break___2;
      }
#line 2063
      ((jp2->color.jp2_cdef)->info + i)->cn = (OPJ_UINT16 )i;
#line 2065
      ((jp2->color.jp2_cdef)->info + i)->typ = (OPJ_UINT16 )0U;
#line 2066
      ((jp2->color.jp2_cdef)->info + i)->asoc = (OPJ_UINT16 )(i + 1U);
#line 2062
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
    {
#line 2069
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 2069
      if (! (i < image->numcomps)) {
#line 2069
        goto while_break___3;
      }
#line 2070
      if ((int )(image->comps + i)->alpha != 0) {
#line 2071
        ((jp2->color.jp2_cdef)->info + i)->cn = (OPJ_UINT16 )i;
#line 2073
        ((jp2->color.jp2_cdef)->info + i)->typ = (OPJ_UINT16 )1U;
#line 2074
        ((jp2->color.jp2_cdef)->info + i)->asoc = (OPJ_UINT16 )0U;
      } else {
#line 2078
        ((jp2->color.jp2_cdef)->info + i)->cn = (OPJ_UINT16 )i;
#line 2080
        ((jp2->color.jp2_cdef)->info + i)->typ = (OPJ_UINT16 )65535U;
#line 2081
        ((jp2->color.jp2_cdef)->info + i)->asoc = (OPJ_UINT16 )65535U;
      }
#line 2069
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: ;
  }
#line 2086
  jp2->precedence = (OPJ_UINT32 )0;
#line 2087
  jp2->approx = (OPJ_UINT32 )0;
#line 2089
  jp2->jpip_on = parameters->jpip_on;
#line 2091
  return (1);
}
}
#line 2094 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 2098
  __cil_tmp4 = opj_j2k_encode(jp2->j2k, stream, p_manager);
  }
#line 2098
  return (__cil_tmp4);
}
}
#line 2101 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 2112
  __cil_tmp7 = opj_jp2_setup_end_header_reading(jp2, p_manager);
  }
#line 2112
  if (! __cil_tmp7) {
#line 2113
    return (0);
  }
  {
#line 2117
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_procedure_list, cio, p_manager);
  }
#line 2117
  if (! __cil_tmp8) {
#line 2118
    return (0);
  }
  {
#line 2121
  __cil_tmp9 = opj_j2k_end_decompress(jp2->j2k, cio, p_manager);
  }
#line 2121
  return (__cil_tmp9);
}
}
#line 2124 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 2135
  __cil_tmp7 = opj_jp2_setup_end_header_writing(jp2, p_manager);
  }
#line 2135
  if (! __cil_tmp7) {
#line 2136
    return (0);
  }
  {
#line 2139
  __cil_tmp8 = opj_j2k_end_compress(jp2->j2k, cio, p_manager);
  }
#line 2139
  if (! __cil_tmp8) {
#line 2140
    return (0);
  }
  {
#line 2144
  __cil_tmp9 = opj_jp2_exec(jp2, jp2->m_procedure_list, cio, p_manager);
  }
#line 2144
  return (__cil_tmp9);
}
}
#line 2147 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_end_header_writing(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 2162
  __cil_tmp5 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp2c),
                                                p_manager);
  }
#line 2162
  if (! __cil_tmp5) {
#line 2164
    return (0);
  }
#line 2179
  return (1);
}
}
#line 2182 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_end_header_reading(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 2189
  __cil_tmp5 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_read_header_procedure),
                                                p_manager);
  }
#line 2189
  if (! __cil_tmp5) {
#line 2191
    return (0);
  }
#line 2195
  return (1);
}
}
#line 2198 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2 , opj_stream_private_t *cio ,
                                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i ;
  OPJ_BOOL __cil_tmp9 ;
  int tmp___2 ;

  {
#line 2203
  l_is_valid = 1;
#line 2217
  l_is_valid &= jp2->jp2_state == 0U;
#line 2220
  l_is_valid &= jp2->jp2_img_state == 0U;
#line 2224
  l_is_valid &= (unsigned long )jp2->j2k != (unsigned long )((opj_j2k_t *)0);
#line 2227
  l_is_valid &= (unsigned long )jp2->m_procedure_list != (unsigned long )((struct opj_procedure_list *)0);
#line 2230
  l_is_valid &= (unsigned long )jp2->m_validation_list != (unsigned long )((struct opj_procedure_list *)0);
#line 2234
  l_is_valid &= jp2->numcl > 0U;
#line 2236
  l_is_valid &= jp2->h > 0U;
#line 2238
  l_is_valid &= jp2->w > 0U;
#line 2240
  i = (OPJ_UINT32 )0;
  {
#line 2240
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2240
    if (! (i < jp2->numcomps)) {
#line 2240
      goto while_break;
    }
#line 2241
    l_is_valid &= ((jp2->comps + i)->bpcc & 127U) < 38U;
#line 2240
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2246
  if (jp2->meth > 0U) {
#line 2246
    if (jp2->meth < 3U) {
#line 2246
      tmp___2 = 1;
    } else {
#line 2246
      tmp___2 = 0;
    }
  } else {
#line 2246
    tmp___2 = 0;
  }
  {
#line 2246
  l_is_valid &= tmp___2;
#line 2250
  __cil_tmp9 = opj_stream_has_seek(cio);
#line 2250
  l_is_valid &= __cil_tmp9;
  }
#line 2252
  return (l_is_valid);
}
}
#line 2255 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                              opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_box_t box ;
  OPJ_UINT32 l_nb_bytes_read ;
  opj_jp2_header_handler_t *l_current_handler ;
  opj_jp2_header_handler_t *l_current_handler_misplaced ;
  OPJ_UINT32 l_last_data_size ;
  OPJ_UINT32 l_current_data_size ;
  OPJ_BYTE *l_current_data ;
  void *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_OFF_T __cil_tmp18 ;
  OPJ_OFF_T __cil_tmp19 ;
  OPJ_OFF_T __cil_tmp20 ;
  OPJ_BYTE *new_current_data ;
  void *__cil_tmp22 ;
  OPJ_SIZE_T __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;
  OPJ_OFF_T __cil_tmp25 ;

  {
  {
#line 2264
  l_last_data_size = (OPJ_UINT32 )1024;
#line 2266
  l_current_data = (OPJ_BYTE *)0;
#line 2273
  __cil_tmp14 = opj_calloc((size_t )1, (size_t )l_last_data_size);
#line 2273
  l_current_data = (OPJ_BYTE *)__cil_tmp14;
  }
#line 2275
  if ((unsigned long )l_current_data == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 2276
    opj_event_msg(p_manager, 1, "Not enough memory to handle jpeg2000 file header\n\226\3511 V");
    }
#line 2278
    return (0);
  }
  {
#line 2281
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 2281
    __cil_tmp15 = opj_jp2_read_boxhdr(& box, & l_nb_bytes_read, stream, p_manager);
    }
#line 2281
    if (! __cil_tmp15) {
#line 2281
      goto while_break;
    }
#line 2283
    if (box.type == 1785737827U) {
#line 2284
      if (jp2->jp2_state & 4U) {
        {
#line 2285
        jp2->jp2_state |= 8U;
#line 2286
        opj_free((void *)l_current_data);
        }
#line 2287
        return (1);
      } else {
        {
#line 2289
        opj_event_msg(p_manager, 1, "bad placed jpeg codestream\n");
#line 2290
        opj_free((void *)l_current_data);
        }
#line 2291
        return (0);
      }
    } else
#line 2293
    if (box.length == 0U) {
      {
#line 2294
      opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
#line 2295
      opj_free((void *)l_current_data);
      }
#line 2296
      return (0);
    } else
#line 2299
    if (box.length < l_nb_bytes_read) {
      {
#line 2300
      opj_event_msg(p_manager, 1, "invalid box size %d (%x)\n", box.length, box.type);
#line 2302
      opj_free((void *)l_current_data);
      }
#line 2303
      return (0);
    }
    {
#line 2306
    l_current_handler = opj_jp2_find_handler(box.type);
#line 2307
    l_current_handler_misplaced = opj_jp2_img_find_handler(box.type);
#line 2308
    l_current_data_size = box.length - l_nb_bytes_read;
    }
#line 2310
    if ((unsigned long )l_current_handler != (unsigned long )((opj_jp2_header_handler_t *)0)) {
      _L: 
#line 2311
      if ((unsigned long )l_current_handler == (unsigned long )((opj_jp2_header_handler_t *)0)) {
        {
#line 2312
        opj_event_msg(p_manager, 2, "Found a misplaced \'%c%c%c%c\' box outside jp2h box\n\3521 V",
                      (int )((OPJ_BYTE )(box.type >> 24)), (int )((OPJ_BYTE )(box.type >> 16)),
                      (int )((OPJ_BYTE )(box.type >> 8)), (int )((OPJ_BYTE )box.type));
        }
#line 2316
        if (jp2->jp2_state & 4U) {
#line 2318
          l_current_handler = l_current_handler_misplaced;
        } else {
          {
#line 2320
          opj_event_msg(p_manager, 2, "JPEG2000 Header box not read yet, \'%c%c%c%c\' box will be ignored\n",
                        (int )((OPJ_BYTE )(box.type >> 24)), (int )((OPJ_BYTE )(box.type >> 16)),
                        (int )((OPJ_BYTE )(box.type >> 8)), (int )((OPJ_BYTE )box.type));
#line 2324
          jp2->jp2_state |= 2147483647U;
#line 2325
          __cil_tmp18 = opj_stream_skip(stream, (OPJ_OFF_T )l_current_data_size, p_manager);
          }
#line 2325
          if (__cil_tmp18 != (long )l_current_data_size) {
            {
#line 2327
            opj_event_msg(p_manager, 1, "Problem with skipping JPEG2000 box, stream error\n\272\3521 V");
#line 2329
            opj_free((void *)l_current_data);
            }
#line 2330
            return (0);
          }
#line 2332
          goto while_continue;
        }
      }
      {
#line 2335
      __cil_tmp19 = opj_stream_get_number_byte_left(stream);
      }
#line 2335
      if ((OPJ_OFF_T )l_current_data_size > __cil_tmp19) {
        {
#line 2337
        __cil_tmp20 = opj_stream_get_number_byte_left(stream);
#line 2337
        opj_event_msg(p_manager, 1, "Invalid box size %d for box \'%c%c%c%c\'. Need %d bytes, %d bytes remaining \n1 V",
                      box.length, (int )((OPJ_BYTE )(box.type >> 24)), (int )((OPJ_BYTE )(box.type >> 16)),
                      (int )((OPJ_BYTE )(box.type >> 8)), (int )((OPJ_BYTE )box.type),
                      l_current_data_size, (OPJ_UINT32 )__cil_tmp20);
#line 2342
        opj_free((void *)l_current_data);
        }
#line 2343
        return (0);
      }
#line 2345
      if (l_current_data_size > l_last_data_size) {
        {
#line 2346
        __cil_tmp22 = opj_realloc((void *)l_current_data, (size_t )l_current_data_size);
#line 2346
        new_current_data = (OPJ_BYTE *)__cil_tmp22;
        }
#line 2348
        if (! new_current_data) {
          {
#line 2349
          opj_free((void *)l_current_data);
#line 2350
          opj_event_msg(p_manager, 1, "Not enough memory to handle jpeg2000 box\n");
          }
#line 2352
          return (0);
        }
#line 2354
        l_current_data = new_current_data;
#line 2355
        l_last_data_size = l_current_data_size;
      }
      {
#line 2358
      __cil_tmp23 = opj_stream_read_data(stream, l_current_data, (OPJ_SIZE_T )l_current_data_size,
                                         p_manager);
#line 2358
      l_nb_bytes_read = (OPJ_UINT32 )__cil_tmp23;
      }
#line 2360
      if (l_nb_bytes_read != l_current_data_size) {
        {
#line 2361
        opj_event_msg(p_manager, 1, "Problem with reading JPEG2000 box, stream error\n\220");
#line 2363
        opj_free((void *)l_current_data);
        }
#line 2364
        return (0);
      }
      {
#line 2367
      __cil_tmp24 = (*(l_current_handler->handler))(jp2, l_current_data, l_current_data_size,
                                                    p_manager);
      }
#line 2367
      if (! __cil_tmp24) {
        {
#line 2369
        opj_free((void *)l_current_data);
        }
#line 2370
        return (0);
      }
    } else
#line 2310
    if ((unsigned long )l_current_handler_misplaced != (unsigned long )((opj_jp2_header_handler_t *)0)) {
#line 2310
      goto _L;
    } else {
#line 2373
      if (! (jp2->jp2_state & 1U)) {
        {
#line 2374
        opj_event_msg(p_manager, 1, "Malformed JP2 file format: first box must be JPEG 2000 signature box\n");
#line 2376
        opj_free((void *)l_current_data);
        }
#line 2377
        return (0);
      }
#line 2379
      if (! (jp2->jp2_state & 2U)) {
        {
#line 2380
        opj_event_msg(p_manager, 1, "Malformed JP2 file format: second box must be file type box\n");
#line 2382
        opj_free((void *)l_current_data);
        }
#line 2383
        return (0);
      }
      {
#line 2385
      jp2->jp2_state |= 2147483647U;
#line 2386
      __cil_tmp25 = opj_stream_skip(stream, (OPJ_OFF_T )l_current_data_size, p_manager);
      }
#line 2386
      if (__cil_tmp25 != (long )l_current_data_size) {
#line 2388
        if (jp2->jp2_state & 8U) {
          {
#line 2391
          opj_event_msg(p_manager, 2, "Problem with skipping JPEG2000 box, stream error\n");
#line 2393
          opj_free((void *)l_current_data);
          }
#line 2394
          return (1);
        } else {
          {
#line 2396
          opj_event_msg(p_manager, 1, "Problem with skipping JPEG2000 box, stream error\n");
#line 2398
          opj_free((void *)l_current_data);
          }
#line 2399
          return (0);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2405
  opj_free((void *)l_current_data);
  }
#line 2407
  return (1);
}
}
#line 2420 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i ;
  opj_procedure *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  int tmp___3 ;

  {
  {
#line 2427
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 2429
  l_result = 1;
#line 2438
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 2439
  __cil_tmp14 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 2439
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp14;
#line 2442
  i = (OPJ_UINT32 )0;
  }
  {
#line 2442
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2442
    if (! (i < l_nb_proc)) {
#line 2442
      goto while_break;
    }
    {
#line 2443
    __cil_tmp15 = (*(*l_procedure))(jp2, stream, p_manager);
    }
#line 2443
    if (l_result) {
#line 2443
      if (__cil_tmp15) {
#line 2443
        tmp___3 = 1;
      } else {
#line 2443
        tmp___3 = 0;
      }
    } else {
#line 2443
      tmp___3 = 0;
    }
#line 2443
    l_result = tmp___3;
#line 2444
    l_procedure ++;
#line 2442
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2448
  opj_procedure_list_clear(p_procedure_list);
  }
#line 2449
  return (l_result);
}
}
#line 2452 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_image_t *p_image ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 2464
  __cil_tmp8 = opj_jp2_setup_encoding_validation(jp2, p_manager);
  }
#line 2464
  if (! __cil_tmp8) {
#line 2465
    return (0);
  }
  {
#line 2469
  __cil_tmp9 = opj_jp2_exec(jp2, jp2->m_validation_list, stream, p_manager);
  }
#line 2469
  if (! __cil_tmp9) {
#line 2470
    return (0);
  }
  {
#line 2474
  __cil_tmp10 = opj_jp2_setup_header_writing(jp2, p_manager);
  }
#line 2474
  if (! __cil_tmp10) {
#line 2475
    return (0);
  }
  {
#line 2479
  __cil_tmp11 = opj_jp2_exec(jp2, jp2->m_procedure_list, stream, p_manager);
  }
#line 2479
  if (! __cil_tmp11) {
#line 2480
    return (0);
  }
  {
#line 2483
  __cil_tmp12 = opj_j2k_start_compress(jp2->j2k, stream, p_image, p_manager);
  }
#line 2483
  return (__cil_tmp12);
}
}
#line 2486 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_handler_size ;

  {
#line 2488
  l_handler_size = (OPJ_UINT32 )(sizeof(jp2_header) / sizeof(opj_jp2_header_handler_t ));
#line 2491
  i = (OPJ_UINT32 )0;
  {
#line 2491
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2491
    if (! (i < l_handler_size)) {
#line 2491
      goto while_break;
    }
#line 2492
    if (jp2_header[i].id == p_id) {
#line 2493
      return (& jp2_header[i]);
    }
#line 2491
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2496
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 2506 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_handler_size ;

  {
#line 2509
  l_handler_size = (OPJ_UINT32 )(sizeof(jp2_img_header) / sizeof(opj_jp2_header_handler_t ));
#line 2511
  i = (OPJ_UINT32 )0;
  {
#line 2511
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2511
    if (! (i < l_handler_size)) {
#line 2511
      goto while_break;
    }
#line 2512
    if (jp2_img_header[i].id == p_id) {
#line 2513
      return (& jp2_img_header[i]);
    }
#line 2511
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2517
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 2530 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_magic_number ;

  {
#line 2544
  if (jp2->jp2_state != 0U) {
    {
#line 2545
    opj_event_msg(p_manager, 1, "The signature box must be the first box in the file.\n");
    }
#line 2547
    return (0);
  }
#line 2551
  if (p_header_size != 4U) {
    {
#line 2552
    opj_event_msg(p_manager, 1, "Error with JP signature Box size\n");
    }
#line 2553
    return (0);
  }
  {
#line 2557
  opj_read_bytes_LE(p_header_data, & l_magic_number, (OPJ_UINT32 )4);
  }
#line 2558
  if (l_magic_number != 218793738U) {
    {
#line 2559
    opj_event_msg(p_manager, 1, "Error with JP Signature : bad magic number\n");
    }
#line 2561
    return (0);
  }
#line 2564
  jp2->jp2_state |= 1U;
#line 2566
  return (1);
}
}
#line 2579 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_remaining_bytes ;
  void *__cil_tmp10 ;

  {
#line 2592
  if (jp2->jp2_state != 1U) {
    {
#line 2593
    opj_event_msg(p_manager, 1, "The ftyp box must be the second box in the file.\n");
    }
#line 2595
    return (0);
  }
#line 2599
  if (p_header_size < 8U) {
    {
#line 2600
    opj_event_msg(p_manager, 1, "Error with FTYP signature Box size\n");
    }
#line 2601
    return (0);
  }
  {
#line 2604
  opj_read_bytes_LE(p_header_data, & jp2->brand, (OPJ_UINT32 )4);
#line 2605
  p_header_data += 4;
#line 2607
  opj_read_bytes_LE(p_header_data, & jp2->minversion, (OPJ_UINT32 )4);
#line 2608
  p_header_data += 4;
#line 2610
  l_remaining_bytes = p_header_size - 8U;
  }
#line 2613
  if ((l_remaining_bytes & 3U) != 0U) {
    {
#line 2614
    opj_event_msg(p_manager, 1, "Error with FTYP signature Box size\n");
    }
#line 2615
    return (0);
  }
#line 2619
  jp2->numcl = l_remaining_bytes >> 2;
#line 2620
  if (jp2->numcl) {
    {
#line 2621
    __cil_tmp10 = opj_calloc((size_t )jp2->numcl, sizeof(OPJ_UINT32 ));
#line 2621
    jp2->cl = (OPJ_UINT32 *)__cil_tmp10;
    }
#line 2622
    if ((unsigned long )jp2->cl == (unsigned long )((OPJ_UINT32 *)0)) {
      {
#line 2623
      opj_event_msg(p_manager, 1, "Not enough memory with FTYP Box\n\220");
      }
#line 2624
      return (0);
    }
  }
#line 2628
  i = (OPJ_UINT32 )0;
  {
#line 2628
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2628
    if (! (i < jp2->numcl)) {
#line 2628
      goto while_break;
    }
    {
#line 2629
    opj_read_bytes_LE(p_header_data, jp2->cl + i, (OPJ_UINT32 )4);
#line 2630
    p_header_data += 4;
#line 2628
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 2633
  jp2->jp2_state |= 2U;
#line 2635
  return (1);
}
}
#line 2638 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T __cil_tmp8 ;

  {
  {
#line 2647
  jp2->j2k_codestream_offset = opj_stream_tell(stream);
#line 2649
  __cil_tmp8 = opj_stream_skip(stream, (OPJ_OFF_T )8, p_manager);
  }
#line 2649
  if (__cil_tmp8 != 8L) {
#line 2650
    return (0);
  }
#line 2653
  return (1);
}
}
#line 2656 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jpip_skip_iptr(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T __cil_tmp8 ;

  {
  {
#line 2665
  jp2->jpip_iptr_offset = opj_stream_tell(stream);
#line 2667
  __cil_tmp8 = opj_stream_skip(stream, (OPJ_OFF_T )24, p_manager);
  }
#line 2667
  if (__cil_tmp8 != 24L) {
#line 2668
    return (0);
  }
#line 2671
  return (1);
}
}
#line 2684 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_box_size ;
  OPJ_UINT32 l_current_data_size ;
  opj_jp2_box_t box ;
  opj_jp2_header_handler_t *l_current_handler ;
  OPJ_BOOL l_has_ihdr ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 2690
  l_box_size = (OPJ_UINT32 )0;
#line 2690
  l_current_data_size = (OPJ_UINT32 )0;
#line 2693
  l_has_ihdr = 0;
#line 2701
  if ((jp2->jp2_state & 2U) != 2U) {
    {
#line 2702
    opj_event_msg(p_manager, 1, "The  box must be the first box in the file.\n");
    }
#line 2704
    return (0);
  }
#line 2707
  jp2->jp2_img_state = (OPJ_UINT32 )0;
  {
#line 2710
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2710
    if (! (p_header_size > 0U)) {
#line 2710
      goto while_break;
    }
    {
#line 2712
    __cil_tmp13 = opj_jp2_read_boxhdr_char(& box, p_header_data, & l_box_size, p_header_size,
                                           p_manager);
    }
#line 2712
    if (! __cil_tmp13) {
      {
#line 2714
      opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box\n");
      }
#line 2716
      return (0);
    }
#line 2719
    if (box.length > p_header_size) {
      {
#line 2720
      opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box: box length is inconsistent.\n");
      }
#line 2722
      return (0);
    }
    {
#line 2725
    l_current_handler = opj_jp2_img_find_handler(box.type);
#line 2726
    l_current_data_size = box.length - l_box_size;
#line 2727
    p_header_data += l_box_size;
    }
#line 2729
    if ((unsigned long )l_current_handler != (unsigned long )((opj_jp2_header_handler_t *)0)) {
      {
#line 2730
      __cil_tmp15 = (*(l_current_handler->handler))(jp2, p_header_data, l_current_data_size,
                                                    p_manager);
      }
#line 2730
      if (! __cil_tmp15) {
#line 2732
        return (0);
      }
    } else {
#line 2735
      jp2->jp2_img_state |= 2147483647U;
    }
#line 2738
    if (box.type == 1768449138U) {
#line 2739
      l_has_ihdr = 1;
    }
#line 2742
    p_header_data += l_current_data_size;
#line 2743
    p_header_size -= box.length;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2746
  if (l_has_ihdr == 0) {
    {
#line 2747
    opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box: no \'ihdr\' box.\n");
    }
#line 2749
    return (0);
  }
#line 2752
  jp2->jp2_state |= 4U;
#line 2753
  jp2->has_jp2h = (OPJ_BYTE )1;
#line 2755
  return (1);
}
}
#line 2758 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box , OPJ_BYTE *p_data , OPJ_UINT32 *p_number_bytes_read ,
                                         OPJ_UINT32 p_box_max_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_value ;
  OPJ_UINT32 l_xl_part_size ;

  {
#line 2773
  if (p_box_max_size < 8U) {
    {
#line 2774
    opj_event_msg(p_manager, 1, "Cannot handle box of less than 8 bytes\n");
    }
#line 2775
    return (0);
  }
  {
#line 2779
  opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2780
  p_data += 4;
#line 2781
  box->length = l_value;
#line 2783
  opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2784
  p_data += 4;
#line 2785
  box->type = l_value;
#line 2787
  *p_number_bytes_read = (OPJ_UINT32 )8;
  }
#line 2791
  if (box->length == 1U) {
#line 2794
    if (p_box_max_size < 16U) {
      {
#line 2795
      opj_event_msg(p_manager, 1, "Cannot handle XL box of less than 16 bytes\n1 V");
      }
#line 2797
      return (0);
    }
    {
#line 2800
    opj_read_bytes_LE(p_data, & l_xl_part_size, (OPJ_UINT32 )4);
#line 2801
    p_data += 4;
#line 2802
    *p_number_bytes_read += 4U;
    }
#line 2804
    if (l_xl_part_size != 0U) {
      {
#line 2805
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\nE\3541 V");
      }
#line 2807
      return (0);
    }
    {
#line 2810
    opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2811
    *p_number_bytes_read += 4U;
#line 2812
    box->length = l_value;
    }
#line 2814
    if (box->length == 0U) {
      {
#line 2815
      opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
      }
#line 2816
      return (0);
    }
  } else
#line 2818
  if (box->length == 0U) {
    {
#line 2819
    opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
    }
#line 2820
    return (0);
  }
#line 2822
  if (box->length < *p_number_bytes_read) {
    {
#line 2823
    opj_event_msg(p_manager, 1, "Box length is inconsistent.\n");
    }
#line 2824
    return (0);
  }
#line 2826
  return (1);
}
}
#line 2829 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream , opj_jp2_t *jp2 , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 2841
  __cil_tmp8 = opj_jp2_setup_decoding_validation(jp2, p_manager);
  }
#line 2841
  if (! __cil_tmp8) {
#line 2842
    return (0);
  }
  {
#line 2846
  __cil_tmp9 = opj_jp2_setup_header_reading(jp2, p_manager);
  }
#line 2846
  if (! __cil_tmp9) {
#line 2847
    return (0);
  }
  {
#line 2851
  __cil_tmp10 = opj_jp2_exec(jp2, jp2->m_validation_list, p_stream, p_manager);
  }
#line 2851
  if (! __cil_tmp10) {
#line 2852
    return (0);
  }
  {
#line 2856
  __cil_tmp11 = opj_jp2_exec(jp2, jp2->m_procedure_list, p_stream, p_manager);
  }
#line 2856
  if (! __cil_tmp11) {
#line 2857
    return (0);
  }
#line 2859
  if ((int )jp2->has_jp2h == 0) {
    {
#line 2860
    opj_event_msg(p_manager, 1, "JP2H box missing. Required.\n V");
    }
#line 2861
    return (0);
  }
#line 2863
  if ((int )jp2->has_ihdr == 0) {
    {
#line 2864
    opj_event_msg(p_manager, 1, "IHDR box_missing. Required.\n");
    }
#line 2865
    return (0);
  }
  {
#line 2868
  __cil_tmp12 = opj_j2k_read_header(p_stream, jp2->j2k, p_image, p_manager);
  }
#line 2868
  return (__cil_tmp12);
}
}
#line 2874 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_encoding_validation(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 2881
  __cil_tmp5 = opj_procedure_list_add_procedure(jp2->m_validation_list, (void (*)(void))(& opj_jp2_default_validation),
                                                p_manager);
  }
#line 2881
  if (! __cil_tmp5) {
#line 2883
    return (0);
  }
#line 2887
  return (1);
}
}
#line 2890 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_decoding_validation(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 


  {
#line 2902
  return (1);
}
}
#line 2905 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_header_writing(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 2912
  __cil_tmp5 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp),
                                                p_manager);
  }
#line 2912
  if (! __cil_tmp5) {
#line 2914
    return (0);
  }
  {
#line 2916
  __cil_tmp6 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_ftyp),
                                                p_manager);
  }
#line 2916
  if (! __cil_tmp6) {
#line 2918
    return (0);
  }
  {
#line 2920
  __cil_tmp7 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp2h),
                                                p_manager);
  }
#line 2920
  if (! __cil_tmp7) {
#line 2922
    return (0);
  }
#line 2924
  if (jp2->jpip_on) {
    {
#line 2925
    __cil_tmp8 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jpip_skip_iptr),
                                                  p_manager);
    }
#line 2925
    if (! __cil_tmp8) {
#line 2927
      return (0);
    }
  }
  {
#line 2930
  __cil_tmp9 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_skip_jp2c),
                                                p_manager);
  }
#line 2930
  if (! __cil_tmp9) {
#line 2932
    return (0);
  }
#line 2937
  return (1);
}
}
#line 2940 "/root/patron/new_24/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_header_reading(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 2947
  __cil_tmp5 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_read_header_procedure),
                                                p_manager);
  }
#line 2947
  if (! __cil_tmp5) {
#line 2949
    return (0);
  }
#line 2954
  return (1);
}
}
#line 2957 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 2970
  __cil_tmp12 = opj_j2k_read_tile_header(p_jp2->j2k, p_tile_index, p_data_size, p_tile_x0,
                                         p_tile_y0, p_tile_x1, p_tile_y1, p_nb_comps,
                                         p_go_on, p_stream, p_manager);
  }
#line 2970
  return (__cil_tmp12);
}
}
#line 2981 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 2990
  __cil_tmp7 = opj_j2k_write_tile(p_jp2->j2k, p_tile_index, p_data, p_data_size, p_stream,
                                  p_manager);
  }
#line 2990
  return (__cil_tmp7);
}
}
#line 2994 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 3002
  __cil_tmp7 = opj_j2k_decode_tile(p_jp2->j2k, p_tile_index, p_data, p_data_size,
                                   p_stream, p_manager);
  }
#line 3002
  return (__cil_tmp7);
}
}
#line 3006 "/root/patron/new_24/src/lib/openjp2/jp2.c"
void opj_jp2_destroy(opj_jp2_t *jp2 ) 
{ 


  {
#line 3008
  if (jp2) {
    {
#line 3010
    opj_j2k_destroy(jp2->j2k);
#line 3011
    jp2->j2k = (opj_j2k_t *)0;
    }
#line 3013
    if (jp2->comps) {
      {
#line 3014
      opj_free((void *)jp2->comps);
#line 3015
      jp2->comps = (opj_jp2_comps_t *)0;
      }
    }
#line 3018
    if (jp2->cl) {
      {
#line 3019
      opj_free((void *)jp2->cl);
#line 3020
      jp2->cl = (OPJ_UINT32 *)0;
      }
    }
#line 3023
    if (jp2->color.icc_profile_buf) {
      {
#line 3024
      opj_free((void *)jp2->color.icc_profile_buf);
#line 3025
      jp2->color.icc_profile_buf = (OPJ_BYTE *)0;
      }
    }
#line 3028
    if (jp2->color.jp2_cdef) {
#line 3029
      if ((jp2->color.jp2_cdef)->info) {
        {
#line 3030
        opj_free((void *)(jp2->color.jp2_cdef)->info);
#line 3031
        (jp2->color.jp2_cdef)->info = (opj_jp2_cdef_info_t *)((void *)0);
        }
      }
      {
#line 3034
      opj_free((void *)jp2->color.jp2_cdef);
#line 3035
      jp2->color.jp2_cdef = (opj_jp2_cdef_t *)0;
      }
    }
#line 3038
    if (jp2->color.jp2_pclr) {
#line 3039
      if ((jp2->color.jp2_pclr)->cmap) {
        {
#line 3040
        opj_free((void *)(jp2->color.jp2_pclr)->cmap);
#line 3041
        (jp2->color.jp2_pclr)->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
        }
      }
#line 3043
      if ((jp2->color.jp2_pclr)->channel_sign) {
        {
#line 3044
        opj_free((void *)(jp2->color.jp2_pclr)->channel_sign);
#line 3045
        (jp2->color.jp2_pclr)->channel_sign = (OPJ_BYTE *)((void *)0);
        }
      }
#line 3047
      if ((jp2->color.jp2_pclr)->channel_size) {
        {
#line 3048
        opj_free((void *)(jp2->color.jp2_pclr)->channel_size);
#line 3049
        (jp2->color.jp2_pclr)->channel_size = (OPJ_BYTE *)((void *)0);
        }
      }
#line 3051
      if ((jp2->color.jp2_pclr)->entries) {
        {
#line 3052
        opj_free((void *)(jp2->color.jp2_pclr)->entries);
#line 3053
        (jp2->color.jp2_pclr)->entries = (OPJ_UINT32 *)((void *)0);
        }
      }
      {
#line 3056
      opj_free((void *)jp2->color.jp2_pclr);
#line 3057
      jp2->color.jp2_pclr = (opj_jp2_pclr_t *)0;
      }
    }
#line 3060
    if (jp2->m_validation_list) {
      {
#line 3061
      opj_procedure_list_destroy(jp2->m_validation_list);
#line 3062
      jp2->m_validation_list = (struct opj_procedure_list *)0;
      }
    }
#line 3065
    if (jp2->m_procedure_list) {
      {
#line 3066
      opj_procedure_list_destroy(jp2->m_procedure_list);
#line 3067
      jp2->m_procedure_list = (struct opj_procedure_list *)0;
      }
    }
    {
#line 3070
    opj_free((void *)jp2);
    }
  }
#line 3073
  return;
}
}
#line 3074 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2 , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 3081
  __cil_tmp8 = opj_j2k_set_decode_area(p_jp2->j2k, p_image, p_start_x, p_start_y,
                                       p_end_x, p_end_y, p_manager);
  }
#line 3081
  return (__cil_tmp8);
}
}
#line 3085 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) 
{ 
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 3092
  if (! p_image) {
#line 3093
    return (0);
  }
  {
#line 3096
  opj_event_msg(p_manager, 2, "JP2 box which are after the codestream will not be read by this function.\n");
#line 3099
  __cil_tmp6 = opj_j2k_get_tile(p_jp2->j2k, p_stream, p_image, p_manager, tile_index);
  }
#line 3099
  if (! __cil_tmp6) {
    {
#line 3100
    opj_event_msg(p_manager, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 3102
    return (0);
  }
  {
#line 3105
  __cil_tmp7 = opj_jp2_check_color(p_image, & p_jp2->color, p_manager);
  }
#line 3105
  if (! __cil_tmp7) {
#line 3106
    return (0);
  }
#line 3110
  if (p_jp2->enumcs == 16U) {
#line 3111
    p_image->color_space = (OPJ_COLOR_SPACE )1;
  } else
#line 3112
  if (p_jp2->enumcs == 17U) {
#line 3113
    p_image->color_space = (OPJ_COLOR_SPACE )2;
  } else
#line 3114
  if (p_jp2->enumcs == 18U) {
#line 3115
    p_image->color_space = (OPJ_COLOR_SPACE )3;
  } else
#line 3116
  if (p_jp2->enumcs == 24U) {
#line 3117
    p_image->color_space = (OPJ_COLOR_SPACE )4;
  } else
#line 3118
  if (p_jp2->enumcs == 12U) {
#line 3119
    p_image->color_space = (OPJ_COLOR_SPACE )5;
  } else {
#line 3121
    p_image->color_space = (OPJ_COLOR_SPACE )-1;
  }
#line 3124
  if (p_jp2->color.jp2_pclr) {
#line 3126
    if (! (p_jp2->color.jp2_pclr)->cmap) {
      {
#line 3127
      opj_jp2_free_pclr(& p_jp2->color);
      }
    } else {
      {
#line 3129
      __cil_tmp8 = opj_jp2_apply_pclr(p_image, & p_jp2->color, p_manager);
      }
#line 3129
      if (! __cil_tmp8) {
#line 3130
        return (0);
      }
    }
  }
#line 3136
  if (p_jp2->color.jp2_cdef) {
    {
#line 3137
    opj_jp2_apply_cdef(p_image, & p_jp2->color, p_manager);
    }
  }
#line 3140
  if (p_jp2->color.icc_profile_buf) {
#line 3141
    p_image->icc_profile_buf = p_jp2->color.icc_profile_buf;
#line 3142
    p_image->icc_profile_len = p_jp2->color.icc_profile_len;
#line 3143
    p_jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
  }
#line 3146
  return (1);
}
}
#line 3153 "/root/patron/new_24/src/lib/openjp2/jp2.c"
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 3155
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_jp2_t ));
#line 3155
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 3156
  if (jp2) {
#line 3159
    if (! p_is_decoder) {
      {
#line 3160
      jp2->j2k = opj_j2k_create_compress();
      }
    } else {
      {
#line 3162
      jp2->j2k = opj_j2k_create_decompress();
      }
    }
#line 3165
    if ((unsigned long )jp2->j2k == (unsigned long )((opj_j2k_t *)0)) {
      {
#line 3166
      opj_jp2_destroy(jp2);
      }
#line 3167
      return ((opj_jp2_t *)0);
    }
    {
#line 3171
    jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 3172
    jp2->color.icc_profile_len = (OPJ_UINT32 )0;
#line 3173
    jp2->color.jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
#line 3174
    jp2->color.jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
#line 3175
    jp2->color.jp2_has_colr = (OPJ_BYTE )0;
#line 3178
    jp2->m_validation_list = opj_procedure_list_create();
    }
#line 3179
    if (! jp2->m_validation_list) {
      {
#line 3180
      opj_jp2_destroy(jp2);
      }
#line 3181
      return ((opj_jp2_t *)0);
    }
    {
#line 3185
    jp2->m_procedure_list = opj_procedure_list_create();
    }
#line 3186
    if (! jp2->m_procedure_list) {
      {
#line 3187
      opj_jp2_destroy(jp2);
      }
#line 3188
      return ((opj_jp2_t *)0);
    }
  }
#line 3192
  return (jp2);
}
}
#line 3195 "/root/patron/new_24/src/lib/openjp2/jp2.c"
void jp2_dump(opj_jp2_t *p_jp2 , OPJ_INT32 flag , FILE *out_stream ) 
{ 


  {
  {
#line 3200
  j2k_dump(p_jp2->j2k, flag, out_stream);
  }
#line 3202
  return;
}
}
#line 3205 "/root/patron/new_24/src/lib/openjp2/jp2.c"
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2 ) 
{ 
  opj_codestream_index_t *__cil_tmp2 ;

  {
  {
#line 3207
  __cil_tmp2 = j2k_get_cstr_index(p_jp2->j2k);
  }
#line 3207
  return (__cil_tmp2);
}
}
#line 3210 "/root/patron/new_24/src/lib/openjp2/jp2.c"
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2 ) 
{ 
  opj_codestream_info_v2_t *__cil_tmp2 ;

  {
  {
#line 3212
  __cil_tmp2 = j2k_get_cstr_info(p_jp2->j2k);
  }
#line 3212
  return (__cil_tmp2);
}
}
#line 3215 "/root/patron/new_24/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2 , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 3219
  __cil_tmp4 = opj_j2k_set_decoded_resolution_factor(p_jp2->j2k, res_factor, p_manager);
  }
#line 3219
  return (__cil_tmp4);
}
}
#line 55 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 61
static OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) ;
#line 74
static OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) ;
#line 87
static OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) ;
#line 95
static OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 102
static OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 109
static OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 121
static OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) ;
#line 128
static OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) ;
#line 134
static OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) ;
#line 145
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) ;
#line 159
static OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 171
static OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 179
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) ;
#line 186
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) ;
#line 197
static struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) ;
#line 205
static void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) ;
#line 212
static void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) ;
#line 219
static void opj_j2k_cp_destroy(opj_cp_t *p_cp ) ;
#line 231
static OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                            OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) ;
#line 246
static OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                          OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) ;
#line 262
static OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                               OPJ_UINT32 p_comp_no ) ;
#line 274
static OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                         OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 289
static OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                             OPJ_UINT32 p_comp_no ) ;
#line 303
static OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) ;
#line 318
static OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                        OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) ;
#line 328
static void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) ;
#line 340
static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                       OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 351
static void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) ;
#line 358
static void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) ;
#line 363
static OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 367
static OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index ,
                                       opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 372
static OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , opj_image_t *p_output_image ) ;
#line 375
static void opj_get_tile_dimensions(opj_image_t *l_image , opj_tcd_tilecomp_t *l_tilec ,
                                    opj_image_comp_t *l_img_comp , OPJ_UINT32 *l_size_comp ,
                                    OPJ_UINT32 *l_width , OPJ_UINT32 *l_height , OPJ_UINT32 *l_offset_x ,
                                    OPJ_UINT32 *l_offset_y , OPJ_UINT32 *l_image_width ,
                                    OPJ_UINT32 *l_stride , OPJ_UINT32 *l_tile_offset ) ;
#line 387
static void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) ;
#line 389
static OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) ;
#line 397
static OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 400
static OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                              OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                                              opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) ;
#line 407
static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                                             opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) ;
#line 421
static OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                       struct opj_event_mgr *p_manager ) ;
#line 425
static OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) ;
#line 440
static OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 450
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) ;
#line 461
static OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 472
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 484
static OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 495
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 506
static OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 517
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 531
static OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) ;
#line 542
static OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 556
static void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) ;
#line 567
static OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) ;
#line 576
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 588
static OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 599
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 613
static OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) ;
#line 624
static OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 638
static void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) ;
#line 647
static OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) ;
#line 656
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 667
static OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 678
static void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) ;
#line 685
static OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) ;
#line 695
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 703
static OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) ;
#line 710
static OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) ;
#line 720
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 732
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 744
static OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                          struct opj_event_mgr *p_manager ) ;
#line 756
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 768
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 782
static OPJ_BOOL opj_j2k_read_ppm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 794
static OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp , opj_event_mgr_t *p_manager ) ;
#line 804
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 815
static OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp , opj_event_mgr_t *p_manager ) ;
#line 826
static OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 840
static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 p_total_data_size ,
                                  OPJ_UINT32 *p_data_written , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 860
static OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                       OPJ_UINT32 *p_tile_no , OPJ_UINT32 *p_tot_len ,
                                       OPJ_UINT32 *p_current_part , OPJ_UINT32 *p_num_parts ,
                                       opj_event_mgr_t *p_manager ) ;
#line 875
static OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 890
static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                                  OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                                  opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 905
static OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) ;
#line 909 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) 
{ 


  {
  {
#line 911
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_j2k->m_current_tile_number, (OPJ_UINT32 )1);
#line 913
  (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current) ++;
#line 915
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_tile_part_size, (OPJ_UINT32 )4);
#line 917
  p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;
  }
#line 919
  return;
}
}
#line 930
static OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                  OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 945
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 957
static OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 981
static OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                             struct opj_event_mgr *p_manager ) ;
#line 992
static OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1003
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 1013
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 1027
static OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 OPJ_UINT32 *output_marker , opj_event_mgr_t *p_manager ) ;
#line 1040
static OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 1053
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1066
static OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 1079
static OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1091
static OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1103
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1108
static OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) ;
#line 1111
static void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1113
static void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1115
static void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1117
static void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1120
static void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1122
static void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1124
static void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1126
static void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1129
static void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) ;
#line 1131
static void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) ;
#line 1133
static void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) ;
#line 1135
static void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                           OPJ_UINT32 p_nb_elem ) ;
#line 1145
static OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                     struct opj_event_mgr *p_manager ) ;
#line 1156
static OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1167
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1180
static OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 1191
static OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 1202
static OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 1213
static OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1230
static OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 p_nb_pocs , OPJ_UINT32 p_nb_resolutions ,
                                      OPJ_UINT32 p_num_comps , OPJ_UINT32 p_num_layers ,
                                      opj_event_mgr_t *p_manager ) ;
#line 1246
static OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) ;
#line 1261
static OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                                     opj_image_t *image , opj_event_mgr_t *p_manager ) ;
#line 1267
static void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1269
static void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1271
static opj_codestream_index_t *opj_j2k_create_cstr_index(void) ;
#line 1273
static OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) ;
#line 1275
static OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) ;
#line 1277
static int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) ;
#line 1279
static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                          opj_event_mgr_t *p_manager ) ;
#line 1282
static OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_UINT16 rsiz ,
                                            opj_event_mgr_t *p_manager ) ;
#line 1295
static OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream ,
                                                      OPJ_UINT32 tile_no , OPJ_BOOL *p_correction_needed ,
                                                      opj_event_mgr_t *p_manager ) ;
#line 1309 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {(char )"CPRL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )0, {(char )"LRCP", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )3, {(char )"PCRL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )1, {(char )"RLCP", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )2, {(char )"RPCL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )-1, {(char )"\250", (char)0, (char)0, (char)0, (char)0}}};
#line 1321 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_UINT32 MCT_ELEMENT_SIZE[4]  = {      (OPJ_UINT32 )2,      (OPJ_UINT32 )4,      (OPJ_UINT32 )4,      (OPJ_UINT32 )8};
#line 1331 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_read_functions_to_float[4]  = {      & opj_j2k_read_int16_to_float,      & opj_j2k_read_int32_to_float,      & opj_j2k_read_float32_to_float,      & opj_j2k_read_float64_to_float};
#line 1338 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_read_functions_to_int32[4]  = {      & opj_j2k_read_int16_to_int32,      & opj_j2k_read_int32_to_int32,      & opj_j2k_read_float32_to_int32,      & opj_j2k_read_float64_to_int32};
#line 1345 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_write_functions_from_float[4]  = {      & opj_j2k_write_float_to_int16,      & opj_j2k_write_float_to_int32,      & opj_j2k_write_float_to_float,      & opj_j2k_write_float_to_float64};
#line 1365 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab[21]  = 
#line 1365
  {      {(OPJ_UINT32 )65424, (OPJ_UINT32 )12, & opj_j2k_read_sot}, 
        {(OPJ_UINT32 )65362, (OPJ_UINT32 )20, & opj_j2k_read_cod}, 
        {(OPJ_UINT32 )65363, (OPJ_UINT32 )20, & opj_j2k_read_coc}, 
        {(OPJ_UINT32 )65374, (OPJ_UINT32 )20, & opj_j2k_read_rgn}, 
        {(OPJ_UINT32 )65372, (OPJ_UINT32 )20, & opj_j2k_read_qcd}, 
        {(OPJ_UINT32 )65373, (OPJ_UINT32 )20, & opj_j2k_read_qcc}, 
        {(OPJ_UINT32 )65375, (OPJ_UINT32 )20, & opj_j2k_read_poc}, 
        {(OPJ_UINT32 )65361, (OPJ_UINT32 )2, & opj_j2k_read_siz}, 
        {(OPJ_UINT32 )65365, (OPJ_UINT32 )4, & opj_j2k_read_tlm}, 
        {(OPJ_UINT32 )65367, (OPJ_UINT32 )4, & opj_j2k_read_plm}, 
        {(OPJ_UINT32 )65368, (OPJ_UINT32 )16, & opj_j2k_read_plt}, 
        {(OPJ_UINT32 )65376, (OPJ_UINT32 )4, & opj_j2k_read_ppm}, 
        {(OPJ_UINT32 )65377, (OPJ_UINT32 )16, & opj_j2k_read_ppt}, 
        {(OPJ_UINT32 )65425, (OPJ_UINT32 )0, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * ,
                                                        OPJ_UINT32  , opj_event_mgr_t * ))0}, 
        {(OPJ_UINT32 )65379,
      (OPJ_UINT32 )4, & opj_j2k_read_crg}, 
        {(OPJ_UINT32 )65380, (OPJ_UINT32 )20, & opj_j2k_read_com}, 
        {(OPJ_UINT32 )65396, (OPJ_UINT32 )20, & opj_j2k_read_mct}, 
        {(OPJ_UINT32 )65400, (OPJ_UINT32 )4, & opj_j2k_read_cbd}, 
        {(OPJ_UINT32 )65397, (OPJ_UINT32 )20, & opj_j2k_read_mcc}, 
        {(OPJ_UINT32 )65399, (OPJ_UINT32 )20, & opj_j2k_read_mco}, 
        {(OPJ_UINT32 )0, (OPJ_UINT32 )20, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  ,
                                                     opj_event_mgr_t * ))0}};
#line 1402 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1405
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1406
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1410
  i = (OPJ_UINT32 )0;
  {
#line 1410
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1410
    if (! (i < p_nb_elem)) {
#line 1410
      goto while_break;
    }
    {
#line 1411
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1413
    l_src_data += sizeof(OPJ_INT16 );
#line 1415
    __cil_tmp8 = l_dest_data;
#line 1415
    l_dest_data ++;
#line 1415
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
#line 1410
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1414
  return;
}
}
#line 1419 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1422
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1423
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1427
  i = (OPJ_UINT32 )0;
  {
#line 1427
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1427
    if (! (i < p_nb_elem)) {
#line 1427
      goto while_break;
    }
    {
#line 1428
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1430
    l_src_data += sizeof(OPJ_INT32 );
#line 1432
    __cil_tmp8 = l_dest_data;
#line 1432
    l_dest_data ++;
#line 1432
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
#line 1427
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1431
  return;
}
}
#line 1436 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1439
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1440
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1444
  i = (OPJ_UINT32 )0;
  {
#line 1444
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1444
    if (! (i < p_nb_elem)) {
#line 1444
      goto while_break;
    }
    {
#line 1445
    opj_read_float_LE(l_src_data, & l_temp);
#line 1447
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1449
    __cil_tmp8 = l_dest_data;
#line 1449
    l_dest_data ++;
#line 1449
    *__cil_tmp8 = l_temp;
#line 1444
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1448
  return;
}
}
#line 1453 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1456
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1457
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1461
  i = (OPJ_UINT32 )0;
  {
#line 1461
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1461
    if (! (i < p_nb_elem)) {
#line 1461
      goto while_break;
    }
    {
#line 1462
    opj_read_double_LE(l_src_data, & l_temp);
#line 1464
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1466
    __cil_tmp8 = l_dest_data;
#line 1466
    l_dest_data ++;
#line 1466
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
#line 1461
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1465
  return;
}
}
#line 1470 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1473
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1474
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1478
  i = (OPJ_UINT32 )0;
  {
#line 1478
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1478
    if (! (i < p_nb_elem)) {
#line 1478
      goto while_break;
    }
    {
#line 1479
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1481
    l_src_data += sizeof(OPJ_INT16 );
#line 1483
    __cil_tmp8 = l_dest_data;
#line 1483
    l_dest_data ++;
#line 1483
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1478
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1482
  return;
}
}
#line 1487 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1490
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1491
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1495
  i = (OPJ_UINT32 )0;
  {
#line 1495
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1495
    if (! (i < p_nb_elem)) {
#line 1495
      goto while_break;
    }
    {
#line 1496
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1498
    l_src_data += sizeof(OPJ_INT32 );
#line 1500
    __cil_tmp8 = l_dest_data;
#line 1500
    l_dest_data ++;
#line 1500
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1495
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1499
  return;
}
}
#line 1504 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1507
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1508
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1512
  i = (OPJ_UINT32 )0;
  {
#line 1512
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1512
    if (! (i < p_nb_elem)) {
#line 1512
      goto while_break;
    }
    {
#line 1513
    opj_read_float_LE(l_src_data, & l_temp);
#line 1515
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1517
    __cil_tmp8 = l_dest_data;
#line 1517
    l_dest_data ++;
#line 1517
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1512
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1516
  return;
}
}
#line 1521 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1524
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1525
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1529
  i = (OPJ_UINT32 )0;
  {
#line 1529
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1529
    if (! (i < p_nb_elem)) {
#line 1529
      goto while_break;
    }
    {
#line 1530
    opj_read_double_LE(l_src_data, & l_temp);
#line 1532
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1534
    __cil_tmp8 = l_dest_data;
#line 1534
    l_dest_data ++;
#line 1534
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1529
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1533
  return;
}
}
#line 1538 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1541
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1542
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1546
  i = (OPJ_UINT32 )0;
  {
#line 1546
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1546
    if (! (i < p_nb_elem)) {
#line 1546
      goto while_break;
    }
    {
#line 1547
    __cil_tmp8 = l_src_data;
#line 1547
    l_src_data ++;
#line 1547
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1549
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT16 ));
#line 1551
    l_dest_data += sizeof(OPJ_INT16 );
#line 1546
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1550
  return;
}
}
#line 1555 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1558
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1559
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1563
  i = (OPJ_UINT32 )0;
  {
#line 1563
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1563
    if (! (i < p_nb_elem)) {
#line 1563
      goto while_break;
    }
    {
#line 1564
    __cil_tmp8 = l_src_data;
#line 1564
    l_src_data ++;
#line 1564
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1566
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT32 ));
#line 1568
    l_dest_data += sizeof(OPJ_INT32 );
#line 1563
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1567
  return;
}
}
#line 1572 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1575
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1576
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1580
  i = (OPJ_UINT32 )0;
  {
#line 1580
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1580
    if (! (i < p_nb_elem)) {
#line 1580
      goto while_break;
    }
    {
#line 1581
    __cil_tmp8 = l_src_data;
#line 1581
    l_src_data ++;
#line 1581
    l_temp = *__cil_tmp8;
#line 1583
    opj_write_float_LE(l_dest_data, l_temp);
#line 1585
    l_dest_data += sizeof(OPJ_FLOAT32 );
#line 1580
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1584
  return;
}
}
#line 1589 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                           OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1592
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1593
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1597
  i = (OPJ_UINT32 )0;
  {
#line 1597
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1597
    if (! (i < p_nb_elem)) {
#line 1597
      goto while_break;
    }
    {
#line 1598
    __cil_tmp8 = l_src_data;
#line 1598
    l_src_data ++;
#line 1598
    l_temp = (OPJ_FLOAT64 )*__cil_tmp8;
#line 1600
    opj_write_double_LE(l_dest_data, l_temp);
#line 1602
    l_dest_data += sizeof(OPJ_FLOAT64 );
#line 1597
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1601
  return;
}
}
#line 1606 "/root/patron/new_24/src/lib/openjp2/j2k.c"
char const   *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;

  {
#line 1609
  po = j2k_prog_order_list;
  {
#line 1609
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1609
    if (! ((int )po->enum_prog != -1)) {
#line 1609
      goto while_break;
    }
#line 1610
    if ((int )po->enum_prog == (int )prg_order) {
#line 1611
      return ((char const   *)(po->str_prog));
    }
#line 1609
    po ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1614
  return ((char const   *)(po->str_prog));
}
}
#line 1617 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 p_nb_pocs , OPJ_UINT32 p_nb_resolutions ,
                                      OPJ_UINT32 p_num_comps , OPJ_UINT32 p_num_layers ,
                                      opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 *packet_array ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 i ;
  OPJ_UINT32 step_c ;
  OPJ_UINT32 step_r ;
  OPJ_UINT32 step_l ;
  OPJ_BOOL loss ;
  OPJ_UINT32 layno0 ;
  void *__cil_tmp18 ;
  OPJ_UINT32 res_index ;
  OPJ_UINT32 comp_index ;
  OPJ_UINT32 l_last_layno1 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 res_index___0 ;
  OPJ_UINT32 comp_index___0 ;

  {
  {
#line 1627
  step_c = (OPJ_UINT32 )1;
#line 1628
  step_r = p_num_comps * step_c;
#line 1629
  step_l = p_nb_resolutions * step_r;
#line 1630
  loss = 0;
#line 1631
  layno0 = (OPJ_UINT32 )0;
#line 1633
  __cil_tmp18 = opj_calloc((size_t )(step_l * p_num_layers), sizeof(OPJ_UINT32 ));
#line 1633
  packet_array = (OPJ_UINT32 *)__cil_tmp18;
  }
#line 1635
  if ((unsigned long )packet_array == (unsigned long )((OPJ_UINT32 *)0)) {
    {
#line 1636
    opj_event_msg(p_manager, 1, "Not enough memory for checking the poc values.\n");
    }
#line 1638
    return (0);
  }
#line 1641
  if (p_nb_pocs == 0U) {
    {
#line 1642
    opj_free((void *)packet_array);
    }
#line 1643
    return (1);
  }
#line 1646
  index___0 = step_r * p_pocs->resno0;
#line 1648
  resno = p_pocs->resno0;
  {
#line 1648
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1648
    if (! (resno < p_pocs->resno1)) {
#line 1648
      goto while_break;
    }
#line 1649
    res_index = index___0 + p_pocs->compno0 * step_c;
#line 1652
    compno = p_pocs->compno0;
    {
#line 1652
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1652
      if (! (compno < p_pocs->compno1)) {
#line 1652
        goto while_break___0;
      }
#line 1653
      comp_index = res_index + layno0 * step_l;
#line 1656
      layno = layno0;
      {
#line 1656
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1656
        if (! (layno < p_pocs->layno1)) {
#line 1656
          goto while_break___1;
        }
#line 1658
        *(packet_array + comp_index) = (OPJ_UINT32 )1;
#line 1659
        comp_index += step_l;
#line 1656
        layno ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___1: 
#line 1662
      res_index += step_c;
#line 1652
      compno ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___0: 
#line 1665
    index___0 += step_r;
#line 1648
    resno ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: 
#line 1667
  p_pocs ++;
#line 1670
  i = (OPJ_UINT32 )1;
  {
#line 1670
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1670
    if (! (i < p_nb_pocs)) {
#line 1670
      goto while_break___2;
    }
#line 1671
    l_last_layno1 = (p_pocs - 1)->layno1;
#line 1673
    if (p_pocs->layno1 > l_last_layno1) {
#line 1673
      tmp = l_last_layno1;
    } else {
#line 1673
      tmp = 0U;
    }
#line 1673
    layno0 = tmp;
#line 1674
    index___0 = step_r * p_pocs->resno0;
#line 1677
    resno = p_pocs->resno0;
    {
#line 1677
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1677
      if (! (resno < p_pocs->resno1)) {
#line 1677
        goto while_break___3;
      }
#line 1678
      res_index___0 = index___0 + p_pocs->compno0 * step_c;
#line 1681
      compno = p_pocs->compno0;
      {
#line 1681
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1681
        if (! (compno < p_pocs->compno1)) {
#line 1681
          goto while_break___4;
        }
#line 1682
        comp_index___0 = res_index___0 + layno0 * step_l;
#line 1685
        layno = layno0;
        {
#line 1685
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 1685
          if (! (layno < p_pocs->layno1)) {
#line 1685
            goto while_break___5;
          }
#line 1687
          *(packet_array + comp_index___0) = (OPJ_UINT32 )1;
#line 1688
          comp_index___0 += step_l;
#line 1685
          layno ++;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___5: 
#line 1691
        res_index___0 += step_c;
#line 1681
        compno ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___4: 
#line 1694
      index___0 += step_r;
#line 1677
      resno ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___3: 
#line 1697
    p_pocs ++;
#line 1670
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___2: 
#line 1700
  index___0 = (OPJ_UINT32 )0;
#line 1701
  layno = (OPJ_UINT32 )0;
  {
#line 1701
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 1701
    if (! (layno < p_num_layers)) {
#line 1701
      goto while_break___6;
    }
#line 1702
    resno = (OPJ_UINT32 )0;
    {
#line 1702
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 1702
      if (! (resno < p_nb_resolutions)) {
#line 1702
        goto while_break___7;
      }
#line 1703
      compno = (OPJ_UINT32 )0;
      {
#line 1703
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 1703
        if (! (compno < p_num_comps)) {
#line 1703
          goto while_break___8;
        }
#line 1704
        loss |= *(packet_array + index___0) != 1U;
#line 1706
        index___0 += step_c;
#line 1703
        compno ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___8: 
#line 1702
      resno ++;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___7: 
#line 1701
    layno ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___6: ;
#line 1711
  if (loss) {
    {
#line 1712
    opj_event_msg(p_manager, 1, "Missing packets possible loss of data\n");
    }
  }
  {
#line 1715
  opj_free((void *)packet_array);
  }
#line 1717
  return (! loss);
}
}
#line 1722 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i ;
  OPJ_UINT32 tpnum ;
  opj_tcp_t *tcp ;
  opj_poc_t *l_current_poc ;
  char const   *tmp___4 ;

  {
  {
#line 1725
  prog = (OPJ_CHAR *)0;
#line 1727
  tpnum = (OPJ_UINT32 )1;
#line 1728
  tcp = (opj_tcp_t *)0;
#line 1729
  l_current_poc = (opj_poc_t *)0;
#line 1736
  tcp = cp->tcps + tileno;
#line 1739
  l_current_poc = & tcp->pocs[pino];
#line 1743
  tmp___4 = opj_j2k_convert_progression_order(tcp->prg);
#line 1743
  prog = (OPJ_CHAR *)tmp___4;
  }
#line 1746
  if ((int )cp->m_specific_param.m_enc.m_tp_on == 1) {
#line 1747
    i = 0;
    {
#line 1747
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1747
      if (! (i < 4)) {
#line 1747
        goto while_break;
      }
#line 1750
      if ((int )*(prog + i) == 67) {
#line 1750
        goto case_67;
      }
#line 1754
      if ((int )*(prog + i) == 82) {
#line 1754
        goto case_82;
      }
#line 1758
      if ((int )*(prog + i) == 80) {
#line 1758
        goto case_80;
      }
#line 1762
      if ((int )*(prog + i) == 76) {
#line 1762
        goto case_76;
      }
#line 1748
      goto switch_break;
      case_67: 
#line 1751
      tpnum *= l_current_poc->compE;
#line 1752
      goto switch_break;
      case_82: 
#line 1755
      tpnum *= l_current_poc->resE;
#line 1756
      goto switch_break;
      case_80: 
#line 1759
      tpnum *= l_current_poc->prcE;
#line 1760
      goto switch_break;
      case_76: 
#line 1763
      tpnum *= l_current_poc->layE;
#line 1764
      goto switch_break;
      switch_break: ;
#line 1767
      if ((int )cp->m_specific_param.m_enc.m_tp_flag == (int )*(prog + i)) {
#line 1768
        cp->m_specific_param.m_enc.m_tp_pos = i;
#line 1769
        goto while_break;
      }
#line 1747
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 1773
    tpnum = (OPJ_UINT32 )1;
  }
#line 1776
  return (tpnum);
}
}
#line 1779 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                                     opj_image_t *image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *tcp ;
  OPJ_UINT32 cur_totnum_tp ;
  OPJ_UINT32 tp_num ;
  OPJ_UINT32 __cil_tmp17 ;

  {
#line 1800
  l_nb_tiles = cp->tw * cp->th;
#line 1801
  *p_nb_tiles = (OPJ_UINT32 )0;
#line 1802
  tcp = cp->tcps;
#line 1839
  tileno = (OPJ_UINT32 )0;
  {
#line 1839
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1839
    if (! (tileno < l_nb_tiles)) {
#line 1839
      goto while_break;
    }
    {
#line 1840
    cur_totnum_tp = (OPJ_UINT32 )0;
#line 1842
    opj_pi_update_encoding_parameters(image, cp, tileno);
#line 1844
    pino = (OPJ_UINT32 )0;
    }
    {
#line 1844
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1844
      if (! (pino <= tcp->numpocs)) {
#line 1844
        goto while_break___0;
      }
      {
#line 1845
      __cil_tmp17 = opj_j2k_get_num_tp(cp, pino, tileno);
#line 1845
      tp_num = __cil_tmp17;
#line 1847
      *p_nb_tiles += tp_num;
#line 1849
      cur_totnum_tp += tp_num;
#line 1844
      pino ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 1851
    tcp->m_nb_tile_parts = cur_totnum_tp;
#line 1853
    tcp ++;
#line 1839
    tileno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1857
  return (1);
}
}
#line 1860 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_start_stream ;
  OPJ_SIZE_T __cil_tmp8 ;

  {
  {
#line 1865
  l_start_stream = (OPJ_BYTE *)0;
#line 1872
  l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 1875
  opj_write_bytes_LE(l_start_stream, (OPJ_UINT32 )65359, (OPJ_UINT32 )2);
#line 1877
  __cil_tmp8 = opj_stream_write_data(p_stream, l_start_stream, (OPJ_SIZE_T )2, p_manager);
  }
#line 1877
  if (__cil_tmp8 != 2UL) {
#line 1878
    return (0);
  }
#line 1891
  return (1);
}
}
#line 1900 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data[2] ;
  OPJ_UINT32 l_marker ;
  OPJ_SIZE_T __cil_tmp9 ;
  OPJ_OFF_T __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 1913
  __cil_tmp9 = opj_stream_read_data(p_stream, l_data, (OPJ_SIZE_T )2, p_manager);
  }
#line 1913
  if (__cil_tmp9 != 2UL) {
#line 1914
    return (0);
  }
  {
#line 1917
  opj_read_bytes_LE(l_data, & l_marker, (OPJ_UINT32 )2);
  }
#line 1918
  if (l_marker != 65359U) {
#line 1919
    return (0);
  }
  {
#line 1923
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )2;
#line 1926
  __cil_tmp10 = opj_stream_tell(p_stream);
#line 1926
  (p_j2k->cstr_index)->main_head_start = __cil_tmp10 - 2L;
#line 1928
  opj_event_msg(p_manager, 4, "Start to read j2k main header (%d).\n V", (p_j2k->cstr_index)->main_head_start);
#line 1932
  __cil_tmp11 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )65359, (p_j2k->cstr_index)->main_head_start,
                                     (OPJ_UINT32 )2);
  }
#line 1932
  if (0 == __cil_tmp11) {
    {
#line 1934
    opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n");
    }
#line 1935
    return (0);
  }
#line 1937
  return (1);
}
}
#line 1940 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_size_len ;
  OPJ_BYTE *l_current_ptr ;
  opj_image_t *l_image ;
  opj_cp_t *cp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
#line 1947
  l_image = (opj_image_t *)0;
#line 1948
  cp = (opj_cp_t *)0;
#line 1949
  l_img_comp = (opj_image_comp_t *)0;
#line 1956
  l_image = p_j2k->m_private_image;
#line 1957
  cp = & p_j2k->m_cp;
#line 1958
  l_size_len = 40U + 3U * l_image->numcomps;
#line 1959
  l_img_comp = l_image->comps;
#line 1961
  if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 1963
    __cil_tmp14 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_size_len);
#line 1963
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 1965
    if (! new_header_tile_data) {
      {
#line 1966
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 1967
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 1968
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 1969
      opj_event_msg(p_manager, 1, "Not enough memory for the SIZ marker\n");
      }
#line 1970
      return (0);
    }
#line 1972
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 1973
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;
  }
  {
#line 1976
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 1979
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65361, (OPJ_UINT32 )2);
#line 1980
  l_current_ptr += 2;
#line 1982
  opj_write_bytes_LE(l_current_ptr, l_size_len - 2U, (OPJ_UINT32 )2);
#line 1983
  l_current_ptr += 2;
#line 1985
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )cp->rsiz, (OPJ_UINT32 )2);
#line 1986
  l_current_ptr += 2;
#line 1988
  opj_write_bytes_LE(l_current_ptr, l_image->x1, (OPJ_UINT32 )4);
#line 1989
  l_current_ptr += 4;
#line 1991
  opj_write_bytes_LE(l_current_ptr, l_image->y1, (OPJ_UINT32 )4);
#line 1992
  l_current_ptr += 4;
#line 1994
  opj_write_bytes_LE(l_current_ptr, l_image->x0, (OPJ_UINT32 )4);
#line 1995
  l_current_ptr += 4;
#line 1997
  opj_write_bytes_LE(l_current_ptr, l_image->y0, (OPJ_UINT32 )4);
#line 1998
  l_current_ptr += 4;
#line 2000
  opj_write_bytes_LE(l_current_ptr, cp->tdx, (OPJ_UINT32 )4);
#line 2001
  l_current_ptr += 4;
#line 2003
  opj_write_bytes_LE(l_current_ptr, cp->tdy, (OPJ_UINT32 )4);
#line 2004
  l_current_ptr += 4;
#line 2006
  opj_write_bytes_LE(l_current_ptr, cp->tx0, (OPJ_UINT32 )4);
#line 2007
  l_current_ptr += 4;
#line 2009
  opj_write_bytes_LE(l_current_ptr, cp->ty0, (OPJ_UINT32 )4);
#line 2010
  l_current_ptr += 4;
#line 2012
  opj_write_bytes_LE(l_current_ptr, l_image->numcomps, (OPJ_UINT32 )2);
#line 2013
  l_current_ptr += 2;
#line 2015
  i = (OPJ_UINT32 )0;
  }
  {
#line 2015
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2015
    if (! (i < l_image->numcomps)) {
#line 2015
      goto while_break;
    }
    {
#line 2017
    opj_write_bytes_LE(l_current_ptr, (l_img_comp->prec - 1U) + (l_img_comp->sgnd << 7),
                       (OPJ_UINT32 )1);
#line 2019
    l_current_ptr ++;
#line 2021
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dx, (OPJ_UINT32 )1);
#line 2022
    l_current_ptr ++;
#line 2024
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dy, (OPJ_UINT32 )1);
#line 2025
    l_current_ptr ++;
#line 2027
    l_img_comp ++;
#line 2015
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2030
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_size_len, p_manager);
  }
#line 2030
  if (__cil_tmp15 != (unsigned long )l_size_len) {
#line 2033
    return (0);
  }
#line 2036
  return (1);
}
}
#line 2046 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_comp_remain ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_prec0 ;
  OPJ_UINT32 l_sgnd0 ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcp_t *l_current_tile_param ;
  OPJ_UINT32 siz_w ;
  OPJ_UINT32 siz_h ;
  void *__cil_tmp26 ;
  OPJ_UINT32 tmp___2 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;

  {
#line 2059
  l_image = (opj_image_t *)0;
#line 2060
  l_cp = (opj_cp_t *)0;
#line 2061
  l_img_comp = (opj_image_comp_t *)0;
#line 2062
  l_current_tile_param = (opj_tcp_t *)0;
#line 2069
  l_image = p_j2k->m_private_image;
#line 2070
  l_cp = & p_j2k->m_cp;
#line 2073
  if (p_header_size < 36U) {
    {
#line 2074
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\n");
    }
#line 2075
    return (0);
  }
#line 2078
  l_remaining_size = p_header_size - 36U;
#line 2079
  l_nb_comp = l_remaining_size / 3U;
#line 2080
  l_nb_comp_remain = l_remaining_size % 3U;
#line 2081
  if (l_nb_comp_remain != 0U) {
    {
#line 2082
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\n2 V");
    }
#line 2083
    return (0);
  }
  {
#line 2086
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 2088
  p_header_data += 2;
#line 2089
  l_cp->rsiz = (OPJ_UINT16 )l_tmp;
#line 2090
  opj_read_bytes_LE(p_header_data, & l_image->x1, (OPJ_UINT32 )4);
#line 2091
  p_header_data += 4;
#line 2092
  opj_read_bytes_LE(p_header_data, & l_image->y1, (OPJ_UINT32 )4);
#line 2093
  p_header_data += 4;
#line 2094
  opj_read_bytes_LE(p_header_data, & l_image->x0, (OPJ_UINT32 )4);
#line 2095
  p_header_data += 4;
#line 2096
  opj_read_bytes_LE(p_header_data, & l_image->y0, (OPJ_UINT32 )4);
#line 2097
  p_header_data += 4;
#line 2098
  opj_read_bytes_LE(p_header_data, & l_cp->tdx, (OPJ_UINT32 )4);
#line 2100
  p_header_data += 4;
#line 2101
  opj_read_bytes_LE(p_header_data, & l_cp->tdy, (OPJ_UINT32 )4);
#line 2103
  p_header_data += 4;
#line 2104
  opj_read_bytes_LE(p_header_data, & l_cp->tx0, (OPJ_UINT32 )4);
#line 2106
  p_header_data += 4;
#line 2107
  opj_read_bytes_LE(p_header_data, & l_cp->ty0, (OPJ_UINT32 )4);
#line 2109
  p_header_data += 4;
#line 2110
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 2112
  p_header_data += 2;
  }
#line 2113
  if (l_tmp < 16385U) {
#line 2114
    l_image->numcomps = (OPJ_UINT32 )((OPJ_UINT16 )l_tmp);
  } else {
    {
#line 2116
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is illegal -> %d\n",
                  l_tmp);
    }
#line 2118
    return (0);
  }
#line 2121
  if (l_image->numcomps != l_nb_comp) {
    {
#line 2122
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\n",
                  l_image->numcomps, l_nb_comp);
    }
#line 2125
    return (0);
  }
#line 2130
  if (l_image->x0 >= l_image->x1) {
    {
#line 2131
    opj_event_msg(p_manager, 1, "Error with SIZ marker: negative or zero image size (%ld x %ld)\n",
                  (OPJ_INT64 )l_image->x1 - (long )l_image->x0, (OPJ_INT64 )l_image->y1 - (long )l_image->y0);
    }
#line 2135
    return (0);
  } else
#line 2130
  if (l_image->y0 >= l_image->y1) {
    {
#line 2131
    opj_event_msg(p_manager, 1, "Error with SIZ marker: negative or zero image size (%ld x %ld)\n",
                  (OPJ_INT64 )l_image->x1 - (long )l_image->x0, (OPJ_INT64 )l_image->y1 - (long )l_image->y0);
    }
#line 2135
    return (0);
  }
#line 2138
  if (l_cp->tdx == 0U) {
    {
#line 2139
    opj_event_msg(p_manager, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n",
                  l_cp->tdx, l_cp->tdy);
    }
#line 2142
    return (0);
  } else
#line 2138
  if (l_cp->tdy == 0U) {
    {
#line 2139
    opj_event_msg(p_manager, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n",
                  l_cp->tdx, l_cp->tdy);
    }
#line 2142
    return (0);
  }
  {
#line 2146
  l_tx1 = opj_uint_adds(l_cp->tx0, l_cp->tdx);
#line 2147
  l_ty1 = opj_uint_adds(l_cp->ty0, l_cp->tdy);
  }
#line 2148
  if (l_cp->tx0 > l_image->x0) {
    {
#line 2150
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
#line 2152
    return (0);
  } else
#line 2148
  if (l_cp->ty0 > l_image->y0) {
    {
#line 2150
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
#line 2152
    return (0);
  } else
#line 2148
  if (l_tx1 <= l_image->x0) {
    {
#line 2150
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
#line 2152
    return (0);
  } else
#line 2148
  if (l_ty1 <= l_image->y0) {
    {
#line 2150
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
#line 2152
    return (0);
  }
#line 2154
  if (! p_j2k->dump_state) {
#line 2157
    siz_w = l_image->x1 - l_image->x0;
#line 2158
    siz_h = l_image->y1 - l_image->y0;
#line 2160
    if (p_j2k->ihdr_w > 0U) {
#line 2160
      if (p_j2k->ihdr_h > 0U) {
#line 2160
        if (p_j2k->ihdr_w != siz_w) {
          {
#line 2162
          opj_event_msg(p_manager, 1, "Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\n",
                        p_j2k->ihdr_w, p_j2k->ihdr_h, siz_w, siz_h);
          }
#line 2165
          return (0);
        } else
#line 2160
        if (p_j2k->ihdr_h != siz_h) {
          {
#line 2162
          opj_event_msg(p_manager, 1, "Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\n",
                        p_j2k->ihdr_w, p_j2k->ihdr_h, siz_w, siz_h);
          }
#line 2165
          return (0);
        }
      }
    }
  }
  {
#line 2211
  __cil_tmp26 = opj_calloc((size_t )l_image->numcomps, sizeof(opj_image_comp_t ));
#line 2211
  l_image->comps = (opj_image_comp_t *)__cil_tmp26;
  }
#line 2213
  if ((unsigned long )l_image->comps == (unsigned long )((opj_image_comp_t *)0)) {
    {
#line 2214
    l_image->numcomps = (OPJ_UINT32 )0;
#line 2215
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2217
    return (0);
  }
#line 2220
  l_img_comp = l_image->comps;
#line 2222
  l_prec0 = (OPJ_UINT32 )0;
#line 2223
  l_sgnd0 = (OPJ_UINT32 )0;
#line 2225
  i = (OPJ_UINT32 )0;
  {
#line 2225
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2225
    if (! (i < l_image->numcomps)) {
#line 2225
      goto while_break;
    }
    {
#line 2227
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2228
    p_header_data ++;
#line 2229
    l_img_comp->prec = (tmp___2 & 127U) + 1U;
#line 2230
    l_img_comp->sgnd = tmp___2 >> 7;
    }
#line 2232
    if (p_j2k->dump_state == 0U) {
#line 2233
      if (i == 0U) {
#line 2234
        l_prec0 = l_img_comp->prec;
#line 2235
        l_sgnd0 = l_img_comp->sgnd;
      } else
#line 2236
      if (! l_cp->allow_different_bit_depth_sign) {
#line 2236
        if (l_img_comp->prec != l_prec0) {
          {
#line 2238
          opj_event_msg(p_manager, 2, "Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\n        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\n",
                        i, l_prec0, l_sgnd0, i, l_img_comp->prec, l_img_comp->sgnd);
          }
        } else
#line 2236
        if (l_img_comp->sgnd != l_sgnd0) {
          {
#line 2238
          opj_event_msg(p_manager, 2, "Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\n        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\n",
                        i, l_prec0, l_sgnd0, i, l_img_comp->prec, l_img_comp->sgnd);
          }
        }
      }
    }
    {
#line 2245
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2246
    p_header_data ++;
#line 2247
    l_img_comp->dx = tmp___2;
#line 2248
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2249
    p_header_data ++;
#line 2250
    l_img_comp->dy = tmp___2;
    }
#line 2251
    if (l_img_comp->dx < 1U) {
      {
#line 2253
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2256
      return (0);
    } else
#line 2251
    if (l_img_comp->dx > 255U) {
      {
#line 2253
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2256
      return (0);
    } else
#line 2251
    if (l_img_comp->dy < 1U) {
      {
#line 2253
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2256
      return (0);
    } else
#line 2251
    if (l_img_comp->dy > 255U) {
      {
#line 2253
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2256
      return (0);
    }
#line 2261
    if (l_img_comp->prec > 31U) {
      {
#line 2262
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\n",
                    i, l_img_comp->prec);
      }
#line 2265
      return (0);
    }
#line 2296
    l_img_comp->resno_decoded = (OPJ_UINT32 )0;
#line 2298
    l_img_comp->factor = l_cp->m_specific_param.m_dec.m_reduce;
#line 2300
    l_img_comp ++;
#line 2225
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 2303
  if (l_cp->tdx == 0U) {
#line 2304
    return (0);
  } else
#line 2303
  if (l_cp->tdy == 0U) {
#line 2304
    return (0);
  }
  {
#line 2308
  __cil_tmp28 = opj_int_ceildiv((OPJ_INT32 )(l_image->x1 - l_cp->tx0), (OPJ_INT32 )l_cp->tdx);
#line 2308
  l_cp->tw = (OPJ_UINT32 )__cil_tmp28;
#line 2310
  __cil_tmp29 = opj_int_ceildiv((OPJ_INT32 )(l_image->y1 - l_cp->ty0), (OPJ_INT32 )l_cp->tdy);
#line 2310
  l_cp->th = (OPJ_UINT32 )__cil_tmp29;
  }
#line 2314
  if (l_cp->tw == 0U) {
    {
#line 2315
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
#line 2318
    return (0);
  } else
#line 2314
  if (l_cp->th == 0U) {
    {
#line 2315
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
#line 2318
    return (0);
  } else
#line 2314
  if (l_cp->tw > 65535U / l_cp->th) {
    {
#line 2315
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
#line 2318
    return (0);
  }
#line 2320
  l_nb_tiles = l_cp->tw * l_cp->th;
#line 2323
  if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {
    {
#line 2324
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;
#line 2326
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;
#line 2328
    __cil_tmp30 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0),
                                  (OPJ_INT32 )l_cp->tdx);
#line 2328
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp30;
#line 2331
    __cil_tmp31 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0),
                                  (OPJ_INT32 )l_cp->tdy);
#line 2331
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp31;
    }
  } else {
#line 2335
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 2336
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 2337
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 2338
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
  }
  {
#line 2387
  __cil_tmp32 = opj_calloc((size_t )l_nb_tiles, sizeof(opj_tcp_t ));
#line 2387
  l_cp->tcps = (opj_tcp_t *)__cil_tmp32;
  }
#line 2388
  if ((unsigned long )l_cp->tcps == (unsigned long )((opj_tcp_t *)0)) {
    {
#line 2389
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2391
    return (0);
  }
  {
#line 2407
  __cil_tmp33 = opj_calloc((size_t )l_image->numcomps, sizeof(opj_tccp_t ));
#line 2407
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps = (opj_tccp_t *)__cil_tmp33;
  }
#line 2409
  if ((unsigned long )(p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps == (unsigned long )((opj_tccp_t *)0)) {
    {
#line 2410
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2412
    return (0);
  }
  {
#line 2415
  __cil_tmp34 = opj_calloc((size_t )10, sizeof(opj_mct_data_t ));
#line 2415
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records = (opj_mct_data_t *)__cil_tmp34;
  }
#line 2419
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records) {
    {
#line 2420
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2422
    return (0);
  }
  {
#line 2424
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mct_records = (OPJ_UINT32 )10;
#line 2427
  __cil_tmp35 = opj_calloc((size_t )10, sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 2427
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp35;
  }
#line 2432
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records) {
    {
#line 2433
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2435
    return (0);
  }
#line 2437
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mcc_records = (OPJ_UINT32 )10;
#line 2441
  i = (OPJ_UINT32 )0;
  {
#line 2441
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2441
    if (! (i < l_image->numcomps)) {
#line 2441
      goto while_break___0;
    }
#line 2442
    if (! (l_image->comps + i)->sgnd) {
#line 2443
      ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + i)->m_dc_level_shift = 1 << ((l_image->comps + i)->prec - 1U);
    }
#line 2441
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 2448
  l_current_tile_param = l_cp->tcps;
#line 2449
  i = (OPJ_UINT32 )0;
  {
#line 2449
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 2449
    if (! (i < l_nb_tiles)) {
#line 2449
      goto while_break___1;
    }
    {
#line 2450
    __cil_tmp36 = opj_calloc((size_t )l_image->numcomps, sizeof(opj_tccp_t ));
#line 2450
    l_current_tile_param->tccps = (opj_tccp_t *)__cil_tmp36;
    }
#line 2452
    if ((unsigned long )l_current_tile_param->tccps == (unsigned long )((opj_tccp_t *)0)) {
      {
#line 2453
      opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
      }
#line 2455
      return (0);
    }
#line 2458
    l_current_tile_param ++;
#line 2449
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 2461
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )4;
#line 2462
  opj_image_comp_header_update(l_image, l_cp);
  }
#line 2464
  return (1);
}
}
#line 2467 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_comment_size ;
  OPJ_UINT32 l_total_com_size ;
  OPJ_CHAR *l_comment ;
  OPJ_BYTE *l_current_ptr ;
  unsigned long __cil_tmp11 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 2475
  l_current_ptr = (OPJ_BYTE *)0;
#line 2482
  l_comment = p_j2k->m_cp.comment;
#line 2483
  __cil_tmp11 = strlen((char const   *)l_comment);
#line 2483
  l_comment_size = (OPJ_UINT32 )__cil_tmp11;
#line 2484
  l_total_com_size = l_comment_size + 6U;
  }
#line 2486
  if (l_total_com_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2488
    __cil_tmp13 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_total_com_size);
#line 2488
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 2490
    if (! new_header_tile_data) {
      {
#line 2491
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2492
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2493
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2494
      opj_event_msg(p_manager, 1, "Not enough memory to write the COM marker\n");
      }
#line 2496
      return (0);
    }
#line 2498
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2499
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;
  }
  {
#line 2502
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2504
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65380, (OPJ_UINT32 )2);
#line 2505
  l_current_ptr += 2;
#line 2507
  opj_write_bytes_LE(l_current_ptr, l_total_com_size - 2U, (OPJ_UINT32 )2);
#line 2508
  l_current_ptr += 2;
#line 2510
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 2512
  l_current_ptr += 2;
#line 2514
  memcpy((void *)l_current_ptr, (void const   *)l_comment, (unsigned long )l_comment_size);
#line 2516
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_total_com_size, p_manager);
  }
#line 2516
  if (__cil_tmp14 != (unsigned long )l_total_com_size) {
#line 2519
    return (0);
  }
#line 2522
  return (1);
}
}
#line 2532 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 2548
  return (1);
}
}
#line 2551 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_code_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
  {
#line 2555
  l_cp = (opj_cp_t *)0;
#line 2556
  l_tcp = (opj_tcp_t *)0;
#line 2558
  l_current_data = (OPJ_BYTE *)0;
#line 2565
  l_cp = & p_j2k->m_cp;
#line 2566
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2567
  __cil_tmp12 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number,
                                             (OPJ_UINT32 )0);
#line 2567
  l_code_size = 9U + __cil_tmp12;
#line 2569
  l_remaining_size = l_code_size;
  }
#line 2571
  if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2572
    __cil_tmp14 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_code_size);
#line 2572
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 2574
    if (! new_header_tile_data) {
      {
#line 2575
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2576
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2577
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2578
      opj_event_msg(p_manager, 1, "Not enough memory to write COD marker\n");
      }
#line 2579
      return (0);
    }
#line 2581
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2582
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;
  }
  {
#line 2585
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2587
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65362, (OPJ_UINT32 )2);
#line 2588
  l_current_data += 2;
#line 2590
  opj_write_bytes_LE(l_current_data, l_code_size - 2U, (OPJ_UINT32 )2);
#line 2591
  l_current_data += 2;
#line 2593
  opj_write_bytes_LE(l_current_data, l_tcp->csty, (OPJ_UINT32 )1);
#line 2594
  l_current_data ++;
#line 2596
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tcp->prg, (OPJ_UINT32 )1);
#line 2597
  l_current_data ++;
#line 2599
  opj_write_bytes_LE(l_current_data, l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2600
  l_current_data += 2;
#line 2602
  opj_write_bytes_LE(l_current_data, l_tcp->mct, (OPJ_UINT32 )1);
#line 2603
  l_current_data ++;
#line 2605
  l_remaining_size -= 9U;
#line 2607
  __cil_tmp15 = opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                          l_current_data, & l_remaining_size, p_manager);
  }
#line 2607
  if (! __cil_tmp15) {
    {
#line 2609
    opj_event_msg(p_manager, 1, "Error writing COD marker\n\277\r2 V");
    }
#line 2610
    return (0);
  }
#line 2613
  if (l_remaining_size != 0U) {
    {
#line 2614
    opj_event_msg(p_manager, 1, "Error writing COD marker\n");
    }
#line 2615
    return (0);
  }
  {
#line 2618
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_code_size, p_manager);
  }
#line 2618
  if (__cil_tmp16 != (unsigned long )l_code_size) {
#line 2621
    return (0);
  }
#line 2624
  return (1);
}
}
#line 2634 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  opj_tcp_t *tmp___2 ;
  OPJ_BOOL __cil_tmp14 ;

  {
#line 2643
  l_cp = (opj_cp_t *)0;
#line 2644
  l_tcp = (opj_tcp_t *)0;
#line 2645
  l_image = (opj_image_t *)0;
#line 2652
  l_image = p_j2k->m_private_image;
#line 2653
  l_cp = & p_j2k->m_cp;
#line 2656
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2656
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2656
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2656
  l_tcp = tmp___2;
#line 2661
  if (l_tcp->cod) {
    {
#line 2662
    opj_event_msg(p_manager, 1, "COD marker already read. No more than one COD marker per tile.\n");
    }
#line 2664
    return (0);
  }
#line 2666
  l_tcp->cod = (OPJ_BITFIELD )1;
#line 2669
  if (p_header_size < 5U) {
    {
#line 2670
    opj_event_msg(p_manager, 1, "Error reading COD marker\n");
    }
#line 2671
    return (0);
  }
  {
#line 2674
  opj_read_bytes_LE(p_header_data, & l_tcp->csty, (OPJ_UINT32 )1);
#line 2675
  p_header_data ++;
  }
#line 2677
  if ((l_tcp->csty & 4294967288U) != 0U) {
    {
#line 2679
    opj_event_msg(p_manager, 1, "Unknown Scod value in COD marker\n\247\r2 V");
    }
#line 2680
    return (0);
  }
  {
#line 2682
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 2683
  p_header_data ++;
#line 2684
  l_tcp->prg = (OPJ_PROG_ORDER )l_tmp;
  }
#line 2686
  if ((int )l_tcp->prg > 4) {
    {
#line 2687
    opj_event_msg(p_manager, 1, "Unknown progression order in COD marker\n\220");
#line 2689
    l_tcp->prg = (OPJ_PROG_ORDER )-1;
    }
  }
  {
#line 2691
  opj_read_bytes_LE(p_header_data, & l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2692
  p_header_data += 2;
  }
#line 2694
  if (l_tcp->numlayers < 1U) {
    {
#line 2695
    opj_event_msg(p_manager, 1, "Invalid number of layers in COD marker : %d not in range [1-65535]\n2 V",
                  l_tcp->numlayers);
    }
#line 2698
    return (0);
  } else
#line 2694
  if (l_tcp->numlayers > 65535U) {
    {
#line 2695
    opj_event_msg(p_manager, 1, "Invalid number of layers in COD marker : %d not in range [1-65535]\n2 V",
                  l_tcp->numlayers);
    }
#line 2698
    return (0);
  }
#line 2702
  if (l_cp->m_specific_param.m_dec.m_layer) {
#line 2703
    l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;
  } else {
#line 2705
    l_tcp->num_layers_to_decode = l_tcp->numlayers;
  }
  {
#line 2708
  opj_read_bytes_LE(p_header_data, & l_tcp->mct, (OPJ_UINT32 )1);
#line 2709
  p_header_data ++;
#line 2711
  p_header_size -= 5U;
#line 2712
  i = (OPJ_UINT32 )0;
  }
  {
#line 2712
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2712
    if (! (i < l_image->numcomps)) {
#line 2712
      goto while_break;
    }
#line 2713
    (l_tcp->tccps + i)->csty = l_tcp->csty & 1U;
#line 2712
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2716
  __cil_tmp14 = opj_j2k_read_SPCod_SPCoc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2716
  if (! __cil_tmp14) {
    {
#line 2718
    opj_event_msg(p_manager, 1, "Error reading COD marker\n\312\r2 V");
    }
#line 2719
    return (0);
  }
#line 2722
  if (p_header_size != 0U) {
    {
#line 2723
    opj_event_msg(p_manager, 1, "Error reading COD marker\n\222\r2 V");
    }
#line 2724
    return (0);
  }
  {
#line 2728
  opj_j2k_copy_tile_component_parameters(p_j2k);
  }
#line 2747
  return (1);
}
}
#line 2750 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_coc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 l_comp_room ;
  int tmp___2 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
#line 2763
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
#line 2763
    tmp___2 = 1;
  } else {
#line 2763
    tmp___2 = 2;
  }
  {
#line 2763
  l_comp_room = (OPJ_UINT32 )tmp___2;
#line 2765
  __cil_tmp12 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number,
                                             p_comp_no);
#line 2765
  l_coc_size = (5U + l_comp_room) + __cil_tmp12;
  }
#line 2768
  if (l_coc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2775
    __cil_tmp14 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_coc_size);
#line 2775
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 2777
    if (! new_header_tile_data) {
      {
#line 2778
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2779
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2780
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2781
      opj_event_msg(p_manager, 1, "Not enough memory to write COC marker\n");
      }
#line 2782
      return (0);
    }
#line 2784
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2785
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_coc_size;
  }
  {
#line 2788
  opj_j2k_write_coc_in_memory(p_j2k, p_comp_no, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_remaining_size, p_manager);
#line 2792
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_coc_size, p_manager);
  }
#line 2792
  if (__cil_tmp15 != (unsigned long )l_coc_size) {
#line 2795
    return (0);
  }
#line 2798
  return (1);
}
}
#line 2801 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 2804
  l_cp = (opj_cp_t *)((void *)0);
#line 2805
  l_tcp = (opj_tcp_t *)((void *)0);
#line 2810
  l_cp = & p_j2k->m_cp;
#line 2811
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2813
  if ((l_tcp->tccps + p_first_comp_no)->csty != (l_tcp->tccps + p_second_comp_no)->csty) {
#line 2814
    return (0);
  }
  {
#line 2818
  __cil_tmp7 = opj_j2k_compare_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, p_first_comp_no,
                                           p_second_comp_no);
  }
#line 2818
  return (__cil_tmp7);
}
}
#line 2822 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_coc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_comp_room ;
  int tmp___1 ;
  OPJ_UINT32 __cil_tmp16 ;

  {
#line 2829
  l_cp = (opj_cp_t *)0;
#line 2830
  l_tcp = (opj_tcp_t *)0;
#line 2832
  l_current_data = (OPJ_BYTE *)0;
#line 2833
  l_image = (opj_image_t *)0;
#line 2840
  l_cp = & p_j2k->m_cp;
#line 2841
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2842
  l_image = p_j2k->m_private_image;
#line 2843
  if (l_image->numcomps <= 256U) {
#line 2843
    tmp___1 = 1;
  } else {
#line 2843
    tmp___1 = 2;
  }
  {
#line 2843
  l_comp_room = (OPJ_UINT32 )tmp___1;
#line 2845
  __cil_tmp16 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number,
                                             p_comp_no);
#line 2845
  l_coc_size = (5U + l_comp_room) + __cil_tmp16;
#line 2847
  l_remaining_size = l_coc_size;
#line 2849
  l_current_data = p_data;
#line 2851
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65363, (OPJ_UINT32 )2);
#line 2853
  l_current_data += 2;
#line 2855
  opj_write_bytes_LE(l_current_data, l_coc_size - 2U, (OPJ_UINT32 )2);
#line 2857
  l_current_data += 2;
#line 2859
  opj_write_bytes_LE(l_current_data, p_comp_no, l_comp_room);
#line 2860
  l_current_data += l_comp_room;
#line 2862
  opj_write_bytes_LE(l_current_data, (l_tcp->tccps + p_comp_no)->csty, (OPJ_UINT32 )1);
#line 2864
  l_current_data ++;
#line 2866
  l_remaining_size -= 5U + l_comp_room;
#line 2867
  opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0, l_current_data,
                            & l_remaining_size, p_manager);
#line 2869
  *p_data_written = l_coc_size;
  }
#line 2871
  return;
}
}
#line 2872 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 2877
  l_max = (OPJ_UINT32 )0;
#line 2881
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 2882
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 2884
  i = (OPJ_UINT32 )0;
  {
#line 2884
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2884
    if (! (i < l_nb_tiles)) {
#line 2884
      goto while_break;
    }
#line 2885
    j = (OPJ_UINT32 )0;
    {
#line 2885
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2885
      if (! (j < l_nb_comp)) {
#line 2885
        goto while_break___0;
      }
      {
#line 2886
      __cil_tmp7 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, i, j);
#line 2886
      __cil_tmp8 = opj_uint_max(l_max, __cil_tmp7);
#line 2886
      l_max = __cil_tmp8;
#line 2885
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 2884
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 2890
  return (6U + l_max);
}
}
#line 2900 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  opj_tcp_t *tmp___2 ;
  int tmp___3 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 2906
  l_cp = (opj_cp_t *)((void *)0);
#line 2907
  l_tcp = (opj_tcp_t *)((void *)0);
#line 2908
  l_image = (opj_image_t *)((void *)0);
#line 2917
  l_cp = & p_j2k->m_cp;
#line 2918
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2918
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2918
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2918
  l_tcp = tmp___2;
#line 2922
  l_image = p_j2k->m_private_image;
#line 2924
  if (l_image->numcomps <= 256U) {
#line 2924
    tmp___3 = 1;
  } else {
#line 2924
    tmp___3 = 2;
  }
#line 2924
  l_comp_room = (OPJ_UINT32 )tmp___3;
#line 2927
  if (p_header_size < l_comp_room + 1U) {
    {
#line 2928
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2929
    return (0);
  }
  {
#line 2931
  p_header_size -= l_comp_room + 1U;
#line 2933
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 2935
  p_header_data += l_comp_room;
  }
#line 2936
  if (l_comp_no >= l_image->numcomps) {
    {
#line 2937
    opj_event_msg(p_manager, 1, "Error reading COC marker (bad number of components)\n");
    }
#line 2939
    return (0);
  }
  {
#line 2942
  opj_read_bytes_LE(p_header_data, & (l_tcp->tccps + l_comp_no)->csty, (OPJ_UINT32 )1);
#line 2944
  p_header_data ++;
#line 2946
  __cil_tmp15 = opj_j2k_read_SPCod_SPCoc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2946
  if (! __cil_tmp15) {
    {
#line 2948
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2949
    return (0);
  }
#line 2952
  if (p_header_size != 0U) {
    {
#line 2953
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2954
    return (0);
  }
#line 2956
  return (1);
}
}
#line 2959 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcd_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 2965
  l_current_data = (OPJ_BYTE *)0;
#line 2972
  __cil_tmp10 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0);
#line 2972
  l_qcd_size = 4U + __cil_tmp10;
#line 2974
  l_remaining_size = l_qcd_size;
  }
#line 2976
  if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2977
    __cil_tmp12 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_qcd_size);
#line 2977
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp12;
    }
#line 2979
    if (! new_header_tile_data) {
      {
#line 2980
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2981
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2982
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2983
      opj_event_msg(p_manager, 1, "Not enough memory to write QCD marker\n");
      }
#line 2984
      return (0);
    }
#line 2986
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2987
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;
  }
  {
#line 2990
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2992
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65372, (OPJ_UINT32 )2);
#line 2993
  l_current_data += 2;
#line 2995
  opj_write_bytes_LE(l_current_data, l_qcd_size - 2U, (OPJ_UINT32 )2);
#line 2996
  l_current_data += 2;
#line 2998
  l_remaining_size -= 4U;
#line 3000
  __cil_tmp13 = opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                        l_current_data, & l_remaining_size, p_manager);
  }
#line 3000
  if (! __cil_tmp13) {
    {
#line 3002
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n");
    }
#line 3003
    return (0);
  }
#line 3006
  if (l_remaining_size != 0U) {
    {
#line 3007
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n");
    }
#line 3008
    return (0);
  }
  {
#line 3011
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_qcd_size, p_manager);
  }
#line 3011
  if (__cil_tmp14 != (unsigned long )l_qcd_size) {
#line 3014
    return (0);
  }
#line 3017
  return (1);
}
}
#line 3027 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 3038
  __cil_tmp8 = opj_j2k_read_SQcd_SQcc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                      p_manager);
  }
#line 3038
  if (! __cil_tmp8) {
    {
#line 3040
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n");
    }
#line 3041
    return (0);
  }
#line 3044
  if (p_header_size != 0U) {
    {
#line 3045
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n");
    }
#line 3046
    return (0);
  }
  {
#line 3050
  opj_j2k_copy_tile_quantization_parameters(p_j2k);
  }
#line 3052
  return (1);
}
}
#line 3055 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 __cil_tmp10 ;
  int tmp___2 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 3068
  __cil_tmp10 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, p_comp_no);
#line 3068
  l_qcc_size = 5U + __cil_tmp10;
  }
#line 3070
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
#line 3070
    tmp___2 = 0;
  } else {
#line 3070
    tmp___2 = 1;
  }
#line 3070
  l_qcc_size += (unsigned int )tmp___2;
#line 3071
  l_remaining_size = l_qcc_size;
#line 3073
  if (l_qcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3074
    __cil_tmp13 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_qcc_size);
#line 3074
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 3076
    if (! new_header_tile_data) {
      {
#line 3077
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 3078
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3079
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3080
      opj_event_msg(p_manager, 1, "Not enough memory to write QCC marker\n");
      }
#line 3081
      return (0);
    }
#line 3083
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 3084
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcc_size;
  }
  {
#line 3087
  opj_j2k_write_qcc_in_memory(p_j2k, p_comp_no, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_remaining_size, p_manager);
#line 3091
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_qcc_size, p_manager);
  }
#line 3091
  if (__cil_tmp14 != (unsigned long )l_qcc_size) {
#line 3094
    return (0);
  }
#line 3097
  return (1);
}
}
#line 3100 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 3103
  __cil_tmp4 = opj_j2k_compare_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, p_first_comp_no,
                                         p_second_comp_no);
  }
#line 3103
  return (__cil_tmp4);
}
}
#line 3107 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp11 ;

  {
  {
#line 3115
  l_current_data = (OPJ_BYTE *)0;
#line 3121
  __cil_tmp11 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, p_comp_no);
#line 3121
  l_qcc_size = 6U + __cil_tmp11;
#line 3123
  l_remaining_size = l_qcc_size;
#line 3125
  l_current_data = p_data;
#line 3127
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65373, (OPJ_UINT32 )2);
#line 3128
  l_current_data += 2;
  }
#line 3130
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
    {
#line 3131
    l_qcc_size --;
#line 3133
    opj_write_bytes_LE(l_current_data, l_qcc_size - 2U, (OPJ_UINT32 )2);
#line 3134
    l_current_data += 2;
#line 3136
    opj_write_bytes_LE(l_current_data, p_comp_no, (OPJ_UINT32 )1);
#line 3137
    l_current_data ++;
#line 3140
    l_remaining_size -= 6U;
    }
  } else {
    {
#line 3142
    opj_write_bytes_LE(l_current_data, l_qcc_size - 2U, (OPJ_UINT32 )2);
#line 3143
    l_current_data += 2;
#line 3145
    opj_write_bytes_LE(l_current_data, p_comp_no, (OPJ_UINT32 )2);
#line 3146
    l_current_data += 2;
#line 3148
    l_remaining_size -= 6U;
    }
  }
  {
#line 3151
  opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, p_comp_no, l_current_data,
                          & l_remaining_size, p_manager);
#line 3154
  *p_data_written = l_qcc_size;
  }
#line 3156
  return;
}
}
#line 3157 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 3159
  __cil_tmp2 = opj_j2k_get_max_coc_size(p_j2k);
  }
#line 3159
  return (__cil_tmp2);
}
}
#line 3169 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_no ;
  OPJ_BOOL __cil_tmp10 ;

  {
#line 3182
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 3184
  if (l_num_comp <= 256U) {
#line 3185
    if (p_header_size < 1U) {
      {
#line 3186
      opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
      }
#line 3187
      return (0);
    }
    {
#line 3189
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )1);
#line 3190
    p_header_data ++;
#line 3191
    p_header_size --;
    }
  } else {
#line 3193
    if (p_header_size < 2U) {
      {
#line 3194
      opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
      }
#line 3195
      return (0);
    }
    {
#line 3197
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )2);
#line 3198
    p_header_data += 2;
#line 3199
    p_header_size -= 2U;
    }
  }
#line 3228
  if (l_comp_no >= (p_j2k->m_private_image)->numcomps) {
    {
#line 3229
    opj_event_msg(p_manager, 1, "Invalid component number: %d, regarding the number of components %d\n",
                  l_comp_no, (p_j2k->m_private_image)->numcomps);
    }
#line 3232
    return (0);
  }
  {
#line 3235
  __cil_tmp10 = opj_j2k_read_SQcd_SQcc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                       p_manager);
  }
#line 3235
  if (! __cil_tmp10) {
    {
#line 3237
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
    }
#line 3238
    return (0);
  }
#line 3241
  if (p_header_size != 0U) {
    {
#line 3242
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
    }
#line 3243
    return (0);
  }
#line 3246
  return (1);
}
}
#line 3249 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  OPJ_UINT32 l_written_size ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_poc_room ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
#line 3257
  l_written_size = (OPJ_UINT32 )0;
#line 3258
  l_tcp = (opj_tcp_t *)0;
#line 3266
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 3267
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 3268
  l_nb_poc = 1U + l_tcp->numpocs;
#line 3270
  if (l_nb_comp <= 256U) {
#line 3271
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 3273
    l_poc_room = (OPJ_UINT32 )2;
  }
#line 3275
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 3277
  if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3278
    __cil_tmp14 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_poc_size);
#line 3278
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 3280
    if (! new_header_tile_data) {
      {
#line 3281
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 3282
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3283
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3284
      opj_event_msg(p_manager, 1, "Not enough memory to write POC marker\n");
      }
#line 3285
      return (0);
    }
#line 3287
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 3288
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;
  }
  {
#line 3291
  opj_j2k_write_poc_in_memory(p_j2k, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_written_size, p_manager);
#line 3295
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_poc_size, p_manager);
  }
#line 3295
  if (__cil_tmp15 != (unsigned long )l_poc_size) {
#line 3298
    return (0);
  }
#line 3301
  return (1);
}
}
#line 3304 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_room ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;

  {
#line 3311
  l_current_data = (OPJ_BYTE *)0;
#line 3315
  l_image = (opj_image_t *)0;
#line 3316
  l_tcp = (opj_tcp_t *)0;
#line 3317
  l_tccp = (opj_tccp_t *)0;
#line 3318
  l_current_poc = (opj_poc_t *)0;
#line 3327
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 3328
  l_tccp = l_tcp->tccps + 0;
#line 3329
  l_image = p_j2k->m_private_image;
#line 3330
  l_nb_comp = l_image->numcomps;
#line 3331
  l_nb_poc = 1U + l_tcp->numpocs;
#line 3333
  if (l_nb_comp <= 256U) {
#line 3334
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 3336
    l_poc_room = (OPJ_UINT32 )2;
  }
  {
#line 3339
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 3341
  l_current_data = p_data;
#line 3343
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65375, (OPJ_UINT32 )2);
#line 3345
  l_current_data += 2;
#line 3347
  opj_write_bytes_LE(l_current_data, l_poc_size - 2U, (OPJ_UINT32 )2);
#line 3349
  l_current_data += 2;
#line 3351
  l_current_poc = l_tcp->pocs;
#line 3352
  i = (OPJ_UINT32 )0;
  }
  {
#line 3352
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3352
    if (! (i < l_nb_poc)) {
#line 3352
      goto while_break;
    }
    {
#line 3353
    opj_write_bytes_LE(l_current_data, l_current_poc->resno0, (OPJ_UINT32 )1);
#line 3355
    l_current_data ++;
#line 3357
    opj_write_bytes_LE(l_current_data, l_current_poc->compno0, l_poc_room);
#line 3359
    l_current_data += l_poc_room;
#line 3361
    opj_write_bytes_LE(l_current_data, l_current_poc->layno1, (OPJ_UINT32 )2);
#line 3363
    l_current_data += 2;
#line 3365
    opj_write_bytes_LE(l_current_data, l_current_poc->resno1, (OPJ_UINT32 )1);
#line 3367
    l_current_data ++;
#line 3369
    opj_write_bytes_LE(l_current_data, l_current_poc->compno1, l_poc_room);
#line 3371
    l_current_data += l_poc_room;
#line 3373
    opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_current_poc->prg, (OPJ_UINT32 )1);
#line 3375
    l_current_data ++;
#line 3378
    __cil_tmp17 = opj_int_min((OPJ_INT32 )l_current_poc->layno1, (OPJ_INT32 )l_tcp->numlayers);
#line 3378
    l_current_poc->layno1 = (OPJ_UINT32 )__cil_tmp17;
#line 3380
    __cil_tmp18 = opj_int_min((OPJ_INT32 )l_current_poc->resno1, (OPJ_INT32 )l_tccp->numresolutions);
#line 3380
    l_current_poc->resno1 = (OPJ_UINT32 )__cil_tmp18;
#line 3382
    __cil_tmp19 = opj_int_min((OPJ_INT32 )l_current_poc->compno1, (OPJ_INT32 )l_nb_comp);
#line 3382
    l_current_poc->compno1 = (OPJ_UINT32 )__cil_tmp19;
#line 3385
    l_current_poc ++;
#line 3352
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 3388
  *p_data_written = l_poc_size;
#line 3389
  return;
}
}
#line 3391 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) 
{ 
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max_poc ;
  OPJ_UINT32 i ;

  {
#line 3393
  l_tcp = (opj_tcp_t *)0;
#line 3394
  l_nb_tiles = (OPJ_UINT32 )0;
#line 3395
  l_max_poc = (OPJ_UINT32 )0;
#line 3398
  l_tcp = p_j2k->m_cp.tcps;
#line 3399
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 3401
  i = (OPJ_UINT32 )0;
  {
#line 3401
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3401
    if (! (i < l_nb_tiles)) {
#line 3401
      goto while_break;
    }
    {
#line 3402
    l_max_poc = opj_uint_max(l_max_poc, l_tcp->numpocs);
#line 3403
    l_tcp ++;
#line 3401
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 3406
  l_max_poc ++;
#line 3408
  return (4U + 9U * l_max_poc);
}
}
#line 3411 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  opj_tcp_t *l_tcp ;

  {
#line 3415
  l_max = (OPJ_UINT32 )0;
#line 3416
  l_tcp = (opj_tcp_t *)0;
#line 3418
  l_tcp = p_j2k->m_cp.tcps;
#line 3419
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 3421
  i = (OPJ_UINT32 )0;
  {
#line 3421
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3421
    if (! (i < l_nb_tiles)) {
#line 3421
      goto while_break;
    }
    {
#line 3422
    l_max = opj_uint_max(l_max, l_tcp->m_nb_tile_parts);
#line 3424
    l_tcp ++;
#line 3421
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 3427
  return (12U * l_max);
}
}
#line 3430 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_coc_bytes ;
  OPJ_UINT32 l_qcc_bytes ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp9 ;

  {
  {
#line 3432
  l_nb_bytes = (OPJ_UINT32 )0;
#line 3436
  l_nb_comps = (p_j2k->m_private_image)->numcomps - 1U;
#line 3437
  __cil_tmp6 = opj_j2k_get_max_toc_size(p_j2k);
#line 3437
  l_nb_bytes += __cil_tmp6;
  }
#line 3439
  if ((int )p_j2k->m_cp.rsiz >= 3) {
#line 3439
    if (! ((int )p_j2k->m_cp.rsiz <= 6)) {
      {
#line 3440
      l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);
#line 3441
      l_nb_bytes += l_nb_comps * l_coc_bytes;
#line 3443
      l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);
#line 3444
      l_nb_bytes += l_nb_comps * l_qcc_bytes;
      }
    }
  } else {
    {
#line 3440
    l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);
#line 3441
    l_nb_bytes += l_nb_comps * l_coc_bytes;
#line 3443
    l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);
#line 3444
    l_nb_bytes += l_nb_comps * l_qcc_bytes;
    }
  }
  {
#line 3447
  __cil_tmp9 = opj_j2k_get_max_poc_size(p_j2k);
#line 3447
  l_nb_bytes += __cil_tmp9;
  }
#line 3451
  return (l_nb_bytes);
}
}
#line 3462 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_tmp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_old_poc_nb ;
  OPJ_UINT32 l_current_poc_nb ;
  OPJ_UINT32 l_current_poc_remaining ;
  OPJ_UINT32 l_chunk_size ;
  OPJ_UINT32 l_comp_room ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  opj_tcp_t *tmp___2 ;
  OPJ_UINT32 tmp___3 ;

  {
#line 3469
  l_image = (opj_image_t *)0;
#line 3473
  l_cp = (opj_cp_t *)0;
#line 3474
  l_tcp = (opj_tcp_t *)0;
#line 3475
  l_current_poc = (opj_poc_t *)0;
#line 3482
  l_image = p_j2k->m_private_image;
#line 3483
  l_nb_comp = l_image->numcomps;
#line 3484
  if (l_nb_comp <= 256U) {
#line 3485
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 3487
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 3489
  l_chunk_size = 5U + 2U * l_comp_room;
#line 3490
  l_current_poc_nb = p_header_size / l_chunk_size;
#line 3491
  l_current_poc_remaining = p_header_size % l_chunk_size;
#line 3493
  if (l_current_poc_nb <= 0U) {
    {
#line 3494
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
#line 3495
    return (0);
  } else
#line 3493
  if (l_current_poc_remaining != 0U) {
    {
#line 3494
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
#line 3495
    return (0);
  }
#line 3498
  l_cp = & p_j2k->m_cp;
#line 3499
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 3499
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 3499
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 3499
  l_tcp = tmp___2;
#line 3502
  if ((int )l_tcp->POC) {
#line 3502
    tmp___3 = l_tcp->numpocs + 1U;
  } else {
#line 3502
    tmp___3 = 0U;
  }
#line 3502
  l_old_poc_nb = tmp___3;
#line 3503
  l_current_poc_nb += l_old_poc_nb;
#line 3505
  if (l_current_poc_nb >= 32U) {
    {
#line 3506
    opj_event_msg(p_manager, 1, "Too many POCs %d\n", l_current_poc_nb);
    }
#line 3507
    return (0);
  }
#line 3512
  l_tcp->POC = (OPJ_BITFIELD )1;
#line 3514
  l_current_poc = & l_tcp->pocs[l_old_poc_nb];
#line 3515
  i = l_old_poc_nb;
  {
#line 3515
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3515
    if (! (i < l_current_poc_nb)) {
#line 3515
      goto while_break;
    }
    {
#line 3516
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno0, (OPJ_UINT32 )1);
#line 3518
    p_header_data ++;
#line 3519
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno0, l_comp_room);
#line 3521
    p_header_data += l_comp_room;
#line 3522
    opj_read_bytes_LE(p_header_data, & l_current_poc->layno1, (OPJ_UINT32 )2);
#line 3525
    l_current_poc->layno1 = opj_uint_min(l_current_poc->layno1, l_tcp->numlayers);
#line 3526
    p_header_data += 2;
#line 3527
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno1, (OPJ_UINT32 )1);
#line 3529
    p_header_data ++;
#line 3530
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno1, l_comp_room);
#line 3532
    p_header_data += l_comp_room;
#line 3533
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3535
    p_header_data ++;
#line 3536
    l_current_poc->prg = (OPJ_PROG_ORDER )l_tmp;
#line 3538
    l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);
#line 3539
    l_current_poc ++;
#line 3515
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 3542
  l_tcp->numpocs = l_current_poc_nb - 1U;
#line 3543
  return (1);
}
}
#line 3554 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;

  {
#line 3568
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 3570
  if (p_header_size != l_nb_comp * 4U) {
    {
#line 3571
    opj_event_msg(p_manager, 1, "Error reading CRG marker\n");
    }
#line 3572
    return (0);
  }
#line 3585
  return (1);
}
}
#line 3596 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Ztlm ;
  OPJ_UINT32 l_Stlm ;
  OPJ_UINT32 l_ST ;
  OPJ_UINT32 l_SP ;
  OPJ_UINT32 l_tot_num_tp_remaining ;
  OPJ_UINT32 l_quotient ;
  OPJ_UINT32 l_Ptlm_size ;

  {
#line 3611
  if (p_header_size < 2U) {
    {
#line 3612
    opj_event_msg(p_manager, 1, "Error reading TLM marker\n\341\0202 V");
    }
#line 3613
    return (0);
  }
  {
#line 3615
  p_header_size -= 2U;
#line 3617
  opj_read_bytes_LE(p_header_data, & l_Ztlm, (OPJ_UINT32 )1);
#line 3619
  p_header_data ++;
#line 3620
  opj_read_bytes_LE(p_header_data, & l_Stlm, (OPJ_UINT32 )1);
#line 3622
  p_header_data ++;
#line 3624
  l_ST = (l_Stlm >> 4) & 3U;
#line 3625
  l_SP = (l_Stlm >> 6) & 1U;
#line 3627
  l_Ptlm_size = (l_SP + 1U) * 2U;
#line 3628
  l_quotient = l_Ptlm_size + l_ST;
#line 3630
  l_tot_num_tp_remaining = p_header_size % l_quotient;
  }
#line 3632
  if (l_tot_num_tp_remaining != 0U) {
    {
#line 3633
    opj_event_msg(p_manager, 1, "Error reading TLM marker\n");
    }
#line 3634
    return (0);
  }
#line 3646
  return (1);
}
}
#line 3657 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 3671
  if (p_header_size < 1U) {
    {
#line 3672
    opj_event_msg(p_manager, 1, "Error reading PLM marker\nn\0202 V");
    }
#line 3673
    return (0);
  }
#line 3719
  return (1);
}
}
#line 3730 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Zplt ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_packet_len ;
  OPJ_UINT32 i ;

  {
#line 3736
  l_packet_len = (OPJ_UINT32 )0;
#line 3745
  if (p_header_size < 1U) {
    {
#line 3746
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n");
    }
#line 3747
    return (0);
  }
  {
#line 3750
  opj_read_bytes_LE(p_header_data, & l_Zplt, (OPJ_UINT32 )1);
#line 3751
  p_header_data ++;
#line 3752
  p_header_size --;
#line 3754
  i = (OPJ_UINT32 )0;
  }
  {
#line 3754
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3754
    if (! (i < p_header_size)) {
#line 3754
      goto while_break;
    }
    {
#line 3755
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3756
    p_header_data ++;
#line 3758
    l_packet_len |= l_tmp & 127U;
    }
#line 3759
    if (l_tmp & 128U) {
#line 3760
      l_packet_len <<= 7;
    } else {
#line 3763
      l_packet_len = (OPJ_UINT32 )0;
    }
#line 3754
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 3767
  if (l_packet_len != 0U) {
    {
#line 3768
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n");
    }
#line 3769
    return (0);
  }
#line 3772
  return (1);
}
}
#line 3784 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_ppm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_Z_ppm ;
  OPJ_UINT32 l_newCount ;
  void *__cil_tmp12 ;
  OPJ_UINT32 l_newCount___0 ;
  opj_ppx *new_ppm_markers ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
#line 3790
  l_cp = (opj_cp_t *)0;
#line 3799
  if (p_header_size < 2U) {
    {
#line 3800
    opj_event_msg(p_manager, 1, "Error reading PPM marker\n");
    }
#line 3801
    return (0);
  }
  {
#line 3804
  l_cp = & p_j2k->m_cp;
#line 3805
  l_cp->ppm = (OPJ_BITFIELD )1;
#line 3807
  opj_read_bytes_LE(p_header_data, & l_Z_ppm, (OPJ_UINT32 )1);
#line 3808
  p_header_data ++;
#line 3809
  p_header_size --;
  }
#line 3812
  if ((unsigned long )l_cp->ppm_markers == (unsigned long )((void *)0)) {
    {
#line 3813
    l_newCount = l_Z_ppm + 1U;
#line 3816
    __cil_tmp12 = opj_calloc((size_t )l_newCount, sizeof(opj_ppx ));
#line 3816
    l_cp->ppm_markers = (opj_ppx *)__cil_tmp12;
    }
#line 3817
    if ((unsigned long )l_cp->ppm_markers == (unsigned long )((void *)0)) {
      {
#line 3818
      opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\nV");
      }
#line 3819
      return (0);
    }
#line 3821
    l_cp->ppm_markers_count = l_newCount;
  } else
#line 3822
  if (l_cp->ppm_markers_count <= l_Z_ppm) {
    {
#line 3823
    l_newCount___0 = l_Z_ppm + 1U;
#line 3825
    __cil_tmp15 = opj_realloc((void *)l_cp->ppm_markers, (unsigned long )l_newCount___0 * sizeof(opj_ppx ));
#line 3825
    new_ppm_markers = (opj_ppx *)__cil_tmp15;
    }
#line 3827
    if ((unsigned long )new_ppm_markers == (unsigned long )((void *)0)) {
      {
#line 3829
      opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\nV");
      }
#line 3830
      return (0);
    }
    {
#line 3832
    l_cp->ppm_markers = new_ppm_markers;
#line 3833
    memset((void *)(l_cp->ppm_markers + l_cp->ppm_markers_count), 0, (unsigned long )(l_newCount___0 - l_cp->ppm_markers_count) * sizeof(opj_ppx ));
#line 3835
    l_cp->ppm_markers_count = l_newCount___0;
    }
  }
#line 3838
  if ((unsigned long )(l_cp->ppm_markers + l_Z_ppm)->m_data != (unsigned long )((void *)0)) {
    {
#line 3840
    opj_event_msg(p_manager, 1, "Zppm %u already read\n", l_Z_ppm);
    }
#line 3841
    return (0);
  }
  {
#line 3844
  __cil_tmp16 = opj_malloc((size_t )p_header_size);
#line 3844
  (l_cp->ppm_markers + l_Z_ppm)->m_data = (OPJ_BYTE *)__cil_tmp16;
  }
#line 3845
  if ((unsigned long )(l_cp->ppm_markers + l_Z_ppm)->m_data == (unsigned long )((void *)0)) {
    {
#line 3847
    opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\n");
    }
#line 3848
    return (0);
  }
  {
#line 3850
  (l_cp->ppm_markers + l_Z_ppm)->m_data_size = p_header_size;
#line 3851
  memcpy((void *)(l_cp->ppm_markers + l_Z_ppm)->m_data, (void const   *)p_header_data,
         (unsigned long )p_header_size);
  }
#line 3853
  return (1);
}
}
#line 3862 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_ppm_data_size ;
  OPJ_UINT32 l_N_ppm_remaining ;
  OPJ_UINT32 l_N_ppm ;
  OPJ_UINT32 l_data_size ;
  OPJ_BYTE *l_data ;
  void *__cil_tmp12 ;
  OPJ_UINT32 l_N_ppm___0 ;
  OPJ_UINT32 l_data_size___0 ;
  OPJ_BYTE *l_data___0 ;

  {
#line 3871
  if (p_cp->ppm == 0U) {
#line 3872
    return (1);
  }
#line 3875
  l_ppm_data_size = 0U;
#line 3876
  l_N_ppm_remaining = 0U;
#line 3877
  i = 0U;
  {
#line 3877
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3877
    if (! (i < p_cp->ppm_markers_count)) {
#line 3877
      goto while_break;
    }
#line 3878
    if ((unsigned long )(p_cp->ppm_markers + i)->m_data != (unsigned long )((void *)0)) {
#line 3881
      l_data_size = (p_cp->ppm_markers + i)->m_data_size;
#line 3882
      l_data = (p_cp->ppm_markers + i)->m_data;
#line 3884
      if (l_N_ppm_remaining >= l_data_size) {
#line 3885
        l_N_ppm_remaining -= l_data_size;
#line 3886
        l_data_size = 0U;
      } else {
#line 3888
        l_data += l_N_ppm_remaining;
#line 3889
        l_data_size -= l_N_ppm_remaining;
#line 3890
        l_N_ppm_remaining = 0U;
      }
#line 3893
      if (l_data_size > 0U) {
        {
#line 3894
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 3896
          if (l_data_size < 4U) {
            {
#line 3898
            opj_event_msg(p_manager, 1, "Not enough bytes to read Nppm\n");
            }
#line 3899
            return (0);
          }
          {
#line 3901
          opj_read_bytes_LE(l_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3902
          l_data += 4;
#line 3903
          l_data_size -= 4U;
#line 3904
          l_ppm_data_size += l_N_ppm;
          }
#line 3907
          if (l_data_size >= l_N_ppm) {
#line 3908
            l_data_size -= l_N_ppm;
#line 3909
            l_data += l_N_ppm;
          } else {
#line 3911
            l_N_ppm_remaining = l_N_ppm - l_data_size;
#line 3912
            l_data_size = 0U;
          }
#line 3894
          if (! (l_data_size > 0U)) {
#line 3894
            goto while_break___0;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___0: ;
      }
    }
#line 3877
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 3919
  if (l_N_ppm_remaining != 0U) {
    {
#line 3921
    opj_event_msg(p_manager, 1, "Corrupted PPM markers\n");
    }
#line 3922
    return (0);
  }
  {
#line 3925
  __cil_tmp12 = opj_malloc((size_t )l_ppm_data_size);
#line 3925
  p_cp->ppm_buffer = (OPJ_BYTE *)__cil_tmp12;
  }
#line 3926
  if ((unsigned long )p_cp->ppm_buffer == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 3927
    opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\n");
    }
#line 3928
    return (0);
  }
#line 3930
  p_cp->ppm_len = l_ppm_data_size;
#line 3931
  l_ppm_data_size = 0U;
#line 3932
  l_N_ppm_remaining = 0U;
#line 3933
  i = 0U;
  {
#line 3933
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 3933
    if (! (i < p_cp->ppm_markers_count)) {
#line 3933
      goto while_break___1;
    }
#line 3934
    if ((unsigned long )(p_cp->ppm_markers + i)->m_data != (unsigned long )((void *)0)) {
#line 3937
      l_data_size___0 = (p_cp->ppm_markers + i)->m_data_size;
#line 3938
      l_data___0 = (p_cp->ppm_markers + i)->m_data;
#line 3940
      if (l_N_ppm_remaining >= l_data_size___0) {
        {
#line 3941
        memcpy((void *)(p_cp->ppm_buffer + l_ppm_data_size), (void const   *)l_data___0,
               (unsigned long )l_data_size___0);
#line 3942
        l_ppm_data_size += l_data_size___0;
#line 3943
        l_N_ppm_remaining -= l_data_size___0;
#line 3944
        l_data_size___0 = 0U;
        }
      } else {
        {
#line 3946
        memcpy((void *)(p_cp->ppm_buffer + l_ppm_data_size), (void const   *)l_data___0,
               (unsigned long )l_N_ppm_remaining);
#line 3947
        l_ppm_data_size += l_N_ppm_remaining;
#line 3948
        l_data___0 += l_N_ppm_remaining;
#line 3949
        l_data_size___0 -= l_N_ppm_remaining;
#line 3950
        l_N_ppm_remaining = 0U;
        }
      }
#line 3953
      if (l_data_size___0 > 0U) {
        {
#line 3954
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 3956
          if (l_data_size___0 < 4U) {
            {
#line 3958
            opj_event_msg(p_manager, 1, "Not enough bytes to read Nppm\n");
            }
#line 3959
            return (0);
          }
          {
#line 3961
          opj_read_bytes_LE(l_data___0, & l_N_ppm___0, (OPJ_UINT32 )4);
#line 3962
          l_data___0 += 4;
#line 3963
          l_data_size___0 -= 4U;
          }
#line 3965
          if (l_data_size___0 >= l_N_ppm___0) {
            {
#line 3966
            memcpy((void *)(p_cp->ppm_buffer + l_ppm_data_size), (void const   *)l_data___0,
                   (unsigned long )l_N_ppm___0);
#line 3967
            l_ppm_data_size += l_N_ppm___0;
#line 3968
            l_data_size___0 -= l_N_ppm___0;
#line 3969
            l_data___0 += l_N_ppm___0;
            }
          } else {
            {
#line 3971
            memcpy((void *)(p_cp->ppm_buffer + l_ppm_data_size), (void const   *)l_data___0,
                   (unsigned long )l_data_size___0);
#line 3972
            l_ppm_data_size += l_data_size___0;
#line 3973
            l_N_ppm_remaining = l_N_ppm___0 - l_data_size___0;
#line 3974
            l_data_size___0 = 0U;
            }
          }
#line 3954
          if (! (l_data_size___0 > 0U)) {
#line 3954
            goto while_break___2;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: ;
      }
      {
#line 3978
      opj_free((void *)(p_cp->ppm_markers + i)->m_data);
#line 3979
      (p_cp->ppm_markers + i)->m_data = (OPJ_BYTE *)((void *)0);
#line 3980
      (p_cp->ppm_markers + i)->m_data_size = 0U;
      }
    }
#line 3933
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 3984
  p_cp->ppm_data = p_cp->ppm_buffer;
#line 3985
  p_cp->ppm_data_size = p_cp->ppm_len;
#line 3987
  p_cp->ppm_markers_count = 0U;
#line 3988
  opj_free((void *)p_cp->ppm_markers);
#line 3989
  p_cp->ppm_markers = (opj_ppx *)((void *)0);
  }
#line 3991
  return (1);
}
}
#line 4002 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_Z_ppt ;
  OPJ_UINT32 l_newCount ;
  void *__cil_tmp13 ;
  OPJ_UINT32 l_newCount___0 ;
  opj_ppx *new_ppt_markers ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 4008
  l_cp = (opj_cp_t *)0;
#line 4009
  l_tcp = (opj_tcp_t *)0;
#line 4018
  if (p_header_size < 2U) {
    {
#line 4019
    opj_event_msg(p_manager, 1, "Error reading PPT marker\n");
    }
#line 4020
    return (0);
  }
#line 4023
  l_cp = & p_j2k->m_cp;
#line 4024
  if (l_cp->ppm) {
    {
#line 4025
    opj_event_msg(p_manager, 1, "Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\n");
    }
#line 4027
    return (0);
  }
  {
#line 4030
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 4031
  l_tcp->ppt = (OPJ_BITFIELD )1;
#line 4033
  opj_read_bytes_LE(p_header_data, & l_Z_ppt, (OPJ_UINT32 )1);
#line 4034
  p_header_data ++;
#line 4035
  p_header_size --;
  }
#line 4038
  if ((unsigned long )l_tcp->ppt_markers == (unsigned long )((void *)0)) {
    {
#line 4039
    l_newCount = l_Z_ppt + 1U;
#line 4042
    __cil_tmp13 = opj_calloc((size_t )l_newCount, sizeof(opj_ppx ));
#line 4042
    l_tcp->ppt_markers = (opj_ppx *)__cil_tmp13;
    }
#line 4043
    if ((unsigned long )l_tcp->ppt_markers == (unsigned long )((void *)0)) {
      {
#line 4044
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\n");
      }
#line 4045
      return (0);
    }
#line 4047
    l_tcp->ppt_markers_count = l_newCount;
  } else
#line 4048
  if (l_tcp->ppt_markers_count <= l_Z_ppt) {
    {
#line 4049
    l_newCount___0 = l_Z_ppt + 1U;
#line 4051
    __cil_tmp16 = opj_realloc((void *)l_tcp->ppt_markers, (unsigned long )l_newCount___0 * sizeof(opj_ppx ));
#line 4051
    new_ppt_markers = (opj_ppx *)__cil_tmp16;
    }
#line 4053
    if ((unsigned long )new_ppt_markers == (unsigned long )((void *)0)) {
      {
#line 4055
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\n");
      }
#line 4056
      return (0);
    }
    {
#line 4058
    l_tcp->ppt_markers = new_ppt_markers;
#line 4059
    memset((void *)(l_tcp->ppt_markers + l_tcp->ppt_markers_count), 0, (unsigned long )(l_newCount___0 - l_tcp->ppt_markers_count) * sizeof(opj_ppx ));
#line 4061
    l_tcp->ppt_markers_count = l_newCount___0;
    }
  }
#line 4064
  if ((unsigned long )(l_tcp->ppt_markers + l_Z_ppt)->m_data != (unsigned long )((void *)0)) {
    {
#line 4066
    opj_event_msg(p_manager, 1, "Zppt %u already read\nV", l_Z_ppt);
    }
#line 4067
    return (0);
  }
  {
#line 4070
  __cil_tmp17 = opj_malloc((size_t )p_header_size);
#line 4070
  (l_tcp->ppt_markers + l_Z_ppt)->m_data = (OPJ_BYTE *)__cil_tmp17;
  }
#line 4071
  if ((unsigned long )(l_tcp->ppt_markers + l_Z_ppt)->m_data == (unsigned long )((void *)0)) {
    {
#line 4073
    opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nV");
    }
#line 4074
    return (0);
  }
  {
#line 4076
  (l_tcp->ppt_markers + l_Z_ppt)->m_data_size = p_header_size;
#line 4077
  memcpy((void *)(l_tcp->ppt_markers + l_Z_ppt)->m_data, (void const   *)p_header_data,
         (unsigned long )p_header_size);
  }
#line 4078
  return (1);
}
}
#line 4087 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_ppt_data_size ;
  void *__cil_tmp8 ;

  {
#line 4095
  if (p_tcp->ppt == 0U) {
#line 4096
    return (1);
  }
#line 4099
  l_ppt_data_size = 0U;
#line 4100
  i = 0U;
  {
#line 4100
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4100
    if (! (i < p_tcp->ppt_markers_count)) {
#line 4100
      goto while_break;
    }
#line 4101
    l_ppt_data_size += (p_tcp->ppt_markers + i)->m_data_size;
#line 4100
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 4105
  __cil_tmp8 = opj_malloc((size_t )l_ppt_data_size);
#line 4105
  p_tcp->ppt_buffer = (OPJ_BYTE *)__cil_tmp8;
  }
#line 4106
  if ((unsigned long )p_tcp->ppt_buffer == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 4107
    opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nV");
    }
#line 4108
    return (0);
  }
#line 4110
  p_tcp->ppt_len = l_ppt_data_size;
#line 4111
  l_ppt_data_size = 0U;
#line 4112
  i = 0U;
  {
#line 4112
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 4112
    if (! (i < p_tcp->ppt_markers_count)) {
#line 4112
      goto while_break___0;
    }
#line 4113
    if ((unsigned long )(p_tcp->ppt_markers + i)->m_data != (unsigned long )((void *)0)) {
      {
#line 4115
      memcpy((void *)(p_tcp->ppt_buffer + l_ppt_data_size), (void const   *)(p_tcp->ppt_markers + i)->m_data,
             (unsigned long )(p_tcp->ppt_markers + i)->m_data_size);
#line 4117
      l_ppt_data_size += (p_tcp->ppt_markers + i)->m_data_size;
#line 4120
      opj_free((void *)(p_tcp->ppt_markers + i)->m_data);
#line 4121
      (p_tcp->ppt_markers + i)->m_data = (OPJ_BYTE *)((void *)0);
#line 4122
      (p_tcp->ppt_markers + i)->m_data_size = 0U;
      }
    }
#line 4112
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 4126
  p_tcp->ppt_markers_count = 0U;
#line 4127
  opj_free((void *)p_tcp->ppt_markers);
#line 4128
  p_tcp->ppt_markers = (opj_ppx *)((void *)0);
#line 4130
  p_tcp->ppt_data = p_tcp->ppt_buffer;
#line 4131
  p_tcp->ppt_data_size = p_tcp->ppt_len;
  }
#line 4132
  return (1);
}
}
#line 4135 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tlm_size ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp12 ;

  {
#line 4140
  l_current_data = (OPJ_BYTE *)0;
#line 4148
  l_tlm_size = 6U + 5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 4150
  if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 4151
    __cil_tmp10 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_tlm_size);
#line 4151
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 4153
    if (! new_header_tile_data) {
      {
#line 4154
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 4155
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 4156
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 4157
      opj_event_msg(p_manager, 1, "Not enough memory to write TLM marker\n");
      }
#line 4158
      return (0);
    }
#line 4160
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 4161
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;
  }
  {
#line 4164
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 4168
  p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);
#line 4170
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65365, (OPJ_UINT32 )2);
#line 4172
  l_current_data += 2;
#line 4174
  opj_write_bytes_LE(l_current_data, l_tlm_size - 2U, (OPJ_UINT32 )2);
#line 4176
  l_current_data += 2;
#line 4178
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 4180
  l_current_data ++;
#line 4182
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )80, (OPJ_UINT32 )1);
#line 4184
  l_current_data ++;
#line 4187
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 4187
  if (__cil_tmp12 != (unsigned long )l_tlm_size) {
#line 4190
    return (0);
  }
#line 4193
  return (1);
}
}
#line 4196 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 p_total_data_size ,
                                  OPJ_UINT32 *p_data_written , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 


  {
#line 4211
  if (p_total_data_size < 12U) {
    {
#line 4212
    opj_event_msg(p_manager, 1, "Not enough bytes in output buffer to write SOT marker\n");
    }
#line 4214
    return (0);
  }
  {
#line 4217
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65424, (OPJ_UINT32 )2);
#line 4219
  p_data += 2;
#line 4221
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )10, (OPJ_UINT32 )2);
#line 4223
  p_data += 2;
#line 4225
  opj_write_bytes_LE(p_data, p_j2k->m_current_tile_number, (OPJ_UINT32 )2);
#line 4227
  p_data += 2;
#line 4230
  p_data += 4;
#line 4232
  opj_write_bytes_LE(p_data, p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,
                     (OPJ_UINT32 )1);
#line 4235
  p_data ++;
#line 4237
  opj_write_bytes_LE(p_data, (p_j2k->m_cp.tcps + p_j2k->m_current_tile_number)->m_nb_tile_parts,
                     (OPJ_UINT32 )1);
#line 4240
  p_data ++;
#line 4251
  *p_data_written = (OPJ_UINT32 )12;
  }
#line 4253
  return (1);
}
}
#line 4256 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                       OPJ_UINT32 *p_tile_no , OPJ_UINT32 *p_tot_len ,
                                       OPJ_UINT32 *p_current_part , OPJ_UINT32 *p_num_parts ,
                                       opj_event_mgr_t *p_manager ) 
{ 


  {
#line 4269
  if (p_header_size != 8U) {
    {
#line 4270
    opj_event_msg(p_manager, 1, "Error reading SOT marker\n");
    }
#line 4271
    return (0);
  }
  {
#line 4274
  opj_read_bytes_LE(p_header_data, p_tile_no, (OPJ_UINT32 )2);
#line 4275
  p_header_data += 2;
#line 4276
  opj_read_bytes_LE(p_header_data, p_tot_len, (OPJ_UINT32 )4);
#line 4277
  p_header_data += 4;
#line 4278
  opj_read_bytes_LE(p_header_data, p_current_part, (OPJ_UINT32 )1);
#line 4279
  p_header_data ++;
#line 4280
  opj_read_bytes_LE(p_header_data, p_num_parts, (OPJ_UINT32 )1);
#line 4281
  p_header_data ++;
  }
#line 4282
  return (1);
}
}
#line 4285 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tot_len ;
  OPJ_UINT32 l_num_parts ;
  OPJ_UINT32 l_current_part ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  OPJ_BOOL __cil_tmp14 ;
  void *__cil_tmp17 ;
  opj_tp_index_t *new_tp_index ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  opj_tp_index_t *new_tp_index___0 ;
  void *__cil_tmp22 ;
  int tmp___3 ;

  {
  {
#line 4290
  l_cp = (opj_cp_t *)0;
#line 4291
  l_tcp = (opj_tcp_t *)0;
#line 4292
  l_num_parts = (OPJ_UINT32 )0;
#line 4301
  __cil_tmp14 = opj_j2k_get_sot_values(p_header_data, p_header_size, & p_j2k->m_current_tile_number,
                                       & l_tot_len, & l_current_part, & l_num_parts,
                                       p_manager);
  }
#line 4301
  if (! __cil_tmp14) {
    {
#line 4304
    opj_event_msg(p_manager, 1, "Error reading SOT marker\n\302\0222 V");
    }
#line 4305
    return (0);
  }
#line 4308
  l_cp = & p_j2k->m_cp;
#line 4311
  if (p_j2k->m_current_tile_number >= l_cp->tw * l_cp->th) {
    {
#line 4312
    opj_event_msg(p_manager, 1, "Invalid tile number %d\n", p_j2k->m_current_tile_number);
    }
#line 4314
    return (0);
  }
#line 4317
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 4318
  l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;
#line 4319
  l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;
#line 4328
  if (l_tcp->m_current_tile_part_number + 1 != (OPJ_INT32 )l_current_part) {
    {
#line 4329
    opj_event_msg(p_manager, 1, "Invalid tile part index for tile number %d. Got %d, expected %d\n V",
                  p_j2k->m_current_tile_number, l_current_part, l_tcp->m_current_tile_part_number + 1);
    }
#line 4335
    return (0);
  }
#line 4337
  (l_tcp->m_current_tile_part_number) ++;
#line 4371
  if (l_tot_len != 0U) {
#line 4371
    if (l_tot_len < 14U) {
#line 4372
      if (l_tot_len == 12U) {
        {
#line 4374
        opj_event_msg(p_manager, 2, "Empty SOT marker detected: Psot=%d.\n", l_tot_len);
        }
      } else {
        {
#line 4377
        opj_event_msg(p_manager, 1, "Psot value is not correct regards to the JPEG2000 norm: %d.\n",
                      l_tot_len);
        }
#line 4379
        return (0);
      }
    }
  }
#line 4407
  if (! l_tot_len) {
    {
#line 4408
    opj_event_msg(p_manager, 4, "Psot value of the current tile-part is equal to zero, we assuming it is the last tile-part of the codestream.\n");
#line 4411
    p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
    }
  }
#line 4414
  if (l_tcp->m_nb_tile_parts != 0U) {
#line 4414
    if (l_current_part >= l_tcp->m_nb_tile_parts) {
      {
#line 4416
      opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the previous number of tile-part (%d), giving up\n",
                    l_current_part, l_tcp->m_nb_tile_parts);
#line 4420
      p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
      }
#line 4421
      return (0);
    }
  }
#line 4424
  if (l_num_parts != 0U) {
#line 4426
    l_num_parts += p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction;
#line 4429
    if (l_tcp->m_nb_tile_parts) {
#line 4430
      if (l_current_part >= l_tcp->m_nb_tile_parts) {
        {
#line 4431
        opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (%d), giving up\n",
                      l_current_part, l_tcp->m_nb_tile_parts);
#line 4435
        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
        }
#line 4436
        return (0);
      }
    }
#line 4439
    if (l_current_part >= l_num_parts) {
      {
#line 4441
      opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (header) (%d), giving up\n",
                    l_current_part, l_num_parts);
#line 4444
      p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
      }
#line 4445
      return (0);
    }
#line 4447
    l_tcp->m_nb_tile_parts = l_num_parts;
  }
#line 4451
  if (l_tcp->m_nb_tile_parts) {
#line 4452
    if (l_tcp->m_nb_tile_parts == l_current_part + 1U) {
#line 4453
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )1;
    }
  }
#line 4458
  if (! p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
#line 4460
    p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len - 12U;
  } else {
#line 4464
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )0;
  }
#line 4467
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )16;
#line 4470
  if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {
#line 4471
    if (l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x) {
#line 4471
      tmp___3 = 1;
    } else
#line 4471
    if (l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x) {
#line 4471
      tmp___3 = 1;
    } else
#line 4471
    if (l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y) {
#line 4471
      tmp___3 = 1;
    } else
#line 4471
    if (l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y) {
#line 4471
      tmp___3 = 1;
    } else {
#line 4471
      tmp___3 = 0;
    }
#line 4471
    p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_BITFIELD )tmp___3;
  } else {
#line 4478
    p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_BITFIELD )(p_j2k->m_current_tile_number != (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec);
  }
#line 4484
  if (p_j2k->cstr_index) {
#line 4486
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tileno = p_j2k->m_current_tile_number;
#line 4488
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_tpsno = l_current_part;
#line 4491
    if (l_num_parts != 0U) {
#line 4492
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->nb_tps = l_num_parts;
#line 4494
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = l_num_parts;
#line 4497
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4498
        __cil_tmp17 = opj_calloc((size_t )l_num_parts, sizeof(opj_tp_index_t ));
#line 4498
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp17;
        }
#line 4500
        if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
          {
#line 4501
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4503
          return (0);
        }
      } else {
        {
#line 4506
        __cil_tmp19 = opj_realloc((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                                  (unsigned long )l_num_parts * sizeof(opj_tp_index_t ));
#line 4506
        new_tp_index = (opj_tp_index_t *)__cil_tmp19;
        }
#line 4509
        if (! new_tp_index) {
          {
#line 4510
          opj_free((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4511
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4512
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4514
          return (0);
        }
#line 4516
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index;
      }
    } else {
#line 4522
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4523
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )10;
#line 4524
        __cil_tmp20 = opj_calloc((size_t )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps,
                                 sizeof(opj_tp_index_t ));
#line 4524
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp20;
        }
#line 4528
        if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
          {
#line 4529
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4530
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4532
          return (0);
        }
      }
#line 4536
      if (l_current_part >= ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps) {
        {
#line 4539
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = l_current_part + 1U;
#line 4541
        __cil_tmp22 = opj_realloc((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                                  (unsigned long )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps * sizeof(opj_tp_index_t ));
#line 4541
        new_tp_index___0 = (opj_tp_index_t *)__cil_tmp22;
        }
#line 4545
        if (! new_tp_index___0) {
          {
#line 4546
          opj_free((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4547
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4548
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4549
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4551
          return (0);
        }
#line 4553
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index___0;
      }
    }
  }
#line 4589
  return (1);
}
}
#line 4592 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                                  OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                                  opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_UINT32 l_remaining_data ;
  OPJ_BOOL __cil_tmp13 ;

  {
#line 4601
  l_cstr_info = (opj_codestream_info_t *)0;
#line 4611
  if (p_total_data_size < 4U) {
    {
#line 4612
    opj_event_msg(p_manager, 1, "Not enough bytes in output buffer to write SOD marker\n");
    }
#line 4614
    return (0);
  }
  {
#line 4617
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65427, (OPJ_UINT32 )2);
#line 4619
  p_data += 2;
#line 4622
  l_remaining_data = p_total_data_size - 4U;
#line 4625
  p_tile_coder->tp_num = p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number;
#line 4627
  p_tile_coder->cur_tp_num = p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
  }
#line 4658
  if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0U) {
#line 4659
    ((p_tile_coder->tcd_image)->tiles)->packno = (OPJ_UINT32 )0;
#line 4660
    if (l_cstr_info) {
#line 4661
      l_cstr_info->packno = 0;
    }
  }
  {
#line 4665
  *p_data_written = (OPJ_UINT32 )0;
#line 4667
  __cil_tmp13 = opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,
                                    p_data_written, l_remaining_data, l_cstr_info,
                                    p_manager);
  }
#line 4667
  if (! __cil_tmp13) {
    {
#line 4670
    opj_event_msg(p_manager, 1, "Cannot encode tile\n");
    }
#line 4671
    return (0);
  }
#line 4674
  *p_data_written += 2U;
#line 4676
  return (1);
}
}
#line 4679 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_SIZE_T l_current_read_size ;
  opj_codestream_index_t *l_cstr_index ;
  OPJ_BYTE **l_current_data ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 *l_tile_len ;
  OPJ_BOOL l_sot_length_pb_detected ;
  OPJ_OFF_T __cil_tmp13 ;
  OPJ_OFF_T __cil_tmp14 ;
  void *__cil_tmp15 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp17 ;
  OPJ_OFF_T l_current_pos ;
  OPJ_OFF_T __cil_tmp19 ;
  OPJ_UINT32 l_current_tile_part ;
  OPJ_BOOL __cil_tmp21 ;

  {
#line 4685
  l_cstr_index = (opj_codestream_index_t *)0;
#line 4686
  l_current_data = (OPJ_BYTE **)0;
#line 4687
  l_tcp = (opj_tcp_t *)0;
#line 4688
  l_tile_len = (OPJ_UINT32 *)0;
#line 4689
  l_sot_length_pb_detected = 0;
#line 4696
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 4698
  if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
    {
#line 4703
    __cil_tmp13 = opj_stream_get_number_byte_left(p_stream);
#line 4703
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )(__cil_tmp13 - 2L);
    }
  } else
#line 4707
  if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2U) {
#line 4708
    p_j2k->m_specific_param.m_decoder.m_sot_length -= 2U;
  }
#line 4714
  l_current_data = & l_tcp->m_data;
#line 4715
  l_tile_len = & l_tcp->m_data_size;
#line 4718
  if (p_j2k->m_specific_param.m_decoder.m_sot_length) {
    {
#line 4721
    __cil_tmp14 = opj_stream_get_number_byte_left(p_stream);
    }
#line 4721
    if ((OPJ_OFF_T )p_j2k->m_specific_param.m_decoder.m_sot_length > __cil_tmp14) {
      {
#line 4723
      opj_event_msg(p_manager, 1, "Tile part length size inconsistent with stream length\n");
      }
#line 4725
      return (0);
    }
#line 4727
    if (p_j2k->m_specific_param.m_decoder.m_sot_length > 4294967293U) {
      {
#line 4729
      opj_event_msg(p_manager, 1, "p_j2k->m_specific_param.m_decoder.m_sot_length > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA");
      }
#line 4732
      return (0);
    }
#line 4737
    if (! *l_current_data) {
      {
#line 4741
      __cil_tmp15 = opj_malloc((size_t )(p_j2k->m_specific_param.m_decoder.m_sot_length + 2U));
#line 4741
      *l_current_data = (OPJ_BYTE *)__cil_tmp15;
      }
    } else {
#line 4745
      if (*l_tile_len > 4294967293U - p_j2k->m_specific_param.m_decoder.m_sot_length) {
        {
#line 4747
        opj_event_msg(p_manager, 1, "*l_tile_len > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA - p_j2k->m_specific_param.m_decoder.m_sot_length\220");
        }
#line 4750
        return (0);
      }
      {
#line 4753
      __cil_tmp17 = opj_realloc((void *)*l_current_data, (size_t )((*l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length) + 2U));
#line 4753
      l_new_current_data = (OPJ_BYTE *)__cil_tmp17;
      }
#line 4756
      if (! l_new_current_data) {
        {
#line 4757
        opj_free((void *)*l_current_data);
        }
      }
#line 4763
      *l_current_data = l_new_current_data;
    }
#line 4766
    if ((unsigned long )*l_current_data == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 4767
      opj_event_msg(p_manager, 1, "Not enough memory to decode tile\n\023\0232 V");
      }
#line 4768
      return (0);
    }
  } else {
#line 4771
    l_sot_length_pb_detected = 1;
  }
#line 4775
  l_cstr_index = p_j2k->cstr_index;
#line 4776
  if (l_cstr_index) {
    {
#line 4777
    __cil_tmp19 = opj_stream_tell(p_stream);
#line 4777
    l_current_pos = __cil_tmp19 - 2L;
#line 4779
    l_current_tile_part = (l_cstr_index->tile_index + p_j2k->m_current_tile_number)->current_tpsno;
#line 4781
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_header = l_current_pos;
#line 4784
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_pos = (l_current_pos + (long )p_j2k->m_specific_param.m_decoder.m_sot_length) + 2L;
#line 4788
    __cil_tmp21 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, l_cstr_index,
                                       (OPJ_UINT32 )65427, l_current_pos, p_j2k->m_specific_param.m_decoder.m_sot_length + 2U);
    }
#line 4788
    if (0 == __cil_tmp21) {
      {
#line 4793
      opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\n");
      }
#line 4794
      return (0);
    }
  }
#line 4801
  if (! l_sot_length_pb_detected) {
    {
#line 4802
    l_current_read_size = opj_stream_read_data(p_stream, *l_current_data + *l_tile_len,
                                               (OPJ_SIZE_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                               p_manager);
    }
  } else {
#line 4808
    l_current_read_size = (OPJ_SIZE_T )0;
  }
#line 4811
  if (l_current_read_size != (unsigned long )p_j2k->m_specific_param.m_decoder.m_sot_length) {
#line 4812
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
  } else {
#line 4814
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 4817
  *l_tile_len += (OPJ_UINT32 )l_current_read_size;
#line 4819
  return (1);
}
}
#line 4822 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                  OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_rgn_size ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 l_comp_room ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
#line 4830
  l_current_data = (OPJ_BYTE *)0;
#line 4832
  l_cp = (opj_cp_t *)0;
#line 4833
  l_tcp = (opj_tcp_t *)0;
#line 4834
  l_tccp = (opj_tccp_t *)0;
#line 4842
  l_cp = & p_j2k->m_cp;
#line 4843
  l_tcp = l_cp->tcps + p_tile_no;
#line 4844
  l_tccp = l_tcp->tccps + p_comp_no;
#line 4846
  if (nb_comps <= 256U) {
#line 4847
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 4849
    l_comp_room = (OPJ_UINT32 )2;
  }
  {
#line 4852
  l_rgn_size = 6U + l_comp_room;
#line 4854
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 4856
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65374, (OPJ_UINT32 )2);
#line 4858
  l_current_data += 2;
#line 4860
  opj_write_bytes_LE(l_current_data, l_rgn_size - 2U, (OPJ_UINT32 )2);
#line 4862
  l_current_data += 2;
#line 4864
  opj_write_bytes_LE(l_current_data, p_comp_no, l_comp_room);
#line 4866
  l_current_data += l_comp_room;
#line 4868
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 4870
  l_current_data ++;
#line 4872
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tccp->roishift, (OPJ_UINT32 )1);
#line 4874
  l_current_data ++;
#line 4876
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_rgn_size, p_manager);
  }
#line 4876
  if (__cil_tmp16 != (unsigned long )l_rgn_size) {
#line 4879
    return (0);
  }
#line 4882
  return (1);
}
}
#line 4885 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_SIZE_T __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 4895
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (OPJ_UINT32 )65497,
                     (OPJ_UINT32 )2);
#line 4906
  __cil_tmp7 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 4906
  if (__cil_tmp7 != 2UL) {
#line 4908
    return (0);
  }
  {
#line 4911
  __cil_tmp8 = opj_stream_flush(p_stream, p_manager);
  }
#line 4911
  if (! __cil_tmp8) {
#line 4912
    return (0);
  }
#line 4915
  return (1);
}
}
#line 4926 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  OPJ_UINT32 l_roi_sty ;
  opj_tcp_t *tmp___2 ;

  {
#line 4933
  l_image = (opj_image_t *)0;
#line 4935
  l_cp = (opj_cp_t *)0;
#line 4936
  l_tcp = (opj_tcp_t *)0;
#line 4944
  l_image = p_j2k->m_private_image;
#line 4945
  l_nb_comp = l_image->numcomps;
#line 4947
  if (l_nb_comp <= 256U) {
#line 4948
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 4950
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 4953
  if (p_header_size != 2U + l_comp_room) {
    {
#line 4954
    opj_event_msg(p_manager, 1, "Error reading RGN marker\nJ\0242 V");
    }
#line 4955
    return (0);
  }
#line 4958
  l_cp = & p_j2k->m_cp;
#line 4959
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 4959
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 4959
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
  {
#line 4959
  l_tcp = tmp___2;
#line 4963
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 4964
  p_header_data += l_comp_room;
#line 4965
  opj_read_bytes_LE(p_header_data, & l_roi_sty, (OPJ_UINT32 )1);
#line 4967
  p_header_data ++;
  }
#line 4985
  if (l_comp_no >= l_nb_comp) {
    {
#line 4986
    opj_event_msg(p_manager, 1, "bad component number in RGN (%d when there are only %d)\n\230\001",
                  l_comp_no, l_nb_comp);
    }
#line 4989
    return (0);
  }
  {
#line 4992
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& (l_tcp->tccps + l_comp_no)->roishift),
                    (OPJ_UINT32 )1);
#line 4994
  p_header_data ++;
  }
#line 4996
  return (1);
}
}
#line 5000 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 5002
  return ((OPJ_FLOAT32 )((p_tcp->m_nb_tile_parts - 1U) * 14U));
}
}
#line 5005 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 5008
  return ((OPJ_FLOAT32 )0);
}
}
#line 5011 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 l_x0 ;
  OPJ_INT32 l_y0 ;
  OPJ_INT32 l_x1 ;
  OPJ_INT32 l_y1 ;
  OPJ_FLOAT32 *l_rates ;
  OPJ_FLOAT32 l_sot_remove ;
  OPJ_UINT32 l_bits_empty ;
  OPJ_UINT32 l_size_pixel ;
  OPJ_UINT32 l_tile_size ;
  OPJ_UINT32 l_last_res ;
  OPJ_FLOAT32 (*l_tp_stride_func)(opj_tcp_t * ) ;
  OPJ_OFF_T __cil_tmp25 ;
  OPJ_FLOAT32 l_offset ;
  OPJ_FLOAT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;

  {
  {
#line 5015
  l_cp = (opj_cp_t *)0;
#line 5016
  l_image = (opj_image_t *)0;
#line 5017
  l_tcp = (opj_tcp_t *)0;
#line 5018
  l_img_comp = (opj_image_comp_t *)0;
#line 5022
  l_rates = (OPJ_FLOAT32 *)0;
#line 5025
  l_tile_size = (OPJ_UINT32 )0;
#line 5027
  l_tp_stride_func = (OPJ_FLOAT32 (*)(opj_tcp_t * ))0;
#line 5036
  l_cp = & p_j2k->m_cp;
#line 5037
  l_image = p_j2k->m_private_image;
#line 5038
  l_tcp = l_cp->tcps;
#line 5040
  l_bits_empty = (8U * (l_image->comps)->dx) * (l_image->comps)->dy;
#line 5041
  l_size_pixel = l_image->numcomps * (l_image->comps)->prec;
#line 5042
  __cil_tmp25 = opj_stream_tell(p_stream);
#line 5042
  l_sot_remove = (OPJ_FLOAT32 )__cil_tmp25 / (OPJ_FLOAT32 )(l_cp->th * l_cp->tw);
  }
#line 5045
  if (l_cp->m_specific_param.m_enc.m_tp_on) {
#line 5046
    l_tp_stride_func = & opj_j2k_get_tp_stride;
  } else {
#line 5048
    l_tp_stride_func = & opj_j2k_get_default_stride;
  }
#line 5051
  i = (OPJ_UINT32 )0;
  {
#line 5051
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5051
    if (! (i < l_cp->th)) {
#line 5051
      goto while_break;
    }
#line 5052
    j = (OPJ_UINT32 )0;
    {
#line 5052
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 5052
      if (! (j < l_cp->tw)) {
#line 5052
        goto while_break___0;
      }
      {
#line 5053
      __cil_tmp27 = (*l_tp_stride_func)(l_tcp);
#line 5053
      l_offset = __cil_tmp27 / (OPJ_FLOAT32 )l_tcp->numlayers;
#line 5057
      l_x0 = opj_int_max((OPJ_INT32 )(l_cp->tx0 + j * l_cp->tdx), (OPJ_INT32 )l_image->x0);
#line 5059
      l_y0 = opj_int_max((OPJ_INT32 )(l_cp->ty0 + i * l_cp->tdy), (OPJ_INT32 )l_image->y0);
#line 5061
      l_x1 = opj_int_min((OPJ_INT32 )(l_cp->tx0 + (j + 1U) * l_cp->tdx), (OPJ_INT32 )l_image->x1);
#line 5063
      l_y1 = opj_int_min((OPJ_INT32 )(l_cp->ty0 + (i + 1U) * l_cp->tdy), (OPJ_INT32 )l_image->y1);
#line 5066
      l_rates = l_tcp->rates;
      }
#line 5069
      if (*l_rates > 0.f) {
#line 5070
        *l_rates = (OPJ_FLOAT32 )((l_size_pixel * (OPJ_UINT32 )(l_x1 - l_x0)) * (OPJ_UINT32 )(l_y1 - l_y0)) / (*l_rates * (OPJ_FLOAT32 )l_bits_empty) - l_offset;
      }
#line 5079
      l_rates ++;
#line 5081
      k = (OPJ_UINT32 )1;
      {
#line 5081
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 5081
        if (! (k < l_tcp->numlayers)) {
#line 5081
          goto while_break___1;
        }
#line 5082
        if (*l_rates > 0.f) {
#line 5083
          *l_rates = (OPJ_FLOAT32 )((l_size_pixel * (OPJ_UINT32 )(l_x1 - l_x0)) * (OPJ_UINT32 )(l_y1 - l_y0)) / (*l_rates * (OPJ_FLOAT32 )l_bits_empty) - l_offset;
        }
#line 5092
        l_rates ++;
#line 5081
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: 
#line 5095
      l_tcp ++;
#line 5052
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: 
#line 5051
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: 
#line 5100
  l_tcp = l_cp->tcps;
#line 5102
  i = (OPJ_UINT32 )0;
  {
#line 5102
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 5102
    if (! (i < l_cp->th)) {
#line 5102
      goto while_break___2;
    }
#line 5103
    j = (OPJ_UINT32 )0;
    {
#line 5103
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 5103
      if (! (j < l_cp->tw)) {
#line 5103
        goto while_break___3;
      }
#line 5104
      l_rates = l_tcp->rates;
#line 5106
      if (*l_rates > 0.f) {
#line 5107
        *l_rates -= l_sot_remove;
#line 5109
        if (*l_rates < 30.f) {
#line 5110
          *l_rates = 30.f;
        }
      }
#line 5114
      l_rates ++;
#line 5116
      l_last_res = l_tcp->numlayers - 1U;
#line 5118
      k = (OPJ_UINT32 )1;
      {
#line 5118
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 5118
        if (! (k < l_last_res)) {
#line 5118
          goto while_break___4;
        }
#line 5120
        if (*l_rates > 0.f) {
#line 5121
          *l_rates -= l_sot_remove;
#line 5123
          if (*l_rates < *(l_rates - 1) + 10.f) {
#line 5124
            *l_rates = *(l_rates - 1) + 20.f;
          }
        }
#line 5128
        l_rates ++;
#line 5118
        k ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: ;
#line 5131
      if (*l_rates > 0.f) {
#line 5132
        *l_rates -= l_sot_remove + 2.f;
#line 5134
        if (*l_rates < *(l_rates - 1) + 10.f) {
#line 5135
          *l_rates = *(l_rates - 1) + 20.f;
        }
      }
#line 5139
      l_tcp ++;
#line 5103
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___3: 
#line 5102
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___2: 
#line 5143
  l_img_comp = l_image->comps;
#line 5144
  l_tile_size = (OPJ_UINT32 )0;
#line 5146
  i = (OPJ_UINT32 )0;
  {
#line 5146
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 5146
    if (! (i < l_image->numcomps)) {
#line 5146
      goto while_break___5;
    }
    {
#line 5147
    __cil_tmp33 = opj_uint_ceildiv(l_cp->tdy, l_img_comp->dy);
#line 5147
    __cil_tmp32 = opj_uint_ceildiv(l_cp->tdx, l_img_comp->dx);
#line 5147
    l_tile_size += (__cil_tmp32 * __cil_tmp33) * l_img_comp->prec;
#line 5154
    l_img_comp ++;
#line 5146
    i ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___5: 
  {
#line 5163
  l_tile_size = (OPJ_UINT32 )(((double )l_tile_size * 1.4) / (double )8);
#line 5167
  l_tile_size += 500U;
#line 5169
  __cil_tmp34 = opj_j2k_get_specific_header_sizes(p_j2k);
#line 5169
  l_tile_size += __cil_tmp34;
#line 5171
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = l_tile_size;
#line 5172
  __cil_tmp35 = opj_malloc((size_t )p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);
#line 5172
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)__cil_tmp35;
  }
#line 5174
  if ((unsigned long )p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 5175
    return (0);
  }
#line 5178
  if ((int )l_cp->rsiz >= 3) {
#line 5178
    if ((int )l_cp->rsiz <= 6) {
      {
#line 5179
      __cil_tmp36 = opj_malloc((size_t )(5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts));
#line 5179
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)__cil_tmp36;
      }
#line 5182
      if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
#line 5183
        return (0);
      }
#line 5186
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;
    }
  }
#line 5190
  return (1);
}
}
#line 5245 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                       struct opj_event_mgr *p_manager ) 
{ 


  {
  {
#line 5256
  (p_j2k->cstr_index)->main_head_end = opj_stream_tell(p_stream);
  }
#line 5258
  return (1);
}
}
#line 5261 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                             struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_record ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 5275
  __cil_tmp11 = opj_j2k_write_cbd(p_j2k, p_stream, p_manager);
  }
#line 5275
  if (! __cil_tmp11) {
#line 5276
    return (0);
  }
#line 5279
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 5280
  l_mct_record = l_tcp->m_mct_records;
#line 5282
  i = (OPJ_UINT32 )0;
  {
#line 5282
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5282
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 5282
      goto while_break;
    }
    {
#line 5284
    __cil_tmp12 = opj_j2k_write_mct_record(p_j2k, l_mct_record, p_stream, p_manager);
    }
#line 5284
    if (! __cil_tmp12) {
#line 5285
      return (0);
    }
#line 5288
    l_mct_record ++;
#line 5282
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 5291
  l_mcc_record = l_tcp->m_mcc_records;
#line 5293
  i = (OPJ_UINT32 )0;
  {
#line 5293
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 5293
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5293
      goto while_break___0;
    }
    {
#line 5295
    __cil_tmp13 = opj_j2k_write_mcc_record(p_j2k, l_mcc_record, p_stream, p_manager);
    }
#line 5295
    if (! __cil_tmp13) {
#line 5296
      return (0);
    }
#line 5299
    l_mcc_record ++;
#line 5293
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 5302
  __cil_tmp14 = opj_j2k_write_mco(p_j2k, p_stream, p_manager);
  }
#line 5302
  if (! __cil_tmp14) {
#line 5303
    return (0);
  }
#line 5306
  return (1);
}
}
#line 5309 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 5321
  compno = (OPJ_UINT32 )1;
  {
#line 5321
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5321
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 5321
      goto while_break;
    }
    {
#line 5323
    __cil_tmp8 = opj_j2k_compare_coc(p_j2k, (OPJ_UINT32 )0, compno);
    }
#line 5323
    if (! __cil_tmp8) {
      {
#line 5324
      __cil_tmp9 = opj_j2k_write_coc(p_j2k, compno, p_stream, p_manager);
      }
#line 5324
      if (! __cil_tmp9) {
#line 5325
        return (0);
      }
    }
#line 5321
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 5330
  return (1);
}
}
#line 5333 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 5345
  compno = (OPJ_UINT32 )1;
  {
#line 5345
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5345
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 5345
      goto while_break;
    }
    {
#line 5347
    __cil_tmp8 = opj_j2k_compare_qcc(p_j2k, (OPJ_UINT32 )0, compno);
    }
#line 5347
    if (! __cil_tmp8) {
      {
#line 5348
      __cil_tmp9 = opj_j2k_write_qcc(p_j2k, compno, p_stream, p_manager);
      }
#line 5348
      if (! __cil_tmp9) {
#line 5349
        return (0);
      }
    }
#line 5345
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 5353
  return (1);
}
}
#line 5356 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  opj_tccp_t *l_tccp ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 5361
  l_tccp = (opj_tccp_t *)0;
#line 5368
  l_tccp = (p_j2k->m_cp.tcps)->tccps;
#line 5370
  compno = (OPJ_UINT32 )0;
  {
#line 5370
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5370
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 5370
      goto while_break;
    }
#line 5371
    if (l_tccp->roishift) {
      {
#line 5373
      __cil_tmp9 = opj_j2k_write_rgn(p_j2k, (OPJ_UINT32 )0, compno, (p_j2k->m_private_image)->numcomps,
                                     p_stream, p_manager);
      }
#line 5373
      if (! __cil_tmp9) {
#line 5375
        return (0);
      }
    }
#line 5379
    l_tccp ++;
#line 5370
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 5382
  return (1);
}
}
#line 5385 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  OPJ_OFF_T __cil_tmp8 ;

  {
#line 5389
  l_cstr_index = (opj_codestream_index_t *)0;
#line 5398
  l_cstr_index = p_j2k->cstr_index;
#line 5399
  if (l_cstr_index) {
    {
#line 5400
    __cil_tmp8 = opj_stream_tell(p_stream);
#line 5400
    l_cstr_index->codestream_size = (OPJ_UINT64 )__cil_tmp8;
#line 5405
    l_cstr_index->codestream_size -= (OPJ_UINT64 )l_cstr_index->main_head_start;
    }
  }
#line 5422
  return (1);
}
}
#line 5425 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 OPJ_UINT32 *output_marker , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_unknown_marker ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_UINT32 l_size_unk ;
  OPJ_SIZE_T __cil_tmp11 ;
  OPJ_BOOL res ;
  OPJ_OFF_T __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;

  {
  {
#line 5433
  l_size_unk = (OPJ_UINT32 )2;
#line 5440
  opj_event_msg(p_manager, 2, "Unknown marker\n");
  }
  {
#line 5442
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5444
    __cil_tmp11 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 5444
    if (__cil_tmp11 != 2UL) {
      {
#line 5446
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 5447
      return (0);
    }
    {
#line 5451
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_unknown_marker,
                      (OPJ_UINT32 )2);
    }
#line 5454
    if (! (l_unknown_marker < 65280U)) {
      {
#line 5457
      l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);
      }
#line 5459
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 5460
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n");
        }
#line 5462
        return (0);
      } else
#line 5464
      if (l_marker_handler->id != 0U) {
#line 5466
        if (l_marker_handler->id != 65424U) {
          {
#line 5467
          __cil_tmp14 = opj_stream_tell(p_stream);
#line 5467
          __cil_tmp15 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )0, (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp14 - l_size_unk),
                                             l_size_unk);
#line 5467
          res = __cil_tmp15;
          }
#line 5470
          if (res == 0) {
            {
#line 5471
            opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n");
            }
#line 5472
            return (0);
          }
        }
#line 5475
        goto while_break;
      } else {
#line 5477
        l_size_unk += 2U;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 5483
  *output_marker = l_marker_handler->id;
#line 5485
  return (1);
}
}
#line 5488 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_mct_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tmp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;

  {
#line 5494
  l_current_data = (OPJ_BYTE *)0;
#line 5502
  l_mct_size = 10U + p_mct_record->m_data_size;
#line 5504
  if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5505
    __cil_tmp12 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_mct_size);
#line 5505
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp12;
    }
#line 5507
    if (! new_header_tile_data) {
      {
#line 5508
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5509
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5510
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5511
      opj_event_msg(p_manager, 1, "Not enough memory to write MCT marker\n");
      }
#line 5512
      return (0);
    }
#line 5514
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5515
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;
  }
  {
#line 5518
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5520
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65396, (OPJ_UINT32 )2);
#line 5522
  l_current_data += 2;
#line 5524
  opj_write_bytes_LE(l_current_data, l_mct_size - 2U, (OPJ_UINT32 )2);
#line 5526
  l_current_data += 2;
#line 5528
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5530
  l_current_data += 2;
#line 5533
  l_tmp = ((p_mct_record->m_index & 255U) | ((unsigned int )p_mct_record->m_array_type << 8)) | ((unsigned int )p_mct_record->m_element_type << 10);
#line 5536
  opj_write_bytes_LE(l_current_data, l_tmp, (OPJ_UINT32 )2);
#line 5537
  l_current_data += 2;
#line 5539
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5541
  l_current_data += 2;
#line 5543
  memcpy((void *)l_current_data, (void const   *)p_mct_record->m_data, (unsigned long )p_mct_record->m_data_size);
#line 5545
  __cil_tmp13 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mct_size, p_manager);
  }
#line 5545
  if (__cil_tmp13 != (unsigned long )l_mct_size) {
#line 5548
    return (0);
  }
#line 5551
  return (1);
}
}
#line 5562 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_data ;
  opj_tcp_t *tmp___1 ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp14 ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  void *__cil_tmp16 ;

  {
#line 5569
  l_tcp = (opj_tcp_t *)0;
#line 5578
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5578
    tmp___1 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5578
    tmp___1 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5578
  l_tcp = tmp___1;
#line 5582
  if (p_header_size < 2U) {
    {
#line 5583
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5584
    return (0);
  }
  {
#line 5588
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5589
  p_header_data += 2;
  }
#line 5590
  if (l_tmp != 0U) {
    {
#line 5591
    opj_event_msg(p_manager, 2, "Cannot take in charge mct data within multiple MCT records\n");
    }
#line 5593
    return (1);
  }
#line 5596
  if (p_header_size <= 6U) {
    {
#line 5597
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5598
    return (0);
  }
  {
#line 5602
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5603
  p_header_data += 2;
#line 5605
  l_indix = l_tmp & 255U;
#line 5606
  l_mct_data = l_tcp->m_mct_records;
#line 5608
  i = (OPJ_UINT32 )0;
  }
  {
#line 5608
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5608
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 5608
      goto while_break;
    }
#line 5609
    if (l_mct_data->m_index == l_indix) {
#line 5610
      goto while_break;
    }
#line 5612
    l_mct_data ++;
#line 5608
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 5616
  if (i == l_tcp->m_nb_mct_records) {
#line 5617
    if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {
      {
#line 5619
      l_tcp->m_nb_max_mct_records += 10U;
#line 5621
      __cil_tmp14 = opj_realloc((void *)l_tcp->m_mct_records, (unsigned long )l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 5621
      new_mct_records = (opj_mct_data_t *)__cil_tmp14;
      }
#line 5623
      if (! new_mct_records) {
        {
#line 5624
        opj_free((void *)l_tcp->m_mct_records);
#line 5625
        l_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 5626
        l_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 5627
        l_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
#line 5628
        opj_event_msg(p_manager, 1, "Not enough memory to read MCT marker\n");
        }
#line 5629
        return (0);
      }
#line 5634
      if ((unsigned long )new_mct_records != (unsigned long )l_tcp->m_mct_records) {
#line 5635
        i = (OPJ_UINT32 )0;
        {
#line 5635
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 5635
          if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5635
            goto while_break___0;
          }
#line 5636
          l_mcc_record = l_tcp->m_mcc_records + i;
#line 5638
          if (l_mcc_record->m_decorrelation_array) {
#line 5639
            l_mcc_record->m_decorrelation_array = new_mct_records + (l_mcc_record->m_decorrelation_array - l_tcp->m_mct_records);
          }
#line 5644
          if (l_mcc_record->m_offset_array) {
#line 5645
            l_mcc_record->m_offset_array = new_mct_records + (l_mcc_record->m_offset_array - l_tcp->m_mct_records);
          }
#line 5635
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
      }
      {
#line 5653
      l_tcp->m_mct_records = new_mct_records;
#line 5654
      l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
#line 5655
      memset((void *)l_mct_data, 0, (unsigned long )(l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 5659
    l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
#line 5660
    (l_tcp->m_nb_mct_records) ++;
  }
#line 5663
  if (l_mct_data->m_data) {
    {
#line 5664
    opj_free((void *)l_mct_data->m_data);
#line 5665
    l_mct_data->m_data = (OPJ_BYTE *)0;
#line 5666
    l_mct_data->m_data_size = (OPJ_UINT32 )0;
    }
  }
  {
#line 5669
  l_mct_data->m_index = l_indix;
#line 5670
  l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE )((l_tmp >> 8) & 3U);
#line 5671
  l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )((l_tmp >> 10) & 3U);
#line 5673
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5674
  p_header_data += 2;
  }
#line 5675
  if (l_tmp != 0U) {
    {
#line 5676
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple MCT markers\n");
    }
#line 5678
    return (1);
  }
  {
#line 5681
  p_header_size -= 6U;
#line 5683
  __cil_tmp16 = opj_malloc((size_t )p_header_size);
#line 5683
  l_mct_data->m_data = (OPJ_BYTE *)__cil_tmp16;
  }
#line 5684
  if (! l_mct_data->m_data) {
    {
#line 5685
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5686
    return (0);
  }
  {
#line 5688
  memcpy((void *)l_mct_data->m_data, (void const   *)p_header_data, (unsigned long )p_header_size);
#line 5690
  l_mct_data->m_data_size = p_header_size;
  }
#line 5692
  return (1);
}
}
#line 5695 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_mcc_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes_for_comp ;
  OPJ_UINT32 l_mask ;
  OPJ_UINT32 l_tmcc ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
#line 5702
  l_current_data = (OPJ_BYTE *)0;
#line 5712
  if (p_mcc_record->m_nb_comps > 255U) {
#line 5713
    l_nb_bytes_for_comp = (OPJ_UINT32 )2;
#line 5714
    l_mask = (OPJ_UINT32 )32768;
  } else {
#line 5716
    l_nb_bytes_for_comp = (OPJ_UINT32 )1;
#line 5717
    l_mask = (OPJ_UINT32 )0;
  }
#line 5720
  l_mcc_size = (p_mcc_record->m_nb_comps * 2U) * l_nb_bytes_for_comp + 19U;
#line 5721
  if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5722
    __cil_tmp15 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_mcc_size);
#line 5722
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp15;
    }
#line 5724
    if (! new_header_tile_data) {
      {
#line 5725
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5726
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5727
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5728
      opj_event_msg(p_manager, 1, "Not enough memory to write MCC marker\n");
      }
#line 5729
      return (0);
    }
#line 5731
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5732
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;
  }
  {
#line 5735
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5737
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65397, (OPJ_UINT32 )2);
#line 5739
  l_current_data += 2;
#line 5741
  opj_write_bytes_LE(l_current_data, l_mcc_size - 2U, (OPJ_UINT32 )2);
#line 5743
  l_current_data += 2;
#line 5746
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5748
  l_current_data += 2;
#line 5750
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_index, (OPJ_UINT32 )1);
#line 5752
  l_current_data ++;
#line 5755
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5757
  l_current_data += 2;
#line 5759
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 5761
  l_current_data += 2;
#line 5763
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 5765
  l_current_data ++;
#line 5767
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 5769
  l_current_data += 2;
#line 5771
  i = (OPJ_UINT32 )0;
  }
  {
#line 5771
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5771
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 5771
      goto while_break;
    }
    {
#line 5772
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 5774
    l_current_data += l_nb_bytes_for_comp;
#line 5771
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 5777
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 5779
  l_current_data += 2;
#line 5781
  i = (OPJ_UINT32 )0;
  }
  {
#line 5781
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 5781
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 5781
      goto while_break___0;
    }
    {
#line 5782
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 5784
    l_current_data += l_nb_bytes_for_comp;
#line 5781
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 5787
  l_tmcc = ((unsigned int )(! p_mcc_record->m_is_irreversible) & 1U) << 16;
#line 5789
  if (p_mcc_record->m_decorrelation_array) {
#line 5790
    l_tmcc |= (p_mcc_record->m_decorrelation_array)->m_index;
  }
#line 5793
  if (p_mcc_record->m_offset_array) {
#line 5794
    l_tmcc |= (p_mcc_record->m_offset_array)->m_index << 8;
  }
  {
#line 5797
  opj_write_bytes_LE(l_current_data, l_tmcc, (OPJ_UINT32 )3);
#line 5799
  l_current_data += 3;
#line 5801
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mcc_size, p_manager);
  }
#line 5801
  if (__cil_tmp16 != (unsigned long )l_mcc_size) {
#line 5804
    return (0);
  }
#line 5807
  return (1);
}
}
#line 5810 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 l_nb_collections ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_nb_bytes_by_comp ;
  OPJ_BOOL l_new_mcc ;
  opj_tcp_t *tmp___2 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp21 ;

  {
#line 5824
  l_new_mcc = 0;
#line 5831
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5831
    tmp___2 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5831
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5831
  l_tcp = tmp___2;
#line 5835
  if (p_header_size < 2U) {
    {
#line 5836
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 5837
    return (0);
  }
  {
#line 5841
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5842
  p_header_data += 2;
  }
#line 5843
  if (l_tmp != 0U) {
    {
#line 5844
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\n");
    }
#line 5846
    return (1);
  }
#line 5849
  if (p_header_size < 7U) {
    {
#line 5850
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 5851
    return (0);
  }
  {
#line 5854
  opj_read_bytes_LE(p_header_data, & l_indix, (OPJ_UINT32 )1);
#line 5856
  p_header_data ++;
#line 5858
  l_mcc_record = l_tcp->m_mcc_records;
#line 5860
  i = (OPJ_UINT32 )0;
  }
  {
#line 5860
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5860
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5860
      goto while_break;
    }
#line 5861
    if (l_mcc_record->m_index == l_indix) {
#line 5862
      goto while_break;
    }
#line 5864
    l_mcc_record ++;
#line 5860
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 5868
  if (i == l_tcp->m_nb_mcc_records) {
#line 5869
    if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {
      {
#line 5871
      l_tcp->m_nb_max_mcc_records += 10U;
#line 5873
      __cil_tmp21 = opj_realloc((void *)l_tcp->m_mcc_records, (unsigned long )l_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 5873
      new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp21;
      }
#line 5876
      if (! new_mcc_records) {
        {
#line 5877
        opj_free((void *)l_tcp->m_mcc_records);
#line 5878
        l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 5879
        l_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 5880
        l_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
#line 5881
        opj_event_msg(p_manager, 1, "Not enough memory to read MCC marker\n");
        }
#line 5882
        return (0);
      }
      {
#line 5884
      l_tcp->m_mcc_records = new_mcc_records;
#line 5885
      l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
#line 5886
      memset((void *)l_mcc_record, 0, (unsigned long )(l_tcp->m_nb_max_mcc_records - l_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
      }
    }
#line 5889
    l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
#line 5890
    l_new_mcc = 1;
  }
  {
#line 5892
  l_mcc_record->m_index = l_indix;
#line 5895
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5896
  p_header_data += 2;
  }
#line 5897
  if (l_tmp != 0U) {
    {
#line 5898
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\n");
    }
#line 5900
    return (1);
  }
  {
#line 5903
  opj_read_bytes_LE(p_header_data, & l_nb_collections, (OPJ_UINT32 )2);
#line 5905
  p_header_data += 2;
  }
#line 5907
  if (l_nb_collections > 1U) {
    {
#line 5908
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple collections\n");
    }
#line 5910
    return (1);
  }
#line 5913
  p_header_size -= 7U;
#line 5915
  i = (OPJ_UINT32 )0;
  {
#line 5915
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 5915
    if (! (i < l_nb_collections)) {
#line 5915
      goto while_break___0;
    }
#line 5916
    if (p_header_size < 3U) {
      {
#line 5917
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 5918
      return (0);
    }
    {
#line 5921
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 5923
    p_header_data ++;
    }
#line 5925
    if (l_tmp != 1U) {
      {
#line 5926
      opj_event_msg(p_manager, 2, "Cannot take in charge collections other than array decorrelation\n");
      }
#line 5928
      return (1);
    }
    {
#line 5931
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 5933
    p_header_data += 2;
#line 5934
    p_header_size -= 3U;
#line 5936
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 5937
    l_mcc_record->m_nb_comps = l_nb_comps & 32767U;
    }
#line 5939
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U) {
      {
#line 5940
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 5941
      return (0);
    }
#line 5944
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U;
#line 5946
    j = (OPJ_UINT32 )0;
    {
#line 5946
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 5946
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 5946
        goto while_break___1;
      }
      {
#line 5947
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 5949
      p_header_data += l_nb_bytes_by_comp;
      }
#line 5951
      if (l_tmp != j) {
        {
#line 5952
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 5954
        return (1);
      }
#line 5946
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 5958
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 5959
    p_header_data += 2;
#line 5961
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 5962
    l_nb_comps &= 32767U;
    }
#line 5964
    if (l_nb_comps != l_mcc_record->m_nb_comps) {
      {
#line 5965
      opj_event_msg(p_manager, 2, "Cannot take in charge collections without same number of indixes\n");
      }
#line 5967
      return (1);
    }
#line 5970
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U) {
      {
#line 5971
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 5972
      return (0);
    }
#line 5975
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U;
#line 5977
    j = (OPJ_UINT32 )0;
    {
#line 5977
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 5977
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 5977
        goto while_break___2;
      }
      {
#line 5978
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 5980
      p_header_data += l_nb_bytes_by_comp;
      }
#line 5982
      if (l_tmp != j) {
        {
#line 5983
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 5985
        return (1);
      }
#line 5977
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 5989
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )3);
#line 5990
    p_header_data += 3;
#line 5992
    l_mcc_record->m_is_irreversible = (OPJ_BITFIELD )(! ((l_tmp >> 16) & 1U));
#line 5993
    l_mcc_record->m_decorrelation_array = (opj_mct_data_t *)0;
#line 5994
    l_mcc_record->m_offset_array = (opj_mct_data_t *)0;
#line 5996
    l_indix = l_tmp & 255U;
    }
#line 5997
    if (l_indix != 0U) {
#line 5998
      l_mct_data = l_tcp->m_mct_records;
#line 5999
      j = (OPJ_UINT32 )0;
      {
#line 5999
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 5999
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 5999
          goto while_break___3;
        }
#line 6000
        if (l_mct_data->m_index == l_indix) {
#line 6001
          l_mcc_record->m_decorrelation_array = l_mct_data;
#line 6002
          goto while_break___3;
        }
#line 6004
        l_mct_data ++;
#line 5999
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: ;
#line 6007
      if ((unsigned long )l_mcc_record->m_decorrelation_array == (unsigned long )((opj_mct_data_t *)0)) {
        {
#line 6008
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 6009
        return (0);
      }
    }
#line 6013
    l_indix = (l_tmp >> 8) & 255U;
#line 6014
    if (l_indix != 0U) {
#line 6015
      l_mct_data = l_tcp->m_mct_records;
#line 6016
      j = (OPJ_UINT32 )0;
      {
#line 6016
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 6016
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 6016
          goto while_break___4;
        }
#line 6017
        if (l_mct_data->m_index == l_indix) {
#line 6018
          l_mcc_record->m_offset_array = l_mct_data;
#line 6019
          goto while_break___4;
        }
#line 6021
        l_mct_data ++;
#line 6016
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: ;
#line 6024
      if ((unsigned long )l_mcc_record->m_offset_array == (unsigned long )((opj_mct_data_t *)0)) {
        {
#line 6025
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 6026
        return (0);
      }
    }
#line 5915
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: ;
#line 6031
  if (p_header_size != 0U) {
    {
#line 6032
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 6033
    return (0);
  }
#line 6036
  if (l_new_mcc) {
#line 6037
    (l_tcp->m_nb_mcc_records) ++;
  }
#line 6040
  return (1);
}
}
#line 6043 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_mco_size ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  OPJ_UINT32 i ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
#line 6048
  l_current_data = (OPJ_BYTE *)0;
#line 6050
  l_tcp = (opj_tcp_t *)0;
#line 6059
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 6061
  l_mco_size = 5U + l_tcp->m_nb_mcc_records;
#line 6062
  if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 6064
    __cil_tmp13 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_mco_size);
#line 6064
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 6066
    if (! new_header_tile_data) {
      {
#line 6067
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 6068
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 6069
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 6070
      opj_event_msg(p_manager, 1, "Not enough memory to write MCO marker\n");
      }
#line 6071
      return (0);
    }
#line 6073
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 6074
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;
  }
  {
#line 6076
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 6079
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65399, (OPJ_UINT32 )2);
#line 6080
  l_current_data += 2;
#line 6082
  opj_write_bytes_LE(l_current_data, l_mco_size - 2U, (OPJ_UINT32 )2);
#line 6083
  l_current_data += 2;
#line 6085
  opj_write_bytes_LE(l_current_data, l_tcp->m_nb_mcc_records, (OPJ_UINT32 )1);
#line 6087
  l_current_data ++;
#line 6089
  l_mcc_record = l_tcp->m_mcc_records;
#line 6090
  i = (OPJ_UINT32 )0;
  }
  {
#line 6090
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6090
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 6090
      goto while_break;
    }
    {
#line 6091
    opj_write_bytes_LE(l_current_data, l_mcc_record->m_index, (OPJ_UINT32 )1);
#line 6093
    l_current_data ++;
#line 6094
    l_mcc_record ++;
#line 6090
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 6097
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mco_size, p_manager);
  }
#line 6097
  if (__cil_tmp14 != (unsigned long )l_mco_size) {
#line 6100
    return (0);
  }
#line 6103
  return (1);
}
}
#line 6114 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_stages ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_t *l_image ;
  opj_tcp_t *tmp___2 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 6131
  l_image = p_j2k->m_private_image;
#line 6132
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 6132
    tmp___2 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 6132
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 6132
  l_tcp = tmp___2;
#line 6136
  if (p_header_size < 1U) {
    {
#line 6137
    opj_event_msg(p_manager, 1, "Error reading MCO marker\n");
    }
#line 6138
    return (0);
  }
  {
#line 6141
  opj_read_bytes_LE(p_header_data, & l_nb_stages, (OPJ_UINT32 )1);
#line 6143
  p_header_data ++;
  }
#line 6145
  if (l_nb_stages > 1U) {
    {
#line 6146
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple transformation stages.\n");
    }
#line 6148
    return (1);
  }
#line 6151
  if (p_header_size != l_nb_stages + 1U) {
    {
#line 6152
    opj_event_msg(p_manager, 2, "Error reading MCO marker\n>\0272 V");
    }
#line 6153
    return (0);
  }
#line 6156
  l_tccp = l_tcp->tccps;
#line 6158
  i = (OPJ_UINT32 )0;
  {
#line 6158
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6158
    if (! (i < l_image->numcomps)) {
#line 6158
      goto while_break;
    }
#line 6159
    l_tccp->m_dc_level_shift = 0;
#line 6160
    l_tccp ++;
#line 6158
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 6163
  if (l_tcp->m_mct_decoding_matrix) {
    {
#line 6164
    opj_free((void *)l_tcp->m_mct_decoding_matrix);
#line 6165
    l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 6168
  i = (OPJ_UINT32 )0;
  {
#line 6168
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 6168
    if (! (i < l_nb_stages)) {
#line 6168
      goto while_break___0;
    }
    {
#line 6169
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 6170
    p_header_data ++;
#line 6172
    __cil_tmp15 = opj_j2k_add_mct(l_tcp, p_j2k->m_private_image, l_tmp);
    }
#line 6172
    if (! __cil_tmp15) {
#line 6173
      return (0);
    }
#line 6168
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 6177
  return (1);
}
}
#line 6180 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_deco_array ;
  opj_mct_data_t *l_offset_array ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_offset_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_UINT32 *l_offset_data ;
  OPJ_UINT32 *l_current_offset_data ;
  opj_tccp_t *l_tccp ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  OPJ_UINT32 *__cil_tmp18 ;

  {
#line 6194
  l_mcc_record = p_tcp->m_mcc_records;
#line 6196
  i = (OPJ_UINT32 )0;
  {
#line 6196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6196
    if (! (i < p_tcp->m_nb_mcc_records)) {
#line 6196
      goto while_break;
    }
#line 6197
    if (l_mcc_record->m_index == p_index) {
#line 6198
      goto while_break;
    }
#line 6196
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 6202
  if (i == p_tcp->m_nb_mcc_records) {
#line 6204
    return (1);
  }
#line 6207
  if (l_mcc_record->m_nb_comps != p_image->numcomps) {
#line 6209
    return (1);
  }
#line 6212
  l_deco_array = l_mcc_record->m_decorrelation_array;
#line 6214
  if (l_deco_array) {
#line 6215
    l_data_size = (MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps) * p_image->numcomps;
#line 6217
    if (l_deco_array->m_data_size != l_data_size) {
#line 6218
      return (0);
    }
    {
#line 6221
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 6222
    l_mct_size = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 6223
    __cil_tmp16 = opj_malloc((size_t )l_mct_size);
#line 6223
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp16;
    }
#line 6225
    if (! p_tcp->m_mct_decoding_matrix) {
#line 6226
      return (0);
    }
    {
#line 6229
    (*(j2k_mct_read_functions_to_float[l_deco_array->m_element_type]))((void const   *)l_deco_array->m_data,
                                                                       (void *)p_tcp->m_mct_decoding_matrix,
                                                                       l_nb_elem);
    }
  }
#line 6233
  l_offset_array = l_mcc_record->m_offset_array;
#line 6235
  if (l_offset_array) {
#line 6236
    l_data_size = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] * p_image->numcomps;
#line 6238
    if (l_offset_array->m_data_size != l_data_size) {
#line 6239
      return (0);
    }
    {
#line 6242
    l_nb_elem = p_image->numcomps;
#line 6243
    l_offset_size = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 6244
    __cil_tmp17 = opj_malloc((size_t )l_offset_size);
#line 6244
    l_offset_data = (OPJ_UINT32 *)__cil_tmp17;
    }
#line 6246
    if (! l_offset_data) {
#line 6247
      return (0);
    }
    {
#line 6250
    (*(j2k_mct_read_functions_to_int32[l_offset_array->m_element_type]))((void const   *)l_offset_array->m_data,
                                                                         (void *)l_offset_data,
                                                                         l_nb_elem);
#line 6253
    l_tccp = p_tcp->tccps;
#line 6254
    l_current_offset_data = l_offset_data;
#line 6256
    i = (OPJ_UINT32 )0;
    }
    {
#line 6256
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 6256
      if (! (i < p_image->numcomps)) {
#line 6256
        goto while_break___0;
      }
#line 6257
      __cil_tmp18 = l_current_offset_data;
#line 6257
      l_current_offset_data ++;
#line 6257
      l_tccp->m_dc_level_shift = (OPJ_INT32 )*__cil_tmp18;
#line 6258
      l_tccp ++;
#line 6256
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 6261
    opj_free((void *)l_offset_data);
    }
  }
#line 6264
  return (1);
}
}
#line 6267 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_cbd_size ;
  OPJ_BYTE *l_current_data ;
  opj_image_t *l_image ;
  opj_image_comp_t *l_comp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
#line 6273
  l_current_data = (OPJ_BYTE *)0;
#line 6274
  l_image = (opj_image_t *)0;
#line 6275
  l_comp = (opj_image_comp_t *)0;
#line 6282
  l_image = p_j2k->m_private_image;
#line 6283
  l_cbd_size = 6U + (p_j2k->m_private_image)->numcomps;
#line 6285
  if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 6286
    __cil_tmp13 = opj_realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_cbd_size);
#line 6286
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 6288
    if (! new_header_tile_data) {
      {
#line 6289
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 6290
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 6291
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 6292
      opj_event_msg(p_manager, 1, "Not enough memory to write CBD marker\n");
      }
#line 6293
      return (0);
    }
#line 6295
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 6296
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;
  }
  {
#line 6299
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 6301
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65400, (OPJ_UINT32 )2);
#line 6302
  l_current_data += 2;
#line 6304
  opj_write_bytes_LE(l_current_data, l_cbd_size - 2U, (OPJ_UINT32 )2);
#line 6305
  l_current_data += 2;
#line 6307
  opj_write_bytes_LE(l_current_data, l_image->numcomps, (OPJ_UINT32 )2);
#line 6308
  l_current_data += 2;
#line 6310
  l_comp = l_image->comps;
#line 6312
  i = (OPJ_UINT32 )0;
  }
  {
#line 6312
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6312
    if (! (i < l_image->numcomps)) {
#line 6312
      goto while_break;
    }
    {
#line 6313
    opj_write_bytes_LE(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1U),
                       (OPJ_UINT32 )1);
#line 6315
    l_current_data ++;
#line 6317
    l_comp ++;
#line 6312
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 6320
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_cbd_size, p_manager);
  }
#line 6320
  if (__cil_tmp14 != (unsigned long )l_cbd_size) {
#line 6323
    return (0);
  }
#line 6326
  return (1);
}
}
#line 6336 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_def ;
  OPJ_UINT32 i ;
  opj_image_comp_t *l_comp ;

  {
#line 6345
  l_comp = (opj_image_comp_t *)0;
#line 6352
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 6354
  if (p_header_size != (p_j2k->m_private_image)->numcomps + 2U) {
    {
#line 6355
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\n\375\001");
    }
#line 6356
    return (0);
  }
  {
#line 6359
  opj_read_bytes_LE(p_header_data, & l_nb_comp, (OPJ_UINT32 )2);
#line 6361
  p_header_data += 2;
  }
#line 6363
  if (l_nb_comp != l_num_comp) {
    {
#line 6364
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\n");
    }
#line 6365
    return (0);
  }
#line 6368
  l_comp = (p_j2k->m_private_image)->comps;
#line 6369
  i = (OPJ_UINT32 )0;
  {
#line 6369
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6369
    if (! (i < l_num_comp)) {
#line 6369
      goto while_break;
    }
    {
#line 6370
    opj_read_bytes_LE(p_header_data, & l_comp_def, (OPJ_UINT32 )1);
#line 6372
    p_header_data ++;
#line 6373
    l_comp->sgnd = (l_comp_def >> 7) & 1U;
#line 6374
    l_comp->prec = (l_comp_def & 127U) + 1U;
    }
#line 6376
    if (l_comp->prec > 31U) {
      {
#line 6377
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\n",
                    i, l_comp->prec);
      }
#line 6380
      return (0);
    }
#line 6382
    l_comp ++;
#line 6369
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 6385
  return (1);
}
}
#line 6392 "/root/patron/new_24/src/lib/openjp2/j2k.c"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 


  {
#line 6394
  if (j2k) {
#line 6394
    if (parameters) {
#line 6395
      j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;
#line 6396
      j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;
#line 6398
      j2k->dump_state = parameters->flags & 2U;
    }
  }
#line 6401
  return;
}
}
#line 6407 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k , OPJ_UINT32 num_threads ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 6409
  __cil_tmp3 = opj_has_thread_support();
  }
#line 6409
  if (__cil_tmp3) {
    {
#line 6410
    opj_thread_pool_destroy(j2k->m_tp);
#line 6411
    j2k->m_tp = (opj_thread_pool_t *)((void *)0);
    }
#line 6412
    if (num_threads <= 2147483647U) {
      {
#line 6413
      j2k->m_tp = opj_thread_pool_create((int )num_threads);
      }
    }
#line 6415
    if ((unsigned long )j2k->m_tp == (unsigned long )((void *)0)) {
      {
#line 6416
      j2k->m_tp = opj_thread_pool_create(0);
      }
#line 6417
      return (0);
    }
#line 6419
    return (1);
  }
#line 6421
  return (0);
}
}
#line 6424 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static int opj_j2k_get_default_thread_count(void) 
{ 
  char const   *num_threads ;
  char *__cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 6426
  __cil_tmp2 = getenv("OPJ_NUM_THREADS");
#line 6426
  num_threads = (char const   *)__cil_tmp2;
#line 6427
  __cil_tmp3 = opj_has_thread_support();
  }
#line 6427
  if ((unsigned long )num_threads == (unsigned long )((void *)0)) {
#line 6428
    return (0);
  } else
#line 6427
  if (! __cil_tmp3) {
#line 6428
    return (0);
  }
  {
#line 6430
  __cil_tmp4 = strcmp(num_threads, "ALL_CPUS\220");
  }
#line 6430
  if (__cil_tmp4 == 0) {
    {
#line 6431
    __cil_tmp5 = opj_get_num_cpus();
    }
#line 6431
    return (__cil_tmp5);
  }
  {
#line 6433
  __cil_tmp6 = atoi(num_threads);
  }
#line 6433
  return (__cil_tmp6);
}
}
#line 6440 "/root/patron/new_24/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_compress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  int __cil_tmp6 ;
  opj_thread_pool_t *__cil_tmp7 ;

  {
  {
#line 6442
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_j2k_t ));
#line 6442
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 6443
  if (! l_j2k) {
#line 6444
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6448
  l_j2k->m_is_decoder = 0;
#line 6449
  l_j2k->m_cp.m_is_decoder = (OPJ_BITFIELD )0;
#line 6451
  __cil_tmp3 = opj_malloc((size_t )1000);
#line 6451
  l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)__cil_tmp3;
  }
#line 6453
  if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 6454
    opj_j2k_destroy(l_j2k);
    }
#line 6455
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6458
  l_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )1000;
#line 6462
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 6463
  if (! l_j2k->m_validation_list) {
    {
#line 6464
    opj_j2k_destroy(l_j2k);
    }
#line 6465
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6469
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 6470
  if (! l_j2k->m_procedure_list) {
    {
#line 6471
    opj_j2k_destroy(l_j2k);
    }
#line 6472
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6475
  __cil_tmp6 = opj_j2k_get_default_thread_count();
#line 6475
  __cil_tmp7 = opj_thread_pool_create(__cil_tmp6);
#line 6475
  l_j2k->m_tp = __cil_tmp7;
  }
#line 6476
  if (! l_j2k->m_tp) {
    {
#line 6477
    l_j2k->m_tp = opj_thread_pool_create(0);
    }
  }
#line 6479
  if (! l_j2k->m_tp) {
    {
#line 6480
    opj_j2k_destroy(l_j2k);
    }
#line 6481
    return ((opj_j2k_t *)((void *)0));
  }
#line 6484
  return (l_j2k);
}
}
#line 6487 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) 
{ 


  {
#line 6489
  (POC + 0)->tile = (OPJ_UINT32 )1;
#line 6490
  (POC + 0)->resno0 = (OPJ_UINT32 )0;
#line 6491
  (POC + 0)->compno0 = (OPJ_UINT32 )0;
#line 6492
  (POC + 0)->layno1 = (OPJ_UINT32 )1;
#line 6493
  (POC + 0)->resno1 = (OPJ_UINT32 )(numres - 1);
#line 6494
  (POC + 0)->compno1 = (OPJ_UINT32 )3;
#line 6495
  (POC + 0)->prg1 = (OPJ_PROG_ORDER )4;
#line 6496
  (POC + 1)->tile = (OPJ_UINT32 )1;
#line 6497
  (POC + 1)->resno0 = (OPJ_UINT32 )(numres - 1);
#line 6498
  (POC + 1)->compno0 = (OPJ_UINT32 )0;
#line 6499
  (POC + 1)->layno1 = (OPJ_UINT32 )1;
#line 6500
  (POC + 1)->resno1 = (OPJ_UINT32 )numres;
#line 6501
  (POC + 1)->compno1 = (OPJ_UINT32 )3;
#line 6502
  (POC + 1)->prg1 = (OPJ_PROG_ORDER )4;
#line 6503
  return (2);
}
}
#line 6506 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                          opj_event_mgr_t *p_manager ) 
{ 
  int i ;
  int __cil_tmp6 ;

  {
#line 6513
  parameters->tile_size_on = 0;
#line 6514
  parameters->cp_tdx = 1;
#line 6515
  parameters->cp_tdy = 1;
#line 6518
  parameters->tp_flag = (char )'C';
#line 6519
  parameters->tp_on = (char)1;
#line 6522
  parameters->cp_tx0 = 0;
#line 6523
  parameters->cp_ty0 = 0;
#line 6524
  parameters->image_offset_x0 = 0;
#line 6525
  parameters->image_offset_y0 = 0;
#line 6528
  parameters->cblockw_init = 32;
#line 6529
  parameters->cblockh_init = 32;
#line 6532
  parameters->mode = 0;
#line 6535
  parameters->roi_compno = -1;
#line 6538
  parameters->subsampling_dx = 1;
#line 6539
  parameters->subsampling_dy = 1;
#line 6542
  parameters->irreversible = 1;
#line 6545
  if (parameters->tcp_numlayers > 1) {
    {
#line 6546
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n1 single quality layer-> Number of layers forced to 1 (rather than %d)\n-> Rate of the last layer (%3.1f) will be used\230\001",
                  parameters->tcp_numlayers, (double )parameters->tcp_rates[parameters->tcp_numlayers - 1]);
#line 6553
    parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];
#line 6554
    parameters->tcp_numlayers = 1;
    }
  }
#line 6559
  if ((int )parameters->rsiz == 3) {
#line 6559
    goto case_3;
  }
#line 6569
  if ((int )parameters->rsiz == 4) {
#line 6569
    goto case_4;
  }
#line 6586
  goto switch_default;
  case_3: 
#line 6560
  if (parameters->numresolution > 6) {
    {
#line 6561
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nNumber of decomposition levels <= 5\n-> Number of decomposition levels forced to 5 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6566
    parameters->numresolution = 6;
    }
  }
#line 6568
  goto switch_break;
  case_4: 
#line 6570
  if (parameters->numresolution < 2) {
    {
#line 6571
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 1 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6576
    parameters->numresolution = 1;
    }
  } else
#line 6577
  if (parameters->numresolution > 7) {
    {
#line 6578
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 6 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6583
    parameters->numresolution = 7;
    }
  }
#line 6585
  goto switch_break;
  switch_default: 
#line 6587
  goto switch_break;
  switch_break: 
#line 6591
  parameters->csty |= 1;
#line 6592
  if (parameters->numresolution == 1) {
#line 6593
    parameters->res_spec = 1;
#line 6594
    parameters->prcw_init[0] = 128;
#line 6595
    parameters->prch_init[0] = 128;
  } else {
#line 6597
    parameters->res_spec = parameters->numresolution - 1;
#line 6598
    i = 0;
    {
#line 6598
    while (1) {
      while_continue: /* CIL Label */ ;

#line 6598
      if (! (i < parameters->res_spec)) {
#line 6598
        goto while_break;
      }
#line 6599
      parameters->prcw_init[i] = 256;
#line 6600
      parameters->prch_init[i] = 256;
#line 6598
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 6605
  parameters->prog_order = (OPJ_PROG_ORDER )4;
#line 6608
  if ((int )parameters->rsiz == 4) {
    {
#line 6609
    __cil_tmp6 = opj_j2k_initialise_4K_poc(parameters->POC, parameters->numresolution);
#line 6609
    parameters->numpocs = (OPJ_UINT32 )__cil_tmp6;
    }
  } else {
#line 6612
    parameters->numpocs = (OPJ_UINT32 )0;
  }
#line 6616
  parameters->cp_disto_alloc = 1;
#line 6617
  if (parameters->max_cs_size <= 0) {
    {
#line 6619
    parameters->max_cs_size = 1302083;
#line 6620
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6624
  if (parameters->max_cs_size > 1302083) {
    {
#line 6625
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n");
#line 6629
    parameters->max_cs_size = 1302083;
    }
  }
#line 6632
  if (parameters->max_comp_size <= 0) {
    {
#line 6634
    parameters->max_comp_size = 1041666;
#line 6635
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6639
  if (parameters->max_comp_size > 1041666) {
    {
#line 6640
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n");
#line 6644
    parameters->max_comp_size = 1041666;
    }
  }
#line 6647
  parameters->tcp_rates[0] = (OPJ_FLOAT32 )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (OPJ_FLOAT32 )((((OPJ_UINT32 )parameters->max_cs_size * 8U) * (image->comps + 0)->dx) * (image->comps + 0)->dy);
#line 6648
  return;
}
}
#line 6654 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_UINT16 rsiz ,
                                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  char signed_str[7] ;
  char unsigned_str[9] ;
  char *tmp_str ;
  char *tmp ;

  {
#line 6660
  if (image->numcomps != 3U) {
    {
#line 6661
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\n3 components-> Number of components of input image (%d) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  image->numcomps);
    }
#line 6667
    return (0);
  }
#line 6671
  i = (OPJ_UINT32 )0;
  {
#line 6671
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6671
    if (! (i < image->numcomps)) {
#line 6671
      goto while_break;
    }
#line 6672
    if ((unsigned int )((image->comps + i)->bpp != 12U) | (image->comps + i)->sgnd) {
      {
#line 6673
      strcpy(signed_str, "signed");
#line 6674
      strcpy(unsigned_str, "unsigned\f");
      }
#line 6675
      if ((image->comps + i)->sgnd) {
#line 6675
        tmp = signed_str;
      } else {
#line 6675
        tmp = unsigned_str;
      }
      {
#line 6675
      tmp_str = tmp;
#line 6676
      opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nPrecision of each component shall be 12 bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                    i, (image->comps + i)->bpp, tmp_str);
      }
#line 6682
      return (0);
    }
#line 6671
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 6688
  if ((int )rsiz == 3) {
#line 6688
    goto case_3;
  }
#line 6699
  if ((int )rsiz == 4) {
#line 6699
    goto case_4;
  }
#line 6710
  goto switch_default;
  case_3: 
#line 6689
  if (((image->comps + 0)->w > 2048U) | ((image->comps + 0)->h > 1080U)) {
    {
#line 6690
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nwidth <= 2048 and height <= 1080\n-> Input image size %d x %d is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 6696
    return (0);
  }
#line 6698
  goto switch_break;
  case_4: 
#line 6700
  if (((image->comps + 0)->w > 4096U) | ((image->comps + 0)->h > 2160U)) {
    {
#line 6701
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nwidth <= 4096 and height <= 2160\n-> Image size %d x %d is not compliant\n-> Non-profile-4 codestream will be generated\n\230\001",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 6707
    return (0);
  }
#line 6709
  goto switch_break;
  switch_default: 
#line 6711
  goto switch_break;
  switch_break: ;
#line 6714
  return (1);
}
}
#line 6717 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters ,
                               opj_image_t *image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 numpocs_tile ;
  opj_cp_t *cp ;
  OPJ_UINT32 cblkw ;
  OPJ_UINT32 cblkh ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_BOOL deprecated_used ;
  OPJ_FLOAT32 rate_i_corr ;
  OPJ_FLOAT32 rate_i_m_1_corr ;
  OPJ_FLOAT32 temp_size ;
  double __cil_tmp20 ;
  OPJ_FLOAT32 temp_rate ;
  OPJ_BOOL cap ;
  OPJ_BOOL __cil_tmp24 ;
  size_t array_size ;
  void *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  void *__cil_tmp28 ;
  char comment[29] ;
  size_t clen ;
  unsigned long __cil_tmp31 ;
  char const   *version ;
  char const   *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  void *__cil_tmp35 ;
  OPJ_INT32 __cil_tmp36 ;
  OPJ_INT32 __cil_tmp37 ;
  void *__cil_tmp38 ;
  opj_tcp_t *tcp ;
  opj_poc_t *tcp_poc ;
  void *__cil_tmp44 ;
  OPJ_UINT32 lMctSize ;
  OPJ_FLOAT32 *lTmpBuf ;
  void *__cil_tmp47 ;
  OPJ_INT32 *l_dc_shift ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  OPJ_BOOL __cil_tmp51 ;
  void *__cil_tmp52 ;
  opj_tccp_t *tccp ;
  OPJ_BOOL __cil_tmp55 ;
  opj_tccp_t *tccp___0 ;
  opj_image_comp_t *l_comp ;
  opj_tccp_t *tccp___1 ;
  OPJ_INT32 __cil_tmp60 ;
  OPJ_INT32 __cil_tmp61 ;
  int tmp ;
  int tmp___0 ;
  OPJ_INT32 p ;
  OPJ_INT32 it_res ;
  OPJ_INT32 __cil_tmp67 ;
  OPJ_INT32 __cil_tmp68 ;
  OPJ_INT32 res_spec ;
  OPJ_INT32 size_prcw ;
  OPJ_INT32 size_prch ;
  OPJ_INT32 __cil_tmp73 ;
  OPJ_INT32 __cil_tmp74 ;
  OPJ_INT32 __cil_tmp76 ;

  {
#line 6723
  cp = (opj_cp_t *)0;
#line 6726
  if (! p_j2k) {
#line 6727
    return (0);
  } else
#line 6726
  if (! parameters) {
#line 6727
    return (0);
  } else
#line 6726
  if (! image) {
#line 6727
    return (0);
  }
#line 6730
  if (parameters->numresolution <= 0) {
    {
#line 6732
    opj_event_msg(p_manager, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters->numresolution, 33);
    }
#line 6735
    return (0);
  } else
#line 6730
  if (parameters->numresolution > 33) {
    {
#line 6732
    opj_event_msg(p_manager, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters->numresolution, 33);
    }
#line 6735
    return (0);
  }
#line 6738
  if (parameters->cblockw_init < 4) {
    {
#line 6739
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockw_init);
    }
#line 6742
    return (0);
  } else
#line 6738
  if (parameters->cblockw_init > 1024) {
    {
#line 6739
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockw_init);
    }
#line 6742
    return (0);
  }
#line 6744
  if (parameters->cblockh_init < 4) {
    {
#line 6745
    opj_event_msg(p_manager, 1, "Invalid value for cblockh_init: %d not a power of 2 not in range [4,1024]\n",
                  parameters->cblockh_init);
    }
#line 6748
    return (0);
  } else
#line 6744
  if (parameters->cblockh_init > 1024) {
    {
#line 6745
    opj_event_msg(p_manager, 1, "Invalid value for cblockh_init: %d not a power of 2 not in range [4,1024]\n",
                  parameters->cblockh_init);
    }
#line 6748
    return (0);
  }
#line 6750
  if (parameters->cblockw_init * parameters->cblockh_init > 4096) {
    {
#line 6751
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init * cblockh_init: should be <= 4096\n");
    }
#line 6753
    return (0);
  }
  {
#line 6755
  __cil_tmp12 = opj_int_floorlog2(parameters->cblockw_init);
#line 6755
  cblkw = (OPJ_UINT32 )__cil_tmp12;
#line 6756
  __cil_tmp13 = opj_int_floorlog2(parameters->cblockh_init);
#line 6756
  cblkh = (OPJ_UINT32 )__cil_tmp13;
  }
#line 6757
  if (parameters->cblockw_init != 1 << cblkw) {
    {
#line 6758
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockw_init);
    }
#line 6761
    return (0);
  }
#line 6763
  if (parameters->cblockh_init != 1 << cblkh) {
    {
#line 6764
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockh_init);
    }
#line 6767
    return (0);
  }
#line 6771
  cp = & p_j2k->m_cp;
#line 6774
  cp->tw = (OPJ_UINT32 )1;
#line 6775
  cp->th = (OPJ_UINT32 )1;
#line 6778
  if ((int )parameters->rsiz == 0) {
#line 6780
    deprecated_used = 0;
#line 6782
    if ((unsigned int )parameters->cp_cinema == 1U) {
#line 6782
      goto case_1;
    }
#line 6788
    if ((unsigned int )parameters->cp_cinema == 2U) {
#line 6788
      goto case_2;
    }
#line 6794
    if ((unsigned int )parameters->cp_cinema == 3U) {
#line 6794
      goto case_3;
    }
#line 6801
    goto switch_default;
    case_1: 
#line 6783
    parameters->rsiz = (OPJ_UINT16 )3;
#line 6784
    parameters->max_cs_size = 1302083;
#line 6785
    parameters->max_comp_size = 1041666;
#line 6786
    deprecated_used = 1;
#line 6787
    goto switch_break;
    case_2: 
#line 6789
    parameters->rsiz = (OPJ_UINT16 )3;
#line 6790
    parameters->max_cs_size = 651041;
#line 6791
    parameters->max_comp_size = 520833;
#line 6792
    deprecated_used = 1;
#line 6793
    goto switch_break;
    case_3: 
#line 6795
    parameters->rsiz = (OPJ_UINT16 )4;
#line 6796
    parameters->max_cs_size = 1302083;
#line 6797
    parameters->max_comp_size = 1041666;
#line 6798
    deprecated_used = 1;
#line 6799
    goto switch_break;
    switch_default: 
#line 6802
    goto switch_break;
    switch_break: ;
#line 6805
    if ((unsigned int )parameters->cp_rsiz == 3U) {
#line 6805
      goto case_3___0;
    }
#line 6809
    if ((unsigned int )parameters->cp_rsiz == 4U) {
#line 6809
      goto case_4;
    }
#line 6813
    if ((unsigned int )parameters->cp_rsiz == 33024U) {
#line 6813
      goto case_33024;
    }
#line 6817
    goto switch_default___0;
    case_3___0: 
#line 6806
    parameters->rsiz = (OPJ_UINT16 )3;
#line 6807
    deprecated_used = 1;
#line 6808
    goto switch_break___0;
    case_4: 
#line 6810
    parameters->rsiz = (OPJ_UINT16 )4;
#line 6811
    deprecated_used = 1;
#line 6812
    goto switch_break___0;
    case_33024: 
#line 6814
    parameters->rsiz = (OPJ_UINT16 )33024;
#line 6815
    deprecated_used = 1;
    switch_default___0: 
#line 6818
    goto switch_break___0;
    switch_break___0: ;
#line 6820
    if (deprecated_used) {
      {
#line 6821
      opj_event_msg(p_manager, 2, "Deprecated fields cp_cinema or cp_rsiz are used\nPlease consider using only the rsiz field\nSee openjpeg.h documentation for more details\n\220");
      }
    }
  }
#line 6829
  if (parameters->tcp_numlayers == 0) {
#line 6830
    parameters->tcp_numlayers = 1;
#line 6831
    parameters->cp_disto_alloc = 1;
#line 6832
    parameters->tcp_rates[0] = (float )0;
  }
#line 6835
  if (parameters->cp_disto_alloc) {
#line 6837
    i = (OPJ_UINT32 )1;
    {
#line 6837
    while (1) {
      while_continue: /* CIL Label */ ;

#line 6837
      if (! (i < (OPJ_UINT32 )parameters->tcp_numlayers)) {
#line 6837
        goto while_break;
      }
#line 6838
      rate_i_corr = parameters->tcp_rates[i];
#line 6839
      rate_i_m_1_corr = parameters->tcp_rates[i - 1U];
#line 6840
      if ((double )rate_i_corr <= 1.) {
#line 6841
        rate_i_corr = (OPJ_FLOAT32 )1.;
      }
#line 6843
      if ((double )rate_i_m_1_corr <= 1.) {
#line 6844
        rate_i_m_1_corr = (OPJ_FLOAT32 )1.;
      }
#line 6846
      if (rate_i_corr >= rate_i_m_1_corr) {
#line 6847
        if (rate_i_corr != parameters->tcp_rates[i]) {
#line 6847
          if (rate_i_m_1_corr != parameters->tcp_rates[i - 1U]) {
            {
#line 6849
            opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f (corrected as %f) should be strictly lesser than tcp_rates[%d]=%f (corrected as %f)\n",
                          i, (double )parameters->tcp_rates[i], (double )rate_i_corr,
                          i - 1U, (double )parameters->tcp_rates[i - 1U], (double )rate_i_m_1_corr);
            }
          } else {
#line 6847
            goto _L;
          }
        } else
        _L: 
#line 6854
        if (rate_i_corr != parameters->tcp_rates[i]) {
          {
#line 6855
          opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f (corrected as %f) should be strictly lesser than tcp_rates[%d]=%f\n",
                        i, (double )parameters->tcp_rates[i], (double )rate_i_corr,
                        i - 1U, (double )parameters->tcp_rates[i - 1U]);
          }
        } else
#line 6860
        if (rate_i_m_1_corr != parameters->tcp_rates[i - 1U]) {
          {
#line 6861
          opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f should be strictly lesser than tcp_rates[%d]=%f (corrected as %f)\n",
                        i, (double )parameters->tcp_rates[i], i - 1U, (double )parameters->tcp_rates[i - 1U],
                        (double )rate_i_m_1_corr);
          }
        } else {
          {
#line 6867
          opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f should be strictly lesser than tcp_rates[%d]=%f\n",
                        i, (double )parameters->tcp_rates[i], i - 1U, (double )parameters->tcp_rates[i - 1U]);
          }
        }
      }
#line 6837
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 6875
  if (parameters->cp_fixed_quality) {
#line 6877
    i = (OPJ_UINT32 )1;
    {
#line 6877
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 6877
      if (! (i < (OPJ_UINT32 )parameters->tcp_numlayers)) {
#line 6877
        goto while_break___0;
      }
#line 6878
      if (parameters->tcp_distoratio[i] < parameters->tcp_distoratio[i - 1U]) {
#line 6878
        if (i == (OPJ_UINT32 )parameters->tcp_numlayers - 1U) {
#line 6878
          if (! (parameters->tcp_distoratio[i] == (float )0)) {
            {
#line 6881
            opj_event_msg(p_manager, 2, "tcp_distoratio[%d]=%f should be strictly greater than tcp_distoratio[%d]=%f\n\230\001",
                          i, (double )parameters->tcp_distoratio[i], i - 1U, (double )parameters->tcp_distoratio[i - 1U]);
            }
          }
        } else {
          {
#line 6881
          opj_event_msg(p_manager, 2, "tcp_distoratio[%d]=%f should be strictly greater than tcp_distoratio[%d]=%f\n\230\001",
                        i, (double )parameters->tcp_distoratio[i], i - 1U, (double )parameters->tcp_distoratio[i - 1U]);
          }
        }
      }
#line 6877
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 6891
  if (parameters->max_cs_size <= 0) {
#line 6892
    if (parameters->tcp_rates[parameters->tcp_numlayers - 1] > (float )0) {
#line 6894
      temp_size = (OPJ_FLOAT32 )(((((double )image->numcomps * (double )(image->comps + 0)->w) * (double )(image->comps + 0)->h) * (double )(image->comps + 0)->prec) / ((((double )parameters->tcp_rates[parameters->tcp_numlayers - 1] * (double )8) * (double )(image->comps + 0)->dx) * (double )(image->comps + 0)->dy));
#line 6898
      if (temp_size > (float )2147483647) {
#line 6899
        parameters->max_cs_size = 2147483647;
      } else {
        {
#line 6901
        __cil_tmp20 = floor((double )temp_size);
#line 6901
        parameters->max_cs_size = (int )__cil_tmp20;
        }
      }
    } else {
#line 6904
      parameters->max_cs_size = 0;
    }
  } else {
#line 6908
    cap = 0;
#line 6909
    temp_rate = (OPJ_FLOAT32 )(((((double )image->numcomps * (double )(image->comps + 0)->w) * (double )(image->comps + 0)->h) * (double )(image->comps + 0)->prec) / ((((double )parameters->max_cs_size * (double )8) * (double )(image->comps + 0)->dx) * (double )(image->comps + 0)->dy));
#line 6913
    i = (OPJ_UINT32 )0;
    {
#line 6913
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 6913
      if (! (i < (OPJ_UINT32 )parameters->tcp_numlayers)) {
#line 6913
        goto while_break___1;
      }
#line 6914
      if (parameters->tcp_rates[i] < temp_rate) {
#line 6915
        parameters->tcp_rates[i] = temp_rate;
#line 6916
        cap = 1;
      }
#line 6913
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___1: ;
#line 6919
    if (cap) {
      {
#line 6920
      opj_event_msg(p_manager, 2, "The desired maximum codestream size has limited\nat least one of the desired quality layers\n");
      }
    }
  }
#line 6928
  if ((int )parameters->rsiz >= 3) {
#line 6928
    if ((int )parameters->rsiz <= 6) {
#line 6929
      if ((int )parameters->rsiz == 5) {
        {
#line 6931
        opj_event_msg(p_manager, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
#line 6933
        parameters->rsiz = (OPJ_UINT16 )0;
        }
      } else
#line 6929
      if ((int )parameters->rsiz == 6) {
        {
#line 6931
        opj_event_msg(p_manager, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
#line 6933
        parameters->rsiz = (OPJ_UINT16 )0;
        }
      } else {
        {
#line 6935
        opj_j2k_set_cinema_parameters(parameters, image, p_manager);
#line 6936
        __cil_tmp24 = opj_j2k_is_cinema_compliant(image, parameters->rsiz, p_manager);
        }
#line 6936
        if (! __cil_tmp24) {
#line 6937
          parameters->rsiz = (OPJ_UINT16 )0;
        }
      }
    } else {
#line 6928
      goto _L___14;
    }
  } else
  _L___14: 
#line 6940
  if ((int )parameters->rsiz == 7) {
    {
#line 6941
    opj_event_msg(p_manager, 2, "JPEG 2000 Long Term Storage profile not yet supported\n");
#line 6943
    parameters->rsiz = (OPJ_UINT16 )0;
    }
  } else
#line 6944
  if ((int )parameters->rsiz >= 256) {
#line 6944
    if ((int )parameters->rsiz <= 779) {
      {
#line 6945
      opj_event_msg(p_manager, 2, "JPEG 2000 Broadcast profiles not yet supported\n");
#line 6947
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 6944
      goto _L___13;
    }
  } else
  _L___13: 
#line 6948
  if ((int )parameters->rsiz >= 1024) {
#line 6948
    if ((int )parameters->rsiz <= 2203) {
      {
#line 6949
      opj_event_msg(p_manager, 2, "JPEG 2000 IMF profiles not yet supported\n");
#line 6951
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 6948
      goto _L___12;
    }
  } else
  _L___12: 
#line 6952
  if ((int )parameters->rsiz & 32768) {
#line 6953
    if ((int )parameters->rsiz == 32768) {
      {
#line 6954
      opj_event_msg(p_manager, 2, "JPEG 2000 Part-2 profile defined\nbut no Part-2 extension enabled.\nProfile set to NONE.\n");
#line 6958
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else
#line 6959
    if ((int )parameters->rsiz != 33024) {
      {
#line 6960
      opj_event_msg(p_manager, 2, "Unsupported Part-2 extension enabled\nProfile set to NONE.\n");
#line 6963
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    }
  }
#line 6970
  cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32 )parameters->max_comp_size;
#line 6972
  cp->rsiz = parameters->rsiz;
#line 6973
  cp->m_specific_param.m_enc.m_disto_alloc = (OPJ_UINT32 )parameters->cp_disto_alloc & 1U;
#line 6975
  cp->m_specific_param.m_enc.m_fixed_alloc = (OPJ_UINT32 )parameters->cp_fixed_alloc & 1U;
#line 6977
  cp->m_specific_param.m_enc.m_fixed_quality = (OPJ_UINT32 )parameters->cp_fixed_quality & 1U;
#line 6981
  if (parameters->cp_matrice) {
#line 6981
    if (parameters->cp_fixed_alloc) {
      {
#line 6982
      array_size = (((size_t )parameters->tcp_numlayers * (size_t )parameters->numresolution) * 3UL) * sizeof(OPJ_INT32 );
#line 6984
      __cil_tmp26 = opj_malloc(array_size);
#line 6984
      cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)__cil_tmp26;
      }
#line 6985
      if (! cp->m_specific_param.m_enc.m_matrice) {
        {
#line 6986
        opj_event_msg(p_manager, 1, "Not enough memory to allocate copy of user encoding parameters matrix \n");
        }
#line 6988
        return (0);
      }
      {
#line 6990
      memcpy((void *)cp->m_specific_param.m_enc.m_matrice, (void const   *)parameters->cp_matrice,
             array_size);
      }
    }
  }
#line 6995
  cp->tdx = (OPJ_UINT32 )parameters->cp_tdx;
#line 6996
  cp->tdy = (OPJ_UINT32 )parameters->cp_tdy;
#line 6999
  cp->tx0 = (OPJ_UINT32 )parameters->cp_tx0;
#line 7000
  cp->ty0 = (OPJ_UINT32 )parameters->cp_ty0;
#line 7003
  if (parameters->cp_comment) {
    {
#line 7004
    __cil_tmp27 = strlen((char const   *)parameters->cp_comment);
#line 7004
    __cil_tmp28 = opj_malloc(__cil_tmp27 + 1UL);
#line 7004
    cp->comment = (char *)__cil_tmp28;
    }
#line 7005
    if (! cp->comment) {
      {
#line 7006
      opj_event_msg(p_manager, 1, "Not enough memory to allocate copy of comment string\n");
      }
#line 7008
      return (0);
    }
    {
#line 7010
    strcpy(cp->comment, (char const   *)parameters->cp_comment);
    }
  } else {
    {
#line 7013
    strcpy(comment, "Created by OpenJPEG version ");
#line 7014
    __cil_tmp31 = strlen((char const   *)(comment));
#line 7014
    clen = __cil_tmp31;
#line 7015
    __cil_tmp33 = opj_version();
#line 7015
    version = __cil_tmp33;
#line 7027
    __cil_tmp34 = strlen(version);
#line 7027
    __cil_tmp35 = opj_malloc((clen + __cil_tmp34) + 1UL);
#line 7027
    cp->comment = (char *)__cil_tmp35;
    }
#line 7028
    if (! cp->comment) {
      {
#line 7029
      opj_event_msg(p_manager, 1, "Not enough memory to allocate comment string\n");
      }
#line 7031
      return (0);
    }
    {
#line 7033
    sprintf(cp->comment, "%s%s", (char const   *)(comment), version);
    }
  }
#line 7042
  if (parameters->tile_size_on) {
    {
#line 7043
    __cil_tmp36 = opj_int_ceildiv((OPJ_INT32 )(image->x1 - cp->tx0), (OPJ_INT32 )cp->tdx);
#line 7043
    cp->tw = (OPJ_UINT32 )__cil_tmp36;
#line 7045
    __cil_tmp37 = opj_int_ceildiv((OPJ_INT32 )(image->y1 - cp->ty0), (OPJ_INT32 )cp->tdy);
#line 7045
    cp->th = (OPJ_UINT32 )__cil_tmp37;
    }
  } else {
#line 7048
    cp->tdx = image->x1 - cp->tx0;
#line 7049
    cp->tdy = image->y1 - cp->ty0;
  }
#line 7052
  if (parameters->tp_on) {
#line 7053
    cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE )parameters->tp_flag;
#line 7054
    cp->m_specific_param.m_enc.m_tp_on = (OPJ_BITFIELD )1;
  }
  {
#line 7115
  __cil_tmp38 = opj_calloc((size_t )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 7115
  cp->tcps = (opj_tcp_t *)__cil_tmp38;
  }
#line 7116
  if (! cp->tcps) {
    {
#line 7117
    opj_event_msg(p_manager, 1, "Not enough memory to allocate tile coding parameters\n");
    }
#line 7119
    return (0);
  }
#line 7121
  if (parameters->numpocs) {
    {
#line 7123
    opj_j2k_check_poc_val(parameters->POC, parameters->numpocs, (OPJ_UINT32 )parameters->numresolution,
                          image->numcomps, (OPJ_UINT32 )parameters->tcp_numlayers,
                          p_manager);
    }
  }
#line 7129
  tileno = (OPJ_UINT32 )0;
  {
#line 7129
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 7129
    if (! (tileno < cp->tw * cp->th)) {
#line 7129
      goto while_break___2;
    }
#line 7130
    tcp = cp->tcps + tileno;
#line 7131
    tcp->numlayers = (OPJ_UINT32 )parameters->tcp_numlayers;
#line 7133
    j = (OPJ_UINT32 )0;
    {
#line 7133
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 7133
      if (! (j < tcp->numlayers)) {
#line 7133
        goto while_break___3;
      }
#line 7134
      if ((int )cp->rsiz >= 3) {
#line 7134
        if ((int )cp->rsiz <= 6) {
#line 7135
          if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 7136
            tcp->distoratio[j] = parameters->tcp_distoratio[j];
          }
#line 7138
          tcp->rates[j] = parameters->tcp_rates[j];
        } else {
#line 7134
          goto _L___15;
        }
      } else
      _L___15: 
#line 7140
      if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 7141
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 7143
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 7146
      if (! cp->m_specific_param.m_enc.m_fixed_quality) {
#line 7146
        if ((double )tcp->rates[j] <= 1.) {
#line 7148
          tcp->rates[j] = (OPJ_FLOAT32 )0.;
        }
      }
#line 7133
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___3: 
#line 7152
    tcp->csty = (OPJ_UINT32 )parameters->csty;
#line 7153
    tcp->prg = parameters->prog_order;
#line 7154
    tcp->mct = (OPJ_UINT32 )parameters->tcp_mct;
#line 7156
    numpocs_tile = (OPJ_UINT32 )0;
#line 7157
    tcp->POC = (OPJ_BITFIELD )0;
#line 7159
    if (parameters->numpocs) {
#line 7161
      tcp->POC = (OPJ_BITFIELD )1;
#line 7162
      i = (OPJ_UINT32 )0;
      {
#line 7162
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 7162
        if (! (i < parameters->numpocs)) {
#line 7162
          goto while_break___4;
        }
#line 7163
        if (tileno + 1U == parameters->POC[i].tile) {
#line 7164
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 7166
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 7167
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 7168
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 7169
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 7170
          tcp_poc->compno1 = parameters->POC[numpocs_tile].compno1;
#line 7171
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 7172
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 7174
          numpocs_tile ++;
        }
#line 7162
        i ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___4: 
#line 7178
      tcp->numpocs = numpocs_tile - 1U;
    } else {
#line 7180
      tcp->numpocs = (OPJ_UINT32 )0;
    }
    {
#line 7183
    __cil_tmp44 = opj_calloc((size_t )image->numcomps, sizeof(opj_tccp_t ));
#line 7183
    tcp->tccps = (opj_tccp_t *)__cil_tmp44;
    }
#line 7184
    if (! tcp->tccps) {
      {
#line 7185
      opj_event_msg(p_manager, 1, "Not enough memory to allocate tile component coding parameters\n");
      }
#line 7187
      return (0);
    }
#line 7189
    if (parameters->mct_data) {
      {
#line 7191
      lMctSize = (image->numcomps * image->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 7193
      __cil_tmp47 = opj_malloc((size_t )lMctSize);
#line 7193
      lTmpBuf = (OPJ_FLOAT32 *)__cil_tmp47;
#line 7194
      l_dc_shift = (OPJ_INT32 *)((OPJ_BYTE *)parameters->mct_data + lMctSize);
      }
#line 7197
      if (! lTmpBuf) {
        {
#line 7198
        opj_event_msg(p_manager, 1, "Not enough memory to allocate temp buffer\n");
        }
#line 7200
        return (0);
      }
      {
#line 7203
      tcp->mct = (OPJ_UINT32 )2;
#line 7204
      __cil_tmp49 = opj_malloc((size_t )lMctSize);
#line 7204
      tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)__cil_tmp49;
      }
#line 7205
      if (! tcp->m_mct_coding_matrix) {
        {
#line 7206
        opj_free((void *)lTmpBuf);
#line 7207
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 7208
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT coding matrix \n");
        }
#line 7210
        return (0);
      }
      {
#line 7212
      memcpy((void *)tcp->m_mct_coding_matrix, (void const   *)parameters->mct_data,
             (unsigned long )lMctSize);
#line 7213
      memcpy((void *)lTmpBuf, (void const   *)parameters->mct_data, (unsigned long )lMctSize);
#line 7215
      __cil_tmp50 = opj_malloc((size_t )lMctSize);
#line 7215
      tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp50;
      }
#line 7216
      if (! tcp->m_mct_decoding_matrix) {
        {
#line 7217
        opj_free((void *)lTmpBuf);
#line 7218
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 7219
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT decoding matrix \n");
        }
#line 7221
        return (0);
      }
      {
#line 7223
      __cil_tmp51 = opj_matrix_inversion_f(lTmpBuf, tcp->m_mct_decoding_matrix, image->numcomps);
      }
#line 7223
      if (__cil_tmp51 == 0) {
        {
#line 7225
        opj_free((void *)lTmpBuf);
#line 7226
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 7227
        opj_event_msg(p_manager, 1, "Failed to inverse encoder MCT decoding matrix \n");
        }
#line 7229
        return (0);
      }
      {
#line 7232
      __cil_tmp52 = opj_malloc((unsigned long )image->numcomps * sizeof(OPJ_FLOAT64 ));
#line 7232
      tcp->mct_norms = (OPJ_FLOAT64 *)__cil_tmp52;
      }
#line 7234
      if (! tcp->mct_norms) {
        {
#line 7235
        opj_free((void *)lTmpBuf);
#line 7236
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 7237
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT norms \n");
        }
#line 7239
        return (0);
      }
      {
#line 7241
      opj_calculate_norms(tcp->mct_norms, image->numcomps, tcp->m_mct_decoding_matrix);
#line 7243
      opj_free((void *)lTmpBuf);
#line 7245
      i = (OPJ_UINT32 )0;
      }
      {
#line 7245
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 7245
        if (! (i < image->numcomps)) {
#line 7245
          goto while_break___5;
        }
#line 7246
        tccp = tcp->tccps + i;
#line 7247
        tccp->m_dc_level_shift = *(l_dc_shift + i);
#line 7245
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___5: 
      {
#line 7250
      __cil_tmp55 = opj_j2k_setup_mct_encoding(tcp, image);
      }
#line 7250
      if (__cil_tmp55 == 0) {
        {
#line 7252
        opj_event_msg(p_manager, 1, "Failed to setup j2k mct encoding\n");
        }
#line 7253
        return (0);
      }
    } else {
#line 7256
      if (tcp->mct == 1U) {
#line 7256
        if (image->numcomps >= 3U) {
#line 7257
          if ((image->comps + 0)->dx != (image->comps + 1)->dx) {
            {
#line 7261
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 7263
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 7257
          if ((image->comps + 0)->dx != (image->comps + 2)->dx) {
            {
#line 7261
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 7263
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 7257
          if ((image->comps + 0)->dy != (image->comps + 1)->dy) {
            {
#line 7261
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 7263
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 7257
          if ((image->comps + 0)->dy != (image->comps + 2)->dy) {
            {
#line 7261
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 7263
            tcp->mct = (OPJ_UINT32 )0;
            }
          }
        }
      }
#line 7266
      i = (OPJ_UINT32 )0;
      {
#line 7266
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 7266
        if (! (i < image->numcomps)) {
#line 7266
          goto while_break___6;
        }
#line 7267
        tccp___0 = tcp->tccps + i;
#line 7268
        l_comp = image->comps + i;
#line 7270
        if (! l_comp->sgnd) {
#line 7271
          tccp___0->m_dc_level_shift = 1 << (l_comp->prec - 1U);
        }
#line 7266
        i ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: ;
    }
#line 7276
    i = (OPJ_UINT32 )0;
    {
#line 7276
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 7276
      if (! (i < image->numcomps)) {
#line 7276
        goto while_break___7;
      }
      {
#line 7277
      tccp___1 = tcp->tccps + i;
#line 7279
      tccp___1->csty = (OPJ_UINT32 )(parameters->csty & 1);
#line 7281
      tccp___1->numresolutions = (OPJ_UINT32 )parameters->numresolution;
#line 7282
      __cil_tmp60 = opj_int_floorlog2(parameters->cblockw_init);
#line 7282
      tccp___1->cblkw = (OPJ_UINT32 )__cil_tmp60;
#line 7283
      __cil_tmp61 = opj_int_floorlog2(parameters->cblockh_init);
#line 7283
      tccp___1->cblkh = (OPJ_UINT32 )__cil_tmp61;
#line 7284
      tccp___1->cblksty = (OPJ_UINT32 )parameters->mode;
      }
#line 7285
      if (parameters->irreversible) {
#line 7285
        tmp = 0;
      } else {
#line 7285
        tmp = 1;
      }
#line 7285
      tccp___1->qmfbid = (OPJ_UINT32 )tmp;
#line 7286
      if (parameters->irreversible) {
#line 7286
        tmp___0 = 2;
      } else {
#line 7286
        tmp___0 = 0;
      }
#line 7286
      tccp___1->qntsty = (OPJ_UINT32 )tmp___0;
#line 7288
      tccp___1->numgbits = (OPJ_UINT32 )2;
#line 7290
      if ((OPJ_INT32 )i == parameters->roi_compno) {
#line 7291
        tccp___1->roishift = parameters->roi_shift;
      } else {
#line 7293
        tccp___1->roishift = 0;
      }
#line 7296
      if (parameters->csty & 1) {
#line 7297
        p = 0;
#line 7299
        it_res = (OPJ_INT32 )tccp___1->numresolutions - 1;
        {
#line 7299
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 7299
          if (! (it_res >= 0)) {
#line 7299
            goto while_break___8;
          }
#line 7300
          if (p < parameters->res_spec) {
#line 7302
            if (parameters->prcw_init[p] < 1) {
#line 7303
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 7305
              __cil_tmp67 = opj_int_floorlog2(parameters->prcw_init[p]);
#line 7305
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp67;
              }
            }
#line 7308
            if (parameters->prch_init[p] < 1) {
#line 7309
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 7311
              __cil_tmp68 = opj_int_floorlog2(parameters->prch_init[p]);
#line 7311
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp68;
              }
            }
          } else {
#line 7315
            res_spec = parameters->res_spec;
#line 7316
            size_prcw = 0;
#line 7317
            size_prch = 0;
#line 7320
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 7321
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 7324
            if (size_prcw < 1) {
#line 7325
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 7327
              __cil_tmp73 = opj_int_floorlog2(size_prcw);
#line 7327
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp73;
              }
            }
#line 7330
            if (size_prch < 1) {
#line 7331
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 7333
              __cil_tmp74 = opj_int_floorlog2(size_prch);
#line 7333
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp74;
              }
            }
          }
#line 7336
          p ++;
#line 7299
          __cil_tmp76 = it_res;
#line 7299
          it_res --;
        }
        while_break___19: /* CIL Label */ ;
        }
        while_break___8: ;
      } else {
#line 7340
        j = (OPJ_UINT32 )0;
        {
#line 7340
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 7340
          if (! (j < tccp___1->numresolutions)) {
#line 7340
            goto while_break___9;
          }
#line 7341
          tccp___1->prcw[j] = (OPJ_UINT32 )15;
#line 7342
          tccp___1->prch[j] = (OPJ_UINT32 )15;
#line 7340
          j ++;
        }
        while_break___20: /* CIL Label */ ;
        }
        while_break___9: ;
      }
      {
#line 7346
      opj_dwt_calc_explicit_stepsizes(tccp___1, (image->comps + i)->prec);
#line 7276
      i ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___7: 
#line 7129
    tileno ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___2: ;
#line 7350
  if (parameters->mct_data) {
    {
#line 7351
    opj_free(parameters->mct_data);
#line 7352
    parameters->mct_data = (void *)0;
    }
  }
#line 7354
  return (1);
}
}
#line 7357 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  opj_marker_info_t *new_marker ;
  void *__cil_tmp7 ;

  {
#line 7363
  if (cstr_index->marknum + 1U > cstr_index->maxmarknum) {
    {
#line 7365
    cstr_index->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )cstr_index->maxmarknum);
#line 7367
    __cil_tmp7 = opj_realloc((void *)cstr_index->marker, (unsigned long )cstr_index->maxmarknum * sizeof(opj_marker_info_t ));
#line 7367
    new_marker = (opj_marker_info_t *)__cil_tmp7;
    }
#line 7369
    if (! new_marker) {
      {
#line 7370
      opj_free((void *)cstr_index->marker);
#line 7371
      cstr_index->marker = (opj_marker_info_t *)((void *)0);
#line 7372
      cstr_index->maxmarknum = (OPJ_UINT32 )0;
#line 7373
      cstr_index->marknum = (OPJ_UINT32 )0;
      }
#line 7375
      return (0);
    }
#line 7377
    cstr_index->marker = new_marker;
  }
#line 7381
  (cstr_index->marker + cstr_index->marknum)->type = (OPJ_UINT16 )type;
#line 7382
  (cstr_index->marker + cstr_index->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 7383
  (cstr_index->marker + cstr_index->marknum)->len = (OPJ_INT32 )len;
#line 7384
  (cstr_index->marknum) ++;
#line 7385
  return (1);
}
}
#line 7388 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  opj_marker_info_t *new_marker ;
  void *__cil_tmp9 ;
  OPJ_UINT32 l_current_tile_part ;

  {
#line 7396
  if ((cstr_index->tile_index + tileno)->marknum + 1U > (cstr_index->tile_index + tileno)->maxmarknum) {
    {
#line 7399
    (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )(cstr_index->tile_index + tileno)->maxmarknum);
#line 7401
    __cil_tmp9 = opj_realloc((void *)(cstr_index->tile_index + tileno)->marker, (unsigned long )(cstr_index->tile_index + tileno)->maxmarknum * sizeof(opj_marker_info_t ));
#line 7401
    new_marker = (opj_marker_info_t *)__cil_tmp9;
    }
#line 7404
    if (! new_marker) {
      {
#line 7405
      opj_free((void *)(cstr_index->tile_index + tileno)->marker);
#line 7406
      (cstr_index->tile_index + tileno)->marker = (opj_marker_info_t *)((void *)0);
#line 7407
      (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )0;
#line 7408
      (cstr_index->tile_index + tileno)->marknum = (OPJ_UINT32 )0;
      }
#line 7410
      return (0);
    }
#line 7412
    (cstr_index->tile_index + tileno)->marker = new_marker;
  }
#line 7416
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->type = (OPJ_UINT16 )type;
#line 7418
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 7420
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->len = (OPJ_INT32 )len;
#line 7422
  ((cstr_index->tile_index + tileno)->marknum) ++;
#line 7424
  if (type == 65424U) {
#line 7425
    l_current_tile_part = (cstr_index->tile_index + tileno)->current_tpsno;
#line 7427
    if ((cstr_index->tile_index + tileno)->tp_index) {
#line 7428
      ((cstr_index->tile_index + tileno)->tp_index + l_current_tile_part)->start_pos = pos;
    }
  }
#line 7432
  return (1);
}
}
#line 7441 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 


  {
#line 7449
  return (1);
}
}
#line 7452 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 7463
  p_j2k->m_private_image = opj_image_create0();
  }
#line 7464
  if (! p_j2k->m_private_image) {
#line 7465
    return (0);
  }
  {
#line 7469
  __cil_tmp9 = opj_j2k_setup_decoding_validation(p_j2k, p_manager);
  }
#line 7469
  if (! __cil_tmp9) {
    {
#line 7470
    opj_image_destroy(p_j2k->m_private_image);
#line 7471
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 7472
    return (0);
  }
  {
#line 7476
  __cil_tmp10 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 7476
  if (! __cil_tmp10) {
    {
#line 7477
    opj_image_destroy(p_j2k->m_private_image);
#line 7478
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 7479
    return (0);
  }
  {
#line 7483
  __cil_tmp11 = opj_j2k_setup_header_reading(p_j2k, p_manager);
  }
#line 7483
  if (! __cil_tmp11) {
    {
#line 7484
    opj_image_destroy(p_j2k->m_private_image);
#line 7485
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 7486
    return (0);
  }
  {
#line 7490
  __cil_tmp12 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 7490
  if (! __cil_tmp12) {
    {
#line 7491
    opj_image_destroy(p_j2k->m_private_image);
#line 7492
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 7493
    return (0);
  }
  {
#line 7496
  *p_image = opj_image_create0();
  }
#line 7497
  if (! *p_image) {
#line 7498
    return (0);
  }
  {
#line 7502
  opj_copy_image_header(p_j2k->m_private_image, *p_image);
#line 7505
  __cil_tmp14 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
  }
#line 7505
  if (! __cil_tmp14) {
#line 7506
    return (0);
  }
#line 7509
  return (1);
}
}
#line 7512 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
  {
#line 7519
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_read_header_procedure),
                                                p_manager);
  }
#line 7519
  if (! __cil_tmp5) {
#line 7521
    return (0);
  }
  {
#line 7525
  __cil_tmp6 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_copy_default_tcp_and_create_tcd),
                                                p_manager);
  }
#line 7525
  if (! __cil_tmp6) {
#line 7527
    return (0);
  }
#line 7530
  return (1);
}
}
#line 7533 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
  {
#line 7540
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_build_decoder),
                                                p_manager);
  }
#line 7540
  if (! __cil_tmp5) {
#line 7542
    return (0);
  }
  {
#line 7544
  __cil_tmp6 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_decoding_validation),
                                                p_manager);
  }
#line 7544
  if (! __cil_tmp6) {
#line 7546
    return (0);
  }
#line 7550
  return (1);
}
}
#line 7553 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 7557
  l_is_valid = 1;
#line 7568
  if (((int )p_j2k->m_cp.rsiz & 33280) == 33280) {
#line 7569
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 7570
    l_tcp = p_j2k->m_cp.tcps;
#line 7572
    i = (OPJ_UINT32 )0;
    {
#line 7572
    while (1) {
      while_continue: /* CIL Label */ ;

#line 7572
      if (! (i < l_nb_tiles)) {
#line 7572
        goto while_break;
      }
#line 7573
      if (l_tcp->mct == 2U) {
#line 7574
        l_tccp = l_tcp->tccps;
#line 7575
        l_is_valid &= (unsigned long )l_tcp->m_mct_coding_matrix != (unsigned long )((OPJ_FLOAT32 *)0);
#line 7577
        j = (OPJ_UINT32 )0;
        {
#line 7577
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 7577
          if (! (j < (p_j2k->m_private_image)->numcomps)) {
#line 7577
            goto while_break___0;
          }
#line 7578
          l_is_valid &= ! (l_tccp->qmfbid & 1U);
#line 7579
          l_tccp ++;
#line 7577
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
      }
#line 7582
      l_tcp ++;
#line 7572
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 7586
  return (l_is_valid);
}
}
#line 7589 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_deco_data ;
  opj_mct_data_t *l_mct_offset_data ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_data ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_FLOAT32 *l_data ;
  OPJ_FLOAT32 *l_current_data ;
  opj_tccp_t *l_tccp ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp15 ;
  OPJ_UINT32 __cil_tmp16 ;
  void *__cil_tmp17 ;
  opj_mct_data_t *new_mct_records___0 ;
  void *__cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;

  {
#line 7592
  l_indix = (OPJ_UINT32 )1;
#line 7593
  l_mct_deco_data = (opj_mct_data_t *)0;
#line 7593
  l_mct_offset_data = (opj_mct_data_t *)0;
#line 7602
  if (p_tcp->mct != 2U) {
#line 7603
    return (1);
  }
#line 7606
  if (p_tcp->m_mct_decoding_matrix) {
#line 7607
    if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
      {
#line 7609
      p_tcp->m_nb_max_mct_records += 10U;
#line 7611
      __cil_tmp15 = opj_realloc((void *)p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 7611
      new_mct_records = (opj_mct_data_t *)__cil_tmp15;
      }
#line 7613
      if (! new_mct_records) {
        {
#line 7614
        opj_free((void *)p_tcp->m_mct_records);
#line 7615
        p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 7616
        p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 7617
        p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
        }
#line 7619
        return (0);
      }
      {
#line 7621
      p_tcp->m_mct_records = new_mct_records;
#line 7622
      l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 7624
      memset((void *)l_mct_deco_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 7628
    l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 7630
    if (l_mct_deco_data->m_data) {
      {
#line 7631
      opj_free((void *)l_mct_deco_data->m_data);
#line 7632
      l_mct_deco_data->m_data = (OPJ_BYTE *)0;
      }
    }
    {
#line 7635
    __cil_tmp16 = l_indix;
#line 7635
    l_indix ++;
#line 7635
    l_mct_deco_data->m_index = __cil_tmp16;
#line 7636
    l_mct_deco_data->m_array_type = (J2K_MCT_ARRAY_TYPE )1;
#line 7637
    l_mct_deco_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 7638
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 7639
    l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];
#line 7640
    __cil_tmp17 = opj_malloc((size_t )l_mct_size);
#line 7640
    l_mct_deco_data->m_data = (OPJ_BYTE *)__cil_tmp17;
    }
#line 7642
    if (! l_mct_deco_data->m_data) {
#line 7643
      return (0);
    }
    {
#line 7646
    (*(j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type]))((void const   *)p_tcp->m_mct_decoding_matrix,
                                                                             (void *)l_mct_deco_data->m_data,
                                                                             l_nb_elem);
#line 7649
    l_mct_deco_data->m_data_size = l_mct_size;
#line 7650
    (p_tcp->m_nb_mct_records) ++;
    }
  }
#line 7653
  if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
    {
#line 7655
    p_tcp->m_nb_max_mct_records += 10U;
#line 7656
    __cil_tmp19 = opj_realloc((void *)p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 7656
    new_mct_records___0 = (opj_mct_data_t *)__cil_tmp19;
    }
#line 7658
    if (! new_mct_records___0) {
      {
#line 7659
      opj_free((void *)p_tcp->m_mct_records);
#line 7660
      p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 7661
      p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 7662
      p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
      }
#line 7664
      return (0);
    }
    {
#line 7666
    p_tcp->m_mct_records = new_mct_records___0;
#line 7667
    l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 7669
    memset((void *)l_mct_offset_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
    }
#line 7673
    if (l_mct_deco_data) {
#line 7674
      l_mct_deco_data = l_mct_offset_data - 1;
    }
  }
#line 7678
  l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 7680
  if (l_mct_offset_data->m_data) {
    {
#line 7681
    opj_free((void *)l_mct_offset_data->m_data);
#line 7682
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
  }
  {
#line 7685
  __cil_tmp20 = l_indix;
#line 7685
  l_indix ++;
#line 7685
  l_mct_offset_data->m_index = __cil_tmp20;
#line 7686
  l_mct_offset_data->m_array_type = (J2K_MCT_ARRAY_TYPE )2;
#line 7687
  l_mct_offset_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 7688
  l_nb_elem = p_image->numcomps;
#line 7689
  l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];
#line 7690
  __cil_tmp21 = opj_malloc((size_t )l_mct_size);
#line 7690
  l_mct_offset_data->m_data = (OPJ_BYTE *)__cil_tmp21;
  }
#line 7692
  if (! l_mct_offset_data->m_data) {
#line 7693
    return (0);
  }
  {
#line 7696
  __cil_tmp22 = opj_malloc((unsigned long )l_nb_elem * sizeof(OPJ_FLOAT32 ));
#line 7696
  l_data = (OPJ_FLOAT32 *)__cil_tmp22;
  }
#line 7697
  if (! l_data) {
    {
#line 7698
    opj_free((void *)l_mct_offset_data->m_data);
#line 7699
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
#line 7700
    return (0);
  }
#line 7703
  l_tccp = p_tcp->tccps;
#line 7704
  l_current_data = l_data;
#line 7706
  i = (OPJ_UINT32 )0;
  {
#line 7706
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7706
    if (! (i < l_nb_elem)) {
#line 7706
      goto while_break;
    }
#line 7707
    __cil_tmp23 = l_current_data;
#line 7707
    l_current_data ++;
#line 7707
    *__cil_tmp23 = (OPJ_FLOAT32 )l_tccp->m_dc_level_shift;
#line 7708
    l_tccp ++;
#line 7706
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 7711
  (*(j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type]))((void const   *)l_data,
                                                                             (void *)l_mct_offset_data->m_data,
                                                                             l_nb_elem);
#line 7714
  opj_free((void *)l_data);
#line 7716
  l_mct_offset_data->m_data_size = l_mct_size;
#line 7718
  (p_tcp->m_nb_mct_records) ++;
  }
#line 7720
  if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {
    {
#line 7722
    p_tcp->m_nb_max_mcc_records += 10U;
#line 7723
    __cil_tmp25 = opj_realloc((void *)p_tcp->m_mcc_records, (unsigned long )p_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 7723
    new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp25;
    }
#line 7726
    if (! new_mcc_records) {
      {
#line 7727
      opj_free((void *)p_tcp->m_mcc_records);
#line 7728
      p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 7729
      p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 7730
      p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
      }
#line 7732
      return (0);
    }
    {
#line 7734
    p_tcp->m_mcc_records = new_mcc_records;
#line 7735
    l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 7736
    memset((void *)l_mcc_data, 0, (unsigned long )(p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
    }
  }
#line 7741
  l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 7742
  l_mcc_data->m_decorrelation_array = l_mct_deco_data;
#line 7743
  l_mcc_data->m_is_irreversible = (OPJ_BITFIELD )1;
#line 7744
  l_mcc_data->m_nb_comps = p_image->numcomps;
#line 7745
  __cil_tmp26 = l_indix;
#line 7745
  l_indix ++;
#line 7745
  l_mcc_data->m_index = __cil_tmp26;
#line 7746
  l_mcc_data->m_offset_array = l_mct_offset_data;
#line 7747
  (p_tcp->m_nb_mcc_records) ++;
#line 7749
  return (1);
}
}
#line 7752 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) 
{ 


  {
#line 7761
  return (1);
}
}
#line 7764 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) 
{ 


  {
#line 7773
  return (1);
}
}
#line 7776 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;

  {
#line 7780
  l_is_valid = 1;
#line 7791
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 7795
  l_is_valid &= (unsigned long )p_j2k->m_procedure_list != (unsigned long )((opj_procedure_list_t *)0);
#line 7797
  l_is_valid &= (unsigned long )p_j2k->m_validation_list != (unsigned long )((opj_procedure_list_t *)0);
#line 7802
  if (((p_j2k->m_cp.tcps)->tccps)->numresolutions <= 0U) {
    {
#line 7804
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\nV");
    }
#line 7806
    return (0);
  } else
#line 7802
  if (((p_j2k->m_cp.tcps)->tccps)->numresolutions > 32U) {
    {
#line 7804
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\nV");
    }
#line 7806
    return (0);
  }
#line 7809
  if (p_j2k->m_cp.tdx < (OPJ_UINT32 )(1 << (((p_j2k->m_cp.tcps)->tccps)->numresolutions - 1U))) {
    {
#line 7811
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\nV");
    }
#line 7813
    return (0);
  }
#line 7816
  if (p_j2k->m_cp.tdy < (OPJ_UINT32 )(1 << (((p_j2k->m_cp.tcps)->tccps)->numresolutions - 1U))) {
    {
#line 7818
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
#line 7820
    return (0);
  }
#line 7824
  return (l_is_valid);
}
}
#line 7827 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;

  {
#line 7832
  l_is_valid = 1;
#line 7847
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 7852
  l_is_valid &= (unsigned long )p_j2k->m_procedure_list != (unsigned long )((opj_procedure_list_t *)0);
#line 7854
  l_is_valid &= (unsigned long )p_j2k->m_validation_list != (unsigned long )((opj_procedure_list_t *)0);
#line 7857
  return (l_is_valid);
}
}
#line 7860 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_BOOL l_has_siz ;
  OPJ_BOOL l_has_cod ;
  OPJ_BOOL l_has_qcd ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_BYTE *new_header_data ;
  void *__cil_tmp20 ;
  OPJ_SIZE_T __cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_OFF_T __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;
  OPJ_SIZE_T __cil_tmp25 ;
  OPJ_BOOL __cil_tmp26 ;
  OPJ_OFF_T __cil_tmp27 ;

  {
  {
#line 7866
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 7867
  l_has_siz = 0;
#line 7868
  l_has_cod = 0;
#line 7869
  l_has_qcd = 0;
#line 7877
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )1;
#line 7880
  __cil_tmp13 = opj_j2k_read_soc(p_j2k, p_stream, p_manager);
  }
#line 7880
  if (! __cil_tmp13) {
    {
#line 7881
    opj_event_msg(p_manager, 1, "Expected a SOC marker \n");
    }
#line 7882
    return (0);
  }
  {
#line 7886
  __cil_tmp14 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 7886
  if (__cil_tmp14 != 2UL) {
    {
#line 7888
    opj_event_msg(p_manager, 1, "Stream too short\n\356\0342 V");
    }
#line 7889
    return (0);
  }
  {
#line 7893
  opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                    (OPJ_UINT32 )2);
  }
  {
#line 7897
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7897
    if (! (l_current_marker != 65424U)) {
#line 7897
      goto while_break;
    }
#line 7900
    if (l_current_marker < 65280U) {
      {
#line 7901
      opj_event_msg(p_manager, 1, "A marker ID was expected (0xff--) instead of %.8x\n",
                    l_current_marker);
      }
#line 7903
      return (0);
    }
    {
#line 7907
    l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
    }
#line 7910
    if (l_marker_handler->id == 0U) {
      {
#line 7911
      __cil_tmp16 = opj_j2k_read_unk(p_j2k, p_stream, & l_current_marker, p_manager);
      }
#line 7911
      if (! __cil_tmp16) {
        {
#line 7912
        opj_event_msg(p_manager, 1, "Unknow marker have been detected and generated error.\n");
        }
#line 7914
        return (0);
      }
#line 7917
      if (l_current_marker == 65424U) {
#line 7918
        goto while_break;
      } else {
        {
#line 7920
        l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
        }
      }
    }
#line 7924
    if (l_marker_handler->id == 65361U) {
#line 7926
      l_has_siz = 1;
    }
#line 7928
    if (l_marker_handler->id == 65362U) {
#line 7930
      l_has_cod = 1;
    }
#line 7932
    if (l_marker_handler->id == 65372U) {
#line 7934
      l_has_qcd = 1;
    }
#line 7938
    if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
      {
#line 7939
      opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n\0352 V");
      }
#line 7941
      return (0);
    }
    {
#line 7945
    __cil_tmp18 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 7945
    if (__cil_tmp18 != 2UL) {
      {
#line 7947
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 7948
      return (0);
    }
    {
#line 7952
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                      (OPJ_UINT32 )2);
    }
#line 7954
    if (l_marker_size < 2U) {
      {
#line 7955
      opj_event_msg(p_manager, 1, "Invalid marker size\n");
      }
#line 7956
      return (0);
    }
#line 7958
    l_marker_size -= 2U;
#line 7961
    if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
      {
#line 7962
      __cil_tmp20 = opj_realloc((void *)p_j2k->m_specific_param.m_decoder.m_header_data,
                                (size_t )l_marker_size);
#line 7962
      new_header_data = (OPJ_BYTE *)__cil_tmp20;
      }
#line 7964
      if (! new_header_data) {
        {
#line 7965
        opj_free((void *)p_j2k->m_specific_param.m_decoder.m_header_data);
#line 7966
        p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 7967
        p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 7968
        opj_event_msg(p_manager, 1, "Not enough memory to read header\n");
        }
#line 7969
        return (0);
      }
#line 7971
      p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 7972
      p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
    }
    {
#line 7976
    __cil_tmp21 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )l_marker_size, p_manager);
    }
#line 7976
    if (__cil_tmp21 != (unsigned long )l_marker_size) {
      {
#line 7979
      opj_event_msg(p_manager, 1, "Stream too short\nr\0352 V");
      }
#line 7980
      return (0);
    }
    {
#line 7984
    __cil_tmp22 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                 l_marker_size, p_manager);
    }
#line 7984
    if (! __cil_tmp22) {
      {
#line 7986
      opj_event_msg(p_manager, 1, "Marker handler function failed to read the marker segment\n\0352 V");
      }
#line 7988
      return (0);
    }
    {
#line 7992
    __cil_tmp23 = opj_stream_tell(p_stream);
#line 7992
    __cil_tmp24 = opj_j2k_add_mhmarker(p_j2k->cstr_index, l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp23 - l_marker_size) - 4U),
                                       l_marker_size + 4U);
    }
#line 7992
    if (0 == __cil_tmp24) {
      {
#line 7997
      opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n");
      }
#line 7998
      return (0);
    }
    {
#line 8002
    __cil_tmp25 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 8002
    if (__cil_tmp25 != 2UL) {
      {
#line 8004
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 8005
      return (0);
    }
    {
#line 8009
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                      (OPJ_UINT32 )2);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 8013
  if (l_has_siz == 0) {
    {
#line 8014
    opj_event_msg(p_manager, 1, "required SIZ marker not found in main header\nV");
    }
#line 8016
    return (0);
  }
#line 8018
  if (l_has_cod == 0) {
    {
#line 8019
    opj_event_msg(p_manager, 1, "required COD marker not found in main header\n");
    }
#line 8021
    return (0);
  }
#line 8023
  if (l_has_qcd == 0) {
    {
#line 8024
    opj_event_msg(p_manager, 1, "required QCD marker not found in main header\nV");
    }
#line 8026
    return (0);
  }
  {
#line 8029
  __cil_tmp26 = opj_j2k_merge_ppm(& p_j2k->m_cp, p_manager);
  }
#line 8029
  if (! __cil_tmp26) {
    {
#line 8030
    opj_event_msg(p_manager, 1, "Failed to merge PPM data\n#\0322 V");
    }
#line 8031
    return (0);
  }
  {
#line 8034
  opj_event_msg(p_manager, 4, "Main header has been correctly decoded.\n\220");
#line 8037
  __cil_tmp27 = opj_stream_tell(p_stream);
#line 8037
  (p_j2k->cstr_index)->main_head_end = (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp27 - 2U);
#line 8040
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 8042
  return (1);
}
}
#line 8045 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i ;
  opj_procedure *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  int tmp___3 ;

  {
  {
#line 8050
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 8052
  l_result = 1;
#line 8061
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 8062
  __cil_tmp14 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 8062
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp14;
#line 8065
  i = (OPJ_UINT32 )0;
  }
  {
#line 8065
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8065
    if (! (i < l_nb_proc)) {
#line 8065
      goto while_break;
    }
    {
#line 8066
    __cil_tmp15 = (*(*l_procedure))(p_j2k, p_stream, p_manager);
    }
#line 8066
    if (l_result) {
#line 8066
      if (__cil_tmp15) {
#line 8066
        tmp___3 = 1;
      } else {
#line 8066
        tmp___3 = 0;
      }
    } else {
#line 8066
      tmp___3 = 0;
    }
#line 8066
    l_result = tmp___3;
#line 8067
    l_procedure ++;
#line 8065
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 8071
  opj_procedure_list_clear(p_procedure_list);
  }
#line 8072
  return (l_result);
}
}
#line 8076 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) 
{ 
  opj_tcp_t *l_tcp ;
  opj_tcp_t *l_default_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  opj_tccp_t *l_current_tccp ;
  OPJ_UINT32 l_tccp_size ;
  OPJ_UINT32 l_mct_size ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_mcc_records_size ;
  OPJ_UINT32 l_mct_records_size ;
  opj_mct_data_t *l_src_mct_rec ;
  opj_mct_data_t *l_dest_mct_rec ;
  opj_simple_mcc_decorrelation_data_t *l_src_mcc_rec ;
  opj_simple_mcc_decorrelation_data_t *l_dest_mcc_rec ;
  OPJ_UINT32 l_offset ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  OPJ_BOOL __cil_tmp28 ;

  {
#line 8081
  l_tcp = (opj_tcp_t *)0;
#line 8082
  l_default_tcp = (opj_tcp_t *)0;
#line 8085
  l_current_tccp = (opj_tccp_t *)0;
#line 8101
  l_image = p_j2k->m_private_image;
#line 8102
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 8103
  l_tcp = p_j2k->m_cp.tcps;
#line 8104
  l_tccp_size = l_image->numcomps * (OPJ_UINT32 )sizeof(opj_tccp_t );
#line 8105
  l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 8106
  l_mct_size = (l_image->numcomps * l_image->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 8110
  i = (OPJ_UINT32 )0;
  {
#line 8110
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8110
    if (! (i < l_nb_tiles)) {
#line 8110
      goto while_break;
    }
    {
#line 8112
    l_current_tccp = l_tcp->tccps;
#line 8114
    memcpy((void *)l_tcp, (void const   *)l_default_tcp, sizeof(opj_tcp_t ));
#line 8116
    l_tcp->cod = (OPJ_BITFIELD )0;
#line 8117
    l_tcp->ppt = (OPJ_BITFIELD )0;
#line 8118
    l_tcp->ppt_data = (OPJ_BYTE *)0;
#line 8119
    l_tcp->m_current_tile_part_number = -1;
#line 8121
    l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
#line 8122
    l_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 8123
    l_tcp->m_mct_records = (opj_mct_data_t *)0;
#line 8124
    l_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 8125
    l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)0;
#line 8127
    l_tcp->tccps = l_current_tccp;
    }
#line 8130
    if (l_default_tcp->m_mct_decoding_matrix) {
      {
#line 8131
      __cil_tmp23 = opj_malloc((size_t )l_mct_size);
#line 8131
      l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp23;
      }
#line 8132
      if (! l_tcp->m_mct_decoding_matrix) {
#line 8133
        return (0);
      }
      {
#line 8135
      memcpy((void *)l_tcp->m_mct_decoding_matrix, (void const   *)l_default_tcp->m_mct_decoding_matrix,
             (unsigned long )l_mct_size);
      }
    }
    {
#line 8140
    l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32 )sizeof(opj_mct_data_t );
#line 8142
    __cil_tmp24 = opj_malloc((size_t )l_mct_records_size);
#line 8142
    l_tcp->m_mct_records = (opj_mct_data_t *)__cil_tmp24;
    }
#line 8143
    if (! l_tcp->m_mct_records) {
#line 8144
      return (0);
    }
    {
#line 8146
    memcpy((void *)l_tcp->m_mct_records, (void const   *)l_default_tcp->m_mct_records,
           (unsigned long )l_mct_records_size);
#line 8149
    l_src_mct_rec = l_default_tcp->m_mct_records;
#line 8150
    l_dest_mct_rec = l_tcp->m_mct_records;
#line 8152
    j = (OPJ_UINT32 )0;
    }
    {
#line 8152
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8152
      if (! (j < l_default_tcp->m_nb_mct_records)) {
#line 8152
        goto while_break___0;
      }
#line 8154
      if (l_src_mct_rec->m_data) {
        {
#line 8156
        __cil_tmp25 = opj_malloc((size_t )l_src_mct_rec->m_data_size);
#line 8156
        l_dest_mct_rec->m_data = (OPJ_BYTE *)__cil_tmp25;
        }
#line 8157
        if (! l_dest_mct_rec->m_data) {
#line 8158
          return (0);
        }
        {
#line 8160
        memcpy((void *)l_dest_mct_rec->m_data, (void const   *)l_src_mct_rec->m_data,
               (unsigned long )l_src_mct_rec->m_data_size);
        }
      }
#line 8164
      l_src_mct_rec ++;
#line 8165
      l_dest_mct_rec ++;
#line 8167
      (l_tcp->m_nb_max_mct_records) ++;
#line 8152
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 8171
    l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32 )sizeof(opj_simple_mcc_decorrelation_data_t );
#line 8173
    __cil_tmp26 = opj_malloc((size_t )l_mcc_records_size);
#line 8173
    l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp26;
    }
#line 8175
    if (! l_tcp->m_mcc_records) {
#line 8176
      return (0);
    }
    {
#line 8178
    memcpy((void *)l_tcp->m_mcc_records, (void const   *)l_default_tcp->m_mcc_records,
           (unsigned long )l_mcc_records_size);
#line 8179
    l_tcp->m_nb_max_mcc_records = l_default_tcp->m_nb_max_mcc_records;
#line 8182
    l_src_mcc_rec = l_default_tcp->m_mcc_records;
#line 8183
    l_dest_mcc_rec = l_tcp->m_mcc_records;
#line 8185
    j = (OPJ_UINT32 )0;
    }
    {
#line 8185
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 8185
      if (! (j < l_default_tcp->m_nb_max_mcc_records)) {
#line 8185
        goto while_break___1;
      }
#line 8187
      if (l_src_mcc_rec->m_decorrelation_array) {
#line 8188
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_decorrelation_array - l_default_tcp->m_mct_records);
#line 8190
        l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + l_offset;
      }
#line 8193
      if (l_src_mcc_rec->m_offset_array) {
#line 8194
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_offset_array - l_default_tcp->m_mct_records);
#line 8196
        l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + l_offset;
      }
#line 8199
      l_src_mcc_rec ++;
#line 8200
      l_dest_mcc_rec ++;
#line 8185
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 8204
    memcpy((void *)l_current_tccp, (void const   *)l_default_tcp->tccps, (unsigned long )l_tccp_size);
#line 8207
    l_tcp ++;
#line 8110
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 8211
  p_j2k->m_tcd = opj_tcd_create(1);
  }
#line 8212
  if (! p_j2k->m_tcd) {
#line 8213
    return (0);
  }
  {
#line 8216
  __cil_tmp28 = opj_tcd_init(p_j2k->m_tcd, l_image, & p_j2k->m_cp, p_j2k->m_tp);
  }
#line 8216
  if (! __cil_tmp28) {
    {
#line 8217
    opj_tcd_destroy(p_j2k->m_tcd);
#line 8218
    p_j2k->m_tcd = (struct opj_tcd *)0;
#line 8219
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n");
    }
#line 8220
    return (0);
  }
#line 8223
  return (1);
}
}
#line 8226 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) 
{ 
  opj_dec_memory_marker_handler_t *e ;

  {
#line 8230
  e = j2k_memory_marker_handler_tab;
  {
#line 8230
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8230
    if (! (e->id != 0U)) {
#line 8230
      goto while_break;
    }
#line 8231
    if (e->id == p_id) {
#line 8232
      goto while_break;
    }
#line 8230
    e ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 8235
  return (e);
}
}
#line 8238 "/root/patron/new_24/src/lib/openjp2/j2k.c"
void opj_j2k_destroy(opj_j2k_t *p_j2k ) 
{ 


  {
#line 8240
  if ((unsigned long )p_j2k == (unsigned long )((opj_j2k_t *)0)) {
#line 8241
    return;
  }
#line 8244
  if (p_j2k->m_is_decoder) {
#line 8246
    if ((unsigned long )p_j2k->m_specific_param.m_decoder.m_default_tcp != (unsigned long )((opj_tcp_t *)0)) {
      {
#line 8247
      opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 8248
      opj_free((void *)p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 8249
      p_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)0;
      }
    }
#line 8252
    if ((unsigned long )p_j2k->m_specific_param.m_decoder.m_header_data != (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 8253
      opj_free((void *)p_j2k->m_specific_param.m_decoder.m_header_data);
#line 8254
      p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)0;
#line 8255
      p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
      }
    }
  } else {
#line 8259
    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
      {
#line 8260
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 8261
      p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
      }
    }
#line 8264
    if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
      {
#line 8265
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 8266
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 8267
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
      }
    }
#line 8270
    if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
      {
#line 8271
      opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 8272
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
#line 8273
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
      }
    }
  }
  {
#line 8277
  opj_tcd_destroy(p_j2k->m_tcd);
#line 8279
  opj_j2k_cp_destroy(& p_j2k->m_cp);
#line 8280
  memset((void *)(& p_j2k->m_cp), 0, sizeof(opj_cp_t ));
#line 8282
  opj_procedure_list_destroy(p_j2k->m_procedure_list);
#line 8283
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 8285
  opj_procedure_list_destroy(p_j2k->m_validation_list);
#line 8286
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 8288
  j2k_destroy_cstr_index(p_j2k->cstr_index);
#line 8289
  p_j2k->cstr_index = (opj_codestream_index_t *)((void *)0);
#line 8291
  opj_image_destroy(p_j2k->m_private_image);
#line 8292
  p_j2k->m_private_image = (opj_image_t *)((void *)0);
#line 8294
  opj_image_destroy(p_j2k->m_output_image);
#line 8295
  p_j2k->m_output_image = (opj_image_t *)((void *)0);
#line 8297
  opj_thread_pool_destroy(p_j2k->m_tp);
#line 8298
  p_j2k->m_tp = (opj_thread_pool_t *)((void *)0);
#line 8300
  opj_free((void *)p_j2k);
  }
#line 8302
  return;
}
}
#line 8303 "/root/patron/new_24/src/lib/openjp2/j2k.c"
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) 
{ 
  OPJ_UINT32 it_tile ;

  {
#line 8305
  if (p_cstr_ind) {
#line 8307
    if (p_cstr_ind->marker) {
      {
#line 8308
      opj_free((void *)p_cstr_ind->marker);
#line 8309
      p_cstr_ind->marker = (opj_marker_info_t *)((void *)0);
      }
    }
#line 8312
    if (p_cstr_ind->tile_index) {
#line 8313
      it_tile = (OPJ_UINT32 )0;
#line 8315
      it_tile = (OPJ_UINT32 )0;
      {
#line 8315
      while (1) {
        while_continue: /* CIL Label */ ;

#line 8315
        if (! (it_tile < p_cstr_ind->nb_of_tiles)) {
#line 8315
          goto while_break;
        }
#line 8317
        if ((p_cstr_ind->tile_index + it_tile)->packet_index) {
          {
#line 8318
          opj_free((void *)(p_cstr_ind->tile_index + it_tile)->packet_index);
#line 8319
          (p_cstr_ind->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
          }
        }
#line 8322
        if ((p_cstr_ind->tile_index + it_tile)->tp_index) {
          {
#line 8323
          opj_free((void *)(p_cstr_ind->tile_index + it_tile)->tp_index);
#line 8324
          (p_cstr_ind->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
          }
        }
#line 8327
        if ((p_cstr_ind->tile_index + it_tile)->marker) {
          {
#line 8328
          opj_free((void *)(p_cstr_ind->tile_index + it_tile)->marker);
#line 8329
          (p_cstr_ind->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
          }
        }
#line 8315
        it_tile ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 8334
      opj_free((void *)p_cstr_ind->tile_index);
#line 8335
      p_cstr_ind->tile_index = (opj_tile_index_t *)((void *)0);
      }
    }
    {
#line 8338
    opj_free((void *)p_cstr_ind);
    }
  }
#line 8341
  return;
}
}
#line 8342 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) 
{ 
  OPJ_UINT32 i ;
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 i___0 ;

  {
#line 8344
  if ((unsigned long )p_tcp == (unsigned long )((opj_tcp_t *)0)) {
#line 8345
    return;
  }
#line 8348
  if ((unsigned long )p_tcp->ppt_markers != (unsigned long )((opj_ppx *)0)) {
#line 8350
    i = 0U;
    {
#line 8350
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8350
      if (! (i < p_tcp->ppt_markers_count)) {
#line 8350
        goto while_break;
      }
#line 8351
      if ((unsigned long )(p_tcp->ppt_markers + i)->m_data != (unsigned long )((void *)0)) {
        {
#line 8352
        opj_free((void *)(p_tcp->ppt_markers + i)->m_data);
        }
      }
#line 8350
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 8355
    p_tcp->ppt_markers_count = 0U;
#line 8356
    opj_free((void *)p_tcp->ppt_markers);
#line 8357
    p_tcp->ppt_markers = (opj_ppx *)((void *)0);
    }
  }
#line 8360
  if ((unsigned long )p_tcp->ppt_buffer != (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 8361
    opj_free((void *)p_tcp->ppt_buffer);
#line 8362
    p_tcp->ppt_buffer = (OPJ_BYTE *)0;
    }
  }
#line 8365
  if ((unsigned long )p_tcp->tccps != (unsigned long )((opj_tccp_t *)0)) {
    {
#line 8366
    opj_free((void *)p_tcp->tccps);
#line 8367
    p_tcp->tccps = (opj_tccp_t *)0;
    }
  }
#line 8370
  if ((unsigned long )p_tcp->m_mct_coding_matrix != (unsigned long )((OPJ_FLOAT32 *)0)) {
    {
#line 8371
    opj_free((void *)p_tcp->m_mct_coding_matrix);
#line 8372
    p_tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 8375
  if ((unsigned long )p_tcp->m_mct_decoding_matrix != (unsigned long )((OPJ_FLOAT32 *)0)) {
    {
#line 8376
    opj_free((void *)p_tcp->m_mct_decoding_matrix);
#line 8377
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 8380
  if (p_tcp->m_mcc_records) {
    {
#line 8381
    opj_free((void *)p_tcp->m_mcc_records);
#line 8382
    p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)0;
#line 8383
    p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 8384
    p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
    }
  }
#line 8387
  if (p_tcp->m_mct_records) {
#line 8388
    l_mct_data = p_tcp->m_mct_records;
#line 8391
    i___0 = (OPJ_UINT32 )0;
    {
#line 8391
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8391
      if (! (i___0 < p_tcp->m_nb_mct_records)) {
#line 8391
        goto while_break___0;
      }
#line 8392
      if (l_mct_data->m_data) {
        {
#line 8393
        opj_free((void *)l_mct_data->m_data);
#line 8394
        l_mct_data->m_data = (OPJ_BYTE *)0;
        }
      }
#line 8397
      l_mct_data ++;
#line 8391
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 8400
    opj_free((void *)p_tcp->m_mct_records);
#line 8401
    p_tcp->m_mct_records = (opj_mct_data_t *)0;
    }
  }
#line 8404
  if ((unsigned long )p_tcp->mct_norms != (unsigned long )((OPJ_FLOAT64 *)0)) {
    {
#line 8405
    opj_free((void *)p_tcp->mct_norms);
#line 8406
    p_tcp->mct_norms = (OPJ_FLOAT64 *)0;
    }
  }
  {
#line 8409
  opj_j2k_tcp_data_destroy(p_tcp);
  }
#line 8411
  return;
}
}
#line 8413 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) 
{ 


  {
#line 8415
  if (p_tcp->m_data) {
    {
#line 8416
    opj_free((void *)p_tcp->m_data);
#line 8417
    p_tcp->m_data = (OPJ_BYTE *)((void *)0);
#line 8418
    p_tcp->m_data_size = (OPJ_UINT32 )0;
    }
  }
#line 8421
  return;
}
}
#line 8422 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_cp_destroy(opj_cp_t *p_cp ) 
{ 
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_current_tile ;
  OPJ_UINT32 i ;
  OPJ_UINT32 i___0 ;

  {
#line 8425
  l_current_tile = (opj_tcp_t *)0;
#line 8427
  if ((unsigned long )p_cp == (unsigned long )((opj_cp_t *)0)) {
#line 8428
    return;
  }
#line 8430
  if ((unsigned long )p_cp->tcps != (unsigned long )((opj_tcp_t *)0)) {
#line 8432
    l_current_tile = p_cp->tcps;
#line 8433
    l_nb_tiles = p_cp->th * p_cp->tw;
#line 8435
    i = 0U;
    {
#line 8435
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8435
      if (! (i < l_nb_tiles)) {
#line 8435
        goto while_break;
      }
      {
#line 8436
      opj_j2k_tcp_destroy(l_current_tile);
#line 8437
      l_current_tile ++;
#line 8435
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 8439
    opj_free((void *)p_cp->tcps);
#line 8440
    p_cp->tcps = (opj_tcp_t *)0;
    }
  }
#line 8442
  if ((unsigned long )p_cp->ppm_markers != (unsigned long )((opj_ppx *)0)) {
#line 8444
    i___0 = 0U;
    {
#line 8444
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8444
      if (! (i___0 < p_cp->ppm_markers_count)) {
#line 8444
        goto while_break___0;
      }
#line 8445
      if ((unsigned long )(p_cp->ppm_markers + i___0)->m_data != (unsigned long )((void *)0)) {
        {
#line 8446
        opj_free((void *)(p_cp->ppm_markers + i___0)->m_data);
        }
      }
#line 8444
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 8449
    p_cp->ppm_markers_count = 0U;
#line 8450
    opj_free((void *)p_cp->ppm_markers);
#line 8451
    p_cp->ppm_markers = (opj_ppx *)((void *)0);
    }
  }
  {
#line 8453
  opj_free((void *)p_cp->ppm_buffer);
#line 8454
  p_cp->ppm_buffer = (OPJ_BYTE *)0;
#line 8455
  p_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 8457
  opj_free((void *)p_cp->comment);
#line 8458
  p_cp->comment = (OPJ_CHAR *)0;
  }
#line 8459
  if (! p_cp->m_is_decoder) {
    {
#line 8460
    opj_free((void *)p_cp->m_specific_param.m_enc.m_matrice);
#line 8461
    p_cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)0;
    }
  }
#line 8464
  return;
}
}
#line 8465 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream ,
                                                      OPJ_UINT32 tile_no , OPJ_BOOL *p_correction_needed ,
                                                      opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_header_data[10] ;
  OPJ_OFF_T l_stream_pos_backup ;
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  OPJ_UINT32 l_tile_no ;
  OPJ_UINT32 l_tot_len ;
  OPJ_UINT32 l_current_part ;
  OPJ_UINT32 l_num_parts ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_SIZE_T __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_OFF_T __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;

  {
  {
#line 8476
  *p_correction_needed = 0;
#line 8478
  __cil_tmp13 = opj_stream_has_seek(p_stream);
  }
#line 8478
  if (! __cil_tmp13) {
#line 8480
    return (1);
  }
  {
#line 8483
  l_stream_pos_backup = opj_stream_tell(p_stream);
  }
#line 8484
  if (l_stream_pos_backup == -1L) {
#line 8486
    return (1);
  }
  {
#line 8489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 8491
    __cil_tmp15 = opj_stream_read_data(p_stream, l_header_data, (OPJ_SIZE_T )2, p_manager);
    }
#line 8491
    if (__cil_tmp15 != 2UL) {
      {
#line 8493
      __cil_tmp16 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 8493
      if (! __cil_tmp16) {
#line 8494
        return (0);
      }
#line 8496
      return (1);
    }
    {
#line 8500
    opj_read_bytes_LE(l_header_data, & l_current_marker, (OPJ_UINT32 )2);
    }
#line 8502
    if (l_current_marker != 65424U) {
      {
#line 8504
      __cil_tmp17 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 8504
      if (! __cil_tmp17) {
#line 8505
        return (0);
      }
#line 8507
      return (1);
    }
    {
#line 8511
    __cil_tmp18 = opj_stream_read_data(p_stream, l_header_data, (OPJ_SIZE_T )2, p_manager);
    }
#line 8511
    if (__cil_tmp18 != 2UL) {
      {
#line 8512
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 8513
      return (0);
    }
    {
#line 8517
    opj_read_bytes_LE(l_header_data, & l_marker_size, (OPJ_UINT32 )2);
    }
#line 8520
    if (l_marker_size != 10U) {
      {
#line 8521
      opj_event_msg(p_manager, 1, "Inconsistent marker size\n");
      }
#line 8522
      return (0);
    }
    {
#line 8524
    l_marker_size -= 2U;
#line 8526
    __cil_tmp19 = opj_stream_read_data(p_stream, l_header_data, (OPJ_SIZE_T )l_marker_size,
                                       p_manager);
    }
#line 8526
    if (__cil_tmp19 != (unsigned long )l_marker_size) {
      {
#line 8528
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 8529
      return (0);
    }
    {
#line 8532
    __cil_tmp20 = opj_j2k_get_sot_values(l_header_data, l_marker_size, & l_tile_no,
                                         & l_tot_len, & l_current_part, & l_num_parts,
                                         p_manager);
    }
#line 8532
    if (! __cil_tmp20) {
#line 8534
      return (0);
    }
#line 8537
    if (l_tile_no == tile_no) {
#line 8539
      goto while_break;
    }
#line 8542
    if (l_tot_len == 0U) {
      _L: 
      {
#line 8545
      __cil_tmp21 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 8545
      if (! __cil_tmp21) {
#line 8546
        return (0);
      }
#line 8548
      return (1);
    } else
#line 8542
    if (l_tot_len < 14U) {
#line 8542
      goto _L;
    }
    {
#line 8550
    l_tot_len -= 12U;
#line 8552
    __cil_tmp22 = opj_stream_skip(p_stream, (OPJ_OFF_T )l_tot_len, p_manager);
    }
#line 8552
    if (__cil_tmp22 != (OPJ_OFF_T )l_tot_len) {
      {
#line 8555
      __cil_tmp23 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 8555
      if (! __cil_tmp23) {
#line 8556
        return (0);
      }
#line 8558
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 8563
  if (l_current_part == l_num_parts) {
#line 8564
    *p_correction_needed = 1;
  }
  {
#line 8567
  __cil_tmp24 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
  }
#line 8567
  if (! __cil_tmp24) {
#line 8568
    return (0);
  }
#line 8570
  return (1);
}
}
#line 8573 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  opj_tcp_t *l_tcp ;
  OPJ_OFF_T __cil_tmp19 ;
  OPJ_SIZE_T __cil_tmp20 ;
  OPJ_OFF_T __cil_tmp21 ;
  OPJ_BYTE *new_header_data ;
  OPJ_OFF_T __cil_tmp24 ;
  void *__cil_tmp25 ;
  OPJ_SIZE_T __cil_tmp26 ;
  OPJ_BOOL __cil_tmp27 ;
  OPJ_OFF_T __cil_tmp28 ;
  OPJ_BOOL __cil_tmp29 ;
  OPJ_UINT32 sot_pos ;
  OPJ_OFF_T __cil_tmp31 ;
  OPJ_OFF_T __cil_tmp32 ;
  OPJ_SIZE_T __cil_tmp33 ;
  OPJ_OFF_T __cil_tmp34 ;
  OPJ_BOOL __cil_tmp35 ;
  OPJ_BOOL l_correction_needed ;
  OPJ_BOOL __cil_tmp37 ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_tile_no ;
  OPJ_SIZE_T __cil_tmp40 ;
  OPJ_SIZE_T __cil_tmp41 ;
  OPJ_UINT32 l_nb_tiles___0 ;
  OPJ_BOOL __cil_tmp43 ;
  OPJ_BOOL __cil_tmp44 ;

  {
#line 8583
  l_current_marker = (OPJ_UINT32 )65424;
#line 8585
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 8586
  l_tcp = (opj_tcp_t *)((void *)0);
#line 8594
  if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 8595
    l_current_marker = (OPJ_UINT32 )65497;
  } else
#line 8598
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
#line 8599
    return (0);
  }
  {
#line 8603
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8603
    if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 8603
      if (! (l_current_marker != 65497U)) {
#line 8603
        goto while_break;
      }
    } else {
#line 8603
      goto while_break;
    }
    {
#line 8607
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8607
      if (! (l_current_marker != 65427U)) {
#line 8607
        goto while_break___0;
      }
      {
#line 8609
      __cil_tmp19 = opj_stream_get_number_byte_left(p_stream);
      }
#line 8609
      if (__cil_tmp19 == 0L) {
#line 8610
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 8611
        goto while_break___0;
      }
      {
#line 8615
      __cil_tmp20 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 8615
      if (__cil_tmp20 != 2UL) {
        {
#line 8617
        opj_event_msg(p_manager, 1, "Stream too short\n\t\0372 V");
        }
#line 8618
        return (0);
      }
      {
#line 8622
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                        (OPJ_UINT32 )2);
      }
#line 8626
      if (l_marker_size < 2U) {
        {
#line 8627
        opj_event_msg(p_manager, 1, "Inconsistent marker size\n");
        }
#line 8628
        return (0);
      }
      {
#line 8632
      __cil_tmp21 = opj_stream_get_number_byte_left(p_stream);
      }
#line 8632
      if (l_current_marker == 32896U) {
#line 8632
        if (__cil_tmp21 == 0L) {
#line 8634
          p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 8635
          goto while_break___0;
        }
      }
#line 8639
      if (p_j2k->m_specific_param.m_decoder.m_state & 16U) {
#line 8640
        p_j2k->m_specific_param.m_decoder.m_sot_length -= l_marker_size + 2U;
      }
      {
#line 8642
      l_marker_size -= 2U;
#line 8645
      l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
      }
#line 8648
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 8649
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n");
        }
#line 8651
        return (0);
      }
#line 8656
      if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
        {
#line 8657
        new_header_data = (OPJ_BYTE *)((void *)0);
#line 8660
        __cil_tmp24 = opj_stream_get_number_byte_left(p_stream);
        }
#line 8660
        if ((OPJ_OFF_T )l_marker_size > __cil_tmp24) {
          {
#line 8661
          opj_event_msg(p_manager, 1, "Marker size inconsistent with stream length\n");
          }
#line 8663
          return (0);
        }
        {
#line 8665
        __cil_tmp25 = opj_realloc((void *)p_j2k->m_specific_param.m_decoder.m_header_data,
                                  (size_t )l_marker_size);
#line 8665
        new_header_data = (OPJ_BYTE *)__cil_tmp25;
        }
#line 8667
        if (! new_header_data) {
          {
#line 8668
          opj_free((void *)p_j2k->m_specific_param.m_decoder.m_header_data);
#line 8669
          p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 8670
          p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 8671
          opj_event_msg(p_manager, 1, "Not enough memory to read header\n&\0372 V");
          }
#line 8672
          return (0);
        }
#line 8674
        p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 8675
        p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
      }
      {
#line 8679
      __cil_tmp26 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )l_marker_size, p_manager);
      }
#line 8679
      if (__cil_tmp26 != (unsigned long )l_marker_size) {
        {
#line 8682
        opj_event_msg(p_manager, 1, "Stream too short\n-\0372 V");
        }
#line 8683
        return (0);
      }
#line 8686
      if (! l_marker_handler->handler) {
        {
#line 8688
        opj_event_msg(p_manager, 1, "Not sure how that happened.\n V");
        }
#line 8689
        return (0);
      }
      {
#line 8692
      __cil_tmp27 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                   l_marker_size, p_manager);
      }
#line 8692
      if (! __cil_tmp27) {
        {
#line 8694
        opj_event_msg(p_manager, 1, "Fail to read the current marker segment (%#x)\n",
                      l_current_marker);
        }
#line 8696
        return (0);
      }
      {
#line 8700
      __cil_tmp28 = opj_stream_tell(p_stream);
#line 8700
      __cil_tmp29 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, p_j2k->cstr_index,
                                         l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp28 - l_marker_size) - 4U),
                                         l_marker_size + 4U);
      }
#line 8700
      if (0 == __cil_tmp29) {
        {
#line 8705
        opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\n");
        }
#line 8706
        return (0);
      }
#line 8710
      if (l_marker_handler->id == 65424U) {
        {
#line 8711
        __cil_tmp31 = opj_stream_tell(p_stream);
#line 8711
        sot_pos = ((OPJ_UINT32 )__cil_tmp31 - l_marker_size) - 4U;
        }
#line 8713
        if ((long )sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos) {
#line 8714
          p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )sot_pos;
        }
      }
#line 8718
      if (p_j2k->m_specific_param.m_decoder.m_skip_data) {
        {
#line 8720
        __cil_tmp32 = opj_stream_skip(p_stream, (OPJ_OFF_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                      p_manager);
        }
#line 8720
        if (__cil_tmp32 != (long )p_j2k->m_specific_param.m_decoder.m_sot_length) {
          {
#line 8722
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 8723
          return (0);
        }
#line 8725
        l_current_marker = (OPJ_UINT32 )65427;
      } else {
        {
#line 8728
        __cil_tmp33 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager);
        }
#line 8728
        if (__cil_tmp33 != 2UL) {
          {
#line 8730
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 8731
          return (0);
        }
        {
#line 8734
        opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                          (OPJ_UINT32 )2);
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 8738
    __cil_tmp34 = opj_stream_get_number_byte_left(p_stream);
    }
#line 8738
    if (__cil_tmp34 == 0L) {
#line 8738
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 8740
        goto while_break;
      }
    }
#line 8744
    if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {
      {
#line 8746
      __cil_tmp35 = opj_j2k_read_sod(p_j2k, p_stream, p_manager);
      }
#line 8746
      if (! __cil_tmp35) {
#line 8747
        return (0);
      }
#line 8749
      if ((int )p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 8749
        if (! p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked) {
          {
#line 8754
          p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = (OPJ_BITFIELD )1;
#line 8755
          __cil_tmp37 = opj_j2k_need_nb_tile_parts_correction(p_stream, p_j2k->m_current_tile_number,
                                                              & l_correction_needed,
                                                              p_manager);
          }
#line 8755
          if (! __cil_tmp37) {
            {
#line 8757
            opj_event_msg(p_manager, 1, "opj_j2k_apply_nb_tile_parts_correction error\n");
            }
#line 8759
            return (0);
          }
#line 8761
          if (l_correction_needed) {
#line 8762
            l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 8765
            p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 8766
            p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction = (OPJ_BITFIELD )1;
#line 8768
            l_tile_no = 0U;
            {
#line 8768
            while (1) {
              while_continue___1: /* CIL Label */ ;

#line 8768
              if (! (l_tile_no < l_nb_tiles)) {
#line 8768
                goto while_break___1;
              }
#line 8769
              if ((p_j2k->m_cp.tcps + l_tile_no)->m_nb_tile_parts != 0U) {
#line 8770
                ((p_j2k->m_cp.tcps + l_tile_no)->m_nb_tile_parts) ++;
              }
#line 8768
              l_tile_no ++;
            }
            while_break___5: /* CIL Label */ ;
            }
            while_break___1: 
            {
#line 8773
            opj_event_msg(p_manager, 2, "Non conformant codestream TPsot==TNsot.\n\220");
            }
          }
        }
      }
#line 8777
      if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
        {
#line 8779
        __cil_tmp40 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager);
        }
#line 8779
        if (__cil_tmp40 != 2UL) {
          {
#line 8781
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 8782
          return (0);
        }
        {
#line 8786
        opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                          (OPJ_UINT32 )2);
        }
      }
    } else {
      {
#line 8791
      p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_BITFIELD )0;
#line 8792
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 8793
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
#line 8796
      __cil_tmp41 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 8796
      if (__cil_tmp41 != 2UL) {
        {
#line 8798
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 8799
        return (0);
      }
      {
#line 8803
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                        (OPJ_UINT32 )2);
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 8809
  if (l_current_marker == 65497U) {
#line 8810
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
  }
#line 8814
  if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 8815
    l_nb_tiles___0 = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 8816
    l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
    {
#line 8818
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 8818
      if ((unsigned long )l_tcp->m_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 8818
        if (! (p_j2k->m_current_tile_number < l_nb_tiles___0)) {
#line 8818
          goto while_break___2;
        }
      } else {
#line 8818
        goto while_break___2;
      }
#line 8819
      (p_j2k->m_current_tile_number) ++;
#line 8820
      l_tcp ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
#line 8823
    if (p_j2k->m_current_tile_number == l_nb_tiles___0) {
#line 8824
      *p_go_on = 0;
#line 8825
      return (1);
    }
  }
  {
#line 8829
  __cil_tmp43 = opj_j2k_merge_ppt(p_j2k->m_cp.tcps + p_j2k->m_current_tile_number,
                                  p_manager);
  }
#line 8829
  if (! __cil_tmp43) {
    {
#line 8831
    opj_event_msg(p_manager, 1, "Failed to merge PPT data\n");
    }
#line 8832
    return (0);
  }
  {
#line 8835
  __cil_tmp44 = opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,
                                         p_manager);
  }
#line 8835
  if (! __cil_tmp44) {
    {
#line 8837
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n");
    }
#line 8838
    return (0);
  }
  {
#line 8841
  opj_event_msg(p_manager, 4, "Header of tile %d / %d has been read.\n", p_j2k->m_current_tile_number + 1U,
                p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 8844
  *p_tile_index = p_j2k->m_current_tile_number;
#line 8845
  *p_go_on = 1;
  }
#line 8846
  if (p_data_size) {
    {
#line 8849
    *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd, 0);
    }
#line 8850
    if (*p_data_size == 4294967295U) {
#line 8851
      return (0);
    }
  }
#line 8854
  *p_tile_x0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x0;
#line 8855
  *p_tile_y0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y0;
#line 8856
  *p_tile_x1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x1;
#line 8857
  *p_tile_y1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y1;
#line 8858
  *p_nb_comps = (((p_j2k->m_tcd)->tcd_image)->tiles)->numcomps;
#line 8860
  p_j2k->m_specific_param.m_decoder.m_state |= 128U;
#line 8862
  return (1);
}
}
#line 8865 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_BYTE l_data[2] ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image_for_bounds ;
  opj_image_t *tmp___2 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_OFF_T __cil_tmp17 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_OFF_T __cil_tmp19 ;

  {
#line 8882
  if (! (p_j2k->m_specific_param.m_decoder.m_state & 128U)) {
#line 8884
    return (0);
  } else
#line 8882
  if (p_tile_index != p_j2k->m_current_tile_number) {
#line 8884
    return (0);
  }
#line 8887
  l_tcp = p_j2k->m_cp.tcps + p_tile_index;
#line 8888
  if (! l_tcp->m_data) {
    {
#line 8889
    opj_j2k_tcp_destroy(l_tcp);
    }
#line 8890
    return (0);
  }
#line 8898
  if (p_j2k->m_output_image) {
#line 8898
    tmp___2 = p_j2k->m_output_image;
  } else {
#line 8898
    tmp___2 = p_j2k->m_private_image;
  }
  {
#line 8898
  l_image_for_bounds = tmp___2;
#line 8900
  __cil_tmp15 = opj_tcd_decode_tile(p_j2k->m_tcd, l_image_for_bounds->x0, l_image_for_bounds->y0,
                                    l_image_for_bounds->x1, l_image_for_bounds->y1,
                                    l_tcp->m_data, l_tcp->m_data_size, p_tile_index,
                                    p_j2k->cstr_index, p_manager);
  }
#line 8900
  if (! __cil_tmp15) {
    {
#line 8909
    opj_j2k_tcp_destroy(l_tcp);
#line 8910
    p_j2k->m_specific_param.m_decoder.m_state |= 32768U;
#line 8911
    opj_event_msg(p_manager, 1, "Failed to decode.\n");
    }
#line 8912
    return (0);
  }
#line 8918
  if ((unsigned long )p_data != (unsigned long )((void *)0)) {
    {
#line 8919
    __cil_tmp16 = opj_tcd_update_tile_data(p_j2k->m_tcd, p_data, p_data_size);
    }
#line 8919
    if (! __cil_tmp16) {
#line 8920
      return (0);
    }
    {
#line 8927
    opj_j2k_tcp_data_destroy(l_tcp);
    }
  }
  {
#line 8930
  p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 8931
  p_j2k->m_specific_param.m_decoder.m_state &= 4294967167U;
#line 8933
  __cil_tmp17 = opj_stream_get_number_byte_left(p_stream);
  }
#line 8933
  if (__cil_tmp17 == 0L) {
#line 8933
    if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 8935
      return (1);
    }
  }
#line 8938
  if (p_j2k->m_specific_param.m_decoder.m_state != 256U) {
    {
#line 8939
    __cil_tmp18 = opj_stream_read_data(p_stream, l_data, (OPJ_SIZE_T )2, p_manager);
    }
#line 8939
    if (__cil_tmp18 != 2UL) {
      {
#line 8940
      opj_event_msg(p_manager, 1, "Stream too short\n\200\0372 V");
      }
#line 8941
      return (0);
    }
    {
#line 8944
    opj_read_bytes_LE(l_data, & l_current_marker, (OPJ_UINT32 )2);
    }
#line 8946
    if (l_current_marker == 65497U) {
#line 8947
      p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 8948
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    } else
#line 8949
    if (l_current_marker != 65424U) {
      {
#line 8950
      __cil_tmp19 = opj_stream_get_number_byte_left(p_stream);
      }
#line 8950
      if (__cil_tmp19 == 0L) {
        {
#line 8951
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 8952
        opj_event_msg(p_manager, 2, "Stream does not end with EOC\n");
        }
#line 8953
        return (1);
      }
      {
#line 8955
      opj_event_msg(p_manager, 1, "Stream too short, expected SOT\n");
      }
#line 8956
      return (0);
    }
  }
#line 8960
  return (1);
}
}
#line 8963 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , opj_image_t *p_output_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_width_src ;
  OPJ_UINT32 l_height_src ;
  OPJ_UINT32 l_width_dest ;
  OPJ_UINT32 l_height_dest ;
  OPJ_INT32 l_offset_x0_src ;
  OPJ_INT32 l_offset_y0_src ;
  OPJ_INT32 l_offset_x1_src ;
  OPJ_INT32 l_offset_y1_src ;
  OPJ_SIZE_T l_start_offset_src ;
  OPJ_UINT32 l_start_x_dest ;
  OPJ_UINT32 l_start_y_dest ;
  OPJ_UINT32 l_x0_dest ;
  OPJ_UINT32 l_y0_dest ;
  OPJ_UINT32 l_x1_dest ;
  OPJ_UINT32 l_y1_dest ;
  OPJ_SIZE_T l_start_offset_dest ;
  opj_image_comp_t *l_img_comp_src ;
  opj_image_comp_t *l_img_comp_dest ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_t *l_image_src ;
  OPJ_INT32 *l_dest_ptr ;
  OPJ_INT32 res_x0 ;
  OPJ_INT32 res_x1 ;
  OPJ_INT32 res_y0 ;
  OPJ_INT32 res_y1 ;
  OPJ_UINT32 src_data_stride ;
  OPJ_INT32 *p_src_data ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_resolution_t *l_res___0 ;
  OPJ_SIZE_T l_width ;
  OPJ_SIZE_T l_height ;
  void *__cil_tmp40 ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_UINT32 __cil_tmp42 ;

  {
#line 8975
  l_img_comp_src = (opj_image_comp_t *)0;
#line 8976
  l_img_comp_dest = (opj_image_comp_t *)0;
#line 8978
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 8979
  l_image_src = (opj_image_t *)0;
#line 8982
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 8983
  l_image_src = p_tcd->image;
#line 8984
  l_img_comp_src = l_image_src->comps;
#line 8986
  l_img_comp_dest = p_output_image->comps;
#line 8988
  i = (OPJ_UINT32 )0;
  {
#line 8988
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 8988
    if (! (i < l_image_src->numcomps)) {
#line 8988
      goto while_break;
    }
#line 8995
    l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;
#line 8997
    if (p_tcd->whole_tile_decoding) {
#line 8998
      l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;
#line 9000
      res_x0 = l_res->x0;
#line 9001
      res_y0 = l_res->y0;
#line 9002
      res_x1 = l_res->x1;
#line 9003
      res_y1 = l_res->y1;
#line 9004
      src_data_stride = (OPJ_UINT32 )((l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x1 - (l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x0);
#line 9007
      p_src_data = l_tilec->data;
    } else {
#line 9009
      l_res___0 = l_tilec->resolutions + l_img_comp_src->resno_decoded;
#line 9011
      res_x0 = (OPJ_INT32 )l_res___0->win_x0;
#line 9012
      res_y0 = (OPJ_INT32 )l_res___0->win_y0;
#line 9013
      res_x1 = (OPJ_INT32 )l_res___0->win_x1;
#line 9014
      res_y1 = (OPJ_INT32 )l_res___0->win_y1;
#line 9015
      src_data_stride = l_res___0->win_x1 - l_res___0->win_x0;
#line 9016
      p_src_data = l_tilec->data_win;
    }
    {
#line 9019
    l_width_src = (OPJ_UINT32 )(res_x1 - res_x0);
#line 9020
    l_height_src = (OPJ_UINT32 )(res_y1 - res_y0);
#line 9031
    l_x0_dest = opj_uint_ceildivpow2(l_img_comp_dest->x0, l_img_comp_dest->factor);
#line 9032
    l_y0_dest = opj_uint_ceildivpow2(l_img_comp_dest->y0, l_img_comp_dest->factor);
#line 9033
    l_x1_dest = l_x0_dest + l_img_comp_dest->w;
#line 9035
    l_y1_dest = l_y0_dest + l_img_comp_dest->h;
    }
#line 9051
    if (l_x0_dest < (OPJ_UINT32 )res_x0) {
#line 9052
      l_start_x_dest = (OPJ_UINT32 )res_x0 - l_x0_dest;
#line 9053
      l_offset_x0_src = 0;
#line 9055
      if (l_x1_dest >= (OPJ_UINT32 )res_x1) {
#line 9056
        l_width_dest = l_width_src;
#line 9057
        l_offset_x1_src = 0;
      } else {
#line 9059
        l_width_dest = l_x1_dest - (OPJ_UINT32 )res_x0;
#line 9060
        l_offset_x1_src = (OPJ_INT32 )(l_width_src - l_width_dest);
      }
    } else {
#line 9063
      l_start_x_dest = 0U;
#line 9064
      l_offset_x0_src = (OPJ_INT32 )l_x0_dest - res_x0;
#line 9066
      if (l_x1_dest >= (OPJ_UINT32 )res_x1) {
#line 9067
        l_width_dest = l_width_src - (OPJ_UINT32 )l_offset_x0_src;
#line 9068
        l_offset_x1_src = 0;
      } else {
#line 9070
        l_width_dest = l_img_comp_dest->w;
#line 9071
        l_offset_x1_src = res_x1 - (OPJ_INT32 )l_x1_dest;
      }
    }
#line 9075
    if (l_y0_dest < (OPJ_UINT32 )res_y0) {
#line 9076
      l_start_y_dest = (OPJ_UINT32 )res_y0 - l_y0_dest;
#line 9077
      l_offset_y0_src = 0;
#line 9079
      if (l_y1_dest >= (OPJ_UINT32 )res_y1) {
#line 9080
        l_height_dest = l_height_src;
#line 9081
        l_offset_y1_src = 0;
      } else {
#line 9083
        l_height_dest = l_y1_dest - (OPJ_UINT32 )res_y0;
#line 9084
        l_offset_y1_src = (OPJ_INT32 )(l_height_src - l_height_dest);
      }
    } else {
#line 9087
      l_start_y_dest = 0U;
#line 9088
      l_offset_y0_src = (OPJ_INT32 )l_y0_dest - res_y0;
#line 9090
      if (l_y1_dest >= (OPJ_UINT32 )res_y1) {
#line 9091
        l_height_dest = l_height_src - (OPJ_UINT32 )l_offset_y0_src;
#line 9092
        l_offset_y1_src = 0;
      } else {
#line 9094
        l_height_dest = l_img_comp_dest->h;
#line 9095
        l_offset_y1_src = res_y1 - (OPJ_INT32 )l_y1_dest;
      }
    }
#line 9099
    if (l_offset_x0_src < 0) {
#line 9101
      return (0);
    } else
#line 9099
    if (l_offset_y0_src < 0) {
#line 9101
      return (0);
    } else
#line 9099
    if (l_offset_x1_src < 0) {
#line 9101
      return (0);
    } else
#line 9099
    if (l_offset_y1_src < 0) {
#line 9101
      return (0);
    }
#line 9104
    if ((OPJ_INT32 )l_width_dest < 0) {
#line 9105
      return (0);
    } else
#line 9104
    if ((OPJ_INT32 )l_height_dest < 0) {
#line 9105
      return (0);
    }
#line 9110
    l_start_offset_src = (OPJ_SIZE_T )l_offset_x0_src + (OPJ_SIZE_T )l_offset_y0_src * (OPJ_SIZE_T )src_data_stride;
#line 9114
    l_start_offset_dest = (OPJ_SIZE_T )l_start_x_dest + (OPJ_SIZE_T )l_start_y_dest * (OPJ_SIZE_T )l_img_comp_dest->w;
#line 9118
    if ((unsigned long )l_img_comp_dest->data == (unsigned long )((void *)0)) {
#line 9118
      if (l_start_offset_src == 0UL) {
#line 9118
        if (l_start_offset_dest == 0UL) {
#line 9118
          if (l_width_dest == l_img_comp_dest->w) {
#line 9118
            if (l_height_dest == l_img_comp_dest->h) {
#line 9124
              if (p_tcd->whole_tile_decoding) {
#line 9125
                l_img_comp_dest->data = l_tilec->data;
#line 9126
                l_tilec->data = (OPJ_INT32 *)((void *)0);
              } else {
#line 9128
                l_img_comp_dest->data = l_tilec->data_win;
#line 9129
                l_tilec->data_win = (OPJ_INT32 *)((void *)0);
              }
#line 9131
              goto while_continue;
            } else {
#line 9118
              goto _L;
            }
          } else {
#line 9118
            goto _L;
          }
        } else {
#line 9118
          goto _L;
        }
      } else {
#line 9118
        goto _L;
      }
    } else
    _L: 
#line 9132
    if ((unsigned long )l_img_comp_dest->data == (unsigned long )((void *)0)) {
#line 9133
      l_width = (OPJ_SIZE_T )l_img_comp_dest->w;
#line 9134
      l_height = (OPJ_SIZE_T )l_img_comp_dest->h;
#line 9136
      if (l_height == 0UL) {
#line 9139
        return (0);
      } else
#line 9136
      if (l_width > 0xffffffffffffffffUL / l_height) {
#line 9139
        return (0);
      } else
#line 9136
      if (l_width * l_height > 0xffffffffffffffffUL / sizeof(OPJ_INT32 )) {
#line 9139
        return (0);
      }
      {
#line 9141
      __cil_tmp40 = opj_image_data_alloc((l_width * l_height) * sizeof(OPJ_INT32 ));
#line 9141
      l_img_comp_dest->data = (OPJ_INT32 *)__cil_tmp40;
      }
#line 9143
      if (! l_img_comp_dest->data) {
#line 9144
        return (0);
      }
#line 9147
      if (l_img_comp_dest->w != l_width_dest) {
        {
#line 9149
        memset((void *)l_img_comp_dest->data, 0, ((OPJ_SIZE_T )l_img_comp_dest->w * (unsigned long )l_img_comp_dest->h) * sizeof(OPJ_INT32 ));
        }
      } else
#line 9147
      if (l_img_comp_dest->h != l_height_dest) {
        {
#line 9149
        memset((void *)l_img_comp_dest->data, 0, ((OPJ_SIZE_T )l_img_comp_dest->w * (unsigned long )l_img_comp_dest->h) * sizeof(OPJ_INT32 ));
        }
      }
    }
#line 9155
    l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;
#line 9158
    l_src_ptr = p_src_data;
#line 9159
    l_src_ptr += l_start_offset_src;
#line 9161
    j = (OPJ_UINT32 )0;
    {
#line 9161
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 9161
      if (! (j < l_height_dest)) {
#line 9161
        goto while_break___0;
      }
      {
#line 9162
      memcpy((void *)l_dest_ptr, (void const   *)l_src_ptr, (unsigned long )l_width_dest * sizeof(OPJ_INT32 ));
#line 9163
      l_dest_ptr += l_img_comp_dest->w;
#line 9164
      l_src_ptr += src_data_stride;
#line 9161
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 8989
    l_tilec ++;
#line 8989
    l_img_comp_src ++;
#line 8989
    l_img_comp_dest ++;
#line 8989
    __cil_tmp42 = i;
#line 8989
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 9171
  return (1);
}
}
#line 9174 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_image_dimensions(opj_image_t *p_image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 l_h ;
  OPJ_INT32 l_w ;
  OPJ_INT32 __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;

  {
#line 9179
  l_img_comp = (opj_image_comp_t *)((void *)0);
#line 9181
  l_img_comp = p_image->comps;
#line 9182
  it_comp = (OPJ_UINT32 )0;
  {
#line 9182
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9182
    if (! (it_comp < p_image->numcomps)) {
#line 9182
      goto while_break;
    }
    {
#line 9185
    __cil_tmp9 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 9185
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp9;
#line 9187
    __cil_tmp10 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 9187
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp10;
#line 9189
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 9190
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 9192
    __cil_tmp14 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
#line 9192
    __cil_tmp13 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 9192
    l_w = __cil_tmp13 - __cil_tmp14;
    }
#line 9194
    if (l_w < 0) {
      {
#line 9195
      opj_event_msg(p_manager, 1, "Size x of the decoded component image is incorrect (comp[%d].w=%d).\n V",
                    it_comp, l_w);
      }
#line 9198
      return (0);
    }
    {
#line 9200
    l_img_comp->w = (OPJ_UINT32 )l_w;
#line 9202
    __cil_tmp16 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
#line 9202
    __cil_tmp15 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 9202
    l_h = __cil_tmp15 - __cil_tmp16;
    }
#line 9204
    if (l_h < 0) {
      {
#line 9205
      opj_event_msg(p_manager, 1, "Size y of the decoded component image is incorrect (comp[%d].h=%d).\n V",
                    it_comp, l_h);
      }
#line 9208
      return (0);
    }
#line 9210
    l_img_comp->h = (OPJ_UINT32 )l_h;
#line 9212
    l_img_comp ++;
#line 9182
    it_comp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 9215
  return (1);
}
}
#line 9219 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  OPJ_BOOL ret ;
  OPJ_UINT32 it_comp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;

  {
#line 9225
  l_cp = & p_j2k->m_cp;
#line 9226
  l_image = p_j2k->m_private_image;
#line 9230
  if ((unsigned long )(& (p_j2k->m_cp.tcps + 0)->m_data) != (unsigned long )((void *)0)) {
#line 9230
    if (p_j2k->m_cp.tw == 1U) {
#line 9230
      if (! (p_j2k->m_cp.th == 1U)) {
#line 9230
        goto _L;
      }
    } else {
#line 9230
      goto _L;
    }
  } else
  _L: 
#line 9236
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
    {
#line 9237
    opj_event_msg(p_manager, 1, "Need to decode the main header before begin to decode the remaining codestream.\n\220");
    }
#line 9239
    return (0);
  }
#line 9244
  it_comp = (OPJ_UINT32 )0;
  {
#line 9244
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9244
    if (! (it_comp < p_image->numcomps)) {
#line 9244
      goto while_break;
    }
#line 9245
    (p_image->comps + it_comp)->factor = p_j2k->m_cp.m_specific_param.m_dec.m_reduce;
#line 9244
    it_comp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 9248
  if (! p_start_x) {
#line 9248
    if (! p_start_y) {
#line 9248
      if (! p_end_x) {
#line 9248
        if (! p_end_y) {
          {
#line 9249
          opj_event_msg(p_manager, 4, "No decoded area parameters, set the decoded area to the whole image\n V");
#line 9252
          p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 9253
          p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 9254
          p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 9255
          p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
#line 9257
          p_image->x0 = l_image->x0;
#line 9258
          p_image->y0 = l_image->y0;
#line 9259
          p_image->x1 = l_image->x1;
#line 9260
          p_image->y1 = l_image->y1;
#line 9262
          __cil_tmp12 = opj_j2k_update_image_dimensions(p_image, p_manager);
          }
#line 9262
          return (__cil_tmp12);
        }
      }
    }
  }
#line 9269
  if (p_start_x < 0) {
    {
#line 9270
    opj_event_msg(p_manager, 1, "Left position of the decoded area (region_x0=%d) should be >= 0.\nH 2 V",
                  p_start_x);
    }
#line 9273
    return (0);
  } else
#line 9274
  if ((OPJ_UINT32 )p_start_x > l_image->x1) {
    {
#line 9275
    opj_event_msg(p_manager, 1, "Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\n",
                  p_start_x, l_image->x1);
    }
#line 9278
    return (0);
  } else
#line 9279
  if ((OPJ_UINT32 )p_start_x < l_image->x0) {
    {
#line 9280
    opj_event_msg(p_manager, 2, "Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\n",
                  p_start_x, l_image->x0);
#line 9283
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 9284
    p_image->x0 = l_image->x0;
    }
  } else {
#line 9286
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32 )p_start_x - l_cp->tx0) / l_cp->tdx;
#line 9288
    p_image->x0 = (OPJ_UINT32 )p_start_x;
  }
#line 9292
  if (p_start_x < 0) {
    {
#line 9293
    opj_event_msg(p_manager, 1, "Up position of the decoded area (region_y0=%d) should be >= 0.\n",
                  p_start_y);
    }
#line 9296
    return (0);
  } else
#line 9297
  if ((OPJ_UINT32 )p_start_y > l_image->y1) {
    {
#line 9298
    opj_event_msg(p_manager, 1, "Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\n",
                  p_start_y, l_image->y1);
    }
#line 9301
    return (0);
  } else
#line 9302
  if ((OPJ_UINT32 )p_start_y < l_image->y0) {
    {
#line 9303
    opj_event_msg(p_manager, 2, "Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\nV",
                  p_start_y, l_image->y0);
#line 9306
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 9307
    p_image->y0 = l_image->y0;
    }
  } else {
#line 9309
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32 )p_start_y - l_cp->ty0) / l_cp->tdy;
#line 9311
    p_image->y0 = (OPJ_UINT32 )p_start_y;
  }
#line 9315
  if (p_end_x <= 0) {
    {
#line 9316
    opj_event_msg(p_manager, 1, "Right position of the decoded area (region_x1=%d) should be > 0.\n~ 2 V",
                  p_end_x);
    }
#line 9319
    return (0);
  } else
#line 9320
  if ((OPJ_UINT32 )p_end_x < l_image->x0) {
    {
#line 9321
    opj_event_msg(p_manager, 1, "Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\n\230\001",
                  p_end_x, l_image->x0);
    }
#line 9324
    return (0);
  } else
#line 9325
  if ((OPJ_UINT32 )p_end_x > l_image->x1) {
    {
#line 9326
    opj_event_msg(p_manager, 2, "Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\n",
                  p_end_x, l_image->x1);
#line 9329
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 9330
    p_image->x1 = l_image->x1;
    }
  } else {
    {
#line 9332
    __cil_tmp13 = opj_int_ceildiv(p_end_x - (OPJ_INT32 )l_cp->tx0, (OPJ_INT32 )l_cp->tdx);
#line 9332
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp13;
#line 9334
    p_image->x1 = (OPJ_UINT32 )p_end_x;
    }
  }
#line 9338
  if (p_end_y <= 0) {
    {
#line 9339
    opj_event_msg(p_manager, 1, "Bottom position of the decoded area (region_y1=%d) should be > 0.\n 2 V",
                  p_end_y);
    }
#line 9342
    return (0);
  } else
#line 9343
  if ((OPJ_UINT32 )p_end_y < l_image->y0) {
    {
#line 9344
    opj_event_msg(p_manager, 1, "Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\n",
                  p_end_y, l_image->y0);
    }
#line 9347
    return (0);
  }
#line 9349
  if ((OPJ_UINT32 )p_end_y > l_image->y1) {
    {
#line 9350
    opj_event_msg(p_manager, 2, "Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\n\230\001",
                  p_end_y, l_image->y1);
#line 9353
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
#line 9354
    p_image->y1 = l_image->y1;
    }
  } else {
    {
#line 9356
    __cil_tmp14 = opj_int_ceildiv(p_end_y - (OPJ_INT32 )l_cp->ty0, (OPJ_INT32 )l_cp->tdy);
#line 9356
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp14;
#line 9358
    p_image->y1 = (OPJ_UINT32 )p_end_y;
    }
  }
  {
#line 9362
  p_j2k->m_specific_param.m_decoder.m_discard_tiles = (OPJ_BITFIELD )1;
#line 9364
  ret = opj_j2k_update_image_dimensions(p_image, p_manager);
  }
#line 9366
  if (ret) {
    {
#line 9367
    opj_event_msg(p_manager, 4, "Setting decoding area to %d,%d,%d,%d\nV", p_image->x0,
                  p_image->y0, p_image->x1, p_image->y1);
    }
  }
#line 9371
  return (ret);
}
}
#line 9374 "/root/patron/new_24/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_decompress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  int __cil_tmp8 ;
  opj_thread_pool_t *__cil_tmp9 ;

  {
  {
#line 9376
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_j2k_t ));
#line 9376
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 9377
  if (! l_j2k) {
#line 9378
    return ((opj_j2k_t *)0);
  }
  {
#line 9381
  l_j2k->m_is_decoder = 1;
#line 9382
  l_j2k->m_cp.m_is_decoder = (OPJ_BITFIELD )1;
#line 9385
  l_j2k->m_cp.allow_different_bit_depth_sign = (OPJ_BITFIELD )1;
#line 9391
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_tcp_t ));
#line 9391
  l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)__cil_tmp3;
  }
#line 9393
  if (! l_j2k->m_specific_param.m_decoder.m_default_tcp) {
    {
#line 9394
    opj_j2k_destroy(l_j2k);
    }
#line 9395
    return ((opj_j2k_t *)0);
  }
  {
#line 9398
  __cil_tmp4 = opj_calloc((size_t )1, (size_t )1000);
#line 9398
  l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)__cil_tmp4;
  }
#line 9400
  if (! l_j2k->m_specific_param.m_decoder.m_header_data) {
    {
#line 9401
    opj_j2k_destroy(l_j2k);
    }
#line 9402
    return ((opj_j2k_t *)0);
  }
  {
#line 9405
  l_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )1000;
#line 9408
  l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = -1;
#line 9410
  l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )0;
#line 9413
  l_j2k->cstr_index = opj_j2k_create_cstr_index();
  }
#line 9414
  if (! l_j2k->cstr_index) {
    {
#line 9415
    opj_j2k_destroy(l_j2k);
    }
#line 9416
    return ((opj_j2k_t *)0);
  }
  {
#line 9420
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 9421
  if (! l_j2k->m_validation_list) {
    {
#line 9422
    opj_j2k_destroy(l_j2k);
    }
#line 9423
    return ((opj_j2k_t *)0);
  }
  {
#line 9427
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 9428
  if (! l_j2k->m_procedure_list) {
    {
#line 9429
    opj_j2k_destroy(l_j2k);
    }
#line 9430
    return ((opj_j2k_t *)0);
  }
  {
#line 9433
  __cil_tmp8 = opj_j2k_get_default_thread_count();
#line 9433
  __cil_tmp9 = opj_thread_pool_create(__cil_tmp8);
#line 9433
  l_j2k->m_tp = __cil_tmp9;
  }
#line 9434
  if (! l_j2k->m_tp) {
    {
#line 9435
    l_j2k->m_tp = opj_thread_pool_create(0);
    }
  }
#line 9437
  if (! l_j2k->m_tp) {
    {
#line 9438
    opj_j2k_destroy(l_j2k);
    }
#line 9439
    return ((opj_j2k_t *)((void *)0));
  }
#line 9442
  return (l_j2k);
}
}
#line 9445 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static opj_codestream_index_t *opj_j2k_create_cstr_index(void) 
{ 
  opj_codestream_index_t *cstr_index ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 9447
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_codestream_index_t ));
#line 9447
  cstr_index = (opj_codestream_index_t *)__cil_tmp2;
  }
#line 9449
  if (! cstr_index) {
#line 9450
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 9453
  cstr_index->maxmarknum = (OPJ_UINT32 )100;
#line 9454
  cstr_index->marknum = (OPJ_UINT32 )0;
#line 9455
  __cil_tmp3 = opj_calloc((size_t )cstr_index->maxmarknum, sizeof(opj_marker_info_t ));
#line 9455
  cstr_index->marker = (opj_marker_info_t *)__cil_tmp3;
  }
#line 9457
  if (! cstr_index->marker) {
    {
#line 9458
    opj_free((void *)cstr_index);
    }
#line 9459
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 9462
  cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
#line 9464
  return (cstr_index);
}
}
#line 9467 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                               OPJ_UINT32 p_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 9471
  l_cp = (opj_cp_t *)0;
#line 9472
  l_tcp = (opj_tcp_t *)0;
#line 9473
  l_tccp = (opj_tccp_t *)0;
#line 9478
  l_cp = & p_j2k->m_cp;
#line 9479
  l_tcp = l_cp->tcps + p_tile_no;
#line 9480
  l_tccp = l_tcp->tccps + p_comp_no;
#line 9486
  if (l_tccp->csty & 1U) {
#line 9487
    return (5U + l_tccp->numresolutions);
  } else {
#line 9489
    return ((OPJ_UINT32 )5);
  }
}
}
#line 9493 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                            OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp0 ;
  opj_tccp_t *l_tccp1 ;

  {
#line 9497
  l_cp = (opj_cp_t *)((void *)0);
#line 9498
  l_tcp = (opj_tcp_t *)((void *)0);
#line 9499
  l_tccp0 = (opj_tccp_t *)((void *)0);
#line 9500
  l_tccp1 = (opj_tccp_t *)((void *)0);
#line 9505
  l_cp = & p_j2k->m_cp;
#line 9506
  l_tcp = l_cp->tcps + p_tile_no;
#line 9507
  l_tccp0 = l_tcp->tccps + p_first_comp_no;
#line 9508
  l_tccp1 = l_tcp->tccps + p_second_comp_no;
#line 9510
  if (l_tccp0->numresolutions != l_tccp1->numresolutions) {
#line 9511
    return (0);
  }
#line 9513
  if (l_tccp0->cblkw != l_tccp1->cblkw) {
#line 9514
    return (0);
  }
#line 9516
  if (l_tccp0->cblkh != l_tccp1->cblkh) {
#line 9517
    return (0);
  }
#line 9519
  if (l_tccp0->cblksty != l_tccp1->cblksty) {
#line 9520
    return (0);
  }
#line 9522
  if (l_tccp0->qmfbid != l_tccp1->qmfbid) {
#line 9523
    return (0);
  }
#line 9525
  if ((l_tccp0->csty & 1U) != (l_tccp1->csty & 1U)) {
#line 9526
    return (0);
  }
#line 9529
  i = 0U;
  {
#line 9529
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9529
    if (! (i < l_tccp0->numresolutions)) {
#line 9529
      goto while_break;
    }
#line 9530
    if (l_tccp0->prcw[i] != l_tccp1->prcw[i]) {
#line 9531
      return (0);
    }
#line 9533
    if (l_tccp0->prch[i] != l_tccp1->prch[i]) {
#line 9534
      return (0);
    }
#line 9529
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 9537
  return (1);
}
}
#line 9540 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                          OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 9548
  l_cp = (opj_cp_t *)0;
#line 9549
  l_tcp = (opj_tcp_t *)0;
#line 9550
  l_tccp = (opj_tccp_t *)0;
#line 9558
  l_cp = & p_j2k->m_cp;
#line 9559
  l_tcp = l_cp->tcps + p_tile_no;
#line 9560
  l_tccp = l_tcp->tccps + p_comp_no;
#line 9566
  if (*p_header_size < 5U) {
    {
#line 9567
    opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\n!2 V");
    }
#line 9568
    return (0);
  }
  {
#line 9571
  opj_write_bytes_LE(p_data, l_tccp->numresolutions - 1U, (OPJ_UINT32 )1);
#line 9572
  p_data ++;
#line 9574
  opj_write_bytes_LE(p_data, l_tccp->cblkw - 2U, (OPJ_UINT32 )1);
#line 9575
  p_data ++;
#line 9577
  opj_write_bytes_LE(p_data, l_tccp->cblkh - 2U, (OPJ_UINT32 )1);
#line 9578
  p_data ++;
#line 9580
  opj_write_bytes_LE(p_data, l_tccp->cblksty, (OPJ_UINT32 )1);
#line 9582
  p_data ++;
#line 9584
  opj_write_bytes_LE(p_data, l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 9586
  p_data ++;
#line 9588
  *p_header_size -= 5U;
  }
#line 9590
  if (l_tccp->csty & 1U) {
#line 9592
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 9593
      opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\n!2 V");
      }
#line 9594
      return (0);
    }
#line 9597
    i = (OPJ_UINT32 )0;
    {
#line 9597
    while (1) {
      while_continue: /* CIL Label */ ;

#line 9597
      if (! (i < l_tccp->numresolutions)) {
#line 9597
        goto while_break;
      }
      {
#line 9598
      opj_write_bytes_LE(p_data, l_tccp->prcw[i] + (l_tccp->prch[i] << 4), (OPJ_UINT32 )1);
#line 9600
      p_data ++;
#line 9597
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 9603
    *p_header_size -= l_tccp->numresolutions;
  }
#line 9606
  return (1);
}
}
#line 9609 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                         OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  opj_tcp_t *tmp___2 ;

  {
#line 9616
  l_cp = (opj_cp_t *)((void *)0);
#line 9617
  l_tcp = (opj_tcp_t *)((void *)0);
#line 9618
  l_tccp = (opj_tccp_t *)((void *)0);
#line 9619
  l_current_ptr = (OPJ_BYTE *)((void *)0);
#line 9626
  l_cp = & p_j2k->m_cp;
#line 9627
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 9627
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 9627
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 9627
  l_tcp = tmp___2;
#line 9634
  l_tccp = l_tcp->tccps + compno;
#line 9635
  l_current_ptr = p_header_data;
#line 9638
  if (*p_header_size < 5U) {
    {
#line 9639
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\n");
    }
#line 9640
    return (0);
  }
  {
#line 9643
  opj_read_bytes_LE(l_current_ptr, & l_tccp->numresolutions, (OPJ_UINT32 )1);
#line 9645
  (l_tccp->numresolutions) ++;
  }
#line 9646
  if (l_tccp->numresolutions > 33U) {
    {
#line 9647
    opj_event_msg(p_manager, 1, "Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\n",
                  l_tccp->numresolutions, 33);
    }
#line 9650
    return (0);
  }
#line 9652
  l_current_ptr ++;
#line 9655
  if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {
    {
#line 9656
    opj_event_msg(p_manager, 1, "Error decoding component %d.\nThe number of resolutions to remove (%d) is greater or equal than the number of resolutions of this component (%d)\nModify the cp_reduce parameter.\n\n\252!2 V",
                  compno, l_cp->m_specific_param.m_dec.m_reduce, l_tccp->numresolutions);
#line 9661
    p_j2k->m_specific_param.m_decoder.m_state |= 32768U;
    }
#line 9663
    return (0);
  }
  {
#line 9666
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkw, (OPJ_UINT32 )1);
#line 9667
  l_current_ptr ++;
#line 9668
  l_tccp->cblkw += 2U;
#line 9670
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkh, (OPJ_UINT32 )1);
#line 9671
  l_current_ptr ++;
#line 9672
  l_tccp->cblkh += 2U;
  }
#line 9674
  if (l_tccp->cblkw > 10U) {
    {
#line 9676
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
#line 9678
    return (0);
  } else
#line 9674
  if (l_tccp->cblkh > 10U) {
    {
#line 9676
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
#line 9678
    return (0);
  } else
#line 9674
  if (l_tccp->cblkw + l_tccp->cblkh > 12U) {
    {
#line 9676
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
#line 9678
    return (0);
  }
  {
#line 9682
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblksty, (OPJ_UINT32 )1);
#line 9683
  l_current_ptr ++;
  }
#line 9684
  if (l_tccp->cblksty & 192U) {
    {
#line 9685
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid code-block style found\n");
    }
#line 9687
    return (0);
  }
  {
#line 9690
  opj_read_bytes_LE(l_current_ptr, & l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 9691
  l_current_ptr ++;
#line 9693
  *p_header_size -= 5U;
  }
#line 9696
  if (l_tccp->csty & 1U) {
#line 9697
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 9698
      opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\n\"2 V");
      }
#line 9699
      return (0);
    }
#line 9702
    i = (OPJ_UINT32 )0;
    {
#line 9702
    while (1) {
      while_continue: /* CIL Label */ ;

#line 9702
      if (! (i < l_tccp->numresolutions)) {
#line 9702
        goto while_break;
      }
      {
#line 9703
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 9704
      l_current_ptr ++;
      }
#line 9706
      if (i != 0U) {
#line 9706
        if ((l_tmp & 15U) == 0U) {
          {
#line 9707
          opj_event_msg(p_manager, 1, "Invalid precinct size\n");
          }
#line 9708
          return (0);
        } else
#line 9706
        if (l_tmp >> 4 == 0U) {
          {
#line 9707
          opj_event_msg(p_manager, 1, "Invalid precinct size\n");
          }
#line 9708
          return (0);
        }
      }
#line 9710
      l_tccp->prcw[i] = l_tmp & 15U;
#line 9711
      l_tccp->prch[i] = l_tmp >> 4;
#line 9702
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
#line 9714
    *p_header_size -= l_tccp->numresolutions;
  } else {
#line 9717
    i = (OPJ_UINT32 )0;
    {
#line 9717
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 9717
      if (! (i < l_tccp->numresolutions)) {
#line 9717
        goto while_break___0;
      }
#line 9718
      l_tccp->prcw[i] = (OPJ_UINT32 )15;
#line 9719
      l_tccp->prch[i] = (OPJ_UINT32 )15;
#line 9717
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 9747
  return (1);
}
}
#line 9750 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_prc_size ;
  opj_tcp_t *tmp___0 ;

  {
#line 9754
  l_cp = (opj_cp_t *)((void *)0);
#line 9755
  l_tcp = (opj_tcp_t *)((void *)0);
#line 9756
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 9756
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 9762
  l_cp = & p_j2k->m_cp;
#line 9763
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 9763
    tmp___0 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 9763
    tmp___0 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 9763
  l_tcp = tmp___0;
#line 9768
  l_ref_tccp = l_tcp->tccps + 0;
#line 9769
  l_copied_tccp = l_ref_tccp + 1;
#line 9770
  l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 9772
  i = (OPJ_UINT32 )1;
  {
#line 9772
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9772
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 9772
      goto while_break;
    }
    {
#line 9773
    l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;
#line 9774
    l_copied_tccp->cblkw = l_ref_tccp->cblkw;
#line 9775
    l_copied_tccp->cblkh = l_ref_tccp->cblkh;
#line 9776
    l_copied_tccp->cblksty = l_ref_tccp->cblksty;
#line 9777
    l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;
#line 9778
    memcpy((void *)(l_copied_tccp->prcw), (void const   *)(l_ref_tccp->prcw), (unsigned long )l_prc_size);
#line 9779
    memcpy((void *)(l_copied_tccp->prch), (void const   *)(l_ref_tccp->prch), (unsigned long )l_prc_size);
#line 9780
    l_copied_tccp ++;
#line 9772
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 9776
  return;
}
}
#line 9784 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                             OPJ_UINT32 p_comp_no ) 
{ 
  OPJ_UINT32 l_num_bands ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  unsigned int tmp___2 ;

  {
#line 9790
  l_cp = (opj_cp_t *)0;
#line 9791
  l_tcp = (opj_tcp_t *)0;
#line 9792
  l_tccp = (opj_tccp_t *)0;
#line 9797
  l_cp = & p_j2k->m_cp;
#line 9798
  l_tcp = l_cp->tcps + p_tile_no;
#line 9799
  l_tccp = l_tcp->tccps + p_comp_no;
#line 9805
  if (l_tccp->qntsty == 1U) {
#line 9805
    tmp___2 = 1U;
  } else {
#line 9805
    tmp___2 = l_tccp->numresolutions * 3U - 2U;
  }
#line 9805
  l_num_bands = tmp___2;
#line 9808
  if (l_tccp->qntsty == 0U) {
#line 9809
    return (1U + l_num_bands);
  } else {
#line 9811
    return (1U + 2U * l_num_bands);
  }
}
}
#line 9815 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp0 ;
  opj_tccp_t *l_tccp1 ;
  OPJ_UINT32 l_band_no ;
  OPJ_UINT32 l_num_bands ;

  {
#line 9818
  l_cp = (opj_cp_t *)((void *)0);
#line 9819
  l_tcp = (opj_tcp_t *)((void *)0);
#line 9820
  l_tccp0 = (opj_tccp_t *)((void *)0);
#line 9821
  l_tccp1 = (opj_tccp_t *)((void *)0);
#line 9827
  l_cp = & p_j2k->m_cp;
#line 9828
  l_tcp = l_cp->tcps + p_tile_no;
#line 9829
  l_tccp0 = l_tcp->tccps + p_first_comp_no;
#line 9830
  l_tccp1 = l_tcp->tccps + p_second_comp_no;
#line 9832
  if (l_tccp0->qntsty != l_tccp1->qntsty) {
#line 9833
    return (0);
  }
#line 9835
  if (l_tccp0->numgbits != l_tccp1->numgbits) {
#line 9836
    return (0);
  }
#line 9838
  if (l_tccp0->qntsty == 1U) {
#line 9839
    l_num_bands = 1U;
  } else {
#line 9841
    l_num_bands = l_tccp0->numresolutions * 3U - 2U;
#line 9842
    if (l_num_bands != l_tccp1->numresolutions * 3U - 2U) {
#line 9843
      return (0);
    }
  }
#line 9847
  l_band_no = (OPJ_UINT32 )0;
  {
#line 9847
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9847
    if (! (l_band_no < l_num_bands)) {
#line 9847
      goto while_break;
    }
#line 9848
    if (l_tccp0->stepsizes[l_band_no].expn != l_tccp1->stepsizes[l_band_no].expn) {
#line 9849
      return (0);
    }
#line 9847
    l_band_no ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 9852
  if (l_tccp0->qntsty != 0U) {
#line 9853
    l_band_no = (OPJ_UINT32 )0;
    {
#line 9853
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 9853
      if (! (l_band_no < l_num_bands)) {
#line 9853
        goto while_break___0;
      }
#line 9854
      if (l_tccp0->stepsizes[l_band_no].mant != l_tccp1->stepsizes[l_band_no].mant) {
#line 9855
        return (0);
      }
#line 9853
      l_band_no ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 9859
  return (1);
}
}
#line 9863 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                        OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_header_size ;
  OPJ_UINT32 l_band_no ;
  OPJ_UINT32 l_num_bands ;
  OPJ_UINT32 l_expn ;
  OPJ_UINT32 l_mant ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  unsigned int tmp___5 ;

  {
#line 9874
  l_cp = (opj_cp_t *)0;
#line 9875
  l_tcp = (opj_tcp_t *)0;
#line 9876
  l_tccp = (opj_tccp_t *)0;
#line 9884
  l_cp = & p_j2k->m_cp;
#line 9885
  l_tcp = l_cp->tcps + p_tile_no;
#line 9886
  l_tccp = l_tcp->tccps + p_comp_no;
#line 9892
  if (l_tccp->qntsty == 1U) {
#line 9892
    tmp___5 = 1U;
  } else {
#line 9892
    tmp___5 = l_tccp->numresolutions * 3U - 2U;
  }
#line 9892
  l_num_bands = tmp___5;
#line 9895
  if (l_tccp->qntsty == 0U) {
#line 9896
    l_header_size = 1U + l_num_bands;
#line 9898
    if (*p_header_size < l_header_size) {
      {
#line 9899
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 9900
      return (0);
    }
    {
#line 9903
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 9905
    p_data ++;
#line 9907
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 9907
    while (1) {
      while_continue: /* CIL Label */ ;

#line 9907
      if (! (l_band_no < l_num_bands)) {
#line 9907
        goto while_break;
      }
      {
#line 9908
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 9909
      opj_write_bytes_LE(p_data, l_expn << 3, (OPJ_UINT32 )1);
#line 9910
      p_data ++;
#line 9907
      l_band_no ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 9913
    l_header_size = 1U + 2U * l_num_bands;
#line 9915
    if (*p_header_size < l_header_size) {
      {
#line 9916
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 9917
      return (0);
    }
    {
#line 9920
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 9922
    p_data ++;
#line 9924
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 9924
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 9924
      if (! (l_band_no < l_num_bands)) {
#line 9924
        goto while_break___0;
      }
      {
#line 9925
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 9926
      l_mant = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].mant;
#line 9928
      opj_write_bytes_LE(p_data, (l_expn << 11) + l_mant, (OPJ_UINT32 )2);
#line 9929
      p_data += 2;
#line 9924
      l_band_no ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 9933
  *p_header_size -= l_header_size;
#line 9935
  return (1);
}
}
#line 9938 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                       OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_band_no ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_num_band ;
  opj_tcp_t *tmp___2 ;
  OPJ_UINT32 tmp___4 ;
  OPJ_INT32 tmp___5 ;

  {
#line 9947
  l_cp = (opj_cp_t *)0;
#line 9948
  l_tcp = (opj_tcp_t *)0;
#line 9949
  l_tccp = (opj_tccp_t *)0;
#line 9950
  l_current_ptr = (OPJ_BYTE *)0;
#line 9958
  l_cp = & p_j2k->m_cp;
#line 9960
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 9960
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 9960
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 9960
  l_tcp = tmp___2;
#line 9968
  l_tccp = l_tcp->tccps + p_comp_no;
#line 9969
  l_current_ptr = p_header_data;
#line 9971
  if (*p_header_size < 1U) {
    {
#line 9972
    opj_event_msg(p_manager, 1, "Error reading SQcd or SQcc element\n");
    }
#line 9973
    return (0);
  }
  {
#line 9975
  (*p_header_size) --;
#line 9977
  opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 9978
  l_current_ptr ++;
#line 9980
  l_tccp->qntsty = l_tmp & 31U;
#line 9981
  l_tccp->numgbits = l_tmp >> 5;
  }
#line 9982
  if (l_tccp->qntsty == 1U) {
#line 9983
    l_num_band = (OPJ_UINT32 )1;
  } else {
#line 9985
    if (l_tccp->qntsty == 0U) {
#line 9985
      tmp___4 = *p_header_size;
    } else {
#line 9985
      tmp___4 = *p_header_size / 2U;
    }
#line 9985
    l_num_band = tmp___4;
#line 9989
    if (l_num_band > 97U) {
      {
#line 9990
      opj_event_msg(p_manager, 2, "While reading CCP_QNTSTY element inside QCD or QCC marker segment, number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to OPJ_J2K_MAXBANDS (%d) and skip the rest. \n",
                    l_num_band, 97, 97);
      }
    }
  }
#line 10021
  if (l_tccp->qntsty == 0U) {
#line 10022
    l_band_no = (OPJ_UINT32 )0;
    {
#line 10022
    while (1) {
      while_continue: /* CIL Label */ ;

#line 10022
      if (! (l_band_no < l_num_band)) {
#line 10022
        goto while_break;
      }
      {
#line 10023
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 10024
      l_current_ptr ++;
      }
#line 10025
      if (l_band_no < 97U) {
#line 10026
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 3);
#line 10027
        l_tccp->stepsizes[l_band_no].mant = 0;
      }
#line 10022
      l_band_no ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
#line 10030
    *p_header_size -= l_num_band;
  } else {
#line 10032
    l_band_no = (OPJ_UINT32 )0;
    {
#line 10032
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 10032
      if (! (l_band_no < l_num_band)) {
#line 10032
        goto while_break___0;
      }
      {
#line 10033
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )2);
#line 10034
      l_current_ptr += 2;
      }
#line 10035
      if (l_band_no < 97U) {
#line 10036
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 11);
#line 10037
        l_tccp->stepsizes[l_band_no].mant = (OPJ_INT32 )(l_tmp & 2047U);
      }
#line 10032
      l_band_no ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 10040
    *p_header_size -= 2U * l_num_band;
  }
#line 10044
  if (l_tccp->qntsty == 1U) {
#line 10045
    l_band_no = (OPJ_UINT32 )1;
    {
#line 10045
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 10045
      if (! (l_band_no < 97U)) {
#line 10045
        goto while_break___1;
      }
#line 10046
      if (l_tccp->stepsizes[0].expn - (OPJ_INT32 )((l_band_no - 1U) / 3U) > 0) {
#line 10046
        tmp___5 = l_tccp->stepsizes[0].expn - (OPJ_INT32 )((l_band_no - 1U) / 3U);
      } else {
#line 10046
        tmp___5 = 0;
      }
#line 10046
      l_tccp->stepsizes[l_band_no].expn = tmp___5;
#line 10050
      l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;
#line 10045
      l_band_no ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 10054
  return (1);
}
}
#line 10057 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_size ;
  opj_tcp_t *tmp___0 ;

  {
#line 10060
  l_cp = (opj_cp_t *)((void *)0);
#line 10061
  l_tcp = (opj_tcp_t *)((void *)0);
#line 10062
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 10063
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 10069
  l_cp = & p_j2k->m_cp;
#line 10070
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 10070
    tmp___0 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 10070
    tmp___0 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 10070
  l_tcp = tmp___0;
#line 10074
  l_ref_tccp = l_tcp->tccps + 0;
#line 10075
  l_copied_tccp = l_ref_tccp + 1;
#line 10076
  l_size = (OPJ_UINT32 )(97UL * sizeof(opj_stepsize_t ));
#line 10078
  i = (OPJ_UINT32 )1;
  {
#line 10078
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10078
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 10078
      goto while_break;
    }
    {
#line 10079
    l_copied_tccp->qntsty = l_ref_tccp->qntsty;
#line 10080
    l_copied_tccp->numgbits = l_ref_tccp->numgbits;
#line 10081
    memcpy((void *)(l_copied_tccp->stepsizes), (void const   *)(l_ref_tccp->stepsizes),
           (unsigned long )l_size);
#line 10082
    l_copied_tccp ++;
#line 10078
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 10082
  return;
}
}
#line 10086 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_tile_info(opj_tcp_t *l_default_tile , OPJ_INT32 numcomps ,
                                   FILE *out_stream ) 
{ 
  OPJ_INT32 compno ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 resno ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  int tmp ;

  {
#line 10089
  if (l_default_tile) {
    {
#line 10092
    fprintf(out_stream, "\t default tile {\n");
#line 10093
    fprintf(out_stream, "\t\t csty=%#x\n", l_default_tile->csty);
#line 10094
    fprintf(out_stream, "\t\t prg=%#x\n", (int )l_default_tile->prg);
#line 10095
    fprintf(out_stream, "\t\t numlayers=%d\n\230\001", l_default_tile->numlayers);
#line 10096
    fprintf(out_stream, "\t\t mct=%x\n", l_default_tile->mct);
#line 10098
    compno = 0;
    }
    {
#line 10098
    while (1) {
      while_continue: /* CIL Label */ ;

#line 10098
      if (! (compno < numcomps)) {
#line 10098
        goto while_break;
      }
      {
#line 10099
      l_tccp = l_default_tile->tccps + compno;
#line 10104
      fprintf(out_stream, "\t\t comp %d {\n", compno);
#line 10105
      fprintf(out_stream, "\t\t\t csty=%#x\n", l_tccp->csty);
#line 10106
      fprintf(out_stream, "\t\t\t numresolutions=%d\n", l_tccp->numresolutions);
#line 10107
      fprintf(out_stream, "\t\t\t cblkw=2^%d\n", l_tccp->cblkw);
#line 10108
      fprintf(out_stream, "\t\t\t cblkh=2^%d\n", l_tccp->cblkh);
#line 10109
      fprintf(out_stream, "\t\t\t cblksty=%#x\n\230\001", l_tccp->cblksty);
#line 10110
      fprintf(out_stream, "\t\t\t qmfbid=%d\n", l_tccp->qmfbid);
#line 10112
      fprintf(out_stream, "\t\t\t preccintsize (w,h)=");
#line 10113
      resno = (OPJ_UINT32 )0;
      }
      {
#line 10113
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 10113
        if (! (resno < l_tccp->numresolutions)) {
#line 10113
          goto while_break___0;
        }
        {
#line 10114
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->prcw[resno], l_tccp->prch[resno]);
#line 10113
        resno ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 10116
      fprintf(out_stream, "\nj#2 V");
#line 10119
      fprintf(out_stream, "\t\t\t qntsty=%d\n", l_tccp->qntsty);
#line 10120
      fprintf(out_stream, "\t\t\t numgbits=%d\n\230\001", l_tccp->numgbits);
#line 10121
      fprintf(out_stream, "\t\t\t stepsizes (m,e)= V");
      }
#line 10122
      if (l_tccp->qntsty == 1U) {
#line 10122
        tmp = 1;
      } else {
#line 10122
        tmp = (OPJ_INT32 )l_tccp->numresolutions * 3 - 2;
      }
#line 10122
      numbands = tmp;
#line 10124
      bandno = 0;
      {
#line 10124
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 10124
        if (! (bandno < numbands)) {
#line 10124
          goto while_break___1;
        }
        {
#line 10125
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->stepsizes[bandno].mant, l_tccp->stepsizes[bandno].expn);
#line 10124
        bandno ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 10128
      fprintf(out_stream, "\nv#2 V");
#line 10131
      fprintf(out_stream, "\t\t\t roishift=%d\n\230\001", l_tccp->roishift);
#line 10133
      fprintf(out_stream, "\t\t }\n");
#line 10098
      compno ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
    {
#line 10135
    fprintf(out_stream, "\t }\n");
    }
  }
#line 10138
  return;
}
}
#line 10139 "/root/patron/new_24/src/lib/openjp2/j2k.c"
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) 
{ 
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  opj_tcp_t *l_tcp ;

  {
#line 10142
  if (flag & 128) {
    {
#line 10143
    fprintf(out_stream, "Wrong flag\n");
    }
#line 10144
    return;
  } else
#line 10142
  if (flag & 256) {
    {
#line 10143
    fprintf(out_stream, "Wrong flag\n");
    }
#line 10144
    return;
  }
#line 10148
  if (flag & 1) {
#line 10149
    if (p_j2k->m_private_image) {
      {
#line 10150
      j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);
      }
    }
  }
#line 10155
  if (flag & 2) {
#line 10156
    if (p_j2k->m_private_image) {
      {
#line 10157
      opj_j2k_dump_MH_info(p_j2k, out_stream);
      }
    }
  }
#line 10161
  if (flag & 8) {
#line 10162
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 10164
    l_tcp = p_j2k->m_cp.tcps;
#line 10165
    if (p_j2k->m_private_image) {
#line 10166
      i = (OPJ_UINT32 )0;
      {
#line 10166
      while (1) {
        while_continue: /* CIL Label */ ;

#line 10166
        if (! (i < l_nb_tiles)) {
#line 10166
          goto while_break;
        }
        {
#line 10167
        opj_j2k_dump_tile_info(l_tcp, (OPJ_INT32 )(p_j2k->m_private_image)->numcomps,
                               out_stream);
#line 10169
        l_tcp ++;
#line 10166
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 10180
  if (flag & 16) {
    {
#line 10181
    opj_j2k_dump_MH_index(p_j2k, out_stream);
    }
  }
#line 10188
  return;
}
}
#line 10191 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 
  opj_codestream_index_t *cstr_index ;
  OPJ_UINT32 it_marker ;
  OPJ_UINT32 it_tile ;
  OPJ_UINT32 it_tile_part ;
  OPJ_UINT32 l_acc_nb_of_tile_part ;
  OPJ_UINT32 nb_of_tile_part ;

  {
  {
#line 10193
  cstr_index = p_j2k->cstr_index;
#line 10196
  fprintf(out_stream, "Codestream index from main header: {\n");
#line 10198
  fprintf(out_stream, "\t Main header start position=%li\n\t Main header end position=%li\n V",
          cstr_index->main_head_start, cstr_index->main_head_end);
#line 10202
  fprintf(out_stream, "\t Marker list: {\n\205\2520 V");
  }
#line 10204
  if (cstr_index->marker) {
#line 10205
    it_marker = (OPJ_UINT32 )0;
    {
#line 10205
    while (1) {
      while_continue: /* CIL Label */ ;

#line 10205
      if (! (it_marker < cstr_index->marknum)) {
#line 10205
        goto while_break;
      }
      {
#line 10206
      fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n", (int )(cstr_index->marker + it_marker)->type,
              (cstr_index->marker + it_marker)->pos, (cstr_index->marker + it_marker)->len);
#line 10205
      it_marker ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 10213
  fprintf(out_stream, "\t }\n V");
  }
#line 10215
  if (cstr_index->tile_index) {
#line 10218
    l_acc_nb_of_tile_part = (OPJ_UINT32 )0;
#line 10219
    it_tile = (OPJ_UINT32 )0;
    {
#line 10219
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 10219
      if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 10219
        goto while_break___0;
      }
#line 10220
      l_acc_nb_of_tile_part += (cstr_index->tile_index + it_tile)->nb_tps;
#line 10219
      it_tile ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
#line 10223
    if (l_acc_nb_of_tile_part) {
      {
#line 10224
      fprintf(out_stream, "\t Tile index: {\n\220");
#line 10226
      it_tile = (OPJ_UINT32 )0;
      }
      {
#line 10226
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 10226
        if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 10226
          goto while_break___1;
        }
        {
#line 10227
        nb_of_tile_part = (cstr_index->tile_index + it_tile)->nb_tps;
#line 10229
        fprintf(out_stream, "\t\t nb of tile-part in tile [%d]=%d\n", it_tile, nb_of_tile_part);
        }
#line 10232
        if ((cstr_index->tile_index + it_tile)->tp_index) {
#line 10233
          it_tile_part = (OPJ_UINT32 )0;
          {
#line 10233
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 10233
            if (! (it_tile_part < nb_of_tile_part)) {
#line 10233
              goto while_break___2;
            }
            {
#line 10234
            fprintf(out_stream, "\t\t\t tile-part[%d]: star_pos=%li, end_header=%li, end_pos=%li.\n",
                    it_tile_part, ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->start_pos,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_header,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_pos);
#line 10233
            it_tile_part ++;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
          while_break___2: ;
        }
#line 10243
        if ((cstr_index->tile_index + it_tile)->marker) {
#line 10244
          it_marker = (OPJ_UINT32 )0;
          {
#line 10244
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 10244
            if (! (it_marker < (cstr_index->tile_index + it_tile)->marknum)) {
#line 10244
              goto while_break___3;
            }
            {
#line 10246
            fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n", (int )((cstr_index->tile_index + it_tile)->marker + it_marker)->type,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->pos,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->len);
#line 10245
            it_marker ++;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: ;
        }
#line 10226
        it_tile ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 10253
      fprintf(out_stream, "\t }\n");
      }
    }
  }
  {
#line 10257
  fprintf(out_stream, "}\n");
  }
#line 10259
  return;
}
}
#line 10262 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 


  {
  {
#line 10265
  fprintf(out_stream, "Codestream info from main header: {\n");
#line 10267
  fprintf(out_stream, "\t tx0=%d, ty0=%d\n", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);
#line 10268
  fprintf(out_stream, "\t tdx=%d, tdy=%d\n", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);
#line 10269
  fprintf(out_stream, "\t tw=%d, th=%d\n", p_j2k->m_cp.tw, p_j2k->m_cp.th);
#line 10270
  opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp, (OPJ_INT32 )(p_j2k->m_private_image)->numcomps,
                         out_stream);
#line 10272
  fprintf(out_stream, "}\n");
  }
#line 10274
  return;
}
}
#line 10275 "/root/patron/new_24/src/lib/openjp2/j2k.c"
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) 
{ 
  char tab[2] ;
  OPJ_UINT32 compno ;

  {
#line 10280
  if (dev_dump_flag) {
    {
#line 10281
    fprintf(stdout, "[DEV] Dump an image_header struct {\n");
#line 10282
    tab[0] = (char )'\000';
    }
  } else {
    {
#line 10284
    fprintf(out_stream, "Image info {\n");
#line 10285
    tab[0] = (char )'\t';
#line 10286
    tab[1] = (char )'\000';
    }
  }
  {
#line 10289
  fprintf(out_stream, "%s x0=%d, y0=%d\n\230\001", tab, img_header->x0, img_header->y0);
#line 10290
  fprintf(out_stream, "%s x1=%d, y1=%d\n\230\001", tab, img_header->x1, img_header->y1);
#line 10292
  fprintf(out_stream, "%s numcomps=%d\n", tab, img_header->numcomps);
  }
#line 10294
  if (img_header->comps) {
#line 10296
    compno = (OPJ_UINT32 )0;
    {
#line 10296
    while (1) {
      while_continue: /* CIL Label */ ;

#line 10296
      if (! (compno < img_header->numcomps)) {
#line 10296
        goto while_break;
      }
      {
#line 10297
      fprintf(out_stream, "%s\t component %d {\n", tab, compno);
#line 10298
      j2k_dump_image_comp_header(img_header->comps + compno, dev_dump_flag, out_stream);
#line 10300
      fprintf(out_stream, "%s}\n", tab);
#line 10296
      compno ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 10304
  fprintf(out_stream, "}\n");
  }
#line 10306
  return;
}
}
#line 10307 "/root/patron/new_24/src/lib/openjp2/j2k.c"
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) 
{ 
  char tab[3] ;

  {
#line 10312
  if (dev_dump_flag) {
    {
#line 10313
    fprintf(stdout, "[DEV] Dump an image_comp_header struct {\n");
#line 10314
    tab[0] = (char )'\000';
    }
  } else {
#line 10316
    tab[0] = (char )'\t';
#line 10317
    tab[1] = (char )'\t';
#line 10318
    tab[2] = (char )'\000';
  }
  {
#line 10321
  fprintf(out_stream, "%s dx=%d, dy=%d\n\230\001", tab, comp_header->dx, comp_header->dy);
#line 10322
  fprintf(out_stream, "%s prec=%d\n", tab, comp_header->prec);
#line 10323
  fprintf(out_stream, "%s sgnd=%d\n", tab, comp_header->sgnd);
  }
#line 10325
  if (dev_dump_flag) {
    {
#line 10326
    fprintf(out_stream, "}\n");
    }
  }
#line 10329
  return;
}
}
#line 10330 "/root/patron/new_24/src/lib/openjp2/j2k.c"
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 numcomps ;
  opj_tcp_t *l_default_tile ;
  opj_codestream_info_v2_t *cstr_info ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_tccp_t *l_tccp ;
  opj_tccp_info_t *l_tccp_info ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  int tmp ;

  {
  {
#line 10333
  numcomps = (p_j2k->m_private_image)->numcomps;
#line 10335
  __cil_tmp6 = opj_calloc((size_t )1, sizeof(opj_codestream_info_v2_t ));
#line 10335
  cstr_info = (opj_codestream_info_v2_t *)__cil_tmp6;
  }
#line 10337
  if (! cstr_info) {
#line 10338
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
  {
#line 10341
  cstr_info->nbcomps = (p_j2k->m_private_image)->numcomps;
#line 10343
  cstr_info->tx0 = p_j2k->m_cp.tx0;
#line 10344
  cstr_info->ty0 = p_j2k->m_cp.ty0;
#line 10345
  cstr_info->tdx = p_j2k->m_cp.tdx;
#line 10346
  cstr_info->tdy = p_j2k->m_cp.tdy;
#line 10347
  cstr_info->tw = p_j2k->m_cp.tw;
#line 10348
  cstr_info->th = p_j2k->m_cp.th;
#line 10350
  cstr_info->tile_info = (opj_tile_info_v2_t *)((void *)0);
#line 10352
  l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 10354
  cstr_info->m_default_tile_info.csty = l_default_tile->csty;
#line 10355
  cstr_info->m_default_tile_info.prg = l_default_tile->prg;
#line 10356
  cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;
#line 10357
  cstr_info->m_default_tile_info.mct = l_default_tile->mct;
#line 10359
  __cil_tmp7 = opj_calloc((size_t )cstr_info->nbcomps, sizeof(opj_tccp_info_t ));
#line 10359
  cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t *)__cil_tmp7;
  }
#line 10361
  if (! cstr_info->m_default_tile_info.tccp_info) {
    {
#line 10362
    opj_destroy_cstr_info(& cstr_info);
    }
#line 10363
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
#line 10366
  compno = (OPJ_UINT32 )0;
  {
#line 10366
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10366
    if (! (compno < numcomps)) {
#line 10366
      goto while_break;
    }
#line 10367
    l_tccp = l_default_tile->tccps + compno;
#line 10368
    l_tccp_info = cstr_info->m_default_tile_info.tccp_info + compno;
#line 10373
    l_tccp_info->csty = l_tccp->csty;
#line 10374
    l_tccp_info->numresolutions = l_tccp->numresolutions;
#line 10375
    l_tccp_info->cblkw = l_tccp->cblkw;
#line 10376
    l_tccp_info->cblkh = l_tccp->cblkh;
#line 10377
    l_tccp_info->cblksty = l_tccp->cblksty;
#line 10378
    l_tccp_info->qmfbid = l_tccp->qmfbid;
#line 10379
    if (l_tccp->numresolutions < 33U) {
      {
#line 10380
      memcpy((void *)(l_tccp_info->prch), (void const   *)(l_tccp->prch), (unsigned long )l_tccp->numresolutions);
#line 10381
      memcpy((void *)(l_tccp_info->prcw), (void const   *)(l_tccp->prcw), (unsigned long )l_tccp->numresolutions);
      }
    }
#line 10385
    l_tccp_info->qntsty = l_tccp->qntsty;
#line 10386
    l_tccp_info->numgbits = l_tccp->numgbits;
#line 10388
    if (l_tccp->qntsty == 1U) {
#line 10388
      tmp = 1;
    } else {
#line 10388
      tmp = (OPJ_INT32 )l_tccp->numresolutions * 3 - 2;
    }
#line 10388
    numbands = tmp;
#line 10390
    if (numbands < 97) {
#line 10391
      bandno = 0;
      {
#line 10391
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 10391
        if (! (bandno < numbands)) {
#line 10391
          goto while_break___0;
        }
#line 10392
        l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].mant;
#line 10394
        l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].expn;
#line 10391
        bandno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 10400
    l_tccp_info->roishift = l_tccp->roishift;
#line 10366
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 10403
  return (cstr_info);
}
}
#line 10406 "/root/patron/new_24/src/lib/openjp2/j2k.c"
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  OPJ_UINT32 it_tile ;
  void *__cil_tmp7 ;
  OPJ_UINT32 it_tile_free ;
  void *__cil_tmp10 ;
  OPJ_UINT32 it_tile_free___0 ;

  {
  {
#line 10408
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_codestream_index_t ));
#line 10408
  l_cstr_index = (opj_codestream_index_t *)__cil_tmp3;
  }
#line 10410
  if (! l_cstr_index) {
#line 10411
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 10414
  l_cstr_index->main_head_start = (p_j2k->cstr_index)->main_head_start;
#line 10415
  l_cstr_index->main_head_end = (p_j2k->cstr_index)->main_head_end;
#line 10416
  l_cstr_index->codestream_size = (p_j2k->cstr_index)->codestream_size;
#line 10418
  l_cstr_index->marknum = (p_j2k->cstr_index)->marknum;
#line 10419
  __cil_tmp4 = opj_malloc((unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
#line 10419
  l_cstr_index->marker = (opj_marker_info_t *)__cil_tmp4;
  }
#line 10421
  if (! l_cstr_index->marker) {
    {
#line 10422
    opj_free((void *)l_cstr_index);
    }
#line 10423
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 10426
  if ((p_j2k->cstr_index)->marker) {
    {
#line 10427
    memcpy((void *)l_cstr_index->marker, (void const   *)(p_j2k->cstr_index)->marker,
           (unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
    }
  } else {
    {
#line 10430
    opj_free((void *)l_cstr_index->marker);
#line 10431
    l_cstr_index->marker = (opj_marker_info_t *)((void *)0);
    }
  }
  {
#line 10434
  l_cstr_index->nb_of_tiles = (p_j2k->cstr_index)->nb_of_tiles;
#line 10435
  __cil_tmp5 = opj_calloc((size_t )l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 10435
  l_cstr_index->tile_index = (opj_tile_index_t *)__cil_tmp5;
  }
#line 10437
  if (! l_cstr_index->tile_index) {
    {
#line 10438
    opj_free((void *)l_cstr_index->marker);
#line 10439
    opj_free((void *)l_cstr_index);
    }
#line 10440
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 10443
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 10444
    opj_free((void *)l_cstr_index->tile_index);
#line 10445
    l_cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
    }
  } else {
#line 10447
    it_tile = (OPJ_UINT32 )0;
#line 10448
    it_tile = (OPJ_UINT32 )0;
    {
#line 10448
    while (1) {
      while_continue: /* CIL Label */ ;

#line 10448
      if (! (it_tile < l_cstr_index->nb_of_tiles)) {
#line 10448
        goto while_break;
      }
      {
#line 10451
      (l_cstr_index->tile_index + it_tile)->marknum = ((p_j2k->cstr_index)->tile_index + it_tile)->marknum;
#line 10454
      __cil_tmp7 = opj_malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
#line 10454
      (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp7;
      }
#line 10458
      if (! (l_cstr_index->tile_index + it_tile)->marker) {
#line 10461
        it_tile_free = (OPJ_UINT32 )0;
        {
#line 10461
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 10461
          if (! (it_tile_free < it_tile)) {
#line 10461
            goto while_break___0;
          }
          {
#line 10462
          opj_free((void *)(l_cstr_index->tile_index + it_tile_free)->marker);
#line 10461
          it_tile_free ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break___0: 
        {
#line 10465
        opj_free((void *)l_cstr_index->tile_index);
#line 10466
        opj_free((void *)l_cstr_index->marker);
#line 10467
        opj_free((void *)l_cstr_index);
        }
#line 10468
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 10471
      if (((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
        {
#line 10472
        memcpy((void *)(l_cstr_index->tile_index + it_tile)->marker, (void const   *)((p_j2k->cstr_index)->tile_index + it_tile)->marker,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
        }
      } else {
        {
#line 10476
        opj_free((void *)(l_cstr_index->tile_index + it_tile)->marker);
#line 10477
        (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
        }
      }
      {
#line 10481
      (l_cstr_index->tile_index + it_tile)->nb_tps = ((p_j2k->cstr_index)->tile_index + it_tile)->nb_tps;
#line 10484
      __cil_tmp10 = opj_malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
#line 10484
      (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)__cil_tmp10;
      }
#line 10488
      if (! (l_cstr_index->tile_index + it_tile)->tp_index) {
#line 10491
        it_tile_free___0 = (OPJ_UINT32 )0;
        {
#line 10491
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 10491
          if (! (it_tile_free___0 < it_tile)) {
#line 10491
            goto while_break___1;
          }
          {
#line 10492
          opj_free((void *)(l_cstr_index->tile_index + it_tile_free___0)->marker);
#line 10493
          opj_free((void *)(l_cstr_index->tile_index + it_tile_free___0)->tp_index);
#line 10491
          it_tile_free___0 ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: 
        {
#line 10496
        opj_free((void *)l_cstr_index->tile_index);
#line 10497
        opj_free((void *)l_cstr_index->marker);
#line 10498
        opj_free((void *)l_cstr_index);
        }
#line 10499
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 10502
      if (((p_j2k->cstr_index)->tile_index + it_tile)->tp_index) {
        {
#line 10503
        memcpy((void *)(l_cstr_index->tile_index + it_tile)->tp_index, (void const   *)((p_j2k->cstr_index)->tile_index + it_tile)->tp_index,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
        }
      } else {
        {
#line 10507
        opj_free((void *)(l_cstr_index->tile_index + it_tile)->tp_index);
#line 10508
        (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
        }
      }
#line 10512
      (l_cstr_index->tile_index + it_tile)->nb_packet = (OPJ_UINT32 )0;
#line 10513
      (l_cstr_index->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
#line 10448
      it_tile ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 10518
  return (l_cstr_index);
}
}
#line 10521 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 it_tile ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 10523
  it_tile = (OPJ_UINT32 )0;
#line 10525
  (p_j2k->cstr_index)->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 10526
  __cil_tmp3 = opj_calloc((size_t )(p_j2k->cstr_index)->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 10526
  (p_j2k->cstr_index)->tile_index = (opj_tile_index_t *)__cil_tmp3;
  }
#line 10528
  if (! (p_j2k->cstr_index)->tile_index) {
#line 10529
    return (0);
  }
#line 10532
  it_tile = (OPJ_UINT32 )0;
  {
#line 10532
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10532
    if (! (it_tile < (p_j2k->cstr_index)->nb_of_tiles)) {
#line 10532
      goto while_break;
    }
    {
#line 10533
    ((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum = (OPJ_UINT32 )100;
#line 10534
    ((p_j2k->cstr_index)->tile_index + it_tile)->marknum = (OPJ_UINT32 )0;
#line 10535
    __cil_tmp4 = opj_calloc((size_t )((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum,
                            sizeof(opj_marker_info_t ));
#line 10535
    ((p_j2k->cstr_index)->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp4;
    }
#line 10538
    if (! ((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
#line 10539
      return (0);
    }
#line 10532
    it_tile ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 10543
  return (1);
}
}
#line 10546 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 nr_tiles ;
  OPJ_UINT32 i ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_OFF_T __cil_tmp19 ;

  {
#line 10550
  l_go_on = 1;
#line 10554
  nr_tiles = (OPJ_UINT32 )0;
#line 10558
  if (p_j2k->m_cp.tw == 1U) {
#line 10558
    if (p_j2k->m_cp.th == 1U) {
#line 10558
      if (p_j2k->m_cp.tx0 == 0U) {
#line 10558
        if (p_j2k->m_cp.ty0 == 0U) {
#line 10558
          if ((p_j2k->m_output_image)->x0 == 0U) {
#line 10558
            if ((p_j2k->m_output_image)->y0 == 0U) {
#line 10558
              if ((p_j2k->m_output_image)->x1 == p_j2k->m_cp.tdx) {
#line 10558
                if ((p_j2k->m_output_image)->y1 == p_j2k->m_cp.tdy) {
                  {
#line 10565
                  __cil_tmp13 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no,
                                                         (OPJ_UINT32 *)((void *)0),
                                                         & l_tile_x0, & l_tile_y0,
                                                         & l_tile_x1, & l_tile_y1,
                                                         & l_nb_comps, & l_go_on,
                                                         p_stream, p_manager);
                  }
#line 10565
                  if (! __cil_tmp13) {
#line 10574
                    return (0);
                  }
                  {
#line 10577
                  __cil_tmp14 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, (OPJ_BYTE *)((void *)0),
                                                    (OPJ_UINT32 )0, p_stream, p_manager);
                  }
#line 10577
                  if (! __cil_tmp14) {
                    {
#line 10579
                    opj_event_msg(p_manager, 1, "Failed to decode tile 1/1\n$2 V");
                    }
#line 10580
                    return (0);
                  }
#line 10584
                  i = (OPJ_UINT32 )0;
                  {
#line 10584
                  while (1) {
                    while_continue: /* CIL Label */ ;

#line 10584
                    if (! (i < (p_j2k->m_output_image)->numcomps)) {
#line 10584
                      goto while_break;
                    }
                    {
#line 10585
                    opj_image_data_free((void *)((p_j2k->m_output_image)->comps + i)->data);
#line 10586
                    ((p_j2k->m_output_image)->comps + i)->data = ((((p_j2k->m_tcd)->tcd_image)->tiles)->comps + i)->data;
#line 10588
                    ((p_j2k->m_output_image)->comps + i)->resno_decoded = (((p_j2k->m_tcd)->image)->comps + i)->resno_decoded;
#line 10590
                    ((((p_j2k->m_tcd)->tcd_image)->tiles)->comps + i)->data = (OPJ_INT32 *)((void *)0);
#line 10584
                    i ++;
                    }
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                  while_break: ;
#line 10593
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 10596
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 10597
    if ((unsigned long )(p_j2k->m_cp.tcps + 0)->m_data != (unsigned long )((void *)0)) {
#line 10597
      if (p_j2k->m_cp.tw == 1U) {
#line 10597
        if (p_j2k->m_cp.th == 1U) {
#line 10599
          l_current_tile_no = (OPJ_UINT32 )0;
#line 10600
          p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 10601
          p_j2k->m_specific_param.m_decoder.m_state |= 128U;
        } else {
#line 10597
          goto _L;
        }
      } else {
#line 10597
        goto _L;
      }
    } else {
      _L: 
      {
#line 10603
      __cil_tmp16 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, (OPJ_UINT32 *)((void *)0),
                                             & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                             & l_tile_y1, & l_nb_comps, & l_go_on,
                                             p_stream, p_manager);
      }
#line 10603
      if (! __cil_tmp16) {
#line 10612
        return (0);
      }
#line 10615
      if (! l_go_on) {
#line 10616
        goto while_break___0;
      }
    }
    {
#line 10620
    __cil_tmp17 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, (OPJ_BYTE *)((void *)0),
                                      (OPJ_UINT32 )0, p_stream, p_manager);
    }
#line 10620
    if (! __cil_tmp17) {
      {
#line 10622
      opj_event_msg(p_manager, 1, "Failed to decode tile %d/%d\n", l_current_tile_no + 1U,
                    p_j2k->m_cp.th * p_j2k->m_cp.tw);
      }
#line 10624
      return (0);
    }
    {
#line 10627
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\n", l_current_tile_no + 1U,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 10630
    __cil_tmp18 = opj_j2k_update_image_data(p_j2k->m_tcd, p_j2k->m_output_image);
    }
#line 10630
    if (! __cil_tmp18) {
#line 10632
      return (0);
    }
#line 10635
    if (p_j2k->m_cp.tw == 1U) {
#line 10635
      if (p_j2k->m_cp.th == 1U) {
#line 10635
        if ((p_j2k->m_output_image)->x0 == (p_j2k->m_private_image)->x0) {
#line 10635
          if ((p_j2k->m_output_image)->y0 == (p_j2k->m_private_image)->y0) {
#line 10635
            if ((p_j2k->m_output_image)->x1 == (p_j2k->m_private_image)->x1) {
#line 10635
              if ((p_j2k->m_output_image)->y1 == (p_j2k->m_private_image)->y1) {
                {
#line 10642
                opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
                }
              }
            }
          }
        }
      } else {
        {
#line 10642
        opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
        }
      }
    } else {
      {
#line 10642
      opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
      }
    }
    {
#line 10645
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\n", l_current_tile_no + 1U);
#line 10648
    __cil_tmp19 = opj_stream_get_number_byte_left(p_stream);
    }
#line 10648
    if (__cil_tmp19 == 0L) {
#line 10648
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 10650
        goto while_break___0;
      }
    }
#line 10652
    nr_tiles ++;
#line 10652
    if (nr_tiles == p_j2k->m_cp.th * p_j2k->m_cp.tw) {
#line 10653
      goto while_break___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 10657
  return (1);
}
}
#line 10663 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 10670
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_decode_tiles),
                                                p_manager);
  }
#line 10670
  if (! __cil_tmp5) {
#line 10672
    return (0);
  }
#line 10676
  return (1);
}
}
#line 10682 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decode_one_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_UINT32 l_tile_no_to_dec ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;

  {
#line 10686
  l_go_on = 1;
#line 10695
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 10696
    __cil_tmp14 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
    }
#line 10696
    if (! __cil_tmp14) {
#line 10697
      return (0);
    }
  }
#line 10701
  l_tile_no_to_dec = (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;
#line 10703
  if ((p_j2k->cstr_index)->tile_index) {
#line 10704
    if (((p_j2k->cstr_index)->tile_index)->tp_index) {
#line 10705
      if (! ((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->nb_tps) {
        {
#line 10708
        __cil_tmp15 = opj_stream_read_seek(p_stream, p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos + 2L,
                                           p_manager);
        }
#line 10708
        if (! __cil_tmp15) {
          {
#line 10710
          opj_event_msg(p_manager, 1, "Problem with seek function\n2 V");
          }
#line 10711
          return (0);
        }
      } else {
        {
#line 10714
        __cil_tmp16 = opj_stream_read_seek(p_stream, (((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->tp_index + 0)->start_pos + 2L,
                                           p_manager);
        }
#line 10714
        if (! __cil_tmp16) {
          {
#line 10717
          opj_event_msg(p_manager, 1, "Problem with seek function\n2 V");
          }
#line 10718
          return (0);
        }
      }
#line 10722
      if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 10723
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
      }
    }
  }
#line 10731
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 10732
  i = (OPJ_UINT32 )0;
  {
#line 10732
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10732
    if (! (i < l_nb_tiles)) {
#line 10732
      goto while_break;
    }
#line 10733
    (p_j2k->m_cp.tcps + i)->m_current_tile_part_number = -1;
#line 10732
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 10736
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 10737
    __cil_tmp17 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, (OPJ_UINT32 *)((void *)0),
                                           & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                           & l_tile_y1, & l_nb_comps, & l_go_on, p_stream,
                                           p_manager);
    }
#line 10737
    if (! __cil_tmp17) {
#line 10746
      return (0);
    }
#line 10749
    if (! l_go_on) {
#line 10750
      goto while_break___0;
    }
    {
#line 10753
    __cil_tmp18 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, (OPJ_BYTE *)((void *)0),
                                      (OPJ_UINT32 )0, p_stream, p_manager);
    }
#line 10753
    if (! __cil_tmp18) {
#line 10755
      return (0);
    }
    {
#line 10757
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\nV", l_current_tile_no + 1U,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 10760
    __cil_tmp19 = opj_j2k_update_image_data(p_j2k->m_tcd, p_j2k->m_output_image);
    }
#line 10760
    if (! __cil_tmp19) {
#line 10762
      return (0);
    }
    {
#line 10764
    opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
#line 10766
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\n", l_current_tile_no + 1U);
    }
#line 10769
    if (l_current_tile_no == l_tile_no_to_dec) {
      {
#line 10771
      __cil_tmp20 = opj_stream_read_seek(p_stream, (p_j2k->cstr_index)->main_head_end + 2L,
                                         p_manager);
      }
#line 10771
      if (! __cil_tmp20) {
        {
#line 10773
        opj_event_msg(p_manager, 1, "Problem with seek function\n");
        }
#line 10774
        return (0);
      }
#line 10776
      goto while_break___0;
    } else {
      {
#line 10778
      opj_event_msg(p_manager, 2, "Tile read, decoded and updated is not the desired one (%d vs %d).\n%2 V",
                    l_current_tile_no + 1U, l_tile_no_to_dec + 1U);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 10785
  return (1);
}
}
#line 10791 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding_tile(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 10798
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_decode_one_tile),
                                                p_manager);
  }
#line 10798
  if (! __cil_tmp5) {
#line 10800
    return (0);
  }
#line 10804
  return (1);
}
}
#line 10807 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 it_comp ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;

  {
#line 10814
  if (! p_image) {
#line 10815
    return (0);
  }
#line 10822
  if ((unsigned long )p_j2k->m_private_image != (unsigned long )((void *)0)) {
#line 10822
    if (p_j2k->m_cp.m_specific_param.m_dec.m_reduce > 0U) {
#line 10822
      if ((p_j2k->m_private_image)->numcomps > 0U) {
#line 10822
        if (((p_j2k->m_private_image)->comps + 0)->factor == p_j2k->m_cp.m_specific_param.m_dec.m_reduce) {
#line 10822
          if (p_image->numcomps > 0U) {
#line 10822
            if ((p_image->comps + 0)->factor == 0U) {
#line 10822
              if ((unsigned long )(p_image->comps + 0)->data == (unsigned long )((void *)0)) {
#line 10835
                it_comp = (OPJ_UINT32 )0;
                {
#line 10835
                while (1) {
                  while_continue: /* CIL Label */ ;

#line 10835
                  if (! (it_comp < p_image->numcomps)) {
#line 10835
                    goto while_break;
                  }
#line 10836
                  (p_image->comps + it_comp)->factor = p_j2k->m_cp.m_specific_param.m_dec.m_reduce;
#line 10835
                  it_comp ++;
                }
                while_break___1: /* CIL Label */ ;
                }
                while_break: 
                {
#line 10838
                __cil_tmp7 = opj_j2k_update_image_dimensions(p_image, p_manager);
                }
#line 10838
                if (! __cil_tmp7) {
#line 10839
                  return (0);
                }
              }
            }
          }
        }
      }
    }
  }
#line 10843
  if ((unsigned long )p_j2k->m_output_image == (unsigned long )((void *)0)) {
    {
#line 10844
    p_j2k->m_output_image = opj_image_create0();
    }
#line 10845
    if (! p_j2k->m_output_image) {
#line 10846
      return (0);
    }
  }
  {
#line 10849
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 10852
  __cil_tmp9 = opj_j2k_setup_decoding(p_j2k, p_manager);
  }
#line 10852
  if (! __cil_tmp9) {
#line 10853
    return (0);
  }
  {
#line 10857
  __cil_tmp10 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 10857
  if (! __cil_tmp10) {
    {
#line 10858
    opj_image_destroy(p_j2k->m_private_image);
#line 10859
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 10860
    return (0);
  }
#line 10864
  compno = (OPJ_UINT32 )0;
  {
#line 10864
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 10864
    if (! (compno < p_image->numcomps)) {
#line 10864
      goto while_break___0;
    }
    {
#line 10865
    (p_image->comps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + compno)->resno_decoded;
#line 10867
    opj_image_data_free((void *)(p_image->comps + compno)->data);
#line 10868
    (p_image->comps + compno)->data = ((p_j2k->m_output_image)->comps + compno)->data;
#line 10877
    ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
#line 10864
    compno ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 10880
  return (1);
}
}
#line 10883 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;

  {
#line 10893
  if (! p_image) {
    {
#line 10894
    opj_event_msg(p_manager, 1, "We need an image previously created.\n");
    }
#line 10895
    return (0);
  }
#line 10898
  if (tile_index >= p_j2k->m_cp.tw * p_j2k->m_cp.th) {
    {
#line 10899
    opj_event_msg(p_manager, 1, "Tile index provided by the user is incorrect %d (max = %d) \n",
                  tile_index, p_j2k->m_cp.tw * p_j2k->m_cp.th - 1U);
    }
#line 10902
    return (0);
  }
#line 10906
  l_tile_x = tile_index % p_j2k->m_cp.tw;
#line 10907
  l_tile_y = tile_index / p_j2k->m_cp.tw;
#line 10909
  p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 10910
  if (p_image->x0 < (p_j2k->m_private_image)->x0) {
#line 10911
    p_image->x0 = (p_j2k->m_private_image)->x0;
  }
#line 10913
  p_image->x1 = (l_tile_x + 1U) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 10914
  if (p_image->x1 > (p_j2k->m_private_image)->x1) {
#line 10915
    p_image->x1 = (p_j2k->m_private_image)->x1;
  }
#line 10918
  p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 10919
  if (p_image->y0 < (p_j2k->m_private_image)->y0) {
#line 10920
    p_image->y0 = (p_j2k->m_private_image)->y0;
  }
#line 10922
  p_image->y1 = (l_tile_y + 1U) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 10923
  if (p_image->y1 > (p_j2k->m_private_image)->y1) {
#line 10924
    p_image->y1 = (p_j2k->m_private_image)->y1;
  }
#line 10927
  l_img_comp = p_image->comps;
#line 10928
  compno = (OPJ_UINT32 )0;
  {
#line 10928
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10928
    if (! (compno < p_image->numcomps)) {
#line 10928
      goto while_break;
    }
    {
#line 10931
    l_img_comp->factor = ((p_j2k->m_private_image)->comps + compno)->factor;
#line 10933
    __cil_tmp12 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 10933
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp12;
#line 10935
    __cil_tmp13 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 10935
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp13;
#line 10937
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 10938
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 10940
    __cil_tmp17 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
#line 10940
    __cil_tmp16 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 10940
    l_img_comp->w = (OPJ_UINT32 )(__cil_tmp16 - __cil_tmp17);
#line 10943
    __cil_tmp19 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
#line 10943
    __cil_tmp18 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 10943
    l_img_comp->h = (OPJ_UINT32 )(__cil_tmp18 - __cil_tmp19);
#line 10947
    l_img_comp ++;
#line 10928
    compno ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 10951
  if (p_j2k->m_output_image) {
    {
#line 10952
    opj_image_destroy(p_j2k->m_output_image);
    }
  }
  {
#line 10956
  p_j2k->m_output_image = opj_image_create0();
  }
#line 10957
  if (! p_j2k->m_output_image) {
#line 10958
    return (0);
  }
  {
#line 10960
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 10962
  p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32 )tile_index;
#line 10965
  __cil_tmp22 = opj_j2k_setup_decoding_tile(p_j2k, p_manager);
  }
#line 10965
  if (! __cil_tmp22) {
#line 10966
    return (0);
  }
  {
#line 10970
  __cil_tmp23 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 10970
  if (! __cil_tmp23) {
    {
#line 10971
    opj_image_destroy(p_j2k->m_private_image);
#line 10972
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 10973
    return (0);
  }
#line 10977
  compno = (OPJ_UINT32 )0;
  {
#line 10977
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 10977
    if (! (compno < p_image->numcomps)) {
#line 10977
      goto while_break___0;
    }
#line 10978
    (p_image->comps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + compno)->resno_decoded;
#line 10981
    if ((p_image->comps + compno)->data) {
      {
#line 10982
      opj_image_data_free((void *)(p_image->comps + compno)->data);
      }
    }
#line 10985
    (p_image->comps + compno)->data = ((p_j2k->m_output_image)->comps + compno)->data;
#line 10987
    ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
#line 10977
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 10990
  return (1);
}
}
#line 10993 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_UINT32 max_res ;

  {
#line 10999
  p_j2k->m_cp.m_specific_param.m_dec.m_reduce = res_factor;
#line 11001
  if (p_j2k->m_private_image) {
#line 11002
    if ((p_j2k->m_private_image)->comps) {
#line 11003
      if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {
#line 11004
        if ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps) {
#line 11005
          it_comp = (OPJ_UINT32 )0;
          {
#line 11005
          while (1) {
            while_continue: /* CIL Label */ ;

#line 11005
            if (! (it_comp < (p_j2k->m_private_image)->numcomps)) {
#line 11005
              goto while_break;
            }
#line 11006
            max_res = ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + it_comp)->numresolutions;
#line 11008
            if (res_factor >= max_res) {
              {
#line 11009
              opj_event_msg(p_manager, 1, "Resolution factor is greater than the maximum resolution in the component.\n2 V");
              }
#line 11011
              return (0);
            }
#line 11013
            ((p_j2k->m_private_image)->comps + it_comp)->factor = res_factor;
#line 11005
            it_comp ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: ;
#line 11015
          return (1);
        }
      }
    }
  }
#line 11021
  return (0);
}
}
#line 11024 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_SIZE_T l_max_tile_size ;
  OPJ_SIZE_T l_current_tile_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_BOOL l_reuse_data ;
  opj_tcd_t *p_tcd ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL __cil_tmp16 ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_img_comp___0 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;

  {
#line 11030
  l_max_tile_size = (OPJ_SIZE_T )0;
#line 11031
  l_current_data = (OPJ_BYTE *)0;
#line 11032
  l_reuse_data = 0;
#line 11033
  p_tcd = (opj_tcd_t *)0;
#line 11040
  p_tcd = p_j2k->m_tcd;
#line 11042
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 11043
  if (l_nb_tiles == 1U) {
#line 11044
    l_reuse_data = 1;
#line 11046
    j = (OPJ_UINT32 )0;
    {
#line 11046
    while (1) {
      while_continue: /* CIL Label */ ;

#line 11046
      if (! (j < ((p_j2k->m_tcd)->image)->numcomps)) {
#line 11046
        goto while_break;
      }
#line 11047
      l_img_comp = (p_tcd->image)->comps + j;
#line 11048
      if (((size_t )l_img_comp->data & 15UL) != 0UL) {
#line 11050
        l_reuse_data = 0;
      }
#line 11046
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 11055
  i = (OPJ_UINT32 )0;
  {
#line 11055
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 11055
    if (! (i < l_nb_tiles)) {
#line 11055
      goto while_break___0;
    }
    {
#line 11056
    __cil_tmp16 = opj_j2k_pre_write_tile(p_j2k, i, p_stream, p_manager);
    }
#line 11056
    if (! __cil_tmp16) {
#line 11057
      if (l_current_data) {
        {
#line 11058
        opj_free((void *)l_current_data);
        }
      }
#line 11060
      return (0);
    }
#line 11065
    j = (OPJ_UINT32 )0;
    {
#line 11065
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 11065
      if (! (j < ((p_j2k->m_tcd)->image)->numcomps)) {
#line 11065
        goto while_break___1;
      }
#line 11066
      l_tilec = ((p_tcd->tcd_image)->tiles)->comps + j;
#line 11067
      if (l_reuse_data) {
#line 11068
        l_img_comp___0 = (p_tcd->image)->comps + j;
#line 11069
        l_tilec->data = l_img_comp___0->data;
#line 11070
        l_tilec->ownsData = 0;
      } else {
        {
#line 11072
        __cil_tmp19 = opj_alloc_tile_component_data(l_tilec);
        }
#line 11072
        if (! __cil_tmp19) {
          {
#line 11073
          opj_event_msg(p_manager, 1, "Error allocating tile component data.V");
          }
#line 11074
          if (l_current_data) {
            {
#line 11075
            opj_free((void *)l_current_data);
            }
          }
#line 11077
          return (0);
        }
      }
#line 11065
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 11081
    l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);
    }
#line 11082
    if (! l_reuse_data) {
#line 11083
      if (l_current_tile_size > l_max_tile_size) {
        {
#line 11084
        __cil_tmp22 = opj_realloc((void *)l_current_data, l_current_tile_size);
#line 11084
        l_new_current_data = (OPJ_BYTE *)__cil_tmp22;
        }
#line 11086
        if (! l_new_current_data) {
#line 11087
          if (l_current_data) {
            {
#line 11088
            opj_free((void *)l_current_data);
            }
          }
          {
#line 11090
          opj_event_msg(p_manager, 1, "Not enough memory to encode all tiles\n");
          }
#line 11091
          return (0);
        }
#line 11093
        l_current_data = l_new_current_data;
#line 11094
        l_max_tile_size = l_current_tile_size;
      }
      {
#line 11100
      opj_j2k_get_tile_data(p_j2k->m_tcd, l_current_data);
#line 11103
      __cil_tmp23 = opj_tcd_copy_tile_data(p_j2k->m_tcd, l_current_data, l_current_tile_size);
      }
#line 11103
      if (! __cil_tmp23) {
        {
#line 11105
        opj_event_msg(p_manager, 1, "Size mismatch between tile data and sent data.");
#line 11107
        opj_free((void *)l_current_data);
        }
#line 11108
        return (0);
      }
    }
    {
#line 11112
    __cil_tmp24 = opj_j2k_post_write_tile(p_j2k, p_stream, p_manager);
    }
#line 11112
    if (! __cil_tmp24) {
#line 11113
      if (l_current_data) {
        {
#line 11114
        opj_free((void *)l_current_data);
        }
      }
#line 11116
      return (0);
    }
#line 11055
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 11120
  if (l_current_data) {
    {
#line 11121
    opj_free((void *)l_current_data);
    }
  }
#line 11123
  return (1);
}
}
#line 11126 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 11131
  __cil_tmp4 = opj_j2k_setup_end_compress(p_j2k, p_manager);
  }
#line 11131
  if (! __cil_tmp4) {
#line 11132
    return (0);
  }
  {
#line 11135
  __cil_tmp5 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 11135
  if (! __cil_tmp5) {
#line 11136
    return (0);
  }
#line 11139
  return (1);
}
}
#line 11142 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 11152
  p_j2k->m_private_image = opj_image_create0();
  }
#line 11153
  if (! p_j2k->m_private_image) {
    {
#line 11154
    opj_event_msg(p_manager, 1, "Failed to allocate image header.\220");
    }
#line 11155
    return (0);
  }
  {
#line 11157
  opj_copy_image_header(p_image, p_j2k->m_private_image);
  }
#line 11160
  if (p_image->comps) {
#line 11162
    it_comp = (OPJ_UINT32 )0;
    {
#line 11162
    while (1) {
      while_continue: /* CIL Label */ ;

#line 11162
      if (! (it_comp < p_image->numcomps)) {
#line 11162
        goto while_break;
      }
#line 11163
      if ((p_image->comps + it_comp)->data) {
#line 11164
        ((p_j2k->m_private_image)->comps + it_comp)->data = (p_image->comps + it_comp)->data;
#line 11165
        (p_image->comps + it_comp)->data = (OPJ_INT32 *)((void *)0);
      }
#line 11162
      it_comp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 11172
  __cil_tmp11 = opj_j2k_setup_encoding_validation(p_j2k, p_manager);
  }
#line 11172
  if (! __cil_tmp11) {
#line 11173
    return (0);
  }
  {
#line 11177
  __cil_tmp12 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 11177
  if (! __cil_tmp12) {
#line 11178
    return (0);
  }
  {
#line 11182
  __cil_tmp13 = opj_j2k_setup_header_writing(p_j2k, p_manager);
  }
#line 11182
  if (! __cil_tmp13) {
#line 11183
    return (0);
  }
  {
#line 11187
  __cil_tmp14 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 11187
  if (! __cil_tmp14) {
#line 11188
    return (0);
  }
#line 11191
  return (1);
}
}
#line 11194 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index ,
                                       opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
#line 11200
  if (p_tile_index != p_j2k->m_current_tile_number) {
    {
#line 11201
    opj_event_msg(p_manager, 1, "The given tile index does not match.");
    }
#line 11202
    return (0);
  }
  {
#line 11205
  opj_event_msg(p_manager, 4, "tile number %d / %d\n V", p_j2k->m_current_tile_number + 1U,
                p_j2k->m_cp.tw * p_j2k->m_cp.th);
#line 11208
  p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = (OPJ_UINT32 )0;
#line 11209
  (p_j2k->m_tcd)->cur_totnum_tp = (p_j2k->m_cp.tcps + p_tile_index)->m_nb_tile_parts;
#line 11210
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 11213
  __cil_tmp5 = opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,
                                        p_manager);
  }
#line 11213
  if (! __cil_tmp5) {
#line 11215
    return (0);
  }
#line 11218
  return (1);
}
}
#line 11221 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_get_tile_dimensions(opj_image_t *l_image , opj_tcd_tilecomp_t *l_tilec ,
                                    opj_image_comp_t *l_img_comp , OPJ_UINT32 *l_size_comp ,
                                    OPJ_UINT32 *l_width , OPJ_UINT32 *l_height , OPJ_UINT32 *l_offset_x ,
                                    OPJ_UINT32 *l_offset_y , OPJ_UINT32 *l_image_width ,
                                    OPJ_UINT32 *l_stride , OPJ_UINT32 *l_tile_offset ) 
{ 
  OPJ_UINT32 l_remaining ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;

  {
#line 11234
  *l_size_comp = l_img_comp->prec >> 3;
#line 11235
  l_remaining = l_img_comp->prec & 7U;
#line 11236
  if (l_remaining) {
#line 11237
    (*l_size_comp) ++;
  }
#line 11240
  if (*l_size_comp == 3U) {
#line 11241
    *l_size_comp = (OPJ_UINT32 )4;
  }
  {
#line 11244
  *l_width = (OPJ_UINT32 )(l_tilec->x1 - l_tilec->x0);
#line 11245
  *l_height = (OPJ_UINT32 )(l_tilec->y1 - l_tilec->y0);
#line 11246
  __cil_tmp13 = opj_int_ceildiv((OPJ_INT32 )l_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 11246
  *l_offset_x = (OPJ_UINT32 )__cil_tmp13;
#line 11248
  __cil_tmp14 = opj_int_ceildiv((OPJ_INT32 )l_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 11248
  *l_offset_y = (OPJ_UINT32 )__cil_tmp14;
#line 11250
  __cil_tmp15 = opj_int_ceildiv((OPJ_INT32 )l_image->x1 - (OPJ_INT32 )l_image->x0,
                                (OPJ_INT32 )l_img_comp->dx);
#line 11250
  *l_image_width = (OPJ_UINT32 )__cil_tmp15;
#line 11252
  *l_stride = *l_image_width - *l_width;
#line 11253
  *l_tile_offset = ((OPJ_UINT32 )l_tilec->x0 - *l_offset_x) + ((OPJ_UINT32 )l_tilec->y0 - *l_offset_y) * *l_image_width;
  }
#line 11255
  return;
}
}
#line 11257 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  opj_image_t *l_image ;
  OPJ_INT32 *l_src_ptr ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 l_offset_x ;
  OPJ_UINT32 l_offset_y ;
  OPJ_UINT32 l_image_width ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_tile_offset ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 *__cil_tmp20 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_INT16 *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp25 ;
  OPJ_INT32 *__cil_tmp26 ;

  {
#line 11259
  k = (OPJ_UINT32 )0;
#line 11261
  i = (OPJ_UINT32 )0;
  {
#line 11261
  while (1) {
    while_continue: /* CIL Label */ ;

#line 11261
    if (! (i < (p_tcd->image)->numcomps)) {
#line 11261
      goto while_break;
    }
    {
#line 11262
    l_image = p_tcd->image;
#line 11264
    l_tilec = ((p_tcd->tcd_image)->tiles)->comps + i;
#line 11265
    l_img_comp = l_image->comps + i;
#line 11269
    opj_get_tile_dimensions(l_image, l_tilec, l_img_comp, & l_size_comp, & l_width,
                            & l_height, & l_offset_x, & l_offset_y, & l_image_width,
                            & l_stride, & l_tile_offset);
#line 11281
    l_src_ptr = l_img_comp->data + l_tile_offset;
    }
#line 11284
    if (l_size_comp == 1U) {
#line 11284
      goto case_1;
    }
#line 11309
    if (l_size_comp == 2U) {
#line 11309
      goto case_2;
    }
#line 11330
    if (l_size_comp == 4U) {
#line 11330
      goto case_4;
    }
#line 11283
    goto switch_break;
    case_1: 
#line 11285
    l_dest_ptr = (OPJ_CHAR *)p_data;
#line 11286
    if (l_img_comp->sgnd) {
#line 11287
      j = (OPJ_UINT32 )0;
      {
#line 11287
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 11287
        if (! (j < l_height)) {
#line 11287
          goto while_break___0;
        }
#line 11288
        k = (OPJ_UINT32 )0;
        {
#line 11288
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 11288
          if (! (k < l_width)) {
#line 11288
            goto while_break___1;
          }
#line 11289
          *l_dest_ptr = (OPJ_CHAR )*l_src_ptr;
#line 11290
          l_dest_ptr ++;
#line 11291
          l_src_ptr ++;
#line 11288
          k ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___1: 
#line 11293
        l_src_ptr += l_stride;
#line 11287
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 11296
      j = (OPJ_UINT32 )0;
      {
#line 11296
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 11296
        if (! (j < l_height)) {
#line 11296
          goto while_break___2;
        }
#line 11297
        k = (OPJ_UINT32 )0;
        {
#line 11297
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 11297
          if (! (k < l_width)) {
#line 11297
            goto while_break___3;
          }
#line 11298
          *l_dest_ptr = (OPJ_CHAR )(*l_src_ptr & 255);
#line 11299
          l_dest_ptr ++;
#line 11300
          l_src_ptr ++;
#line 11297
          k ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___3: 
#line 11302
        l_src_ptr += l_stride;
#line 11296
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 11306
    p_data = (OPJ_BYTE *)l_dest_ptr;
#line 11308
    goto switch_break;
    case_2: 
#line 11310
    l_dest_ptr___0 = (OPJ_INT16 *)p_data;
#line 11311
    if (l_img_comp->sgnd) {
#line 11312
      j = (OPJ_UINT32 )0;
      {
#line 11312
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 11312
        if (! (j < l_height)) {
#line 11312
          goto while_break___4;
        }
#line 11313
        k = (OPJ_UINT32 )0;
        {
#line 11313
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 11313
          if (! (k < l_width)) {
#line 11313
            goto while_break___5;
          }
#line 11314
          __cil_tmp21 = l_src_ptr;
#line 11314
          l_src_ptr ++;
#line 11314
          __cil_tmp20 = l_dest_ptr___0;
#line 11314
          l_dest_ptr___0 ++;
#line 11314
          *__cil_tmp20 = (OPJ_INT16 )*__cil_tmp21;
#line 11313
          k ++;
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___5: 
#line 11316
        l_src_ptr += l_stride;
#line 11312
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___4: ;
    } else {
#line 11319
      j = (OPJ_UINT32 )0;
      {
#line 11319
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 11319
        if (! (j < l_height)) {
#line 11319
          goto while_break___6;
        }
#line 11320
        k = (OPJ_UINT32 )0;
        {
#line 11320
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 11320
          if (! (k < l_width)) {
#line 11320
            goto while_break___7;
          }
#line 11321
          __cil_tmp23 = l_src_ptr;
#line 11321
          l_src_ptr ++;
#line 11321
          __cil_tmp22 = l_dest_ptr___0;
#line 11321
          l_dest_ptr___0 ++;
#line 11321
          *__cil_tmp22 = (OPJ_INT16 )(*__cil_tmp23 & 65535);
#line 11320
          k ++;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___7: 
#line 11323
        l_src_ptr += l_stride;
#line 11319
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: ;
    }
#line 11327
    p_data = (OPJ_BYTE *)l_dest_ptr___0;
#line 11329
    goto switch_break;
    case_4: 
#line 11331
    l_dest_ptr___1 = (OPJ_INT32 *)p_data;
#line 11332
    j = (OPJ_UINT32 )0;
    {
#line 11332
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 11332
      if (! (j < l_height)) {
#line 11332
        goto while_break___8;
      }
#line 11333
      k = (OPJ_UINT32 )0;
      {
#line 11333
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 11333
        if (! (k < l_width)) {
#line 11333
          goto while_break___9;
        }
#line 11334
        __cil_tmp26 = l_src_ptr;
#line 11334
        l_src_ptr ++;
#line 11334
        __cil_tmp25 = l_dest_ptr___1;
#line 11334
        l_dest_ptr___1 ++;
#line 11334
        *__cil_tmp25 = *__cil_tmp26;
#line 11333
        k ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___9: 
#line 11336
      l_src_ptr += l_stride;
#line 11332
      j ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___8: 
#line 11339
    p_data = (OPJ_BYTE *)l_dest_ptr___1;
#line 11341
    goto switch_break;
    switch_break: 
#line 11261
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: ;
#line 11265
  return;
}
}
#line 11346 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tile_size ;
  OPJ_UINT32 l_available_data ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
  {
#line 11351
  l_current_data = (OPJ_BYTE *)0;
#line 11352
  l_tile_size = (OPJ_UINT32 )0;
#line 11358
  l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;
#line 11359
  l_available_data = l_tile_size;
#line 11360
  l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;
#line 11362
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 11363
  __cil_tmp9 = opj_j2k_write_first_tile_part(p_j2k, l_current_data, & l_nb_bytes_written,
                                             l_available_data, p_stream, p_manager);
  }
#line 11363
  if (! __cil_tmp9) {
#line 11365
    return (0);
  }
  {
#line 11367
  l_current_data += l_nb_bytes_written;
#line 11368
  l_available_data -= l_nb_bytes_written;
#line 11370
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 11371
  __cil_tmp10 = opj_j2k_write_all_tile_parts(p_j2k, l_current_data, & l_nb_bytes_written,
                                             l_available_data, p_stream, p_manager);
  }
#line 11371
  if (! __cil_tmp10) {
#line 11373
    return (0);
  }
  {
#line 11376
  l_available_data -= l_nb_bytes_written;
#line 11377
  l_nb_bytes_written = l_tile_size - l_available_data;
#line 11379
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,
                                      (OPJ_SIZE_T )l_nb_bytes_written, p_manager);
  }
#line 11379
  if (__cil_tmp11 != (unsigned long )l_nb_bytes_written) {
#line 11382
    return (0);
  }
#line 11385
  (p_j2k->m_current_tile_number) ++;
#line 11387
  return (1);
}
}
#line 11390 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 11398
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_eoc),
                                                p_manager);
  }
#line 11398
  if (! __cil_tmp5) {
#line 11400
    return (0);
  }
#line 11403
  if ((int )p_j2k->m_cp.rsiz >= 3) {
#line 11403
    if ((int )p_j2k->m_cp.rsiz <= 6) {
      {
#line 11404
      __cil_tmp6 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_updated_tlm),
                                                    p_manager);
      }
#line 11404
      if (! __cil_tmp6) {
#line 11406
        return (0);
      }
    }
  }
  {
#line 11410
  __cil_tmp7 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_epc),
                                                p_manager);
  }
#line 11410
  if (! __cil_tmp7) {
#line 11412
    return (0);
  }
  {
#line 11414
  __cil_tmp8 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_end_encoding),
                                                p_manager);
  }
#line 11414
  if (! __cil_tmp8) {
#line 11416
    return (0);
  }
  {
#line 11418
  __cil_tmp9 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_destroy_header_memory),
                                                p_manager);
  }
#line 11418
  if (! __cil_tmp9) {
#line 11420
    return (0);
  }
#line 11422
  return (1);
}
}
#line 11425 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 11432
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_build_encoder),
                                                p_manager);
  }
#line 11432
  if (! __cil_tmp5) {
#line 11434
    return (0);
  }
  {
#line 11436
  __cil_tmp6 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_encoding_validation),
                                                p_manager);
  }
#line 11436
  if (! __cil_tmp6) {
#line 11438
    return (0);
  }
  {
#line 11442
  __cil_tmp7 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_mct_validation),
                                                p_manager);
  }
#line 11442
  if (! __cil_tmp7) {
#line 11444
    return (0);
  }
#line 11447
  return (1);
}
}
#line 11450 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;

  {
  {
#line 11457
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_init_info),
                                                p_manager);
  }
#line 11457
  if (! __cil_tmp5) {
#line 11459
    return (0);
  }
  {
#line 11461
  __cil_tmp6 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_soc),
                                                p_manager);
  }
#line 11461
  if (! __cil_tmp6) {
#line 11463
    return (0);
  }
  {
#line 11465
  __cil_tmp7 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_siz),
                                                p_manager);
  }
#line 11465
  if (! __cil_tmp7) {
#line 11467
    return (0);
  }
  {
#line 11469
  __cil_tmp8 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_cod),
                                                p_manager);
  }
#line 11469
  if (! __cil_tmp8) {
#line 11471
    return (0);
  }
  {
#line 11473
  __cil_tmp9 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_qcd),
                                                p_manager);
  }
#line 11473
  if (! __cil_tmp9) {
#line 11475
    return (0);
  }
  {
#line 11477
  __cil_tmp10 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_all_coc),
                                                 p_manager);
  }
#line 11477
  if (! __cil_tmp10) {
#line 11479
    return (0);
  }
  {
#line 11481
  __cil_tmp11 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_all_qcc),
                                                 p_manager);
  }
#line 11481
  if (! __cil_tmp11) {
#line 11483
    return (0);
  }
#line 11486
  if ((int )p_j2k->m_cp.rsiz >= 3) {
#line 11486
    if ((int )p_j2k->m_cp.rsiz <= 6) {
      {
#line 11487
      __cil_tmp12 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_tlm),
                                                     p_manager);
      }
#line 11487
      if (! __cil_tmp12) {
#line 11489
        return (0);
      }
#line 11492
      if ((int )p_j2k->m_cp.rsiz == 4) {
        {
#line 11493
        __cil_tmp13 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_poc),
                                                       p_manager);
        }
#line 11493
        if (! __cil_tmp13) {
#line 11495
          return (0);
        }
      }
    }
  }
  {
#line 11500
  __cil_tmp14 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_regions),
                                                 p_manager);
  }
#line 11500
  if (! __cil_tmp14) {
#line 11502
    return (0);
  }
#line 11505
  if ((unsigned long )p_j2k->m_cp.comment != (unsigned long )((OPJ_CHAR *)0)) {
    {
#line 11506
    __cil_tmp15 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_com),
                                                   p_manager);
    }
#line 11506
    if (! __cil_tmp15) {
#line 11508
      return (0);
    }
  }
#line 11513
  if ((int )p_j2k->m_cp.rsiz & 256) {
    {
#line 11514
    __cil_tmp16 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_mct_data_group),
                                                   p_manager);
    }
#line 11514
    if (! __cil_tmp16) {
#line 11516
      return (0);
    }
  }
#line 11521
  if (p_j2k->cstr_index) {
    {
#line 11522
    __cil_tmp17 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_get_end_header),
                                                   p_manager);
    }
#line 11522
    if (! __cil_tmp17) {
#line 11524
      return (0);
    }
  }
  {
#line 11528
  __cil_tmp18 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_create_tcd),
                                                 p_manager);
  }
#line 11528
  if (! __cil_tmp18) {
#line 11530
    return (0);
  }
  {
#line 11532
  __cil_tmp19 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_update_rates),
                                                 p_manager);
  }
#line 11532
  if (! __cil_tmp19) {
#line 11534
    return (0);
  }
#line 11537
  return (1);
}
}
#line 11540 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                              OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                                              opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_BYTE *l_begin_data ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 11547
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 11549
  l_begin_data = (OPJ_BYTE *)0;
#line 11551
  l_tcd = (opj_tcd_t *)0;
#line 11552
  l_cp = (opj_cp_t *)0;
#line 11554
  l_tcd = p_j2k->m_tcd;
#line 11555
  l_cp = & p_j2k->m_cp;
#line 11557
  l_tcd->cur_pino = (OPJ_UINT32 )0;
#line 11560
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 11565
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 11566
  l_begin_data = p_data;
#line 11567
  __cil_tmp12 = opj_j2k_write_sot(p_j2k, p_data, p_total_data_size, & l_current_nb_bytes_written,
                                  p_stream, p_manager);
  }
#line 11567
  if (! __cil_tmp12) {
#line 11570
    return (0);
  }
#line 11573
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 11574
  p_data += l_current_nb_bytes_written;
#line 11575
  p_total_data_size -= l_current_nb_bytes_written;
#line 11577
  if ((int )l_cp->rsiz >= 3) {
#line 11577
    if (! ((int )l_cp->rsiz <= 6)) {
#line 11577
      goto _L___19;
    }
  } else
  _L___19: /* CIL Label */ 
#line 11595
  if ((l_cp->tcps + p_j2k->m_current_tile_number)->numpocs) {
    {
#line 11596
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 11597
    opj_j2k_write_poc_in_memory(p_j2k, p_data, & l_current_nb_bytes_written, p_manager);
#line 11599
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 11600
    p_data += l_current_nb_bytes_written;
#line 11601
    p_total_data_size -= l_current_nb_bytes_written;
    }
  }
  {
#line 11605
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 11606
  __cil_tmp13 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                  p_total_data_size, p_stream, p_manager);
  }
#line 11606
  if (! __cil_tmp13) {
#line 11608
    return (0);
  }
  {
#line 11611
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 11612
  *p_data_written = l_nb_bytes_written;
#line 11615
  opj_write_bytes_LE(l_begin_data + 6, l_nb_bytes_written, (OPJ_UINT32 )4);
  }
#line 11618
  if ((int )l_cp->rsiz >= 3) {
#line 11618
    if ((int )l_cp->rsiz <= 6) {
      {
#line 11619
      opj_j2k_update_tlm(p_j2k, l_nb_bytes_written);
      }
    }
  }
#line 11622
  return (1);
}
}
#line 11625 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                                             opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 tilepartno ;
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_UINT32 l_part_tile_size ;
  OPJ_UINT32 tot_num_tp ;
  OPJ_UINT32 pino ;
  OPJ_BYTE *l_begin_data ;
  opj_tcp_t *l_tcp ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;

  {
  {
#line 11633
  tilepartno = (OPJ_UINT32 )0;
#line 11634
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 11641
  l_tcp = (opj_tcp_t *)0;
#line 11642
  l_tcd = (opj_tcd_t *)0;
#line 11643
  l_cp = (opj_cp_t *)0;
#line 11645
  l_tcd = p_j2k->m_tcd;
#line 11646
  l_cp = & p_j2k->m_cp;
#line 11647
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 11650
  tot_num_tp = opj_j2k_get_num_tp(l_cp, (OPJ_UINT32 )0, p_j2k->m_current_tile_number);
#line 11653
  (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 11654
  tilepartno = (OPJ_UINT32 )1;
  }
  {
#line 11654
  while (1) {
    while_continue: /* CIL Label */ ;

#line 11654
    if (! (tilepartno < tot_num_tp)) {
#line 11654
      goto while_break;
    }
    {
#line 11655
    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 11656
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 11657
    l_part_tile_size = (OPJ_UINT32 )0;
#line 11658
    l_begin_data = p_data;
#line 11660
    __cil_tmp18 = opj_j2k_write_sot(p_j2k, p_data, p_total_data_size, & l_current_nb_bytes_written,
                                    p_stream, p_manager);
    }
#line 11660
    if (! __cil_tmp18) {
#line 11665
      return (0);
    }
    {
#line 11668
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 11669
    p_data += l_current_nb_bytes_written;
#line 11670
    p_total_data_size -= l_current_nb_bytes_written;
#line 11671
    l_part_tile_size += l_current_nb_bytes_written;
#line 11673
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 11674
    __cil_tmp19 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                    p_total_data_size, p_stream, p_manager);
    }
#line 11674
    if (! __cil_tmp19) {
#line 11676
      return (0);
    }
    {
#line 11679
    p_data += l_current_nb_bytes_written;
#line 11680
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 11681
    p_total_data_size -= l_current_nb_bytes_written;
#line 11682
    l_part_tile_size += l_current_nb_bytes_written;
#line 11685
    opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
    }
#line 11688
    if ((int )l_cp->rsiz >= 3) {
#line 11688
      if ((int )l_cp->rsiz <= 6) {
        {
#line 11689
        opj_j2k_update_tlm(p_j2k, l_part_tile_size);
        }
      }
    }
#line 11692
    (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 11654
    tilepartno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 11695
  pino = (OPJ_UINT32 )1;
  {
#line 11695
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 11695
    if (! (pino <= l_tcp->numpocs)) {
#line 11695
      goto while_break___0;
    }
    {
#line 11696
    l_tcd->cur_pino = pino;
#line 11699
    tot_num_tp = opj_j2k_get_num_tp(l_cp, pino, p_j2k->m_current_tile_number);
#line 11700
    tilepartno = (OPJ_UINT32 )0;
    }
    {
#line 11700
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 11700
      if (! (tilepartno < tot_num_tp)) {
#line 11700
        goto while_break___1;
      }
      {
#line 11701
      p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 11702
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 11703
      l_part_tile_size = (OPJ_UINT32 )0;
#line 11704
      l_begin_data = p_data;
#line 11706
      __cil_tmp21 = opj_j2k_write_sot(p_j2k, p_data, p_total_data_size, & l_current_nb_bytes_written,
                                      p_stream, p_manager);
      }
#line 11706
      if (! __cil_tmp21) {
#line 11710
        return (0);
      }
      {
#line 11713
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 11714
      p_data += l_current_nb_bytes_written;
#line 11715
      p_total_data_size -= l_current_nb_bytes_written;
#line 11716
      l_part_tile_size += l_current_nb_bytes_written;
#line 11718
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 11720
      __cil_tmp22 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                      p_total_data_size, p_stream, p_manager);
      }
#line 11720
      if (! __cil_tmp22) {
#line 11722
        return (0);
      }
      {
#line 11725
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 11726
      p_data += l_current_nb_bytes_written;
#line 11727
      p_total_data_size -= l_current_nb_bytes_written;
#line 11728
      l_part_tile_size += l_current_nb_bytes_written;
#line 11731
      opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
      }
#line 11734
      if ((int )l_cp->rsiz >= 3) {
#line 11734
        if ((int )l_cp->rsiz <= 6) {
          {
#line 11735
          opj_j2k_update_tlm(p_j2k, l_part_tile_size);
          }
        }
      }
#line 11738
      (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 11700
      tilepartno ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 11695
    pino ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 11742
  *p_data_written = l_nb_bytes_written;
#line 11744
  return (1);
}
}
#line 11747 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                          struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_tlm_size ;
  OPJ_OFF_T l_tlm_position ;
  OPJ_OFF_T l_current_position ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_SIZE_T __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 11759
  l_tlm_size = 5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 11760
  l_tlm_position = 6L + p_j2k->m_specific_param.m_encoder.m_tlm_start;
#line 11761
  l_current_position = opj_stream_tell(p_stream);
#line 11763
  __cil_tmp11 = opj_stream_seek(p_stream, l_tlm_position, p_manager);
  }
#line 11763
  if (! __cil_tmp11) {
#line 11764
    return (0);
  }
  {
#line 11767
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 11767
  if (__cil_tmp12 != (unsigned long )l_tlm_size) {
#line 11770
    return (0);
  }
  {
#line 11773
  __cil_tmp13 = opj_stream_seek(p_stream, l_current_position, p_manager);
  }
#line 11773
  if (! __cil_tmp13) {
#line 11774
    return (0);
  }
#line 11777
  return (1);
}
}
#line 11780 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                     struct opj_event_mgr *p_manager ) 
{ 


  {
  {
#line 11792
  opj_tcd_destroy(p_j2k->m_tcd);
#line 11793
  p_j2k->m_tcd = (struct opj_tcd *)0;
  }
#line 11795
  if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
    {
#line 11796
    opj_free((void *)p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 11797
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 11798
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
    }
  }
#line 11801
  if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
    {
#line 11802
    opj_free((void *)p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 11803
    p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 11806
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = (OPJ_UINT32 )0;
#line 11808
  return (1);
}
}
#line 11814 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) 
{ 


  {
#line 11827
  if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 11828
    opj_free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 11829
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 11832
  p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 11834
  return (1);
}
}
#line 11837 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 11841
  l_cstr_info = (opj_codestream_info_t *)0;
#line 11890
  __cil_tmp8 = opj_j2k_calculate_tp(p_j2k, & p_j2k->m_cp, & p_j2k->m_specific_param.m_encoder.m_total_tile_parts,
                                    p_j2k->m_private_image, p_manager);
  }
#line 11890
  return (__cil_tmp8);
}
}
#line 11902 "/root/patron/new_24/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 11914
  p_j2k->m_tcd = opj_tcd_create(0);
  }
#line 11916
  if (! p_j2k->m_tcd) {
    {
#line 11917
    opj_event_msg(p_manager, 1, "Not enough memory to create Tile Coder\n");
    }
#line 11918
    return (0);
  }
  {
#line 11921
  __cil_tmp8 = opj_tcd_init(p_j2k->m_tcd, p_j2k->m_private_image, & p_j2k->m_cp, p_j2k->m_tp);
  }
#line 11921
  if (! __cil_tmp8) {
    {
#line 11923
    opj_tcd_destroy(p_j2k->m_tcd);
#line 11924
    p_j2k->m_tcd = (struct opj_tcd *)0;
    }
#line 11925
    return (0);
  }
#line 11928
  return (1);
}
}
#line 11931 "/root/patron/new_24/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_UINT32 j ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 11938
  __cil_tmp7 = opj_j2k_pre_write_tile(p_j2k, p_tile_index, p_stream, p_manager);
  }
#line 11938
  if (! __cil_tmp7) {
    {
#line 11939
    opj_event_msg(p_manager, 1, "Error while opj_j2k_pre_write_tile with tile index = %d\n\230\001",
                  p_tile_index);
    }
#line 11941
    return (0);
  } else {
#line 11945
    j = (OPJ_UINT32 )0;
    {
#line 11945
    while (1) {
      while_continue: /* CIL Label */ ;

#line 11945
      if (! (j < ((p_j2k->m_tcd)->image)->numcomps)) {
#line 11945
        goto while_break;
      }
      {
#line 11946
      l_tilec = (((p_j2k->m_tcd)->tcd_image)->tiles)->comps + j;
#line 11948
      __cil_tmp10 = opj_alloc_tile_component_data(l_tilec);
      }
#line 11948
      if (! __cil_tmp10) {
        {
#line 11949
        opj_event_msg(p_manager, 1, "Error allocating tile component data.");
        }
#line 11950
        return (0);
      }
#line 11945
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 11955
    __cil_tmp11 = opj_tcd_copy_tile_data(p_j2k->m_tcd, p_data, (OPJ_SIZE_T )p_data_size);
    }
#line 11955
    if (! __cil_tmp11) {
      {
#line 11956
      opj_event_msg(p_manager, 1, "Size mismatch between tile data and sent data.");
      }
#line 11958
      return (0);
    }
    {
#line 11960
    __cil_tmp12 = opj_j2k_post_write_tile(p_j2k, p_stream, p_manager);
    }
#line 11960
    if (! __cil_tmp12) {
      {
#line 11961
      opj_event_msg(p_manager, 1, "Error while opj_j2k_post_write_tile with tile index = %d\n",
                    p_tile_index);
      }
#line 11963
      return (0);
    }
  }
#line 11967
  return (1);
}
}
#line 37 "/root/patron/new_24/src/lib/openjp2/invert.c"
static OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations ,
                                 OPJ_FLOAT32 *p_swap_area , OPJ_UINT32 nb_compo ) ;
#line 44
static void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                         OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo , OPJ_FLOAT32 *p_intermediate_data ) ;
#line 54
static void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix , OPJ_UINT32 nb_compo ,
                          OPJ_UINT32 *pPermutations , OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp ,
                          OPJ_FLOAT32 *p_swap_area ) ;
#line 70 "/root/patron/new_24/src/lib/openjp2/invert.c"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) 
{ 
  OPJ_BYTE *l_data ;
  OPJ_UINT32 l_permutation_size ;
  OPJ_UINT32 l_swap_size ;
  OPJ_UINT32 l_total_size ;
  OPJ_UINT32 *lPermutations ;
  OPJ_FLOAT32 *l_double_data ;
  void *__cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 74
  l_data = (OPJ_BYTE *)0;
#line 75
  l_permutation_size = nb_compo * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 76
  l_swap_size = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 77
  l_total_size = l_permutation_size + 3U * l_swap_size;
#line 78
  lPermutations = (OPJ_UINT32 *)0;
#line 79
  l_double_data = (OPJ_FLOAT32 *)0;
#line 81
  __cil_tmp10 = opj_malloc((size_t )l_total_size);
#line 81
  l_data = (OPJ_BYTE *)__cil_tmp10;
  }
#line 82
  if ((unsigned long )l_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 83
    return (0);
  }
  {
#line 85
  lPermutations = (OPJ_UINT32 *)l_data;
#line 86
  l_double_data = (OPJ_FLOAT32 *)(l_data + l_permutation_size);
#line 87
  memset((void *)lPermutations, 0, (unsigned long )l_permutation_size);
#line 89
  __cil_tmp11 = opj_lupDecompose(pSrcMatrix, lPermutations, l_double_data, nb_compo);
  }
#line 89
  if (! __cil_tmp11) {
    {
#line 90
    opj_free((void *)l_data);
    }
#line 91
    return (0);
  }
  {
#line 94
  opj_lupInvert(pSrcMatrix, pDestMatrix, nb_compo, lPermutations, l_double_data, l_double_data + nb_compo,
                l_double_data + 2U * nb_compo);
#line 96
  opj_free((void *)l_data);
  }
#line 98
  return (1);
}
}
#line 107 "/root/patron/new_24/src/lib/openjp2/invert.c"
static OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations ,
                                 OPJ_FLOAT32 *p_swap_area , OPJ_UINT32 nb_compo ) 
{ 
  OPJ_UINT32 *tmpPermutations ;
  OPJ_UINT32 *dstPermutations ;
  OPJ_UINT32 k2 ;
  OPJ_UINT32 t ;
  OPJ_FLOAT32 temp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_FLOAT32 p ;
  OPJ_UINT32 lLastColum ;
  OPJ_UINT32 lSwapSize ;
  OPJ_FLOAT32 *lTmpMatrix ;
  OPJ_FLOAT32 *lColumnMatrix ;
  OPJ_FLOAT32 *lDestMatrix ;
  OPJ_UINT32 offset ;
  OPJ_UINT32 lStride ;
  OPJ_UINT32 *__cil_tmp21 ;
  OPJ_FLOAT32 tmp ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  OPJ_FLOAT32 *__cil_tmp24 ;
  OPJ_FLOAT32 *__cil_tmp25 ;
  OPJ_FLOAT32 *__cil_tmp26 ;

  {
#line 112
  tmpPermutations = permutations;
#line 114
  k2 = (OPJ_UINT32 )0;
#line 118
  lLastColum = nb_compo - 1U;
#line 119
  lSwapSize = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 120
  lTmpMatrix = matrix;
#line 122
  offset = (OPJ_UINT32 )1;
#line 123
  lStride = nb_compo - 1U;
#line 126
  i = (OPJ_UINT32 )0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;

#line 126
    if (! (i < nb_compo)) {
#line 126
      goto while_break;
    }
#line 127
    __cil_tmp21 = tmpPermutations;
#line 127
    tmpPermutations ++;
#line 127
    *__cil_tmp21 = i;
#line 126
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 130
  tmpPermutations = permutations;
#line 131
  k = (OPJ_UINT32 )0;
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 131
    if (! (k < lLastColum)) {
#line 131
      goto while_break___0;
    }
#line 132
    p = (OPJ_FLOAT32 )0.;
#line 135
    lColumnMatrix = lTmpMatrix + k;
#line 138
    i = k;
    {
#line 138
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 138
      if (! (i < nb_compo)) {
#line 138
        goto while_break___1;
      }
#line 139
      if (*lColumnMatrix > (float )0) {
#line 139
        tmp = *lColumnMatrix;
      } else {
#line 139
        tmp = - *lColumnMatrix;
      }
#line 139
      temp = tmp;
#line 140
      if (temp > p) {
#line 141
        p = temp;
#line 142
        k2 = i;
      }
#line 145
      lColumnMatrix += nb_compo;
#line 138
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: ;
#line 149
    if ((double )p == 0.) {
#line 150
      return (0);
    }
#line 154
    if (k2 != k) {
      {
#line 157
      dstPermutations = (tmpPermutations + k2) - k;
#line 159
      t = *tmpPermutations;
#line 160
      *tmpPermutations = *dstPermutations;
#line 161
      *dstPermutations = t;
#line 164
      lColumnMatrix = lTmpMatrix + (k2 - k) * nb_compo;
#line 165
      memcpy((void *)p_swap_area, (void const   *)lColumnMatrix, (unsigned long )lSwapSize);
#line 166
      memcpy((void *)lColumnMatrix, (void const   *)lTmpMatrix, (unsigned long )lSwapSize);
#line 167
      memcpy((void *)lTmpMatrix, (void const   *)p_swap_area, (unsigned long )lSwapSize);
      }
    }
#line 171
    lDestMatrix = lTmpMatrix + k;
#line 172
    lColumnMatrix = lDestMatrix + nb_compo;
#line 174
    __cil_tmp23 = lDestMatrix;
#line 174
    lDestMatrix ++;
#line 174
    temp = *__cil_tmp23;
#line 177
    i = offset;
    {
#line 177
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 177
      if (! (i < nb_compo)) {
#line 177
        goto while_break___2;
      }
#line 183
      p = *lColumnMatrix / temp;
#line 184
      __cil_tmp24 = lColumnMatrix;
#line 184
      lColumnMatrix ++;
#line 184
      *__cil_tmp24 = p;
#line 186
      j = offset;
      {
#line 186
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 186
        if (! (j < nb_compo)) {
#line 186
          goto while_break___3;
        }
#line 188
        __cil_tmp26 = lDestMatrix;
#line 188
        lDestMatrix ++;
#line 188
        __cil_tmp25 = lColumnMatrix;
#line 188
        lColumnMatrix ++;
#line 188
        *__cil_tmp25 -= p * *__cil_tmp26;
#line 186
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 191
      lDestMatrix -= lStride;
#line 193
      lColumnMatrix += k;
#line 177
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 197
    offset ++;
#line 199
    lStride --;
#line 201
    lTmpMatrix += nb_compo;
#line 203
    tmpPermutations ++;
#line 131
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 205
  return (1);
}
}
#line 208 "/root/patron/new_24/src/lib/openjp2/invert.c"
static void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                         OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo , OPJ_FLOAT32 *p_intermediate_data ) 
{ 
  OPJ_INT32 k ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_FLOAT32 sum ;
  OPJ_FLOAT32 u ;
  OPJ_UINT32 lStride ;
  OPJ_FLOAT32 *lCurrentPtr ;
  OPJ_FLOAT32 *lIntermediatePtr ;
  OPJ_FLOAT32 *lDestPtr ;
  OPJ_FLOAT32 *lTmpMatrix ;
  OPJ_FLOAT32 *lLineMatrix ;
  OPJ_FLOAT32 *lBeginPtr ;
  OPJ_FLOAT32 *lGeneratedData ;
  OPJ_UINT32 *lCurrentPermutationPtr ;
  OPJ_FLOAT32 *__cil_tmp21 ;
  OPJ_FLOAT32 *__cil_tmp22 ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  OPJ_UINT32 *__cil_tmp24 ;
  OPJ_FLOAT32 *__cil_tmp26 ;
  OPJ_FLOAT32 *__cil_tmp27 ;
  OPJ_FLOAT32 *__cil_tmp28 ;
  OPJ_FLOAT32 *__cil_tmp29 ;
  OPJ_FLOAT32 *__cil_tmp30 ;
  OPJ_FLOAT32 *__cil_tmp31 ;

  {
#line 218
  lStride = nb_compo + 1U;
#line 223
  lLineMatrix = pMatrix;
#line 224
  lBeginPtr = (pResult + nb_compo) - 1;
#line 226
  lCurrentPermutationPtr = pPermutations;
#line 229
  lIntermediatePtr = p_intermediate_data;
#line 230
  lGeneratedData = (p_intermediate_data + nb_compo) - 1;
#line 232
  i = (OPJ_UINT32 )0;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;

#line 232
    if (! (i < nb_compo)) {
#line 232
      goto while_break;
    }
#line 233
    sum = (OPJ_FLOAT32 )0.;
#line 234
    lCurrentPtr = p_intermediate_data;
#line 235
    lTmpMatrix = lLineMatrix;
#line 236
    j = (OPJ_UINT32 )1;
    {
#line 236
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 236
      if (! (j <= i)) {
#line 236
        goto while_break___0;
      }
#line 238
      __cil_tmp22 = lCurrentPtr;
#line 238
      lCurrentPtr ++;
#line 238
      __cil_tmp21 = lTmpMatrix;
#line 238
      lTmpMatrix ++;
#line 238
      sum += *__cil_tmp21 * *__cil_tmp22;
#line 236
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 241
    __cil_tmp24 = lCurrentPermutationPtr;
#line 241
    lCurrentPermutationPtr ++;
#line 241
    __cil_tmp23 = lIntermediatePtr;
#line 241
    lIntermediatePtr ++;
#line 241
    *__cil_tmp23 = *(pVector + *__cil_tmp24) - sum;
#line 242
    lLineMatrix += nb_compo;
#line 232
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 246
  lLineMatrix = (pMatrix + nb_compo * nb_compo) - 1;
#line 249
  lDestPtr = pResult + nb_compo;
#line 253
  k = (OPJ_INT32 )nb_compo - 1;
  {
#line 253
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 253
    if (! (k != -1)) {
#line 253
      goto while_break___1;
    }
#line 254
    sum = (OPJ_FLOAT32 )0.;
#line 255
    lTmpMatrix = lLineMatrix;
#line 256
    __cil_tmp26 = lTmpMatrix;
#line 256
    lTmpMatrix ++;
#line 256
    u = *__cil_tmp26;
#line 257
    __cil_tmp27 = lDestPtr;
#line 257
    lDestPtr --;
#line 257
    lCurrentPtr = __cil_tmp27;
#line 258
    j = (OPJ_UINT32 )(k + 1);
    {
#line 258
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 258
      if (! (j < nb_compo)) {
#line 258
        goto while_break___2;
      }
#line 260
      __cil_tmp29 = lCurrentPtr;
#line 260
      lCurrentPtr ++;
#line 260
      __cil_tmp28 = lTmpMatrix;
#line 260
      lTmpMatrix ++;
#line 260
      sum += *__cil_tmp28 * *__cil_tmp29;
#line 258
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 263
    __cil_tmp31 = lGeneratedData;
#line 263
    lGeneratedData --;
#line 263
    __cil_tmp30 = lBeginPtr;
#line 263
    lBeginPtr --;
#line 263
    *__cil_tmp30 = (*__cil_tmp31 - sum) / u;
#line 264
    lLineMatrix -= lStride;
#line 253
    k --;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 257
  return;
}
}
#line 269 "/root/patron/new_24/src/lib/openjp2/invert.c"
static void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix , OPJ_UINT32 nb_compo ,
                          OPJ_UINT32 *pPermutations , OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp ,
                          OPJ_FLOAT32 *p_swap_area ) 
{ 
  OPJ_UINT32 j ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 *lCurrentPtr ;
  OPJ_FLOAT32 *lLineMatrix ;
  OPJ_UINT32 lSwapSize ;
  OPJ_FLOAT32 *__cil_tmp13 ;

  {
#line 279
  lLineMatrix = pDestMatrix;
#line 280
  lSwapSize = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 282
  j = (OPJ_UINT32 )0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;

#line 282
    if (! (j < nb_compo)) {
#line 282
      goto while_break;
    }
    {
#line 283
    __cil_tmp13 = lLineMatrix;
#line 283
    lLineMatrix ++;
#line 283
    lCurrentPtr = __cil_tmp13;
#line 284
    memset((void *)p_src_temp, 0, (unsigned long )lSwapSize);
#line 285
    *(p_src_temp + j) = (OPJ_FLOAT32 )1.;
#line 286
    opj_lupSolve(p_dest_temp, pSrcMatrix, p_src_temp, pPermutations, nb_compo, p_swap_area);
#line 289
    i = (OPJ_UINT32 )0;
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 289
      if (! (i < nb_compo)) {
#line 289
        goto while_break___0;
      }
#line 290
      *lCurrentPtr = *(p_dest_temp + i);
#line 291
      lCurrentPtr += nb_compo;
#line 289
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 282
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 286
  return;
}
}
#line 34 "/root/patron/new_24/src/lib/openjp2/image.c"
opj_image_t *opj_image_create0(void) 
{ 
  opj_image_t *image ;
  void *__cil_tmp2 ;

  {
  {
#line 36
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_image_t ));
#line 36
  image = (opj_image_t *)__cil_tmp2;
  }
#line 37
  return (image);
}
}
#line 40 "/root/patron/new_24/src/lib/openjp2/image.c"
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  void *__cil_tmp9 ;

  {
  {
#line 44
  image = (opj_image_t *)((void *)0);
#line 46
  __cil_tmp6 = opj_calloc((size_t )1, sizeof(opj_image_t ));
#line 46
  image = (opj_image_t *)__cil_tmp6;
  }
#line 47
  if (image) {
    {
#line 48
    image->color_space = clrspc;
#line 49
    image->numcomps = numcmpts;
#line 51
    __cil_tmp7 = opj_calloc((size_t )1, (unsigned long )image->numcomps * sizeof(opj_image_comp_t ));
#line 51
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 53
    if (! image->comps) {
      {
#line 56
      opj_image_destroy(image);
      }
#line 57
      return ((opj_image_t *)((void *)0));
    }
#line 60
    compno = (OPJ_UINT32 )0;
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;

#line 60
      if (! (compno < numcmpts)) {
#line 60
        goto while_break;
      }
#line 61
      comp = image->comps + compno;
#line 62
      comp->dx = (cmptparms + compno)->dx;
#line 63
      comp->dy = (cmptparms + compno)->dy;
#line 64
      comp->w = (cmptparms + compno)->w;
#line 65
      comp->h = (cmptparms + compno)->h;
#line 66
      comp->x0 = (cmptparms + compno)->x0;
#line 67
      comp->y0 = (cmptparms + compno)->y0;
#line 68
      comp->prec = (cmptparms + compno)->prec;
#line 69
      comp->bpp = (cmptparms + compno)->bpp;
#line 70
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 71
      if (comp->h != 0U) {
#line 71
        if ((OPJ_SIZE_T )comp->w > (0xffffffffffffffffUL / (unsigned long )comp->h) / sizeof(OPJ_INT32 )) {
          {
#line 74
          opj_image_destroy(image);
          }
#line 75
          return ((opj_image_t *)((void *)0));
        }
      }
      {
#line 77
      __cil_tmp9 = opj_image_data_alloc(((size_t )comp->w * (unsigned long )comp->h) * sizeof(OPJ_INT32 ));
#line 77
      comp->data = (OPJ_INT32 *)__cil_tmp9;
      }
#line 79
      if (! comp->data) {
        {
#line 82
        opj_image_destroy(image);
        }
#line 83
        return ((opj_image_t *)((void *)0));
      }
      {
#line 85
      memset((void *)comp->data, 0, ((size_t )comp->w * (unsigned long )comp->h) * sizeof(OPJ_INT32 ));
#line 60
      compno ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 89
  return (image);
}
}
#line 92 "/root/patron/new_24/src/lib/openjp2/image.c"
void opj_image_destroy(opj_image_t *image ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_comp_t *image_comp ;

  {
#line 94
  if (image) {
#line 95
    if (image->comps) {
#line 99
      compno = (OPJ_UINT32 )0;
      {
#line 99
      while (1) {
        while_continue: /* CIL Label */ ;

#line 99
        if (! (compno < image->numcomps)) {
#line 99
          goto while_break;
        }
#line 100
        image_comp = image->comps + compno;
#line 101
        if (image_comp->data) {
          {
#line 102
          opj_image_data_free((void *)image_comp->data);
          }
        }
#line 99
        compno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 105
      opj_free((void *)image->comps);
      }
    }
#line 108
    if (image->icc_profile_buf) {
      {
#line 109
      opj_free((void *)image->icc_profile_buf);
      }
    }
    {
#line 112
    opj_free((void *)image);
    }
  }
#line 115
  return;
}
}
#line 122 "/root/patron/new_24/src/lib/openjp2/image.c"
void opj_image_comp_header_update(opj_image_t *p_image_header , struct opj_cp *p_cp ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 l_x0 ;
  OPJ_UINT32 l_y0 ;
  OPJ_UINT32 l_x1 ;
  OPJ_UINT32 l_y1 ;
  OPJ_UINT32 l_comp_x0 ;
  OPJ_UINT32 l_comp_y0 ;
  OPJ_UINT32 l_comp_x1 ;
  OPJ_UINT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT32 __cil_tmp18 ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;

  {
  {
#line 128
  l_img_comp = (opj_image_comp_t *)((void *)0);
#line 130
  l_x0 = opj_uint_max(p_cp->tx0, p_image_header->x0);
#line 131
  l_y0 = opj_uint_max(p_cp->ty0, p_image_header->y0);
#line 132
  l_x1 = p_cp->tx0 + (p_cp->tw - 1U) * p_cp->tdx;
#line 134
  l_y1 = p_cp->ty0 + (p_cp->th - 1U) * p_cp->tdy;
#line 135
  __cil_tmp17 = opj_uint_adds(l_x1, p_cp->tdx);
#line 135
  __cil_tmp18 = opj_uint_min(__cil_tmp17, p_image_header->x1);
#line 135
  l_x1 = __cil_tmp18;
#line 137
  __cil_tmp19 = opj_uint_adds(l_y1, p_cp->tdy);
#line 137
  __cil_tmp20 = opj_uint_min(__cil_tmp19, p_image_header->y1);
#line 137
  l_y1 = __cil_tmp20;
#line 140
  l_img_comp = p_image_header->comps;
#line 141
  i = (OPJ_UINT32 )0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;

#line 141
    if (! (i < p_image_header->numcomps)) {
#line 141
      goto while_break;
    }
    {
#line 142
    l_comp_x0 = opj_uint_ceildiv(l_x0, l_img_comp->dx);
#line 143
    l_comp_y0 = opj_uint_ceildiv(l_y0, l_img_comp->dy);
#line 144
    l_comp_x1 = opj_uint_ceildiv(l_x1, l_img_comp->dx);
#line 145
    l_comp_y1 = opj_uint_ceildiv(l_y1, l_img_comp->dy);
#line 146
    l_width = opj_uint_ceildivpow2(l_comp_x1 - l_comp_x0, l_img_comp->factor);
#line 147
    l_height = opj_uint_ceildivpow2(l_comp_y1 - l_comp_y0, l_img_comp->factor);
#line 148
    l_img_comp->w = l_width;
#line 149
    l_img_comp->h = l_height;
#line 150
    l_img_comp->x0 = l_comp_x0;
#line 151
    l_img_comp->y0 = l_comp_y0;
#line 152
    l_img_comp ++;
#line 141
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 145
  return;
}
}
#line 165 "/root/patron/new_24/src/lib/openjp2/image.c"
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_comp_t *image_comp ;
  void *__cil_tmp8 ;
  void *__cil_tmp10 ;

  {
#line 174
  p_image_dest->x0 = p_image_src->x0;
#line 175
  p_image_dest->y0 = p_image_src->y0;
#line 176
  p_image_dest->x1 = p_image_src->x1;
#line 177
  p_image_dest->y1 = p_image_src->y1;
#line 179
  if (p_image_dest->comps) {
#line 180
    compno = (OPJ_UINT32 )0;
    {
#line 180
    while (1) {
      while_continue: /* CIL Label */ ;

#line 180
      if (! (compno < p_image_dest->numcomps)) {
#line 180
        goto while_break;
      }
#line 181
      image_comp = p_image_dest->comps + compno;
#line 182
      if (image_comp->data) {
        {
#line 183
        opj_free((void *)image_comp->data);
        }
      }
#line 180
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 186
    opj_free((void *)p_image_dest->comps);
#line 187
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
    }
  }
  {
#line 190
  p_image_dest->numcomps = p_image_src->numcomps;
#line 192
  __cil_tmp8 = opj_malloc((unsigned long )p_image_dest->numcomps * sizeof(opj_image_comp_t ));
#line 192
  p_image_dest->comps = (opj_image_comp_t *)__cil_tmp8;
  }
#line 194
  if (! p_image_dest->comps) {
#line 195
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
#line 196
    p_image_dest->numcomps = (OPJ_UINT32 )0;
#line 197
    return;
  }
#line 200
  compno = (OPJ_UINT32 )0;
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 200
    if (! (compno < p_image_dest->numcomps)) {
#line 200
      goto while_break___0;
    }
    {
#line 201
    memcpy((void *)(p_image_dest->comps + compno), (void const   *)(p_image_src->comps + compno),
           sizeof(opj_image_comp_t ));
#line 204
    (p_image_dest->comps + compno)->data = (OPJ_INT32 *)((void *)0);
#line 200
    compno ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 207
  p_image_dest->color_space = p_image_src->color_space;
#line 208
  p_image_dest->icc_profile_len = p_image_src->icc_profile_len;
#line 210
  if (p_image_dest->icc_profile_len) {
    {
#line 211
    __cil_tmp10 = opj_malloc((size_t )p_image_dest->icc_profile_len);
#line 211
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)__cil_tmp10;
    }
#line 213
    if (! p_image_dest->icc_profile_buf) {
#line 214
      p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 215
      p_image_dest->icc_profile_len = (OPJ_UINT32 )0;
#line 216
      return;
    }
    {
#line 218
    memcpy((void *)p_image_dest->icc_profile_buf, (void const   *)p_image_src->icc_profile_buf,
           (unsigned long )p_image_src->icc_profile_len);
    }
  } else {
#line 222
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
  }
#line 225
  return;
}
}
#line 228 "/root/patron/new_24/src/lib/openjp2/image.c"
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                                   OPJ_COLOR_SPACE clrspc ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;

  {
  {
#line 232
  image = (opj_image_t *)0;
#line 234
  __cil_tmp6 = opj_calloc((size_t )1, sizeof(opj_image_t ));
#line 234
  image = (opj_image_t *)__cil_tmp6;
  }
#line 235
  if (image) {
    {
#line 237
    image->color_space = clrspc;
#line 238
    image->numcomps = numcmpts;
#line 241
    __cil_tmp7 = opj_calloc((size_t )image->numcomps, sizeof(opj_image_comp_t ));
#line 241
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 243
    if (! image->comps) {
      {
#line 244
      opj_image_destroy(image);
      }
#line 245
      return ((opj_image_t *)0);
    }
#line 249
    compno = (OPJ_UINT32 )0;
    {
#line 249
    while (1) {
      while_continue: /* CIL Label */ ;

#line 249
      if (! (compno < numcmpts)) {
#line 249
        goto while_break;
      }
#line 250
      comp = image->comps + compno;
#line 251
      comp->dx = (cmptparms + compno)->dx;
#line 252
      comp->dy = (cmptparms + compno)->dy;
#line 253
      comp->w = (cmptparms + compno)->w;
#line 254
      comp->h = (cmptparms + compno)->h;
#line 255
      comp->x0 = (cmptparms + compno)->x0;
#line 256
      comp->y0 = (cmptparms + compno)->y0;
#line 257
      comp->prec = (cmptparms + compno)->prec;
#line 258
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 259
      comp->data = (OPJ_INT32 *)0;
#line 249
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 263
  return (image);
}
}
#line 39 "/root/patron/new_24/src/lib/openjp2/function_list.c"
opj_procedure_list_t *opj_procedure_list_create(void) 
{ 
  opj_procedure_list_t *l_validation ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 42
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_procedure_list_t ));
#line 42
  l_validation = (opj_procedure_list_t *)__cil_tmp2;
  }
#line 44
  if (! l_validation) {
#line 45
    return ((opj_procedure_list_t *)0);
  }
  {
#line 48
  l_validation->m_nb_max_procedures = (OPJ_UINT32 )10;
#line 49
  __cil_tmp3 = opj_calloc((size_t )10, sizeof(void (*)(void)));
#line 49
  l_validation->m_procedures = (opj_procedure *)__cil_tmp3;
  }
#line 51
  if (! l_validation->m_procedures) {
    {
#line 52
    opj_free((void *)l_validation);
    }
#line 53
    return ((opj_procedure_list_t *)0);
  }
#line 55
  return (l_validation);
}
}
#line 58 "/root/patron/new_24/src/lib/openjp2/function_list.c"
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) 
{ 


  {
#line 60
  if (! p_list) {
#line 61
    return;
  }
#line 64
  if (p_list->m_procedures) {
    {
#line 65
    opj_free((void *)p_list->m_procedures);
    }
  }
  {
#line 67
  opj_free((void *)p_list);
  }
#line 69
  return;
}
}
#line 70 "/root/patron/new_24/src/lib/openjp2/function_list.c"
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          void (*p_procedure)(void) , opj_event_mgr_t *p_manager ) 
{ 
  opj_procedure *new_procedures ;
  void *__cil_tmp6 ;

  {
#line 76
  if (p_validation_list->m_nb_max_procedures == p_validation_list->m_nb_procedures) {
    {
#line 80
    p_validation_list->m_nb_max_procedures += 10U;
#line 81
    __cil_tmp6 = opj_realloc((void *)p_validation_list->m_procedures, (unsigned long )p_validation_list->m_nb_max_procedures * sizeof(void (*)(void)));
#line 81
    new_procedures = (opj_procedure *)__cil_tmp6;
    }
#line 84
    if (! new_procedures) {
      {
#line 85
      opj_free((void *)p_validation_list->m_procedures);
#line 86
      p_validation_list->m_nb_max_procedures = (OPJ_UINT32 )0;
#line 87
      p_validation_list->m_nb_procedures = (OPJ_UINT32 )0;
#line 88
      opj_event_msg(p_manager, 1, "Not enough memory to add a new validation procedure\n V");
      }
#line 90
      return (0);
    } else {
#line 92
      p_validation_list->m_procedures = new_procedures;
    }
  }
#line 95
  *(p_validation_list->m_procedures + p_validation_list->m_nb_procedures) = p_procedure;
#line 97
  (p_validation_list->m_nb_procedures) ++;
#line 99
  return (1);
}
}
#line 102 "/root/patron/new_24/src/lib/openjp2/function_list.c"
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 105
  return (p_validation_list->m_nb_procedures);
}
}
#line 108 "/root/patron/new_24/src/lib/openjp2/function_list.c"
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 111
  return (p_validation_list->m_procedures);
}
}
#line 114 "/root/patron/new_24/src/lib/openjp2/function_list.c"
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 116
  p_validation_list->m_nb_procedures = (OPJ_UINT32 )0;
#line 117
  return;
}
}
#line 81 "/root/patron/new_24/src/lib/openjp2/event.c"
static void opj_default_callback(char const   *msg , void *client_data ) 
{ 


  {
#line 86
  return;
}
}
#line 91 "/root/patron/new_24/src/lib/openjp2/event.c"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) 
{ 
  void (*msg_handler)(char const   * , void * ) ;
  void *l_data ;
  va_list arg ;
  char message[512] ;

  {
#line 95
  msg_handler = (void (*)(char const   * , void * ))0;
#line 96
  l_data = (void *)0;
#line 98
  if ((unsigned long )p_event_mgr != (unsigned long )((opj_event_mgr_t *)0)) {
#line 100
    if (event_type == 1) {
#line 100
      goto case_1;
    }
#line 104
    if (event_type == 2) {
#line 104
      goto case_2;
    }
#line 108
    if (event_type == 4) {
#line 108
      goto case_4;
    }
#line 112
    goto switch_default;
    case_1: 
#line 101
    msg_handler = p_event_mgr->error_handler;
#line 102
    l_data = p_event_mgr->m_error_data;
#line 103
    goto switch_break;
    case_2: 
#line 105
    msg_handler = p_event_mgr->warning_handler;
#line 106
    l_data = p_event_mgr->m_warning_data;
#line 107
    goto switch_break;
    case_4: 
#line 109
    msg_handler = p_event_mgr->info_handler;
#line 110
    l_data = p_event_mgr->m_info_data;
#line 111
    goto switch_break;
    switch_default: 
#line 113
    goto switch_break;
    switch_break: ;
#line 115
    if ((unsigned long )msg_handler == (unsigned long )((void (*)(char const   * ,
                                                                  void * ))0)) {
#line 116
      return (0);
    }
  } else {
#line 119
    return (0);
  }
#line 122
  if ((unsigned long )fmt != (unsigned long )((char const   *)0)) {
#line 122
    if ((unsigned long )p_event_mgr != (unsigned long )((opj_event_mgr_t *)0)) {
      {
#line 125
      memset((void *)(message), 0, 512UL);
#line 127
      __builtin_va_start((__builtin_va_list )((void *)arg), fmt);
#line 129
      vsnprintf(message, 512UL, fmt, (__gnuc_va_list )((void *)arg));
#line 131
      message[511] = (char )'\000';
#line 133
      __builtin_va_end((__builtin_va_list )((void *)arg));
#line 136
      (*msg_handler)((char const   *)(message), l_data);
      }
    }
  }
#line 139
  return (1);
}
}
#line 142 "/root/patron/new_24/src/lib/openjp2/event.c"
void opj_set_default_event_handler(opj_event_mgr_t *p_manager ) 
{ 


  {
#line 144
  p_manager->m_error_data = (void *)0;
#line 145
  p_manager->m_warning_data = (void *)0;
#line 146
  p_manager->m_info_data = (void *)0;
#line 147
  p_manager->error_handler = & opj_default_callback;
#line 148
  p_manager->info_handler = & opj_default_callback;
#line 149
  p_manager->warning_handler = & opj_default_callback;
#line 150
  return;
}
}
#line 105 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_dwt_alpha  =    1.58613431454f;
#line 106 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_dwt_beta  =    0.0529801174999f;
#line 107 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_dwt_gamma  =    - 0.882911086083f;
#line 108 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_dwt_delta  =    - 0.443506866694f;
#line 110 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_K  =    1.23017406464f;
#line 111 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_FLOAT32 opj_c13318  =    1.62573242188f;
#line 126
static void opj_dwt_deinterleave_h(OPJ_INT32 *a , OPJ_INT32 *b , OPJ_INT32 dn , OPJ_INT32 sn ,
                                   OPJ_INT32 cas ) ;
#line 131
static void opj_dwt_deinterleave_v(OPJ_INT32 *a , OPJ_INT32 *b , OPJ_INT32 dn , OPJ_INT32 sn ,
                                   OPJ_INT32 x , OPJ_INT32 cas ) ;
#line 136
static void opj_dwt_encode_1(OPJ_INT32 *a , OPJ_INT32 dn , OPJ_INT32 sn , OPJ_INT32 cas ) ;
#line 141
static void opj_dwt_encode_1_real(OPJ_INT32 *a , OPJ_INT32 dn , OPJ_INT32 sn , OPJ_INT32 cas ) ;
#line 146
static void opj_dwt_encode_stepsize(OPJ_INT32 stepsize , OPJ_INT32 numbps , opj_stepsize_t *bandno_stepsize ) ;
#line 151
static OPJ_BOOL opj_dwt_decode_tile(opj_thread_pool_t *tp , opj_tcd_tilecomp_t *tilec ,
                                    OPJ_UINT32 numres ) ;
#line 154
static OPJ_BOOL opj_dwt_decode_partial_tile(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 158
__inline static OPJ_BOOL opj_dwt_encode_procedure(opj_tcd_tilecomp_t *tilec , void (*p_function)(OPJ_INT32 * ,
                                                                                                 OPJ_INT32  ,
                                                                                                 OPJ_INT32  ,
                                                                                                 OPJ_INT32  ) ) ;
#line 161
static OPJ_UINT32 opj_dwt_max_resolution(opj_tcd_resolution_t *r , OPJ_UINT32 i ) ;
#line 167
static void opj_v4dwt_decode(opj_v4dwt_t *dwt ) ;
#line 169
static void opj_v4dwt_interleave_h(opj_v4dwt_t *dwt , OPJ_FLOAT32 *a , OPJ_UINT32 width ,
                                   OPJ_UINT32 remaining_height ) ;
#line 174
static void opj_v4dwt_interleave_v(opj_v4dwt_t *dwt , OPJ_FLOAT32 *a , OPJ_UINT32 width ,
                                   OPJ_UINT32 nb_elts_read ) ;
#line 180
static void opj_v4dwt_decode_step1_sse(opj_v4_t *w , OPJ_UINT32 start , OPJ_UINT32 end ,
                                       __m128 c ) ;
#line 185
static void opj_v4dwt_decode_step2_sse(opj_v4_t *l , opj_v4_t *w , OPJ_UINT32 start ,
                                       OPJ_UINT32 end , OPJ_UINT32 m , __m128 c ) ;
#line 219 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_FLOAT64 opj_dwt_norms[4][10]  = { {        1.,        1.5,        2.75,        5.375, 
            10.68,        21.34,        42.6700000001,        85.33, 
            170.7,        341.300000001}, 
   {        1.03800000001,        1.59200000001,        2.91900000001,        5.70300000001, 
            11.3300000001,        22.6400000001,        45.25,        90.4800000001, 
            180.900000001}, 
   {        1.03800000001,        1.59200000001,        2.91900000001,        5.70300000001, 
            11.3300000001,        22.6400000001,        45.25,        90.4800000001, 
            180.900000001}, 
   {        0.718600000001,        0.9218,        1.58600000001,        3.04300000001, 
            6.01900000001,        12.01,        24.,        47.97, 
            95.9300000001}};
#line 229 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_FLOAT64 opj_dwt_norms_real[4][10]  = { {        1.,        1.96500000001,        4.177,        8.40300000001, 
            16.9,        33.8400000001,        67.69,        135.300000001, 
            270.600000001,        540.9}, 
   {        2.022,        3.989,        8.35500000001,        17.04, 
            34.2700000001,        68.63,        137.300000001,        274.600000001, 
            549.}, 
   {        2.022,        3.989,        8.35500000001,        17.04, 
            34.2700000001,        68.63,        137.300000001,        274.600000001, 
            549.}, 
   {        2.08000000001,        3.86500000001,        8.30700000001,        17.18, 
            34.7100000001,        69.5900000001,        139.300000001,        278.600000001, 
            557.200000001}};
#line 245 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_deinterleave_h(OPJ_INT32 *a , OPJ_INT32 *b , OPJ_INT32 dn , OPJ_INT32 sn ,
                                   OPJ_INT32 cas ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 *l_dest ;
  OPJ_INT32 *l_src ;
  OPJ_INT32 *__cil_tmp9 ;
  OPJ_INT32 *__cil_tmp10 ;

  {
#line 249
  l_dest = b;
#line 250
  l_src = a + cas;
#line 252
  i = 0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;

#line 252
    if (! (i < sn)) {
#line 252
      goto while_break;
    }
#line 253
    __cil_tmp9 = l_dest;
#line 253
    l_dest ++;
#line 253
    *__cil_tmp9 = *l_src;
#line 254
    l_src += 2;
#line 252
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 257
  l_dest = b + sn;
#line 258
  l_src = (a + 1) - cas;
#line 260
  i = 0;
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 260
    if (! (i < dn)) {
#line 260
      goto while_break___0;
    }
#line 261
    __cil_tmp10 = l_dest;
#line 261
    l_dest ++;
#line 261
    *__cil_tmp10 = *l_src;
#line 262
    l_src += 2;
#line 260
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 264
  return;
}
}
#line 269 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_deinterleave_v(OPJ_INT32 *a , OPJ_INT32 *b , OPJ_INT32 dn , OPJ_INT32 sn ,
                                   OPJ_INT32 x , OPJ_INT32 cas ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 *l_dest ;
  OPJ_INT32 *l_src ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_INT32 __cil_tmp11 ;

  {
#line 272
  i = sn;
#line 273
  l_dest = b;
#line 274
  l_src = a + cas;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    __cil_tmp10 = i;
#line 276
    i --;
#line 276
    if (! __cil_tmp10) {
#line 276
      goto while_break;
    }
#line 277
    *l_dest = *l_src;
#line 278
    l_dest += x;
#line 279
    l_src += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 282
  l_dest = b + (OPJ_SIZE_T )sn * (OPJ_SIZE_T )x;
#line 283
  l_src = (a + 1) - cas;
#line 285
  i = dn;
  {
#line 286
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 286
    __cil_tmp11 = i;
#line 286
    i --;
#line 286
    if (! __cil_tmp11) {
#line 286
      goto while_break___0;
    }
#line 287
    *l_dest = *l_src;
#line 288
    l_dest += x;
#line 289
    l_src += 2;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 293
  return;
}
}
#line 343 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_encode_1(OPJ_INT32 *a , OPJ_INT32 dn , OPJ_INT32 sn , OPJ_INT32 cas ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;
  OPJ_INT32 tmp___2 ;
  OPJ_INT32 tmp___3 ;
  OPJ_INT32 tmp___4 ;
  OPJ_INT32 tmp___5 ;
  OPJ_INT32 tmp___6 ;
  OPJ_INT32 tmp___7 ;
  OPJ_INT32 tmp___8 ;
  OPJ_INT32 tmp___9 ;
  OPJ_INT32 tmp___10 ;
  OPJ_INT32 tmp___11 ;
  OPJ_INT32 tmp___12 ;
  OPJ_INT32 tmp___13 ;
  OPJ_INT32 tmp___14 ;

  {
#line 348
  if (! cas) {
#line 349
    if (dn > 0) {
      _L: 
#line 350
      i = 0;
      {
#line 350
      while (1) {
        while_continue: /* CIL Label */ ;

#line 350
        if (! (i < dn)) {
#line 350
          goto while_break;
        }
#line 351
        if (i + 1 < 0) {
#line 351
          tmp___2 = *(a + 0);
        } else {
#line 351
          if (i + 1 >= sn) {
#line 351
            tmp___1 = *(a + (sn - 1) * 2);
          } else {
#line 351
            tmp___1 = *(a + (i + 1) * 2);
          }
#line 351
          tmp___2 = tmp___1;
        }
#line 351
        if (i < 0) {
#line 351
          tmp___0 = *(a + 0);
        } else {
#line 351
          if (i >= sn) {
#line 351
            tmp = *(a + (sn - 1) * 2);
          } else {
#line 351
            tmp = *(a + i * 2);
          }
#line 351
          tmp___0 = tmp;
        }
#line 351
        *(a + (1 + i * 2)) -= (tmp___0 + tmp___2) >> 1;
#line 350
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: 
#line 353
      i = 0;
      {
#line 353
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 353
        if (! (i < sn)) {
#line 353
          goto while_break___0;
        }
#line 354
        if (i < 0) {
#line 354
          tmp___6 = *(a + 1);
        } else {
#line 354
          if (i >= dn) {
#line 354
            tmp___5 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 354
            tmp___5 = *(a + (1 + i * 2));
          }
#line 354
          tmp___6 = tmp___5;
        }
#line 354
        if (i - 1 < 0) {
#line 354
          tmp___4 = *(a + 1);
        } else {
#line 354
          if (i - 1 >= dn) {
#line 354
            tmp___3 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 354
            tmp___3 = *(a + (1 + (i - 1) * 2));
          }
#line 354
          tmp___4 = tmp___3;
        }
#line 354
        *(a + i * 2) += ((tmp___4 + tmp___6) + 2) >> 2;
#line 353
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
    } else
#line 349
    if (sn > 1) {
#line 349
      goto _L;
    }
  } else
#line 358
  if (! sn) {
#line 358
    if (dn == 1) {
#line 359
      *(a + 0) *= 2;
    } else {
#line 358
      goto _L___19;
    }
  } else {
    _L___19: 
#line 361
    i = 0;
    {
#line 361
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 361
      if (! (i < dn)) {
#line 361
        goto while_break___1;
      }
#line 362
      if (i - 1 < 0) {
#line 362
        tmp___10 = *(a + 1);
      } else {
#line 362
        if (i - 1 >= sn) {
#line 362
          tmp___9 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 362
          tmp___9 = *(a + (1 + (i - 1) * 2));
        }
#line 362
        tmp___10 = tmp___9;
      }
#line 362
      if (i < 0) {
#line 362
        tmp___8 = *(a + 1);
      } else {
#line 362
        if (i >= sn) {
#line 362
          tmp___7 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 362
          tmp___7 = *(a + (1 + i * 2));
        }
#line 362
        tmp___8 = tmp___7;
      }
#line 362
      *(a + i * 2) -= (tmp___8 + tmp___10) >> 1;
#line 361
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 364
    i = 0;
    {
#line 364
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 364
      if (! (i < sn)) {
#line 364
        goto while_break___2;
      }
#line 365
      if (i + 1 < 0) {
#line 365
        tmp___14 = *(a + 0);
      } else {
#line 365
        if (i + 1 >= dn) {
#line 365
          tmp___13 = *(a + (dn - 1) * 2);
        } else {
#line 365
          tmp___13 = *(a + (i + 1) * 2);
        }
#line 365
        tmp___14 = tmp___13;
      }
#line 365
      if (i < 0) {
#line 365
        tmp___12 = *(a + 0);
      } else {
#line 365
        if (i >= dn) {
#line 365
          tmp___11 = *(a + (dn - 1) * 2);
        } else {
#line 365
          tmp___11 = *(a + i * 2);
        }
#line 365
        tmp___12 = tmp___11;
      }
#line 365
      *(a + (1 + i * 2)) += ((tmp___12 + tmp___14) + 2) >> 2;
#line 364
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 369
  return;
}
}
#line 411 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_idwt53_h_cas0(OPJ_INT32 *tmp , OPJ_INT32 sn , OPJ_INT32 len , OPJ_INT32 *tiledp ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 *in_even ;
  OPJ_INT32 *in_odd ;
  OPJ_INT32 d1c ;
  OPJ_INT32 d1n ;
  OPJ_INT32 s1n ;
  OPJ_INT32 s0c ;
  OPJ_INT32 s0n ;
  OPJ_INT32 __cil_tmp15 ;

  {
#line 417
  in_even = tiledp + 0;
#line 418
  in_odd = tiledp + sn;
#line 450
  s1n = *(in_even + 0);
#line 451
  d1n = *(in_odd + 0);
#line 452
  s0n = s1n - ((d1n + 1) >> 1);
#line 454
  j = 1;
#line 454
  i = 0;
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;

#line 454
    if (! (i < len - 3)) {
#line 454
      goto while_break;
    }
#line 455
    d1c = d1n;
#line 456
    s0c = s0n;
#line 458
    s1n = *(in_even + j);
#line 459
    d1n = *(in_odd + j);
#line 461
    s0n = s1n - (((d1c + d1n) + 2) >> 2);
#line 463
    *(tmp + i) = s0c;
#line 464
    *(tmp + (i + 1)) = d1c + ((s0c + s0n) >> 1);
#line 454
    __cil_tmp15 = j;
#line 454
    j ++;
#line 454
    i += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 467
  *(tmp + i) = s0n;
#line 469
  if (len & 1) {
#line 470
    *(tmp + (len - 1)) = *(in_even + (len - 1) / 2) - ((d1n + 1) >> 1);
#line 471
    *(tmp + (len - 2)) = d1n + ((s0n + *(tmp + (len - 1))) >> 1);
  } else {
#line 473
    *(tmp + (len - 1)) = d1n + s0n;
  }
  {
#line 476
  memcpy((void *)tiledp, (void const   *)tmp, (unsigned long )((OPJ_UINT32 )len) * sizeof(OPJ_INT32 ));
  }
#line 478
  return;
}
}
#line 479 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_idwt53_h_cas1(OPJ_INT32 *tmp , OPJ_INT32 sn , OPJ_INT32 len , OPJ_INT32 *tiledp ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 *in_even ;
  OPJ_INT32 *in_odd ;
  OPJ_INT32 s1 ;
  OPJ_INT32 s2 ;
  OPJ_INT32 dc ;
  OPJ_INT32 dn ;
  OPJ_INT32 __cil_tmp14 ;

  {
#line 485
  in_even = tiledp + sn;
#line 486
  in_odd = tiledp + 0;
#line 519
  s1 = *(in_even + 1);
#line 520
  dc = *(in_odd + 0) - (((*(in_even + 0) + s1) + 2) >> 2);
#line 521
  *(tmp + 0) = *(in_even + 0) + dc;
#line 523
  j = 1;
#line 523
  i = 1;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;

#line 523
    if (! (i < (len - 2) - ! (len & 1))) {
#line 523
      goto while_break;
    }
#line 525
    s2 = *(in_even + (j + 1));
#line 527
    dn = *(in_odd + j) - (((s1 + s2) + 2) >> 2);
#line 528
    *(tmp + i) = dc;
#line 529
    *(tmp + (i + 1)) = s1 + ((dn + dc) >> 1);
#line 531
    dc = dn;
#line 532
    s1 = s2;
#line 523
    __cil_tmp14 = j;
#line 523
    j ++;
#line 523
    i += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 535
  *(tmp + i) = dc;
#line 537
  if (! (len & 1)) {
#line 538
    dn = *(in_odd + (len / 2 - 1)) - ((s1 + 1) >> 1);
#line 539
    *(tmp + (len - 2)) = s1 + ((dn + dc) >> 1);
#line 540
    *(tmp + (len - 1)) = dn;
  } else {
#line 542
    *(tmp + (len - 1)) = s1 + dc;
  }
  {
#line 545
  memcpy((void *)tiledp, (void const   *)tmp, (unsigned long )((OPJ_UINT32 )len) * sizeof(OPJ_INT32 ));
  }
#line 547
  return;
}
}
#line 555 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_idwt53_h(opj_dwt_t *dwt , OPJ_INT32 *tiledp ) 
{ 
  OPJ_INT32 sn ;
  OPJ_INT32 len ;
  OPJ_INT32 *out ;
  OPJ_INT32 *in_even ;
  OPJ_INT32 *in_odd ;

  {
#line 564
  sn = dwt->sn;
#line 565
  len = sn + dwt->dn;
#line 566
  if (dwt->cas == 0) {
#line 567
    if (len > 1) {
      {
#line 568
      opj_idwt53_h_cas0(dwt->mem, sn, len, tiledp);
      }
    }
  } else
#line 573
  if (len == 1) {
#line 574
    *(tiledp + 0) /= 2;
  } else
#line 575
  if (len == 2) {
    {
#line 576
    out = dwt->mem;
#line 577
    in_even = tiledp + sn;
#line 578
    in_odd = tiledp + 0;
#line 579
    *(out + 1) = *(in_odd + 0) - ((*(in_even + 0) + 1) >> 1);
#line 580
    *(out + 0) = *(in_even + 0) + *(out + 1);
#line 581
    memcpy((void *)tiledp, (void const   *)dwt->mem, (unsigned long )((OPJ_UINT32 )len) * sizeof(OPJ_INT32 ));
    }
  } else
#line 582
  if (len > 2) {
    {
#line 583
    opj_idwt53_h_cas1(dwt->mem, sn, len, tiledp);
    }
  }
#line 586
  return;
}
}
#line 616 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_idwt53_v_final_memcpy(OPJ_INT32 *tiledp_col , OPJ_INT32 *tmp , OPJ_INT32 len ,
                                      OPJ_SIZE_T stride ) 
{ 
  OPJ_INT32 i ;
  __m128i __cil_tmp6 ;
  __m128i __cil_tmp7 ;

  {
#line 622
  i = 0;
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;

#line 622
    if (! (i < len)) {
#line 622
      goto while_break;
    }
    {
#line 628
    __cil_tmp6 = _mm_load_si128(tmp + 8 * i);
#line 628
    _mm_storeu_si128(tiledp_col + (OPJ_SIZE_T )i * stride, __cil_tmp6);
#line 630
    __cil_tmp7 = _mm_load_si128(tmp + (8 * i + 4));
#line 630
    _mm_storeu_si128(tiledp_col + ((OPJ_SIZE_T )i * stride + 4UL), __cil_tmp7);
#line 622
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 626
  return;
}
}
#line 637 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_idwt53_v_cas0_mcols_SSE2_OR_AVX2(OPJ_INT32 *tmp , OPJ_INT32 sn , OPJ_INT32 len ,
                                                 OPJ_INT32 *tiledp_col , OPJ_SIZE_T stride ) 
{ 
  OPJ_INT32 *in_even ;
  OPJ_INT32 *in_odd ;
  OPJ_INT32 i ;
  OPJ_SIZE_T j ;
  __m128i d1c_0 ;
  __m128i d1n_0 ;
  __m128i s1n_0 ;
  __m128i s0c_0 ;
  __m128i s0n_0 ;
  __m128i d1c_1 ;
  __m128i d1n_1 ;
  __m128i s1n_1 ;
  __m128i s0c_1 ;
  __m128i s0n_1 ;
  __m128i two ;
  __m128i __cil_tmp21 ;
  __m128i __cil_tmp30 ;
  __m128i __cil_tmp31 ;
  __m128i __cil_tmp32 ;
  __m128i __cil_tmp33 ;
  __m128i __cil_tmp34 ;
  __m128i __cil_tmp35 ;
  __m128i __cil_tmp36 ;
  __m128i __cil_tmp37 ;
  __m128i __cil_tmp42 ;
  __m128i __cil_tmp43 ;
  __m128i __cil_tmp44 ;
  __m128i __cil_tmp45 ;
  __m128i __cil_tmp46 ;
  __m128i __cil_tmp47 ;
  __m128i __cil_tmp48 ;
  __m128i __cil_tmp49 ;
  __m128i __cil_tmp50 ;
  __m128i __cil_tmp51 ;
  __m128i __cil_tmp52 ;
  __m128i __cil_tmp53 ;
  __m128i __cil_tmp54 ;
  __m128i __cil_tmp55 ;
  OPJ_SIZE_T __cil_tmp56 ;
  __m128i tmp_len_minus_1 ;
  __m128i __cil_tmp59 ;
  __m128i __cil_tmp60 ;
  __m128i __cil_tmp61 ;
  __m128i __cil_tmp62 ;
  __m128i __cil_tmp63 ;
  __m128i __cil_tmp64 ;
  __m128i __cil_tmp65 ;
  __m128i __cil_tmp67 ;
  __m128i __cil_tmp68 ;
  __m128i __cil_tmp69 ;
  __m128i __cil_tmp70 ;
  __m128i __cil_tmp71 ;
  __m128i __cil_tmp72 ;
  __m128i __cil_tmp73 ;
  __m128i __cil_tmp74 ;
  __m128i __cil_tmp75 ;

  {
  {
#line 644
  in_even = tiledp_col + 0;
#line 645
  in_odd = tiledp_col + (OPJ_SIZE_T )sn * stride;
#line 651
  __cil_tmp21 = _mm_set1_epi32(2);
#line 651
  two = __cil_tmp21;
#line 667
  s1n_0 = _mm_loadu_si128(in_even + 0);
#line 668
  s1n_1 = _mm_loadu_si128(in_even + 4);
#line 669
  d1n_0 = _mm_loadu_si128(in_odd);
#line 670
  d1n_1 = _mm_loadu_si128(in_odd + 4);
#line 674
  __cil_tmp30 = _mm_add_epi32(d1n_0, d1n_0);
#line 674
  __cil_tmp31 = _mm_add_epi32(__cil_tmp30, two);
#line 674
  __cil_tmp32 = _mm_srai_epi32(__cil_tmp31, 2);
#line 674
  __cil_tmp33 = _mm_sub_epi32(s1n_0, __cil_tmp32);
#line 674
  s0n_0 = __cil_tmp33;
#line 675
  __cil_tmp34 = _mm_add_epi32(d1n_1, d1n_1);
#line 675
  __cil_tmp35 = _mm_add_epi32(__cil_tmp34, two);
#line 675
  __cil_tmp36 = _mm_srai_epi32(__cil_tmp35, 2);
#line 675
  __cil_tmp37 = _mm_sub_epi32(s1n_1, __cil_tmp36);
#line 675
  s0n_1 = __cil_tmp37;
#line 677
  j = (OPJ_SIZE_T )1;
#line 677
  i = 0;
  }
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;

#line 677
    if (! (i < len - 3)) {
#line 677
      goto while_break;
    }
    {
#line 678
    d1c_0 = d1n_0;
#line 679
    s0c_0 = s0n_0;
#line 680
    d1c_1 = d1n_1;
#line 681
    s0c_1 = s0n_1;
#line 683
    s1n_0 = _mm_loadu_si128(in_even + j * stride);
#line 684
    s1n_1 = _mm_loadu_si128((in_even + j * stride) + 4);
#line 685
    d1n_0 = _mm_loadu_si128(in_odd + j * stride);
#line 686
    d1n_1 = _mm_loadu_si128((in_odd + j * stride) + 4);
#line 689
    __cil_tmp42 = _mm_add_epi32(d1c_0, d1n_0);
#line 689
    __cil_tmp43 = _mm_add_epi32(__cil_tmp42, two);
#line 689
    __cil_tmp44 = _mm_srai_epi32(__cil_tmp43, 2);
#line 689
    __cil_tmp45 = _mm_sub_epi32(s1n_0, __cil_tmp44);
#line 689
    s0n_0 = __cil_tmp45;
#line 690
    __cil_tmp46 = _mm_add_epi32(d1c_1, d1n_1);
#line 690
    __cil_tmp47 = _mm_add_epi32(__cil_tmp46, two);
#line 690
    __cil_tmp48 = _mm_srai_epi32(__cil_tmp47, 2);
#line 690
    __cil_tmp49 = _mm_sub_epi32(s1n_1, __cil_tmp48);
#line 690
    s0n_1 = __cil_tmp49;
#line 692
    _mm_store_si128(tmp + 8 * i, s0c_0);
#line 693
    _mm_store_si128((tmp + 8 * i) + 4, s0c_1);
#line 696
    __cil_tmp50 = _mm_add_epi32(s0c_0, s0n_0);
#line 696
    __cil_tmp51 = _mm_srai_epi32(__cil_tmp50, 1);
#line 696
    __cil_tmp52 = _mm_add_epi32(d1c_0, __cil_tmp51);
#line 696
    _mm_store_si128((tmp + 8 * (i + 1)) + 0, __cil_tmp52);
#line 698
    __cil_tmp53 = _mm_add_epi32(s0c_1, s0n_1);
#line 698
    __cil_tmp54 = _mm_srai_epi32(__cil_tmp53, 1);
#line 698
    __cil_tmp55 = _mm_add_epi32(d1c_1, __cil_tmp54);
#line 698
    _mm_store_si128((tmp + 8 * (i + 1)) + 4, __cil_tmp55);
#line 677
    __cil_tmp56 = j;
#line 677
    j ++;
#line 677
    i += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 702
  _mm_store_si128((tmp + 8 * i) + 0, s0n_0);
#line 703
  _mm_store_si128((tmp + 8 * i) + 4, s0n_1);
  }
#line 705
  if (len & 1) {
    {
#line 707
    s1n_0 = _mm_loadu_si128(in_even + (OPJ_SIZE_T )((len - 1) / 2) * stride);
#line 709
    __cil_tmp59 = _mm_add_epi32(d1n_0, d1n_0);
#line 709
    __cil_tmp60 = _mm_add_epi32(__cil_tmp59, two);
#line 709
    __cil_tmp61 = _mm_srai_epi32(__cil_tmp60, 2);
#line 709
    __cil_tmp62 = _mm_sub_epi32(s1n_0, __cil_tmp61);
#line 709
    tmp_len_minus_1 = __cil_tmp62;
#line 710
    _mm_store_si128(tmp + 8 * (len - 1), tmp_len_minus_1);
#line 712
    __cil_tmp63 = _mm_add_epi32(s0n_0, tmp_len_minus_1);
#line 712
    __cil_tmp64 = _mm_srai_epi32(__cil_tmp63, 1);
#line 712
    __cil_tmp65 = _mm_add_epi32(d1n_0, __cil_tmp64);
#line 712
    _mm_store_si128(tmp + 8 * (len - 2), __cil_tmp65);
#line 715
    s1n_1 = _mm_loadu_si128((in_even + (OPJ_SIZE_T )((len - 1) / 2) * stride) + 4);
#line 717
    __cil_tmp67 = _mm_add_epi32(d1n_1, d1n_1);
#line 717
    __cil_tmp68 = _mm_add_epi32(__cil_tmp67, two);
#line 717
    __cil_tmp69 = _mm_srai_epi32(__cil_tmp68, 2);
#line 717
    __cil_tmp70 = _mm_sub_epi32(s1n_1, __cil_tmp69);
#line 717
    tmp_len_minus_1 = __cil_tmp70;
#line 718
    _mm_store_si128((tmp + 8 * (len - 1)) + 4, tmp_len_minus_1);
#line 721
    __cil_tmp71 = _mm_add_epi32(s0n_1, tmp_len_minus_1);
#line 721
    __cil_tmp72 = _mm_srai_epi32(__cil_tmp71, 1);
#line 721
    __cil_tmp73 = _mm_add_epi32(d1n_1, __cil_tmp72);
#line 721
    _mm_store_si128((tmp + 8 * (len - 2)) + 4, __cil_tmp73);
    }
  } else {
    {
#line 726
    __cil_tmp74 = _mm_add_epi32(d1n_0, s0n_0);
#line 726
    _mm_store_si128((tmp + 8 * (len - 1)) + 0, __cil_tmp74);
#line 728
    __cil_tmp75 = _mm_add_epi32(d1n_1, s0n_1);
#line 728
    _mm_store_si128((tmp + 8 * (len - 1)) + 4, __cil_tmp75);
    }
  }
  {
#line 732
  opj_idwt53_v_final_memcpy(tiledp_col, tmp, len, stride);
  }
#line 734
  return;
}
}
#line 738 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_idwt53_v_cas1_mcols_SSE2_OR_AVX2(OPJ_INT32 *tmp , OPJ_INT32 sn , OPJ_INT32 len ,
                                                 OPJ_INT32 *tiledp_col , OPJ_SIZE_T stride ) 
{ 
  OPJ_INT32 i ;
  OPJ_SIZE_T j ;
  __m128i s1_0 ;
  __m128i s2_0 ;
  __m128i dc_0 ;
  __m128i dn_0 ;
  __m128i s1_1 ;
  __m128i s2_1 ;
  __m128i dc_1 ;
  __m128i dn_1 ;
  __m128i two ;
  __m128i __cil_tmp17 ;
  OPJ_INT32 *in_even ;
  OPJ_INT32 *in_odd ;
  __m128i __cil_tmp25 ;
  __m128i __cil_tmp26 ;
  __m128i __cil_tmp27 ;
  __m128i __cil_tmp28 ;
  __m128i __cil_tmp29 ;
  __m128i __cil_tmp30 ;
  __m128i __cil_tmp31 ;
  __m128i __cil_tmp32 ;
  __m128i __cil_tmp34 ;
  __m128i __cil_tmp35 ;
  __m128i __cil_tmp36 ;
  __m128i __cil_tmp37 ;
  __m128i __cil_tmp38 ;
  __m128i __cil_tmp39 ;
  __m128i __cil_tmp40 ;
  __m128i __cil_tmp41 ;
  __m128i __cil_tmp44 ;
  __m128i __cil_tmp45 ;
  __m128i __cil_tmp46 ;
  __m128i __cil_tmp47 ;
  __m128i __cil_tmp48 ;
  __m128i __cil_tmp49 ;
  __m128i __cil_tmp50 ;
  __m128i __cil_tmp51 ;
  __m128i __cil_tmp52 ;
  __m128i __cil_tmp53 ;
  __m128i __cil_tmp54 ;
  __m128i __cil_tmp55 ;
  __m128i __cil_tmp56 ;
  __m128i __cil_tmp57 ;
  __m128i __cil_tmp58 ;
  __m128i __cil_tmp59 ;
  OPJ_SIZE_T __cil_tmp60 ;
  __m128i __cil_tmp61 ;
  __m128i __cil_tmp62 ;
  __m128i __cil_tmp63 ;
  __m128i __cil_tmp64 ;
  __m128i __cil_tmp65 ;
  __m128i __cil_tmp66 ;
  __m128i __cil_tmp67 ;
  __m128i __cil_tmp68 ;
  __m128i __cil_tmp69 ;
  __m128i __cil_tmp70 ;
  __m128i __cil_tmp71 ;
  __m128i __cil_tmp72 ;
  __m128i __cil_tmp73 ;
  __m128i __cil_tmp74 ;
  __m128i __cil_tmp75 ;
  __m128i __cil_tmp76 ;
  __m128i __cil_tmp77 ;
  __m128i __cil_tmp78 ;

  {
  {
#line 750
  __cil_tmp17 = _mm_set1_epi32(2);
#line 750
  two = __cil_tmp17;
#line 752
  in_even = tiledp_col + (OPJ_SIZE_T )sn * stride;
#line 753
  in_odd = tiledp_col + 0;
#line 769
  s1_0 = _mm_loadu_si128(in_even + stride);
#line 771
  __cil_tmp25 = _mm_loadu_si128(in_odd + 0);
#line 771
  __cil_tmp26 = _mm_loadu_si128(in_even + 0);
#line 771
  __cil_tmp27 = _mm_add_epi32(__cil_tmp26, s1_0);
#line 771
  __cil_tmp28 = _mm_add_epi32(__cil_tmp27, two);
#line 771
  __cil_tmp29 = _mm_srai_epi32(__cil_tmp28, 2);
#line 771
  __cil_tmp30 = _mm_sub_epi32(__cil_tmp25, __cil_tmp29);
#line 771
  dc_0 = __cil_tmp30;
#line 773
  __cil_tmp31 = _mm_loadu_si128(in_even + 0);
#line 773
  __cil_tmp32 = _mm_add_epi32(__cil_tmp31, dc_0);
#line 773
  _mm_store_si128(tmp + 0, __cil_tmp32);
#line 775
  s1_1 = _mm_loadu_si128((in_even + stride) + 4);
#line 777
  __cil_tmp34 = _mm_loadu_si128(in_odd + 4);
#line 777
  __cil_tmp35 = _mm_loadu_si128(in_even + 4);
#line 777
  __cil_tmp36 = _mm_add_epi32(__cil_tmp35, s1_1);
#line 777
  __cil_tmp37 = _mm_add_epi32(__cil_tmp36, two);
#line 777
  __cil_tmp38 = _mm_srai_epi32(__cil_tmp37, 2);
#line 777
  __cil_tmp39 = _mm_sub_epi32(__cil_tmp34, __cil_tmp38);
#line 777
  dc_1 = __cil_tmp39;
#line 779
  __cil_tmp40 = _mm_loadu_si128(in_even + 4);
#line 779
  __cil_tmp41 = _mm_add_epi32(__cil_tmp40, dc_1);
#line 779
  _mm_store_si128((tmp + 0) + 4, __cil_tmp41);
#line 782
  j = (OPJ_SIZE_T )1;
#line 782
  i = 1;
  }
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;

#line 782
    if (! (i < (len - 2) - ! (len & 1))) {
#line 782
      goto while_break;
    }
    {
#line 784
    s2_0 = _mm_loadu_si128(in_even + (j + 1UL) * stride);
#line 785
    s2_1 = _mm_loadu_si128((in_even + (j + 1UL) * stride) + 4);
#line 788
    __cil_tmp44 = _mm_loadu_si128(in_odd + j * stride);
#line 788
    __cil_tmp45 = _mm_add_epi32(s1_0, s2_0);
#line 788
    __cil_tmp46 = _mm_add_epi32(__cil_tmp45, two);
#line 788
    __cil_tmp47 = _mm_srai_epi32(__cil_tmp46, 2);
#line 788
    __cil_tmp48 = _mm_sub_epi32(__cil_tmp44, __cil_tmp47);
#line 788
    dn_0 = __cil_tmp48;
#line 790
    __cil_tmp49 = _mm_loadu_si128((in_odd + j * stride) + 4);
#line 790
    __cil_tmp50 = _mm_add_epi32(s1_1, s2_1);
#line 790
    __cil_tmp51 = _mm_add_epi32(__cil_tmp50, two);
#line 790
    __cil_tmp52 = _mm_srai_epi32(__cil_tmp51, 2);
#line 790
    __cil_tmp53 = _mm_sub_epi32(__cil_tmp49, __cil_tmp52);
#line 790
    dn_1 = __cil_tmp53;
#line 793
    _mm_store_si128(tmp + 8 * i, dc_0);
#line 794
    _mm_store_si128((tmp + 8 * i) + 4, dc_1);
#line 797
    __cil_tmp54 = _mm_add_epi32(dn_0, dc_0);
#line 797
    __cil_tmp55 = _mm_srai_epi32(__cil_tmp54, 1);
#line 797
    __cil_tmp56 = _mm_add_epi32(s1_0, __cil_tmp55);
#line 797
    _mm_store_si128((tmp + 8 * (i + 1)) + 0, __cil_tmp56);
#line 799
    __cil_tmp57 = _mm_add_epi32(dn_1, dc_1);
#line 799
    __cil_tmp58 = _mm_srai_epi32(__cil_tmp57, 1);
#line 799
    __cil_tmp59 = _mm_add_epi32(s1_1, __cil_tmp58);
#line 799
    _mm_store_si128((tmp + 8 * (i + 1)) + 4, __cil_tmp59);
#line 802
    dc_0 = dn_0;
#line 803
    s1_0 = s2_0;
#line 804
    dc_1 = dn_1;
#line 805
    s1_1 = s2_1;
#line 782
    __cil_tmp60 = j;
#line 782
    j ++;
#line 782
    i += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 807
  _mm_store_si128(tmp + 8 * i, dc_0);
#line 808
  _mm_store_si128((tmp + 8 * i) + 4, dc_1);
  }
#line 810
  if (! (len & 1)) {
    {
#line 812
    __cil_tmp61 = _mm_loadu_si128(in_odd + (OPJ_SIZE_T )(len / 2 - 1) * stride);
#line 812
    __cil_tmp62 = _mm_add_epi32(s1_0, s1_0);
#line 812
    __cil_tmp63 = _mm_add_epi32(__cil_tmp62, two);
#line 812
    __cil_tmp64 = _mm_srai_epi32(__cil_tmp63, 2);
#line 812
    __cil_tmp65 = _mm_sub_epi32(__cil_tmp61, __cil_tmp64);
#line 812
    dn_0 = __cil_tmp65;
#line 814
    __cil_tmp66 = _mm_loadu_si128((in_odd + (OPJ_SIZE_T )(len / 2 - 1) * stride) + 4);
#line 814
    __cil_tmp67 = _mm_add_epi32(s1_1, s1_1);
#line 814
    __cil_tmp68 = _mm_add_epi32(__cil_tmp67, two);
#line 814
    __cil_tmp69 = _mm_srai_epi32(__cil_tmp68, 2);
#line 814
    __cil_tmp70 = _mm_sub_epi32(__cil_tmp66, __cil_tmp69);
#line 814
    dn_1 = __cil_tmp70;
#line 818
    __cil_tmp71 = _mm_add_epi32(dn_0, dc_0);
#line 818
    __cil_tmp72 = _mm_srai_epi32(__cil_tmp71, 1);
#line 818
    __cil_tmp73 = _mm_add_epi32(s1_0, __cil_tmp72);
#line 818
    _mm_store_si128((tmp + 8 * (len - 2)) + 0, __cil_tmp73);
#line 820
    __cil_tmp74 = _mm_add_epi32(dn_1, dc_1);
#line 820
    __cil_tmp75 = _mm_srai_epi32(__cil_tmp74, 1);
#line 820
    __cil_tmp76 = _mm_add_epi32(s1_1, __cil_tmp75);
#line 820
    _mm_store_si128((tmp + 8 * (len - 2)) + 4, __cil_tmp76);
#line 823
    _mm_store_si128((tmp + 8 * (len - 1)) + 0, dn_0);
#line 824
    _mm_store_si128((tmp + 8 * (len - 1)) + 4, dn_1);
    }
  } else {
    {
#line 826
    __cil_tmp77 = _mm_add_epi32(s1_0, dc_0);
#line 826
    _mm_store_si128((tmp + 8 * (len - 1)) + 0, __cil_tmp77);
#line 827
    __cil_tmp78 = _mm_add_epi32(s1_1, dc_1);
#line 827
    _mm_store_si128((tmp + 8 * (len - 1)) + 4, __cil_tmp78);
    }
  }
  {
#line 831
  opj_idwt53_v_final_memcpy(tiledp_col, tmp, len, stride);
  }
#line 833
  return;
}
}
#line 850 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_idwt3_v_cas0(OPJ_INT32 *tmp , OPJ_INT32 sn , OPJ_INT32 len , OPJ_INT32 *tiledp_col ,
                             OPJ_SIZE_T stride ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 d1c ;
  OPJ_INT32 d1n ;
  OPJ_INT32 s1n ;
  OPJ_INT32 s0c ;
  OPJ_INT32 s0n ;
  OPJ_INT32 __cil_tmp14 ;

  {
#line 864
  s1n = *(tiledp_col + 0);
#line 865
  d1n = *(tiledp_col + (OPJ_SIZE_T )sn * stride);
#line 866
  s0n = s1n - ((d1n + 1) >> 1);
#line 868
  j = 0;
#line 868
  i = 0;
  {
#line 868
  while (1) {
    while_continue: /* CIL Label */ ;

#line 868
    if (! (i < len - 3)) {
#line 868
      goto while_break;
    }
#line 869
    d1c = d1n;
#line 870
    s0c = s0n;
#line 872
    s1n = *(tiledp_col + (OPJ_SIZE_T )(j + 1) * stride);
#line 873
    d1n = *(tiledp_col + (OPJ_SIZE_T )((sn + j) + 1) * stride);
#line 875
    s0n = s1n - (((d1c + d1n) + 2) >> 2);
#line 877
    *(tmp + i) = s0c;
#line 878
    *(tmp + (i + 1)) = d1c + ((s0c + s0n) >> 1);
#line 868
    __cil_tmp14 = j;
#line 868
    j ++;
#line 868
    i += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 881
  *(tmp + i) = s0n;
#line 883
  if (len & 1) {
#line 884
    *(tmp + (len - 1)) = *(tiledp_col + (OPJ_SIZE_T )((len - 1) / 2) * stride) - ((d1n + 1) >> 1);
#line 887
    *(tmp + (len - 2)) = d1n + ((s0n + *(tmp + (len - 1))) >> 1);
  } else {
#line 889
    *(tmp + (len - 1)) = d1n + s0n;
  }
#line 892
  i = 0;
  {
#line 892
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 892
    if (! (i < len)) {
#line 892
      goto while_break___0;
    }
#line 893
    *(tiledp_col + (OPJ_SIZE_T )i * stride) = *(tmp + i);
#line 892
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 896
  return;
}
}
#line 900 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_idwt3_v_cas1(OPJ_INT32 *tmp , OPJ_INT32 sn , OPJ_INT32 len , OPJ_INT32 *tiledp_col ,
                             OPJ_SIZE_T stride ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 s1 ;
  OPJ_INT32 s2 ;
  OPJ_INT32 dc ;
  OPJ_INT32 dn ;
  OPJ_INT32 *in_even ;
  OPJ_INT32 *in_odd ;
  OPJ_INT32 __cil_tmp15 ;

  {
#line 908
  in_even = tiledp_col + (OPJ_SIZE_T )sn * stride;
#line 909
  in_odd = tiledp_col + 0;
#line 916
  s1 = *(in_even + stride);
#line 917
  dc = *(in_odd + 0) - (((*(in_even + 0) + s1) + 2) >> 2);
#line 918
  *(tmp + 0) = *(in_even + 0) + dc;
#line 919
  j = 1;
#line 919
  i = 1;
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;

#line 919
    if (! (i < (len - 2) - ! (len & 1))) {
#line 919
      goto while_break;
    }
#line 921
    s2 = *(in_even + (OPJ_SIZE_T )(j + 1) * stride);
#line 923
    dn = *(in_odd + (OPJ_SIZE_T )j * stride) - (((s1 + s2) + 2) >> 2);
#line 924
    *(tmp + i) = dc;
#line 925
    *(tmp + (i + 1)) = s1 + ((dn + dc) >> 1);
#line 927
    dc = dn;
#line 928
    s1 = s2;
#line 919
    __cil_tmp15 = j;
#line 919
    j ++;
#line 919
    i += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 930
  *(tmp + i) = dc;
#line 931
  if (! (len & 1)) {
#line 932
    dn = *(in_odd + (OPJ_SIZE_T )(len / 2 - 1) * stride) - ((s1 + 1) >> 1);
#line 933
    *(tmp + (len - 2)) = s1 + ((dn + dc) >> 1);
#line 934
    *(tmp + (len - 1)) = dn;
  } else {
#line 936
    *(tmp + (len - 1)) = s1 + dc;
  }
#line 939
  i = 0;
  {
#line 939
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 939
    if (! (i < len)) {
#line 939
      goto while_break___0;
    }
#line 940
    *(tiledp_col + (OPJ_SIZE_T )i * stride) = *(tmp + i);
#line 939
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 943
  return;
}
}
#line 949 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_idwt53_v(opj_dwt_t *dwt , OPJ_INT32 *tiledp_col , OPJ_SIZE_T stride ,
                         OPJ_INT32 nb_cols ) 
{ 
  OPJ_INT32 sn ;
  OPJ_INT32 len ;
  OPJ_INT32 c ;
  OPJ_INT32 __cil_tmp8 ;
  OPJ_INT32 *__cil_tmp9 ;
  OPJ_INT32 c___0 ;
  OPJ_INT32 __cil_tmp11 ;
  OPJ_INT32 *__cil_tmp12 ;
  OPJ_INT32 c___1 ;
  OPJ_INT32 *out ;
  OPJ_INT32 i ;
  OPJ_INT32 *in_even ;
  OPJ_INT32 *in_odd ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 *__cil_tmp19 ;
  OPJ_INT32 c___2 ;
  OPJ_INT32 __cil_tmp21 ;
  OPJ_INT32 *__cil_tmp22 ;

  {
#line 965
  sn = dwt->sn;
#line 966
  len = sn + dwt->dn;
#line 967
  if (dwt->cas == 0) {
#line 971
    if (len > 1) {
#line 971
      if (nb_cols == 8) {
        {
#line 974
        opj_idwt53_v_cas0_mcols_SSE2_OR_AVX2(dwt->mem, sn, len, tiledp_col, stride);
        }
#line 975
        return;
      }
    }
#line 978
    if (len > 1) {
#line 980
      c = 0;
      {
#line 980
      while (1) {
        while_continue: /* CIL Label */ ;

#line 980
        if (! (c < nb_cols)) {
#line 980
          goto while_break;
        }
        {
#line 981
        opj_idwt3_v_cas0(dwt->mem, sn, len, tiledp_col, stride);
#line 980
        __cil_tmp9 = tiledp_col;
#line 980
        tiledp_col ++;
#line 980
        __cil_tmp8 = c;
#line 980
        c ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break: ;
#line 983
      return;
    }
  } else {
#line 986
    if (len == 1) {
#line 988
      c___0 = 0;
      {
#line 988
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 988
        if (! (c___0 < nb_cols)) {
#line 988
          goto while_break___0;
        }
#line 989
        *(tiledp_col + 0) /= 2;
#line 988
        __cil_tmp12 = tiledp_col;
#line 988
        tiledp_col ++;
#line 988
        __cil_tmp11 = c___0;
#line 988
        c___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: ;
#line 991
      return;
    }
#line 994
    if (len == 2) {
#line 996
      out = dwt->mem;
#line 997
      c___1 = 0;
      {
#line 997
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 997
        if (! (c___1 < nb_cols)) {
#line 997
          goto while_break___1;
        }
#line 999
        in_even = tiledp_col + (OPJ_SIZE_T )sn * stride;
#line 1000
        in_odd = tiledp_col + 0;
#line 1002
        *(out + 1) = *(in_odd + 0) - ((*(in_even + 0) + 1) >> 1);
#line 1003
        *(out + 0) = *(in_even + 0) + *(out + 1);
#line 1005
        i = 0;
        {
#line 1005
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1005
          if (! (i < len)) {
#line 1005
            goto while_break___2;
          }
#line 1006
          *(tiledp_col + (OPJ_SIZE_T )i * stride) = *(out + i);
#line 1005
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: 
#line 997
        __cil_tmp19 = tiledp_col;
#line 997
        tiledp_col ++;
#line 997
        __cil_tmp18 = c___1;
#line 997
        c___1 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: ;
#line 1010
      return;
    }
#line 1014
    if (len > 2) {
#line 1014
      if (nb_cols == 8) {
        {
#line 1017
        opj_idwt53_v_cas1_mcols_SSE2_OR_AVX2(dwt->mem, sn, len, tiledp_col, stride);
        }
#line 1018
        return;
      }
    }
#line 1021
    if (len > 2) {
#line 1023
      c___2 = 0;
      {
#line 1023
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1023
        if (! (c___2 < nb_cols)) {
#line 1023
          goto while_break___3;
        }
        {
#line 1024
        opj_idwt3_v_cas1(dwt->mem, sn, len, tiledp_col, stride);
#line 1023
        __cil_tmp22 = tiledp_col;
#line 1023
        tiledp_col ++;
#line 1023
        __cil_tmp21 = c___2;
#line 1023
        c___2 ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: ;
#line 1026
      return;
    }
  }
#line 1029
  return;
}
}
#line 1036 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_encode_1_real(OPJ_INT32 *a , OPJ_INT32 dn , OPJ_INT32 sn , OPJ_INT32 cas ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;
  OPJ_INT32 tmp___2 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_INT32 tmp___3 ;
  OPJ_INT32 tmp___4 ;
  OPJ_INT32 tmp___5 ;
  OPJ_INT32 tmp___6 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 tmp___7 ;
  OPJ_INT32 tmp___8 ;
  OPJ_INT32 tmp___9 ;
  OPJ_INT32 tmp___10 ;
  OPJ_INT32 __cil_tmp22 ;
  OPJ_INT32 tmp___11 ;
  OPJ_INT32 tmp___12 ;
  OPJ_INT32 tmp___13 ;
  OPJ_INT32 tmp___14 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 tmp___15 ;
  OPJ_INT32 tmp___16 ;
  OPJ_INT32 tmp___17 ;
  OPJ_INT32 tmp___18 ;
  OPJ_INT32 __cil_tmp38 ;
  OPJ_INT32 tmp___19 ;
  OPJ_INT32 tmp___20 ;
  OPJ_INT32 tmp___21 ;
  OPJ_INT32 tmp___22 ;
  OPJ_INT32 __cil_tmp44 ;
  OPJ_INT32 tmp___23 ;
  OPJ_INT32 tmp___24 ;
  OPJ_INT32 tmp___25 ;
  OPJ_INT32 tmp___26 ;
  OPJ_INT32 __cil_tmp50 ;
  OPJ_INT32 tmp___27 ;
  OPJ_INT32 tmp___28 ;
  OPJ_INT32 tmp___29 ;
  OPJ_INT32 tmp___30 ;
  OPJ_INT32 __cil_tmp56 ;

  {
#line 1040
  if (! cas) {
#line 1041
    if (dn > 0) {
      _L: 
#line 1042
      i = 0;
      {
#line 1042
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1042
        if (! (i < dn)) {
#line 1042
          goto while_break;
        }
#line 1043
        if (i + 1 < 0) {
#line 1043
          tmp___2 = *(a + 0);
        } else {
#line 1043
          if (i + 1 >= sn) {
#line 1043
            tmp___1 = *(a + (sn - 1) * 2);
          } else {
#line 1043
            tmp___1 = *(a + (i + 1) * 2);
          }
#line 1043
          tmp___2 = tmp___1;
        }
#line 1043
        if (i < 0) {
#line 1043
          tmp___0 = *(a + 0);
        } else {
#line 1043
          if (i >= sn) {
#line 1043
            tmp = *(a + (sn - 1) * 2);
          } else {
#line 1043
            tmp = *(a + i * 2);
          }
#line 1043
          tmp___0 = tmp;
        }
        {
#line 1043
        __cil_tmp10 = opj_int_fix_mul(tmp___0 + tmp___2, 12993);
#line 1043
        *(a + (1 + i * 2)) -= __cil_tmp10;
#line 1042
        i ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break: 
#line 1045
      i = 0;
      {
#line 1045
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1045
        if (! (i < sn)) {
#line 1045
          goto while_break___0;
        }
#line 1046
        if (i < 0) {
#line 1046
          tmp___6 = *(a + 1);
        } else {
#line 1046
          if (i >= dn) {
#line 1046
            tmp___5 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 1046
            tmp___5 = *(a + (1 + i * 2));
          }
#line 1046
          tmp___6 = tmp___5;
        }
#line 1046
        if (i - 1 < 0) {
#line 1046
          tmp___4 = *(a + 1);
        } else {
#line 1046
          if (i - 1 >= dn) {
#line 1046
            tmp___3 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 1046
            tmp___3 = *(a + (1 + (i - 1) * 2));
          }
#line 1046
          tmp___4 = tmp___3;
        }
        {
#line 1046
        __cil_tmp16 = opj_int_fix_mul(tmp___4 + tmp___6, 434);
#line 1046
        *(a + i * 2) -= __cil_tmp16;
#line 1045
        i ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___0: 
#line 1048
      i = 0;
      {
#line 1048
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1048
        if (! (i < dn)) {
#line 1048
          goto while_break___1;
        }
#line 1049
        if (i + 1 < 0) {
#line 1049
          tmp___10 = *(a + 0);
        } else {
#line 1049
          if (i + 1 >= sn) {
#line 1049
            tmp___9 = *(a + (sn - 1) * 2);
          } else {
#line 1049
            tmp___9 = *(a + (i + 1) * 2);
          }
#line 1049
          tmp___10 = tmp___9;
        }
#line 1049
        if (i < 0) {
#line 1049
          tmp___8 = *(a + 0);
        } else {
#line 1049
          if (i >= sn) {
#line 1049
            tmp___7 = *(a + (sn - 1) * 2);
          } else {
#line 1049
            tmp___7 = *(a + i * 2);
          }
#line 1049
          tmp___8 = tmp___7;
        }
        {
#line 1049
        __cil_tmp22 = opj_int_fix_mul(tmp___8 + tmp___10, 7233);
#line 1049
        *(a + (1 + i * 2)) += __cil_tmp22;
#line 1048
        i ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___1: 
#line 1051
      i = 0;
      {
#line 1051
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1051
        if (! (i < sn)) {
#line 1051
          goto while_break___2;
        }
#line 1052
        if (i < 0) {
#line 1052
          tmp___14 = *(a + 1);
        } else {
#line 1052
          if (i >= dn) {
#line 1052
            tmp___13 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 1052
            tmp___13 = *(a + (1 + i * 2));
          }
#line 1052
          tmp___14 = tmp___13;
        }
#line 1052
        if (i - 1 < 0) {
#line 1052
          tmp___12 = *(a + 1);
        } else {
#line 1052
          if (i - 1 >= dn) {
#line 1052
            tmp___11 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 1052
            tmp___11 = *(a + (1 + (i - 1) * 2));
          }
#line 1052
          tmp___12 = tmp___11;
        }
        {
#line 1052
        __cil_tmp28 = opj_int_fix_mul(tmp___12 + tmp___14, 3633);
#line 1052
        *(a + i * 2) += __cil_tmp28;
#line 1051
        i ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___2: 
#line 1054
      i = 0;
      {
#line 1054
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1054
        if (! (i < dn)) {
#line 1054
          goto while_break___3;
        }
        {
#line 1055
        *(a + (1 + i * 2)) = opj_int_fix_mul(*(a + (1 + i * 2)), 5038);
#line 1054
        i ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___3: 
#line 1057
      i = 0;
      {
#line 1057
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1057
        if (! (i < sn)) {
#line 1057
          goto while_break___4;
        }
        {
#line 1058
        *(a + i * 2) = opj_int_fix_mul(*(a + i * 2), 6659);
#line 1057
        i ++;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___4: ;
    } else
#line 1041
    if (sn > 1) {
#line 1041
      goto _L;
    }
  } else
#line 1062
  if (sn > 0) {
    _L___32: 
#line 1063
    i = 0;
    {
#line 1063
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 1063
      if (! (i < dn)) {
#line 1063
        goto while_break___5;
      }
#line 1064
      if (i - 1 < 0) {
#line 1064
        tmp___18 = *(a + 1);
      } else {
#line 1064
        if (i - 1 >= sn) {
#line 1064
          tmp___17 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 1064
          tmp___17 = *(a + (1 + (i - 1) * 2));
        }
#line 1064
        tmp___18 = tmp___17;
      }
#line 1064
      if (i < 0) {
#line 1064
        tmp___16 = *(a + 1);
      } else {
#line 1064
        if (i >= sn) {
#line 1064
          tmp___15 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 1064
          tmp___15 = *(a + (1 + i * 2));
        }
#line 1064
        tmp___16 = tmp___15;
      }
      {
#line 1064
      __cil_tmp38 = opj_int_fix_mul(tmp___16 + tmp___18, 12993);
#line 1064
      *(a + i * 2) -= __cil_tmp38;
#line 1063
      i ++;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___5: 
#line 1066
    i = 0;
    {
#line 1066
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 1066
      if (! (i < sn)) {
#line 1066
        goto while_break___6;
      }
#line 1067
      if (i + 1 < 0) {
#line 1067
        tmp___22 = *(a + 0);
      } else {
#line 1067
        if (i + 1 >= dn) {
#line 1067
          tmp___21 = *(a + (dn - 1) * 2);
        } else {
#line 1067
          tmp___21 = *(a + (i + 1) * 2);
        }
#line 1067
        tmp___22 = tmp___21;
      }
#line 1067
      if (i < 0) {
#line 1067
        tmp___20 = *(a + 0);
      } else {
#line 1067
        if (i >= dn) {
#line 1067
          tmp___19 = *(a + (dn - 1) * 2);
        } else {
#line 1067
          tmp___19 = *(a + i * 2);
        }
#line 1067
        tmp___20 = tmp___19;
      }
      {
#line 1067
      __cil_tmp44 = opj_int_fix_mul(tmp___20 + tmp___22, 434);
#line 1067
      *(a + (1 + i * 2)) -= __cil_tmp44;
#line 1066
      i ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___6: 
#line 1069
    i = 0;
    {
#line 1069
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 1069
      if (! (i < dn)) {
#line 1069
        goto while_break___7;
      }
#line 1070
      if (i - 1 < 0) {
#line 1070
        tmp___26 = *(a + 1);
      } else {
#line 1070
        if (i - 1 >= sn) {
#line 1070
          tmp___25 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 1070
          tmp___25 = *(a + (1 + (i - 1) * 2));
        }
#line 1070
        tmp___26 = tmp___25;
      }
#line 1070
      if (i < 0) {
#line 1070
        tmp___24 = *(a + 1);
      } else {
#line 1070
        if (i >= sn) {
#line 1070
          tmp___23 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 1070
          tmp___23 = *(a + (1 + i * 2));
        }
#line 1070
        tmp___24 = tmp___23;
      }
      {
#line 1070
      __cil_tmp50 = opj_int_fix_mul(tmp___24 + tmp___26, 7233);
#line 1070
      *(a + i * 2) += __cil_tmp50;
#line 1069
      i ++;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___7: 
#line 1072
    i = 0;
    {
#line 1072
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 1072
      if (! (i < sn)) {
#line 1072
        goto while_break___8;
      }
#line 1073
      if (i + 1 < 0) {
#line 1073
        tmp___30 = *(a + 0);
      } else {
#line 1073
        if (i + 1 >= dn) {
#line 1073
          tmp___29 = *(a + (dn - 1) * 2);
        } else {
#line 1073
          tmp___29 = *(a + (i + 1) * 2);
        }
#line 1073
        tmp___30 = tmp___29;
      }
#line 1073
      if (i < 0) {
#line 1073
        tmp___28 = *(a + 0);
      } else {
#line 1073
        if (i >= dn) {
#line 1073
          tmp___27 = *(a + (dn - 1) * 2);
        } else {
#line 1073
          tmp___27 = *(a + i * 2);
        }
#line 1073
        tmp___28 = tmp___27;
      }
      {
#line 1073
      __cil_tmp56 = opj_int_fix_mul(tmp___28 + tmp___30, 3633);
#line 1073
      *(a + (1 + i * 2)) += __cil_tmp56;
#line 1072
      i ++;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___8: 
#line 1075
    i = 0;
    {
#line 1075
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 1075
      if (! (i < dn)) {
#line 1075
        goto while_break___9;
      }
      {
#line 1076
      *(a + i * 2) = opj_int_fix_mul(*(a + i * 2), 5038);
#line 1075
      i ++;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___9: 
#line 1078
    i = 0;
    {
#line 1078
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 1078
      if (! (i < sn)) {
#line 1078
        goto while_break___10;
      }
      {
#line 1079
      *(a + (1 + i * 2)) = opj_int_fix_mul(*(a + (1 + i * 2)), 6659);
#line 1078
      i ++;
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___10: ;
  } else
#line 1062
  if (dn > 1) {
#line 1062
    goto _L___32;
  }
#line 1064
  return;
}
}
#line 1085 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_encode_stepsize(OPJ_INT32 stepsize , OPJ_INT32 numbps , opj_stepsize_t *bandno_stepsize ) 
{ 
  OPJ_INT32 p ;
  OPJ_INT32 n ;
  OPJ_INT32 __cil_tmp6 ;
  OPJ_INT32 __cil_tmp7 ;
  OPJ_INT32 tmp ;

  {
  {
#line 1089
  __cil_tmp6 = opj_int_floorlog2(stepsize);
#line 1089
  p = __cil_tmp6 - 13;
#line 1090
  __cil_tmp7 = opj_int_floorlog2(stepsize);
#line 1090
  n = 11 - __cil_tmp7;
  }
#line 1091
  if (n < 0) {
#line 1091
    tmp = stepsize >> - n;
  } else {
#line 1091
    tmp = stepsize << n;
  }
#line 1091
  bandno_stepsize->mant = tmp & 2047;
#line 1092
  bandno_stepsize->expn = numbps - p;
#line 1093
  return;
}
}
#line 1105 "/root/patron/new_24/src/lib/openjp2/dwt.c"
__inline static OPJ_BOOL opj_dwt_encode_procedure(opj_tcd_tilecomp_t *tilec , void (*p_function)(OPJ_INT32 * ,
                                                                                                 OPJ_INT32  ,
                                                                                                 OPJ_INT32  ,
                                                                                                 OPJ_INT32  ) ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_INT32 *a ;
  OPJ_INT32 *aj ;
  OPJ_INT32 *bj ;
  OPJ_INT32 w ;
  OPJ_INT32 l ;
  OPJ_INT32 rw ;
  OPJ_INT32 rh ;
  OPJ_SIZE_T l_data_size ;
  opj_tcd_resolution_t *l_cur_res ;
  opj_tcd_resolution_t *l_last_res ;
  OPJ_UINT32 __cil_tmp16 ;
  void *__cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 rw1 ;
  OPJ_INT32 rh1 ;
  OPJ_INT32 cas_col ;
  OPJ_INT32 cas_row ;
  OPJ_INT32 dn ;
  OPJ_INT32 sn ;

  {
  {
#line 1109
  a = (OPJ_INT32 *)0;
#line 1110
  aj = (OPJ_INT32 *)0;
#line 1111
  bj = (OPJ_INT32 *)0;
#line 1118
  l_cur_res = (opj_tcd_resolution_t *)0;
#line 1119
  l_last_res = (opj_tcd_resolution_t *)0;
#line 1121
  w = tilec->x1 - tilec->x0;
#line 1122
  l = (OPJ_INT32 )tilec->numresolutions - 1;
#line 1123
  a = tilec->data;
#line 1125
  l_cur_res = tilec->resolutions + l;
#line 1126
  l_last_res = l_cur_res - 1;
#line 1128
  __cil_tmp16 = opj_dwt_max_resolution(tilec->resolutions, tilec->numresolutions);
#line 1128
  l_data_size = (OPJ_SIZE_T )__cil_tmp16;
  }
#line 1130
  if (l_data_size > 0xffffffffffffffffUL / sizeof(OPJ_INT32 )) {
#line 1132
    return (0);
  }
  {
#line 1134
  l_data_size *= sizeof(OPJ_INT32 );
#line 1135
  __cil_tmp17 = opj_malloc(l_data_size);
#line 1135
  bj = (OPJ_INT32 *)__cil_tmp17;
  }
#line 1138
  if (! bj) {
#line 1138
    if (l_data_size != 0UL) {
#line 1139
      return (0);
    }
  }
#line 1141
  i = l;
  {
#line 1143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1143
    __cil_tmp18 = i;
#line 1143
    i --;
#line 1143
    if (! __cil_tmp18) {
#line 1143
      goto while_break;
    }
#line 1150
    rw = l_cur_res->x1 - l_cur_res->x0;
#line 1151
    rh = l_cur_res->y1 - l_cur_res->y0;
#line 1152
    rw1 = l_last_res->x1 - l_last_res->x0;
#line 1153
    rh1 = l_last_res->y1 - l_last_res->y0;
#line 1155
    cas_row = l_cur_res->x0 & 1;
#line 1156
    cas_col = l_cur_res->y0 & 1;
#line 1158
    sn = rh1;
#line 1159
    dn = rh - rh1;
#line 1160
    j = 0;
    {
#line 1160
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1160
      if (! (j < rw)) {
#line 1160
        goto while_break___0;
      }
#line 1161
      aj = a + j;
#line 1162
      k = 0;
      {
#line 1162
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1162
        if (! (k < rh)) {
#line 1162
          goto while_break___1;
        }
#line 1163
        *(bj + k) = *(aj + k * w);
#line 1162
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 1166
      (*p_function)(bj, dn, sn, cas_col);
#line 1168
      opj_dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
#line 1160
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 1171
    sn = rw1;
#line 1172
    dn = rw - rw1;
#line 1174
    j = 0;
    {
#line 1174
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1174
      if (! (j < rh)) {
#line 1174
        goto while_break___2;
      }
#line 1175
      aj = a + j * w;
#line 1176
      k = 0;
      {
#line 1176
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1176
        if (! (k < rw)) {
#line 1176
          goto while_break___3;
        }
#line 1177
        *(bj + k) = *(aj + k);
#line 1176
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 1179
      (*p_function)(bj, dn, sn, cas_row);
#line 1180
      opj_dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
#line 1174
      j ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 1183
    l_cur_res = l_last_res;
#line 1185
    l_last_res --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1188
  opj_free((void *)bj);
  }
#line 1189
  return (1);
}
}
#line 1194 "/root/patron/new_24/src/lib/openjp2/dwt.c"
OPJ_BOOL opj_dwt_encode(opj_tcd_tilecomp_t *tilec ) 
{ 
  OPJ_BOOL __cil_tmp2 ;

  {
  {
#line 1196
  __cil_tmp2 = opj_dwt_encode_procedure(tilec, & opj_dwt_encode_1);
  }
#line 1196
  return (__cil_tmp2);
}
}
#line 1202 "/root/patron/new_24/src/lib/openjp2/dwt.c"
OPJ_BOOL opj_dwt_decode(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 1205
  if (p_tcd->whole_tile_decoding) {
    {
#line 1206
    __cil_tmp4 = opj_dwt_decode_tile(p_tcd->thread_pool, tilec, numres);
    }
#line 1206
    return (__cil_tmp4);
  } else {
    {
#line 1208
    __cil_tmp5 = opj_dwt_decode_partial_tile(tilec, numres);
    }
#line 1208
    return (__cil_tmp5);
  }
}
}
#line 1216 "/root/patron/new_24/src/lib/openjp2/dwt.c"
OPJ_UINT32 opj_dwt_getgain(OPJ_UINT32 orient ) 
{ 


  {
#line 1218
  if (orient == 0U) {
#line 1219
    return ((OPJ_UINT32 )0);
  }
#line 1221
  if (orient == 1U) {
#line 1222
    return ((OPJ_UINT32 )1);
  } else
#line 1221
  if (orient == 2U) {
#line 1222
    return ((OPJ_UINT32 )1);
  }
#line 1224
  return ((OPJ_UINT32 )2);
}
}
#line 1230 "/root/patron/new_24/src/lib/openjp2/dwt.c"
OPJ_FLOAT64 opj_dwt_getnorm(OPJ_UINT32 level , OPJ_UINT32 orient ) 
{ 


  {
#line 1232
  return (opj_dwt_norms[orient][level]);
}
}
#line 1238 "/root/patron/new_24/src/lib/openjp2/dwt.c"
OPJ_BOOL opj_dwt_encode_real(opj_tcd_tilecomp_t *tilec ) 
{ 
  OPJ_BOOL __cil_tmp2 ;

  {
  {
#line 1240
  __cil_tmp2 = opj_dwt_encode_procedure(tilec, & opj_dwt_encode_1_real);
  }
#line 1240
  return (__cil_tmp2);
}
}
#line 1246 "/root/patron/new_24/src/lib/openjp2/dwt.c"
OPJ_UINT32 opj_dwt_getgain_real(OPJ_UINT32 orient ) 
{ 


  {
#line 1249
  return ((OPJ_UINT32 )0);
}
}
#line 1255 "/root/patron/new_24/src/lib/openjp2/dwt.c"
OPJ_FLOAT64 opj_dwt_getnorm_real(OPJ_UINT32 level , OPJ_UINT32 orient ) 
{ 


  {
#line 1257
  return (opj_dwt_norms_real[orient][level]);
}
}
#line 1260 "/root/patron/new_24/src/lib/openjp2/dwt.c"
void opj_dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , OPJ_UINT32 prec ) 
{ 
  OPJ_UINT32 numbands ;
  OPJ_UINT32 bandno ;
  OPJ_FLOAT64 stepsize ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 level ;
  OPJ_UINT32 orient ;
  OPJ_UINT32 gain ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  OPJ_FLOAT64 norm ;
  double __cil_tmp16 ;

  {
#line 1263
  numbands = 3U * tccp->numresolutions - 2U;
#line 1264
  bandno = (OPJ_UINT32 )0;
  {
#line 1264
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1264
    if (! (bandno < numbands)) {
#line 1264
      goto while_break;
    }
#line 1268
    if (bandno == 0U) {
#line 1268
      tmp = 0U;
    } else {
#line 1268
      tmp = (bandno - 1U) / 3U + 1U;
    }
#line 1268
    resno = tmp;
#line 1269
    if (bandno == 0U) {
#line 1269
      tmp___0 = 0U;
    } else {
#line 1269
      tmp___0 = (bandno - 1U) % 3U + 1U;
    }
#line 1269
    orient = tmp___0;
#line 1270
    level = (tccp->numresolutions - 1U) - resno;
#line 1271
    if (tccp->qmfbid == 0U) {
#line 1271
      tmp___3 = 0;
    } else {
#line 1271
      if (orient == 0U) {
#line 1271
        tmp___2 = 0;
      } else {
#line 1271
        if (orient == 1U) {
#line 1271
          tmp___1 = 1;
        } else
#line 1271
        if (orient == 2U) {
#line 1271
          tmp___1 = 1;
        } else {
#line 1271
          tmp___1 = 2;
        }
#line 1271
        tmp___2 = tmp___1;
      }
#line 1271
      tmp___3 = tmp___2;
    }
#line 1271
    gain = (OPJ_UINT32 )tmp___3;
#line 1273
    if (tccp->qntsty == 0U) {
#line 1274
      stepsize = 1.;
    } else {
#line 1276
      norm = opj_dwt_norms_real[orient][level];
#line 1277
      stepsize = (double )(1 << gain) / norm;
    }
    {
#line 1279
    __cil_tmp16 = floor(stepsize * 8192.);
#line 1279
    opj_dwt_encode_stepsize((OPJ_INT32 )__cil_tmp16, (OPJ_INT32 )(prec + gain), & tccp->stepsizes[bandno]);
#line 1264
    bandno ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1268
  return;
}
}
#line 1287 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_UINT32 opj_dwt_max_resolution(opj_tcd_resolution_t *r , OPJ_UINT32 i ) 
{ 
  OPJ_UINT32 mr ;
  OPJ_UINT32 w ;

  {
#line 1290
  mr = (OPJ_UINT32 )0;
  {
#line 1292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1292
    i --;
#line 1292
    if (! i) {
#line 1292
      goto while_break;
    }
#line 1293
    r ++;
#line 1294
    w = (OPJ_UINT32 )(r->x1 - r->x0);
#line 1294
    if (mr < w) {
#line 1295
      mr = w;
    }
#line 1297
    w = (OPJ_UINT32 )(r->y1 - r->y0);
#line 1297
    if (mr < w) {
#line 1298
      mr = w;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1301
  return (mr);
}
}
#line 1313 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_decode_h_func(void *user_data , opj_tls_t *tls ) 
{ 
  OPJ_UINT32 j ;
  opj_dwd_decode_h_job_t *job ;

  {
#line 1319
  job = (opj_dwd_decode_h_job_t *)user_data;
#line 1320
  j = job->min_j;
  {
#line 1320
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1320
    if (! (j < job->max_j)) {
#line 1320
      goto while_break;
    }
    {
#line 1321
    opj_idwt53_h(& job->h, job->tiledp + j * job->w);
#line 1320
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1324
  opj_aligned_free((void *)job->h.mem);
#line 1325
  opj_free((void *)job);
  }
#line 1327
  return;
}
}
#line 1337 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_decode_v_func(void *user_data , opj_tls_t *tls ) 
{ 
  OPJ_UINT32 j ;
  opj_dwd_decode_v_job_t *job ;

  {
#line 1343
  job = (opj_dwd_decode_v_job_t *)user_data;
#line 1344
  j = job->min_j;
  {
#line 1344
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1344
    if (! (j + 8U <= job->max_j)) {
#line 1344
      goto while_break;
    }
    {
#line 1346
    opj_idwt53_v(& job->v, job->tiledp + j, (OPJ_SIZE_T )job->w, 8);
#line 1345
    j += 8U;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1349
  if (j < job->max_j) {
    {
#line 1350
    opj_idwt53_v(& job->v, job->tiledp + j, (OPJ_SIZE_T )job->w, (OPJ_INT32 )(job->max_j - j));
    }
  }
  {
#line 1353
  opj_aligned_free((void *)job->v.mem);
#line 1354
  opj_free((void *)job);
  }
#line 1356
  return;
}
}
#line 1361 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_BOOL opj_dwt_decode_tile(opj_thread_pool_t *tp , opj_tcd_tilecomp_t *tilec ,
                                    OPJ_UINT32 numres ) 
{ 
  opj_dwt_t h ;
  opj_dwt_t v ;
  opj_tcd_resolution_t *tr ;
  OPJ_UINT32 rw ;
  OPJ_UINT32 rh ;
  OPJ_UINT32 w ;
  OPJ_SIZE_T h_mem_size ;
  int num_threads ;
  OPJ_UINT32 __cil_tmp13 ;
  void *__cil_tmp14 ;
  OPJ_INT32 *tiledp ;
  OPJ_UINT32 j ;
  OPJ_UINT32 num_jobs ;
  OPJ_UINT32 step_j ;
  opj_dwd_decode_h_job_t *job ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  OPJ_UINT32 num_jobs___0 ;
  OPJ_UINT32 step_j___0 ;
  opj_dwd_decode_v_job_t *job___0 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;

  {
#line 1367
  tr = tilec->resolutions;
#line 1369
  rw = (OPJ_UINT32 )(tr->x1 - tr->x0);
#line 1371
  rh = (OPJ_UINT32 )(tr->y1 - tr->y0);
#line 1374
  w = (OPJ_UINT32 )((tilec->resolutions + (tilec->minimum_num_resolutions - 1U))->x1 - (tilec->resolutions + (tilec->minimum_num_resolutions - 1U))->x0);
#line 1380
  if (numres == 1U) {
#line 1381
    return (1);
  }
  {
#line 1383
  num_threads = opj_thread_pool_get_thread_count(tp);
#line 1384
  __cil_tmp13 = opj_dwt_max_resolution(tr, numres);
#line 1384
  h_mem_size = (OPJ_SIZE_T )__cil_tmp13;
  }
#line 1386
  if (h_mem_size > 2305843009213693951UL / sizeof(OPJ_INT32 )) {
#line 1388
    return (0);
  }
  {
#line 1393
  h_mem_size *= 8UL * sizeof(OPJ_INT32 );
#line 1394
  __cil_tmp14 = opj_aligned_32_malloc(h_mem_size);
#line 1394
  h.mem = (OPJ_INT32 *)__cil_tmp14;
  }
#line 1395
  if (! h.mem) {
#line 1397
    return (0);
  }
#line 1400
  v.mem = h.mem;
  {
#line 1402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1402
    numres --;
#line 1402
    if (! numres) {
#line 1402
      goto while_break;
    }
#line 1403
    tiledp = tilec->data;
#line 1406
    tr ++;
#line 1407
    h.sn = (OPJ_INT32 )rw;
#line 1408
    v.sn = (OPJ_INT32 )rh;
#line 1410
    rw = (OPJ_UINT32 )(tr->x1 - tr->x0);
#line 1411
    rh = (OPJ_UINT32 )(tr->y1 - tr->y0);
#line 1413
    h.dn = (OPJ_INT32 )(rw - (OPJ_UINT32 )h.sn);
#line 1414
    h.cas = tr->x0 % 2;
#line 1416
    if (num_threads <= 1) {
      _L: 
#line 1417
      j = (OPJ_UINT32 )0;
      {
#line 1417
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1417
        if (! (j < rh)) {
#line 1417
          goto while_break___0;
        }
        {
#line 1418
        opj_idwt53_h(& h, tiledp + (OPJ_SIZE_T )j * (unsigned long )w);
#line 1417
        j ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: ;
    } else
#line 1416
    if (rh <= 1U) {
#line 1416
      goto _L;
    } else {
#line 1421
      num_jobs = (OPJ_UINT32 )num_threads;
#line 1424
      if (rh < num_jobs) {
#line 1425
        num_jobs = rh;
      }
#line 1427
      step_j = rh / num_jobs;
#line 1429
      j = (OPJ_UINT32 )0;
      {
#line 1429
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1429
        if (! (j < num_jobs)) {
#line 1429
          goto while_break___1;
        }
        {
#line 1432
        __cil_tmp20 = opj_malloc(sizeof(opj_dwd_decode_h_job_t ));
#line 1432
        job = (opj_dwd_decode_h_job_t *)__cil_tmp20;
        }
#line 1433
        if (! job) {
          {
#line 1438
          opj_thread_pool_wait_completion(tp, 0);
#line 1439
          opj_aligned_free((void *)h.mem);
          }
#line 1440
          return (0);
        }
#line 1442
        job->h = h;
#line 1443
        job->rw = rw;
#line 1444
        job->w = w;
#line 1445
        job->tiledp = tiledp;
#line 1446
        job->min_j = j * step_j;
#line 1447
        job->max_j = (j + 1U) * step_j;
#line 1448
        if (j == num_jobs - 1U) {
#line 1449
          job->max_j = rh;
        }
        {
#line 1451
        __cil_tmp21 = opj_aligned_32_malloc(h_mem_size);
#line 1451
        job->h.mem = (OPJ_INT32 *)__cil_tmp21;
        }
#line 1452
        if (! job->h.mem) {
          {
#line 1454
          opj_thread_pool_wait_completion(tp, 0);
#line 1455
          opj_free((void *)job);
#line 1456
          opj_aligned_free((void *)h.mem);
          }
#line 1457
          return (0);
        }
        {
#line 1459
        opj_thread_pool_submit_job(tp, & opj_dwt_decode_h_func, (void *)job);
#line 1429
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 1461
      opj_thread_pool_wait_completion(tp, 0);
      }
    }
#line 1464
    v.dn = (OPJ_INT32 )(rh - (OPJ_UINT32 )v.sn);
#line 1465
    v.cas = tr->y0 % 2;
#line 1467
    if (num_threads <= 1) {
      _L___33: 
#line 1468
      j = (OPJ_UINT32 )0;
      {
#line 1468
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1468
        if (! (j + 8U <= rw)) {
#line 1468
          goto while_break___2;
        }
        {
#line 1470
        opj_idwt53_v(& v, tiledp + j, (OPJ_SIZE_T )w, 8);
#line 1469
        j += 8U;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: ;
#line 1472
      if (j < rw) {
        {
#line 1473
        opj_idwt53_v(& v, tiledp + j, (OPJ_SIZE_T )w, (OPJ_INT32 )(rw - j));
        }
      }
    } else
#line 1467
    if (rw <= 1U) {
#line 1467
      goto _L___33;
    } else {
#line 1476
      num_jobs___0 = (OPJ_UINT32 )num_threads;
#line 1479
      if (rw < num_jobs___0) {
#line 1480
        num_jobs___0 = rw;
      }
#line 1482
      step_j___0 = rw / num_jobs___0;
#line 1484
      j = (OPJ_UINT32 )0;
      {
#line 1484
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1484
        if (! (j < num_jobs___0)) {
#line 1484
          goto while_break___3;
        }
        {
#line 1487
        __cil_tmp26 = opj_malloc(sizeof(opj_dwd_decode_v_job_t ));
#line 1487
        job___0 = (opj_dwd_decode_v_job_t *)__cil_tmp26;
        }
#line 1488
        if (! job___0) {
          {
#line 1493
          opj_thread_pool_wait_completion(tp, 0);
#line 1494
          opj_aligned_free((void *)v.mem);
          }
#line 1495
          return (0);
        }
#line 1497
        job___0->v = v;
#line 1498
        job___0->rh = rh;
#line 1499
        job___0->w = w;
#line 1500
        job___0->tiledp = tiledp;
#line 1501
        job___0->min_j = j * step_j___0;
#line 1502
        job___0->max_j = (j + 1U) * step_j___0;
#line 1503
        if (j == num_jobs___0 - 1U) {
#line 1504
          job___0->max_j = rw;
        }
        {
#line 1506
        __cil_tmp27 = opj_aligned_32_malloc(h_mem_size);
#line 1506
        job___0->v.mem = (OPJ_INT32 *)__cil_tmp27;
        }
#line 1507
        if (! job___0->v.mem) {
          {
#line 1509
          opj_thread_pool_wait_completion(tp, 0);
#line 1510
          opj_free((void *)job___0);
#line 1511
          opj_aligned_free((void *)v.mem);
          }
#line 1512
          return (0);
        }
        {
#line 1514
        opj_thread_pool_submit_job(tp, & opj_dwt_decode_v_func, (void *)job___0);
#line 1484
        j ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 1516
      opj_thread_pool_wait_completion(tp, 0);
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1519
  opj_aligned_free((void *)h.mem);
  }
#line 1520
  return (1);
}
}
#line 1523 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_interleave_partial_h(OPJ_INT32 *dest , OPJ_INT32 cas , opj_sparse_array_int32_t *sa ,
                                         OPJ_UINT32 sa_line , OPJ_UINT32 sn , OPJ_UINT32 win_l_x0 ,
                                         OPJ_UINT32 win_l_x1 , OPJ_UINT32 win_h_x0 ,
                                         OPJ_UINT32 win_h_x1 ) 
{ 
  OPJ_BOOL ret ;

  {
  {
#line 1534
  ret = opj_sparse_array_int32_read(sa, win_l_x0, sa_line, win_l_x1, sa_line + 1U,
                                    (dest + cas) + 2U * win_l_x0, (OPJ_UINT32 )2,
                                    (OPJ_UINT32 )0, 1);
#line 1540
  ret = opj_sparse_array_int32_read(sa, sn + win_h_x0, sa_line, sn + win_h_x1, sa_line + 1U,
                                    ((dest + 1) - cas) + 2U * win_h_x0, (OPJ_UINT32 )2,
                                    (OPJ_UINT32 )0, 1);
  }
#line 1544
  return;
}
}
#line 1550 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_interleave_partial_v(OPJ_INT32 *dest , OPJ_INT32 cas , opj_sparse_array_int32_t *sa ,
                                         OPJ_UINT32 sa_col , OPJ_UINT32 nb_cols ,
                                         OPJ_UINT32 sn , OPJ_UINT32 win_l_y0 , OPJ_UINT32 win_l_y1 ,
                                         OPJ_UINT32 win_h_y0 , OPJ_UINT32 win_h_y1 ) 
{ 
  OPJ_BOOL ret ;

  {
  {
#line 1562
  ret = opj_sparse_array_int32_read(sa, sa_col, win_l_y0, sa_col + nb_cols, win_l_y1,
                                    (dest + cas * 4) + 8U * win_l_y0, (OPJ_UINT32 )1,
                                    (OPJ_UINT32 )8, 1);
#line 1568
  ret = opj_sparse_array_int32_read(sa, sa_col, sn + win_h_y0, sa_col + nb_cols, sn + win_h_y1,
                                    (dest + (1 - cas) * 4) + 8U * win_h_y0, (OPJ_UINT32 )1,
                                    (OPJ_UINT32 )8, 1);
  }
#line 1572
  return;
}
}
#line 1577 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_decode_partial_1(OPJ_INT32 *a , OPJ_INT32 dn , OPJ_INT32 sn ,
                                     OPJ_INT32 cas , OPJ_INT32 win_l_x0 , OPJ_INT32 win_l_x1 ,
                                     OPJ_INT32 win_h_x0 , OPJ_INT32 win_h_x1 ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 i_max ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;
  OPJ_INT32 tmp___2 ;
  OPJ_INT32 tmp___3 ;
  OPJ_INT32 tmp___4 ;
  OPJ_INT32 tmp___5 ;
  OPJ_INT32 tmp___6 ;
  OPJ_INT32 i_max___0 ;
  OPJ_INT32 tmp___7 ;
  OPJ_INT32 tmp___8 ;
  OPJ_INT32 tmp___9 ;
  OPJ_INT32 tmp___10 ;
  OPJ_INT32 tmp___11 ;
  OPJ_INT32 tmp___12 ;
  OPJ_INT32 tmp___13 ;
  OPJ_INT32 tmp___14 ;
  OPJ_INT32 tmp___15 ;
  OPJ_INT32 tmp___16 ;
  OPJ_INT32 tmp___17 ;
  OPJ_INT32 tmp___18 ;

  {
#line 1586
  if (! cas) {
#line 1587
    if (dn > 0) {
      _L: 
#line 1600
      i = win_l_x0;
#line 1601
      if (i < win_l_x1) {
#line 1605
        if (i < 0) {
#line 1605
          tmp___2 = *(a + 1);
        } else {
#line 1605
          if (i >= dn) {
#line 1605
            tmp___1 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 1605
            tmp___1 = *(a + (1 + i * 2));
          }
#line 1605
          tmp___2 = tmp___1;
        }
#line 1605
        if (i - 1 < 0) {
#line 1605
          tmp___0 = *(a + 1);
        } else {
#line 1605
          if (i - 1 >= dn) {
#line 1605
            tmp = *(a + (1 + (dn - 1) * 2));
          } else {
#line 1605
            tmp = *(a + (1 + (i - 1) * 2));
          }
#line 1605
          tmp___0 = tmp;
        }
#line 1605
        *(a + i * 2) -= ((tmp___0 + tmp___2) + 2) >> 2;
#line 1606
        i ++;
#line 1608
        i_max = win_l_x1;
#line 1609
        if (i_max > dn) {
#line 1610
          i_max = dn;
        }
        {
#line 1612
        while (1) {
          while_continue: /* CIL Label */ ;

#line 1612
          if (! (i < i_max)) {
#line 1612
            goto while_break;
          }
#line 1614
          *(a + i * 2) -= ((*(a + (1 + (i - 1) * 2)) + *(a + (1 + i * 2))) + 2) >> 2;
#line 1612
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break: ;
        {
#line 1616
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 1616
          if (! (i < win_l_x1)) {
#line 1616
            goto while_break___0;
          }
#line 1618
          if (i < 0) {
#line 1618
            tmp___6 = *(a + 1);
          } else {
#line 1618
            if (i >= dn) {
#line 1618
              tmp___5 = *(a + (1 + (dn - 1) * 2));
            } else {
#line 1618
              tmp___5 = *(a + (1 + i * 2));
            }
#line 1618
            tmp___6 = tmp___5;
          }
#line 1618
          if (i - 1 < 0) {
#line 1618
            tmp___4 = *(a + 1);
          } else {
#line 1618
            if (i - 1 >= dn) {
#line 1618
              tmp___3 = *(a + (1 + (dn - 1) * 2));
            } else {
#line 1618
              tmp___3 = *(a + (1 + (i - 1) * 2));
            }
#line 1618
            tmp___4 = tmp___3;
          }
#line 1618
          *(a + i * 2) -= ((tmp___4 + tmp___6) + 2) >> 2;
#line 1616
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___0: ;
      }
#line 1622
      i = win_h_x0;
#line 1623
      if (i < win_h_x1) {
#line 1624
        i_max___0 = win_h_x1;
#line 1625
        if (i_max___0 >= sn) {
#line 1626
          i_max___0 = sn - 1;
        }
        {
#line 1628
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1628
          if (! (i < i_max___0)) {
#line 1628
            goto while_break___1;
          }
#line 1630
          *(a + (1 + i * 2)) += (*(a + i * 2) + *(a + (i + 1) * 2)) >> 1;
#line 1628
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___1: ;
        {
#line 1632
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1632
          if (! (i < win_h_x1)) {
#line 1632
            goto while_break___2;
          }
#line 1634
          if (i + 1 < 0) {
#line 1634
            tmp___10 = *(a + 0);
          } else {
#line 1634
            if (i + 1 >= sn) {
#line 1634
              tmp___9 = *(a + (sn - 1) * 2);
            } else {
#line 1634
              tmp___9 = *(a + (i + 1) * 2);
            }
#line 1634
            tmp___10 = tmp___9;
          }
#line 1634
          if (i < 0) {
#line 1634
            tmp___8 = *(a + 0);
          } else {
#line 1634
            if (i >= sn) {
#line 1634
              tmp___7 = *(a + (sn - 1) * 2);
            } else {
#line 1634
              tmp___7 = *(a + i * 2);
            }
#line 1634
            tmp___8 = tmp___7;
          }
#line 1634
          *(a + (1 + i * 2)) += (tmp___8 + tmp___10) >> 1;
#line 1632
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: ;
      }
    } else
#line 1587
    if (sn > 1) {
#line 1587
      goto _L;
    }
  } else
#line 1639
  if (! sn) {
#line 1639
    if (dn == 1) {
#line 1640
      *(a + 0) /= 2;
    } else {
#line 1639
      goto _L___34;
    }
  } else {
    _L___34: 
#line 1642
    i = win_l_x0;
    {
#line 1642
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1642
      if (! (i < win_l_x1)) {
#line 1642
        goto while_break___3;
      }
#line 1643
      if (i + 1 < 0) {
#line 1643
        tmp___14 = *(a + 0);
      } else {
#line 1643
        if (i + 1 >= dn) {
#line 1643
          tmp___13 = *(a + (dn - 1) * 2);
        } else {
#line 1643
          tmp___13 = *(a + (i + 1) * 2);
        }
#line 1643
        tmp___14 = tmp___13;
      }
#line 1643
      if (i < 0) {
#line 1643
        tmp___12 = *(a + 0);
      } else {
#line 1643
        if (i >= dn) {
#line 1643
          tmp___11 = *(a + (dn - 1) * 2);
        } else {
#line 1643
          tmp___11 = *(a + i * 2);
        }
#line 1643
        tmp___12 = tmp___11;
      }
#line 1643
      *(a + (1 + i * 2)) -= ((tmp___12 + tmp___14) + 2) >> 2;
#line 1642
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 1645
    i = win_h_x0;
    {
#line 1645
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 1645
      if (! (i < win_h_x1)) {
#line 1645
        goto while_break___4;
      }
#line 1646
      if (i - 1 < 0) {
#line 1646
        tmp___18 = *(a + 1);
      } else {
#line 1646
        if (i - 1 >= sn) {
#line 1646
          tmp___17 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 1646
          tmp___17 = *(a + (1 + (i - 1) * 2));
        }
#line 1646
        tmp___18 = tmp___17;
      }
#line 1646
      if (i < 0) {
#line 1646
        tmp___16 = *(a + 1);
      } else {
#line 1646
        if (i >= sn) {
#line 1646
          tmp___15 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 1646
          tmp___15 = *(a + (1 + i * 2));
        }
#line 1646
        tmp___16 = tmp___15;
      }
#line 1646
      *(a + i * 2) += (tmp___16 + tmp___18) >> 1;
#line 1645
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: ;
  }
#line 1650
  return;
}
}
#line 1659 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_decode_partial_1_parallel(OPJ_INT32 *a , OPJ_UINT32 nb_cols ,
                                              OPJ_INT32 dn , OPJ_INT32 sn , OPJ_INT32 cas ,
                                              OPJ_INT32 win_l_x0 , OPJ_INT32 win_l_x1 ,
                                              OPJ_INT32 win_h_x0 , OPJ_INT32 win_h_x1 ) 
{ 
  OPJ_INT32 i ;
  OPJ_UINT32 off ;
  OPJ_INT32 i_max ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;
  OPJ_INT32 tmp___2 ;
  __m128i two ;
  __m128i __cil_tmp20 ;
  __m128i Dm1 ;
  __m128i __cil_tmp22 ;
  __m128i S ;
  __m128i __cil_tmp24 ;
  __m128i D ;
  __m128i __cil_tmp26 ;
  __m128i S1 ;
  __m128i __cil_tmp28 ;
  __m128i D1 ;
  __m128i __cil_tmp30 ;
  __m128i __cil_tmp31 ;
  __m128i __cil_tmp32 ;
  __m128i __cil_tmp33 ;
  __m128i __cil_tmp34 ;
  __m128i __cil_tmp35 ;
  __m128i __cil_tmp36 ;
  __m128i __cil_tmp37 ;
  __m128i __cil_tmp38 ;
  OPJ_INT32 tmp___3 ;
  OPJ_INT32 tmp___4 ;
  OPJ_INT32 tmp___5 ;
  OPJ_INT32 tmp___6 ;
  OPJ_INT32 i_max___0 ;
  __m128i S___0 ;
  __m128i __cil_tmp49 ;
  __m128i D___0 ;
  __m128i __cil_tmp51 ;
  __m128i S1___0 ;
  __m128i __cil_tmp53 ;
  __m128i D1___0 ;
  __m128i __cil_tmp55 ;
  __m128i S2 ;
  __m128i __cil_tmp57 ;
  __m128i __cil_tmp58 ;
  __m128i __cil_tmp59 ;
  __m128i __cil_tmp60 ;
  __m128i __cil_tmp61 ;
  __m128i __cil_tmp62 ;
  __m128i __cil_tmp63 ;
  OPJ_INT32 tmp___7 ;
  OPJ_INT32 tmp___8 ;
  OPJ_INT32 tmp___9 ;
  OPJ_INT32 tmp___10 ;
  OPJ_INT32 tmp___11 ;
  OPJ_INT32 tmp___12 ;
  OPJ_INT32 tmp___13 ;
  OPJ_INT32 tmp___14 ;
  OPJ_INT32 tmp___15 ;
  OPJ_INT32 tmp___16 ;
  OPJ_INT32 tmp___17 ;
  OPJ_INT32 tmp___18 ;

  {
#line 1673
  if (! cas) {
#line 1674
    if (dn > 0) {
      _L: 
#line 1687
      i = win_l_x0;
#line 1688
      if (i < win_l_x1) {
#line 1692
        off = (OPJ_UINT32 )0;
        {
#line 1692
        while (1) {
          while_continue: /* CIL Label */ ;

#line 1692
          if (! (off < 4U)) {
#line 1692
            goto while_break;
          }
#line 1693
          if (i < 0) {
#line 1693
            tmp___2 = *(a + (4U + off));
          } else {
#line 1693
            if (i >= dn) {
#line 1693
              tmp___1 = *(a + ((1U + (OPJ_UINT32 )(dn - 1) * 2U) * 4U + off));
            } else {
#line 1693
              tmp___1 = *(a + ((1U + (OPJ_UINT32 )i * 2U) * 4U + off));
            }
#line 1693
            tmp___2 = tmp___1;
          }
#line 1693
          if (i - 1 < 0) {
#line 1693
            tmp___0 = *(a + (4U + off));
          } else {
#line 1693
            if (i - 1 >= dn) {
#line 1693
              tmp = *(a + ((1U + (OPJ_UINT32 )(dn - 1) * 2U) * 4U + off));
            } else {
#line 1693
              tmp = *(a + ((1U + (OPJ_UINT32 )(i - 1) * 2U) * 4U + off));
            }
#line 1693
            tmp___0 = tmp;
          }
#line 1693
          *(a + (((OPJ_UINT32 )i * 2U) * 4U + off)) -= ((tmp___0 + tmp___2) + 2) >> 2;
#line 1692
          off ++;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break: 
#line 1695
        i ++;
#line 1697
        i_max = win_l_x1;
#line 1698
        if (i_max > dn) {
#line 1699
          i_max = dn;
        }
#line 1703
        if (i + 1 < i_max) {
          {
#line 1704
          __cil_tmp20 = _mm_set1_epi32(2);
#line 1704
          two = __cil_tmp20;
#line 1705
          __cil_tmp22 = _mm_load_si128((a + 4) + (i - 1) * 8);
#line 1705
          Dm1 = __cil_tmp22;
          }
          {
#line 1706
          while (1) {
            while_continue___0: /* CIL Label */ ;

#line 1706
            if (! (i + 1 < i_max)) {
#line 1706
              goto while_break___0;
            }
            {
#line 1708
            __cil_tmp24 = _mm_load_si128(a + i * 8);
#line 1708
            S = __cil_tmp24;
#line 1709
            __cil_tmp26 = _mm_load_si128((a + 4) + i * 8);
#line 1709
            D = __cil_tmp26;
#line 1710
            __cil_tmp28 = _mm_load_si128(a + (i + 1) * 8);
#line 1710
            S1 = __cil_tmp28;
#line 1711
            __cil_tmp30 = _mm_load_si128((a + 4) + (i + 1) * 8);
#line 1711
            D1 = __cil_tmp30;
#line 1712
            __cil_tmp31 = _mm_add_epi32(Dm1, D);
#line 1712
            __cil_tmp32 = _mm_add_epi32(__cil_tmp31, two);
#line 1712
            __cil_tmp33 = _mm_srai_epi32(__cil_tmp32, 2);
#line 1712
            __cil_tmp34 = _mm_sub_epi32(S, __cil_tmp33);
#line 1712
            S = __cil_tmp34;
#line 1714
            __cil_tmp35 = _mm_add_epi32(D, D1);
#line 1714
            __cil_tmp36 = _mm_add_epi32(__cil_tmp35, two);
#line 1714
            __cil_tmp37 = _mm_srai_epi32(__cil_tmp36, 2);
#line 1714
            __cil_tmp38 = _mm_sub_epi32(S1, __cil_tmp37);
#line 1714
            S1 = __cil_tmp38;
#line 1716
            _mm_store_si128(a + i * 8, S);
#line 1717
            _mm_store_si128(a + (i + 1) * 8, S1);
#line 1718
            Dm1 = D1;
#line 1706
            i += 2;
            }
          }
          while_break___16: /* CIL Label */ ;
          }
          while_break___0: ;
        }
        {
#line 1723
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1723
          if (! (i < i_max)) {
#line 1723
            goto while_break___1;
          }
#line 1725
          off = (OPJ_UINT32 )0;
          {
#line 1725
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 1725
            if (! (off < 4U)) {
#line 1725
              goto while_break___2;
            }
#line 1726
            *(a + (((OPJ_UINT32 )i * 2U) * 4U + off)) -= ((*(a + ((1U + (OPJ_UINT32 )(i - 1) * 2U) * 4U + off)) + *(a + ((1U + (OPJ_UINT32 )i * 2U) * 4U + off))) + 2) >> 2;
#line 1725
            off ++;
          }
          while_break___18: /* CIL Label */ ;
          }
          while_break___2: 
#line 1723
          i ++;
        }
        while_break___17: /* CIL Label */ ;
        }
        while_break___1: ;
        {
#line 1729
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1729
          if (! (i < win_l_x1)) {
#line 1729
            goto while_break___3;
          }
#line 1731
          off = (OPJ_UINT32 )0;
          {
#line 1731
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 1731
            if (! (off < 4U)) {
#line 1731
              goto while_break___4;
            }
#line 1732
            if (i < 0) {
#line 1732
              tmp___6 = *(a + (4U + off));
            } else {
#line 1732
              if (i >= dn) {
#line 1732
                tmp___5 = *(a + ((1U + (OPJ_UINT32 )(dn - 1) * 2U) * 4U + off));
              } else {
#line 1732
                tmp___5 = *(a + ((1U + (OPJ_UINT32 )i * 2U) * 4U + off));
              }
#line 1732
              tmp___6 = tmp___5;
            }
#line 1732
            if (i - 1 < 0) {
#line 1732
              tmp___4 = *(a + (4U + off));
            } else {
#line 1732
              if (i - 1 >= dn) {
#line 1732
                tmp___3 = *(a + ((1U + (OPJ_UINT32 )(dn - 1) * 2U) * 4U + off));
              } else {
#line 1732
                tmp___3 = *(a + ((1U + (OPJ_UINT32 )(i - 1) * 2U) * 4U + off));
              }
#line 1732
              tmp___4 = tmp___3;
            }
#line 1732
            *(a + (((OPJ_UINT32 )i * 2U) * 4U + off)) -= ((tmp___4 + tmp___6) + 2) >> 2;
#line 1731
            off ++;
          }
          while_break___20: /* CIL Label */ ;
          }
          while_break___4: 
#line 1729
          i ++;
        }
        while_break___19: /* CIL Label */ ;
        }
        while_break___3: ;
      }
#line 1737
      i = win_h_x0;
#line 1738
      if (i < win_h_x1) {
#line 1739
        i_max___0 = win_h_x1;
#line 1740
        if (i_max___0 >= sn) {
#line 1741
          i_max___0 = sn - 1;
        }
#line 1745
        if (i + 1 < i_max___0) {
          {
#line 1746
          __cil_tmp49 = _mm_load_si128(a + i * 8);
#line 1746
          S___0 = __cil_tmp49;
          }
          {
#line 1747
          while (1) {
            while_continue___5: /* CIL Label */ ;

#line 1747
            if (! (i + 1 < i_max___0)) {
#line 1747
              goto while_break___5;
            }
            {
#line 1749
            __cil_tmp51 = _mm_load_si128((a + 4) + i * 8);
#line 1749
            D___0 = __cil_tmp51;
#line 1750
            __cil_tmp53 = _mm_load_si128(a + (i + 1) * 8);
#line 1750
            S1___0 = __cil_tmp53;
#line 1751
            __cil_tmp55 = _mm_load_si128((a + 4) + (i + 1) * 8);
#line 1751
            D1___0 = __cil_tmp55;
#line 1752
            __cil_tmp57 = _mm_load_si128(a + (i + 2) * 8);
#line 1752
            S2 = __cil_tmp57;
#line 1753
            __cil_tmp58 = _mm_add_epi32(S___0, S1___0);
#line 1753
            __cil_tmp59 = _mm_srai_epi32(__cil_tmp58, 1);
#line 1753
            __cil_tmp60 = _mm_add_epi32(D___0, __cil_tmp59);
#line 1753
            D___0 = __cil_tmp60;
#line 1754
            __cil_tmp61 = _mm_add_epi32(S1___0, S2);
#line 1754
            __cil_tmp62 = _mm_srai_epi32(__cil_tmp61, 1);
#line 1754
            __cil_tmp63 = _mm_add_epi32(D1___0, __cil_tmp62);
#line 1754
            D1___0 = __cil_tmp63;
#line 1755
            _mm_store_si128((a + 4) + i * 8, D___0);
#line 1756
            _mm_store_si128((a + 4) + (i + 1) * 8, D1___0);
#line 1757
            S___0 = S2;
#line 1747
            i += 2;
            }
          }
          while_break___21: /* CIL Label */ ;
          }
          while_break___5: ;
        }
        {
#line 1762
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 1762
          if (! (i < i_max___0)) {
#line 1762
            goto while_break___6;
          }
#line 1764
          off = (OPJ_UINT32 )0;
          {
#line 1764
          while (1) {
            while_continue___7: /* CIL Label */ ;

#line 1764
            if (! (off < 4U)) {
#line 1764
              goto while_break___7;
            }
#line 1765
            *(a + ((1U + (OPJ_UINT32 )i * 2U) * 4U + off)) += (*(a + (((OPJ_UINT32 )i * 2U) * 4U + off)) + *(a + (((OPJ_UINT32 )(i + 1) * 2U) * 4U + off))) >> 1;
#line 1764
            off ++;
          }
          while_break___23: /* CIL Label */ ;
          }
          while_break___7: 
#line 1762
          i ++;
        }
        while_break___22: /* CIL Label */ ;
        }
        while_break___6: ;
        {
#line 1768
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 1768
          if (! (i < win_h_x1)) {
#line 1768
            goto while_break___8;
          }
#line 1770
          off = (OPJ_UINT32 )0;
          {
#line 1770
          while (1) {
            while_continue___9: /* CIL Label */ ;

#line 1770
            if (! (off < 4U)) {
#line 1770
              goto while_break___9;
            }
#line 1771
            if (i + 1 < 0) {
#line 1771
              tmp___10 = *(a + off);
            } else {
#line 1771
              if (i + 1 >= sn) {
#line 1771
                tmp___9 = *(a + (((OPJ_UINT32 )(sn - 1) * 2U) * 4U + off));
              } else {
#line 1771
                tmp___9 = *(a + (((OPJ_UINT32 )(i + 1) * 2U) * 4U + off));
              }
#line 1771
              tmp___10 = tmp___9;
            }
#line 1771
            if (i < 0) {
#line 1771
              tmp___8 = *(a + off);
            } else {
#line 1771
              if (i >= sn) {
#line 1771
                tmp___7 = *(a + (((OPJ_UINT32 )(sn - 1) * 2U) * 4U + off));
              } else {
#line 1771
                tmp___7 = *(a + (((OPJ_UINT32 )i * 2U) * 4U + off));
              }
#line 1771
              tmp___8 = tmp___7;
            }
#line 1771
            *(a + ((1U + (OPJ_UINT32 )i * 2U) * 4U + off)) += (tmp___8 + tmp___10) >> 1;
#line 1770
            off ++;
          }
          while_break___25: /* CIL Label */ ;
          }
          while_break___9: 
#line 1768
          i ++;
        }
        while_break___24: /* CIL Label */ ;
        }
        while_break___8: ;
      }
    } else
#line 1674
    if (sn > 1) {
#line 1674
      goto _L;
    }
  } else
#line 1777
  if (! sn) {
#line 1777
    if (dn == 1) {
#line 1778
      off = (OPJ_UINT32 )0;
      {
#line 1778
      while (1) {
        while_continue___10: /* CIL Label */ ;

#line 1778
        if (! (off < 4U)) {
#line 1778
          goto while_break___10;
        }
#line 1779
        *(a + off) /= 2;
#line 1778
        off ++;
      }
      while_break___26: /* CIL Label */ ;
      }
      while_break___10: ;
    } else {
#line 1777
      goto _L___35;
    }
  } else {
    _L___35: 
#line 1782
    i = win_l_x0;
    {
#line 1782
    while (1) {
      while_continue___11: /* CIL Label */ ;

#line 1782
      if (! (i < win_l_x1)) {
#line 1782
        goto while_break___11;
      }
#line 1783
      off = (OPJ_UINT32 )0;
      {
#line 1783
      while (1) {
        while_continue___12: /* CIL Label */ ;

#line 1783
        if (! (off < 4U)) {
#line 1783
          goto while_break___12;
        }
#line 1784
        if (i + 1 < 0) {
#line 1784
          tmp___14 = *(a + off);
        } else {
#line 1784
          if (i + 1 >= dn) {
#line 1784
            tmp___13 = *(a + (((OPJ_UINT32 )(dn - 1) * 2U) * 4U + off));
          } else {
#line 1784
            tmp___13 = *(a + (((OPJ_UINT32 )(i + 1) * 2U) * 4U + off));
          }
#line 1784
          tmp___14 = tmp___13;
        }
#line 1784
        if (i < 0) {
#line 1784
          tmp___12 = *(a + off);
        } else {
#line 1784
          if (i >= dn) {
#line 1784
            tmp___11 = *(a + (((OPJ_UINT32 )(dn - 1) * 2U) * 4U + off));
          } else {
#line 1784
            tmp___11 = *(a + (((OPJ_UINT32 )i * 2U) * 4U + off));
          }
#line 1784
          tmp___12 = tmp___11;
        }
#line 1784
        *(a + ((1U + (OPJ_UINT32 )i * 2U) * 4U + off)) -= ((tmp___12 + tmp___14) + 2) >> 2;
#line 1783
        off ++;
      }
      while_break___28: /* CIL Label */ ;
      }
      while_break___12: 
#line 1782
      i ++;
    }
    while_break___27: /* CIL Label */ ;
    }
    while_break___11: 
#line 1787
    i = win_h_x0;
    {
#line 1787
    while (1) {
      while_continue___13: /* CIL Label */ ;

#line 1787
      if (! (i < win_h_x1)) {
#line 1787
        goto while_break___13;
      }
#line 1788
      off = (OPJ_UINT32 )0;
      {
#line 1788
      while (1) {
        while_continue___14: /* CIL Label */ ;

#line 1788
        if (! (off < 4U)) {
#line 1788
          goto while_break___14;
        }
#line 1789
        if (i - 1 < 0) {
#line 1789
          tmp___18 = *(a + (4U + off));
        } else {
#line 1789
          if (i - 1 >= sn) {
#line 1789
            tmp___17 = *(a + ((1U + (OPJ_UINT32 )(sn - 1) * 2U) * 4U + off));
          } else {
#line 1789
            tmp___17 = *(a + ((1U + (OPJ_UINT32 )(i - 1) * 2U) * 4U + off));
          }
#line 1789
          tmp___18 = tmp___17;
        }
#line 1789
        if (i < 0) {
#line 1789
          tmp___16 = *(a + (4U + off));
        } else {
#line 1789
          if (i >= sn) {
#line 1789
            tmp___15 = *(a + ((1U + (OPJ_UINT32 )(sn - 1) * 2U) * 4U + off));
          } else {
#line 1789
            tmp___15 = *(a + ((1U + (OPJ_UINT32 )i * 2U) * 4U + off));
          }
#line 1789
          tmp___16 = tmp___15;
        }
#line 1789
        *(a + (((OPJ_UINT32 )i * 2U) * 4U + off)) += (tmp___16 + tmp___18) >> 1;
#line 1788
        off ++;
      }
      while_break___30: /* CIL Label */ ;
      }
      while_break___14: 
#line 1787
      i ++;
    }
    while_break___29: /* CIL Label */ ;
    }
    while_break___13: ;
  }
#line 1792
  return;
}
}
#line 1796 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_get_band_coordinates(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 resno ,
                                         OPJ_UINT32 bandno , OPJ_UINT32 tcx0 , OPJ_UINT32 tcy0 ,
                                         OPJ_UINT32 tcx1 , OPJ_UINT32 tcy1 , OPJ_UINT32 *tbx0 ,
                                         OPJ_UINT32 *tby0 , OPJ_UINT32 *tbx1 , OPJ_UINT32 *tby1 ) 
{ 
  OPJ_UINT32 nb ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 x0b ;
  OPJ_UINT32 y0b ;
  OPJ_UINT32 __cil_tmp16 ;
  unsigned int tmp___0 ;
  OPJ_UINT32 tmp___1 ;
  OPJ_UINT32 __cil_tmp19 ;
  unsigned int tmp___2 ;
  OPJ_UINT32 tmp___3 ;
  OPJ_UINT32 __cil_tmp22 ;
  unsigned int tmp___4 ;
  OPJ_UINT32 tmp___5 ;
  OPJ_UINT32 __cil_tmp25 ;
  unsigned int tmp___6 ;
  OPJ_UINT32 tmp___7 ;

  {
#line 1809
  if (resno == 0U) {
#line 1809
    tmp = tilec->numresolutions - 1U;
  } else {
#line 1809
    tmp = tilec->numresolutions - resno;
  }
#line 1809
  nb = tmp;
#line 1814
  x0b = bandno & 1U;
#line 1815
  y0b = bandno >> 1;
#line 1816
  if (tbx0) {
#line 1817
    if (nb == 0U) {
#line 1817
      tmp___1 = tcx0;
    } else {
#line 1817
      if (tcx0 <= (1U << (nb - 1U)) * x0b) {
#line 1817
        tmp___0 = 0U;
      } else {
        {
#line 1817
        __cil_tmp16 = opj_uint_ceildivpow2(tcx0 - (1U << (nb - 1U)) * x0b, nb);
#line 1817
        tmp___0 = __cil_tmp16;
        }
      }
#line 1817
      tmp___1 = tmp___0;
    }
#line 1817
    *tbx0 = tmp___1;
  }
#line 1821
  if (tby0) {
#line 1822
    if (nb == 0U) {
#line 1822
      tmp___3 = tcy0;
    } else {
#line 1822
      if (tcy0 <= (1U << (nb - 1U)) * y0b) {
#line 1822
        tmp___2 = 0U;
      } else {
        {
#line 1822
        __cil_tmp19 = opj_uint_ceildivpow2(tcy0 - (1U << (nb - 1U)) * y0b, nb);
#line 1822
        tmp___2 = __cil_tmp19;
        }
      }
#line 1822
      tmp___3 = tmp___2;
    }
#line 1822
    *tby0 = tmp___3;
  }
#line 1826
  if (tbx1) {
#line 1827
    if (nb == 0U) {
#line 1827
      tmp___5 = tcx1;
    } else {
#line 1827
      if (tcx1 <= (1U << (nb - 1U)) * x0b) {
#line 1827
        tmp___4 = 0U;
      } else {
        {
#line 1827
        __cil_tmp22 = opj_uint_ceildivpow2(tcx1 - (1U << (nb - 1U)) * x0b, nb);
#line 1827
        tmp___4 = __cil_tmp22;
        }
      }
#line 1827
      tmp___5 = tmp___4;
    }
#line 1827
    *tbx1 = tmp___5;
  }
#line 1831
  if (tby1) {
#line 1832
    if (nb == 0U) {
#line 1832
      tmp___7 = tcy1;
    } else {
#line 1832
      if (tcy1 <= (1U << (nb - 1U)) * y0b) {
#line 1832
        tmp___6 = 0U;
      } else {
        {
#line 1832
        __cil_tmp25 = opj_uint_ceildivpow2(tcy1 - (1U << (nb - 1U)) * y0b, nb);
#line 1832
        tmp___6 = __cil_tmp25;
        }
      }
#line 1832
      tmp___7 = tmp___6;
    }
#line 1832
    *tby1 = tmp___7;
  }
#line 1834
  return;
}
}
#line 1838 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_dwt_segment_grow(OPJ_UINT32 filter_width , OPJ_UINT32 max_size , OPJ_UINT32 *start ,
                                 OPJ_UINT32 *end ) 
{ 


  {
  {
#line 1843
  *start = opj_uint_subs(*start, filter_width);
#line 1844
  *end = opj_uint_adds(*end, filter_width);
#line 1845
  *end = opj_uint_min(*end, max_size);
  }
#line 1847
  return;
}
}
#line 1849 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static opj_sparse_array_int32_t *opj_dwt_init_sparse_array(opj_tcd_tilecomp_t *tilec ,
                                                           OPJ_UINT32 numres ) 
{ 
  opj_tcd_resolution_t *tr_max ;
  OPJ_UINT32 w ;
  OPJ_UINT32 h ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_sparse_array_int32_t *sa ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 __cil_tmp12 ;
  opj_sparse_array_int32_t *__cil_tmp13 ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *precinct ;
  opj_tcd_cblk_dec_t *cblk ;
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT32 cblk_w ;
  OPJ_UINT32 cblk_h ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  OPJ_BOOL __cil_tmp24 ;

  {
  {
#line 1853
  tr_max = tilec->resolutions + (numres - 1U);
#line 1854
  w = (OPJ_UINT32 )(tr_max->x1 - tr_max->x0);
#line 1855
  h = (OPJ_UINT32 )(tr_max->y1 - tr_max->y0);
#line 1857
  __cil_tmp11 = opj_uint_min(w, (OPJ_UINT32 )64);
#line 1857
  __cil_tmp12 = opj_uint_min(h, (OPJ_UINT32 )64);
#line 1857
  __cil_tmp13 = opj_sparse_array_int32_create(w, h, __cil_tmp11, __cil_tmp12);
#line 1857
  sa = __cil_tmp13;
  }
#line 1859
  if ((unsigned long )sa == (unsigned long )((void *)0)) {
#line 1860
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
#line 1863
  resno = (OPJ_UINT32 )0;
  {
#line 1863
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1863
    if (! (resno < numres)) {
#line 1863
      goto while_break;
    }
#line 1864
    res = tilec->resolutions + resno;
#line 1866
    bandno = (OPJ_UINT32 )0;
    {
#line 1866
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1866
      if (! (bandno < res->numbands)) {
#line 1866
        goto while_break___0;
      }
#line 1867
      band = & res->bands[bandno];
#line 1869
      precno = (OPJ_UINT32 )0;
      {
#line 1869
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1869
        if (! (precno < res->pw * res->ph)) {
#line 1869
          goto while_break___1;
        }
#line 1870
        precinct = band->precincts + precno;
#line 1871
        cblkno = (OPJ_UINT32 )0;
        {
#line 1871
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1871
          if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1871
            goto while_break___2;
          }
#line 1872
          cblk = precinct->cblks.dec + cblkno;
#line 1873
          if ((unsigned long )cblk->decoded_data != (unsigned long )((void *)0)) {
#line 1874
            x = (OPJ_UINT32 )(cblk->x0 - band->x0);
#line 1875
            y = (OPJ_UINT32 )(cblk->y0 - band->y0);
#line 1876
            cblk_w = (OPJ_UINT32 )(cblk->x1 - cblk->x0);
#line 1877
            cblk_h = (OPJ_UINT32 )(cblk->y1 - cblk->y0);
#line 1879
            if (band->bandno & 1U) {
#line 1880
              pres = tilec->resolutions + (resno - 1U);
#line 1881
              x += (OPJ_UINT32 )(pres->x1 - pres->x0);
            }
#line 1883
            if (band->bandno & 2U) {
#line 1884
              pres___0 = tilec->resolutions + (resno - 1U);
#line 1885
              y += (OPJ_UINT32 )(pres___0->y1 - pres___0->y0);
            }
            {
#line 1888
            __cil_tmp24 = opj_sparse_array_int32_write(sa, x, y, x + cblk_w, y + cblk_h,
                                                       cblk->decoded_data, (OPJ_UINT32 )1,
                                                       cblk_w, 1);
            }
#line 1888
            if (! __cil_tmp24) {
              {
#line 1892
              opj_sparse_array_int32_free(sa);
              }
#line 1893
              return ((opj_sparse_array_int32_t *)((void *)0));
            }
          }
#line 1871
          cblkno ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 1869
        precno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 1866
      bandno ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 1863
    resno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 1901
  return (sa);
}
}
#line 1903 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static opj_sparse_array_int32_t *opj_dwt_init_sparse_array1(opj_tcd_tilecomp_t *tilec ,
                                                            OPJ_UINT32 numres ) 
{ 
  opj_tcd_resolution_t *tr_max ;
  OPJ_UINT32 w ;
  OPJ_UINT32 h ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_sparse_array_int32_t *sa ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 __cil_tmp12 ;
  opj_sparse_array_int32_t *__cil_tmp13 ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *precinct ;
  opj_tcd_cblk_dec_t *cblk ;
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT32 cblk_w ;
  OPJ_UINT32 cblk_h ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  OPJ_BOOL __cil_tmp24 ;

  {
  {
#line 1907
  tr_max = tilec->resolutions + (numres - 1U);
#line 1908
  w = (OPJ_UINT32 )(tr_max->x1 - tr_max->x0);
#line 1909
  h = (OPJ_UINT32 )(tr_max->y1 - tr_max->y0);
#line 1911
  __cil_tmp11 = opj_uint_min(w, (OPJ_UINT32 )64);
#line 1911
  __cil_tmp12 = opj_uint_min(h, (OPJ_UINT32 )64);
#line 1911
  __cil_tmp13 = opj_sparse_array_int32_create(w, h, __cil_tmp11, __cil_tmp12);
#line 1911
  sa = __cil_tmp13;
  }
#line 1913
  if ((unsigned long )sa == (unsigned long )((void *)0)) {
#line 1914
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
#line 1917
  resno = (OPJ_UINT32 )0;
  {
#line 1917
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1917
    if (! (resno < numres)) {
#line 1917
      goto while_break;
    }
#line 1918
    res = tilec->resolutions + resno;
#line 1920
    bandno = (OPJ_UINT32 )0;
    {
#line 1920
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1920
      if (! (bandno < res->numbands)) {
#line 1920
        goto while_break___0;
      }
#line 1921
      band = & res->bands[bandno];
#line 1923
      precno = (OPJ_UINT32 )0;
      {
#line 1923
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1923
        if (! (precno < res->pw * res->ph)) {
#line 1923
          goto while_break___1;
        }
#line 1924
        precinct = band->precincts + precno;
#line 1925
        cblkno = (OPJ_UINT32 )0;
        {
#line 1925
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1925
          if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1925
            goto while_break___2;
          }
#line 1926
          cblk = precinct->cblks.dec + cblkno;
#line 1927
          if ((unsigned long )cblk->decoded_data != (unsigned long )((void *)0)) {
#line 1928
            x = (OPJ_UINT32 )(cblk->x0 - band->x0);
#line 1929
            y = (OPJ_UINT32 )(cblk->y0 - band->y0);
#line 1930
            cblk_w = (OPJ_UINT32 )(cblk->x1 - cblk->x0);
#line 1931
            cblk_h = (OPJ_UINT32 )(cblk->y1 - cblk->y0);
#line 1933
            if (band->bandno & 1U) {
#line 1934
              pres = tilec->resolutions + (resno - 1U);
#line 1935
              x += (OPJ_UINT32 )(pres->x1 - pres->x0);
            }
#line 1937
            if (band->bandno & 2U) {
#line 1938
              pres___0 = tilec->resolutions + (resno - 1U);
#line 1939
              y += (OPJ_UINT32 )(pres___0->y1 - pres___0->y0);
            }
            {
#line 1942
            __cil_tmp24 = opj_sparse_array_int32_write(sa, x, y, x + cblk_w, y + cblk_h,
                                                       cblk->decoded_data, (OPJ_UINT32 )1,
                                                       cblk_w, 1);
            }
#line 1942
            if (! __cil_tmp24) {
              {
#line 1946
              opj_sparse_array_int32_free(sa);
              }
#line 1947
              return ((opj_sparse_array_int32_t *)((void *)0));
            }
          }
#line 1925
          cblkno ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 1923
        precno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 1920
      bandno ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 1917
    resno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 1955
  return (sa);
}
}
#line 1959 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_BOOL opj_dwt_decode_partial_tile(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) 
{ 
  opj_sparse_array_int32_t *sa ;
  opj_dwt_t h ;
  opj_dwt_t v ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 filter_width ;
  opj_tcd_resolution_t *tr ;
  opj_tcd_resolution_t *tr_max ;
  OPJ_UINT32 rw ;
  OPJ_UINT32 rh ;
  OPJ_SIZE_T h_mem_size ;
  OPJ_UINT32 win_tcx0 ;
  OPJ_UINT32 win_tcy0 ;
  OPJ_UINT32 win_tcx1 ;
  OPJ_UINT32 win_tcy1 ;
  OPJ_BOOL ret ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp21 ;
  void *__cil_tmp22 ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 win_ll_x0 ;
  OPJ_UINT32 win_ll_y0 ;
  OPJ_UINT32 win_ll_x1 ;
  OPJ_UINT32 win_ll_y1 ;
  OPJ_UINT32 win_hl_x0 ;
  OPJ_UINT32 win_hl_x1 ;
  OPJ_UINT32 win_lh_y0 ;
  OPJ_UINT32 win_lh_y1 ;
  OPJ_UINT32 win_tr_x0 ;
  OPJ_UINT32 win_tr_x1 ;
  OPJ_UINT32 win_tr_y0 ;
  OPJ_UINT32 win_tr_y1 ;
  OPJ_UINT32 tr_ll_x0 ;
  OPJ_UINT32 tr_ll_y0 ;
  OPJ_UINT32 tr_hl_x0 ;
  OPJ_UINT32 tr_lh_y0 ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 __cil_tmp51 ;
  OPJ_UINT32 __cil_tmp53 ;
  OPJ_UINT32 __cil_tmp54 ;
  OPJ_UINT32 __cil_tmp56 ;
  OPJ_UINT32 __cil_tmp57 ;
  OPJ_UINT32 __cil_tmp59 ;
  OPJ_UINT32 __cil_tmp60 ;
  OPJ_BOOL __cil_tmp61 ;
  OPJ_UINT32 nb_cols ;
  OPJ_UINT32 __cil_tmp63 ;
  OPJ_BOOL __cil_tmp64 ;
  OPJ_BOOL ret___0 ;
  OPJ_BOOL __cil_tmp67 ;

  {
#line 1969
  filter_width = 2U;
#line 1971
  tr = tilec->resolutions;
#line 1972
  tr_max = tilec->resolutions + (numres - 1U);
#line 1974
  rw = (OPJ_UINT32 )(tr->x1 - tr->x0);
#line 1976
  rh = (OPJ_UINT32 )(tr->y1 - tr->y0);
#line 1983
  win_tcx0 = tilec->win_x0;
#line 1984
  win_tcy0 = tilec->win_y0;
#line 1985
  win_tcx1 = tilec->win_x1;
#line 1986
  win_tcy1 = tilec->win_y1;
#line 1988
  if (tr_max->x0 == tr_max->x1) {
#line 1989
    return (1);
  }
  {
#line 1992
  sa = opj_dwt_init_sparse_array(tilec, numres);
  }
#line 1993
  if ((unsigned long )sa == (unsigned long )((void *)0)) {
#line 1994
    return (0);
  }
#line 1997
  if (numres == 1U) {
    {
#line 1998
    __cil_tmp19 = opj_sparse_array_int32_read(sa, tr_max->win_x0 - (OPJ_UINT32 )tr_max->x0,
                                              tr_max->win_y0 - (OPJ_UINT32 )tr_max->y0,
                                              tr_max->win_x1 - (OPJ_UINT32 )tr_max->x0,
                                              tr_max->win_y1 - (OPJ_UINT32 )tr_max->y0,
                                              tilec->data_win, (OPJ_UINT32 )1, tr_max->win_x1 - tr_max->win_x0,
                                              1);
#line 1998
    ret = __cil_tmp19;
#line 2008
    opj_sparse_array_int32_free(sa);
    }
#line 2009
    return (1);
  }
  {
#line 2011
  __cil_tmp21 = opj_dwt_max_resolution(tr, numres);
#line 2011
  h_mem_size = (OPJ_SIZE_T )__cil_tmp21;
  }
#line 2014
  if (h_mem_size > 0xffffffffffffffffUL / (4UL * sizeof(OPJ_INT32 ))) {
    {
#line 2016
    opj_sparse_array_int32_free(sa);
    }
#line 2017
    return (0);
  }
  {
#line 2020
  h_mem_size *= 4UL * sizeof(OPJ_INT32 );
#line 2021
  __cil_tmp22 = opj_aligned_32_malloc(h_mem_size);
#line 2021
  h.mem = (OPJ_INT32 *)__cil_tmp22;
  }
#line 2022
  if (! h.mem) {
    {
#line 2024
    opj_sparse_array_int32_free(sa);
    }
#line 2025
    return (0);
  }
#line 2028
  v.mem = h.mem;
#line 2030
  resno = (OPJ_UINT32 )1;
  {
#line 2030
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2030
    if (! (resno < numres)) {
#line 2030
      goto while_break;
    }
    {
#line 2041
    tr ++;
#line 2043
    h.sn = (OPJ_INT32 )rw;
#line 2044
    v.sn = (OPJ_INT32 )rh;
#line 2046
    rw = (OPJ_UINT32 )(tr->x1 - tr->x0);
#line 2047
    rh = (OPJ_UINT32 )(tr->y1 - tr->y0);
#line 2049
    h.dn = (OPJ_INT32 )(rw - (OPJ_UINT32 )h.sn);
#line 2050
    h.cas = tr->x0 % 2;
#line 2052
    v.dn = (OPJ_INT32 )(rh - (OPJ_UINT32 )v.sn);
#line 2053
    v.cas = tr->y0 % 2;
#line 2057
    opj_dwt_get_band_coordinates(tilec, resno, (OPJ_UINT32 )0, win_tcx0, win_tcy0,
                                 win_tcx1, win_tcy1, & win_ll_x0, & win_ll_y0, & win_ll_x1,
                                 & win_ll_y1);
#line 2063
    opj_dwt_get_band_coordinates(tilec, resno, (OPJ_UINT32 )1, win_tcx0, win_tcy0,
                                 win_tcx1, win_tcy1, & win_hl_x0, (OPJ_UINT32 *)((void *)0),
                                 & win_hl_x1, (OPJ_UINT32 *)((void *)0));
#line 2068
    opj_dwt_get_band_coordinates(tilec, resno, (OPJ_UINT32 )2, win_tcx0, win_tcy0,
                                 win_tcx1, win_tcy1, (OPJ_UINT32 *)((void *)0), & win_lh_y0,
                                 (OPJ_UINT32 *)((void *)0), & win_lh_y1);
#line 2073
    tr_ll_x0 = (OPJ_UINT32 )tr->bands[1].x0;
#line 2074
    tr_ll_y0 = (OPJ_UINT32 )tr->bands[0].y0;
#line 2075
    tr_hl_x0 = (OPJ_UINT32 )tr->bands[0].x0;
#line 2076
    tr_lh_y0 = (OPJ_UINT32 )tr->bands[1].y0;
#line 2081
    win_ll_x0 = opj_uint_subs(win_ll_x0, tr_ll_x0);
#line 2082
    win_ll_y0 = opj_uint_subs(win_ll_y0, tr_ll_y0);
#line 2083
    win_ll_x1 = opj_uint_subs(win_ll_x1, tr_ll_x0);
#line 2084
    win_ll_y1 = opj_uint_subs(win_ll_y1, tr_ll_y0);
#line 2085
    win_hl_x0 = opj_uint_subs(win_hl_x0, tr_hl_x0);
#line 2086
    win_hl_x1 = opj_uint_subs(win_hl_x1, tr_hl_x0);
#line 2087
    win_lh_y0 = opj_uint_subs(win_lh_y0, tr_lh_y0);
#line 2088
    win_lh_y1 = opj_uint_subs(win_lh_y1, tr_lh_y0);
#line 2090
    opj_dwt_segment_grow(filter_width, (OPJ_UINT32 )h.sn, & win_ll_x0, & win_ll_x1);
#line 2091
    opj_dwt_segment_grow(filter_width, (OPJ_UINT32 )h.dn, & win_hl_x0, & win_hl_x1);
#line 2093
    opj_dwt_segment_grow(filter_width, (OPJ_UINT32 )v.sn, & win_ll_y0, & win_ll_y1);
#line 2094
    opj_dwt_segment_grow(filter_width, (OPJ_UINT32 )v.dn, & win_lh_y0, & win_lh_y1);
    }
#line 2097
    if (h.cas == 0) {
      {
#line 2098
      win_tr_x0 = opj_uint_min(2U * win_ll_x0, 2U * win_hl_x0 + 1U);
#line 2099
      __cil_tmp50 = opj_uint_max(2U * win_ll_x1, 2U * win_hl_x1 + 1U);
#line 2099
      __cil_tmp51 = opj_uint_min(__cil_tmp50, rw);
#line 2099
      win_tr_x1 = __cil_tmp51;
      }
    } else {
      {
#line 2101
      win_tr_x0 = opj_uint_min(2U * win_hl_x0, 2U * win_ll_x0 + 1U);
#line 2102
      __cil_tmp53 = opj_uint_max(2U * win_hl_x1, 2U * win_ll_x1 + 1U);
#line 2102
      __cil_tmp54 = opj_uint_min(__cil_tmp53, rw);
#line 2102
      win_tr_x1 = __cil_tmp54;
      }
    }
#line 2105
    if (v.cas == 0) {
      {
#line 2106
      win_tr_y0 = opj_uint_min(2U * win_ll_y0, 2U * win_lh_y0 + 1U);
#line 2107
      __cil_tmp56 = opj_uint_max(2U * win_ll_y1, 2U * win_lh_y1 + 1U);
#line 2107
      __cil_tmp57 = opj_uint_min(__cil_tmp56, rh);
#line 2107
      win_tr_y1 = __cil_tmp57;
      }
    } else {
      {
#line 2109
      win_tr_y0 = opj_uint_min(2U * win_lh_y0, 2U * win_ll_y0 + 1U);
#line 2110
      __cil_tmp59 = opj_uint_max(2U * win_lh_y1, 2U * win_ll_y1 + 1U);
#line 2110
      __cil_tmp60 = opj_uint_min(__cil_tmp59, rh);
#line 2110
      win_tr_y1 = __cil_tmp60;
      }
    }
#line 2113
    j = (OPJ_UINT32 )0;
    {
#line 2113
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2113
      if (! (j < rh)) {
#line 2113
        goto while_break___0;
      }
#line 2114
      if (j >= win_ll_y0) {
#line 2114
        if (j < win_ll_y1) {
          _L: 
#line 2122
          if (win_tr_x1 >= 1U) {
#line 2122
            if (win_tr_x1 < rw) {
#line 2123
              *(h.mem + (win_tr_x1 - 1U)) = 0;
            }
          }
#line 2125
          if (win_tr_x1 < rw) {
#line 2126
            *(h.mem + win_tr_x1) = 0;
          }
          {
#line 2129
          opj_dwt_interleave_partial_h(h.mem, h.cas, sa, j, (OPJ_UINT32 )h.sn, win_ll_x0,
                                       win_ll_x1, win_hl_x0, win_hl_x1);
#line 2138
          opj_dwt_decode_partial_1(h.mem, h.dn, h.sn, h.cas, (OPJ_INT32 )win_ll_x0,
                                   (OPJ_INT32 )win_ll_x1, (OPJ_INT32 )win_hl_x0, (OPJ_INT32 )win_hl_x1);
#line 2143
          __cil_tmp61 = opj_sparse_array_int32_write(sa, win_tr_x0, j, win_tr_x1,
                                                     j + 1U, h.mem + win_tr_x0, (OPJ_UINT32 )1,
                                                     (OPJ_UINT32 )0, 1);
          }
#line 2143
          if (! __cil_tmp61) {
            {
#line 2149
            opj_sparse_array_int32_free(sa);
#line 2150
            opj_aligned_free((void *)h.mem);
            }
#line 2151
            return (0);
          }
        } else {
#line 2114
          goto _L___36;
        }
      } else
      _L___36: 
#line 2114
      if (j >= win_lh_y0 + (OPJ_UINT32 )v.sn) {
#line 2114
        if (j < win_lh_y1 + (OPJ_UINT32 )v.sn) {
#line 2114
          goto _L;
        }
      }
#line 2113
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 2156
    i = win_tr_x0;
    {
#line 2156
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 2156
      if (! (i < win_tr_x1)) {
#line 2156
        goto while_break___1;
      }
      {
#line 2157
      __cil_tmp63 = opj_uint_min(4U, win_tr_x1 - i);
#line 2157
      nb_cols = __cil_tmp63;
#line 2158
      opj_dwt_interleave_partial_v(v.mem, v.cas, sa, i, nb_cols, (OPJ_UINT32 )v.sn,
                                   win_ll_y0, win_ll_y1, win_lh_y0, win_lh_y1);
#line 2168
      opj_dwt_decode_partial_1_parallel(v.mem, nb_cols, v.dn, v.sn, v.cas, (OPJ_INT32 )win_ll_y0,
                                        (OPJ_INT32 )win_ll_y1, (OPJ_INT32 )win_lh_y0,
                                        (OPJ_INT32 )win_lh_y1);
#line 2173
      __cil_tmp64 = opj_sparse_array_int32_write(sa, i, win_tr_y0, i + nb_cols, win_tr_y1,
                                                 v.mem + 4U * win_tr_y0, (OPJ_UINT32 )1,
                                                 (OPJ_UINT32 )4, 1);
      }
#line 2173
      if (! __cil_tmp64) {
        {
#line 2179
        opj_sparse_array_int32_free(sa);
#line 2180
        opj_aligned_free((void *)h.mem);
        }
#line 2181
        return (0);
      }
#line 2184
      i += nb_cols;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 2030
    resno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2187
  opj_aligned_free((void *)h.mem);
#line 2190
  __cil_tmp67 = opj_sparse_array_int32_read(sa, tr_max->win_x0 - (OPJ_UINT32 )tr_max->x0,
                                            tr_max->win_y0 - (OPJ_UINT32 )tr_max->y0,
                                            tr_max->win_x1 - (OPJ_UINT32 )tr_max->x0,
                                            tr_max->win_y1 - (OPJ_UINT32 )tr_max->y0,
                                            tilec->data_win, (OPJ_UINT32 )1, tr_max->win_x1 - tr_max->win_x0,
                                            1);
#line 2190
  ret___0 = __cil_tmp67;
#line 2201
  opj_sparse_array_int32_free(sa);
  }
#line 2202
  return (1);
}
}
#line 2205 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_v4dwt_interleave_h(opj_v4dwt_t *dwt , OPJ_FLOAT32 *a , OPJ_UINT32 width ,
                                   OPJ_UINT32 remaining_height ) 
{ 
  OPJ_FLOAT32 *bi ;
  OPJ_UINT32 i ;
  OPJ_UINT32 k ;
  OPJ_UINT32 x0 ;
  OPJ_UINT32 x1 ;
  OPJ_UINT32 j ;
  OPJ_UINT32 j___0 ;

  {
#line 2210
  bi = (OPJ_FLOAT32 *)(dwt->wavelet + dwt->cas);
#line 2212
  x0 = dwt->win_l_x0;
#line 2213
  x1 = dwt->win_l_x1;
#line 2215
  k = (OPJ_UINT32 )0;
  {
#line 2215
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2215
    if (! (k < 2U)) {
#line 2215
      goto while_break;
    }
#line 2216
    if (remaining_height >= 4U) {
#line 2216
      if (((OPJ_SIZE_T )a & 15UL) == 0UL) {
#line 2216
        if (((OPJ_SIZE_T )bi & 15UL) == 0UL) {
#line 2216
          if ((width & 15U) == 0U) {
#line 2219
            i = x0;
            {
#line 2219
            while (1) {
              while_continue___2: /* CIL Label */ ;

#line 2219
              if (! (i < x1)) {
#line 2219
                goto while_break___0;
              }
#line 2220
              j = i;
#line 2221
              *(bi + i * 8U) = *(a + j);
#line 2222
              j += width;
#line 2223
              *(bi + (i * 8U + 1U)) = *(a + j);
#line 2224
              j += width;
#line 2225
              *(bi + (i * 8U + 2U)) = *(a + j);
#line 2226
              j += width;
#line 2227
              *(bi + (i * 8U + 3U)) = *(a + j);
#line 2219
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            while_break___0: ;
          } else {
#line 2216
            goto _L;
          }
        } else {
#line 2216
          goto _L;
        }
      } else {
#line 2216
        goto _L;
      }
    } else {
      _L: 
#line 2231
      i = x0;
      {
#line 2231
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 2231
        if (! (i < x1)) {
#line 2231
          goto while_break___1;
        }
#line 2232
        j___0 = i;
#line 2233
        *(bi + i * 8U) = *(a + j___0);
#line 2234
        j___0 += width;
#line 2235
        if (remaining_height == 1U) {
#line 2236
          goto while_continue___1;
        }
#line 2238
        *(bi + (i * 8U + 1U)) = *(a + j___0);
#line 2239
        j___0 += width;
#line 2240
        if (remaining_height == 2U) {
#line 2241
          goto while_continue___1;
        }
#line 2243
        *(bi + (i * 8U + 2U)) = *(a + j___0);
#line 2244
        j___0 += width;
#line 2245
        if (remaining_height == 3U) {
#line 2246
          goto while_continue___1;
        }
#line 2248
        *(bi + (i * 8U + 3U)) = *(a + j___0);
#line 2231
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 2252
    bi = (OPJ_FLOAT32 *)((dwt->wavelet + 1) - dwt->cas);
#line 2253
    a += dwt->sn;
#line 2254
    x0 = dwt->win_h_x0;
#line 2255
    x1 = dwt->win_h_x1;
#line 2215
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 2219
  return;
}
}
#line 2259 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_v4dwt_interleave_partial_h(opj_v4dwt_t *dwt , opj_sparse_array_int32_t *sa ,
                                           OPJ_UINT32 sa_line , OPJ_UINT32 remaining_height ) 
{ 
  OPJ_UINT32 i ;
  OPJ_BOOL ret ;

  {
#line 2265
  i = (OPJ_UINT32 )0;
  {
#line 2265
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2265
    if (! (i < remaining_height)) {
#line 2265
      goto while_break;
    }
    {
#line 2267
    ret = opj_sparse_array_int32_read(sa, dwt->win_l_x0, sa_line + i, dwt->win_l_x1,
                                      (sa_line + i) + 1U, (OPJ_INT32 *)((dwt->wavelet + dwt->cas) + 2U * dwt->win_l_x0) + i,
                                      (OPJ_UINT32 )8, (OPJ_UINT32 )0, 1);
#line 2274
    ret = opj_sparse_array_int32_read(sa, (OPJ_UINT32 )dwt->sn + dwt->win_h_x0, sa_line + i,
                                      (OPJ_UINT32 )dwt->sn + dwt->win_h_x1, (sa_line + i) + 1U,
                                      (OPJ_INT32 *)(((dwt->wavelet + 1) - dwt->cas) + 2U * dwt->win_h_x0) + i,
                                      (OPJ_UINT32 )8, (OPJ_UINT32 )0, 1);
#line 2265
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2269
  return;
}
}
#line 2285 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_v4dwt_interleave_v(opj_v4dwt_t *dwt , OPJ_FLOAT32 *a , OPJ_UINT32 width ,
                                   OPJ_UINT32 nb_elts_read ) 
{ 
  opj_v4_t *bi ;
  OPJ_UINT32 i ;

  {
#line 2290
  bi = dwt->wavelet + dwt->cas;
#line 2293
  i = dwt->win_l_x0;
  {
#line 2293
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2293
    if (! (i < dwt->win_l_x1)) {
#line 2293
      goto while_break;
    }
    {
#line 2294
    memcpy((void *)(bi + i * 2U), (void const   *)(a + (unsigned long )i * (OPJ_SIZE_T )width),
           (OPJ_SIZE_T )nb_elts_read * sizeof(OPJ_FLOAT32 ));
#line 2293
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 2298
  a += (unsigned long )((OPJ_UINT32 )dwt->sn) * (OPJ_SIZE_T )width;
#line 2299
  bi = (dwt->wavelet + 1) - dwt->cas;
#line 2301
  i = dwt->win_h_x0;
  {
#line 2301
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2301
    if (! (i < dwt->win_h_x1)) {
#line 2301
      goto while_break___0;
    }
    {
#line 2302
    memcpy((void *)(bi + i * 2U), (void const   *)(a + (unsigned long )i * (OPJ_SIZE_T )width),
           (OPJ_SIZE_T )nb_elts_read * sizeof(OPJ_FLOAT32 ));
#line 2301
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 2305
  return;
}
}
#line 2307 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_v4dwt_interleave_partial_v(opj_v4dwt_t *dwt , opj_sparse_array_int32_t *sa ,
                                           OPJ_UINT32 sa_col , OPJ_UINT32 nb_elts_read ) 
{ 
  OPJ_BOOL ret ;

  {
  {
#line 2313
  ret = opj_sparse_array_int32_read(sa, sa_col, dwt->win_l_x0, sa_col + nb_elts_read,
                                    dwt->win_l_x1, (OPJ_INT32 *)((dwt->wavelet + dwt->cas) + 2U * dwt->win_l_x0),
                                    (OPJ_UINT32 )1, (OPJ_UINT32 )8, 1);
#line 2319
  ret = opj_sparse_array_int32_read(sa, sa_col, (OPJ_UINT32 )dwt->sn + dwt->win_h_x0,
                                    sa_col + nb_elts_read, (OPJ_UINT32 )dwt->sn + dwt->win_h_x1,
                                    (OPJ_INT32 *)(((dwt->wavelet + 1) - dwt->cas) + 2U * dwt->win_h_x0),
                                    (OPJ_UINT32 )1, (OPJ_UINT32 )8, 1);
  }
#line 2324
  return;
}
}
#line 2330 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_v4dwt_decode_step1_sse(opj_v4_t *w , OPJ_UINT32 start , OPJ_UINT32 end ,
                                       __m128 c ) 
{ 
  __m128 *vw ;
  OPJ_UINT32 i ;
  __m128 xmm0 ;
  __m128 __cil_tmp8 ;
  __m128 xmm2 ;
  __m128 __cil_tmp10 ;
  __m128 xmm4 ;
  __m128 __cil_tmp12 ;
  __m128 xmm6 ;
  __m128 __cil_tmp14 ;

  {
#line 2335
  vw = (__m128 *)w;
#line 2338
  vw += 2U * start;
#line 2339
  i = start;
  {
#line 2339
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2339
    if (! (i + 3U < end)) {
#line 2339
      goto while_break;
    }
    {
#line 2340
    __cil_tmp8 = _mm_mul_ps(*(vw + 0), c);
#line 2340
    xmm0 = __cil_tmp8;
#line 2341
    __cil_tmp10 = _mm_mul_ps(*(vw + 2), c);
#line 2341
    xmm2 = __cil_tmp10;
#line 2342
    __cil_tmp12 = _mm_mul_ps(*(vw + 4), c);
#line 2342
    xmm4 = __cil_tmp12;
#line 2343
    __cil_tmp14 = _mm_mul_ps(*(vw + 6), c);
#line 2343
    xmm6 = __cil_tmp14;
#line 2344
    *(vw + 0) = xmm0;
#line 2345
    *(vw + 2) = xmm2;
#line 2346
    *(vw + 4) = xmm4;
#line 2347
    *(vw + 6) = xmm6;
#line 2339
    vw += 8;
#line 2339
    i += 4U;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 2349
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2349
    if (! (i < end)) {
#line 2349
      goto while_break___0;
    }
    {
#line 2350
    *(vw + 0) = _mm_mul_ps(*(vw + 0), c);
#line 2349
    vw += 2;
#line 2349
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 2353
  return;
}
}
#line 2354 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_v4dwt_decode_step2_sse(opj_v4_t *l , opj_v4_t *w , OPJ_UINT32 start ,
                                       OPJ_UINT32 end , OPJ_UINT32 m , __m128 c ) 
{ 
  __m128 *vl ;
  __m128 *vw ;
  OPJ_UINT32 i ;
  OPJ_UINT32 imax ;
  OPJ_UINT32 __cil_tmp11 ;
  __m128 tmp1 ;
  __m128 tmp2 ;
  __m128 tmp3 ;
  __m128 tmp4 ;
  __m128 tmp5 ;
  __m128 tmp6 ;
  __m128 tmp7 ;
  __m128 tmp8 ;
  __m128 tmp9 ;
  __m128 __cil_tmp21 ;
  __m128 __cil_tmp22 ;
  __m128 __cil_tmp23 ;
  __m128 __cil_tmp24 ;
  __m128 __cil_tmp25 ;
  __m128 __cil_tmp26 ;
  __m128 __cil_tmp27 ;
  __m128 __cil_tmp28 ;
  __m128 __cil_tmp29 ;
  __m128 __cil_tmp30 ;
  __m128 __cil_tmp31 ;
  __m128 __cil_tmp32 ;
  __m128 __cil_tmp33 ;
  __m128 __cil_tmp34 ;
  __m128 __cil_tmp35 ;

  {
  {
#line 2360
  vl = (__m128 *)l;
#line 2361
  vw = (__m128 *)w;
#line 2363
  __cil_tmp11 = opj_uint_min(end, m);
#line 2363
  imax = __cil_tmp11;
  }
#line 2365
  if (start == 0U) {
#line 2366
    tmp1 = *(vl + 0);
  } else {
#line 2368
    vw += start * 2U;
#line 2369
    tmp1 = *(vw + -3);
  }
#line 2372
  i = start;
  {
#line 2375
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2375
    if (! (i + 3U < imax)) {
#line 2375
      goto while_break;
    }
    {
#line 2377
    tmp2 = *(vw + -1);
#line 2378
    tmp3 = *(vw + 0);
#line 2379
    tmp4 = *(vw + 1);
#line 2380
    tmp5 = *(vw + 2);
#line 2381
    tmp6 = *(vw + 3);
#line 2382
    tmp7 = *(vw + 4);
#line 2383
    tmp8 = *(vw + 5);
#line 2384
    tmp9 = *(vw + 6);
#line 2385
    __cil_tmp21 = _mm_add_ps(tmp1, tmp3);
#line 2385
    __cil_tmp22 = _mm_mul_ps(__cil_tmp21, c);
#line 2385
    __cil_tmp23 = _mm_add_ps(tmp2, __cil_tmp22);
#line 2385
    *(vw + -1) = __cil_tmp23;
#line 2386
    __cil_tmp24 = _mm_add_ps(tmp3, tmp5);
#line 2386
    __cil_tmp25 = _mm_mul_ps(__cil_tmp24, c);
#line 2386
    __cil_tmp26 = _mm_add_ps(tmp4, __cil_tmp25);
#line 2386
    *(vw + 1) = __cil_tmp26;
#line 2387
    __cil_tmp27 = _mm_add_ps(tmp5, tmp7);
#line 2387
    __cil_tmp28 = _mm_mul_ps(__cil_tmp27, c);
#line 2387
    __cil_tmp29 = _mm_add_ps(tmp6, __cil_tmp28);
#line 2387
    *(vw + 3) = __cil_tmp29;
#line 2388
    __cil_tmp30 = _mm_add_ps(tmp7, tmp9);
#line 2388
    __cil_tmp31 = _mm_mul_ps(__cil_tmp30, c);
#line 2388
    __cil_tmp32 = _mm_add_ps(tmp8, __cil_tmp31);
#line 2388
    *(vw + 5) = __cil_tmp32;
#line 2389
    tmp1 = tmp9;
#line 2390
    vw += 8;
#line 2375
    i += 4U;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 2393
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2393
    if (! (i < imax)) {
#line 2393
      goto while_break___0;
    }
    {
#line 2394
    tmp2 = *(vw + -1);
#line 2395
    tmp3 = *(vw + 0);
#line 2396
    __cil_tmp33 = _mm_add_ps(tmp1, tmp3);
#line 2396
    __cil_tmp34 = _mm_mul_ps(__cil_tmp33, c);
#line 2396
    __cil_tmp35 = _mm_add_ps(tmp2, __cil_tmp34);
#line 2396
    *(vw + -1) = __cil_tmp35;
#line 2397
    tmp1 = tmp3;
#line 2398
    vw += 2;
#line 2393
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 2400
  if (m < end) {
    {
#line 2402
    c = _mm_add_ps(c, c);
#line 2403
    c = _mm_mul_ps(c, *(vw + -2));
#line 2404
    *(vw + -1) = _mm_add_ps(*(vw + -1), c);
    }
  }
#line 2407
  return;
}
}
#line 2478 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static void opj_v4dwt_decode(opj_v4dwt_t *dwt ) 
{ 
  OPJ_INT32 a ;
  OPJ_INT32 b ;
  __m128 __cil_tmp4 ;
  __m128 __cil_tmp5 ;
  OPJ_INT32 __cil_tmp6 ;
  __m128 __cil_tmp7 ;
  OPJ_INT32 __cil_tmp8 ;
  __m128 __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  __m128 __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  __m128 __cil_tmp13 ;

  {
#line 2481
  if (dwt->cas == 0) {
#line 2482
    if (! (dwt->dn > 0)) {
#line 2482
      if (! (dwt->sn > 1)) {
#line 2483
        return;
      }
    }
#line 2485
    a = 0;
#line 2486
    b = 1;
  } else {
#line 2488
    if (! (dwt->sn > 0)) {
#line 2488
      if (! (dwt->dn > 1)) {
#line 2489
        return;
      }
    }
#line 2491
    a = 1;
#line 2492
    b = 0;
  }
  {
#line 2495
  __cil_tmp4 = _mm_set_ss(opj_K);
#line 2495
  opj_v4dwt_decode_step1_sse(dwt->wavelet + a, dwt->win_l_x0, dwt->win_l_x1, __cil_tmp4);
#line 2497
  __cil_tmp5 = _mm_set_ss(opj_c13318);
#line 2497
  opj_v4dwt_decode_step1_sse(dwt->wavelet + b, dwt->win_h_x0, dwt->win_h_x1, __cil_tmp5);
#line 2499
  __cil_tmp6 = opj_int_min(dwt->sn, dwt->dn - a);
#line 2499
  __cil_tmp7 = _mm_set_ss(opj_dwt_delta);
#line 2499
  opj_v4dwt_decode_step2_sse(dwt->wavelet + b, (dwt->wavelet + a) + 1, dwt->win_l_x0,
                             dwt->win_l_x1, (OPJ_UINT32 )__cil_tmp6, __cil_tmp7);
#line 2503
  __cil_tmp8 = opj_int_min(dwt->dn, dwt->sn - b);
#line 2503
  __cil_tmp9 = _mm_set_ss(opj_dwt_gamma);
#line 2503
  opj_v4dwt_decode_step2_sse(dwt->wavelet + a, (dwt->wavelet + b) + 1, dwt->win_h_x0,
                             dwt->win_h_x1, (OPJ_UINT32 )__cil_tmp8, __cil_tmp9);
#line 2507
  __cil_tmp10 = opj_int_min(dwt->sn, dwt->dn - a);
#line 2507
  __cil_tmp11 = _mm_set_ss(opj_dwt_beta);
#line 2507
  opj_v4dwt_decode_step2_sse(dwt->wavelet + b, (dwt->wavelet + a) + 1, dwt->win_l_x0,
                             dwt->win_l_x1, (OPJ_UINT32 )__cil_tmp10, __cil_tmp11);
#line 2511
  __cil_tmp12 = opj_int_min(dwt->dn, dwt->sn - b);
#line 2511
  __cil_tmp13 = _mm_set_ss(opj_dwt_alpha);
#line 2511
  opj_v4dwt_decode_step2_sse(dwt->wavelet + a, (dwt->wavelet + b) + 1, dwt->win_h_x0,
                             dwt->win_h_x1, (OPJ_UINT32 )__cil_tmp12, __cil_tmp13);
  }
#line 2514
  return;
}
}
#line 2544 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_BOOL opj_dwt_decode_tile_97(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) 
{ 
  opj_v4dwt_t h ;
  opj_v4dwt_t v ;
  opj_tcd_resolution_t *res ;
  OPJ_UINT32 rw ;
  OPJ_UINT32 rh ;
  OPJ_UINT32 w ;
  OPJ_SIZE_T l_data_size ;
  OPJ_UINT32 __cil_tmp10 ;
  void *__cil_tmp11 ;
  OPJ_FLOAT32 *aj ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 k___0 ;
  OPJ_UINT32 k___1 ;
  OPJ_UINT32 k___2 ;

  {
  {
#line 2550
  res = tilec->resolutions;
#line 2552
  rw = (OPJ_UINT32 )(res->x1 - res->x0);
#line 2554
  rh = (OPJ_UINT32 )(res->y1 - res->y0);
#line 2557
  w = (OPJ_UINT32 )((tilec->resolutions + (tilec->minimum_num_resolutions - 1U))->x1 - (tilec->resolutions + (tilec->minimum_num_resolutions - 1U))->x0);
#line 2563
  __cil_tmp10 = opj_dwt_max_resolution(res, numres);
#line 2563
  l_data_size = (OPJ_SIZE_T )__cil_tmp10;
  }
#line 2565
  if (l_data_size > 0xfffffffffffffffaUL) {
#line 2567
    return (0);
  }
#line 2569
  l_data_size += 5UL;
#line 2571
  if (l_data_size > 0xffffffffffffffffUL / sizeof(opj_v4_t )) {
#line 2573
    return (0);
  }
  {
#line 2575
  __cil_tmp11 = opj_aligned_malloc(l_data_size * sizeof(opj_v4_t ));
#line 2575
  h.wavelet = (opj_v4_t *)__cil_tmp11;
  }
#line 2576
  if (! h.wavelet) {
#line 2578
    return (0);
  }
#line 2580
  v.wavelet = h.wavelet;
  {
#line 2582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2582
    numres --;
#line 2582
    if (! numres) {
#line 2582
      goto while_break;
    }
#line 2583
    aj = (OPJ_FLOAT32 *)tilec->data;
#line 2586
    h.sn = (OPJ_INT32 )rw;
#line 2587
    v.sn = (OPJ_INT32 )rh;
#line 2589
    res ++;
#line 2591
    rw = (OPJ_UINT32 )(res->x1 - res->x0);
#line 2593
    rh = (OPJ_UINT32 )(res->y1 - res->y0);
#line 2596
    h.dn = (OPJ_INT32 )(rw - (OPJ_UINT32 )h.sn);
#line 2597
    h.cas = res->x0 % 2;
#line 2599
    h.win_l_x0 = (OPJ_UINT32 )0;
#line 2600
    h.win_l_x1 = (OPJ_UINT32 )h.sn;
#line 2601
    h.win_h_x0 = (OPJ_UINT32 )0;
#line 2602
    h.win_h_x1 = (OPJ_UINT32 )h.dn;
#line 2603
    j = (OPJ_UINT32 )0;
    {
#line 2603
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2603
      if (! (j + 3U < rh)) {
#line 2603
        goto while_break___0;
      }
      {
#line 2605
      opj_v4dwt_interleave_h(& h, aj, w, rh - j);
#line 2606
      opj_v4dwt_decode(& h);
#line 2608
      k = (OPJ_UINT32 )0;
      }
      {
#line 2608
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2608
        if (! (k < rw)) {
#line 2608
          goto while_break___1;
        }
#line 2609
        *(aj + k) = (h.wavelet + k)->f[0];
#line 2610
        *(aj + ((unsigned long )k + (OPJ_SIZE_T )w)) = (h.wavelet + k)->f[1];
#line 2611
        *(aj + ((unsigned long )k + (OPJ_SIZE_T )w * 2UL)) = (h.wavelet + k)->f[2];
#line 2612
        *(aj + ((unsigned long )k + (OPJ_SIZE_T )w * 3UL)) = (h.wavelet + k)->f[3];
#line 2608
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: 
#line 2615
      aj += w * 4U;
#line 2603
      j += 4U;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: ;
#line 2618
    if (j < rh) {
      {
#line 2620
      opj_v4dwt_interleave_h(& h, aj, w, rh - j);
#line 2621
      opj_v4dwt_decode(& h);
#line 2622
      k___0 = (OPJ_UINT32 )0;
      }
      {
#line 2622
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 2622
        if (! (k___0 < rw)) {
#line 2622
          goto while_break___2;
        }
#line 2624
        if (rh - j == 3U) {
#line 2624
          goto case_3;
        }
#line 2627
        if (rh - j == 2U) {
#line 2627
          goto case_2;
        }
#line 2630
        if (rh - j == 1U) {
#line 2630
          goto case_1;
        }
#line 2623
        goto switch_break;
        case_3: 
#line 2625
        *(aj + ((unsigned long )k___0 + (OPJ_SIZE_T )w * 2UL)) = (h.wavelet + k___0)->f[2];
        case_2: 
#line 2628
        *(aj + ((unsigned long )k___0 + (OPJ_SIZE_T )w)) = (h.wavelet + k___0)->f[1];
        case_1: 
#line 2631
        *(aj + k___0) = (h.wavelet + k___0)->f[0];
        switch_break: 
#line 2622
        k___0 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 2636
    v.dn = (OPJ_INT32 )(rh - (OPJ_UINT32 )v.sn);
#line 2637
    v.cas = res->y0 % 2;
#line 2638
    v.win_l_x0 = (OPJ_UINT32 )0;
#line 2639
    v.win_l_x1 = (OPJ_UINT32 )v.sn;
#line 2640
    v.win_h_x0 = (OPJ_UINT32 )0;
#line 2641
    v.win_h_x1 = (OPJ_UINT32 )v.dn;
#line 2643
    aj = (OPJ_FLOAT32 *)tilec->data;
#line 2644
    j = rw;
    {
#line 2644
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 2644
      if (! (j > 3U)) {
#line 2644
        goto while_break___3;
      }
      {
#line 2647
      opj_v4dwt_interleave_v(& v, aj, w, (OPJ_UINT32 )4);
#line 2648
      opj_v4dwt_decode(& v);
#line 2650
      k___1 = (OPJ_UINT32 )0;
      }
      {
#line 2650
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 2650
        if (! (k___1 < rh)) {
#line 2650
          goto while_break___4;
        }
        {
#line 2651
        memcpy((void *)(aj + (unsigned long )k___1 * (OPJ_SIZE_T )w), (void const   *)(v.wavelet + k___1),
               4UL * sizeof(OPJ_FLOAT32 ));
#line 2650
        k___1 ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: 
#line 2653
      aj += 4;
#line 2644
      j -= 4U;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___3: ;
#line 2656
    if (rw & 3U) {
      {
#line 2659
      j = rw & 3U;
#line 2661
      opj_v4dwt_interleave_v(& v, aj, w, j);
#line 2662
      opj_v4dwt_decode(& v);
#line 2664
      k___2 = (OPJ_UINT32 )0;
      }
      {
#line 2664
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 2664
        if (! (k___2 < rh)) {
#line 2664
          goto while_break___5;
        }
        {
#line 2665
        memcpy((void *)(aj + (unsigned long )k___2 * (OPJ_SIZE_T )w), (void const   *)(v.wavelet + k___2),
               (OPJ_SIZE_T )j * sizeof(OPJ_FLOAT32 ));
#line 2664
        k___2 ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___5: ;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2671
  opj_aligned_free((void *)h.wavelet);
  }
#line 2672
  return (1);
}
}
#line 2676 "/root/patron/new_24/src/lib/openjp2/dwt.c"
static OPJ_BOOL opj_dwt_decode_partial_97(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) 
{ 
  opj_sparse_array_int32_t *sa ;
  opj_v4dwt_t h ;
  opj_v4dwt_t v ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 filter_width ;
  opj_tcd_resolution_t *tr ;
  opj_tcd_resolution_t *tr_max ;
  OPJ_UINT32 rw ;
  OPJ_UINT32 rh ;
  OPJ_SIZE_T l_data_size ;
  OPJ_UINT32 win_tcx0 ;
  OPJ_UINT32 win_tcy0 ;
  OPJ_UINT32 win_tcx1 ;
  OPJ_UINT32 win_tcy1 ;
  OPJ_BOOL ret ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp21 ;
  void *__cil_tmp22 ;
  OPJ_UINT32 j ;
  OPJ_UINT32 win_ll_x0 ;
  OPJ_UINT32 win_ll_y0 ;
  OPJ_UINT32 win_ll_x1 ;
  OPJ_UINT32 win_ll_y1 ;
  OPJ_UINT32 win_hl_x0 ;
  OPJ_UINT32 win_hl_x1 ;
  OPJ_UINT32 win_lh_y0 ;
  OPJ_UINT32 win_lh_y1 ;
  OPJ_UINT32 win_tr_x0 ;
  OPJ_UINT32 win_tr_x1 ;
  OPJ_UINT32 win_tr_y0 ;
  OPJ_UINT32 win_tr_y1 ;
  OPJ_UINT32 tr_ll_x0 ;
  OPJ_UINT32 tr_ll_y0 ;
  OPJ_UINT32 tr_hl_x0 ;
  OPJ_UINT32 tr_lh_y0 ;
  OPJ_UINT32 __cil_tmp49 ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 __cil_tmp52 ;
  OPJ_UINT32 __cil_tmp53 ;
  OPJ_UINT32 __cil_tmp55 ;
  OPJ_UINT32 __cil_tmp56 ;
  OPJ_UINT32 __cil_tmp58 ;
  OPJ_UINT32 __cil_tmp59 ;
  OPJ_UINT32 __cil_tmp60 ;
  OPJ_BOOL __cil_tmp61 ;
  OPJ_BOOL __cil_tmp62 ;
  OPJ_UINT32 nb_elts ;
  OPJ_UINT32 __cil_tmp64 ;
  OPJ_BOOL __cil_tmp65 ;
  OPJ_BOOL ret___0 ;
  OPJ_BOOL __cil_tmp68 ;

  {
  {
#line 2686
  filter_width = 4U;
#line 2688
  tr = tilec->resolutions;
#line 2689
  tr_max = tilec->resolutions + (numres - 1U);
#line 2691
  rw = (OPJ_UINT32 )(tr->x1 - tr->x0);
#line 2693
  rh = (OPJ_UINT32 )(tr->y1 - tr->y0);
#line 2700
  win_tcx0 = tilec->win_x0;
#line 2701
  win_tcy0 = tilec->win_y0;
#line 2702
  win_tcx1 = tilec->win_x1;
#line 2703
  win_tcy1 = tilec->win_y1;
#line 2709
  sa = opj_dwt_init_sparse_array1(tilec, numres);
  }
#line 2714
  if (numres == 1U) {
    {
#line 2715
    __cil_tmp19 = opj_sparse_array_int32_read(sa, tr_max->win_x0 - (OPJ_UINT32 )tr_max->x0,
                                              tr_max->win_y0 - (OPJ_UINT32 )tr_max->y0,
                                              tr_max->win_x1 - (OPJ_UINT32 )tr_max->x0,
                                              tr_max->win_y1 - (OPJ_UINT32 )tr_max->y0,
                                              tilec->data_win, (OPJ_UINT32 )1, tr_max->win_x1 - tr_max->win_x0,
                                              1);
#line 2715
    ret = __cil_tmp19;
#line 2725
    opj_sparse_array_int32_free(sa);
    }
#line 2726
    return (1);
  }
  {
#line 2729
  __cil_tmp21 = opj_dwt_max_resolution(tr, numres);
#line 2729
  l_data_size = (OPJ_SIZE_T )__cil_tmp21;
  }
#line 2731
  if (l_data_size > 0xfffffffffffffffaUL) {
#line 2733
    return (0);
  }
#line 2735
  l_data_size += 5UL;
#line 2737
  if (l_data_size > 0xffffffffffffffffUL / sizeof(opj_v4_t )) {
#line 2739
    return (0);
  }
  {
#line 2741
  __cil_tmp22 = opj_aligned_malloc(l_data_size * sizeof(opj_v4_t ));
#line 2741
  h.wavelet = (opj_v4_t *)__cil_tmp22;
  }
#line 2742
  if (! h.wavelet) {
#line 2744
    return (0);
  }
#line 2746
  v.wavelet = h.wavelet;
#line 2748
  resno = (OPJ_UINT32 )1;
  {
#line 2748
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2748
    if (! (resno < numres)) {
#line 2748
      goto while_break;
    }
    {
#line 2759
    tr ++;
#line 2761
    h.sn = (OPJ_INT32 )rw;
#line 2762
    v.sn = (OPJ_INT32 )rh;
#line 2764
    rw = (OPJ_UINT32 )(tr->x1 - tr->x0);
#line 2765
    rh = (OPJ_UINT32 )(tr->y1 - tr->y0);
#line 2767
    h.dn = (OPJ_INT32 )(rw - (OPJ_UINT32 )h.sn);
#line 2768
    h.cas = tr->x0 % 2;
#line 2770
    v.dn = (OPJ_INT32 )(rh - (OPJ_UINT32 )v.sn);
#line 2771
    v.cas = tr->y0 % 2;
#line 2775
    opj_dwt_get_band_coordinates(tilec, resno, (OPJ_UINT32 )0, win_tcx0, win_tcy0,
                                 win_tcx1, win_tcy1, & win_ll_x0, & win_ll_y0, & win_ll_x1,
                                 & win_ll_y1);
#line 2781
    opj_dwt_get_band_coordinates(tilec, resno, (OPJ_UINT32 )1, win_tcx0, win_tcy0,
                                 win_tcx1, win_tcy1, & win_hl_x0, (OPJ_UINT32 *)((void *)0),
                                 & win_hl_x1, (OPJ_UINT32 *)((void *)0));
#line 2786
    opj_dwt_get_band_coordinates(tilec, resno, (OPJ_UINT32 )2, win_tcx0, win_tcy0,
                                 win_tcx1, win_tcy1, (OPJ_UINT32 *)((void *)0), & win_lh_y0,
                                 (OPJ_UINT32 *)((void *)0), & win_lh_y1);
#line 2791
    tr_ll_x0 = (OPJ_UINT32 )tr->bands[1].x0;
#line 2792
    tr_ll_y0 = (OPJ_UINT32 )tr->bands[0].y0;
#line 2793
    tr_hl_x0 = (OPJ_UINT32 )tr->bands[0].x0;
#line 2794
    tr_lh_y0 = (OPJ_UINT32 )tr->bands[1].y0;
#line 2799
    win_ll_x0 = opj_uint_subs(win_ll_x0, tr_ll_x0);
#line 2800
    win_ll_y0 = opj_uint_subs(win_ll_y0, tr_ll_y0);
#line 2801
    win_ll_x1 = opj_uint_subs(win_ll_x1, tr_ll_x0);
#line 2802
    win_ll_y1 = opj_uint_subs(win_ll_y1, tr_ll_y0);
#line 2803
    win_hl_x0 = opj_uint_subs(win_hl_x0, tr_hl_x0);
#line 2804
    win_hl_x1 = opj_uint_subs(win_hl_x1, tr_hl_x0);
#line 2805
    win_lh_y0 = opj_uint_subs(win_lh_y0, tr_lh_y0);
#line 2806
    win_lh_y1 = opj_uint_subs(win_lh_y1, tr_lh_y0);
#line 2808
    opj_dwt_segment_grow(filter_width, (OPJ_UINT32 )h.sn, & win_ll_x0, & win_ll_x1);
#line 2809
    opj_dwt_segment_grow(filter_width, (OPJ_UINT32 )h.dn, & win_hl_x0, & win_hl_x1);
#line 2811
    opj_dwt_segment_grow(filter_width, (OPJ_UINT32 )v.sn, & win_ll_y0, & win_ll_y1);
#line 2812
    opj_dwt_segment_grow(filter_width, (OPJ_UINT32 )v.dn, & win_lh_y0, & win_lh_y1);
    }
#line 2815
    if (h.cas == 0) {
      {
#line 2816
      win_tr_x0 = opj_uint_min(2U * win_ll_x0, 2U * win_hl_x0 + 1U);
#line 2817
      __cil_tmp49 = opj_uint_max(2U * win_ll_x1, 2U * win_hl_x1 + 1U);
#line 2817
      __cil_tmp50 = opj_uint_min(__cil_tmp49, rw);
#line 2817
      win_tr_x1 = __cil_tmp50;
      }
    } else {
      {
#line 2819
      win_tr_x0 = opj_uint_min(2U * win_hl_x0, 2U * win_ll_x0 + 1U);
#line 2820
      __cil_tmp52 = opj_uint_max(2U * win_hl_x1, 2U * win_ll_x1 + 1U);
#line 2820
      __cil_tmp53 = opj_uint_min(__cil_tmp52, rw);
#line 2820
      win_tr_x1 = __cil_tmp53;
      }
    }
#line 2823
    if (v.cas == 0) {
      {
#line 2824
      win_tr_y0 = opj_uint_min(2U * win_ll_y0, 2U * win_lh_y0 + 1U);
#line 2825
      __cil_tmp55 = opj_uint_max(2U * win_ll_y1, 2U * win_lh_y1 + 1U);
#line 2825
      __cil_tmp56 = opj_uint_min(__cil_tmp55, rh);
#line 2825
      win_tr_y1 = __cil_tmp56;
      }
    } else {
      {
#line 2827
      win_tr_y0 = opj_uint_min(2U * win_lh_y0, 2U * win_ll_y0 + 1U);
#line 2828
      __cil_tmp58 = opj_uint_max(2U * win_lh_y1, 2U * win_ll_y1 + 1U);
#line 2828
      __cil_tmp59 = opj_uint_min(__cil_tmp58, rh);
#line 2828
      win_tr_y1 = __cil_tmp59;
      }
    }
#line 2831
    h.win_l_x0 = win_ll_x0;
#line 2832
    h.win_l_x1 = win_ll_x1;
#line 2833
    h.win_h_x0 = win_hl_x0;
#line 2834
    h.win_h_x1 = win_hl_x1;
#line 2835
    j = (OPJ_UINT32 )0;
    {
#line 2835
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2835
      if (! (j + 3U < rh)) {
#line 2835
        goto while_break___0;
      }
#line 2836
      if (j + 3U >= win_ll_y0) {
#line 2836
        if (j < win_ll_y1) {
          _L: 
          {
#line 2839
          __cil_tmp60 = opj_uint_min(4U, rh - j);
#line 2839
          opj_v4dwt_interleave_partial_h(& h, sa, j, __cil_tmp60);
#line 2840
          opj_v4dwt_decode(& h);
#line 2841
          __cil_tmp61 = opj_sparse_array_int32_write(sa, win_tr_x0, j, win_tr_x1,
                                                     j + 4U, (OPJ_INT32 *)(& (h.wavelet + win_tr_x0)->f[0]),
                                                     (OPJ_UINT32 )4, (OPJ_UINT32 )1,
                                                     1);
          }
#line 2841
          if (! __cil_tmp61) {
            {
#line 2847
            opj_sparse_array_int32_free(sa);
#line 2848
            opj_aligned_free((void *)h.wavelet);
            }
#line 2849
            return (0);
          }
        } else {
#line 2836
          goto _L___39;
        }
      } else
      _L___39: 
#line 2836
      if (j + 3U >= win_lh_y0 + (OPJ_UINT32 )v.sn) {
#line 2836
        if (j < win_lh_y1 + (OPJ_UINT32 )v.sn) {
#line 2836
          goto _L;
        }
      }
#line 2835
      j += 4U;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 2854
    if (j < rh) {
#line 2854
      if (j + 3U >= win_ll_y0) {
#line 2854
        if (j < win_ll_y1) {
          _L___40: 
          {
#line 2858
          opj_v4dwt_interleave_partial_h(& h, sa, j, rh - j);
#line 2859
          opj_v4dwt_decode(& h);
#line 2860
          __cil_tmp62 = opj_sparse_array_int32_write(sa, win_tr_x0, j, win_tr_x1,
                                                     rh, (OPJ_INT32 *)(& (h.wavelet + win_tr_x0)->f[0]),
                                                     (OPJ_UINT32 )4, (OPJ_UINT32 )1,
                                                     1);
          }
#line 2860
          if (! __cil_tmp62) {
            {
#line 2866
            opj_sparse_array_int32_free(sa);
#line 2867
            opj_aligned_free((void *)h.wavelet);
            }
#line 2868
            return (0);
          }
        } else {
#line 2854
          goto _L___41;
        }
      } else
      _L___41: 
#line 2854
      if (j + 3U >= win_lh_y0 + (OPJ_UINT32 )v.sn) {
#line 2854
        if (j < win_lh_y1 + (OPJ_UINT32 )v.sn) {
#line 2854
          goto _L___40;
        }
      }
    }
#line 2872
    v.win_l_x0 = win_ll_y0;
#line 2873
    v.win_l_x1 = win_ll_y1;
#line 2874
    v.win_h_x0 = win_lh_y0;
#line 2875
    v.win_h_x1 = win_lh_y1;
#line 2876
    j = win_tr_x0;
    {
#line 2876
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 2876
      if (! (j < win_tr_x1)) {
#line 2876
        goto while_break___1;
      }
      {
#line 2877
      __cil_tmp64 = opj_uint_min(4U, win_tr_x1 - j);
#line 2877
      nb_elts = __cil_tmp64;
#line 2879
      opj_v4dwt_interleave_partial_v(& v, sa, j, nb_elts);
#line 2880
      opj_v4dwt_decode(& v);
#line 2882
      __cil_tmp65 = opj_sparse_array_int32_write(sa, j, win_tr_y0, j + nb_elts, win_tr_y1,
                                                 (OPJ_INT32 *)(& (h.wavelet + win_tr_y0)->f[0]),
                                                 (OPJ_UINT32 )1, (OPJ_UINT32 )4, 1);
      }
#line 2882
      if (! __cil_tmp65) {
        {
#line 2888
        opj_sparse_array_int32_free(sa);
#line 2889
        opj_aligned_free((void *)h.wavelet);
        }
#line 2890
        return (0);
      }
#line 2876
      j += 4U;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 2748
    resno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2896
  __cil_tmp68 = opj_sparse_array_int32_read(sa, tr_max->win_x0 - (OPJ_UINT32 )tr_max->x0,
                                            tr_max->win_y0 - (OPJ_UINT32 )tr_max->y0,
                                            tr_max->win_x1 - (OPJ_UINT32 )tr_max->x0,
                                            tr_max->win_y1 - (OPJ_UINT32 )tr_max->y0,
                                            tilec->data_win, (OPJ_UINT32 )1, tr_max->win_x1 - tr_max->win_x0,
                                            1);
#line 2896
  ret___0 = __cil_tmp68;
#line 2907
  opj_sparse_array_int32_free(sa);
#line 2909
  opj_aligned_free((void *)h.wavelet);
  }
#line 2910
  return (1);
}
}
#line 2914 "/root/patron/new_24/src/lib/openjp2/dwt.c"
OPJ_BOOL opj_dwt_decode_real(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 2918
  if (p_tcd->whole_tile_decoding) {
    {
#line 2919
    __cil_tmp4 = opj_dwt_decode_tile_97(tilec, numres);
    }
#line 2919
    return (__cil_tmp4);
  } else {
    {
#line 2921
    __cil_tmp5 = opj_dwt_decode_partial_97(tilec, numres);
    }
#line 2921
    return (__cil_tmp5);
  }
}
}
#line 47 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 50
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_UINT32 )) - p_nb_bytes;
#line 55
  memcpy((void *)p_buffer, (void const   *)l_data_ptr, (unsigned long )p_nb_bytes);
  }
#line 57
  return;
}
}
#line 58 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_write_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 61
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + p_nb_bytes) - 1;
#line 66
  i = (OPJ_UINT32 )0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;

#line 66
    if (! (i < p_nb_bytes)) {
#line 66
      goto while_break;
    }
#line 67
    __cil_tmp8 = l_data_ptr;
#line 67
    l_data_ptr --;
#line 67
    __cil_tmp7 = p_buffer;
#line 67
    p_buffer ++;
#line 67
    *__cil_tmp7 = *__cil_tmp8;
#line 66
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 70
  return;
}
}
#line 71 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_read_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 74
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 78
  *p_value = (OPJ_UINT32 )0;
#line 79
  memcpy((void *)((l_data_ptr + sizeof(OPJ_UINT32 )) - p_nb_bytes), (void const   *)p_buffer,
         (unsigned long )p_nb_bytes);
  }
#line 81
  return;
}
}
#line 82 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_read_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 85
  l_data_ptr = ((OPJ_BYTE *)p_value + p_nb_bytes) - 1;
#line 90
  *p_value = (OPJ_UINT32 )0;
#line 91
  i = (OPJ_UINT32 )0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;

#line 91
    if (! (i < p_nb_bytes)) {
#line 91
      goto while_break;
    }
#line 92
    __cil_tmp8 = p_buffer;
#line 92
    p_buffer ++;
#line 92
    __cil_tmp7 = l_data_ptr;
#line 92
    l_data_ptr --;
#line 92
    *__cil_tmp7 = *__cil_tmp8;
#line 91
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 95
  return;
}
}
#line 96 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_write_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 98
  l_data_ptr = (OPJ_BYTE *)(& p_value);
#line 99
  memcpy((void *)p_buffer, (void const   *)l_data_ptr, sizeof(OPJ_FLOAT64 ));
  }
#line 101
  return;
}
}
#line 102 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_write_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 104
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_FLOAT64 )) - 1;
#line 107
  i = (OPJ_UINT32 )0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;

#line 107
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT64 ))) {
#line 107
      goto while_break;
    }
#line 108
    __cil_tmp6 = l_data_ptr;
#line 108
    l_data_ptr --;
#line 108
    __cil_tmp5 = p_buffer;
#line 108
    p_buffer ++;
#line 108
    *__cil_tmp5 = *__cil_tmp6;
#line 107
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 111
  return;
}
}
#line 112 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_read_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 114
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 115
  memcpy((void *)l_data_ptr, (void const   *)p_buffer, sizeof(OPJ_FLOAT64 ));
  }
#line 117
  return;
}
}
#line 118 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_read_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 120
  l_data_ptr = ((OPJ_BYTE *)p_value + sizeof(OPJ_FLOAT64 )) - 1;
#line 122
  i = (OPJ_UINT32 )0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;

#line 122
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT64 ))) {
#line 122
      goto while_break;
    }
#line 123
    __cil_tmp6 = p_buffer;
#line 123
    p_buffer ++;
#line 123
    __cil_tmp5 = l_data_ptr;
#line 123
    l_data_ptr --;
#line 123
    *__cil_tmp5 = *__cil_tmp6;
#line 122
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 126
  return;
}
}
#line 127 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_write_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 129
  l_data_ptr = (OPJ_BYTE *)(& p_value);
#line 130
  memcpy((void *)p_buffer, (void const   *)l_data_ptr, sizeof(OPJ_FLOAT32 ));
  }
#line 132
  return;
}
}
#line 133 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_write_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 135
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_FLOAT32 )) - 1;
#line 138
  i = (OPJ_UINT32 )0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;

#line 138
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT32 ))) {
#line 138
      goto while_break;
    }
#line 139
    __cil_tmp6 = l_data_ptr;
#line 139
    l_data_ptr --;
#line 139
    __cil_tmp5 = p_buffer;
#line 139
    p_buffer ++;
#line 139
    *__cil_tmp5 = *__cil_tmp6;
#line 138
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 142
  return;
}
}
#line 143 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_read_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 145
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 146
  memcpy((void *)l_data_ptr, (void const   *)p_buffer, sizeof(OPJ_FLOAT32 ));
  }
#line 148
  return;
}
}
#line 149 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_read_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 151
  l_data_ptr = ((OPJ_BYTE *)p_value + sizeof(OPJ_FLOAT32 )) - 1;
#line 153
  i = (OPJ_UINT32 )0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;

#line 153
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT32 ))) {
#line 153
      goto while_break;
    }
#line 154
    __cil_tmp6 = p_buffer;
#line 154
    p_buffer ++;
#line 154
    __cil_tmp5 = l_data_ptr;
#line 154
    l_data_ptr --;
#line 154
    *__cil_tmp5 = *__cil_tmp6;
#line 153
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 157
  return;
}
}
#line 158 "/root/patron/new_24/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) 
{ 
  opj_stream_private_t *l_stream ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 161
  l_stream = (opj_stream_private_t *)0;
#line 162
  __cil_tmp4 = opj_calloc((size_t )1, sizeof(opj_stream_private_t ));
#line 162
  l_stream = (opj_stream_private_t *)__cil_tmp4;
  }
#line 163
  if (! l_stream) {
#line 164
    return ((opj_stream_t *)0);
  }
  {
#line 167
  l_stream->m_buffer_size = p_buffer_size;
#line 168
  __cil_tmp5 = opj_malloc(p_buffer_size);
#line 168
  l_stream->m_stored_data = (OPJ_BYTE *)__cil_tmp5;
  }
#line 169
  if (! l_stream->m_stored_data) {
    {
#line 170
    opj_free((void *)l_stream);
    }
#line 171
    return ((opj_stream_t *)0);
  }
#line 174
  l_stream->m_current_data = l_stream->m_stored_data;
#line 176
  if (l_is_input) {
#line 177
    l_stream->m_status |= 2U;
#line 178
    l_stream->m_opj_skip = & opj_stream_read_skip;
#line 179
    l_stream->m_opj_seek = & opj_stream_read_seek;
  } else {
#line 181
    l_stream->m_status |= 1U;
#line 182
    l_stream->m_opj_skip = & opj_stream_write_skip;
#line 183
    l_stream->m_opj_seek = & opj_stream_write_seek;
  }
#line 186
  l_stream->m_read_fn = & opj_stream_default_read;
#line 187
  l_stream->m_write_fn = & opj_stream_default_write;
#line 188
  l_stream->m_skip_fn = & opj_stream_default_skip;
#line 189
  l_stream->m_seek_fn = & opj_stream_default_seek;
#line 191
  return ((opj_stream_t *)l_stream);
}
}
#line 194 "/root/patron/new_24/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input ) 
{ 
  opj_stream_t *__cil_tmp2 ;

  {
  {
#line 196
  __cil_tmp2 = opj_stream_create((OPJ_SIZE_T )1048576, l_is_input);
  }
#line 196
  return (__cil_tmp2);
}
}
#line 199 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_stream_destroy(opj_stream_t *p_stream ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 201
  l_stream = (opj_stream_private_t *)p_stream;
#line 203
  if (l_stream) {
#line 204
    if (l_stream->m_free_user_data_fn) {
      {
#line 205
      (*(l_stream->m_free_user_data_fn))(l_stream->m_user_data);
      }
    }
    {
#line 207
    opj_free((void *)l_stream->m_stored_data);
#line 208
    l_stream->m_stored_data = (OPJ_BYTE *)0;
#line 209
    opj_free((void *)l_stream);
    }
  }
#line 212
  return;
}
}
#line 213 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_stream_set_read_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                    OPJ_SIZE_T  ,
                                                                                    void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 216
  l_stream = (opj_stream_private_t *)p_stream;
#line 218
  if (! l_stream) {
#line 219
    return;
  } else
#line 218
  if (! (l_stream->m_status & 2U)) {
#line 219
    return;
  }
#line 222
  l_stream->m_read_fn = p_function;
#line 223
  return;
}
}
#line 225 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_stream_set_seek_function(opj_stream_t *p_stream , OPJ_BOOL (*p_function)(OPJ_OFF_T  ,
                                                                                  void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 228
  l_stream = (opj_stream_private_t *)p_stream;
#line 230
  if (! l_stream) {
#line 231
    return;
  }
#line 233
  l_stream->m_seek_fn = p_function;
#line 234
  return;
}
}
#line 236 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_stream_set_write_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                     OPJ_SIZE_T  ,
                                                                                     void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 239
  l_stream = (opj_stream_private_t *)p_stream;
#line 241
  if (! l_stream) {
#line 242
    return;
  } else
#line 241
  if (! (l_stream->m_status & 1U)) {
#line 242
    return;
  }
#line 245
  l_stream->m_write_fn = p_function;
#line 246
  return;
}
}
#line 248 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_stream_set_skip_function(opj_stream_t *p_stream , OPJ_OFF_T (*p_function)(OPJ_OFF_T  ,
                                                                                   void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 251
  l_stream = (opj_stream_private_t *)p_stream;
#line 253
  if (! l_stream) {
#line 254
    return;
  }
#line 257
  l_stream->m_skip_fn = p_function;
#line 258
  return;
}
}
#line 260 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_stream_set_user_data(opj_stream_t *p_stream , void *p_data , void (*p_function)(void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 263
  l_stream = (opj_stream_private_t *)p_stream;
#line 264
  if (! l_stream) {
#line 265
    return;
  }
#line 267
  l_stream->m_user_data = p_data;
#line 268
  l_stream->m_free_user_data_fn = p_function;
#line 269
  return;
}
}
#line 271 "/root/patron/new_24/src/lib/openjp2/cio.c"
void opj_stream_set_user_data_length(opj_stream_t *p_stream , OPJ_UINT64 data_length ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 274
  l_stream = (opj_stream_private_t *)p_stream;
#line 275
  if (! l_stream) {
#line 276
    return;
  }
#line 278
  l_stream->m_user_data_length = data_length;
#line 279
  return;
}
}
#line 281 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_read_nb_bytes ;
  OPJ_SIZE_T tmp ;
  OPJ_SIZE_T tmp___0 ;
  OPJ_SIZE_T tmp___1 ;

  {
#line 284
  l_read_nb_bytes = (OPJ_SIZE_T )0;
#line 285
  if (p_stream->m_bytes_in_buffer >= p_size) {
    {
#line 286
    memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_size);
#line 287
    p_stream->m_current_data += p_size;
#line 288
    p_stream->m_bytes_in_buffer -= p_size;
#line 289
    l_read_nb_bytes += p_size;
#line 290
    p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
    }
#line 291
    return (l_read_nb_bytes);
  }
#line 295
  if (p_stream->m_status & 4U) {
    {
#line 296
    l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 297
    memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 298
    p_stream->m_current_data += p_stream->m_bytes_in_buffer;
#line 299
    p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 300
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
#line 301
    if (l_read_nb_bytes) {
#line 301
      tmp = l_read_nb_bytes;
    } else {
#line 301
      tmp = (OPJ_SIZE_T )-1;
    }
#line 301
    return (tmp);
  }
#line 305
  if (p_stream->m_bytes_in_buffer) {
    {
#line 306
    l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 307
    memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 308
    p_stream->m_current_data = p_stream->m_stored_data;
#line 309
    p_buffer += p_stream->m_bytes_in_buffer;
#line 310
    p_size -= p_stream->m_bytes_in_buffer;
#line 311
    p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 312
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
  } else {
#line 317
    p_stream->m_current_data = p_stream->m_stored_data;
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;

#line 322
    if (p_size < p_stream->m_buffer_size) {
      {
#line 324
      p_stream->m_bytes_in_buffer = (*(p_stream->m_read_fn))((void *)p_stream->m_stored_data,
                                                             p_stream->m_buffer_size,
                                                             p_stream->m_user_data);
      }
#line 327
      if (p_stream->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 329
        opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 331
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 332
        p_stream->m_status |= 4U;
        }
#line 334
        if (l_read_nb_bytes) {
#line 334
          tmp___0 = l_read_nb_bytes;
        } else {
#line 334
          tmp___0 = (OPJ_SIZE_T )-1;
        }
#line 334
        return (tmp___0);
      } else
#line 335
      if (p_stream->m_bytes_in_buffer < p_size) {
        {
#line 337
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 338
        memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 339
        p_stream->m_current_data = p_stream->m_stored_data;
#line 340
        p_buffer += p_stream->m_bytes_in_buffer;
#line 341
        p_size -= p_stream->m_bytes_in_buffer;
#line 342
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 343
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
        }
      } else {
        {
#line 345
        l_read_nb_bytes += p_size;
#line 346
        memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_size);
#line 347
        p_stream->m_current_data += p_size;
#line 348
        p_stream->m_bytes_in_buffer -= p_size;
#line 349
        p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
        }
#line 350
        return (l_read_nb_bytes);
      }
    } else {
      {
#line 354
      p_stream->m_bytes_in_buffer = (*(p_stream->m_read_fn))((void *)p_buffer, p_size,
                                                             p_stream->m_user_data);
      }
#line 357
      if (p_stream->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 359
        opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 361
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 362
        p_stream->m_status |= 4U;
        }
#line 364
        if (l_read_nb_bytes) {
#line 364
          tmp___1 = l_read_nb_bytes;
        } else {
#line 364
          tmp___1 = (OPJ_SIZE_T )-1;
        }
#line 364
        return (tmp___1);
      } else
#line 365
      if (p_stream->m_bytes_in_buffer < p_size) {
#line 367
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 368
        p_stream->m_current_data = p_stream->m_stored_data;
#line 369
        p_buffer += p_stream->m_bytes_in_buffer;
#line 370
        p_size -= p_stream->m_bytes_in_buffer;
#line 371
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 372
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
      } else {
#line 375
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 376
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 377
        p_stream->m_current_data = p_stream->m_stored_data;
#line 378
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 379
        return (l_read_nb_bytes);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 385
  return;
}
}
#line 385 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                 OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_remaining_bytes ;
  OPJ_SIZE_T l_write_nb_bytes ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 390
  l_remaining_bytes = (OPJ_SIZE_T )0;
#line 391
  l_write_nb_bytes = (OPJ_SIZE_T )0;
#line 393
  if (p_stream->m_status & 8U) {
#line 394
    return ((OPJ_SIZE_T )-1);
  }
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    l_remaining_bytes = p_stream->m_buffer_size - p_stream->m_bytes_in_buffer;
#line 401
    if (l_remaining_bytes >= p_size) {
      {
#line 402
      memcpy((void *)p_stream->m_current_data, (void const   *)p_buffer, p_size);
#line 404
      p_stream->m_current_data += p_size;
#line 405
      p_stream->m_bytes_in_buffer += p_size;
#line 406
      l_write_nb_bytes += p_size;
#line 407
      p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
      }
#line 409
      return (l_write_nb_bytes);
    }
#line 413
    if (l_remaining_bytes) {
      {
#line 414
      l_write_nb_bytes += l_remaining_bytes;
#line 416
      memcpy((void *)p_stream->m_current_data, (void const   *)p_buffer, l_remaining_bytes);
#line 418
      p_stream->m_current_data = p_stream->m_stored_data;
#line 420
      p_buffer += l_remaining_bytes;
#line 421
      p_size -= l_remaining_bytes;
#line 422
      p_stream->m_bytes_in_buffer += l_remaining_bytes;
#line 423
      p_stream->m_byte_offset += (OPJ_OFF_T )l_remaining_bytes;
      }
    }
    {
#line 426
    __cil_tmp7 = opj_stream_flush(p_stream, p_event_mgr);
    }
#line 426
    if (! __cil_tmp7) {
#line 427
      return ((OPJ_SIZE_T )-1);
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 432
  return;
}
}
#line 433 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_current_write_nb_bytes ;

  {
#line 437
  l_current_write_nb_bytes = (OPJ_SIZE_T )0;
#line 439
  p_stream->m_current_data = p_stream->m_stored_data;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;

#line 441
    if (! p_stream->m_bytes_in_buffer) {
#line 441
      goto while_break;
    }
    {
#line 443
    l_current_write_nb_bytes = (*(p_stream->m_write_fn))((void *)p_stream->m_current_data,
                                                         p_stream->m_bytes_in_buffer,
                                                         p_stream->m_user_data);
    }
#line 447
    if (l_current_write_nb_bytes == 0xffffffffffffffffUL) {
      {
#line 448
      p_stream->m_status |= 8U;
#line 449
      opj_event_msg(p_event_mgr, 4, "Error on writing stream!\n\312\3422 V");
      }
#line 451
      return (0);
    }
#line 454
    p_stream->m_current_data += l_current_write_nb_bytes;
#line 455
    p_stream->m_bytes_in_buffer -= l_current_write_nb_bytes;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 458
  p_stream->m_current_data = p_stream->m_stored_data;
#line 460
  return (1);
}
}
#line 463 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_OFF_T l_skip_nb_bytes ;
  OPJ_OFF_T l_current_skip_nb_bytes ;
  OPJ_OFF_T tmp___0 ;
  OPJ_OFF_T tmp___1 ;
  OPJ_OFF_T tmp___2 ;

  {
#line 466
  l_skip_nb_bytes = (OPJ_OFF_T )0;
#line 467
  l_current_skip_nb_bytes = (OPJ_OFF_T )0;
#line 471
  if (p_stream->m_bytes_in_buffer >= (OPJ_SIZE_T )p_size) {
#line 472
    p_stream->m_current_data += p_size;
#line 475
    p_stream->m_bytes_in_buffer -= (OPJ_SIZE_T )p_size;
#line 476
    l_skip_nb_bytes += p_size;
#line 477
    p_stream->m_byte_offset += l_skip_nb_bytes;
#line 478
    return (l_skip_nb_bytes);
  }
#line 482
  if (p_stream->m_status & 4U) {
#line 483
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 484
    p_stream->m_current_data += p_stream->m_bytes_in_buffer;
#line 485
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 486
    p_stream->m_byte_offset += l_skip_nb_bytes;
#line 487
    if (l_skip_nb_bytes) {
#line 487
      tmp___0 = l_skip_nb_bytes;
    } else {
#line 487
      tmp___0 = (OPJ_OFF_T )-1;
    }
#line 487
    return (tmp___0);
  }
#line 491
  if (p_stream->m_bytes_in_buffer) {
#line 492
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 493
    p_stream->m_current_data = p_stream->m_stored_data;
#line 494
    p_size -= (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 495
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
  }
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;

#line 498
    if (! (p_size > 0L)) {
#line 498
      goto while_break;
    }
#line 503
    if ((OPJ_UINT64 )((p_stream->m_byte_offset + l_skip_nb_bytes) + p_size) > p_stream->m_user_data_length) {
      {
#line 505
      opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 507
      p_stream->m_byte_offset += l_skip_nb_bytes;
#line 508
      l_skip_nb_bytes = (OPJ_OFF_T )(p_stream->m_user_data_length - (OPJ_UINT64 )p_stream->m_byte_offset);
#line 511
      opj_stream_read_seek(p_stream, (OPJ_OFF_T )p_stream->m_user_data_length, p_event_mgr);
#line 513
      p_stream->m_status |= 4U;
      }
#line 516
      if (l_skip_nb_bytes) {
#line 516
        tmp___1 = l_skip_nb_bytes;
      } else {
#line 516
        tmp___1 = (OPJ_OFF_T )-1;
      }
#line 516
      return (tmp___1);
    }
    {
#line 520
    l_current_skip_nb_bytes = (*(p_stream->m_skip_fn))(p_size, p_stream->m_user_data);
    }
#line 521
    if (l_current_skip_nb_bytes == -1L) {
      {
#line 522
      opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 524
      p_stream->m_status |= 4U;
#line 525
      p_stream->m_byte_offset += l_skip_nb_bytes;
      }
#line 527
      if (l_skip_nb_bytes) {
#line 527
        tmp___2 = l_skip_nb_bytes;
      } else {
#line 527
        tmp___2 = (OPJ_OFF_T )-1;
      }
#line 527
      return (tmp___2);
    }
#line 529
    p_size -= l_current_skip_nb_bytes;
#line 530
    l_skip_nb_bytes += l_current_skip_nb_bytes;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 533
  p_stream->m_byte_offset += l_skip_nb_bytes;
#line 535
  return (l_skip_nb_bytes);
}
}
#line 538 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                                opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL l_is_written ;
  OPJ_OFF_T l_current_skip_nb_bytes ;
  OPJ_OFF_T l_skip_nb_bytes ;
  OPJ_OFF_T tmp ;

  {
#line 541
  l_is_written = 0;
#line 542
  l_current_skip_nb_bytes = (OPJ_OFF_T )0;
#line 543
  l_skip_nb_bytes = (OPJ_OFF_T )0;
#line 545
  if (p_stream->m_status & 8U) {
#line 546
    return ((OPJ_OFF_T )-1);
  }
  {
#line 550
  l_is_written = opj_stream_flush(p_stream, p_event_mgr);
  }
#line 551
  if (! l_is_written) {
#line 552
    p_stream->m_status |= 8U;
#line 553
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 554
    return ((OPJ_OFF_T )-1);
  }
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;

#line 558
    if (! (p_size > 0L)) {
#line 558
      goto while_break;
    }
    {
#line 560
    l_current_skip_nb_bytes = (*(p_stream->m_skip_fn))(p_size, p_stream->m_user_data);
    }
#line 562
    if (l_current_skip_nb_bytes == -1L) {
      {
#line 563
      opj_event_msg(p_event_mgr, 4, "Stream error!\n");
#line 565
      p_stream->m_status |= 8U;
#line 566
      p_stream->m_byte_offset += l_skip_nb_bytes;
      }
#line 568
      if (l_skip_nb_bytes) {
#line 568
        tmp = l_skip_nb_bytes;
      } else {
#line 568
        tmp = (OPJ_OFF_T )-1;
      }
#line 568
      return (tmp);
    }
#line 570
    p_size -= l_current_skip_nb_bytes;
#line 571
    l_skip_nb_bytes += l_current_skip_nb_bytes;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 574
  p_stream->m_byte_offset += l_skip_nb_bytes;
#line 576
  return (l_skip_nb_bytes);
}
}
#line 579 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream ) 
{ 


  {
#line 581
  return (p_stream->m_byte_offset);
}
}
#line 584 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream ) 
{ 
  OPJ_OFF_T tmp___1 ;

  {
#line 588
  if (p_stream->m_user_data_length) {
#line 588
    tmp___1 = (OPJ_OFF_T )p_stream->m_user_data_length - p_stream->m_byte_offset;
  } else {
#line 588
    tmp___1 = 0L;
  }
#line 588
  return (tmp___1);
}
}
#line 593 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_OFF_T __cil_tmp5 ;

  {
  {
#line 597
  __cil_tmp5 = (*(p_stream->m_opj_skip))(p_stream, p_size, p_event_mgr);
  }
#line 597
  return (__cil_tmp5);
}
}
#line 600 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                              opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 604
  p_stream->m_current_data = p_stream->m_stored_data;
#line 605
  p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 607
  __cil_tmp4 = (*(p_stream->m_seek_fn))(p_size, p_stream->m_user_data);
  }
#line 607
  if (! __cil_tmp4) {
#line 608
    p_stream->m_status |= 4U;
#line 609
    return (0);
  } else {
#line 612
    p_stream->m_status &= 4294967291U;
#line 613
    p_stream->m_byte_offset = p_size;
  }
#line 617
  return (1);
}
}
#line 620 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 623
  __cil_tmp4 = opj_stream_flush(p_stream, p_event_mgr);
  }
#line 623
  if (! __cil_tmp4) {
#line 624
    p_stream->m_status |= 8U;
#line 625
    return (0);
  }
  {
#line 628
  p_stream->m_current_data = p_stream->m_stored_data;
#line 629
  p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 631
  __cil_tmp5 = (*(p_stream->m_seek_fn))(p_size, p_stream->m_user_data);
  }
#line 631
  if (! __cil_tmp5) {
#line 632
    p_stream->m_status |= 8U;
#line 633
    return (0);
  } else {
#line 635
    p_stream->m_byte_offset = p_size;
  }
#line 638
  return (1);
}
}
#line 641 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 645
  __cil_tmp5 = (*(p_stream->m_opj_seek))(p_stream, p_size, p_event_mgr);
  }
#line 645
  return (__cil_tmp5);
}
}
#line 648 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream ) 
{ 


  {
#line 650
  return ((unsigned long )p_stream->m_seek_fn != (unsigned long )(& opj_stream_default_seek));
}
}
#line 653 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_read(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 659
  return ((OPJ_SIZE_T )-1);
}
}
#line 662 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_write(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 668
  return ((OPJ_SIZE_T )-1);
}
}
#line 671 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 675
  return ((OPJ_OFF_T )-1);
}
}
#line 678 "/root/patron/new_24/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 682
  return (0);
}
}
#line 51 "/root/patron/new_24/src/lib/openjp2/bio.c"
static void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) ;
#line 57
static OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) ;
#line 63
static OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) ;
#line 69
static OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) ;
#line 81 "/root/patron/new_24/src/lib/openjp2/bio.c"
static OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 83
  bio->buf = (bio->buf << 8) & 65535U;
#line 84
  if (bio->buf == 65280U) {
#line 84
    tmp = 7;
  } else {
#line 84
    tmp = 8;
  }
#line 84
  bio->ct = (OPJ_UINT32 )tmp;
#line 85
  if ((OPJ_SIZE_T )bio->bp >= (OPJ_SIZE_T )bio->end) {
#line 86
    return (0);
  }
#line 88
  __cil_tmp3 = bio->bp;
#line 88
  (bio->bp) ++;
#line 88
  *__cil_tmp3 = (OPJ_BYTE )(bio->buf >> 8);
#line 89
  return (1);
}
}
#line 92 "/root/patron/new_24/src/lib/openjp2/bio.c"
static OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 94
  bio->buf = (bio->buf << 8) & 65535U;
#line 95
  if (bio->buf == 65280U) {
#line 95
    tmp = 7;
  } else {
#line 95
    tmp = 8;
  }
#line 95
  bio->ct = (OPJ_UINT32 )tmp;
#line 96
  if ((OPJ_SIZE_T )bio->bp >= (OPJ_SIZE_T )bio->end) {
#line 97
    return (0);
  }
#line 99
  __cil_tmp3 = bio->bp;
#line 99
  (bio->bp) ++;
#line 99
  bio->buf |= (unsigned int )*__cil_tmp3;
#line 100
  return (1);
}
}
#line 103 "/root/patron/new_24/src/lib/openjp2/bio.c"
static void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 105
  if (bio->ct == 0U) {
    {
#line 106
    opj_bio_byteout(bio);
    }
  }
#line 109
  __cil_tmp3 = bio->ct;
#line 109
  (bio->ct) --;
#line 110
  bio->buf |= b << bio->ct;
#line 111
  return;
}
}
#line 113 "/root/patron/new_24/src/lib/openjp2/bio.c"
static OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
#line 115
  if (bio->ct == 0U) {
    {
#line 116
    opj_bio_bytein(bio);
    }
  }
#line 119
  __cil_tmp2 = bio->ct;
#line 119
  (bio->ct) --;
#line 120
  return ((bio->buf >> bio->ct) & 1U);
}
}
#line 129 "/root/patron/new_24/src/lib/openjp2/bio.c"
opj_bio_t *opj_bio_create(void) 
{ 
  opj_bio_t *bio ;
  void *__cil_tmp2 ;

  {
  {
#line 131
  __cil_tmp2 = opj_malloc(sizeof(opj_bio_t ));
#line 131
  bio = (opj_bio_t *)__cil_tmp2;
  }
#line 132
  return (bio);
}
}
#line 135 "/root/patron/new_24/src/lib/openjp2/bio.c"
void opj_bio_destroy(opj_bio_t *bio ) 
{ 


  {
#line 137
  if (bio) {
    {
#line 138
    opj_free((void *)bio);
    }
  }
#line 141
  return;
}
}
#line 142 "/root/patron/new_24/src/lib/openjp2/bio.c"
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) 
{ 


  {
#line 144
  return (bio->bp - bio->start);
}
}
#line 147 "/root/patron/new_24/src/lib/openjp2/bio.c"
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 149
  bio->start = bp;
#line 150
  bio->end = bp + len;
#line 151
  bio->bp = bp;
#line 152
  bio->buf = (OPJ_UINT32 )0;
#line 153
  bio->ct = (OPJ_UINT32 )8;
#line 154
  return;
}
}
#line 156 "/root/patron/new_24/src/lib/openjp2/bio.c"
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 158
  bio->start = bp;
#line 159
  bio->end = bp + len;
#line 160
  bio->bp = bp;
#line 161
  bio->buf = (OPJ_UINT32 )0;
#line 162
  bio->ct = (OPJ_UINT32 )0;
#line 163
  return;
}
}
#line 165 "/root/patron/new_24/src/lib/openjp2/bio.c"
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 __cil_tmp6 ;

  {
#line 170
  i = (OPJ_INT32 )n - 1;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;

#line 170
    if (! (i >= 0)) {
#line 170
      goto while_break;
    }
    {
#line 171
    opj_bio_putbit(bio, (v >> i) & 1U);
#line 170
    __cil_tmp6 = i;
#line 170
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 174
  return;
}
}
#line 175 "/root/patron/new_24/src/lib/openjp2/bio.c"
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 
  OPJ_INT32 i ;
  OPJ_UINT32 v ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_INT32 __cil_tmp7 ;

  {
#line 187
  v = 0U;
#line 188
  i = (OPJ_INT32 )n - 1;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;

#line 188
    if (! (i >= 0)) {
#line 188
      goto while_break;
    }
    {
#line 189
    __cil_tmp6 = opj_bio_getbit(bio);
#line 189
    v |= __cil_tmp6 << i;
#line 188
    __cil_tmp7 = i;
#line 188
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 192
  return (v);
}
}
#line 195 "/root/patron/new_24/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 197
  __cil_tmp2 = opj_bio_byteout(bio);
  }
#line 197
  if (! __cil_tmp2) {
#line 198
    return (0);
  }
#line 200
  if (bio->ct == 7U) {
    {
#line 201
    __cil_tmp3 = opj_bio_byteout(bio);
    }
#line 201
    if (! __cil_tmp3) {
#line 202
      return (0);
    }
  }
#line 205
  return (1);
}
}
#line 208 "/root/patron/new_24/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;

  {
#line 210
  if ((bio->buf & 255U) == 255U) {
    {
#line 211
    __cil_tmp2 = opj_bio_bytein(bio);
    }
#line 211
    if (! __cil_tmp2) {
#line 212
      return (0);
    }
  }
#line 215
  bio->ct = (OPJ_UINT32 )0;
#line 216
  return (1);
}
}
#line 47 "/root/patron/new_24/src/bin/jp2/index.h"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) ;
#line 49 "/root/patron/new_24/src/bin/jp2/index.c"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int resno ;
  int precno ;
  int pack_nb ;
  int x ;
  int y ;
  FILE *stream ;
  double total_disto ;
  int tilepartno ;
  char disto_on ;
  char numpix_on ;
  int __cil_tmp17 ;
  OPJ_OFF_T start_pos ;
  OPJ_OFF_T end_ph_pos ;
  OPJ_OFF_T end_pos ;
  double disto ;
  int max_numdecompos ;
  int prec_max ;
  int prec_max___0 ;
  int numprec ;
  int x0 ;
  double __cil_tmp40 ;
  int y0___42 ;
  double __cil_tmp42 ;
  int x1 ;
  int y1___43 ;
  int pcnx ;
  int pcx ;
  double __cil_tmp47 ;
  int pcy ;
  double __cil_tmp49 ;
  int precno_x ;
  double __cil_tmp51 ;
  int precno_y ;
  double __cil_tmp53 ;
  int x0___0 ;
  double __cil_tmp62 ;
  int y0___44 ;
  double __cil_tmp64 ;
  int x1___0 ;
  int y1___45 ;
  int max_numprec ;
  int numprec___0 ;
  int numprec___1 ;
  int pcnx___0 ;
  int pcx___0 ;
  double __cil_tmp73 ;
  int pcy___0 ;
  double __cil_tmp75 ;
  int precno_x___0 ;
  double __cil_tmp77 ;
  int precno_y___0 ;
  double __cil_tmp79 ;
  int max_numprec___0 ;
  int numprec___2 ;
  int x0___1 ;
  double __cil_tmp91 ;
  int y0___46 ;
  double __cil_tmp93 ;
  int x1___1 ;
  int y1___47 ;
  int numprec___3 ;
  int pcnx___1 ;
  int pcx___1 ;
  double __cil_tmp99 ;
  int pcy___1 ;
  double __cil_tmp101 ;
  int precno_x___1 ;
  double __cil_tmp103 ;
  int precno_y___1 ;
  double __cil_tmp105 ;

  {
#line 52
  stream = (FILE *)((void *)0);
#line 53
  total_disto = (double )0;
#line 65
  if (! cstr_info) {
#line 66
    return (1);
  }
  {
#line 69
  stream = fopen((char const   *)index___0, "w");
  }
#line 70
  if (! stream) {
    {
#line 71
    fprintf(stderr, "failed to open index file [%s] for writing\n", index___0);
    }
#line 72
    return (1);
  }
#line 75
  if ((cstr_info->tile + 0)->distotile > 0.) {
#line 76
    disto_on = (char)1;
  } else {
#line 78
    disto_on = (char)0;
  }
#line 81
  if ((cstr_info->tile + 0)->numpix) {
#line 82
    numpix_on = (char)1;
  } else {
#line 84
    numpix_on = (char)0;
  }
  {
#line 87
  fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
#line 88
  fprintf(stream, "%d\n", (int )cstr_info->prog);
#line 89
  fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
#line 90
  fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
#line 91
  fprintf(stream, "%d\n", cstr_info->numcomps);
#line 92
  fprintf(stream, "%d\n", cstr_info->numlayers);
#line 93
  fprintf(stream, "%d\n", *(cstr_info->numdecompos + 0));
#line 95
  resno = *(cstr_info->numdecompos + 0);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;

#line 95
    if (! (resno >= 0)) {
#line 95
      goto while_break;
    }
    {
#line 96
    fprintf(stream, "[%d,%d] \251", 1 << (cstr_info->tile + 0)->pdx[resno], 1 << (cstr_info->tile + 0)->pdx[resno]);
#line 95
    __cil_tmp17 = resno;
#line 95
    resno --;
    }
  }
  while_break___33: /* CIL Label */ ;
  }
  while_break: 
  {
#line 101
  fprintf(stream, "\n");
#line 103
  fprintf(stream, "%d\n", cstr_info->main_head_start);
#line 105
  fprintf(stream, "%d\n", cstr_info->main_head_end);
#line 106
  fprintf(stream, "%d\n", cstr_info->codestream_size);
#line 108
  fprintf(stream, "\nINFO ON TILES\n");
#line 109
  fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
  }
#line 110
  if (disto_on) {
    {
#line 111
    fprintf(stream, "         disto");
    }
  }
#line 113
  if (numpix_on) {
    {
#line 114
    fprintf(stream, "     nbpix");
    }
  }
#line 116
  if ((int )disto_on) {
#line 116
    if ((int )numpix_on) {
      {
#line 117
      fprintf(stream, "  disto/nbpix");
      }
    }
  }
  {
#line 119
  fprintf(stream, "\n");
#line 121
  tileno = 0;
  }
  {
#line 121
  while (1) {
    while_continue___29: /* CIL Label */ ;

#line 121
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 121
      goto while_break___0;
    }
    {
#line 122
    fprintf(stream, "%4d %9d %9d %9d %9d", (cstr_info->tile + tileno)->tileno, (cstr_info->tile + tileno)->start_pos,
            (cstr_info->tile + tileno)->end_header, (cstr_info->tile + tileno)->end_pos,
            (cstr_info->tile + tileno)->num_tps);
    }
#line 128
    if (disto_on) {
      {
#line 129
      fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile);
      }
    }
#line 131
    if (numpix_on) {
      {
#line 132
      fprintf(stream, " %9d", (cstr_info->tile + tileno)->numpix);
      }
    }
#line 134
    if ((int )disto_on) {
#line 134
      if ((int )numpix_on) {
        {
#line 135
        fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile / (double )(cstr_info->tile + tileno)->numpix);
        }
      }
    }
    {
#line 138
    fprintf(stream, "\n");
#line 121
    tileno ++;
    }
  }
  while_break___34: /* CIL Label */ ;
  }
  while_break___0: 
#line 141
  tileno = 0;
  {
#line 141
  while (1) {
    while_continue___30: /* CIL Label */ ;

#line 141
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 141
      goto while_break___1;
    }
#line 143
    disto = (double )0;
#line 144
    max_numdecompos = 0;
#line 145
    pack_nb = 0;
#line 147
    compno = 0;
    {
#line 147
    while (1) {
      while_continue___31: /* CIL Label */ ;

#line 147
      if (! (compno < cstr_info->numcomps)) {
#line 147
        goto while_break___2;
      }
#line 148
      if (max_numdecompos < *(cstr_info->numdecompos + compno)) {
#line 149
        max_numdecompos = *(cstr_info->numdecompos + compno);
      }
#line 147
      compno ++;
    }
    while_break___36: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 153
    fprintf(stream, "\nTILE %d DETAILS\n", tileno);
#line 154
    fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
#line 156
    tilepartno = 0;
    }
    {
#line 156
    while (1) {
      while_continue___32: /* CIL Label */ ;

#line 156
      if (! (tilepartno < (cstr_info->tile + tileno)->num_tps)) {
#line 156
        goto while_break___3;
      }
      {
#line 157
      fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n\230\001", tilepartno, tileno,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pack, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_numpacks,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pos, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_header,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_pos);
#line 156
      tilepartno ++;
      }
    }
    while_break___37: /* CIL Label */ ;
    }
    while_break___3: ;
#line 166
    if ((int )cstr_info->prog == 0) {
      {
#line 167
      fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
      }
#line 169
      if (disto_on) {
        {
#line 170
        fprintf(stream, " disto");
        }
      }
      {
#line 172
      fprintf(stream, "\n");
#line 174
      layno = 0;
      }
      {
#line 174
      while (1) {
        while_continue___33: /* CIL Label */ ;

#line 174
        if (! (layno < cstr_info->numlayers)) {
#line 174
          goto while_break___4;
        }
#line 175
        resno = 0;
        {
#line 175
        while (1) {
          while_continue___34: /* CIL Label */ ;

#line 175
          if (! (resno < max_numdecompos + 1)) {
#line 175
            goto while_break___5;
          }
#line 176
          compno = 0;
          {
#line 176
          while (1) {
            while_continue___35: /* CIL Label */ ;

#line 176
            if (! (compno < cstr_info->numcomps)) {
#line 176
              goto while_break___6;
            }
#line 178
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 179
              goto while_break___6;
            }
#line 181
            prec_max = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 183
            precno = 0;
            {
#line 183
            while (1) {
              while_continue___36: /* CIL Label */ ;

#line 183
              if (! (precno < prec_max)) {
#line 183
                goto while_break___7;
              }
              {
#line 184
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 185
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 186
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 187
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 188
              fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6ld     %6ld %7ld", pack_nb,
                      tileno, layno, resno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 191
              if (disto_on) {
                {
#line 192
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 194
              fprintf(stream, "\n");
#line 195
              total_disto += disto;
#line 196
              pack_nb ++;
#line 183
              precno ++;
              }
            }
            while_break___41: /* CIL Label */ ;
            }
            while_break___7: 
#line 176
            compno ++;
          }
          while_break___40: /* CIL Label */ ;
          }
          while_break___6: 
#line 175
          resno ++;
        }
        while_break___39: /* CIL Label */ ;
        }
        while_break___5: 
#line 174
        layno ++;
      }
      while_break___38: /* CIL Label */ ;
      }
      while_break___4: ;
    } else
#line 203
    if ((int )cstr_info->prog == 1) {
      {
#line 204
      fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
      }
#line 206
      if (disto_on) {
        {
#line 207
        fprintf(stream, " disto");
        }
      }
      {
#line 209
      fprintf(stream, "\n");
#line 211
      resno = 0;
      }
      {
#line 211
      while (1) {
        while_continue___37: /* CIL Label */ ;

#line 211
        if (! (resno < max_numdecompos + 1)) {
#line 211
          goto while_break___8;
        }
#line 212
        layno = 0;
        {
#line 212
        while (1) {
          while_continue___38: /* CIL Label */ ;

#line 212
          if (! (layno < cstr_info->numlayers)) {
#line 212
            goto while_break___9;
          }
#line 213
          compno = 0;
          {
#line 213
          while (1) {
            while_continue___39: /* CIL Label */ ;

#line 213
            if (! (compno < cstr_info->numcomps)) {
#line 213
              goto while_break___10;
            }
#line 215
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 216
              goto while_break___10;
            }
#line 218
            prec_max___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 220
            precno = 0;
            {
#line 220
            while (1) {
              while_continue___40: /* CIL Label */ ;

#line 220
              if (! (precno < prec_max___0)) {
#line 220
                goto while_break___11;
              }
              {
#line 221
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 222
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 223
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 224
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 225
              fprintf(stream, "%4d %6d %5d %7d %6d %6d %9ld   %9ld %7ld\230\001",
                      pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 227
              if (disto_on) {
                {
#line 228
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 230
              fprintf(stream, "\n");
#line 231
              total_disto += disto;
#line 232
              pack_nb ++;
#line 220
              precno ++;
              }
            }
            while_break___45: /* CIL Label */ ;
            }
            while_break___11: 
#line 213
            compno ++;
          }
          while_break___44: /* CIL Label */ ;
          }
          while_break___10: 
#line 212
          layno ++;
        }
        while_break___43: /* CIL Label */ ;
        }
        while_break___9: 
#line 211
        resno ++;
      }
      while_break___42: /* CIL Label */ ;
      }
      while_break___8: ;
    } else
#line 239
    if ((int )cstr_info->prog == 2) {
      {
#line 241
      fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos");
      }
#line 243
      if (disto_on) {
        {
#line 244
        fprintf(stream, " disto");
        }
      }
      {
#line 246
      fprintf(stream, "\n");
#line 248
      resno = 0;
      }
      {
#line 248
      while (1) {
        while_continue___41: /* CIL Label */ ;

#line 248
        if (! (resno < max_numdecompos + 1)) {
#line 248
          goto while_break___12;
        }
#line 249
        numprec = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 251
        precno = 0;
        {
#line 251
        while (1) {
          while_continue___42: /* CIL Label */ ;

#line 251
          if (! (precno < numprec)) {
#line 251
            goto while_break___13;
          }
          {
#line 253
          __cil_tmp40 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 253
          x0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp40 * cstr_info->tw) * cstr_info->tile_x;
#line 255
          __cil_tmp42 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 255
          y0___42 = cstr_info->tile_Ox + (int )__cil_tmp42 * cstr_info->tile_y;
#line 257
          x1 = x0 + cstr_info->tile_x;
#line 258
          y1___43 = y0___42 + cstr_info->tile_y;
#line 259
          compno = 0;
          }
          {
#line 259
          while (1) {
            while_continue___43: /* CIL Label */ ;

#line 259
            if (! (compno < cstr_info->numcomps)) {
#line 259
              goto while_break___14;
            }
            {
#line 260
            pcnx = (cstr_info->tile + tileno)->pw[resno];
#line 261
            __cil_tmp47 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 261
            pcx = (int )__cil_tmp47;
#line 263
            __cil_tmp49 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 263
            pcy = (int )__cil_tmp49;
#line 265
            __cil_tmp51 = floor((double )((float )precno / (float )pcnx));
#line 265
            precno_x = precno - (int )__cil_tmp51 * pcnx;
#line 266
            __cil_tmp53 = floor((double )((float )precno / (float )pcnx));
#line 266
            precno_y = (int )__cil_tmp53;
            }
#line 267
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 268
              goto while_break___14;
            }
#line 270
            y = y0___42;
            {
#line 270
            while (1) {
              while_continue___44: /* CIL Label */ ;

#line 270
              if (! (y < y1___43)) {
#line 270
                goto while_break___15;
              }
#line 271
              if (precno_y * pcy == y) {
#line 272
                x = x0;
                {
#line 272
                while (1) {
                  while_continue___45: /* CIL Label */ ;

#line 272
                  if (! (x < x1)) {
#line 272
                    goto while_break___16;
                  }
#line 273
                  if (precno_x * pcx == x) {
#line 274
                    layno = 0;
                    {
#line 274
                    while (1) {
                      while_continue___46: /* CIL Label */ ;

#line 274
                      if (! (layno < cstr_info->numlayers)) {
#line 274
                        goto while_break___17;
                      }
                      {
#line 275
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 276
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 277
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 278
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 279
                      fprintf(stream, "%4d %6d %5d %6d %6d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, resno, precno, compno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 281
                      if (disto_on) {
                        {
#line 282
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 284
                      fprintf(stream, "\n");
#line 285
                      total_disto += disto;
#line 286
                      pack_nb ++;
#line 274
                      layno ++;
                      }
                    }
                    while_break___51: /* CIL Label */ ;
                    }
                    while_break___17: ;
                  }
#line 272
                  x ++;
                }
                while_break___50: /* CIL Label */ ;
                }
                while_break___16: ;
              }
#line 270
              y ++;
            }
            while_break___49: /* CIL Label */ ;
            }
            while_break___15: 
#line 259
            compno ++;
          }
          while_break___48: /* CIL Label */ ;
          }
          while_break___14: 
#line 251
          precno ++;
        }
        while_break___47: /* CIL Label */ ;
        }
        while_break___13: 
#line 248
        resno ++;
      }
      while_break___46: /* CIL Label */ ;
      }
      while_break___12: ;
    } else
#line 297
    if ((int )cstr_info->prog == 3) {
      {
#line 299
      __cil_tmp62 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 299
      x0___0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp62 * cstr_info->tw) * cstr_info->tile_x;
#line 301
      __cil_tmp64 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 301
      y0___44 = cstr_info->tile_Ox + (int )__cil_tmp64 * cstr_info->tile_y;
#line 303
      x1___0 = x0___0 + cstr_info->tile_x;
#line 304
      y1___45 = y0___44 + cstr_info->tile_y;
#line 307
      max_numprec = 0;
#line 308
      resno = 0;
      }
      {
#line 308
      while (1) {
        while_continue___47: /* CIL Label */ ;

#line 308
        if (! (resno < max_numdecompos + 1)) {
#line 308
          goto while_break___18;
        }
#line 309
        numprec___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 311
        if (numprec___0 > max_numprec) {
#line 312
          max_numprec = numprec___0;
        }
#line 308
        resno ++;
      }
      while_break___52: /* CIL Label */ ;
      }
      while_break___18: 
      {
#line 316
      fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos");
      }
#line 318
      if (disto_on) {
        {
#line 319
        fprintf(stream, " disto");
        }
      }
      {
#line 321
      fprintf(stream, "\n");
#line 323
      precno = 0;
      }
      {
#line 323
      while (1) {
        while_continue___48: /* CIL Label */ ;

#line 323
        if (! (precno < max_numprec)) {
#line 323
          goto while_break___19;
        }
#line 324
        compno = 0;
        {
#line 324
        while (1) {
          while_continue___49: /* CIL Label */ ;

#line 324
          if (! (compno < cstr_info->numcomps)) {
#line 324
            goto while_break___20;
          }
#line 325
          resno = 0;
          {
#line 325
          while (1) {
            while_continue___50: /* CIL Label */ ;
            while_continue___21: ;
#line 325
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 325
              goto while_break___21;
            }
            {
#line 326
            numprec___1 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 328
            pcnx___0 = (cstr_info->tile + tileno)->pw[resno];
#line 329
            __cil_tmp73 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 329
            pcx___0 = (int )__cil_tmp73;
#line 331
            __cil_tmp75 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 331
            pcy___0 = (int )__cil_tmp75;
#line 333
            __cil_tmp77 = floor((double )((float )precno / (float )pcnx___0));
#line 333
            precno_x___0 = precno - (int )__cil_tmp77 * pcnx___0;
#line 334
            __cil_tmp79 = floor((double )((float )precno / (float )pcnx___0));
#line 334
            precno_y___0 = (int )__cil_tmp79;
            }
#line 335
            if (precno >= numprec___1) {
#line 336
              goto while_continue___21;
            }
#line 338
            y = y0___44;
            {
#line 338
            while (1) {
              while_continue___51: /* CIL Label */ ;

#line 338
              if (! (y < y1___45)) {
#line 338
                goto while_break___22;
              }
#line 339
              if (precno_y___0 * pcy___0 == y) {
#line 340
                x = x0___0;
                {
#line 340
                while (1) {
                  while_continue___52: /* CIL Label */ ;

#line 340
                  if (! (x < x1___0)) {
#line 340
                    goto while_break___23;
                  }
#line 341
                  if (precno_x___0 * pcx___0 == x) {
#line 342
                    layno = 0;
                    {
#line 342
                    while (1) {
                      while_continue___53: /* CIL Label */ ;

#line 342
                      if (! (layno < cstr_info->numlayers)) {
#line 342
                        goto while_break___24;
                      }
                      {
#line 343
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 344
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 345
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 346
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 347
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, precno, compno, resno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 349
                      if (disto_on) {
                        {
#line 350
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 352
                      fprintf(stream, "\n");
#line 353
                      total_disto += disto;
#line 354
                      pack_nb ++;
#line 342
                      layno ++;
                      }
                    }
                    while_break___58: /* CIL Label */ ;
                    }
                    while_break___24: ;
                  }
#line 340
                  x ++;
                }
                while_break___57: /* CIL Label */ ;
                }
                while_break___23: ;
              }
#line 338
              y ++;
            }
            while_break___56: /* CIL Label */ ;
            }
            while_break___22: 
#line 325
            resno ++;
          }
          while_break___55: /* CIL Label */ ;
          }
          while_break___21: 
#line 324
          compno ++;
        }
        while_break___54: /* CIL Label */ ;
        }
        while_break___20: 
#line 323
        precno ++;
      }
      while_break___53: /* CIL Label */ ;
      }
      while_break___19: ;
    } else {
#line 367
      max_numprec___0 = 0;
#line 368
      resno = 0;
      {
#line 368
      while (1) {
        while_continue___54: /* CIL Label */ ;

#line 368
        if (! (resno < max_numdecompos + 1)) {
#line 368
          goto while_break___25;
        }
#line 369
        numprec___2 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 371
        if (numprec___2 > max_numprec___0) {
#line 372
          max_numprec___0 = numprec___2;
        }
#line 368
        resno ++;
      }
      while_break___59: /* CIL Label */ ;
      }
      while_break___25: 
      {
#line 376
      fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos");
      }
#line 378
      if (disto_on) {
        {
#line 379
        fprintf(stream, " disto");
        }
      }
      {
#line 381
      fprintf(stream, "\n");
#line 383
      compno = 0;
      }
      {
#line 383
      while (1) {
        while_continue___55: /* CIL Label */ ;

#line 383
        if (! (compno < cstr_info->numcomps)) {
#line 383
          goto while_break___26;
        }
        {
#line 385
        __cil_tmp91 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 385
        x0___1 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp91 * cstr_info->tw) * cstr_info->tile_x;
#line 387
        __cil_tmp93 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 387
        y0___46 = cstr_info->tile_Ox + (int )__cil_tmp93 * cstr_info->tile_y;
#line 389
        x1___1 = x0___1 + cstr_info->tile_x;
#line 390
        y1___47 = y0___46 + cstr_info->tile_y;
#line 392
        precno = 0;
        }
        {
#line 392
        while (1) {
          while_continue___56: /* CIL Label */ ;

#line 392
          if (! (precno < max_numprec___0)) {
#line 392
            goto while_break___27;
          }
#line 393
          resno = 0;
          {
#line 393
          while (1) {
            while_continue___57: /* CIL Label */ ;
            while_continue___28: ;
#line 393
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 393
              goto while_break___28;
            }
            {
#line 394
            numprec___3 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 396
            pcnx___1 = (cstr_info->tile + tileno)->pw[resno];
#line 397
            __cil_tmp99 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 397
            pcx___1 = (int )__cil_tmp99;
#line 399
            __cil_tmp101 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 399
            pcy___1 = (int )__cil_tmp101;
#line 401
            __cil_tmp103 = floor((double )((float )precno / (float )pcnx___1));
#line 401
            precno_x___1 = precno - (int )__cil_tmp103 * pcnx___1;
#line 402
            __cil_tmp105 = floor((double )((float )precno / (float )pcnx___1));
#line 402
            precno_y___1 = (int )__cil_tmp105;
            }
#line 403
            if (precno >= numprec___3) {
#line 404
              goto while_continue___28;
            }
#line 407
            y = y0___46;
            {
#line 407
            while (1) {
              while_continue___58: /* CIL Label */ ;

#line 407
              if (! (y < y1___47)) {
#line 407
                goto while_break___29;
              }
#line 408
              if (precno_y___1 * pcy___1 == y) {
#line 409
                x = x0___1;
                {
#line 409
                while (1) {
                  while_continue___59: /* CIL Label */ ;

#line 409
                  if (! (x < x1___1)) {
#line 409
                    goto while_break___30;
                  }
#line 410
                  if (precno_x___1 * pcx___1 == x) {
#line 411
                    layno = 0;
                    {
#line 411
                    while (1) {
                      while_continue___60: /* CIL Label */ ;

#line 411
                      if (! (layno < cstr_info->numlayers)) {
#line 411
                        goto while_break___31;
                      }
                      {
#line 412
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 413
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 414
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 415
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 416
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, compno, precno, resno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 418
                      if (disto_on) {
                        {
#line 419
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 421
                      fprintf(stream, "\n");
#line 422
                      total_disto += disto;
#line 423
                      pack_nb ++;
#line 411
                      layno ++;
                      }
                    }
                    while_break___65: /* CIL Label */ ;
                    }
                    while_break___31: ;
                  }
#line 409
                  x ++;
                }
                while_break___64: /* CIL Label */ ;
                }
                while_break___30: ;
              }
#line 407
              y ++;
            }
            while_break___63: /* CIL Label */ ;
            }
            while_break___29: 
#line 393
            resno ++;
          }
          while_break___62: /* CIL Label */ ;
          }
          while_break___28: 
#line 392
          precno ++;
        }
        while_break___61: /* CIL Label */ ;
        }
        while_break___27: 
#line 383
        compno ++;
      }
      while_break___60: /* CIL Label */ ;
      }
      while_break___26: ;
    }
#line 141
    tileno ++;
  }
  while_break___35: /* CIL Label */ ;
  }
  while_break___1: ;
#line 435
  if (disto_on) {
    {
#line 436
    fprintf(stream, "%8e\n", cstr_info->D_max);
#line 437
    fprintf(stream, "%.8e\n", total_disto);
    }
  }
#line 441
  if (cstr_info->marknum) {
    {
#line 442
    fprintf(stream, "\nMARKER LIST\n");
#line 443
    fprintf(stream, "%d\n", cstr_info->marknum);
#line 444
    fprintf(stream, "type\tstart_pos    length\n");
#line 445
    x = 0;
    }
    {
#line 445
    while (1) {
      while_continue___61: /* CIL Label */ ;

#line 445
      if (! (x < cstr_info->marknum)) {
#line 445
        goto while_break___32;
      }
      {
#line 446
      fprintf(stream, "%X\t%9ld %9d\n\230\001", (int )(cstr_info->marker + x)->type,
              (cstr_info->marker + x)->pos, (cstr_info->marker + x)->len);
#line 445
      x ++;
      }
    }
    while_break___66: /* CIL Label */ ;
    }
    while_break___32: ;
  }
  {
#line 451
  fclose(stream);
#line 453
  fprintf(stderr, "Generated index file %s\n\230\001", index___0);
  }
#line 455
  return (0);
}
}
#line 299 "/usr/include/x86_64-linux-gnu/tiffio.h"
extern void _TIFFfree(void *p ) ;
#line 343
extern void TIFFClose(TIFF *tif ) ;
#line 346
extern int TIFFGetField(TIFF *tif , uint32 tag  , ...) ;
#line 358
extern tmsize_t TIFFStripSize(TIFF *tif ) ;
#line 407
extern int TIFFSetField(TIFF * , uint32   , ...) ;
#line 440
extern TIFF *TIFFOpen(char const   * , char const   * ) ;
#line 469
extern tmsize_t TIFFReadEncodedStrip(TIFF *tif , uint32 strip , void *buf , tmsize_t size ) ;
#line 476
extern tmsize_t TIFFWriteEncodedStrip(TIFF *tif , uint32 strip , void *data , tmsize_t cc ) ;
#line 69 "/root/patron/new_24/src/bin/jp2/convert.h"
void clip_component(opj_image_comp_t *component , OPJ_UINT32 precision ) ;
#line 71
void scale_component(opj_image_comp_t *component , OPJ_UINT32 precision ) ;
#line 76
convert_32s_CXPX convert_32s_CXPX_LUT[5] ;
#line 79
convert_32s_PXCX convert_32s_PXCX_LUT[5] ;
#line 83
convert_XXx32s_C1R convert_XXu32s_C1R_LUT[9] ;
#line 86
convert_32sXXx_C1R convert_32sXXu_C1R_LUT[9] ;
#line 90
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 91
int imagetotga(opj_image_t *image , char const   *outfile ) ;
#line 94
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 95
int imagetobmp(opj_image_t *image , char const   *outfile ) ;
#line 98
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 99
int imagetotif(opj_image_t *image , char const   *outfile ) ;
#line 106
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 107
int imagetopgx(opj_image_t *image , char const   *outfile ) ;
#line 109
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 110
int imagetopnm(opj_image_t *image , char const   *outfile , int force_split ) ;
#line 113
int imagetoraw(opj_image_t *image , char const   *outfile ) ;
#line 114
int imagetorawl(opj_image_t *image , char const   *outfile ) ;
#line 115
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) ;
#line 117
opj_image_t *rawltoimage(char const   *filename , opj_cparameters_t *parameters ,
                         raw_cparameters_t *raw_cp ) ;
#line 121
int imagetopng(opj_image_t *image , char const   *write_idf ) ;
#line 122
opj_image_t *pngtoimage(char const   *read_idf , opj_cparameters_t *params ) ;
#line 88 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_32sto3u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;

  {
#line 93
  i = (OPJ_SIZE_T )0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;

#line 93
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 93
      goto while_break;
    }
#line 94
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 95
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 96
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 97
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 98
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 99
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 100
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 101
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 103
    __cil_tmp13 = pDst;
#line 103
    pDst ++;
#line 103
    *__cil_tmp13 = (OPJ_BYTE )(((src0 << 5) | (src1 << 2)) | (src2 >> 1));
#line 104
    __cil_tmp14 = pDst;
#line 104
    pDst ++;
#line 104
    *__cil_tmp14 = (OPJ_BYTE )((((src2 << 7) | (src3 << 4)) | (src4 << 1)) | (src5 >> 2));
#line 105
    __cil_tmp15 = pDst;
#line 105
    pDst ++;
#line 105
    *__cil_tmp15 = (OPJ_BYTE )(((src5 << 6) | (src6 << 3)) | src7);
#line 93
    i += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 108
  if (length & 7UL) {
#line 109
    trailing = 0U;
#line 110
    remaining = 8;
#line 111
    length &= 7UL;
#line 112
    if (3 >= remaining) {
#line 112
      trailing <<= remaining;
#line 112
      trailing |= (OPJ_UINT32 )*(pSrc + i) >> (3 - remaining);
#line 112
      __cil_tmp18 = pDst;
#line 112
      pDst ++;
#line 112
      *__cil_tmp18 = (OPJ_BYTE )trailing;
#line 112
      trailing = (OPJ_UINT32 )*(pSrc + i) & ((1U << (3 - remaining)) - 1U);
#line 112
      if (3 >= remaining + 8) {
#line 112
        __cil_tmp19 = pDst;
#line 112
        pDst ++;
#line 112
        *__cil_tmp19 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 112
        trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 112
        remaining += 13;
      } else {
#line 112
        remaining += 5;
      }
    } else {
#line 112
      trailing <<= 3;
#line 112
      trailing |= (OPJ_UINT32 )*(pSrc + i);
#line 112
      remaining -= 3;
    }
#line 113
    if (length > 1UL) {
#line 114
      if (3 >= remaining) {
#line 114
        trailing <<= remaining;
#line 114
        trailing |= (OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (3 - remaining);
#line 114
        __cil_tmp20 = pDst;
#line 114
        pDst ++;
#line 114
        *__cil_tmp20 = (OPJ_BYTE )trailing;
#line 114
        trailing = (OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (3 - remaining)) - 1U);
#line 114
        if (3 >= remaining + 8) {
#line 114
          __cil_tmp21 = pDst;
#line 114
          pDst ++;
#line 114
          *__cil_tmp21 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 114
          trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 114
          remaining += 13;
        } else {
#line 114
          remaining += 5;
        }
      } else {
#line 114
        trailing <<= 3;
#line 114
        trailing |= (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 114
        remaining -= 3;
      }
#line 115
      if (length > 2UL) {
#line 116
        if (3 >= remaining) {
#line 116
          trailing <<= remaining;
#line 116
          trailing |= (OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (3 - remaining);
#line 116
          __cil_tmp22 = pDst;
#line 116
          pDst ++;
#line 116
          *__cil_tmp22 = (OPJ_BYTE )trailing;
#line 116
          trailing = (OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (3 - remaining)) - 1U);
#line 116
          if (3 >= remaining + 8) {
#line 116
            __cil_tmp23 = pDst;
#line 116
            pDst ++;
#line 116
            *__cil_tmp23 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 116
            trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 116
            remaining += 13;
          } else {
#line 116
            remaining += 5;
          }
        } else {
#line 116
          trailing <<= 3;
#line 116
          trailing |= (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 116
          remaining -= 3;
        }
#line 117
        if (length > 3UL) {
#line 118
          if (3 >= remaining) {
#line 118
            trailing <<= remaining;
#line 118
            trailing |= (OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (3 - remaining);
#line 118
            __cil_tmp24 = pDst;
#line 118
            pDst ++;
#line 118
            *__cil_tmp24 = (OPJ_BYTE )trailing;
#line 118
            trailing = (OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (3 - remaining)) - 1U);
#line 118
            if (3 >= remaining + 8) {
#line 118
              __cil_tmp25 = pDst;
#line 118
              pDst ++;
#line 118
              *__cil_tmp25 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 118
              trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 118
              remaining += 13;
            } else {
#line 118
              remaining += 5;
            }
          } else {
#line 118
            trailing <<= 3;
#line 118
            trailing |= (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 118
            remaining -= 3;
          }
#line 119
          if (length > 4UL) {
#line 120
            if (3 >= remaining) {
#line 120
              trailing <<= remaining;
#line 120
              trailing |= (OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (3 - remaining);
#line 120
              __cil_tmp26 = pDst;
#line 120
              pDst ++;
#line 120
              *__cil_tmp26 = (OPJ_BYTE )trailing;
#line 120
              trailing = (OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (3 - remaining)) - 1U);
#line 120
              if (3 >= remaining + 8) {
#line 120
                __cil_tmp27 = pDst;
#line 120
                pDst ++;
#line 120
                *__cil_tmp27 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 120
                trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 120
                remaining += 13;
              } else {
#line 120
                remaining += 5;
              }
            } else {
#line 120
              trailing <<= 3;
#line 120
              trailing |= (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 120
              remaining -= 3;
            }
#line 121
            if (length > 5UL) {
#line 122
              if (3 >= remaining) {
#line 122
                trailing <<= remaining;
#line 122
                trailing |= (OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (3 - remaining);
#line 122
                __cil_tmp28 = pDst;
#line 122
                pDst ++;
#line 122
                *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 122
                trailing = (OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (3 - remaining)) - 1U);
#line 122
                if (3 >= remaining + 8) {
#line 122
                  __cil_tmp29 = pDst;
#line 122
                  pDst ++;
#line 122
                  *__cil_tmp29 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 122
                  trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 122
                  remaining += 13;
                } else {
#line 122
                  remaining += 5;
                }
              } else {
#line 122
                trailing <<= 3;
#line 122
                trailing |= (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 122
                remaining -= 3;
              }
#line 123
              if (length > 6UL) {
#line 124
                if (3 >= remaining) {
#line 124
                  trailing <<= remaining;
#line 124
                  trailing |= (OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (3 - remaining);
#line 124
                  __cil_tmp30 = pDst;
#line 124
                  pDst ++;
#line 124
                  *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 124
                  trailing = (OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (3 - remaining)) - 1U);
#line 124
                  if (3 >= remaining + 8) {
#line 124
                    __cil_tmp31 = pDst;
#line 124
                    pDst ++;
#line 124
                    *__cil_tmp31 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 124
                    trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 124
                    remaining += 13;
                  } else {
#line 124
                    remaining += 5;
                  }
                } else {
#line 124
                  trailing <<= 3;
#line 124
                  trailing |= (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 124
                  remaining -= 3;
                }
              }
            }
          }
        }
      }
    }
#line 131
    if (remaining != 8) {
#line 131
      trailing <<= remaining;
#line 131
      __cil_tmp32 = pDst;
#line 131
      pDst ++;
#line 131
      *__cil_tmp32 = (OPJ_BYTE )trailing;
    }
  }
#line 134
  return;
}
}
#line 135 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_32sto5u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;

  {
#line 140
  i = (OPJ_SIZE_T )0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;

#line 140
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 140
      goto while_break;
    }
#line 141
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 142
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 143
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 144
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 145
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 146
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 147
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 148
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 150
    __cil_tmp13 = pDst;
#line 150
    pDst ++;
#line 150
    *__cil_tmp13 = (OPJ_BYTE )((src0 << 3) | (src1 >> 2));
#line 151
    __cil_tmp14 = pDst;
#line 151
    pDst ++;
#line 151
    *__cil_tmp14 = (OPJ_BYTE )(((src1 << 6) | (src2 << 1)) | (src3 >> 4));
#line 152
    __cil_tmp15 = pDst;
#line 152
    pDst ++;
#line 152
    *__cil_tmp15 = (OPJ_BYTE )((src3 << 4) | (src4 >> 1));
#line 153
    __cil_tmp16 = pDst;
#line 153
    pDst ++;
#line 153
    *__cil_tmp16 = (OPJ_BYTE )(((src4 << 7) | (src5 << 2)) | (src6 >> 3));
#line 154
    __cil_tmp17 = pDst;
#line 154
    pDst ++;
#line 154
    *__cil_tmp17 = (OPJ_BYTE )((src6 << 5) | src7);
#line 140
    i += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 158
  if (length & 7UL) {
#line 159
    trailing = 0U;
#line 160
    remaining = 8;
#line 161
    length &= 7UL;
#line 162
    if (5 >= remaining) {
#line 162
      trailing <<= remaining;
#line 162
      trailing |= (OPJ_UINT32 )*(pSrc + i) >> (5 - remaining);
#line 162
      __cil_tmp20 = pDst;
#line 162
      pDst ++;
#line 162
      *__cil_tmp20 = (OPJ_BYTE )trailing;
#line 162
      trailing = (OPJ_UINT32 )*(pSrc + i) & ((1U << (5 - remaining)) - 1U);
#line 162
      if (5 >= remaining + 8) {
#line 162
        __cil_tmp21 = pDst;
#line 162
        pDst ++;
#line 162
        *__cil_tmp21 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 162
        trailing &= (1U << (5 - (remaining + 8))) - 1U;
#line 162
        remaining += 11;
      } else {
#line 162
        remaining += 3;
      }
    } else {
#line 162
      trailing <<= 5;
#line 162
      trailing |= (OPJ_UINT32 )*(pSrc + i);
#line 162
      remaining -= 5;
    }
#line 163
    if (length > 1UL) {
#line 164
      if (5 >= remaining) {
#line 164
        trailing <<= remaining;
#line 164
        trailing |= (OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (5 - remaining);
#line 164
        __cil_tmp22 = pDst;
#line 164
        pDst ++;
#line 164
        *__cil_tmp22 = (OPJ_BYTE )trailing;
#line 164
        trailing = (OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (5 - remaining)) - 1U);
#line 164
        if (5 >= remaining + 8) {
#line 164
          __cil_tmp23 = pDst;
#line 164
          pDst ++;
#line 164
          *__cil_tmp23 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 164
          trailing &= (1U << (5 - (remaining + 8))) - 1U;
#line 164
          remaining += 11;
        } else {
#line 164
          remaining += 3;
        }
      } else {
#line 164
        trailing <<= 5;
#line 164
        trailing |= (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 164
        remaining -= 5;
      }
#line 165
      if (length > 2UL) {
#line 166
        if (5 >= remaining) {
#line 166
          trailing <<= remaining;
#line 166
          trailing |= (OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (5 - remaining);
#line 166
          __cil_tmp24 = pDst;
#line 166
          pDst ++;
#line 166
          *__cil_tmp24 = (OPJ_BYTE )trailing;
#line 166
          trailing = (OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (5 - remaining)) - 1U);
#line 166
          if (5 >= remaining + 8) {
#line 166
            __cil_tmp25 = pDst;
#line 166
            pDst ++;
#line 166
            *__cil_tmp25 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 166
            trailing &= (1U << (5 - (remaining + 8))) - 1U;
#line 166
            remaining += 11;
          } else {
#line 166
            remaining += 3;
          }
        } else {
#line 166
          trailing <<= 5;
#line 166
          trailing |= (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 166
          remaining -= 5;
        }
#line 167
        if (length > 3UL) {
#line 168
          if (5 >= remaining) {
#line 168
            trailing <<= remaining;
#line 168
            trailing |= (OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (5 - remaining);
#line 168
            __cil_tmp26 = pDst;
#line 168
            pDst ++;
#line 168
            *__cil_tmp26 = (OPJ_BYTE )trailing;
#line 168
            trailing = (OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (5 - remaining)) - 1U);
#line 168
            if (5 >= remaining + 8) {
#line 168
              __cil_tmp27 = pDst;
#line 168
              pDst ++;
#line 168
              *__cil_tmp27 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 168
              trailing &= (1U << (5 - (remaining + 8))) - 1U;
#line 168
              remaining += 11;
            } else {
#line 168
              remaining += 3;
            }
          } else {
#line 168
            trailing <<= 5;
#line 168
            trailing |= (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 168
            remaining -= 5;
          }
#line 169
          if (length > 4UL) {
#line 170
            if (5 >= remaining) {
#line 170
              trailing <<= remaining;
#line 170
              trailing |= (OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (5 - remaining);
#line 170
              __cil_tmp28 = pDst;
#line 170
              pDst ++;
#line 170
              *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 170
              trailing = (OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (5 - remaining)) - 1U);
#line 170
              if (5 >= remaining + 8) {
#line 170
                __cil_tmp29 = pDst;
#line 170
                pDst ++;
#line 170
                *__cil_tmp29 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 170
                trailing &= (1U << (5 - (remaining + 8))) - 1U;
#line 170
                remaining += 11;
              } else {
#line 170
                remaining += 3;
              }
            } else {
#line 170
              trailing <<= 5;
#line 170
              trailing |= (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 170
              remaining -= 5;
            }
#line 171
            if (length > 5UL) {
#line 172
              if (5 >= remaining) {
#line 172
                trailing <<= remaining;
#line 172
                trailing |= (OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (5 - remaining);
#line 172
                __cil_tmp30 = pDst;
#line 172
                pDst ++;
#line 172
                *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 172
                trailing = (OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (5 - remaining)) - 1U);
#line 172
                if (5 >= remaining + 8) {
#line 172
                  __cil_tmp31 = pDst;
#line 172
                  pDst ++;
#line 172
                  *__cil_tmp31 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 172
                  trailing &= (1U << (5 - (remaining + 8))) - 1U;
#line 172
                  remaining += 11;
                } else {
#line 172
                  remaining += 3;
                }
              } else {
#line 172
                trailing <<= 5;
#line 172
                trailing |= (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 172
                remaining -= 5;
              }
#line 173
              if (length > 6UL) {
#line 174
                if (5 >= remaining) {
#line 174
                  trailing <<= remaining;
#line 174
                  trailing |= (OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (5 - remaining);
#line 174
                  __cil_tmp32 = pDst;
#line 174
                  pDst ++;
#line 174
                  *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 174
                  trailing = (OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (5 - remaining)) - 1U);
#line 174
                  if (5 >= remaining + 8) {
#line 174
                    __cil_tmp33 = pDst;
#line 174
                    pDst ++;
#line 174
                    *__cil_tmp33 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 174
                    trailing &= (1U << (5 - (remaining + 8))) - 1U;
#line 174
                    remaining += 11;
                  } else {
#line 174
                    remaining += 3;
                  }
                } else {
#line 174
                  trailing <<= 5;
#line 174
                  trailing |= (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 174
                  remaining -= 5;
                }
              }
            }
          }
        }
      }
    }
#line 181
    if (remaining != 8) {
#line 181
      trailing <<= remaining;
#line 181
      __cil_tmp34 = pDst;
#line 181
      pDst ++;
#line 181
      *__cil_tmp34 = (OPJ_BYTE )trailing;
    }
  }
#line 184
  return;
}
}
#line 185 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_32sto7u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;

  {
#line 190
  i = (OPJ_SIZE_T )0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;

#line 190
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 190
      goto while_break;
    }
#line 191
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 192
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 193
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 194
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 195
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 196
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 197
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 198
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 200
    __cil_tmp13 = pDst;
#line 200
    pDst ++;
#line 200
    *__cil_tmp13 = (OPJ_BYTE )((src0 << 1) | (src1 >> 6));
#line 201
    __cil_tmp14 = pDst;
#line 201
    pDst ++;
#line 201
    *__cil_tmp14 = (OPJ_BYTE )((src1 << 2) | (src2 >> 5));
#line 202
    __cil_tmp15 = pDst;
#line 202
    pDst ++;
#line 202
    *__cil_tmp15 = (OPJ_BYTE )((src2 << 3) | (src3 >> 4));
#line 203
    __cil_tmp16 = pDst;
#line 203
    pDst ++;
#line 203
    *__cil_tmp16 = (OPJ_BYTE )((src3 << 4) | (src4 >> 3));
#line 204
    __cil_tmp17 = pDst;
#line 204
    pDst ++;
#line 204
    *__cil_tmp17 = (OPJ_BYTE )((src4 << 5) | (src5 >> 2));
#line 205
    __cil_tmp18 = pDst;
#line 205
    pDst ++;
#line 205
    *__cil_tmp18 = (OPJ_BYTE )((src5 << 6) | (src6 >> 1));
#line 206
    __cil_tmp19 = pDst;
#line 206
    pDst ++;
#line 206
    *__cil_tmp19 = (OPJ_BYTE )((src6 << 7) | src7);
#line 190
    i += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 209
  if (length & 7UL) {
#line 210
    trailing = 0U;
#line 211
    remaining = 8;
#line 212
    length &= 7UL;
#line 213
    if (7 >= remaining) {
#line 213
      trailing <<= remaining;
#line 213
      trailing |= (OPJ_UINT32 )*(pSrc + i) >> (7 - remaining);
#line 213
      __cil_tmp22 = pDst;
#line 213
      pDst ++;
#line 213
      *__cil_tmp22 = (OPJ_BYTE )trailing;
#line 213
      trailing = (OPJ_UINT32 )*(pSrc + i) & ((1U << (7 - remaining)) - 1U);
#line 213
      if (7 >= remaining + 8) {
#line 213
        __cil_tmp23 = pDst;
#line 213
        pDst ++;
#line 213
        *__cil_tmp23 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 213
        trailing &= (1U << (7 - (remaining + 8))) - 1U;
#line 213
        remaining += 9;
      } else {
#line 213
        remaining ++;
      }
    } else {
#line 213
      trailing <<= 7;
#line 213
      trailing |= (OPJ_UINT32 )*(pSrc + i);
#line 213
      remaining -= 7;
    }
#line 214
    if (length > 1UL) {
#line 215
      if (7 >= remaining) {
#line 215
        trailing <<= remaining;
#line 215
        trailing |= (OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (7 - remaining);
#line 215
        __cil_tmp24 = pDst;
#line 215
        pDst ++;
#line 215
        *__cil_tmp24 = (OPJ_BYTE )trailing;
#line 215
        trailing = (OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (7 - remaining)) - 1U);
#line 215
        if (7 >= remaining + 8) {
#line 215
          __cil_tmp25 = pDst;
#line 215
          pDst ++;
#line 215
          *__cil_tmp25 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 215
          trailing &= (1U << (7 - (remaining + 8))) - 1U;
#line 215
          remaining += 9;
        } else {
#line 215
          remaining ++;
        }
      } else {
#line 215
        trailing <<= 7;
#line 215
        trailing |= (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 215
        remaining -= 7;
      }
#line 216
      if (length > 2UL) {
#line 217
        if (7 >= remaining) {
#line 217
          trailing <<= remaining;
#line 217
          trailing |= (OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (7 - remaining);
#line 217
          __cil_tmp26 = pDst;
#line 217
          pDst ++;
#line 217
          *__cil_tmp26 = (OPJ_BYTE )trailing;
#line 217
          trailing = (OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (7 - remaining)) - 1U);
#line 217
          if (7 >= remaining + 8) {
#line 217
            __cil_tmp27 = pDst;
#line 217
            pDst ++;
#line 217
            *__cil_tmp27 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 217
            trailing &= (1U << (7 - (remaining + 8))) - 1U;
#line 217
            remaining += 9;
          } else {
#line 217
            remaining ++;
          }
        } else {
#line 217
          trailing <<= 7;
#line 217
          trailing |= (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 217
          remaining -= 7;
        }
#line 218
        if (length > 3UL) {
#line 219
          if (7 >= remaining) {
#line 219
            trailing <<= remaining;
#line 219
            trailing |= (OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (7 - remaining);
#line 219
            __cil_tmp28 = pDst;
#line 219
            pDst ++;
#line 219
            *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 219
            trailing = (OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (7 - remaining)) - 1U);
#line 219
            if (7 >= remaining + 8) {
#line 219
              __cil_tmp29 = pDst;
#line 219
              pDst ++;
#line 219
              *__cil_tmp29 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 219
              trailing &= (1U << (7 - (remaining + 8))) - 1U;
#line 219
              remaining += 9;
            } else {
#line 219
              remaining ++;
            }
          } else {
#line 219
            trailing <<= 7;
#line 219
            trailing |= (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 219
            remaining -= 7;
          }
#line 220
          if (length > 4UL) {
#line 221
            if (7 >= remaining) {
#line 221
              trailing <<= remaining;
#line 221
              trailing |= (OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (7 - remaining);
#line 221
              __cil_tmp30 = pDst;
#line 221
              pDst ++;
#line 221
              *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 221
              trailing = (OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (7 - remaining)) - 1U);
#line 221
              if (7 >= remaining + 8) {
#line 221
                __cil_tmp31 = pDst;
#line 221
                pDst ++;
#line 221
                *__cil_tmp31 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 221
                trailing &= (1U << (7 - (remaining + 8))) - 1U;
#line 221
                remaining += 9;
              } else {
#line 221
                remaining ++;
              }
            } else {
#line 221
              trailing <<= 7;
#line 221
              trailing |= (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 221
              remaining -= 7;
            }
#line 222
            if (length > 5UL) {
#line 223
              if (7 >= remaining) {
#line 223
                trailing <<= remaining;
#line 223
                trailing |= (OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (7 - remaining);
#line 223
                __cil_tmp32 = pDst;
#line 223
                pDst ++;
#line 223
                *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 223
                trailing = (OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (7 - remaining)) - 1U);
#line 223
                if (7 >= remaining + 8) {
#line 223
                  __cil_tmp33 = pDst;
#line 223
                  pDst ++;
#line 223
                  *__cil_tmp33 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 223
                  trailing &= (1U << (7 - (remaining + 8))) - 1U;
#line 223
                  remaining += 9;
                } else {
#line 223
                  remaining ++;
                }
              } else {
#line 223
                trailing <<= 7;
#line 223
                trailing |= (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 223
                remaining -= 7;
              }
#line 224
              if (length > 6UL) {
#line 225
                if (7 >= remaining) {
#line 225
                  trailing <<= remaining;
#line 225
                  trailing |= (OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (7 - remaining);
#line 225
                  __cil_tmp34 = pDst;
#line 225
                  pDst ++;
#line 225
                  *__cil_tmp34 = (OPJ_BYTE )trailing;
#line 225
                  trailing = (OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (7 - remaining)) - 1U);
#line 225
                  if (7 >= remaining + 8) {
#line 225
                    __cil_tmp35 = pDst;
#line 225
                    pDst ++;
#line 225
                    *__cil_tmp35 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 225
                    trailing &= (1U << (7 - (remaining + 8))) - 1U;
#line 225
                    remaining += 9;
                  } else {
#line 225
                    remaining ++;
                  }
                } else {
#line 225
                  trailing <<= 7;
#line 225
                  trailing |= (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 225
                  remaining -= 7;
                }
              }
            }
          }
        }
      }
    }
#line 232
    if (remaining != 8) {
#line 232
      trailing <<= remaining;
#line 232
      __cil_tmp36 = pDst;
#line 232
      pDst ++;
#line 232
      *__cil_tmp36 = (OPJ_BYTE )trailing;
    }
  }
#line 235
  return;
}
}
#line 236 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_32sto9u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  OPJ_BYTE *__cil_tmp37 ;
  OPJ_BYTE *__cil_tmp38 ;

  {
#line 241
  i = (OPJ_SIZE_T )0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;

#line 241
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 241
      goto while_break;
    }
#line 242
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 243
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 244
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 245
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 246
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 247
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 248
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 249
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 251
    __cil_tmp13 = pDst;
#line 251
    pDst ++;
#line 251
    *__cil_tmp13 = (OPJ_BYTE )(src0 >> 1);
#line 252
    __cil_tmp14 = pDst;
#line 252
    pDst ++;
#line 252
    *__cil_tmp14 = (OPJ_BYTE )((src0 << 7) | (src1 >> 2));
#line 253
    __cil_tmp15 = pDst;
#line 253
    pDst ++;
#line 253
    *__cil_tmp15 = (OPJ_BYTE )((src1 << 6) | (src2 >> 3));
#line 254
    __cil_tmp16 = pDst;
#line 254
    pDst ++;
#line 254
    *__cil_tmp16 = (OPJ_BYTE )((src2 << 5) | (src3 >> 4));
#line 255
    __cil_tmp17 = pDst;
#line 255
    pDst ++;
#line 255
    *__cil_tmp17 = (OPJ_BYTE )((src3 << 4) | (src4 >> 5));
#line 256
    __cil_tmp18 = pDst;
#line 256
    pDst ++;
#line 256
    *__cil_tmp18 = (OPJ_BYTE )((src4 << 3) | (src5 >> 6));
#line 257
    __cil_tmp19 = pDst;
#line 257
    pDst ++;
#line 257
    *__cil_tmp19 = (OPJ_BYTE )((src5 << 2) | (src6 >> 7));
#line 258
    __cil_tmp20 = pDst;
#line 258
    pDst ++;
#line 258
    *__cil_tmp20 = (OPJ_BYTE )((src6 << 1) | (src7 >> 8));
#line 259
    __cil_tmp21 = pDst;
#line 259
    pDst ++;
#line 259
    *__cil_tmp21 = (OPJ_BYTE )src7;
#line 241
    i += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 262
  if (length & 7UL) {
#line 263
    trailing = 0U;
#line 264
    remaining = 8;
#line 265
    length &= 7UL;
#line 266
    trailing <<= remaining;
#line 266
    trailing |= (OPJ_UINT32 )*(pSrc + i) >> (9 - remaining);
#line 266
    __cil_tmp24 = pDst;
#line 266
    pDst ++;
#line 266
    *__cil_tmp24 = (OPJ_BYTE )trailing;
#line 266
    trailing = (OPJ_UINT32 )*(pSrc + i) & ((1U << (9 - remaining)) - 1U);
#line 266
    if (9 >= remaining + 8) {
#line 266
      __cil_tmp25 = pDst;
#line 266
      pDst ++;
#line 266
      *__cil_tmp25 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 266
      trailing &= (1U << (9 - (remaining + 8))) - 1U;
#line 266
      remaining += 7;
    } else {
#line 266
      remaining --;
    }
#line 267
    if (length > 1UL) {
#line 268
      trailing <<= remaining;
#line 268
      trailing |= (OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (9 - remaining);
#line 268
      __cil_tmp26 = pDst;
#line 268
      pDst ++;
#line 268
      *__cil_tmp26 = (OPJ_BYTE )trailing;
#line 268
      trailing = (OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (9 - remaining)) - 1U);
#line 268
      if (9 >= remaining + 8) {
#line 268
        __cil_tmp27 = pDst;
#line 268
        pDst ++;
#line 268
        *__cil_tmp27 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 268
        trailing &= (1U << (9 - (remaining + 8))) - 1U;
#line 268
        remaining += 7;
      } else {
#line 268
        remaining --;
      }
#line 269
      if (length > 2UL) {
#line 270
        trailing <<= remaining;
#line 270
        trailing |= (OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (9 - remaining);
#line 270
        __cil_tmp28 = pDst;
#line 270
        pDst ++;
#line 270
        *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 270
        trailing = (OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (9 - remaining)) - 1U);
#line 270
        if (9 >= remaining + 8) {
#line 270
          __cil_tmp29 = pDst;
#line 270
          pDst ++;
#line 270
          *__cil_tmp29 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 270
          trailing &= (1U << (9 - (remaining + 8))) - 1U;
#line 270
          remaining += 7;
        } else {
#line 270
          remaining --;
        }
#line 271
        if (length > 3UL) {
#line 272
          trailing <<= remaining;
#line 272
          trailing |= (OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (9 - remaining);
#line 272
          __cil_tmp30 = pDst;
#line 272
          pDst ++;
#line 272
          *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 272
          trailing = (OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (9 - remaining)) - 1U);
#line 272
          if (9 >= remaining + 8) {
#line 272
            __cil_tmp31 = pDst;
#line 272
            pDst ++;
#line 272
            *__cil_tmp31 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 272
            trailing &= (1U << (9 - (remaining + 8))) - 1U;
#line 272
            remaining += 7;
          } else {
#line 272
            remaining --;
          }
#line 273
          if (length > 4UL) {
#line 274
            trailing <<= remaining;
#line 274
            trailing |= (OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (9 - remaining);
#line 274
            __cil_tmp32 = pDst;
#line 274
            pDst ++;
#line 274
            *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 274
            trailing = (OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (9 - remaining)) - 1U);
#line 274
            if (9 >= remaining + 8) {
#line 274
              __cil_tmp33 = pDst;
#line 274
              pDst ++;
#line 274
              *__cil_tmp33 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 274
              trailing &= (1U << (9 - (remaining + 8))) - 1U;
#line 274
              remaining += 7;
            } else {
#line 274
              remaining --;
            }
#line 275
            if (length > 5UL) {
#line 276
              trailing <<= remaining;
#line 276
              trailing |= (OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (9 - remaining);
#line 276
              __cil_tmp34 = pDst;
#line 276
              pDst ++;
#line 276
              *__cil_tmp34 = (OPJ_BYTE )trailing;
#line 276
              trailing = (OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (9 - remaining)) - 1U);
#line 276
              if (9 >= remaining + 8) {
#line 276
                __cil_tmp35 = pDst;
#line 276
                pDst ++;
#line 276
                *__cil_tmp35 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 276
                trailing &= (1U << (9 - (remaining + 8))) - 1U;
#line 276
                remaining += 7;
              } else {
#line 276
                remaining --;
              }
#line 277
              if (length > 6UL) {
#line 278
                trailing <<= remaining;
#line 278
                trailing |= (OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (9 - remaining);
#line 278
                __cil_tmp36 = pDst;
#line 278
                pDst ++;
#line 278
                *__cil_tmp36 = (OPJ_BYTE )trailing;
#line 278
                trailing = (OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (9 - remaining)) - 1U);
#line 278
                if (9 >= remaining + 8) {
#line 278
                  __cil_tmp37 = pDst;
#line 278
                  pDst ++;
#line 278
                  *__cil_tmp37 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 278
                  trailing &= (1U << (9 - (remaining + 8))) - 1U;
#line 278
                  remaining += 7;
                } else {
#line 278
                  remaining --;
                }
              }
            }
          }
        }
      }
    }
#line 285
    if (remaining != 8) {
#line 285
      trailing <<= remaining;
#line 285
      __cil_tmp38 = pDst;
#line 285
      pDst ++;
#line 285
      *__cil_tmp38 = (OPJ_BYTE )trailing;
    }
  }
#line 288
  return;
}
}
#line 289 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_32sto10u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_BYTE *__cil_tmp9 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_BYTE *__cil_tmp11 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_UINT32 src0___0 ;
  OPJ_UINT32 src1___0 ;
  OPJ_UINT32 src2___0 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;

  {
#line 293
  i = (OPJ_SIZE_T )0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;

#line 293
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 293
      goto while_break;
    }
#line 294
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 295
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 296
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 297
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 299
    __cil_tmp9 = pDst;
#line 299
    pDst ++;
#line 299
    *__cil_tmp9 = (OPJ_BYTE )(src0 >> 2);
#line 300
    __cil_tmp10 = pDst;
#line 300
    pDst ++;
#line 300
    *__cil_tmp10 = (OPJ_BYTE )(((src0 & 3U) << 6) | (src1 >> 4));
#line 301
    __cil_tmp11 = pDst;
#line 301
    pDst ++;
#line 301
    *__cil_tmp11 = (OPJ_BYTE )(((src1 & 15U) << 4) | (src2 >> 6));
#line 302
    __cil_tmp12 = pDst;
#line 302
    pDst ++;
#line 302
    *__cil_tmp12 = (OPJ_BYTE )(((src2 & 63U) << 2) | (src3 >> 8));
#line 303
    __cil_tmp13 = pDst;
#line 303
    pDst ++;
#line 303
    *__cil_tmp13 = (OPJ_BYTE )src3;
#line 293
    i += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 306
  if (length & 3UL) {
#line 307
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 308
    src1___0 = 0U;
#line 309
    src2___0 = 0U;
#line 310
    length &= 3UL;
#line 312
    if (length > 1UL) {
#line 313
      src1___0 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 314
      if (length > 2UL) {
#line 315
        src2___0 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
      }
    }
#line 318
    __cil_tmp17 = pDst;
#line 318
    pDst ++;
#line 318
    *__cil_tmp17 = (OPJ_BYTE )(src0___0 >> 2);
#line 319
    __cil_tmp18 = pDst;
#line 319
    pDst ++;
#line 319
    *__cil_tmp18 = (OPJ_BYTE )(((src0___0 & 3U) << 6) | (src1___0 >> 4));
#line 320
    if (length > 1UL) {
#line 321
      __cil_tmp19 = pDst;
#line 321
      pDst ++;
#line 321
      *__cil_tmp19 = (OPJ_BYTE )(((src1___0 & 15U) << 4) | (src2___0 >> 6));
#line 322
      if (length > 2UL) {
#line 323
        __cil_tmp20 = pDst;
#line 323
        pDst ++;
#line 323
        *__cil_tmp20 = (OPJ_BYTE )((src2___0 & 63U) << 2);
      }
    }
  }
#line 327
  return;
}
}
#line 328 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_32sto11u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  OPJ_BYTE *__cil_tmp37 ;
  OPJ_BYTE *__cil_tmp38 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;

  {
#line 333
  i = (OPJ_SIZE_T )0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;

#line 333
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 333
      goto while_break;
    }
#line 334
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 335
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 336
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 337
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 338
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 339
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 340
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 341
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 343
    __cil_tmp13 = pDst;
#line 343
    pDst ++;
#line 343
    *__cil_tmp13 = (OPJ_BYTE )(src0 >> 3);
#line 344
    __cil_tmp14 = pDst;
#line 344
    pDst ++;
#line 344
    *__cil_tmp14 = (OPJ_BYTE )((src0 << 5) | (src1 >> 6));
#line 345
    __cil_tmp15 = pDst;
#line 345
    pDst ++;
#line 345
    *__cil_tmp15 = (OPJ_BYTE )((src1 << 2) | (src2 >> 9));
#line 346
    __cil_tmp16 = pDst;
#line 346
    pDst ++;
#line 346
    *__cil_tmp16 = (OPJ_BYTE )(src2 >> 1);
#line 347
    __cil_tmp17 = pDst;
#line 347
    pDst ++;
#line 347
    *__cil_tmp17 = (OPJ_BYTE )((src2 << 7) | (src3 >> 4));
#line 348
    __cil_tmp18 = pDst;
#line 348
    pDst ++;
#line 348
    *__cil_tmp18 = (OPJ_BYTE )((src3 << 4) | (src4 >> 7));
#line 349
    __cil_tmp19 = pDst;
#line 349
    pDst ++;
#line 349
    *__cil_tmp19 = (OPJ_BYTE )((src4 << 1) | (src5 >> 10));
#line 350
    __cil_tmp20 = pDst;
#line 350
    pDst ++;
#line 350
    *__cil_tmp20 = (OPJ_BYTE )(src5 >> 2);
#line 351
    __cil_tmp21 = pDst;
#line 351
    pDst ++;
#line 351
    *__cil_tmp21 = (OPJ_BYTE )((src5 << 6) | (src6 >> 5));
#line 352
    __cil_tmp22 = pDst;
#line 352
    pDst ++;
#line 352
    *__cil_tmp22 = (OPJ_BYTE )((src6 << 3) | (src7 >> 8));
#line 353
    __cil_tmp23 = pDst;
#line 353
    pDst ++;
#line 353
    *__cil_tmp23 = (OPJ_BYTE )src7;
#line 333
    i += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 356
  if (length & 7UL) {
#line 357
    trailing = 0U;
#line 358
    remaining = 8;
#line 359
    length &= 7UL;
#line 360
    trailing <<= remaining;
#line 360
    trailing |= (OPJ_UINT32 )*(pSrc + i) >> (11 - remaining);
#line 360
    __cil_tmp26 = pDst;
#line 360
    pDst ++;
#line 360
    *__cil_tmp26 = (OPJ_BYTE )trailing;
#line 360
    trailing = (OPJ_UINT32 )*(pSrc + i) & ((1U << (11 - remaining)) - 1U);
#line 360
    if (11 >= remaining + 8) {
#line 360
      __cil_tmp27 = pDst;
#line 360
      pDst ++;
#line 360
      *__cil_tmp27 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 360
      trailing &= (1U << (11 - (remaining + 8))) - 1U;
#line 360
      remaining += 5;
    } else {
#line 360
      remaining += -3;
    }
#line 361
    if (length > 1UL) {
#line 362
      trailing <<= remaining;
#line 362
      trailing |= (OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (11 - remaining);
#line 362
      __cil_tmp28 = pDst;
#line 362
      pDst ++;
#line 362
      *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 362
      trailing = (OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (11 - remaining)) - 1U);
#line 362
      if (11 >= remaining + 8) {
#line 362
        __cil_tmp29 = pDst;
#line 362
        pDst ++;
#line 362
        *__cil_tmp29 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 362
        trailing &= (1U << (11 - (remaining + 8))) - 1U;
#line 362
        remaining += 5;
      } else {
#line 362
        remaining += -3;
      }
#line 363
      if (length > 2UL) {
#line 364
        trailing <<= remaining;
#line 364
        trailing |= (OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (11 - remaining);
#line 364
        __cil_tmp30 = pDst;
#line 364
        pDst ++;
#line 364
        *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 364
        trailing = (OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (11 - remaining)) - 1U);
#line 364
        if (11 >= remaining + 8) {
#line 364
          __cil_tmp31 = pDst;
#line 364
          pDst ++;
#line 364
          *__cil_tmp31 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 364
          trailing &= (1U << (11 - (remaining + 8))) - 1U;
#line 364
          remaining += 5;
        } else {
#line 364
          remaining += -3;
        }
#line 365
        if (length > 3UL) {
#line 366
          trailing <<= remaining;
#line 366
          trailing |= (OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (11 - remaining);
#line 366
          __cil_tmp32 = pDst;
#line 366
          pDst ++;
#line 366
          *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 366
          trailing = (OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (11 - remaining)) - 1U);
#line 366
          if (11 >= remaining + 8) {
#line 366
            __cil_tmp33 = pDst;
#line 366
            pDst ++;
#line 366
            *__cil_tmp33 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 366
            trailing &= (1U << (11 - (remaining + 8))) - 1U;
#line 366
            remaining += 5;
          } else {
#line 366
            remaining += -3;
          }
#line 367
          if (length > 4UL) {
#line 368
            trailing <<= remaining;
#line 368
            trailing |= (OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (11 - remaining);
#line 368
            __cil_tmp34 = pDst;
#line 368
            pDst ++;
#line 368
            *__cil_tmp34 = (OPJ_BYTE )trailing;
#line 368
            trailing = (OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (11 - remaining)) - 1U);
#line 368
            if (11 >= remaining + 8) {
#line 368
              __cil_tmp35 = pDst;
#line 368
              pDst ++;
#line 368
              *__cil_tmp35 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 368
              trailing &= (1U << (11 - (remaining + 8))) - 1U;
#line 368
              remaining += 5;
            } else {
#line 368
              remaining += -3;
            }
#line 369
            if (length > 5UL) {
#line 370
              trailing <<= remaining;
#line 370
              trailing |= (OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (11 - remaining);
#line 370
              __cil_tmp36 = pDst;
#line 370
              pDst ++;
#line 370
              *__cil_tmp36 = (OPJ_BYTE )trailing;
#line 370
              trailing = (OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (11 - remaining)) - 1U);
#line 370
              if (11 >= remaining + 8) {
#line 370
                __cil_tmp37 = pDst;
#line 370
                pDst ++;
#line 370
                *__cil_tmp37 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 370
                trailing &= (1U << (11 - (remaining + 8))) - 1U;
#line 370
                remaining += 5;
              } else {
#line 370
                remaining += -3;
              }
#line 371
              if (length > 6UL) {
#line 372
                trailing <<= remaining;
#line 372
                trailing |= (OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (11 - remaining);
#line 372
                __cil_tmp38 = pDst;
#line 372
                pDst ++;
#line 372
                *__cil_tmp38 = (OPJ_BYTE )trailing;
#line 372
                trailing = (OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (11 - remaining)) - 1U);
#line 372
                if (11 >= remaining + 8) {
#line 372
                  __cil_tmp39 = pDst;
#line 372
                  pDst ++;
#line 372
                  *__cil_tmp39 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 372
                  trailing &= (1U << (11 - (remaining + 8))) - 1U;
#line 372
                  remaining += 5;
                } else {
#line 372
                  remaining += -3;
                }
              }
            }
          }
        }
      }
    }
#line 379
    if (remaining != 8) {
#line 379
      trailing <<= remaining;
#line 379
      __cil_tmp40 = pDst;
#line 379
      pDst ++;
#line 379
      *__cil_tmp40 = (OPJ_BYTE )trailing;
    }
  }
#line 382
  return;
}
}
#line 382 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_32sto12u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_BYTE *__cil_tmp9 ;
  OPJ_UINT32 src0___0 ;
  OPJ_BYTE *__cil_tmp11 ;
  OPJ_BYTE *__cil_tmp12 ;

  {
#line 386
  i = (OPJ_SIZE_T )0;
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;

#line 386
    if (! (i < (length & 0xfffffffffffffffeUL))) {
#line 386
      goto while_break;
    }
#line 387
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 388
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 390
    __cil_tmp7 = pDst;
#line 390
    pDst ++;
#line 390
    *__cil_tmp7 = (OPJ_BYTE )(src0 >> 4);
#line 391
    __cil_tmp8 = pDst;
#line 391
    pDst ++;
#line 391
    *__cil_tmp8 = (OPJ_BYTE )(((src0 & 15U) << 4) | (src1 >> 8));
#line 392
    __cil_tmp9 = pDst;
#line 392
    pDst ++;
#line 392
    *__cil_tmp9 = (OPJ_BYTE )src1;
#line 386
    i += 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 395
  if (length & 1UL) {
#line 396
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 397
    __cil_tmp11 = pDst;
#line 397
    pDst ++;
#line 397
    *__cil_tmp11 = (OPJ_BYTE )(src0___0 >> 4);
#line 398
    __cil_tmp12 = pDst;
#line 398
    pDst ++;
#line 398
    *__cil_tmp12 = (OPJ_BYTE )((src0___0 & 15U) << 4);
  }
#line 400
  return;
}
}
#line 401 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_32sto13u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  OPJ_BYTE *__cil_tmp37 ;
  OPJ_BYTE *__cil_tmp38 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  OPJ_BYTE *__cil_tmp41 ;
  OPJ_BYTE *__cil_tmp42 ;

  {
#line 406
  i = (OPJ_SIZE_T )0;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;

#line 406
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 406
      goto while_break;
    }
#line 407
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 408
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 409
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 410
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 411
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 412
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 413
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 414
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 416
    __cil_tmp13 = pDst;
#line 416
    pDst ++;
#line 416
    *__cil_tmp13 = (OPJ_BYTE )(src0 >> 5);
#line 417
    __cil_tmp14 = pDst;
#line 417
    pDst ++;
#line 417
    *__cil_tmp14 = (OPJ_BYTE )((src0 << 3) | (src1 >> 10));
#line 418
    __cil_tmp15 = pDst;
#line 418
    pDst ++;
#line 418
    *__cil_tmp15 = (OPJ_BYTE )(src1 >> 2);
#line 419
    __cil_tmp16 = pDst;
#line 419
    pDst ++;
#line 419
    *__cil_tmp16 = (OPJ_BYTE )((src1 << 6) | (src2 >> 7));
#line 420
    __cil_tmp17 = pDst;
#line 420
    pDst ++;
#line 420
    *__cil_tmp17 = (OPJ_BYTE )((src2 << 1) | (src3 >> 12));
#line 421
    __cil_tmp18 = pDst;
#line 421
    pDst ++;
#line 421
    *__cil_tmp18 = (OPJ_BYTE )(src3 >> 4);
#line 422
    __cil_tmp19 = pDst;
#line 422
    pDst ++;
#line 422
    *__cil_tmp19 = (OPJ_BYTE )((src3 << 4) | (src4 >> 9));
#line 423
    __cil_tmp20 = pDst;
#line 423
    pDst ++;
#line 423
    *__cil_tmp20 = (OPJ_BYTE )(src4 >> 1);
#line 424
    __cil_tmp21 = pDst;
#line 424
    pDst ++;
#line 424
    *__cil_tmp21 = (OPJ_BYTE )((src4 << 7) | (src5 >> 6));
#line 425
    __cil_tmp22 = pDst;
#line 425
    pDst ++;
#line 425
    *__cil_tmp22 = (OPJ_BYTE )((src5 << 2) | (src6 >> 11));
#line 426
    __cil_tmp23 = pDst;
#line 426
    pDst ++;
#line 426
    *__cil_tmp23 = (OPJ_BYTE )(src6 >> 3);
#line 427
    __cil_tmp24 = pDst;
#line 427
    pDst ++;
#line 427
    *__cil_tmp24 = (OPJ_BYTE )((src6 << 5) | (src7 >> 8));
#line 428
    __cil_tmp25 = pDst;
#line 428
    pDst ++;
#line 428
    *__cil_tmp25 = (OPJ_BYTE )src7;
#line 406
    i += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 431
  if (length & 7UL) {
#line 432
    trailing = 0U;
#line 433
    remaining = 8;
#line 434
    length &= 7UL;
#line 435
    trailing <<= remaining;
#line 435
    trailing |= (OPJ_UINT32 )*(pSrc + i) >> (13 - remaining);
#line 435
    __cil_tmp28 = pDst;
#line 435
    pDst ++;
#line 435
    *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 435
    trailing = (OPJ_UINT32 )*(pSrc + i) & ((1U << (13 - remaining)) - 1U);
#line 435
    if (13 >= remaining + 8) {
#line 435
      __cil_tmp29 = pDst;
#line 435
      pDst ++;
#line 435
      *__cil_tmp29 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 435
      trailing &= (1U << (13 - (remaining + 8))) - 1U;
#line 435
      remaining += 3;
    } else {
#line 435
      remaining += -5;
    }
#line 436
    if (length > 1UL) {
#line 437
      trailing <<= remaining;
#line 437
      trailing |= (OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (13 - remaining);
#line 437
      __cil_tmp30 = pDst;
#line 437
      pDst ++;
#line 437
      *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 437
      trailing = (OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (13 - remaining)) - 1U);
#line 437
      if (13 >= remaining + 8) {
#line 437
        __cil_tmp31 = pDst;
#line 437
        pDst ++;
#line 437
        *__cil_tmp31 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 437
        trailing &= (1U << (13 - (remaining + 8))) - 1U;
#line 437
        remaining += 3;
      } else {
#line 437
        remaining += -5;
      }
#line 438
      if (length > 2UL) {
#line 439
        trailing <<= remaining;
#line 439
        trailing |= (OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (13 - remaining);
#line 439
        __cil_tmp32 = pDst;
#line 439
        pDst ++;
#line 439
        *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 439
        trailing = (OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (13 - remaining)) - 1U);
#line 439
        if (13 >= remaining + 8) {
#line 439
          __cil_tmp33 = pDst;
#line 439
          pDst ++;
#line 439
          *__cil_tmp33 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 439
          trailing &= (1U << (13 - (remaining + 8))) - 1U;
#line 439
          remaining += 3;
        } else {
#line 439
          remaining += -5;
        }
#line 440
        if (length > 3UL) {
#line 441
          trailing <<= remaining;
#line 441
          trailing |= (OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (13 - remaining);
#line 441
          __cil_tmp34 = pDst;
#line 441
          pDst ++;
#line 441
          *__cil_tmp34 = (OPJ_BYTE )trailing;
#line 441
          trailing = (OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (13 - remaining)) - 1U);
#line 441
          if (13 >= remaining + 8) {
#line 441
            __cil_tmp35 = pDst;
#line 441
            pDst ++;
#line 441
            *__cil_tmp35 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 441
            trailing &= (1U << (13 - (remaining + 8))) - 1U;
#line 441
            remaining += 3;
          } else {
#line 441
            remaining += -5;
          }
#line 442
          if (length > 4UL) {
#line 443
            trailing <<= remaining;
#line 443
            trailing |= (OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (13 - remaining);
#line 443
            __cil_tmp36 = pDst;
#line 443
            pDst ++;
#line 443
            *__cil_tmp36 = (OPJ_BYTE )trailing;
#line 443
            trailing = (OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (13 - remaining)) - 1U);
#line 443
            if (13 >= remaining + 8) {
#line 443
              __cil_tmp37 = pDst;
#line 443
              pDst ++;
#line 443
              *__cil_tmp37 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 443
              trailing &= (1U << (13 - (remaining + 8))) - 1U;
#line 443
              remaining += 3;
            } else {
#line 443
              remaining += -5;
            }
#line 444
            if (length > 5UL) {
#line 445
              trailing <<= remaining;
#line 445
              trailing |= (OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (13 - remaining);
#line 445
              __cil_tmp38 = pDst;
#line 445
              pDst ++;
#line 445
              *__cil_tmp38 = (OPJ_BYTE )trailing;
#line 445
              trailing = (OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (13 - remaining)) - 1U);
#line 445
              if (13 >= remaining + 8) {
#line 445
                __cil_tmp39 = pDst;
#line 445
                pDst ++;
#line 445
                *__cil_tmp39 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 445
                trailing &= (1U << (13 - (remaining + 8))) - 1U;
#line 445
                remaining += 3;
              } else {
#line 445
                remaining += -5;
              }
#line 446
              if (length > 6UL) {
#line 447
                trailing <<= remaining;
#line 447
                trailing |= (OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (13 - remaining);
#line 447
                __cil_tmp40 = pDst;
#line 447
                pDst ++;
#line 447
                *__cil_tmp40 = (OPJ_BYTE )trailing;
#line 447
                trailing = (OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (13 - remaining)) - 1U);
#line 447
                if (13 >= remaining + 8) {
#line 447
                  __cil_tmp41 = pDst;
#line 447
                  pDst ++;
#line 447
                  *__cil_tmp41 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 447
                  trailing &= (1U << (13 - (remaining + 8))) - 1U;
#line 447
                  remaining += 3;
                } else {
#line 447
                  remaining += -5;
                }
              }
            }
          }
        }
      }
    }
#line 454
    if (remaining != 8) {
#line 454
      trailing <<= remaining;
#line 454
      __cil_tmp42 = pDst;
#line 454
      pDst ++;
#line 454
      *__cil_tmp42 = (OPJ_BYTE )trailing;
    }
  }
#line 457
  return;
}
}
#line 457 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_32sto14u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_BYTE *__cil_tmp9 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_BYTE *__cil_tmp11 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_UINT32 src0___0 ;
  OPJ_UINT32 src1___0 ;
  OPJ_UINT32 src2___0 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;

  {
#line 461
  i = (OPJ_SIZE_T )0;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;

#line 461
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 461
      goto while_break;
    }
#line 462
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 463
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 464
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 465
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 467
    __cil_tmp9 = pDst;
#line 467
    pDst ++;
#line 467
    *__cil_tmp9 = (OPJ_BYTE )(src0 >> 6);
#line 468
    __cil_tmp10 = pDst;
#line 468
    pDst ++;
#line 468
    *__cil_tmp10 = (OPJ_BYTE )(((src0 & 63U) << 2) | (src1 >> 12));
#line 469
    __cil_tmp11 = pDst;
#line 469
    pDst ++;
#line 469
    *__cil_tmp11 = (OPJ_BYTE )(src1 >> 4);
#line 470
    __cil_tmp12 = pDst;
#line 470
    pDst ++;
#line 470
    *__cil_tmp12 = (OPJ_BYTE )(((src1 & 15U) << 4) | (src2 >> 10));
#line 471
    __cil_tmp13 = pDst;
#line 471
    pDst ++;
#line 471
    *__cil_tmp13 = (OPJ_BYTE )(src2 >> 2);
#line 472
    __cil_tmp14 = pDst;
#line 472
    pDst ++;
#line 472
    *__cil_tmp14 = (OPJ_BYTE )(((src2 & 3U) << 6) | (src3 >> 8));
#line 473
    __cil_tmp15 = pDst;
#line 473
    pDst ++;
#line 473
    *__cil_tmp15 = (OPJ_BYTE )src3;
#line 461
    i += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 476
  if (length & 3UL) {
#line 477
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 478
    src1___0 = 0U;
#line 479
    src2___0 = 0U;
#line 480
    length &= 3UL;
#line 482
    if (length > 1UL) {
#line 483
      src1___0 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 484
      if (length > 2UL) {
#line 485
        src2___0 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
      }
    }
#line 488
    __cil_tmp19 = pDst;
#line 488
    pDst ++;
#line 488
    *__cil_tmp19 = (OPJ_BYTE )(src0___0 >> 6);
#line 489
    __cil_tmp20 = pDst;
#line 489
    pDst ++;
#line 489
    *__cil_tmp20 = (OPJ_BYTE )(((src0___0 & 63U) << 2) | (src1___0 >> 12));
#line 490
    if (length > 1UL) {
#line 491
      __cil_tmp21 = pDst;
#line 491
      pDst ++;
#line 491
      *__cil_tmp21 = (OPJ_BYTE )(src1___0 >> 4);
#line 492
      __cil_tmp22 = pDst;
#line 492
      pDst ++;
#line 492
      *__cil_tmp22 = (OPJ_BYTE )(((src1___0 & 15U) << 4) | (src2___0 >> 10));
#line 493
      if (length > 2UL) {
#line 494
        __cil_tmp23 = pDst;
#line 494
        pDst ++;
#line 494
        *__cil_tmp23 = (OPJ_BYTE )(src2___0 >> 2);
#line 495
        __cil_tmp24 = pDst;
#line 495
        pDst ++;
#line 495
        *__cil_tmp24 = (OPJ_BYTE )((src2___0 & 3U) << 6);
      }
    }
  }
#line 499
  return;
}
}
#line 500 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_32sto15u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  OPJ_BYTE *__cil_tmp37 ;
  OPJ_BYTE *__cil_tmp38 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  OPJ_BYTE *__cil_tmp41 ;
  OPJ_BYTE *__cil_tmp42 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;

  {
#line 505
  i = (OPJ_SIZE_T )0;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;

#line 505
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 505
      goto while_break;
    }
#line 506
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 507
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 508
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 509
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 510
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 511
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 512
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 513
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 515
    __cil_tmp13 = pDst;
#line 515
    pDst ++;
#line 515
    *__cil_tmp13 = (OPJ_BYTE )(src0 >> 7);
#line 516
    __cil_tmp14 = pDst;
#line 516
    pDst ++;
#line 516
    *__cil_tmp14 = (OPJ_BYTE )((src0 << 1) | (src1 >> 14));
#line 517
    __cil_tmp15 = pDst;
#line 517
    pDst ++;
#line 517
    *__cil_tmp15 = (OPJ_BYTE )(src1 >> 6);
#line 518
    __cil_tmp16 = pDst;
#line 518
    pDst ++;
#line 518
    *__cil_tmp16 = (OPJ_BYTE )((src1 << 2) | (src2 >> 13));
#line 519
    __cil_tmp17 = pDst;
#line 519
    pDst ++;
#line 519
    *__cil_tmp17 = (OPJ_BYTE )(src2 >> 5);
#line 520
    __cil_tmp18 = pDst;
#line 520
    pDst ++;
#line 520
    *__cil_tmp18 = (OPJ_BYTE )((src2 << 3) | (src3 >> 12));
#line 521
    __cil_tmp19 = pDst;
#line 521
    pDst ++;
#line 521
    *__cil_tmp19 = (OPJ_BYTE )(src3 >> 4);
#line 522
    __cil_tmp20 = pDst;
#line 522
    pDst ++;
#line 522
    *__cil_tmp20 = (OPJ_BYTE )((src3 << 4) | (src4 >> 11));
#line 523
    __cil_tmp21 = pDst;
#line 523
    pDst ++;
#line 523
    *__cil_tmp21 = (OPJ_BYTE )(src4 >> 3);
#line 524
    __cil_tmp22 = pDst;
#line 524
    pDst ++;
#line 524
    *__cil_tmp22 = (OPJ_BYTE )((src4 << 5) | (src5 >> 10));
#line 525
    __cil_tmp23 = pDst;
#line 525
    pDst ++;
#line 525
    *__cil_tmp23 = (OPJ_BYTE )(src5 >> 2);
#line 526
    __cil_tmp24 = pDst;
#line 526
    pDst ++;
#line 526
    *__cil_tmp24 = (OPJ_BYTE )((src5 << 6) | (src6 >> 9));
#line 527
    __cil_tmp25 = pDst;
#line 527
    pDst ++;
#line 527
    *__cil_tmp25 = (OPJ_BYTE )(src6 >> 1);
#line 528
    __cil_tmp26 = pDst;
#line 528
    pDst ++;
#line 528
    *__cil_tmp26 = (OPJ_BYTE )((src6 << 7) | (src7 >> 8));
#line 529
    __cil_tmp27 = pDst;
#line 529
    pDst ++;
#line 529
    *__cil_tmp27 = (OPJ_BYTE )src7;
#line 505
    i += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 532
  if (length & 7UL) {
#line 533
    trailing = 0U;
#line 534
    remaining = 8;
#line 535
    length &= 7UL;
#line 536
    trailing <<= remaining;
#line 536
    trailing |= (OPJ_UINT32 )*(pSrc + i) >> (15 - remaining);
#line 536
    __cil_tmp30 = pDst;
#line 536
    pDst ++;
#line 536
    *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 536
    trailing = (OPJ_UINT32 )*(pSrc + i) & ((1U << (15 - remaining)) - 1U);
#line 536
    if (15 >= remaining + 8) {
#line 536
      __cil_tmp31 = pDst;
#line 536
      pDst ++;
#line 536
      *__cil_tmp31 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 536
      trailing &= (1U << (15 - (remaining + 8))) - 1U;
#line 536
      remaining ++;
    } else {
#line 536
      remaining += -7;
    }
#line 537
    if (length > 1UL) {
#line 538
      trailing <<= remaining;
#line 538
      trailing |= (OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (15 - remaining);
#line 538
      __cil_tmp32 = pDst;
#line 538
      pDst ++;
#line 538
      *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 538
      trailing = (OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (15 - remaining)) - 1U);
#line 538
      if (15 >= remaining + 8) {
#line 538
        __cil_tmp33 = pDst;
#line 538
        pDst ++;
#line 538
        *__cil_tmp33 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 538
        trailing &= (1U << (15 - (remaining + 8))) - 1U;
#line 538
        remaining ++;
      } else {
#line 538
        remaining += -7;
      }
#line 539
      if (length > 2UL) {
#line 540
        trailing <<= remaining;
#line 540
        trailing |= (OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (15 - remaining);
#line 540
        __cil_tmp34 = pDst;
#line 540
        pDst ++;
#line 540
        *__cil_tmp34 = (OPJ_BYTE )trailing;
#line 540
        trailing = (OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (15 - remaining)) - 1U);
#line 540
        if (15 >= remaining + 8) {
#line 540
          __cil_tmp35 = pDst;
#line 540
          pDst ++;
#line 540
          *__cil_tmp35 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 540
          trailing &= (1U << (15 - (remaining + 8))) - 1U;
#line 540
          remaining ++;
        } else {
#line 540
          remaining += -7;
        }
#line 541
        if (length > 3UL) {
#line 542
          trailing <<= remaining;
#line 542
          trailing |= (OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (15 - remaining);
#line 542
          __cil_tmp36 = pDst;
#line 542
          pDst ++;
#line 542
          *__cil_tmp36 = (OPJ_BYTE )trailing;
#line 542
          trailing = (OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (15 - remaining)) - 1U);
#line 542
          if (15 >= remaining + 8) {
#line 542
            __cil_tmp37 = pDst;
#line 542
            pDst ++;
#line 542
            *__cil_tmp37 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 542
            trailing &= (1U << (15 - (remaining + 8))) - 1U;
#line 542
            remaining ++;
          } else {
#line 542
            remaining += -7;
          }
#line 543
          if (length > 4UL) {
#line 544
            trailing <<= remaining;
#line 544
            trailing |= (OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (15 - remaining);
#line 544
            __cil_tmp38 = pDst;
#line 544
            pDst ++;
#line 544
            *__cil_tmp38 = (OPJ_BYTE )trailing;
#line 544
            trailing = (OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (15 - remaining)) - 1U);
#line 544
            if (15 >= remaining + 8) {
#line 544
              __cil_tmp39 = pDst;
#line 544
              pDst ++;
#line 544
              *__cil_tmp39 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 544
              trailing &= (1U << (15 - (remaining + 8))) - 1U;
#line 544
              remaining ++;
            } else {
#line 544
              remaining += -7;
            }
#line 545
            if (length > 5UL) {
#line 546
              trailing <<= remaining;
#line 546
              trailing |= (OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (15 - remaining);
#line 546
              __cil_tmp40 = pDst;
#line 546
              pDst ++;
#line 546
              *__cil_tmp40 = (OPJ_BYTE )trailing;
#line 546
              trailing = (OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (15 - remaining)) - 1U);
#line 546
              if (15 >= remaining + 8) {
#line 546
                __cil_tmp41 = pDst;
#line 546
                pDst ++;
#line 546
                *__cil_tmp41 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 546
                trailing &= (1U << (15 - (remaining + 8))) - 1U;
#line 546
                remaining ++;
              } else {
#line 546
                remaining += -7;
              }
#line 547
              if (length > 6UL) {
#line 548
                trailing <<= remaining;
#line 548
                trailing |= (OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (15 - remaining);
#line 548
                __cil_tmp42 = pDst;
#line 548
                pDst ++;
#line 548
                *__cil_tmp42 = (OPJ_BYTE )trailing;
#line 548
                trailing = (OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (15 - remaining)) - 1U);
#line 548
                if (15 >= remaining + 8) {
#line 548
                  __cil_tmp43 = pDst;
#line 548
                  pDst ++;
#line 548
                  *__cil_tmp43 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 548
                  trailing &= (1U << (15 - (remaining + 8))) - 1U;
#line 548
                  remaining ++;
                } else {
#line 548
                  remaining += -7;
                }
              }
            }
          }
        }
      }
    }
#line 555
    if (remaining != 8) {
#line 555
      trailing <<= remaining;
#line 555
      __cil_tmp44 = pDst;
#line 555
      pDst ++;
#line 555
      *__cil_tmp44 = (OPJ_BYTE )trailing;
    }
  }
#line 558
  return;
}
}
#line 558 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_32sto16u(OPJ_INT32 *pSrc , OPJ_UINT16 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;

  {
#line 562
  i = (OPJ_SIZE_T )0;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;

#line 562
    if (! (i < length)) {
#line 562
      goto while_break;
    }
#line 563
    *(pDst + i) = (OPJ_UINT16 )*(pSrc + i);
#line 562
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 566
  return;
}
}
#line 567 "/root/patron/new_24/src/bin/jp2/converttif.c"
int imagetotif(opj_image_t *image , char const   *outfile ) 
{ 
  TIFF *tif ;
  tdata_t buf ;
  uint32 width ;
  uint32 height ;
  uint16 bps ;
  uint16 tiPhoto ;
  int adjust ;
  int sgnd ;
  int64_t strip_size ;
  int64_t rowStride ;
  int64_t TIFF_MAX ;
  OPJ_UINT32 i ;
  OPJ_UINT32 numcomps ;
  OPJ_INT32 *buffer32s ;
  OPJ_INT32 *planes[4] ;
  void (*cvtPxToCx)(OPJ_INT32 * const  * , OPJ_INT32 * , OPJ_SIZE_T  , OPJ_INT32  ) ;
  void (*cvt32sToTif)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ) ;
  int tmp ;
  tmsize_t __cil_tmp22 ;
  void *__cil_tmp24 ;

  {
#line 576
  buffer32s = (OPJ_INT32 *)((void *)0);
#line 578
  cvtPxToCx = (void (*)(OPJ_INT32 * const  * , OPJ_INT32 * , OPJ_SIZE_T  , OPJ_INT32  ))((void *)0);
#line 579
  cvt32sToTif = (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0);
#line 581
  bps = (uint16 )(image->comps + 0)->prec;
#line 582
  planes[0] = (image->comps + 0)->data;
#line 584
  numcomps = image->numcomps;
#line 586
  if ((int )image->color_space == 5) {
#line 587
    if (numcomps < 4U) {
      {
#line 588
      fprintf(stderr, "imagetotif: CMYK images shall be composed of at least 4 planes.\n\220");
#line 590
      fprintf(stderr, "\tAborting\n");
      }
#line 591
      return (1);
    }
#line 593
    tiPhoto = (uint16 )5;
#line 594
    if (numcomps > 4U) {
#line 595
      numcomps = 4U;
    }
  } else
#line 597
  if (numcomps > 2U) {
#line 598
    tiPhoto = (uint16 )2;
#line 599
    if (numcomps > 4U) {
#line 600
      numcomps = 4U;
    }
  } else {
#line 603
    tiPhoto = (uint16 )1;
  }
#line 605
  i = 1U;
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;

#line 605
    if (! (i < numcomps)) {
#line 605
      goto while_break;
    }
#line 606
    if ((image->comps + 0)->dx != (image->comps + i)->dx) {
#line 607
      goto while_break;
    }
#line 609
    if ((image->comps + 0)->dy != (image->comps + i)->dy) {
#line 610
      goto while_break;
    }
#line 612
    if ((image->comps + 0)->prec != (image->comps + i)->prec) {
#line 613
      goto while_break;
    }
#line 615
    if ((image->comps + 0)->sgnd != (image->comps + i)->sgnd) {
#line 616
      goto while_break;
    }
#line 618
    planes[i] = (image->comps + i)->data;
#line 605
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 620
  if (i != numcomps) {
    {
#line 621
    fprintf(stderr, "imagetotif: All components shall have the same subsampling, same bit depth.\n");
#line 623
    fprintf(stderr, "\tAborting\n");
    }
#line 624
    return (1);
  }
#line 627
  if ((int )bps > 16) {
#line 628
    bps = (uint16 )0;
  }
#line 630
  if ((int )bps == 0) {
    {
#line 631
    fprintf(stderr, "imagetotif: Bits=%d, Only 1 to 16 bits implemented\n", (int )bps);
#line 632
    fprintf(stderr, "\tAborting\n");
    }
#line 633
    return (1);
  }
  {
#line 635
  tif = TIFFOpen(outfile, "wb");
  }
#line 636
  if (! tif) {
    {
#line 637
    fprintf(stderr, "imagetotif:failed to open %s for writing\n", outfile);
    }
#line 638
    return (1);
  }
#line 640
  i = 0U;
  {
#line 640
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 640
    if (! (i < numcomps)) {
#line 640
      goto while_break___0;
    }
    {
#line 641
    clip_component(image->comps + i, (image->comps + 0)->prec);
#line 640
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 643
  cvtPxToCx = convert_32s_PXCX_LUT[numcomps];
#line 649
  if ((int )bps == 8) {
#line 649
    goto case_8;
  }
#line 649
  if ((int )bps == 6) {
#line 649
    goto case_8;
  }
#line 649
  if ((int )bps == 4) {
#line 649
    goto case_8;
  }
#line 649
  if ((int )bps == 2) {
#line 649
    goto case_8;
  }
#line 649
  if ((int )bps == 1) {
#line 649
    goto case_8;
  }
#line 652
  if ((int )bps == 3) {
#line 652
    goto case_3;
  }
#line 655
  if ((int )bps == 5) {
#line 655
    goto case_5;
  }
#line 658
  if ((int )bps == 7) {
#line 658
    goto case_7;
  }
#line 661
  if ((int )bps == 9) {
#line 661
    goto case_9;
  }
#line 664
  if ((int )bps == 10) {
#line 664
    goto case_10;
  }
#line 667
  if ((int )bps == 11) {
#line 667
    goto case_11;
  }
#line 670
  if ((int )bps == 12) {
#line 670
    goto case_12;
  }
#line 673
  if ((int )bps == 13) {
#line 673
    goto case_13;
  }
#line 676
  if ((int )bps == 14) {
#line 676
    goto case_14;
  }
#line 679
  if ((int )bps == 15) {
#line 679
    goto case_15;
  }
#line 682
  if ((int )bps == 16) {
#line 682
    goto case_16;
  }
#line 685
  goto switch_default;
  case_8: 
#line 650
  cvt32sToTif = convert_32sXXu_C1R_LUT[bps];
#line 651
  goto switch_break;
  case_3: 
#line 653
  cvt32sToTif = & tif_32sto3u;
#line 654
  goto switch_break;
  case_5: 
#line 656
  cvt32sToTif = & tif_32sto5u;
#line 657
  goto switch_break;
  case_7: 
#line 659
  cvt32sToTif = & tif_32sto7u;
#line 660
  goto switch_break;
  case_9: 
#line 662
  cvt32sToTif = & tif_32sto9u;
#line 663
  goto switch_break;
  case_10: 
#line 665
  cvt32sToTif = & tif_32sto10u;
#line 666
  goto switch_break;
  case_11: 
#line 668
  cvt32sToTif = & tif_32sto11u;
#line 669
  goto switch_break;
  case_12: 
#line 671
  cvt32sToTif = & tif_32sto12u;
#line 672
  goto switch_break;
  case_13: 
#line 674
  cvt32sToTif = & tif_32sto13u;
#line 675
  goto switch_break;
  case_14: 
#line 677
  cvt32sToTif = & tif_32sto14u;
#line 678
  goto switch_break;
  case_15: 
#line 680
  cvt32sToTif = & tif_32sto15u;
#line 681
  goto switch_break;
  case_16: 
#line 683
  cvt32sToTif = (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))(& tif_32sto16u);
#line 684
  goto switch_break;
  switch_default: 
#line 687
  goto switch_break;
  switch_break: 
#line 689
  sgnd = (int )(image->comps + 0)->sgnd;
#line 690
  if (sgnd) {
#line 690
    tmp = 1 << ((image->comps + 0)->prec - 1U);
  } else {
#line 690
    tmp = 0;
  }
  {
#line 690
  adjust = tmp;
#line 691
  width = (image->comps + 0)->w;
#line 692
  height = (image->comps + 0)->h;
#line 694
  TIFFSetField(tif, (uint32 )256, width);
#line 695
  TIFFSetField(tif, (uint32 )257, height);
#line 696
  TIFFSetField(tif, (uint32 )277, (int )((uint16 )numcomps));
#line 697
  TIFFSetField(tif, (uint32 )258, (int )bps);
#line 698
  TIFFSetField(tif, (uint32 )274, 1);
#line 699
  TIFFSetField(tif, (uint32 )284, 1);
#line 700
  TIFFSetField(tif, (uint32 )262, (int )tiPhoto);
#line 701
  TIFFSetField(tif, (uint32 )278, 1);
  }
#line 702
  if (sizeof(tsize_t ) == 4UL) {
#line 703
    TIFF_MAX = (int64_t )2147483647;
  } else {
#line 705
    TIFF_MAX = (int64_t )4294967295U;
  }
  {
#line 707
  __cil_tmp22 = TIFFStripSize(tif);
#line 707
  strip_size = __cil_tmp22;
  }
#line 709
  if ((int64_t )width > TIFF_MAX / (long )numcomps) {
    {
#line 713
    fprintf(stderr, "Buffer overflow\n\220");
#line 714
    TIFFClose(tif);
    }
#line 715
    return (1);
  } else
#line 709
  if ((int64_t )(width * numcomps) > TIFF_MAX / (long )bps) {
    {
#line 713
    fprintf(stderr, "Buffer overflow\n\220");
#line 714
    TIFFClose(tif);
    }
#line 715
    return (1);
  } else
#line 709
  if ((int64_t )(width * numcomps) > TIFF_MAX / (int64_t )sizeof(OPJ_INT32 )) {
    {
#line 713
    fprintf(stderr, "Buffer overflow\n\220");
#line 714
    TIFFClose(tif);
    }
#line 715
    return (1);
  }
#line 717
  rowStride = (int64_t )(((width * numcomps) * (unsigned int )bps + 7U) / 8U);
#line 718
  if (rowStride != strip_size) {
    {
#line 719
    fprintf(stderr, "Invalid TIFF strip size\n\220");
#line 720
    TIFFClose(tif);
    }
#line 721
    return (1);
  }
  {
#line 723
  buf = malloc((OPJ_SIZE_T )strip_size);
  }
#line 724
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 725
    TIFFClose(tif);
    }
#line 726
    return (1);
  }
  {
#line 728
  __cil_tmp24 = malloc((unsigned long )(width * numcomps) * sizeof(OPJ_INT32 ));
#line 728
  buffer32s = (OPJ_INT32 *)__cil_tmp24;
  }
#line 730
  if ((unsigned long )buffer32s == (unsigned long )((void *)0)) {
    {
#line 731
    _TIFFfree(buf);
#line 732
    TIFFClose(tif);
    }
#line 733
    return (1);
  }
#line 736
  i = (OPJ_UINT32 )0;
  {
#line 736
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 736
    if (! (i < (image->comps + 0)->h)) {
#line 736
      goto while_break___1;
    }
    {
#line 737
    (*cvtPxToCx)((OPJ_INT32 * const  *)(planes), buffer32s, (OPJ_SIZE_T )width, adjust);
#line 738
    (*cvt32sToTif)(buffer32s, (OPJ_BYTE *)buf, (OPJ_SIZE_T )width * (unsigned long )numcomps);
#line 739
    TIFFWriteEncodedStrip(tif, i, buf, strip_size);
#line 740
    planes[0] += width;
#line 741
    planes[1] += width;
#line 742
    planes[2] += width;
#line 743
    planes[3] += width;
#line 736
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 745
  _TIFFfree(buf);
#line 746
  TIFFClose(tif);
#line 747
  free((void *)buffer32s);
  }
#line 749
  return (0);
}
}
#line 771 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_3uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;

  {
#line 775
  i = (OPJ_SIZE_T )0;
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;

#line 775
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 775
      goto while_break;
    }
#line 776
    __cil_tmp6 = pSrc;
#line 776
    pSrc ++;
#line 776
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 777
    __cil_tmp8 = pSrc;
#line 777
    pSrc ++;
#line 777
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 778
    __cil_tmp10 = pSrc;
#line 778
    pSrc ++;
#line 778
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 780
    *(pDst + i) = (OPJ_INT32 )(val0 >> 5);
#line 781
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((val0 & 31U) >> 2);
#line 782
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val0 & 3U) << 1) | (val1 >> 7));
#line 783
    *(pDst + (i + 3UL)) = (OPJ_INT32 )((val1 & 127U) >> 4);
#line 784
    *(pDst + (i + 4UL)) = (OPJ_INT32 )((val1 & 15U) >> 1);
#line 785
    *(pDst + (i + 5UL)) = (OPJ_INT32 )(((val1 & 1U) << 2) | (val2 >> 6));
#line 786
    *(pDst + (i + 6UL)) = (OPJ_INT32 )((val2 & 63U) >> 3);
#line 787
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(val2 & 7U);
#line 775
    i += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 790
  if (length & 7UL) {
#line 792
    available = 0;
#line 794
    length &= 7UL;
#line 796
    needed = 3;
#line 796
    dst = 0U;
#line 796
    if (available == 0) {
#line 796
      __cil_tmp15 = pSrc;
#line 796
      pSrc ++;
#line 796
      val = (unsigned int )*__cil_tmp15;
#line 796
      available = 8;
    }
    {
#line 796
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 796
      if (! (needed > available)) {
#line 796
        goto while_break___0;
      }
#line 796
      dst |= val & ((1U << available) - 1U);
#line 796
      needed -= available;
#line 796
      dst <<= needed;
#line 796
      __cil_tmp16 = pSrc;
#line 796
      pSrc ++;
#line 796
      val = (unsigned int )*__cil_tmp16;
#line 796
      available = 8;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 796
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 796
    available -= needed;
#line 796
    *(pDst + i) = (OPJ_INT32 )dst;
#line 798
    if (length > 1UL) {
#line 799
      needed___0 = 3;
#line 799
      dst___0 = 0U;
#line 799
      if (available == 0) {
#line 799
        __cil_tmp19 = pSrc;
#line 799
        pSrc ++;
#line 799
        val = (unsigned int )*__cil_tmp19;
#line 799
        available = 8;
      }
      {
#line 799
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 799
        if (! (needed___0 > available)) {
#line 799
          goto while_break___1;
        }
#line 799
        dst___0 |= val & ((1U << available) - 1U);
#line 799
        needed___0 -= available;
#line 799
        dst___0 <<= needed___0;
#line 799
        __cil_tmp20 = pSrc;
#line 799
        pSrc ++;
#line 799
        val = (unsigned int )*__cil_tmp20;
#line 799
        available = 8;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 799
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 799
      available -= needed___0;
#line 799
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 800
      if (length > 2UL) {
#line 801
        needed___1 = 3;
#line 801
        dst___1 = 0U;
#line 801
        if (available == 0) {
#line 801
          __cil_tmp23 = pSrc;
#line 801
          pSrc ++;
#line 801
          val = (unsigned int )*__cil_tmp23;
#line 801
          available = 8;
        }
        {
#line 801
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 801
          if (! (needed___1 > available)) {
#line 801
            goto while_break___2;
          }
#line 801
          dst___1 |= val & ((1U << available) - 1U);
#line 801
          needed___1 -= available;
#line 801
          dst___1 <<= needed___1;
#line 801
          __cil_tmp24 = pSrc;
#line 801
          pSrc ++;
#line 801
          val = (unsigned int )*__cil_tmp24;
#line 801
          available = 8;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 801
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 801
        available -= needed___1;
#line 801
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 802
        if (length > 3UL) {
#line 803
          needed___2 = 3;
#line 803
          dst___2 = 0U;
#line 803
          if (available == 0) {
#line 803
            __cil_tmp27 = pSrc;
#line 803
            pSrc ++;
#line 803
            val = (unsigned int )*__cil_tmp27;
#line 803
            available = 8;
          }
          {
#line 803
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 803
            if (! (needed___2 > available)) {
#line 803
              goto while_break___3;
            }
#line 803
            dst___2 |= val & ((1U << available) - 1U);
#line 803
            needed___2 -= available;
#line 803
            dst___2 <<= needed___2;
#line 803
            __cil_tmp28 = pSrc;
#line 803
            pSrc ++;
#line 803
            val = (unsigned int )*__cil_tmp28;
#line 803
            available = 8;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: 
#line 803
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 803
          available -= needed___2;
#line 803
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 804
          if (length > 4UL) {
#line 805
            needed___3 = 3;
#line 805
            dst___3 = 0U;
#line 805
            if (available == 0) {
#line 805
              __cil_tmp31 = pSrc;
#line 805
              pSrc ++;
#line 805
              val = (unsigned int )*__cil_tmp31;
#line 805
              available = 8;
            }
            {
#line 805
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 805
              if (! (needed___3 > available)) {
#line 805
                goto while_break___4;
              }
#line 805
              dst___3 |= val & ((1U << available) - 1U);
#line 805
              needed___3 -= available;
#line 805
              dst___3 <<= needed___3;
#line 805
              __cil_tmp32 = pSrc;
#line 805
              pSrc ++;
#line 805
              val = (unsigned int )*__cil_tmp32;
#line 805
              available = 8;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: 
#line 805
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 805
            available -= needed___3;
#line 805
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 806
            if (length > 5UL) {
#line 807
              needed___4 = 3;
#line 807
              dst___4 = 0U;
#line 807
              if (available == 0) {
#line 807
                __cil_tmp35 = pSrc;
#line 807
                pSrc ++;
#line 807
                val = (unsigned int )*__cil_tmp35;
#line 807
                available = 8;
              }
              {
#line 807
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 807
                if (! (needed___4 > available)) {
#line 807
                  goto while_break___5;
                }
#line 807
                dst___4 |= val & ((1U << available) - 1U);
#line 807
                needed___4 -= available;
#line 807
                dst___4 <<= needed___4;
#line 807
                __cil_tmp36 = pSrc;
#line 807
                pSrc ++;
#line 807
                val = (unsigned int )*__cil_tmp36;
#line 807
                available = 8;
              }
              while_break___13: /* CIL Label */ ;
              }
              while_break___5: 
#line 807
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 807
              available -= needed___4;
#line 807
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 808
              if (length > 6UL) {
#line 809
                needed___5 = 3;
#line 809
                dst___5 = 0U;
#line 809
                if (available == 0) {
#line 809
                  __cil_tmp39 = pSrc;
#line 809
                  pSrc ++;
#line 809
                  val = (unsigned int )*__cil_tmp39;
#line 809
                  available = 8;
                }
                {
#line 809
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 809
                  if (! (needed___5 > available)) {
#line 809
                    goto while_break___6;
                  }
#line 809
                  dst___5 |= val & ((1U << available) - 1U);
#line 809
                  needed___5 -= available;
#line 809
                  dst___5 <<= needed___5;
#line 809
                  __cil_tmp40 = pSrc;
#line 809
                  pSrc ++;
#line 809
                  val = (unsigned int )*__cil_tmp40;
#line 809
                  available = 8;
                }
                while_break___14: /* CIL Label */ ;
                }
                while_break___6: 
#line 809
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 809
                available -= needed___5;
#line 809
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
#line 817
  return;
}
}
#line 818 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_5uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;

  {
#line 822
  i = (OPJ_SIZE_T )0;
  {
#line 822
  while (1) {
    while_continue: /* CIL Label */ ;

#line 822
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 822
      goto while_break;
    }
#line 823
    __cil_tmp6 = pSrc;
#line 823
    pSrc ++;
#line 823
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 824
    __cil_tmp8 = pSrc;
#line 824
    pSrc ++;
#line 824
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 825
    __cil_tmp10 = pSrc;
#line 825
    pSrc ++;
#line 825
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 826
    __cil_tmp12 = pSrc;
#line 826
    pSrc ++;
#line 826
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 827
    __cil_tmp14 = pSrc;
#line 827
    pSrc ++;
#line 827
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 829
    *(pDst + i) = (OPJ_INT32 )(val0 >> 3);
#line 830
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val0 & 7U) << 2) | (val1 >> 6));
#line 831
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((val1 & 63U) >> 1);
#line 832
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val1 & 1U) << 4) | (val2 >> 4));
#line 833
    *(pDst + (i + 4UL)) = (OPJ_INT32 )(((val2 & 15U) << 1) | (val3 >> 7));
#line 834
    *(pDst + (i + 5UL)) = (OPJ_INT32 )((val3 & 127U) >> 2);
#line 835
    *(pDst + (i + 6UL)) = (OPJ_INT32 )(((val3 & 3U) << 3) | (val4 >> 5));
#line 836
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(val4 & 31U);
#line 822
    i += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 839
  if (length & 7UL) {
#line 841
    available = 0;
#line 843
    length &= 7UL;
#line 845
    needed = 5;
#line 845
    dst = 0U;
#line 845
    if (available == 0) {
#line 845
      __cil_tmp19 = pSrc;
#line 845
      pSrc ++;
#line 845
      val = (unsigned int )*__cil_tmp19;
#line 845
      available = 8;
    }
    {
#line 845
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 845
      if (! (needed > available)) {
#line 845
        goto while_break___0;
      }
#line 845
      dst |= val & ((1U << available) - 1U);
#line 845
      needed -= available;
#line 845
      dst <<= needed;
#line 845
      __cil_tmp20 = pSrc;
#line 845
      pSrc ++;
#line 845
      val = (unsigned int )*__cil_tmp20;
#line 845
      available = 8;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 845
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 845
    available -= needed;
#line 845
    *(pDst + i) = (OPJ_INT32 )dst;
#line 847
    if (length > 1UL) {
#line 848
      needed___0 = 5;
#line 848
      dst___0 = 0U;
#line 848
      if (available == 0) {
#line 848
        __cil_tmp23 = pSrc;
#line 848
        pSrc ++;
#line 848
        val = (unsigned int )*__cil_tmp23;
#line 848
        available = 8;
      }
      {
#line 848
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 848
        if (! (needed___0 > available)) {
#line 848
          goto while_break___1;
        }
#line 848
        dst___0 |= val & ((1U << available) - 1U);
#line 848
        needed___0 -= available;
#line 848
        dst___0 <<= needed___0;
#line 848
        __cil_tmp24 = pSrc;
#line 848
        pSrc ++;
#line 848
        val = (unsigned int )*__cil_tmp24;
#line 848
        available = 8;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 848
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 848
      available -= needed___0;
#line 848
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 849
      if (length > 2UL) {
#line 850
        needed___1 = 5;
#line 850
        dst___1 = 0U;
#line 850
        if (available == 0) {
#line 850
          __cil_tmp27 = pSrc;
#line 850
          pSrc ++;
#line 850
          val = (unsigned int )*__cil_tmp27;
#line 850
          available = 8;
        }
        {
#line 850
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 850
          if (! (needed___1 > available)) {
#line 850
            goto while_break___2;
          }
#line 850
          dst___1 |= val & ((1U << available) - 1U);
#line 850
          needed___1 -= available;
#line 850
          dst___1 <<= needed___1;
#line 850
          __cil_tmp28 = pSrc;
#line 850
          pSrc ++;
#line 850
          val = (unsigned int )*__cil_tmp28;
#line 850
          available = 8;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 850
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 850
        available -= needed___1;
#line 850
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 851
        if (length > 3UL) {
#line 852
          needed___2 = 5;
#line 852
          dst___2 = 0U;
#line 852
          if (available == 0) {
#line 852
            __cil_tmp31 = pSrc;
#line 852
            pSrc ++;
#line 852
            val = (unsigned int )*__cil_tmp31;
#line 852
            available = 8;
          }
          {
#line 852
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 852
            if (! (needed___2 > available)) {
#line 852
              goto while_break___3;
            }
#line 852
            dst___2 |= val & ((1U << available) - 1U);
#line 852
            needed___2 -= available;
#line 852
            dst___2 <<= needed___2;
#line 852
            __cil_tmp32 = pSrc;
#line 852
            pSrc ++;
#line 852
            val = (unsigned int )*__cil_tmp32;
#line 852
            available = 8;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: 
#line 852
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 852
          available -= needed___2;
#line 852
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 853
          if (length > 4UL) {
#line 854
            needed___3 = 5;
#line 854
            dst___3 = 0U;
#line 854
            if (available == 0) {
#line 854
              __cil_tmp35 = pSrc;
#line 854
              pSrc ++;
#line 854
              val = (unsigned int )*__cil_tmp35;
#line 854
              available = 8;
            }
            {
#line 854
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 854
              if (! (needed___3 > available)) {
#line 854
                goto while_break___4;
              }
#line 854
              dst___3 |= val & ((1U << available) - 1U);
#line 854
              needed___3 -= available;
#line 854
              dst___3 <<= needed___3;
#line 854
              __cil_tmp36 = pSrc;
#line 854
              pSrc ++;
#line 854
              val = (unsigned int )*__cil_tmp36;
#line 854
              available = 8;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: 
#line 854
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 854
            available -= needed___3;
#line 854
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 855
            if (length > 5UL) {
#line 856
              needed___4 = 5;
#line 856
              dst___4 = 0U;
#line 856
              if (available == 0) {
#line 856
                __cil_tmp39 = pSrc;
#line 856
                pSrc ++;
#line 856
                val = (unsigned int )*__cil_tmp39;
#line 856
                available = 8;
              }
              {
#line 856
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 856
                if (! (needed___4 > available)) {
#line 856
                  goto while_break___5;
                }
#line 856
                dst___4 |= val & ((1U << available) - 1U);
#line 856
                needed___4 -= available;
#line 856
                dst___4 <<= needed___4;
#line 856
                __cil_tmp40 = pSrc;
#line 856
                pSrc ++;
#line 856
                val = (unsigned int )*__cil_tmp40;
#line 856
                available = 8;
              }
              while_break___13: /* CIL Label */ ;
              }
              while_break___5: 
#line 856
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 856
              available -= needed___4;
#line 856
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 857
              if (length > 6UL) {
#line 858
                needed___5 = 5;
#line 858
                dst___5 = 0U;
#line 858
                if (available == 0) {
#line 858
                  __cil_tmp43 = pSrc;
#line 858
                  pSrc ++;
#line 858
                  val = (unsigned int )*__cil_tmp43;
#line 858
                  available = 8;
                }
                {
#line 858
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 858
                  if (! (needed___5 > available)) {
#line 858
                    goto while_break___6;
                  }
#line 858
                  dst___5 |= val & ((1U << available) - 1U);
#line 858
                  needed___5 -= available;
#line 858
                  dst___5 <<= needed___5;
#line 858
                  __cil_tmp44 = pSrc;
#line 858
                  pSrc ++;
#line 858
                  val = (unsigned int )*__cil_tmp44;
#line 858
                  available = 8;
                }
                while_break___14: /* CIL Label */ ;
                }
                while_break___6: 
#line 858
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 858
                available -= needed___5;
#line 858
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
#line 866
  return;
}
}
#line 867 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_7uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp47 ;
  OPJ_BYTE *__cil_tmp48 ;

  {
#line 871
  i = (OPJ_SIZE_T )0;
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;

#line 871
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 871
      goto while_break;
    }
#line 872
    __cil_tmp6 = pSrc;
#line 872
    pSrc ++;
#line 872
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 873
    __cil_tmp8 = pSrc;
#line 873
    pSrc ++;
#line 873
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 874
    __cil_tmp10 = pSrc;
#line 874
    pSrc ++;
#line 874
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 875
    __cil_tmp12 = pSrc;
#line 875
    pSrc ++;
#line 875
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 876
    __cil_tmp14 = pSrc;
#line 876
    pSrc ++;
#line 876
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 877
    __cil_tmp16 = pSrc;
#line 877
    pSrc ++;
#line 877
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 878
    __cil_tmp18 = pSrc;
#line 878
    pSrc ++;
#line 878
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 880
    *(pDst + i) = (OPJ_INT32 )(val0 >> 1);
#line 881
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val0 & 1U) << 6) | (val1 >> 2));
#line 882
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val1 & 3U) << 5) | (val2 >> 3));
#line 883
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val2 & 7U) << 4) | (val3 >> 4));
#line 884
    *(pDst + (i + 4UL)) = (OPJ_INT32 )(((val3 & 15U) << 3) | (val4 >> 5));
#line 885
    *(pDst + (i + 5UL)) = (OPJ_INT32 )(((val4 & 31U) << 2) | (val5 >> 6));
#line 886
    *(pDst + (i + 6UL)) = (OPJ_INT32 )(((val5 & 63U) << 1) | (val6 >> 7));
#line 887
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(val6 & 127U);
#line 871
    i += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 890
  if (length & 7UL) {
#line 892
    available = 0;
#line 894
    length &= 7UL;
#line 896
    needed = 7;
#line 896
    dst = 0U;
#line 896
    if (available == 0) {
#line 896
      __cil_tmp23 = pSrc;
#line 896
      pSrc ++;
#line 896
      val = (unsigned int )*__cil_tmp23;
#line 896
      available = 8;
    }
    {
#line 896
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 896
      if (! (needed > available)) {
#line 896
        goto while_break___0;
      }
#line 896
      dst |= val & ((1U << available) - 1U);
#line 896
      needed -= available;
#line 896
      dst <<= needed;
#line 896
      __cil_tmp24 = pSrc;
#line 896
      pSrc ++;
#line 896
      val = (unsigned int )*__cil_tmp24;
#line 896
      available = 8;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 896
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 896
    available -= needed;
#line 896
    *(pDst + i) = (OPJ_INT32 )dst;
#line 898
    if (length > 1UL) {
#line 899
      needed___0 = 7;
#line 899
      dst___0 = 0U;
#line 899
      if (available == 0) {
#line 899
        __cil_tmp27 = pSrc;
#line 899
        pSrc ++;
#line 899
        val = (unsigned int )*__cil_tmp27;
#line 899
        available = 8;
      }
      {
#line 899
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 899
        if (! (needed___0 > available)) {
#line 899
          goto while_break___1;
        }
#line 899
        dst___0 |= val & ((1U << available) - 1U);
#line 899
        needed___0 -= available;
#line 899
        dst___0 <<= needed___0;
#line 899
        __cil_tmp28 = pSrc;
#line 899
        pSrc ++;
#line 899
        val = (unsigned int )*__cil_tmp28;
#line 899
        available = 8;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 899
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 899
      available -= needed___0;
#line 899
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 900
      if (length > 2UL) {
#line 901
        needed___1 = 7;
#line 901
        dst___1 = 0U;
#line 901
        if (available == 0) {
#line 901
          __cil_tmp31 = pSrc;
#line 901
          pSrc ++;
#line 901
          val = (unsigned int )*__cil_tmp31;
#line 901
          available = 8;
        }
        {
#line 901
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 901
          if (! (needed___1 > available)) {
#line 901
            goto while_break___2;
          }
#line 901
          dst___1 |= val & ((1U << available) - 1U);
#line 901
          needed___1 -= available;
#line 901
          dst___1 <<= needed___1;
#line 901
          __cil_tmp32 = pSrc;
#line 901
          pSrc ++;
#line 901
          val = (unsigned int )*__cil_tmp32;
#line 901
          available = 8;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 901
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 901
        available -= needed___1;
#line 901
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 902
        if (length > 3UL) {
#line 903
          needed___2 = 7;
#line 903
          dst___2 = 0U;
#line 903
          if (available == 0) {
#line 903
            __cil_tmp35 = pSrc;
#line 903
            pSrc ++;
#line 903
            val = (unsigned int )*__cil_tmp35;
#line 903
            available = 8;
          }
          {
#line 903
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 903
            if (! (needed___2 > available)) {
#line 903
              goto while_break___3;
            }
#line 903
            dst___2 |= val & ((1U << available) - 1U);
#line 903
            needed___2 -= available;
#line 903
            dst___2 <<= needed___2;
#line 903
            __cil_tmp36 = pSrc;
#line 903
            pSrc ++;
#line 903
            val = (unsigned int )*__cil_tmp36;
#line 903
            available = 8;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: 
#line 903
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 903
          available -= needed___2;
#line 903
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 904
          if (length > 4UL) {
#line 905
            needed___3 = 7;
#line 905
            dst___3 = 0U;
#line 905
            if (available == 0) {
#line 905
              __cil_tmp39 = pSrc;
#line 905
              pSrc ++;
#line 905
              val = (unsigned int )*__cil_tmp39;
#line 905
              available = 8;
            }
            {
#line 905
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 905
              if (! (needed___3 > available)) {
#line 905
                goto while_break___4;
              }
#line 905
              dst___3 |= val & ((1U << available) - 1U);
#line 905
              needed___3 -= available;
#line 905
              dst___3 <<= needed___3;
#line 905
              __cil_tmp40 = pSrc;
#line 905
              pSrc ++;
#line 905
              val = (unsigned int )*__cil_tmp40;
#line 905
              available = 8;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: 
#line 905
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 905
            available -= needed___3;
#line 905
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 906
            if (length > 5UL) {
#line 907
              needed___4 = 7;
#line 907
              dst___4 = 0U;
#line 907
              if (available == 0) {
#line 907
                __cil_tmp43 = pSrc;
#line 907
                pSrc ++;
#line 907
                val = (unsigned int )*__cil_tmp43;
#line 907
                available = 8;
              }
              {
#line 907
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 907
                if (! (needed___4 > available)) {
#line 907
                  goto while_break___5;
                }
#line 907
                dst___4 |= val & ((1U << available) - 1U);
#line 907
                needed___4 -= available;
#line 907
                dst___4 <<= needed___4;
#line 907
                __cil_tmp44 = pSrc;
#line 907
                pSrc ++;
#line 907
                val = (unsigned int )*__cil_tmp44;
#line 907
                available = 8;
              }
              while_break___13: /* CIL Label */ ;
              }
              while_break___5: 
#line 907
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 907
              available -= needed___4;
#line 907
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 908
              if (length > 6UL) {
#line 909
                needed___5 = 7;
#line 909
                dst___5 = 0U;
#line 909
                if (available == 0) {
#line 909
                  __cil_tmp47 = pSrc;
#line 909
                  pSrc ++;
#line 909
                  val = (unsigned int )*__cil_tmp47;
#line 909
                  available = 8;
                }
                {
#line 909
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 909
                  if (! (needed___5 > available)) {
#line 909
                    goto while_break___6;
                  }
#line 909
                  dst___5 |= val & ((1U << available) - 1U);
#line 909
                  needed___5 -= available;
#line 909
                  dst___5 <<= needed___5;
#line 909
                  __cil_tmp48 = pSrc;
#line 909
                  pSrc ++;
#line 909
                  val = (unsigned int )*__cil_tmp48;
#line 909
                  available = 8;
                }
                while_break___14: /* CIL Label */ ;
                }
                while_break___6: 
#line 909
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 909
                available -= needed___5;
#line 909
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
#line 917
  return;
}
}
#line 918 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_9uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val7 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val8 ;
  OPJ_BYTE *__cil_tmp22 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp47 ;
  OPJ_BYTE *__cil_tmp48 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp51 ;
  OPJ_BYTE *__cil_tmp52 ;

  {
#line 922
  i = (OPJ_SIZE_T )0;
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;

#line 922
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 922
      goto while_break;
    }
#line 923
    __cil_tmp6 = pSrc;
#line 923
    pSrc ++;
#line 923
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 924
    __cil_tmp8 = pSrc;
#line 924
    pSrc ++;
#line 924
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 925
    __cil_tmp10 = pSrc;
#line 925
    pSrc ++;
#line 925
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 926
    __cil_tmp12 = pSrc;
#line 926
    pSrc ++;
#line 926
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 927
    __cil_tmp14 = pSrc;
#line 927
    pSrc ++;
#line 927
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 928
    __cil_tmp16 = pSrc;
#line 928
    pSrc ++;
#line 928
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 929
    __cil_tmp18 = pSrc;
#line 929
    pSrc ++;
#line 929
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 930
    __cil_tmp20 = pSrc;
#line 930
    pSrc ++;
#line 930
    val7 = (OPJ_UINT32 )*__cil_tmp20;
#line 931
    __cil_tmp22 = pSrc;
#line 931
    pSrc ++;
#line 931
    val8 = (OPJ_UINT32 )*__cil_tmp22;
#line 933
    *(pDst + i) = (OPJ_INT32 )((val0 << 1) | (val1 >> 7));
#line 934
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val1 & 127U) << 2) | (val2 >> 6));
#line 935
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val2 & 63U) << 3) | (val3 >> 5));
#line 936
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val3 & 31U) << 4) | (val4 >> 4));
#line 937
    *(pDst + (i + 4UL)) = (OPJ_INT32 )(((val4 & 15U) << 5) | (val5 >> 3));
#line 938
    *(pDst + (i + 5UL)) = (OPJ_INT32 )(((val5 & 7U) << 6) | (val6 >> 2));
#line 939
    *(pDst + (i + 6UL)) = (OPJ_INT32 )(((val6 & 3U) << 7) | (val7 >> 1));
#line 940
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(((val7 & 1U) << 8) | val8);
#line 922
    i += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 943
  if (length & 7UL) {
#line 945
    available = 0;
#line 947
    length &= 7UL;
#line 949
    needed = 9;
#line 949
    dst = 0U;
#line 949
    if (available == 0) {
#line 949
      __cil_tmp27 = pSrc;
#line 949
      pSrc ++;
#line 949
      val = (unsigned int )*__cil_tmp27;
#line 949
      available = 8;
    }
    {
#line 949
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 949
      if (! (needed > available)) {
#line 949
        goto while_break___0;
      }
#line 949
      dst |= val & ((1U << available) - 1U);
#line 949
      needed -= available;
#line 949
      dst <<= needed;
#line 949
      __cil_tmp28 = pSrc;
#line 949
      pSrc ++;
#line 949
      val = (unsigned int )*__cil_tmp28;
#line 949
      available = 8;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 949
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 949
    available -= needed;
#line 949
    *(pDst + i) = (OPJ_INT32 )dst;
#line 951
    if (length > 1UL) {
#line 952
      needed___0 = 9;
#line 952
      dst___0 = 0U;
#line 952
      if (available == 0) {
#line 952
        __cil_tmp31 = pSrc;
#line 952
        pSrc ++;
#line 952
        val = (unsigned int )*__cil_tmp31;
#line 952
        available = 8;
      }
      {
#line 952
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 952
        if (! (needed___0 > available)) {
#line 952
          goto while_break___1;
        }
#line 952
        dst___0 |= val & ((1U << available) - 1U);
#line 952
        needed___0 -= available;
#line 952
        dst___0 <<= needed___0;
#line 952
        __cil_tmp32 = pSrc;
#line 952
        pSrc ++;
#line 952
        val = (unsigned int )*__cil_tmp32;
#line 952
        available = 8;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 952
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 952
      available -= needed___0;
#line 952
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 953
      if (length > 2UL) {
#line 954
        needed___1 = 9;
#line 954
        dst___1 = 0U;
#line 954
        if (available == 0) {
#line 954
          __cil_tmp35 = pSrc;
#line 954
          pSrc ++;
#line 954
          val = (unsigned int )*__cil_tmp35;
#line 954
          available = 8;
        }
        {
#line 954
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 954
          if (! (needed___1 > available)) {
#line 954
            goto while_break___2;
          }
#line 954
          dst___1 |= val & ((1U << available) - 1U);
#line 954
          needed___1 -= available;
#line 954
          dst___1 <<= needed___1;
#line 954
          __cil_tmp36 = pSrc;
#line 954
          pSrc ++;
#line 954
          val = (unsigned int )*__cil_tmp36;
#line 954
          available = 8;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 954
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 954
        available -= needed___1;
#line 954
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 955
        if (length > 3UL) {
#line 956
          needed___2 = 9;
#line 956
          dst___2 = 0U;
#line 956
          if (available == 0) {
#line 956
            __cil_tmp39 = pSrc;
#line 956
            pSrc ++;
#line 956
            val = (unsigned int )*__cil_tmp39;
#line 956
            available = 8;
          }
          {
#line 956
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 956
            if (! (needed___2 > available)) {
#line 956
              goto while_break___3;
            }
#line 956
            dst___2 |= val & ((1U << available) - 1U);
#line 956
            needed___2 -= available;
#line 956
            dst___2 <<= needed___2;
#line 956
            __cil_tmp40 = pSrc;
#line 956
            pSrc ++;
#line 956
            val = (unsigned int )*__cil_tmp40;
#line 956
            available = 8;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: 
#line 956
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 956
          available -= needed___2;
#line 956
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 957
          if (length > 4UL) {
#line 958
            needed___3 = 9;
#line 958
            dst___3 = 0U;
#line 958
            if (available == 0) {
#line 958
              __cil_tmp43 = pSrc;
#line 958
              pSrc ++;
#line 958
              val = (unsigned int )*__cil_tmp43;
#line 958
              available = 8;
            }
            {
#line 958
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 958
              if (! (needed___3 > available)) {
#line 958
                goto while_break___4;
              }
#line 958
              dst___3 |= val & ((1U << available) - 1U);
#line 958
              needed___3 -= available;
#line 958
              dst___3 <<= needed___3;
#line 958
              __cil_tmp44 = pSrc;
#line 958
              pSrc ++;
#line 958
              val = (unsigned int )*__cil_tmp44;
#line 958
              available = 8;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: 
#line 958
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 958
            available -= needed___3;
#line 958
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 959
            if (length > 5UL) {
#line 960
              needed___4 = 9;
#line 960
              dst___4 = 0U;
#line 960
              if (available == 0) {
#line 960
                __cil_tmp47 = pSrc;
#line 960
                pSrc ++;
#line 960
                val = (unsigned int )*__cil_tmp47;
#line 960
                available = 8;
              }
              {
#line 960
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 960
                if (! (needed___4 > available)) {
#line 960
                  goto while_break___5;
                }
#line 960
                dst___4 |= val & ((1U << available) - 1U);
#line 960
                needed___4 -= available;
#line 960
                dst___4 <<= needed___4;
#line 960
                __cil_tmp48 = pSrc;
#line 960
                pSrc ++;
#line 960
                val = (unsigned int )*__cil_tmp48;
#line 960
                available = 8;
              }
              while_break___13: /* CIL Label */ ;
              }
              while_break___5: 
#line 960
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 960
              available -= needed___4;
#line 960
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 961
              if (length > 6UL) {
#line 962
                needed___5 = 9;
#line 962
                dst___5 = 0U;
#line 962
                if (available == 0) {
#line 962
                  __cil_tmp51 = pSrc;
#line 962
                  pSrc ++;
#line 962
                  val = (unsigned int )*__cil_tmp51;
#line 962
                  available = 8;
                }
                {
#line 962
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 962
                  if (! (needed___5 > available)) {
#line 962
                    goto while_break___6;
                  }
#line 962
                  dst___5 |= val & ((1U << available) - 1U);
#line 962
                  needed___5 -= available;
#line 962
                  dst___5 <<= needed___5;
#line 962
                  __cil_tmp52 = pSrc;
#line 962
                  pSrc ++;
#line 962
                  val = (unsigned int )*__cil_tmp52;
#line 962
                  available = 8;
                }
                while_break___14: /* CIL Label */ ;
                }
                while_break___6: 
#line 962
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 962
                available -= needed___5;
#line 962
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
#line 970
  return;
}
}
#line 971 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_10uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val0___0 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val1___0 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val2___0 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val3___0 ;
  OPJ_BYTE *__cil_tmp22 ;

  {
#line 975
  i = (OPJ_SIZE_T )0;
  {
#line 975
  while (1) {
    while_continue: /* CIL Label */ ;

#line 975
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 975
      goto while_break;
    }
#line 976
    __cil_tmp6 = pSrc;
#line 976
    pSrc ++;
#line 976
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 977
    __cil_tmp8 = pSrc;
#line 977
    pSrc ++;
#line 977
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 978
    __cil_tmp10 = pSrc;
#line 978
    pSrc ++;
#line 978
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 979
    __cil_tmp12 = pSrc;
#line 979
    pSrc ++;
#line 979
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 980
    __cil_tmp14 = pSrc;
#line 980
    pSrc ++;
#line 980
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 982
    *(pDst + i) = (OPJ_INT32 )((val0 << 2) | (val1 >> 6));
#line 983
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val1 & 63U) << 4) | (val2 >> 4));
#line 984
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val2 & 15U) << 6) | (val3 >> 2));
#line 985
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val3 & 3U) << 8) | val4);
#line 975
    i += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 988
  if (length & 3UL) {
#line 989
    __cil_tmp16 = pSrc;
#line 989
    pSrc ++;
#line 989
    val0___0 = (OPJ_UINT32 )*__cil_tmp16;
#line 990
    __cil_tmp18 = pSrc;
#line 990
    pSrc ++;
#line 990
    val1___0 = (OPJ_UINT32 )*__cil_tmp18;
#line 991
    length &= 3UL;
#line 992
    *(pDst + i) = (OPJ_INT32 )((val0___0 << 2) | (val1___0 >> 6));
#line 994
    if (length > 1UL) {
#line 995
      __cil_tmp20 = pSrc;
#line 995
      pSrc ++;
#line 995
      val2___0 = (OPJ_UINT32 )*__cil_tmp20;
#line 996
      *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val1___0 & 63U) << 4) | (val2___0 >> 4));
#line 997
      if (length > 2UL) {
#line 998
        __cil_tmp22 = pSrc;
#line 998
        pSrc ++;
#line 998
        val3___0 = (OPJ_UINT32 )*__cil_tmp22;
#line 999
        *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val2___0 & 15U) << 6) | (val3___0 >> 2));
      }
    }
  }
#line 1003
  return;
}
}
#line 1004 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_11uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val7 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val8 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_UINT32 val9 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_UINT32 val10 ;
  OPJ_BYTE *__cil_tmp26 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp47 ;
  OPJ_BYTE *__cil_tmp48 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp51 ;
  OPJ_BYTE *__cil_tmp52 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp55 ;
  OPJ_BYTE *__cil_tmp56 ;

  {
#line 1008
  i = (OPJ_SIZE_T )0;
  {
#line 1008
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1008
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 1008
      goto while_break;
    }
#line 1009
    __cil_tmp6 = pSrc;
#line 1009
    pSrc ++;
#line 1009
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 1010
    __cil_tmp8 = pSrc;
#line 1010
    pSrc ++;
#line 1010
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 1011
    __cil_tmp10 = pSrc;
#line 1011
    pSrc ++;
#line 1011
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 1012
    __cil_tmp12 = pSrc;
#line 1012
    pSrc ++;
#line 1012
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 1013
    __cil_tmp14 = pSrc;
#line 1013
    pSrc ++;
#line 1013
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 1014
    __cil_tmp16 = pSrc;
#line 1014
    pSrc ++;
#line 1014
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 1015
    __cil_tmp18 = pSrc;
#line 1015
    pSrc ++;
#line 1015
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 1016
    __cil_tmp20 = pSrc;
#line 1016
    pSrc ++;
#line 1016
    val7 = (OPJ_UINT32 )*__cil_tmp20;
#line 1017
    __cil_tmp22 = pSrc;
#line 1017
    pSrc ++;
#line 1017
    val8 = (OPJ_UINT32 )*__cil_tmp22;
#line 1018
    __cil_tmp24 = pSrc;
#line 1018
    pSrc ++;
#line 1018
    val9 = (OPJ_UINT32 )*__cil_tmp24;
#line 1019
    __cil_tmp26 = pSrc;
#line 1019
    pSrc ++;
#line 1019
    val10 = (OPJ_UINT32 )*__cil_tmp26;
#line 1021
    *(pDst + i) = (OPJ_INT32 )((val0 << 3) | (val1 >> 5));
#line 1022
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val1 & 31U) << 6) | (val2 >> 2));
#line 1023
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((((val2 & 3U) << 9) | (val3 << 1)) | (val4 >> 7));
#line 1024
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val4 & 127U) << 4) | (val5 >> 4));
#line 1025
    *(pDst + (i + 4UL)) = (OPJ_INT32 )(((val5 & 15U) << 7) | (val6 >> 1));
#line 1026
    *(pDst + (i + 5UL)) = (OPJ_INT32 )((((val6 & 1U) << 10) | (val7 << 2)) | (val8 >> 6));
#line 1027
    *(pDst + (i + 6UL)) = (OPJ_INT32 )(((val8 & 63U) << 5) | (val9 >> 3));
#line 1028
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(((val9 & 7U) << 8) | val10);
#line 1008
    i += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 1031
  if (length & 7UL) {
#line 1033
    available = 0;
#line 1035
    length &= 7UL;
#line 1037
    needed = 11;
#line 1037
    dst = 0U;
#line 1037
    if (available == 0) {
#line 1037
      __cil_tmp31 = pSrc;
#line 1037
      pSrc ++;
#line 1037
      val = (unsigned int )*__cil_tmp31;
#line 1037
      available = 8;
    }
    {
#line 1037
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1037
      if (! (needed > available)) {
#line 1037
        goto while_break___0;
      }
#line 1037
      dst |= val & ((1U << available) - 1U);
#line 1037
      needed -= available;
#line 1037
      dst <<= needed;
#line 1037
      __cil_tmp32 = pSrc;
#line 1037
      pSrc ++;
#line 1037
      val = (unsigned int )*__cil_tmp32;
#line 1037
      available = 8;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 1037
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 1037
    available -= needed;
#line 1037
    *(pDst + i) = (OPJ_INT32 )dst;
#line 1039
    if (length > 1UL) {
#line 1040
      needed___0 = 11;
#line 1040
      dst___0 = 0U;
#line 1040
      if (available == 0) {
#line 1040
        __cil_tmp35 = pSrc;
#line 1040
        pSrc ++;
#line 1040
        val = (unsigned int )*__cil_tmp35;
#line 1040
        available = 8;
      }
      {
#line 1040
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1040
        if (! (needed___0 > available)) {
#line 1040
          goto while_break___1;
        }
#line 1040
        dst___0 |= val & ((1U << available) - 1U);
#line 1040
        needed___0 -= available;
#line 1040
        dst___0 <<= needed___0;
#line 1040
        __cil_tmp36 = pSrc;
#line 1040
        pSrc ++;
#line 1040
        val = (unsigned int )*__cil_tmp36;
#line 1040
        available = 8;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 1040
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 1040
      available -= needed___0;
#line 1040
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 1041
      if (length > 2UL) {
#line 1042
        needed___1 = 11;
#line 1042
        dst___1 = 0U;
#line 1042
        if (available == 0) {
#line 1042
          __cil_tmp39 = pSrc;
#line 1042
          pSrc ++;
#line 1042
          val = (unsigned int )*__cil_tmp39;
#line 1042
          available = 8;
        }
        {
#line 1042
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1042
          if (! (needed___1 > available)) {
#line 1042
            goto while_break___2;
          }
#line 1042
          dst___1 |= val & ((1U << available) - 1U);
#line 1042
          needed___1 -= available;
#line 1042
          dst___1 <<= needed___1;
#line 1042
          __cil_tmp40 = pSrc;
#line 1042
          pSrc ++;
#line 1042
          val = (unsigned int )*__cil_tmp40;
#line 1042
          available = 8;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 1042
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 1042
        available -= needed___1;
#line 1042
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 1043
        if (length > 3UL) {
#line 1044
          needed___2 = 11;
#line 1044
          dst___2 = 0U;
#line 1044
          if (available == 0) {
#line 1044
            __cil_tmp43 = pSrc;
#line 1044
            pSrc ++;
#line 1044
            val = (unsigned int )*__cil_tmp43;
#line 1044
            available = 8;
          }
          {
#line 1044
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 1044
            if (! (needed___2 > available)) {
#line 1044
              goto while_break___3;
            }
#line 1044
            dst___2 |= val & ((1U << available) - 1U);
#line 1044
            needed___2 -= available;
#line 1044
            dst___2 <<= needed___2;
#line 1044
            __cil_tmp44 = pSrc;
#line 1044
            pSrc ++;
#line 1044
            val = (unsigned int )*__cil_tmp44;
#line 1044
            available = 8;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: 
#line 1044
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 1044
          available -= needed___2;
#line 1044
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 1045
          if (length > 4UL) {
#line 1046
            needed___3 = 11;
#line 1046
            dst___3 = 0U;
#line 1046
            if (available == 0) {
#line 1046
              __cil_tmp47 = pSrc;
#line 1046
              pSrc ++;
#line 1046
              val = (unsigned int )*__cil_tmp47;
#line 1046
              available = 8;
            }
            {
#line 1046
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 1046
              if (! (needed___3 > available)) {
#line 1046
                goto while_break___4;
              }
#line 1046
              dst___3 |= val & ((1U << available) - 1U);
#line 1046
              needed___3 -= available;
#line 1046
              dst___3 <<= needed___3;
#line 1046
              __cil_tmp48 = pSrc;
#line 1046
              pSrc ++;
#line 1046
              val = (unsigned int )*__cil_tmp48;
#line 1046
              available = 8;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: 
#line 1046
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 1046
            available -= needed___3;
#line 1046
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 1047
            if (length > 5UL) {
#line 1048
              needed___4 = 11;
#line 1048
              dst___4 = 0U;
#line 1048
              if (available == 0) {
#line 1048
                __cil_tmp51 = pSrc;
#line 1048
                pSrc ++;
#line 1048
                val = (unsigned int )*__cil_tmp51;
#line 1048
                available = 8;
              }
              {
#line 1048
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 1048
                if (! (needed___4 > available)) {
#line 1048
                  goto while_break___5;
                }
#line 1048
                dst___4 |= val & ((1U << available) - 1U);
#line 1048
                needed___4 -= available;
#line 1048
                dst___4 <<= needed___4;
#line 1048
                __cil_tmp52 = pSrc;
#line 1048
                pSrc ++;
#line 1048
                val = (unsigned int )*__cil_tmp52;
#line 1048
                available = 8;
              }
              while_break___13: /* CIL Label */ ;
              }
              while_break___5: 
#line 1048
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 1048
              available -= needed___4;
#line 1048
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 1049
              if (length > 6UL) {
#line 1050
                needed___5 = 11;
#line 1050
                dst___5 = 0U;
#line 1050
                if (available == 0) {
#line 1050
                  __cil_tmp55 = pSrc;
#line 1050
                  pSrc ++;
#line 1050
                  val = (unsigned int )*__cil_tmp55;
#line 1050
                  available = 8;
                }
                {
#line 1050
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 1050
                  if (! (needed___5 > available)) {
#line 1050
                    goto while_break___6;
                  }
#line 1050
                  dst___5 |= val & ((1U << available) - 1U);
#line 1050
                  needed___5 -= available;
#line 1050
                  dst___5 <<= needed___5;
#line 1050
                  __cil_tmp56 = pSrc;
#line 1050
                  pSrc ++;
#line 1050
                  val = (unsigned int )*__cil_tmp56;
#line 1050
                  available = 8;
                }
                while_break___14: /* CIL Label */ ;
                }
                while_break___6: 
#line 1050
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 1050
                available -= needed___5;
#line 1050
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
#line 1058
  return;
}
}
#line 1059 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_12uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val0___0 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val1___0 ;
  OPJ_BYTE *__cil_tmp14 ;

  {
#line 1063
  i = (OPJ_SIZE_T )0;
  {
#line 1063
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1063
    if (! (i < (length & 0xfffffffffffffffeUL))) {
#line 1063
      goto while_break;
    }
#line 1064
    __cil_tmp6 = pSrc;
#line 1064
    pSrc ++;
#line 1064
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 1065
    __cil_tmp8 = pSrc;
#line 1065
    pSrc ++;
#line 1065
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 1066
    __cil_tmp10 = pSrc;
#line 1066
    pSrc ++;
#line 1066
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 1068
    *(pDst + i) = (OPJ_INT32 )((val0 << 4) | (val1 >> 4));
#line 1069
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val1 & 15U) << 8) | val2);
#line 1063
    i += 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1071
  if (length & 1UL) {
#line 1072
    __cil_tmp12 = pSrc;
#line 1072
    pSrc ++;
#line 1072
    val0___0 = (OPJ_UINT32 )*__cil_tmp12;
#line 1073
    __cil_tmp14 = pSrc;
#line 1073
    pSrc ++;
#line 1073
    val1___0 = (OPJ_UINT32 )*__cil_tmp14;
#line 1074
    *(pDst + i) = (OPJ_INT32 )((val0___0 << 4) | (val1___0 >> 4));
  }
#line 1076
  return;
}
}
#line 1077 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_13uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val7 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val8 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_UINT32 val9 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_UINT32 val10 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_UINT32 val11 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_UINT32 val12 ;
  OPJ_BYTE *__cil_tmp30 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp47 ;
  OPJ_BYTE *__cil_tmp48 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp51 ;
  OPJ_BYTE *__cil_tmp52 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp55 ;
  OPJ_BYTE *__cil_tmp56 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp59 ;
  OPJ_BYTE *__cil_tmp60 ;

  {
#line 1081
  i = (OPJ_SIZE_T )0;
  {
#line 1081
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1081
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 1081
      goto while_break;
    }
#line 1082
    __cil_tmp6 = pSrc;
#line 1082
    pSrc ++;
#line 1082
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 1083
    __cil_tmp8 = pSrc;
#line 1083
    pSrc ++;
#line 1083
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 1084
    __cil_tmp10 = pSrc;
#line 1084
    pSrc ++;
#line 1084
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 1085
    __cil_tmp12 = pSrc;
#line 1085
    pSrc ++;
#line 1085
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 1086
    __cil_tmp14 = pSrc;
#line 1086
    pSrc ++;
#line 1086
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 1087
    __cil_tmp16 = pSrc;
#line 1087
    pSrc ++;
#line 1087
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 1088
    __cil_tmp18 = pSrc;
#line 1088
    pSrc ++;
#line 1088
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 1089
    __cil_tmp20 = pSrc;
#line 1089
    pSrc ++;
#line 1089
    val7 = (OPJ_UINT32 )*__cil_tmp20;
#line 1090
    __cil_tmp22 = pSrc;
#line 1090
    pSrc ++;
#line 1090
    val8 = (OPJ_UINT32 )*__cil_tmp22;
#line 1091
    __cil_tmp24 = pSrc;
#line 1091
    pSrc ++;
#line 1091
    val9 = (OPJ_UINT32 )*__cil_tmp24;
#line 1092
    __cil_tmp26 = pSrc;
#line 1092
    pSrc ++;
#line 1092
    val10 = (OPJ_UINT32 )*__cil_tmp26;
#line 1093
    __cil_tmp28 = pSrc;
#line 1093
    pSrc ++;
#line 1093
    val11 = (OPJ_UINT32 )*__cil_tmp28;
#line 1094
    __cil_tmp30 = pSrc;
#line 1094
    pSrc ++;
#line 1094
    val12 = (OPJ_UINT32 )*__cil_tmp30;
#line 1096
    *(pDst + i) = (OPJ_INT32 )((val0 << 5) | (val1 >> 3));
#line 1097
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((((val1 & 7U) << 10) | (val2 << 2)) | (val3 >> 6));
#line 1098
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val3 & 63U) << 7) | (val4 >> 1));
#line 1099
    *(pDst + (i + 3UL)) = (OPJ_INT32 )((((val4 & 1U) << 12) | (val5 << 4)) | (val6 >> 4));
#line 1100
    *(pDst + (i + 4UL)) = (OPJ_INT32 )((((val6 & 15U) << 9) | (val7 << 1)) | (val8 >> 7));
#line 1101
    *(pDst + (i + 5UL)) = (OPJ_INT32 )(((val8 & 127U) << 6) | (val9 >> 2));
#line 1102
    *(pDst + (i + 6UL)) = (OPJ_INT32 )((((val9 & 3U) << 11) | (val10 << 3)) | (val11 >> 5));
#line 1103
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(((val11 & 31U) << 8) | val12);
#line 1081
    i += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 1106
  if (length & 7UL) {
#line 1108
    available = 0;
#line 1110
    length &= 7UL;
#line 1112
    needed = 13;
#line 1112
    dst = 0U;
#line 1112
    if (available == 0) {
#line 1112
      __cil_tmp35 = pSrc;
#line 1112
      pSrc ++;
#line 1112
      val = (unsigned int )*__cil_tmp35;
#line 1112
      available = 8;
    }
    {
#line 1112
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1112
      if (! (needed > available)) {
#line 1112
        goto while_break___0;
      }
#line 1112
      dst |= val & ((1U << available) - 1U);
#line 1112
      needed -= available;
#line 1112
      dst <<= needed;
#line 1112
      __cil_tmp36 = pSrc;
#line 1112
      pSrc ++;
#line 1112
      val = (unsigned int )*__cil_tmp36;
#line 1112
      available = 8;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 1112
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 1112
    available -= needed;
#line 1112
    *(pDst + i) = (OPJ_INT32 )dst;
#line 1114
    if (length > 1UL) {
#line 1115
      needed___0 = 13;
#line 1115
      dst___0 = 0U;
#line 1115
      if (available == 0) {
#line 1115
        __cil_tmp39 = pSrc;
#line 1115
        pSrc ++;
#line 1115
        val = (unsigned int )*__cil_tmp39;
#line 1115
        available = 8;
      }
      {
#line 1115
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1115
        if (! (needed___0 > available)) {
#line 1115
          goto while_break___1;
        }
#line 1115
        dst___0 |= val & ((1U << available) - 1U);
#line 1115
        needed___0 -= available;
#line 1115
        dst___0 <<= needed___0;
#line 1115
        __cil_tmp40 = pSrc;
#line 1115
        pSrc ++;
#line 1115
        val = (unsigned int )*__cil_tmp40;
#line 1115
        available = 8;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 1115
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 1115
      available -= needed___0;
#line 1115
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 1116
      if (length > 2UL) {
#line 1117
        needed___1 = 13;
#line 1117
        dst___1 = 0U;
#line 1117
        if (available == 0) {
#line 1117
          __cil_tmp43 = pSrc;
#line 1117
          pSrc ++;
#line 1117
          val = (unsigned int )*__cil_tmp43;
#line 1117
          available = 8;
        }
        {
#line 1117
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1117
          if (! (needed___1 > available)) {
#line 1117
            goto while_break___2;
          }
#line 1117
          dst___1 |= val & ((1U << available) - 1U);
#line 1117
          needed___1 -= available;
#line 1117
          dst___1 <<= needed___1;
#line 1117
          __cil_tmp44 = pSrc;
#line 1117
          pSrc ++;
#line 1117
          val = (unsigned int )*__cil_tmp44;
#line 1117
          available = 8;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 1117
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 1117
        available -= needed___1;
#line 1117
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 1118
        if (length > 3UL) {
#line 1119
          needed___2 = 13;
#line 1119
          dst___2 = 0U;
#line 1119
          if (available == 0) {
#line 1119
            __cil_tmp47 = pSrc;
#line 1119
            pSrc ++;
#line 1119
            val = (unsigned int )*__cil_tmp47;
#line 1119
            available = 8;
          }
          {
#line 1119
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 1119
            if (! (needed___2 > available)) {
#line 1119
              goto while_break___3;
            }
#line 1119
            dst___2 |= val & ((1U << available) - 1U);
#line 1119
            needed___2 -= available;
#line 1119
            dst___2 <<= needed___2;
#line 1119
            __cil_tmp48 = pSrc;
#line 1119
            pSrc ++;
#line 1119
            val = (unsigned int )*__cil_tmp48;
#line 1119
            available = 8;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: 
#line 1119
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 1119
          available -= needed___2;
#line 1119
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 1120
          if (length > 4UL) {
#line 1121
            needed___3 = 13;
#line 1121
            dst___3 = 0U;
#line 1121
            if (available == 0) {
#line 1121
              __cil_tmp51 = pSrc;
#line 1121
              pSrc ++;
#line 1121
              val = (unsigned int )*__cil_tmp51;
#line 1121
              available = 8;
            }
            {
#line 1121
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 1121
              if (! (needed___3 > available)) {
#line 1121
                goto while_break___4;
              }
#line 1121
              dst___3 |= val & ((1U << available) - 1U);
#line 1121
              needed___3 -= available;
#line 1121
              dst___3 <<= needed___3;
#line 1121
              __cil_tmp52 = pSrc;
#line 1121
              pSrc ++;
#line 1121
              val = (unsigned int )*__cil_tmp52;
#line 1121
              available = 8;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: 
#line 1121
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 1121
            available -= needed___3;
#line 1121
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 1122
            if (length > 5UL) {
#line 1123
              needed___4 = 13;
#line 1123
              dst___4 = 0U;
#line 1123
              if (available == 0) {
#line 1123
                __cil_tmp55 = pSrc;
#line 1123
                pSrc ++;
#line 1123
                val = (unsigned int )*__cil_tmp55;
#line 1123
                available = 8;
              }
              {
#line 1123
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 1123
                if (! (needed___4 > available)) {
#line 1123
                  goto while_break___5;
                }
#line 1123
                dst___4 |= val & ((1U << available) - 1U);
#line 1123
                needed___4 -= available;
#line 1123
                dst___4 <<= needed___4;
#line 1123
                __cil_tmp56 = pSrc;
#line 1123
                pSrc ++;
#line 1123
                val = (unsigned int )*__cil_tmp56;
#line 1123
                available = 8;
              }
              while_break___13: /* CIL Label */ ;
              }
              while_break___5: 
#line 1123
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 1123
              available -= needed___4;
#line 1123
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 1124
              if (length > 6UL) {
#line 1125
                needed___5 = 13;
#line 1125
                dst___5 = 0U;
#line 1125
                if (available == 0) {
#line 1125
                  __cil_tmp59 = pSrc;
#line 1125
                  pSrc ++;
#line 1125
                  val = (unsigned int )*__cil_tmp59;
#line 1125
                  available = 8;
                }
                {
#line 1125
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 1125
                  if (! (needed___5 > available)) {
#line 1125
                    goto while_break___6;
                  }
#line 1125
                  dst___5 |= val & ((1U << available) - 1U);
#line 1125
                  needed___5 -= available;
#line 1125
                  dst___5 <<= needed___5;
#line 1125
                  __cil_tmp60 = pSrc;
#line 1125
                  pSrc ++;
#line 1125
                  val = (unsigned int )*__cil_tmp60;
#line 1125
                  available = 8;
                }
                while_break___14: /* CIL Label */ ;
                }
                while_break___6: 
#line 1125
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 1125
                available -= needed___5;
#line 1125
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
#line 1133
  return;
}
}
#line 1134 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_14uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val0___0 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val1___0 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_UINT32 val2___0 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_UINT32 val3___0 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_UINT32 val4___0 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_UINT32 val5___0 ;
  OPJ_BYTE *__cil_tmp30 ;

  {
#line 1138
  i = (OPJ_SIZE_T )0;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1138
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 1138
      goto while_break;
    }
#line 1139
    __cil_tmp6 = pSrc;
#line 1139
    pSrc ++;
#line 1139
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 1140
    __cil_tmp8 = pSrc;
#line 1140
    pSrc ++;
#line 1140
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 1141
    __cil_tmp10 = pSrc;
#line 1141
    pSrc ++;
#line 1141
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 1142
    __cil_tmp12 = pSrc;
#line 1142
    pSrc ++;
#line 1142
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 1143
    __cil_tmp14 = pSrc;
#line 1143
    pSrc ++;
#line 1143
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 1144
    __cil_tmp16 = pSrc;
#line 1144
    pSrc ++;
#line 1144
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 1145
    __cil_tmp18 = pSrc;
#line 1145
    pSrc ++;
#line 1145
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 1147
    *(pDst + i) = (OPJ_INT32 )((val0 << 6) | (val1 >> 2));
#line 1148
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((((val1 & 3U) << 12) | (val2 << 4)) | (val3 >> 4));
#line 1149
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((((val3 & 15U) << 10) | (val4 << 2)) | (val5 >> 6));
#line 1150
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val5 & 63U) << 8) | val6);
#line 1138
    i += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1153
  if (length & 3UL) {
#line 1154
    __cil_tmp20 = pSrc;
#line 1154
    pSrc ++;
#line 1154
    val0___0 = (OPJ_UINT32 )*__cil_tmp20;
#line 1155
    __cil_tmp22 = pSrc;
#line 1155
    pSrc ++;
#line 1155
    val1___0 = (OPJ_UINT32 )*__cil_tmp22;
#line 1156
    length &= 3UL;
#line 1157
    *(pDst + i) = (OPJ_INT32 )((val0___0 << 6) | (val1___0 >> 2));
#line 1159
    if (length > 1UL) {
#line 1160
      __cil_tmp24 = pSrc;
#line 1160
      pSrc ++;
#line 1160
      val2___0 = (OPJ_UINT32 )*__cil_tmp24;
#line 1161
      __cil_tmp26 = pSrc;
#line 1161
      pSrc ++;
#line 1161
      val3___0 = (OPJ_UINT32 )*__cil_tmp26;
#line 1162
      *(pDst + (i + 1UL)) = (OPJ_INT32 )((((val1___0 & 3U) << 12) | (val2___0 << 4)) | (val3___0 >> 4));
#line 1163
      if (length > 2UL) {
#line 1164
        __cil_tmp28 = pSrc;
#line 1164
        pSrc ++;
#line 1164
        val4___0 = (OPJ_UINT32 )*__cil_tmp28;
#line 1165
        __cil_tmp30 = pSrc;
#line 1165
        pSrc ++;
#line 1165
        val5___0 = (OPJ_UINT32 )*__cil_tmp30;
#line 1166
        *(pDst + (i + 2UL)) = (OPJ_INT32 )((((val3___0 & 15U) << 10) | (val4___0 << 2)) | (val5___0 >> 6));
      }
    }
  }
#line 1170
  return;
}
}
#line 1171 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_15uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val7 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val8 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_UINT32 val9 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_UINT32 val10 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_UINT32 val11 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_UINT32 val12 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_UINT32 val13 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_UINT32 val14 ;
  OPJ_BYTE *__cil_tmp34 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp47 ;
  OPJ_BYTE *__cil_tmp48 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp51 ;
  OPJ_BYTE *__cil_tmp52 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp55 ;
  OPJ_BYTE *__cil_tmp56 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp59 ;
  OPJ_BYTE *__cil_tmp60 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp63 ;
  OPJ_BYTE *__cil_tmp64 ;

  {
#line 1175
  i = (OPJ_SIZE_T )0;
  {
#line 1175
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1175
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 1175
      goto while_break;
    }
#line 1176
    __cil_tmp6 = pSrc;
#line 1176
    pSrc ++;
#line 1176
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 1177
    __cil_tmp8 = pSrc;
#line 1177
    pSrc ++;
#line 1177
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 1178
    __cil_tmp10 = pSrc;
#line 1178
    pSrc ++;
#line 1178
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 1179
    __cil_tmp12 = pSrc;
#line 1179
    pSrc ++;
#line 1179
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 1180
    __cil_tmp14 = pSrc;
#line 1180
    pSrc ++;
#line 1180
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 1181
    __cil_tmp16 = pSrc;
#line 1181
    pSrc ++;
#line 1181
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 1182
    __cil_tmp18 = pSrc;
#line 1182
    pSrc ++;
#line 1182
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 1183
    __cil_tmp20 = pSrc;
#line 1183
    pSrc ++;
#line 1183
    val7 = (OPJ_UINT32 )*__cil_tmp20;
#line 1184
    __cil_tmp22 = pSrc;
#line 1184
    pSrc ++;
#line 1184
    val8 = (OPJ_UINT32 )*__cil_tmp22;
#line 1185
    __cil_tmp24 = pSrc;
#line 1185
    pSrc ++;
#line 1185
    val9 = (OPJ_UINT32 )*__cil_tmp24;
#line 1186
    __cil_tmp26 = pSrc;
#line 1186
    pSrc ++;
#line 1186
    val10 = (OPJ_UINT32 )*__cil_tmp26;
#line 1187
    __cil_tmp28 = pSrc;
#line 1187
    pSrc ++;
#line 1187
    val11 = (OPJ_UINT32 )*__cil_tmp28;
#line 1188
    __cil_tmp30 = pSrc;
#line 1188
    pSrc ++;
#line 1188
    val12 = (OPJ_UINT32 )*__cil_tmp30;
#line 1189
    __cil_tmp32 = pSrc;
#line 1189
    pSrc ++;
#line 1189
    val13 = (OPJ_UINT32 )*__cil_tmp32;
#line 1190
    __cil_tmp34 = pSrc;
#line 1190
    pSrc ++;
#line 1190
    val14 = (OPJ_UINT32 )*__cil_tmp34;
#line 1192
    *(pDst + i) = (OPJ_INT32 )((val0 << 7) | (val1 >> 1));
#line 1193
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((((val1 & 1U) << 14) | (val2 << 6)) | (val3 >> 2));
#line 1194
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((((val3 & 3U) << 13) | (val4 << 5)) | (val5 >> 3));
#line 1195
    *(pDst + (i + 3UL)) = (OPJ_INT32 )((((val5 & 7U) << 12) | (val6 << 4)) | (val7 >> 4));
#line 1196
    *(pDst + (i + 4UL)) = (OPJ_INT32 )((((val7 & 15U) << 11) | (val8 << 3)) | (val9 >> 5));
#line 1197
    *(pDst + (i + 5UL)) = (OPJ_INT32 )((((val9 & 31U) << 10) | (val10 << 2)) | (val11 >> 6));
#line 1198
    *(pDst + (i + 6UL)) = (OPJ_INT32 )((((val11 & 63U) << 9) | (val12 << 1)) | (val13 >> 7));
#line 1199
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(((val13 & 127U) << 8) | val14);
#line 1175
    i += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 1202
  if (length & 7UL) {
#line 1204
    available = 0;
#line 1206
    length &= 7UL;
#line 1208
    needed = 15;
#line 1208
    dst = 0U;
#line 1208
    if (available == 0) {
#line 1208
      __cil_tmp39 = pSrc;
#line 1208
      pSrc ++;
#line 1208
      val = (unsigned int )*__cil_tmp39;
#line 1208
      available = 8;
    }
    {
#line 1208
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1208
      if (! (needed > available)) {
#line 1208
        goto while_break___0;
      }
#line 1208
      dst |= val & ((1U << available) - 1U);
#line 1208
      needed -= available;
#line 1208
      dst <<= needed;
#line 1208
      __cil_tmp40 = pSrc;
#line 1208
      pSrc ++;
#line 1208
      val = (unsigned int )*__cil_tmp40;
#line 1208
      available = 8;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 1208
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 1208
    available -= needed;
#line 1208
    *(pDst + i) = (OPJ_INT32 )dst;
#line 1210
    if (length > 1UL) {
#line 1211
      needed___0 = 15;
#line 1211
      dst___0 = 0U;
#line 1211
      if (available == 0) {
#line 1211
        __cil_tmp43 = pSrc;
#line 1211
        pSrc ++;
#line 1211
        val = (unsigned int )*__cil_tmp43;
#line 1211
        available = 8;
      }
      {
#line 1211
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1211
        if (! (needed___0 > available)) {
#line 1211
          goto while_break___1;
        }
#line 1211
        dst___0 |= val & ((1U << available) - 1U);
#line 1211
        needed___0 -= available;
#line 1211
        dst___0 <<= needed___0;
#line 1211
        __cil_tmp44 = pSrc;
#line 1211
        pSrc ++;
#line 1211
        val = (unsigned int )*__cil_tmp44;
#line 1211
        available = 8;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 1211
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 1211
      available -= needed___0;
#line 1211
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 1212
      if (length > 2UL) {
#line 1213
        needed___1 = 15;
#line 1213
        dst___1 = 0U;
#line 1213
        if (available == 0) {
#line 1213
          __cil_tmp47 = pSrc;
#line 1213
          pSrc ++;
#line 1213
          val = (unsigned int )*__cil_tmp47;
#line 1213
          available = 8;
        }
        {
#line 1213
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1213
          if (! (needed___1 > available)) {
#line 1213
            goto while_break___2;
          }
#line 1213
          dst___1 |= val & ((1U << available) - 1U);
#line 1213
          needed___1 -= available;
#line 1213
          dst___1 <<= needed___1;
#line 1213
          __cil_tmp48 = pSrc;
#line 1213
          pSrc ++;
#line 1213
          val = (unsigned int )*__cil_tmp48;
#line 1213
          available = 8;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 1213
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 1213
        available -= needed___1;
#line 1213
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 1214
        if (length > 3UL) {
#line 1215
          needed___2 = 15;
#line 1215
          dst___2 = 0U;
#line 1215
          if (available == 0) {
#line 1215
            __cil_tmp51 = pSrc;
#line 1215
            pSrc ++;
#line 1215
            val = (unsigned int )*__cil_tmp51;
#line 1215
            available = 8;
          }
          {
#line 1215
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 1215
            if (! (needed___2 > available)) {
#line 1215
              goto while_break___3;
            }
#line 1215
            dst___2 |= val & ((1U << available) - 1U);
#line 1215
            needed___2 -= available;
#line 1215
            dst___2 <<= needed___2;
#line 1215
            __cil_tmp52 = pSrc;
#line 1215
            pSrc ++;
#line 1215
            val = (unsigned int )*__cil_tmp52;
#line 1215
            available = 8;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: 
#line 1215
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 1215
          available -= needed___2;
#line 1215
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 1216
          if (length > 4UL) {
#line 1217
            needed___3 = 15;
#line 1217
            dst___3 = 0U;
#line 1217
            if (available == 0) {
#line 1217
              __cil_tmp55 = pSrc;
#line 1217
              pSrc ++;
#line 1217
              val = (unsigned int )*__cil_tmp55;
#line 1217
              available = 8;
            }
            {
#line 1217
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 1217
              if (! (needed___3 > available)) {
#line 1217
                goto while_break___4;
              }
#line 1217
              dst___3 |= val & ((1U << available) - 1U);
#line 1217
              needed___3 -= available;
#line 1217
              dst___3 <<= needed___3;
#line 1217
              __cil_tmp56 = pSrc;
#line 1217
              pSrc ++;
#line 1217
              val = (unsigned int )*__cil_tmp56;
#line 1217
              available = 8;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: 
#line 1217
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 1217
            available -= needed___3;
#line 1217
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 1218
            if (length > 5UL) {
#line 1219
              needed___4 = 15;
#line 1219
              dst___4 = 0U;
#line 1219
              if (available == 0) {
#line 1219
                __cil_tmp59 = pSrc;
#line 1219
                pSrc ++;
#line 1219
                val = (unsigned int )*__cil_tmp59;
#line 1219
                available = 8;
              }
              {
#line 1219
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 1219
                if (! (needed___4 > available)) {
#line 1219
                  goto while_break___5;
                }
#line 1219
                dst___4 |= val & ((1U << available) - 1U);
#line 1219
                needed___4 -= available;
#line 1219
                dst___4 <<= needed___4;
#line 1219
                __cil_tmp60 = pSrc;
#line 1219
                pSrc ++;
#line 1219
                val = (unsigned int )*__cil_tmp60;
#line 1219
                available = 8;
              }
              while_break___13: /* CIL Label */ ;
              }
              while_break___5: 
#line 1219
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 1219
              available -= needed___4;
#line 1219
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 1220
              if (length > 6UL) {
#line 1221
                needed___5 = 15;
#line 1221
                dst___5 = 0U;
#line 1221
                if (available == 0) {
#line 1221
                  __cil_tmp63 = pSrc;
#line 1221
                  pSrc ++;
#line 1221
                  val = (unsigned int )*__cil_tmp63;
#line 1221
                  available = 8;
                }
                {
#line 1221
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 1221
                  if (! (needed___5 > available)) {
#line 1221
                    goto while_break___6;
                  }
#line 1221
                  dst___5 |= val & ((1U << available) - 1U);
#line 1221
                  needed___5 -= available;
#line 1221
                  dst___5 <<= needed___5;
#line 1221
                  __cil_tmp64 = pSrc;
#line 1221
                  pSrc ++;
#line 1221
                  val = (unsigned int )*__cil_tmp64;
#line 1221
                  available = 8;
                }
                while_break___14: /* CIL Label */ ;
                }
                while_break___6: 
#line 1221
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 1221
                available -= needed___5;
#line 1221
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
#line 1229
  return;
}
}
#line 1232 "/root/patron/new_24/src/bin/jp2/converttif.c"
static void tif_16uto32s(OPJ_UINT16 *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;

  {
#line 1236
  i = (OPJ_SIZE_T )0;
  {
#line 1236
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1236
    if (! (i < length)) {
#line 1236
      goto while_break;
    }
#line 1237
    *(pDst + i) = (OPJ_INT32 )*(pSrc + i);
#line 1236
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1240
  return;
}
}
#line 1245 "/root/patron/new_24/src/bin/jp2/converttif.c"
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  TIFF *tif ;
  tdata_t buf ;
  tstrip_t strip ;
  int64_t strip_size ;
  int64_t rowStride ;
  int64_t TIFF_MAX ;
  int j ;
  int currentPlane ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  uint16 tiBps ;
  uint16 tiPhoto ;
  uint16 tiSf ;
  uint16 tiSpp ;
  uint16 tiPC ;
  uint32 tiWidth ;
  uint32 tiHeight ;
  OPJ_BOOL is_cinema ;
  void (*cvtTifTo32s)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ) ;
  void (*cvtCxToPx)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  ) ;
  OPJ_INT32 *buffer32s ;
  OPJ_INT32 *planes[4] ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 tmp___0 ;
  tmsize_t __cil_tmp37 ;
  void *__cil_tmp39 ;
  uint32 __cil_tmp40 ;
  OPJ_UINT8 *dat8 ;
  int64_t ssize ;
  tmsize_t __cil_tmp43 ;
  int __cil_tmp44 ;
  int tmp___1 ;

  {
#line 1247
  subsampling_dx = parameters->subsampling_dx;
#line 1248
  subsampling_dy = parameters->subsampling_dy;
#line 1253
  numcomps = 0;
#line 1254
  color_space = (OPJ_COLOR_SPACE )-1;
#line 1256
  image = (opj_image_t *)((void *)0);
#line 1259
  if ((int )parameters->rsiz >= 3) {
#line 1259
    if ((int )parameters->rsiz <= 6) {
#line 1259
      tmp___1 = 1;
    } else {
#line 1259
      tmp___1 = 0;
    }
  } else {
#line 1259
    tmp___1 = 0;
  }
  {
#line 1259
  is_cinema = tmp___1;
#line 1260
  cvtTifTo32s = (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0);
#line 1261
  cvtCxToPx = (void (*)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  ))((void *)0);
#line 1262
  buffer32s = (OPJ_INT32 *)((void *)0);
#line 1265
  tif = TIFFOpen(filename, "r");
  }
#line 1267
  if (! tif) {
    {
#line 1268
    fprintf(stderr, "tiftoimage:Failed to open %s for reading\n", filename);
    }
#line 1269
    return ((opj_image_t *)0);
  }
  {
#line 1271
  tiPC = (uint16 )0;
#line 1271
  tiSpp = tiPC;
#line 1271
  tiSf = tiSpp;
#line 1271
  tiPhoto = tiSf;
#line 1271
  tiBps = tiPhoto;
#line 1272
  tiHeight = (uint32 )0;
#line 1272
  tiWidth = tiHeight;
#line 1274
  TIFFGetField(tif, (uint32 )256, & tiWidth);
#line 1275
  TIFFGetField(tif, (uint32 )257, & tiHeight);
#line 1276
  TIFFGetField(tif, (uint32 )258, & tiBps);
#line 1277
  TIFFGetField(tif, (uint32 )339, & tiSf);
#line 1278
  TIFFGetField(tif, (uint32 )277, & tiSpp);
#line 1279
  TIFFGetField(tif, (uint32 )262, & tiPhoto);
#line 1280
  TIFFGetField(tif, (uint32 )284, & tiPC);
#line 1281
  w = (int )tiWidth;
#line 1282
  h = (int )tiHeight;
  }
#line 1284
  if ((int )tiSpp == 0) {
    {
#line 1285
    fprintf(stderr, "tiftoimage: Bad value for samples per pixel == %d.\n\tAborting.\n",
            (int )tiSpp);
#line 1287
    TIFFClose(tif);
    }
#line 1288
    return ((opj_image_t *)((void *)0));
  } else
#line 1284
  if ((int )tiSpp > 4) {
    {
#line 1285
    fprintf(stderr, "tiftoimage: Bad value for samples per pixel == %d.\n\tAborting.\n",
            (int )tiSpp);
#line 1287
    TIFFClose(tif);
    }
#line 1288
    return ((opj_image_t *)((void *)0));
  }
#line 1290
  if ((unsigned int )tiBps > 16U) {
    {
#line 1291
    fprintf(stderr, "tiftoimage: Bad values for Bits == %d.\n\tMax. 16 Bits are allowed here.\n\tAborting.\n",
            (int )tiBps);
#line 1293
    TIFFClose(tif);
    }
#line 1294
    return ((opj_image_t *)((void *)0));
  } else
#line 1290
  if ((int )tiBps == 0) {
    {
#line 1291
    fprintf(stderr, "tiftoimage: Bad values for Bits == %d.\n\tMax. 16 Bits are allowed here.\n\tAborting.\n",
            (int )tiBps);
#line 1293
    TIFFClose(tif);
    }
#line 1294
    return ((opj_image_t *)((void *)0));
  }
#line 1296
  if ((int )tiPhoto != 1) {
#line 1296
    if ((int )tiPhoto != 2) {
      {
#line 1297
      fprintf(stderr, "tiftoimage: Bad color format %d.\n\tOnly RGB(A) and GRAY(A) has been implemented\n\tAborting.\n",
              (int )tiPhoto);
#line 1300
      TIFFClose(tif);
      }
#line 1301
      return ((opj_image_t *)((void *)0));
    }
  }
#line 1303
  if (tiWidth == 0U) {
    {
#line 1304
    fprintf(stderr, "tiftoimage: Bad values for width(%u) and/or height(%u)\n\tAborting.\n",
            tiWidth, tiHeight);
#line 1306
    TIFFClose(tif);
    }
#line 1307
    return ((opj_image_t *)((void *)0));
  } else
#line 1303
  if (tiHeight == 0U) {
    {
#line 1304
    fprintf(stderr, "tiftoimage: Bad values for width(%u) and/or height(%u)\n\tAborting.\n",
            tiWidth, tiHeight);
#line 1306
    TIFFClose(tif);
    }
#line 1307
    return ((opj_image_t *)((void *)0));
  }
#line 1309
  w = (int )tiWidth;
#line 1310
  h = (int )tiHeight;
#line 1317
  if ((int )tiBps == 8) {
#line 1317
    goto case_8;
  }
#line 1317
  if ((int )tiBps == 6) {
#line 1317
    goto case_8;
  }
#line 1317
  if ((int )tiBps == 4) {
#line 1317
    goto case_8;
  }
#line 1317
  if ((int )tiBps == 2) {
#line 1317
    goto case_8;
  }
#line 1317
  if ((int )tiBps == 1) {
#line 1317
    goto case_8;
  }
#line 1321
  if ((int )tiBps == 3) {
#line 1321
    goto case_3;
  }
#line 1324
  if ((int )tiBps == 5) {
#line 1324
    goto case_5;
  }
#line 1327
  if ((int )tiBps == 7) {
#line 1327
    goto case_7;
  }
#line 1330
  if ((int )tiBps == 9) {
#line 1330
    goto case_9;
  }
#line 1333
  if ((int )tiBps == 10) {
#line 1333
    goto case_10;
  }
#line 1336
  if ((int )tiBps == 11) {
#line 1336
    goto case_11;
  }
#line 1339
  if ((int )tiBps == 12) {
#line 1339
    goto case_12;
  }
#line 1342
  if ((int )tiBps == 13) {
#line 1342
    goto case_13;
  }
#line 1345
  if ((int )tiBps == 14) {
#line 1345
    goto case_14;
  }
#line 1348
  if ((int )tiBps == 15) {
#line 1348
    goto case_15;
  }
#line 1351
  if ((int )tiBps == 16) {
#line 1351
    goto case_16;
  }
#line 1354
  goto switch_default;
  case_8: 
#line 1318
  cvtTifTo32s = convert_XXu32s_C1R_LUT[tiBps];
#line 1319
  goto switch_break;
  case_3: 
#line 1322
  cvtTifTo32s = & tif_3uto32s;
#line 1323
  goto switch_break;
  case_5: 
#line 1325
  cvtTifTo32s = & tif_5uto32s;
#line 1326
  goto switch_break;
  case_7: 
#line 1328
  cvtTifTo32s = & tif_7uto32s;
#line 1329
  goto switch_break;
  case_9: 
#line 1331
  cvtTifTo32s = & tif_9uto32s;
#line 1332
  goto switch_break;
  case_10: 
#line 1334
  cvtTifTo32s = & tif_10uto32s;
#line 1335
  goto switch_break;
  case_11: 
#line 1337
  cvtTifTo32s = & tif_11uto32s;
#line 1338
  goto switch_break;
  case_12: 
#line 1340
  cvtTifTo32s = & tif_12uto32s;
#line 1341
  goto switch_break;
  case_13: 
#line 1343
  cvtTifTo32s = & tif_13uto32s;
#line 1344
  goto switch_break;
  case_14: 
#line 1346
  cvtTifTo32s = & tif_14uto32s;
#line 1347
  goto switch_break;
  case_15: 
#line 1349
  cvtTifTo32s = & tif_15uto32s;
#line 1350
  goto switch_break;
  case_16: 
#line 1352
  cvtTifTo32s = (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))(& tif_16uto32s);
#line 1353
  goto switch_break;
  switch_default: 
#line 1356
  goto switch_break;
  switch_break: 
  {
#line 1360
  memset((void *)(& cmptparm[0]), 0, 4UL * sizeof(opj_image_cmptparm_t ));
  }
#line 1362
  if ((int )tiPhoto == 2) {
#line 1362
    if (is_cinema) {
#line 1362
      if ((unsigned int )tiBps != 12U) {
        {
#line 1363
        fprintf(stdout, "WARNING:\nInput image bitdepth is %d bits\nTIF conversion has automatically rescaled to 12-bits\nto comply with cinema profiles.\n",
                (int )tiBps);
        }
      } else {
#line 1369
        is_cinema = (OPJ_BOOL )0U;
      }
    } else {
#line 1369
      is_cinema = (OPJ_BOOL )0U;
    }
  } else {
#line 1369
    is_cinema = (OPJ_BOOL )0U;
  }
#line 1372
  numcomps = (int )tiSpp;
#line 1373
  if ((int )tiPhoto == 2) {
#line 1374
    color_space = (OPJ_COLOR_SPACE )1;
  } else
#line 1375
  if ((int )tiPhoto == 1) {
#line 1376
    color_space = (OPJ_COLOR_SPACE )2;
  }
#line 1379
  cvtCxToPx = convert_32s_CXPX_LUT[numcomps];
#line 1380
  if ((int )tiPC == 2) {
#line 1381
    cvtCxToPx = convert_32s_CXPX_LUT[1];
#line 1382
    tiSpp = (uint16 )1U;
  }
#line 1385
  j = 0;
  {
#line 1385
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1385
    if (! (j < numcomps)) {
#line 1385
      goto while_break;
    }
#line 1386
    cmptparm[j].prec = (OPJ_UINT32 )tiBps;
#line 1387
    cmptparm[j].bpp = (OPJ_UINT32 )tiBps;
#line 1388
    cmptparm[j].dx = (OPJ_UINT32 )subsampling_dx;
#line 1389
    cmptparm[j].dy = (OPJ_UINT32 )subsampling_dy;
#line 1390
    cmptparm[j].w = (OPJ_UINT32 )w;
#line 1391
    cmptparm[j].h = (OPJ_UINT32 )h;
#line 1385
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1394
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 1395
  if (! image) {
    {
#line 1396
    TIFFClose(tif);
    }
#line 1397
    return ((opj_image_t *)((void *)0));
  }
#line 1400
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1401
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1402
  if (! image->x0) {
#line 1402
    tmp = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
  } else {
#line 1402
    tmp = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
  }
#line 1402
  image->x1 = tmp;
#line 1404
  if (image->x1 <= image->x0) {
    {
#line 1405
    fprintf(stderr, "tiftoimage: Bad value for image->x1(%d) vs. image->x0(%d)\n\tAborting.\n",
            image->x1, image->x0);
#line 1407
    TIFFClose(tif);
#line 1408
    opj_image_destroy(image);
    }
#line 1409
    return ((opj_image_t *)((void *)0));
  }
#line 1411
  if (! image->y0) {
#line 1411
    tmp___0 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
  } else {
#line 1411
    tmp___0 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
  }
#line 1411
  image->y1 = tmp___0;
#line 1413
  if (image->y1 <= image->y0) {
    {
#line 1414
    fprintf(stderr, "tiftoimage: Bad value for image->y1(%d) vs. image->y0(%d)\n\tAborting.\n",
            image->y1, image->y0);
#line 1416
    TIFFClose(tif);
#line 1417
    opj_image_destroy(image);
    }
#line 1418
    return ((opj_image_t *)((void *)0));
  }
#line 1421
  j = 0;
  {
#line 1421
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1421
    if (! (j < numcomps)) {
#line 1421
      goto while_break___0;
    }
#line 1422
    planes[j] = (image->comps + j)->data;
#line 1421
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1424
  (image->comps + (numcomps - 1))->alpha = (OPJ_UINT16 )(1 - (numcomps & 1));
#line 1426
  __cil_tmp37 = TIFFStripSize(tif);
#line 1426
  strip_size = __cil_tmp37;
#line 1428
  buf = malloc((OPJ_SIZE_T )strip_size);
  }
#line 1429
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 1430
    TIFFClose(tif);
#line 1431
    opj_image_destroy(image);
    }
#line 1432
    return ((opj_image_t *)((void *)0));
  }
#line 1434
  if (sizeof(tsize_t ) == 4UL) {
#line 1435
    TIFF_MAX = (int64_t )2147483647;
  } else {
#line 1437
    TIFF_MAX = (int64_t )4294967295U;
  }
#line 1439
  if ((int64_t )tiWidth > TIFF_MAX / (long )tiSpp) {
    {
#line 1442
    fprintf(stderr, "Buffer overflow\n\220");
#line 1443
    _TIFFfree(buf);
#line 1444
    TIFFClose(tif);
#line 1445
    opj_image_destroy(image);
    }
#line 1446
    return ((opj_image_t *)((void *)0));
  } else
#line 1439
  if ((int64_t )(tiWidth * (unsigned int )tiSpp) > TIFF_MAX / (long )tiBps) {
    {
#line 1442
    fprintf(stderr, "Buffer overflow\n\220");
#line 1443
    _TIFFfree(buf);
#line 1444
    TIFFClose(tif);
#line 1445
    opj_image_destroy(image);
    }
#line 1446
    return ((opj_image_t *)((void *)0));
  } else
#line 1439
  if ((int64_t )(tiWidth * (unsigned int )tiSpp) > TIFF_MAX / (int64_t )sizeof(OPJ_INT32 )) {
    {
#line 1442
    fprintf(stderr, "Buffer overflow\n\220");
#line 1443
    _TIFFfree(buf);
#line 1444
    TIFFClose(tif);
#line 1445
    opj_image_destroy(image);
    }
#line 1446
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1449
  rowStride = (int64_t )(((tiWidth * (unsigned int )tiSpp) * (unsigned int )tiBps + 7U) / 8U);
#line 1450
  __cil_tmp39 = malloc((unsigned long )(tiWidth * (unsigned int )tiSpp) * sizeof(OPJ_INT32 ));
#line 1450
  buffer32s = (OPJ_INT32 *)__cil_tmp39;
  }
#line 1452
  if ((unsigned long )buffer32s == (unsigned long )((void *)0)) {
    {
#line 1453
    _TIFFfree(buf);
#line 1454
    TIFFClose(tif);
#line 1455
    opj_image_destroy(image);
    }
#line 1456
    return ((opj_image_t *)((void *)0));
  }
#line 1459
  strip = (tstrip_t )0;
#line 1460
  currentPlane = 0;
  {
#line 1461
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1462
    planes[0] = (image->comps + currentPlane)->data;
#line 1463
    h = (int )tiHeight;
    {
#line 1465
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1465
      if (h > 0) {
#line 1465
        if (! (strip < __cil_tmp40)) {
#line 1465
          goto while_break___2;
        }
      } else {
#line 1465
        goto while_break___2;
      }
      {
#line 1469
      __cil_tmp43 = TIFFReadEncodedStrip(tif, strip, buf, strip_size);
#line 1469
      ssize = __cil_tmp43;
      }
#line 1471
      if (ssize < 1L) {
        {
#line 1472
        fprintf(stderr, "tiftoimage: Bad value for ssize(%ld) vs. strip_size(%ld).\n\tAborting.\n",
                ssize, strip_size);
#line 1474
        _TIFFfree(buf);
#line 1475
        _TIFFfree((void *)buffer32s);
#line 1476
        TIFFClose(tif);
#line 1477
        opj_image_destroy(image);
        }
#line 1478
        return ((opj_image_t *)((void *)0));
      } else
#line 1471
      if (ssize > strip_size) {
        {
#line 1472
        fprintf(stderr, "tiftoimage: Bad value for ssize(%ld) vs. strip_size(%ld).\n\tAborting.\n",
                ssize, strip_size);
#line 1474
        _TIFFfree(buf);
#line 1475
        _TIFFfree((void *)buffer32s);
#line 1476
        TIFFClose(tif);
#line 1477
        opj_image_destroy(image);
        }
#line 1478
        return ((opj_image_t *)((void *)0));
      }
#line 1480
      dat8 = (OPJ_UINT8 *)buf;
      {
#line 1482
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1482
        if (! (ssize >= rowStride)) {
#line 1482
          goto while_break___3;
        }
        {
#line 1483
        (*cvtTifTo32s)(dat8, buffer32s, (OPJ_SIZE_T )w * (unsigned long )tiSpp);
#line 1484
        (*cvtCxToPx)(buffer32s, (OPJ_INT32 * const  *)(planes), (OPJ_SIZE_T )w);
#line 1485
        planes[0] += w;
#line 1486
        planes[1] += w;
#line 1487
        planes[2] += w;
#line 1488
        planes[3] += w;
#line 1489
        dat8 += rowStride;
#line 1490
        ssize -= rowStride;
#line 1491
        __cil_tmp44 = h;
#line 1491
        h --;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: 
#line 1465
      strip ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
#line 1494
    currentPlane ++;
#line 1461
    if ((int )tiPC == 2) {
#line 1461
      if (! (currentPlane < numcomps)) {
#line 1461
        goto while_break___1;
      }
    } else {
#line 1461
      goto while_break___1;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 1497
  free((void *)buffer32s);
#line 1498
  _TIFFfree(buf);
#line 1499
  TIFFClose(tif);
  }
#line 1501
  if (is_cinema) {
#line 1502
    j = 0;
    {
#line 1502
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 1502
      if (! (j < numcomps)) {
#line 1502
        goto while_break___4;
      }
      {
#line 1503
      scale_component(image->comps + j, (OPJ_UINT32 )12);
#line 1502
      j ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: ;
  }
#line 1507
  return (image);
}
}
#line 58 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 67
extern  __attribute__((__nothrow__)) void longjmp(struct __jmp_buf_tag *__env , int __val ) ;
#line 929 "/usr/include/png.h"
extern void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) ;
#line 945
extern png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                          void (*error_fn)(png_structp  , png_const_charp  ) ,
                                          void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 951
extern png_structp png_create_write_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                           void (*error_fn)(png_structp  , png_const_charp  ) ,
                                           void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 973
extern jmp_buf *png_set_longjmp_fn(png_structrp png_ptr , void (*longjmp_fn)(struct __jmp_buf_tag * ,
                                                                             int  ) ,
                                   size_t jmp_buf_size ) ;
#line 1027
extern png_infop png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1040
extern void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1045
extern void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1074
extern void png_set_expand(png_structrp png_ptr ) ;
#line 1373
extern void png_set_gamma(png_structrp png_ptr , double screen_gamma , double override_file_gamma ) ;
#line 1390
extern void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1407
extern void png_read_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1411
extern void png_write_row(png_structrp png_ptr , png_const_bytep row ) ;
#line 1426
extern void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1439
extern void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                                    png_infopp end_info_ptr_ptr ) ;
#line 1443
extern void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) ;
#line 1531
extern void png_set_compression_level(png_structrp png_ptr , int level ) ;
#line 1583
extern void png_init_io(png_structrp png_ptr , png_FILE_p fp ) ;
#line 1861
extern png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                 png_uint_32 flag ) ;
#line 1865
extern size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1896
extern png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1900
extern png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2017
extern png_uint_32 png_get_gAMA(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                double *file_gamma ) ;
#line 2038
extern png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                                int *color_type , int *interlace_method , int *compression_method ,
                                int *filter_method ) ;
#line 2043
extern void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                         png_uint_32 height , int bit_depth , int color_type , int interlace_method ,
                         int compression_method , int filter_method ) ;
#line 2096
extern void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) ;
#line 57 "/root/patron/new_24/src/bin/jp2/convertpng.c"
static void convert_16u32s_C1R(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_INT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 61
  i = (OPJ_SIZE_T )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;

#line 61
    if (! (i < length)) {
#line 61
      goto while_break;
    }
#line 62
    __cil_tmp6 = pSrc;
#line 62
    pSrc ++;
#line 62
    val0 = (OPJ_INT32 )*__cil_tmp6;
#line 63
    __cil_tmp8 = pSrc;
#line 63
    pSrc ++;
#line 63
    val1 = (OPJ_INT32 )*__cil_tmp8;
#line 64
    *(pDst + i) = (val0 << 8) | val1;
#line 61
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 65
  return;
}
}
#line 68 "/root/patron/new_24/src/bin/jp2/convertpng.c"
opj_image_t *pngtoimage(char const   *read_idf , opj_cparameters_t *params ) 
{ 
  png_structp png ;
  png_infop info ;
  double gamma___0 ;
  int bit_depth ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  OPJ_UINT32 i ;
  png_uint_32 width ;
  png_uint_32 height ;
  int color_type ;
  FILE *reader ;
  OPJ_BYTE **rows ;
  OPJ_INT32 *row32s ;
  opj_image_t *image ;
  opj_image_cmptparm_t cmptparm[4] ;
  OPJ_UINT32 nr_comp ;
  OPJ_BYTE sigbuf[8] ;
  void (*cvtXXTo32s)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ) ;
  void (*cvtCxToPx)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  ) ;
  OPJ_INT32 *planes[4] ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  jmp_buf *__cil_tmp29 ;
  int __cil_tmp30 ;
  png_uint_32 __cil_tmp31 ;
  png_uint_32 __cil_tmp32 ;
  png_uint_32 __cil_tmp33 ;
  png_byte __cil_tmp34 ;
  png_byte __cil_tmp35 ;
  void *__cil_tmp36 ;
  size_t __cil_tmp37 ;
  void *__cil_tmp38 ;
  int tmp ;
  opj_image_t *__cil_tmp40 ;
  void *__cil_tmp41 ;

  {
  {
#line 70
  png = (png_structp )((void *)0);
#line 71
  info = (png_infop )((void *)0);
#line 75
  height = 0U;
#line 77
  reader = (FILE *)((void *)0);
#line 78
  rows = (OPJ_BYTE **)((void *)0);
#line 79
  row32s = (OPJ_INT32 *)((void *)0);
#line 81
  image = (opj_image_t *)((void *)0);
#line 85
  cvtXXTo32s = (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0);
#line 86
  cvtCxToPx = (void (*)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  ))((void *)0);
#line 89
  reader = fopen(read_idf, "rb");
  }
#line 89
  if ((unsigned long )reader == (unsigned long )((void *)0)) {
    {
#line 90
    fprintf(stderr, "pngtoimage: can not open %s\n", read_idf);
    }
#line 91
    return ((opj_image_t *)((void *)0));
  }
  {
#line 94
  __cil_tmp26 = memcmp((void const   *)(sigbuf), (void const   *)"\211PNG\r\n\032\n\251",
                       8UL);
#line 94
  __cil_tmp25 = fread((void *)(sigbuf), 1UL, 8UL, reader);
  }
#line 94
  if (__cil_tmp25 != 8UL) {
    {
#line 96
    fprintf(stderr, "pngtoimage: %s is no valid PNG file\n", read_idf);
    }
#line 97
    goto fin;
  } else
#line 94
  if (__cil_tmp26 != 0) {
    {
#line 96
    fprintf(stderr, "pngtoimage: %s is no valid PNG file\n", read_idf);
    }
#line 97
    goto fin;
  }
  {
#line 100
  png = png_create_read_struct("1.6.37", (void *)0, (void (*)(png_structp  , png_const_charp  ))((void *)0),
                               (void (*)(png_structp  , png_const_charp  ))((void *)0));
  }
#line 100
  if ((unsigned long )png == (unsigned long )((void *)0)) {
#line 102
    goto fin;
  }
  {
#line 104
  info = png_create_info_struct(png);
  }
#line 104
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 105
    goto fin;
  }
  {
#line 108
  __cil_tmp29 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 108
  __cil_tmp30 = _setjmp((struct __jmp_buf_tag *)(*__cil_tmp29));
  }
#line 108
  if (__cil_tmp30) {
#line 109
    goto fin;
  }
  {
#line 112
  png_init_io(png, reader);
#line 113
  png_set_sig_bytes(png, 8);
#line 115
  png_read_info(png, info);
#line 117
  __cil_tmp31 = png_get_IHDR(png, info, & width, & height, & bit_depth, & color_type,
                             & interlace_type, & compression_type, & filter_type);
  }
#line 117
  if (__cil_tmp31 == 0U) {
#line 120
    goto fin;
  }
#line 128
  if (color_type == 3) {
    {
#line 129
    png_set_expand(png);
    }
  }
  {
#line 132
  __cil_tmp32 = png_get_valid(png, info, 16U);
  }
#line 132
  if (__cil_tmp32) {
    {
#line 133
    png_set_expand(png);
    }
  }
  {
#line 144
  __cil_tmp33 = png_get_gAMA(png, info, & gamma___0);
  }
#line 144
  if (! __cil_tmp33) {
#line 145
    gamma___0 = 1.;
  }
  {
#line 149
  png_set_gamma(png, 1., gamma___0);
#line 151
  png_read_update_info(png, info);
#line 153
  __cil_tmp34 = png_get_color_type(png, info);
#line 153
  color_type = (int )__cil_tmp34;
  }
#line 156
  if (color_type == 0) {
#line 156
    goto case_0;
  }
#line 159
  if (color_type == 4) {
#line 159
    goto case_4;
  }
#line 162
  if (color_type == 2) {
#line 162
    goto case_2;
  }
#line 165
  if (color_type == 6) {
#line 165
    goto case_6;
  }
#line 168
  goto switch_default;
  case_0: 
#line 157
  nr_comp = (OPJ_UINT32 )1;
#line 158
  goto switch_break;
  case_4: 
#line 160
  nr_comp = (OPJ_UINT32 )2;
#line 161
  goto switch_break;
  case_2: 
#line 163
  nr_comp = (OPJ_UINT32 )3;
#line 164
  goto switch_break;
  case_6: 
#line 166
  nr_comp = (OPJ_UINT32 )4;
#line 167
  goto switch_break;
  switch_default: 
  {
#line 169
  fprintf(stderr, "pngtoimage: colortype %d is not supported\n", color_type);
  }
#line 170
  goto fin;
  switch_break: 
  {
#line 172
  cvtCxToPx = convert_32s_CXPX_LUT[nr_comp];
#line 173
  __cil_tmp35 = png_get_bit_depth(png, info);
#line 173
  bit_depth = (int )__cil_tmp35;
  }
#line 179
  if (bit_depth == 8) {
#line 179
    goto case_8;
  }
#line 179
  if (bit_depth == 4) {
#line 179
    goto case_8;
  }
#line 179
  if (bit_depth == 2) {
#line 179
    goto case_8;
  }
#line 179
  if (bit_depth == 1) {
#line 179
    goto case_8;
  }
#line 182
  if (bit_depth == 16) {
#line 182
    goto case_16;
  }
#line 185
  goto switch_default___0;
  case_8: 
#line 180
  cvtXXTo32s = convert_XXu32s_C1R_LUT[bit_depth];
#line 181
  goto switch_break___0;
  case_16: 
#line 183
  cvtXXTo32s = & convert_16u32s_C1R;
#line 184
  goto switch_break___0;
  switch_default___0: 
  {
#line 186
  fprintf(stderr, "pngtoimage: bit depth %d is not supported\n", bit_depth);
  }
#line 187
  goto fin;
  switch_break___0: 
  {
#line 191
  __cil_tmp36 = calloc((unsigned long )(height + 1U), sizeof(OPJ_BYTE *));
#line 191
  rows = (OPJ_BYTE **)__cil_tmp36;
  }
#line 192
  if ((unsigned long )rows == (unsigned long )((void *)0)) {
    {
#line 193
    fprintf(stderr, "pngtoimage: memory out\n");
    }
#line 194
    goto fin;
  }
#line 196
  i = (OPJ_UINT32 )0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 196
    if (! (i < height)) {
#line 196
      goto while_break;
    }
    {
#line 197
    __cil_tmp37 = png_get_rowbytes(png, info);
#line 197
    __cil_tmp38 = malloc(__cil_tmp37);
#line 197
    *(rows + i) = (OPJ_BYTE *)__cil_tmp38;
    }
#line 198
    if ((unsigned long )*(rows + i) == (unsigned long )((void *)0)) {
      {
#line 199
      fprintf(stderr, "pngtoimage: memory out\n");
      }
#line 200
      goto fin;
    }
#line 196
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 203
  png_read_image(png, rows);
#line 206
  memset((void *)(cmptparm), 0, sizeof(cmptparm));
#line 207
  i = (OPJ_UINT32 )0;
  }
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 207
    if (! (i < nr_comp)) {
#line 207
      goto while_break___0;
    }
#line 208
    cmptparm[i].prec = (OPJ_UINT32 )bit_depth;
#line 210
    cmptparm[i].bpp = (OPJ_UINT32 )bit_depth;
#line 211
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 212
    cmptparm[i].dx = (OPJ_UINT32 )params->subsampling_dx;
#line 213
    cmptparm[i].dy = (OPJ_UINT32 )params->subsampling_dy;
#line 214
    cmptparm[i].w = width;
#line 215
    cmptparm[i].h = height;
#line 207
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 218
  if (nr_comp > 2U) {
#line 218
    tmp = 1;
  } else {
#line 218
    tmp = 2;
  }
  {
#line 218
  __cil_tmp40 = opj_image_create(nr_comp, & cmptparm[0], (OPJ_COLOR_SPACE )tmp);
#line 218
  image = __cil_tmp40;
  }
#line 220
  if ((unsigned long )image == (unsigned long )((void *)0)) {
#line 221
    goto fin;
  }
  {
#line 223
  image->x0 = (OPJ_UINT32 )params->image_offset_x0;
#line 224
  image->y0 = (OPJ_UINT32 )params->image_offset_y0;
#line 225
  image->x1 = ((image->x0 + (width - 1U) * (OPJ_UINT32 )params->subsampling_dx) + 1U) + image->x0;
#line 227
  image->y1 = ((image->y0 + (height - 1U) * (OPJ_UINT32 )params->subsampling_dy) + 1U) + image->y0;
#line 230
  __cil_tmp41 = malloc(((size_t )width * (unsigned long )nr_comp) * sizeof(OPJ_INT32 ));
#line 230
  row32s = (OPJ_INT32 *)__cil_tmp41;
  }
#line 231
  if ((unsigned long )row32s == (unsigned long )((void *)0)) {
#line 232
    goto fin;
  }
#line 236
  (image->comps + (nr_comp - 1U))->alpha = (OPJ_UINT16 )(1U - (nr_comp & 1U));
#line 238
  i = (OPJ_UINT32 )0;
  {
#line 238
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 238
    if (! (i < nr_comp)) {
#line 238
      goto while_break___1;
    }
#line 239
    planes[i] = (image->comps + i)->data;
#line 238
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
#line 242
  i = (OPJ_UINT32 )0;
  {
#line 242
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 242
    if (! (i < height)) {
#line 242
      goto while_break___2;
    }
    {
#line 243
    (*cvtXXTo32s)(*(rows + i), row32s, (OPJ_SIZE_T )width * (unsigned long )nr_comp);
#line 244
    (*cvtCxToPx)(row32s, (OPJ_INT32 * const  *)(planes), (OPJ_SIZE_T )width);
#line 245
    planes[0] += width;
#line 246
    planes[1] += width;
#line 247
    planes[2] += width;
#line 248
    planes[3] += width;
#line 242
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: ;
  fin: 
#line 251
  if (rows) {
#line 252
    i = (OPJ_UINT32 )0;
    {
#line 252
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 252
      if (! (i < height)) {
#line 252
        goto while_break___3;
      }
#line 253
      if (*(rows + i)) {
        {
#line 254
        free((void *)*(rows + i));
        }
      }
#line 252
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
    {
#line 256
    free((void *)rows);
    }
  }
#line 258
  if (row32s) {
    {
#line 259
    free((void *)row32s);
    }
  }
#line 261
  if (png) {
    {
#line 262
    png_destroy_read_struct(& png, & info, (png_infopp )((void *)0));
    }
  }
  {
#line 265
  fclose(reader);
  }
#line 267
  return (image);
}
}
#line 272 "/root/patron/new_24/src/bin/jp2/convertpng.c"
static void convert_32s16u_C1R(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_BYTE *__cil_tmp7 ;

  {
#line 276
  i = (OPJ_SIZE_T )0;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;

#line 276
    if (! (i < length)) {
#line 276
      goto while_break;
    }
#line 277
    val = (OPJ_UINT32 )*(pSrc + i);
#line 278
    __cil_tmp6 = pDst;
#line 278
    pDst ++;
#line 278
    *__cil_tmp6 = (OPJ_BYTE )(val >> 8);
#line 279
    __cil_tmp7 = pDst;
#line 279
    pDst ++;
#line 279
    *__cil_tmp7 = (OPJ_BYTE )val;
#line 276
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 280
  return;
}
}
#line 282 "/root/patron/new_24/src/bin/jp2/convertpng.c"
int imagetopng(opj_image_t *image , char const   *write_idf ) 
{ 
  FILE *writer ;
  png_structp png ;
  png_infop info ;
  png_bytep row_buf ;
  int nr_comp ;
  int color_type ;
  int prec ;
  png_color_8 sig_bit ;
  OPJ_INT32 *planes[4] ;
  int i ;
  OPJ_INT32 *buffer32s ;
  int fails ;
  jmp_buf *__cil_tmp19 ;
  int __cil_tmp20 ;
  OPJ_SIZE_T rowStride ;
  png_size_t png_row_size ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  OPJ_SIZE_T width ;
  OPJ_UINT32 y ;
  void (*cvtPxToCx)(OPJ_INT32 * const  * , OPJ_INT32 * , OPJ_SIZE_T  , OPJ_INT32  ) ;
  void (*cvt32sToPack)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ) ;
  OPJ_INT32 adjust ;
  int tmp ;
  png_bytep row_buf_cpy ;
  OPJ_INT32 *buffer32s_cpy ;

  {
  {
#line 284
  writer = (FILE *)((void *)0);
#line 285
  png = (png_structp )((void *)0);
#line 286
  info = (png_infop )((void *)0);
#line 287
  row_buf = (png_bytep )((void *)0);
#line 293
  buffer32s = (OPJ_INT32 *)((void *)0);
#line 295
  fails = 1;
#line 297
  memset((void *)(& sig_bit), 0, sizeof(sig_bit));
#line 298
  prec = (int )(image->comps + 0)->prec;
#line 299
  planes[0] = (image->comps + 0)->data;
#line 300
  nr_comp = (int )image->numcomps;
  }
#line 302
  if (nr_comp > 4) {
#line 303
    nr_comp = 4;
  }
#line 305
  i = 1;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;

#line 305
    if (! (i < nr_comp)) {
#line 305
      goto while_break;
    }
#line 306
    if ((image->comps + 0)->dx != (image->comps + i)->dx) {
#line 307
      goto while_break;
    }
#line 309
    if ((image->comps + 0)->dy != (image->comps + i)->dy) {
#line 310
      goto while_break;
    }
#line 312
    if ((image->comps + 0)->prec != (image->comps + i)->prec) {
#line 313
      goto while_break;
    }
#line 315
    if ((image->comps + 0)->sgnd != (image->comps + i)->sgnd) {
#line 316
      goto while_break;
    }
#line 318
    planes[i] = (image->comps + i)->data;
#line 305
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 320
  if (i != nr_comp) {
    {
#line 321
    fprintf(stderr, "imagetopng: All components shall have the same subsampling, same bit depth, same sign.\n");
#line 323
    fprintf(stderr, "\tAborting\n");
    }
#line 324
    return (1);
  }
#line 326
  i = 0;
  {
#line 326
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 326
    if (! (i < nr_comp)) {
#line 326
      goto while_break___0;
    }
    {
#line 327
    clip_component(image->comps + i, (image->comps + 0)->prec);
#line 326
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: ;
#line 329
  if (prec > 8) {
#line 329
    if (prec < 16) {
#line 330
      i = 0;
      {
#line 330
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 330
        if (! (i < nr_comp)) {
#line 330
          goto while_break___1;
        }
        {
#line 331
        scale_component(image->comps + i, (OPJ_UINT32 )16);
#line 330
        i ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
#line 333
      prec = 16;
    } else {
#line 329
      goto _L___49;
    }
  } else
  _L___49: 
#line 334
  if (prec < 8) {
#line 334
    if (nr_comp > 1) {
#line 335
      i = 0;
      {
#line 335
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 335
        if (! (i < nr_comp)) {
#line 335
          goto while_break___2;
        }
        {
#line 336
        scale_component(image->comps + i, (OPJ_UINT32 )8);
#line 335
        i ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
#line 338
      prec = 8;
    } else {
#line 334
      goto _L___48;
    }
  } else
  _L___48: 
#line 339
  if (prec > 1) {
#line 339
    if (prec < 8) {
#line 339
      if (prec == 6) {
        _L: 
#line 341
        if (prec == 5) {
#line 342
          prec = 8;
        } else
#line 341
        if (prec == 6) {
#line 342
          prec = 8;
        } else {
#line 344
          prec ++;
        }
#line 346
        i = 0;
        {
#line 346
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 346
          if (! (i < nr_comp)) {
#line 346
            goto while_break___3;
          }
          {
#line 347
          scale_component(image->comps + i, (OPJ_UINT32 )prec);
#line 346
          i ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: ;
      } else
#line 339
      if ((prec & 1) == 1) {
#line 339
        goto _L;
      }
    }
  }
#line 351
  if (prec != 1) {
#line 351
    if (prec != 2) {
#line 351
      if (prec != 4) {
#line 351
        if (prec != 8) {
#line 351
          if (prec != 16) {
            {
#line 352
            fprintf(stderr, "imagetopng: can not create %s\n\twrong bit_depth %d\nH3 V",
                    write_idf, prec);
            }
#line 354
            return (fails);
          }
        }
      }
    }
  }
  {
#line 357
  writer = fopen(write_idf, "wb");
  }
#line 359
  if ((unsigned long )writer == (unsigned long )((void *)0)) {
#line 360
    return (fails);
  }
  {
#line 369
  png = png_create_write_struct("1.6.37", (void *)0, (void (*)(png_structp  , png_const_charp  ))((void *)0),
                                (void (*)(png_structp  , png_const_charp  ))((void *)0));
  }
#line 373
  if ((unsigned long )png == (unsigned long )((void *)0)) {
#line 374
    goto fin;
  }
  {
#line 379
  info = png_create_info_struct(png);
  }
#line 381
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 382
    goto fin;
  }
  {
#line 388
  __cil_tmp19 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 388
  __cil_tmp20 = _setjmp((struct __jmp_buf_tag *)(*__cil_tmp19));
  }
#line 388
  if (__cil_tmp20) {
#line 389
    goto fin;
  }
  {
#line 394
  png_init_io(png, writer);
#line 413
  png_set_compression_level(png, 9);
  }
#line 415
  if (nr_comp >= 3) {
#line 416
    color_type = 2;
#line 417
    sig_bit.blue = (png_byte )prec;
#line 417
    sig_bit.green = sig_bit.blue;
#line 417
    sig_bit.red = sig_bit.green;
  } else {
#line 419
    color_type = 0;
#line 420
    sig_bit.gray = (png_byte )prec;
  }
#line 422
  if ((nr_comp & 1) == 0) {
#line 423
    color_type |= 4;
#line 424
    sig_bit.alpha = (png_byte )prec;
  }
  {
#line 427
  png_set_IHDR(png, info, (image->comps + 0)->w, (image->comps + 0)->h, prec, color_type,
               0, 0, 0);
#line 430
  png_set_sBIT(png, info, & sig_bit);
#line 433
  png_write_info(png, info);
#line 440
  png_row_size = png_get_rowbytes(png, info);
#line 441
  rowStride = (((OPJ_SIZE_T )(image->comps + 0)->w * (OPJ_SIZE_T )nr_comp) * (OPJ_SIZE_T )prec + 7UL) / 8UL;
  }
#line 443
  if (rowStride != png_row_size) {
    {
#line 444
    fprintf(stderr, "Invalid PNG row size\n");
    }
#line 445
    goto fin;
  }
  {
#line 447
  __cil_tmp24 = malloc(png_row_size);
#line 447
  row_buf = (png_bytep )__cil_tmp24;
  }
#line 448
  if ((unsigned long )row_buf == (unsigned long )((void *)0)) {
    {
#line 449
    fprintf(stderr, "Can\'t allocate memory for PNG row\nH3 V");
    }
#line 450
    goto fin;
  }
  {
#line 452
  __cil_tmp25 = malloc(((OPJ_SIZE_T )(image->comps + 0)->w * (OPJ_SIZE_T )nr_comp) * sizeof(OPJ_INT32 ));
#line 452
  buffer32s = (OPJ_INT32 *)__cil_tmp25;
  }
#line 454
  if ((unsigned long )buffer32s == (unsigned long )((void *)0)) {
    {
#line 455
    fprintf(stderr, "Can\'t allocate memory for interleaved 32s row\n");
    }
#line 456
    goto fin;
  }
#line 462
  width = (OPJ_SIZE_T )(image->comps + 0)->w;
#line 464
  cvtPxToCx = convert_32s_PXCX_LUT[nr_comp];
#line 465
  cvt32sToPack = (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0);
#line 466
  if ((image->comps + 0)->sgnd) {
#line 466
    tmp = 1 << (prec - 1);
  } else {
#line 466
    tmp = 0;
  }
#line 466
  adjust = tmp;
#line 467
  row_buf_cpy = row_buf;
#line 468
  buffer32s_cpy = buffer32s;
#line 474
  if (prec == 8) {
#line 474
    goto case_8;
  }
#line 474
  if (prec == 4) {
#line 474
    goto case_8;
  }
#line 474
  if (prec == 2) {
#line 474
    goto case_8;
  }
#line 474
  if (prec == 1) {
#line 474
    goto case_8;
  }
#line 477
  if (prec == 16) {
#line 477
    goto case_16;
  }
#line 480
  goto switch_default;
  case_8: 
#line 475
  cvt32sToPack = convert_32sXXu_C1R_LUT[prec];
#line 476
  goto switch_break;
  case_16: 
#line 478
  cvt32sToPack = & convert_32s16u_C1R;
#line 479
  goto switch_break;
  switch_default: 
#line 482
  goto switch_break;
  switch_break: 
#line 485
  y = (OPJ_UINT32 )0;
  {
#line 485
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 485
    if (! (y < (image->comps + 0)->h)) {
#line 485
      goto while_break___4;
    }
    {
#line 486
    (*cvtPxToCx)((OPJ_INT32 * const  *)(planes), buffer32s_cpy, width, adjust);
#line 487
    (*cvt32sToPack)(buffer32s_cpy, row_buf_cpy, width * (OPJ_SIZE_T )nr_comp);
#line 488
    png_write_row(png, row_buf_cpy);
#line 489
    planes[0] += width;
#line 490
    planes[1] += width;
#line 491
    planes[2] += width;
#line 492
    planes[3] += width;
#line 485
    y ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: 
  {
#line 496
  png_write_end(png, info);
#line 498
  fails = 0;
  }
  fin: 
#line 501
  if (png) {
    {
#line 502
    png_destroy_write_struct(& png, & info);
    }
  }
#line 504
  if (row_buf) {
    {
#line 505
    free((void *)row_buf);
    }
  }
#line 507
  if (buffer32s) {
    {
#line 508
    free((void *)buffer32s);
    }
  }
  {
#line 510
  fclose(writer);
  }
#line 512
  if (fails) {
    {
#line 513
    remove(write_idf);
    }
  }
#line 516
  return (fails);
}
}
#line 83 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static void opj_applyLUT8u_8u32s_C1R(OPJ_UINT8 *pSrc , OPJ_INT32 srcStride , OPJ_INT32 *pDst ,
                                     OPJ_INT32 dstStride , OPJ_UINT8 *pLUT , OPJ_UINT32 width ,
                                     OPJ_UINT32 height ) 
{ 
  OPJ_UINT32 y ;
  OPJ_UINT32 x ;

  {
#line 91
  y = height;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;

#line 91
    if (! (y != 0U)) {
#line 91
      goto while_break;
    }
#line 94
    x = (OPJ_UINT32 )0;
    {
#line 94
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 94
      if (! (x < width)) {
#line 94
        goto while_break___0;
      }
#line 95
      *(pDst + x) = (OPJ_INT32 )*(pLUT + (int )*(pSrc + x));
#line 94
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 97
    pSrc += srcStride;
#line 98
    pDst += dstStride;
#line 91
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 95
  return;
}
}
#line 102 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static void opj_applyLUT8u_8u32s_C1P3R(OPJ_UINT8 *pSrc , OPJ_INT32 srcStride , OPJ_INT32 * const  *pDst ,
                                       OPJ_INT32 *pDstStride , OPJ_UINT8 * const  *pLUT ,
                                       OPJ_UINT32 width , OPJ_UINT32 height ) 
{ 
  OPJ_UINT32 y ;
  OPJ_INT32 *pR ;
  OPJ_INT32 *pG ;
  OPJ_INT32 *pB ;
  OPJ_UINT8 *pLUT_R ;
  OPJ_UINT8 *pLUT_G ;
  OPJ_UINT8 *pLUT_B ;
  OPJ_UINT32 x ;
  OPJ_UINT8 idx ;

  {
#line 109
  pR = (OPJ_INT32 *)*(pDst + 0);
#line 110
  pG = (OPJ_INT32 *)*(pDst + 1);
#line 111
  pB = (OPJ_INT32 *)*(pDst + 2);
#line 112
  pLUT_R = (OPJ_UINT8 *)*(pLUT + 0);
#line 113
  pLUT_G = (OPJ_UINT8 *)*(pLUT + 1);
#line 114
  pLUT_B = (OPJ_UINT8 *)*(pLUT + 2);
#line 116
  y = height;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;

#line 116
    if (! (y != 0U)) {
#line 116
      goto while_break;
    }
#line 119
    x = (OPJ_UINT32 )0;
    {
#line 119
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 119
      if (! (x < width)) {
#line 119
        goto while_break___0;
      }
#line 120
      idx = *(pSrc + x);
#line 121
      *(pR + x) = (OPJ_INT32 )*(pLUT_R + (int )idx);
#line 122
      *(pG + x) = (OPJ_INT32 )*(pLUT_G + (int )idx);
#line 123
      *(pB + x) = (OPJ_INT32 )*(pLUT_B + (int )idx);
#line 119
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 125
    pSrc += srcStride;
#line 126
    pR += *(pDstStride + 0);
#line 127
    pG += *(pDstStride + 1);
#line 128
    pB += *(pDstStride + 2);
#line 116
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 120
  return;
}
}
#line 132 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static void bmp24toimage(OPJ_UINT8 *pData , OPJ_UINT32 stride , opj_image_t *image ) 
{ 
  int index___0 ;
  OPJ_UINT32 width ;
  OPJ_UINT32 height ;
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT8 *pSrc ;

  {
#line 138
  pSrc = (OPJ_UINT8 *)((void *)0);
#line 140
  width = (image->comps + 0)->w;
#line 141
  height = (image->comps + 0)->h;
#line 143
  index___0 = 0;
#line 144
  pSrc = pData + (height - 1U) * stride;
#line 145
  y = (OPJ_UINT32 )0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;

#line 145
    if (! (y < height)) {
#line 145
      goto while_break;
    }
#line 146
    x = (OPJ_UINT32 )0;
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 146
      if (! (x < width)) {
#line 146
        goto while_break___0;
      }
#line 147
      *((image->comps + 0)->data + index___0) = (OPJ_INT32 )*(pSrc + (3U * x + 2U));
#line 148
      *((image->comps + 1)->data + index___0) = (OPJ_INT32 )*(pSrc + (3U * x + 1U));
#line 149
      *((image->comps + 2)->data + index___0) = (OPJ_INT32 )*(pSrc + 3U * x);
#line 150
      index___0 ++;
#line 146
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 152
    pSrc -= stride;
#line 145
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 149
  return;
}
}
#line 156 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask , OPJ_UINT32 *shift , OPJ_UINT32 *prec ) 
{ 
  OPJ_UINT32 l_shift ;
  OPJ_UINT32 l_prec ;

  {
#line 161
  l_prec = 0U;
#line 161
  l_shift = l_prec;
#line 163
  if (mask != 0U) {
    {
#line 164
    while (1) {
      while_continue: /* CIL Label */ ;

#line 164
      if (! ((mask & 1U) == 0U)) {
#line 164
        goto while_break;
      }
#line 165
      mask >>= 1;
#line 166
      l_shift ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 168
      if (! (mask & 1U)) {
#line 168
        goto while_break___0;
      }
#line 169
      mask >>= 1;
#line 170
      l_prec ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 173
  *shift = l_shift;
#line 174
  *prec = l_prec;
#line 175
  return;
}
}
#line 177 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static void bmpmask32toimage(OPJ_UINT8 *pData , OPJ_UINT32 stride , opj_image_t *image ,
                             OPJ_UINT32 redMask , OPJ_UINT32 greenMask , OPJ_UINT32 blueMask ,
                             OPJ_UINT32 alphaMask ) 
{ 
  int index___0 ;
  OPJ_UINT32 width ;
  OPJ_UINT32 height ;
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT8 *pSrc ;
  OPJ_BOOL hasAlpha ;
  OPJ_UINT32 redShift ;
  OPJ_UINT32 redPrec ;
  OPJ_UINT32 greenShift ;
  OPJ_UINT32 greenPrec ;
  OPJ_UINT32 blueShift ;
  OPJ_UINT32 bluePrec ;
  OPJ_UINT32 alphaShift ;
  OPJ_UINT32 alphaPrec ;
  OPJ_UINT32 value ;

  {
  {
#line 184
  pSrc = (OPJ_UINT8 *)((void *)0);
#line 191
  width = (image->comps + 0)->w;
#line 192
  height = (image->comps + 0)->h;
#line 194
  hasAlpha = image->numcomps > 3U;
#line 196
  bmp_mask_get_shift_and_prec(redMask, & redShift, & redPrec);
#line 197
  bmp_mask_get_shift_and_prec(greenMask, & greenShift, & greenPrec);
#line 198
  bmp_mask_get_shift_and_prec(blueMask, & blueShift, & bluePrec);
#line 199
  bmp_mask_get_shift_and_prec(alphaMask, & alphaShift, & alphaPrec);
#line 201
  (image->comps + 0)->bpp = redPrec;
#line 202
  (image->comps + 0)->prec = redPrec;
#line 203
  (image->comps + 1)->bpp = greenPrec;
#line 204
  (image->comps + 1)->prec = greenPrec;
#line 205
  (image->comps + 2)->bpp = bluePrec;
#line 206
  (image->comps + 2)->prec = bluePrec;
  }
#line 207
  if (hasAlpha) {
#line 208
    (image->comps + 3)->bpp = alphaPrec;
#line 209
    (image->comps + 3)->prec = alphaPrec;
  }
#line 212
  index___0 = 0;
#line 213
  pSrc = pData + (height - 1U) * stride;
#line 214
  y = (OPJ_UINT32 )0;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;

#line 214
    if (! (y < height)) {
#line 214
      goto while_break;
    }
#line 215
    x = (OPJ_UINT32 )0;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 215
      if (! (x < width)) {
#line 215
        goto while_break___0;
      }
#line 216
      value = 0U;
#line 218
      value |= (OPJ_UINT32 )*(pSrc + 4U * x);
#line 219
      value |= (OPJ_UINT32 )*(pSrc + (4U * x + 1U)) << 8;
#line 220
      value |= (OPJ_UINT32 )*(pSrc + (4U * x + 2U)) << 16;
#line 221
      value |= (OPJ_UINT32 )*(pSrc + (4U * x + 3U)) << 24;
#line 223
      *((image->comps + 0)->data + index___0) = (OPJ_INT32 )((value & redMask) >> redShift);
#line 225
      *((image->comps + 1)->data + index___0) = (OPJ_INT32 )((value & greenMask) >> greenShift);
#line 227
      *((image->comps + 2)->data + index___0) = (OPJ_INT32 )((value & blueMask) >> blueShift);
#line 229
      if (hasAlpha) {
#line 230
        *((image->comps + 3)->data + index___0) = (OPJ_INT32 )((value & alphaMask) >> alphaShift);
      }
#line 233
      index___0 ++;
#line 215
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 235
    pSrc -= stride;
#line 214
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 218
  return;
}
}
#line 239 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static void bmpmask16toimage(OPJ_UINT8 *pData , OPJ_UINT32 stride , opj_image_t *image ,
                             OPJ_UINT32 redMask , OPJ_UINT32 greenMask , OPJ_UINT32 blueMask ,
                             OPJ_UINT32 alphaMask ) 
{ 
  int index___0 ;
  OPJ_UINT32 width ;
  OPJ_UINT32 height ;
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT8 *pSrc ;
  OPJ_BOOL hasAlpha ;
  OPJ_UINT32 redShift ;
  OPJ_UINT32 redPrec ;
  OPJ_UINT32 greenShift ;
  OPJ_UINT32 greenPrec ;
  OPJ_UINT32 blueShift ;
  OPJ_UINT32 bluePrec ;
  OPJ_UINT32 alphaShift ;
  OPJ_UINT32 alphaPrec ;
  OPJ_UINT32 value ;

  {
  {
#line 246
  pSrc = (OPJ_UINT8 *)((void *)0);
#line 253
  width = (image->comps + 0)->w;
#line 254
  height = (image->comps + 0)->h;
#line 256
  hasAlpha = image->numcomps > 3U;
#line 258
  bmp_mask_get_shift_and_prec(redMask, & redShift, & redPrec);
#line 259
  bmp_mask_get_shift_and_prec(greenMask, & greenShift, & greenPrec);
#line 260
  bmp_mask_get_shift_and_prec(blueMask, & blueShift, & bluePrec);
#line 261
  bmp_mask_get_shift_and_prec(alphaMask, & alphaShift, & alphaPrec);
#line 263
  (image->comps + 0)->bpp = redPrec;
#line 264
  (image->comps + 0)->prec = redPrec;
#line 265
  (image->comps + 1)->bpp = greenPrec;
#line 266
  (image->comps + 1)->prec = greenPrec;
#line 267
  (image->comps + 2)->bpp = bluePrec;
#line 268
  (image->comps + 2)->prec = bluePrec;
  }
#line 269
  if (hasAlpha) {
#line 270
    (image->comps + 3)->bpp = alphaPrec;
#line 271
    (image->comps + 3)->prec = alphaPrec;
  }
#line 274
  index___0 = 0;
#line 275
  pSrc = pData + (height - 1U) * stride;
#line 276
  y = (OPJ_UINT32 )0;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;

#line 276
    if (! (y < height)) {
#line 276
      goto while_break;
    }
#line 277
    x = (OPJ_UINT32 )0;
    {
#line 277
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 277
      if (! (x < width)) {
#line 277
        goto while_break___0;
      }
#line 278
      value = 0U;
#line 280
      value |= (OPJ_UINT32 )*(pSrc + 2U * x);
#line 281
      value |= (OPJ_UINT32 )*(pSrc + (2U * x + 1U)) << 8;
#line 283
      *((image->comps + 0)->data + index___0) = (OPJ_INT32 )((value & redMask) >> redShift);
#line 285
      *((image->comps + 1)->data + index___0) = (OPJ_INT32 )((value & greenMask) >> greenShift);
#line 287
      *((image->comps + 2)->data + index___0) = (OPJ_INT32 )((value & blueMask) >> blueShift);
#line 289
      if (hasAlpha) {
#line 290
        *((image->comps + 3)->data + index___0) = (OPJ_INT32 )((value & alphaMask) >> alphaShift);
      }
#line 293
      index___0 ++;
#line 277
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 295
    pSrc -= stride;
#line 276
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 280
  return;
}
}
#line 299 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static opj_image_t *bmp8toimage(OPJ_UINT8 *pData , OPJ_UINT32 stride , opj_image_t *image ,
                                OPJ_UINT8 * const  *pLUT ) 
{ 
  OPJ_UINT32 width ;
  OPJ_UINT32 height ;
  OPJ_UINT8 *pSrc ;
  OPJ_INT32 *pDst[3] ;
  OPJ_INT32 pDstStride[3] ;

  {
#line 303
  pSrc = (OPJ_UINT8 *)((void *)0);
#line 305
  width = (image->comps + 0)->w;
#line 306
  height = (image->comps + 0)->h;
#line 308
  pSrc = pData + (height - 1U) * stride;
#line 309
  if (image->numcomps == 1U) {
    {
#line 310
    opj_applyLUT8u_8u32s_C1R(pSrc, - ((OPJ_INT32 )stride), (image->comps + 0)->data,
                             (OPJ_INT32 )width, (OPJ_UINT8 *)*(pLUT + 0), width, height);
    }
  } else {
    {
#line 316
    pDst[0] = (image->comps + 0)->data;
#line 317
    pDst[1] = (image->comps + 1)->data;
#line 318
    pDst[2] = (image->comps + 2)->data;
#line 319
    pDstStride[0] = (OPJ_INT32 )width;
#line 320
    pDstStride[1] = (OPJ_INT32 )width;
#line 321
    pDstStride[2] = (OPJ_INT32 )width;
#line 322
    opj_applyLUT8u_8u32s_C1P3R(pSrc, - ((OPJ_INT32 )stride), (OPJ_INT32 * const  *)(pDst),
                               pDstStride, pLUT, width, height);
    }
  }
#line 325
  return (image);
}
}
#line 328 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_file_header(FILE *IN , OPJ_BITMAPFILEHEADER *header ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 330
  __cil_tmp3 = getc(IN);
#line 330
  header->bfType = (OPJ_UINT16 )__cil_tmp3;
#line 331
  __cil_tmp4 = getc(IN);
#line 331
  header->bfType = (OPJ_UINT16 )((int )header->bfType | (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp4 << 8)));
  }
#line 333
  if ((int )header->bfType != 19778) {
    {
#line 334
    fprintf(stderr, "Error, not a BMP file!\n");
    }
#line 335
    return (0);
  }
  {
#line 340
  __cil_tmp5 = getc(IN);
#line 340
  header->bfSize = (OPJ_UINT32 )__cil_tmp5;
#line 341
  __cil_tmp6 = getc(IN);
#line 341
  header->bfSize |= (OPJ_UINT32 )__cil_tmp6 << 8;
#line 342
  __cil_tmp7 = getc(IN);
#line 342
  header->bfSize |= (OPJ_UINT32 )__cil_tmp7 << 16;
#line 343
  __cil_tmp8 = getc(IN);
#line 343
  header->bfSize |= (OPJ_UINT32 )__cil_tmp8 << 24;
#line 345
  __cil_tmp9 = getc(IN);
#line 345
  header->bfReserved1 = (OPJ_UINT16 )__cil_tmp9;
#line 346
  __cil_tmp10 = getc(IN);
#line 346
  header->bfReserved1 = (OPJ_UINT16 )((int )header->bfReserved1 | (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp10 << 8)));
#line 348
  __cil_tmp11 = getc(IN);
#line 348
  header->bfReserved2 = (OPJ_UINT16 )__cil_tmp11;
#line 349
  __cil_tmp12 = getc(IN);
#line 349
  header->bfReserved2 = (OPJ_UINT16 )((int )header->bfReserved2 | (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp12 << 8)));
#line 351
  __cil_tmp13 = getc(IN);
#line 351
  header->bfOffBits = (OPJ_UINT32 )__cil_tmp13;
#line 352
  __cil_tmp14 = getc(IN);
#line 352
  header->bfOffBits |= (OPJ_UINT32 )__cil_tmp14 << 8;
#line 353
  __cil_tmp15 = getc(IN);
#line 353
  header->bfOffBits |= (OPJ_UINT32 )__cil_tmp15 << 16;
#line 354
  __cil_tmp16 = getc(IN);
#line 354
  header->bfOffBits |= (OPJ_UINT32 )__cil_tmp16 << 24;
  }
#line 355
  return (1);
}
}
#line 357 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_info_header(FILE *IN , OPJ_BITMAPINFOHEADER *header ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;

  {
  {
#line 359
  memset((void *)header, 0, sizeof(*header));
#line 362
  __cil_tmp3 = getc(IN);
#line 362
  header->biSize = (OPJ_UINT32 )__cil_tmp3;
#line 363
  __cil_tmp4 = getc(IN);
#line 363
  header->biSize |= (OPJ_UINT32 )__cil_tmp4 << 8;
#line 364
  __cil_tmp5 = getc(IN);
#line 364
  header->biSize |= (OPJ_UINT32 )__cil_tmp5 << 16;
#line 365
  __cil_tmp6 = getc(IN);
#line 365
  header->biSize |= (OPJ_UINT32 )__cil_tmp6 << 24;
  }
#line 373
  if (header->biSize == 124U) {
#line 373
    goto case_124;
  }
#line 373
  if (header->biSize == 108U) {
#line 373
    goto case_124;
  }
#line 373
  if (header->biSize == 56U) {
#line 373
    goto case_124;
  }
#line 373
  if (header->biSize == 52U) {
#line 373
    goto case_124;
  }
#line 373
  if (header->biSize == 40U) {
#line 373
    goto case_124;
  }
#line 373
  if (header->biSize == 12U) {
#line 373
    goto case_124;
  }
#line 375
  goto switch_default;
  case_124: 
#line 374
  goto switch_break;
  switch_default: 
  {
#line 376
  fprintf(stderr, "Error, unknown BMP header size %d\n", header->biSize);
  }
#line 377
  return (0);
  switch_break: 
  {
#line 380
  __cil_tmp7 = getc(IN);
#line 380
  header->biWidth = (OPJ_UINT32 )__cil_tmp7;
#line 381
  __cil_tmp8 = getc(IN);
#line 381
  header->biWidth |= (OPJ_UINT32 )__cil_tmp8 << 8;
#line 382
  __cil_tmp9 = getc(IN);
#line 382
  header->biWidth |= (OPJ_UINT32 )__cil_tmp9 << 16;
#line 383
  __cil_tmp10 = getc(IN);
#line 383
  header->biWidth |= (OPJ_UINT32 )__cil_tmp10 << 24;
#line 385
  __cil_tmp11 = getc(IN);
#line 385
  header->biHeight = (OPJ_UINT32 )__cil_tmp11;
#line 386
  __cil_tmp12 = getc(IN);
#line 386
  header->biHeight |= (OPJ_UINT32 )__cil_tmp12 << 8;
#line 387
  __cil_tmp13 = getc(IN);
#line 387
  header->biHeight |= (OPJ_UINT32 )__cil_tmp13 << 16;
#line 388
  __cil_tmp14 = getc(IN);
#line 388
  header->biHeight |= (OPJ_UINT32 )__cil_tmp14 << 24;
#line 390
  __cil_tmp15 = getc(IN);
#line 390
  header->biPlanes = (OPJ_UINT16 )__cil_tmp15;
#line 391
  __cil_tmp16 = getc(IN);
#line 391
  header->biPlanes = (OPJ_UINT16 )((int )header->biPlanes | (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp16 << 8)));
#line 393
  __cil_tmp17 = getc(IN);
#line 393
  header->biBitCount = (OPJ_UINT16 )__cil_tmp17;
#line 394
  __cil_tmp18 = getc(IN);
#line 394
  header->biBitCount = (OPJ_UINT16 )((int )header->biBitCount | (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp18 << 8)));
  }
#line 395
  if ((int )header->biBitCount == 0) {
    {
#line 396
    fprintf(stderr, "Error, invalid biBitCount %d\n", 0);
    }
#line 397
    return (0);
  }
#line 400
  if (header->biSize >= 40U) {
    {
#line 401
    __cil_tmp19 = getc(IN);
#line 401
    header->biCompression = (OPJ_UINT32 )__cil_tmp19;
#line 402
    __cil_tmp20 = getc(IN);
#line 402
    header->biCompression |= (OPJ_UINT32 )__cil_tmp20 << 8;
#line 403
    __cil_tmp21 = getc(IN);
#line 403
    header->biCompression |= (OPJ_UINT32 )__cil_tmp21 << 16;
#line 404
    __cil_tmp22 = getc(IN);
#line 404
    header->biCompression |= (OPJ_UINT32 )__cil_tmp22 << 24;
#line 406
    __cil_tmp23 = getc(IN);
#line 406
    header->biSizeImage = (OPJ_UINT32 )__cil_tmp23;
#line 407
    __cil_tmp24 = getc(IN);
#line 407
    header->biSizeImage |= (OPJ_UINT32 )__cil_tmp24 << 8;
#line 408
    __cil_tmp25 = getc(IN);
#line 408
    header->biSizeImage |= (OPJ_UINT32 )__cil_tmp25 << 16;
#line 409
    __cil_tmp26 = getc(IN);
#line 409
    header->biSizeImage |= (OPJ_UINT32 )__cil_tmp26 << 24;
#line 411
    __cil_tmp27 = getc(IN);
#line 411
    header->biXpelsPerMeter = (OPJ_UINT32 )__cil_tmp27;
#line 412
    __cil_tmp28 = getc(IN);
#line 412
    header->biXpelsPerMeter |= (OPJ_UINT32 )__cil_tmp28 << 8;
#line 413
    __cil_tmp29 = getc(IN);
#line 413
    header->biXpelsPerMeter |= (OPJ_UINT32 )__cil_tmp29 << 16;
#line 414
    __cil_tmp30 = getc(IN);
#line 414
    header->biXpelsPerMeter |= (OPJ_UINT32 )__cil_tmp30 << 24;
#line 416
    __cil_tmp31 = getc(IN);
#line 416
    header->biYpelsPerMeter = (OPJ_UINT32 )__cil_tmp31;
#line 417
    __cil_tmp32 = getc(IN);
#line 417
    header->biYpelsPerMeter |= (OPJ_UINT32 )__cil_tmp32 << 8;
#line 418
    __cil_tmp33 = getc(IN);
#line 418
    header->biYpelsPerMeter |= (OPJ_UINT32 )__cil_tmp33 << 16;
#line 419
    __cil_tmp34 = getc(IN);
#line 419
    header->biYpelsPerMeter |= (OPJ_UINT32 )__cil_tmp34 << 24;
#line 421
    __cil_tmp35 = getc(IN);
#line 421
    header->biClrUsed = (OPJ_UINT32 )__cil_tmp35;
#line 422
    __cil_tmp36 = getc(IN);
#line 422
    header->biClrUsed |= (OPJ_UINT32 )__cil_tmp36 << 8;
#line 423
    __cil_tmp37 = getc(IN);
#line 423
    header->biClrUsed |= (OPJ_UINT32 )__cil_tmp37 << 16;
#line 424
    __cil_tmp38 = getc(IN);
#line 424
    header->biClrUsed |= (OPJ_UINT32 )__cil_tmp38 << 24;
#line 426
    __cil_tmp39 = getc(IN);
#line 426
    header->biClrImportant = (OPJ_UINT32 )__cil_tmp39;
#line 427
    __cil_tmp40 = getc(IN);
#line 427
    header->biClrImportant |= (OPJ_UINT32 )__cil_tmp40 << 8;
#line 428
    __cil_tmp41 = getc(IN);
#line 428
    header->biClrImportant |= (OPJ_UINT32 )__cil_tmp41 << 16;
#line 429
    __cil_tmp42 = getc(IN);
#line 429
    header->biClrImportant |= (OPJ_UINT32 )__cil_tmp42 << 24;
    }
  }
#line 432
  if (header->biSize >= 56U) {
    {
#line 433
    __cil_tmp43 = getc(IN);
#line 433
    header->biRedMask = (OPJ_UINT32 )__cil_tmp43;
#line 434
    __cil_tmp44 = getc(IN);
#line 434
    header->biRedMask |= (OPJ_UINT32 )__cil_tmp44 << 8;
#line 435
    __cil_tmp45 = getc(IN);
#line 435
    header->biRedMask |= (OPJ_UINT32 )__cil_tmp45 << 16;
#line 436
    __cil_tmp46 = getc(IN);
#line 436
    header->biRedMask |= (OPJ_UINT32 )__cil_tmp46 << 24;
#line 438
    __cil_tmp47 = getc(IN);
#line 438
    header->biGreenMask = (OPJ_UINT32 )__cil_tmp47;
#line 439
    __cil_tmp48 = getc(IN);
#line 439
    header->biGreenMask |= (OPJ_UINT32 )__cil_tmp48 << 8;
#line 440
    __cil_tmp49 = getc(IN);
#line 440
    header->biGreenMask |= (OPJ_UINT32 )__cil_tmp49 << 16;
#line 441
    __cil_tmp50 = getc(IN);
#line 441
    header->biGreenMask |= (OPJ_UINT32 )__cil_tmp50 << 24;
#line 443
    __cil_tmp51 = getc(IN);
#line 443
    header->biBlueMask = (OPJ_UINT32 )__cil_tmp51;
#line 444
    __cil_tmp52 = getc(IN);
#line 444
    header->biBlueMask |= (OPJ_UINT32 )__cil_tmp52 << 8;
#line 445
    __cil_tmp53 = getc(IN);
#line 445
    header->biBlueMask |= (OPJ_UINT32 )__cil_tmp53 << 16;
#line 446
    __cil_tmp54 = getc(IN);
#line 446
    header->biBlueMask |= (OPJ_UINT32 )__cil_tmp54 << 24;
#line 448
    __cil_tmp55 = getc(IN);
#line 448
    header->biAlphaMask = (OPJ_UINT32 )__cil_tmp55;
#line 449
    __cil_tmp56 = getc(IN);
#line 449
    header->biAlphaMask |= (OPJ_UINT32 )__cil_tmp56 << 8;
#line 450
    __cil_tmp57 = getc(IN);
#line 450
    header->biAlphaMask |= (OPJ_UINT32 )__cil_tmp57 << 16;
#line 451
    __cil_tmp58 = getc(IN);
#line 451
    header->biAlphaMask |= (OPJ_UINT32 )__cil_tmp58 << 24;
    }
  }
#line 454
  if (header->biSize >= 108U) {
    {
#line 455
    __cil_tmp59 = getc(IN);
#line 455
    header->biColorSpaceType = (OPJ_UINT32 )__cil_tmp59;
#line 456
    __cil_tmp60 = getc(IN);
#line 456
    header->biColorSpaceType |= (OPJ_UINT32 )__cil_tmp60 << 8;
#line 457
    __cil_tmp61 = getc(IN);
#line 457
    header->biColorSpaceType |= (OPJ_UINT32 )__cil_tmp61 << 16;
#line 458
    __cil_tmp62 = getc(IN);
#line 458
    header->biColorSpaceType |= (OPJ_UINT32 )__cil_tmp62 << 24;
#line 460
    __cil_tmp63 = fread((void *)(& header->biColorSpaceEP), 1UL, sizeof(header->biColorSpaceEP),
                        IN);
    }
#line 460
    if (__cil_tmp63 != sizeof(header->biColorSpaceEP)) {
      {
#line 462
      fprintf(stderr, "Error, can\'t  read BMP header\n");
      }
#line 463
      return (0);
    }
    {
#line 466
    __cil_tmp64 = getc(IN);
#line 466
    header->biRedGamma = (OPJ_UINT32 )__cil_tmp64;
#line 467
    __cil_tmp65 = getc(IN);
#line 467
    header->biRedGamma |= (OPJ_UINT32 )__cil_tmp65 << 8;
#line 468
    __cil_tmp66 = getc(IN);
#line 468
    header->biRedGamma |= (OPJ_UINT32 )__cil_tmp66 << 16;
#line 469
    __cil_tmp67 = getc(IN);
#line 469
    header->biRedGamma |= (OPJ_UINT32 )__cil_tmp67 << 24;
#line 471
    __cil_tmp68 = getc(IN);
#line 471
    header->biGreenGamma = (OPJ_UINT32 )__cil_tmp68;
#line 472
    __cil_tmp69 = getc(IN);
#line 472
    header->biGreenGamma |= (OPJ_UINT32 )__cil_tmp69 << 8;
#line 473
    __cil_tmp70 = getc(IN);
#line 473
    header->biGreenGamma |= (OPJ_UINT32 )__cil_tmp70 << 16;
#line 474
    __cil_tmp71 = getc(IN);
#line 474
    header->biGreenGamma |= (OPJ_UINT32 )__cil_tmp71 << 24;
#line 476
    __cil_tmp72 = getc(IN);
#line 476
    header->biBlueGamma = (OPJ_UINT32 )__cil_tmp72;
#line 477
    __cil_tmp73 = getc(IN);
#line 477
    header->biBlueGamma |= (OPJ_UINT32 )__cil_tmp73 << 8;
#line 478
    __cil_tmp74 = getc(IN);
#line 478
    header->biBlueGamma |= (OPJ_UINT32 )__cil_tmp74 << 16;
#line 479
    __cil_tmp75 = getc(IN);
#line 479
    header->biBlueGamma |= (OPJ_UINT32 )__cil_tmp75 << 24;
    }
  }
#line 482
  if (header->biSize >= 124U) {
    {
#line 483
    __cil_tmp76 = getc(IN);
#line 483
    header->biIntent = (OPJ_UINT32 )__cil_tmp76;
#line 484
    __cil_tmp77 = getc(IN);
#line 484
    header->biIntent |= (OPJ_UINT32 )__cil_tmp77 << 8;
#line 485
    __cil_tmp78 = getc(IN);
#line 485
    header->biIntent |= (OPJ_UINT32 )__cil_tmp78 << 16;
#line 486
    __cil_tmp79 = getc(IN);
#line 486
    header->biIntent |= (OPJ_UINT32 )__cil_tmp79 << 24;
#line 488
    __cil_tmp80 = getc(IN);
#line 488
    header->biIccProfileData = (OPJ_UINT32 )__cil_tmp80;
#line 489
    __cil_tmp81 = getc(IN);
#line 489
    header->biIccProfileData |= (OPJ_UINT32 )__cil_tmp81 << 8;
#line 490
    __cil_tmp82 = getc(IN);
#line 490
    header->biIccProfileData |= (OPJ_UINT32 )__cil_tmp82 << 16;
#line 491
    __cil_tmp83 = getc(IN);
#line 491
    header->biIccProfileData |= (OPJ_UINT32 )__cil_tmp83 << 24;
#line 493
    __cil_tmp84 = getc(IN);
#line 493
    header->biIccProfileSize = (OPJ_UINT32 )__cil_tmp84;
#line 494
    __cil_tmp85 = getc(IN);
#line 494
    header->biIccProfileSize |= (OPJ_UINT32 )__cil_tmp85 << 8;
#line 495
    __cil_tmp86 = getc(IN);
#line 495
    header->biIccProfileSize |= (OPJ_UINT32 )__cil_tmp86 << 16;
#line 496
    __cil_tmp87 = getc(IN);
#line 496
    header->biIccProfileSize |= (OPJ_UINT32 )__cil_tmp87 << 24;
#line 498
    __cil_tmp88 = getc(IN);
#line 498
    header->biReserved = (OPJ_UINT32 )__cil_tmp88;
#line 499
    __cil_tmp89 = getc(IN);
#line 499
    header->biReserved |= (OPJ_UINT32 )__cil_tmp89 << 8;
#line 500
    __cil_tmp90 = getc(IN);
#line 500
    header->biReserved |= (OPJ_UINT32 )__cil_tmp90 << 16;
#line 501
    __cil_tmp91 = getc(IN);
#line 501
    header->biReserved |= (OPJ_UINT32 )__cil_tmp91 << 24;
    }
  }
#line 503
  return (1);
}
}
#line 506 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_raw_data(FILE *IN , OPJ_UINT8 *pData , OPJ_UINT32 stride ,
                                  OPJ_UINT32 width , OPJ_UINT32 height ) 
{ 
  unsigned long __cil_tmp6 ;

  {
  {
#line 511
  __cil_tmp6 = fread((void *)pData, sizeof(OPJ_UINT8 ), (unsigned long )(stride * height),
                     IN);
  }
#line 511
  if (__cil_tmp6 != (unsigned long )(stride * height)) {
    {
#line 512
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 514
    return (0);
  }
#line 516
  return (1);
}
}
#line 519 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_rle8_data(FILE *IN , OPJ_UINT8 *pData , OPJ_UINT32 stride ,
                                   OPJ_UINT32 width , OPJ_UINT32 height ) 
{ 
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT8 *pix ;
  OPJ_UINT8 *beyond ;
  int c ;
  int __cil_tmp11 ;
  int j ;
  int c1_int ;
  OPJ_UINT8 c1 ;
  int __cil_tmp16 ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT8 *__cil_tmp18 ;
  int j___0 ;
  int c1_int___0 ;
  OPJ_UINT8 c1___0 ;
  int __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT8 *__cil_tmp28 ;

  {
#line 526
  beyond = pData + stride * height;
#line 527
  pix = pData;
#line 529
  y = 0U;
#line 529
  x = y;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;

#line 530
    if (! (y < height)) {
#line 530
      goto while_break;
    }
    {
#line 531
    __cil_tmp11 = getc(IN);
#line 531
    c = __cil_tmp11;
    }
#line 532
    if (c == -1) {
#line 533
      return (0);
    }
#line 536
    if (c) {
      {
#line 540
      c1_int = getc(IN);
      }
#line 541
      if (c1_int == -1) {
#line 542
        return (0);
      }
#line 544
      c1 = (OPJ_UINT8 )c1_int;
#line 546
      j = 0;
      {
#line 546
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 546
        if (j < c) {
#line 546
          if (x < width) {
#line 546
            if (! ((OPJ_SIZE_T )pix < (OPJ_SIZE_T )beyond)) {
#line 546
              goto while_break___0;
            }
          } else {
#line 546
            goto while_break___0;
          }
        } else {
#line 546
          goto while_break___0;
        }
#line 548
        *pix = c1;
#line 547
        __cil_tmp18 = pix;
#line 547
        pix ++;
#line 547
        __cil_tmp17 = x;
#line 547
        x ++;
#line 547
        __cil_tmp16 = j;
#line 547
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
      {
#line 551
      c = getc(IN);
      }
#line 552
      if (c == -1) {
#line 553
        return (0);
      }
#line 556
      if (c == 0) {
#line 557
        x = (OPJ_UINT32 )0;
#line 558
        y ++;
#line 559
        pix = (pData + y * stride) + x;
      } else
#line 560
      if (c == 1) {
#line 561
        goto while_break;
      } else
#line 562
      if (c == 2) {
        {
#line 563
        c = getc(IN);
        }
#line 564
        if (c == -1) {
#line 565
          return (0);
        }
        {
#line 567
        x += (OPJ_UINT32 )c;
#line 568
        c = getc(IN);
        }
#line 569
        if (c == -1) {
#line 570
          return (0);
        }
#line 572
        y += (OPJ_UINT32 )c;
#line 573
        pix = (pData + y * stride) + x;
      } else {
#line 576
        j___0 = 0;
        {
#line 576
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 576
          if (j___0 < c) {
#line 576
            if (x < width) {
#line 576
              if (! ((OPJ_SIZE_T )pix < (OPJ_SIZE_T )beyond)) {
#line 576
                goto while_break___1;
              }
            } else {
#line 576
              goto while_break___1;
            }
          } else {
#line 576
            goto while_break___1;
          }
          {
#line 580
          c1_int___0 = getc(IN);
          }
#line 581
          if (c1_int___0 == -1) {
#line 582
            return (0);
          }
#line 584
          c1___0 = (OPJ_UINT8 )c1_int___0;
#line 585
          *pix = c1___0;
#line 577
          __cil_tmp28 = pix;
#line 577
          pix ++;
#line 577
          __cil_tmp27 = x;
#line 577
          x ++;
#line 577
          __cil_tmp26 = j___0;
#line 577
          j___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: ;
#line 587
        if ((OPJ_UINT32 )c & 1U) {
          {
#line 588
          c = getc(IN);
          }
#line 589
          if (c == -1) {
#line 590
            return (0);
          }
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 596
  return (1);
}
}
#line 599 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_rle4_data(FILE *IN , OPJ_UINT8 *pData , OPJ_UINT32 stride ,
                                   OPJ_UINT32 width , OPJ_UINT32 height ) 
{ 
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT8 *pix ;
  OPJ_UINT8 *beyond ;
  int c ;
  int __cil_tmp11 ;
  int j ;
  OPJ_UINT8 c1 ;
  int __cil_tmp14 ;
  unsigned int tmp ;
  int __cil_tmp16 ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT8 *__cil_tmp18 ;
  int j___0 ;
  OPJ_UINT8 c1___0 ;
  int __cil_tmp25 ;
  unsigned int tmp___0 ;
  int __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT8 *__cil_tmp29 ;

  {
#line 606
  beyond = pData + stride * height;
#line 607
  pix = pData;
#line 608
  y = 0U;
#line 608
  x = y;
  {
#line 609
  while (1) {
    while_continue: /* CIL Label */ ;

#line 609
    if (! (y < height)) {
#line 609
      goto while_break;
    }
    {
#line 610
    __cil_tmp11 = getc(IN);
#line 610
    c = __cil_tmp11;
    }
#line 611
    if (c == -1) {
#line 612
      goto while_break;
    }
#line 615
    if (c) {
      {
#line 617
      __cil_tmp14 = getc(IN);
#line 617
      c1 = (OPJ_UINT8 )__cil_tmp14;
#line 619
      j = 0;
      }
      {
#line 619
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 619
        if (j < c) {
#line 619
          if (x < width) {
#line 619
            if (! ((OPJ_SIZE_T )pix < (OPJ_SIZE_T )beyond)) {
#line 619
              goto while_break___0;
            }
          } else {
#line 619
            goto while_break___0;
          }
        } else {
#line 619
          goto while_break___0;
        }
#line 621
        if (j & 1) {
#line 621
          tmp = (unsigned int )c1 & 15U;
        } else {
#line 621
          tmp = (unsigned int )((int )c1 >> 4) & 15U;
        }
#line 621
        *pix = (OPJ_UINT8 )tmp;
#line 620
        __cil_tmp18 = pix;
#line 620
        pix ++;
#line 620
        __cil_tmp17 = x;
#line 620
        x ++;
#line 620
        __cil_tmp16 = j;
#line 620
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
      {
#line 624
      c = getc(IN);
      }
#line 625
      if (c == -1) {
#line 626
        goto while_break;
      }
#line 629
      if (c == 0) {
#line 630
        x = (OPJ_UINT32 )0;
#line 631
        y ++;
#line 632
        pix = pData + y * stride;
      } else
#line 633
      if (c == 1) {
#line 634
        goto while_break;
      } else
#line 635
      if (c == 2) {
        {
#line 636
        c = getc(IN);
#line 637
        x += (OPJ_UINT32 )c;
#line 638
        c = getc(IN);
#line 639
        y += (OPJ_UINT32 )c;
#line 640
        pix = (pData + y * stride) + x;
        }
      } else {
#line 643
        c1___0 = (OPJ_UINT8 )0U;
#line 645
        j___0 = 0;
        {
#line 645
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 645
          if (j___0 < c) {
#line 645
            if (x < width) {
#line 645
              if (! ((OPJ_SIZE_T )pix < (OPJ_SIZE_T )beyond)) {
#line 645
                goto while_break___1;
              }
            } else {
#line 645
              goto while_break___1;
            }
          } else {
#line 645
            goto while_break___1;
          }
#line 647
          if ((j___0 & 1) == 0) {
            {
#line 648
            __cil_tmp25 = getc(IN);
#line 648
            c1___0 = (OPJ_UINT8 )__cil_tmp25;
            }
          }
#line 650
          if (j___0 & 1) {
#line 650
            tmp___0 = (unsigned int )c1___0 & 15U;
          } else {
#line 650
            tmp___0 = (unsigned int )((int )c1___0 >> 4) & 15U;
          }
#line 650
          *pix = (OPJ_UINT8 )tmp___0;
#line 646
          __cil_tmp29 = pix;
#line 646
          pix ++;
#line 646
          __cil_tmp28 = x;
#line 646
          x ++;
#line 646
          __cil_tmp27 = j___0;
#line 646
          j___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: ;
#line 652
        if ((c & 3) == 1) {
          {
#line 653
          getc(IN);
          }
        } else
#line 652
        if ((c & 3) == 2) {
          {
#line 653
          getc(IN);
          }
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 658
  return (1);
}
}
#line 661 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  opj_image_cmptparm_t cmptparm[4] ;
  OPJ_UINT8 lut_R[256] ;
  OPJ_UINT8 lut_G[256] ;
  OPJ_UINT8 lut_B[256] ;
  OPJ_UINT8 *pLUT[3] ;
  opj_image_t *image ;
  FILE *IN ;
  OPJ_BITMAPFILEHEADER File_h ;
  OPJ_BITMAPINFOHEADER Info_h ;
  OPJ_UINT32 i ;
  OPJ_UINT32 palette_len ;
  OPJ_UINT32 numcmpts ;
  OPJ_BOOL l_result ;
  OPJ_UINT8 *pData ;
  OPJ_UINT32 stride ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_UINT8 has_color ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  void *__cil_tmp27 ;
  int tmp ;
  opj_image_t *__cil_tmp33 ;

  {
  {
#line 666
  image = (opj_image_t *)((void *)0);
#line 670
  numcmpts = 1U;
#line 671
  l_result = 0;
#line 672
  pData = (OPJ_UINT8 *)((void *)0);
#line 675
  pLUT[0] = lut_R;
#line 676
  pLUT[1] = lut_G;
#line 677
  pLUT[2] = lut_B;
#line 679
  IN = fopen(filename, "rbY3 V");
  }
#line 680
  if (! IN) {
    {
#line 681
    fprintf(stderr, "Failed to open %s for reading !!\n\236Y3 V", filename);
    }
#line 682
    return ((opj_image_t *)((void *)0));
  }
  {
#line 685
  __cil_tmp19 = bmp_read_file_header(IN, & File_h);
  }
#line 685
  if (! __cil_tmp19) {
    {
#line 686
    fclose(IN);
    }
#line 687
    return ((opj_image_t *)((void *)0));
  }
  {
#line 689
  __cil_tmp20 = bmp_read_info_header(IN, & Info_h);
  }
#line 689
  if (! __cil_tmp20) {
    {
#line 690
    fclose(IN);
    }
#line 691
    return ((opj_image_t *)((void *)0));
  }
#line 695
  if ((unsigned int )Info_h.biBitCount <= 8U) {
    {
#line 696
    memset((void *)(& lut_R[0]), 0, sizeof(lut_R));
#line 697
    memset((void *)(& lut_G[0]), 0, sizeof(lut_G));
#line 698
    memset((void *)(& lut_B[0]), 0, sizeof(lut_B));
#line 700
    palette_len = Info_h.biClrUsed;
    }
#line 701
    if (palette_len == 0U) {
#line 701
      if ((unsigned int )Info_h.biBitCount <= 8U) {
#line 702
        palette_len = 1U << (int )Info_h.biBitCount;
      }
    }
#line 704
    if (palette_len > 256U) {
#line 705
      palette_len = 256U;
    }
#line 707
    if (palette_len > 0U) {
#line 708
      has_color = (OPJ_UINT8 )0U;
#line 709
      i = 0U;
      {
#line 709
      while (1) {
        while_continue: /* CIL Label */ ;

#line 709
        if (! (i < palette_len)) {
#line 709
          goto while_break;
        }
        {
#line 710
        __cil_tmp22 = getc(IN);
#line 710
        lut_B[i] = (OPJ_UINT8 )__cil_tmp22;
#line 711
        __cil_tmp23 = getc(IN);
#line 711
        lut_G[i] = (OPJ_UINT8 )__cil_tmp23;
#line 712
        __cil_tmp24 = getc(IN);
#line 712
        lut_R[i] = (OPJ_UINT8 )__cil_tmp24;
#line 713
        getc(IN);
#line 714
        has_color = (OPJ_UINT8 )((int )has_color | (((int )lut_B[i] ^ (int )lut_G[i]) | ((int )lut_G[i] ^ (int )lut_R[i])));
#line 709
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: ;
#line 716
      if (has_color) {
#line 717
        numcmpts = 3U;
      }
    }
  } else {
#line 721
    numcmpts = 3U;
#line 722
    if (Info_h.biCompression == 3U) {
#line 722
      if (Info_h.biAlphaMask != 0U) {
#line 723
        numcmpts ++;
      }
    }
  }
#line 727
  if (Info_h.biWidth == 0U) {
    {
#line 728
    fclose(IN);
    }
#line 729
    return ((opj_image_t *)((void *)0));
  } else
#line 727
  if (Info_h.biHeight == 0U) {
    {
#line 728
    fclose(IN);
    }
#line 729
    return ((opj_image_t *)((void *)0));
  }
#line 732
  if ((unsigned int )Info_h.biBitCount > 4294967264U / Info_h.biWidth) {
    {
#line 733
    fclose(IN);
    }
#line 734
    return ((opj_image_t *)((void *)0));
  }
#line 736
  stride = ((Info_h.biWidth * (unsigned int )Info_h.biBitCount + 31U) / 32U) * 4U;
#line 738
  if ((int )Info_h.biBitCount == 4) {
#line 738
    if (Info_h.biCompression == 2U) {
#line 740
      if (8U > 4294967264U / Info_h.biWidth) {
        {
#line 741
        fclose(IN);
        }
#line 742
        return ((opj_image_t *)((void *)0));
      }
#line 744
      stride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;
    }
  }
#line 747
  if ((unsigned long )stride > (4294967295UL / sizeof(OPJ_UINT8 )) / (unsigned long )Info_h.biHeight) {
    {
#line 748
    fclose(IN);
    }
#line 749
    return ((opj_image_t *)((void *)0));
  }
  {
#line 751
  __cil_tmp27 = calloc(1UL, (unsigned long )(stride * Info_h.biHeight) * sizeof(OPJ_UINT8 ));
#line 751
  pData = (OPJ_UINT8 *)__cil_tmp27;
  }
#line 752
  if ((unsigned long )pData == (unsigned long )((void *)0)) {
    {
#line 753
    fclose(IN);
    }
#line 754
    return ((opj_image_t *)((void *)0));
  }
  {
#line 757
  fseek(IN, 0L, 0);
#line 758
  fseek(IN, (long )File_h.bfOffBits, 0);
  }
#line 762
  if (Info_h.biCompression == 3U) {
#line 762
    goto case_3;
  }
#line 762
  if (Info_h.biCompression == 0U) {
#line 762
    goto case_3;
  }
#line 767
  if (Info_h.biCompression == 1U) {
#line 767
    goto case_1;
  }
#line 772
  if (Info_h.biCompression == 2U) {
#line 772
    goto case_2;
  }
#line 777
  goto switch_default;
  case_3: 
  {
#line 764
  l_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);
  }
#line 766
  goto switch_break;
  case_1: 
  {
#line 769
  l_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);
  }
#line 771
  goto switch_break;
  case_2: 
  {
#line 774
  l_result = bmp_read_rle4_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);
  }
#line 776
  goto switch_break;
  switch_default: 
  {
#line 778
  fprintf(stderr, "Unsupported BMP compression\n");
#line 779
  l_result = 0;
  }
#line 780
  goto switch_break;
  switch_break: ;
#line 782
  if (! l_result) {
    {
#line 783
    free((void *)pData);
#line 784
    fclose(IN);
    }
#line 785
    return ((opj_image_t *)((void *)0));
  }
  {
#line 789
  memset((void *)(& cmptparm[0]), 0, sizeof(cmptparm));
#line 790
  i = (OPJ_UINT32 )0;
  }
  {
#line 790
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 790
    if (! (i < 4U)) {
#line 790
      goto while_break___0;
    }
#line 791
    cmptparm[i].prec = (OPJ_UINT32 )8;
#line 792
    cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 793
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 794
    cmptparm[i].dx = (OPJ_UINT32 )parameters->subsampling_dx;
#line 795
    cmptparm[i].dy = (OPJ_UINT32 )parameters->subsampling_dy;
#line 796
    cmptparm[i].w = Info_h.biWidth;
#line 797
    cmptparm[i].h = Info_h.biHeight;
#line 790
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 800
  if (numcmpts == 1U) {
#line 800
    tmp = 2;
  } else {
#line 800
    tmp = 1;
  }
  {
#line 800
  __cil_tmp33 = opj_image_create(numcmpts, & cmptparm[0], (OPJ_COLOR_SPACE )tmp);
#line 800
  image = __cil_tmp33;
  }
#line 802
  if (! image) {
    {
#line 803
    fclose(IN);
#line 804
    free((void *)pData);
    }
#line 805
    return ((opj_image_t *)((void *)0));
  }
#line 807
  if (numcmpts == 4U) {
#line 808
    (image->comps + 3)->alpha = (OPJ_UINT16 )1;
  }
#line 812
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 813
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 814
  image->x1 = (image->x0 + (Info_h.biWidth - 1U) * (OPJ_UINT32 )parameters->subsampling_dx) + 1U;
#line 816
  image->y1 = (image->y0 + (Info_h.biHeight - 1U) * (OPJ_UINT32 )parameters->subsampling_dy) + 1U;
#line 820
  if ((int )Info_h.biBitCount == 24) {
#line 820
    if (Info_h.biCompression == 0U) {
      {
#line 821
      bmp24toimage(pData, stride, image);
      }
    } else {
#line 820
      goto _L___55;
    }
  } else
  _L___55: 
#line 822
  if ((int )Info_h.biBitCount == 8) {
#line 822
    if (Info_h.biCompression == 0U) {
      {
#line 824
      bmp8toimage(pData, stride, image, (OPJ_UINT8 * const  *)(pLUT));
      }
    } else {
#line 822
      goto _L___54;
    }
  } else
  _L___54: 
#line 825
  if ((int )Info_h.biBitCount == 8) {
#line 825
    if (Info_h.biCompression == 1U) {
      {
#line 826
      bmp8toimage(pData, stride, image, (OPJ_UINT8 * const  *)(pLUT));
      }
    } else {
#line 825
      goto _L___53;
    }
  } else
  _L___53: 
#line 827
  if ((int )Info_h.biBitCount == 4) {
#line 827
    if (Info_h.biCompression == 2U) {
      {
#line 828
      bmp8toimage(pData, stride, image, (OPJ_UINT8 * const  *)(pLUT));
      }
    } else {
#line 827
      goto _L___52;
    }
  } else
  _L___52: 
#line 830
  if ((int )Info_h.biBitCount == 32) {
#line 830
    if (Info_h.biCompression == 0U) {
      {
#line 831
      bmpmask32toimage(pData, stride, image, 16711680U, 65280U, 255U, 0U);
      }
    } else {
#line 830
      goto _L___51;
    }
  } else
  _L___51: 
#line 833
  if ((int )Info_h.biBitCount == 32) {
#line 833
    if (Info_h.biCompression == 3U) {
      {
#line 834
      bmpmask32toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask,
                       Info_h.biBlueMask, Info_h.biAlphaMask);
      }
    } else {
#line 833
      goto _L___50;
    }
  } else
  _L___50: 
#line 836
  if ((int )Info_h.biBitCount == 16) {
#line 836
    if (Info_h.biCompression == 0U) {
      {
#line 837
      bmpmask16toimage(pData, stride, image, 31744U, 992U, 31U, 0U);
      }
    } else {
#line 836
      goto _L;
    }
  } else
  _L: 
#line 838
  if ((int )Info_h.biBitCount == 16) {
#line 838
    if (Info_h.biCompression == 3U) {
#line 839
      if (Info_h.biRedMask == 0U) {
#line 839
        if (Info_h.biGreenMask == 0U) {
#line 839
          if (Info_h.biBlueMask == 0U) {
#line 841
            Info_h.biRedMask = 63488U;
#line 842
            Info_h.biGreenMask = 2016U;
#line 843
            Info_h.biBlueMask = 31U;
          }
        }
      }
      {
#line 845
      bmpmask16toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask,
                       Info_h.biBlueMask, Info_h.biAlphaMask);
      }
    } else {
      {
#line 848
      opj_image_destroy(image);
#line 849
      image = (opj_image_t *)((void *)0);
#line 850
      fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
              (int )Info_h.biBitCount);
      }
    }
  } else {
    {
#line 848
    opj_image_destroy(image);
#line 849
    image = (opj_image_t *)((void *)0);
#line 850
    fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
            (int )Info_h.biBitCount);
    }
  }
  {
#line 854
  free((void *)pData);
#line 855
  fclose(IN);
  }
#line 856
  return (image);
}
}
#line 859 "/root/patron/new_24/src/bin/jp2/convertbmp.c"
int imagetobmp(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int pad ;
  FILE *fdest ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  OPJ_UINT8 rc ;
  OPJ_UINT8 gc ;
  OPJ_UINT8 bc ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  int r___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp29 ;

  {
#line 863
  fdest = (FILE *)((void *)0);
#line 866
  if ((image->comps + 0)->prec < 8U) {
    {
#line 867
    fprintf(stderr, "imagetobmp: Unsupported precision: %d\n", (image->comps + 0)->prec);
    }
#line 869
    return (1);
  }
#line 871
  if (image->numcomps >= 3U) {
#line 871
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 871
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 871
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 871
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 871
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 871
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 871
                if ((image->comps + 0)->sgnd == (image->comps + 1)->sgnd) {
#line 871
                  if ((image->comps + 1)->sgnd == (image->comps + 2)->sgnd) {
                    {
#line 884
                    fdest = fopen(outfile, "wbZ3 V");
                    }
#line 885
                    if (! fdest) {
                      {
#line 886
                      fprintf(stderr, "ERROR -> failed to open %s for writing\n",
                              outfile);
                      }
#line 887
                      return (1);
                    }
                    {
#line 890
                    w = (int )(image->comps + 0)->w;
#line 891
                    h = (int )(image->comps + 0)->h;
#line 893
                    fprintf(fdest, "BMZ3 V");
#line 897
                    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(((h * w) * 3 + (3 * h) * (w % 2)) + 54)) & 255,
                            (int )((OPJ_UINT8 )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 8)) & 255,
                            (int )((OPJ_UINT8 )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 16)) & 255,
                            (int )((OPJ_UINT8 )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 24)) & 255);
#line 902
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 904
                    fprintf(fdest, "%c%c%c%c\251", 54, (54 >> 8) & 255, (54 >> 16) & 255,
                            (54 >> 24) & 255);
#line 909
                    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255,
                            (40 >> 24) & 255);
#line 911
                    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(w & 255)),
                            (int )((OPJ_UINT8 )(w >> 8)) & 255, (int )((OPJ_UINT8 )(w >> 16)) & 255,
                            (int )((OPJ_UINT8 )(w >> 24)) & 255);
#line 915
                    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(h & 255)),
                            (int )((OPJ_UINT8 )(h >> 8)) & 255, (int )((OPJ_UINT8 )(h >> 16)) & 255,
                            (int )((OPJ_UINT8 )(h >> 24)) & 255);
#line 919
                    fprintf(fdest, "%c%c V", 1, (1 >> 8) & 255);
#line 920
                    fprintf(fdest, "%c%c", 24, (24 >> 8) & 255);
#line 921
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 923
                    fprintf(fdest, "%c%c%c%c\251", (int )((OPJ_UINT8 )((3 * h) * w + (3 * h) * (w % 2))) & 255,
                            (int )((OPJ_UINT8 )(((h * w) * 3 + (3 * h) * (w % 2)) >> 8)) & 255,
                            (int )((OPJ_UINT8 )(((h * w) * 3 + (3 * h) * (w % 2)) >> 16)) & 255,
                            (int )((OPJ_UINT8 )(((h * w) * 3 + (3 * h) * (w % 2)) >> 24)) & 255);
#line 927
                    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                            (7834 >> 24) & 255);
#line 929
                    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                            (7834 >> 24) & 255);
#line 931
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 933
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
                    }
#line 936
                    if ((image->comps + 0)->prec > 8U) {
                      {
#line 937
                      adjustR = (int )(image->comps + 0)->prec - 8;
#line 938
                      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n",
                             (image->comps + 0)->prec);
                      }
                    } else {
#line 941
                      adjustR = 0;
                    }
#line 943
                    if ((image->comps + 1)->prec > 8U) {
                      {
#line 944
                      adjustG = (int )(image->comps + 1)->prec - 8;
#line 945
                      printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n",
                             (image->comps + 1)->prec);
                      }
                    } else {
#line 948
                      adjustG = 0;
                    }
#line 950
                    if ((image->comps + 2)->prec > 8U) {
                      {
#line 951
                      adjustB = (int )(image->comps + 2)->prec - 8;
#line 952
                      printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n",
                             (image->comps + 2)->prec);
                      }
                    } else {
#line 955
                      adjustB = 0;
                    }
#line 958
                    i = 0;
                    {
#line 958
                    while (1) {
                      while_continue: /* CIL Label */ ;

#line 958
                      if (! (i < w * h)) {
#line 958
                        goto while_break;
                      }
#line 962
                      r = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 963
                      if ((image->comps + 0)->sgnd) {
#line 963
                        tmp = 1 << ((image->comps + 0)->prec - 1U);
                      } else {
#line 963
                        tmp = 0;
                      }
#line 963
                      r += tmp;
#line 964
                      if (adjustR > 0) {
#line 965
                        r = (r >> adjustR) + (r >> (adjustR - 1)) % 2;
                      }
#line 967
                      if (r > 255) {
#line 968
                        r = 255;
                      } else
#line 969
                      if (r < 0) {
#line 970
                        r = 0;
                      }
#line 972
                      rc = (OPJ_UINT8 )r;
#line 974
                      g = *((image->comps + 1)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 975
                      if ((image->comps + 1)->sgnd) {
#line 975
                        tmp___0 = 1 << ((image->comps + 1)->prec - 1U);
                      } else {
#line 975
                        tmp___0 = 0;
                      }
#line 975
                      g += tmp___0;
#line 976
                      if (adjustG > 0) {
#line 977
                        g = (g >> adjustG) + (g >> (adjustG - 1)) % 2;
                      }
#line 979
                      if (g > 255) {
#line 980
                        g = 255;
                      } else
#line 981
                      if (g < 0) {
#line 982
                        g = 0;
                      }
#line 984
                      gc = (OPJ_UINT8 )g;
#line 986
                      b = *((image->comps + 2)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 987
                      if ((image->comps + 2)->sgnd) {
#line 987
                        tmp___1 = 1 << ((image->comps + 2)->prec - 1U);
                      } else {
#line 987
                        tmp___1 = 0;
                      }
#line 987
                      b += tmp___1;
#line 988
                      if (adjustB > 0) {
#line 989
                        b = (b >> adjustB) + (b >> (adjustB - 1)) % 2;
                      }
#line 991
                      if (b > 255) {
#line 992
                        b = 255;
                      } else
#line 993
                      if (b < 0) {
#line 994
                        b = 0;
                      }
                      {
#line 996
                      bc = (OPJ_UINT8 )b;
#line 998
                      fprintf(fdest, "%c%c%c", (int )bc, (int )gc, (int )rc);
                      }
#line 1000
                      if ((i + 1) % w == 0) {
#line 1001
                        if ((3 * w) % 4) {
#line 1001
                          tmp___2 = 4 - (3 * w) % 4;
                        } else {
#line 1001
                          tmp___2 = 0;
                        }
#line 1001
                        pad = tmp___2;
                        {
#line 1001
                        while (1) {
                          while_continue___0: /* CIL Label */ ;

#line 1001
                          if (! (pad > 0)) {
#line 1001
                            goto while_break___0;
                          }
                          {
#line 1002
                          fprintf(fdest, "%c", 0);
#line 1001
                          __cil_tmp22 = pad;
#line 1001
                          pad --;
                          }
                        }
                        while_break___5: /* CIL Label */ ;
                        }
                        while_break___0: ;
                      }
#line 958
                      i ++;
                    }
                    while_break___4: /* CIL Label */ ;
                    }
                    while_break: 
                    {
#line 1006
                    fclose(fdest);
                    }
                  } else {
#line 871
                    goto _L;
                  }
                } else {
#line 871
                  goto _L;
                }
              } else {
#line 871
                goto _L;
              }
            } else {
#line 871
              goto _L;
            }
          } else {
#line 871
            goto _L;
          }
        } else {
#line 871
          goto _L;
        }
      } else {
#line 871
        goto _L;
      }
    } else {
#line 871
      goto _L;
    }
  } else {
    _L: 
    {
#line 1013
    fdest = fopen(outfile, "wb");
    }
#line 1014
    if (! fdest) {
      {
#line 1015
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
      }
#line 1016
      return (1);
    }
#line 1018
    if (image->numcomps > 1U) {
      {
#line 1019
      fprintf(stderr, "imagetobmp: only first component of %d is used.\n\230\001",
              image->numcomps);
      }
    }
    {
#line 1022
    w = (int )(image->comps + 0)->w;
#line 1023
    h = (int )(image->comps + 0)->h;
#line 1025
    fprintf(fdest, "BM");
#line 1029
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(((h * w + 54) + 1024) + h * (w % 2))) & 255,
            (int )((OPJ_UINT8 )((((h * w + 54) + 1024) + h * (w % 2)) >> 8)) & 255,
            (int )((OPJ_UINT8 )((((h * w + 54) + 1024) + h * (w % 2)) >> 16)) & 255,
            (int )((OPJ_UINT8 )((((h * w + 54) + 1024) + w * (w % 2)) >> 24)) & 255);
#line 1033
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1035
    fprintf(fdest, "%c%c%c%c\251", 54, (1078 >> 8) & 255, (1078 >> 16) & 255, (1078 >> 24) & 255);
#line 1041
    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255, (40 >> 24) & 255);
#line 1043
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(w & 255)), (int )((OPJ_UINT8 )(w >> 8)) & 255,
            (int )((OPJ_UINT8 )(w >> 16)) & 255, (int )((OPJ_UINT8 )(w >> 24)) & 255);
#line 1047
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(h & 255)), (int )((OPJ_UINT8 )(h >> 8)) & 255,
            (int )((OPJ_UINT8 )(h >> 16)) & 255, (int )((OPJ_UINT8 )(h >> 24)) & 255);
#line 1051
    fprintf(fdest, "%c%c", 1, (1 >> 8) & 255);
#line 1052
    fprintf(fdest, "%c%c", 8, (8 >> 8) & 255);
#line 1053
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1055
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(h * w + h * (w % 2))) & 255,
            (int )((OPJ_UINT8 )((h * w + h * (w % 2)) >> 8)) & 255, (int )((OPJ_UINT8 )((h * w + h * (w % 2)) >> 16)) & 255,
            (int )((OPJ_UINT8 )((h * w + h * (w % 2)) >> 24)) & 255);
#line 1059
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1061
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1063
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
#line 1065
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
    }
#line 1068
    if ((image->comps + 0)->prec > 8U) {
      {
#line 1069
      adjustR = (int )(image->comps + 0)->prec - 8;
#line 1070
      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", (image->comps + 0)->prec);
      }
    } else {
#line 1073
      adjustR = 0;
    }
#line 1076
    i = 0;
    {
#line 1076
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1076
      if (! (i < 256)) {
#line 1076
        goto while_break___1;
      }
      {
#line 1077
      fprintf(fdest, "%c%c%c%c\230\001", i, i, i, 0);
#line 1076
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
#line 1080
    i = 0;
    {
#line 1080
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1080
      if (! (i < w * h)) {
#line 1080
        goto while_break___2;
      }
#line 1083
      r___0 = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1084
      if ((image->comps + 0)->sgnd) {
#line 1084
        tmp___3 = 1 << ((image->comps + 0)->prec - 1U);
      } else {
#line 1084
        tmp___3 = 0;
      }
#line 1084
      r___0 += tmp___3;
#line 1085
      if (adjustR > 0) {
#line 1086
        r___0 = (r___0 >> adjustR) + (r___0 >> (adjustR - 1)) % 2;
      }
#line 1088
      if (r___0 > 255) {
#line 1089
        r___0 = 255;
      } else
#line 1090
      if (r___0 < 0) {
#line 1091
        r___0 = 0;
      }
      {
#line 1094
      fprintf(fdest, "%c", (int )((OPJ_UINT8 )r___0));
      }
#line 1096
      if ((i + 1) % w == 0) {
#line 1097
        if (w % 4) {
#line 1097
          tmp___4 = 4 - w % 4;
        } else {
#line 1097
          tmp___4 = 0;
        }
#line 1097
        pad = tmp___4;
        {
#line 1097
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1097
          if (! (pad > 0)) {
#line 1097
            goto while_break___3;
          }
          {
#line 1098
          fprintf(fdest, "%c", 0);
#line 1097
          __cil_tmp29 = pad;
#line 1097
          pad --;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: ;
      }
#line 1080
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 1102
    fclose(fdest);
    }
  }
#line 1105
  return (0);
}
}
#line 54 "/root/patron/new_24/src/bin/jp2/convert.c"
static int int_floorlog2(int a ) 
{ 
  int l ;

  {
#line 57
  l = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;

#line 57
    if (! (a > 1)) {
#line 57
      goto while_break;
    }
#line 58
    a >>= 1;
#line 57
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 60
  return (l);
}
}
#line 64 "/root/patron/new_24/src/bin/jp2/convert.c"
void clip_component(opj_image_comp_t *component , OPJ_UINT32 precision ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  OPJ_UINT32 umax ;
  OPJ_INT32 *l_data ;
  OPJ_INT32 max ;
  OPJ_INT32 min ;
  OPJ_UINT32 *l_data___0 ;

  {
#line 68
  umax = (OPJ_UINT32 )-1;
#line 70
  len = (OPJ_SIZE_T )component->w * (OPJ_SIZE_T )component->h;
#line 71
  if (precision < 32U) {
#line 72
    umax = (1U << precision) - 1U;
  }
#line 75
  if (component->sgnd) {
#line 76
    l_data = component->data;
#line 77
    max = (OPJ_INT32 )(umax / 2U);
#line 78
    min = - max - 1;
#line 79
    i = (OPJ_SIZE_T )0;
    {
#line 79
    while (1) {
      while_continue: /* CIL Label */ ;

#line 79
      if (! (i < len)) {
#line 79
        goto while_break;
      }
#line 80
      if (*(l_data + i) > max) {
#line 81
        *(l_data + i) = max;
      } else
#line 82
      if (*(l_data + i) < min) {
#line 83
        *(l_data + i) = min;
      }
#line 79
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 87
    l_data___0 = (OPJ_UINT32 *)component->data;
#line 88
    i = (OPJ_SIZE_T )0;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 88
      if (! (i < len)) {
#line 88
        goto while_break___0;
      }
#line 89
      if (*(l_data___0 + i) > umax) {
#line 90
        *(l_data___0 + i) = umax;
      }
#line 88
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 94
  component->prec = precision;
#line 95
  return;
}
}
#line 98 "/root/patron/new_24/src/bin/jp2/convert.c"
static void scale_component_up(opj_image_comp_t *component , OPJ_UINT32 precision ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  OPJ_INT64 newMax ;
  OPJ_INT64 oldMax ;
  OPJ_INT32 *l_data ;
  OPJ_UINT64 newMax___0 ;
  OPJ_UINT64 oldMax___0 ;
  OPJ_UINT32 *l_data___0 ;

  {
#line 103
  len = (OPJ_SIZE_T )component->w * (OPJ_SIZE_T )component->h;
#line 104
  if (component->sgnd) {
#line 105
    newMax = (OPJ_INT64 )(1U << (precision - 1U));
#line 106
    oldMax = (OPJ_INT64 )(1U << (component->prec - 1U));
#line 107
    l_data = component->data;
#line 108
    i = (OPJ_SIZE_T )0;
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;

#line 108
      if (! (i < len)) {
#line 108
        goto while_break;
      }
#line 109
      *(l_data + i) = (OPJ_INT32 )(((OPJ_INT64 )*(l_data + i) * newMax) / oldMax);
#line 108
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 112
    newMax___0 = (OPJ_UINT64 )((1U << precision) - 1U);
#line 113
    oldMax___0 = (OPJ_UINT64 )((1U << component->prec) - 1U);
#line 114
    l_data___0 = (OPJ_UINT32 *)component->data;
#line 115
    i = (OPJ_SIZE_T )0;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 115
      if (! (i < len)) {
#line 115
        goto while_break___0;
      }
#line 116
      *(l_data___0 + i) = (OPJ_UINT32 )(((OPJ_UINT64 )*(l_data___0 + i) * newMax___0) / oldMax___0);
#line 115
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 119
  component->prec = precision;
#line 120
  component->bpp = precision;
#line 121
  return;
}
}
#line 122 "/root/patron/new_24/src/bin/jp2/convert.c"
void scale_component(opj_image_comp_t *component , OPJ_UINT32 precision ) 
{ 
  int shift ;
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  OPJ_INT32 *l_data ;
  OPJ_UINT32 *l_data___0 ;

  {
#line 127
  if (component->prec == precision) {
#line 128
    return;
  }
#line 130
  if (component->prec < precision) {
    {
#line 131
    scale_component_up(component, precision);
    }
#line 132
    return;
  }
#line 134
  shift = (int )(component->prec - precision);
#line 135
  len = (OPJ_SIZE_T )component->w * (OPJ_SIZE_T )component->h;
#line 136
  if (component->sgnd) {
#line 137
    l_data = component->data;
#line 138
    i = (OPJ_SIZE_T )0;
    {
#line 138
    while (1) {
      while_continue: /* CIL Label */ ;

#line 138
      if (! (i < len)) {
#line 138
        goto while_break;
      }
#line 139
      *(l_data + i) >>= shift;
#line 138
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 142
    l_data___0 = (OPJ_UINT32 *)component->data;
#line 143
    i = (OPJ_SIZE_T )0;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 143
      if (! (i < len)) {
#line 143
        goto while_break___0;
      }
#line 144
      *(l_data___0 + i) >>= shift;
#line 143
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 147
  component->bpp = precision;
#line 148
  component->prec = precision;
#line 149
  return;
}
}
#line 154 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s_C1P1(OPJ_INT32 *pSrc , OPJ_INT32 * const  *pDst , OPJ_SIZE_T length ) 
{ 


  {
  {
#line 157
  memcpy((void *)*(pDst + 0), (void const   *)pSrc, length * sizeof(OPJ_INT32 ));
  }
#line 159
  return;
}
}
#line 159 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s_C2P2(OPJ_INT32 *pSrc , OPJ_INT32 * const  *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pDst0 ;
  OPJ_INT32 *pDst1 ;

  {
#line 163
  pDst0 = (OPJ_INT32 *)*(pDst + 0);
#line 164
  pDst1 = (OPJ_INT32 *)*(pDst + 1);
#line 166
  i = (OPJ_SIZE_T )0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;

#line 166
    if (! (i < length)) {
#line 166
      goto while_break;
    }
#line 167
    *(pDst0 + i) = *(pSrc + 2UL * i);
#line 168
    *(pDst1 + i) = *(pSrc + (2UL * i + 1UL));
#line 166
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 170
  return;
}
}
#line 171 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s_C3P3(OPJ_INT32 *pSrc , OPJ_INT32 * const  *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pDst0 ;
  OPJ_INT32 *pDst1 ;
  OPJ_INT32 *pDst2 ;

  {
#line 175
  pDst0 = (OPJ_INT32 *)*(pDst + 0);
#line 176
  pDst1 = (OPJ_INT32 *)*(pDst + 1);
#line 177
  pDst2 = (OPJ_INT32 *)*(pDst + 2);
#line 179
  i = (OPJ_SIZE_T )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;

#line 179
    if (! (i < length)) {
#line 179
      goto while_break;
    }
#line 180
    *(pDst0 + i) = *(pSrc + 3UL * i);
#line 181
    *(pDst1 + i) = *(pSrc + (3UL * i + 1UL));
#line 182
    *(pDst2 + i) = *(pSrc + (3UL * i + 2UL));
#line 179
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 183
  return;
}
}
#line 185 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s_C4P4(OPJ_INT32 *pSrc , OPJ_INT32 * const  *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pDst0 ;
  OPJ_INT32 *pDst1 ;
  OPJ_INT32 *pDst2 ;
  OPJ_INT32 *pDst3 ;

  {
#line 189
  pDst0 = (OPJ_INT32 *)*(pDst + 0);
#line 190
  pDst1 = (OPJ_INT32 *)*(pDst + 1);
#line 191
  pDst2 = (OPJ_INT32 *)*(pDst + 2);
#line 192
  pDst3 = (OPJ_INT32 *)*(pDst + 3);
#line 194
  i = (OPJ_SIZE_T )0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;

#line 194
    if (! (i < length)) {
#line 194
      goto while_break;
    }
#line 195
    *(pDst0 + i) = *(pSrc + 4UL * i);
#line 196
    *(pDst1 + i) = *(pSrc + (4UL * i + 1UL));
#line 197
    *(pDst2 + i) = *(pSrc + (4UL * i + 2UL));
#line 198
    *(pDst3 + i) = *(pSrc + (4UL * i + 3UL));
#line 194
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 198
  return;
}
}
#line 201 "/root/patron/new_24/src/bin/jp2/convert.c"
convert_32s_CXPX convert_32s_CXPX_LUT[5]  = {      (void (*)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  ))((void *)0),      & convert_32s_C1P1,      & convert_32s_C2P2,      & convert_32s_C3P3, 
        & convert_32s_C4P4};
#line 209 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s_P1C1(OPJ_INT32 * const  *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ,
                             OPJ_INT32 adjust ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pSrc0 ;

  {
#line 213
  pSrc0 = (OPJ_INT32 *)*(pSrc + 0);
#line 215
  i = (OPJ_SIZE_T )0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;

#line 215
    if (! (i < length)) {
#line 215
      goto while_break;
    }
#line 216
    *(pDst + i) = *(pSrc0 + i) + adjust;
#line 215
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 219
  return;
}
}
#line 219 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s_P2C2(OPJ_INT32 * const  *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ,
                             OPJ_INT32 adjust ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pSrc0 ;
  OPJ_INT32 *pSrc1 ;

  {
#line 223
  pSrc0 = (OPJ_INT32 *)*(pSrc + 0);
#line 224
  pSrc1 = (OPJ_INT32 *)*(pSrc + 1);
#line 226
  i = (OPJ_SIZE_T )0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;

#line 226
    if (! (i < length)) {
#line 226
      goto while_break;
    }
#line 227
    *(pDst + 2UL * i) = *(pSrc0 + i) + adjust;
#line 228
    *(pDst + (2UL * i + 1UL)) = *(pSrc1 + i) + adjust;
#line 226
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 230
  return;
}
}
#line 231 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s_P3C3(OPJ_INT32 * const  *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ,
                             OPJ_INT32 adjust ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pSrc0 ;
  OPJ_INT32 *pSrc1 ;
  OPJ_INT32 *pSrc2 ;

  {
#line 235
  pSrc0 = (OPJ_INT32 *)*(pSrc + 0);
#line 236
  pSrc1 = (OPJ_INT32 *)*(pSrc + 1);
#line 237
  pSrc2 = (OPJ_INT32 *)*(pSrc + 2);
#line 239
  i = (OPJ_SIZE_T )0;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;

#line 239
    if (! (i < length)) {
#line 239
      goto while_break;
    }
#line 240
    *(pDst + 3UL * i) = *(pSrc0 + i) + adjust;
#line 241
    *(pDst + (3UL * i + 1UL)) = *(pSrc1 + i) + adjust;
#line 242
    *(pDst + (3UL * i + 2UL)) = *(pSrc2 + i) + adjust;
#line 239
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 243
  return;
}
}
#line 245 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s_P4C4(OPJ_INT32 * const  *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ,
                             OPJ_INT32 adjust ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pSrc0 ;
  OPJ_INT32 *pSrc1 ;
  OPJ_INT32 *pSrc2 ;
  OPJ_INT32 *pSrc3 ;

  {
#line 249
  pSrc0 = (OPJ_INT32 *)*(pSrc + 0);
#line 250
  pSrc1 = (OPJ_INT32 *)*(pSrc + 1);
#line 251
  pSrc2 = (OPJ_INT32 *)*(pSrc + 2);
#line 252
  pSrc3 = (OPJ_INT32 *)*(pSrc + 3);
#line 254
  i = (OPJ_SIZE_T )0;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;

#line 254
    if (! (i < length)) {
#line 254
      goto while_break;
    }
#line 255
    *(pDst + 4UL * i) = *(pSrc0 + i) + adjust;
#line 256
    *(pDst + (4UL * i + 1UL)) = *(pSrc1 + i) + adjust;
#line 257
    *(pDst + (4UL * i + 2UL)) = *(pSrc2 + i) + adjust;
#line 258
    *(pDst + (4UL * i + 3UL)) = *(pSrc3 + i) + adjust;
#line 254
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 258
  return;
}
}
#line 261 "/root/patron/new_24/src/bin/jp2/convert.c"
convert_32s_PXCX convert_32s_PXCX_LUT[5]  = {      (void (*)(OPJ_INT32 * const  * , OPJ_INT32 * , OPJ_SIZE_T  , OPJ_INT32  ))((void *)0),      & convert_32s_P1C1,      & convert_32s_P2C2,      & convert_32s_P3C3, 
        & convert_32s_P4C4};
#line 271 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_1u32s_C1R(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val___0 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 275
  i = (OPJ_SIZE_T )0;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;

#line 275
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 275
      goto while_break;
    }
#line 276
    __cil_tmp6 = pSrc;
#line 276
    pSrc ++;
#line 276
    val = (OPJ_UINT32 )*__cil_tmp6;
#line 277
    *(pDst + i) = (OPJ_INT32 )(val >> 7);
#line 278
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((val >> 6) & 1U);
#line 279
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((val >> 5) & 1U);
#line 280
    *(pDst + (i + 3UL)) = (OPJ_INT32 )((val >> 4) & 1U);
#line 281
    *(pDst + (i + 4UL)) = (OPJ_INT32 )((val >> 3) & 1U);
#line 282
    *(pDst + (i + 5UL)) = (OPJ_INT32 )((val >> 2) & 1U);
#line 283
    *(pDst + (i + 6UL)) = (OPJ_INT32 )((val >> 1) & 1U);
#line 284
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(val & 1U);
#line 275
    i += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 286
  if (length & 7UL) {
#line 287
    __cil_tmp8 = pSrc;
#line 287
    pSrc ++;
#line 287
    val___0 = (OPJ_UINT32 )*__cil_tmp8;
#line 288
    length &= 7UL;
#line 289
    *(pDst + i) = (OPJ_INT32 )(val___0 >> 7);
#line 291
    if (length > 1UL) {
#line 292
      *(pDst + (i + 1UL)) = (OPJ_INT32 )((val___0 >> 6) & 1U);
#line 293
      if (length > 2UL) {
#line 294
        *(pDst + (i + 2UL)) = (OPJ_INT32 )((val___0 >> 5) & 1U);
#line 295
        if (length > 3UL) {
#line 296
          *(pDst + (i + 3UL)) = (OPJ_INT32 )((val___0 >> 4) & 1U);
#line 297
          if (length > 4UL) {
#line 298
            *(pDst + (i + 4UL)) = (OPJ_INT32 )((val___0 >> 3) & 1U);
#line 299
            if (length > 5UL) {
#line 300
              *(pDst + (i + 5UL)) = (OPJ_INT32 )((val___0 >> 2) & 1U);
#line 301
              if (length > 6UL) {
#line 302
                *(pDst + (i + 6UL)) = (OPJ_INT32 )((val___0 >> 1) & 1U);
              }
            }
          }
        }
      }
    }
  }
#line 310
  return;
}
}
#line 311 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_2u32s_C1R(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val___0 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 315
  i = (OPJ_SIZE_T )0;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;

#line 315
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 315
      goto while_break;
    }
#line 316
    __cil_tmp6 = pSrc;
#line 316
    pSrc ++;
#line 316
    val = (OPJ_UINT32 )*__cil_tmp6;
#line 317
    *(pDst + i) = (OPJ_INT32 )(val >> 6);
#line 318
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((val >> 4) & 3U);
#line 319
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((val >> 2) & 3U);
#line 320
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(val & 3U);
#line 315
    i += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 322
  if (length & 3UL) {
#line 323
    __cil_tmp8 = pSrc;
#line 323
    pSrc ++;
#line 323
    val___0 = (OPJ_UINT32 )*__cil_tmp8;
#line 324
    length &= 3UL;
#line 325
    *(pDst + i) = (OPJ_INT32 )(val___0 >> 6);
#line 327
    if (length > 1UL) {
#line 328
      *(pDst + (i + 1UL)) = (OPJ_INT32 )((val___0 >> 4) & 3U);
#line 329
      if (length > 2UL) {
#line 330
        *(pDst + (i + 2UL)) = (OPJ_INT32 )((val___0 >> 2) & 3U);
      }
    }
  }
#line 334
  return;
}
}
#line 336 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_4u32s_C1R(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT8 val___0 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 340
  i = (OPJ_SIZE_T )0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;

#line 340
    if (! (i < (length & 0xfffffffffffffffeUL))) {
#line 340
      goto while_break;
    }
#line 341
    __cil_tmp6 = pSrc;
#line 341
    pSrc ++;
#line 341
    val = (OPJ_UINT32 )*__cil_tmp6;
#line 342
    *(pDst + i) = (OPJ_INT32 )(val >> 4);
#line 343
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(val & 15U);
#line 340
    i += 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 345
  if (length & 1UL) {
#line 346
    __cil_tmp8 = pSrc;
#line 346
    pSrc ++;
#line 346
    val___0 = *__cil_tmp8;
#line 347
    *(pDst + i) = (int )val___0 >> 4;
  }
#line 349
  return;
}
}
#line 350 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_6u32s_C1R(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val0___0 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val1___0 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val2___0 ;
  OPJ_BYTE *__cil_tmp16 ;

  {
#line 354
  i = (OPJ_SIZE_T )0;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;

#line 354
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 354
      goto while_break;
    }
#line 355
    __cil_tmp6 = pSrc;
#line 355
    pSrc ++;
#line 355
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 356
    __cil_tmp8 = pSrc;
#line 356
    pSrc ++;
#line 356
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 357
    __cil_tmp10 = pSrc;
#line 357
    pSrc ++;
#line 357
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 358
    *(pDst + i) = (OPJ_INT32 )(val0 >> 2);
#line 359
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val0 & 3U) << 4) | (val1 >> 4));
#line 360
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val1 & 15U) << 2) | (val2 >> 6));
#line 361
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(val2 & 63U);
#line 354
    i += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 364
  if (length & 3UL) {
#line 365
    __cil_tmp12 = pSrc;
#line 365
    pSrc ++;
#line 365
    val0___0 = (OPJ_UINT32 )*__cil_tmp12;
#line 366
    length &= 3UL;
#line 367
    *(pDst + i) = (OPJ_INT32 )(val0___0 >> 2);
#line 369
    if (length > 1UL) {
#line 370
      __cil_tmp14 = pSrc;
#line 370
      pSrc ++;
#line 370
      val1___0 = (OPJ_UINT32 )*__cil_tmp14;
#line 371
      *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val0___0 & 3U) << 4) | (val1___0 >> 4));
#line 372
      if (length > 2UL) {
#line 373
        __cil_tmp16 = pSrc;
#line 373
        pSrc ++;
#line 373
        val2___0 = (OPJ_UINT32 )*__cil_tmp16;
#line 374
        *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val1___0 & 15U) << 2) | (val2___0 >> 6));
      }
    }
  }
#line 378
  return;
}
}
#line 379 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_8u32s_C1R(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;

  {
#line 383
  i = (OPJ_SIZE_T )0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;

#line 383
    if (! (i < length)) {
#line 383
      goto while_break;
    }
#line 384
    *(pDst + i) = (OPJ_INT32 )*(pSrc + i);
#line 383
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 387
  return;
}
}
#line 387 "/root/patron/new_24/src/bin/jp2/convert.c"
convert_XXx32s_C1R convert_XXu32s_C1R_LUT[9]  = 
#line 387
  {      (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0),      & convert_1u32s_C1R,      & convert_2u32s_C1R,      (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0), 
        & convert_4u32s_C1R,      (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0),      & convert_6u32s_C1R,      (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0), 
        & convert_8u32s_C1R};
#line 400 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s1u_C1R(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_UINT32 src0___0 ;
  OPJ_UINT32 src1___0 ;
  OPJ_UINT32 src2___0 ;
  OPJ_UINT32 src3___0 ;
  OPJ_UINT32 src4___0 ;
  OPJ_UINT32 src5___0 ;
  OPJ_UINT32 src6___0 ;
  OPJ_BYTE *__cil_tmp21 ;

  {
#line 404
  i = (OPJ_SIZE_T )0;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;

#line 404
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 404
      goto while_break;
    }
#line 405
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 406
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 407
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 408
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 409
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 410
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 411
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 412
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 414
    __cil_tmp13 = pDst;
#line 414
    pDst ++;
#line 414
    *__cil_tmp13 = (OPJ_BYTE )((((((((src0 << 7) | (src1 << 6)) | (src2 << 5)) | (src3 << 4)) | (src4 << 3)) | (src5 << 2)) | (src6 << 1)) | src7);
#line 404
    i += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 418
  if (length & 7UL) {
#line 419
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 420
    src1___0 = 0U;
#line 421
    src2___0 = 0U;
#line 422
    src3___0 = 0U;
#line 423
    src4___0 = 0U;
#line 424
    src5___0 = 0U;
#line 425
    src6___0 = 0U;
#line 426
    length &= 7UL;
#line 428
    if (length > 1UL) {
#line 429
      src1___0 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 430
      if (length > 2UL) {
#line 431
        src2___0 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 432
        if (length > 3UL) {
#line 433
          src3___0 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 434
          if (length > 4UL) {
#line 435
            src4___0 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 436
            if (length > 5UL) {
#line 437
              src5___0 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 438
              if (length > 6UL) {
#line 439
                src6___0 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
              }
            }
          }
        }
      }
    }
#line 446
    __cil_tmp21 = pDst;
#line 446
    pDst ++;
#line 446
    *__cil_tmp21 = (OPJ_BYTE )(((((((src0___0 << 7) | (src1___0 << 6)) | (src2___0 << 5)) | (src3___0 << 4)) | (src4___0 << 3)) | (src5___0 << 2)) | (src6___0 << 1));
  }
#line 448
  return;
}
}
#line 451 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s2u_C1R(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_BYTE *__cil_tmp9 ;
  OPJ_UINT32 src0___0 ;
  OPJ_UINT32 src1___0 ;
  OPJ_UINT32 src2___0 ;
  OPJ_BYTE *__cil_tmp13 ;

  {
#line 455
  i = (OPJ_SIZE_T )0;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;

#line 455
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 455
      goto while_break;
    }
#line 456
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 457
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 458
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 459
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 461
    __cil_tmp9 = pDst;
#line 461
    pDst ++;
#line 461
    *__cil_tmp9 = (OPJ_BYTE )((((src0 << 6) | (src1 << 4)) | (src2 << 2)) | src3);
#line 455
    i += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 464
  if (length & 3UL) {
#line 465
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 466
    src1___0 = 0U;
#line 467
    src2___0 = 0U;
#line 468
    length &= 3UL;
#line 470
    if (length > 1UL) {
#line 471
      src1___0 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 472
      if (length > 2UL) {
#line 473
        src2___0 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
      }
    }
#line 476
    __cil_tmp13 = pDst;
#line 476
    pDst ++;
#line 476
    *__cil_tmp13 = (OPJ_BYTE )(((src0___0 << 6) | (src1___0 << 4)) | (src2___0 << 2));
  }
#line 478
  return;
}
}
#line 480 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s4u_C1R(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_UINT32 src0___0 ;
  OPJ_BYTE *__cil_tmp9 ;

  {
#line 484
  i = (OPJ_SIZE_T )0;
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;

#line 484
    if (! (i < (length & 0xfffffffffffffffeUL))) {
#line 484
      goto while_break;
    }
#line 485
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 486
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 488
    __cil_tmp7 = pDst;
#line 488
    pDst ++;
#line 488
    *__cil_tmp7 = (OPJ_BYTE )((src0 << 4) | src1);
#line 484
    i += 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 491
  if (length & 1UL) {
#line 492
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 493
    __cil_tmp9 = pDst;
#line 493
    pDst ++;
#line 493
    *__cil_tmp9 = (OPJ_BYTE )(src0___0 << 4);
  }
#line 495
  return;
}
}
#line 497 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s6u_C1R(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_BYTE *__cil_tmp9 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_BYTE *__cil_tmp11 ;
  OPJ_UINT32 src0___0 ;
  OPJ_UINT32 src1___0 ;
  OPJ_UINT32 src2___0 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;

  {
#line 501
  i = (OPJ_SIZE_T )0;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;

#line 501
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 501
      goto while_break;
    }
#line 502
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 503
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 504
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 505
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 507
    __cil_tmp9 = pDst;
#line 507
    pDst ++;
#line 507
    *__cil_tmp9 = (OPJ_BYTE )((src0 << 2) | (src1 >> 4));
#line 508
    __cil_tmp10 = pDst;
#line 508
    pDst ++;
#line 508
    *__cil_tmp10 = (OPJ_BYTE )(((src1 & 15U) << 4) | (src2 >> 2));
#line 509
    __cil_tmp11 = pDst;
#line 509
    pDst ++;
#line 509
    *__cil_tmp11 = (OPJ_BYTE )(((src2 & 3U) << 6) | src3);
#line 501
    i += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 512
  if (length & 3UL) {
#line 513
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 514
    src1___0 = 0U;
#line 515
    src2___0 = 0U;
#line 516
    length &= 3UL;
#line 518
    if (length > 1UL) {
#line 519
      src1___0 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 520
      if (length > 2UL) {
#line 521
        src2___0 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
      }
    }
#line 524
    __cil_tmp15 = pDst;
#line 524
    pDst ++;
#line 524
    *__cil_tmp15 = (OPJ_BYTE )((src0___0 << 2) | (src1___0 >> 4));
#line 525
    if (length > 1UL) {
#line 526
      __cil_tmp16 = pDst;
#line 526
      pDst ++;
#line 526
      *__cil_tmp16 = (OPJ_BYTE )(((src1___0 & 15U) << 4) | (src2___0 >> 2));
#line 527
      if (length > 2UL) {
#line 528
        __cil_tmp17 = pDst;
#line 528
        pDst ++;
#line 528
        *__cil_tmp17 = (OPJ_BYTE )((src2___0 & 3U) << 6);
      }
    }
  }
#line 532
  return;
}
}
#line 533 "/root/patron/new_24/src/bin/jp2/convert.c"
static void convert_32s8u_C1R(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;

  {
#line 537
  i = (OPJ_SIZE_T )0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;

#line 537
    if (! (i < length)) {
#line 537
      goto while_break;
    }
#line 538
    *(pDst + i) = (OPJ_BYTE )*(pSrc + i);
#line 537
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 541
  return;
}
}
#line 541 "/root/patron/new_24/src/bin/jp2/convert.c"
convert_32sXXx_C1R convert_32sXXu_C1R_LUT[9]  = 
#line 541
  {      (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0),      & convert_32s1u_C1R,      & convert_32s2u_C1R,      (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0), 
        & convert_32s4u_C1R,      (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0),      & convert_32s6u_C1R,      (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0), 
        & convert_32s8u_C1R};
#line 584 "/root/patron/new_24/src/bin/jp2/convert.c"
static unsigned short get_tga_ushort(unsigned char const   *data ) 
{ 


  {
#line 586
  return ((unsigned short )((int )*(data + 0) | ((int )*(data + 1) << 8)));
}
}
#line 591 "/root/patron/new_24/src/bin/jp2/convert.c"
static int tga_readheader(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width ,
                          unsigned int *height , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char tga[18] ;
  unsigned char id_len ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned long __cil_tmp16 ;
  unsigned char *id ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;

  {
#line 601
  if (! bits_per_pixel) {
#line 602
    return (0);
  } else
#line 601
  if (! width) {
#line 602
    return (0);
  } else
#line 601
  if (! height) {
#line 602
    return (0);
  } else
#line 601
  if (! flip_image) {
#line 602
    return (0);
  }
  {
#line 605
  __cil_tmp16 = fread((void *)(tga), 18UL, 1UL, fp);
  }
#line 605
  if (__cil_tmp16 != 1UL) {
    {
#line 606
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 608
    return (0);
  }
  {
#line 610
  id_len = tga[0];
#line 612
  image_type = tga[2];
#line 614
  cmap_len = get_tga_ushort((unsigned char const   *)(& tga[5]));
#line 615
  cmap_entry_size = (unsigned short )tga[7];
#line 622
  image_w = get_tga_ushort((unsigned char const   *)(& tga[12]));
#line 623
  image_h = get_tga_ushort((unsigned char const   *)(& tga[14]));
#line 624
  pixel_depth = tga[16];
#line 625
  image_desc = tga[17];
#line 627
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 628
  *width = (unsigned int )image_w;
#line 629
  *height = (unsigned int )image_h;
  }
#line 632
  if (id_len) {
    {
#line 633
    __cil_tmp21 = malloc((unsigned long )id_len);
#line 633
    id = (unsigned char *)__cil_tmp21;
    }
#line 634
    if ((unsigned long )id == (unsigned long )((unsigned char *)0)) {
      {
#line 635
      fprintf(stderr, "tga_readheader: memory out\n");
      }
#line 636
      return (0);
    }
    {
#line 638
    __cil_tmp22 = fread((void *)id, (unsigned long )id_len, 1UL, fp);
    }
#line 638
    if (! __cil_tmp22) {
      {
#line 639
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 641
      free((void *)id);
      }
#line 642
      return (0);
    }
    {
#line 644
    free((void *)id);
    }
  }
#line 650
  if ((int )image_type > 8) {
    {
#line 651
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 652
    return (0);
  }
#line 655
  *flip_image = ! ((int )image_desc & 32);
#line 658
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 660
  if (palette_size > 0) {
    {
#line 661
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 662
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 664
  return (1);
}
}
#line 676 "/root/patron/new_24/src/bin/jp2/convert.c"
static int tga_writeheader(FILE *fp , int bits_per_pixel , int width , int height ,
                           OPJ_BOOL flip_image ) 
{ 
  OPJ_UINT16 image_w ;
  OPJ_UINT16 image_h ;
  OPJ_UINT16 us0 ;
  unsigned char uc0 ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;

  {
#line 683
  if (! bits_per_pixel) {
#line 684
    return (0);
  } else
#line 683
  if (! width) {
#line 684
    return (0);
  } else
#line 683
  if (! height) {
#line 684
    return (0);
  }
#line 687
  pixel_depth = (unsigned char)0;
#line 689
  if (bits_per_pixel < 256) {
#line 690
    pixel_depth = (unsigned char )bits_per_pixel;
  } else {
    {
#line 692
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_headerV");
    }
#line 693
    return (0);
  }
  {
#line 695
  uc0 = (unsigned char)0;
#line 697
  __cil_tmp13 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp);
  }
#line 697
  if (__cil_tmp13 != 1UL) {
#line 698
    goto fails;
  }
  {
#line 700
  __cil_tmp14 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp);
  }
#line 700
  if (__cil_tmp14 != 1UL) {
#line 701
    goto fails;
  }
  {
#line 704
  image_type = (unsigned char)2;
#line 705
  __cil_tmp15 = fwrite((void const   *)(& image_type), 1UL, 1UL, fp);
  }
#line 705
  if (__cil_tmp15 != 1UL) {
#line 706
    goto fails;
  }
  {
#line 709
  us0 = (OPJ_UINT16 )0;
#line 710
  __cil_tmp16 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 710
  if (__cil_tmp16 != 1UL) {
#line 711
    goto fails;
  }
  {
#line 713
  __cil_tmp17 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 713
  if (__cil_tmp17 != 1UL) {
#line 714
    goto fails;
  }
  {
#line 716
  __cil_tmp18 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp);
  }
#line 716
  if (__cil_tmp18 != 1UL) {
#line 717
    goto fails;
  }
  {
#line 720
  __cil_tmp19 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 720
  if (__cil_tmp19 != 1UL) {
#line 721
    goto fails;
  }
  {
#line 723
  __cil_tmp20 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 723
  if (__cil_tmp20 != 1UL) {
#line 724
    goto fails;
  }
  {
#line 727
  image_w = (unsigned short )width;
#line 728
  image_h = (unsigned short )height;
#line 731
  __cil_tmp21 = fwrite((void const   *)(& image_w), 2UL, 1UL, fp);
  }
#line 731
  if (__cil_tmp21 != 1UL) {
#line 732
    goto fails;
  }
  {
#line 734
  __cil_tmp22 = fwrite((void const   *)(& image_h), 2UL, 1UL, fp);
  }
#line 734
  if (__cil_tmp22 != 1UL) {
#line 735
    goto fails;
  }
  {
#line 748
  __cil_tmp23 = fwrite((void const   *)(& pixel_depth), 1UL, 1UL, fp);
  }
#line 748
  if (__cil_tmp23 != 1UL) {
#line 749
    goto fails;
  }
#line 752
  image_desc = (unsigned char)8;
#line 754
  if (flip_image) {
#line 755
    image_desc = (unsigned char )((int )image_desc | 32);
  }
  {
#line 757
  __cil_tmp24 = fwrite((void const   *)(& image_desc), 1UL, 1UL, fp);
  }
#line 757
  if (__cil_tmp24 != 1UL) {
#line 758
    goto fails;
  }
#line 761
  return (1);
  fails: 
  {
#line 764
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 765
  return (0);
}
}
#line 768 "/root/patron/new_24/src/bin/jp2/convert.c"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  opj_image_t *image ;
  unsigned int image_width ;
  unsigned int image_height ;
  unsigned int pixel_bit_depth ;
  unsigned int x ;
  unsigned int y ;
  int flip_image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int numcomps ;
  OPJ_COLOR_SPACE color_space ;
  OPJ_BOOL mono ;
  OPJ_BOOL save_alpha ;
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  int __cil_tmp20 ;
  int tmp ;
  int tmp___0 ;
  char ch ;
  OPJ_UINT64 expected_file_size ;
  long curpos ;
  long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  OPJ_UINT32 tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  int index___0 ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  unsigned char r___0 ;
  unsigned char g___0 ;
  unsigned char b___0 ;
  unsigned char a ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 774
  flip_image = 0;
#line 783
  f = fopen(filename, "rb");
  }
#line 784
  if (! f) {
    {
#line 785
    fprintf(stderr, "Failed to open %s for reading !!\nil3 V", filename);
    }
#line 786
    return ((opj_image_t *)0);
  }
  {
#line 789
  __cil_tmp20 = tga_readheader(f, & pixel_bit_depth, & image_width, & image_height,
                               & flip_image);
  }
#line 789
  if (! __cil_tmp20) {
    {
#line 791
    fclose(f);
    }
#line 792
    return ((opj_image_t *)((void *)0));
  }
#line 796
  if (! (pixel_bit_depth == 24U)) {
#line 796
    if (! (pixel_bit_depth == 32U)) {
      {
#line 797
      fclose(f);
      }
#line 798
      return ((opj_image_t *)((void *)0));
    }
  }
  {
#line 802
  memset((void *)(& cmptparm[0]), 0, 4UL * sizeof(opj_image_cmptparm_t ));
  }
#line 804
  if (pixel_bit_depth == 8U) {
#line 804
    tmp___3 = 1;
  } else
#line 804
  if (pixel_bit_depth == 16U) {
#line 804
    tmp___3 = 1;
  } else {
#line 804
    tmp___3 = 0;
  }
#line 804
  mono = tmp___3;
#line 806
  if (pixel_bit_depth == 16U) {
#line 806
    tmp___4 = 1;
  } else
#line 806
  if (pixel_bit_depth == 32U) {
#line 806
    tmp___4 = 1;
  } else {
#line 806
    tmp___4 = 0;
  }
#line 806
  save_alpha = tmp___4;
#line 809
  if (mono) {
#line 810
    color_space = (OPJ_COLOR_SPACE )2;
#line 811
    if (save_alpha) {
#line 811
      tmp = 2;
    } else {
#line 811
      tmp = 1;
    }
#line 811
    numcomps = tmp;
  } else {
#line 813
    if (save_alpha) {
#line 813
      tmp___0 = 4;
    } else {
#line 813
      tmp___0 = 3;
    }
#line 813
    numcomps = tmp___0;
#line 814
    color_space = (OPJ_COLOR_SPACE )1;
  }
#line 819
  if (image_height != 0U) {
#line 819
    if (image_width > (10000000U / image_height) / (OPJ_UINT32 )numcomps) {
      {
#line 822
      expected_file_size = ((OPJ_UINT64 )image_width * (unsigned long )image_height) * (unsigned long )((OPJ_UINT32 )numcomps);
#line 824
      __cil_tmp26 = ftell(f);
#line 824
      curpos = __cil_tmp26;
      }
#line 825
      if (expected_file_size > 2147483647UL) {
#line 826
        expected_file_size = (OPJ_UINT64 )2147483647;
      }
      {
#line 828
      fseek(f, (long )expected_file_size - 1L, 0);
#line 829
      __cil_tmp27 = fread((void *)(& ch), 1UL, 1UL, f);
      }
#line 829
      if (__cil_tmp27 != 1UL) {
        {
#line 830
        fclose(f);
        }
#line 831
        return ((opj_image_t *)((void *)0));
      }
      {
#line 833
      fseek(f, curpos, 0);
      }
    }
  }
#line 836
  subsampling_dx = parameters->subsampling_dx;
#line 837
  subsampling_dy = parameters->subsampling_dy;
#line 839
  i = 0;
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;

#line 839
    if (! (i < numcomps)) {
#line 839
      goto while_break;
    }
#line 840
    cmptparm[i].prec = (OPJ_UINT32 )8;
#line 841
    cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 842
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 843
    cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 844
    cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 845
    cmptparm[i].w = image_width;
#line 846
    cmptparm[i].h = image_height;
#line 839
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 850
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 852
  if (! image) {
    {
#line 853
    fclose(f);
    }
#line 854
    return ((opj_image_t *)((void *)0));
  }
#line 859
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 860
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 861
  if (! image->x0) {
#line 861
    tmp___1 = (image_width - 1U) * (OPJ_UINT32 )subsampling_dx + 1U;
  } else {
#line 861
    tmp___1 = (image->x0 + (image_width - 1U) * (OPJ_UINT32 )subsampling_dx) + 1U;
  }
#line 861
  image->x1 = tmp___1;
#line 864
  if (! image->y0) {
#line 864
    tmp___2 = (image_height - 1U) * (OPJ_UINT32 )subsampling_dy + 1U;
  } else {
#line 864
    tmp___2 = (image->y0 + (image_height - 1U) * (OPJ_UINT32 )subsampling_dy) + 1U;
  }
#line 864
  image->y1 = tmp___2;
#line 869
  y = 0U;
  {
#line 869
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 869
    if (! (y < image_height)) {
#line 869
      goto while_break___0;
    }
#line 872
    if (flip_image) {
#line 873
      index___0 = (int )(((image_height - y) - 1U) * image_width);
    } else {
#line 875
      index___0 = (int )(y * image_width);
    }
#line 878
    if (numcomps == 3) {
#line 879
      x = 0U;
      {
#line 879
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 879
        if (! (x < image_width)) {
#line 879
          goto while_break___1;
        }
        {
#line 882
        __cil_tmp36 = fread((void *)(& b), 1UL, 1UL, f);
        }
#line 882
        if (! __cil_tmp36) {
          {
#line 883
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 885
          opj_image_destroy(image);
#line 886
          fclose(f);
          }
#line 887
          return ((opj_image_t *)((void *)0));
        }
        {
#line 889
        __cil_tmp37 = fread((void *)(& g), 1UL, 1UL, f);
        }
#line 889
        if (! __cil_tmp37) {
          {
#line 890
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 892
          opj_image_destroy(image);
#line 893
          fclose(f);
          }
#line 894
          return ((opj_image_t *)((void *)0));
        }
        {
#line 896
        __cil_tmp38 = fread((void *)(& r), 1UL, 1UL, f);
        }
#line 896
        if (! __cil_tmp38) {
          {
#line 897
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 899
          opj_image_destroy(image);
#line 900
          fclose(f);
          }
#line 901
          return ((opj_image_t *)((void *)0));
        }
#line 904
        *((image->comps + 0)->data + index___0) = (OPJ_INT32 )r;
#line 905
        *((image->comps + 1)->data + index___0) = (OPJ_INT32 )g;
#line 906
        *((image->comps + 2)->data + index___0) = (OPJ_INT32 )b;
#line 907
        index___0 ++;
#line 879
        x ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: ;
    } else
#line 909
    if (numcomps == 4) {
#line 910
      x = 0U;
      {
#line 910
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 910
        if (! (x < image_width)) {
#line 910
          goto while_break___2;
        }
        {
#line 912
        __cil_tmp45 = fread((void *)(& b___0), 1UL, 1UL, f);
        }
#line 912
        if (! __cil_tmp45) {
          {
#line 913
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 915
          opj_image_destroy(image);
#line 916
          fclose(f);
          }
#line 917
          return ((opj_image_t *)((void *)0));
        }
        {
#line 919
        __cil_tmp46 = fread((void *)(& g___0), 1UL, 1UL, f);
        }
#line 919
        if (! __cil_tmp46) {
          {
#line 920
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 922
          opj_image_destroy(image);
#line 923
          fclose(f);
          }
#line 924
          return ((opj_image_t *)((void *)0));
        }
        {
#line 926
        __cil_tmp47 = fread((void *)(& r___0), 1UL, 1UL, f);
        }
#line 926
        if (! __cil_tmp47) {
          {
#line 927
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 929
          opj_image_destroy(image);
#line 930
          fclose(f);
          }
#line 931
          return ((opj_image_t *)((void *)0));
        }
        {
#line 933
        __cil_tmp48 = fread((void *)(& a), 1UL, 1UL, f);
        }
#line 933
        if (! __cil_tmp48) {
          {
#line 934
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 936
          opj_image_destroy(image);
#line 937
          fclose(f);
          }
#line 938
          return ((opj_image_t *)((void *)0));
        }
#line 941
        *((image->comps + 0)->data + index___0) = (OPJ_INT32 )r___0;
#line 942
        *((image->comps + 1)->data + index___0) = (OPJ_INT32 )g___0;
#line 943
        *((image->comps + 2)->data + index___0) = (OPJ_INT32 )b___0;
#line 944
        *((image->comps + 3)->data + index___0) = (OPJ_INT32 )a;
#line 945
        index___0 ++;
#line 910
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: ;
    } else {
      {
#line 948
      fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
      }
    }
#line 869
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 951
  fclose(f);
  }
#line 952
  return (image);
}
}
#line 955 "/root/patron/new_24/src/bin/jp2/convert.c"
int imagetotga(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int bpp ;
  int x ;
  int y ;
  OPJ_BOOL write_alpha ;
  unsigned int i ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int fails ;
  unsigned int alpha_channel ;
  float r ;
  float g ;
  float b ;
  float a ;
  unsigned char value ;
  float scale ;
  FILE *fdest ;
  size_t res ;
  int tmp ;
  int __cil_tmp26 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int index___0 ;
  int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  int tmp___3 ;

  {
  {
#line 960
  adjustG = 0;
#line 960
  adjustB = 0;
#line 967
  fails = 1;
#line 969
  fdest = fopen(outfile, "wbm3 V");
  }
#line 970
  if (! fdest) {
    {
#line 971
    fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
    }
#line 972
    return (1);
  }
#line 975
  i = 0U;
  {
#line 975
  while (1) {
    while_continue: /* CIL Label */ ;

#line 975
    if (! (i < image->numcomps - 1U)) {
#line 975
      goto while_break;
    }
#line 976
    if ((image->comps + 0)->dx != (image->comps + (i + 1U))->dx) {
      {
#line 980
      fclose(fdest);
#line 981
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
#line 983
      return (1);
    } else
#line 976
    if ((image->comps + 0)->dy != (image->comps + (i + 1U))->dy) {
      {
#line 980
      fclose(fdest);
#line 981
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
#line 983
      return (1);
    } else
#line 976
    if ((image->comps + 0)->prec != (image->comps + (i + 1U))->prec) {
      {
#line 980
      fclose(fdest);
#line 981
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
#line 983
      return (1);
    } else
#line 976
    if ((image->comps + 0)->sgnd != (image->comps + (i + 1U))->sgnd) {
      {
#line 980
      fclose(fdest);
#line 981
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
#line 983
      return (1);
    }
#line 975
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 987
  width = (int )(image->comps + 0)->w;
#line 988
  height = (int )(image->comps + 0)->h;
#line 991
  if (image->numcomps == 2U) {
#line 991
    tmp___3 = 1;
  } else
#line 991
  if (image->numcomps == 4U) {
#line 991
    tmp___3 = 1;
  } else {
#line 991
    tmp___3 = 0;
  }
#line 991
  write_alpha = tmp___3;
#line 994
  if (write_alpha) {
#line 994
    tmp = 32;
  } else {
#line 994
    tmp = 24;
  }
  {
#line 994
  bpp = tmp;
#line 996
  __cil_tmp26 = tga_writeheader(fdest, bpp, width, height, 1);
  }
#line 996
  if (! __cil_tmp26) {
#line 997
    goto fin;
  }
#line 1000
  alpha_channel = image->numcomps - 1U;
#line 1002
  scale = 255.f / (float )((1 << (image->comps + 0)->prec) - 1);
#line 1004
  if ((image->comps + 0)->sgnd) {
#line 1004
    tmp___0 = 1 << ((image->comps + 0)->prec - 1U);
  } else {
#line 1004
    tmp___0 = 0;
  }
#line 1004
  adjustR = tmp___0;
#line 1005
  if (image->numcomps >= 3U) {
#line 1006
    if ((image->comps + 1)->sgnd) {
#line 1006
      tmp___1 = 1 << ((image->comps + 1)->prec - 1U);
    } else {
#line 1006
      tmp___1 = 0;
    }
#line 1006
    adjustG = tmp___1;
#line 1007
    if ((image->comps + 2)->sgnd) {
#line 1007
      tmp___2 = 1 << ((image->comps + 2)->prec - 1U);
    } else {
#line 1007
      tmp___2 = 0;
    }
#line 1007
    adjustB = tmp___2;
  }
#line 1010
  y = 0;
  {
#line 1010
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1010
    if (! (y < height)) {
#line 1010
      goto while_break___0;
    }
#line 1011
    index___0 = (unsigned int )(y * width);
#line 1013
    x = 0;
    {
#line 1013
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1013
      if (! (x < width)) {
#line 1013
        goto while_break___1;
      }
#line 1014
      r = (float )(*((image->comps + 0)->data + index___0) + adjustR);
#line 1016
      if (image->numcomps > 2U) {
#line 1017
        g = (float )(*((image->comps + 1)->data + index___0) + adjustG);
#line 1018
        b = (float )(*((image->comps + 2)->data + index___0) + adjustB);
      } else {
#line 1021
        g = r;
#line 1022
        b = r;
      }
#line 1026
      if ((double )b > 255.) {
#line 1027
        b = (float )255.;
      } else
#line 1028
      if ((double )b < 0.) {
#line 1029
        b = (float )0.;
      }
      {
#line 1031
      value = (unsigned char )(b * scale);
#line 1032
      res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
      }
#line 1034
      if (res < 1UL) {
        {
#line 1035
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 1036
        goto fin;
      }
#line 1038
      if ((double )g > 255.) {
#line 1039
        g = (float )255.;
      } else
#line 1040
      if ((double )g < 0.) {
#line 1041
        g = (float )0.;
      }
      {
#line 1043
      value = (unsigned char )(g * scale);
#line 1044
      res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
      }
#line 1046
      if (res < 1UL) {
        {
#line 1047
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 1048
        goto fin;
      }
#line 1050
      if ((double )r > 255.) {
#line 1051
        r = (float )255.;
      } else
#line 1052
      if ((double )r < 0.) {
#line 1053
        r = (float )0.;
      }
      {
#line 1055
      value = (unsigned char )(r * scale);
#line 1056
      res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
      }
#line 1058
      if (res < 1UL) {
        {
#line 1059
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 1060
        goto fin;
      }
#line 1063
      if (write_alpha) {
#line 1064
        a = (float )*((image->comps + alpha_channel)->data + index___0);
#line 1065
        if ((double )a > 255.) {
#line 1066
          a = (float )255.;
        } else
#line 1067
        if ((double )a < 0.) {
#line 1068
          a = (float )0.;
        }
        {
#line 1070
        value = (unsigned char )(a * scale);
#line 1071
        res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
        }
#line 1073
        if (res < 1UL) {
          {
#line 1074
          fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
          }
#line 1075
          goto fin;
        }
      }
#line 1013
      __cil_tmp36 = index___0;
#line 1013
      index___0 ++;
#line 1013
      __cil_tmp35 = x;
#line 1013
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 1010
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 1080
  fails = 0;
  fin: 
  {
#line 1082
  fclose(fdest);
  }
#line 1084
  return (fails);
}
}
#line 1094 "/root/patron/new_24/src/bin/jp2/convert.c"
static unsigned char readuchar(FILE *f ) 
{ 
  unsigned char c1 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 1097
  __cil_tmp3 = fread((void *)(& c1), 1UL, 1UL, f);
  }
#line 1097
  if (! __cil_tmp3) {
    {
#line 1098
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1100
    return ((unsigned char)0);
  }
#line 1102
  return (c1);
}
}
#line 1105 "/root/patron/new_24/src/bin/jp2/convert.c"
static unsigned short readushort(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1108
  __cil_tmp5 = fread((void *)(& c1), 1UL, 1UL, f);
  }
#line 1108
  if (! __cil_tmp5) {
    {
#line 1109
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1111
    return ((unsigned short)0);
  }
  {
#line 1113
  __cil_tmp6 = fread((void *)(& c2), 1UL, 1UL, f);
  }
#line 1113
  if (! __cil_tmp6) {
    {
#line 1114
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1116
    return ((unsigned short)0);
  }
#line 1118
  if (bigendian) {
#line 1119
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 1121
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 1125 "/root/patron/new_24/src/bin/jp2/convert.c"
static unsigned int readuint(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 1128
  __cil_tmp7 = fread((void *)(& c1), 1UL, 1UL, f);
  }
#line 1128
  if (! __cil_tmp7) {
    {
#line 1129
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1131
    return (0U);
  }
  {
#line 1133
  __cil_tmp8 = fread((void *)(& c2), 1UL, 1UL, f);
  }
#line 1133
  if (! __cil_tmp8) {
    {
#line 1134
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1136
    return (0U);
  }
  {
#line 1138
  __cil_tmp9 = fread((void *)(& c3), 1UL, 1UL, f);
  }
#line 1138
  if (! __cil_tmp9) {
    {
#line 1139
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1141
    return (0U);
  }
  {
#line 1143
  __cil_tmp10 = fread((void *)(& c4), 1UL, 1UL, f);
  }
#line 1143
  if (! __cil_tmp10) {
    {
#line 1144
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1146
    return (0U);
  }
#line 1148
  if (bigendian) {
#line 1149
    return ((((unsigned int )((int )c1 << 24) + (unsigned int )((int )c2 << 16)) + (unsigned int )((int )c3 << 8)) + (unsigned int )c4);
  } else {
#line 1152
    return ((((unsigned int )((int )c4 << 24) + (unsigned int )((int )c3 << 16)) + (unsigned int )((int )c2 << 8)) + (unsigned int )c1);
  }
}
}
#line 1157 "/root/patron/new_24/src/bin/jp2/convert.c"
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  int w ;
  int h ;
  int prec ;
  int i ;
  int numcomps ;
  int max ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm ;
  opj_image_t *image ;
  int adjustS ;
  int ushift ;
  int dshift ;
  int force8 ;
  OPJ_UINT64 expected_file_size ;
  char endian1 ;
  char endian2 ;
  char sign ;
  char signtmp[32] ;
  char temp[32] ;
  int bigendian ;
  opj_image_comp_t *comp ;
  int __cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  char ch ;
  long curpos ;
  long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  OPJ_UINT32 tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  int v ;
  unsigned char __cil_tmp38 ;
  unsigned char __cil_tmp39 ;
  unsigned char __cil_tmp40 ;
  unsigned short __cil_tmp41 ;
  unsigned short __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  int __cil_tmp46 ;

  {
  {
#line 1159
  f = (FILE *)((void *)0);
#line 1164
  image = (opj_image_t *)((void *)0);
#line 1173
  comp = (opj_image_comp_t *)((void *)0);
#line 1175
  numcomps = 1;
#line 1176
  color_space = (OPJ_COLOR_SPACE )2;
#line 1178
  memset((void *)(& cmptparm), 0, sizeof(opj_image_cmptparm_t ));
#line 1180
  max = 0;
#line 1182
  f = fopen(filename, "rbm3 V");
  }
#line 1183
  if (! f) {
    {
#line 1184
    fprintf(stderr, "Failed to open %s for reading !\n\230\001", filename);
    }
#line 1185
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1188
  fseek(f, 0L, 0);
#line 1189
  __cil_tmp26 = fscanf(f, "PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%dm3 V", temp,
                       & endian1, & endian2, signtmp, & prec, temp, & w, temp, & h);
  }
#line 1189
  if (__cil_tmp26 != 9) {
    {
#line 1191
    fclose(f);
#line 1192
    fprintf(stderr, "ERROR: Failed to read the right number of element from the fscanf() function!\n");
    }
#line 1194
    return ((opj_image_t *)((void *)0));
  }
#line 1197
  i = 0;
#line 1198
  sign = (char )'+';
  {
#line 1199
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1199
    if (! ((int )signtmp[i] != 0)) {
#line 1199
      goto while_break;
    }
#line 1200
    if ((int )signtmp[i] == 45) {
#line 1201
      sign = (char )'-';
    }
#line 1203
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1206
  fgetc(f);
  }
#line 1207
  if ((int )endian1 == 77) {
#line 1207
    if ((int )endian2 == 76) {
#line 1208
      bigendian = 1;
    } else {
#line 1207
      goto _L;
    }
  } else
  _L: 
#line 1209
  if ((int )endian2 == 77) {
#line 1209
    if ((int )endian1 == 76) {
#line 1210
      bigendian = 0;
    } else {
      {
#line 1212
      fclose(f);
#line 1213
      fprintf(stderr, "Bad pgx header, please check input file\n\220");
      }
#line 1214
      return ((opj_image_t *)((void *)0));
    }
  } else {
    {
#line 1212
    fclose(f);
#line 1213
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1214
    return ((opj_image_t *)((void *)0));
  }
#line 1217
  if (w < 1) {
    {
#line 1218
    fclose(f);
#line 1219
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1220
    return ((opj_image_t *)((void *)0));
  } else
#line 1217
  if (h < 1) {
    {
#line 1218
    fclose(f);
#line 1219
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1220
    return ((opj_image_t *)((void *)0));
  } else
#line 1217
  if (prec < 1) {
    {
#line 1218
    fclose(f);
#line 1219
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1220
    return ((opj_image_t *)((void *)0));
  } else
#line 1217
  if (prec > 31) {
    {
#line 1218
    fclose(f);
#line 1219
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1220
    return ((opj_image_t *)((void *)0));
  }
#line 1223
  if (prec > 16) {
#line 1223
    tmp___0 = 4;
  } else {
#line 1223
    if (prec > 8) {
#line 1223
      tmp = 2;
    } else {
#line 1223
      tmp = 1;
    }
#line 1223
    tmp___0 = tmp;
  }
#line 1223
  expected_file_size = ((OPJ_UINT64 )w * (OPJ_UINT64 )h) * (unsigned long )tmp___0;
#line 1225
  if (expected_file_size > 10000000UL) {
    {
#line 1227
    __cil_tmp32 = ftell(f);
#line 1227
    curpos = __cil_tmp32;
    }
#line 1228
    if (expected_file_size > 2147483647UL) {
#line 1229
      expected_file_size = (OPJ_UINT64 )2147483647;
    }
    {
#line 1231
    fseek(f, (long )expected_file_size - 1L, 0);
#line 1232
    __cil_tmp33 = fread((void *)(& ch), 1UL, 1UL, f);
    }
#line 1232
    if (__cil_tmp33 != 1UL) {
      {
#line 1233
      fprintf(stderr, "File too short\n");
#line 1234
      fclose(f);
      }
#line 1235
      return ((opj_image_t *)((void *)0));
    }
    {
#line 1237
    fseek(f, curpos, 0);
    }
  }
#line 1242
  cmptparm.x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1243
  cmptparm.y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1244
  if (! cmptparm.x0) {
#line 1244
    tmp___1 = (OPJ_UINT32 )((w - 1) * parameters->subsampling_dx + 1);
  } else {
#line 1244
    tmp___1 = (cmptparm.x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )parameters->subsampling_dx) + 1U;
  }
#line 1244
  cmptparm.w = tmp___1;
#line 1247
  if (! cmptparm.y0) {
#line 1247
    tmp___2 = (OPJ_UINT32 )((h - 1) * parameters->subsampling_dy + 1);
  } else {
#line 1247
    tmp___2 = (cmptparm.y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )parameters->subsampling_dy) + 1U;
  }
#line 1247
  cmptparm.h = tmp___2;
#line 1251
  if ((int )sign == 45) {
#line 1252
    cmptparm.sgnd = (OPJ_UINT32 )1;
  } else {
#line 1254
    cmptparm.sgnd = (OPJ_UINT32 )0;
  }
#line 1256
  if (prec < 8) {
#line 1257
    force8 = 1;
#line 1258
    ushift = 8 - prec;
#line 1259
    dshift = prec - ushift;
#line 1260
    if (cmptparm.sgnd) {
#line 1261
      adjustS = 1 << (prec - 1);
    } else {
#line 1263
      adjustS = 0;
    }
#line 1265
    cmptparm.sgnd = (OPJ_UINT32 )0;
#line 1266
    prec = 8;
  } else {
#line 1268
    adjustS = 0;
#line 1268
    force8 = adjustS;
#line 1268
    dshift = force8;
#line 1268
    ushift = dshift;
  }
  {
#line 1271
  cmptparm.prec = (OPJ_UINT32 )prec;
#line 1272
  cmptparm.bpp = (OPJ_UINT32 )prec;
#line 1273
  cmptparm.dx = (OPJ_UINT32 )parameters->subsampling_dx;
#line 1274
  cmptparm.dy = (OPJ_UINT32 )parameters->subsampling_dy;
#line 1277
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm, color_space);
  }
#line 1278
  if (! image) {
    {
#line 1279
    fclose(f);
    }
#line 1280
    return ((opj_image_t *)((void *)0));
  }
#line 1283
  image->x0 = cmptparm.x0;
#line 1284
  image->y0 = cmptparm.x0;
#line 1285
  image->x1 = cmptparm.w;
#line 1286
  image->y1 = cmptparm.h;
#line 1290
  comp = image->comps + 0;
#line 1292
  i = 0;
  {
#line 1292
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: ;
#line 1292
    if (! (i < w * h)) {
#line 1292
      goto while_break___0;
    }
#line 1294
    if (force8) {
      {
#line 1295
      __cil_tmp38 = readuchar(f);
#line 1295
      v = (int )__cil_tmp38 + adjustS;
#line 1296
      v = (v << ushift) + (v >> dshift);
#line 1297
      *(comp->data + i) = (OPJ_INT32 )((unsigned char )v);
      }
#line 1299
      if (v > max) {
#line 1300
        max = v;
      }
#line 1303
      goto while_continue___0;
    }
#line 1305
    if (comp->prec == 8U) {
#line 1306
      if (! comp->sgnd) {
        {
#line 1307
        __cil_tmp39 = readuchar(f);
#line 1307
        v = (int )__cil_tmp39;
        }
      } else {
        {
#line 1309
        __cil_tmp40 = readuchar(f);
#line 1309
        v = (int )((char )__cil_tmp40);
        }
      }
    } else
#line 1311
    if (comp->prec <= 16U) {
#line 1312
      if (! comp->sgnd) {
        {
#line 1313
        __cil_tmp41 = readushort(f, bigendian);
#line 1313
        v = (int )__cil_tmp41;
        }
      } else {
        {
#line 1315
        __cil_tmp42 = readushort(f, bigendian);
#line 1315
        v = (int )((short )__cil_tmp42);
        }
      }
    } else
#line 1318
    if (! comp->sgnd) {
      {
#line 1319
      __cil_tmp43 = readuint(f, bigendian);
#line 1319
      v = (int )__cil_tmp43;
      }
    } else {
      {
#line 1321
      __cil_tmp44 = readuint(f, bigendian);
#line 1321
      v = (int )__cil_tmp44;
      }
    }
#line 1324
    if (v > max) {
#line 1325
      max = v;
    }
#line 1327
    *(comp->data + i) = v;
#line 1292
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1329
  fclose(f);
#line 1330
  __cil_tmp46 = int_floorlog2(max);
#line 1330
  comp->bpp = (OPJ_UINT32 )__cil_tmp46 + 1U;
  }
#line 1332
  return (image);
}
}
#line 1337 "/root/patron/new_24/src/bin/jp2/convert.c"
__inline static int clamp(int value , int prec , int sgnd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1339
  if (sgnd) {
#line 1340
    if (prec <= 8) {
#line 1341
      if (value < -128) {
#line 1341
        tmp___0 = -128;
      } else {
#line 1341
        if (value > 127) {
#line 1341
          tmp = 127;
        } else {
#line 1341
          tmp = value;
        }
#line 1341
        tmp___0 = tmp;
      }
#line 1341
      return (tmp___0);
    } else
#line 1342
    if (prec <= 16) {
#line 1343
      if (value < -32768) {
#line 1343
        tmp___2 = -32768;
      } else {
#line 1343
        if (value > 32767) {
#line 1343
          tmp___1 = 32767;
        } else {
#line 1343
          tmp___1 = value;
        }
#line 1343
        tmp___2 = tmp___1;
      }
#line 1343
      return (tmp___2);
    } else {
#line 1345
      if (value < (-0x7FFFFFFF-1)) {
#line 1345
        tmp___4 = (-0x7FFFFFFF-1);
      } else {
#line 1345
        if (value > 2147483647) {
#line 1345
          tmp___3 = 2147483647;
        } else {
#line 1345
          tmp___3 = value;
        }
#line 1345
        tmp___4 = tmp___3;
      }
#line 1345
      return (tmp___4);
    }
  } else
#line 1348
  if (prec <= 8) {
#line 1349
    if (value < 0) {
#line 1349
      tmp___6 = 0;
    } else {
#line 1349
      if (value > 255) {
#line 1349
        tmp___5 = 255;
      } else {
#line 1349
        tmp___5 = value;
      }
#line 1349
      tmp___6 = tmp___5;
    }
#line 1349
    return (tmp___6);
  } else
#line 1350
  if (prec <= 16) {
#line 1351
    if (value < 0) {
#line 1351
      tmp___8 = 0;
    } else {
#line 1351
      if (value > 65535) {
#line 1351
        tmp___7 = 65535;
      } else {
#line 1351
        tmp___7 = value;
      }
#line 1351
      tmp___8 = tmp___7;
    }
#line 1351
    return (tmp___8);
  } else {
#line 1353
    return (value);
  }
}
}
#line 1358 "/root/patron/new_24/src/bin/jp2/convert.c"
int imagetopgx(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int j ;
  int fails ;
  unsigned int compno ;
  FILE *fdest ;
  opj_image_comp_t *comp ;
  char bname[256] ;
  char *name ;
  int nbytes ;
  size_t res ;
  size_t olen ;
  unsigned long __cil_tmp16 ;
  size_t dotpos ;
  size_t total ;
  void *__cil_tmp19 ;
  int tmp ;
  unsigned char *line_buffer ;
  void *__cil_tmp23 ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp27 ;
  int val ;
  int __cil_tmp32 ;
  int v ;
  unsigned char byte ;
  int __cil_tmp36 ;

  {
#line 1361
  fails = 1;
#line 1363
  fdest = (FILE *)((void *)0);
#line 1365
  compno = 0U;
  {
#line 1365
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1365
    if (! (compno < image->numcomps)) {
#line 1365
      goto while_break;
    }
    {
#line 1366
    comp = image->comps + compno;
#line 1368
    name = bname;
#line 1369
    nbytes = 0;
#line 1371
    __cil_tmp16 = strlen(outfile);
#line 1371
    olen = __cil_tmp16;
#line 1372
    dotpos = olen - 4UL;
#line 1373
    total = ((dotpos + 1UL) + 1UL) + 4UL;
    }
#line 1375
    if ((int )*(outfile + dotpos) != 46) {
      {
#line 1377
      fprintf(stderr, "ERROR -> Impossible happen.");
      }
#line 1378
      goto fin;
    }
#line 1380
    if (total > 256UL) {
      {
#line 1381
      __cil_tmp19 = malloc(total + 1UL);
#line 1381
      name = (char *)__cil_tmp19;
      }
#line 1382
      if ((unsigned long )name == (unsigned long )((void *)0)) {
        {
#line 1383
        fprintf(stderr, "imagetopgx: memory out\n");
        }
#line 1384
        goto fin;
      }
    }
    {
#line 1387
    strncpy(name, outfile, dotpos);
#line 1388
    sprintf(name + dotpos, "_%u.pgx", compno);
#line 1389
    fdest = fopen((char const   *)name, "wb");
    }
#line 1392
    if (! fdest) {
      {
#line 1394
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
      }
#line 1395
      if (total > 256UL) {
        {
#line 1396
        free((void *)name);
        }
      }
#line 1398
      goto fin;
    }
#line 1401
    w = (int )(image->comps + compno)->w;
#line 1402
    h = (int )(image->comps + compno)->h;
#line 1404
    if (comp->sgnd) {
#line 1404
      tmp = '-';
    } else {
#line 1404
      tmp = '+';
    }
    {
#line 1404
    fprintf(fdest, "PG ML %c %d %d %d\n83 V", tmp, comp->prec, w, h);
    }
#line 1407
    if (comp->prec <= 8U) {
#line 1408
      nbytes = 1;
    } else
#line 1409
    if (comp->prec <= 16U) {
#line 1410
      nbytes = 2;
    } else {
#line 1412
      nbytes = 4;
    }
#line 1415
    if (nbytes == 1) {
      {
#line 1416
      __cil_tmp23 = malloc((size_t )w);
#line 1416
      line_buffer = (unsigned char *)__cil_tmp23;
      }
#line 1417
      if ((unsigned long )line_buffer == (unsigned long )((void *)0)) {
        {
#line 1418
        fprintf(stderr, "Out of memory");
        }
#line 1419
        goto fin;
      }
#line 1421
      j = 0;
      {
#line 1421
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1421
        if (! (j < h)) {
#line 1421
          goto while_break___0;
        }
#line 1422
        if (comp->prec == 8U) {
#line 1422
          if (comp->sgnd == 0U) {
#line 1423
            i = 0;
            {
#line 1423
            while (1) {
              while_continue___1: /* CIL Label */ ;

#line 1423
              if (! (i < w)) {
#line 1423
                goto while_break___1;
              }
#line 1424
              if (*((image->comps + compno)->data + (j * w + i)) < 0) {
#line 1424
                tmp___1 = 0;
              } else {
#line 1424
                if (*((image->comps + compno)->data + (j * w + i)) > 255) {
#line 1424
                  tmp___0 = 255;
                } else {
#line 1424
                  tmp___0 = *((image->comps + compno)->data + (j * w + i));
                }
#line 1424
                tmp___1 = tmp___0;
              }
#line 1424
              *(line_buffer + i) = (unsigned char )tmp___1;
#line 1423
              i ++;
            }
            while_break___7: /* CIL Label */ ;
            }
            while_break___1: ;
          } else {
#line 1422
            goto _L;
          }
        } else {
          _L: 
#line 1428
          i = 0;
          {
#line 1428
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 1428
            if (! (i < w)) {
#line 1428
              goto while_break___2;
            }
            {
#line 1429
            __cil_tmp27 = clamp(*((image->comps + compno)->data + (j * w + i)), (int )comp->prec,
                                (int )comp->sgnd);
#line 1429
            *(line_buffer + i) = (unsigned char )__cil_tmp27;
#line 1428
            i ++;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___2: ;
        }
        {
#line 1434
        res = fwrite((void const   *)line_buffer, 1UL, (size_t )w, fdest);
        }
#line 1435
        if (res != (size_t )w) {
          {
#line 1436
          fprintf(stderr, "failed to write %d bytes for %s\n\230\001", w, name);
          }
#line 1437
          if (total > 256UL) {
            {
#line 1438
            free((void *)name);
            }
          }
          {
#line 1440
          free((void *)line_buffer);
          }
#line 1441
          goto fin;
        }
#line 1421
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 1444
      free((void *)line_buffer);
      }
    } else {
#line 1447
      i = 0;
      {
#line 1447
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1447
        if (! (i < w * h)) {
#line 1447
          goto while_break___3;
        }
        {
#line 1449
        __cil_tmp32 = clamp(*((image->comps + compno)->data + i), (int )comp->prec,
                            (int )comp->sgnd);
#line 1449
        val = __cil_tmp32;
#line 1452
        j = nbytes - 1;
        }
        {
#line 1452
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 1452
          if (! (j >= 0)) {
#line 1452
            goto while_break___4;
          }
          {
#line 1453
          v = val >> j * 8;
#line 1454
          byte = (unsigned char )v;
#line 1455
          res = fwrite((void const   *)(& byte), 1UL, 1UL, fdest);
          }
#line 1457
          if (res < 1UL) {
            {
#line 1458
            fprintf(stderr, "failed to write 1 byte for %s\n", name);
            }
#line 1459
            if (total > 256UL) {
              {
#line 1460
              free((void *)name);
              }
            }
#line 1462
            goto fin;
          }
#line 1452
          __cil_tmp36 = j;
#line 1452
          j --;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: 
#line 1447
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: ;
    }
#line 1468
    if (total > 256UL) {
      {
#line 1469
      free((void *)name);
      }
    }
    {
#line 1471
    fclose(fdest);
#line 1472
    fdest = (FILE *)((void *)0);
#line 1365
    compno ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 1474
  fails = 0;
  fin: 
#line 1476
  if (fdest) {
    {
#line 1477
    fclose(fdest);
    }
  }
#line 1480
  return (fails);
}
}
#line 1495 "/root/patron/new_24/src/bin/jp2/convert.c"
static char *skip_white(char *s ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
#line 1497
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 1498
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: ;
#line 1498
      if (! *s) {
#line 1498
        goto while_break;
      }
#line 1499
      if ((int )*s == 10) {
#line 1500
        return ((char *)((void *)0));
      } else
#line 1499
      if ((int )*s == 13) {
#line 1500
        return ((char *)((void *)0));
      }
      {
#line 1502
      __cil_tmp2 = __ctype_b_loc();
      }
#line 1502
      if ((int )*(*__cil_tmp2 + (int )*s) & 8192) {
#line 1503
        s ++;
#line 1504
        goto while_continue;
      }
#line 1506
      return (s);
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 1509
  return ((char *)((void *)0));
}
}
#line 1512 "/root/patron/new_24/src/bin/jp2/convert.c"
static char *skip_int(char *start , int *out_n ) 
{ 
  char *s ;
  char c ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1517
  *out_n = 0;
#line 1519
  s = skip_white(start);
  }
#line 1520
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1521
    return ((char *)((void *)0));
  }
#line 1523
  start = s;
  {
#line 1525
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1525
    if (! *s) {
#line 1525
      goto while_break;
    }
    {
#line 1526
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1526
    if (! ((int )*(*__cil_tmp6 + (int )*s) & 2048)) {
#line 1527
      goto while_break;
    }
#line 1529
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1531
  c = *s;
#line 1532
  *s = (char)0;
#line 1533
  *out_n = atoi((char const   *)start);
#line 1534
  *s = c;
  }
#line 1535
  return (s);
}
}
#line 1538 "/root/patron/new_24/src/bin/jp2/convert.c"
static char *skip_idf(char *start , char *out_idf ) 
{ 
  char *s ;
  char c ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1543
  s = skip_white(start);
  }
#line 1544
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1545
    return ((char *)((void *)0));
  }
#line 1547
  start = s;
  {
#line 1549
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1549
    if (! *s) {
#line 1549
      goto while_break;
    }
    {
#line 1550
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1550
    if ((int )*(*__cil_tmp6 + (int )*s) & 1024) {
#line 1551
      s ++;
#line 1552
      goto while_continue;
    } else
#line 1550
    if ((int )*s == 95) {
#line 1551
      s ++;
#line 1552
      goto while_continue;
    }
#line 1554
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1556
  c = *s;
#line 1557
  *s = (char)0;
#line 1558
  strncpy((char *)out_idf, (char const   *)start, 255UL);
#line 1559
  *s = c;
  }
#line 1560
  return (s);
}
}
#line 1563 "/root/patron/new_24/src/bin/jp2/convert.c"
static void read_pnm_header(FILE *reader , struct pnm_header *ph ) 
{ 
  int format ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type[256] ;
  char line[256] ;
  char *__cil_tmp9 ;
  char *__cil_tmp11 ;
  char *s ;
  int allow_null ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  int __cil_tmp20 ;
  int __cil_tmp22 ;
  int __cil_tmp24 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
  {
#line 1569
  __cil_tmp9 = fgets(line, 250, reader);
  }
#line 1569
  if ((unsigned long )__cil_tmp9 == (unsigned long )((void *)0)) {
    {
#line 1570
    fprintf(stderr, "\nWARNING: fgets return a NULL value3 V");
    }
#line 1571
    return;
  }
#line 1574
  if ((int )line[0] != 80) {
    {
#line 1575
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\n V");
    }
#line 1576
    return;
  }
  {
#line 1578
  format = atoi((char const   *)(line + 1));
  }
#line 1579
  if (format < 1) {
    {
#line 1580
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
#line 1581
    return;
  } else
#line 1579
  if (format > 7) {
    {
#line 1580
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
#line 1581
    return;
  }
#line 1583
  ph->format = format;
#line 1584
  end = 0;
#line 1584
  ttype = end;
  {
#line 1586
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 1586
    __cil_tmp11 = fgets(line, 250, reader);
    }
#line 1586
    if (! __cil_tmp11) {
#line 1586
      goto while_break;
    }
#line 1588
    allow_null = 0;
#line 1590
    if ((int )line[0] == 35) {
#line 1591
      goto while_continue;
    }
#line 1594
    s = line;
#line 1596
    if (format == 7) {
      {
#line 1597
      s = skip_idf(s, (char *)(idf));
      }
#line 1599
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1600
        return;
      } else
#line 1599
      if ((int )*s == 0) {
#line 1600
        return;
      }
      {
#line 1603
      __cil_tmp15 = strcmp((char const   *)(idf), "ENDHDR");
      }
#line 1603
      if (__cil_tmp15 == 0) {
#line 1604
        end = 1;
#line 1605
        goto while_break;
      }
      {
#line 1607
      __cil_tmp16 = strcmp((char const   *)(idf), "WIDTHV");
      }
#line 1607
      if (__cil_tmp16 == 0) {
        {
#line 1608
        s = skip_int(s, & ph->width);
        }
#line 1609
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1610
          return;
        } else
#line 1609
        if ((int )*s == 0) {
#line 1610
          return;
        }
#line 1613
        goto while_continue;
      }
      {
#line 1615
      __cil_tmp18 = strcmp((char const   *)(idf), "HEIGHT");
      }
#line 1615
      if (__cil_tmp18 == 0) {
        {
#line 1616
        s = skip_int(s, & ph->height);
        }
#line 1617
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1618
          return;
        } else
#line 1617
        if ((int )*s == 0) {
#line 1618
          return;
        }
#line 1621
        goto while_continue;
      }
      {
#line 1623
      __cil_tmp20 = strcmp((char const   *)(idf), "DEPTHV");
      }
#line 1623
      if (__cil_tmp20 == 0) {
        {
#line 1624
        s = skip_int(s, & ph->depth);
        }
#line 1625
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1626
          return;
        } else
#line 1625
        if ((int )*s == 0) {
#line 1626
          return;
        }
#line 1629
        goto while_continue;
      }
      {
#line 1631
      __cil_tmp22 = strcmp((char const   *)(idf), "MAXVAL");
      }
#line 1631
      if (__cil_tmp22 == 0) {
        {
#line 1632
        s = skip_int(s, & ph->maxval);
        }
#line 1633
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1634
          return;
        } else
#line 1633
        if ((int )*s == 0) {
#line 1634
          return;
        }
#line 1637
        goto while_continue;
      }
      {
#line 1639
      __cil_tmp24 = strcmp((char const   *)(idf), "TUPLTYPE\220");
      }
#line 1639
      if (__cil_tmp24 == 0) {
        {
#line 1640
        s = skip_idf(s, (char *)(type));
        }
#line 1641
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1642
          return;
        } else
#line 1641
        if ((int )*s == 0) {
#line 1642
          return;
        }
        {
#line 1645
        __cil_tmp26 = strcmp((char const   *)(type), "BLACKANDWHITEV");
        }
#line 1645
        if (__cil_tmp26 == 0) {
#line 1646
          ph->bw = (char)1;
#line 1647
          ttype = 1;
#line 1648
          goto while_continue;
        }
        {
#line 1650
        __cil_tmp27 = strcmp((char const   *)(type), "GRAYSCALE\211n3 V");
        }
#line 1650
        if (__cil_tmp27 == 0) {
#line 1651
          ph->gray = (char)1;
#line 1652
          ttype = 1;
#line 1653
          goto while_continue;
        }
        {
#line 1655
        __cil_tmp28 = strcmp((char const   *)(type), "GRAYSCALE_ALPHA");
        }
#line 1655
        if (__cil_tmp28 == 0) {
#line 1656
          ph->graya = (char)1;
#line 1657
          ttype = 1;
#line 1658
          goto while_continue;
        }
        {
#line 1660
        __cil_tmp29 = strcmp((char const   *)(type), "RGB");
        }
#line 1660
        if (__cil_tmp29 == 0) {
#line 1661
          ph->rgb = (char)1;
#line 1662
          ttype = 1;
#line 1663
          goto while_continue;
        }
        {
#line 1665
        __cil_tmp30 = strcmp((char const   *)(type), "RGB_ALPHABo3 V");
        }
#line 1665
        if (__cil_tmp30 == 0) {
#line 1666
          ph->rgba = (char)1;
#line 1667
          ttype = 1;
#line 1668
          goto while_continue;
        }
        {
#line 1670
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", type);
        }
#line 1671
        return;
      }
      {
#line 1673
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\no3 V", idf);
      }
#line 1674
      return;
    }
#line 1678
    if (ph->width == 0) {
      {
#line 1679
      s = skip_int(s, & ph->width);
      }
#line 1680
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1681
        return;
      } else
#line 1680
      if ((int )*s == 0) {
#line 1681
        return;
      } else
#line 1680
      if (ph->width < 1) {
#line 1681
        return;
      }
#line 1683
      allow_null = 1;
    }
#line 1685
    if (ph->height == 0) {
      {
#line 1686
      s = skip_int(s, & ph->height);
      }
#line 1687
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1687
        if (allow_null) {
#line 1688
          goto while_continue;
        }
      }
#line 1690
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1691
        return;
      } else
#line 1690
      if ((int )*s == 0) {
#line 1691
        return;
      } else
#line 1690
      if (ph->height < 1) {
#line 1691
        return;
      }
#line 1693
      if (format == 1) {
#line 1694
        goto while_break;
      } else
#line 1693
      if (format == 4) {
#line 1694
        goto while_break;
      }
#line 1696
      allow_null = 1;
    }
    {
#line 1699
    s = skip_int(s, & ph->maxval);
    }
#line 1700
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1700
      if (allow_null) {
#line 1701
        goto while_continue;
      }
    }
#line 1703
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1704
      return;
    } else
#line 1703
    if ((int )*s == 0) {
#line 1704
      return;
    }
#line 1706
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1708
  if (format == 2) {
    _L: 
#line 1709
    if (ph->maxval < 1) {
#line 1710
      return;
    } else
#line 1709
    if (ph->maxval > 65535) {
#line 1710
      return;
    }
  } else
#line 1708
  if (format == 3) {
#line 1708
    goto _L;
  } else
#line 1708
  if (format > 4) {
#line 1708
    goto _L;
  }
#line 1713
  if (ph->width < 1) {
#line 1714
    return;
  } else
#line 1713
  if (ph->height < 1) {
#line 1714
    return;
  }
#line 1717
  if (format == 7) {
#line 1718
    if (! end) {
      {
#line 1719
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1720
      return;
    }
#line 1722
    if (ph->depth < 1) {
#line 1723
      return;
    } else
#line 1722
    if (ph->depth > 4) {
#line 1723
      return;
    }
#line 1726
    if (ttype) {
#line 1727
      ph->ok = (char)1;
    }
  } else {
#line 1730
    ph->ok = (char)1;
#line 1731
    if (format == 1) {
#line 1732
      ph->maxval = 255;
    } else
#line 1731
    if (format == 4) {
#line 1732
      ph->maxval = 255;
    }
  }
#line 1735
  return;
}
}
#line 1737 "/root/patron/new_24/src/bin/jp2/convert.c"
static int has_prec(int val ) 
{ 


  {
#line 1739
  if (val < 2) {
#line 1740
    return (1);
  }
#line 1742
  if (val < 4) {
#line 1743
    return (2);
  }
#line 1745
  if (val < 8) {
#line 1746
    return (3);
  }
#line 1748
  if (val < 16) {
#line 1749
    return (4);
  }
#line 1751
  if (val < 32) {
#line 1752
    return (5);
  }
#line 1754
  if (val < 64) {
#line 1755
    return (6);
  }
#line 1757
  if (val < 128) {
#line 1758
    return (7);
  }
#line 1760
  if (val < 256) {
#line 1761
    return (8);
  }
#line 1763
  if (val < 512) {
#line 1764
    return (9);
  }
#line 1766
  if (val < 1024) {
#line 1767
    return (10);
  }
#line 1769
  if (val < 2048) {
#line 1770
    return (11);
  }
#line 1772
  if (val < 4096) {
#line 1773
    return (12);
  }
#line 1775
  if (val < 8192) {
#line 1776
    return (13);
  }
#line 1778
  if (val < 16384) {
#line 1779
    return (14);
  }
#line 1781
  if (val < 32768) {
#line 1782
    return (15);
  }
#line 1784
  return (16);
}
}
#line 1787 "/root/patron/new_24/src/bin/jp2/convert.c"
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *fp ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  int prec ;
  int format ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  struct pnm_header header_info ;
  unsigned int index___0 ;
  int __cil_tmp22 ;
  unsigned char c0 ;
  unsigned char c1 ;
  unsigned char one ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned int index___1 ;
  int __cil_tmp33 ;
  int tmp ;
  int x ;
  int y ;
  int bit ;
  unsigned char uc ;
  int __cil_tmp40 ;
  int tmp___0 ;
  unsigned char uc___0 ;
  unsigned long __cil_tmp43 ;
  int tmp___1 ;

  {
  {
#line 1789
  subsampling_dx = parameters->subsampling_dx;
#line 1790
  subsampling_dy = parameters->subsampling_dy;
#line 1792
  fp = (FILE *)((void *)0);
#line 1796
  image = (opj_image_t *)((void *)0);
#line 1799
  fp = fopen(filename, "rbo3 V");
  }
#line 1799
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1800
    fprintf(stderr, "pnmtoimage:Failed to open %s for reading!\no3 V", filename);
    }
#line 1801
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1803
  memset((void *)(& header_info), 0, sizeof(struct pnm_header ));
#line 1805
  read_pnm_header(fp, & header_info);
  }
#line 1807
  if (! header_info.ok) {
    {
#line 1808
    fclose(fp);
    }
#line 1809
    return ((opj_image_t *)((void *)0));
  }
#line 1813
  if (header_info.height != 0) {
#line 1813
    if (header_info.width > 2147483647 / header_info.height) {
      {
#line 1815
      fprintf(stderr, "pnmtoimage:Image %dx%d too big!\n\230\001", header_info.width,
              header_info.height);
#line 1817
      fclose(fp);
      }
#line 1818
      return ((opj_image_t *)((void *)0));
    }
  }
#line 1821
  format = header_info.format;
#line 1825
  if (format == 4) {
#line 1825
    goto case_4;
  }
#line 1825
  if (format == 1) {
#line 1825
    goto case_4;
  }
#line 1830
  if (format == 5) {
#line 1830
    goto case_5;
  }
#line 1830
  if (format == 2) {
#line 1830
    goto case_5;
  }
#line 1835
  if (format == 6) {
#line 1835
    goto case_6;
  }
#line 1835
  if (format == 3) {
#line 1835
    goto case_6;
  }
#line 1839
  if (format == 7) {
#line 1839
    goto case_7;
  }
#line 1843
  goto switch_default;
  case_4: 
#line 1826
  numcomps = 1;
#line 1827
  goto switch_break;
  case_5: 
#line 1831
  numcomps = 1;
#line 1832
  goto switch_break;
  case_6: 
#line 1836
  numcomps = 3;
#line 1837
  goto switch_break;
  case_7: 
#line 1840
  numcomps = header_info.depth;
#line 1841
  goto switch_break;
  switch_default: 
  {
#line 1844
  fclose(fp);
  }
#line 1845
  return ((opj_image_t *)((void *)0));
  switch_break: ;
#line 1847
  if (numcomps < 3) {
#line 1848
    color_space = (OPJ_COLOR_SPACE )2;
  } else {
#line 1850
    color_space = (OPJ_COLOR_SPACE )1;
  }
  {
#line 1853
  prec = has_prec(header_info.maxval);
  }
#line 1855
  if (prec < 8) {
#line 1856
    prec = 8;
  }
  {
#line 1859
  w = header_info.width;
#line 1860
  h = header_info.height;
#line 1861
  subsampling_dx = parameters->subsampling_dx;
#line 1862
  subsampling_dy = parameters->subsampling_dy;
#line 1864
  memset((void *)(& cmptparm[0]), 0, (size_t )numcomps * sizeof(opj_image_cmptparm_t ));
#line 1866
  i = 0;
  }
  {
#line 1866
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1866
    if (! (i < numcomps)) {
#line 1866
      goto while_break;
    }
#line 1867
    cmptparm[i].prec = (OPJ_UINT32 )prec;
#line 1868
    cmptparm[i].bpp = (OPJ_UINT32 )prec;
#line 1869
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 1870
    cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 1871
    cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 1872
    cmptparm[i].w = (OPJ_UINT32 )w;
#line 1873
    cmptparm[i].h = (OPJ_UINT32 )h;
#line 1866
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1875
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 1877
  if (! image) {
    {
#line 1878
    fclose(fp);
    }
#line 1879
    return ((opj_image_t *)((void *)0));
  }
#line 1883
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1884
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1885
  image->x1 = (OPJ_UINT32 )((parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1);
#line 1887
  image->y1 = (OPJ_UINT32 )((parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1);
#line 1890
  if (format == 2) {
    _L___66: 
#line 1893
    i = 0;
    {
#line 1893
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1893
      if (! (i < w * h)) {
#line 1893
        goto while_break___0;
      }
#line 1894
      compno = 0;
      {
#line 1894
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1894
        if (! (compno < numcomps)) {
#line 1894
          goto while_break___1;
        }
        {
#line 1895
        index___0 = 0U;
#line 1896
        __cil_tmp22 = fscanf(fp, "%u", & index___0);
        }
#line 1896
        if (__cil_tmp22 != 1) {
          {
#line 1897
          fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
          }
        }
#line 1901
        *((image->comps + compno)->data + i) = (OPJ_INT32 )(index___0 * 255U) / header_info.maxval;
#line 1894
        compno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___1: 
#line 1893
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: ;
  } else
#line 1890
  if (format == 3) {
#line 1890
    goto _L___66;
  } else
#line 1904
  if (format == 5) {
    _L: 
#line 1911
    one = (unsigned char )(prec < 9);
#line 1913
    i = 0;
    {
#line 1913
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1913
      if (! (i < w * h)) {
#line 1913
        goto while_break___2;
      }
#line 1914
      compno = 0;
      {
#line 1914
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1914
        if (! (compno < numcomps)) {
#line 1914
          goto while_break___3;
        }
        {
#line 1915
        __cil_tmp28 = fread((void *)(& c0), 1UL, 1UL, fp);
        }
#line 1915
        if (! __cil_tmp28) {
          {
#line 1916
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 1918
          opj_image_destroy(image);
#line 1919
          fclose(fp);
          }
#line 1920
          return ((opj_image_t *)((void *)0));
        }
#line 1922
        if (one) {
#line 1923
          *((image->comps + compno)->data + i) = (OPJ_INT32 )c0;
        } else {
          {
#line 1925
          __cil_tmp29 = fread((void *)(& c1), 1UL, 1UL, fp);
          }
#line 1925
          if (! __cil_tmp29) {
            {
#line 1926
            fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
            }
          }
#line 1930
          *((image->comps + compno)->data + i) = ((int )c0 << 8) | (int )c1;
        }
#line 1914
        compno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___3: 
#line 1913
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___2: ;
  } else
#line 1904
  if (format == 6) {
#line 1904
    goto _L;
  } else
#line 1904
  if (format == 7) {
#line 1904
    if ((int )header_info.gray) {
#line 1904
      goto _L;
    } else
#line 1904
    if ((int )header_info.graya) {
#line 1904
      goto _L;
    } else
#line 1904
    if ((int )header_info.rgb) {
#line 1904
      goto _L;
    } else
#line 1904
    if ((int )header_info.rgba) {
#line 1904
      goto _L;
    } else {
#line 1904
      goto _L___64;
    }
  } else
  _L___64: 
#line 1934
  if (format == 1) {
#line 1935
    i = 0;
    {
#line 1935
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 1935
      if (! (i < w * h)) {
#line 1935
        goto while_break___4;
      }
      {
#line 1938
      __cil_tmp33 = fscanf(fp, "%u", & index___1);
      }
#line 1938
      if (__cil_tmp33 != 1) {
        {
#line 1939
        fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
        }
      }
#line 1943
      if (index___1) {
#line 1943
        tmp = 0;
      } else {
#line 1943
        tmp = 255;
      }
#line 1943
      *((image->comps + 0)->data + i) = tmp;
#line 1935
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: ;
  } else
#line 1945
  if (format == 4) {
#line 1949
    i = 0;
#line 1950
    y = 0;
    {
#line 1950
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 1950
      if (! (y < h)) {
#line 1950
        goto while_break___5;
      }
#line 1951
      bit = -1;
#line 1952
      uc = (unsigned char)0;
#line 1954
      x = 0;
      {
#line 1954
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 1954
        if (! (x < w)) {
#line 1954
          goto while_break___6;
        }
#line 1955
        if (bit == -1) {
          {
#line 1956
          bit = 7;
#line 1957
          __cil_tmp40 = getc(fp);
#line 1957
          uc = (unsigned char )__cil_tmp40;
          }
        }
#line 1959
        if (((int )uc >> bit) & 1) {
#line 1959
          tmp___0 = 0;
        } else {
#line 1959
          tmp___0 = 255;
        }
#line 1959
        *((image->comps + 0)->data + i) = tmp___0;
#line 1960
        bit --;
#line 1961
        i ++;
#line 1954
        x ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___6: 
#line 1950
      y ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___5: ;
  } else
#line 1964
  if (format == 7) {
#line 1964
    if ((int )header_info.bw) {
#line 1967
      i = 0;
      {
#line 1967
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 1967
        if (! (i < w * h)) {
#line 1967
          goto while_break___7;
        }
        {
#line 1968
        __cil_tmp43 = fread((void *)(& uc___0), 1UL, 1UL, fp);
        }
#line 1968
        if (! __cil_tmp43) {
          {
#line 1969
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n\001");
          }
        }
#line 1972
        if ((int )uc___0 & 1) {
#line 1972
          tmp___1 = 0;
        } else {
#line 1972
          tmp___1 = 255;
        }
#line 1972
        *((image->comps + 0)->data + i) = tmp___1;
#line 1967
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___7: ;
    }
  }
  {
#line 1975
  fclose(fp);
  }
#line 1977
  return (image);
}
}
#line 1980 "/root/patron/new_24/src/bin/jp2/convert.c"
static int are_comps_similar(opj_image_t *image ) 
{ 
  unsigned int i ;

  {
#line 1983
  i = 1U;
  {
#line 1983
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1983
    if (! (i < image->numcomps)) {
#line 1983
      goto while_break;
    }
#line 1984
    if ((image->comps + 0)->dx != (image->comps + i)->dx) {
#line 1989
      return (0);
    } else
#line 1984
    if ((image->comps + 0)->dy != (image->comps + i)->dy) {
#line 1989
      return (0);
    } else
#line 1984
    if (i <= 2U) {
#line 1984
      if ((image->comps + 0)->prec != (image->comps + i)->prec) {
#line 1989
        return (0);
      } else
#line 1984
      if ((image->comps + 0)->sgnd != (image->comps + i)->sgnd) {
#line 1989
        return (0);
      }
    }
#line 1983
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1992
  return (1);
}
}
#line 1996 "/root/patron/new_24/src/bin/jp2/convert.c"
int imagetopnm(opj_image_t *image , char const   *outfile , int force_split ) 
{ 
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  int wr ;
  int hr ;
  int max ;
  int i ;
  unsigned int compno ;
  unsigned int ncomp ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustA ;
  int fails ;
  int two ;
  int want_gray ;
  int has_alpha ;
  int triple ;
  int prec ;
  int v ;
  FILE *fdest ;
  char const   *tmp ;
  char *destname ;
  int __cil_tmp28 ;
  char const   *tt ;
  char const   *tmp___67 ;
  char const   *__cil_tmp32 ;
  int tmp___68 ;
  char const   *__cil_tmp34 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int *__cil_tmp38 ;
  int *__cil_tmp39 ;
  int *__cil_tmp40 ;
  int *__cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  void *__cil_tmp43 ;
  size_t olen ;
  unsigned long __cil_tmp45 ;
  size_t dotpos ;
  char const   *__cil_tmp48 ;
  int tmp___72 ;
  int *__cil_tmp50 ;
  int tmp___73 ;
  int tmp___74 ;

  {
#line 2005
  fdest = (FILE *)((void *)0);
#line 2006
  tmp = outfile;
#line 2009
  alpha = (int *)((void *)0);
#line 2011
  prec = (int )(image->comps + 0)->prec;
#line 2011
  if (prec > 16) {
    {
#line 2012
    fprintf(stderr, "%s:%d:imagetopnm\n\tprecision %d is larger than 16\n\t: refused.\nZp3 V",
            "/root/patron/new_24/src/bin/jp2/convert.c", 2013, prec);
    }
#line 2014
    return (1);
  }
#line 2016
  has_alpha = 0;
#line 2016
  two = has_alpha;
#line 2017
  fails = 1;
#line 2018
  ncomp = image->numcomps;
  {
#line 2020
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2020
    if (! *tmp) {
#line 2020
      goto while_break;
    }
#line 2021
    tmp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 2023
  tmp -= 2;
#line 2024
  if ((int )*tmp == 103) {
#line 2024
    tmp___73 = 1;
  } else
#line 2024
  if ((int )*tmp == 71) {
#line 2024
    tmp___73 = 1;
  } else {
#line 2024
    tmp___73 = 0;
  }
#line 2024
  want_gray = tmp___73;
#line 2025
  ncomp = image->numcomps;
#line 2027
  if (want_gray) {
#line 2028
    ncomp = 1U;
  }
  {
#line 2031
  __cil_tmp28 = are_comps_similar(image);
  }
#line 2031
  if (force_split == 0) {
#line 2031
    if (ncomp >= 2U) {
#line 2031
      if (__cil_tmp28) {
        {
#line 2033
        fdest = fopen(outfile, "wb");
        }
#line 2035
        if (! fdest) {
          {
#line 2036
          fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
          }
#line 2037
          return (fails);
        }
#line 2039
        two = prec > 8;
#line 2040
        triple = ncomp > 2U;
#line 2041
        wr = (int )(image->comps + 0)->w;
#line 2042
        hr = (int )(image->comps + 0)->h;
#line 2043
        max = (1 << prec) - 1;
#line 2044
        if (ncomp == 4U) {
#line 2044
          tmp___74 = 1;
        } else
#line 2044
        if (ncomp == 2U) {
#line 2044
          tmp___74 = 1;
        } else {
#line 2044
          tmp___74 = 0;
        }
#line 2044
        has_alpha = tmp___74;
#line 2046
        red = (image->comps + 0)->data;
#line 2048
        if (triple) {
#line 2049
          green = (image->comps + 1)->data;
#line 2050
          blue = (image->comps + 2)->data;
        } else {
#line 2052
          blue = (int *)((void *)0);
#line 2052
          green = blue;
        }
#line 2055
        if (has_alpha) {
#line 2056
          if (triple) {
            {
#line 2056
            strcpy((char *)tmp___67, "RGB_ALPHA");
            }
          } else {
            {
#line 2056
            strcpy((char *)tmp___67, "GRAYSCALE_ALPHA");
            }
          }
          {
#line 2056
          tt = tmp___67;
#line 2058
          __cil_tmp32 = opj_version();
#line 2058
          fprintf(fdest, "P7\n# OpenJPEG-%s\nWIDTH %d\nHEIGHT %d\nDEPTH %u\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
                  __cil_tmp32, wr, hr, ncomp, max, tt);
#line 2061
          alpha = (image->comps + (ncomp - 1U))->data;
          }
#line 2062
          if ((image->comps + (ncomp - 1U))->sgnd) {
#line 2062
            tmp___68 = 1 << ((image->comps + (ncomp - 1U))->prec - 1U);
          } else {
#line 2062
            tmp___68 = 0;
          }
#line 2062
          adjustA = tmp___68;
        } else {
          {
#line 2065
          __cil_tmp34 = opj_version();
#line 2065
          fprintf(fdest, "P6\n# OpenJPEG-%s\n%d %d\n%d\np3 V", __cil_tmp34, wr, hr,
                  max);
#line 2067
          adjustA = 0;
          }
        }
#line 2069
        if ((image->comps + 0)->sgnd) {
#line 2069
          tmp___69 = 1 << ((image->comps + 0)->prec - 1U);
        } else {
#line 2069
          tmp___69 = 0;
        }
#line 2069
        adjustR = tmp___69;
#line 2071
        if (triple) {
#line 2072
          if ((image->comps + 1)->sgnd) {
#line 2072
            tmp___70 = 1 << ((image->comps + 1)->prec - 1U);
          } else {
#line 2072
            tmp___70 = 0;
          }
#line 2072
          adjustG = tmp___70;
#line 2073
          if ((image->comps + 2)->sgnd) {
#line 2073
            tmp___71 = 1 << ((image->comps + 2)->prec - 1U);
          } else {
#line 2073
            tmp___71 = 0;
          }
#line 2073
          adjustB = tmp___71;
        } else {
#line 2075
          adjustB = 0;
#line 2075
          adjustG = adjustB;
        }
#line 2078
        i = 0;
        {
#line 2078
        while (1) {
          while_continue___1: /* CIL Label */ ;
          while_continue___0: ;
#line 2078
          if (! (i < wr * hr)) {
#line 2078
            goto while_break___0;
          }
#line 2079
          if (two) {
#line 2080
            v = *red + adjustR;
#line 2081
            red ++;
#line 2082
            if (v > 65535) {
#line 2083
              v = 65535;
            } else
#line 2084
            if (v < 0) {
#line 2085
              v = 0;
            }
            {
#line 2089
            fprintf(fdest, "%c%c V", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
            }
#line 2091
            if (triple) {
#line 2092
              v = *green + adjustG;
#line 2093
              green ++;
#line 2094
              if (v > 65535) {
#line 2095
                v = 65535;
              } else
#line 2096
              if (v < 0) {
#line 2097
                v = 0;
              }
              {
#line 2101
              fprintf(fdest, "%c%c V", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
#line 2103
              v = *blue + adjustB;
#line 2104
              blue ++;
              }
#line 2105
              if (v > 65535) {
#line 2106
                v = 65535;
              } else
#line 2107
              if (v < 0) {
#line 2108
                v = 0;
              }
              {
#line 2112
              fprintf(fdest, "%c%c V", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
              }
            }
#line 2116
            if (has_alpha) {
#line 2117
              v = *alpha + adjustA;
#line 2118
              alpha ++;
#line 2119
              if (v > 65535) {
#line 2120
                v = 65535;
              } else
#line 2121
              if (v < 0) {
#line 2122
                v = 0;
              }
              {
#line 2126
              fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
              }
            }
#line 2128
            goto while_continue___0;
          }
#line 2133
          __cil_tmp38 = red;
#line 2133
          red ++;
#line 2133
          v = *__cil_tmp38;
#line 2134
          if (v > 255) {
#line 2135
            v = 255;
          } else
#line 2136
          if (v < 0) {
#line 2137
            v = 0;
          }
          {
#line 2140
          fprintf(fdest, "%cp3 V", (int )((unsigned char )v));
          }
#line 2141
          if (triple) {
#line 2142
            __cil_tmp39 = green;
#line 2142
            green ++;
#line 2142
            v = *__cil_tmp39;
#line 2143
            if (v > 255) {
#line 2144
              v = 255;
            } else
#line 2145
            if (v < 0) {
#line 2146
              v = 0;
            }
            {
#line 2149
            fprintf(fdest, "%cp3 V", (int )((unsigned char )v));
#line 2150
            __cil_tmp40 = blue;
#line 2150
            blue ++;
#line 2150
            v = *__cil_tmp40;
            }
#line 2151
            if (v > 255) {
#line 2152
              v = 255;
            } else
#line 2153
            if (v < 0) {
#line 2154
              v = 0;
            }
            {
#line 2157
            fprintf(fdest, "%co3 V", (int )((unsigned char )v));
            }
          }
#line 2159
          if (has_alpha) {
#line 2160
            __cil_tmp41 = alpha;
#line 2160
            alpha ++;
#line 2160
            v = *__cil_tmp41;
#line 2161
            if (v > 255) {
#line 2162
              v = 255;
            } else
#line 2163
            if (v < 0) {
#line 2164
              v = 0;
            }
            {
#line 2167
            fprintf(fdest, "%co3 V", (int )((unsigned char )v));
            }
          }
#line 2078
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___0: 
        {
#line 2171
        fclose(fdest);
        }
#line 2172
        return (0);
      }
    }
  }
#line 2177
  if (image->numcomps > ncomp) {
    {
#line 2178
    fprintf(stderr, "WARNING -> [PGM file] Only the first component\n");
#line 2179
    fprintf(stderr, "           is written to the file\no3 V");
    }
  }
  {
#line 2181
  __cil_tmp42 = strlen(outfile);
#line 2181
  __cil_tmp43 = malloc(__cil_tmp42 + 8UL);
#line 2181
  destname = (char *)__cil_tmp43;
  }
#line 2182
  if ((unsigned long )destname == (unsigned long )((void *)0)) {
    {
#line 2183
    fprintf(stderr, "imagetopnm: memory out\n");
    }
#line 2184
    return (1);
  }
#line 2186
  compno = 0U;
  {
#line 2186
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 2186
    if (! (compno < ncomp)) {
#line 2186
      goto while_break___1;
    }
#line 2187
    if (ncomp > 1U) {
      {
#line 2189
      __cil_tmp45 = strlen(outfile);
#line 2189
      olen = __cil_tmp45;
#line 2190
      dotpos = olen - 4UL;
#line 2192
      strncpy(destname, outfile, dotpos);
#line 2193
      sprintf(destname + dotpos, "_%u.pgm", compno);
      }
    } else {
      {
#line 2195
      sprintf(destname, "%so3 V", outfile);
      }
    }
    {
#line 2198
    fdest = fopen((char const   *)destname, "wbo3 V");
    }
#line 2199
    if (! fdest) {
      {
#line 2200
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", destname);
#line 2201
      free((void *)destname);
      }
#line 2202
      return (1);
    }
    {
#line 2204
    wr = (int )(image->comps + compno)->w;
#line 2205
    hr = (int )(image->comps + compno)->h;
#line 2206
    prec = (int )(image->comps + compno)->prec;
#line 2207
    max = (1 << prec) - 1;
#line 2209
    __cil_tmp48 = opj_version();
#line 2209
    fprintf(fdest, "P5\n#OpenJPEG-%s\n%d %d\n%d\n\21283 V", __cil_tmp48, wr, hr, max);
#line 2212
    red = (image->comps + compno)->data;
    }
#line 2213
    if ((image->comps + compno)->sgnd) {
#line 2213
      tmp___72 = 1 << ((image->comps + compno)->prec - 1U);
    } else {
#line 2213
      tmp___72 = 0;
    }
#line 2213
    adjustR = tmp___72;
#line 2216
    if (prec > 8) {
#line 2217
      i = 0;
      {
#line 2217
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 2217
        if (! (i < wr * hr)) {
#line 2217
          goto while_break___2;
        }
#line 2218
        v = *red + adjustR;
#line 2219
        red ++;
#line 2220
        if (v > 65535) {
#line 2221
          v = 65535;
        } else
#line 2222
        if (v < 0) {
#line 2223
          v = 0;
        }
        {
#line 2227
        fprintf(fdest, "%c%c V", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 2229
        if (has_alpha) {
#line 2230
          __cil_tmp50 = alpha;
#line 2230
          alpha ++;
#line 2230
          v = *__cil_tmp50;
#line 2231
          if (v > 65535) {
#line 2232
            v = 65535;
          } else
#line 2233
          if (v < 0) {
#line 2234
            v = 0;
          }
          {
#line 2238
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2217
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: ;
    } else {
#line 2242
      i = 0;
      {
#line 2242
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 2242
        if (! (i < wr * hr)) {
#line 2242
          goto while_break___3;
        }
#line 2243
        v = *red + adjustR;
#line 2244
        red ++;
#line 2245
        if (v > 255) {
#line 2246
          v = 255;
        } else
#line 2247
        if (v < 0) {
#line 2248
          v = 0;
        }
        {
#line 2251
        fprintf(fdest, "%c", (int )((unsigned char )v));
#line 2242
        i ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: ;
    }
    {
#line 2254
    fclose(fdest);
#line 2186
    compno ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 2256
  free((void *)destname);
  }
#line 2258
  return (0);
}
}
#line 2266 "/root/patron/new_24/src/bin/jp2/convert.c"
static opj_image_t *rawtoimage_common(char const   *filename , opj_cparameters_t *parameters ,
                                      raw_cparameters_t *raw_cp , OPJ_BOOL big_endian ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *f ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t *cmptparm ;
  opj_image_t *image ;
  unsigned short ch ;
  void *__cil_tmp18 ;
  unsigned char value ;
  int nloop ;
  unsigned long __cil_tmp23 ;
  int tmp ;
  unsigned short value___0 ;
  int nloop___0 ;
  unsigned char temp1 ;
  unsigned char temp2 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int tmp___0 ;
  unsigned long __cil_tmp36 ;

  {
#line 2269
  subsampling_dx = parameters->subsampling_dx;
#line 2270
  subsampling_dy = parameters->subsampling_dy;
#line 2272
  f = (FILE *)((void *)0);
#line 2276
  image = (opj_image_t *)((void *)0);
#line 2279
  if (! (((raw_cp->rawWidth & raw_cp->rawHeight) & raw_cp->rawComp) & raw_cp->rawBitDepth) == 0) {
    {
#line 2281
    fprintf(stderr, "\nError: invalid raw image parameters\n");
#line 2282
    fprintf(stderr, "Please use the Format option -F:\n");
#line 2283
    fprintf(stderr, "-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\n\004q3 V");
#line 2285
    fprintf(stderr, "If subsampling is omitted, 1x1 is assumed for all components\n");
#line 2287
    fprintf(stderr, "Example: -i image.raw -o image.j2k -F 512,512,3,8,u@1x1:2x2:2x2\n\220");
#line 2289
    fprintf(stderr, "         for raw 512x512 image with 4:2:0 subsampling\n");
#line 2290
    fprintf(stderr, "Aborting.\nq3 V");
    }
#line 2291
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2294
  f = fopen(filename, "rbq3 V");
  }
#line 2295
  if (! f) {
    {
#line 2296
    fprintf(stderr, "Failed to open %s for reading !!\n", filename);
#line 2297
    fprintf(stderr, "Aborting\n");
    }
#line 2298
    return ((opj_image_t *)((void *)0));
  }
#line 2300
  numcomps = raw_cp->rawComp;
#line 2303
  if (numcomps == 1) {
#line 2304
    color_space = (OPJ_COLOR_SPACE )2;
  } else
#line 2305
  if (numcomps >= 3) {
#line 2305
    if ((int )parameters->tcp_mct == 0) {
#line 2306
      color_space = (OPJ_COLOR_SPACE )3;
    } else {
#line 2305
      goto _L;
    }
  } else
  _L: 
#line 2307
  if (numcomps >= 3) {
#line 2307
    if ((int )parameters->tcp_mct != 2) {
#line 2308
      color_space = (OPJ_COLOR_SPACE )1;
    } else {
#line 2310
      color_space = (OPJ_COLOR_SPACE )-1;
    }
  } else {
#line 2310
    color_space = (OPJ_COLOR_SPACE )-1;
  }
  {
#line 2312
  w = raw_cp->rawWidth;
#line 2313
  h = raw_cp->rawHeight;
#line 2314
  __cil_tmp18 = calloc((unsigned long )((OPJ_UINT32 )numcomps), sizeof(opj_image_cmptparm_t ));
#line 2314
  cmptparm = (opj_image_cmptparm_t *)__cil_tmp18;
  }
#line 2316
  if (! cmptparm) {
    {
#line 2317
    fprintf(stderr, "Failed to allocate image components parameters !!\n");
#line 2318
    fprintf(stderr, "Aborting\n%q3 V");
#line 2319
    fclose(f);
    }
#line 2320
    return ((opj_image_t *)((void *)0));
  }
#line 2323
  i = 0;
  {
#line 2323
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2323
    if (! (i < numcomps)) {
#line 2323
      goto while_break;
    }
#line 2324
    (cmptparm + i)->prec = (OPJ_UINT32 )raw_cp->rawBitDepth;
#line 2325
    (cmptparm + i)->bpp = (OPJ_UINT32 )raw_cp->rawBitDepth;
#line 2326
    (cmptparm + i)->sgnd = (OPJ_UINT32 )raw_cp->rawSigned;
#line 2327
    (cmptparm + i)->dx = (OPJ_UINT32 )(subsampling_dx * (raw_cp->rawComps + i)->dx);
#line 2328
    (cmptparm + i)->dy = (OPJ_UINT32 )(subsampling_dy * (raw_cp->rawComps + i)->dy);
#line 2329
    (cmptparm + i)->w = (OPJ_UINT32 )w;
#line 2330
    (cmptparm + i)->h = (OPJ_UINT32 )h;
#line 2323
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2333
  image = opj_image_create((OPJ_UINT32 )numcomps, cmptparm + 0, color_space);
#line 2334
  free((void *)cmptparm);
  }
#line 2335
  if (! image) {
    {
#line 2336
    fclose(f);
    }
#line 2337
    return ((opj_image_t *)((void *)0));
  }
#line 2340
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 2341
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 2342
  image->x1 = ((OPJ_UINT32 )parameters->image_offset_x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
#line 2344
  image->y1 = ((OPJ_UINT32 )parameters->image_offset_y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
#line 2347
  if (raw_cp->rawBitDepth <= 8) {
#line 2348
    value = (unsigned char)0;
#line 2349
    compno = 0;
    {
#line 2349
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2349
      if (! (compno < numcomps)) {
#line 2349
        goto while_break___0;
      }
#line 2350
      nloop = (w * h) / ((raw_cp->rawComps + compno)->dx * (raw_cp->rawComps + compno)->dy);
#line 2352
      i = 0;
      {
#line 2352
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2352
        if (! (i < nloop)) {
#line 2352
          goto while_break___1;
        }
        {
#line 2353
        __cil_tmp23 = fread((void *)(& value), 1UL, 1UL, f);
        }
#line 2353
        if (! __cil_tmp23) {
          {
#line 2354
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2355
          opj_image_destroy(image);
#line 2356
          fclose(f);
          }
#line 2357
          return ((opj_image_t *)((void *)0));
        }
#line 2359
        if (raw_cp->rawSigned) {
#line 2359
          tmp = (int )((char )value);
        } else {
#line 2359
          tmp = (int )value;
        }
#line 2359
        *((image->comps + compno)->data + i) = tmp;
#line 2352
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 2349
      compno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
  } else
#line 2362
  if (raw_cp->rawBitDepth <= 16) {
#line 2364
    compno = 0;
    {
#line 2364
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 2364
      if (! (compno < numcomps)) {
#line 2364
        goto while_break___2;
      }
#line 2365
      nloop___0 = (w * h) / ((raw_cp->rawComps + compno)->dx * (raw_cp->rawComps + compno)->dy);
#line 2367
      i = 0;
      {
#line 2367
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 2367
        if (! (i < nloop___0)) {
#line 2367
          goto while_break___3;
        }
        {
#line 2370
        __cil_tmp31 = fread((void *)(& temp1), 1UL, 1UL, f);
        }
#line 2370
        if (! __cil_tmp31) {
          {
#line 2371
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2372
          opj_image_destroy(image);
#line 2373
          fclose(f);
          }
#line 2374
          return ((opj_image_t *)((void *)0));
        }
        {
#line 2376
        __cil_tmp32 = fread((void *)(& temp2), 1UL, 1UL, f);
        }
#line 2376
        if (! __cil_tmp32) {
          {
#line 2377
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2378
          opj_image_destroy(image);
#line 2379
          fclose(f);
          }
#line 2380
          return ((opj_image_t *)((void *)0));
        }
#line 2382
        if (big_endian) {
#line 2383
          value___0 = (unsigned short )(((int )temp1 << 8) + (int )temp2);
        } else {
#line 2385
          value___0 = (unsigned short )(((int )temp2 << 8) + (int )temp1);
        }
#line 2387
        if (raw_cp->rawSigned) {
#line 2387
          tmp___0 = (int )((short )value___0);
        } else {
#line 2387
          tmp___0 = (int )value___0;
        }
#line 2387
        *((image->comps + compno)->data + i) = tmp___0;
#line 2367
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 2364
      compno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
  } else {
    {
#line 2391
    fprintf(stderr, "OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\nq3 V");
#line 2393
    opj_image_destroy(image);
#line 2394
    fclose(f);
    }
#line 2395
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2398
  __cil_tmp36 = fread((void *)(& ch), 1UL, 1UL, f);
  }
#line 2398
  if (__cil_tmp36) {
    {
#line 2399
    fprintf(stderr, "Warning. End of raw file not reached... processing anyway\nq3 V");
    }
  }
  {
#line 2401
  fclose(f);
  }
#line 2403
  return (image);
}
}
#line 2406 "/root/patron/new_24/src/bin/jp2/convert.c"
opj_image_t *rawltoimage(char const   *filename , opj_cparameters_t *parameters ,
                         raw_cparameters_t *raw_cp ) 
{ 
  opj_image_t *__cil_tmp4 ;

  {
  {
#line 2409
  __cil_tmp4 = rawtoimage_common(filename, parameters, raw_cp, 0);
  }
#line 2409
  return (__cil_tmp4);
}
}
#line 2412 "/root/patron/new_24/src/bin/jp2/convert.c"
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) 
{ 
  opj_image_t *__cil_tmp4 ;

  {
  {
#line 2415
  __cil_tmp4 = rawtoimage_common(filename, parameters, raw_cp, 1);
  }
#line 2415
  return (__cil_tmp4);
}
}
#line 2418 "/root/patron/new_24/src/bin/jp2/convert.c"
static int imagetoraw_common(opj_image_t *image , char const   *outfile , OPJ_BOOL big_endian ) 
{ 
  FILE *rawFile ;
  size_t res ;
  unsigned int compno ;
  unsigned int numcomps ;
  int w ;
  int h ;
  int fails ;
  int line ;
  int row ;
  int curr ;
  int mask ;
  int *ptr ;
  unsigned char uc ;
  char const   *tmp ;

  {
#line 2421
  rawFile = (FILE *)((void *)0);
#line 2430
  if ((image->numcomps * image->x1) * image->y1 == 0U) {
    {
#line 2431
    fprintf(stderr, "\nError: invalid raw image parameters\n");
    }
#line 2432
    return (1);
  }
#line 2435
  numcomps = image->numcomps;
#line 2437
  if (numcomps > 4U) {
#line 2438
    numcomps = 4U;
  }
#line 2441
  compno = 1U;
  {
#line 2441
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2441
    if (! (compno < numcomps)) {
#line 2441
      goto while_break;
    }
#line 2442
    if ((image->comps + 0)->dx != (image->comps + compno)->dx) {
#line 2443
      goto while_break;
    }
#line 2445
    if ((image->comps + 0)->dy != (image->comps + compno)->dy) {
#line 2446
      goto while_break;
    }
#line 2448
    if ((image->comps + 0)->prec != (image->comps + compno)->prec) {
#line 2449
      goto while_break;
    }
#line 2451
    if ((image->comps + 0)->sgnd != (image->comps + compno)->sgnd) {
#line 2452
      goto while_break;
    }
#line 2441
    compno ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: ;
#line 2455
  if (compno != numcomps) {
    {
#line 2456
    fprintf(stderr, "imagetoraw_common: All components shall have the same subsampling, same bit depth, same sign.\n");
#line 2458
    fprintf(stderr, "\tAborting\nq3 V");
    }
#line 2459
    return (1);
  }
  {
#line 2462
  rawFile = fopen(outfile, "wb");
  }
#line 2463
  if (! rawFile) {
    {
#line 2464
    fprintf(stderr, "Failed to open %s for writing !!\n", outfile);
    }
#line 2465
    return (1);
  }
  {
#line 2468
  fails = 1;
#line 2469
  fprintf(stdout, "Raw image characteristics: %d components\n", image->numcomps);
#line 2471
  compno = 0U;
  }
  {
#line 2471
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2471
    if (! (compno < image->numcomps)) {
#line 2471
      goto while_break___0;
    }
#line 2472
    if ((image->comps + compno)->sgnd == 1U) {
      {
#line 2472
      strcpy((char *)tmp, "signed");
      }
    } else {
      {
#line 2472
      strcpy((char *)tmp, "unsigned\220");
      }
    }
    {
#line 2472
    fprintf(stdout, "Component %u characteristics: %dx%dx%d %s\n", compno, (image->comps + compno)->w,
            (image->comps + compno)->h, (image->comps + compno)->prec, tmp);
#line 2477
    w = (int )(image->comps + compno)->w;
#line 2478
    h = (int )(image->comps + compno)->h;
    }
#line 2480
    if ((image->comps + compno)->prec <= 8U) {
#line 2481
      if ((image->comps + compno)->sgnd == 1U) {
#line 2482
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2483
        ptr = (image->comps + compno)->data;
#line 2484
        line = 0;
        {
#line 2484
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 2484
          if (! (line < h)) {
#line 2484
            goto while_break___1;
          }
#line 2485
          row = 0;
          {
#line 2485
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 2485
            if (! (row < w)) {
#line 2485
              goto while_break___2;
            }
#line 2486
            curr = *ptr;
#line 2487
            if (curr > 127) {
#line 2488
              curr = 127;
            } else
#line 2489
            if (curr < -128) {
#line 2490
              curr = -128;
            }
            {
#line 2492
            uc = (unsigned char )(curr & mask);
#line 2493
            res = fwrite((void const   *)(& uc), 1UL, 1UL, rawFile);
            }
#line 2494
            if (res < 1UL) {
              {
#line 2495
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2496
              goto fin;
            }
#line 2498
            ptr ++;
#line 2485
            row ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___2: 
#line 2484
          line ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___1: ;
      } else
#line 2501
      if ((image->comps + compno)->sgnd == 0U) {
#line 2502
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2503
        ptr = (image->comps + compno)->data;
#line 2504
        line = 0;
        {
#line 2504
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 2504
          if (! (line < h)) {
#line 2504
            goto while_break___3;
          }
#line 2505
          row = 0;
          {
#line 2505
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 2505
            if (! (row < w)) {
#line 2505
              goto while_break___4;
            }
#line 2506
            curr = *ptr;
#line 2507
            if (curr > 255) {
#line 2508
              curr = 255;
            } else
#line 2509
            if (curr < 0) {
#line 2510
              curr = 0;
            }
            {
#line 2512
            uc = (unsigned char )(curr & mask);
#line 2513
            res = fwrite((void const   *)(& uc), 1UL, 1UL, rawFile);
            }
#line 2514
            if (res < 1UL) {
              {
#line 2515
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2516
              goto fin;
            }
#line 2518
            ptr ++;
#line 2505
            row ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___4: 
#line 2504
          line ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___3: ;
      }
    } else
#line 2522
    if ((image->comps + compno)->prec <= 16U) {
#line 2523
      if ((image->comps + compno)->sgnd == 1U) {
#line 2528
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2529
        ptr = (image->comps + compno)->data;
#line 2530
        line = 0;
        {
#line 2530
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 2530
          if (! (line < h)) {
#line 2530
            goto while_break___5;
          }
#line 2531
          row = 0;
          {
#line 2531
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 2531
            if (! (row < w)) {
#line 2531
              goto while_break___6;
            }
#line 2532
            curr = *ptr;
#line 2533
            if (curr > 32767) {
#line 2534
              curr = 32767;
            } else
#line 2535
            if (curr < -32768) {
#line 2536
              curr = -32768;
            }
#line 2544
            ptr ++;
#line 2531
            row ++;
          }
          while_break___16: /* CIL Label */ ;
          }
          while_break___6: 
#line 2530
          line ++;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___5: ;
      } else
#line 2547
      if ((image->comps + compno)->sgnd == 0U) {
#line 2552
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2553
        ptr = (image->comps + compno)->data;
#line 2554
        line = 0;
        {
#line 2554
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 2554
          if (! (line < h)) {
#line 2554
            goto while_break___7;
          }
#line 2555
          row = 0;
          {
#line 2555
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 2555
            if (! (row < w)) {
#line 2555
              goto while_break___8;
            }
#line 2556
            curr = *ptr;
#line 2557
            if (curr > 65535) {
#line 2558
              curr = 65535;
            } else
#line 2559
            if (curr < 0) {
#line 2560
              curr = 0;
            }
#line 2568
            ptr ++;
#line 2555
            row ++;
          }
          while_break___18: /* CIL Label */ ;
          }
          while_break___8: 
#line 2554
          line ++;
        }
        while_break___17: /* CIL Label */ ;
        }
        while_break___7: ;
      }
    } else
#line 2572
    if ((image->comps + compno)->prec <= 32U) {
      {
#line 2573
      fprintf(stderr, "More than 16 bits per component not handled yet\n\220");
      }
#line 2574
      goto fin;
    } else {
      {
#line 2576
      fprintf(stderr, "Error: invalid precision: %d\n", (image->comps + compno)->prec);
      }
#line 2577
      goto fin;
    }
#line 2471
    compno ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___0: 
#line 2580
  fails = 0;
  fin: 
  {
#line 2582
  fclose(rawFile);
  }
#line 2583
  return (fails);
}
}
#line 2586 "/root/patron/new_24/src/bin/jp2/convert.c"
int imagetoraw(opj_image_t *image , char const   *outfile ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 2588
  __cil_tmp3 = imagetoraw_common(image, outfile, 1);
  }
#line 2588
  return (__cil_tmp3);
}
}
#line 2591 "/root/patron/new_24/src/bin/jp2/convert.c"
int imagetorawl(opj_image_t *image , char const   *outfile ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 2593
  __cil_tmp3 = imagetoraw_common(image, outfile, 0);
  }
#line 2593
  return (__cil_tmp3);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 21 "/root/patron/new_24/src/bin/common/opj_getopt.h"
extern char *opj_optarg ;
#line 24
extern int opj_getopt_long(int argc , char * const  *argv , char const   *optstring ,
                           opj_option_t *longopts , int totlen ) ;
#line 26
extern void opj_reset_options_reading(void) ;
#line 41 "/root/patron/new_24/src/bin/common/color.h"
extern void color_sycc_to_rgb(opj_image_t *img ) ;
#line 45
extern void color_cmyk_to_rgb(opj_image_t *image ) ;
#line 46
extern void color_esycc_to_rgb(opj_image_t *image ) ;
#line 40 "/root/patron/new_24/src/bin/common/opj_string.h"
static size_t opj_strnlen_s(char const   *src , size_t max_len ) 
{ 
  size_t len ;
  char const   *__cil_tmp4 ;
  size_t __cil_tmp5 ;

  {
#line 44
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 45
    return ((size_t )0U);
  }
#line 47
  len = (size_t )0U;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;

#line 47
    if ((int )*src != 0) {
#line 47
      if (! (len < max_len)) {
#line 47
        goto while_break;
      }
    } else {
#line 47
      goto while_break;
    }
#line 47
    __cil_tmp5 = len;
#line 47
    len ++;
#line 47
    __cil_tmp4 = src;
#line 47
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 48
  return (len);
}
}
#line 53 "/root/patron/new_24/src/bin/common/opj_string.h"
static int opj_strcpy_s(char *dst , size_t dst_size , char const   *src ) 
{ 
  size_t src_len ;

  {
#line 55
  src_len = (size_t )0U;
#line 56
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 57
    return (22);
  } else
#line 56
  if (dst_size == 0UL) {
#line 57
    return (22);
  }
#line 59
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 60
    *(dst + 0) = (char )'\000';
#line 61
    return (22);
  }
  {
#line 63
  src_len = opj_strnlen_s(src, dst_size);
  }
#line 64
  if (src_len >= dst_size) {
#line 65
    return (34);
  }
  {
#line 67
  memcpy((void *)dst, (void const   *)src, src_len);
#line 68
  *(dst + src_len) = (char )'\000';
  }
#line 69
  return (0);
}
}
#line 159 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
int get_num_images(char *imgdirpath ) ;
#line 160
int load_images(dircnt_t *dirptr , char *imgdirpath ) ;
#line 161
int get_file_format(char const   *filename ) ;
#line 162
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_decompress_parameters *parameters ) ;
#line 164
static int infile_format(char const   *fname ) ;
#line 166
int parse_cmdline_decoder(int argc , char **argv , opj_decompress_parameters *parameters ,
                          img_fol_t *img_fol ) ;
#line 168
int parse_DA_values(char *inArg , unsigned int *DA_x0 , unsigned int *DA_y0 , unsigned int *DA_x1 ,
                    unsigned int *DA_y1 ) ;
#line 171
static opj_image_t *convert_gray_to_rgb(opj_image_t *original ) ;
#line 174 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static void decode_help_display(void) 
{ 
  char const   *__cil_tmp1 ;
  OPJ_BOOL __cil_tmp2 ;

  {
  {
#line 176
  __cil_tmp1 = opj_version();
#line 176
  fprintf(stdout, "\nThis is the opj_decompress utility from the OpenJPEG project.\nIt decompresses JPEG 2000 codestreams to various image formats.\nIt has been compiled against openjp2 library v%s.\n\n",
          __cil_tmp1);
#line 181
  fprintf(stdout, "Parameters:\n-----------\n\n  -ImgDir <directory> \n\tImage file Directory path \n  -OutFor <PBM|PGM|PPM|PNM|PAM|PGX|PNG|BMP|TIF|RAW|RAWL|TGA>\n    REQUIRED only if -ImgDir is used\n\tOutput format for decompressed images.\n");
#line 189
  fprintf(stdout, "  -i <compressed file>\n    REQUIRED only if an Input image directory is not specified\n    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n    is identified based on its suffix.\n");
#line 193
  fprintf(stdout, "  -o <decompressed file>\n    REQUIRED\n    Currently accepts formats specified above (see OutFor option)\n    Binary data is written to the file (not ascii). If a PGX\n    filename is given, there will be as many output files as there are\n    components: an indice starting from 0 will then be appended to the\n    output filename, just before the \"pgx\" extension. If a PGM filename\n    is given and there are more than one component, only the first component\n    will be written to the file.\n");
#line 202
  fprintf(stdout, "  -r <reduce factor>\n    Set the number of highest resolution levels to be discarded. The\n    image resolution is effectively divided by 2 to the power of the\n    number of discarded levels. The reduce factor is limited by the\n    smallest total number of decomposition levels among tiles.\n  -l <number of quality layers to decode>\n    Set the maximum number of quality layers to decode. If there are\n    less quality layers than the specified number, all the quality layers\n    are decoded.\n");
#line 211
  fprintf(stdout, "  -x  \n    Create an index file *.Idx (-x index_name.Idx) \n  -d <x0,y0,x1,y1>\n    OPTIONAL\n    Decoding area\n    By default all the image is decoded.\n  -t <tile_number>\n    OPTIONAL\n    Set the tile number of the decoded tile. Follow the JPEG2000 convention from left-up to bottom-up\n    By default all tiles are decoded.\n");
#line 221
  fprintf(stdout, "  -p <comp 0 precision>[C|S][,<comp 1 precision>[C|S][,...]]\n    OPTIONAL\n    Force the precision (bit depth) of components.\n");
#line 224
  fprintf(stdout, "    There shall be at least 1 value. Theres no limit on the number of values (comma separated, last values ignored if too much values).\n    If there are less values than components, the last value is used for remaining components.\n    If \'C\' is specified (default), values are clipped.\n    If \'S\' is specified, values are scaled.\n    A 0 value can be specified (meaning original bit depth).\n");
#line 230
  fprintf(stdout, "  -force-rgb\n    Force output image colorspace to RGB\n  -upsample\n    Downsampled components will be upsampled to image size\n  -split-pnm\n    Split output components to different files when writing to PNM\n");
#line 236
  __cil_tmp2 = opj_has_thread_support();
  }
#line 236
  if (__cil_tmp2) {
    {
#line 237
    fprintf(stdout, "  -threads <num_threads>\n    Number of threads to use for decoding.\n\220");
    }
  }
  {
#line 240
  fprintf(stdout, "  -quiet\n    Disable output from the library and other output.\n");
#line 253
  fprintf(stdout, "\n");
  }
#line 255
  return;
}
}
#line 258 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static OPJ_BOOL parse_precision(char const   *option , opj_decompress_parameters *parameters ) 
{ 
  char const   *l_remaining ;
  OPJ_BOOL l_result ;
  int prec ;
  char mode ;
  char comma ;
  int count ;
  void *__cil_tmp11 ;
  OPJ_UINT32 l_new_size ;
  opj_precision *l_new ;
  void *__cil_tmp14 ;
  char *__cil_tmp16 ;

  {
#line 261
  l_remaining = option;
#line 262
  l_result = 1;
#line 265
  if (parameters->precision) {
    {
#line 266
    free((void *)parameters->precision);
#line 267
    parameters->precision = (opj_precision *)((void *)0);
    }
  }
#line 269
  parameters->nb_precision = 0U;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 277
    count = sscanf(l_remaining, "%d%c%c", & prec, & mode, & comma);
    }
#line 278
    if (count == 1) {
#line 279
      mode = (char )'C';
#line 280
      count ++;
    }
#line 282
    if (count == 2) {
      _L: 
#line 283
      if ((int )mode == 44) {
#line 284
        mode = (char )'C';
      }
#line 286
      comma = (char )',';
#line 287
      count = 3;
    } else
#line 282
    if ((int )mode == 44) {
#line 282
      goto _L;
    }
#line 289
    if (count == 3) {
#line 290
      if (prec < 1) {
        {
#line 291
        fprintf(stderr, "Invalid precision %d in precision option %s\n", prec, option);
#line 292
        l_result = 0;
        }
#line 293
        goto while_break;
      } else
#line 290
      if (prec > 32) {
        {
#line 291
        fprintf(stderr, "Invalid precision %d in precision option %s\n", prec, option);
#line 292
        l_result = 0;
        }
#line 293
        goto while_break;
      }
#line 295
      if ((int )mode != 67) {
#line 295
        if ((int )mode != 83) {
          {
#line 296
          fprintf(stderr, "Invalid precision mode %c in precision option %s\n", (int )mode,
                  option);
#line 298
          l_result = 0;
          }
#line 299
          goto while_break;
        }
      }
#line 301
      if ((int )comma != 44) {
        {
#line 302
        fprintf(stderr, "Invalid character %c in precision option %s\n", (int )comma,
                option);
#line 303
        l_result = 0;
        }
#line 304
        goto while_break;
      }
#line 307
      if ((unsigned long )parameters->precision == (unsigned long )((void *)0)) {
        {
#line 309
        __cil_tmp11 = malloc(sizeof(opj_precision ));
#line 309
        parameters->precision = (opj_precision *)__cil_tmp11;
        }
#line 310
        if ((unsigned long )parameters->precision == (unsigned long )((void *)0)) {
          {
#line 311
          fprintf(stderr, "Could not allocate memory for precision option\n");
#line 312
          l_result = 0;
          }
#line 313
          goto while_break;
        }
      } else {
#line 316
        l_new_size = parameters->nb_precision + 1U;
#line 319
        if (l_new_size == 0U) {
          {
#line 320
          fprintf(stderr, "Could not allocate memory for precision option\n");
#line 321
          l_result = 0;
          }
#line 322
          goto while_break;
        }
        {
#line 325
        __cil_tmp14 = realloc((void *)parameters->precision, (unsigned long )l_new_size * sizeof(opj_precision ));
#line 325
        l_new = (opj_precision *)__cil_tmp14;
        }
#line 327
        if ((unsigned long )l_new == (unsigned long )((void *)0)) {
          {
#line 328
          fprintf(stderr, "Could not allocate memory for precision option\n");
#line 329
          l_result = 0;
          }
#line 330
          goto while_break;
        }
#line 332
        parameters->precision = l_new;
      }
#line 335
      (parameters->precision + parameters->nb_precision)->prec = (OPJ_UINT32 )prec;
#line 337
      if ((int )mode == 67) {
#line 337
        goto case_67;
      }
#line 340
      if ((int )mode == 83) {
#line 340
        goto case_83;
      }
#line 343
      goto switch_default;
      case_67: 
#line 338
      (parameters->precision + parameters->nb_precision)->mode = (opj_precision_mode )0;
#line 339
      goto switch_break;
      case_83: 
#line 341
      (parameters->precision + parameters->nb_precision)->mode = (opj_precision_mode )1;
#line 342
      goto switch_break;
      switch_default: 
#line 344
      goto switch_break;
      switch_break: 
      {
#line 346
      (parameters->nb_precision) ++;
#line 348
      __cil_tmp16 = strchr(l_remaining, ',');
#line 348
      l_remaining = (char const   *)__cil_tmp16;
      }
#line 349
      if ((unsigned long )l_remaining == (unsigned long )((void *)0)) {
#line 350
        goto while_break;
      }
#line 352
      l_remaining ++;
    } else {
      {
#line 354
      fprintf(stderr, "Could not parse precision option %s\n", option);
#line 355
      l_result = 0;
      }
#line 356
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 360
  return (l_result);
}
}
#line 365 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int num_images ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 369
  num_images = 0;
#line 373
  dir = opendir((char const   *)imgdirpath);
  }
#line 374
  if (! dir) {
    {
#line 375
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 376
    return (0);
  }
  {
#line 379
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 379
    content = readdir(dir);
    }
#line 379
    if (! ((unsigned long )content != (unsigned long )((void *)0))) {
#line 379
      goto while_break;
    }
    {
#line 380
    __cil_tmp8 = strcmp("..", (char const   *)(content->d_name));
#line 380
    __cil_tmp7 = strcmp(".", (char const   *)(content->d_name));
    }
#line 380
    if (__cil_tmp7 == 0) {
#line 381
      goto while_continue;
    } else
#line 380
    if (__cil_tmp8 == 0) {
#line 381
      goto while_continue;
    }
#line 383
    num_images ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 385
  closedir(dir);
  }
#line 386
  return (num_images);
}
}
#line 390 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
int load_images(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 394
  i = 0;
#line 398
  dir = opendir((char const   *)imgdirpath);
  }
#line 399
  if (! dir) {
    {
#line 400
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 401
    return (1);
  } else {
    {
#line 403
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 406
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 406
    content = readdir(dir);
    }
#line 406
    if (! ((unsigned long )content != (unsigned long )((void *)0))) {
#line 406
      goto while_break;
    }
    {
#line 407
    __cil_tmp9 = strcmp("..\2103 V", (char const   *)(content->d_name));
#line 407
    __cil_tmp8 = strcmp(".", (char const   *)(content->d_name));
    }
#line 407
    if (__cil_tmp8 == 0) {
#line 408
      goto while_continue;
    } else
#line 407
    if (__cil_tmp9 == 0) {
#line 408
      goto while_continue;
    }
    {
#line 411
    strcpy(*(dirptr->filename + i), (char const   *)(content->d_name));
#line 412
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 414
  closedir(dir);
  }
#line 415
  return (0);
}
}
#line 422 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static char const   *extension[15]  ;
#line 423 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static int const   format[15]  ;
#line 419 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
int get_file_format(char const   *filename ) 
{ 
  unsigned int i ;
  char const   *ext ;
  char *__cil_tmp6 ;
  int __cil_tmp8 ;

  {
  {
#line 422
  strcpy((char *)extension[0], "pgx3 V");
#line 422
  strcpy((char *)extension[1], "pnm3 V");
#line 422
  strcpy((char *)extension[2], "pgm3 V");
#line 422
  strcpy((char *)extension[3], "ppm3 V");
#line 422
  strcpy((char *)extension[4], "bmp3 V");
#line 422
  strcpy((char *)extension[5], "tif3 V");
#line 422
  strcpy((char *)extension[6], "raw3 V");
#line 422
  strcpy((char *)extension[7], "rawl V");
#line 422
  strcpy((char *)extension[8], "tga");
#line 422
  strcpy((char *)extension[9], "png");
#line 422
  strcpy((char *)extension[10], "j2k");
#line 422
  strcpy((char *)extension[11], "jp23 V");
#line 422
  strcpy((char *)extension[12], "jpt3 V");
#line 422
  strcpy((char *)extension[13], "j2c3 V");
#line 422
  strcpy((char *)extension[14], "jpc");
#line 423
  format[0] = (int const   )11;
#line 423
  format[1] = (int const   )10;
#line 423
  format[2] = (int const   )10;
#line 423
  format[3] = (int const   )10;
#line 423
  format[4] = (int const   )12;
#line 423
  format[5] = (int const   )14;
#line 423
  format[6] = (int const   )15;
#line 423
  format[7] = (int const   )18;
#line 423
  format[8] = (int const   )16;
#line 423
  format[9] = (int const   )17;
#line 423
  format[10] = (int const   )0;
#line 423
  format[11] = (int const   )1;
#line 423
  format[12] = (int const   )2;
#line 423
  format[13] = (int const   )0;
#line 423
  format[14] = (int const   )0;
#line 424
  __cil_tmp6 = strrchr(filename, '.');
#line 424
  ext = (char const   *)__cil_tmp6;
  }
#line 425
  if ((unsigned long )ext == (unsigned long )((void *)0)) {
#line 426
    return (-1);
  }
#line 428
  ext ++;
#line 429
  if (*ext) {
#line 430
    i = 0U;
    {
#line 430
    while (1) {
      while_continue: /* CIL Label */ ;

#line 430
      if (! ((unsigned long )i < sizeof(format) / sizeof(format[0]))) {
#line 430
        goto while_break;
      }
      {
#line 431
      __cil_tmp8 = strcasecmp(ext, extension[i]);
      }
#line 431
      if (__cil_tmp8 == 0) {
#line 432
        return ((int )format[i]);
      }
#line 430
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 437
  return (-1);
}
}
#line 443 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
char const   *path_separator  =    "/\361\2073 V";
#line 447 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_decompress_parameters *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  int __cil_tmp15 ;

  {
  {
#line 452
  strcpy(temp1, "\002");
#line 454
  strcpy(image_filename, (char const   *)*(dirptr->filename + imageno));
#line 455
  fprintf(stderr, "File Number %d \"%s\"\n V", imageno, image_filename);
#line 456
  sprintf(infilename, "%s%s%s", img_fol->imgdirpath, path_separator, image_filename);
#line 458
  parameters->decod_format = infile_format((char const   *)(infilename));
  }
#line 459
  if (parameters->decod_format == -1) {
#line 460
    return ((char)1);
  }
  {
#line 462
  __cil_tmp12 = opj_strcpy_s(parameters->infile, sizeof(parameters->infile), (char const   *)(infilename));
  }
#line 462
  if (__cil_tmp12 != 0) {
#line 464
    return ((char)1);
  }
  {
#line 468
  __cil_tmp13 = strtok(image_filename, ".");
#line 468
  strcpy(temp_ofname, (char const   *)__cil_tmp13);
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 469
    temp_p = strtok((char *)((void *)0), ".");
    }
#line 469
    if (! ((unsigned long )temp_p != (unsigned long )((void *)0))) {
#line 469
      goto while_break;
    }
    {
#line 470
    strcat(temp_ofname, (char const   *)(temp1));
#line 471
    sprintf(temp1, ".%s", temp_p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 473
  if ((int )img_fol->set_out_format == 1) {
    {
#line 474
    sprintf(outfilename, "%s/%s.%s\230\001", img_fol->imgdirpath, temp_ofname, img_fol->out_format);
#line 476
    __cil_tmp15 = opj_strcpy_s(parameters->outfile, sizeof(parameters->outfile), (char const   *)(outfilename));
    }
#line 476
    if (__cil_tmp15 != 0) {
#line 478
      return ((char)1);
    }
  }
#line 481
  return ((char)0);
}
}
#line 490 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static int infile_format(char const   *fname ) 
{ 
  FILE *reader ;
  char const   *s ;
  char const   *magic_s ;
  int ext_format ;
  int magic_format ;
  unsigned char buf[12] ;
  OPJ_SIZE_T l_nb_read ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;

  {
  {
#line 498
  reader = fopen(fname, "rb");
  }
#line 500
  if ((unsigned long )reader == (unsigned long )((void *)0)) {
#line 501
    return (-2);
  }
  {
#line 504
  memset((void *)(buf), 0, 12UL);
#line 505
  l_nb_read = fread((void *)(buf), 1UL, 12UL, reader);
#line 506
  fclose(reader);
  }
#line 507
  if (l_nb_read != 12UL) {
#line 508
    return (-1);
  }
  {
#line 513
  ext_format = get_file_format(fname);
  }
#line 515
  if (ext_format == 2) {
#line 516
    return (2);
  }
  {
#line 519
  __cil_tmp13 = memcmp((void const   *)(buf), (void const   *)"\r\n\207\n", 4UL);
#line 519
  __cil_tmp12 = memcmp((void const   *)(buf), (void const   *)"", 12UL);
  }
#line 519
  if (__cil_tmp12 == 0) {
    {
#line 520
    magic_format = 1;
#line 521
    strcpy((char *)magic_s, ".jp2");
    }
  } else
#line 519
  if (__cil_tmp13 == 0) {
    {
#line 520
    magic_format = 1;
#line 521
    strcpy((char *)magic_s, ".jp2");
    }
  } else {
    {
#line 522
    __cil_tmp14 = memcmp((void const   *)(buf), (void const   *)"\377O\377Q", 4UL);
    }
#line 522
    if (__cil_tmp14 == 0) {
      {
#line 523
      magic_format = 0;
#line 524
      strcpy((char *)magic_s, ".j2k or .jpc or .j2c");
      }
    } else {
#line 526
      return (-1);
    }
  }
#line 529
  if (magic_format == ext_format) {
#line 530
    return (ext_format);
  }
  {
#line 533
  __cil_tmp15 = strlen(fname);
#line 533
  s = (fname + __cil_tmp15) - 4;
#line 535
  fputs("\n===========================================\n", stderr);
#line 536
  fprintf(stderr, "The extension of this file is incorrect.\nFOUND %s. SHOULD BE %s\n",
          s, magic_s);
#line 538
  fputs("===========================================\n", stderr);
  }
#line 540
  return (magic_format);
}
}
#line 548 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
int parse_cmdline_decoder(int argc , char **argv , opj_decompress_parameters *parameters ,
                          img_fol_t *img_fol ) 
{ 
  int totlen ;
  int c ;
  opj_option_t long_option[7] ;
  char optlist[18] ;
  char *infile ;
  int __cil_tmp12 ;
  char *outfile ;
  int __cil_tmp15 ;
  char outformat[50] ;
  char *of ;
  unsigned long __cil_tmp19 ;
  void *__cil_tmp20 ;
  size_t size_optarg ;
  unsigned long __cil_tmp22 ;
  char *ROI_values ;
  void *__cil_tmp24 ;
  int __cil_tmp25 ;
  OPJ_BOOL __cil_tmp26 ;
  int __cil_tmp27 ;

  {
  {
#line 553
  strcpy((char *)long_option[0].name, "ImgDir");
#line 553
  long_option[0].has_arg = 1;
#line 553
  long_option[0].flag = (int *)((void *)0);
#line 553
  long_option[0].val = 'y';
#line 553
  strcpy((char *)long_option[1].name, "OutFor");
#line 553
  long_option[1].has_arg = 1;
#line 553
  long_option[1].flag = (int *)((void *)0);
#line 553
  long_option[1].val = 'O';
#line 553
  strcpy((char *)long_option[2].name, "force-rgb");
#line 553
  long_option[2].has_arg = 0;
#line 553
  long_option[2].flag = (int *)((void *)0);
#line 553
  long_option[2].val = 1;
#line 553
  strcpy((char *)long_option[3].name, "upsample\251");
#line 553
  long_option[3].has_arg = 0;
#line 553
  long_option[3].flag = (int *)((void *)0);
#line 553
  long_option[3].val = 1;
#line 553
  strcpy((char *)long_option[4].name, "split-pnm");
#line 553
  long_option[4].has_arg = 0;
#line 553
  long_option[4].flag = (int *)((void *)0);
#line 553
  long_option[4].val = 1;
#line 553
  strcpy((char *)long_option[5].name, "threads");
#line 553
  long_option[5].has_arg = 1;
#line 553
  long_option[5].flag = (int *)((void *)0);
#line 553
  long_option[5].val = 'T';
#line 553
  strcpy((char *)long_option[6].name, "quiet");
#line 553
  long_option[6].has_arg = 0;
#line 553
  long_option[6].flag = (int *)((void *)0);
#line 553
  long_option[6].val = 1;
#line 563
  strcpy(optlist, "i:o:r:l:x:d:t:p:h");
#line 572
  long_option[2].flag = & parameters->force_rgb;
#line 573
  long_option[3].flag = & parameters->upsample;
#line 574
  long_option[4].flag = & parameters->split_pnm;
#line 575
  long_option[6].flag = & parameters->quiet;
#line 576
  totlen = (int )sizeof(long_option);
#line 577
  opj_reset_options_reading();
#line 578
  img_fol->set_out_format = (char)0;
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 580
    c = opj_getopt_long(argc, argv, (char const   *)(optlist), long_option, totlen);
    }
#line 581
    if (c == -1) {
#line 582
      goto while_break;
    }
#line 585
    if (c == 0) {
#line 585
      goto case_0;
    }
#line 587
    if (c == 105) {
#line 587
      goto case_105;
    }
#line 591
    if (c == 0) {
#line 591
      goto case_0___0;
    }
#line 593
    if (c == 1) {
#line 593
      goto case_1;
    }
#line 595
    if (c == 2) {
#line 595
      goto case_2;
    }
#line 597
    if (c == -2) {
#line 597
      goto case_exp;
    }
#line 618
    if (c == 111) {
#line 618
      goto case_111;
    }
#line 622
    if (c == 11) {
#line 622
      goto case_11;
    }
#line 624
    if (c == 10) {
#line 624
      goto case_10;
    }
#line 626
    if (c == 12) {
#line 626
      goto case_12;
    }
#line 628
    if (c == 14) {
#line 628
      goto case_14;
    }
#line 630
    if (c == 15) {
#line 630
      goto case_15;
    }
#line 632
    if (c == 18) {
#line 632
      goto case_18;
    }
#line 634
    if (c == 16) {
#line 634
      goto case_16;
    }
#line 636
    if (c == 17) {
#line 636
      goto case_17;
    }
#line 654
    if (c == 79) {
#line 654
      goto case_79;
    }
#line 661
    if (c == 11) {
#line 661
      goto case_11___0;
    }
#line 664
    if (c == 10) {
#line 664
      goto case_10___0;
    }
#line 667
    if (c == 12) {
#line 667
      goto case_12___0;
    }
#line 670
    if (c == 14) {
#line 670
      goto case_14___0;
    }
#line 673
    if (c == 15) {
#line 673
      goto case_15___0;
    }
#line 676
    if (c == 18) {
#line 676
      goto case_18___0;
    }
#line 679
    if (c == 16) {
#line 679
      goto case_16___0;
    }
#line 682
    if (c == 17) {
#line 682
      goto case_17___0;
    }
#line 698
    if (c == 114) {
#line 698
      goto case_114;
    }
#line 706
    if (c == 108) {
#line 706
      goto case_108;
    }
#line 713
    if (c == 104) {
#line 713
      goto case_104;
    }
#line 719
    if (c == 121) {
#line 719
      goto case_121;
    }
#line 731
    if (c == 100) {
#line 731
      goto case_100;
    }
#line 750
    if (c == 116) {
#line 750
      goto case_116;
    }
#line 758
    if (c == 120) {
#line 758
      goto case_120;
    }
#line 768
    if (c == 112) {
#line 768
      goto case_112;
    }
#line 849
    if (c == 84) {
#line 849
      goto case_84;
    }
#line 863
    goto switch_default___2;
    case_0: 
#line 586
    goto switch_break;
    case_105: 
    {
#line 588
    infile = opj_optarg;
#line 589
    parameters->decod_format = infile_format((char const   *)infile);
    }
#line 591
    if (parameters->decod_format == 0) {
#line 591
      goto case_0___0;
    }
#line 593
    if (parameters->decod_format == 1) {
#line 593
      goto case_1;
    }
#line 595
    if (parameters->decod_format == 2) {
#line 595
      goto case_2;
    }
#line 597
    if (parameters->decod_format == -2) {
#line 597
      goto case_exp;
    }
#line 602
    goto switch_default;
    case_0___0: 
#line 592
    goto switch_break___0;
    case_1: 
#line 594
    goto switch_break___0;
    case_2: 
#line 596
    goto switch_break___0;
    case_exp: 
    {
#line 598
    fprintf(stderr, "!! infile cannot be read: %s !!\n\n", infile);
    }
#line 601
    return (1);
    switch_default: 
    {
#line 603
    fprintf(stderr, "[ERROR] Unknown input file format: %s \n        Known file formats are *.j2k, *.jp2, *.jpc or *.jpt\n",
            infile);
    }
#line 607
    return (1);
    switch_break___0: 
    {
#line 609
    __cil_tmp12 = opj_strcpy_s(parameters->infile, sizeof(parameters->infile), (char const   *)infile);
    }
#line 609
    if (__cil_tmp12 != 0) {
      {
#line 610
      fprintf(stderr, "[ERROR] Path is too long\n");
      }
#line 611
      return (1);
    }
#line 614
    goto switch_break;
    case_111: 
    {
#line 619
    outfile = opj_optarg;
#line 620
    parameters->cod_format = get_file_format((char const   *)outfile);
    }
#line 622
    if (parameters->cod_format == 11) {
#line 622
      goto case_11;
    }
#line 624
    if (parameters->cod_format == 10) {
#line 624
      goto case_10;
    }
#line 626
    if (parameters->cod_format == 12) {
#line 626
      goto case_12;
    }
#line 628
    if (parameters->cod_format == 14) {
#line 628
      goto case_14;
    }
#line 630
    if (parameters->cod_format == 15) {
#line 630
      goto case_15;
    }
#line 632
    if (parameters->cod_format == 18) {
#line 632
      goto case_18;
    }
#line 634
    if (parameters->cod_format == 16) {
#line 634
      goto case_16;
    }
#line 636
    if (parameters->cod_format == 17) {
#line 636
      goto case_17;
    }
#line 638
    goto switch_default___0;
    case_11: 
#line 623
    goto switch_break___1;
    case_10: 
#line 625
    goto switch_break___1;
    case_12: 
#line 627
    goto switch_break___1;
    case_14: 
#line 629
    goto switch_break___1;
    case_15: 
#line 631
    goto switch_break___1;
    case_18: 
#line 633
    goto switch_break___1;
    case_16: 
#line 635
    goto switch_break___1;
    case_17: 
#line 637
    goto switch_break___1;
    switch_default___0: 
    {
#line 639
    fprintf(stderr, "Unknown output format image %s [only *.png, *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!!\n\230\001",
            outfile);
    }
#line 642
    return (1);
    switch_break___1: 
    {
#line 644
    __cil_tmp15 = opj_strcpy_s(parameters->outfile, sizeof(parameters->outfile), (char const   *)outfile);
    }
#line 644
    if (__cil_tmp15 != 0) {
      {
#line 646
      fprintf(stderr, "[ERROR] Path is too long\n");
      }
#line 647
      return (1);
    }
#line 650
    goto switch_break;
    case_79: 
    {
#line 656
    of = opj_optarg;
#line 657
    sprintf(outformat, ".%s", of);
#line 658
    img_fol->set_out_format = (char)1;
#line 659
    parameters->cod_format = get_file_format((char const   *)(outformat));
    }
#line 661
    if (parameters->cod_format == 11) {
#line 661
      goto case_11___0;
    }
#line 664
    if (parameters->cod_format == 10) {
#line 664
      goto case_10___0;
    }
#line 667
    if (parameters->cod_format == 12) {
#line 667
      goto case_12___0;
    }
#line 670
    if (parameters->cod_format == 14) {
#line 670
      goto case_14___0;
    }
#line 673
    if (parameters->cod_format == 15) {
#line 673
      goto case_15___0;
    }
#line 676
    if (parameters->cod_format == 18) {
#line 676
      goto case_18___0;
    }
#line 679
    if (parameters->cod_format == 16) {
#line 679
      goto case_16___0;
    }
#line 682
    if (parameters->cod_format == 17) {
#line 682
      goto case_17___0;
    }
#line 685
    goto switch_default___1;
    case_11___0: 
    {
#line 662
    strcpy((char *)img_fol->out_format, "pgx");
    }
#line 663
    goto switch_break___2;
    case_10___0: 
    {
#line 665
    strcpy((char *)img_fol->out_format, "ppm");
    }
#line 666
    goto switch_break___2;
    case_12___0: 
    {
#line 668
    strcpy((char *)img_fol->out_format, "bmp");
    }
#line 669
    goto switch_break___2;
    case_14___0: 
    {
#line 671
    strcpy((char *)img_fol->out_format, "tif");
    }
#line 672
    goto switch_break___2;
    case_15___0: 
    {
#line 674
    strcpy((char *)img_fol->out_format, "raw");
    }
#line 675
    goto switch_break___2;
    case_18___0: 
    {
#line 677
    strcpy((char *)img_fol->out_format, "rawl");
    }
#line 678
    goto switch_break___2;
    case_16___0: 
    {
#line 680
    strcpy((char *)img_fol->out_format, "raw");
    }
#line 681
    goto switch_break___2;
    case_17___0: 
    {
#line 683
    strcpy((char *)img_fol->out_format, "png");
    }
#line 684
    goto switch_break___2;
    switch_default___1: 
    {
#line 686
    fprintf(stderr, "Unknown output format image %s [only *.png, *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!!\n\230\001",
            outformat);
    }
#line 689
    return (1);
#line 690
    goto switch_break___2;
    switch_break___2: ;
#line 693
    goto switch_break;
    case_114: 
    {
#line 699
    sscanf((char const   *)opj_optarg, "%u", & parameters->core.cp_reduce);
    }
#line 701
    goto switch_break;
    case_108: 
    {
#line 707
    sscanf((char const   *)opj_optarg, "%u", & parameters->core.cp_layer);
    }
#line 709
    goto switch_break;
    case_104: 
    {
#line 714
    decode_help_display();
    }
#line 715
    return (1);
    case_121: 
    {
#line 720
    __cil_tmp19 = strlen((char const   *)opj_optarg);
#line 720
    __cil_tmp20 = malloc(__cil_tmp19 + 1UL);
#line 720
    img_fol->imgdirpath = (char *)__cil_tmp20;
    }
#line 721
    if ((unsigned long )img_fol->imgdirpath == (unsigned long )((void *)0)) {
#line 722
      return (1);
    }
    {
#line 724
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 725
    img_fol->set_imgdir = (char)1;
    }
#line 727
    goto switch_break;
    case_100: 
    {
#line 732
    __cil_tmp22 = strlen((char const   *)opj_optarg);
#line 732
    size_optarg = __cil_tmp22 + 1UL;
#line 733
    __cil_tmp24 = malloc(size_optarg);
#line 733
    ROI_values = (char *)__cil_tmp24;
    }
#line 734
    if ((unsigned long )ROI_values == (unsigned long )((void *)0)) {
      {
#line 735
      fprintf(stderr, "[ERROR] Couldn\'t allocate memory\n");
      }
#line 736
      return (1);
    }
    {
#line 738
    *(ROI_values + 0) = (char )'\000';
#line 739
    memcpy((void *)ROI_values, (void const   *)opj_optarg, size_optarg);
#line 741
    parse_DA_values(ROI_values, & parameters->DA_x0, & parameters->DA_y0, & parameters->DA_x1,
                    & parameters->DA_y1);
#line 744
    free((void *)ROI_values);
    }
#line 746
    goto switch_break;
    case_116: 
    {
#line 751
    sscanf((char const   *)opj_optarg, "%u", & parameters->tile_index);
#line 752
    parameters->nb_tile_to_decode = (OPJ_UINT32 )1;
    }
#line 754
    goto switch_break;
    case_120: 
    {
#line 759
    __cil_tmp25 = opj_strcpy_s(parameters->indexfilename, sizeof(parameters->indexfilename),
                               (char const   *)opj_optarg);
    }
#line 759
    if (__cil_tmp25 != 0) {
      {
#line 761
      fprintf(stderr, "[ERROR] Path is too long\n");
      }
#line 762
      return (1);
    }
#line 765
    goto switch_break;
    case_112: 
    {
#line 769
    __cil_tmp26 = parse_precision((char const   *)opj_optarg, parameters);
    }
#line 769
    if (! __cil_tmp26) {
#line 770
      return (1);
    }
#line 773
    goto switch_break;
    case_84: 
    {
#line 850
    __cil_tmp27 = strcmp((char const   *)opj_optarg, "ALL_CPUS\220");
    }
#line 850
    if (__cil_tmp27 == 0) {
      {
#line 851
      parameters->num_threads = opj_get_num_cpus();
      }
#line 852
      if (parameters->num_threads == 1) {
#line 853
        parameters->num_threads = 0;
      }
    } else {
      {
#line 856
      sscanf((char const   *)opj_optarg, "%d", & parameters->num_threads);
      }
    }
#line 859
    goto switch_break;
    switch_default___2: 
    {
#line 864
    fprintf(stderr, "[WARNING] An invalid option has been ignored.\n");
    }
#line 865
    goto switch_break;
    switch_break: ;
#line 579
    if (! (c != -1)) {
#line 579
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 870
  if ((int )img_fol->set_imgdir == 1) {
#line 871
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 872
      fprintf(stderr, "[ERROR] options -ImgDir and -i cannot be used together.\n\220");
      }
#line 873
      return (1);
    }
#line 875
    if ((int )img_fol->set_out_format == 0) {
      {
#line 876
      fprintf(stderr, "[ERROR] When -ImgDir is used, -OutFor <FORMAT> must be used.\n");
#line 878
      fprintf(stderr, "Only one format allowed.\nValid format are PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA.\n");
      }
#line 880
      return (1);
    }
#line 882
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 883
      fprintf(stderr, "[ERROR] options -ImgDir and -o cannot be used together.\n\220");
      }
#line 884
      return (1);
    }
  } else
#line 887
  if ((int )parameters->infile[0] == 0) {
    {
#line 888
    fprintf(stderr, "[ERROR] Required parameters are missing\nExample: %s -i image.j2k -o image.pgm\n",
            *(argv + 0));
#line 890
    fprintf(stderr, "   Help: %s -h\n", *(argv + 0));
    }
#line 891
    return (1);
  } else
#line 887
  if ((int )parameters->outfile[0] == 0) {
    {
#line 888
    fprintf(stderr, "[ERROR] Required parameters are missing\nExample: %s -i image.j2k -o image.pgm\n",
            *(argv + 0));
#line 890
    fprintf(stderr, "   Help: %s -h\n", *(argv + 0));
    }
#line 891
    return (1);
  }
#line 895
  return (0);
}
}
#line 904 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
int parse_DA_values(char *inArg , unsigned int *DA_x0 , unsigned int *DA_y0 , unsigned int *DA_x1 ,
                    unsigned int *DA_y1 ) 
{ 
  int it ;
  int values[4] ;
  char delims[2] ;
  char *result ;

  {
  {
#line 907
  it = 0;
#line 909
  strcpy(delims, ",");
#line 910
  result = (char *)((void *)0);
#line 911
  result = strtok(inArg, (char const   *)(delims));
  }
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;

#line 913
    if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 913
      if (! (it < 4)) {
#line 913
        goto while_break;
      }
    } else {
#line 913
      goto while_break;
    }
    {
#line 914
    values[it] = atoi((char const   *)result);
#line 915
    result = strtok((char *)((void *)0), (char const   *)(delims));
#line 916
    it ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 919
  if (it != 4) {
#line 920
    return (1);
  } else {
#line 922
    *DA_x0 = (OPJ_UINT32 )values[0];
#line 923
    *DA_y0 = (OPJ_UINT32 )values[1];
#line 924
    *DA_x1 = (OPJ_UINT32 )values[2];
#line 925
    *DA_y1 = (OPJ_UINT32 )values[3];
#line 926
    return (0);
  }
}
}
#line 967 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static void error_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 970
  fprintf(stdout, "[ERROR] %s", msg);
  }
#line 972
  return;
}
}
#line 975 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static void warning_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 978
  fprintf(stdout, "[WARNING] %s V", msg);
  }
#line 980
  return;
}
}
#line 983 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static void info_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 986
  fprintf(stdout, "[INFO] %s\320\2113 V", msg);
  }
#line 988
  return;
}
}
#line 991 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static void quiet_callback(char const   *msg , void *client_data ) 
{ 


  {
#line 996
  return;
}
}
#line 997 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static void set_default_parameters(opj_decompress_parameters *parameters ) 
{ 


  {
#line 999
  if (parameters) {
    {
#line 1000
    memset((void *)parameters, 0, sizeof(opj_decompress_parameters ));
#line 1003
    parameters->decod_format = -1;
#line 1004
    parameters->cod_format = -1;
#line 1007
    opj_set_default_decoder_parameters(& parameters->core);
    }
  }
#line 1010
  return;
}
}
#line 1011 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static void destroy_parameters(opj_decompress_parameters *parameters ) 
{ 


  {
#line 1013
  if (parameters) {
#line 1014
    if (parameters->precision) {
      {
#line 1015
      free((void *)parameters->precision);
#line 1016
      parameters->precision = (opj_precision *)((void *)0);
      }
    }
  }
#line 1020
  return;
}
}
#line 1023 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static opj_image_t *convert_gray_to_rgb(opj_image_t *original ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *l_new_image ;
  opj_image_cmptparm_t *l_new_components ;
  void *__cil_tmp5 ;

  {
  {
#line 1026
  l_new_image = (opj_image_t *)((void *)0);
#line 1027
  l_new_components = (opj_image_cmptparm_t *)((void *)0);
#line 1029
  __cil_tmp5 = malloc((unsigned long )(original->numcomps + 2U) * sizeof(opj_image_cmptparm_t ));
#line 1029
  l_new_components = (opj_image_cmptparm_t *)__cil_tmp5;
  }
#line 1031
  if ((unsigned long )l_new_components == (unsigned long )((void *)0)) {
    {
#line 1032
    fprintf(stderr, "ERROR -> opj_decompress: failed to allocate memory for RGB image!\n");
#line 1034
    opj_image_destroy(original);
    }
#line 1035
    return ((opj_image_t *)((void *)0));
  }
#line 1038
  (l_new_components + 2)->bpp = (original->comps + 0)->bpp;
#line 1038
  (l_new_components + 1)->bpp = (l_new_components + 2)->bpp;
#line 1038
  (l_new_components + 0)->bpp = (l_new_components + 1)->bpp;
#line 1040
  (l_new_components + 2)->dx = (original->comps + 0)->dx;
#line 1040
  (l_new_components + 1)->dx = (l_new_components + 2)->dx;
#line 1040
  (l_new_components + 0)->dx = (l_new_components + 1)->dx;
#line 1042
  (l_new_components + 2)->dy = (original->comps + 0)->dy;
#line 1042
  (l_new_components + 1)->dy = (l_new_components + 2)->dy;
#line 1042
  (l_new_components + 0)->dy = (l_new_components + 1)->dy;
#line 1044
  (l_new_components + 2)->h = (original->comps + 0)->h;
#line 1044
  (l_new_components + 1)->h = (l_new_components + 2)->h;
#line 1044
  (l_new_components + 0)->h = (l_new_components + 1)->h;
#line 1046
  (l_new_components + 2)->w = (original->comps + 0)->w;
#line 1046
  (l_new_components + 1)->w = (l_new_components + 2)->w;
#line 1046
  (l_new_components + 0)->w = (l_new_components + 1)->w;
#line 1048
  (l_new_components + 2)->prec = (original->comps + 0)->prec;
#line 1048
  (l_new_components + 1)->prec = (l_new_components + 2)->prec;
#line 1048
  (l_new_components + 0)->prec = (l_new_components + 1)->prec;
#line 1050
  (l_new_components + 2)->sgnd = (original->comps + 0)->sgnd;
#line 1050
  (l_new_components + 1)->sgnd = (l_new_components + 2)->sgnd;
#line 1050
  (l_new_components + 0)->sgnd = (l_new_components + 1)->sgnd;
#line 1052
  (l_new_components + 2)->x0 = (original->comps + 0)->x0;
#line 1052
  (l_new_components + 1)->x0 = (l_new_components + 2)->x0;
#line 1052
  (l_new_components + 0)->x0 = (l_new_components + 1)->x0;
#line 1054
  (l_new_components + 2)->y0 = (original->comps + 0)->y0;
#line 1054
  (l_new_components + 1)->y0 = (l_new_components + 2)->y0;
#line 1054
  (l_new_components + 0)->y0 = (l_new_components + 1)->y0;
#line 1057
  compno = 1U;
  {
#line 1057
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1057
    if (! (compno < original->numcomps)) {
#line 1057
      goto while_break;
    }
#line 1058
    (l_new_components + (compno + 2U))->bpp = (original->comps + compno)->bpp;
#line 1059
    (l_new_components + (compno + 2U))->dx = (original->comps + compno)->dx;
#line 1060
    (l_new_components + (compno + 2U))->dy = (original->comps + compno)->dy;
#line 1061
    (l_new_components + (compno + 2U))->h = (original->comps + compno)->h;
#line 1062
    (l_new_components + (compno + 2U))->w = (original->comps + compno)->w;
#line 1063
    (l_new_components + (compno + 2U))->prec = (original->comps + compno)->prec;
#line 1064
    (l_new_components + (compno + 2U))->sgnd = (original->comps + compno)->sgnd;
#line 1065
    (l_new_components + (compno + 2U))->x0 = (original->comps + compno)->x0;
#line 1066
    (l_new_components + (compno + 2U))->y0 = (original->comps + compno)->y0;
#line 1057
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1069
  l_new_image = opj_image_create(original->numcomps + 2U, l_new_components, (OPJ_COLOR_SPACE )1);
#line 1071
  free((void *)l_new_components);
  }
#line 1072
  if ((unsigned long )l_new_image == (unsigned long )((void *)0)) {
    {
#line 1073
    fprintf(stderr, "ERROR -> opj_decompress: failed to allocate memory for RGB image!\n");
#line 1075
    opj_image_destroy(original);
    }
#line 1076
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1079
  l_new_image->x0 = original->x0;
#line 1080
  l_new_image->x1 = original->x1;
#line 1081
  l_new_image->y0 = original->y0;
#line 1082
  l_new_image->y1 = original->y1;
#line 1084
  (l_new_image->comps + 2)->factor = (original->comps + 0)->factor;
#line 1084
  (l_new_image->comps + 1)->factor = (l_new_image->comps + 2)->factor;
#line 1084
  (l_new_image->comps + 0)->factor = (l_new_image->comps + 1)->factor;
#line 1086
  (l_new_image->comps + 2)->alpha = (original->comps + 0)->alpha;
#line 1086
  (l_new_image->comps + 1)->alpha = (l_new_image->comps + 2)->alpha;
#line 1086
  (l_new_image->comps + 0)->alpha = (l_new_image->comps + 1)->alpha;
#line 1088
  (l_new_image->comps + 2)->resno_decoded = (original->comps + 0)->resno_decoded;
#line 1088
  (l_new_image->comps + 1)->resno_decoded = (l_new_image->comps + 2)->resno_decoded;
#line 1088
  (l_new_image->comps + 0)->resno_decoded = (l_new_image->comps + 1)->resno_decoded;
#line 1091
  memcpy((void *)(l_new_image->comps + 0)->data, (void const   *)(original->comps + 0)->data,
         (unsigned long )((original->comps + 0)->w * (original->comps + 0)->h) * sizeof(OPJ_INT32 ));
#line 1093
  memcpy((void *)(l_new_image->comps + 1)->data, (void const   *)(original->comps + 0)->data,
         (unsigned long )((original->comps + 0)->w * (original->comps + 0)->h) * sizeof(OPJ_INT32 ));
#line 1095
  memcpy((void *)(l_new_image->comps + 2)->data, (void const   *)(original->comps + 0)->data,
         (unsigned long )((original->comps + 0)->w * (original->comps + 0)->h) * sizeof(OPJ_INT32 ));
#line 1098
  compno = 1U;
  }
  {
#line 1098
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1098
    if (! (compno < original->numcomps)) {
#line 1098
      goto while_break___0;
    }
    {
#line 1099
    (l_new_image->comps + (compno + 2U))->factor = (original->comps + compno)->factor;
#line 1100
    (l_new_image->comps + (compno + 2U))->alpha = (original->comps + compno)->alpha;
#line 1101
    (l_new_image->comps + (compno + 2U))->resno_decoded = (original->comps + compno)->resno_decoded;
#line 1103
    memcpy((void *)(l_new_image->comps + (compno + 2U))->data, (void const   *)(original->comps + compno)->data,
           (unsigned long )((original->comps + compno)->w * (original->comps + compno)->h) * sizeof(OPJ_INT32 ));
#line 1098
    compno ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1106
  opj_image_destroy(original);
  }
#line 1107
  return (l_new_image);
}
}
#line 1112 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
static opj_image_t *upsample_image_components(opj_image_t *original ) 
{ 
  opj_image_t *l_new_image ;
  opj_image_cmptparm_t *l_new_components ;
  OPJ_BOOL l_upsample_need ;
  OPJ_UINT32 compno ;
  void *__cil_tmp6 ;
  opj_image_cmptparm_t *l_new_cmp ;
  opj_image_comp_t *l_org_cmp ;
  opj_image_comp_t *l_new_cmp___0 ;
  opj_image_comp_t *l_org_cmp___0 ;
  OPJ_INT32 *l_src ;
  OPJ_INT32 *l_dst ;
  OPJ_UINT32 y ;
  OPJ_UINT32 xoff ;
  OPJ_UINT32 yoff ;
  OPJ_UINT32 x ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 xorg ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 x___0 ;
  OPJ_UINT32 xorg___0 ;
  OPJ_UINT32 dx___0 ;

  {
#line 1114
  l_new_image = (opj_image_t *)((void *)0);
#line 1115
  l_new_components = (opj_image_cmptparm_t *)((void *)0);
#line 1116
  l_upsample_need = 0;
#line 1119
  compno = 0U;
  {
#line 1119
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1119
    if (! (compno < original->numcomps)) {
#line 1119
      goto while_break;
    }
#line 1120
    if ((original->comps + compno)->factor > 0U) {
      {
#line 1121
      fprintf(stderr, "ERROR -> opj_decompress: -upsample not supported with reduction\n\220");
#line 1123
      opj_image_destroy(original);
      }
#line 1124
      return ((opj_image_t *)((void *)0));
    }
#line 1126
    if ((original->comps + compno)->dx > 1U) {
#line 1127
      l_upsample_need = 1;
#line 1128
      goto while_break;
    } else
#line 1126
    if ((original->comps + compno)->dy > 1U) {
#line 1127
      l_upsample_need = 1;
#line 1128
      goto while_break;
    }
#line 1119
    compno ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break: ;
#line 1131
  if (! l_upsample_need) {
#line 1132
    return (original);
  }
  {
#line 1135
  __cil_tmp6 = malloc((unsigned long )original->numcomps * sizeof(opj_image_cmptparm_t ));
#line 1135
  l_new_components = (opj_image_cmptparm_t *)__cil_tmp6;
  }
#line 1137
  if ((unsigned long )l_new_components == (unsigned long )((void *)0)) {
    {
#line 1138
    fprintf(stderr, "ERROR -> opj_decompress: failed to allocate memory for upsampled components!\n");
#line 1140
    opj_image_destroy(original);
    }
#line 1141
    return ((opj_image_t *)((void *)0));
  }
#line 1144
  compno = 0U;
  {
#line 1144
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1144
    if (! (compno < original->numcomps)) {
#line 1144
      goto while_break___0;
    }
#line 1145
    l_new_cmp = l_new_components + compno;
#line 1146
    l_org_cmp = original->comps + compno;
#line 1148
    l_new_cmp->bpp = l_org_cmp->bpp;
#line 1149
    l_new_cmp->prec = l_org_cmp->prec;
#line 1150
    l_new_cmp->sgnd = l_org_cmp->sgnd;
#line 1151
    l_new_cmp->x0 = original->x0;
#line 1152
    l_new_cmp->y0 = original->y0;
#line 1153
    l_new_cmp->dx = (OPJ_UINT32 )1;
#line 1154
    l_new_cmp->dy = (OPJ_UINT32 )1;
#line 1155
    l_new_cmp->w = l_org_cmp->w;
#line 1157
    l_new_cmp->h = l_org_cmp->h;
#line 1160
    if (l_org_cmp->dx > 1U) {
#line 1161
      l_new_cmp->w = original->x1 - original->x0;
    }
#line 1164
    if (l_org_cmp->dy > 1U) {
#line 1165
      l_new_cmp->h = original->y1 - original->y0;
    }
#line 1144
    compno ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1169
  l_new_image = opj_image_create(original->numcomps, l_new_components, original->color_space);
#line 1171
  free((void *)l_new_components);
  }
#line 1172
  if ((unsigned long )l_new_image == (unsigned long )((void *)0)) {
    {
#line 1173
    fprintf(stderr, "ERROR -> opj_decompress: failed to allocate memory for upsampled components!\n");
#line 1175
    opj_image_destroy(original);
    }
#line 1176
    return ((opj_image_t *)((void *)0));
  }
#line 1179
  l_new_image->x0 = original->x0;
#line 1180
  l_new_image->x1 = original->x1;
#line 1181
  l_new_image->y0 = original->y0;
#line 1182
  l_new_image->y1 = original->y1;
#line 1184
  compno = 0U;
  {
#line 1184
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1184
    if (! (compno < original->numcomps)) {
#line 1184
      goto while_break___1;
    }
#line 1185
    l_new_cmp___0 = l_new_image->comps + compno;
#line 1186
    l_org_cmp___0 = original->comps + compno;
#line 1188
    l_new_cmp___0->factor = l_org_cmp___0->factor;
#line 1189
    l_new_cmp___0->alpha = l_org_cmp___0->alpha;
#line 1190
    l_new_cmp___0->resno_decoded = l_org_cmp___0->resno_decoded;
#line 1192
    if (l_org_cmp___0->dx > 1U) {
      _L: 
#line 1193
      l_src = l_org_cmp___0->data;
#line 1194
      l_dst = l_new_cmp___0->data;
#line 1199
      xoff = l_org_cmp___0->dx * l_org_cmp___0->x0 - original->x0;
#line 1200
      yoff = l_org_cmp___0->dy * l_org_cmp___0->y0 - original->y0;
#line 1201
      if (xoff >= l_org_cmp___0->dx) {
        {
#line 1202
        fprintf(stderr, "ERROR -> opj_decompress: Invalid image/component parameters found when upsampling\n");
#line 1204
        opj_image_destroy(original);
#line 1205
        opj_image_destroy(l_new_image);
        }
#line 1206
        return ((opj_image_t *)((void *)0));
      } else
#line 1201
      if (yoff >= l_org_cmp___0->dy) {
        {
#line 1202
        fprintf(stderr, "ERROR -> opj_decompress: Invalid image/component parameters found when upsampling\n");
#line 1204
        opj_image_destroy(original);
#line 1205
        opj_image_destroy(l_new_image);
        }
#line 1206
        return ((opj_image_t *)((void *)0));
      }
#line 1209
      y = 0U;
      {
#line 1209
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1209
        if (! (y < yoff)) {
#line 1209
          goto while_break___2;
        }
        {
#line 1210
        memset((void *)l_dst, 0, (unsigned long )l_new_cmp___0->w * sizeof(OPJ_INT32 ));
#line 1211
        l_dst += l_new_cmp___0->w;
#line 1209
        y ++;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___2: ;
#line 1214
      if (l_new_cmp___0->h > l_org_cmp___0->dy - 1U) {
        {
#line 1216
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1216
          if (! (y < l_new_cmp___0->h - (l_org_cmp___0->dy - 1U))) {
#line 1216
            goto while_break___3;
          }
#line 1220
          xorg = 0U;
#line 1221
          x = 0U;
          {
#line 1221
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 1221
            if (! (x < xoff)) {
#line 1221
              goto while_break___4;
            }
#line 1222
            *(l_dst + x) = 0;
#line 1221
            x ++;
          }
          while_break___19: /* CIL Label */ ;
          }
          while_break___4: ;
#line 1224
          if (l_new_cmp___0->w > l_org_cmp___0->dx - 1U) {
            {
#line 1226
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 1226
              if (! (x < l_new_cmp___0->w - (l_org_cmp___0->dx - 1U))) {
#line 1226
                goto while_break___5;
              }
#line 1228
              dx = 0U;
              {
#line 1228
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 1228
                if (! (dx < l_org_cmp___0->dx)) {
#line 1228
                  goto while_break___6;
                }
#line 1229
                *(l_dst + (x + dx)) = *(l_src + xorg);
#line 1228
                dx ++;
              }
              while_break___21: /* CIL Label */ ;
              }
              while_break___6: 
#line 1226
              xorg ++;
#line 1226
              x += l_org_cmp___0->dx;
            }
            while_break___20: /* CIL Label */ ;
            }
            while_break___5: ;
          }
          {
#line 1233
          while (1) {
            while_continue___7: /* CIL Label */ ;

#line 1233
            if (! (x < l_new_cmp___0->w)) {
#line 1233
              goto while_break___7;
            }
#line 1234
            *(l_dst + x) = *(l_src + xorg);
#line 1233
            x ++;
          }
          while_break___22: /* CIL Label */ ;
          }
          while_break___7: 
#line 1236
          l_dst += l_new_cmp___0->w;
#line 1238
          dy = 1U;
          {
#line 1238
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 1238
            if (! (dy < l_org_cmp___0->dy)) {
#line 1238
              goto while_break___8;
            }
            {
#line 1239
            memcpy((void *)l_dst, (void const   *)(l_dst - l_new_cmp___0->w), (unsigned long )l_new_cmp___0->w * sizeof(OPJ_INT32 ));
#line 1240
            l_dst += l_new_cmp___0->w;
#line 1238
            dy ++;
            }
          }
          while_break___23: /* CIL Label */ ;
          }
          while_break___8: 
#line 1242
          l_src += l_org_cmp___0->w;
#line 1216
          y += l_org_cmp___0->dy;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___3: ;
      }
#line 1245
      if (y < l_new_cmp___0->h) {
#line 1249
        xorg___0 = 0U;
#line 1250
        x___0 = 0U;
        {
#line 1250
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 1250
          if (! (x___0 < xoff)) {
#line 1250
            goto while_break___9;
          }
#line 1251
          *(l_dst + x___0) = 0;
#line 1250
          x___0 ++;
        }
        while_break___24: /* CIL Label */ ;
        }
        while_break___9: ;
#line 1253
        if (l_new_cmp___0->w > l_org_cmp___0->dx - 1U) {
          {
#line 1255
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 1255
            if (! (x___0 < l_new_cmp___0->w - (l_org_cmp___0->dx - 1U))) {
#line 1255
              goto while_break___10;
            }
#line 1257
            dx___0 = 0U;
            {
#line 1257
            while (1) {
              while_continue___11: /* CIL Label */ ;

#line 1257
              if (! (dx___0 < l_org_cmp___0->dx)) {
#line 1257
                goto while_break___11;
              }
#line 1258
              *(l_dst + (x___0 + dx___0)) = *(l_src + xorg___0);
#line 1257
              dx___0 ++;
            }
            while_break___26: /* CIL Label */ ;
            }
            while_break___11: 
#line 1255
            xorg___0 ++;
#line 1255
            x___0 += l_org_cmp___0->dx;
          }
          while_break___25: /* CIL Label */ ;
          }
          while_break___10: ;
        }
        {
#line 1262
        while (1) {
          while_continue___12: /* CIL Label */ ;

#line 1262
          if (! (x___0 < l_new_cmp___0->w)) {
#line 1262
            goto while_break___12;
          }
#line 1263
          *(l_dst + x___0) = *(l_src + xorg___0);
#line 1262
          x___0 ++;
        }
        while_break___27: /* CIL Label */ ;
        }
        while_break___12: 
#line 1265
        l_dst += l_new_cmp___0->w;
#line 1266
        y ++;
        {
#line 1267
        while (1) {
          while_continue___13: /* CIL Label */ ;

#line 1267
          if (! (y < l_new_cmp___0->h)) {
#line 1267
            goto while_break___13;
          }
          {
#line 1268
          memcpy((void *)l_dst, (void const   *)(l_dst - l_new_cmp___0->w), (unsigned long )l_new_cmp___0->w * sizeof(OPJ_INT32 ));
#line 1269
          l_dst += l_new_cmp___0->w;
#line 1267
          y ++;
          }
        }
        while_break___28: /* CIL Label */ ;
        }
        while_break___13: ;
      }
    } else
#line 1192
    if (l_org_cmp___0->dy > 1U) {
#line 1192
      goto _L;
    } else {
      {
#line 1273
      memcpy((void *)l_new_cmp___0->data, (void const   *)l_org_cmp___0->data, (unsigned long )(l_org_cmp___0->w * l_org_cmp___0->h) * sizeof(OPJ_INT32 ));
      }
    }
#line 1184
    compno ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 1277
  opj_image_destroy(original);
  }
#line 1278
  return (l_new_image);
}
}
#line 1286 "/root/patron/new_24/src/bin/jp2/opj_decompress.c"
int main(int argc , char **argv ) 
{ 
  opj_decompress_parameters parameters ;
  opj_image_t *image ;
  opj_stream_t *l_stream ;
  opj_codec_t *l_codec ;
  opj_codestream_index_t *cstr_index ;
  OPJ_INT32 num_images ;
  OPJ_INT32 imageno ;
  img_fol_t img_fol ;
  dircnt_t *dirptr ;
  int failed ;
  OPJ_FLOAT64 t ;
  OPJ_FLOAT64 tCumulative ;
  OPJ_UINT32 numDecompressedImages ;
  OPJ_UINT32 cp_reduce ;
  int __cil_tmp17 ;
  char *__cil_tmp18 ;
  int it_image ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  int __cil_tmp25 ;
  char __cil_tmp26 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_BOOL __cil_tmp33 ;
  OPJ_BOOL __cil_tmp34 ;
  char *__cil_tmp35 ;
  OPJ_BOOL __cil_tmp36 ;
  char *__cil_tmp37 ;
  OPJ_BOOL __cil_tmp38 ;
  OPJ_BOOL __cil_tmp39 ;
  OPJ_BOOL __cil_tmp40 ;
  OPJ_BOOL __cil_tmp41 ;
  OPJ_FLOAT64 __cil_tmp42 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 prec ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int tmp ;

  {
  {
#line 1289
  image = (opj_image_t *)((void *)0);
#line 1290
  l_stream = (opj_stream_t *)((void *)0);
#line 1291
  l_codec = (opj_codec_t *)((void *)0);
#line 1292
  cstr_index = (opj_codestream_index_t *)((void *)0);
#line 1296
  dirptr = (dircnt_t *)((void *)0);
#line 1297
  failed = 0;
#line 1298
  tCumulative = (OPJ_FLOAT64 )0;
#line 1299
  numDecompressedImages = (OPJ_UINT32 )0;
#line 1303
  set_default_parameters(& parameters);
#line 1306
  memset((void *)(& img_fol), 0, sizeof(img_fol_t ));
#line 1309
  __cil_tmp17 = parse_cmdline_decoder(argc, argv, & parameters, & img_fol);
  }
#line 1309
  if (__cil_tmp17 == 1) {
#line 1310
    failed = 1;
#line 1311
    goto fin;
  }
  {
#line 1314
  cp_reduce = parameters.core.cp_reduce;
#line 1315
  __cil_tmp18 = getenv("USE_OPJ_SET_DECODED_RESOLUTION_FACTOR");
  }
#line 1315
  if ((unsigned long )__cil_tmp18 != (unsigned long )((void *)0)) {
#line 1319
    parameters.core.cp_reduce = (OPJ_UINT32 )0;
  }
#line 1324
  if ((int )img_fol.set_imgdir == 1) {
    {
#line 1326
    num_images = get_num_images(img_fol.imgdirpath);
#line 1328
    __cil_tmp21 = malloc(sizeof(dircnt_t ));
#line 1328
    dirptr = (dircnt_t *)__cil_tmp21;
    }
#line 1329
    if (! dirptr) {
      {
#line 1330
      destroy_parameters(& parameters);
      }
#line 1331
      return (1);
    }
    {
#line 1333
    __cil_tmp22 = malloc(((size_t )num_images * 4096UL) * sizeof(char ));
#line 1333
    dirptr->filename_buf = (char *)__cil_tmp22;
    }
#line 1335
    if (! dirptr->filename_buf) {
#line 1336
      failed = 1;
#line 1337
      goto fin;
    }
    {
#line 1340
    __cil_tmp23 = malloc((size_t )num_images * sizeof(char *));
#line 1340
    dirptr->filename = (char **)__cil_tmp23;
    }
#line 1342
    if (! dirptr->filename) {
#line 1343
      failed = 1;
#line 1344
      goto fin;
    }
#line 1346
    it_image = 0;
    {
#line 1346
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1346
      if (! (it_image < num_images)) {
#line 1346
        goto while_break;
      }
#line 1347
      *(dirptr->filename + it_image) = dirptr->filename_buf + it_image * 4096;
#line 1346
      it_image ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1350
    __cil_tmp25 = load_images(dirptr, img_fol.imgdirpath);
    }
#line 1350
    if (__cil_tmp25 == 1) {
#line 1351
      failed = 1;
#line 1352
      goto fin;
    }
#line 1354
    if (num_images == 0) {
      {
#line 1355
      fprintf(stderr, "Folder is empty\n\220");
#line 1356
      failed = 1;
      }
#line 1357
      goto fin;
    }
  } else {
#line 1360
    num_images = 1;
  }
#line 1364
  imageno = 0;
  {
#line 1364
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: ;
#line 1364
    if (! (imageno < num_images)) {
#line 1364
      goto while_break___0;
    }
#line 1366
    if (! parameters.quiet) {
      {
#line 1367
      fprintf(stderr, "\n");
      }
    }
#line 1370
    if ((int )img_fol.set_imgdir == 1) {
      {
#line 1371
      __cil_tmp26 = get_next_file(imageno, dirptr, & img_fol, & parameters);
      }
#line 1371
      if (__cil_tmp26) {
        {
#line 1372
        fprintf(stderr, "skipping file...\nW\2133 V");
#line 1373
        destroy_parameters(& parameters);
        }
#line 1374
        goto while_continue___0;
      }
    }
    {
#line 1381
    l_stream = opj_stream_create_default_file_stream((char const   *)(parameters.infile),
                                                     1);
    }
#line 1382
    if (! l_stream) {
      {
#line 1383
      fprintf(stderr, "ERROR -> failed to create the stream from the file %s\n", parameters.infile);
#line 1385
      failed = 1;
      }
#line 1386
      goto fin;
    }
#line 1393
    if (parameters.decod_format == 0) {
#line 1393
      goto case_0;
    }
#line 1398
    if (parameters.decod_format == 1) {
#line 1398
      goto case_1;
    }
#line 1403
    if (parameters.decod_format == 2) {
#line 1403
      goto case_2;
    }
#line 1408
    goto switch_default;
    case_0: 
    {
#line 1395
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )0);
    }
#line 1396
    goto switch_break;
    case_1: 
    {
#line 1400
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )2);
    }
#line 1401
    goto switch_break;
    case_2: 
    {
#line 1405
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )1);
    }
#line 1406
    goto switch_break;
    switch_default: 
    {
#line 1409
    fprintf(stderr, "skipping file..\n\220");
#line 1410
    destroy_parameters(& parameters);
#line 1411
    opj_stream_destroy(l_stream);
    }
#line 1412
    goto while_continue___0;
    switch_break: ;
#line 1415
    if (parameters.quiet) {
      {
#line 1417
      opj_set_info_handler(l_codec, & quiet_callback, (void *)0);
#line 1418
      opj_set_warning_handler(l_codec, & quiet_callback, (void *)0);
#line 1419
      opj_set_error_handler(l_codec, & quiet_callback, (void *)0);
      }
    } else {
      {
#line 1422
      opj_set_info_handler(l_codec, & info_callback, (void *)0);
#line 1423
      opj_set_warning_handler(l_codec, & warning_callback, (void *)0);
#line 1424
      opj_set_error_handler(l_codec, & error_callback, (void *)0);
      }
    }
    {
#line 1428
    t = opj_clock();
#line 1431
    __cil_tmp32 = opj_setup_decoder(l_codec, & parameters.core);
    }
#line 1431
    if (! __cil_tmp32) {
      {
#line 1432
      fprintf(stderr, "ERROR -> opj_decompress: failed to setup the decoder\nV");
#line 1433
      opj_stream_destroy(l_stream);
#line 1434
      opj_destroy_codec(l_codec);
#line 1435
      failed = 1;
      }
#line 1436
      goto fin;
    }
    {
#line 1439
    __cil_tmp33 = opj_codec_set_threads(l_codec, parameters.num_threads);
    }
#line 1439
    if (parameters.num_threads >= 1) {
#line 1439
      if (! __cil_tmp33) {
        {
#line 1441
        fprintf(stderr, "ERROR -> opj_decompress: failed to set number of threads\nM\2133 V");
#line 1442
        opj_stream_destroy(l_stream);
#line 1443
        opj_destroy_codec(l_codec);
#line 1444
        failed = 1;
        }
#line 1445
        goto fin;
      }
    }
    {
#line 1449
    __cil_tmp34 = opj_read_header(l_stream, l_codec, & image);
    }
#line 1449
    if (! __cil_tmp34) {
      {
#line 1450
      fprintf(stderr, "ERROR -> opj_decompress: failed to read the header\n");
#line 1451
      opj_stream_destroy(l_stream);
#line 1452
      opj_destroy_codec(l_codec);
#line 1453
      opj_image_destroy(image);
#line 1454
      failed = 1;
      }
#line 1455
      goto fin;
    }
    {
#line 1458
    __cil_tmp35 = getenv("USE_OPJ_SET_DECODED_RESOLUTION_FACTORV");
    }
#line 1458
    if ((unsigned long )__cil_tmp35 != (unsigned long )((void *)0)) {
      {
#line 1462
      __cil_tmp36 = opj_set_decoded_resolution_factor(l_codec, cp_reduce);
      }
#line 1462
      if (! __cil_tmp36) {
        {
#line 1463
        fprintf(stderr, "ERROR -> opj_decompress: failed to set the resolution factor tile!\n");
#line 1465
        opj_destroy_codec(l_codec);
#line 1466
        opj_stream_destroy(l_stream);
#line 1467
        opj_image_destroy(image);
#line 1468
        failed = 1;
        }
#line 1469
        goto fin;
      }
    }
#line 1473
    if (! parameters.nb_tile_to_decode) {
      {
#line 1474
      __cil_tmp37 = getenv("SKIP_OPJ_SET_DECODE_AREA\220");
      }
#line 1474
      if ((unsigned long )__cil_tmp37 != (unsigned long )((void *)0)) {
#line 1474
        if (parameters.DA_x0 == 0U) {
#line 1474
          if (parameters.DA_y0 == 0U) {
#line 1474
            if (parameters.DA_x1 == 0U) {
#line 1474
              if (! (parameters.DA_y1 == 0U)) {
#line 1474
                goto _L;
              }
            } else {
#line 1474
              goto _L;
            }
          } else {
#line 1474
            goto _L;
          }
        } else {
#line 1474
          goto _L;
        }
      } else {
        _L: 
        {
#line 1484
        __cil_tmp38 = opj_set_decode_area(l_codec, image, (OPJ_INT32 )parameters.DA_x0,
                                          (OPJ_INT32 )parameters.DA_y0, (OPJ_INT32 )parameters.DA_x1,
                                          (OPJ_INT32 )parameters.DA_y1);
        }
#line 1484
        if (! __cil_tmp38) {
          {
#line 1487
          fprintf(stderr, "ERROR -> opj_decompress: failed to set the decoded area\n\220");
#line 1488
          opj_stream_destroy(l_stream);
#line 1489
          opj_destroy_codec(l_codec);
#line 1490
          opj_image_destroy(image);
#line 1491
          failed = 1;
          }
#line 1492
          goto fin;
        }
      }
      {
#line 1496
      __cil_tmp40 = opj_end_decompress(l_codec, l_stream);
#line 1496
      __cil_tmp39 = opj_decode(l_codec, l_stream, image);
      }
#line 1496
      if (__cil_tmp39) {
#line 1496
        if (! __cil_tmp40) {
#line 1496
          goto _L___80;
        }
      } else {
        _L___80: /* CIL Label */ 
        {
#line 1498
        fprintf(stderr, "ERROR -> opj_decompress: failed to decode image!\n");
#line 1499
        opj_destroy_codec(l_codec);
#line 1500
        opj_stream_destroy(l_stream);
#line 1501
        opj_image_destroy(image);
#line 1502
        failed = 1;
        }
#line 1503
        goto fin;
      }
    } else {
      {
#line 1507
      __cil_tmp41 = opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index);
      }
#line 1507
      if (! __cil_tmp41) {
        {
#line 1508
        fprintf(stderr, "ERROR -> opj_decompress: failed to decode tile!\n\220");
#line 1509
        opj_destroy_codec(l_codec);
#line 1510
        opj_stream_destroy(l_stream);
#line 1511
        opj_image_destroy(image);
#line 1512
        failed = 1;
        }
#line 1513
        goto fin;
      }
#line 1515
      if (! parameters.quiet) {
        {
#line 1516
        fprintf(stdout, "tile %d is decoded!\n\nV", parameters.tile_index);
        }
      }
    }
#line 1522
    if ((unsigned long )(image->comps + 0)->data == (unsigned long )((void *)0)) {
      {
#line 1523
      fprintf(stderr, "ERROR -> opj_decompress: no image data!\n\220");
#line 1524
      opj_destroy_codec(l_codec);
#line 1525
      opj_stream_destroy(l_stream);
#line 1526
      opj_image_destroy(image);
#line 1527
      failed = 1;
      }
#line 1528
      goto fin;
    }
    {
#line 1531
    __cil_tmp42 = opj_clock();
#line 1531
    tCumulative += __cil_tmp42 - t;
#line 1532
    numDecompressedImages ++;
#line 1535
    opj_stream_destroy(l_stream);
    }
#line 1537
    if ((int )image->color_space != 3) {
#line 1537
      if (image->numcomps == 3U) {
#line 1537
        if ((image->comps + 0)->dx == (image->comps + 0)->dy) {
#line 1537
          if ((image->comps + 1)->dx != 1U) {
#line 1540
            image->color_space = (OPJ_COLOR_SPACE )3;
          } else {
#line 1537
            goto _L___76;
          }
        } else {
#line 1537
          goto _L___76;
        }
      } else {
#line 1537
        goto _L___76;
      }
    } else
    _L___76: 
#line 1541
    if (image->numcomps <= 2U) {
#line 1542
      image->color_space = (OPJ_COLOR_SPACE )2;
    }
#line 1545
    if ((int )image->color_space == 3) {
      {
#line 1546
      color_sycc_to_rgb(image);
      }
    } else
#line 1547
    if ((int )image->color_space == 5) {
#line 1547
      if (parameters.cod_format != 14) {
        {
#line 1549
        color_cmyk_to_rgb(image);
        }
      } else {
#line 1547
        goto _L___79;
      }
    } else
    _L___79: 
#line 1550
    if ((int )image->color_space == 4) {
      {
#line 1551
      color_esycc_to_rgb(image);
      }
    }
#line 1554
    if (image->icc_profile_buf) {
      {
#line 1562
      free((void *)image->icc_profile_buf);
#line 1563
      image->icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 1564
      image->icc_profile_len = (OPJ_UINT32 )0;
      }
    }
#line 1569
    if ((unsigned long )parameters.precision != (unsigned long )((void *)0)) {
#line 1571
      compno = (OPJ_UINT32 )0;
      {
#line 1571
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1571
        if (! (compno < image->numcomps)) {
#line 1571
          goto while_break___1;
        }
#line 1572
        precno = compno;
#line 1575
        if (precno >= parameters.nb_precision) {
#line 1576
          precno = parameters.nb_precision - 1U;
        }
#line 1579
        prec = (parameters.precision + precno)->prec;
#line 1580
        if (prec == 0U) {
#line 1581
          prec = (image->comps + compno)->prec;
        }
#line 1585
        if ((unsigned int )(parameters.precision + precno)->mode == 0U) {
#line 1585
          goto case_0___0;
        }
#line 1588
        if ((unsigned int )(parameters.precision + precno)->mode == 1U) {
#line 1588
          goto case_1___0;
        }
#line 1591
        goto switch_default___0;
        case_0___0: 
        {
#line 1586
        clip_component(image->comps + compno, prec);
        }
#line 1587
        goto switch_break___0;
        case_1___0: 
        {
#line 1589
        scale_component(image->comps + compno, prec);
        }
#line 1590
        goto switch_break___0;
        switch_default___0: 
#line 1592
        goto switch_break___0;
        switch_break___0: 
#line 1571
        compno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 1600
    if (parameters.upsample) {
      {
#line 1601
      image = upsample_image_components(image);
      }
#line 1602
      if ((unsigned long )image == (unsigned long )((void *)0)) {
        {
#line 1603
        fprintf(stderr, "ERROR -> opj_decompress: failed to upsample image components!\n");
#line 1605
        opj_destroy_codec(l_codec);
#line 1606
        failed = 1;
        }
#line 1607
        goto fin;
      }
    }
#line 1613
    if (parameters.force_rgb) {
#line 1615
      if ((int )image->color_space == 1) {
#line 1615
        goto case_1___1;
      }
#line 1617
      if ((int )image->color_space == 2) {
#line 1617
        goto case_2___0;
      }
#line 1620
      goto switch_default___1;
      case_1___1: 
#line 1616
      goto switch_break___1;
      case_2___0: 
      {
#line 1618
      image = convert_gray_to_rgb(image);
      }
#line 1619
      goto switch_break___1;
      switch_default___1: 
      {
#line 1621
      fprintf(stderr, "ERROR -> opj_decompress: don\'t know how to convert image to RGB colorspace!\n");
#line 1623
      opj_image_destroy(image);
#line 1624
      image = (opj_image_t *)((void *)0);
      }
#line 1625
      goto switch_break___1;
      switch_break___1: ;
#line 1627
      if ((unsigned long )image == (unsigned long )((void *)0)) {
        {
#line 1628
        fprintf(stderr, "ERROR -> opj_decompress: failed to convert to RGB image!\n");
#line 1629
        opj_destroy_codec(l_codec);
#line 1630
        failed = 1;
        }
#line 1631
        goto fin;
      }
    }
#line 1638
    if (parameters.cod_format == 10) {
#line 1638
      goto case_10;
    }
#line 1647
    if (parameters.cod_format == 11) {
#line 1647
      goto case_11;
    }
#line 1656
    if (parameters.cod_format == 12) {
#line 1656
      goto case_12;
    }
#line 1665
    if (parameters.cod_format == 14) {
#line 1665
      goto case_14;
    }
#line 1674
    if (parameters.cod_format == 15) {
#line 1674
      goto case_15;
    }
#line 1684
    if (parameters.cod_format == 18) {
#line 1684
      goto case_18;
    }
#line 1695
    if (parameters.cod_format == 16) {
#line 1695
      goto case_16;
    }
#line 1705
    if (parameters.cod_format == 17) {
#line 1705
      goto case_17;
    }
#line 1718
    goto switch_default___2;
    case_10: 
    {
#line 1639
    __cil_tmp49 = imagetopnm(image, (char const   *)(parameters.outfile), parameters.split_pnm);
    }
#line 1639
    if (__cil_tmp49) {
      {
#line 1640
      fprintf(stderr, "[ERROR] Outfile %s not generated\n", parameters.outfile);
#line 1641
      failed = 1;
      }
    } else
#line 1642
    if (! parameters.quiet) {
      {
#line 1643
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1645
    goto switch_break___2;
    case_11: 
    {
#line 1648
    __cil_tmp50 = imagetopgx(image, (char const   *)(parameters.outfile));
    }
#line 1648
    if (__cil_tmp50) {
      {
#line 1649
      fprintf(stderr, "[ERROR] Outfile %s not generated\n", parameters.outfile);
#line 1650
      failed = 1;
      }
    } else
#line 1651
    if (! parameters.quiet) {
      {
#line 1652
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1654
    goto switch_break___2;
    case_12: 
    {
#line 1657
    __cil_tmp51 = imagetobmp(image, (char const   *)(parameters.outfile));
    }
#line 1657
    if (__cil_tmp51) {
      {
#line 1658
      fprintf(stderr, "[ERROR] Outfile %s not generated\n", parameters.outfile);
#line 1659
      failed = 1;
      }
    } else
#line 1660
    if (! parameters.quiet) {
      {
#line 1661
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1663
    goto switch_break___2;
    case_14: 
    {
#line 1666
    __cil_tmp52 = imagetotif(image, (char const   *)(parameters.outfile));
    }
#line 1666
    if (__cil_tmp52) {
      {
#line 1667
      fprintf(stderr, "[ERROR] Outfile %s not generated\n", parameters.outfile);
#line 1668
      failed = 1;
      }
    } else
#line 1669
    if (! parameters.quiet) {
      {
#line 1670
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1672
    goto switch_break___2;
    case_15: 
    {
#line 1675
    __cil_tmp53 = imagetoraw(image, (char const   *)(parameters.outfile));
    }
#line 1675
    if (__cil_tmp53) {
      {
#line 1676
      fprintf(stderr, "[ERROR] Error generating raw file. Outfile %s not generated\n",
              parameters.outfile);
#line 1678
      failed = 1;
      }
    } else
#line 1679
    if (! parameters.quiet) {
      {
#line 1680
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1682
    goto switch_break___2;
    case_18: 
    {
#line 1685
    __cil_tmp54 = imagetorawl(image, (char const   *)(parameters.outfile));
    }
#line 1685
    if (__cil_tmp54) {
      {
#line 1686
      fprintf(stderr, "[ERROR] Error generating rawl file. Outfile %s not generated\n",
              parameters.outfile);
#line 1689
      failed = 1;
      }
    } else
#line 1690
    if (! parameters.quiet) {
      {
#line 1691
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1693
    goto switch_break___2;
    case_16: 
    {
#line 1696
    __cil_tmp55 = imagetotga(image, (char const   *)(parameters.outfile));
    }
#line 1696
    if (__cil_tmp55) {
      {
#line 1697
      fprintf(stderr, "[ERROR] Error generating tga file. Outfile %s not generated\n",
              parameters.outfile);
#line 1699
      failed = 1;
      }
    } else
#line 1700
    if (! parameters.quiet) {
      {
#line 1701
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1703
    goto switch_break___2;
    case_17: 
    {
#line 1706
    __cil_tmp56 = imagetopng(image, (char const   *)(parameters.outfile));
    }
#line 1706
    if (__cil_tmp56) {
      {
#line 1707
      fprintf(stderr, "[ERROR] Error generating png file. Outfile %s not generated\n",
              parameters.outfile);
#line 1709
      failed = 1;
      }
    } else
#line 1710
    if (! parameters.quiet) {
      {
#line 1711
      fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 1713
    goto switch_break___2;
    switch_default___2: 
    {
#line 1719
    fprintf(stderr, "[ERROR] Outfile %s not generated\n", parameters.outfile);
#line 1720
    failed = 1;
    }
    switch_break___2: ;
#line 1724
    if (l_codec) {
      {
#line 1725
      opj_destroy_codec(l_codec);
      }
    }
    {
#line 1730
    opj_image_destroy(image);
#line 1733
    opj_destroy_cstr_index(& cstr_index);
    }
#line 1735
    if (failed) {
      {
#line 1736
      remove((char const   *)(parameters.outfile));
      }
    }
#line 1364
    imageno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
  fin: 
  {
#line 1740
  destroy_parameters(& parameters);
  }
#line 1741
  if (img_fol.imgdirpath) {
#line 1741
    if (failed) {
      {
#line 1742
      free((void *)img_fol.imgdirpath);
      }
    }
  }
#line 1744
  if (dirptr) {
#line 1745
    if (dirptr->filename) {
      {
#line 1746
      free((void *)dirptr->filename);
      }
    }
#line 1748
    if (dirptr->filename_buf) {
      {
#line 1749
      free((void *)dirptr->filename_buf);
      }
    }
    {
#line 1751
    free((void *)dirptr);
    }
  }
#line 1753
  if (numDecompressedImages) {
#line 1753
    if (! failed) {
#line 1753
      if (! parameters.quiet) {
        {
#line 1754
        fprintf(stdout, "decode time: %d ms\n", (int )((tCumulative * 1000.) / (OPJ_FLOAT64 )numDecompressedImages));
        }
      }
    }
  }
#line 1757
  if (failed) {
#line 1757
    tmp = 1;
  } else {
#line 1757
    tmp = 0;
  }
#line 1757
  return (tmp);
}
}
