/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef int wchar_t;
#line 391 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 393 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 394 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 400 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 409 "/usr/include/zconf.h"
typedef void *voidpf;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 85 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 108 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 99 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 84 "/usr/include/zlib.h"
struct internal_state ;
#line 86 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf  , uInt  , uInt  ) ;
   void (*zfree)(voidpf  , voidpf  ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 106 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 108 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 18 "./zipconf.h"
typedef int8_t zip_int8_t;
#line 22 "./zipconf.h"
typedef uint8_t zip_uint8_t;
#line 25 "./zipconf.h"
typedef int16_t zip_int16_t;
#line 29 "./zipconf.h"
typedef uint16_t zip_uint16_t;
#line 32 "./zipconf.h"
typedef int32_t zip_int32_t;
#line 36 "./zipconf.h"
typedef uint32_t zip_uint32_t;
#line 39 "./zipconf.h"
typedef int64_t zip_int64_t;
#line 43 "./zipconf.h"
typedef uint64_t zip_uint64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 214 "/root/patchweave_new/24/lib/zip.h"
enum zip_source_cmd {
    ZIP_SOURCE_OPEN = 0,
    ZIP_SOURCE_READ = 1,
    ZIP_SOURCE_CLOSE = 2,
    ZIP_SOURCE_STAT = 3,
    ZIP_SOURCE_ERROR = 4,
    ZIP_SOURCE_FREE = 5,
    ZIP_SOURCE_SEEK = 6,
    ZIP_SOURCE_TELL = 7,
    ZIP_SOURCE_BEGIN_WRITE = 8,
    ZIP_SOURCE_COMMIT_WRITE = 9,
    ZIP_SOURCE_ROLLBACK_WRITE = 10,
    ZIP_SOURCE_WRITE = 11,
    ZIP_SOURCE_SEEK_WRITE = 12,
    ZIP_SOURCE_TELL_WRITE = 13,
    ZIP_SOURCE_SUPPORTS = 14,
    ZIP_SOURCE_REMOVE = 15,
    ZIP_SOURCE_GET_COMPRESSION_FLAGS = 16
} ;
#line 233 "/root/patchweave_new/24/lib/zip.h"
typedef enum zip_source_cmd zip_source_cmd_t;
#line 259 "/root/patchweave_new/24/lib/zip.h"
struct zip_source_args_seek {
   zip_int64_t offset ;
   int whence ;
};
#line 264 "/root/patchweave_new/24/lib/zip.h"
typedef struct zip_source_args_seek zip_source_args_seek_t;
#line 270 "/root/patchweave_new/24/lib/zip.h"
struct zip_error {
   int zip_err ;
   int sys_err ;
   char *str ;
};
#line 286 "/root/patchweave_new/24/lib/zip.h"
struct zip_stat {
   zip_uint64_t valid ;
   char const   *name ;
   zip_uint64_t index ;
   zip_uint64_t size ;
   zip_uint64_t comp_size ;
   time_t mtime ;
   zip_uint32_t crc ;
   zip_uint16_t comp_method ;
   zip_uint16_t encryption_method ;
   zip_uint32_t flags ;
};
#line 299
struct zip ;
#line 300
struct zip_file ;
#line 301
struct zip_source ;
#line 303 "/root/patchweave_new/24/lib/zip.h"
typedef struct zip zip_t;
#line 304 "/root/patchweave_new/24/lib/zip.h"
typedef struct zip_error zip_error_t;
#line 305 "/root/patchweave_new/24/lib/zip.h"
typedef struct zip_file zip_file_t;
#line 306 "/root/patchweave_new/24/lib/zip.h"
typedef struct zip_source zip_source_t;
#line 307 "/root/patchweave_new/24/lib/zip.h"
typedef struct zip_stat zip_stat_t;
#line 309 "/root/patchweave_new/24/lib/zip.h"
typedef zip_uint32_t zip_flags_t;
#line 99 "/root/patchweave_new/24/lib/zipint.h"
typedef zip_source_t *(*zip_encryption_implementation)(zip_t * , zip_source_t * ,
                                                       zip_uint16_t  , int  , char const   * );
#line 103
enum zip_compression_status {
    ZIP_COMPRESSION_OK = 0,
    ZIP_COMPRESSION_END = 1,
    ZIP_COMPRESSION_ERROR = 2,
    ZIP_COMPRESSION_NEED_DATA = 3
} ;
#line 109 "/root/patchweave_new/24/lib/zipint.h"
typedef enum zip_compression_status zip_compression_status_t;
#line 111 "/root/patchweave_new/24/lib/zipint.h"
struct zip_compression_algorithm {
   void *(*allocate)(zip_uint16_t  , int  , zip_error_t * ) ;
   void (*deallocate)(void * ) ;
   int (*compression_flags)(void * ) ;
   int (*start)(void * ) ;
   int (*end)(void * ) ;
   int (*input)(void * , zip_uint8_t * , zip_uint64_t  ) ;
   void (*end_of_input)(void * ) ;
   zip_compression_status_t (*process)(void * , zip_uint8_t * , zip_uint64_t * ) ;
};
#line 134 "/root/patchweave_new/24/lib/zipint.h"
typedef struct zip_compression_algorithm zip_compression_algorithm_t;
#line 188
enum zip_encoding_type {
    ZIP_ENCODING_UNKNOWN = 0,
    ZIP_ENCODING_ASCII = 1,
    ZIP_ENCODING_UTF8_KNOWN = 2,
    ZIP_ENCODING_UTF8_GUESSED = 3,
    ZIP_ENCODING_CP437 = 4,
    ZIP_ENCODING_ERROR = 5
} ;
#line 197 "/root/patchweave_new/24/lib/zipint.h"
typedef enum zip_encoding_type zip_encoding_type_t;
#line 199
struct zip_hash ;
#line 200
struct zip_progress ;
#line 202
struct zip_cdir ;
#line 202 "/root/patchweave_new/24/lib/zipint.h"
typedef struct zip_cdir zip_cdir_t;
#line 203
struct zip_dirent ;
#line 203 "/root/patchweave_new/24/lib/zipint.h"
typedef struct zip_dirent zip_dirent_t;
#line 204
struct zip_entry ;
#line 204 "/root/patchweave_new/24/lib/zipint.h"
typedef struct zip_entry zip_entry_t;
#line 205
struct zip_extra_field ;
#line 205 "/root/patchweave_new/24/lib/zipint.h"
typedef struct zip_extra_field zip_extra_field_t;
#line 206
struct zip_string ;
#line 206 "/root/patchweave_new/24/lib/zipint.h"
typedef struct zip_string zip_string_t;
#line 207
struct zip_buffer ;
#line 207 "/root/patchweave_new/24/lib/zipint.h"
typedef struct zip_buffer zip_buffer_t;
#line 208 "/root/patchweave_new/24/lib/zipint.h"
typedef struct zip_hash zip_hash_t;
#line 209 "/root/patchweave_new/24/lib/zipint.h"
typedef struct zip_progress zip_progress_t;
#line 213 "/root/patchweave_new/24/lib/zipint.h"
struct zip {
   zip_source_t *src ;
   unsigned int open_flags ;
   zip_error_t error ;
   unsigned int flags ;
   unsigned int ch_flags ;
   char *default_password ;
   zip_string_t *comment_orig ;
   zip_string_t *comment_changes ;
   int comment_changed ;
   zip_uint64_t nentry ;
   zip_uint64_t nentry_alloc ;
   zip_entry_t *entry ;
   unsigned int nopen_source ;
   unsigned int nopen_source_alloc ;
   zip_source_t **open_source ;
   zip_hash_t *names ;
   zip_progress_t *progress ;
};
#line 242 "/root/patchweave_new/24/lib/zipint.h"
struct zip_file {
   zip_t *za ;
   zip_error_t error ;
   int eof ;
   zip_source_t *src ;
};
#line 261 "/root/patchweave_new/24/lib/zipint.h"
struct zip_dirent {
   zip_uint32_t changed ;
   int local_extra_fields_read ;
   int cloned ;
   int crc_valid ;
   zip_uint16_t version_madeby ;
   zip_uint16_t version_needed ;
   zip_uint16_t bitflags ;
   zip_int32_t comp_method ;
   time_t last_mod ;
   zip_uint32_t crc ;
   zip_uint64_t comp_size ;
   zip_uint64_t uncomp_size ;
   zip_string_t *filename ;
   zip_extra_field_t *extra_fields ;
   zip_string_t *comment ;
   zip_uint32_t disk_number ;
   zip_uint16_t int_attrib ;
   zip_uint32_t ext_attrib ;
   zip_uint64_t offset ;
   zip_uint16_t compression_level ;
   zip_uint16_t encryption_method ;
   char *password ;
};
#line 291 "/root/patchweave_new/24/lib/zipint.h"
struct zip_cdir {
   zip_entry_t *entry ;
   zip_uint64_t nentry ;
   zip_uint64_t nentry_alloc ;
   zip_uint64_t size ;
   zip_uint64_t offset ;
   zip_string_t *comment ;
   int is_zip64 ;
};
#line 302 "/root/patchweave_new/24/lib/zipint.h"
struct zip_extra_field {
   zip_extra_field_t *next ;
   zip_flags_t flags ;
   zip_uint16_t id ;
   zip_uint16_t size ;
   zip_uint8_t *data ;
};
#line 310
enum zip_source_write_state {
    ZIP_SOURCE_WRITE_CLOSED = 0,
    ZIP_SOURCE_WRITE_OPEN = 1,
    ZIP_SOURCE_WRITE_FAILED = 2,
    ZIP_SOURCE_WRITE_REMOVED = 3
} ;
#line 316 "/root/patchweave_new/24/lib/zipint.h"
typedef enum zip_source_write_state zip_source_write_state_t;
#line 320 "/root/patchweave_new/24/lib/zipint.h"
union __anonunion_22 {
   zip_int64_t (*f)(void * , void * , zip_uint64_t  , zip_source_cmd_t  ) ;
   zip_int64_t (*l)(zip_source_t * , void * , void * , zip_uint64_t  , enum zip_source_cmd  ) ;
};
#line 318 "/root/patchweave_new/24/lib/zipint.h"
struct zip_source {
   zip_source_t *src ;
   union __anonunion_22 cb ;
   void *ud ;
   zip_error_t error ;
   zip_int64_t supports ;
   unsigned int open_count ;
   zip_source_write_state_t write_state ;
   int source_closed ;
   zip_t *source_archive ;
   unsigned int refcount ;
   int eof ;
};
#line 341 "/root/patchweave_new/24/lib/zipint.h"
struct zip_entry {
   zip_dirent_t *orig ;
   zip_dirent_t *changes ;
   zip_source_t *source ;
   int deleted ;
};
#line 351 "/root/patchweave_new/24/lib/zipint.h"
struct zip_string {
   zip_uint8_t *raw ;
   zip_uint16_t length ;
   enum zip_encoding_type encoding ;
   zip_uint8_t *converted ;
   zip_uint32_t converted_length ;
};
#line 362 "/root/patchweave_new/24/lib/zipint.h"
struct zip_buffer {
   int ok ;
   int free_data ;
   zip_uint8_t *data ;
   zip_uint64_t size ;
   zip_uint64_t offset ;
};
#line 373 "/root/patchweave_new/24/lib/zipint.h"
struct zip_filelist {
   zip_uint64_t idx ;
};
#line 378 "/root/patchweave_new/24/lib/zipint.h"
typedef struct zip_filelist zip_filelist_t;
#line 53 "./gladman-fcrypt/aes.h"
typedef zip_uint32_t aes_32t;
#line 80 "./gladman-fcrypt/aes.h"
struct __anonstruct_85 {
   aes_32t k_sch[64] ;
   aes_32t n_rnd ;
   aes_32t n_blk ;
};
#line 87 "./gladman-fcrypt/aes.h"
typedef struct __anonstruct_85 aes_ctx;
#line 53 "./gladman-fcrypt/sha1.h"
typedef zip_uint32_t sha1_32t;
#line 57 "./gladman-fcrypt/sha1.h"
struct __anonstruct_86 {
   sha1_32t count[2] ;
   sha1_32t hash[5] ;
   sha1_32t wbuf[16] ;
};
#line 61 "./gladman-fcrypt/sha1.h"
typedef struct __anonstruct_86 sha1_ctx;
#line 55 "./gladman-fcrypt/hmac.h"
struct __anonstruct_87 {
   unsigned char key[64] ;
   sha1_ctx ctx[1] ;
   unsigned int klen ;
};
#line 59 "./gladman-fcrypt/hmac.h"
typedef struct __anonstruct_87 hmac_ctx;
#line 84 "./gladman-fcrypt/fileenc.h"
struct __anonstruct_88 {
   unsigned char nonce[16] ;
   unsigned char encr_bfr[16] ;
   aes_ctx encr_ctx[1] ;
   hmac_ctx auth_ctx[1] ;
   unsigned int encr_pos ;
   unsigned int pwd_len ;
   unsigned int mode ;
};
#line 92 "./gladman-fcrypt/fileenc.h"
typedef struct __anonstruct_88 fcrypt_ctx;
#line 47 "/root/patchweave_new/24/lib/zip_source_winzip_aes_encode.c"
struct winzip_aes {
   char *password ;
   unsigned int mode ;
   zip_uint16_t encryption_method ;
   zip_uint8_t data[18] ;
   zip_buffer_t *buffer ;
   fcrypt_ctx fcrypt_ctx ;
   int eof ;
   zip_error_t error ;
};
#line 47 "/root/patchweave_new/24/lib/zip_source_winzip_aes_decode.c"
struct winzip_aes___0 {
   char *password ;
   unsigned int mode ;
   zip_uint64_t data_length ;
   zip_uint64_t current_position ;
   fcrypt_ctx fcrypt_ctx ;
   zip_error_t error ;
};
#line 40 "/root/patchweave_new/24/lib/zip_source_window.c"
struct window {
   zip_uint64_t start ;
   zip_uint64_t end ;
   zip_t *source_archive ;
   zip_uint64_t source_index ;
   zip_uint64_t offset ;
   zip_stat_t stat ;
   zip_int8_t compression_flags ;
   zip_error_t error ;
   zip_int64_t supports ;
   int needs_seek ;
};
#line 40 "/root/patchweave_new/24/lib/zip_source_pkware.c"
struct trad_pkware {
   zip_error_t error ;
   zip_uint32_t key[3] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 67 "/root/patchweave_new/24/lib/zip_source_filep.c"
struct read_file {
   zip_error_t error ;
   zip_int64_t supports ;
   char *fname ;
   FILE *f ;
   struct zip_stat st ;
   zip_error_t stat_error ;
   zip_uint64_t start ;
   zip_uint64_t end ;
   zip_uint64_t current ;
   char *tmpname ;
   FILE *fout ;
};
#line 41 "/root/patchweave_new/24/lib/zip_source_crc.c"
struct crc_context {
   int validate ;
   int crc_complete ;
   zip_error_t error ;
   zip_uint64_t size ;
   zip_uint64_t position ;
   zip_uint64_t crc_position ;
   zip_uint32_t crc ;
};
#line 40 "/root/patchweave_new/24/lib/zip_source_compress.c"
struct context {
   zip_error_t error ;
   int end_of_input ;
   int end_of_stream ;
   int can_store ;
   int is_stored ;
   int compress ;
   zip_int32_t method ;
   zip_uint64_t size ;
   zip_int64_t first_read ;
   zip_uint8_t buffer[8192] ;
   zip_compression_algorithm_t *algorithm ;
   void *ud ;
};
#line 59 "/root/patchweave_new/24/lib/zip_source_compress.c"
struct implementation {
   zip_uint16_t method ;
   zip_compression_algorithm_t *compress ;
   zip_compression_algorithm_t *decompress ;
};
#line 43 "/root/patchweave_new/24/lib/zip_source_buffer.c"
struct buffer {
   zip_uint64_t fragment_size ;
   zip_uint8_t **fragments ;
   zip_uint64_t nfragments ;
   zip_uint64_t fragments_capacity ;
   zip_uint64_t size ;
   zip_uint64_t offset ;
   int free_data ;
};
#line 54 "/root/patchweave_new/24/lib/zip_source_buffer.c"
typedef struct buffer buffer_t;
#line 56 "/root/patchweave_new/24/lib/zip_source_buffer.c"
struct read_data {
   zip_error_t error ;
   time_t mtime ;
   buffer_t *in ;
   buffer_t *out ;
};
#line 41 "/root/patchweave_new/24/lib/zip_progress.c"
struct zip_progress {
   zip_t *za ;
   void (*callback)(zip_t * , double  , void * ) ;
   void (*ud_free)(void * ) ;
   void *ud ;
   double precision ;
   double last_update ;
   double start ;
   double end ;
};
#line 154 "/root/patchweave_new/24/lib/zip_progress.c"
struct legacy_ud {
   void (*callback)(double  ) ;
};
#line 43 "/root/patchweave_new/24/lib/zip_open.c"
enum __anonenum__141 {
    EXISTS_ERROR = -1,
    EXISTS_NOT = 0,
    EXISTS_EMPTY = 1,
    EXISTS_NONEMPTY = 2
} ;
#line 48 "/root/patchweave_new/24/lib/zip_open.c"
typedef enum __anonenum__141 exists_t;
#line 50 "/root/patchweave_new/24/lib/zip_hash.c"
struct zip_hash_entry {
   zip_uint8_t *name ;
   zip_int64_t orig_index ;
   zip_int64_t current_index ;
   struct zip_hash_entry *next ;
   zip_uint32_t hash_value ;
};
#line 57 "/root/patchweave_new/24/lib/zip_hash.c"
typedef struct zip_hash_entry zip_hash_entry_t;
#line 59 "/root/patchweave_new/24/lib/zip_hash.c"
struct zip_hash {
   zip_uint32_t table_size ;
   zip_uint64_t nentries ;
   zip_hash_entry_t **table ;
};
#line 40 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
struct ctx {
   zip_error_t *error ;
   int compress ;
   int compression_flags ;
   int end_of_input ;
   z_stream zstr ;
};
#line 58 "/root/patchweave_new/24/src/ziptool.c"
enum __anonenum__230 {
    SOURCE_TYPE_NONE = 0,
    SOURCE_TYPE_IN_MEMORY = 1,
    SOURCE_TYPE_HOLE = 2
} ;
#line 62 "/root/patchweave_new/24/src/ziptool.c"
typedef enum __anonenum__230 source_type_t;
#line 64 "/root/patchweave_new/24/src/ziptool.c"
struct dispatch_table_s {
   char const   *cmdline_name ;
   int argument_count ;
   char const   *arg_names ;
   char const   *description ;
   int (*function)(int  , char ** ) ;
};
#line 70 "/root/patchweave_new/24/src/ziptool.c"
typedef struct dispatch_table_s dispatch_table_t;
#line 808 "/root/patchweave_new/24/src/ziptool.c"
struct source_nul {
   zip_error_t error ;
   zip_uint64_t length ;
   zip_uint64_t offset ;
};
#line 812 "/root/patchweave_new/24/src/ziptool.c"
typedef struct source_nul source_nul_t;
#line 61 "/root/patchweave_new/24/src/source_hole.c"
struct buffer___0 {
   zip_uint64_t fragment_size ;
   zip_uint8_t **fragment ;
   zip_uint64_t nfragments ;
   zip_uint64_t size ;
   zip_uint64_t offset ;
};
#line 67 "/root/patchweave_new/24/src/source_hole.c"
typedef struct buffer___0 buffer_t___0;
#line 83 "/root/patchweave_new/24/src/source_hole.c"
struct hole {
   zip_error_t error ;
   char *fname ;
   buffer_t___0 *in ;
   buffer_t___0 *out ;
};
#line 88 "/root/patchweave_new/24/src/source_hole.c"
typedef struct hole hole_t;
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
__inline extern ssize_t ( __attribute__((__gnu_inline__)) read)(int __fd , void *__buf ,
                                                                size_t __nbytes ) ;
#line 511
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf ,
                                                                                              size_t __size ) ;
#line 525
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) ;
#line 531
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 623
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) confstr)(int __name ,
                                                                                                char *__buf ,
                                                                                                size_t __len ) ;
#line 689
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getgroups)(int __size ,
                                                                                               __gid_t *__list ) ;
#line 774
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 808
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                                                  char *__buf ,
                                                                                                  size_t __len ) ;
#line 819
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    char *__buf ,
                                                                                                    size_t __len ) ;
#line 825
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 856
__inline extern int ( __attribute__((__gnu_inline__)) getlogin_r)(char *__buf , size_t __buflen ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 59
extern int optopt ;
#line 91
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 877 "/usr/include/unistd.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf ,
                                                                                                 size_t __buflen ) ;
#line 895
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                                                   size_t __buflen ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 25
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 27
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__gnu_inline__)) read)(int __fd , void *__buf ,
                                                                size_t __nbytes ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__buf, 0);
  }
#line 36
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 38
    __cil_tmp5 = 0;
#line 38
    if (! __cil_tmp5) {
      {
#line 39
      __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 39
      __cil_tmp7 = __read_chk(__fd, __buf, __nbytes, __cil_tmp6);
      }
#line 39
      return (__cil_tmp7);
    }
    {
#line 41
    __cil_tmp8 = __builtin_object_size(__buf, 0);
    }
#line 41
    if (__nbytes > __cil_tmp8) {
      {
#line 42
      __cil_tmp9 = __builtin_object_size(__buf, 0);
#line 42
      __cil_tmp10 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp9);
      }
#line 42
      return (__cil_tmp10);
    }
  }
  {
#line 44
  __cil_tmp11 = __read_alias(__fd, __buf, __nbytes);
  }
#line 44
  return (__cil_tmp11);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 139
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                                                  char *__buf ,
                                                                                                  size_t __len ) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                    char *__buf ,
                                                                    size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 142
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 142
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 144
    __cil_tmp5 = 0;
#line 144
    if (! __cil_tmp5) {
      {
#line 145
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 145
      __cil_tmp7 = __readlink_chk(__path, __buf, __len, __cil_tmp6);
      }
#line 145
      return (__cil_tmp7);
    }
    {
#line 147
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 147
    if (__len > __cil_tmp8) {
      {
#line 148
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 148
      __cil_tmp10 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp9);
      }
#line 148
      return (__cil_tmp10);
    }
  }
  {
#line 150
  __cil_tmp11 = __readlink_alias(__path, __buf, __len);
  }
#line 150
  return (__cil_tmp11);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 173
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    char *__buf ,
                                                                                                    size_t __len ) ;
#line 173 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd , char const   *__path ,
                                                                      char *__buf ,
                                                                      size_t __len ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 176
  __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
  }
#line 176
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 178
    __cil_tmp6 = 0;
#line 178
    if (! __cil_tmp6) {
      {
#line 179
      __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
#line 179
      __cil_tmp8 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp7);
      }
#line 179
      return (__cil_tmp8);
    }
    {
#line 181
    __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
    }
#line 181
    if (__len > __cil_tmp9) {
      {
#line 182
      __cil_tmp10 = __builtin_object_size((void *)__buf, 1);
#line 182
      __cil_tmp11 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp10);
      }
#line 182
      return (__cil_tmp11);
    }
  }
  {
#line 185
  __cil_tmp12 = __readlinkat_alias(__fd, __path, __buf, __len);
  }
#line 185
  return (__cil_tmp12);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 193
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf ,
                                                                                              size_t __size ) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 202
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 204
    __cil_tmp4 = 0;
#line 204
    if (! __cil_tmp4) {
      {
#line 205
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 205
      __cil_tmp6 = __getcwd_chk(__buf, __size, __cil_tmp5);
      }
#line 205
      return (__cil_tmp6);
    }
    {
#line 207
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 207
    if (__size > __cil_tmp7) {
      {
#line 208
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 208
      __cil_tmp9 = __getcwd_chk_warn(__buf, __size, __cil_tmp8);
      }
#line 208
      return (__cil_tmp9);
    }
  }
  {
#line 210
  __cil_tmp10 = __getcwd_alias(__buf, __size);
  }
#line 210
  return (__cil_tmp10);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 221
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) ;
#line 221 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 223
  __cil_tmp2 = __builtin_object_size((void *)__buf, 1);
  }
#line 223
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 224
    __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
#line 224
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 224
    return (__cil_tmp4);
  }
  {
#line 225
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 225
  return (__cil_tmp5);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) confstr)(int __name ,
                                                                                                char *__buf ,
                                                                                                size_t __len ) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) confstr)(int __name , char *__buf ,
                                                                  size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 242
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 242
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 244
    __cil_tmp5 = 0;
#line 244
    if (! __cil_tmp5) {
      {
#line 245
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 245
      __cil_tmp7 = __confstr_chk(__name, __buf, __len, __cil_tmp6);
      }
#line 245
      return (__cil_tmp7);
    }
    {
#line 247
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 247
    if (__cil_tmp8 < __len) {
      {
#line 248
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 248
      __cil_tmp10 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp9);
      }
#line 248
      return (__cil_tmp10);
    }
  }
  {
#line 250
  __cil_tmp11 = __confstr_alias(__name, __buf, __len);
  }
#line 250
  return (__cil_tmp11);
}
}
#line 254
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t *__list ,
                                                         size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t *__list ) ;
#line 258
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t *__list ,
                                                              size_t __listlen ) ;
#line 265
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getgroups)(int __size ,
                                                                                               __gid_t *__list ) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_object_size((void *)__list, 1);
  }
#line 267
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 269
    __cil_tmp4 = 0;
#line 269
    if (! __cil_tmp4) {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void *)__list, 1);
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
#line 270
      return (__cil_tmp6);
    } else
#line 269
    if (__size < 0) {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void *)__list, 1);
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
#line 270
      return (__cil_tmp6);
    }
    {
#line 272
    __cil_tmp7 = __builtin_object_size((void *)__list, 1);
    }
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > __cil_tmp7) {
      {
#line 273
      __cil_tmp8 = __builtin_object_size((void *)__list, 1);
#line 273
      __cil_tmp9 = __getgroups_chk_warn(__size, __list, __cil_tmp8);
      }
#line 273
      return (__cil_tmp9);
    }
  }
  {
#line 275
  __cil_tmp10 = __getgroups_alias(__size, __list);
  }
#line 275
  return (__cil_tmp10);
}
}
#line 279
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 284
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 291 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                                 size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 293
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 293
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 295
    __cil_tmp5 = 0;
#line 295
    if (! __cil_tmp5) {
      {
#line 296
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 296
      __cil_tmp7 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 296
      return (__cil_tmp7);
    }
    {
#line 298
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 298
    if (__buflen > __cil_tmp8) {
      {
#line 299
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 299
      __cil_tmp10 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 299
      return (__cil_tmp10);
    }
  }
  {
#line 301
  __cil_tmp11 = __ttyname_r_alias(__fd, __buf, __buflen);
  }
#line 301
  return (__cil_tmp11);
}
}
#line 306
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 308
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 310
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 317 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getlogin_r)(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 319
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 319
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 321
    __cil_tmp4 = 0;
#line 321
    if (! __cil_tmp4) {
      {
#line 322
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 322
      __cil_tmp6 = __getlogin_r_chk(__buf, __buflen, __cil_tmp5);
      }
#line 322
      return (__cil_tmp6);
    }
    {
#line 324
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 324
    if (__buflen > __cil_tmp7) {
      {
#line 325
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 325
      __cil_tmp9 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 325
      return (__cil_tmp9);
    }
  }
  {
#line 327
  __cil_tmp10 = __getlogin_r_alias(__buf, __buflen);
  }
#line 327
  return (__cil_tmp10);
}
}
#line 333
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 337
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf ,
                                                                                                 size_t __buflen ) ;
#line 344 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 346
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 348
    __cil_tmp4 = 0;
#line 348
    if (! __cil_tmp4) {
      {
#line 349
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 349
      __cil_tmp6 = __gethostname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 349
      return (__cil_tmp6);
    }
    {
#line 351
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 351
    if (__buflen > __cil_tmp7) {
      {
#line 352
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 352
      __cil_tmp9 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 352
      return (__cil_tmp9);
    }
  }
  {
#line 354
  __cil_tmp10 = __gethostname_alias(__buf, __buflen);
  }
#line 354
  return (__cil_tmp10);
}
}
#line 360
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 365
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                                                   size_t __buflen ) ;
#line 373 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                     size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 375
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 375
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 377
    __cil_tmp4 = 0;
#line 377
    if (! __cil_tmp4) {
      {
#line 378
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 378
      __cil_tmp6 = __getdomainname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 378
      return (__cil_tmp6);
    }
    {
#line 380
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 380
    if (__buflen > __cil_tmp7) {
      {
#line 381
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 381
      __cil_tmp9 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 381
      return (__cil_tmp9);
    }
  }
  {
#line 383
  __cil_tmp10 = __getdomainname_alias(__buf, __buflen);
  }
#line 383
  return (__cil_tmp10);
}
}
#line 250 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 363
extern int deflateEnd(z_streamp strm ) ;
#line 400
extern int inflate(z_streamp strm , int flush ) ;
#line 520
extern int inflateEnd(z_streamp strm ) ;
#line 1726
extern uLong crc32(uLong crc , Bytef *buf , uInt len ) ;
#line 1769
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
#line 1773
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
#line 1889
extern char const   *zError(int  ) ;
#line 297 "/usr/include/inttypes.h"
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                      char **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                       char **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                      __gwchar_t **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                       __gwchar_t **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 326
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 379
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 382
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 499
extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 500
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 510
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) ;
#line 646
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                                0L);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                                0L);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                                0L);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                                0L);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) sprintf)(char *__s , char const   *__fmt 
                                                               , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
#line 36
  __cil_tmp4 = (int )__builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) snprintf)(char *__s , size_t __n ,
                                                                char const   *__fmt 
                                                                , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 67
  __cil_tmp5 = (int )__builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s , size_t __n ,
                                                                 char const   *__fmt ,
                                                                 __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = (int )__builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 259
    __cil_tmp5 = 0;
#line 259
    if (! __cil_tmp5) {
      {
#line 260
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
#line 260
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size((void *)__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size((void *)__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 289
    __cil_tmp7 = 0;
#line 289
    __cil_tmp6 = 0;
#line 289
    if (! __cil_tmp6) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 350
    __cil_tmp7 = 0;
#line 350
    __cil_tmp6 = 0;
#line 350
    if (! __cil_tmp6) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
#line 362
  __cil_tmp14 = 0;
#line 362
  __cil_tmp13 = 0;
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;

#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: ;
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 331 "/root/patchweave_new/24/lib/zip.h"
int zip_close(zip_t *za___0 ) ;
#line 332
int zip_delete(zip_t *za___0 , zip_uint64_t idx ) ;
#line 333
zip_int64_t zip_dir_add(zip_t *za___0 , char const   *name , zip_flags_t flags ) ;
#line 334
void zip_discard(zip_t *za___0 ) ;
#line 336
zip_error_t *zip_get_error(zip_t *za___0 ) ;
#line 337
void zip_error_clear(zip_t *za___0 ) ;
#line 338
int zip_error_code_zip(zip_error_t *error ) ;
#line 339
int zip_error_code_system(zip_error_t *error ) ;
#line 340
void zip_error_fini(zip_error_t *err ) ;
#line 341
void zip_error_init(zip_error_t *err ) ;
#line 342
void zip_error_init_with_code(zip_error_t *error , int ze ) ;
#line 343
void zip_error_set(zip_error_t *err , int ze , int se ) ;
#line 344
char const   *zip_error_strerror(zip_error_t *err ) ;
#line 345
int zip_error_system_type(zip_error_t *error ) ;
#line 346
zip_int64_t zip_error_to_data(zip_error_t *error , void *data , zip_uint64_t length ) ;
#line 348
int zip_fclose(zip_file_t *zf ) ;
#line 349
zip_t *zip_fdopen(int fd_orig , int _flags , int *zep ) ;
#line 350
zip_int64_t zip_file_add(zip_t *za___0 , char const   *name , zip_source_t *source ,
                         zip_flags_t flags ) ;
#line 351
void zip_file_error_clear(zip_file_t *zf ) ;
#line 352
int zip_file_extra_field_delete(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_idx ,
                                zip_flags_t flags ) ;
#line 353
int zip_file_extra_field_delete_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                      zip_uint16_t ef_idx , zip_flags_t flags ) ;
#line 354
int zip_file_extra_field_set(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                             zip_uint16_t ef_idx , zip_uint8_t *data , zip_uint16_t len ,
                             zip_flags_t flags ) ;
#line 355
zip_int16_t zip_file_extra_fields_count(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ) ;
#line 356
zip_int16_t zip_file_extra_fields_count_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                              zip_flags_t flags ) ;
#line 357
zip_uint8_t *zip_file_extra_field_get(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_idx ,
                                      zip_uint16_t *idp , zip_uint16_t *lenp , zip_flags_t flags ) ;
#line 358
zip_uint8_t *zip_file_extra_field_get_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                            zip_uint16_t ef_idx , zip_uint16_t *lenp ,
                                            zip_flags_t flags ) ;
#line 359
char const   *zip_file_get_comment(zip_t *za___0 , zip_uint64_t idx , zip_uint32_t *lenp ,
                                   zip_flags_t flags ) ;
#line 360
zip_error_t *zip_file_get_error(zip_file_t *f ) ;
#line 361
int zip_file_get_external_attributes(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                                     zip_uint8_t *opsys , zip_uint32_t *attributes ) ;
#line 362
int zip_file_rename(zip_t *za___0 , zip_uint64_t idx , char const   *name , zip_flags_t flags ) ;
#line 363
int zip_file_replace(zip_t *za___0 , zip_uint64_t idx , zip_source_t *source , zip_flags_t flags ) ;
#line 364
int zip_file_set_comment(zip_t *za___0 , zip_uint64_t idx , char const   *comment ,
                         zip_uint16_t len , zip_flags_t flags ) ;
#line 365
int zip_file_set_encryption(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t method ,
                            char const   *password ) ;
#line 366
int zip_file_set_external_attributes(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                                     zip_uint8_t opsys , zip_uint32_t attributes ) ;
#line 367
int zip_file_set_mtime(zip_t *za___0 , zip_uint64_t idx , time_t mtime , zip_flags_t flags ) ;
#line 368
char const   *zip_file_strerror(zip_file_t *zf ) ;
#line 369
zip_file_t *zip_fopen(zip_t *za___0 , char const   *fname , zip_flags_t flags ) ;
#line 370
zip_file_t *zip_fopen_encrypted(zip_t *za___0 , char const   *fname , zip_flags_t flags ,
                                char const   *password ) ;
#line 371
zip_file_t *zip_fopen_index(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags ) ;
#line 372
zip_file_t *zip_fopen_index_encrypted(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags ,
                                      char const   *password ) ;
#line 373
zip_int64_t zip_fread(zip_file_t *zf , void *outbuf , zip_uint64_t toread ) ;
#line 374
zip_int8_t zip_fseek(zip_file_t *zf , zip_int64_t offset , int whence ) ;
#line 375
zip_int64_t zip_ftell(zip_file_t *zf ) ;
#line 376
char const   *zip_get_archive_comment(zip_t *za___0 , int *lenp , zip_flags_t flags ) ;
#line 377
int zip_get_archive_flag(zip_t *za___0 , zip_flags_t flag , zip_flags_t flags ) ;
#line 378
char const   *zip_get_name(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ) ;
#line 379
zip_int64_t zip_get_num_entries(zip_t *za___0 , zip_flags_t flags ) ;
#line 380
zip_int64_t zip_name_locate(zip_t *za___0 , char const   *fname , zip_flags_t flags ) ;
#line 381
zip_t *zip_open(char const   *fn , int _flags , int *zep ) ;
#line 382
zip_t *zip_open_from_source(zip_source_t *src , int _flags , zip_error_t *error ) ;
#line 383
int zip_register_progress_callback_with_state(zip_t *za___0 , double precision , void (*callback)(zip_t * ,
                                                                                                  double  ,
                                                                                                  void * ) ,
                                              void (*ud_free)(void * ) , void *ud ) ;
#line 384
int zip_set_archive_comment(zip_t *za___0 , char const   *comment , zip_uint16_t len ) ;
#line 385
int zip_set_archive_flag(zip_t *za___0 , zip_flags_t flag , int value ) ;
#line 386
int zip_set_default_password(zip_t *za___0 , char const   *passwd ) ;
#line 387
int zip_set_file_compression(zip_t *za___0 , zip_uint64_t idx , zip_int32_t method ,
                             zip_uint32_t flags ) ;
#line 388
int zip_source_begin_write(zip_source_t *src ) ;
#line 389
zip_source_t *zip_source_buffer(zip_t *za___0 , void const   *data , zip_uint64_t len ,
                                int freep ) ;
#line 390
zip_source_t *zip_source_buffer_create(void const   *data , zip_uint64_t len , int freep ,
                                       zip_error_t *error ) ;
#line 391
int zip_source_close(zip_source_t *src ) ;
#line 392
int zip_source_commit_write(zip_source_t *src ) ;
#line 393
zip_error_t *zip_source_error(zip_source_t *src ) ;
#line 394
zip_source_t *zip_source_file(zip_t *za___0 , char const   *fname , zip_uint64_t start___0 ,
                              zip_int64_t len ) ;
#line 395
zip_source_t *zip_source_file_create(char const   *fname , zip_uint64_t start___0 ,
                                     zip_int64_t length , zip_error_t *error ) ;
#line 396
zip_source_t *zip_source_filep(zip_t *za___0 , FILE *file , zip_uint64_t start___0 ,
                               zip_int64_t len ) ;
#line 397
zip_source_t *zip_source_filep_create(FILE *file , zip_uint64_t start___0 , zip_int64_t length ,
                                      zip_error_t *error ) ;
#line 398
void zip_source_free(zip_source_t *src ) ;
#line 399
zip_source_t *zip_source_function(zip_t *za___0 , zip_int64_t (*zcb)(void * , void * ,
                                                                     zip_uint64_t  ,
                                                                     zip_source_cmd_t  ) ,
                                  void *ud ) ;
#line 400
zip_source_t *zip_source_function_create(zip_int64_t (*zcb)(void * , void * , zip_uint64_t  ,
                                                            zip_source_cmd_t  ) ,
                                         void *ud , zip_error_t *error ) ;
#line 401
int zip_source_is_deleted(zip_source_t *src ) ;
#line 402
void zip_source_keep(zip_source_t *src ) ;
#line 403
zip_int64_t zip_source_make_command_bitmap(zip_source_cmd_t cmd0  , ...) ;
#line 404
int zip_source_open(zip_source_t *src ) ;
#line 405
zip_int64_t zip_source_read(zip_source_t *src , void *data , zip_uint64_t len ) ;
#line 406
void zip_source_rollback_write(zip_source_t *src ) ;
#line 407
int zip_source_seek(zip_source_t *src , zip_int64_t offset , int whence ) ;
#line 408
zip_int64_t zip_source_seek_compute_offset(zip_uint64_t offset , zip_uint64_t length ,
                                           void *data , zip_uint64_t data_length ,
                                           zip_error_t *error ) ;
#line 409
int zip_source_seek_write(zip_source_t *src , zip_int64_t offset , int whence ) ;
#line 410
int zip_source_stat(zip_source_t *src , zip_stat_t *st ) ;
#line 411
zip_int64_t zip_source_tell(zip_source_t *src ) ;
#line 412
zip_int64_t zip_source_tell_write(zip_source_t *src ) ;
#line 421
zip_int64_t zip_source_write(zip_source_t *src , void const   *data , zip_uint64_t length ) ;
#line 422
zip_source_t *zip_source_zip(zip_t *za___0 , zip_t *srcza , zip_uint64_t srcidx ,
                             zip_flags_t flags , zip_uint64_t start___0 , zip_int64_t len ) ;
#line 423
int zip_stat(zip_t *za___0 , char const   *fname , zip_flags_t flags , zip_stat_t *st ) ;
#line 424
int zip_stat_index(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags , zip_stat_t *st ) ;
#line 425
void zip_stat_init(zip_stat_t *st ) ;
#line 426
char const   *zip_strerror(zip_t *za___0 ) ;
#line 427
int zip_unchange(zip_t *za___0 , zip_uint64_t idx ) ;
#line 428
int zip_unchange_all(zip_t *za___0 ) ;
#line 429
int zip_unchange_archive(zip_t *za___0 ) ;
#line 101 "/root/patchweave_new/24/lib/zipint.h"
zip_encryption_implementation _zip_get_encryption_implementation(zip_uint16_t em ,
                                                                 int operation ) ;
#line 138
zip_compression_algorithm_t zip_algorithm_deflate_compress ;
#line 139
zip_compression_algorithm_t zip_algorithm_deflate_decompress ;
#line 141
int zip_compression_method_supported(zip_int32_t method , int compress___0 ) ;
#line 152
zip_source_t *zip_source_compress(zip_t *za___0 , zip_source_t *src , zip_int32_t method ,
                                  int compression_flags___0 ) ;
#line 153
zip_source_t *zip_source_crc(zip_t *za___0 , zip_source_t *src , int validate ) ;
#line 154
zip_source_t *zip_source_decompress(zip_t *za___0 , zip_source_t *src , zip_int32_t method ) ;
#line 155
zip_source_t *zip_source_layered(zip_t *za___0 , zip_source_t *src , zip_int64_t (*cb)(zip_source_t * ,
                                                                                       void * ,
                                                                                       void * ,
                                                                                       zip_uint64_t  ,
                                                                                       enum zip_source_cmd  ) ,
                                 void *ud ) ;
#line 156
zip_source_t *zip_source_layered_create(zip_source_t *src , zip_int64_t (*cb)(zip_source_t * ,
                                                                              void * ,
                                                                              void * ,
                                                                              zip_uint64_t  ,
                                                                              enum zip_source_cmd  ) ,
                                        void *ud , zip_error_t *error ) ;
#line 157
zip_source_t *zip_source_pkware(zip_t *za___0 , zip_source_t *src , zip_uint16_t em ,
                                int flags , char const   *password ) ;
#line 158
int zip_source_remove(zip_source_t *src ) ;
#line 159
zip_int64_t zip_source_supports(zip_source_t *src ) ;
#line 160
zip_source_t *zip_source_window(zip_t *za___0 , zip_source_t *src , zip_uint64_t start___0 ,
                                zip_uint64_t len ) ;
#line 161
zip_source_t *zip_source_winzip_aes_decode(zip_t *za___0 , zip_source_t *src , zip_uint16_t em ,
                                           int flags , char const   *password ) ;
#line 162
zip_source_t *zip_source_winzip_aes_encode(zip_t *za___0 , zip_source_t *src , zip_uint16_t encryption_method ,
                                           int flags , char const   *password ) ;
#line 381
char const   * const  _zip_err_str[32] ;
#line 382
int const   _zip_nerr_str ;
#line 383
int const   _zip_err_type[32] ;
#line 406
zip_int64_t _zip_add_entry(zip_t *za___0 ) ;
#line 408
zip_uint8_t *_zip_buffer_data(zip_buffer_t *buffer ) ;
#line 409
int _zip_buffer_eof(zip_buffer_t *buffer ) ;
#line 410
void _zip_buffer_free(zip_buffer_t *buffer ) ;
#line 411
zip_uint8_t *_zip_buffer_get(zip_buffer_t *buffer , zip_uint64_t length ) ;
#line 412
zip_uint16_t _zip_buffer_get_16(zip_buffer_t *buffer ) ;
#line 413
zip_uint32_t _zip_buffer_get_32(zip_buffer_t *buffer ) ;
#line 414
zip_uint64_t _zip_buffer_get_64(zip_buffer_t *buffer ) ;
#line 415
zip_uint8_t _zip_buffer_get_8(zip_buffer_t *buffer ) ;
#line 416
zip_uint64_t _zip_buffer_left(zip_buffer_t *buffer ) ;
#line 417
zip_buffer_t *_zip_buffer_new(zip_uint8_t *data , zip_uint64_t size ) ;
#line 418
zip_buffer_t *_zip_buffer_new_from_source(zip_source_t *src , zip_uint64_t size ,
                                          zip_uint8_t *buf , zip_error_t *error ) ;
#line 419
zip_uint64_t _zip_buffer_offset(zip_buffer_t *buffer ) ;
#line 420
int _zip_buffer_ok(zip_buffer_t *buffer ) ;
#line 421
zip_uint8_t *_zip_buffer_peek(zip_buffer_t *buffer , zip_uint64_t length ) ;
#line 422
int _zip_buffer_put(zip_buffer_t *buffer , void const   *src , size_t length ) ;
#line 423
int _zip_buffer_put_16(zip_buffer_t *buffer , zip_uint16_t i ) ;
#line 424
int _zip_buffer_put_32(zip_buffer_t *buffer , zip_uint32_t i ) ;
#line 425
int _zip_buffer_put_64(zip_buffer_t *buffer , zip_uint64_t i ) ;
#line 426
int _zip_buffer_put_8(zip_buffer_t *buffer , zip_uint8_t i ) ;
#line 427
zip_uint64_t _zip_buffer_read(zip_buffer_t *buffer , zip_uint8_t *data , zip_uint64_t length ) ;
#line 428
int _zip_buffer_skip(zip_buffer_t *buffer , zip_uint64_t length ) ;
#line 429
int _zip_buffer_set_offset(zip_buffer_t *buffer , zip_uint64_t offset ) ;
#line 430
zip_uint64_t _zip_buffer_size(zip_buffer_t *buffer ) ;
#line 433
void _zip_cdir_free(zip_cdir_t *cd ) ;
#line 434
int _zip_cdir_grow(zip_cdir_t *cd , zip_uint64_t additional_entries , zip_error_t *error ) ;
#line 435
zip_cdir_t *_zip_cdir_new(zip_uint64_t nentry , zip_error_t *error ) ;
#line 436
zip_int64_t _zip_cdir_write(zip_t *za___0 , zip_filelist_t *filelist , zip_uint64_t survivors ) ;
#line 437
void _zip_deregister_source(zip_t *za___0 , zip_source_t *src ) ;
#line 439
zip_dirent_t *_zip_dirent_clone(zip_dirent_t *sde ) ;
#line 440
void _zip_dirent_free(zip_dirent_t *zde ) ;
#line 441
void _zip_dirent_finalize(zip_dirent_t *zde ) ;
#line 442
void _zip_dirent_init(zip_dirent_t *de ) ;
#line 443
int _zip_dirent_needs_zip64(zip_dirent_t *de , zip_flags_t flags ) ;
#line 444
zip_dirent_t *_zip_dirent_new(void) ;
#line 445
zip_int64_t _zip_dirent_read(zip_dirent_t *zde , zip_source_t *src , zip_buffer_t *buffer ,
                             int local , zip_error_t *error ) ;
#line 446
void _zip_dirent_set_version_needed(zip_dirent_t *de , int force_zip64 ) ;
#line 447
zip_int32_t _zip_dirent_size(zip_source_t *src , zip_uint16_t flags , zip_error_t *error ) ;
#line 448
int _zip_dirent_write(zip_t *za___0 , zip_dirent_t *de , zip_flags_t flags ) ;
#line 450
zip_extra_field_t *_zip_ef_clone(zip_extra_field_t *ef , zip_error_t *error ) ;
#line 451
zip_extra_field_t *_zip_ef_delete_by_id(zip_extra_field_t *ef , zip_uint16_t id ,
                                        zip_uint16_t id_idx , zip_flags_t flags ) ;
#line 452
void _zip_ef_free(zip_extra_field_t *ef ) ;
#line 453
zip_uint8_t *_zip_ef_get_by_id(zip_extra_field_t *ef , zip_uint16_t *lenp , zip_uint16_t id ,
                               zip_uint16_t id_idx , zip_flags_t flags , zip_error_t *error ) ;
#line 454
zip_extra_field_t *_zip_ef_merge(zip_extra_field_t *to , zip_extra_field_t *from ) ;
#line 455
zip_extra_field_t *_zip_ef_new(zip_uint16_t id , zip_uint16_t size , zip_uint8_t *data ,
                               zip_flags_t flags ) ;
#line 456
int _zip_ef_parse(zip_uint8_t *data , zip_uint16_t len , zip_flags_t flags , zip_extra_field_t **ef_head_p ,
                  zip_error_t *error ) ;
#line 457
zip_extra_field_t *_zip_ef_remove_internal(zip_extra_field_t *ef ) ;
#line 458
zip_uint16_t _zip_ef_size(zip_extra_field_t *ef , zip_flags_t flags ) ;
#line 459
int _zip_ef_write(zip_t *za___0 , zip_extra_field_t *ef , zip_flags_t flags ) ;
#line 461
void _zip_entry_finalize(zip_entry_t *e ) ;
#line 462
void _zip_entry_init(zip_entry_t *e ) ;
#line 464
void _zip_error_clear(zip_error_t *err ) ;
#line 465
void _zip_error_get(zip_error_t *err , int *zep , int *sep ) ;
#line 467
void _zip_error_copy(zip_error_t *dst , zip_error_t *src ) ;
#line 468
void _zip_error_set_from_source(zip_error_t *err , zip_source_t *src ) ;
#line 472
int _zip_file_extra_field_prepare_for_change(zip_t *za___0 , zip_uint64_t idx ) ;
#line 474
zip_uint64_t _zip_file_get_offset(zip_t *za___0 , zip_uint64_t idx , zip_error_t *error ) ;
#line 476
int _zip_filerange_crc(zip_source_t *src , zip_uint64_t start___0 , zip_uint64_t len ,
                       uLong *crcp , zip_error_t *error ) ;
#line 478
zip_dirent_t *_zip_get_dirent(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                              zip_error_t *error ) ;
#line 480
enum zip_encoding_type _zip_guess_encoding(zip_string_t *str , zip_encoding_type_t expected_encoding ) ;
#line 481
zip_uint8_t *_zip_cp437_to_utf8(zip_uint8_t *_cp437buf , zip_uint32_t len , zip_uint32_t *utf8_lenp ,
                                zip_error_t *error ) ;
#line 483
int _zip_hash_add(zip_hash_t *hash , zip_uint8_t *name , zip_uint64_t index___0 ,
                  zip_flags_t flags , zip_error_t *error ) ;
#line 484
int _zip_hash_delete(zip_hash_t *hash , zip_uint8_t *name , zip_error_t *error ) ;
#line 485
void _zip_hash_free(zip_hash_t *hash ) ;
#line 486
zip_int64_t _zip_hash_lookup(zip_hash_t *hash , zip_uint8_t *name , zip_flags_t flags ,
                             zip_error_t *error ) ;
#line 487
zip_hash_t *_zip_hash_new(zip_error_t *error ) ;
#line 488
int _zip_hash_reserve_capacity(zip_hash_t *hash , zip_uint64_t capacity , zip_error_t *error ) ;
#line 489
int _zip_hash_revert(zip_hash_t *hash , zip_error_t *error ) ;
#line 491
zip_t *_zip_open(zip_source_t *src , unsigned int flags , zip_error_t *error ) ;
#line 493
void _zip_progress_end(zip_progress_t *progress ) ;
#line 494
void _zip_progress_free(zip_progress_t *progress ) ;
#line 495
zip_progress_t *_zip_progress_new(zip_t *za___0 , double precision , void (*callback)(zip_t * ,
                                                                                      double  ,
                                                                                      void * ) ,
                                  void (*ud_free)(void * ) , void *ud ) ;
#line 496
void _zip_progress_start(zip_progress_t *progress ) ;
#line 497
void _zip_progress_subrange(zip_progress_t *progress , double start___0 , double end___0 ) ;
#line 498
void _zip_progress_update(zip_progress_t *progress , double sub_current ) ;
#line 500
int zip_random(zip_uint8_t *buffer , zip_uint16_t length ) ;
#line 502
int _zip_read(zip_source_t *src , zip_uint8_t *b , zip_uint64_t length , zip_error_t *error ) ;
#line 504
zip_uint8_t *_zip_read_data(zip_buffer_t *buffer , zip_source_t *src , size_t length ,
                            int nulp , zip_error_t *error ) ;
#line 505
int _zip_read_local_ef(zip_t *za___0 , zip_uint64_t idx ) ;
#line 506
zip_string_t *_zip_read_string(zip_buffer_t *buffer , zip_source_t *src , zip_uint16_t len ,
                               int nulp , zip_error_t *error ) ;
#line 507
int _zip_register_source(zip_t *za___0 , zip_source_t *src ) ;
#line 509
void _zip_set_open_error(int *zep , zip_error_t *err , int ze ) ;
#line 511
zip_int64_t _zip_source_call(zip_source_t *src , void *data , zip_uint64_t length ,
                             zip_source_cmd_t command ) ;
#line 512
int _zip_source_eof(zip_source_t *src ) ;
#line 513
zip_source_t *_zip_source_file_or_p(char const   *fname , FILE *file , zip_uint64_t start___0 ,
                                    zip_int64_t len , zip_stat_t *st , zip_error_t *error ) ;
#line 514
zip_int8_t zip_source_get_compression_flags(zip_source_t *src ) ;
#line 515
int _zip_source_had_error(zip_source_t *src ) ;
#line 516
void _zip_source_invalidate(zip_source_t *src ) ;
#line 517
zip_source_t *_zip_source_new(zip_error_t *error ) ;
#line 518
int _zip_source_set_source_archive(zip_source_t *src , zip_t *za___0 ) ;
#line 519
zip_source_t *_zip_source_window_new(zip_source_t *src , zip_uint64_t start___0 ,
                                     zip_uint64_t length , zip_stat_t *st , zip_int8_t compression_flags___0 ,
                                     zip_t *source_archive , zip_uint64_t source_index ,
                                     zip_error_t *error ) ;
#line 520
zip_source_t *_zip_source_zip_new(zip_t *za___0 , zip_t *srcza , zip_uint64_t srcidx ,
                                  zip_flags_t flags , zip_uint64_t start___0 , zip_uint64_t len ,
                                  char const   *password ) ;
#line 522
int _zip_stat_merge(zip_stat_t *dst , zip_stat_t *src , zip_error_t *error ) ;
#line 523
int _zip_string_equal(zip_string_t *a , zip_string_t *b ) ;
#line 524
void _zip_string_free(zip_string_t *s ) ;
#line 525
zip_uint32_t _zip_string_crc32(zip_string_t *s ) ;
#line 526
zip_uint8_t *_zip_string_get(zip_string_t *string , zip_uint32_t *lenp , zip_flags_t flags ,
                             zip_error_t *error ) ;
#line 527
zip_uint16_t _zip_string_length(zip_string_t *s ) ;
#line 528
zip_string_t *_zip_string_new(zip_uint8_t *raw , zip_uint16_t length , zip_flags_t flags ,
                              zip_error_t *error ) ;
#line 529
int _zip_string_write(zip_t *za___0 , zip_string_t *s ) ;
#line 531
int _zip_changed(zip_t *za___0 , zip_uint64_t *survivorsp ) ;
#line 532
char const   *_zip_get_name(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                            zip_error_t *error ) ;
#line 534
void *_zip_memdup(void const   *mem , size_t len , zip_error_t *error ) ;
#line 535
zip_int64_t _zip_name_locate(zip_t *za___0 , char const   *fname , zip_flags_t flags ,
                             zip_error_t *error ) ;
#line 536
zip_t *_zip_new(zip_error_t *error ) ;
#line 538
zip_int64_t _zip_file_replace(zip_t *za___0 , zip_uint64_t idx , char const   *name ,
                              zip_source_t *source , zip_flags_t flags ) ;
#line 539
int _zip_set_name(zip_t *za___0 , zip_uint64_t idx , char const   *name , zip_flags_t flags ) ;
#line 540
void _zip_u2d_time(time_t intime , zip_uint16_t *dtime , zip_uint16_t *ddate ) ;
#line 541
int _zip_unchange(zip_t *za___0 , zip_uint64_t idx , int allow_duplicates ) ;
#line 542
void _zip_unchange_data(zip_entry_t *ze ) ;
#line 543
int _zip_write(zip_t *za___0 , void const   *data , zip_uint64_t length ) ;
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 820
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;

#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 42
  return ((void *)0);
}
}
#line 929 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd , char *__buf ,
                                                                 size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 68
    __cil_tmp5 = 0;
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 92
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                   char const   *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    __cil_tmp5 = 0;
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst , wchar_t *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 149
    __cil_tmp5 = 0;
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 40 "/root/patchweave_new/24/lib/zip_utf-8.c"
static zip_uint16_t _cp437_to_unicode[256]  = 
#line 40 "/root/patchweave_new/24/lib/zip_utf-8.c"
  {      (zip_uint16_t )8199,      (zip_uint16_t )9786,      (zip_uint16_t )9787,      (zip_uint16_t )9829, 
        (zip_uint16_t )9830,      (zip_uint16_t )9827,      (zip_uint16_t )9824,      (zip_uint16_t )8226, 
        (zip_uint16_t )9688,      (zip_uint16_t )9675,      (zip_uint16_t )9689,      (zip_uint16_t )9794, 
        (zip_uint16_t )9792,      (zip_uint16_t )9834,      (zip_uint16_t )9835,      (zip_uint16_t )9788, 
        (zip_uint16_t )9658,      (zip_uint16_t )9668,      (zip_uint16_t )8597,      (zip_uint16_t )8252, 
        (zip_uint16_t )182,      (zip_uint16_t )167,      (zip_uint16_t )9644,      (zip_uint16_t )8616, 
        (zip_uint16_t )8593,      (zip_uint16_t )8595,      (zip_uint16_t )8594,      (zip_uint16_t )8592, 
        (zip_uint16_t )8735,      (zip_uint16_t )8596,      (zip_uint16_t )9650,      (zip_uint16_t )9660, 
        (zip_uint16_t )32,      (zip_uint16_t )33,      (zip_uint16_t )34,      (zip_uint16_t )35, 
        (zip_uint16_t )36,      (zip_uint16_t )37,      (zip_uint16_t )38,      (zip_uint16_t )39, 
        (zip_uint16_t )40,      (zip_uint16_t )41,      (zip_uint16_t )42,      (zip_uint16_t )43, 
        (zip_uint16_t )44,      (zip_uint16_t )45,      (zip_uint16_t )46,      (zip_uint16_t )47, 
        (zip_uint16_t )48,      (zip_uint16_t )49,      (zip_uint16_t )50,      (zip_uint16_t )51, 
        (zip_uint16_t )52,      (zip_uint16_t )53,      (zip_uint16_t )54,      (zip_uint16_t )55, 
        (zip_uint16_t )56,      (zip_uint16_t )57,      (zip_uint16_t )58,      (zip_uint16_t )59, 
        (zip_uint16_t )60,      (zip_uint16_t )61,      (zip_uint16_t )62,      (zip_uint16_t )63, 
        (zip_uint16_t )64,      (zip_uint16_t )65,      (zip_uint16_t )66,      (zip_uint16_t )67, 
        (zip_uint16_t )68,      (zip_uint16_t )69,      (zip_uint16_t )70,      (zip_uint16_t )71, 
        (zip_uint16_t )72,      (zip_uint16_t )73,      (zip_uint16_t )74,      (zip_uint16_t )75, 
        (zip_uint16_t )76,      (zip_uint16_t )77,      (zip_uint16_t )78,      (zip_uint16_t )79, 
        (zip_uint16_t )80,      (zip_uint16_t )81,      (zip_uint16_t )82,      (zip_uint16_t )83, 
        (zip_uint16_t )84,      (zip_uint16_t )85,      (zip_uint16_t )86,      (zip_uint16_t )87, 
        (zip_uint16_t )88,      (zip_uint16_t )89,      (zip_uint16_t )90,      (zip_uint16_t )91, 
        (zip_uint16_t )92,      (zip_uint16_t )93,      (zip_uint16_t )94,      (zip_uint16_t )95, 
        (zip_uint16_t )96,      (zip_uint16_t )97,      (zip_uint16_t )98,      (zip_uint16_t )99, 
        (zip_uint16_t )100,      (zip_uint16_t )101,      (zip_uint16_t )102,      (zip_uint16_t )103, 
        (zip_uint16_t )104,      (zip_uint16_t )105,      (zip_uint16_t )106,      (zip_uint16_t )107, 
        (zip_uint16_t )108,      (zip_uint16_t )109,      (zip_uint16_t )110,      (zip_uint16_t )111, 
        (zip_uint16_t )112,      (zip_uint16_t )113,      (zip_uint16_t )114,      (zip_uint16_t )115, 
        (zip_uint16_t )116,      (zip_uint16_t )117,      (zip_uint16_t )118,      (zip_uint16_t )119, 
        (zip_uint16_t )120,      (zip_uint16_t )121,      (zip_uint16_t )122,      (zip_uint16_t )123, 
        (zip_uint16_t )124,      (zip_uint16_t )125,      (zip_uint16_t )126,      (zip_uint16_t )8962, 
        (zip_uint16_t )199,      (zip_uint16_t )252,      (zip_uint16_t )233,      (zip_uint16_t )226, 
        (zip_uint16_t )228,      (zip_uint16_t )224,      (zip_uint16_t )229,      (zip_uint16_t )231, 
        (zip_uint16_t )234,      (zip_uint16_t )235,      (zip_uint16_t )232,      (zip_uint16_t )239, 
        (zip_uint16_t )238,      (zip_uint16_t )236,      (zip_uint16_t )196,      (zip_uint16_t )197, 
        (zip_uint16_t )201,      (zip_uint16_t )230,      (zip_uint16_t )198,      (zip_uint16_t )244, 
        (zip_uint16_t )246,      (zip_uint16_t )242,      (zip_uint16_t )251,      (zip_uint16_t )249, 
        (zip_uint16_t )255,      (zip_uint16_t )214,      (zip_uint16_t )220,      (zip_uint16_t )162, 
        (zip_uint16_t )163,      (zip_uint16_t )165,      (zip_uint16_t )8359,      (zip_uint16_t )402, 
        (zip_uint16_t )225,      (zip_uint16_t )237,      (zip_uint16_t )243,      (zip_uint16_t )250, 
        (zip_uint16_t )241,      (zip_uint16_t )209,      (zip_uint16_t )170,      (zip_uint16_t )186, 
        (zip_uint16_t )191,      (zip_uint16_t )8976,      (zip_uint16_t )172,      (zip_uint16_t )189, 
        (zip_uint16_t )188,      (zip_uint16_t )161,      (zip_uint16_t )171,      (zip_uint16_t )187, 
        (zip_uint16_t )9617,      (zip_uint16_t )9618,      (zip_uint16_t )9619,      (zip_uint16_t )9474, 
        (zip_uint16_t )9508,      (zip_uint16_t )9569,      (zip_uint16_t )9570,      (zip_uint16_t )9558, 
        (zip_uint16_t )9557,      (zip_uint16_t )9571,      (zip_uint16_t )9553,      (zip_uint16_t )9559, 
        (zip_uint16_t )9565,      (zip_uint16_t )9564,      (zip_uint16_t )9563,      (zip_uint16_t )9488, 
        (zip_uint16_t )9492,      (zip_uint16_t )9524,      (zip_uint16_t )9516,      (zip_uint16_t )9500, 
        (zip_uint16_t )9472,      (zip_uint16_t )9532,      (zip_uint16_t )9566,      (zip_uint16_t )9567, 
        (zip_uint16_t )9562,      (zip_uint16_t )9556,      (zip_uint16_t )9577,      (zip_uint16_t )9574, 
        (zip_uint16_t )9568,      (zip_uint16_t )9552,      (zip_uint16_t )9580,      (zip_uint16_t )9575, 
        (zip_uint16_t )9576,      (zip_uint16_t )9572,      (zip_uint16_t )9573,      (zip_uint16_t )9561, 
        (zip_uint16_t )9560,      (zip_uint16_t )9554,      (zip_uint16_t )9555,      (zip_uint16_t )9579, 
        (zip_uint16_t )9578,      (zip_uint16_t )9496,      (zip_uint16_t )9484,      (zip_uint16_t )9608, 
        (zip_uint16_t )9604,      (zip_uint16_t )9612,      (zip_uint16_t )9616,      (zip_uint16_t )9600, 
        (zip_uint16_t )945,      (zip_uint16_t )223,      (zip_uint16_t )915,      (zip_uint16_t )960, 
        (zip_uint16_t )931,      (zip_uint16_t )963,      (zip_uint16_t )181,      (zip_uint16_t )964, 
        (zip_uint16_t )934,      (zip_uint16_t )920,      (zip_uint16_t )937,      (zip_uint16_t )948, 
        (zip_uint16_t )8734,      (zip_uint16_t )966,      (zip_uint16_t )949,      (zip_uint16_t )8745, 
        (zip_uint16_t )8801,      (zip_uint16_t )177,      (zip_uint16_t )8805,      (zip_uint16_t )8804, 
        (zip_uint16_t )8992,      (zip_uint16_t )8993,      (zip_uint16_t )247,      (zip_uint16_t )8776, 
        (zip_uint16_t )176,      (zip_uint16_t )8729,      (zip_uint16_t )183,      (zip_uint16_t )8730, 
        (zip_uint16_t )8319,      (zip_uint16_t )178,      (zip_uint16_t )9632,      (zip_uint16_t )160};
#line 117 "/root/patchweave_new/24/lib/zip_utf-8.c"
enum zip_encoding_type _zip_guess_encoding(zip_string_t *str , zip_encoding_type_t expected_encoding ) 
{ 
  zip_encoding_type_t enc ;
  zip_uint8_t *name ;
  zip_uint32_t i ;
  zip_uint32_t j ;
  zip_uint32_t ulen ;

  {
#line 123
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 124
    return ((enum zip_encoding_type )1);
  }
#line 126
  name = str->raw;
#line 128
  if ((unsigned int )str->encoding != 0U) {
#line 129
    enc = str->encoding;
  } else {
#line 131
    enc = (zip_encoding_type_t )1;
#line 132
    i = (zip_uint32_t )0;
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: ;
#line 132
      if (! (i < (unsigned int )str->length)) {
#line 132
        goto while_break;
      }
#line 133
      if ((int )*(name + i) > 31) {
#line 133
        if ((int )*(name + i) < 128) {
#line 134
          goto while_continue;
        } else {
#line 133
          goto _L;
        }
      } else
      _L: 
#line 133
      if ((int )*(name + i) == 13) {
#line 134
        goto while_continue;
      } else
#line 133
      if ((int )*(name + i) == 10) {
#line 134
        goto while_continue;
      } else
#line 133
      if ((int )*(name + i) == 9) {
#line 134
        goto while_continue;
      }
#line 136
      enc = (zip_encoding_type_t )3;
#line 137
      if (((int )*(name + i) & 224) == 192) {
#line 138
        ulen = (zip_uint32_t )1;
      } else
#line 139
      if (((int )*(name + i) & 240) == 224) {
#line 140
        ulen = (zip_uint32_t )2;
      } else
#line 141
      if (((int )*(name + i) & 248) == 240) {
#line 142
        ulen = (zip_uint32_t )3;
      } else {
#line 144
        enc = (zip_encoding_type_t )4;
#line 145
        goto while_break;
      }
#line 148
      if (i + ulen >= (unsigned int )str->length) {
#line 149
        enc = (zip_encoding_type_t )4;
#line 150
        goto while_break;
      }
#line 153
      j = (zip_uint32_t )1;
      {
#line 153
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 153
        if (! (j <= ulen)) {
#line 153
          goto while_break___0;
        }
#line 154
        if (((int )*(name + (i + j)) & 192) != 128) {
#line 155
          enc = (zip_encoding_type_t )4;
#line 156
          goto done;
        }
#line 153
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 159
      i += ulen;
#line 132
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
  done: 
#line 164
  str->encoding = enc;
#line 166
  if ((unsigned int )expected_encoding != 0U) {
#line 167
    if ((unsigned int )expected_encoding == 2U) {
#line 167
      if ((unsigned int )enc == 3U) {
#line 168
        enc = (zip_encoding_type_t )2;
#line 168
        str->encoding = enc;
      }
    }
#line 170
    if ((unsigned int )expected_encoding != (unsigned int )enc) {
#line 170
      if ((unsigned int )enc != 1U) {
#line 171
        return ((enum zip_encoding_type )5);
      }
    }
  }
#line 174
  return (enc);
}
}
#line 179 "/root/patchweave_new/24/lib/zip_utf-8.c"
static zip_uint32_t _zip_unicode_to_utf8_len(zip_uint32_t codepoint ) 
{ 


  {
#line 181
  if (codepoint < 128U) {
#line 182
    return ((zip_uint32_t )1);
  }
#line 183
  if (codepoint < 2048U) {
#line 184
    return ((zip_uint32_t )2);
  }
#line 185
  if (codepoint < 65536U) {
#line 186
    return ((zip_uint32_t )3);
  }
#line 187
  return ((zip_uint32_t )4);
}
}
#line 192 "/root/patchweave_new/24/lib/zip_utf-8.c"
static zip_uint32_t _zip_unicode_to_utf8(zip_uint32_t codepoint , zip_uint8_t *buf ) 
{ 


  {
#line 194
  if (codepoint < 128U) {
#line 195
    *(buf + 0) = (zip_uint8_t )(codepoint & 255U);
#line 196
    return ((zip_uint32_t )1);
  }
#line 198
  if (codepoint < 2048U) {
#line 199
    *(buf + 0) = (zip_uint8_t )(192U | ((codepoint >> 6) & 31U));
#line 200
    *(buf + 1) = (zip_uint8_t )(128U | (codepoint & 63U));
#line 201
    return ((zip_uint32_t )2);
  }
#line 203
  if (codepoint < 65536U) {
#line 204
    *(buf + 0) = (zip_uint8_t )(224U | ((codepoint >> 12) & 15U));
#line 205
    *(buf + 1) = (zip_uint8_t )(128U | ((codepoint >> 6) & 63U));
#line 206
    *(buf + 2) = (zip_uint8_t )(128U | (codepoint & 63U));
#line 207
    return ((zip_uint32_t )3);
  }
#line 209
  *(buf + 0) = (zip_uint8_t )(240U | ((codepoint >> 18) & 7U));
#line 210
  *(buf + 1) = (zip_uint8_t )(128U | ((codepoint >> 12) & 63U));
#line 211
  *(buf + 2) = (zip_uint8_t )(128U | ((codepoint >> 6) & 63U));
#line 212
  *(buf + 3) = (zip_uint8_t )(128U | (codepoint & 63U));
#line 213
  return ((zip_uint32_t )4);
}
}
#line 218 "/root/patchweave_new/24/lib/zip_utf-8.c"
zip_uint8_t *_zip_cp437_to_utf8(zip_uint8_t *_cp437buf , zip_uint32_t len , zip_uint32_t *utf8_lenp ,
                                zip_error_t *error ) 
{ 
  zip_uint8_t *cp437buf ;
  zip_uint8_t *utf8buf ;
  zip_uint32_t buflen ;
  zip_uint32_t i ;
  zip_uint32_t offset ;
  zip_uint32_t __cil_tmp10 ;
  void *__cil_tmp12 ;
  zip_uint32_t __cil_tmp13 ;

  {
#line 221
  cp437buf = _cp437buf;
#line 225
  if (len == 0U) {
#line 226
    if (utf8_lenp) {
#line 227
      *utf8_lenp = (zip_uint32_t )0;
    }
#line 228
    return ((zip_uint8_t *)((void *)0));
  }
#line 231
  buflen = (zip_uint32_t )1;
#line 232
  i = (zip_uint32_t )0;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;

#line 232
    if (! (i < len)) {
#line 232
      goto while_break;
    }
    {
#line 233
    __cil_tmp10 = _zip_unicode_to_utf8_len((zip_uint32_t )_cp437_to_unicode[*(cp437buf + i)]);
#line 233
    buflen += __cil_tmp10;
#line 232
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 235
  __cil_tmp12 = malloc((unsigned long )buflen);
#line 235
  utf8buf = (zip_uint8_t *)__cil_tmp12;
  }
#line 235
  if ((unsigned long )utf8buf == (unsigned long )((void *)0)) {
    {
#line 236
    zip_error_set(error, 14, 0);
    }
#line 237
    return ((zip_uint8_t *)((void *)0));
  }
#line 240
  offset = (zip_uint32_t )0;
#line 241
  i = (zip_uint32_t )0;
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 241
    if (! (i < len)) {
#line 241
      goto while_break___0;
    }
    {
#line 242
    __cil_tmp13 = _zip_unicode_to_utf8((zip_uint32_t )_cp437_to_unicode[*(cp437buf + i)],
                                       utf8buf + offset);
#line 242
    offset += __cil_tmp13;
#line 241
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 245
  *(utf8buf + (buflen - 1U)) = (zip_uint8_t )0;
#line 246
  if (utf8_lenp) {
#line 247
    *utf8_lenp = buflen - 1U;
  }
#line 248
  return (utf8buf);
}
}
#line 38 "/root/patchweave_new/24/lib/zip_unchange_data.c"
void _zip_unchange_data(zip_entry_t *ze ) 
{ 


  {
#line 40
  if (ze->source) {
    {
#line 41
    zip_source_free(ze->source);
#line 42
    ze->source = (zip_source_t *)((void *)0);
    }
  }
#line 45
  if ((unsigned long )ze->changes != (unsigned long )((void *)0)) {
#line 45
    if ((ze->changes)->changed & 1U) {
#line 45
      if ((ze->changes)->comp_method == -2) {
#line 46
        (ze->changes)->changed &= 4294967294U;
#line 47
        if ((ze->changes)->changed == 0U) {
          {
#line 48
          _zip_dirent_free(ze->changes);
#line 49
          ze->changes = (zip_dirent_t *)((void *)0);
          }
        }
      }
    }
  }
#line 53
  ze->deleted = 0;
#line 54
  return;
}
}
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                  char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size((void *)__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size((void *)__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_unchange_archive.c"
int zip_unchange_archive(zip_t *za___0 ) 
{ 


  {
#line 43
  if (za___0->comment_changed) {
    {
#line 44
    _zip_string_free(za___0->comment_changes);
#line 45
    za___0->comment_changes = (zip_string_t *)((void *)0);
#line 46
    za___0->comment_changed = 0;
    }
  }
#line 49
  za___0->ch_flags = za___0->flags;
#line 51
  return (0);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_unchange_all.c"
int zip_unchange_all(zip_t *za___0 ) 
{ 
  int ret ;
  zip_uint64_t i ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp7 ;

  {
  {
#line 46
  __cil_tmp4 = _zip_hash_revert(za___0->names, & za___0->error);
  }
#line 46
  if (! __cil_tmp4) {
#line 47
    return (-1);
  }
#line 50
  ret = 0;
#line 51
  i = (zip_uint64_t )0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;

#line 51
    if (! (i < za___0->nentry)) {
#line 51
      goto while_break;
    }
    {
#line 52
    __cil_tmp5 = _zip_unchange(za___0, i, 1);
#line 52
    ret |= __cil_tmp5;
#line 51
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 54
  __cil_tmp7 = zip_unchange_archive(za___0);
#line 54
  ret |= __cil_tmp7;
  }
#line 56
  return (ret);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_unchange.c"
int zip_unchange(zip_t *za___0 , zip_uint64_t idx ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 43
  __cil_tmp3 = _zip_unchange(za___0, idx, 0);
  }
#line 43
  return (__cil_tmp3);
}
}
#line 48 "/root/patchweave_new/24/lib/zip_unchange.c"
int _zip_unchange(zip_t *za___0 , zip_uint64_t idx , int allow_duplicates ) 
{ 
  zip_int64_t i ;
  char const   *orig_name ;
  char const   *changed_name ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 53
  if (idx >= za___0->nentry) {
    {
#line 54
    zip_error_set(& za___0->error, 18, 0);
    }
#line 55
    return (-1);
  }
#line 58
  if ((za___0->entry + idx)->changes) {
#line 58
    if (! allow_duplicates) {
#line 58
      if (((za___0->entry + idx)->changes)->changed & 2U) {
#line 59
        if ((unsigned long )(za___0->entry + idx)->orig != (unsigned long )((void *)0)) {
          {
#line 60
          orig_name = _zip_get_name(za___0, idx, 8U, & za___0->error);
          }
#line 60
          if ((unsigned long )orig_name == (unsigned long )((void *)0)) {
#line 61
            return (-1);
          }
          {
#line 64
          i = _zip_name_locate(za___0, orig_name, (zip_flags_t )0, (zip_error_t *)((void *)0));
          }
#line 65
          if (i >= 0L) {
#line 65
            if ((zip_uint64_t )i != idx) {
              {
#line 66
              zip_error_set(& za___0->error, 10, 0);
              }
#line 67
              return (-1);
            }
          }
        } else {
#line 71
          orig_name = (char const   *)((void *)0);
        }
        {
#line 74
        changed_name = _zip_get_name(za___0, idx, (zip_flags_t )0, & za___0->error);
        }
#line 74
        if ((unsigned long )changed_name == (unsigned long )((void *)0)) {
#line 75
          return (-1);
        }
#line 78
        if (orig_name) {
          {
#line 79
          __cil_tmp10 = _zip_hash_add(za___0->names, (zip_uint8_t *)orig_name, idx,
                                      (zip_flags_t )0, & za___0->error);
          }
#line 79
          if (__cil_tmp10 == 0) {
#line 80
            return (-1);
          }
        }
        {
#line 83
        __cil_tmp11 = _zip_hash_delete(za___0->names, (zip_uint8_t *)changed_name,
                                       & za___0->error);
        }
#line 83
        if (__cil_tmp11 == 0) {
          {
#line 84
          _zip_hash_delete(za___0->names, (zip_uint8_t *)orig_name, (zip_error_t *)((void *)0));
          }
#line 85
          return (-1);
        }
      }
    }
  }
  {
#line 89
  _zip_dirent_free((za___0->entry + idx)->changes);
#line 90
  (za___0->entry + idx)->changes = (zip_dirent_t *)((void *)0);
#line 92
  _zip_unchange_data(za___0->entry + idx);
  }
#line 94
  return (0);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 38 "/usr/include/strings.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                              void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 27
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) bzero)(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
#line 33
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                                                     size_t __len ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest , void const   *__src ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memmove)(void *__dest , void const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memset)(void *__dest , int __ch ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
extern  __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                               size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                                                     size_t __len ) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                       size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
#line 85
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                                                 size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size((void *)__dest, 1);
#line 118
  __cil_tmp5 = 0;
#line 118
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcat)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncat)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 42 "/root/patchweave_new/24/lib/zip_string.c"
zip_uint32_t _zip_string_crc32(zip_string_t *s ) 
{ 
  zip_uint32_t crc ;
  uLong __cil_tmp3 ;
  uLong __cil_tmp4 ;

  {
  {
#line 46
  __cil_tmp3 = crc32((uLong )0L, (Bytef *)0, (uInt )0);
#line 46
  crc = (zip_uint32_t )__cil_tmp3;
  }
#line 48
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 49
    __cil_tmp4 = crc32((uLong )crc, s->raw, (uInt )s->length);
#line 49
    crc = (zip_uint32_t )__cil_tmp4;
    }
  }
#line 51
  return (crc);
}
}
#line 56 "/root/patchweave_new/24/lib/zip_string.c"
int _zip_string_equal(zip_string_t *a , zip_string_t *b ) 
{ 
  int __cil_tmp3 ;

  {
#line 58
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 59
    return ((unsigned long )a == (unsigned long )b);
  } else
#line 58
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 59
    return ((unsigned long )a == (unsigned long )b);
  }
#line 61
  if ((int )a->length != (int )b->length) {
#line 62
    return (0);
  }
  {
#line 66
  __cil_tmp3 = memcmp((void const   *)a->raw, (void const   *)b->raw, (unsigned long )a->length);
  }
#line 66
  return (__cil_tmp3 == 0);
}
}
#line 71 "/root/patchweave_new/24/lib/zip_string.c"
void _zip_string_free(zip_string_t *s ) 
{ 


  {
#line 73
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 74
    return;
  }
  {
#line 76
  free((void *)s->raw);
#line 77
  free((void *)s->converted);
#line 78
  free((void *)s);
  }
#line 80
  return;
}
}
#line 86 "/root/patchweave_new/24/lib/zip_string.c"
static zip_uint8_t empty[1]  ;
#line 83 "/root/patchweave_new/24/lib/zip_string.c"
zip_uint8_t *_zip_string_get(zip_string_t *string , zip_uint32_t *lenp , zip_flags_t flags ,
                             zip_error_t *error ) 
{ 


  {
  {
#line 85
  strcpy((char *)(empty), "\f");
  }
#line 87
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 88
    if (lenp) {
#line 89
      *lenp = (zip_uint32_t )0;
    }
#line 90
    return (empty);
  }
#line 93
  if ((flags & 64U) == 0U) {
#line 95
    if ((unsigned int )string->encoding == 0U) {
      {
#line 96
      _zip_guess_encoding(string, (enum zip_encoding_type )0);
      }
    }
#line 98
    if (flags & 128U) {
#line 98
      if ((unsigned int )string->encoding != 1U) {
#line 98
        if ((unsigned int )string->encoding != 2U) {
          _L: 
#line 101
          if ((unsigned long )string->converted == (unsigned long )((void *)0)) {
            {
#line 102
            string->converted = _zip_cp437_to_utf8(string->raw, (zip_uint32_t )string->length,
                                                   & string->converted_length, error);
            }
#line 102
            if ((unsigned long )string->converted == (unsigned long )((void *)0)) {
#line 104
              return ((zip_uint8_t *)((void *)0));
            }
          }
#line 106
          if (lenp) {
#line 107
            *lenp = string->converted_length;
          }
#line 108
          return (string->converted);
        } else {
#line 98
          goto _L___0;
        }
      } else {
#line 98
        goto _L___0;
      }
    } else
    _L___0: 
#line 98
    if ((unsigned int )string->encoding == 4U) {
#line 98
      goto _L;
    }
  }
#line 112
  if (lenp) {
#line 113
    *lenp = (zip_uint32_t )string->length;
  }
#line 114
  return (string->raw);
}
}
#line 119 "/root/patchweave_new/24/lib/zip_string.c"
zip_uint16_t _zip_string_length(zip_string_t *s ) 
{ 


  {
#line 121
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 122
    return ((zip_uint16_t )0);
  }
#line 124
  return (s->length);
}
}
#line 129 "/root/patchweave_new/24/lib/zip_string.c"
zip_string_t *_zip_string_new(zip_uint8_t *raw , zip_uint16_t length , zip_flags_t flags ,
                              zip_error_t *error ) 
{ 
  zip_string_t *s ;
  zip_encoding_type_t expected_encoding ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  enum zip_encoding_type __cil_tmp9 ;

  {
#line 134
  if ((int )length == 0) {
#line 135
    return ((zip_string_t *)((void *)0));
  }
#line 138
  if ((flags & 6144U) == 0U) {
#line 138
    goto case_0;
  }
#line 141
  if ((flags & 6144U) == 2048U) {
#line 141
    goto case_2048;
  }
#line 144
  if ((flags & 6144U) == 4096U) {
#line 144
    goto case_4096;
  }
#line 147
  goto switch_default;
  case_0: 
#line 139
  expected_encoding = (zip_encoding_type_t )0;
#line 140
  goto switch_break;
  case_2048: 
#line 142
  expected_encoding = (zip_encoding_type_t )2;
#line 143
  goto switch_break;
  case_4096: 
#line 145
  expected_encoding = (zip_encoding_type_t )4;
#line 146
  goto switch_break;
  switch_default: 
  {
#line 148
  zip_error_set(error, 18, 0);
  }
#line 149
  return ((zip_string_t *)((void *)0));
  switch_break: 
  {
#line 152
  __cil_tmp7 = malloc(sizeof(*s));
#line 152
  s = (zip_string_t *)__cil_tmp7;
  }
#line 152
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 153
    zip_error_set(error, 14, 0);
    }
#line 154
    return ((zip_string_t *)((void *)0));
  }
  {
#line 157
  __cil_tmp8 = malloc((size_t )((int )length + 1));
#line 157
  s->raw = (zip_uint8_t *)__cil_tmp8;
  }
#line 157
  if ((unsigned long )s->raw == (unsigned long )((void *)0)) {
    {
#line 158
    free((void *)s);
    }
#line 159
    return ((zip_string_t *)((void *)0));
  }
  {
#line 162
  memcpy((void *)s->raw, (void const   *)raw, (unsigned long )length);
#line 163
  *(s->raw + (int )length) = (zip_uint8_t )'\000';
#line 164
  s->length = length;
#line 165
  s->encoding = (enum zip_encoding_type )0;
#line 166
  s->converted = (zip_uint8_t *)((void *)0);
#line 167
  s->converted_length = (zip_uint32_t )0;
  }
#line 169
  if ((unsigned int )expected_encoding != 0U) {
    {
#line 170
    __cil_tmp9 = _zip_guess_encoding(s, expected_encoding);
    }
#line 170
    if ((unsigned int )__cil_tmp9 == 5U) {
      {
#line 171
      _zip_string_free(s);
#line 172
      zip_error_set(error, 18, 0);
      }
#line 173
      return ((zip_string_t *)((void *)0));
    }
  }
#line 177
  return (s);
}
}
#line 182 "/root/patchweave_new/24/lib/zip_string.c"
int _zip_string_write(zip_t *za___0 , zip_string_t *s ) 
{ 
  int __cil_tmp3 ;

  {
#line 184
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 185
    return (0);
  }
  {
#line 187
  __cil_tmp3 = _zip_write(za___0, (void const   *)s->raw, (zip_uint64_t )s->length);
  }
#line 187
  return (__cil_tmp3);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_strerror.c"
char const   *zip_strerror(zip_t *za___0 ) 
{ 
  char const   *__cil_tmp2 ;

  {
  {
#line 41
  __cil_tmp2 = zip_error_strerror(& za___0->error);
  }
#line 41
  return (__cil_tmp2);
}
}
#line 40 "/root/patchweave_new/24/lib/zip_stat_init.c"
void zip_stat_init(zip_stat_t *st ) 
{ 


  {
#line 42
  st->valid = (zip_uint64_t )0;
#line 43
  st->name = (char const   *)((void *)0);
#line 44
  st->index = 0xffffffffffffffffUL;
#line 45
  st->crc = (zip_uint32_t )0;
#line 46
  st->mtime = (time_t )-1;
#line 47
  st->size = (zip_uint64_t )0;
#line 48
  st->comp_size = (zip_uint64_t )0;
#line 49
  st->comp_method = (zip_uint16_t )0;
#line 50
  st->encryption_method = (zip_uint16_t )0;
#line 51
  return;
}
}
#line 55 "/root/patchweave_new/24/lib/zip_stat_init.c"
int _zip_stat_merge(zip_stat_t *dst , zip_stat_t *src , zip_error_t *error ) 
{ 


  {
#line 58
  if (src->valid & 2UL) {
#line 59
    dst->index = src->index;
  }
#line 61
  if (src->valid & 4UL) {
#line 62
    dst->size = src->size;
  }
#line 64
  if (src->valid & 8UL) {
#line 65
    dst->comp_size = src->comp_size;
  }
#line 67
  if (src->valid & 16UL) {
#line 68
    dst->mtime = src->mtime;
  }
#line 70
  if (src->valid & 32UL) {
#line 71
    dst->crc = src->crc;
  }
#line 73
  if (src->valid & 64UL) {
#line 74
    dst->comp_method = src->comp_method;
  }
#line 76
  if (src->valid & 128UL) {
#line 77
    dst->encryption_method = src->encryption_method;
  }
#line 79
  if (src->valid & 256UL) {
#line 80
    dst->flags = src->flags;
  }
#line 82
  dst->valid |= src->valid;
#line 84
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_stat_index.c"
int zip_stat_index(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags , zip_stat_t *st ) 
{ 
  char const   *name ;
  zip_dirent_t *de ;
  int __cil_tmp9 ;
  unsigned int tmp ;

  {
  {
#line 45
  de = _zip_get_dirent(za___0, index___0, flags, (zip_error_t *)((void *)0));
  }
#line 45
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 46
    return (-1);
  }
  {
#line 48
  name = zip_get_name(za___0, index___0, flags);
  }
#line 48
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 49
    return (-1);
  }
#line 52
  if ((unsigned long )(za___0->entry + index___0)->source != (unsigned long )((void *)0)) {
#line 52
    if ((flags & 8U) == 0U) {
      {
#line 54
      __cil_tmp9 = zip_source_stat((za___0->entry + index___0)->source, st);
      }
#line 54
      if (__cil_tmp9 < 0) {
        {
#line 55
        zip_error_set(& za___0->error, 15, 0);
        }
#line 56
        return (-1);
      }
    } else {
#line 52
      goto _L;
    }
  } else {
    _L: 
    {
#line 60
    zip_stat_init(st);
#line 62
    st->crc = de->crc;
#line 63
    st->size = de->uncomp_size;
#line 64
    st->mtime = de->last_mod;
#line 65
    st->comp_size = de->comp_size;
#line 66
    st->comp_method = (zip_uint16_t )de->comp_method;
#line 67
    st->encryption_method = de->encryption_method;
    }
#line 68
    if (de->crc_valid) {
#line 68
      tmp = 32U;
    } else {
#line 68
      tmp = 0U;
    }
#line 68
    st->valid = (zip_uint64_t )(((((tmp | 4U) | 16U) | 8U) | 64U) | 128U);
  }
#line 72
  st->index = index___0;
#line 73
  st->name = name;
#line 74
  st->valid |= 3UL;
#line 76
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_stat.c"
int zip_stat(zip_t *za___0 , char const   *fname , zip_flags_t flags , zip_stat_t *st ) 
{ 
  zip_int64_t idx ;
  int __cil_tmp7 ;

  {
  {
#line 43
  idx = zip_name_locate(za___0, fname, flags);
  }
#line 43
  if (idx < 0L) {
#line 44
    return (-1);
  }
  {
#line 46
  __cil_tmp7 = zip_stat_index(za___0, (zip_uint64_t )idx, flags, st);
  }
#line 46
  return (__cil_tmp7);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_source_zip_new.c"
zip_source_t *_zip_source_zip_new(zip_t *za___0 , zip_t *srcza , zip_uint64_t srcidx ,
                                  zip_flags_t flags , zip_uint64_t start___0 , zip_uint64_t len ,
                                  char const   *password ) 
{ 
  zip_source_t *src ;
  zip_source_t *s2 ;
  struct zip_stat st ;
  int partial_data ;
  int needs_crc ;
  int needs_decrypt ;
  int needs_decompress ;
  int __cil_tmp15 ;
  zip_source_t *__cil_tmp16 ;
  struct zip_stat st2 ;
  zip_dirent_t *de ;
  int __cil_tmp22 ;
  zip_source_t *(*enc_impl)(zip_t * , zip_source_t * , zip_uint16_t  , int  , char const   * ) ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 47
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 48
    return ((zip_source_t *)((void *)0));
  }
#line 50
  if ((unsigned long )srcza == (unsigned long )((void *)0)) {
    {
#line 51
    zip_error_set(& za___0->error, 18, 0);
    }
#line 52
    return ((zip_source_t *)((void *)0));
  } else
#line 50
  if (srcidx >= srcza->nentry) {
    {
#line 51
    zip_error_set(& za___0->error, 18, 0);
    }
#line 52
    return ((zip_source_t *)((void *)0));
  }
#line 55
  if ((unsigned long )(srcza->entry + srcidx)->source != (unsigned long )((void *)0)) {
    _L: 
#line 55
    if ((flags & 8U) == 0U) {
      {
#line 57
      zip_error_set(& za___0->error, 15, 0);
      }
#line 58
      return ((zip_source_t *)((void *)0));
    }
  } else
#line 55
  if ((srcza->entry + srcidx)->deleted) {
#line 55
    goto _L;
  }
  {
#line 61
  __cil_tmp15 = zip_stat_index(srcza, srcidx, flags | 8U, & st);
  }
#line 61
  if (__cil_tmp15 < 0) {
    {
#line 62
    zip_error_set(& za___0->error, 20, 0);
    }
#line 63
    return ((zip_source_t *)((void *)0));
  }
#line 66
  if (flags & 32U) {
#line 67
    flags |= 4U;
  }
#line 69
  if (start___0 > 0UL) {
    _L___2: 
#line 69
    if (flags & 4U) {
      {
#line 70
      zip_error_set(& za___0->error, 18, 0);
      }
#line 71
      return ((zip_source_t *)((void *)0));
    }
  } else
#line 69
  if (len > 0UL) {
#line 69
    goto _L___2;
  }
#line 75
  if (start___0 > 0UL) {
    _L___3: 
#line 75
    if (start___0 + len < start___0) {
      {
#line 76
      zip_error_set(& za___0->error, 18, 0);
      }
#line 77
      return ((zip_source_t *)((void *)0));
    } else
#line 75
    if (start___0 + len > st.size) {
      {
#line 76
      zip_error_set(& za___0->error, 18, 0);
      }
#line 77
      return ((zip_source_t *)((void *)0));
    }
  } else
#line 75
  if (len > 0UL) {
#line 75
    goto _L___3;
  }
#line 80
  if (len == 0UL) {
#line 81
    len = st.size - start___0;
  }
#line 84
  partial_data = len < st.size;
#line 85
  if ((flags & 32U) == 0U) {
#line 85
    if ((int )st.encryption_method != 0) {
#line 85
      tmp = 1;
    } else {
#line 85
      tmp = 0;
    }
  } else {
#line 85
    tmp = 0;
  }
#line 85
  needs_decrypt = tmp;
#line 86
  if ((flags & 4U) == 0U) {
#line 86
    if ((int )st.comp_method != 0) {
#line 86
      tmp___0 = 1;
    } else {
#line 86
      tmp___0 = 0;
    }
  } else {
#line 86
    tmp___0 = 0;
  }
#line 86
  needs_decompress = tmp___0;
#line 88
  if ((flags & 4U) == 0U) {
#line 88
    goto _L___7;
  } else
#line 88
  if ((int )st.comp_method == 0) {
    _L___7: /* CIL Label */ 
#line 88
    if (! partial_data) {
#line 88
      tmp___1 = 1;
    } else {
#line 88
      tmp___1 = 0;
    }
  } else {
#line 88
    tmp___1 = 0;
  }
#line 88
  needs_crc = tmp___1;
#line 90
  if (needs_decrypt) {
#line 91
    if ((unsigned long )password == (unsigned long )((void *)0)) {
#line 92
      password = (char const   *)za___0->default_password;
    }
#line 94
    if ((unsigned long )password == (unsigned long )((void *)0)) {
      {
#line 95
      zip_error_set(& za___0->error, 26, 0);
      }
#line 96
      return ((zip_source_t *)((void *)0));
    }
  }
#line 100
  if (st.comp_size == 0UL) {
    {
#line 101
    __cil_tmp16 = zip_source_buffer(za___0, (void const   *)((void *)0), (zip_uint64_t )0,
                                    0);
    }
#line 101
    return (__cil_tmp16);
  }
#line 104
  if (partial_data) {
#line 104
    if (! needs_decrypt) {
#line 104
      if (! needs_decompress) {
        {
#line 107
        st2.size = len;
#line 108
        st2.comp_size = len;
#line 109
        st2.comp_method = (zip_uint16_t )0;
#line 110
        st2.mtime = st.mtime;
#line 111
        st2.valid = (zip_uint64_t )92U;
#line 113
        src = _zip_source_window_new(srcza->src, start___0, len, & st2, (zip_int8_t )0,
                                     srcza, srcidx, & za___0->error);
        }
#line 113
        if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 114
          return ((zip_source_t *)((void *)0));
        }
      } else {
#line 104
        goto _L___4;
      }
    } else {
#line 104
      goto _L___4;
    }
  } else {
    _L___4: 
    {
#line 120
    de = _zip_get_dirent(srcza, srcidx, flags, & za___0->error);
    }
#line 120
    if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 121
      return ((zip_source_t *)((void *)0));
    }
    {
#line 123
    src = _zip_source_window_new(srcza->src, (zip_uint64_t )0, st.comp_size, & st,
                                 (zip_int8_t )(((int )de->bitflags >> 1) & 3), srcza,
                                 srcidx, & za___0->error);
    }
#line 123
    if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 124
      return ((zip_source_t *)((void *)0));
    }
  }
  {
#line 128
  __cil_tmp22 = _zip_source_set_source_archive(src, srcza);
  }
#line 128
  if (__cil_tmp22 < 0) {
    {
#line 129
    zip_source_free(src);
    }
#line 130
    return ((zip_source_t *)((void *)0));
  }
#line 135
  if (needs_decrypt) {
    {
#line 138
    enc_impl = _zip_get_encryption_implementation(st.encryption_method, 0);
    }
#line 138
    if ((unsigned long )enc_impl == (unsigned long )((void *)0)) {
      {
#line 139
      zip_error_set(& za___0->error, 24, 0);
      }
#line 140
      return ((zip_source_t *)((void *)0));
    }
    {
#line 143
    s2 = (*enc_impl)(za___0, src, st.encryption_method, 0, password);
#line 144
    zip_source_free(src);
    }
#line 145
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 146
      return ((zip_source_t *)((void *)0));
    }
#line 148
    src = s2;
  }
#line 150
  if (needs_decompress) {
    {
#line 151
    s2 = zip_source_decompress(za___0, src, (zip_int32_t )st.comp_method);
#line 152
    zip_source_free(src);
    }
#line 153
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 154
      return ((zip_source_t *)((void *)0));
    }
#line 156
    src = s2;
  }
#line 158
  if (needs_crc) {
    {
#line 159
    s2 = zip_source_crc(za___0, src, 1);
#line 160
    zip_source_free(src);
    }
#line 161
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 162
      return ((zip_source_t *)((void *)0));
    }
#line 164
    src = s2;
  }
#line 167
  if (partial_data) {
#line 167
    if (needs_decrypt) {
      _L___6: 
      {
#line 168
      s2 = zip_source_window(za___0, src, start___0, len);
#line 169
      zip_source_free(src);
      }
#line 170
      if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 171
        return ((zip_source_t *)((void *)0));
      }
#line 173
      src = s2;
    } else
#line 167
    if (needs_decompress) {
#line 167
      goto _L___6;
    }
  }
#line 176
  return (src);
}
}
#line 42 "/root/patchweave_new/24/lib/zip_source_zip.c"
zip_source_t *zip_source_zip(zip_t *za___0 , zip_t *srcza , zip_uint64_t srcidx ,
                             zip_flags_t flags , zip_uint64_t start___0 , zip_int64_t len ) 
{ 
  zip_source_t *__cil_tmp7 ;

  {
#line 45
  if (len < -1L) {
    {
#line 46
    zip_error_set(& za___0->error, 18, 0);
    }
#line 47
    return ((zip_source_t *)((void *)0));
  }
#line 50
  if (len == -1L) {
#line 51
    len = (zip_int64_t )0;
  }
#line 53
  if (start___0 == 0UL) {
#line 53
    if (len == 0L) {
#line 54
      flags |= 4U;
    } else {
#line 56
      flags &= 4294967291U;
    }
  } else {
#line 56
    flags &= 4294967291U;
  }
  {
#line 58
  __cil_tmp7 = _zip_source_zip_new(za___0, srcza, srcidx, flags, start___0, (zip_uint64_t )len,
                                   (char const   *)((void *)0));
  }
#line 58
  return (__cil_tmp7);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_write.c"
zip_int64_t zip_source_write(zip_source_t *src , void const   *data , zip_uint64_t length ) 
{ 
  zip_int64_t __cil_tmp4 ;

  {
#line 41
  if (! ((unsigned int )src->write_state == 1U)) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return ((zip_int64_t )-1);
  } else
#line 41
  if (length > 0xffffffffffffffffUL) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return ((zip_int64_t )-1);
  }
  {
#line 46
  __cil_tmp4 = _zip_source_call(src, (void *)data, length, (zip_source_cmd_t )11);
  }
#line 46
  return (__cil_tmp4);
}
}
#line 96 "./gladman-fcrypt/fileenc.h"
extern int _zip_fcrypt_init(unsigned int mode , unsigned char const   *pwd , unsigned int pwd_len ,
                            unsigned char const   *salt , unsigned char *pwd_ver ,
                            fcrypt_ctx *cx ) ;
#line 108
extern void _zip_fcrypt_encrypt(unsigned char *data , unsigned int data_len , fcrypt_ctx *cx ) ;
#line 109
extern void _zip_fcrypt_decrypt(unsigned char *data , unsigned int data_len , fcrypt_ctx *cx ) ;
#line 114
extern int _zip_fcrypt_end(unsigned char *mac , fcrypt_ctx *cx ) ;
#line 45 "/root/patchweave_new/24/lib/zip_source_winzip_aes_encode.c"
static unsigned int salt_length[4]  = {      0U,      8U,      12U,      16U};
#line 61
static int encrypt_header(zip_source_t *src , struct winzip_aes *ctx ) ;
#line 62
static void winzip_aes_free(struct winzip_aes *ctx ) ;
#line 63
static zip_int64_t winzip_aes_encrypt(zip_source_t *src , void *ud , void *data ,
                                      zip_uint64_t length , zip_source_cmd_t cmd ) ;
#line 64
static struct winzip_aes *winzip_aes_new(unsigned int mode , zip_uint16_t encryption_method ,
                                         char const   *password ) ;
#line 68 "/root/patchweave_new/24/lib/zip_source_winzip_aes_encode.c"
zip_source_t *zip_source_winzip_aes_encode(zip_t *za___0 , zip_source_t *src , zip_uint16_t encryption_method ,
                                           int flags , char const   *password ) 
{ 
  zip_source_t *s2 ;
  unsigned int mode ;
  struct winzip_aes *ctx ;
  unsigned long __cil_tmp9 ;

  {
#line 71
  mode = 0U;
#line 75
  if ((int )encryption_method == 257) {
#line 75
    goto case_257;
  }
#line 78
  if ((int )encryption_method == 258) {
#line 78
    goto case_258;
  }
#line 81
  if ((int )encryption_method == 259) {
#line 81
    goto case_259;
  }
#line 74
  goto switch_break;
  case_257: 
#line 76
  mode = 1U;
#line 77
  goto switch_break;
  case_258: 
#line 79
  mode = 2U;
#line 80
  goto switch_break;
  case_259: 
#line 82
  mode = 3U;
#line 83
  goto switch_break;
  switch_break: ;
#line 86
  if ((unsigned long )password == (unsigned long )((void *)0)) {
    {
#line 87
    zip_error_set(& za___0->error, 18, 0);
    }
#line 88
    return ((zip_source_t *)((void *)0));
  } else
#line 86
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 87
    zip_error_set(& za___0->error, 18, 0);
    }
#line 88
    return ((zip_source_t *)((void *)0));
  } else
#line 86
  if (mode == 0U) {
    {
#line 87
    zip_error_set(& za___0->error, 18, 0);
    }
#line 88
    return ((zip_source_t *)((void *)0));
  }
  {
#line 91
  __cil_tmp9 = strlen(password);
  }
#line 91
  if (__cil_tmp9 > 4294967295UL) {
    {
#line 92
    zip_error_set(& za___0->error, 18, 0);
    }
#line 93
    return ((zip_source_t *)((void *)0));
  }
  {
#line 96
  ctx = winzip_aes_new(mode, encryption_method, password);
  }
#line 96
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 97
    zip_error_set(& za___0->error, 14, 0);
    }
#line 98
    return ((zip_source_t *)((void *)0));
  }
  {
#line 101
  s2 = zip_source_layered(za___0, src, & winzip_aes_encrypt, (void *)ctx);
  }
#line 101
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
    {
#line 102
    winzip_aes_free(ctx);
    }
#line 103
    return ((zip_source_t *)((void *)0));
  }
#line 106
  return (s2);
}
}
#line 111 "/root/patchweave_new/24/lib/zip_source_winzip_aes_encode.c"
static int encrypt_header(zip_source_t *src , struct winzip_aes *ctx ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 113
  __cil_tmp3 = zip_random(ctx->data, (zip_uint16_t )salt_length[ctx->mode]);
  }
#line 113
  if (! __cil_tmp3) {
    {
#line 114
    zip_error_set(& ctx->error, 20, 0);
    }
#line 115
    return (-1);
  }
  {
#line 118
  __cil_tmp4 = strlen((char const   *)ctx->password);
#line 118
  __cil_tmp5 = _zip_fcrypt_init(ctx->mode, (unsigned char const   *)((unsigned char *)ctx->password),
                                (unsigned int )__cil_tmp4, (unsigned char const   *)(ctx->data),
                                (unsigned char *)(ctx->data + salt_length[ctx->mode]),
                                (fcrypt_ctx *)(& ctx->fcrypt_ctx));
  }
#line 118
  if (__cil_tmp5 != 0) {
    {
#line 119
    zip_error_set(& ctx->error, 14, 0);
    }
#line 120
    return (-1);
  }
  {
#line 123
  ctx->buffer = _zip_buffer_new(ctx->data, (zip_uint64_t )(salt_length[ctx->mode] + 2U));
  }
#line 123
  if ((unsigned long )ctx->buffer == (unsigned long )((void *)0)) {
    {
#line 124
    zip_error_set(& ctx->error, 14, 0);
    }
#line 125
    return (-1);
  }
#line 128
  return (0);
}
}
#line 133 "/root/patchweave_new/24/lib/zip_source_winzip_aes_encode.c"
static zip_int64_t winzip_aes_encrypt(zip_source_t *src , void *ud , void *data ,
                                      zip_uint64_t length , zip_source_cmd_t cmd ) 
{ 
  struct winzip_aes *ctx ;
  zip_int64_t ret ;
  zip_uint64_t buffer_n ;
  zip_uint64_t offset ;
  zip_uint64_t n ;
  int __cil_tmp11 ;
  int __cil_tmp13 ;
  zip_uint64_t tmp ;
  zip_uint64_t tmp___0 ;
  zip_stat_t *st ;
  zip_int64_t __cil_tmp19 ;
  zip_int64_t __cil_tmp20 ;

  {
#line 139
  ctx = (struct winzip_aes *)ud;
#line 142
  if ((unsigned int )cmd == 0U) {
#line 142
    goto case_0;
  }
#line 149
  if ((unsigned int )cmd == 1U) {
#line 149
    goto case_1;
  }
#line 190
  if ((unsigned int )cmd == 2U) {
#line 190
    goto case_2;
  }
#line 193
  if ((unsigned int )cmd == 3U) {
#line 193
    goto case_3;
  }
#line 207
  if ((unsigned int )cmd == 14U) {
#line 207
    goto case_14;
  }
#line 210
  if ((unsigned int )cmd == 4U) {
#line 210
    goto case_4;
  }
#line 213
  if ((unsigned int )cmd == 5U) {
#line 213
    goto case_5;
  }
#line 217
  goto switch_default;
  case_0: 
  {
#line 143
  ctx->eof = 0;
#line 144
  __cil_tmp11 = encrypt_header(src, ctx);
  }
#line 144
  if (__cil_tmp11 < 0) {
#line 145
    return ((zip_int64_t )-1);
  }
#line 147
  return ((zip_int64_t )0);
  case_1: 
#line 150
  buffer_n = (zip_uint64_t )0;
#line 152
  if (ctx->buffer) {
    {
#line 153
    buffer_n = _zip_buffer_read(ctx->buffer, (zip_uint8_t *)data, length);
#line 155
    data = (void *)((zip_uint8_t *)data + buffer_n);
#line 156
    length -= buffer_n;
#line 158
    __cil_tmp13 = _zip_buffer_eof(ctx->buffer);
    }
#line 158
    if (__cil_tmp13) {
      {
#line 159
      _zip_buffer_free(ctx->buffer);
#line 160
      ctx->buffer = (zip_buffer_t *)((void *)0);
      }
    }
  }
#line 164
  if (ctx->eof) {
#line 165
    return ((zip_int64_t )buffer_n);
  }
  {
#line 168
  ret = zip_source_read(src, data, length);
  }
#line 168
  if (ret < 0L) {
    {
#line 169
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 170
    return ((zip_int64_t )-1);
  }
#line 173
  n = (zip_uint64_t )ret;
#line 174
  offset = (zip_uint64_t )0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;

#line 174
    if (! (offset < n)) {
#line 174
      goto while_break;
    }
#line 175
    if (n - offset < 4294967295UL) {
#line 175
      tmp = n - offset;
    } else {
#line 175
      tmp = 4294967295UL;
    }
    {
#line 175
    _zip_fcrypt_encrypt((zip_uint8_t *)data + offset, (unsigned int )tmp, (fcrypt_ctx *)(& ctx->fcrypt_ctx));
    }
#line 174
    if (n - offset < 4294967295UL) {
#line 174
      tmp___0 = n - offset;
    } else {
#line 174
      tmp___0 = 4294967295UL;
    }
#line 174
    offset += tmp___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 178
  if (n < length) {
    {
#line 179
    ctx->eof = 1;
#line 180
    _zip_fcrypt_end(ctx->data, (fcrypt_ctx *)(& ctx->fcrypt_ctx));
#line 181
    ctx->buffer = _zip_buffer_new(ctx->data, (zip_uint64_t )10);
    }
#line 181
    if ((unsigned long )ctx->buffer == (unsigned long )((void *)0)) {
      {
#line 182
      zip_error_set(& ctx->error, 14, 0);
      }
#line 184
      return ((zip_int64_t )-1);
    }
  }
#line 188
  return ((zip_int64_t )(buffer_n + n));
  case_2: 
#line 191
  return ((zip_int64_t )0);
  case_3: 
#line 197
  st = (zip_stat_t *)data;
#line 198
  st->encryption_method = ctx->encryption_method;
#line 199
  st->valid |= 128UL;
#line 200
  if (st->valid & 8UL) {
#line 201
    st->comp_size += (unsigned long )(12U + salt_length[ctx->mode]);
  }
#line 204
  return ((zip_int64_t )0);
  case_14: 
  {
#line 208
  __cil_tmp19 = zip_source_make_command_bitmap((zip_source_cmd_t )0, 1, 2, 3, 4, 5,
                                               -1);
  }
#line 208
  return (__cil_tmp19);
  case_4: 
  {
#line 211
  __cil_tmp20 = zip_error_to_data(& ctx->error, data, length);
  }
#line 211
  return (__cil_tmp20);
  case_5: 
  {
#line 214
  winzip_aes_free(ctx);
  }
#line 215
  return ((zip_int64_t )0);
  switch_default: 
  {
#line 218
  zip_error_set(& ctx->error, 18, 0);
  }
#line 219
  return ((zip_int64_t )-1);

#line 223
  return (0L);
}
}
#line 225 "/root/patchweave_new/24/lib/zip_source_winzip_aes_encode.c"
static void winzip_aes_free(struct winzip_aes *ctx ) 
{ 
  unsigned long __cil_tmp2 ;

  {
#line 227
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 228
    return;
  }
  {
#line 231
  explicit_bzero((void *)(& ctx->fcrypt_ctx), sizeof(ctx->fcrypt_ctx));
#line 232
  __cil_tmp2 = strlen((char const   *)ctx->password);
#line 232
  explicit_bzero((void *)ctx->password, __cil_tmp2);
#line 233
  free((void *)ctx->password);
#line 234
  zip_error_fini(& ctx->error);
#line 235
  _zip_buffer_free(ctx->buffer);
#line 236
  free((void *)ctx);
  }
#line 238
  return;
}
}
#line 241 "/root/patchweave_new/24/lib/zip_source_winzip_aes_encode.c"
static struct winzip_aes *winzip_aes_new(unsigned int mode , zip_uint16_t encryption_method ,
                                         char const   *password ) 
{ 
  struct winzip_aes *ctx ;
  void *__cil_tmp5 ;

  {
  {
#line 244
  __cil_tmp5 = malloc(sizeof(*ctx));
#line 244
  ctx = (struct winzip_aes *)__cil_tmp5;
  }
#line 244
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 245
    return ((struct winzip_aes *)((void *)0));
  }
  {
#line 248
  ctx->password = strdup(password);
  }
#line 248
  if ((unsigned long )ctx->password == (unsigned long )((void *)0)) {
    {
#line 249
    free((void *)ctx);
    }
#line 250
    return ((struct winzip_aes *)((void *)0));
  }
  {
#line 253
  ctx->mode = mode;
#line 254
  ctx->encryption_method = encryption_method;
#line 255
  ctx->buffer = (zip_buffer_t *)((void *)0);
#line 257
  zip_error_init(& ctx->error);
#line 259
  ctx->eof = 0;
  }
#line 260
  return (ctx);
}
}
#line 45 "/root/patchweave_new/24/lib/zip_source_winzip_aes_decode.c"
static unsigned int salt_length___0[4]  = {      0U,      8U,      12U,      16U};
#line 59
static int decrypt_header(zip_source_t *src , struct winzip_aes___0 *ctx ) ;
#line 60
static void winzip_aes_free___0(struct winzip_aes___0 *ctx ) ;
#line 61
static zip_int64_t winzip_aes_decrypt(zip_source_t *src , void *ud , void *data ,
                                      zip_uint64_t len , zip_source_cmd_t cmd ) ;
#line 62
static struct winzip_aes___0 *winzip_aes_new___0(unsigned int mode , char const   *password ) ;
#line 66 "/root/patchweave_new/24/lib/zip_source_winzip_aes_decode.c"
zip_source_t *zip_source_winzip_aes_decode(zip_t *za___0 , zip_source_t *src , zip_uint16_t em ,
                                           int flags , char const   *password ) 
{ 
  zip_source_t *s2 ;
  unsigned int mode ;
  zip_stat_t st ;
  zip_uint64_t aux_length ;
  struct winzip_aes___0 *ctx ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 69
  mode = 0U;
#line 75
  if ((int )em == 257) {
#line 75
    goto case_257;
  }
#line 78
  if ((int )em == 258) {
#line 78
    goto case_258;
  }
#line 81
  if ((int )em == 259) {
#line 81
    goto case_259;
  }
#line 74
  goto switch_break;
  case_257: 
#line 76
  mode = 1U;
#line 77
  goto switch_break;
  case_258: 
#line 79
  mode = 2U;
#line 80
  goto switch_break;
  case_259: 
#line 82
  mode = 3U;
#line 83
  goto switch_break;
  switch_break: ;
#line 86
  if ((unsigned long )password == (unsigned long )((void *)0)) {
    {
#line 87
    zip_error_set(& za___0->error, 18, 0);
    }
#line 88
    return ((zip_source_t *)((void *)0));
  } else
#line 86
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 87
    zip_error_set(& za___0->error, 18, 0);
    }
#line 88
    return ((zip_source_t *)((void *)0));
  } else
#line 86
  if (mode == 0U) {
    {
#line 87
    zip_error_set(& za___0->error, 18, 0);
    }
#line 88
    return ((zip_source_t *)((void *)0));
  }
#line 90
  if (flags & 1) {
    {
#line 91
    zip_error_set(& za___0->error, 24, 0);
    }
#line 92
    return ((zip_source_t *)((void *)0));
  }
  {
#line 95
  __cil_tmp11 = strlen(password);
  }
#line 95
  if (__cil_tmp11 > 4294967295UL) {
    {
#line 96
    zip_error_set(& za___0->error, 18, 0);
    }
#line 97
    return ((zip_source_t *)((void *)0));
  }
  {
#line 100
  __cil_tmp12 = zip_source_stat(src, & st);
  }
#line 100
  if (__cil_tmp12 != 0) {
    {
#line 101
    _zip_error_set_from_source(& za___0->error, src);
    }
#line 102
    return ((zip_source_t *)((void *)0));
  }
#line 105
  aux_length = (zip_uint64_t )((2U + salt_length___0[mode]) + 10U);
#line 107
  if ((st.valid & 8UL) == 0UL) {
    {
#line 108
    zip_error_set(& za___0->error, 28, 0);
    }
#line 109
    return ((zip_source_t *)((void *)0));
  } else
#line 107
  if (st.comp_size < aux_length) {
    {
#line 108
    zip_error_set(& za___0->error, 28, 0);
    }
#line 109
    return ((zip_source_t *)((void *)0));
  }
  {
#line 112
  ctx = winzip_aes_new___0(mode, password);
  }
#line 112
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 113
    zip_error_set(& za___0->error, 14, 0);
    }
#line 114
    return ((zip_source_t *)((void *)0));
  }
  {
#line 117
  ctx->data_length = st.comp_size - aux_length;
#line 119
  s2 = zip_source_layered(za___0, src, & winzip_aes_decrypt, (void *)ctx);
  }
#line 119
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
    {
#line 120
    winzip_aes_free___0(ctx);
    }
#line 121
    return ((zip_source_t *)((void *)0));
  }
#line 124
  return (s2);
}
}
#line 129 "/root/patchweave_new/24/lib/zip_source_winzip_aes_decode.c"
static int decrypt_header(zip_source_t *src , struct winzip_aes___0 *ctx ) 
{ 
  zip_uint8_t header[18] ;
  zip_uint8_t password_verification[2] ;
  unsigned int headerlen ;
  zip_int64_t n ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 136
  headerlen = 2U + salt_length___0[ctx->mode];
#line 137
  n = zip_source_read(src, (void *)(header), (zip_uint64_t )headerlen);
  }
#line 137
  if (n < 0L) {
    {
#line 138
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 139
    return (-1);
  }
#line 142
  if (n != (long )headerlen) {
    {
#line 143
    zip_error_set(& ctx->error, 17, 0);
    }
#line 144
    return (-1);
  }
  {
#line 147
  __cil_tmp8 = strlen((char const   *)ctx->password);
#line 147
  __cil_tmp9 = _zip_fcrypt_init(ctx->mode, (unsigned char const   *)((unsigned char *)ctx->password),
                                (unsigned int )__cil_tmp8, (unsigned char const   *)(header),
                                (unsigned char *)(password_verification), (fcrypt_ctx *)(& ctx->fcrypt_ctx));
  }
#line 147
  if (__cil_tmp9 != 0) {
    {
#line 148
    zip_error_set(& ctx->error, 14, 0);
    }
#line 149
    return (-1);
  }
  {
#line 151
  __cil_tmp10 = memcmp((void const   *)(password_verification), (void const   *)(header + salt_length___0[ctx->mode]),
                       2UL);
  }
#line 151
  if (__cil_tmp10 != 0) {
    {
#line 152
    zip_error_set(& ctx->error, 27, 0);
    }
#line 153
    return (-1);
  }
#line 155
  return (0);
}
}
#line 160 "/root/patchweave_new/24/lib/zip_source_winzip_aes_decode.c"
static int verify_hmac(zip_source_t *src , struct winzip_aes___0 *ctx ) 
{ 
  unsigned char computed[10] ;
  unsigned char from_file[10] ;
  zip_int64_t __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 163
  __cil_tmp5 = zip_source_read(src, (void *)(from_file), (zip_uint64_t )10);
  }
#line 163
  if (__cil_tmp5 < 10L) {
    {
#line 164
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 165
    return (0);
  }
  {
#line 168
  _zip_fcrypt_end(computed, (fcrypt_ctx *)(& ctx->fcrypt_ctx));
#line 170
  __cil_tmp6 = memcmp((void const   *)(from_file), (void const   *)(computed), 10UL);
  }
#line 170
  if (__cil_tmp6 != 0) {
    {
#line 171
    zip_error_set(& ctx->error, 7, 0);
    }
#line 172
    return (0);
  }
#line 175
  return (1);
}
}
#line 180 "/root/patchweave_new/24/lib/zip_source_winzip_aes_decode.c"
static zip_int64_t winzip_aes_decrypt(zip_source_t *src , void *ud , void *data ,
                                      zip_uint64_t len , zip_source_cmd_t cmd ) 
{ 
  struct winzip_aes___0 *ctx ;
  zip_int64_t n ;
  zip_uint64_t total ;
  zip_uint64_t offset ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  zip_uint64_t tmp ;
  zip_uint64_t tmp___0 ;
  zip_stat_t *st ;
  zip_int64_t __cil_tmp16 ;
  zip_int64_t __cil_tmp17 ;

  {
#line 186
  ctx = (struct winzip_aes___0 *)ud;
#line 189
  if ((unsigned int )cmd == 0U) {
#line 189
    goto case_0;
  }
#line 196
  if ((unsigned int )cmd == 1U) {
#line 196
    goto case_1;
  }
#line 221
  if ((unsigned int )cmd == 2U) {
#line 221
    goto case_2;
  }
#line 224
  if ((unsigned int )cmd == 3U) {
#line 224
    goto case_3;
  }
#line 239
  if ((unsigned int )cmd == 14U) {
#line 239
    goto case_14;
  }
#line 242
  if ((unsigned int )cmd == 4U) {
#line 242
    goto case_4;
  }
#line 245
  if ((unsigned int )cmd == 5U) {
#line 245
    goto case_5;
  }
#line 249
  goto switch_default;
  case_0: 
  {
#line 190
  __cil_tmp10 = decrypt_header(src, ctx);
  }
#line 190
  if (__cil_tmp10 < 0) {
#line 191
    return ((zip_int64_t )-1);
  }
#line 193
  ctx->current_position = (zip_uint64_t )0;
#line 194
  return ((zip_int64_t )0);
  case_1: 
#line 197
  if (len > ctx->data_length - ctx->current_position) {
#line 198
    len = ctx->data_length - ctx->current_position;
  }
#line 201
  if (len == 0UL) {
    {
#line 202
    __cil_tmp11 = verify_hmac(src, ctx);
    }
#line 202
    if (! __cil_tmp11) {
#line 203
      return ((zip_int64_t )-1);
    }
#line 205
    return ((zip_int64_t )0);
  }
  {
#line 208
  n = zip_source_read(src, data, len);
  }
#line 208
  if (n < 0L) {
    {
#line 209
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 210
    return ((zip_int64_t )-1);
  }
#line 212
  ctx->current_position += (zip_uint64_t )n;
#line 214
  total = (zip_uint64_t )n;
#line 215
  offset = (zip_uint64_t )0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;

#line 215
    if (! (offset < total)) {
#line 215
      goto while_break;
    }
#line 216
    if (total - offset < 4294967295UL) {
#line 216
      tmp = total - offset;
    } else {
#line 216
      tmp = 4294967295UL;
    }
    {
#line 216
    _zip_fcrypt_decrypt((zip_uint8_t *)data + offset, (unsigned int )tmp, (fcrypt_ctx *)(& ctx->fcrypt_ctx));
    }
#line 215
    if (total - offset < 4294967295UL) {
#line 215
      tmp___0 = total - offset;
    } else {
#line 215
      tmp___0 = 4294967295UL;
    }
#line 215
    offset += tmp___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 219
  return (n);
  case_2: 
#line 222
  return ((zip_int64_t )0);
  case_3: 
#line 228
  st = (zip_stat_t *)data;
#line 230
  st->encryption_method = (zip_uint16_t )0;
#line 231
  st->valid |= 128UL;
#line 232
  if (st->valid & 8UL) {
#line 233
    st->comp_size -= (unsigned long )(12U + salt_length___0[ctx->mode]);
  }
#line 236
  return ((zip_int64_t )0);
  case_14: 
  {
#line 240
  __cil_tmp16 = zip_source_make_command_bitmap((zip_source_cmd_t )0, 1, 2, 3, 4, 5,
                                               -1);
  }
#line 240
  return (__cil_tmp16);
  case_4: 
  {
#line 243
  __cil_tmp17 = zip_error_to_data(& ctx->error, data, len);
  }
#line 243
  return (__cil_tmp17);
  case_5: 
  {
#line 246
  winzip_aes_free___0(ctx);
  }
#line 247
  return ((zip_int64_t )0);
  switch_default: 
  {
#line 250
  zip_error_set(& ctx->error, 18, 0);
  }
#line 251
  return ((zip_int64_t )-1);

#line 255
  return (0L);
}
}
#line 257 "/root/patchweave_new/24/lib/zip_source_winzip_aes_decode.c"
static void winzip_aes_free___0(struct winzip_aes___0 *ctx ) 
{ 
  unsigned long __cil_tmp2 ;

  {
#line 259
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 260
    return;
  }
  {
#line 263
  explicit_bzero((void *)(& ctx->fcrypt_ctx), sizeof(ctx->fcrypt_ctx));
#line 264
  __cil_tmp2 = strlen((char const   *)ctx->password);
#line 264
  explicit_bzero((void *)ctx->password, __cil_tmp2);
#line 265
  free((void *)ctx->password);
#line 266
  zip_error_fini(& ctx->error);
#line 267
  free((void *)ctx);
  }
#line 269
  return;
}
}
#line 272 "/root/patchweave_new/24/lib/zip_source_winzip_aes_decode.c"
static struct winzip_aes___0 *winzip_aes_new___0(unsigned int mode , char const   *password ) 
{ 
  struct winzip_aes___0 *ctx ;
  void *__cil_tmp4 ;

  {
  {
#line 275
  __cil_tmp4 = malloc(sizeof(*ctx));
#line 275
  ctx = (struct winzip_aes___0 *)__cil_tmp4;
  }
#line 275
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 276
    return ((struct winzip_aes___0 *)((void *)0));
  }
  {
#line 279
  ctx->password = strdup(password);
  }
#line 279
  if ((unsigned long )ctx->password == (unsigned long )((void *)0)) {
    {
#line 280
    free((void *)ctx);
    }
#line 281
    return ((struct winzip_aes___0 *)((void *)0));
  }
  {
#line 284
  ctx->mode = mode;
#line 286
  zip_error_init(& ctx->error);
  }
#line 288
  return (ctx);
}
}
#line 57 "/root/patchweave_new/24/lib/zip_source_window.c"
static zip_int64_t window_read(zip_source_t *src , void *_ctx , void *data , zip_uint64_t len ,
                               zip_source_cmd_t cmd ) ;
#line 61 "/root/patchweave_new/24/lib/zip_source_window.c"
zip_source_t *zip_source_window(zip_t *za___0 , zip_source_t *src , zip_uint64_t start___0 ,
                                zip_uint64_t len ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
  {
#line 63
  __cil_tmp5 = _zip_source_window_new(src, start___0, len, (zip_stat_t *)((void *)0),
                                      (zip_int8_t )0, (zip_t *)((void *)0), (zip_uint64_t )0,
                                      & za___0->error);
  }
#line 63
  return (__cil_tmp5);
}
}
#line 68 "/root/patchweave_new/24/lib/zip_source_window.c"
zip_source_t *_zip_source_window_new(zip_source_t *src , zip_uint64_t start___0 ,
                                     zip_uint64_t length , zip_stat_t *st , zip_int8_t compression_flags___0 ,
                                     zip_t *source_archive , zip_uint64_t source_index ,
                                     zip_error_t *error ) 
{ 
  struct window *ctx ;
  void *__cil_tmp10 ;
  zip_int64_t __cil_tmp11 ;
  zip_int64_t __cil_tmp12 ;
  int tmp ;
  int __cil_tmp14 ;
  zip_source_t *__cil_tmp15 ;

  {
#line 72
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 73
    zip_error_set(error, 18, 0);
    }
#line 74
    return ((zip_source_t *)((void *)0));
  } else
#line 72
  if (start___0 + length < start___0) {
    {
#line 73
    zip_error_set(error, 18, 0);
    }
#line 74
    return ((zip_source_t *)((void *)0));
  } else
#line 72
  if ((unsigned long )source_archive == (unsigned long )((void *)0)) {
#line 72
    if (source_index != 0UL) {
      {
#line 73
      zip_error_set(error, 18, 0);
      }
#line 74
      return ((zip_source_t *)((void *)0));
    }
  }
  {
#line 77
  __cil_tmp10 = malloc(sizeof(*ctx));
#line 77
  ctx = (struct window *)__cil_tmp10;
  }
#line 77
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 78
    zip_error_set(error, 14, 0);
    }
#line 79
    return ((zip_source_t *)((void *)0));
  }
  {
#line 82
  ctx->start = start___0;
#line 83
  ctx->end = start___0 + length;
#line 84
  zip_stat_init(& ctx->stat);
#line 85
  ctx->compression_flags = compression_flags___0;
#line 86
  ctx->source_archive = source_archive;
#line 87
  ctx->source_index = source_index;
#line 88
  zip_error_init(& ctx->error);
#line 89
  __cil_tmp12 = zip_source_make_command_bitmap((zip_source_cmd_t )16, 14, 7, -1);
#line 89
  __cil_tmp11 = zip_source_supports(src);
#line 89
  ctx->supports = (zip_int64_t )(((unsigned long )__cil_tmp11 & ((((((((1UL | (1UL << 1)) | (1UL << 2)) | (1UL << 3)) | (1UL << 4)) | (1UL << 5)) | (1UL << 6)) | (1UL << 7)) | (1UL << 14))) | (unsigned long )__cil_tmp12);
  }
#line 90
  if ((unsigned long )ctx->supports & (1UL << 6)) {
#line 90
    tmp = 1;
  } else {
#line 90
    tmp = 0;
  }
#line 90
  ctx->needs_seek = tmp;
#line 92
  if (st) {
    {
#line 93
    __cil_tmp14 = _zip_stat_merge(& ctx->stat, st, error);
    }
#line 93
    if (__cil_tmp14 < 0) {
      {
#line 94
      free((void *)ctx);
      }
#line 95
      return ((zip_source_t *)((void *)0));
    }
  }
  {
#line 99
  __cil_tmp15 = zip_source_layered_create(src, & window_read, (void *)ctx, error);
  }
#line 99
  return (__cil_tmp15);
}
}
#line 104 "/root/patchweave_new/24/lib/zip_source_window.c"
int _zip_source_set_source_archive(zip_source_t *src , zip_t *za___0 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 106
  src->source_archive = za___0;
#line 107
  __cil_tmp3 = _zip_register_source(za___0, src);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 113 "/root/patchweave_new/24/lib/zip_source_window.c"
void _zip_source_invalidate(zip_source_t *src ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 115
  src->source_closed = 1;
#line 117
  __cil_tmp2 = zip_error_code_zip(& src->error);
  }
#line 117
  if (__cil_tmp2 == 0) {
    {
#line 118
    zip_error_set(& src->error, 8, 0);
    }
  }
#line 121
  return;
}
}
#line 124 "/root/patchweave_new/24/lib/zip_source_window.c"
static zip_int64_t window_read(zip_source_t *src , void *_ctx , void *data , zip_uint64_t len ,
                               zip_source_cmd_t cmd ) 
{ 
  struct window *ctx ;
  zip_int64_t ret ;
  zip_uint64_t n ;
  zip_uint64_t i ;
  char b[8192] ;
  zip_int64_t __cil_tmp11 ;
  zip_int64_t offset ;
  zip_uint64_t __cil_tmp13 ;
  unsigned long tmp ;
  int __cil_tmp16 ;
  zip_int64_t new_offset ;
  zip_int64_t __cil_tmp19 ;
  zip_stat_t *st ;
  int __cil_tmp21 ;

  {
#line 131
  ctx = (struct window *)_ctx;
#line 134
  if ((unsigned int )cmd == 2U) {
#line 134
    goto case_2;
  }
#line 137
  if ((unsigned int )cmd == 4U) {
#line 137
    goto case_4;
  }
#line 140
  if ((unsigned int )cmd == 5U) {
#line 140
    goto case_5;
  }
#line 144
  if ((unsigned int )cmd == 0U) {
#line 144
    goto case_0;
  }
#line 178
  if ((unsigned int )cmd == 1U) {
#line 178
    goto case_1;
  }
#line 207
  if ((unsigned int )cmd == 6U) {
#line 207
    goto case_6;
  }
#line 219
  if ((unsigned int )cmd == 3U) {
#line 219
    goto case_3;
  }
#line 231
  if ((unsigned int )cmd == 16U) {
#line 231
    goto case_16;
  }
#line 234
  if ((unsigned int )cmd == 14U) {
#line 234
    goto case_14;
  }
#line 237
  if ((unsigned int )cmd == 7U) {
#line 237
    goto case_7;
  }
#line 240
  goto switch_default;
  case_2: 
#line 135
  return ((zip_int64_t )0);
  case_4: 
  {
#line 138
  __cil_tmp11 = zip_error_to_data(& ctx->error, data, len);
  }
#line 138
  return (__cil_tmp11);
  case_5: 
  {
#line 141
  free((void *)ctx);
  }
#line 142
  return ((zip_int64_t )0);
  case_0: 
#line 145
  if (ctx->source_archive) {
    {
#line 148
    __cil_tmp13 = _zip_file_get_offset(ctx->source_archive, ctx->source_index, & ctx->error);
#line 148
    offset = (zip_int64_t )__cil_tmp13;
    }
#line 148
    if (offset == 0L) {
#line 149
      return ((zip_int64_t )-1);
    }
#line 151
    if (ctx->end + (unsigned long )offset < ctx->end) {
      {
#line 153
      zip_error_set(& ctx->error, 21, 0);
      }
#line 154
      return ((zip_int64_t )-1);
    }
#line 156
    ctx->start += (unsigned long )offset;
#line 157
    ctx->end += (unsigned long )offset;
#line 158
    ctx->source_archive = (zip_t *)((void *)0);
  }
#line 161
  if (! ctx->needs_seek) {
#line 162
    n = (zip_uint64_t )0;
    {
#line 162
    while (1) {
      while_continue: /* CIL Label */ ;

#line 162
      if (! (n < ctx->start)) {
#line 162
        goto while_break;
      }
#line 163
      if (ctx->start - n > sizeof(b)) {
#line 163
        tmp = sizeof(b);
      } else {
#line 163
        tmp = ctx->start - n;
      }
      {
#line 163
      i = tmp;
#line 164
      ret = zip_source_read(src, (void *)(b), i);
      }
#line 164
      if (ret < 0L) {
        {
#line 165
        _zip_error_set_from_source(& ctx->error, src);
        }
#line 166
        return ((zip_int64_t )-1);
      }
#line 168
      if (ret == 0L) {
        {
#line 169
        zip_error_set(& ctx->error, 17, 0);
        }
#line 170
        return ((zip_int64_t )-1);
      }
#line 162
      n += (zip_uint64_t )ret;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 175
  ctx->offset = ctx->start;
#line 176
  return ((zip_int64_t )0);
  case_1: 
#line 179
  if (len > ctx->end - ctx->offset) {
#line 180
    len = ctx->end - ctx->offset;
  }
#line 182
  if (len == 0UL) {
#line 183
    return ((zip_int64_t )0);
  }
#line 185
  if (ctx->needs_seek) {
    {
#line 186
    __cil_tmp16 = zip_source_seek(src, (zip_int64_t )ctx->offset, 0);
    }
#line 186
    if (__cil_tmp16 < 0) {
      {
#line 187
      _zip_error_set_from_source(& ctx->error, src);
      }
#line 188
      return ((zip_int64_t )-1);
    }
  }
  {
#line 192
  ret = zip_source_read(src, data, len);
  }
#line 192
  if (ret < 0L) {
    {
#line 193
    zip_error_set(& ctx->error, 17, 0);
    }
#line 194
    return ((zip_int64_t )-1);
  }
#line 197
  ctx->offset += (zip_uint64_t )ret;
#line 199
  if (ret == 0L) {
#line 200
    if (ctx->offset < ctx->end) {
      {
#line 201
      zip_error_set(& ctx->error, 17, 0);
      }
#line 202
      return ((zip_int64_t )-1);
    }
  }
#line 205
  return (ret);
  case_6: 
  {
#line 209
  __cil_tmp19 = zip_source_seek_compute_offset(ctx->offset - ctx->start, ctx->end - ctx->start,
                                               data, len, & ctx->error);
#line 209
  new_offset = __cil_tmp19;
  }
#line 211
  if (new_offset < 0L) {
#line 212
    return ((zip_int64_t )-1);
  }
#line 215
  ctx->offset = (zip_uint64_t )new_offset + ctx->start;
#line 216
  return ((zip_int64_t )0);
  case_3: 
  {
#line 223
  st = (zip_stat_t *)data;
#line 225
  __cil_tmp21 = _zip_stat_merge(st, & ctx->stat, & ctx->error);
  }
#line 225
  if (__cil_tmp21 < 0) {
#line 226
    return ((zip_int64_t )-1);
  }
#line 228
  return ((zip_int64_t )0);
  case_16: 
#line 232
  return ((zip_int64_t )ctx->compression_flags);
  case_14: 
#line 235
  return (ctx->supports);
  case_7: 
#line 238
  return ((zip_int64_t )(ctx->offset - ctx->start));
  switch_default: 
  {
#line 241
  zip_error_set(& ctx->error, 28, 0);
  }
#line 242
  return ((zip_int64_t )-1);

#line 246
  return (0L);
}
}
#line 248 "/root/patchweave_new/24/lib/zip_source_window.c"
void _zip_deregister_source(zip_t *za___0 , zip_source_t *src ) 
{ 
  unsigned int i ;
  unsigned int __cil_tmp4 ;

  {
#line 252
  i = 0U;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;

#line 252
    if (! (i < za___0->nopen_source)) {
#line 252
      goto while_break;
    }
#line 253
    if ((unsigned long )*(za___0->open_source + i) == (unsigned long )src) {
#line 254
      *(za___0->open_source + i) = *(za___0->open_source + (za___0->nopen_source - 1U));
#line 255
      __cil_tmp4 = za___0->nopen_source;
#line 255
      (za___0->nopen_source) --;
#line 256
      goto while_break;
    }
#line 252
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 256
  return;
}
}
#line 263 "/root/patchweave_new/24/lib/zip_source_window.c"
int _zip_register_source(zip_t *za___0 , zip_source_t *src ) 
{ 
  zip_source_t **open_source ;
  unsigned int n ;
  void *__cil_tmp5 ;
  unsigned int __cil_tmp6 ;

  {
#line 267
  if (za___0->nopen_source + 1U >= za___0->nopen_source_alloc) {
    {
#line 269
    n = za___0->nopen_source_alloc + 10U;
#line 270
    __cil_tmp5 = realloc((void *)za___0->open_source, (unsigned long )n * sizeof(zip_source_t *));
#line 270
    open_source = (zip_source_t **)__cil_tmp5;
    }
#line 271
    if ((unsigned long )open_source == (unsigned long )((void *)0)) {
      {
#line 272
      zip_error_set(& za___0->error, 14, 0);
      }
#line 273
      return (-1);
    }
#line 275
    za___0->nopen_source_alloc = n;
#line 276
    za___0->open_source = open_source;
  }
#line 279
  __cil_tmp6 = za___0->nopen_source;
#line 279
  (za___0->nopen_source) ++;
#line 279
  *(za___0->open_source + __cil_tmp6) = src;
#line 281
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_tell_write.c"
zip_int64_t zip_source_tell_write(zip_source_t *src ) 
{ 
  zip_int64_t __cil_tmp2 ;

  {
#line 41
  if (! ((unsigned int )src->write_state == 1U)) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return ((zip_int64_t )-1);
  }
  {
#line 46
  __cil_tmp2 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )13);
  }
#line 46
  return (__cil_tmp2);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_tell.c"
zip_int64_t zip_source_tell(zip_source_t *src ) 
{ 
  zip_int64_t __cil_tmp2 ;

  {
#line 41
  if (src->source_closed) {
#line 42
    return ((zip_int64_t )-1);
  }
#line 44
  if (! (src->open_count > 0U)) {
    {
#line 45
    zip_error_set(& src->error, 18, 0);
    }
#line 46
    return ((zip_int64_t )-1);
  }
  {
#line 49
  __cil_tmp2 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )7);
  }
#line 49
  return (__cil_tmp2);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_source_supports.c"
zip_int64_t zip_source_supports(zip_source_t *src ) 
{ 


  {
#line 43
  return (src->supports);
}
}
#line 48 "/root/patchweave_new/24/lib/zip_source_supports.c"
zip_int64_t zip_source_make_command_bitmap(zip_source_cmd_t cmd0  , ...) 
{ 
  zip_int64_t bitmap ;
  va_list ap ;
  int cmd ;

  {
  {
#line 53
  bitmap = (zip_int64_t )(1UL << (unsigned int )cmd0);
#line 57
  __builtin_va_start((__builtin_va_list )((void *)ap), cmd0);
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    cmd = 0;
#line 60
    if (cmd < 0) {
#line 61
      goto while_break;
    }
#line 63
    bitmap = (zip_int64_t )((unsigned long )bitmap | (1UL << cmd));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 65
  __builtin_va_end((__builtin_va_list )((void *)ap));
  }
#line 67
  return (bitmap);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_stat.c"
int zip_source_stat(zip_source_t *src , zip_stat_t *st ) 
{ 
  int __cil_tmp3 ;
  zip_int64_t __cil_tmp4 ;

  {
#line 41
  if (src->source_closed) {
#line 42
    return (-1);
  }
#line 44
  if ((unsigned long )st == (unsigned long )((void *)0)) {
    {
#line 45
    zip_error_set(& src->error, 18, 0);
    }
#line 46
    return (-1);
  }
  {
#line 49
  zip_stat_init(st);
  }
#line 51
  if ((unsigned long )src->src != (unsigned long )((void *)0)) {
    {
#line 52
    __cil_tmp3 = zip_source_stat(src->src, st);
    }
#line 52
    if (__cil_tmp3 < 0) {
      {
#line 53
      _zip_error_set_from_source(& src->error, src->src);
      }
#line 54
      return (-1);
    }
  }
  {
#line 58
  __cil_tmp4 = _zip_source_call(src, (void *)st, sizeof(*st), (zip_source_cmd_t )3);
  }
#line 58
  if (__cil_tmp4 < 0L) {
#line 59
    return (-1);
  }
#line 62
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_seek_write.c"
int zip_source_seek_write(zip_source_t *src , zip_int64_t offset , int whence ) 
{ 
  zip_source_args_seek_t args ;
  zip_int64_t __cil_tmp5 ;
  int tmp ;

  {
#line 43
  if (! ((unsigned int )src->write_state == 1U)) {
    {
#line 44
    zip_error_set(& src->error, 18, 0);
    }
#line 45
    return (-1);
  } else
#line 43
  if (whence != 0) {
#line 43
    if (whence != 1) {
#line 43
      if (whence != 2) {
        {
#line 44
        zip_error_set(& src->error, 18, 0);
        }
#line 45
        return (-1);
      }
    }
  }
  {
#line 48
  args.offset = offset;
#line 49
  args.whence = whence;
#line 51
  __cil_tmp5 = _zip_source_call(src, (void *)(& args), sizeof(args), (zip_source_cmd_t )12);
  }
#line 51
  if (__cil_tmp5 < 0L) {
#line 51
    tmp = -1;
  } else {
#line 51
    tmp = 0;
  }
#line 51
  return (tmp);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_seek.c"
int zip_source_seek(zip_source_t *src , zip_int64_t offset , int whence ) 
{ 
  zip_source_args_seek_t args ;
  zip_int64_t __cil_tmp5 ;
  int tmp ;

  {
#line 43
  if (src->source_closed) {
#line 44
    return (-1);
  }
#line 46
  if (! (src->open_count > 0U)) {
    {
#line 47
    zip_error_set(& src->error, 18, 0);
    }
#line 48
    return (-1);
  } else
#line 46
  if (whence != 0) {
#line 46
    if (whence != 1) {
#line 46
      if (whence != 2) {
        {
#line 47
        zip_error_set(& src->error, 18, 0);
        }
#line 48
        return (-1);
      }
    }
  }
  {
#line 51
  args.offset = offset;
#line 52
  args.whence = whence;
#line 54
  __cil_tmp5 = _zip_source_call(src, (void *)(& args), sizeof(args), (zip_source_cmd_t )6);
  }
#line 54
  if (__cil_tmp5 < 0L) {
#line 54
    tmp = -1;
  } else {
#line 54
    tmp = 0;
  }
#line 54
  return (tmp);
}
}
#line 59 "/root/patchweave_new/24/lib/zip_source_seek.c"
zip_int64_t zip_source_seek_compute_offset(zip_uint64_t offset , zip_uint64_t length ,
                                           void *data , zip_uint64_t data_length ,
                                           zip_error_t *error ) 
{ 
  zip_int64_t new_offset ;
  zip_source_args_seek_t *args ;
  zip_source_args_seek_t *tmp ;

  {
#line 62
  if (data_length < sizeof(zip_source_args_seek_t )) {
    {
#line 62
    zip_error_set(error, 18, 0);
#line 62
    tmp = (zip_source_args_seek_t *)((void *)0);
    }
  } else {
#line 62
    tmp = (zip_source_args_seek_t *)data;
  }
#line 62
  args = tmp;
#line 64
  if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 65
    return ((zip_int64_t )-1);
  }
#line 69
  if (args->whence == 1) {
#line 69
    goto case_1;
  }
#line 73
  if (args->whence == 2) {
#line 73
    goto case_2;
  }
#line 77
  if (args->whence == 0) {
#line 77
    goto case_0;
  }
#line 81
  goto switch_default;
  case_1: 
#line 70
  new_offset = (zip_int64_t )offset + args->offset;
#line 71
  goto switch_break;
  case_2: 
#line 74
  new_offset = (zip_int64_t )length + args->offset;
#line 75
  goto switch_break;
  case_0: 
#line 78
  new_offset = args->offset;
#line 79
  goto switch_break;
  switch_default: 
  {
#line 82
  zip_error_set(error, 18, 0);
  }
#line 83
  return ((zip_int64_t )-1);
  switch_break: ;
#line 86
  if (new_offset < 0L) {
    {
#line 87
    zip_error_set(error, 18, 0);
    }
#line 88
    return ((zip_int64_t )-1);
  } else
#line 86
  if ((zip_uint64_t )new_offset > length) {
    {
#line 87
    zip_error_set(error, 18, 0);
    }
#line 88
    return ((zip_int64_t )-1);
  }
#line 91
  return (new_offset);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_rollback_write.c"
void zip_source_rollback_write(zip_source_t *src ) 
{ 


  {
#line 41
  if ((unsigned int )src->write_state != 1U) {
#line 41
    if ((unsigned int )src->write_state != 2U) {
#line 42
      return;
    }
  }
  {
#line 45
  _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )10);
#line 46
  src->write_state = (zip_source_write_state_t )0;
  }
#line 48
  return;
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_remove.c"
int zip_source_remove(zip_source_t *src ) 
{ 
  int __cil_tmp2 ;
  zip_int64_t __cil_tmp3 ;

  {
#line 41
  if ((unsigned int )src->write_state == 3U) {
#line 42
    return (0);
  }
#line 45
  if (src->open_count > 0U) {
    {
#line 46
    __cil_tmp2 = zip_source_close(src);
    }
#line 46
    if (__cil_tmp2 < 0) {
#line 47
      return (-1);
    }
  }
#line 50
  if ((unsigned int )src->write_state != 0U) {
    {
#line 51
    zip_source_rollback_write(src);
    }
  }
  {
#line 54
  __cil_tmp3 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )15);
  }
#line 54
  if (__cil_tmp3 < 0L) {
#line 55
    return (-1);
  }
#line 58
  src->write_state = (zip_source_write_state_t )3;
#line 60
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_read.c"
zip_int64_t zip_source_read(zip_source_t *src , void *data , zip_uint64_t len ) 
{ 
  zip_uint64_t bytes_read ;
  zip_int64_t n ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 44
  if (src->source_closed) {
#line 45
    return ((zip_int64_t )-1);
  }
#line 47
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 47
    if (len > 0UL) {
      {
#line 48
      zip_error_set(& src->error, 18, 0);
      }
#line 49
      return ((zip_int64_t )-1);
    } else {
#line 47
      goto _L;
    }
  } else
  _L: 
#line 47
  if (! (src->open_count > 0U)) {
    {
#line 48
    zip_error_set(& src->error, 18, 0);
    }
#line 49
    return ((zip_int64_t )-1);
  } else
#line 47
  if (len > 0xffffffffffffffffUL) {
    {
#line 48
    zip_error_set(& src->error, 18, 0);
    }
#line 49
    return ((zip_int64_t )-1);
  }
  {
#line 52
  __cil_tmp6 = _zip_source_had_error(src);
  }
#line 52
  if (__cil_tmp6) {
#line 53
    return ((zip_int64_t )-1);
  }
  {
#line 56
  __cil_tmp7 = _zip_source_eof(src);
  }
#line 56
  if (__cil_tmp7) {
#line 57
    return ((zip_int64_t )0);
  }
#line 60
  bytes_read = (zip_uint64_t )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;

#line 61
    if (! (bytes_read < len)) {
#line 61
      goto while_break;
    }
    {
#line 62
    n = _zip_source_call(src, (void *)((zip_uint8_t *)data + bytes_read), len - bytes_read,
                         (zip_source_cmd_t )1);
    }
#line 62
    if (n < 0L) {
#line 63
      if (bytes_read == 0UL) {
#line 64
        return ((zip_int64_t )-1);
      } else {
#line 67
        return ((zip_int64_t )bytes_read);
      }
    }
#line 71
    if (n == 0L) {
#line 72
      src->eof = 1;
#line 73
      goto while_break;
    }
#line 76
    bytes_read += (zip_uint64_t )n;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 79
  return ((zip_int64_t )bytes_read);
}
}
#line 84 "/root/patchweave_new/24/lib/zip_source_read.c"
int _zip_source_eof(zip_source_t *src ) 
{ 


  {
#line 86
  return (src->eof);
}
}
#line 51 "/root/patchweave_new/24/lib/zip_source_pkware.c"
static void decrypt(struct trad_pkware *ctx , zip_uint8_t *out , zip_uint8_t *in ,
                    zip_uint64_t len , int update_only ) ;
#line 53
static int decrypt_header___0(zip_source_t *src , struct trad_pkware *ctx ) ;
#line 54
static zip_int64_t pkware_decrypt(zip_source_t *src , void *ud , void *data , zip_uint64_t len ,
                                  zip_source_cmd_t cmd ) ;
#line 56
static void pkware_free(struct trad_pkware *ctx ) ;
#line 60 "/root/patchweave_new/24/lib/zip_source_pkware.c"
zip_source_t *zip_source_pkware(zip_t *za___0 , zip_source_t *src , zip_uint16_t em ,
                                int flags , char const   *password ) 
{ 
  struct trad_pkware *ctx ;
  zip_source_t *s2 ;
  void *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;

  {
#line 66
  if ((unsigned long )password == (unsigned long )((void *)0)) {
    {
#line 67
    zip_error_set(& za___0->error, 18, 0);
    }
#line 68
    return ((zip_source_t *)((void *)0));
  } else
#line 66
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 67
    zip_error_set(& za___0->error, 18, 0);
    }
#line 68
    return ((zip_source_t *)((void *)0));
  } else
#line 66
  if ((int )em != 1) {
    {
#line 67
    zip_error_set(& za___0->error, 18, 0);
    }
#line 68
    return ((zip_source_t *)((void *)0));
  }
#line 70
  if (flags & 1) {
    {
#line 71
    zip_error_set(& za___0->error, 24, 0);
    }
#line 72
    return ((zip_source_t *)((void *)0));
  }
  {
#line 75
  __cil_tmp8 = malloc(sizeof(*ctx));
#line 75
  ctx = (struct trad_pkware *)__cil_tmp8;
  }
#line 75
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 76
    zip_error_set(& za___0->error, 14, 0);
    }
#line 77
    return ((zip_source_t *)((void *)0));
  }
  {
#line 80
  zip_error_init(& ctx->error);
#line 82
  ctx->key[0] = (zip_uint32_t )305419896;
#line 83
  ctx->key[1] = (zip_uint32_t )591751049;
#line 84
  ctx->key[2] = (zip_uint32_t )878082192;
#line 85
  __cil_tmp9 = strlen(password);
#line 85
  decrypt(ctx, (zip_uint8_t *)((void *)0), (zip_uint8_t *)password, __cil_tmp9, 1);
#line 87
  s2 = zip_source_layered(za___0, src, & pkware_decrypt, (void *)ctx);
  }
#line 87
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
    {
#line 88
    pkware_free(ctx);
    }
#line 89
    return ((zip_source_t *)((void *)0));
  }
#line 92
  return (s2);
}
}
#line 97 "/root/patchweave_new/24/lib/zip_source_pkware.c"
static void decrypt(struct trad_pkware *ctx , zip_uint8_t *out , zip_uint8_t *in ,
                    zip_uint64_t len , int update_only ) 
{ 
  zip_uint16_t tmp ;
  zip_uint64_t i ;
  Bytef b ;
  uLong __cil_tmp9 ;
  uLong __cil_tmp10 ;

  {
#line 104
  i = (zip_uint64_t )0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;

#line 104
    if (! (i < len)) {
#line 104
      goto while_break;
    }
#line 105
    b = *(in + i);
#line 107
    if (! update_only) {
#line 109
      tmp = (zip_uint16_t )(ctx->key[2] | 2U);
#line 110
      tmp = (zip_uint16_t )((zip_uint32_t )tmp * (unsigned int )((int )tmp ^ 1) >> 8);
#line 111
      b = (Bytef )((int )b ^ (int )((Bytef )tmp));
    }
#line 115
    if (out) {
#line 116
      *(out + i) = b;
    }
    {
#line 119
    __cil_tmp9 = crc32((unsigned long )ctx->key[0] ^ 4294967295UL, & b, (uInt )1);
#line 119
    ctx->key[0] = (zip_uint32_t )((unsigned long )((zip_uint32_t )__cil_tmp9) ^ 4294967295UL);
#line 120
    ctx->key[1] = (ctx->key[1] + (ctx->key[0] & 255U)) * 134775813U + 1U;
#line 121
    b = (Bytef )(ctx->key[1] >> 24);
#line 122
    __cil_tmp10 = crc32((unsigned long )ctx->key[2] ^ 4294967295UL, & b, (uInt )1);
#line 122
    ctx->key[2] = (zip_uint32_t )((unsigned long )((zip_uint32_t )__cil_tmp10) ^ 4294967295UL);
#line 104
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 108
  return;
}
}
#line 128 "/root/patchweave_new/24/lib/zip_source_pkware.c"
static int decrypt_header___0(zip_source_t *src , struct trad_pkware *ctx ) 
{ 
  zip_uint8_t header[12] ;
  struct zip_stat st ;
  zip_int64_t n ;
  unsigned short dostime ;
  unsigned short dosdate ;
  int __cil_tmp9 ;

  {
  {
#line 135
  n = zip_source_read(src, (void *)(header), (zip_uint64_t )12);
  }
#line 135
  if (n < 0L) {
    {
#line 136
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 137
    return (-1);
  }
#line 140
  if (n != 12L) {
    {
#line 141
    zip_error_set(& ctx->error, 17, 0);
    }
#line 142
    return (-1);
  }
  {
#line 145
  decrypt(ctx, header, header, (zip_uint64_t )12, 0);
#line 147
  __cil_tmp9 = zip_source_stat(src, & st);
  }
#line 147
  if (__cil_tmp9 < 0) {
#line 149
    return (0);
  }
  {
#line 152
  _zip_u2d_time(st.mtime, & dostime, & dosdate);
  }
#line 154
  if ((unsigned int )header[11] != st.crc >> 24) {
#line 154
    if ((int )header[11] != (int )dostime >> 8) {
      {
#line 155
      zip_error_set(& ctx->error, 27, 0);
      }
#line 156
      return (-1);
    }
  }
#line 159
  return (0);
}
}
#line 164 "/root/patchweave_new/24/lib/zip_source_pkware.c"
static zip_int64_t pkware_decrypt(zip_source_t *src , void *ud , void *data , zip_uint64_t len ,
                                  zip_source_cmd_t cmd ) 
{ 
  struct trad_pkware *ctx ;
  zip_int64_t n ;
  int __cil_tmp8 ;
  zip_stat_t *st ;
  zip_int64_t __cil_tmp11 ;
  zip_int64_t __cil_tmp12 ;

  {
#line 170
  ctx = (struct trad_pkware *)ud;
#line 173
  if ((unsigned int )cmd == 0U) {
#line 173
    goto case_0;
  }
#line 178
  if ((unsigned int )cmd == 1U) {
#line 178
    goto case_1;
  }
#line 187
  if ((unsigned int )cmd == 2U) {
#line 187
    goto case_2;
  }
#line 190
  if ((unsigned int )cmd == 3U) {
#line 190
    goto case_3;
  }
#line 205
  if ((unsigned int )cmd == 14U) {
#line 205
    goto case_14;
  }
#line 208
  if ((unsigned int )cmd == 4U) {
#line 208
    goto case_4;
  }
#line 211
  if ((unsigned int )cmd == 5U) {
#line 211
    goto case_5;
  }
#line 215
  goto switch_default;
  case_0: 
  {
#line 174
  __cil_tmp8 = decrypt_header___0(src, ctx);
  }
#line 174
  if (__cil_tmp8 < 0) {
#line 175
    return ((zip_int64_t )-1);
  }
#line 176
  return ((zip_int64_t )0);
  case_1: 
  {
#line 179
  n = zip_source_read(src, data, len);
  }
#line 179
  if (n < 0L) {
    {
#line 180
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 181
    return ((zip_int64_t )-1);
  }
  {
#line 184
  decrypt((struct trad_pkware *)ud, (zip_uint8_t *)data, (zip_uint8_t *)data, (zip_uint64_t )n,
          0);
  }
#line 185
  return (n);
  case_2: 
#line 188
  return ((zip_int64_t )0);
  case_3: 
#line 194
  st = (zip_stat_t *)data;
#line 196
  st->encryption_method = (zip_uint16_t )0;
#line 197
  st->valid |= 128UL;
#line 199
  if (st->valid & 8UL) {
#line 200
    st->comp_size -= 12UL;
  }
#line 202
  return ((zip_int64_t )0);
  case_14: 
  {
#line 206
  __cil_tmp11 = zip_source_make_command_bitmap((zip_source_cmd_t )0, 1, 2, 3, 4, 5,
                                               -1);
  }
#line 206
  return (__cil_tmp11);
  case_4: 
  {
#line 209
  __cil_tmp12 = zip_error_to_data(& ctx->error, data, len);
  }
#line 209
  return (__cil_tmp12);
  case_5: 
  {
#line 212
  pkware_free(ctx);
  }
#line 213
  return ((zip_int64_t )0);
  switch_default: 
  {
#line 216
  zip_error_set(& ctx->error, 18, 0);
  }
#line 217
  return ((zip_int64_t )-1);

#line 221
  return (0L);
}
}
#line 223 "/root/patchweave_new/24/lib/zip_source_pkware.c"
static void pkware_free(struct trad_pkware *ctx ) 
{ 


  {
  {
#line 225
  free((void *)ctx);
  }
#line 227
  return;
}
}
#line 38 "/root/patchweave_new/24/lib/zip_source_open.c"
int zip_source_open(zip_source_t *src ) 
{ 
  zip_int64_t __cil_tmp2 ;
  int __cil_tmp3 ;
  zip_int64_t __cil_tmp4 ;

  {
#line 40
  if (src->source_closed) {
#line 41
    return (-1);
  }
#line 43
  if ((unsigned int )src->write_state == 3U) {
    {
#line 44
    zip_error_set(& src->error, 23, 0);
    }
#line 45
    return (-1);
  }
#line 48
  if (src->open_count > 0U) {
    {
#line 49
    __cil_tmp2 = zip_source_supports(src);
    }
#line 49
    if (((unsigned long )__cil_tmp2 & (1UL << 6)) == 0UL) {
      {
#line 50
      zip_error_set(& src->error, 29, 0);
      }
#line 51
      return (-1);
    }
  } else {
#line 55
    if ((unsigned long )src->src != (unsigned long )((void *)0)) {
      {
#line 56
      __cil_tmp3 = zip_source_open(src->src);
      }
#line 56
      if (__cil_tmp3 < 0) {
        {
#line 57
        _zip_error_set_from_source(& src->error, src->src);
        }
#line 58
        return (-1);
      }
    }
    {
#line 62
    __cil_tmp4 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )0);
    }
#line 62
    if (__cil_tmp4 < 0L) {
#line 63
      if ((unsigned long )src->src != (unsigned long )((void *)0)) {
        {
#line 64
        zip_source_close(src->src);
        }
      }
#line 66
      return (-1);
    }
  }
  {
#line 70
  src->eof = 0;
#line 71
  _zip_error_clear(& src->error);
#line 72
  (src->open_count) ++;
  }
#line 74
  return (0);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_source_layered.c"
zip_source_t *zip_source_layered(zip_t *za___0 , zip_source_t *src , zip_int64_t (*cb)(zip_source_t * ,
                                                                                       void * ,
                                                                                       void * ,
                                                                                       zip_uint64_t  ,
                                                                                       enum zip_source_cmd  ) ,
                                 void *ud ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 43
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 44
    return ((zip_source_t *)((void *)0));
  }
  {
#line 46
  __cil_tmp5 = zip_source_layered_create(src, cb, ud, & za___0->error);
  }
#line 46
  return (__cil_tmp5);
}
}
#line 51 "/root/patchweave_new/24/lib/zip_source_layered.c"
zip_source_t *zip_source_layered_create(zip_source_t *src , zip_int64_t (*cb)(zip_source_t * ,
                                                                              void * ,
                                                                              void * ,
                                                                              zip_uint64_t  ,
                                                                              enum zip_source_cmd  ) ,
                                        void *ud , zip_error_t *error ) 
{ 
  zip_source_t *zs ;

  {
  {
#line 55
  zs = _zip_source_new(error);
  }
#line 55
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
#line 56
    return ((zip_source_t *)((void *)0));
  }
  {
#line 58
  zip_source_keep(src);
#line 59
  zs->src = src;
#line 60
  zs->cb.l = cb;
#line 61
  zs->ud = ud;
#line 63
  zs->supports = (*cb)(src, ud, (void *)0, (zip_uint64_t )0, (enum zip_source_cmd )14);
  }
#line 64
  if (zs->supports < 0L) {
#line 65
    zs->supports = (zip_int64_t )(((((1UL | (1UL << 1)) | (1UL << 2)) | (1UL << 3)) | (1UL << 4)) | (1UL << 5));
  }
#line 68
  return (zs);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_is_deleted.c"
int zip_source_is_deleted(zip_source_t *src ) 
{ 


  {
#line 41
  return ((unsigned int )src->write_state == 3U);
}
}
#line 40 "/root/patchweave_new/24/lib/zip_source_get_compression_flags.c"
zip_int8_t zip_source_get_compression_flags(zip_source_t *src ) 
{ 
  zip_int64_t ret ;
  zip_int64_t __cil_tmp3 ;

  {
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;

#line 42
    if (! src) {
#line 42
      goto while_break;
    }
#line 43
    if ((unsigned long )src->supports & (1UL << 16)) {
      {
#line 44
      __cil_tmp3 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )16);
#line 44
      ret = __cil_tmp3;
      }
#line 45
      if (ret < 0L) {
#line 46
        return ((zip_int8_t )-1);
      }
#line 48
      if (ret > 3L) {
        {
#line 49
        zip_error_set(& src->error, 20, 0);
        }
#line 50
        return ((zip_int8_t )-1);
      }
#line 52
      return ((zip_int8_t )ret);
    }
#line 54
    src = src->src;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 57
  return ((zip_int8_t )0);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_source_function.c"
zip_source_t *zip_source_function(zip_t *za___0 , zip_int64_t (*zcb)(void * , void * ,
                                                                     zip_uint64_t  ,
                                                                     zip_source_cmd_t  ) ,
                                  void *ud ) 
{ 
  zip_source_t *__cil_tmp4 ;

  {
#line 43
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 44
    return ((zip_source_t *)((void *)0));
  }
  {
#line 47
  __cil_tmp4 = zip_source_function_create(zcb, ud, & za___0->error);
  }
#line 47
  return (__cil_tmp4);
}
}
#line 52 "/root/patchweave_new/24/lib/zip_source_function.c"
zip_source_t *zip_source_function_create(zip_int64_t (*zcb)(void * , void * , zip_uint64_t  ,
                                                            zip_source_cmd_t  ) ,
                                         void *ud , zip_error_t *error ) 
{ 
  zip_source_t *zs ;

  {
  {
#line 56
  zs = _zip_source_new(error);
  }
#line 56
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
#line 57
    return ((zip_source_t *)((void *)0));
  }
  {
#line 59
  zs->cb.f = zcb;
#line 60
  zs->ud = ud;
#line 62
  zs->supports = (*zcb)(ud, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )14);
  }
#line 63
  if (zs->supports < 0L) {
#line 64
    zs->supports = (zip_int64_t )(((((1UL | (1UL << 1)) | (1UL << 2)) | (1UL << 3)) | (1UL << 4)) | (1UL << 5));
  }
#line 67
  return (zs);
}
}
#line 72 "/root/patchweave_new/24/lib/zip_source_function.c"
void zip_source_keep(zip_source_t *src ) 
{ 


  {
#line 74
  (src->refcount) ++;
#line 75
  return;
}
}
#line 79 "/root/patchweave_new/24/lib/zip_source_function.c"
zip_source_t *_zip_source_new(zip_error_t *error ) 
{ 
  zip_source_t *src ;
  void *__cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = malloc(sizeof(*src));
#line 83
  src = (zip_source_t *)__cil_tmp3;
  }
#line 83
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 84
    zip_error_set(error, 14, 0);
    }
#line 85
    return ((zip_source_t *)((void *)0));
  }
  {
#line 88
  src->src = (zip_source_t *)((void *)0);
#line 89
  src->cb.f = (zip_int64_t (*)(void * , void * , zip_uint64_t  , zip_source_cmd_t  ))((void *)0);
#line 90
  src->ud = (void *)0;
#line 91
  src->open_count = 0U;
#line 92
  src->write_state = (zip_source_write_state_t )0;
#line 93
  src->source_closed = 0;
#line 94
  src->source_archive = (zip_t *)((void *)0);
#line 95
  src->refcount = 1U;
#line 96
  zip_error_init(& src->error);
#line 97
  src->eof = 0;
  }
#line 99
  return (src);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_source_free.c"
void zip_source_free(zip_source_t *src ) 
{ 
  unsigned int __cil_tmp2 ;

  {
#line 43
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 44
    return;
  }
#line 46
  if (src->refcount > 0U) {
#line 47
    __cil_tmp2 = src->refcount;
#line 47
    (src->refcount) --;
  }
#line 49
  if (src->refcount > 0U) {
#line 50
    return;
  }
#line 53
  if (src->open_count > 0U) {
    {
#line 54
    src->open_count = 1U;
#line 55
    zip_source_close(src);
    }
  }
#line 57
  if ((unsigned int )src->write_state == 1U) {
    {
#line 58
    zip_source_rollback_write(src);
    }
  }
#line 61
  if (src->source_archive) {
#line 61
    if (! src->source_closed) {
      {
#line 62
      _zip_deregister_source(src->source_archive, src);
      }
    }
  }
  {
#line 65
  _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )5);
  }
#line 67
  if (src->src) {
    {
#line 68
    zip_source_free(src->src);
    }
  }
  {
#line 71
  free((void *)src);
  }
#line 73
  return;
}
}
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                                                          struct stat *__statbuf ) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat)(int __fd ,
                                                                                             char const   *__filename ,
                                                                                             struct stat *__statbuf ,
                                                                                             int __flag ) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                                                           struct stat *__statbuf ) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 308
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknodat)(int __fd ,
                                                                                             char const   *__path ,
                                                                                             __mode_t __mode ,
                                                                                             __dev_t __dev ) ;
#line 395
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev ) ;
#line 453
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                                                          struct stat *__statbuf ) ;
#line 453 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                            struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = __xstat(1, __path, __statbuf);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 460
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                                                           struct stat *__statbuf ) ;
#line 460 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                             struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 462
  __cil_tmp3 = __lxstat(1, __path, __statbuf);
  }
#line 462
  return (__cil_tmp3);
}
}
#line 467
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 467 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 469
  __cil_tmp3 = __fxstat(1, __fd, __statbuf);
  }
#line 469
  return (__cil_tmp3);
}
}
#line 474
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat)(int __fd ,
                                                                                             char const   *__filename ,
                                                                                             struct stat *__statbuf ,
                                                                                             int __flag ) ;
#line 474 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstatat)(int __fd , char const   *__filename ,
                                                               struct stat *__statbuf ,
                                                               int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 477
  __cil_tmp5 = __fxstatat(1, __fd, __filename, __statbuf, __flag);
  }
#line 477
  return (__cil_tmp5);
}
}
#line 483
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 483 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                             __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 485
  __cil_tmp4 = __xmknod(0, __path, __mode, & __dev);
  }
#line 485
  return (__cil_tmp4);
}
}
#line 491
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknodat)(int __fd ,
                                                                                             char const   *__path ,
                                                                                             __mode_t __mode ,
                                                                                             __dev_t __dev ) ;
#line 491 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) mknodat)(int __fd , char const   *__path ,
                                                               __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 494
  __cil_tmp5 = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 494
  return (__cil_tmp5);
}
}
#line 85 "/root/patchweave_new/24/lib/zip_source_filep.c"
static zip_int64_t read_file(void *state , void *data , zip_uint64_t len , zip_source_cmd_t cmd ) ;
#line 86
static int create_temp_output(struct read_file *ctx ) ;
#line 87
static int _zip_fseek_u(FILE *f , zip_uint64_t offset , int whence , zip_error_t *error ) ;
#line 88
static int _zip_fseek(FILE *f , zip_int64_t offset , int whence , zip_error_t *error ) ;
#line 92 "/root/patchweave_new/24/lib/zip_source_filep.c"
zip_source_t *zip_source_filep(zip_t *za___0 , FILE *file , zip_uint64_t start___0 ,
                               zip_int64_t len ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 94
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 95
    return ((zip_source_t *)((void *)0));
  }
  {
#line 97
  __cil_tmp5 = zip_source_filep_create(file, start___0, len, & za___0->error);
  }
#line 97
  return (__cil_tmp5);
}
}
#line 102 "/root/patchweave_new/24/lib/zip_source_filep.c"
zip_source_t *zip_source_filep_create(FILE *file , zip_uint64_t start___0 , zip_int64_t length ,
                                      zip_error_t *error ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 104
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 105
    zip_error_set(error, 18, 0);
    }
#line 106
    return ((zip_source_t *)((void *)0));
  } else
#line 104
  if (length < -1L) {
    {
#line 105
    zip_error_set(error, 18, 0);
    }
#line 106
    return ((zip_source_t *)((void *)0));
  }
  {
#line 109
  __cil_tmp5 = _zip_source_file_or_p((char const   *)((void *)0), file, start___0,
                                     length, (zip_stat_t *)((void *)0), error);
  }
#line 109
  return (__cil_tmp5);
}
}
#line 114 "/root/patchweave_new/24/lib/zip_source_filep.c"
zip_source_t *_zip_source_file_or_p(char const   *fname , FILE *file , zip_uint64_t start___0 ,
                                    zip_int64_t len , zip_stat_t *st , zip_error_t *error ) 
{ 
  struct read_file *ctx ;
  zip_source_t *zs ;
  struct stat sb ;
  int stat_valid ;
  void *__cil_tmp11 ;
  zip_int64_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int *__cil_tmp17 ;

  {
#line 121
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 121
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
      {
#line 122
      zip_error_set(error, 18, 0);
      }
#line 123
      return ((zip_source_t *)((void *)0));
    }
  }
#line 126
  if (len < 0L) {
#line 127
    len = (zip_int64_t )0;
  }
#line 130
  if (start___0 > 0xffffffffffffffffUL) {
    {
#line 131
    zip_error_set(error, 18, 0);
    }
#line 132
    return ((zip_source_t *)((void *)0));
  } else
#line 130
  if (start___0 + (zip_uint64_t )len < start___0) {
    {
#line 131
    zip_error_set(error, 18, 0);
    }
#line 132
    return ((zip_source_t *)((void *)0));
  }
  {
#line 135
  __cil_tmp11 = malloc(sizeof(struct read_file ));
#line 135
  ctx = (struct read_file *)__cil_tmp11;
  }
#line 135
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 136
    zip_error_set(error, 14, 0);
    }
#line 137
    return ((zip_source_t *)((void *)0));
  }
#line 140
  ctx->fname = (char *)((void *)0);
#line 141
  if (fname) {
    {
#line 142
    ctx->fname = strdup(fname);
    }
#line 142
    if ((unsigned long )ctx->fname == (unsigned long )((void *)0)) {
      {
#line 143
      zip_error_set(error, 14, 0);
#line 144
      free((void *)ctx);
      }
#line 145
      return ((zip_source_t *)((void *)0));
    }
  }
#line 148
  ctx->f = file;
#line 149
  ctx->start = start___0;
#line 150
  ctx->end = (zip_uint64_t )len;
#line 151
  if (st) {
    {
#line 152
    memcpy((void *)(& ctx->st), (void const   *)st, sizeof(ctx->st));
#line 153
    ctx->st.name = (char const   *)((void *)0);
#line 154
    ctx->st.valid &= 4294967294UL;
    }
  } else {
    {
#line 157
    zip_stat_init(& ctx->st);
    }
  }
#line 160
  if (ctx->end > 0UL) {
#line 161
    ctx->st.size = ctx->end;
#line 162
    ctx->st.valid |= 4UL;
  }
  {
#line 165
  zip_error_init(& ctx->stat_error);
#line 167
  ctx->tmpname = (char *)((void *)0);
#line 168
  ctx->fout = (FILE *)((void *)0);
#line 170
  zip_error_init(& ctx->error);
#line 172
  __cil_tmp13 = zip_source_make_command_bitmap((zip_source_cmd_t )14, 7, -1);
#line 172
  ctx->supports = (zip_int64_t )((((((1UL | (1UL << 1)) | (1UL << 2)) | (1UL << 3)) | (1UL << 4)) | (1UL << 5)) | (unsigned long )__cil_tmp13);
  }
#line 174
  if (ctx->fname) {
    {
#line 175
    __cil_tmp14 = stat((char const   *)ctx->fname, & sb);
#line 175
    stat_valid = __cil_tmp14 >= 0;
    }
#line 177
    if (! stat_valid) {
#line 178
      if (ctx->start == 0UL) {
#line 178
        if (ctx->end == 0UL) {
#line 179
          ctx->supports = (zip_int64_t )(((((((((((((((1UL | (1UL << 1)) | (1UL << 2)) | (1UL << 3)) | (1UL << 4)) | (1UL << 5)) | (1UL << 6)) | (1UL << 7)) | (1UL << 14)) | (1UL << 8)) | (1UL << 9)) | (1UL << 10)) | (1UL << 11)) | (1UL << 12)) | (1UL << 13)) | (1UL << 15));
        }
      }
    }
  } else {
    {
#line 184
    __cil_tmp15 = fileno(ctx->f);
#line 184
    __cil_tmp16 = fstat(__cil_tmp15, & sb);
#line 184
    stat_valid = __cil_tmp16 >= 0;
    }
  }
#line 187
  if (! stat_valid) {
    {
#line 188
    __cil_tmp17 = __errno_location();
#line 188
    zip_error_set(& ctx->stat_error, 5, *__cil_tmp17);
    }
  } else {
#line 191
    if ((ctx->st.valid & 16UL) == 0UL) {
#line 192
      ctx->st.mtime = sb.st_mtim.tv_sec;
#line 193
      ctx->st.valid |= 16UL;
    }
#line 195
    if ((sb.st_mode & 61440U) == 32768U) {
#line 196
      ctx->supports = (zip_int64_t )((((((((1UL | (1UL << 1)) | (1UL << 2)) | (1UL << 3)) | (1UL << 4)) | (1UL << 5)) | (1UL << 6)) | (1UL << 7)) | (1UL << 14));
#line 198
      if (ctx->start + ctx->end > (zip_uint64_t )sb.st_size) {
        {
#line 199
        zip_error_set(error, 18, 0);
#line 200
        free((void *)ctx->fname);
#line 201
        free((void *)ctx);
        }
#line 202
        return ((zip_source_t *)((void *)0));
      }
#line 205
      if (ctx->end == 0UL) {
#line 206
        ctx->st.size = (zip_uint64_t )sb.st_size - ctx->start;
#line 207
        ctx->st.valid |= 4UL;
#line 209
        if (ctx->fname) {
#line 209
          if (start___0 == 0UL) {
#line 210
            ctx->supports = (zip_int64_t )(((((((((((((((1UL | (1UL << 1)) | (1UL << 2)) | (1UL << 3)) | (1UL << 4)) | (1UL << 5)) | (1UL << 6)) | (1UL << 7)) | (1UL << 14)) | (1UL << 8)) | (1UL << 9)) | (1UL << 10)) | (1UL << 11)) | (1UL << 12)) | (1UL << 13)) | (1UL << 15));
          }
        }
      }
    }
  }
  {
#line 216
  zs = zip_source_function_create(& read_file, (void *)ctx, error);
  }
#line 216
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 217
    free((void *)ctx->fname);
#line 218
    free((void *)ctx);
    }
#line 219
    return ((zip_source_t *)((void *)0));
  }
#line 222
  return (zs);
}
}
#line 227 "/root/patchweave_new/24/lib/zip_source_filep.c"
static int create_temp_output(struct read_file *ctx ) 
{ 
  char *temp ;
  int tfd ;
  mode_t mask ;
  FILE *tfp ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;
  int *__cil_tmp10 ;
  int *__cil_tmp12 ;

  {
  {
#line 234
  __cil_tmp6 = strlen((char const   *)ctx->fname);
#line 234
  __cil_tmp7 = malloc(__cil_tmp6 + 8UL);
#line 234
  temp = (char *)__cil_tmp7;
  }
#line 234
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 235
    zip_error_set(& ctx->error, 14, 0);
    }
#line 236
    return (-1);
  }
  {
#line 238
  sprintf(temp, "%s.XXXXXX", ctx->fname);
#line 240
  mask = umask((__mode_t )((64 | (448 >> 3)) | ((448 >> 3) >> 3)));
#line 241
  tfd = mkstemp(temp);
  }
#line 241
  if (tfd == -1) {
    {
#line 242
    __cil_tmp10 = __errno_location();
#line 242
    zip_error_set(& ctx->error, 12, *__cil_tmp10);
#line 243
    umask(mask);
#line 244
    free((void *)temp);
    }
#line 245
    return (-1);
  }
  {
#line 247
  umask(mask);
#line 249
  tfp = fdopen(tfd, "r+b");
  }
#line 249
  if ((unsigned long )tfp == (unsigned long )((void *)0)) {
    {
#line 250
    __cil_tmp12 = __errno_location();
#line 250
    zip_error_set(& ctx->error, 12, *__cil_tmp12);
#line 251
    close(tfd);
#line 252
    remove((char const   *)temp);
#line 253
    free((void *)temp);
    }
#line 254
    return (-1);
  }
#line 265
  ctx->fout = tfp;
#line 266
  ctx->tmpname = temp;
#line 268
  return (0);
}
}
#line 273 "/root/patchweave_new/24/lib/zip_source_filep.c"
static zip_int64_t read_file(void *state , void *data , zip_uint64_t len , zip_source_cmd_t cmd ) 
{ 
  struct read_file *ctx ;
  char *buf ;
  zip_uint64_t n ;
  size_t i ;
  int __cil_tmp9 ;
  mode_t mask ;
  int __cil_tmp11 ;
  int *__cil_tmp12 ;
  int __cil_tmp13 ;
  int *__cil_tmp14 ;
  zip_int64_t __cil_tmp16 ;
  int *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp21 ;
  int *__cil_tmp22 ;
  int __cil_tmp23 ;
  int *__cil_tmp24 ;
  zip_int64_t new_current ;
  int need_seek ;
  zip_source_args_seek_t *args ;
  zip_source_args_seek_t *tmp ;
  int __cil_tmp29 ;
  int *__cil_tmp31 ;
  int __cil_tmp32 ;
  zip_source_args_seek_t *args___0 ;
  zip_source_args_seek_t *tmp___0 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  off_t ret ;
  __off_t __cil_tmp40 ;
  int *__cil_tmp41 ;
  size_t ret___0 ;
  int __cil_tmp44 ;
  int *__cil_tmp45 ;

  {
#line 280
  ctx = (struct read_file *)state;
#line 281
  buf = (char *)data;
#line 284
  if ((unsigned int )cmd == 8U) {
#line 284
    goto case_8;
  }
#line 291
  if ((unsigned int )cmd == 9U) {
#line 291
    goto case_9;
  }
#line 312
  if ((unsigned int )cmd == 2U) {
#line 312
    goto case_2;
  }
#line 319
  if ((unsigned int )cmd == 4U) {
#line 319
    goto case_4;
  }
#line 322
  if ((unsigned int )cmd == 5U) {
#line 322
    goto case_5;
  }
#line 330
  if ((unsigned int )cmd == 0U) {
#line 330
    goto case_0;
  }
#line 347
  if ((unsigned int )cmd == 1U) {
#line 347
    goto case_1;
  }
#line 371
  if ((unsigned int )cmd == 15U) {
#line 371
    goto case_15;
  }
#line 378
  if ((unsigned int )cmd == 10U) {
#line 378
    goto case_10;
  }
#line 388
  if ((unsigned int )cmd == 6U) {
#line 388
    goto case_6;
  }
#line 399
  if ((unsigned int )cmd == 0U) {
#line 399
    goto case_0___0;
  }
#line 403
  if ((unsigned int )cmd == 2U) {
#line 403
    goto case_2___0;
  }
#line 420
  if ((unsigned int )cmd == 1U) {
#line 420
    goto case_1___0;
  }
#line 445
  if ((unsigned int )cmd == 12U) {
#line 445
    goto case_12;
  }
#line 459
  if ((unsigned int )cmd == 3U) {
#line 459
    goto case_3;
  }
#line 472
  if ((unsigned int )cmd == 14U) {
#line 472
    goto case_14;
  }
#line 475
  if ((unsigned int )cmd == 7U) {
#line 475
    goto case_7;
  }
#line 478
  if ((unsigned int )cmd == 13U) {
#line 478
    goto case_13;
  }
#line 489
  if ((unsigned int )cmd == 11U) {
#line 489
    goto case_11;
  }
#line 503
  goto switch_default___0;
  case_8: 
#line 285
  if ((unsigned long )ctx->fname == (unsigned long )((void *)0)) {
    {
#line 286
    zip_error_set(& ctx->error, 28, 0);
    }
#line 287
    return ((zip_int64_t )-1);
  }
  {
#line 289
  __cil_tmp9 = create_temp_output(ctx);
  }
#line 289
  return ((zip_int64_t )__cil_tmp9);
  case_9: 
  {
#line 294
  __cil_tmp11 = fclose(ctx->fout);
  }
#line 294
  if (__cil_tmp11 < 0) {
    {
#line 295
    ctx->fout = (FILE *)((void *)0);
#line 296
    __cil_tmp12 = __errno_location();
#line 296
    zip_error_set(& ctx->error, 6, *__cil_tmp12);
    }
  }
  {
#line 298
  ctx->fout = (FILE *)((void *)0);
#line 299
  __cil_tmp13 = rename((char const   *)ctx->tmpname, (char const   *)ctx->fname);
  }
#line 299
  if (__cil_tmp13 < 0) {
    {
#line 300
    __cil_tmp14 = __errno_location();
#line 300
    zip_error_set(& ctx->error, 2, *__cil_tmp14);
    }
#line 301
    return ((zip_int64_t )-1);
  }
  {
#line 303
  mask = umask((__mode_t )18);
#line 304
  umask(mask);
#line 306
  chmod((char const   *)ctx->fname, 438U & ~ mask);
#line 307
  free((void *)ctx->tmpname);
#line 308
  ctx->tmpname = (char *)((void *)0);
  }
#line 309
  return ((zip_int64_t )0);
  case_2: 
#line 313
  if (ctx->fname) {
    {
#line 314
    fclose(ctx->f);
#line 315
    ctx->f = (FILE *)((void *)0);
    }
  }
#line 317
  return ((zip_int64_t )0);
  case_4: 
  {
#line 320
  __cil_tmp16 = zip_error_to_data(& ctx->error, data, len);
  }
#line 320
  return (__cil_tmp16);
  case_5: 
  {
#line 323
  free((void *)ctx->fname);
#line 324
  free((void *)ctx->tmpname);
  }
#line 325
  if (ctx->f) {
    {
#line 326
    fclose(ctx->f);
    }
  }
  {
#line 327
  free((void *)ctx);
  }
#line 328
  return ((zip_int64_t )0);
  case_0: 
#line 331
  if (ctx->fname) {
    {
#line 332
    ctx->f = fopen((char const   *)ctx->fname, "rb");
    }
#line 332
    if ((unsigned long )ctx->f == (unsigned long )((void *)0)) {
      {
#line 333
      __cil_tmp18 = __errno_location();
#line 333
      zip_error_set(& ctx->error, 11, *__cil_tmp18);
      }
#line 334
      return ((zip_int64_t )-1);
    }
  }
#line 338
  if (ctx->start > 0UL) {
    {
#line 339
    __cil_tmp19 = _zip_fseek_u(ctx->f, ctx->start, 0, & ctx->error);
    }
#line 339
    if (__cil_tmp19 < 0) {
#line 341
      return ((zip_int64_t )-1);
    }
  }
#line 344
  ctx->current = (zip_uint64_t )0;
#line 345
  return ((zip_int64_t )0);
  case_1: 
#line 348
  if (ctx->end > 0UL) {
#line 349
    n = ctx->end - ctx->current;
#line 350
    if (n > len) {
#line 351
      n = len;
    }
  } else {
#line 355
    n = len;
  }
#line 358
  if (n > 0xffffffffffffffffUL) {
#line 359
    n = 0xffffffffffffffffUL;
  }
  {
#line 361
  i = fread((void *)buf, 1UL, n, ctx->f);
  }
#line 361
  if (i == 0UL) {
    {
#line 362
    __cil_tmp21 = ferror(ctx->f);
    }
#line 362
    if (__cil_tmp21) {
      {
#line 363
      __cil_tmp22 = __errno_location();
#line 363
      zip_error_set(& ctx->error, 5, *__cil_tmp22);
      }
#line 364
      return ((zip_int64_t )-1);
    }
  }
#line 367
  ctx->current += i;
#line 369
  return ((zip_int64_t )i);
  case_15: 
  {
#line 372
  __cil_tmp23 = remove((char const   *)ctx->fname);
  }
#line 372
  if (__cil_tmp23 < 0) {
    {
#line 373
    __cil_tmp24 = __errno_location();
#line 373
    zip_error_set(& ctx->error, 22, *__cil_tmp24);
    }
#line 374
    return ((zip_int64_t )-1);
  }
#line 376
  return ((zip_int64_t )0);
  case_10: 
#line 379
  if (ctx->fout) {
    {
#line 380
    fclose(ctx->fout);
#line 381
    ctx->fout = (FILE *)((void *)0);
    }
  }
  {
#line 383
  remove((char const   *)ctx->tmpname);
#line 384
  free((void *)ctx->tmpname);
#line 385
  ctx->tmpname = (char *)((void *)0);
  }
#line 386
  return ((zip_int64_t )0);
  case_6: 
#line 391
  if (len < sizeof(zip_source_args_seek_t )) {
    {
#line 391
    zip_error_set(& ctx->error, 18, 0);
#line 391
    tmp = (zip_source_args_seek_t *)((void *)0);
    }
  } else {
#line 391
    tmp = (zip_source_args_seek_t *)data;
  }
#line 391
  args = tmp;
#line 393
  if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 394
    return ((zip_int64_t )-1);
  }
#line 396
  need_seek = 1;
#line 399
  if (args->whence == 0) {
#line 399
    goto case_0___0;
  }
#line 403
  if (args->whence == 2) {
#line 403
    goto case_2___0;
  }
#line 420
  if (args->whence == 1) {
#line 420
    goto case_1___0;
  }
#line 424
  goto switch_default;
  case_0___0: 
#line 400
  new_current = args->offset;
#line 401
  goto switch_break___0;
  case_2___0: 
#line 404
  if (ctx->end == 0UL) {
    {
#line 405
    __cil_tmp29 = _zip_fseek(ctx->f, args->offset, 2, & ctx->error);
    }
#line 405
    if (__cil_tmp29 < 0) {
#line 406
      return ((zip_int64_t )-1);
    }
    {
#line 408
    new_current = ftello(ctx->f);
    }
#line 408
    if (new_current < 0L) {
      {
#line 409
      __cil_tmp31 = __errno_location();
#line 409
      zip_error_set(& ctx->error, 4, *__cil_tmp31);
      }
#line 410
      return ((zip_int64_t )-1);
    }
#line 412
    new_current -= (zip_int64_t )ctx->start;
#line 413
    need_seek = 0;
  } else {
#line 416
    new_current = (zip_int64_t )ctx->end + args->offset;
  }
#line 418
  goto switch_break___0;
  case_1___0: 
#line 421
  new_current = (zip_int64_t )ctx->current + args->offset;
#line 422
  goto switch_break___0;
  switch_default: 
  {
#line 425
  zip_error_set(& ctx->error, 18, 0);
  }
#line 426
  return ((zip_int64_t )-1);
  switch_break___0: ;
#line 429
  if (new_current < 0L) {
    {
#line 431
    zip_error_set(& ctx->error, 18, 0);
    }
#line 432
    return ((zip_int64_t )-1);
  } else
#line 429
  if (ctx->end != 0UL) {
#line 429
    if ((zip_uint64_t )new_current > ctx->end) {
      {
#line 431
      zip_error_set(& ctx->error, 18, 0);
      }
#line 432
      return ((zip_int64_t )-1);
    } else {
#line 429
      goto _L;
    }
  } else
  _L: 
#line 429
  if ((zip_uint64_t )new_current + ctx->start < ctx->start) {
    {
#line 431
    zip_error_set(& ctx->error, 18, 0);
    }
#line 432
    return ((zip_int64_t )-1);
  }
#line 435
  ctx->current = (zip_uint64_t )new_current;
#line 437
  if (need_seek) {
    {
#line 438
    __cil_tmp32 = _zip_fseek_u(ctx->f, ctx->current + ctx->start, 0, & ctx->error);
    }
#line 438
    if (__cil_tmp32 < 0) {
#line 439
      return ((zip_int64_t )-1);
    }
  }
#line 442
  return ((zip_int64_t )0);
  case_12: 
#line 448
  if (len < sizeof(zip_source_args_seek_t )) {
    {
#line 448
    zip_error_set(& ctx->error, 18, 0);
#line 448
    tmp___0 = (zip_source_args_seek_t *)((void *)0);
    }
  } else {
#line 448
    tmp___0 = (zip_source_args_seek_t *)data;
  }
#line 448
  args___0 = tmp___0;
#line 449
  if ((unsigned long )args___0 == (unsigned long )((void *)0)) {
#line 450
    return ((zip_int64_t )-1);
  }
  {
#line 453
  __cil_tmp35 = _zip_fseek(ctx->fout, args___0->offset, args___0->whence, & ctx->error);
  }
#line 453
  if (__cil_tmp35 < 0) {
#line 454
    return ((zip_int64_t )-1);
  }
#line 456
  return ((zip_int64_t )0);
  case_3: 
#line 460
  if (len < sizeof(ctx->st)) {
#line 461
    return ((zip_int64_t )-1);
  }
  {
#line 463
  __cil_tmp36 = zip_error_code_zip(& ctx->stat_error);
  }
#line 463
  if (__cil_tmp36 != 0) {
    {
#line 464
    __cil_tmp37 = zip_error_code_zip(& ctx->stat_error);
#line 464
    __cil_tmp38 = zip_error_code_system(& ctx->stat_error);
#line 464
    zip_error_set(& ctx->error, __cil_tmp37, __cil_tmp38);
    }
#line 465
    return ((zip_int64_t )-1);
  }
  {
#line 468
  memcpy(data, (void const   *)(& ctx->st), sizeof(ctx->st));
  }
#line 469
  return ((zip_int64_t )sizeof(ctx->st));
  case_14: 
#line 473
  return (ctx->supports);
  case_7: 
#line 476
  return ((zip_int64_t )ctx->current);
  case_13: 
  {
#line 480
  __cil_tmp40 = ftello(ctx->fout);
#line 480
  ret = __cil_tmp40;
  }
#line 482
  if (ret < 0L) {
    {
#line 483
    __cil_tmp41 = __errno_location();
#line 483
    zip_error_set(& ctx->error, 30, *__cil_tmp41);
    }
#line 484
    return ((zip_int64_t )-1);
  }
#line 486
  return (ret);
  case_11: 
  {
#line 493
  clearerr(ctx->fout);
#line 494
  ret___0 = fwrite((void const   *)data, 1UL, len, ctx->fout);
#line 495
  __cil_tmp44 = ferror(ctx->fout);
  }
#line 495
  if (ret___0 != len) {
    {
#line 496
    __cil_tmp45 = __errno_location();
#line 496
    zip_error_set(& ctx->error, 6, *__cil_tmp45);
    }
#line 497
    return ((zip_int64_t )-1);
  } else
#line 495
  if (__cil_tmp44) {
    {
#line 496
    __cil_tmp45 = __errno_location();
#line 496
    zip_error_set(& ctx->error, 6, *__cil_tmp45);
    }
#line 497
    return ((zip_int64_t )-1);
  }
#line 500
  return ((zip_int64_t )ret___0);
  switch_default___0: 
  {
#line 504
  zip_error_set(& ctx->error, 28, 0);
  }
#line 505
  return ((zip_int64_t )-1);

#line 509
  return (0L);
}
}
#line 511 "/root/patchweave_new/24/lib/zip_source_filep.c"
static int _zip_fseek_u(FILE *f , zip_uint64_t offset , int whence , zip_error_t *error ) 
{ 
  int __cil_tmp5 ;

  {
#line 513
  if (offset > 0xffffffffffffffffUL) {
    {
#line 514
    zip_error_set(error, 4, 75);
    }
#line 515
    return (-1);
  }
  {
#line 517
  __cil_tmp5 = _zip_fseek(f, (zip_int64_t )offset, whence, error);
  }
#line 517
  return (__cil_tmp5);
}
}
#line 522 "/root/patchweave_new/24/lib/zip_source_filep.c"
static int _zip_fseek(FILE *f , zip_int64_t offset , int whence , zip_error_t *error ) 
{ 
  int __cil_tmp5 ;
  int *__cil_tmp6 ;

  {
#line 524
  if (offset > -1L) {
    {
#line 525
    zip_error_set(error, 4, 75);
    }
#line 526
    return (-1);
  } else
#line 524
  if (offset < 0L) {
    {
#line 525
    zip_error_set(error, 4, 75);
    }
#line 526
    return (-1);
  }
  {
#line 528
  __cil_tmp5 = fseeko(f, offset, whence);
  }
#line 528
  if (__cil_tmp5 < 0) {
    {
#line 529
    __cil_tmp6 = __errno_location();
#line 529
    zip_error_set(error, 4, *__cil_tmp6);
    }
#line 530
    return (-1);
  }
#line 532
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_error.c"
zip_error_t *zip_source_error(zip_source_t *src ) 
{ 


  {
#line 41
  return (& src->error);
}
}
#line 45 "/root/patchweave_new/24/lib/zip_source_error.c"
int _zip_source_had_error(zip_source_t *src ) 
{ 
  zip_error_t *__cil_tmp2 ;

  {
#line 47
  return (__cil_tmp2->zip_err != 0);
}
}
#line 51 "/root/patchweave_new/24/lib/zip_source_crc.c"
static zip_int64_t crc_read(zip_source_t *src , void *_ctx , void *data , zip_uint64_t len ,
                            zip_source_cmd_t cmd ) ;
#line 55 "/root/patchweave_new/24/lib/zip_source_crc.c"
zip_source_t *zip_source_crc(zip_t *za___0 , zip_source_t *src , int validate ) 
{ 
  struct crc_context *ctx ;
  void *__cil_tmp5 ;
  uLong __cil_tmp6 ;
  zip_source_t *__cil_tmp7 ;

  {
#line 59
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 60
    zip_error_set(& za___0->error, 18, 0);
    }
#line 61
    return ((zip_source_t *)((void *)0));
  }
  {
#line 64
  __cil_tmp5 = malloc(sizeof(*ctx));
#line 64
  ctx = (struct crc_context *)__cil_tmp5;
  }
#line 64
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 65
    zip_error_set(& za___0->error, 14, 0);
    }
#line 66
    return ((zip_source_t *)((void *)0));
  }
  {
#line 69
  zip_error_init(& ctx->error);
#line 70
  ctx->validate = validate;
#line 71
  ctx->crc_complete = 0;
#line 72
  ctx->crc_position = (zip_uint64_t )0;
#line 73
  __cil_tmp6 = crc32((uLong )0, (Bytef *)((void *)0), (uInt )0);
#line 73
  ctx->crc = (zip_uint32_t )__cil_tmp6;
#line 74
  ctx->size = (zip_uint64_t )0;
#line 76
  __cil_tmp7 = zip_source_layered(za___0, src, & crc_read, (void *)ctx);
  }
#line 76
  return (__cil_tmp7);
}
}
#line 81 "/root/patchweave_new/24/lib/zip_source_crc.c"
static zip_int64_t crc_read(zip_source_t *src , void *_ctx , void *data , zip_uint64_t len ,
                            zip_source_cmd_t cmd ) 
{ 
  struct crc_context *ctx ;
  zip_int64_t n ;
  struct zip_stat st ;
  int __cil_tmp10 ;
  zip_uint64_t i ;
  zip_uint64_t nn ;
  unsigned long tmp ;
  uLong __cil_tmp14 ;
  zip_stat_t *st___0 ;
  zip_int64_t __cil_tmp16 ;
  zip_int64_t mask ;
  zip_int64_t __cil_tmp18 ;
  zip_int64_t __cil_tmp19 ;
  zip_int64_t new_position ;
  zip_source_args_seek_t *args ;
  zip_source_args_seek_t *tmp___0 ;
  int __cil_tmp23 ;

  {
#line 86
  ctx = (struct crc_context *)_ctx;
#line 89
  if ((unsigned int )cmd == 0U) {
#line 89
    goto case_0;
  }
#line 93
  if ((unsigned int )cmd == 1U) {
#line 93
    goto case_1;
  }
#line 136
  if ((unsigned int )cmd == 2U) {
#line 136
    goto case_2;
  }
#line 139
  if ((unsigned int )cmd == 3U) {
#line 139
    goto case_3;
  }
#line 158
  if ((unsigned int )cmd == 4U) {
#line 158
    goto case_4;
  }
#line 161
  if ((unsigned int )cmd == 5U) {
#line 161
    goto case_5;
  }
#line 165
  if ((unsigned int )cmd == 14U) {
#line 165
    goto case_14;
  }
#line 177
  if ((unsigned int )cmd == 6U) {
#line 177
    goto case_6;
  }
#line 195
  if ((unsigned int )cmd == 7U) {
#line 195
    goto case_7;
  }
#line 198
  goto switch_default;
  case_0: 
#line 90
  ctx->position = (zip_uint64_t )0;
#line 91
  return ((zip_int64_t )0);
  case_1: 
  {
#line 94
  n = zip_source_read(src, data, len);
  }
#line 94
  if (n < 0L) {
    {
#line 95
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 96
    return ((zip_int64_t )-1);
  }
#line 99
  if (n == 0L) {
#line 100
    if (ctx->crc_position == ctx->position) {
#line 101
      ctx->crc_complete = 1;
#line 102
      ctx->size = ctx->position;
#line 104
      if (ctx->validate) {
        {
#line 107
        __cil_tmp10 = zip_source_stat(src, & st);
        }
#line 107
        if (__cil_tmp10 < 0) {
          {
#line 108
          _zip_error_set_from_source(& ctx->error, src);
          }
#line 109
          return ((zip_int64_t )-1);
        }
#line 112
        if (st.valid & 32UL) {
#line 112
          if (st.crc != ctx->crc) {
            {
#line 113
            zip_error_set(& ctx->error, 7, 0);
            }
#line 114
            return ((zip_int64_t )-1);
          }
        }
#line 116
        if (st.valid & 4UL) {
#line 116
          if (st.size != ctx->size) {
            {
#line 117
            zip_error_set(& ctx->error, 21, 0);
            }
#line 118
            return ((zip_int64_t )-1);
          }
        }
      }
    }
  } else
#line 123
  if (! ctx->crc_complete) {
#line 123
    if (ctx->position <= ctx->crc_position) {
#line 126
      i = ctx->crc_position - ctx->position;
      {
#line 126
      while (1) {
        while_continue: /* CIL Label */ ;

#line 126
        if (! (i < (zip_uint64_t )n)) {
#line 126
          goto while_break;
        }
#line 127
        if (4294967295UL < (zip_uint64_t )n - i) {
#line 127
          tmp = 4294967295UL;
        } else {
#line 127
          tmp = (zip_uint64_t )n - i;
        }
        {
#line 127
        nn = tmp;
#line 129
        __cil_tmp14 = crc32((uLong )ctx->crc, (Bytef *)data + i, (uInt )nn);
#line 129
        ctx->crc = (zip_uint32_t )__cil_tmp14;
#line 130
        ctx->crc_position += nn;
#line 126
        i += nn;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 133
  ctx->position += (zip_uint64_t )n;
#line 134
  return (n);
  case_2: 
#line 137
  return ((zip_int64_t )0);
  case_3: 
#line 143
  st___0 = (zip_stat_t *)data;
#line 145
  if (ctx->crc_complete) {
#line 148
    st___0->size = ctx->size;
#line 149
    st___0->crc = ctx->crc;
#line 150
    st___0->comp_size = ctx->size;
#line 151
    st___0->comp_method = (zip_uint16_t )0;
#line 152
    st___0->encryption_method = (zip_uint16_t )0;
#line 153
    st___0->valid |= 236UL;
  }
#line 155
  return ((zip_int64_t )0);
  case_4: 
  {
#line 159
  __cil_tmp16 = zip_error_to_data(& ctx->error, data, len);
  }
#line 159
  return (__cil_tmp16);
  case_5: 
  {
#line 162
  free((void *)ctx);
  }
#line 163
  return ((zip_int64_t )0);
  case_14: 
  {
#line 167
  __cil_tmp18 = zip_source_supports(src);
#line 167
  mask = __cil_tmp18;
  }
#line 169
  if (mask < 0L) {
    {
#line 170
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 171
    return ((zip_int64_t )-1);
  }
  {
#line 174
  __cil_tmp19 = zip_source_make_command_bitmap((zip_source_cmd_t )8, 9, 10, 12, 13,
                                               15, 16, -1);
  }
#line 174
  return (mask & ~ __cil_tmp19);
  case_6: 
#line 180
  if (len < sizeof(zip_source_args_seek_t )) {
    {
#line 180
    zip_error_set(& ctx->error, 18, 0);
#line 180
    tmp___0 = (zip_source_args_seek_t *)((void *)0);
    }
  } else {
#line 180
    tmp___0 = (zip_source_args_seek_t *)data;
  }
#line 180
  args = tmp___0;
#line 182
  if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 183
    return ((zip_int64_t )-1);
  }
  {
#line 185
  new_position = zip_source_tell(src);
#line 185
  __cil_tmp23 = zip_source_seek(src, args->offset, args->whence);
  }
#line 185
  if (__cil_tmp23 < 0) {
    {
#line 186
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 187
    return ((zip_int64_t )-1);
  } else
#line 185
  if (new_position < 0L) {
    {
#line 186
    _zip_error_set_from_source(& ctx->error, src);
    }
#line 187
    return ((zip_int64_t )-1);
  }
#line 190
  ctx->position = (zip_uint64_t )new_position;
#line 192
  return ((zip_int64_t )0);
  case_7: 
#line 196
  return ((zip_int64_t )ctx->position);
  switch_default: 
  {
#line 199
  zip_error_set(& ctx->error, 28, 0);
  }
#line 200
  return ((zip_int64_t )-1);

#line 204
  return (0L);
}
}
#line 65 "/root/patchweave_new/24/lib/zip_source_compress.c"
static struct implementation implementations[1]  = {      {(zip_uint16_t )8, & zip_algorithm_deflate_compress, & zip_algorithm_deflate_decompress}};
#line 72 "/root/patchweave_new/24/lib/zip_source_compress.c"
static size_t implementations_size  =    sizeof(implementations) / sizeof(implementations[0]);
#line 74
static zip_source_t *compression_source_new(zip_t *za___0 , zip_source_t *src , zip_int32_t method ,
                                            int compress___0 , int compression_flags___0 ) ;
#line 75
static zip_int64_t compress_callback(zip_source_t *src , void *ud , void *data , zip_uint64_t len ,
                                     zip_source_cmd_t cmd ) ;
#line 76
static void context_free(struct context *ctx ) ;
#line 77
static struct context *context_new(zip_int32_t method , int compress___0 , int compression_flags___0 ,
                                   zip_compression_algorithm_t *algorithm ) ;
#line 78
static zip_int64_t compress_read(zip_source_t *src , struct context *ctx , void *data ,
                                 zip_uint64_t len ) ;
#line 81 "/root/patchweave_new/24/lib/zip_source_compress.c"
static zip_compression_algorithm_t *get_algorithm(zip_int32_t method , int compress___0 ) 
{ 
  size_t i ;
  zip_uint16_t real_method ;
  int tmp ;

  {
#line 83
  if (method == -1) {
#line 83
    tmp = 8;
  } else
#line 83
  if (method == -2) {
#line 83
    tmp = 8;
  } else {
#line 83
    tmp = method;
  }
#line 83
  real_method = (zip_uint16_t )tmp;
#line 85
  i = (size_t )0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;

#line 85
    if (! (i < implementations_size)) {
#line 85
      goto while_break;
    }
#line 86
    if ((int )implementations[i].method == (int )real_method) {
#line 87
      if (compress___0) {
#line 88
        return (implementations[i].compress);
      } else {
#line 91
        return (implementations[i].decompress);
      }
    }
#line 85
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 96
  return ((zip_compression_algorithm_t *)((void *)0));
}
}
#line 100 "/root/patchweave_new/24/lib/zip_source_compress.c"
int zip_compression_method_supported(zip_int32_t method , int compress___0 ) 
{ 
  zip_compression_algorithm_t *__cil_tmp3 ;

  {
#line 101
  if (method == 0) {
#line 102
    return (1);
  }
  {
#line 104
  __cil_tmp3 = get_algorithm(method, compress___0);
  }
#line 104
  return ((unsigned long )__cil_tmp3 != (unsigned long )((void *)0));
}
}
#line 108 "/root/patchweave_new/24/lib/zip_source_compress.c"
zip_source_t *zip_source_compress(zip_t *za___0 , zip_source_t *src , zip_int32_t method ,
                                  int compression_flags___0 ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
  {
#line 109
  __cil_tmp5 = compression_source_new(za___0, src, method, 1, compression_flags___0);
  }
#line 109
  return (__cil_tmp5);
}
}
#line 113 "/root/patchweave_new/24/lib/zip_source_compress.c"
zip_source_t *zip_source_decompress(zip_t *za___0 , zip_source_t *src , zip_int32_t method ) 
{ 
  zip_source_t *__cil_tmp4 ;

  {
  {
#line 114
  __cil_tmp4 = compression_source_new(za___0, src, method, 0, 0);
  }
#line 114
  return (__cil_tmp4);
}
}
#line 119 "/root/patchweave_new/24/lib/zip_source_compress.c"
static zip_source_t *compression_source_new(zip_t *za___0 , zip_source_t *src , zip_int32_t method ,
                                            int compress___0 , int compression_flags___0 ) 
{ 
  struct context *ctx ;
  zip_source_t *s2 ;
  zip_compression_algorithm_t *algorithm ;

  {
#line 123
  algorithm = (zip_compression_algorithm_t *)((void *)0);
#line 125
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 126
    zip_error_set(& za___0->error, 18, 0);
    }
#line 127
    return ((zip_source_t *)((void *)0));
  }
  {
#line 130
  algorithm = get_algorithm(method, compress___0);
  }
#line 130
  if ((unsigned long )algorithm == (unsigned long )((void *)0)) {
    {
#line 131
    zip_error_set(& za___0->error, 16, 0);
    }
#line 132
    return ((zip_source_t *)((void *)0));
  }
  {
#line 135
  ctx = context_new(method, compress___0, compression_flags___0, algorithm);
  }
#line 135
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 136
    zip_error_set(& za___0->error, 14, 0);
    }
#line 137
    return ((zip_source_t *)((void *)0));
  }
  {
#line 140
  s2 = zip_source_layered(za___0, src, & compress_callback, (void *)ctx);
  }
#line 140
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
    {
#line 141
    context_free(ctx);
    }
#line 142
    return ((zip_source_t *)((void *)0));
  }
#line 145
  return (s2);
}
}
#line 150 "/root/patchweave_new/24/lib/zip_source_compress.c"
static struct context *context_new(zip_int32_t method , int compress___0 , int compression_flags___0 ,
                                   zip_compression_algorithm_t *algorithm ) 
{ 
  struct context *ctx ;
  void *__cil_tmp6 ;
  zip_int32_t tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  int tmp___1 ;

  {
  {
#line 153
  __cil_tmp6 = malloc(sizeof(*ctx));
#line 153
  ctx = (struct context *)__cil_tmp6;
  }
#line 153
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 154
    return ((struct context *)((void *)0));
  }
  {
#line 156
  zip_error_init(& ctx->error);
  }
#line 157
  if (compress___0) {
#line 157
    if (method == -1) {
#line 157
      tmp___1 = 1;
    } else
#line 157
    if (method == -2) {
#line 157
      tmp___1 = 1;
    } else {
#line 157
      tmp___1 = 0;
    }
#line 157
    tmp = tmp___1;
  } else {
#line 157
    tmp = 0;
  }
#line 157
  ctx->can_store = tmp;
#line 158
  ctx->algorithm = algorithm;
#line 159
  ctx->method = method;
#line 160
  ctx->compress = compress___0;
#line 162
  if (method == -1) {
#line 162
    tmp___0 = 8;
  } else
#line 162
  if (method == -2) {
#line 162
    tmp___0 = 8;
  } else {
#line 162
    tmp___0 = method;
  }
  {
#line 162
  __cil_tmp9 = (*((ctx->algorithm)->allocate))((zip_uint16_t )tmp___0, compression_flags___0,
                                               & ctx->error);
#line 162
  ctx->ud = __cil_tmp9;
  }
#line 162
  if ((unsigned long )ctx->ud == (unsigned long )((void *)0)) {
    {
#line 163
    zip_error_fini(& ctx->error);
#line 164
    free((void *)ctx);
    }
#line 165
    return ((struct context *)((void *)0));
  }
#line 168
  return (ctx);
}
}
#line 173 "/root/patchweave_new/24/lib/zip_source_compress.c"
static void context_free(struct context *ctx ) 
{ 


  {
#line 174
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 175
    return;
  }
  {
#line 178
  (*((ctx->algorithm)->deallocate))(ctx->ud);
#line 179
  zip_error_fini(& ctx->error);
#line 181
  free((void *)ctx);
  }
#line 183
  return;
}
}
#line 186 "/root/patchweave_new/24/lib/zip_source_compress.c"
static zip_int64_t compress_read(zip_source_t *src , struct context *ctx , void *data ,
                                 zip_uint64_t len ) 
{ 
  zip_compression_status_t ret ;
  int end___0 ;
  zip_int64_t n ;
  zip_uint64_t out_offset ;
  zip_uint64_t out_len ;
  int __cil_tmp10 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;

  {
  {
#line 194
  __cil_tmp10 = zip_error_code_zip(& ctx->error);
  }
#line 194
  if (__cil_tmp10 != 0) {
#line 195
    return ((zip_int64_t )-1);
  }
#line 198
  if (len == 0UL) {
#line 199
    return ((zip_int64_t )0);
  } else
#line 198
  if (ctx->end_of_stream) {
#line 199
    return ((zip_int64_t )0);
  }
#line 202
  out_offset = (zip_uint64_t )0;
#line 204
  end___0 = 0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;

#line 205
    if (! end___0) {
#line 205
      if (! (out_offset < len)) {
#line 205
        goto while_break;
      }
    } else {
#line 205
      goto while_break;
    }
    {
#line 206
    out_len = len - out_offset;
#line 207
    ret = (*((ctx->algorithm)->process))(ctx->ud, (zip_uint8_t *)data + out_offset,
                                         & out_len);
    }
#line 209
    if ((unsigned int )ret != 2U) {
#line 210
      out_offset += out_len;
    }
#line 214
    if ((unsigned int )ret == 1U) {
#line 214
      goto case_1;
    }
#line 236
    if ((unsigned int )ret == 0U) {
#line 236
      goto case_0;
    }
#line 239
    if ((unsigned int )ret == 3U) {
#line 239
      goto case_3;
    }
#line 271
    if ((unsigned int )ret == 2U) {
#line 271
      goto case_2;
    }
#line 213
    goto switch_break;
    case_1: 
#line 215
    ctx->end_of_stream = 1;
#line 221
    if (ctx->first_read < 0L) {
      {
#line 223
      zip_error_set(& ctx->error, 20, 0);
#line 224
      end___0 = 1;
      }
#line 225
      goto switch_break;
    }
#line 227
    if (ctx->can_store) {
#line 227
      if ((zip_uint64_t )ctx->first_read <= out_offset) {
        {
#line 228
        ctx->is_stored = 1;
#line 229
        ctx->size = (zip_uint64_t )ctx->first_read;
#line 230
        memcpy(data, (void const   *)(ctx->buffer), ctx->size);
        }
#line 231
        return ((zip_int64_t )ctx->size);
      }
    }
#line 233
    end___0 = 1;
#line 234
    goto switch_break;
    case_0: 
#line 237
    goto switch_break;
    case_3: 
#line 240
    if (ctx->end_of_input) {
#line 242
      end___0 = 1;
#line 243
      goto switch_break;
    }
    {
#line 246
    n = zip_source_read(src, (void *)(ctx->buffer), sizeof(ctx->buffer));
    }
#line 246
    if (n < 0L) {
      {
#line 247
      _zip_error_set_from_source(& ctx->error, src);
#line 248
      end___0 = 1;
      }
#line 249
      goto switch_break;
    } else
#line 251
    if (n == 0L) {
      {
#line 252
      ctx->end_of_input = 1;
#line 253
      (*((ctx->algorithm)->end_of_input))(ctx->ud);
      }
#line 254
      if (ctx->first_read < 0L) {
#line 255
        ctx->first_read = (zip_int64_t )0;
      }
    } else {
#line 259
      if (ctx->first_read >= 0L) {
#line 261
        ctx->can_store = 0;
      } else {
#line 264
        ctx->first_read = n;
      }
      {
#line 267
      (*((ctx->algorithm)->input))(ctx->ud, ctx->buffer, (zip_uint64_t )n);
      }
    }
#line 269
    goto switch_break;
    case_2: 
    {
#line 273
    __cil_tmp13 = zip_error_code_zip(& ctx->error);
    }
#line 273
    if (__cil_tmp13 == 0) {
      {
#line 274
      zip_error_set(& ctx->error, 20, 0);
      }
    }
#line 276
    end___0 = 1;
#line 277
    goto switch_break;
    switch_break: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 281
  if (out_offset > 0UL) {
#line 282
    ctx->can_store = 0;
#line 283
    ctx->size += out_offset;
#line 284
    return ((zip_int64_t )out_offset);
  }
  {
#line 287
  __cil_tmp14 = zip_error_code_zip(& ctx->error);
  }
#line 287
  if (__cil_tmp14 == 0) {
#line 287
    tmp = 0;
  } else {
#line 287
    tmp = -1;
  }
#line 287
  return ((zip_int64_t )tmp);
}
}
#line 292 "/root/patchweave_new/24/lib/zip_source_compress.c"
static zip_int64_t compress_callback(zip_source_t *src , void *ud , void *data , zip_uint64_t len ,
                                     zip_source_cmd_t cmd ) 
{ 
  struct context *ctx ;
  int __cil_tmp7 ;
  zip_int64_t __cil_tmp8 ;
  int __cil_tmp9 ;
  zip_stat_t *st ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int tmp___1 ;
  zip_int64_t __cil_tmp15 ;
  zip_int64_t __cil_tmp16 ;

  {
#line 296
  ctx = (struct context *)ud;
#line 299
  if ((unsigned int )cmd == 0U) {
#line 299
    goto case_0;
  }
#line 312
  if ((unsigned int )cmd == 1U) {
#line 312
    goto case_1;
  }
#line 315
  if ((unsigned int )cmd == 2U) {
#line 315
    goto case_2;
  }
#line 321
  if ((unsigned int )cmd == 3U) {
#line 321
    goto case_3;
  }
#line 351
  if ((unsigned int )cmd == 16U) {
#line 351
    goto case_16;
  }
#line 354
  if ((unsigned int )cmd == 4U) {
#line 354
    goto case_4;
  }
#line 357
  if ((unsigned int )cmd == 5U) {
#line 357
    goto case_5;
  }
#line 361
  if ((unsigned int )cmd == 14U) {
#line 361
    goto case_14;
  }
#line 364
  goto switch_default;
  case_0: 
  {
#line 300
  ctx->size = (zip_uint64_t )0;
#line 301
  ctx->end_of_input = 0;
#line 302
  ctx->end_of_stream = 0;
#line 303
  ctx->is_stored = 0;
#line 304
  ctx->first_read = (zip_int64_t )-1;
#line 306
  __cil_tmp7 = (*((ctx->algorithm)->start))(ctx->ud);
  }
#line 306
  if (! __cil_tmp7) {
#line 307
    return ((zip_int64_t )-1);
  }
#line 310
  return ((zip_int64_t )0);
  case_1: 
  {
#line 313
  __cil_tmp8 = compress_read(src, ctx, data, len);
  }
#line 313
  return (__cil_tmp8);
  case_2: 
  {
#line 316
  __cil_tmp9 = (*((ctx->algorithm)->end))(ctx->ud);
  }
#line 316
  if (! __cil_tmp9) {
#line 317
    return ((zip_int64_t )-1);
  }
#line 319
  return ((zip_int64_t )0);
  case_3: 
#line 325
  st = (zip_stat_t *)data;
#line 327
  if (ctx->compress) {
#line 328
    if (ctx->is_stored) {
#line 328
      tmp___0 = 0;
    } else {
#line 328
      if (ctx->method == -1) {
#line 328
        tmp = 8;
      } else
#line 328
      if (ctx->method == -2) {
#line 328
        tmp = 8;
      } else {
#line 328
        tmp = ctx->method;
      }
#line 328
      tmp___0 = (int )((zip_uint16_t )tmp);
    }
#line 328
    st->comp_method = (zip_uint16_t )tmp___0;
#line 329
    if (ctx->end_of_stream) {
#line 330
      st->comp_size = ctx->size;
#line 331
      st->valid |= 8UL;
    } else {
#line 334
      st->valid &= 4294967287UL;
    }
  } else {
#line 338
    st->comp_method = (zip_uint16_t )0;
#line 339
    if (ctx->end_of_stream) {
#line 340
      st->size = ctx->size;
#line 341
      st->valid |= 4UL;
    } else {
#line 344
      st->valid &= 4294967291UL;
    }
  }
#line 347
  st->valid |= 64UL;
#line 349
  return ((zip_int64_t )0);
  case_16: 
#line 352
  if (ctx->is_stored) {
#line 352
    tmp___1 = 0;
  } else {
    {
#line 352
    __cil_tmp13 = (*((ctx->algorithm)->compression_flags))(ctx->ud);
#line 352
    tmp___1 = __cil_tmp13;
    }
  }
#line 352
  return ((zip_int64_t )tmp___1);
  case_4: 
  {
#line 355
  __cil_tmp15 = zip_error_to_data(& ctx->error, data, len);
  }
#line 355
  return (__cil_tmp15);
  case_5: 
  {
#line 358
  context_free(ctx);
  }
#line 359
  return ((zip_int64_t )0);
  case_14: 
  {
#line 362
  __cil_tmp16 = zip_source_make_command_bitmap((zip_source_cmd_t )16, -1);
  }
#line 362
  return ((zip_int64_t )((((((1UL | (1UL << 1)) | (1UL << 2)) | (1UL << 3)) | (1UL << 4)) | (1UL << 5)) | (unsigned long )__cil_tmp16));
  switch_default: 
  {
#line 365
  zip_error_set(& ctx->error, 20, 0);
  }
#line 366
  return ((zip_int64_t )-1);

#line 370
  return (0L);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_commit_write.c"
int zip_source_commit_write(zip_source_t *src ) 
{ 
  int __cil_tmp2 ;
  zip_int64_t __cil_tmp3 ;

  {
#line 41
  if (! ((unsigned int )src->write_state == 1U)) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return (-1);
  }
#line 46
  if (src->open_count > 1U) {
    {
#line 47
    zip_error_set(& src->error, 29, 0);
    }
#line 48
    return (-1);
  } else
#line 50
  if (src->open_count > 0U) {
    {
#line 51
    __cil_tmp2 = zip_source_close(src);
    }
#line 51
    if (__cil_tmp2 < 0) {
#line 52
      return (-1);
    }
  }
  {
#line 56
  __cil_tmp3 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )9);
  }
#line 56
  if (__cil_tmp3 < 0L) {
#line 57
    src->write_state = (zip_source_write_state_t )2;
#line 58
    return (-1);
  }
#line 61
  src->write_state = (zip_source_write_state_t )0;
#line 63
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_close.c"
int zip_source_close(zip_source_t *src ) 
{ 
  unsigned int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 41
  if (! (src->open_count > 0U)) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return (-1);
  }
#line 46
  __cil_tmp2 = src->open_count;
#line 46
  (src->open_count) --;
#line 47
  if (src->open_count == 0U) {
    {
#line 48
    _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )2);
    }
#line 50
    if ((unsigned long )src->src != (unsigned long )((void *)0)) {
      {
#line 51
      __cil_tmp3 = zip_source_close(src->src);
      }
#line 51
      if (__cil_tmp3 < 0) {
        {
#line 52
        zip_error_set(& src->error, 20, 0);
        }
      }
    }
  }
#line 57
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_call.c"
zip_int64_t _zip_source_call(zip_source_t *src , void *data , zip_uint64_t length ,
                             zip_source_cmd_t command ) 
{ 
  zip_int64_t ret ;
  int e[2] ;
  zip_int64_t __cil_tmp9 ;

  {
#line 43
  if (((unsigned long )src->supports & (1UL << (unsigned int )command)) == 0UL) {
    {
#line 44
    zip_error_set(& src->error, 28, 0);
    }
#line 45
    return ((zip_int64_t )-1);
  }
#line 48
  if ((unsigned long )src->src == (unsigned long )((void *)0)) {
    {
#line 49
    ret = (*(src->cb.f))(src->ud, data, length, command);
    }
  } else {
    {
#line 52
    ret = (*(src->cb.l))(src->src, src->ud, data, length, command);
    }
  }
#line 55
  if (ret < 0L) {
#line 56
    if ((unsigned int )command != 4U) {
#line 56
      if ((unsigned int )command != 14U) {
        {
#line 59
        __cil_tmp9 = _zip_source_call(src, (void *)(e), sizeof(e), (zip_source_cmd_t )4);
        }
#line 59
        if (__cil_tmp9 < 0L) {
          {
#line 60
          zip_error_set(& src->error, 20, 0);
          }
        } else {
          {
#line 63
          zip_error_set(& src->error, e[0], e[1]);
          }
        }
      }
    }
  }
#line 68
  return (ret);
}
}
#line 63 "/root/patchweave_new/24/lib/zip_source_buffer.c"
static void buffer_free(buffer_t *buffer ) ;
#line 64
static buffer_t *buffer_new(zip_uint64_t fragment_size ) ;
#line 65
static buffer_t *buffer_new_read(void const   *data , zip_uint64_t length , int free_data ) ;
#line 66
static buffer_t *buffer_new_write(zip_uint64_t fragment_size ) ;
#line 67
static zip_int64_t buffer_read(buffer_t *buffer , zip_uint8_t *data , zip_uint64_t length ) ;
#line 68
static int buffer_seek(buffer_t *buffer , void *data , zip_uint64_t len , zip_error_t *error ) ;
#line 69
static zip_int64_t buffer_write(buffer_t *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                zip_error_t *error ) ;
#line 71
static zip_int64_t read_data(void *state , void *data , zip_uint64_t len , zip_source_cmd_t cmd ) ;
#line 75 "/root/patchweave_new/24/lib/zip_source_buffer.c"
zip_source_t *zip_source_buffer(zip_t *za___0 , void const   *data , zip_uint64_t len ,
                                int freep ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 77
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 78
    return ((zip_source_t *)((void *)0));
  }
  {
#line 80
  __cil_tmp5 = zip_source_buffer_create(data, len, freep, & za___0->error);
  }
#line 80
  return (__cil_tmp5);
}
}
#line 85 "/root/patchweave_new/24/lib/zip_source_buffer.c"
zip_source_t *zip_source_buffer_create(void const   *data , zip_uint64_t len , int freep ,
                                       zip_error_t *error ) 
{ 
  struct read_data *ctx ;
  zip_source_t *zs ;
  void *__cil_tmp7 ;

  {
#line 90
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 90
    if (len > 0UL) {
      {
#line 91
      zip_error_set(error, 18, 0);
      }
#line 92
      return ((zip_source_t *)((void *)0));
    }
  }
  {
#line 95
  __cil_tmp7 = malloc(sizeof(*ctx));
#line 95
  ctx = (struct read_data *)__cil_tmp7;
  }
#line 95
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 96
    zip_error_set(error, 14, 0);
    }
#line 97
    return ((zip_source_t *)((void *)0));
  }
  {
#line 100
  ctx->in = buffer_new_read(data, len, freep);
  }
#line 100
  if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
    {
#line 101
    zip_error_set(error, 14, 0);
#line 102
    free((void *)ctx);
    }
#line 103
    return ((zip_source_t *)((void *)0));
  }
  {
#line 106
  ctx->out = (buffer_t *)((void *)0);
#line 107
  ctx->mtime = time((time_t *)((void *)0));
#line 108
  zip_error_init(& ctx->error);
#line 110
  zs = zip_source_function_create(& read_data, (void *)ctx, error);
  }
#line 110
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 111
    buffer_free(ctx->in);
#line 112
    free((void *)ctx);
    }
#line 113
    return ((zip_source_t *)((void *)0));
  }
#line 116
  return (zs);
}
}
#line 121 "/root/patchweave_new/24/lib/zip_source_buffer.c"
static zip_int64_t read_data(void *state , void *data , zip_uint64_t len , zip_source_cmd_t cmd ) 
{ 
  struct read_data *ctx ;
  zip_int64_t __cil_tmp7 ;
  zip_int64_t __cil_tmp8 ;
  buffer_t *empty___0 ;
  buffer_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  zip_stat_t *st ;
  zip_int64_t __cil_tmp14 ;
  zip_int64_t __cil_tmp15 ;

  {
#line 123
  ctx = (struct read_data *)state;
#line 126
  if ((unsigned int )cmd == 8U) {
#line 126
    goto case_8;
  }
#line 133
  if ((unsigned int )cmd == 2U) {
#line 133
    goto case_2;
  }
#line 136
  if ((unsigned int )cmd == 9U) {
#line 136
    goto case_9;
  }
#line 142
  if ((unsigned int )cmd == 4U) {
#line 142
    goto case_4;
  }
#line 145
  if ((unsigned int )cmd == 5U) {
#line 145
    goto case_5;
  }
#line 151
  if ((unsigned int )cmd == 0U) {
#line 151
    goto case_0;
  }
#line 155
  if ((unsigned int )cmd == 1U) {
#line 155
    goto case_1;
  }
#line 162
  if ((unsigned int )cmd == 15U) {
#line 162
    goto case_15;
  }
#line 175
  if ((unsigned int )cmd == 10U) {
#line 175
    goto case_10;
  }
#line 180
  if ((unsigned int )cmd == 6U) {
#line 180
    goto case_6;
  }
#line 183
  if ((unsigned int )cmd == 12U) {
#line 183
    goto case_12;
  }
#line 186
  if ((unsigned int )cmd == 3U) {
#line 186
    goto case_3;
  }
#line 208
  if ((unsigned int )cmd == 14U) {
#line 208
    goto case_14;
  }
#line 211
  if ((unsigned int )cmd == 7U) {
#line 211
    goto case_7;
  }
#line 219
  if ((unsigned int )cmd == 13U) {
#line 219
    goto case_13;
  }
#line 226
  if ((unsigned int )cmd == 11U) {
#line 226
    goto case_11;
  }
#line 233
  goto switch_default;
  case_8: 
  {
#line 127
  ctx->out = buffer_new_write((zip_uint64_t )65536);
  }
#line 127
  if ((unsigned long )ctx->out == (unsigned long )((void *)0)) {
    {
#line 128
    zip_error_set(& ctx->error, 14, 0);
    }
#line 129
    return ((zip_int64_t )-1);
  }
#line 131
  return ((zip_int64_t )0);
  case_2: 
#line 134
  return ((zip_int64_t )0);
  case_9: 
  {
#line 137
  buffer_free(ctx->in);
#line 138
  ctx->in = ctx->out;
#line 139
  ctx->out = (buffer_t *)((void *)0);
  }
#line 140
  return ((zip_int64_t )0);
  case_4: 
  {
#line 143
  __cil_tmp7 = zip_error_to_data(& ctx->error, data, len);
  }
#line 143
  return (__cil_tmp7);
  case_5: 
  {
#line 146
  buffer_free(ctx->in);
#line 147
  buffer_free(ctx->out);
#line 148
  free((void *)ctx);
  }
#line 149
  return ((zip_int64_t )0);
  case_0: 
#line 152
  (ctx->in)->offset = (zip_uint64_t )0;
#line 153
  return ((zip_int64_t )0);
  case_1: 
#line 156
  if (len > 0xffffffffffffffffUL) {
    {
#line 157
    zip_error_set(& ctx->error, 18, 0);
    }
#line 158
    return ((zip_int64_t )-1);
  }
  {
#line 160
  __cil_tmp8 = buffer_read(ctx->in, (zip_uint8_t *)data, len);
  }
#line 160
  return (__cil_tmp8);
  case_15: 
  {
#line 164
  __cil_tmp10 = buffer_new_read((void const   *)((void *)0), (zip_uint64_t )0, 0);
#line 164
  empty___0 = __cil_tmp10;
  }
#line 165
  if ((unsigned long )empty___0 == (unsigned long )((buffer_t *)0)) {
    {
#line 166
    zip_error_set(& ctx->error, 14, 0);
    }
#line 167
    return ((zip_int64_t )-1);
  }
  {
#line 170
  buffer_free(ctx->in);
#line 171
  ctx->in = empty___0;
  }
#line 172
  return ((zip_int64_t )0);
  case_10: 
  {
#line 176
  buffer_free(ctx->out);
#line 177
  ctx->out = (buffer_t *)((void *)0);
  }
#line 178
  return ((zip_int64_t )0);
  case_6: 
  {
#line 181
  __cil_tmp11 = buffer_seek(ctx->in, data, len, & ctx->error);
  }
#line 181
  return ((zip_int64_t )__cil_tmp11);
  case_12: 
  {
#line 184
  __cil_tmp12 = buffer_seek(ctx->out, data, len, & ctx->error);
  }
#line 184
  return ((zip_int64_t )__cil_tmp12);
  case_3: 
#line 190
  if (len < sizeof(*st)) {
    {
#line 191
    zip_error_set(& ctx->error, 18, 0);
    }
#line 192
    return ((zip_int64_t )-1);
  }
  {
#line 195
  st = (zip_stat_t *)data;
#line 197
  zip_stat_init(st);
#line 198
  st->mtime = ctx->mtime;
#line 199
  st->size = (ctx->in)->size;
#line 200
  st->comp_size = st->size;
#line 201
  st->comp_method = (zip_uint16_t )0;
#line 202
  st->encryption_method = (zip_uint16_t )0;
#line 203
  st->valid = (zip_uint64_t )220U;
  }
#line 205
  return ((zip_int64_t )sizeof(*st));
  case_14: 
  {
#line 209
  __cil_tmp14 = zip_source_make_command_bitmap((zip_source_cmd_t )0, 1, 2, 3, 4, 5,
                                               6, 7, 8, 9, 15, 10, 12, 13, 11, -1);
  }
#line 209
  return (__cil_tmp14);
  case_7: 
#line 212
  if ((ctx->in)->offset > 0xffffffffffffffffUL) {
    {
#line 213
    zip_error_set(& ctx->error, 30, 75);
    }
#line 214
    return ((zip_int64_t )-1);
  }
#line 216
  return ((zip_int64_t )(ctx->in)->offset);
  case_13: 
#line 220
  if ((ctx->out)->offset > 0xffffffffffffffffUL) {
    {
#line 221
    zip_error_set(& ctx->error, 30, 75);
    }
#line 222
    return ((zip_int64_t )-1);
  }
#line 224
  return ((zip_int64_t )(ctx->out)->offset);
  case_11: 
#line 227
  if (len > 0xffffffffffffffffUL) {
    {
#line 228
    zip_error_set(& ctx->error, 18, 0);
    }
#line 229
    return ((zip_int64_t )-1);
  }
  {
#line 231
  __cil_tmp15 = buffer_write(ctx->out, (zip_uint8_t *)data, len, & ctx->error);
  }
#line 231
  return (__cil_tmp15);
  switch_default: 
  {
#line 234
  zip_error_set(& ctx->error, 28, 0);
  }
#line 235
  return ((zip_int64_t )-1);

#line 239
  return (0L);
}
}
#line 241 "/root/patchweave_new/24/lib/zip_source_buffer.c"
static void buffer_free(buffer_t *buffer ) 
{ 
  zip_uint64_t i ;

  {
#line 243
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 244
    return;
  }
#line 247
  if (buffer->free_data) {
#line 250
    i = (zip_uint64_t )0;
    {
#line 250
    while (1) {
      while_continue: /* CIL Label */ ;

#line 250
      if (! (i < buffer->nfragments)) {
#line 250
        goto while_break;
      }
      {
#line 251
      free((void *)*(buffer->fragments + i));
#line 250
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 254
  free((void *)buffer->fragments);
#line 255
  free((void *)buffer);
  }
#line 257
  return;
}
}
#line 260 "/root/patchweave_new/24/lib/zip_source_buffer.c"
static buffer_t *buffer_new(zip_uint64_t fragment_size ) 
{ 
  buffer_t *buffer ;
  void *tmp ;

  {
  {
#line 264
  tmp = malloc(sizeof(*buffer));
#line 264
  buffer = (buffer_t *)tmp;
  }
#line 264
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 265
    return ((buffer_t *)((void *)0));
  }
#line 268
  buffer->fragment_size = fragment_size;
#line 269
  buffer->offset = (zip_uint64_t )0;
#line 270
  buffer->free_data = 0;
#line 271
  buffer->nfragments = (zip_uint64_t )0;
#line 272
  buffer->fragments_capacity = (zip_uint64_t )0;
#line 273
  buffer->fragments = (zip_uint8_t **)((void *)0);
#line 274
  buffer->size = (zip_uint64_t )0;
#line 276
  return (buffer);
}
}
#line 281 "/root/patchweave_new/24/lib/zip_source_buffer.c"
static buffer_t *buffer_new_read(void const   *data , zip_uint64_t length , int free_data ) 
{ 
  buffer_t *buffer ;
  void *tmp ;

  {
  {
#line 285
  buffer = buffer_new(length);
  }
#line 285
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 286
    return ((buffer_t *)((void *)0));
  }
#line 289
  buffer->size = length;
#line 291
  if (length > 0UL) {
    {
#line 292
    tmp = malloc(sizeof(*(buffer->fragments)));
#line 292
    buffer->fragments = (zip_uint8_t **)tmp;
    }
#line 292
    if ((unsigned long )buffer->fragments == (unsigned long )((void *)0)) {
      {
#line 293
      buffer_free(buffer);
      }
#line 294
      return ((buffer_t *)((void *)0));
    }
#line 296
    buffer->fragments_capacity = (zip_uint64_t )1;
#line 298
    buffer->nfragments = (zip_uint64_t )1;
#line 299
    *(buffer->fragments + 0) = (zip_uint8_t *)data;
#line 300
    buffer->free_data = free_data;
  }
#line 303
  return (buffer);
}
}
#line 308 "/root/patchweave_new/24/lib/zip_source_buffer.c"
static buffer_t *buffer_new_write(zip_uint64_t fragment_size ) 
{ 
  buffer_t *buffer ;
  void *tmp ;

  {
  {
#line 312
  buffer = buffer_new(fragment_size);
  }
#line 312
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 313
    return ((buffer_t *)((void *)0));
  }
  {
#line 316
  tmp = malloc(sizeof(*(buffer->fragments)));
#line 316
  buffer->fragments = (zip_uint8_t **)tmp;
  }
#line 316
  if ((unsigned long )buffer->fragments == (unsigned long )((void *)0)) {
    {
#line 317
    buffer_free(buffer);
    }
#line 318
    return ((buffer_t *)((void *)0));
  }
#line 320
  buffer->fragments_capacity = (zip_uint64_t )1;
#line 321
  buffer->nfragments = (zip_uint64_t )0;
#line 322
  buffer->free_data = 1;
#line 324
  return (buffer);
}
}
#line 329 "/root/patchweave_new/24/lib/zip_source_buffer.c"
static zip_int64_t buffer_read(buffer_t *buffer , zip_uint8_t *data , zip_uint64_t length ) 
{ 
  zip_uint64_t n ;
  zip_uint64_t i ;
  zip_uint64_t fragment_offset ;
  zip_uint64_t tmp ;
  zip_uint64_t left ;
  zip_uint64_t tmp___0 ;

  {
#line 333
  if (length < buffer->size - buffer->offset) {
#line 333
    tmp = length;
  } else {
#line 333
    tmp = buffer->size - buffer->offset;
  }
#line 333
  length = tmp;
#line 335
  if (length == 0UL) {
#line 336
    return ((zip_int64_t )0);
  }
#line 338
  if (length > 0xffffffffffffffffUL) {
#line 339
    return ((zip_int64_t )-1);
  }
#line 342
  i = buffer->offset / buffer->fragment_size;
#line 343
  fragment_offset = buffer->offset % buffer->fragment_size;
#line 344
  n = (zip_uint64_t )0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;

#line 345
    if (! (n < length)) {
#line 345
      goto while_break;
    }
#line 346
    if (length - n < buffer->fragment_size - fragment_offset) {
#line 346
      tmp___0 = length - n;
    } else {
#line 346
      tmp___0 = buffer->fragment_size - fragment_offset;
    }
    {
#line 346
    left = tmp___0;
#line 348
    memcpy((void *)(data + n), (void const   *)(*(buffer->fragments + i) + fragment_offset),
           left);
#line 350
    n += left;
#line 351
    i ++;
#line 352
    fragment_offset = (zip_uint64_t )0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 355
  buffer->offset += n;
#line 356
  return ((zip_int64_t )n);
}
}
#line 361 "/root/patchweave_new/24/lib/zip_source_buffer.c"
static int buffer_seek(buffer_t *buffer , void *data , zip_uint64_t len , zip_error_t *error ) 
{ 
  zip_int64_t new_offset ;
  zip_int64_t __cil_tmp6 ;

  {
  {
#line 363
  __cil_tmp6 = zip_source_seek_compute_offset(buffer->offset, buffer->size, data,
                                              len, error);
#line 363
  new_offset = __cil_tmp6;
  }
#line 365
  if (new_offset < 0L) {
#line 366
    return (-1);
  }
#line 369
  buffer->offset = (zip_uint64_t )new_offset;
#line 370
  return (0);
}
}
#line 375 "/root/patchweave_new/24/lib/zip_source_buffer.c"
static zip_int64_t buffer_write(buffer_t *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                zip_error_t *error ) 
{ 
  zip_uint64_t n ;
  zip_uint64_t i ;
  zip_uint64_t fragment_offset ;
  zip_uint8_t **fragments ;
  zip_uint64_t needed_fragments ;
  zip_uint64_t new_capacity ;
  zip_uint64_t left ;
  zip_uint64_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 380
  if (((buffer->offset + length) + buffer->fragment_size) - 1UL < length) {
    {
#line 381
    zip_error_set(error, 18, 0);
    }
#line 382
    return ((zip_int64_t )-1);
  }
#line 386
  if (buffer->offset + length > buffer->nfragments * buffer->fragment_size) {
#line 387
    needed_fragments = (((buffer->offset + length) + buffer->fragment_size) - 1UL) / buffer->fragment_size;
#line 389
    if (needed_fragments > buffer->fragments_capacity) {
#line 390
      new_capacity = buffer->fragments_capacity;
      {
#line 392
      while (1) {
        while_continue: /* CIL Label */ ;

#line 392
        if (! (new_capacity < needed_fragments)) {
#line 392
          goto while_break;
        }
#line 393
        new_capacity *= 2UL;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: 
      {
#line 396
      tmp___0 = realloc((void *)buffer->fragments, new_capacity * sizeof(*fragments));
#line 396
      fragments = (zip_uint8_t **)tmp___0;
      }
#line 398
      if ((unsigned long )fragments == (unsigned long )((void *)0)) {
        {
#line 399
        zip_error_set(error, 14, 0);
        }
#line 400
        return ((zip_int64_t )-1);
      }
#line 403
      buffer->fragments = fragments;
#line 404
      buffer->fragments_capacity = new_capacity;
    }
    {
#line 407
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 407
      if (! (buffer->nfragments < needed_fragments)) {
#line 407
        goto while_break___0;
      }
      {
#line 408
      tmp___1 = malloc(buffer->fragment_size);
#line 408
      *(buffer->fragments + buffer->nfragments) = (zip_uint8_t *)tmp___1;
      }
#line 408
      if ((unsigned long )*(buffer->fragments + buffer->nfragments) == (unsigned long )((void *)0)) {
        {
#line 409
        zip_error_set(error, 14, 0);
        }
#line 410
        return ((zip_int64_t )-1);
      }
#line 412
      (buffer->nfragments) ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 416
  i = buffer->offset / buffer->fragment_size;
#line 417
  fragment_offset = buffer->offset % buffer->fragment_size;
#line 418
  n = (zip_uint64_t )0;
  {
#line 419
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 419
    if (! (n < length)) {
#line 419
      goto while_break___1;
    }
#line 420
    if (length - n < buffer->fragment_size - fragment_offset) {
#line 420
      tmp = length - n;
    } else {
#line 420
      tmp = buffer->fragment_size - fragment_offset;
    }
    {
#line 420
    left = tmp;
#line 422
    memcpy((void *)(*(buffer->fragments + i) + fragment_offset), (void const   *)(data + n),
           left);
#line 424
    n += left;
#line 425
    i ++;
#line 426
    fragment_offset = (zip_uint64_t )0;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
#line 429
  buffer->offset += n;
#line 430
  if (buffer->offset > buffer->size) {
#line 431
    buffer->size = buffer->offset;
  }
#line 434
  return ((zip_int64_t )n);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_source_begin_write.c"
int zip_source_begin_write(zip_source_t *src ) 
{ 
  zip_int64_t __cil_tmp2 ;

  {
#line 41
  if ((unsigned int )src->write_state == 1U) {
    {
#line 42
    zip_error_set(& src->error, 18, 0);
    }
#line 43
    return (-1);
  }
  {
#line 46
  __cil_tmp2 = _zip_source_call(src, (void *)0, (zip_uint64_t )0, (zip_source_cmd_t )8);
  }
#line 46
  if (__cil_tmp2 < 0L) {
#line 47
    return (-1);
  }
#line 50
  src->write_state = (zip_source_write_state_t )1;
#line 52
  return (0);
}
}
#line 42 "/root/patchweave_new/24/lib/zip_set_name.c"
int _zip_set_name(zip_t *za___0 , zip_uint64_t idx , char const   *name , zip_flags_t flags ) 
{ 
  zip_entry_t *e ;
  zip_string_t *str ;
  int same_as_orig ;
  zip_int64_t i ;
  zip_uint8_t *old_name ;
  zip_uint8_t *new_name ;
  zip_string_t *old_str ;
  unsigned long __cil_tmp12 ;
  zip_string_t *__cil_tmp13 ;
  enum zip_encoding_type __cil_tmp14 ;
  zip_string_t *tmp ;
  zip_uint8_t *__cil_tmp19 ;
  int __cil_tmp21 ;

  {
#line 51
  if (idx >= za___0->nentry) {
    {
#line 52
    zip_error_set(& za___0->error, 18, 0);
    }
#line 53
    return (-1);
  }
#line 56
  if (za___0->ch_flags & 2U) {
    {
#line 57
    zip_error_set(& za___0->error, 25, 0);
    }
#line 58
    return (-1);
  }
#line 61
  if (name) {
#line 61
    if ((int )*(name + 0) != 0) {
      {
#line 63
      __cil_tmp12 = strlen(name);
#line 63
      __cil_tmp13 = _zip_string_new((zip_uint8_t *)name, (zip_uint16_t )__cil_tmp12,
                                    flags, & za___0->error);
#line 63
      str = __cil_tmp13;
      }
#line 63
      if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 64
        return (-1);
      }
      {
#line 65
      __cil_tmp14 = _zip_guess_encoding(str, (enum zip_encoding_type )0);
      }
#line 65
      if ((flags & 6144U) == 0U) {
#line 65
        if ((unsigned int )__cil_tmp14 == 3U) {
#line 66
          str->encoding = (enum zip_encoding_type )2;
        }
      }
    } else {
#line 69
      str = (zip_string_t *)((void *)0);
    }
  } else {
#line 69
    str = (zip_string_t *)((void *)0);
  }
  {
#line 72
  i = _zip_name_locate(za___0, name, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 72
  if (i >= 0L) {
#line 72
    if ((zip_uint64_t )i != idx) {
      {
#line 73
      _zip_string_free(str);
#line 74
      zip_error_set(& za___0->error, 10, 0);
      }
#line 75
      return (-1);
    }
  }
#line 79
  if (i >= 0L) {
#line 79
    if ((zip_uint64_t )i == idx) {
      {
#line 80
      _zip_string_free(str);
      }
#line 81
      return (0);
    }
  }
#line 84
  e = za___0->entry + idx;
#line 86
  if (e->orig) {
    {
#line 87
    same_as_orig = _zip_string_equal((e->orig)->filename, str);
    }
  } else {
#line 89
    same_as_orig = 0;
  }
#line 91
  if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
#line 91
    if (! same_as_orig) {
      {
#line 92
      e->changes = _zip_dirent_clone(e->orig);
      }
#line 92
      if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
        {
#line 93
        zip_error_set(& za___0->error, 14, 0);
#line 94
        _zip_string_free(str);
        }
#line 95
        return (-1);
      }
    }
  }
#line 99
  if (same_as_orig) {
#line 99
    tmp = (e->orig)->filename;
  } else {
#line 99
    tmp = str;
  }
  {
#line 99
  __cil_tmp19 = _zip_string_get(tmp, (zip_uint32_t *)((void *)0), (zip_flags_t )0,
                                & za___0->error);
#line 99
  new_name = __cil_tmp19;
  }
#line 99
  if ((unsigned long )new_name == (unsigned long )((void *)0)) {
    {
#line 100
    _zip_string_free(str);
    }
#line 101
    return (-1);
  }
#line 104
  if (e->changes) {
#line 105
    old_str = (e->changes)->filename;
  } else
#line 107
  if (e->orig) {
#line 108
    old_str = (e->orig)->filename;
  } else {
#line 111
    old_str = (zip_string_t *)((void *)0);
  }
#line 114
  if (old_str) {
    {
#line 115
    old_name = _zip_string_get(old_str, (zip_uint32_t *)((void *)0), (zip_flags_t )0,
                               & za___0->error);
    }
#line 115
    if ((unsigned long )old_name == (unsigned long )((void *)0)) {
      {
#line 116
      _zip_string_free(str);
      }
#line 117
      return (-1);
    }
  } else {
#line 121
    old_name = (zip_uint8_t *)((void *)0);
  }
  {
#line 124
  __cil_tmp21 = _zip_hash_add(za___0->names, new_name, idx, (zip_flags_t )0, & za___0->error);
  }
#line 124
  if (__cil_tmp21 == 0) {
    {
#line 125
    _zip_string_free(str);
    }
#line 126
    return (-1);
  }
#line 128
  if (old_name) {
    {
#line 129
    _zip_hash_delete(za___0->names, old_name, (zip_error_t *)((void *)0));
    }
  }
#line 132
  if (same_as_orig) {
#line 133
    if (e->changes) {
#line 134
      if ((e->changes)->changed & 2U) {
        {
#line 135
        _zip_string_free((e->changes)->filename);
#line 136
        (e->changes)->changed &= 4294967293U;
        }
#line 137
        if ((e->changes)->changed == 0U) {
          {
#line 138
          _zip_dirent_free(e->changes);
#line 139
          e->changes = (zip_dirent_t *)((void *)0);
          }
        } else {
#line 143
          (e->changes)->filename = (e->orig)->filename;
        }
      }
    }
    {
#line 147
    _zip_string_free(str);
    }
  } else {
#line 150
    if ((e->changes)->changed & 2U) {
      {
#line 151
      _zip_string_free((e->changes)->filename);
      }
    }
#line 153
    (e->changes)->changed |= 2U;
#line 154
    (e->changes)->filename = str;
  }
#line 157
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_set_file_compression.c"
int zip_set_file_compression(zip_t *za___0 , zip_uint64_t idx , zip_int32_t method ,
                             zip_uint32_t flags ) 
{ 
  zip_entry_t *e ;
  zip_int32_t old_method ;
  int __cil_tmp7 ;
  int tmp ;

  {
#line 44
  if (idx >= za___0->nentry) {
    {
#line 45
    zip_error_set(& za___0->error, 18, 0);
    }
#line 46
    return (-1);
  } else
#line 44
  if (flags > 9U) {
    {
#line 45
    zip_error_set(& za___0->error, 18, 0);
    }
#line 46
    return (-1);
  }
#line 49
  if (za___0->ch_flags & 2U) {
    {
#line 50
    zip_error_set(& za___0->error, 25, 0);
    }
#line 51
    return (-1);
  }
  {
#line 54
  __cil_tmp7 = zip_compression_method_supported(method, 1);
  }
#line 54
  if (! __cil_tmp7) {
    {
#line 55
    zip_error_set(& za___0->error, 16, 0);
    }
#line 56
    return (-1);
  }
#line 59
  e = za___0->entry + idx;
#line 61
  if ((unsigned long )e->orig == (unsigned long )((void *)0)) {
#line 61
    tmp = -1;
  } else {
#line 61
    tmp = (e->orig)->comp_method;
  }
#line 61
  old_method = tmp;
#line 68
  if (method == old_method) {
#line 69
    if (e->changes) {
#line 70
      (e->changes)->changed &= 4294967294U;
#line 71
      (e->changes)->compression_level = (zip_uint16_t )0;
#line 72
      if ((e->changes)->changed == 0U) {
        {
#line 73
        _zip_dirent_free(e->changes);
#line 74
        e->changes = (zip_dirent_t *)((void *)0);
        }
      }
    }
  } else {
#line 79
    if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
      {
#line 80
      e->changes = _zip_dirent_clone(e->orig);
      }
#line 80
      if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
        {
#line 81
        zip_error_set(& za___0->error, 14, 0);
        }
#line 82
        return (-1);
      }
    }
#line 86
    (e->changes)->comp_method = method;
#line 87
    (e->changes)->compression_level = (zip_uint16_t )flags;
#line 88
    (e->changes)->changed |= 1U;
  }
#line 91
  return (0);
}
}
#line 316 "/root/patchweave_new/24/lib/zip.h"
void zip_register_progress_callback(zip_t *za___0 , void (*progress_callback___0)(double  ) ) ;
#line 318
zip_int64_t zip_add(zip_t *za___0 , char const   *name , zip_source_t *source ) ;
#line 319
zip_int64_t zip_add_dir(zip_t *za___0 , char const   *name ) ;
#line 320
char const   *zip_get_file_comment(zip_t *za___0 , zip_uint64_t idx , int *lenp ,
                                   int flags ) ;
#line 321
int zip_get_num_files(zip_t *za___0 ) ;
#line 322
int zip_rename(zip_t *za___0 , zip_uint64_t idx , char const   *name ) ;
#line 323
int zip_replace(zip_t *za___0 , zip_uint64_t idx , zip_source_t *source ) ;
#line 324
int zip_set_file_comment(zip_t *za___0 , zip_uint64_t idx , char const   *comment ,
                         int len ) ;
#line 325
int zip_error_get_sys_type(int ze ) ;
#line 326
void zip_error_get(zip_t *za___0 , int *zep , int *sep ) ;
#line 327
int zip_error_to_str(char *buf , zip_uint64_t len , int ze , int se ) ;
#line 328
void zip_file_error_get(zip_file_t *zf , int *zep , int *sep ) ;
#line 42 "/root/patchweave_new/24/lib/zip_set_file_comment.c"
int zip_set_file_comment(zip_t *za___0 , zip_uint64_t idx , char const   *comment ,
                         int len ) 
{ 
  int __cil_tmp5 ;

  {
#line 44
  if (len < 0) {
    {
#line 45
    zip_error_set(& za___0->error, 18, 0);
    }
#line 46
    return (-1);
  } else
#line 44
  if (len > 65535) {
    {
#line 45
    zip_error_set(& za___0->error, 18, 0);
    }
#line 46
    return (-1);
  }
  {
#line 48
  __cil_tmp5 = zip_file_set_comment(za___0, idx, comment, (zip_uint16_t )len, (zip_flags_t )0);
  }
#line 48
  return (__cil_tmp5);
}
}
#line 42 "/root/patchweave_new/24/lib/zip_set_default_password.c"
int zip_set_default_password(zip_t *za___0 , char const   *passwd ) 
{ 


  {
#line 44
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 45
    return (-1);
  }
  {
#line 47
  free((void *)za___0->default_password);
  }
#line 49
  if (passwd) {
    {
#line 50
    za___0->default_password = strdup(passwd);
    }
#line 50
    if ((unsigned long )za___0->default_password == (unsigned long )((void *)0)) {
      {
#line 51
      zip_error_set(& za___0->error, 14, 0);
      }
#line 52
      return (-1);
    }
  } else {
#line 56
    za___0->default_password = (char *)((void *)0);
  }
#line 58
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_set_archive_flag.c"
int zip_set_archive_flag(zip_t *za___0 , zip_flags_t flag , int value ) 
{ 
  unsigned int new_flags ;
  int __cil_tmp5 ;

  {
#line 43
  if (value) {
#line 44
    new_flags = za___0->ch_flags | flag;
  } else {
#line 46
    new_flags = za___0->ch_flags & ~ flag;
  }
#line 48
  if (new_flags == za___0->ch_flags) {
#line 49
    return (0);
  }
#line 51
  if (za___0->ch_flags & 2U) {
    {
#line 52
    zip_error_set(& za___0->error, 25, 0);
    }
#line 53
    return (-1);
  }
#line 56
  if (flag & 2U) {
#line 56
    if (value) {
#line 56
      if ((za___0->ch_flags & 2U) == 0U) {
        {
#line 58
        __cil_tmp5 = _zip_changed(za___0, (zip_uint64_t *)((void *)0));
        }
#line 58
        if (__cil_tmp5) {
          {
#line 59
          zip_error_set(& za___0->error, 15, 0);
          }
#line 60
          return (-1);
        }
      }
    }
  }
#line 64
  za___0->ch_flags = new_flags;
#line 66
  return (0);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_set_archive_comment.c"
int zip_set_archive_comment(zip_t *za___0 , char const   *comment , zip_uint16_t len ) 
{ 
  zip_string_t *cstr ;
  enum zip_encoding_type __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 45
  if (za___0->ch_flags & 2U) {
    {
#line 46
    zip_error_set(& za___0->error, 25, 0);
    }
#line 47
    return (-1);
  }
#line 50
  if ((unsigned long )comment == (unsigned long )((void *)0)) {
#line 50
    if ((int )len > 0) {
      {
#line 51
      zip_error_set(& za___0->error, 18, 0);
      }
#line 52
      return (-1);
    }
  }
#line 55
  if ((int )len > 0) {
    {
#line 56
    cstr = _zip_string_new((zip_uint8_t *)comment, len, 0U, & za___0->error);
    }
#line 56
    if ((unsigned long )cstr == (unsigned long )((void *)0)) {
#line 57
      return (-1);
    }
    {
#line 59
    __cil_tmp6 = _zip_guess_encoding(cstr, (enum zip_encoding_type )0);
    }
#line 59
    if ((unsigned int )__cil_tmp6 == 4U) {
      {
#line 60
      _zip_string_free(cstr);
#line 61
      zip_error_set(& za___0->error, 18, 0);
      }
#line 62
      return (-1);
    }
  } else {
#line 66
    cstr = (zip_string_t *)((void *)0);
  }
  {
#line 68
  _zip_string_free(za___0->comment_changes);
#line 69
  za___0->comment_changes = (zip_string_t *)((void *)0);
#line 71
  __cil_tmp7 = _zip_string_equal(za___0->comment_orig, cstr);
  }
#line 71
  if (za___0->comment_orig) {
#line 71
    if (__cil_tmp7) {
      {
#line 73
      _zip_string_free(cstr);
#line 74
      za___0->comment_changed = 0;
      }
    } else {
#line 71
      goto _L;
    }
  } else
  _L: 
#line 71
  if ((unsigned long )za___0->comment_orig == (unsigned long )((void *)0)) {
#line 71
    if ((unsigned long )cstr == (unsigned long )((void *)0)) {
      {
#line 73
      _zip_string_free(cstr);
#line 74
      za___0->comment_changed = 0;
      }
    } else {
#line 77
      za___0->comment_changes = cstr;
#line 78
      za___0->comment_changed = 1;
    }
  } else {
#line 77
    za___0->comment_changes = cstr;
#line 78
    za___0->comment_changed = 1;
  }
#line 81
  return (0);
}
}
#line 40 "/root/patchweave_new/24/lib/zip_replace.c"
int zip_replace(zip_t *za___0 , zip_uint64_t idx , zip_source_t *source ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 42
  __cil_tmp4 = zip_file_replace(za___0, idx, source, (zip_flags_t )0);
  }
#line 42
  return (__cil_tmp4);
}
}
#line 42 "/root/patchweave_new/24/lib/zip_rename.c"
int zip_rename(zip_t *za___0 , zip_uint64_t idx , char const   *name ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 44
  __cil_tmp4 = zip_file_rename(za___0, idx, name, (zip_flags_t )0);
  }
#line 44
  return (__cil_tmp4);
}
}
#line 59 "/root/patchweave_new/24/lib/zip_progress.c"
void _zip_progress_end(zip_progress_t *progress ) 
{ 


  {
  {
#line 60
  _zip_progress_update(progress, 1.);
  }
#line 62
  return;
}
}
#line 65 "/root/patchweave_new/24/lib/zip_progress.c"
void _zip_progress_free(zip_progress_t *progress ) 
{ 


  {
#line 66
  if ((unsigned long )progress == (unsigned long )((void *)0)) {
#line 67
    return;
  }
#line 70
  if (progress->ud_free) {
    {
#line 71
    (*(progress->ud_free))(progress->ud);
    }
  }
  {
#line 74
  free((void *)progress);
  }
#line 76
  return;
}
}
#line 79 "/root/patchweave_new/24/lib/zip_progress.c"
zip_progress_t *_zip_progress_new(zip_t *za___0 , double precision , void (*callback)(zip_t * ,
                                                                                      double  ,
                                                                                      void * ) ,
                                  void (*ud_free)(void * ) , void *ud ) 
{ 
  zip_progress_t *progress ;
  void *__cil_tmp7 ;

  {
  {
#line 80
  __cil_tmp7 = malloc(sizeof(*progress));
#line 80
  progress = (zip_progress_t *)__cil_tmp7;
  }
#line 82
  if ((unsigned long )progress == (unsigned long )((void *)0)) {
    {
#line 83
    zip_error_set(& za___0->error, 14, 0);
    }
#line 84
    return ((zip_progress_t *)((void *)0));
  }
#line 87
  progress->za = za___0;
#line 88
  progress->callback = callback;
#line 89
  progress->ud_free = ud_free;
#line 90
  progress->ud = ud;
#line 91
  progress->precision = precision;
#line 93
  return (progress);
}
}
#line 98 "/root/patchweave_new/24/lib/zip_progress.c"
void _zip_progress_start(zip_progress_t *progress ) 
{ 


  {
#line 99
  if ((unsigned long )progress == (unsigned long )((void *)0)) {
#line 100
    return;
  }
  {
#line 103
  progress->last_update = 0.;
#line 104
  (*(progress->callback))(progress->za, 0., progress->ud);
  }
#line 106
  return;
}
}
#line 109 "/root/patchweave_new/24/lib/zip_progress.c"
void _zip_progress_subrange(zip_progress_t *progress , double start___0 , double end___0 ) 
{ 


  {
#line 110
  if ((unsigned long )progress == (unsigned long )((void *)0)) {
#line 111
    return;
  }
  {
#line 114
  progress->start = start___0;
#line 115
  progress->end = end___0;
#line 117
  _zip_progress_update(progress, 0.);
  }
#line 119
  return;
}
}
#line 121 "/root/patchweave_new/24/lib/zip_progress.c"
void _zip_progress_update(zip_progress_t *progress , double sub_current ) 
{ 
  double current ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 124
  if ((unsigned long )progress == (unsigned long )((void *)0)) {
#line 125
    return;
  }
#line 128
  if (sub_current > 0.) {
#line 128
    tmp = sub_current;
  } else {
#line 128
    tmp = 0.;
  }
#line 128
  if (tmp < 1.) {
#line 128
    if (sub_current > 0.) {
#line 128
      tmp___0 = sub_current;
    } else {
#line 128
      tmp___0 = 0.;
    }
#line 128
    tmp___1 = tmp___0;
  } else {
#line 128
    tmp___1 = 1.;
  }
#line 128
  current = tmp___1 * (progress->end - progress->start) + progress->start;
#line 130
  if (current - progress->last_update > progress->precision) {
    {
#line 131
    (*(progress->callback))(progress->za, current, progress->ud);
#line 132
    progress->last_update = current;
    }
  }
#line 135
  return;
}
}
#line 138 "/root/patchweave_new/24/lib/zip_progress.c"
int zip_register_progress_callback_with_state(zip_t *za___0 , double precision , void (*callback)(zip_t * ,
                                                                                                  double  ,
                                                                                                  void * ) ,
                                              void (*ud_free)(void * ) , void *ud ) 
{ 
  zip_progress_t *progress ;

  {
#line 139
  progress = (zip_progress_t *)((void *)0);
#line 141
  if ((unsigned long )callback != (unsigned long )((void *)0)) {
    {
#line 142
    progress = _zip_progress_new(za___0, precision, callback, ud_free, ud);
    }
#line 142
    if ((unsigned long )progress == (unsigned long )((void *)0)) {
#line 143
      return (-1);
    }
  }
  {
#line 147
  _zip_progress_free(za___0->progress);
#line 148
  za___0->progress = progress;
  }
#line 150
  return (0);
}
}
#line 160 "/root/patchweave_new/24/lib/zip_progress.c"
static void _zip_legacy_progress_callback(zip_t *za___0 , double progress , void *vud ) 
{ 
  struct legacy_ud *ud ;

  {
  {
#line 161
  ud = (struct legacy_ud *)vud;
#line 163
  (*(ud->callback))(progress);
  }
#line 165
  return;
}
}
#line 167 "/root/patchweave_new/24/lib/zip_progress.c"
void zip_register_progress_callback(zip_t *za___0 , void (*progress_callback___0)(double  ) ) 
{ 
  struct legacy_ud *ud ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 171
  if ((unsigned long )progress_callback___0 == (unsigned long )((void *)0)) {
    {
#line 172
    zip_register_progress_callback_with_state(za___0, (double )0, (void (*)(zip_t * ,
                                                                            double  ,
                                                                            void * ))((void *)0),
                                              (void (*)(void * ))((void *)0), (void *)0);
    }
  }
  {
#line 175
  __cil_tmp4 = malloc(sizeof(*ud));
#line 175
  ud = (struct legacy_ud *)__cil_tmp4;
  }
#line 175
  if ((unsigned long )ud == (unsigned long )((void *)0)) {
#line 176
    return;
  }
  {
#line 179
  ud->callback = progress_callback___0;
#line 181
  __cil_tmp5 = zip_register_progress_callback_with_state(za___0, 0.00100000000001,
                                                         & _zip_legacy_progress_callback,
                                                         & free, (void *)ud);
  }
#line 181
  if (__cil_tmp5 < 0) {
    {
#line 182
    free((void *)ud);
    }
  }
#line 185
  return;
}
}
#line 49 "/root/patchweave_new/24/lib/zip_open.c"
static zip_t *_zip_allocate_new(zip_source_t *src , unsigned int flags , zip_error_t *error ) ;
#line 50
static zip_int64_t _zip_checkcons(zip_t *za___0 , zip_cdir_t *cd , zip_error_t *error ) ;
#line 51
static zip_cdir_t *_zip_find_central_dir(zip_t *za___0 , zip_uint64_t len ) ;
#line 52
static exists_t _zip_file_exists(zip_source_t *src , zip_error_t *error ) ;
#line 53
static int _zip_headercomp(zip_dirent_t *central , zip_dirent_t *local ) ;
#line 54
static unsigned char *_zip_memmem(unsigned char const   *big , size_t biglen , unsigned char const   *little ,
                                  size_t littlelen ) ;
#line 55
static zip_cdir_t *_zip_read_cdir(zip_t *za___0 , zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                  zip_error_t *error ) ;
#line 56
static zip_cdir_t *_zip_read_eocd(zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                  unsigned int flags , zip_error_t *error ) ;
#line 57
static zip_cdir_t *_zip_read_eocd64(zip_source_t *src , zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                    unsigned int flags , zip_error_t *error ) ;
#line 61 "/root/patchweave_new/24/lib/zip_open.c"
zip_t *zip_open(char const   *fn , int _flags , int *zep ) 
{ 
  zip_t *za___0 ;
  zip_source_t *src ;
  struct zip_error error ;

  {
  {
#line 67
  zip_error_init(& error);
#line 68
  src = zip_source_file_create(fn, (zip_uint64_t )0, (zip_int64_t )-1, & error);
  }
#line 68
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 69
    _zip_set_open_error(zep, & error, 0);
#line 70
    zip_error_fini(& error);
    }
#line 71
    return ((zip_t *)((void *)0));
  }
  {
#line 74
  za___0 = zip_open_from_source(src, _flags, & error);
  }
#line 74
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
    {
#line 75
    zip_source_free(src);
#line 76
    _zip_set_open_error(zep, & error, 0);
#line 77
    zip_error_fini(& error);
    }
#line 78
    return ((zip_t *)((void *)0));
  }
  {
#line 81
  zip_error_fini(& error);
  }
#line 82
  return (za___0);
}
}
#line 89 "/root/patchweave_new/24/lib/zip_open.c"
static zip_int64_t needed_support_read  ;
#line 90 "/root/patchweave_new/24/lib/zip_open.c"
static zip_int64_t needed_support_write  ;
#line 87 "/root/patchweave_new/24/lib/zip_open.c"
zip_t *zip_open_from_source(zip_source_t *src , int _flags , zip_error_t *error ) 
{ 
  unsigned int flags ;
  zip_int64_t supported ;
  exists_t exists ;
  zip_t *__cil_tmp13 ;
  zip_t *za___0 ;
  int __cil_tmp15 ;

  {
#line 89
  needed_support_read = (zip_int64_t )-1;
#line 90
  needed_support_write = (zip_int64_t )-1;
#line 96
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 97
    zip_error_set(error, 18, 0);
    }
#line 98
    return ((zip_t *)((void *)0));
  } else
#line 96
  if (_flags < 0) {
    {
#line 97
    zip_error_set(error, 18, 0);
    }
#line 98
    return ((zip_t *)((void *)0));
  }
  {
#line 100
  flags = (unsigned int )_flags;
#line 102
  supported = zip_source_supports(src);
  }
#line 103
  if (needed_support_read == -1L) {
    {
#line 104
    needed_support_read = zip_source_make_command_bitmap((zip_source_cmd_t )0, 1,
                                                         2, 6, 7, 3, -1);
#line 105
    needed_support_write = zip_source_make_command_bitmap((zip_source_cmd_t )8, 9,
                                                          10, 12, 13, 15, -1);
    }
  }
#line 107
  if ((supported & needed_support_read) != needed_support_read) {
    {
#line 108
    zip_error_set(error, 28, 0);
    }
#line 109
    return ((zip_t *)((void *)0));
  }
#line 111
  if ((supported & needed_support_write) != needed_support_write) {
#line 112
    flags |= 16U;
  }
#line 115
  if ((flags & 24U) == 24U) {
    {
#line 116
    zip_error_set(error, 25, 0);
    }
#line 117
    return ((zip_t *)((void *)0));
  }
  {
#line 120
  exists = _zip_file_exists(src, error);
  }
#line 122
  if ((int )exists == -1) {
#line 122
    goto case_neg_1;
  }
#line 125
  if ((int )exists == 0) {
#line 125
    goto case_0;
  }
#line 132
  goto switch_default;
  case_neg_1: 
#line 123
  return ((zip_t *)((void *)0));
  case_0: 
#line 126
  if ((flags & 1U) == 0U) {
    {
#line 127
    zip_error_set(error, 9, 0);
    }
#line 128
    return ((zip_t *)((void *)0));
  }
  {
#line 130
  __cil_tmp13 = _zip_allocate_new(src, flags, error);
  }
#line 130
  return (__cil_tmp13);
  switch_default: 
#line 134
  if (flags & 2U) {
    {
#line 135
    zip_error_set(error, 10, 0);
    }
#line 136
    return ((zip_t *)((void *)0));
  }
  {
#line 138
  __cil_tmp15 = zip_source_open(src);
  }
#line 138
  if (__cil_tmp15 < 0) {
    {
#line 139
    _zip_error_set_from_source(error, src);
    }
#line 140
    return ((zip_t *)((void *)0));
  }
#line 143
  if (flags & 8U) {
    {
#line 144
    za___0 = _zip_allocate_new(src, flags, error);
    }
  } else {
    {
#line 148
    za___0 = _zip_open(src, flags, error);
    }
  }
#line 151
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
    {
#line 152
    zip_source_close(src);
    }
#line 153
    return ((zip_t *)((void *)0));
  }
#line 155
  return (za___0);

#line 159
  return ((zip_t *)0);
}
}
#line 162 "/root/patchweave_new/24/lib/zip_open.c"
zip_t *_zip_open(zip_source_t *src , unsigned int flags , zip_error_t *error ) 
{ 
  zip_t *za___0 ;
  zip_cdir_t *cdir ;
  struct zip_stat st ;
  zip_uint64_t len ;
  zip_uint64_t idx ;
  int __cil_tmp9 ;
  zip_uint8_t *name ;
  zip_uint8_t *__cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 169
  zip_stat_init(& st);
#line 170
  __cil_tmp9 = zip_source_stat(src, & st);
  }
#line 170
  if (__cil_tmp9 < 0) {
    {
#line 171
    _zip_error_set_from_source(error, src);
    }
#line 172
    return ((zip_t *)((void *)0));
  }
#line 174
  if ((st.valid & 4UL) == 0UL) {
    {
#line 175
    zip_error_set(error, 4, 95);
    }
#line 176
    return ((zip_t *)((void *)0));
  }
#line 178
  len = st.size;
#line 181
  if (len == 0UL) {
    {
#line 182
    za___0 = _zip_allocate_new(src, flags, error);
    }
#line 182
    if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
      {
#line 183
      zip_source_free(src);
      }
#line 184
      return ((zip_t *)((void *)0));
    }
#line 187
    return (za___0);
  }
  {
#line 190
  za___0 = _zip_allocate_new(src, flags, error);
  }
#line 190
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 191
    return ((zip_t *)((void *)0));
  }
  {
#line 194
  cdir = _zip_find_central_dir(za___0, len);
  }
#line 194
  if ((unsigned long )cdir == (unsigned long )((void *)0)) {
    {
#line 195
    _zip_error_copy(error, & za___0->error);
#line 197
    zip_source_keep(src);
#line 198
    zip_discard(za___0);
    }
#line 199
    return ((zip_t *)((void *)0));
  }
  {
#line 202
  za___0->entry = cdir->entry;
#line 203
  za___0->nentry = cdir->nentry;
#line 204
  za___0->nentry_alloc = cdir->nentry_alloc;
#line 205
  za___0->comment_orig = cdir->comment;
#line 207
  free((void *)cdir);
#line 209
  _zip_hash_reserve_capacity(za___0->names, za___0->nentry, & za___0->error);
#line 211
  idx = (zip_uint64_t )0;
  }
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;

#line 211
    if (! (idx < za___0->nentry)) {
#line 211
      goto while_break;
    }
    {
#line 212
    __cil_tmp14 = _zip_string_get(((za___0->entry + idx)->orig)->filename, (zip_uint32_t *)((void *)0),
                                  (zip_flags_t )0, error);
#line 212
    name = __cil_tmp14;
    }
#line 213
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      {
#line 215
      zip_source_keep(src);
#line 216
      zip_discard(za___0);
      }
#line 217
      return ((zip_t *)((void *)0));
    }
    {
#line 220
    __cil_tmp15 = _zip_hash_add(za___0->names, name, idx, 8U, & za___0->error);
    }
#line 220
    if (__cil_tmp15 == 0) {
#line 221
      if (za___0->error.zip_err != 10) {
        {
#line 222
        _zip_error_copy(error, & za___0->error);
#line 224
        zip_source_keep(src);
#line 225
        zip_discard(za___0);
        }
#line 226
        return ((zip_t *)((void *)0));
      } else
#line 221
      if (flags & 4U) {
        {
#line 222
        _zip_error_copy(error, & za___0->error);
#line 224
        zip_source_keep(src);
#line 225
        zip_discard(za___0);
        }
#line 226
        return ((zip_t *)((void *)0));
      }
    }
#line 211
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 231
  za___0->ch_flags = za___0->flags;
#line 233
  return (za___0);
}
}
#line 238 "/root/patchweave_new/24/lib/zip_open.c"
void _zip_set_open_error(int *zep , zip_error_t *err , int ze ) 
{ 
  int __cil_tmp5 ;
  int *__cil_tmp6 ;

  {
#line 240
  if (err) {
    {
#line 241
    ze = zip_error_code_zip(err);
#line 242
    __cil_tmp5 = zip_error_system_type(err);
    }
#line 242
    if (__cil_tmp5 == 1) {
      {
#line 243
      __cil_tmp6 = __errno_location();
#line 243
      *__cil_tmp6 = zip_error_code_system(err);
      }
    }
  }
#line 247
  if (zep) {
#line 248
    *zep = ze;
  }
#line 250
  return;
}
}
#line 259 "/root/patchweave_new/24/lib/zip_open.c"
static zip_cdir_t *_zip_read_cdir(zip_t *za___0 , zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                  zip_error_t *error ) 
{ 
  zip_cdir_t *cd ;
  zip_uint16_t comment_len ;
  zip_uint64_t i ;
  zip_uint64_t left ;
  zip_uint64_t eocd_offset ;
  zip_uint64_t __cil_tmp10 ;
  zip_buffer_t *cd_buffer ;
  zip_uint64_t __cil_tmp12 ;
  zip_uint8_t *__cil_tmp13 ;
  int __cil_tmp14 ;
  zip_uint8_t *__cil_tmp15 ;
  int __cil_tmp16 ;
  zip_uint64_t tail_len ;
  zip_uint8_t *__cil_tmp22 ;
  zip_string_t *__cil_tmp23 ;
  zip_uint8_t *data ;
  int __cil_tmp27 ;
  zip_int64_t __cil_tmp28 ;
  int grown ;
  zip_int64_t entry_size ;
  int __cil_tmp31 ;
  int __cil_tmp34 ;
  int ok ;
  zip_int64_t offset ;
  zip_int64_t __cil_tmp39 ;

  {
  {
#line 264
  __cil_tmp10 = _zip_buffer_offset(buffer);
#line 264
  eocd_offset = __cil_tmp10;
#line 267
  __cil_tmp12 = _zip_buffer_left(buffer);
  }
#line 267
  if (__cil_tmp12 < 22UL) {
    {
#line 269
    zip_error_set(error, 19, 0);
    }
#line 270
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 274
  __cil_tmp13 = _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 274
  __cil_tmp14 = memcmp((void const   *)__cil_tmp13, (void const   *)"PK\005\006",
                       4UL);
  }
#line 274
  if (__cil_tmp14 != 0) {
    {
#line 275
    zip_error_set(error, 19, 0);
    }
#line 276
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 279
  __cil_tmp15 = _zip_buffer_data(buffer);
#line 279
  __cil_tmp16 = memcmp((void const   *)((__cil_tmp15 + eocd_offset) - 20), (void const   *)"PK\006\a",
                       4UL);
  }
#line 279
  if (eocd_offset >= 20UL) {
#line 279
    if (__cil_tmp16 == 0) {
      {
#line 280
      _zip_buffer_set_offset(buffer, eocd_offset - 20UL);
#line 281
      cd = _zip_read_eocd64(za___0->src, buffer, buf_offset, za___0->flags, error);
      }
    } else {
      {
#line 284
      _zip_buffer_set_offset(buffer, eocd_offset);
#line 285
      cd = _zip_read_eocd(buffer, buf_offset, za___0->flags, error);
      }
    }
  } else {
    {
#line 284
    _zip_buffer_set_offset(buffer, eocd_offset);
#line 285
    cd = _zip_read_eocd(buffer, buf_offset, za___0->flags, error);
    }
  }
#line 288
  if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 289
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 291
  _zip_buffer_set_offset(buffer, eocd_offset + 20UL);
#line 292
  comment_len = _zip_buffer_get_16(buffer);
  }
#line 294
  if (cd->offset + cd->size > buf_offset + eocd_offset) {
    {
#line 296
    zip_error_set(error, 21, 0);
#line 297
    _zip_cdir_free(cd);
    }
#line 298
    return ((zip_cdir_t *)((void *)0));
  }
#line 301
  if ((int )comment_len) {
    _L: 
    {
#line 304
    _zip_buffer_set_offset(buffer, eocd_offset + 22UL);
#line 305
    tail_len = _zip_buffer_left(buffer);
    }
#line 307
    if (tail_len < (unsigned long )comment_len) {
      {
#line 308
      zip_error_set(error, 21, 0);
#line 309
      _zip_cdir_free(cd);
      }
#line 310
      return ((zip_cdir_t *)((void *)0));
    } else
#line 307
    if (za___0->open_flags & 4U) {
#line 307
      if (tail_len != (unsigned long )comment_len) {
        {
#line 308
        zip_error_set(error, 21, 0);
#line 309
        _zip_cdir_free(cd);
        }
#line 310
        return ((zip_cdir_t *)((void *)0));
      }
    }
#line 313
    if (comment_len) {
      {
#line 314
      __cil_tmp22 = _zip_buffer_get(buffer, (zip_uint64_t )comment_len);
#line 314
      __cil_tmp23 = _zip_string_new(__cil_tmp22, comment_len, 0U, error);
#line 314
      cd->comment = __cil_tmp23;
      }
#line 314
      if ((unsigned long )cd->comment == (unsigned long )((void *)0)) {
        {
#line 315
        _zip_cdir_free(cd);
        }
#line 316
        return ((zip_cdir_t *)((void *)0));
      }
    }
  } else
#line 301
  if (za___0->open_flags & 4U) {
#line 301
    goto _L;
  }
#line 321
  if (cd->offset >= buf_offset) {
    {
#line 324
    _zip_buffer_set_offset(buffer, cd->offset - buf_offset);
#line 326
    data = _zip_buffer_get(buffer, cd->size);
    }
#line 326
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 327
      zip_error_set(error, 21, 0);
#line 328
      _zip_cdir_free(cd);
      }
#line 329
      return ((zip_cdir_t *)((void *)0));
    }
    {
#line 331
    cd_buffer = _zip_buffer_new(data, cd->size);
    }
#line 331
    if ((unsigned long )cd_buffer == (unsigned long )((void *)0)) {
      {
#line 332
      zip_error_set(error, 14, 0);
#line 333
      _zip_cdir_free(cd);
      }
#line 334
      return ((zip_cdir_t *)((void *)0));
    }
  } else {
    {
#line 338
    cd_buffer = (zip_buffer_t *)((void *)0);
#line 340
    __cil_tmp27 = zip_source_seek(za___0->src, (zip_int64_t )cd->offset, 0);
    }
#line 340
    if (__cil_tmp27 < 0) {
      {
#line 341
      _zip_error_set_from_source(error, za___0->src);
#line 342
      _zip_cdir_free(cd);
      }
#line 343
      return ((zip_cdir_t *)((void *)0));
    }
    {
#line 347
    __cil_tmp28 = zip_source_tell(za___0->src);
    }
#line 347
    if (__cil_tmp28 != (zip_int64_t )cd->offset) {
      {
#line 348
      zip_error_set(error, 19, 0);
#line 349
      _zip_cdir_free(cd);
      }
#line 350
      return ((zip_cdir_t *)((void *)0));
    }
  }
#line 354
  left = cd->size;
#line 355
  i = (zip_uint64_t )0;
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;

#line 356
    if (! (left > 0UL)) {
#line 356
      goto while_break;
    }
#line 357
    grown = 0;
#line 360
    if (i == cd->nentry) {
#line 364
      if (cd->is_zip64) {
#line 365
        goto while_break;
      } else
#line 364
      if (left < 46UL) {
#line 365
        goto while_break;
      }
      {
#line 368
      __cil_tmp31 = _zip_cdir_grow(cd, (zip_uint64_t )65536, error);
      }
#line 368
      if (! __cil_tmp31) {
        {
#line 369
        _zip_cdir_free(cd);
#line 370
        _zip_buffer_free(cd_buffer);
        }
#line 371
        return ((zip_cdir_t *)((void *)0));
      }
#line 373
      grown = 1;
    }
    {
#line 376
    entry_size = _zip_dirent_read((cd->entry + i)->orig, za___0->src, cd_buffer, 0,
                                  error);
#line 376
    (cd->entry + i)->orig = _zip_dirent_new();
    }
#line 376
    if ((unsigned long )(cd->entry + i)->orig == (unsigned long )((void *)0)) {
      _L___7: 
      {
#line 377
      __cil_tmp34 = zip_error_code_zip(error);
      }
#line 377
      if (grown) {
#line 377
        if (__cil_tmp34 == 19) {
          {
#line 378
          zip_error_set(error, 21, 0);
          }
        }
      }
      {
#line 380
      _zip_cdir_free(cd);
#line 381
      _zip_buffer_free(cd_buffer);
      }
#line 382
      return ((zip_cdir_t *)((void *)0));
    } else
#line 376
    if (entry_size < 0L) {
#line 376
      goto _L___7;
    }
#line 384
    i ++;
#line 385
    left -= (zip_uint64_t )entry_size;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 388
  if (i != cd->nentry) {
    {
#line 389
    zip_error_set(error, 21, 0);
#line 390
    _zip_buffer_free(cd_buffer);
#line 391
    _zip_cdir_free(cd);
    }
#line 392
    return ((zip_cdir_t *)((void *)0));
  } else
#line 388
  if (left > 0UL) {
    {
#line 389
    zip_error_set(error, 21, 0);
#line 390
    _zip_buffer_free(cd_buffer);
#line 391
    _zip_cdir_free(cd);
    }
#line 392
    return ((zip_cdir_t *)((void *)0));
  }
#line 395
  if (za___0->open_flags & 4U) {
#line 398
    if (cd_buffer) {
      {
#line 399
      ok = _zip_buffer_eof(cd_buffer);
      }
    } else {
      {
#line 402
      __cil_tmp39 = zip_source_tell(za___0->src);
#line 402
      offset = __cil_tmp39;
      }
#line 404
      if (offset < 0L) {
        {
#line 405
        _zip_error_set_from_source(error, za___0->src);
#line 406
        _zip_cdir_free(cd);
        }
#line 407
        return ((zip_cdir_t *)((void *)0));
      }
#line 409
      ok = (zip_uint64_t )offset == cd->offset + cd->size;
    }
#line 412
    if (! ok) {
      {
#line 413
      zip_error_set(error, 21, 0);
#line 414
      _zip_buffer_free(cd_buffer);
#line 415
      _zip_cdir_free(cd);
      }
#line 416
      return ((zip_cdir_t *)((void *)0));
    }
  }
  {
#line 420
  _zip_buffer_free(cd_buffer);
  }
#line 421
  return (cd);
}
}
#line 432 "/root/patchweave_new/24/lib/zip_open.c"
static zip_int64_t _zip_checkcons(zip_t *za___0 , zip_cdir_t *cd , zip_error_t *error ) 
{ 
  zip_uint64_t i ;
  zip_uint64_t min ;
  zip_uint64_t max ;
  zip_uint64_t j ;
  struct zip_dirent temp ;
  zip_uint16_t __cil_tmp9 ;
  int __cil_tmp10 ;
  zip_int64_t __cil_tmp11 ;
  int __cil_tmp12 ;
  zip_int64_t tmp ;

  {
  {
#line 438
  _zip_dirent_init(& temp);
  }
#line 439
  if (cd->nentry) {
#line 440
    max = ((cd->entry + 0)->orig)->offset;
#line 441
    min = ((cd->entry + 0)->orig)->offset;
  } else {
#line 444
    max = (zip_uint64_t )0;
#line 444
    min = max;
  }
#line 446
  i = (zip_uint64_t )0;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;

#line 446
    if (! (i < cd->nentry)) {
#line 446
      goto while_break;
    }
#line 447
    if (((cd->entry + i)->orig)->offset < min) {
#line 448
      min = ((cd->entry + i)->orig)->offset;
    }
#line 449
    if (min > cd->offset) {
      {
#line 450
      zip_error_set(error, 19, 0);
      }
#line 451
      return ((zip_int64_t )-1);
    }
    {
#line 454
    __cil_tmp9 = _zip_string_length(((cd->entry + i)->orig)->filename);
#line 454
    j = ((((cd->entry + i)->orig)->offset + ((cd->entry + i)->orig)->comp_size) + (unsigned long )__cil_tmp9) + 30UL;
    }
#line 456
    if (j > max) {
#line 457
      max = j;
    }
#line 458
    if (max > cd->offset) {
      {
#line 459
      zip_error_set(error, 19, 0);
      }
#line 460
      return ((zip_int64_t )-1);
    }
    {
#line 463
    __cil_tmp10 = zip_source_seek(za___0->src, (zip_int64_t )((cd->entry + i)->orig)->offset,
                                  0);
    }
#line 463
    if (__cil_tmp10 < 0) {
      {
#line 464
      _zip_error_set_from_source(error, za___0->src);
      }
#line 465
      return ((zip_int64_t )-1);
    }
    {
#line 468
    __cil_tmp11 = _zip_dirent_read(& temp, za___0->src, (zip_buffer_t *)((void *)0),
                                   1, error);
    }
#line 468
    if (__cil_tmp11 == -1L) {
      {
#line 469
      _zip_dirent_finalize(& temp);
      }
#line 470
      return ((zip_int64_t )-1);
    }
    {
#line 473
    __cil_tmp12 = _zip_headercomp((cd->entry + i)->orig, & temp);
    }
#line 473
    if (__cil_tmp12 != 0) {
      {
#line 474
      zip_error_set(error, 21, 0);
#line 475
      _zip_dirent_finalize(& temp);
      }
#line 476
      return ((zip_int64_t )-1);
    }
    {
#line 479
    ((cd->entry + i)->orig)->extra_fields = _zip_ef_merge(((cd->entry + i)->orig)->extra_fields,
                                                          temp.extra_fields);
#line 480
    ((cd->entry + i)->orig)->local_extra_fields_read = 1;
#line 481
    temp.extra_fields = (zip_extra_field_t *)((void *)0);
#line 483
    _zip_dirent_finalize(& temp);
#line 446
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 486
  if (max - min < 0xffffffffffffffffUL) {
#line 486
    tmp = (zip_int64_t )(max - min);
  } else {
#line 486
    tmp = -1L;
  }
#line 486
  return (tmp);
}
}
#line 495 "/root/patchweave_new/24/lib/zip_open.c"
static int _zip_headercomp(zip_dirent_t *central , zip_dirent_t *local ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 497
  __cil_tmp3 = _zip_string_equal(central->filename, local->filename);
  }
#line 497
  if ((int )central->version_needed < (int )local->version_needed) {
#line 506
    return (-1);
  } else
#line 497
  if (central->comp_method != local->comp_method) {
#line 506
    return (-1);
  } else
#line 497
  if (central->last_mod != local->last_mod) {
#line 506
    return (-1);
  } else
#line 497
  if (! __cil_tmp3) {
#line 506
    return (-1);
  }
#line 508
  if (central->crc != local->crc) {
    _L: 
#line 512
    if (((unsigned int )local->bitflags & 8U) == 0U) {
#line 514
      return (-1);
    } else
#line 512
    if (local->crc != 0U) {
#line 514
      return (-1);
    } else
#line 512
    if (local->comp_size != 0UL) {
#line 514
      return (-1);
    } else
#line 512
    if (local->uncomp_size != 0UL) {
#line 514
      return (-1);
    }
  } else
#line 508
  if (central->comp_size != local->comp_size) {
#line 508
    goto _L;
  } else
#line 508
  if (central->uncomp_size != local->uncomp_size) {
#line 508
    goto _L;
  }
#line 517
  return (0);
}
}
#line 522 "/root/patchweave_new/24/lib/zip_open.c"
static zip_t *_zip_allocate_new(zip_source_t *src , unsigned int flags , zip_error_t *error ) 
{ 
  zip_t *za___0 ;

  {
  {
#line 526
  za___0 = _zip_new(error);
  }
#line 526
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 527
    return ((zip_t *)((void *)0));
  }
#line 530
  za___0->src = src;
#line 531
  za___0->open_flags = flags;
#line 532
  if (flags & 16U) {
#line 533
    za___0->flags |= 2U;
#line 534
    za___0->ch_flags |= 2U;
  }
#line 536
  return (za___0);
}
}
#line 544 "/root/patchweave_new/24/lib/zip_open.c"
static exists_t _zip_file_exists(zip_source_t *src , zip_error_t *error ) 
{ 
  struct zip_stat st ;
  int __cil_tmp4 ;
  zip_error_t *src_error ;
  zip_error_t *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;

  {
  {
#line 548
  zip_stat_init(& st);
#line 549
  __cil_tmp4 = zip_source_stat(src, & st);
  }
#line 549
  if (__cil_tmp4 != 0) {
    {
#line 550
    __cil_tmp6 = zip_source_error(src);
#line 550
    src_error = __cil_tmp6;
#line 551
    __cil_tmp8 = zip_error_code_system(src_error);
#line 551
    __cil_tmp7 = zip_error_code_zip(src_error);
    }
#line 551
    if (__cil_tmp7 == 5) {
#line 551
      if (__cil_tmp8 == 2) {
#line 552
        return ((exists_t )0);
      }
    }
    {
#line 554
    _zip_error_copy(error, src_error);
    }
#line 555
    return ((exists_t )-1);
  }
#line 558
  if (st.valid & 4UL) {
#line 558
    if (st.size == 0UL) {
#line 558
      tmp = 1;
    } else {
#line 558
      tmp = 2;
    }
  } else {
#line 558
    tmp = 2;
  }
#line 558
  return ((exists_t )tmp);
}
}
#line 563 "/root/patchweave_new/24/lib/zip_open.c"
static zip_cdir_t *_zip_find_central_dir(zip_t *za___0 , zip_uint64_t len ) 
{ 
  zip_cdir_t *cdir ;
  zip_cdir_t *cdirnew ;
  zip_uint8_t *match ;
  zip_int64_t buf_offset ;
  zip_uint64_t buflen ;
  zip_int64_t a ;
  zip_int64_t best ;
  zip_error_t error ;
  zip_buffer_t *buffer ;
  zip_uint64_t tmp ;
  int __cil_tmp13 ;
  zip_error_t *src_error ;
  zip_error_t *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  zip_uint64_t __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  zip_uint8_t *__cil_tmp23 ;
  zip_uint8_t *__cil_tmp29 ;

  {
#line 574
  if (len < 22UL) {
    {
#line 575
    zip_error_set(& za___0->error, 19, 0);
    }
#line 576
    return ((zip_cdir_t *)((void *)0));
  }
#line 579
  if (len < 65578UL) {
#line 579
    tmp = len;
  } else {
#line 579
    tmp = 65578UL;
  }
  {
#line 579
  buflen = tmp;
#line 580
  __cil_tmp13 = zip_source_seek(za___0->src, - ((zip_int64_t )buflen), 2);
  }
#line 580
  if (__cil_tmp13 < 0) {
    {
#line 581
    __cil_tmp15 = zip_source_error(za___0->src);
#line 581
    src_error = __cil_tmp15;
#line 582
    __cil_tmp17 = zip_error_code_system(src_error);
#line 582
    __cil_tmp16 = zip_error_code_zip(src_error);
    }
#line 582
    if (__cil_tmp16 != 4) {
      {
#line 584
      _zip_error_copy(& za___0->error, src_error);
      }
#line 585
      return ((zip_cdir_t *)((void *)0));
    } else
#line 582
    if (__cil_tmp17 != 27) {
      {
#line 584
      _zip_error_copy(& za___0->error, src_error);
      }
#line 585
      return ((zip_cdir_t *)((void *)0));
    }
  }
  {
#line 588
  buf_offset = zip_source_tell(za___0->src);
  }
#line 588
  if (buf_offset < 0L) {
    {
#line 589
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 590
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 593
  buffer = _zip_buffer_new_from_source(za___0->src, buflen, (zip_uint8_t *)((void *)0),
                                       & za___0->error);
  }
#line 593
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 594
    return ((zip_cdir_t *)((void *)0));
  }
#line 597
  best = (zip_int64_t )-1;
#line 598
  cdir = (zip_cdir_t *)((void *)0);
#line 599
  if (buflen >= 65578UL) {
    {
#line 601
    _zip_buffer_set_offset(buffer, (zip_uint64_t )20);
    }
  }
  {
#line 603
  zip_error_set(& error, 19, 0);
#line 605
  match = _zip_buffer_get(buffer, (zip_uint64_t )0);
  }
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 606
    __cil_tmp21 = _zip_buffer_left(buffer);
#line 606
    __cil_tmp22 = _zip_memmem((unsigned char const   *)match, __cil_tmp21 - 18UL,
                              (unsigned char const   *)"PK\005\006", (size_t )4);
#line 606
    match = __cil_tmp22;
    }
#line 606
    if (! ((unsigned long )match != (unsigned long )((void *)0))) {
#line 606
      goto while_break;
    }
    {
#line 607
    __cil_tmp23 = _zip_buffer_data(buffer);
#line 607
    _zip_buffer_set_offset(buffer, (zip_uint64_t )(match - __cil_tmp23));
#line 608
    cdirnew = _zip_read_cdir(za___0, buffer, (zip_uint64_t )buf_offset, & error);
    }
#line 608
    if ((unsigned long )cdirnew != (unsigned long )((void *)0)) {
#line 609
      if (cdir) {
#line 610
        if (best <= 0L) {
          {
#line 611
          best = _zip_checkcons(za___0, cdir, & error);
          }
        }
        {
#line 614
        a = _zip_checkcons(za___0, cdirnew, & error);
        }
#line 615
        if (best < a) {
          {
#line 616
          _zip_cdir_free(cdir);
#line 617
          cdir = cdirnew;
#line 618
          best = a;
          }
        } else {
          {
#line 621
          _zip_cdir_free(cdirnew);
          }
        }
      } else {
#line 625
        cdir = cdirnew;
#line 626
        if (za___0->open_flags & 4U) {
          {
#line 627
          best = _zip_checkcons(za___0, cdir, & error);
          }
        } else {
#line 629
          best = (zip_int64_t )0;
        }
      }
#line 632
      cdirnew = (zip_cdir_t *)((void *)0);
    }
    {
#line 635
    match ++;
#line 636
    __cil_tmp29 = _zip_buffer_data(buffer);
#line 636
    _zip_buffer_set_offset(buffer, (zip_uint64_t )(match - __cil_tmp29));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 639
  _zip_buffer_free(buffer);
  }
#line 641
  if (best < 0L) {
    {
#line 642
    _zip_error_copy(& za___0->error, & error);
#line 643
    _zip_cdir_free(cdir);
    }
#line 644
    return ((zip_cdir_t *)((void *)0));
  }
#line 647
  return (cdir);
}
}
#line 652 "/root/patchweave_new/24/lib/zip_open.c"
static unsigned char *_zip_memmem(unsigned char const   *big , size_t biglen , unsigned char const   *little ,
                                  size_t littlelen ) 
{ 
  unsigned char const   *p ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 656
  if (biglen < littlelen) {
#line 657
    return ((unsigned char *)((void *)0));
  } else
#line 656
  if (littlelen == 0UL) {
#line 657
    return ((unsigned char *)((void *)0));
  }
#line 658
  p = big - 1;
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 659
    __cil_tmp6 = memchr((void const   *)(p + 1), (int )*(little + 0), ((size_t )(big - (p + 1)) + (biglen - littlelen)) + 1UL);
#line 659
    p = (unsigned char const   *)__cil_tmp6;
    }
#line 659
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 659
      goto while_break;
    }
    {
#line 661
    __cil_tmp7 = memcmp((void const   *)(p + 1), (void const   *)(little + 1), littlelen - 1UL);
    }
#line 661
    if (__cil_tmp7 == 0) {
#line 662
      return ((unsigned char *)p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 665
  return ((unsigned char *)((void *)0));
}
}
#line 670 "/root/patchweave_new/24/lib/zip_open.c"
static zip_cdir_t *_zip_read_eocd(zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                  unsigned int flags , zip_error_t *error ) 
{ 
  zip_cdir_t *cd ;
  zip_uint64_t i ;
  zip_uint64_t nentry ;
  zip_uint64_t size ;
  zip_uint64_t offset ;
  zip_uint64_t eocd_offset ;
  zip_uint64_t __cil_tmp11 ;
  zip_uint32_t __cil_tmp13 ;
  zip_uint16_t __cil_tmp14 ;
  zip_uint16_t __cil_tmp15 ;
  zip_uint32_t __cil_tmp16 ;
  zip_uint32_t __cil_tmp17 ;

  {
  {
#line 675
  __cil_tmp11 = _zip_buffer_left(buffer);
  }
#line 675
  if (__cil_tmp11 < 22UL) {
    {
#line 676
    zip_error_set(error, 21, 0);
    }
#line 677
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 680
  eocd_offset = _zip_buffer_offset(buffer);
#line 682
  _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 684
  __cil_tmp13 = _zip_buffer_get_32(buffer);
  }
#line 684
  if (__cil_tmp13 != 0U) {
    {
#line 685
    zip_error_set(error, 1, 0);
    }
#line 686
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 690
  __cil_tmp14 = _zip_buffer_get_16(buffer);
#line 690
  i = (zip_uint64_t )__cil_tmp14;
#line 692
  __cil_tmp15 = _zip_buffer_get_16(buffer);
#line 692
  nentry = (zip_uint64_t )__cil_tmp15;
  }
#line 694
  if (nentry != i) {
    {
#line 695
    zip_error_set(error, 19, 0);
    }
#line 696
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 699
  __cil_tmp16 = _zip_buffer_get_32(buffer);
#line 699
  size = (zip_uint64_t )__cil_tmp16;
#line 700
  __cil_tmp17 = _zip_buffer_get_32(buffer);
#line 700
  offset = (zip_uint64_t )__cil_tmp17;
  }
#line 702
  if (offset + size < offset) {
    {
#line 703
    zip_error_set(error, 4, 27);
    }
#line 704
    return ((zip_cdir_t *)((void *)0));
  }
#line 707
  if (offset + size > buf_offset + eocd_offset) {
    {
#line 709
    zip_error_set(error, 21, 0);
    }
#line 710
    return ((zip_cdir_t *)((void *)0));
  }
#line 713
  if (flags & 4U) {
#line 713
    if (offset + size != buf_offset + eocd_offset) {
      {
#line 714
      zip_error_set(error, 21, 0);
      }
#line 715
      return ((zip_cdir_t *)((void *)0));
    }
  }
  {
#line 718
  cd = _zip_cdir_new(nentry, error);
  }
#line 718
  if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 719
    return ((zip_cdir_t *)((void *)0));
  }
#line 721
  cd->is_zip64 = 0;
#line 722
  cd->size = size;
#line 723
  cd->offset = offset;
#line 725
  return (cd);
}
}
#line 730 "/root/patchweave_new/24/lib/zip_open.c"
static zip_cdir_t *_zip_read_eocd64(zip_source_t *src , zip_buffer_t *buffer , zip_uint64_t buf_offset ,
                                    unsigned int flags , zip_error_t *error ) 
{ 
  zip_cdir_t *cd ;
  zip_uint64_t offset ;
  zip_uint8_t eocd[56] ;
  zip_uint64_t eocd_offset ;
  zip_uint64_t size ;
  zip_uint64_t nentry ;
  zip_uint64_t i ;
  zip_uint64_t eocdloc_offset ;
  int free_buffer ;
  zip_uint32_t num_disks ;
  zip_uint32_t num_disks64 ;
  zip_uint32_t eocd_disk ;
  zip_uint32_t eocd_disk64 ;
  zip_uint16_t __cil_tmp20 ;
  zip_uint16_t __cil_tmp21 ;
  zip_uint64_t __cil_tmp23 ;
  int __cil_tmp24 ;
  zip_uint8_t *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp35 ;

  {
  {
#line 740
  eocdloc_offset = _zip_buffer_offset(buffer);
#line 742
  _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 744
  __cil_tmp20 = _zip_buffer_get_16(buffer);
#line 744
  num_disks = (zip_uint32_t )__cil_tmp20;
#line 745
  __cil_tmp21 = _zip_buffer_get_16(buffer);
#line 745
  eocd_disk = (zip_uint32_t )__cil_tmp21;
#line 746
  eocd_offset = _zip_buffer_get_64(buffer);
  }
#line 748
  if (eocd_offset > 0xffffffffffffffffUL) {
    {
#line 749
    zip_error_set(error, 4, 27);
    }
#line 750
    return ((zip_cdir_t *)((void *)0));
  } else
#line 748
  if (eocd_offset + 56UL < eocd_offset) {
    {
#line 749
    zip_error_set(error, 4, 27);
    }
#line 750
    return ((zip_cdir_t *)((void *)0));
  }
#line 753
  if (eocd_offset + 56UL > eocdloc_offset + buf_offset) {
    {
#line 754
    zip_error_set(error, 21, 0);
    }
#line 755
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 758
  __cil_tmp23 = _zip_buffer_size(buffer);
  }
#line 758
  if (eocd_offset >= buf_offset) {
#line 758
    if (eocd_offset + 56UL <= buf_offset + __cil_tmp23) {
      {
#line 759
      _zip_buffer_set_offset(buffer, eocd_offset - buf_offset);
#line 760
      free_buffer = 0;
      }
    } else {
#line 758
      goto _L;
    }
  } else {
    _L: 
    {
#line 763
    __cil_tmp24 = zip_source_seek(src, (zip_int64_t )eocd_offset, 0);
    }
#line 763
    if (__cil_tmp24 < 0) {
      {
#line 764
      _zip_error_set_from_source(error, src);
      }
#line 765
      return ((zip_cdir_t *)((void *)0));
    }
    {
#line 767
    buffer = _zip_buffer_new_from_source(src, (zip_uint64_t )56, eocd, error);
    }
#line 767
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 768
      return ((zip_cdir_t *)((void *)0));
    }
#line 770
    free_buffer = 1;
  }
  {
#line 773
  __cil_tmp26 = _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 773
  __cil_tmp27 = memcmp((void const   *)__cil_tmp26, (void const   *)"PK\006\006\342U",
                       4UL);
  }
#line 773
  if (__cil_tmp27 != 0) {
    {
#line 774
    zip_error_set(error, 21, 0);
    }
#line 775
    if (free_buffer) {
      {
#line 776
      _zip_buffer_free(buffer);
      }
    }
#line 778
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 781
  size = _zip_buffer_get_64(buffer);
  }
#line 783
  if (flags & 4U) {
#line 783
    if ((size + eocd_offset) + 12UL != buf_offset + eocdloc_offset) {
      {
#line 784
      zip_error_set(error, 21, 0);
      }
#line 785
      if (free_buffer) {
        {
#line 786
        _zip_buffer_free(buffer);
        }
      }
#line 788
      return ((zip_cdir_t *)((void *)0));
    }
  }
  {
#line 791
  _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 793
  num_disks64 = _zip_buffer_get_32(buffer);
#line 794
  eocd_disk64 = _zip_buffer_get_32(buffer);
  }
#line 799
  if (num_disks == 65535U) {
#line 800
    num_disks = num_disks64;
  }
#line 802
  if (eocd_disk == 65535U) {
#line 803
    eocd_disk = eocd_disk64;
  }
#line 805
  if (flags & 4U) {
#line 805
    if (eocd_disk != eocd_disk64) {
      _L___9: 
      {
#line 806
      zip_error_set(error, 21, 0);
      }
#line 807
      if (free_buffer) {
        {
#line 808
        _zip_buffer_free(buffer);
        }
      }
#line 810
      return ((zip_cdir_t *)((void *)0));
    } else
#line 805
    if (num_disks != num_disks64) {
#line 805
      goto _L___9;
    }
  }
#line 812
  if (num_disks != 0U) {
    _L___10: 
    {
#line 813
    zip_error_set(error, 1, 0);
    }
#line 814
    if (free_buffer) {
      {
#line 815
      _zip_buffer_free(buffer);
      }
    }
#line 817
    return ((zip_cdir_t *)((void *)0));
  } else
#line 812
  if (eocd_disk != 0U) {
#line 812
    goto _L___10;
  }
  {
#line 820
  nentry = _zip_buffer_get_64(buffer);
#line 821
  i = _zip_buffer_get_64(buffer);
  }
#line 823
  if (nentry != i) {
    {
#line 824
    zip_error_set(error, 1, 0);
    }
#line 825
    if (free_buffer) {
      {
#line 826
      _zip_buffer_free(buffer);
      }
    }
#line 828
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 831
  size = _zip_buffer_get_64(buffer);
#line 832
  offset = _zip_buffer_get_64(buffer);
#line 834
  __cil_tmp35 = _zip_buffer_ok(buffer);
  }
#line 834
  if (! __cil_tmp35) {
    {
#line 835
    zip_error_set(error, 20, 0);
    }
#line 836
    if (free_buffer) {
      {
#line 837
      _zip_buffer_free(buffer);
      }
    }
#line 839
    return ((zip_cdir_t *)((void *)0));
  }
#line 842
  if (free_buffer) {
    {
#line 843
    _zip_buffer_free(buffer);
    }
  }
#line 846
  if (offset > 0xffffffffffffffffUL) {
    {
#line 847
    zip_error_set(error, 4, 27);
    }
#line 848
    return ((zip_cdir_t *)((void *)0));
  } else
#line 846
  if (offset + size < offset) {
    {
#line 847
    zip_error_set(error, 4, 27);
    }
#line 848
    return ((zip_cdir_t *)((void *)0));
  }
#line 855
  if (flags & 4U) {
#line 855
    if (offset + size != eocd_offset) {
      {
#line 856
      zip_error_set(error, 21, 0);
      }
#line 857
      return ((zip_cdir_t *)((void *)0));
    }
  }
  {
#line 860
  cd = _zip_cdir_new(nentry, error);
  }
#line 860
  if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 861
    return ((zip_cdir_t *)((void *)0));
  }
#line 863
  cd->is_zip64 = 1;
#line 864
  cd->size = size;
#line 865
  cd->offset = offset;
#line 867
  return (cd);
}
}
#line 45 "/root/patchweave_new/24/lib/zip_new.c"
zip_t *_zip_new(zip_error_t *error ) 
{ 
  zip_t *za___0 ;
  void *__cil_tmp3 ;

  {
  {
#line 49
  __cil_tmp3 = malloc(sizeof(struct zip ));
#line 49
  za___0 = (zip_t *)__cil_tmp3;
  }
#line 50
  if (! za___0) {
    {
#line 51
    zip_error_set(error, 14, 0);
    }
#line 52
    return ((zip_t *)((void *)0));
  }
  {
#line 55
  za___0->names = _zip_hash_new(error);
  }
#line 55
  if ((unsigned long )za___0->names == (unsigned long )((void *)0)) {
    {
#line 56
    free((void *)za___0);
    }
#line 57
    return ((zip_t *)((void *)0));
  }
  {
#line 60
  za___0->src = (zip_source_t *)((void *)0);
#line 61
  za___0->open_flags = 0U;
#line 62
  zip_error_init(& za___0->error);
#line 63
  za___0->ch_flags = 0U;
#line 63
  za___0->flags = za___0->ch_flags;
#line 64
  za___0->default_password = (char *)((void *)0);
#line 65
  za___0->comment_changes = (zip_string_t *)((void *)0);
#line 65
  za___0->comment_orig = za___0->comment_changes;
#line 66
  za___0->comment_changed = 0;
#line 67
  za___0->nentry_alloc = (zip_uint64_t )0;
#line 67
  za___0->nentry = za___0->nentry_alloc;
#line 68
  za___0->entry = (zip_entry_t *)((void *)0);
#line 69
  za___0->nopen_source_alloc = 0U;
#line 69
  za___0->nopen_source = za___0->nopen_source_alloc;
#line 70
  za___0->open_source = (zip_source_t **)((void *)0);
#line 71
  za___0->progress = (zip_progress_t *)((void *)0);
  }
#line 73
  return (za___0);
}
}
#line 44 "/root/patchweave_new/24/lib/zip_name_locate.c"
zip_int64_t zip_name_locate(zip_t *za___0 , char const   *fname , zip_flags_t flags ) 
{ 
  zip_int64_t __cil_tmp4 ;

  {
  {
#line 46
  __cil_tmp4 = _zip_name_locate(za___0, fname, flags, & za___0->error);
  }
#line 46
  return (__cil_tmp4);
}
}
#line 51 "/root/patchweave_new/24/lib/zip_name_locate.c"
zip_int64_t _zip_name_locate(zip_t *za___0 , char const   *fname , zip_flags_t flags ,
                             zip_error_t *error ) 
{ 
  int (*cmp)(char const   * , char const   * ) ;
  char const   *fn ;
  char const   *p ;
  zip_uint64_t i ;
  int (*tmp)(char const   *__s1 , char const   *__s2 ) ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  zip_int64_t __cil_tmp14 ;

  {
#line 57
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 58
    return ((zip_int64_t )-1);
  }
#line 60
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    {
#line 61
    zip_error_set(error, 18, 0);
    }
#line 62
    return ((zip_int64_t )-1);
  }
#line 65
  if (flags & 4099U) {
#line 67
    if (flags & 1U) {
#line 67
      tmp = & strcasecmp;
    } else {
#line 67
      tmp = & strcmp;
    }
#line 67
    cmp = tmp;
#line 69
    i = (zip_uint64_t )0;
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: ;
#line 69
      if (! (i < za___0->nentry)) {
#line 69
        goto while_break;
      }
      {
#line 70
      fn = _zip_get_name(za___0, i, flags, error);
      }
#line 73
      if ((unsigned long )fn == (unsigned long )((void *)0)) {
#line 74
        goto while_continue;
      }
#line 76
      if (flags & 2U) {
        {
#line 77
        __cil_tmp11 = strrchr(fn, '/');
#line 77
        p = (char const   *)__cil_tmp11;
        }
#line 78
        if (p) {
#line 79
          fn = p + 1;
        }
      }
      {
#line 82
      __cil_tmp12 = (*cmp)(fname, fn);
      }
#line 82
      if (__cil_tmp12 == 0) {
        {
#line 83
        _zip_error_clear(error);
        }
#line 84
        return ((zip_int64_t )i);
      }
#line 69
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 88
    zip_error_set(error, 9, 0);
    }
#line 89
    return ((zip_int64_t )-1);
  } else {
    {
#line 92
    __cil_tmp14 = _zip_hash_lookup(za___0->names, (zip_uint8_t *)fname, flags, error);
    }
#line 92
    return (__cil_tmp14);
  }
}
}
#line 41 "/root/patchweave_new/24/lib/zip_memdup.c"
void *_zip_memdup(void const   *mem , size_t len , zip_error_t *error ) 
{ 
  void *ret ;

  {
#line 45
  if (len == 0UL) {
#line 46
    return ((void *)0);
  }
  {
#line 48
  ret = malloc(len);
  }
#line 49
  if (! ret) {
    {
#line 50
    zip_error_set(error, 14, 0);
    }
#line 51
    return ((void *)0);
  }
  {
#line 54
  memcpy(ret, mem, len);
  }
#line 56
  return (ret);
}
}
#line 40 "/root/patchweave_new/24/lib/zip_io_util.c"
int _zip_read(zip_source_t *src , zip_uint8_t *b , zip_uint64_t length , zip_error_t *error ) 
{ 
  zip_int64_t n ;

  {
#line 44
  if (length > 0xffffffffffffffffUL) {
    {
#line 45
    zip_error_set(error, 20, 0);
    }
#line 46
    return (-1);
  }
  {
#line 49
  n = zip_source_read(src, (void *)b, length);
  }
#line 49
  if (n < 0L) {
    {
#line 50
    _zip_error_set_from_source(error, src);
    }
#line 51
    return (-1);
  }
#line 54
  if (n < (zip_int64_t )length) {
    {
#line 55
    zip_error_set(error, 17, 0);
    }
#line 56
    return (-1);
  }
#line 59
  return (0);
}
}
#line 64 "/root/patchweave_new/24/lib/zip_io_util.c"
zip_uint8_t *_zip_read_data(zip_buffer_t *buffer , zip_source_t *src , size_t length ,
                            int nulp , zip_error_t *error ) 
{ 
  zip_uint8_t *r ;
  int tmp ;
  void *__cil_tmp8 ;
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  zip_uint8_t *o ;

  {
#line 68
  if (length == 0UL) {
#line 68
    if (! nulp) {
#line 69
      return ((zip_uint8_t *)((void *)0));
    }
  }
#line 72
  if (nulp) {
#line 72
    tmp = 1;
  } else {
#line 72
    tmp = 0;
  }
  {
#line 72
  __cil_tmp8 = malloc(length + (unsigned long )tmp);
#line 72
  r = (zip_uint8_t *)__cil_tmp8;
  }
#line 73
  if (! r) {
    {
#line 74
    zip_error_set(error, 14, 0);
    }
#line 75
    return ((zip_uint8_t *)((void *)0));
  }
#line 78
  if (buffer) {
    {
#line 79
    __cil_tmp10 = _zip_buffer_get(buffer, length);
#line 79
    data = __cil_tmp10;
    }
#line 81
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      {
#line 82
      zip_error_set(error, 14, 0);
#line 83
      free((void *)r);
      }
#line 84
      return ((zip_uint8_t *)((void *)0));
    }
    {
#line 86
    memcpy((void *)r, (void const   *)data, length);
    }
  } else {
    {
#line 89
    __cil_tmp11 = _zip_read(src, r, length, error);
    }
#line 89
    if (__cil_tmp11 < 0) {
      {
#line 90
      free((void *)r);
      }
#line 91
      return ((zip_uint8_t *)((void *)0));
    }
  }
#line 95
  if (nulp) {
#line 98
    *(r + length) = (zip_uint8_t )0;
#line 99
    o = r;
    {
#line 99
    while (1) {
      while_continue: /* CIL Label */ ;

#line 99
      if (! ((unsigned long )o < (unsigned long )(r + length))) {
#line 99
        goto while_break;
      }
#line 100
      if ((int )*o == 0) {
#line 101
        *o = (zip_uint8_t )' ';
      }
#line 99
      o ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 104
  return (r);
}
}
#line 109 "/root/patchweave_new/24/lib/zip_io_util.c"
zip_string_t *_zip_read_string(zip_buffer_t *buffer , zip_source_t *src , zip_uint16_t len ,
                               int nulp , zip_error_t *error ) 
{ 
  zip_uint8_t *raw ;
  zip_string_t *s ;

  {
  {
#line 114
  raw = _zip_read_data(buffer, src, (size_t )len, nulp, error);
  }
#line 114
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
#line 115
    return ((zip_string_t *)((void *)0));
  }
  {
#line 117
  s = _zip_string_new(raw, len, 0U, error);
#line 118
  free((void *)raw);
  }
#line 119
  return (s);
}
}
#line 124 "/root/patchweave_new/24/lib/zip_io_util.c"
int _zip_write(zip_t *za___0 , void const   *data , zip_uint64_t length ) 
{ 
  zip_int64_t n ;

  {
  {
#line 128
  n = zip_source_write(za___0->src, data, length);
  }
#line 128
  if (n < 0L) {
    {
#line 129
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 130
    return (-1);
  }
#line 132
  if ((zip_uint64_t )n != length) {
    {
#line 133
    zip_error_set(& za___0->error, 6, 4);
    }
#line 134
    return (-1);
  }
#line 137
  return (0);
}
}
#line 68 "/root/patchweave_new/24/lib/zip_hash.c"
static void free_list(zip_hash_entry_t *entry ) 
{ 
  zip_hash_entry_t *next ;

  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;

#line 70
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 70
      goto while_break;
    }
    {
#line 71
    next = entry->next;
#line 72
    free((void *)entry);
#line 73
    entry = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 78
  return;
}
}
#line 80 "/root/patchweave_new/24/lib/zip_hash.c"
static zip_uint32_t hash_string(zip_uint8_t *name ) 
{ 
  zip_uint64_t value ;

  {
#line 82
  value = (zip_uint64_t )5381;
#line 84
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 85
    return ((zip_uint32_t )0);
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;

#line 88
    if (! ((int )*name != 0)) {
#line 88
      goto while_break;
    }
#line 89
    value = (value * 33UL + (unsigned long )*name) % 4294967296UL;
#line 90
    name ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 93
  return ((zip_uint32_t )value);
}
}
#line 99 "/root/patchweave_new/24/lib/zip_hash.c"
static int hash_resize(zip_hash_t *hash , zip_uint32_t new_size , zip_error_t *error ) 
{ 
  zip_hash_entry_t **new_table ;
  void *__cil_tmp5 ;
  zip_uint32_t i ;
  zip_hash_entry_t *entry ;
  zip_hash_entry_t *next ;
  zip_uint32_t new_index ;

  {
#line 103
  if (new_size == hash->table_size) {
#line 104
    return (1);
  }
  {
#line 107
  __cil_tmp5 = calloc((unsigned long )new_size, sizeof(zip_hash_entry_t *));
#line 107
  new_table = (zip_hash_entry_t **)__cil_tmp5;
  }
#line 107
  if ((unsigned long )new_table == (unsigned long )((void *)0)) {
    {
#line 108
    zip_error_set(error, 14, 0);
    }
#line 109
    return (0);
  }
#line 112
  if (hash->nentries > 0UL) {
#line 115
    i = (zip_uint32_t )0;
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;

#line 115
      if (! (i < hash->table_size)) {
#line 115
        goto while_break;
      }
#line 116
      entry = *(hash->table + i);
      {
#line 117
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 117
        if (! entry) {
#line 117
          goto while_break___0;
        }
#line 118
        next = entry->next;
#line 120
        new_index = entry->hash_value % new_size;
#line 122
        entry->next = *(new_table + new_index);
#line 123
        *(new_table + new_index) = entry;
#line 125
        entry = next;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 115
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 130
  free((void *)hash->table);
#line 131
  hash->table = new_table;
#line 132
  hash->table_size = new_size;
  }
#line 134
  return (1);
}
}
#line 139 "/root/patchweave_new/24/lib/zip_hash.c"
static zip_uint32_t size_for_capacity(zip_uint64_t capacity ) 
{ 
  double needed_size ;
  zip_uint32_t v ;
  zip_uint32_t __cil_tmp4 ;

  {
#line 140
  needed_size = (double )capacity / 0.75;
#line 143
  if (needed_size > (double )4294967295U) {
#line 144
    v = 4294967295U;
  } else {
#line 147
    v = (zip_uint32_t )needed_size;
  }
#line 150
  if ((unsigned long )v > 2147483648UL) {
#line 151
    return ((zip_uint32_t )2147483648UL);
  }
#line 157
  __cil_tmp4 = v;
#line 157
  v --;
#line 158
  v |= v >> 1;
#line 159
  v |= v >> 2;
#line 160
  v |= v >> 4;
#line 161
  v |= v >> 8;
#line 162
  v |= v >> 16;
#line 163
  v ++;
#line 165
  return (v);
}
}
#line 170 "/root/patchweave_new/24/lib/zip_hash.c"
zip_hash_t *_zip_hash_new(zip_error_t *error ) 
{ 
  zip_hash_t *hash ;
  void *__cil_tmp3 ;

  {
  {
#line 174
  __cil_tmp3 = malloc(sizeof(zip_hash_t ));
#line 174
  hash = (zip_hash_t *)__cil_tmp3;
  }
#line 174
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
    {
#line 175
    zip_error_set(error, 14, 0);
    }
#line 176
    return ((zip_hash_t *)((void *)0));
  }
#line 179
  hash->table_size = (zip_uint32_t )0;
#line 180
  hash->nentries = (zip_uint64_t )0;
#line 181
  hash->table = (zip_hash_entry_t **)((void *)0);
#line 183
  return (hash);
}
}
#line 188 "/root/patchweave_new/24/lib/zip_hash.c"
void _zip_hash_free(zip_hash_t *hash ) 
{ 
  zip_uint32_t i ;

  {
#line 192
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
#line 193
    return;
  }
#line 196
  if ((unsigned long )hash->table != (unsigned long )((void *)0)) {
#line 197
    i = (zip_uint32_t )0;
    {
#line 197
    while (1) {
      while_continue: /* CIL Label */ ;

#line 197
      if (! (i < hash->table_size)) {
#line 197
        goto while_break;
      }
#line 198
      if ((unsigned long )*(hash->table + i) != (unsigned long )((void *)0)) {
        {
#line 199
        free_list(*(hash->table + i));
        }
      }
#line 197
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 202
    free((void *)hash->table);
    }
  }
  {
#line 204
  free((void *)hash);
  }
#line 206
  return;
}
}
#line 210 "/root/patchweave_new/24/lib/zip_hash.c"
int _zip_hash_add(zip_hash_t *hash , zip_uint8_t *name , zip_uint64_t index___0 ,
                  zip_flags_t flags , zip_error_t *error ) 
{ 
  zip_uint32_t hash_value ;
  zip_uint32_t table_index ;
  zip_hash_entry_t *entry ;
  int __cil_tmp9 ;
  int __cil_tmp11 ;
  void *__cil_tmp12 ;
  int __cil_tmp14 ;

  {
#line 215
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
    {
#line 216
    zip_error_set(error, 18, 0);
    }
#line 217
    return (0);
  } else
#line 215
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 216
    zip_error_set(error, 18, 0);
    }
#line 217
    return (0);
  } else
#line 215
  if (index___0 > 0xffffffffffffffffUL) {
    {
#line 216
    zip_error_set(error, 18, 0);
    }
#line 217
    return (0);
  }
#line 220
  if (hash->table_size == 0U) {
    {
#line 221
    __cil_tmp9 = hash_resize(hash, (zip_uint32_t )256, error);
    }
#line 221
    if (! __cil_tmp9) {
#line 222
      return (0);
    }
  }
  {
#line 226
  hash_value = hash_string(name);
#line 227
  table_index = hash_value % hash->table_size;
#line 229
  entry = *(hash->table + table_index);
  }
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;

#line 229
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 229
      goto while_break;
    }
    {
#line 230
    __cil_tmp11 = strcmp((char const   *)name, (char const   *)entry->name);
    }
#line 230
    if (entry->hash_value == hash_value) {
#line 230
      if (__cil_tmp11 == 0) {
#line 231
        if (flags & 8U) {
#line 231
          if (entry->orig_index != -1L) {
            {
#line 232
            zip_error_set(error, 10, 0);
            }
#line 233
            return (0);
          } else {
#line 231
            goto _L;
          }
        } else
        _L: 
#line 231
        if (entry->current_index != -1L) {
          {
#line 232
          zip_error_set(error, 10, 0);
          }
#line 233
          return (0);
        } else {
#line 236
          goto while_break;
        }
      }
    }
#line 229
    entry = entry->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 241
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    {
#line 242
    __cil_tmp12 = malloc(sizeof(zip_hash_entry_t ));
#line 242
    entry = (zip_hash_entry_t *)__cil_tmp12;
    }
#line 242
    if ((unsigned long )entry == (unsigned long )((void *)0)) {
      {
#line 243
      zip_error_set(error, 14, 0);
      }
#line 244
      return (0);
    }
#line 246
    entry->name = name;
#line 247
    entry->next = *(hash->table + table_index);
#line 248
    *(hash->table + table_index) = entry;
#line 249
    entry->hash_value = hash_value;
#line 250
    entry->orig_index = (zip_int64_t )-1;
#line 251
    (hash->nentries) ++;
#line 252
    if ((double )hash->nentries > (double )hash->table_size * 0.75) {
#line 252
      if ((unsigned long )hash->table_size < 2147483648UL) {
        {
#line 253
        __cil_tmp14 = hash_resize(hash, hash->table_size * 2U, error);
        }
#line 253
        if (! __cil_tmp14) {
#line 254
          return (0);
        }
      }
    }
  }
#line 259
  if (flags & 8U) {
#line 260
    entry->orig_index = (zip_int64_t )index___0;
  }
#line 262
  entry->current_index = (zip_int64_t )index___0;
#line 264
  return (1);
}
}
#line 270 "/root/patchweave_new/24/lib/zip_hash.c"
int _zip_hash_delete(zip_hash_t *hash , zip_uint8_t *name , zip_error_t *error ) 
{ 
  zip_uint32_t hash_value ;
  zip_uint32_t index___11 ;
  zip_hash_entry_t *entry ;
  zip_hash_entry_t *previous ;
  int __cil_tmp9 ;
  zip_uint64_t __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 275
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
    {
#line 276
    zip_error_set(error, 18, 0);
    }
#line 277
    return (0);
  } else
#line 275
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 276
    zip_error_set(error, 18, 0);
    }
#line 277
    return (0);
  }
#line 280
  if (hash->nentries > 0UL) {
    {
#line 281
    hash_value = hash_string(name);
#line 282
    index___11 = hash_value % hash->table_size;
#line 283
    previous = (zip_hash_entry_t *)((void *)0);
#line 284
    entry = *(hash->table + index___11);
    }
    {
#line 285
    while (1) {
      while_continue: /* CIL Label */ ;

#line 285
      if (! entry) {
#line 285
        goto while_break;
      }
      {
#line 286
      __cil_tmp9 = strcmp((char const   *)name, (char const   *)entry->name);
      }
#line 286
      if (entry->hash_value == hash_value) {
#line 286
        if (__cil_tmp9 == 0) {
#line 287
          if (entry->orig_index == -1L) {
#line 288
            if (previous) {
#line 289
              previous->next = entry->next;
            } else {
#line 292
              *(hash->table + index___11) = entry->next;
            }
            {
#line 294
            free((void *)entry);
#line 295
            __cil_tmp10 = hash->nentries;
#line 295
            (hash->nentries) --;
            }
#line 296
            if ((double )hash->nentries < (double )hash->table_size * 0.0100000000001) {
#line 296
              if (hash->table_size > 256U) {
                {
#line 297
                __cil_tmp11 = hash_resize(hash, hash->table_size / 2U, error);
                }
#line 297
                if (! __cil_tmp11) {
#line 298
                  return (0);
                }
              }
            }
          } else {
#line 303
            entry->current_index = (zip_int64_t )-1;
          }
#line 305
          return (1);
        }
      }
#line 307
      previous = entry;
#line 308
      entry = entry->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 312
  zip_error_set(error, 9, 0);
  }
#line 313
  return (0);
}
}
#line 319 "/root/patchweave_new/24/lib/zip_hash.c"
zip_int64_t _zip_hash_lookup(zip_hash_t *hash , zip_uint8_t *name , zip_flags_t flags ,
                             zip_error_t *error ) 
{ 
  zip_uint32_t hash_value ;
  zip_uint32_t index___12 ;
  zip_hash_entry_t *entry ;
  int __cil_tmp9 ;

  {
#line 324
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
    {
#line 325
    zip_error_set(error, 18, 0);
    }
#line 326
    return ((zip_int64_t )-1);
  } else
#line 324
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 325
    zip_error_set(error, 18, 0);
    }
#line 326
    return ((zip_int64_t )-1);
  }
#line 329
  if (hash->nentries > 0UL) {
    {
#line 330
    hash_value = hash_string(name);
#line 331
    index___12 = hash_value % hash->table_size;
#line 332
    entry = *(hash->table + index___12);
    }
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;

#line 332
      if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 332
        goto while_break;
      }
      {
#line 333
      __cil_tmp9 = strcmp((char const   *)name, (char const   *)entry->name);
      }
#line 333
      if (__cil_tmp9 == 0) {
#line 334
        if (flags & 8U) {
#line 335
          if (entry->orig_index != -1L) {
#line 336
            return (entry->orig_index);
          }
        } else
#line 340
        if (entry->current_index != -1L) {
#line 341
          return (entry->current_index);
        }
#line 344
        goto while_break;
      }
#line 332
      entry = entry->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 349
  zip_error_set(error, 9, 0);
  }
#line 350
  return ((zip_int64_t )-1);
}
}
#line 355 "/root/patchweave_new/24/lib/zip_hash.c"
int _zip_hash_reserve_capacity(zip_hash_t *hash , zip_uint64_t capacity , zip_error_t *error ) 
{ 
  zip_uint32_t new_size ;
  int __cil_tmp6 ;

  {
#line 359
  if (capacity == 0UL) {
#line 360
    return (1);
  }
  {
#line 363
  new_size = size_for_capacity(capacity);
  }
#line 365
  if (new_size <= hash->table_size) {
#line 366
    return (1);
  }
  {
#line 369
  __cil_tmp6 = hash_resize(hash, new_size, error);
  }
#line 369
  if (! __cil_tmp6) {
#line 370
    return (0);
  }
#line 373
  return (1);
}
}
#line 378 "/root/patchweave_new/24/lib/zip_hash.c"
int _zip_hash_revert(zip_hash_t *hash , zip_error_t *error ) 
{ 
  zip_uint32_t i ;
  zip_hash_entry_t *entry ;
  zip_hash_entry_t *previous ;
  zip_hash_entry_t *p ;
  zip_uint64_t __cil_tmp7 ;
  zip_uint32_t new_size ;
  int __cil_tmp10 ;

  {
#line 383
  i = (zip_uint32_t )0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;

#line 383
    if (! (i < hash->table_size)) {
#line 383
      goto while_break;
    }
#line 384
    previous = (zip_hash_entry_t *)((void *)0);
#line 385
    entry = *(hash->table + i);
    {
#line 386
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 386
      if (! entry) {
#line 386
        goto while_break___0;
      }
#line 387
      if (entry->orig_index == -1L) {
#line 389
        if (previous) {
#line 390
          previous->next = entry->next;
        } else {
#line 393
          *(hash->table + i) = entry->next;
        }
        {
#line 395
        p = entry;
#line 396
        entry = entry->next;
#line 398
        free((void *)p);
#line 399
        __cil_tmp7 = hash->nentries;
#line 399
        (hash->nentries) --;
        }
      } else {
#line 402
        entry->current_index = entry->orig_index;
#line 403
        previous = entry;
#line 404
        entry = entry->next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 383
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 409
  if ((double )hash->nentries < (double )hash->table_size * 0.0100000000001) {
#line 409
    if (hash->table_size > 256U) {
#line 410
      new_size = hash->table_size / 2U;
      {
#line 411
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 411
        if ((double )hash->nentries < (double )new_size * 0.0100000000001) {
#line 411
          if (! (new_size > 256U)) {
#line 411
            goto while_break___1;
          }
        } else {
#line 411
          goto while_break___1;
        }
#line 412
        new_size /= 2U;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 414
      __cil_tmp10 = hash_resize(hash, new_size, error);
      }
#line 414
      if (! __cil_tmp10) {
#line 415
        return (0);
      }
    }
  }
#line 419
  return (1);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_get_name.c"
char const   *zip_get_name(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ) 
{ 
  char const   *__cil_tmp4 ;

  {
  {
#line 43
  __cil_tmp4 = _zip_get_name(za___0, idx, flags, & za___0->error);
  }
#line 43
  return (__cil_tmp4);
}
}
#line 48 "/root/patchweave_new/24/lib/zip_get_name.c"
char const   *_zip_get_name(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                            zip_error_t *error ) 
{ 
  zip_dirent_t *de ;
  zip_uint8_t *str ;

  {
  {
#line 53
  de = _zip_get_dirent(za___0, idx, flags, error);
  }
#line 53
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 54
    return ((char const   *)((void *)0));
  }
  {
#line 56
  str = _zip_string_get(de->filename, (zip_uint32_t *)((void *)0), flags, error);
  }
#line 56
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 57
    return ((char const   *)((void *)0));
  }
#line 59
  return ((char const   *)str);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_get_num_files.c"
int zip_get_num_files(zip_t *za___0 ) 
{ 


  {
#line 43
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 44
    return (-1);
  }
#line 46
  if (za___0->nentry > 2147483647UL) {
    {
#line 47
    zip_error_set(& za___0->error, 28, 0);
    }
#line 48
    return (-1);
  }
#line 51
  return ((int )za___0->nentry);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_get_num_entries.c"
zip_int64_t zip_get_num_entries(zip_t *za___0 , zip_flags_t flags ) 
{ 
  zip_uint64_t n ;

  {
#line 43
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 44
    return ((zip_int64_t )-1);
  }
#line 46
  if (flags & 8U) {
#line 47
    n = za___0->nentry;
    {
#line 48
    while (1) {
      while_continue: /* CIL Label */ ;

#line 48
      if ((unsigned long )(za___0->entry + (n - 1UL))->orig == (unsigned long )((void *)0)) {
#line 48
        if (! (n > 0UL)) {
#line 48
          goto while_break;
        }
      } else {
#line 48
        goto while_break;
      }
#line 49
      n --;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 50
    return ((zip_int64_t )n);
  }
#line 52
  return ((zip_int64_t )za___0->nentry);
}
}
#line 40 "/root/patchweave_new/24/lib/zip_get_file_comment.c"
char const   *zip_get_file_comment(zip_t *za___0 , zip_uint64_t idx , int *lenp ,
                                   int flags ) 
{ 
  zip_uint32_t len ;
  char const   *s ;

  {
  {
#line 45
  s = zip_file_get_comment(za___0, idx, & len, (zip_flags_t )flags);
  }
#line 45
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 46
    if (lenp) {
#line 47
      *lenp = (int )len;
    }
  }
#line 50
  return (s);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_get_encryption_implementation.c"
zip_encryption_implementation _zip_get_encryption_implementation(zip_uint16_t em ,
                                                                 int operation ) 
{ 
  zip_source_t *(*tmp)(zip_t * , zip_source_t * , zip_uint16_t  , int  , char const   * ) ;

  {
#line 42
  if ((int )em == 1) {
#line 42
    goto case_1;
  }
#line 50
  if ((int )em == 259) {
#line 50
    goto case_259;
  }
#line 50
  if ((int )em == 258) {
#line 50
    goto case_259;
  }
#line 50
  if ((int )em == 257) {
#line 50
    goto case_259;
  }
#line 53
  goto switch_default;
  case_1: 
#line 43
  if (operation == 1) {
#line 44
    return ((zip_source_t *(*)(zip_t * , zip_source_t * , zip_uint16_t  , int  , char const   * ))((void *)0));
  }
#line 46
  return (& zip_source_pkware);
  case_259: 
#line 51
  if (operation == 0) {
#line 51
    tmp = & zip_source_winzip_aes_decode;
  } else {
#line 51
    tmp = & zip_source_winzip_aes_encode;
  }
#line 51
  return (tmp);
  switch_default: 
#line 54
  return ((zip_source_t *(*)(zip_t * , zip_source_t * , zip_uint16_t  , int  , char const   * ))((void *)0));

#line 58
  return ((zip_source_t *(*)(zip_t * , zip_source_t * , zip_uint16_t  , int  , char const   * ))0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_get_archive_flag.c"
int zip_get_archive_flag(zip_t *za___0 , zip_flags_t flag , zip_flags_t flags ) 
{ 
  unsigned int fl ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 43
  if (flags & 8U) {
#line 43
    tmp = za___0->flags;
  } else {
#line 43
    tmp = za___0->ch_flags;
  }
#line 43
  fl = tmp;
#line 45
  if (fl & flag) {
#line 45
    tmp___0 = 1;
  } else {
#line 45
    tmp___0 = 0;
  }
#line 45
  return (tmp___0);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_get_archive_comment.c"
char const   *zip_get_archive_comment(zip_t *za___0 , int *lenp , zip_flags_t flags ) 
{ 
  zip_string_t *comment ;
  zip_uint32_t len ;
  zip_uint8_t *str ;

  {
#line 47
  if ((unsigned long )za___0->comment_changes == (unsigned long )((void *)0)) {
#line 48
    comment = za___0->comment_orig;
  } else
#line 47
  if (flags & 8U) {
#line 48
    comment = za___0->comment_orig;
  } else {
#line 50
    comment = za___0->comment_changes;
  }
  {
#line 52
  str = _zip_string_get(comment, & len, flags, & za___0->error);
  }
#line 52
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 53
    return ((char const   *)((void *)0));
  }
#line 55
  if (lenp) {
#line 56
    *lenp = (int )len;
  }
#line 58
  return ((char const   *)str);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_ftell.c"
zip_int64_t zip_ftell(zip_file_t *zf ) 
{ 
  zip_int64_t res ;

  {
#line 43
  if (! zf) {
#line 44
    return ((zip_int64_t )-1);
  }
#line 46
  if (zf->error.zip_err != 0) {
#line 47
    return ((zip_int64_t )-1);
  }
  {
#line 49
  res = zip_source_tell(zf->src);
  }
#line 50
  if (res < 0L) {
    {
#line 51
    _zip_error_set_from_source(& zf->error, zf->src);
    }
#line 52
    return ((zip_int64_t )-1);
  }
#line 55
  return (res);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_fseek.c"
zip_int8_t zip_fseek(zip_file_t *zf , zip_int64_t offset , int whence ) 
{ 
  int __cil_tmp4 ;

  {
#line 42
  if (! zf) {
#line 43
    return ((zip_int8_t )-1);
  }
#line 45
  if (zf->error.zip_err != 0) {
#line 46
    return ((zip_int8_t )-1);
  }
  {
#line 48
  __cil_tmp4 = zip_source_seek(zf->src, offset, whence);
  }
#line 48
  if (__cil_tmp4 < 0) {
    {
#line 49
    _zip_error_set_from_source(& zf->error, zf->src);
    }
#line 50
    return ((zip_int8_t )-1);
  }
#line 53
  return ((zip_int8_t )0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_fread.c"
zip_int64_t zip_fread(zip_file_t *zf , void *outbuf , zip_uint64_t toread ) 
{ 
  zip_int64_t n ;

  {
#line 43
  if (! zf) {
#line 44
    return ((zip_int64_t )-1);
  }
#line 46
  if (zf->error.zip_err != 0) {
#line 47
    return ((zip_int64_t )-1);
  }
#line 49
  if (toread > 0xffffffffffffffffUL) {
    {
#line 50
    zip_error_set(& zf->error, 18, 0);
    }
#line 51
    return ((zip_int64_t )-1);
  }
#line 54
  if (zf->eof) {
#line 55
    return ((zip_int64_t )0);
  } else
#line 54
  if (toread == 0UL) {
#line 55
    return ((zip_int64_t )0);
  }
  {
#line 57
  n = zip_source_read(zf->src, outbuf, toread);
  }
#line 57
  if (n < 0L) {
    {
#line 58
    _zip_error_set_from_source(& zf->error, zf->src);
    }
#line 59
    return ((zip_int64_t )-1);
  }
#line 62
  return (n);
}
}
#line 40 "/root/patchweave_new/24/lib/zip_fopen_index_encrypted.c"
static zip_file_t *_zip_file_new(zip_t *za___0 ) ;
#line 44 "/root/patchweave_new/24/lib/zip_fopen_index_encrypted.c"
zip_file_t *zip_fopen_index_encrypted(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags ,
                                      char const   *password ) 
{ 
  zip_file_t *zf ;
  zip_source_t *src ;
  int __cil_tmp8 ;

  {
  {
#line 50
  src = _zip_source_zip_new(za___0, za___0, index___0, flags, (zip_uint64_t )0, (zip_uint64_t )0,
                            password);
  }
#line 50
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 51
    return ((zip_file_t *)((void *)0));
  }
  {
#line 53
  __cil_tmp8 = zip_source_open(src);
  }
#line 53
  if (__cil_tmp8 < 0) {
    {
#line 54
    _zip_error_set_from_source(& za___0->error, src);
#line 55
    zip_source_free(src);
    }
#line 56
    return ((zip_file_t *)((void *)0));
  }
  {
#line 59
  zf = _zip_file_new(za___0);
  }
#line 59
  if ((unsigned long )zf == (unsigned long )((void *)0)) {
    {
#line 60
    zip_source_free(src);
    }
#line 61
    return ((zip_file_t *)((void *)0));
  }
#line 64
  zf->src = src;
#line 66
  return (zf);
}
}
#line 71 "/root/patchweave_new/24/lib/zip_fopen_index_encrypted.c"
static zip_file_t *_zip_file_new(zip_t *za___0 ) 
{ 
  zip_file_t *zf ;
  void *__cil_tmp3 ;

  {
  {
#line 75
  __cil_tmp3 = malloc(sizeof(struct zip_file ));
#line 75
  zf = (zip_file_t *)__cil_tmp3;
  }
#line 75
  if ((unsigned long )zf == (unsigned long )((void *)0)) {
    {
#line 76
    zip_error_set(& za___0->error, 14, 0);
    }
#line 77
    return ((zip_file_t *)((void *)0));
  }
  {
#line 80
  zf->za = za___0;
#line 81
  zip_error_init(& zf->error);
#line 82
  zf->eof = 0;
#line 83
  zf->src = (zip_source_t *)((void *)0);
  }
#line 85
  return (zf);
}
}
#line 42 "/root/patchweave_new/24/lib/zip_fopen_index.c"
zip_file_t *zip_fopen_index(zip_t *za___0 , zip_uint64_t index___0 , zip_flags_t flags ) 
{ 
  zip_file_t *__cil_tmp4 ;

  {
  {
#line 44
  __cil_tmp4 = zip_fopen_index_encrypted(za___0, index___0, flags, (char const   *)za___0->default_password);
  }
#line 44
  return (__cil_tmp4);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_fopen_encrypted.c"
zip_file_t *zip_fopen_encrypted(zip_t *za___0 , char const   *fname , zip_flags_t flags ,
                                char const   *password ) 
{ 
  zip_int64_t idx ;
  zip_file_t *__cil_tmp7 ;

  {
  {
#line 43
  idx = zip_name_locate(za___0, fname, flags);
  }
#line 43
  if (idx < 0L) {
#line 44
    return ((zip_file_t *)((void *)0));
  }
  {
#line 46
  __cil_tmp7 = zip_fopen_index_encrypted(za___0, (zip_uint64_t )idx, flags, password);
  }
#line 46
  return (__cil_tmp7);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_fopen.c"
zip_file_t *zip_fopen(zip_t *za___0 , char const   *fname , zip_flags_t flags ) 
{ 
  zip_int64_t idx ;
  zip_file_t *__cil_tmp6 ;

  {
  {
#line 43
  idx = zip_name_locate(za___0, fname, flags);
  }
#line 43
  if (idx < 0L) {
#line 44
    return ((zip_file_t *)((void *)0));
  }
  {
#line 46
  __cil_tmp6 = zip_fopen_index_encrypted(za___0, (zip_uint64_t )idx, flags, (char const   *)za___0->default_password);
  }
#line 46
  return (__cil_tmp6);
}
}
#line 42 "/root/patchweave_new/24/lib/zip_filerange_crc.c"
int _zip_filerange_crc(zip_source_t *src , zip_uint64_t start___0 , zip_uint64_t len ,
                       uLong *crcp , zip_error_t *error ) 
{ 
  Bytef buf[8192] ;
  zip_int64_t n ;
  int __cil_tmp9 ;
  unsigned long tmp ;

  {
  {
#line 47
  *crcp = crc32((uLong )0L, (Bytef *)0, (uInt )0);
  }
#line 49
  if (start___0 > 0xffffffffffffffffUL) {
    {
#line 50
    zip_error_set(error, 4, 27);
    }
#line 51
    return (-1);
  }
  {
#line 54
  __cil_tmp9 = zip_source_seek(src, (zip_int64_t )start___0, 0);
  }
#line 54
  if (__cil_tmp9 != 0) {
    {
#line 55
    _zip_error_set_from_source(error, src);
    }
#line 56
    return (-1);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;

#line 59
    if (! (len > 0UL)) {
#line 59
      goto while_break;
    }
#line 60
    if (len > 8192UL) {
#line 60
      tmp = 8192UL;
    } else {
#line 60
      tmp = len;
    }
    {
#line 60
    n = (zip_int64_t )tmp;
#line 61
    n = zip_source_read(src, (void *)(buf), (zip_uint64_t )n);
    }
#line 61
    if (n < 0L) {
      {
#line 62
      _zip_error_set_from_source(error, src);
      }
#line 63
      return (-1);
    }
#line 65
    if (n == 0L) {
      {
#line 66
      zip_error_set(error, 17, 0);
      }
#line 67
      return (-1);
    }
    {
#line 70
    *crcp = crc32(*crcp, buf, (uInt )n);
#line 72
    len -= (zip_uint64_t )n;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 75
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_file_strerror.c"
char const   *zip_file_strerror(zip_file_t *zf ) 
{ 
  char const   *__cil_tmp2 ;

  {
  {
#line 41
  __cil_tmp2 = zip_error_strerror(& zf->error);
  }
#line 41
  return (__cil_tmp2);
}
}
#line 36 "/root/patchweave_new/24/lib/zip_file_set_mtime.c"
int zip_file_set_mtime(zip_t *za___0 , zip_uint64_t idx , time_t mtime , zip_flags_t flags ) 
{ 
  zip_entry_t *e ;
  int changed ;
  zip_dirent_t *__cil_tmp7 ;
  int tmp ;

  {
  {
#line 41
  __cil_tmp7 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 41
  if ((unsigned long )__cil_tmp7 == (unsigned long )((void *)0)) {
#line 42
    return (-1);
  }
#line 44
  if (za___0->ch_flags & 2U) {
    {
#line 45
    zip_error_set(& za___0->error, 25, 0);
    }
#line 46
    return (-1);
  }
#line 49
  e = za___0->entry + idx;
#line 51
  if ((unsigned long )e->orig == (unsigned long )((void *)0)) {
#line 51
    tmp = 1;
  } else
#line 51
  if (mtime != (e->orig)->last_mod) {
#line 51
    tmp = 1;
  } else {
#line 51
    tmp = 0;
  }
#line 51
  changed = tmp;
#line 53
  if (changed) {
#line 54
    if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
      {
#line 55
      e->changes = _zip_dirent_clone(e->orig);
      }
#line 55
      if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
        {
#line 56
        zip_error_set(& za___0->error, 14, 0);
        }
#line 57
        return (-1);
      }
    }
#line 60
    (e->changes)->last_mod = mtime;
#line 61
    (e->changes)->changed |= 32U;
  } else
#line 64
  if (e->changes) {
#line 65
    (e->changes)->changed &= 4294967263U;
#line 66
    if ((e->changes)->changed == 0U) {
      {
#line 67
      _zip_dirent_free(e->changes);
#line 68
      e->changes = (zip_dirent_t *)((void *)0);
      }
    }
  }
#line 73
  return (0);
}
}
#line 37 "/root/patchweave_new/24/lib/zip_file_set_external_attributes.c"
int zip_file_set_external_attributes(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                                     zip_uint8_t opsys , zip_uint32_t attributes ) 
{ 
  zip_entry_t *e ;
  int changed ;
  zip_uint8_t unchanged_opsys ;
  zip_uint32_t unchanged_attributes ;
  zip_dirent_t *__cil_tmp10 ;
  int tmp ;
  zip_uint32_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 44
  __cil_tmp10 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 44
  if ((unsigned long )__cil_tmp10 == (unsigned long )((void *)0)) {
#line 45
    return (-1);
  }
#line 47
  if (za___0->ch_flags & 2U) {
    {
#line 48
    zip_error_set(& za___0->error, 25, 0);
    }
#line 49
    return (-1);
  }
#line 52
  e = za___0->entry + idx;
#line 54
  if (e->orig) {
#line 54
    tmp = (int )((zip_uint8_t )((int )(e->orig)->version_madeby >> 8));
  } else {
#line 54
    tmp = (int )((zip_uint8_t )3U);
  }
#line 54
  unchanged_opsys = (zip_uint8_t )tmp;
#line 55
  if (e->orig) {
#line 55
    tmp___0 = (e->orig)->ext_attrib;
  } else {
#line 55
    tmp___0 = 33206U << 16;
  }
#line 55
  unchanged_attributes = tmp___0;
#line 57
  if ((int )opsys != (int )unchanged_opsys) {
#line 57
    tmp___1 = 1;
  } else
#line 57
  if (attributes != unchanged_attributes) {
#line 57
    tmp___1 = 1;
  } else {
#line 57
    tmp___1 = 0;
  }
#line 57
  changed = tmp___1;
#line 59
  if (changed) {
#line 60
    if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
      {
#line 61
      e->changes = _zip_dirent_clone(e->orig);
      }
#line 61
      if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
        {
#line 62
        zip_error_set(& za___0->error, 14, 0);
        }
#line 63
        return (-1);
      }
    }
#line 66
    (e->changes)->version_madeby = (zip_uint16_t )(((int )opsys << 8) | ((int )(e->changes)->version_madeby & 255));
#line 67
    (e->changes)->ext_attrib = attributes;
#line 68
    (e->changes)->changed |= 16U;
  } else
#line 70
  if (e->changes) {
#line 71
    (e->changes)->changed &= 4294967279U;
#line 72
    if ((e->changes)->changed == 0U) {
      {
#line 73
      _zip_dirent_free(e->changes);
#line 74
      e->changes = (zip_dirent_t *)((void *)0);
      }
    } else {
#line 77
      (e->changes)->version_madeby = (zip_uint16_t )(((int )unchanged_opsys << 8) | ((int )(e->changes)->version_madeby & 255));
#line 78
      (e->changes)->ext_attrib = unchanged_attributes;
    }
  }
#line 82
  return (0);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_file_set_encryption.c"
int zip_file_set_encryption(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t method ,
                            char const   *password ) 
{ 
  zip_entry_t *e ;
  zip_uint16_t old_method ;
  zip_source_t *(*__cil_tmp7)(zip_t * , zip_source_t * , zip_uint16_t  , int  , char const   * ) ;
  int tmp ;
  unsigned long __cil_tmp9 ;
  char *tmp___0 ;
  char *our_password ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  char *tmp___1 ;

  {
#line 46
  if (idx >= za___0->nentry) {
    {
#line 47
    zip_error_set(& za___0->error, 18, 0);
    }
#line 48
    return (-1);
  }
#line 51
  if (za___0->ch_flags & 2U) {
    {
#line 52
    zip_error_set(& za___0->error, 25, 0);
    }
#line 53
    return (-1);
  }
  {
#line 56
  __cil_tmp7 = _zip_get_encryption_implementation(method, 1);
  }
#line 56
  if ((unsigned long )__cil_tmp7 == (unsigned long )((void *)0)) {
#line 56
    if ((int )method != 0) {
      {
#line 57
      zip_error_set(& za___0->error, 24, 0);
      }
#line 58
      return (-1);
    }
  }
#line 61
  e = za___0->entry + idx;
#line 63
  if ((unsigned long )e->orig == (unsigned long )((void *)0)) {
#line 63
    tmp = 0;
  } else {
#line 63
    tmp = (int )(e->orig)->encryption_method;
  }
#line 63
  old_method = (zip_uint16_t )tmp;
#line 65
  if ((unsigned long )password == (unsigned long )((void *)0)) {
#line 65
    if ((int )method == (int )old_method) {
#line 66
      if (e->changes) {
#line 67
        if ((e->changes)->changed & 128U) {
          {
#line 68
          __cil_tmp9 = strlen((char const   *)(e->changes)->password);
#line 68
          explicit_bzero((void *)(e->changes)->password, __cil_tmp9);
#line 69
          free((void *)(e->changes)->password);
          }
#line 70
          if ((unsigned long )e->orig == (unsigned long )((void *)0)) {
#line 70
            tmp___0 = (char *)((void *)0);
          } else {
#line 70
            tmp___0 = (e->orig)->password;
          }
#line 70
          (e->changes)->password = tmp___0;
        }
#line 72
        (e->changes)->changed &= 4294967103U;
#line 73
        if ((e->changes)->changed == 0U) {
          {
#line 74
          _zip_dirent_free(e->changes);
#line 75
          e->changes = (zip_dirent_t *)((void *)0);
          }
        }
      }
    } else {
#line 65
      goto _L;
    }
  } else {
    _L: 
#line 80
    our_password = (char *)((void *)0);
#line 82
    if (password) {
      {
#line 83
      our_password = strdup(password);
      }
#line 83
      if ((unsigned long )our_password == (unsigned long )((void *)0)) {
        {
#line 84
        zip_error_set(& za___0->error, 14, 0);
        }
#line 85
        return (-1);
      }
    }
#line 89
    if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
      {
#line 90
      e->changes = _zip_dirent_clone(e->orig);
      }
#line 90
      if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
#line 91
        if (our_password) {
          {
#line 92
          __cil_tmp14 = strlen((char const   *)our_password);
#line 92
          explicit_bzero((void *)our_password, __cil_tmp14);
          }
        }
        {
#line 94
        free((void *)our_password);
#line 95
        zip_error_set(& za___0->error, 14, 0);
        }
#line 96
        return (-1);
      }
    }
#line 100
    (e->changes)->encryption_method = method;
#line 101
    (e->changes)->changed |= 64U;
#line 102
    if (password) {
#line 103
      (e->changes)->password = our_password;
#line 104
      (e->changes)->changed |= 128U;
    } else
#line 107
    if ((e->changes)->changed & 128U) {
      {
#line 108
      __cil_tmp15 = strlen((char const   *)(e->changes)->password);
#line 108
      explicit_bzero((void *)(e->changes)->password, __cil_tmp15);
#line 109
      free((void *)(e->changes)->password);
      }
#line 110
      if (e->orig) {
#line 110
        tmp___1 = (e->orig)->password;
      } else {
#line 110
        tmp___1 = (char *)((void *)0);
      }
#line 110
      (e->changes)->password = tmp___1;
#line 111
      (e->changes)->changed &= 4294967167U;
    }
  }
#line 116
  return (0);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_file_set_comment.c"
int zip_file_set_comment(zip_t *za___0 , zip_uint64_t idx , char const   *comment ,
                         zip_uint16_t len , zip_flags_t flags ) 
{ 
  zip_entry_t *e ;
  zip_string_t *cstr ;
  int changed ;
  zip_dirent_t *__cil_tmp9 ;
  enum zip_encoding_type __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 48
  __cil_tmp9 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 48
  if ((unsigned long )__cil_tmp9 == (unsigned long )((void *)0)) {
#line 49
    return (-1);
  }
#line 51
  if (za___0->ch_flags & 2U) {
    {
#line 52
    zip_error_set(& za___0->error, 25, 0);
    }
#line 53
    return (-1);
  }
#line 56
  if ((unsigned long )comment == (unsigned long )((void *)0)) {
#line 56
    if ((int )len > 0) {
      {
#line 57
      zip_error_set(& za___0->error, 18, 0);
      }
#line 58
      return (-1);
    }
  }
#line 61
  if ((int )len > 0) {
    {
#line 62
    cstr = _zip_string_new((zip_uint8_t *)comment, len, flags, & za___0->error);
    }
#line 62
    if ((unsigned long )cstr == (unsigned long )((void *)0)) {
#line 63
      return (-1);
    }
    {
#line 64
    __cil_tmp11 = _zip_guess_encoding(cstr, (enum zip_encoding_type )0);
    }
#line 64
    if ((flags & 6144U) == 0U) {
#line 64
      if ((unsigned int )__cil_tmp11 == 3U) {
#line 65
        cstr->encoding = (enum zip_encoding_type )2;
      }
    }
  } else {
#line 68
    cstr = (zip_string_t *)((void *)0);
  }
#line 70
  e = za___0->entry + idx;
#line 72
  if (e->changes) {
    {
#line 73
    _zip_string_free((e->changes)->comment);
#line 74
    (e->changes)->comment = (zip_string_t *)((void *)0);
#line 75
    (e->changes)->changed &= 4294967291U;
    }
  }
#line 78
  if (e->orig) {
#line 78
    if ((e->orig)->comment) {
      {
#line 79
      __cil_tmp12 = _zip_string_equal((e->orig)->comment, cstr);
#line 79
      changed = ! __cil_tmp12;
      }
    } else {
#line 81
      changed = (unsigned long )cstr != (unsigned long )((void *)0);
    }
  } else {
#line 81
    changed = (unsigned long )cstr != (unsigned long )((void *)0);
  }
#line 83
  if (changed) {
#line 84
    if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
      {
#line 85
      e->changes = _zip_dirent_clone(e->orig);
      }
#line 85
      if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
        {
#line 86
        zip_error_set(& za___0->error, 14, 0);
#line 87
        _zip_string_free(cstr);
        }
#line 88
        return (-1);
      }
    }
#line 91
    (e->changes)->comment = cstr;
#line 92
    (e->changes)->changed |= 4U;
  } else {
    {
#line 95
    _zip_string_free(cstr);
    }
#line 96
    if (e->changes) {
#line 96
      if ((e->changes)->changed == 0U) {
        {
#line 97
        _zip_dirent_free(e->changes);
#line 98
        e->changes = (zip_dirent_t *)((void *)0);
        }
      }
    }
  }
#line 102
  return (0);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_file_replace.c"
int zip_file_replace(zip_t *za___0 , zip_uint64_t idx , zip_source_t *source , zip_flags_t flags ) 
{ 
  zip_int64_t __cil_tmp5 ;

  {
#line 41
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    {
#line 42
    zip_error_set(& za___0->error, 18, 0);
    }
#line 43
    return (-1);
  } else
#line 41
  if (idx >= za___0->nentry) {
    {
#line 42
    zip_error_set(& za___0->error, 18, 0);
    }
#line 43
    return (-1);
  }
  {
#line 46
  __cil_tmp5 = _zip_file_replace(za___0, idx, (char const   *)((void *)0), source,
                                 flags);
  }
#line 46
  if (__cil_tmp5 == -1L) {
#line 47
    return (-1);
  }
#line 49
  return (0);
}
}
#line 57 "/root/patchweave_new/24/lib/zip_file_replace.c"
zip_int64_t _zip_file_replace(zip_t *za___0 , zip_uint64_t idx , char const   *name ,
                              zip_source_t *source , zip_flags_t flags ) 
{ 
  zip_uint64_t za_nentry_prev ;
  zip_int64_t i ;
  int __cil_tmp10 ;

  {
#line 61
  if (za___0->ch_flags & 2U) {
    {
#line 62
    zip_error_set(& za___0->error, 25, 0);
    }
#line 63
    return ((zip_int64_t )-1);
  }
#line 66
  za_nentry_prev = za___0->nentry;
#line 67
  if (idx == 0xffffffffffffffffUL) {
#line 68
    i = (zip_int64_t )-1;
#line 70
    if (flags & 8192U) {
      {
#line 71
      i = _zip_name_locate(za___0, name, flags, (zip_error_t *)((void *)0));
      }
    }
#line 73
    if (i == -1L) {
      {
#line 75
      i = _zip_add_entry(za___0);
      }
#line 75
      if (i < 0L) {
#line 76
        return ((zip_int64_t )-1);
      }
    }
#line 78
    idx = (zip_uint64_t )i;
  }
  {
#line 81
  __cil_tmp10 = _zip_set_name(za___0, idx, name, flags);
  }
#line 81
  if (name) {
#line 81
    if (__cil_tmp10 != 0) {
#line 82
      if (za___0->nentry != za_nentry_prev) {
        {
#line 83
        _zip_entry_finalize(za___0->entry + idx);
#line 84
        za___0->nentry = za_nentry_prev;
        }
      }
#line 86
      return ((zip_int64_t )-1);
    }
  }
  {
#line 91
  _zip_unchange_data(za___0->entry + idx);
  }
#line 93
  if ((unsigned long )(za___0->entry + idx)->orig != (unsigned long )((void *)0)) {
#line 93
    if ((unsigned long )(za___0->entry + idx)->changes == (unsigned long )((void *)0)) {
      _L: 
#line 94
      if ((unsigned long )(za___0->entry + idx)->changes == (unsigned long )((void *)0)) {
        {
#line 95
        (za___0->entry + idx)->changes = _zip_dirent_clone((za___0->entry + idx)->orig);
        }
#line 95
        if ((unsigned long )(za___0->entry + idx)->changes == (unsigned long )((void *)0)) {
          {
#line 96
          zip_error_set(& za___0->error, 14, 0);
          }
#line 97
          return ((zip_int64_t )-1);
        }
      }
#line 101
      ((za___0->entry + idx)->changes)->comp_method = -2;
#line 102
      ((za___0->entry + idx)->changes)->changed |= 1U;
    } else
#line 93
    if ((((za___0->entry + idx)->changes)->changed & 1U) == 0U) {
#line 93
      goto _L;
    }
  }
#line 105
  (za___0->entry + idx)->source = source;
#line 107
  return ((zip_int64_t )idx);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_file_rename.c"
int zip_file_rename(zip_t *za___0 , zip_uint64_t idx , char const   *name , zip_flags_t flags ) 
{ 
  char const   *old_name ;
  int old_is_dir ;
  int new_is_dir ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  int tmp ;

  {
  {
#line 46
  __cil_tmp8 = strlen(name);
  }
#line 46
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 46
    if (__cil_tmp8 > 65535UL) {
      {
#line 47
      zip_error_set(& za___0->error, 18, 0);
      }
#line 48
      return (-1);
    } else {
#line 46
      goto _L;
    }
  } else
  _L: 
#line 46
  if (idx >= za___0->nentry) {
    {
#line 47
    zip_error_set(& za___0->error, 18, 0);
    }
#line 48
    return (-1);
  }
#line 51
  if (za___0->ch_flags & 2U) {
    {
#line 52
    zip_error_set(& za___0->error, 25, 0);
    }
#line 53
    return (-1);
  }
  {
#line 56
  old_name = zip_get_name(za___0, idx, (zip_flags_t )0);
  }
#line 56
  if ((unsigned long )old_name == (unsigned long )((void *)0)) {
#line 57
    return (-1);
  }
  {
#line 59
  __cil_tmp10 = strlen(name);
  }
#line 59
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 59
    if ((int )*(name + (__cil_tmp10 - 1UL)) == 47) {
#line 59
      tmp = 1;
    } else {
#line 59
      tmp = 0;
    }
  } else {
#line 59
    tmp = 0;
  }
  {
#line 59
  new_is_dir = tmp;
#line 60
  __cil_tmp11 = strlen(old_name);
#line 60
  old_is_dir = (int )*(old_name + (__cil_tmp11 - 1UL)) == 47;
  }
#line 62
  if (new_is_dir != old_is_dir) {
    {
#line 63
    zip_error_set(& za___0->error, 18, 0);
    }
#line 64
    return (-1);
  }
  {
#line 67
  __cil_tmp12 = _zip_set_name(za___0, idx, name, flags);
  }
#line 67
  return (__cil_tmp12);
}
}
#line 51 "/root/patchweave_new/24/lib/zip_file_get_offset.c"
zip_uint64_t _zip_file_get_offset(zip_t *za___0 , zip_uint64_t idx , zip_error_t *error ) 
{ 
  zip_uint64_t offset ;
  zip_int32_t size ;
  int __cil_tmp6 ;

  {
  {
#line 56
  offset = ((za___0->entry + idx)->orig)->offset;
#line 58
  __cil_tmp6 = zip_source_seek(za___0->src, (zip_int64_t )offset, 0);
  }
#line 58
  if (__cil_tmp6 < 0) {
    {
#line 59
    _zip_error_set_from_source(error, za___0->src);
    }
#line 60
    return ((zip_uint64_t )0);
  }
  {
#line 64
  size = _zip_dirent_size(za___0->src, (zip_uint16_t )256U, error);
  }
#line 64
  if (size < 0) {
#line 65
    return ((zip_uint64_t )0);
  }
#line 67
  if (offset + (unsigned long )((zip_uint32_t )size) > 0xffffffffffffffffUL) {
    {
#line 68
    zip_error_set(error, 4, 27);
    }
#line 69
    return ((zip_uint64_t )0);
  }
#line 72
  return (offset + (unsigned long )((zip_uint32_t )size));
}
}
#line 37 "/root/patchweave_new/24/lib/zip_file_get_external_attributes.c"
int zip_file_get_external_attributes(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                                     zip_uint8_t *opsys , zip_uint32_t *attributes ) 
{ 
  zip_dirent_t *de ;

  {
  {
#line 41
  de = _zip_get_dirent(za___0, idx, flags, (zip_error_t *)((void *)0));
  }
#line 41
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 42
    return (-1);
  }
#line 44
  if (opsys) {
#line 45
    *opsys = (zip_uint8_t )(((int )de->version_madeby >> 8) & 255);
  }
#line 47
  if (attributes) {
#line 48
    *attributes = de->ext_attrib;
  }
#line 50
  return (0);
}
}
#line 40 "/root/patchweave_new/24/lib/zip_file_get_comment.c"
char const   *zip_file_get_comment(zip_t *za___0 , zip_uint64_t idx , zip_uint32_t *lenp ,
                                   zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_uint32_t len ;
  zip_uint8_t *str ;

  {
  {
#line 46
  de = _zip_get_dirent(za___0, idx, flags, (zip_error_t *)((void *)0));
  }
#line 46
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 47
    return ((char const   *)((void *)0));
  }
  {
#line 49
  str = _zip_string_get(de->comment, & len, flags, & za___0->error);
  }
#line 49
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 50
    return ((char const   *)((void *)0));
  }
#line 52
  if (lenp) {
#line 53
    *lenp = len;
  }
#line 55
  return ((char const   *)str);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_file_error_get.c"
void zip_file_error_get(zip_file_t *zf , int *zep , int *sep ) 
{ 


  {
  {
#line 41
  _zip_error_get(& zf->error, zep, sep);
  }
#line 43
  return;
}
}
#line 39 "/root/patchweave_new/24/lib/zip_file_error_clear.c"
void zip_file_error_clear(zip_file_t *zf ) 
{ 


  {
#line 41
  if ((unsigned long )zf == (unsigned long )((void *)0)) {
#line 42
    return;
  }
  {
#line 44
  _zip_error_clear(& zf->error);
  }
#line 46
  return;
}
}
#line 45 "/root/patchweave_new/24/lib/zip_file_add.c"
zip_int64_t zip_file_add(zip_t *za___0 , char const   *name , zip_source_t *source ,
                         zip_flags_t flags ) 
{ 
  zip_int64_t __cil_tmp5 ;

  {
#line 47
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 48
    zip_error_set(& za___0->error, 18, 0);
    }
#line 49
    return ((zip_int64_t )-1);
  } else
#line 47
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    {
#line 48
    zip_error_set(& za___0->error, 18, 0);
    }
#line 49
    return ((zip_int64_t )-1);
  }
  {
#line 52
  __cil_tmp5 = _zip_file_replace(za___0, 0xffffffffffffffffUL, name, source, flags);
  }
#line 52
  return (__cil_tmp5);
}
}
#line 42 "/root/patchweave_new/24/lib/zip_fdopen.c"
zip_t *zip_fdopen(int fd_orig , int _flags , int *zep ) 
{ 
  int fd ;
  FILE *fp ;
  zip_t *za___0 ;
  zip_source_t *src ;
  struct zip_error error ;

  {
#line 50
  if (_flags < 0) {
    {
#line 51
    _zip_set_open_error(zep, (zip_error_t *)((void *)0), 18);
    }
#line 52
    return ((zip_t *)((void *)0));
  } else
#line 50
  if (_flags & -21) {
    {
#line 51
    _zip_set_open_error(zep, (zip_error_t *)((void *)0), 18);
    }
#line 52
    return ((zip_t *)((void *)0));
  }
  {
#line 58
  fd = dup(fd_orig);
  }
#line 58
  if (fd < 0) {
    {
#line 59
    _zip_set_open_error(zep, (zip_error_t *)((void *)0), 11);
    }
#line 60
    return ((zip_t *)((void *)0));
  }
  {
#line 63
  fp = fdopen(fd, "rb");
  }
#line 63
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 64
    close(fd);
#line 65
    _zip_set_open_error(zep, (zip_error_t *)((void *)0), 11);
    }
#line 66
    return ((zip_t *)((void *)0));
  }
  {
#line 69
  zip_error_init(& error);
#line 70
  src = zip_source_filep_create(fp, (zip_uint64_t )0, (zip_int64_t )-1, & error);
  }
#line 70
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 71
    _zip_set_open_error(zep, & error, 0);
#line 72
    zip_error_fini(& error);
    }
#line 73
    return ((zip_t *)((void *)0));
  }
  {
#line 76
  za___0 = zip_open_from_source(src, _flags, & error);
  }
#line 76
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
    {
#line 77
    _zip_set_open_error(zep, & error, 0);
#line 78
    zip_error_fini(& error);
    }
#line 79
    return ((zip_t *)((void *)0));
  }
  {
#line 82
  zip_error_fini(& error);
#line 83
  close(fd_orig);
  }
#line 84
  return (za___0);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_fclose.c"
int zip_fclose(zip_file_t *zf ) 
{ 
  int ret ;

  {
#line 45
  if (zf->src) {
    {
#line 46
    zip_source_free(zf->src);
    }
  }
#line 48
  ret = 0;
#line 49
  if (zf->error.zip_err) {
#line 50
    ret = zf->error.zip_err;
  }
  {
#line 52
  zip_error_fini(& zf->error);
#line 53
  free((void *)zf);
  }
#line 54
  return (ret);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_extra_field_api.c"
int zip_file_extra_field_delete(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_idx ,
                                zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_dirent_t *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 43
  if ((flags & 768U) == 0U) {
    {
#line 44
    zip_error_set(& za___0->error, 18, 0);
    }
#line 45
    return (-1);
  }
#line 48
  if ((flags & 768U) == 768U) {
#line 48
    if ((int )ef_idx != 65535) {
      {
#line 49
      zip_error_set(& za___0->error, 18, 0);
      }
#line 50
      return (-1);
    }
  }
  {
#line 53
  __cil_tmp6 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 53
  if ((unsigned long )__cil_tmp6 == (unsigned long )((void *)0)) {
#line 54
    return (-1);
  }
#line 56
  if (za___0->ch_flags & 2U) {
    {
#line 57
    zip_error_set(& za___0->error, 25, 0);
    }
#line 58
    return (-1);
  }
  {
#line 61
  __cil_tmp7 = _zip_file_extra_field_prepare_for_change(za___0, idx);
  }
#line 61
  if (__cil_tmp7 < 0) {
#line 62
    return (-1);
  }
  {
#line 64
  de = (za___0->entry + idx)->changes;
#line 66
  de->extra_fields = _zip_ef_delete_by_id(de->extra_fields, (zip_uint16_t )65535,
                                          ef_idx, flags);
  }
#line 67
  return (0);
}
}
#line 72 "/root/patchweave_new/24/lib/zip_extra_field_api.c"
int zip_file_extra_field_delete_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                      zip_uint16_t ef_idx , zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_dirent_t *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 76
  if ((flags & 768U) == 0U) {
    {
#line 77
    zip_error_set(& za___0->error, 18, 0);
    }
#line 78
    return (-1);
  }
#line 81
  if ((flags & 768U) == 768U) {
#line 81
    if ((int )ef_idx != 65535) {
      {
#line 82
      zip_error_set(& za___0->error, 18, 0);
      }
#line 83
      return (-1);
    }
  }
  {
#line 86
  __cil_tmp7 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 86
  if ((unsigned long )__cil_tmp7 == (unsigned long )((void *)0)) {
#line 87
    return (-1);
  }
#line 89
  if (za___0->ch_flags & 2U) {
    {
#line 90
    zip_error_set(& za___0->error, 25, 0);
    }
#line 91
    return (-1);
  }
  {
#line 94
  __cil_tmp8 = _zip_file_extra_field_prepare_for_change(za___0, idx);
  }
#line 94
  if (__cil_tmp8 < 0) {
#line 95
    return (-1);
  }
  {
#line 97
  de = (za___0->entry + idx)->changes;
#line 99
  de->extra_fields = _zip_ef_delete_by_id(de->extra_fields, ef_id, ef_idx, flags);
  }
#line 100
  return (0);
}
}
#line 108 "/root/patchweave_new/24/lib/zip_extra_field_api.c"
static zip_uint8_t empty___0[1]  ;
#line 105 "/root/patchweave_new/24/lib/zip_extra_field_api.c"
zip_uint8_t *zip_file_extra_field_get(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_idx ,
                                      zip_uint16_t *idp , zip_uint16_t *lenp , zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_extra_field_t *ef ;
  int i ;
  int __cil_tmp12 ;

  {
#line 107
  empty___0[0] = (zip_uint8_t )'\000';
#line 113
  if ((flags & 768U) == 0U) {
    {
#line 114
    zip_error_set(& za___0->error, 18, 0);
    }
#line 115
    return ((zip_uint8_t *)((void *)0));
  }
  {
#line 118
  de = _zip_get_dirent(za___0, idx, flags, & za___0->error);
  }
#line 118
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 119
    return ((zip_uint8_t *)((void *)0));
  }
#line 121
  if (flags & 256U) {
    {
#line 122
    __cil_tmp12 = _zip_read_local_ef(za___0, idx);
    }
#line 122
    if (__cil_tmp12 < 0) {
#line 123
      return ((zip_uint8_t *)((void *)0));
    }
  }
#line 125
  i = 0;
#line 126
  ef = de->extra_fields;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 126
    if (! ef) {
#line 126
      goto while_break;
    }
#line 127
    if ((ef->flags & flags) & 768U) {
#line 128
      if (i < (int )ef_idx) {
#line 129
        i ++;
#line 130
        goto while_continue;
      }
#line 133
      if (idp) {
#line 134
        *idp = ef->id;
      }
#line 135
      if (lenp) {
#line 136
        *lenp = ef->size;
      }
#line 137
      if ((int )ef->size > 0) {
#line 138
        return (ef->data);
      } else {
#line 140
        return (empty___0);
      }
    }
#line 126
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 144
  zip_error_set(& za___0->error, 9, 0);
  }
#line 145
  return ((zip_uint8_t *)((void *)0));
}
}
#line 151 "/root/patchweave_new/24/lib/zip_extra_field_api.c"
zip_uint8_t *zip_file_extra_field_get_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                            zip_uint16_t ef_idx , zip_uint16_t *lenp ,
                                            zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  int __cil_tmp9 ;
  zip_uint8_t *__cil_tmp10 ;

  {
#line 155
  if ((flags & 768U) == 0U) {
    {
#line 156
    zip_error_set(& za___0->error, 18, 0);
    }
#line 157
    return ((zip_uint8_t *)((void *)0));
  }
  {
#line 160
  de = _zip_get_dirent(za___0, idx, flags, & za___0->error);
  }
#line 160
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 161
    return ((zip_uint8_t *)((void *)0));
  }
#line 163
  if (flags & 256U) {
    {
#line 164
    __cil_tmp9 = _zip_read_local_ef(za___0, idx);
    }
#line 164
    if (__cil_tmp9 < 0) {
#line 165
      return ((zip_uint8_t *)((void *)0));
    }
  }
  {
#line 167
  __cil_tmp10 = _zip_ef_get_by_id(de->extra_fields, lenp, ef_id, ef_idx, flags, & za___0->error);
  }
#line 167
  return (__cil_tmp10);
}
}
#line 172 "/root/patchweave_new/24/lib/zip_extra_field_api.c"
zip_int16_t zip_file_extra_fields_count(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_extra_field_t *ef ;
  zip_uint16_t n ;
  int __cil_tmp8 ;

  {
#line 178
  if ((flags & 768U) == 0U) {
    {
#line 179
    zip_error_set(& za___0->error, 18, 0);
    }
#line 180
    return ((zip_int16_t )-1);
  }
  {
#line 183
  de = _zip_get_dirent(za___0, idx, flags, & za___0->error);
  }
#line 183
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 184
    return ((zip_int16_t )-1);
  }
#line 186
  if (flags & 256U) {
    {
#line 187
    __cil_tmp8 = _zip_read_local_ef(za___0, idx);
    }
#line 187
    if (__cil_tmp8 < 0) {
#line 188
      return ((zip_int16_t )-1);
    }
  }
#line 190
  n = (zip_uint16_t )0;
#line 191
  ef = de->extra_fields;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;

#line 191
    if (! ef) {
#line 191
      goto while_break;
    }
#line 192
    if ((ef->flags & flags) & 768U) {
#line 193
      n = (zip_uint16_t )((int )n + 1);
    }
#line 191
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 195
  return ((zip_int16_t )n);
}
}
#line 200 "/root/patchweave_new/24/lib/zip_extra_field_api.c"
zip_int16_t zip_file_extra_fields_count_by_id(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                                              zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_extra_field_t *ef ;
  zip_uint16_t n ;
  int __cil_tmp9 ;

  {
#line 206
  if ((flags & 768U) == 0U) {
    {
#line 207
    zip_error_set(& za___0->error, 18, 0);
    }
#line 208
    return ((zip_int16_t )-1);
  }
  {
#line 211
  de = _zip_get_dirent(za___0, idx, flags, & za___0->error);
  }
#line 211
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 212
    return ((zip_int16_t )-1);
  }
#line 214
  if (flags & 256U) {
    {
#line 215
    __cil_tmp9 = _zip_read_local_ef(za___0, idx);
    }
#line 215
    if (__cil_tmp9 < 0) {
#line 216
      return ((zip_int16_t )-1);
    }
  }
#line 218
  n = (zip_uint16_t )0;
#line 219
  ef = de->extra_fields;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;

#line 219
    if (! ef) {
#line 219
      goto while_break;
    }
#line 220
    if ((int )ef->id == (int )ef_id) {
#line 220
      if ((ef->flags & flags) & 768U) {
#line 221
        n = (zip_uint16_t )((int )n + 1);
      }
    }
#line 219
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 223
  return ((zip_int16_t )n);
}
}
#line 228 "/root/patchweave_new/24/lib/zip_extra_field_api.c"
int zip_file_extra_field_set(zip_t *za___0 , zip_uint64_t idx , zip_uint16_t ef_id ,
                             zip_uint16_t ef_idx , zip_uint8_t *data , zip_uint16_t len ,
                             zip_flags_t flags ) 
{ 
  zip_dirent_t *de ;
  zip_uint16_t ls ;
  zip_uint16_t cs ;
  zip_extra_field_t *ef ;
  zip_extra_field_t *ef_prev ;
  zip_extra_field_t *ef_new ;
  int i ;
  int found ;
  int new_len ;
  zip_dirent_t *__cil_tmp17 ;
  int __cil_tmp18 ;
  int tmp ;

  {
#line 235
  if ((flags & 768U) == 0U) {
    {
#line 236
    zip_error_set(& za___0->error, 18, 0);
    }
#line 237
    return (-1);
  }
  {
#line 240
  __cil_tmp17 = _zip_get_dirent(za___0, idx, (zip_flags_t )0, (zip_error_t *)((void *)0));
  }
#line 240
  if ((unsigned long )__cil_tmp17 == (unsigned long )((void *)0)) {
#line 241
    return (-1);
  }
#line 243
  if (za___0->ch_flags & 2U) {
    {
#line 244
    zip_error_set(& za___0->error, 25, 0);
    }
#line 245
    return (-1);
  }
#line 248
  if ((int )ef_id == 25461) {
    {
#line 249
    zip_error_set(& za___0->error, 18, 0);
    }
#line 250
    return (-1);
  } else
#line 248
  if ((int )ef_id == 28789) {
    {
#line 249
    zip_error_set(& za___0->error, 18, 0);
    }
#line 250
    return (-1);
  } else
#line 248
  if ((int )ef_id == 39169) {
    {
#line 249
    zip_error_set(& za___0->error, 18, 0);
    }
#line 250
    return (-1);
  } else
#line 248
  if ((int )ef_id == 1) {
    {
#line 249
    zip_error_set(& za___0->error, 18, 0);
    }
#line 250
    return (-1);
  }
  {
#line 253
  __cil_tmp18 = _zip_file_extra_field_prepare_for_change(za___0, idx);
  }
#line 253
  if (__cil_tmp18 < 0) {
#line 254
    return (-1);
  }
#line 256
  de = (za___0->entry + idx)->changes;
#line 258
  ef = de->extra_fields;
#line 259
  ef_prev = (zip_extra_field_t *)((void *)0);
#line 260
  i = 0;
#line 261
  found = 0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;

#line 263
    if (! ef) {
#line 263
      goto while_break;
    }
#line 264
    if ((int )ef->id == (int )ef_id) {
#line 264
      if ((ef->flags & flags) & 768U) {
#line 265
        if (i == (int )ef_idx) {
#line 266
          found = 1;
#line 267
          goto while_break;
        }
#line 269
        i ++;
      }
    }
#line 271
    ef_prev = ef;
#line 263
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 274
  if (i < (int )ef_idx) {
#line 274
    if ((int )ef_idx != 65535) {
      {
#line 275
      zip_error_set(& za___0->error, 18, 0);
      }
#line 276
      return (-1);
    }
  }
#line 279
  if (flags & 256U) {
    {
#line 280
    ls = _zip_ef_size(de->extra_fields, 256U);
    }
  } else {
#line 282
    ls = (zip_uint16_t )0;
  }
#line 283
  if (flags & 512U) {
    {
#line 284
    cs = _zip_ef_size(de->extra_fields, 512U);
    }
  } else {
#line 286
    cs = (zip_uint16_t )0;
  }
#line 288
  if ((int )ls > (int )cs) {
#line 288
    tmp = (int )ls;
  } else {
#line 288
    tmp = (int )cs;
  }
#line 288
  new_len = tmp;
#line 289
  if (found) {
#line 290
    new_len -= (int )ef->size + 4;
  }
#line 291
  new_len += (int )len + 4;
#line 293
  if (new_len > 65535) {
    {
#line 294
    zip_error_set(& za___0->error, 18, 0);
    }
#line 295
    return (-1);
  }
  {
#line 298
  ef_new = _zip_ef_new(ef_id, len, data, flags);
  }
#line 298
  if ((unsigned long )ef_new == (unsigned long )((void *)0)) {
    {
#line 299
    zip_error_set(& za___0->error, 14, 0);
    }
#line 300
    return (-1);
  }
#line 303
  if (found) {
#line 304
    if ((ef->flags & 768U) == (flags & 768U)) {
      {
#line 305
      ef_new->next = ef->next;
#line 306
      ef->next = (zip_extra_field_t *)((void *)0);
#line 307
      _zip_ef_free(ef);
      }
#line 308
      if (ef_prev) {
#line 309
        ef_prev->next = ef_new;
      } else {
#line 311
        de->extra_fields = ef_new;
      }
    } else {
#line 314
      ef->flags &= ~ (flags & 768U);
#line 315
      ef_new->next = ef->next;
#line 316
      ef->next = ef_new;
    }
  } else
#line 319
  if (ef_prev) {
#line 320
    ef_new->next = ef_prev->next;
#line 321
    ef_prev->next = ef_new;
  } else {
#line 324
    de->extra_fields = ef_new;
  }
#line 326
  return (0);
}
}
#line 332 "/root/patchweave_new/24/lib/zip_extra_field_api.c"
int _zip_file_extra_field_prepare_for_change(zip_t *za___0 , zip_uint64_t idx ) 
{ 
  zip_entry_t *e ;
  int __cil_tmp4 ;

  {
#line 336
  if (idx >= za___0->nentry) {
    {
#line 337
    zip_error_set(& za___0->error, 18, 0);
    }
#line 338
    return (-1);
  }
#line 341
  e = za___0->entry + idx;
#line 343
  if (e->changes) {
#line 343
    if ((e->changes)->changed & 8U) {
#line 344
      return (0);
    }
  }
#line 346
  if (e->orig) {
    {
#line 347
    __cil_tmp4 = _zip_read_local_ef(za___0, idx);
    }
#line 347
    if (__cil_tmp4 < 0) {
#line 348
      return (-1);
    }
  }
#line 351
  if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
    {
#line 352
    e->changes = _zip_dirent_clone(e->orig);
    }
#line 352
    if ((unsigned long )e->changes == (unsigned long )((void *)0)) {
      {
#line 353
      zip_error_set(& za___0->error, 14, 0);
      }
#line 354
      return (-1);
    }
  }
#line 358
  if (e->orig) {
#line 358
    if ((e->orig)->extra_fields) {
      {
#line 359
      (e->changes)->extra_fields = _zip_ef_clone((e->orig)->extra_fields, & za___0->error);
      }
#line 359
      if ((unsigned long )(e->changes)->extra_fields == (unsigned long )((void *)0)) {
#line 360
        return (-1);
      }
    }
  }
#line 362
  (e->changes)->changed |= 8U;
#line 364
  return (0);
}
}
#line 41 "/root/patchweave_new/24/lib/zip_extra_field.c"
zip_extra_field_t *_zip_ef_clone(zip_extra_field_t *ef , zip_error_t *error ) 
{ 
  zip_extra_field_t *head ;
  zip_extra_field_t *prev ;
  zip_extra_field_t *def ;

  {
#line 45
  prev = (zip_extra_field_t *)((void *)0);
#line 45
  head = prev;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;

#line 47
    if (! ef) {
#line 47
      goto while_break;
    }
    {
#line 48
    def = _zip_ef_new(ef->id, ef->size, ef->data, ef->flags);
    }
#line 48
    if ((unsigned long )def == (unsigned long )((void *)0)) {
      {
#line 49
      zip_error_set(error, 14, 0);
#line 50
      _zip_ef_free(head);
      }
#line 51
      return ((zip_extra_field_t *)((void *)0));
    }
#line 54
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 55
      head = def;
    }
#line 56
    if (prev) {
#line 57
      prev->next = def;
    }
#line 58
    prev = def;
#line 60
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 63
  return (head);
}
}
#line 68 "/root/patchweave_new/24/lib/zip_extra_field.c"
zip_extra_field_t *_zip_ef_delete_by_id(zip_extra_field_t *ef , zip_uint16_t id ,
                                        zip_uint16_t id_idx , zip_flags_t flags ) 
{ 
  zip_extra_field_t *head ;
  zip_extra_field_t *prev ;
  int i ;
  zip_extra_field_t *tmp ;

  {
#line 73
  i = 0;
#line 74
  head = ef;
#line 75
  prev = (zip_extra_field_t *)((void *)0);
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 76
    if (! ef) {
#line 76
      goto while_break;
    }
#line 77
    if ((ef->flags & flags) & 768U) {
#line 77
      if ((int )ef->id == (int )id) {
        _L___13: 
#line 78
        if ((int )id_idx == 65535) {
          _L: 
#line 79
          ef->flags &= ~ (flags & 768U);
#line 80
          if ((ef->flags & 768U) == 0U) {
#line 81
            if (prev) {
#line 82
              prev->next = ef->next;
            } else {
#line 84
              head = ef->next;
            }
            {
#line 85
            ef->next = (zip_extra_field_t *)((void *)0);
#line 86
            _zip_ef_free(ef);
            }
#line 88
            if ((int )id_idx == 65535) {
#line 89
              goto while_continue;
            }
          }
        } else
#line 78
        if (i == (int )id_idx) {
#line 78
          goto _L;
        }
#line 93
        i ++;
#line 94
        if (i > (int )id_idx) {
#line 95
          goto while_break;
        }
      } else
#line 77
      if ((int )id == 65535) {
#line 77
        goto _L___13;
      }
    }
#line 97
    prev = ef;
#line 76
    if (prev) {
#line 76
      tmp = prev->next;
    } else {
#line 76
      tmp = head;
    }
#line 76
    ef = tmp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 100
  return (head);
}
}
#line 106 "/root/patchweave_new/24/lib/zip_extra_field.c"
void _zip_ef_free(zip_extra_field_t *ef ) 
{ 
  zip_extra_field_t *ef2 ;

  {
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;

#line 110
    if (! ef) {
#line 110
      goto while_break;
    }
    {
#line 111
    ef2 = ef->next;
#line 112
    free((void *)ef->data);
#line 113
    free((void *)ef);
#line 114
    ef = ef2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 119
  return;
}
}
#line 123 "/root/patchweave_new/24/lib/zip_extra_field.c"
static zip_uint8_t empty___1[1]  ;
#line 120 "/root/patchweave_new/24/lib/zip_extra_field.c"
zip_uint8_t *_zip_ef_get_by_id(zip_extra_field_t *ef , zip_uint16_t *lenp , zip_uint16_t id ,
                               zip_uint16_t id_idx , zip_flags_t flags , zip_error_t *error ) 
{ 
  int i ;

  {
#line 122
  empty___1[0] = (zip_uint8_t )'\000';
#line 126
  i = 0;
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 127
    if (! ef) {
#line 127
      goto while_break;
    }
#line 128
    if ((int )ef->id == (int )id) {
#line 128
      if ((ef->flags & flags) & 768U) {
#line 129
        if (i < (int )id_idx) {
#line 130
          i ++;
#line 131
          goto while_continue;
        }
#line 134
        if (lenp) {
#line 135
          *lenp = ef->size;
        }
#line 136
        if ((int )ef->size > 0) {
#line 137
          return (ef->data);
        } else {
#line 139
          return (empty___1);
        }
      }
    }
#line 127
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 143
  zip_error_set(error, 9, 0);
  }
#line 144
  return ((zip_uint8_t *)((void *)0));
}
}
#line 149 "/root/patchweave_new/24/lib/zip_extra_field.c"
zip_extra_field_t *_zip_ef_merge(zip_extra_field_t *to , zip_extra_field_t *from ) 
{ 
  zip_extra_field_t *ef2 ;
  zip_extra_field_t *tt ;
  zip_extra_field_t *tail ;
  int duplicate ;
  int __cil_tmp7 ;

  {
#line 154
  if ((unsigned long )to == (unsigned long )((void *)0)) {
#line 155
    return (from);
  }
#line 157
  tail = to;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;

#line 157
    if (! tail->next) {
#line 157
      goto while_break;
    }
#line 157
    tail = tail->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 160
    if (! from) {
#line 160
      goto while_break___0;
    }
#line 161
    ef2 = from->next;
#line 163
    duplicate = 0;
#line 164
    tt = to;
    {
#line 164
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 164
      if (! tt) {
#line 164
        goto while_break___1;
      }
      {
#line 165
      __cil_tmp7 = memcmp((void const   *)tt->data, (void const   *)from->data, (unsigned long )tt->size);
      }
#line 165
      if ((int )tt->id == (int )from->id) {
#line 165
        if ((int )tt->size == (int )from->size) {
#line 165
          if (__cil_tmp7 == 0) {
#line 166
            tt->flags |= from->flags & 768U;
#line 167
            duplicate = 1;
#line 168
            goto while_break___1;
          }
        }
      }
#line 164
      tt = tt->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 172
    from->next = (zip_extra_field_t *)((void *)0);
#line 173
    if (duplicate) {
      {
#line 174
      _zip_ef_free(from);
      }
    } else {
#line 176
      tail->next = from;
#line 176
      tail = tail->next;
    }
#line 160
    from = ef2;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 179
  return (to);
}
}
#line 184 "/root/patchweave_new/24/lib/zip_extra_field.c"
zip_extra_field_t *_zip_ef_new(zip_uint16_t id , zip_uint16_t size , zip_uint8_t *data ,
                               zip_flags_t flags ) 
{ 
  zip_extra_field_t *ef ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 188
  __cil_tmp6 = malloc(sizeof(*ef));
#line 188
  ef = (zip_extra_field_t *)__cil_tmp6;
  }
#line 188
  if ((unsigned long )ef == (unsigned long )((void *)0)) {
#line 189
    return ((zip_extra_field_t *)((void *)0));
  }
#line 191
  ef->next = (zip_extra_field_t *)((void *)0);
#line 192
  ef->flags = flags;
#line 193
  ef->id = id;
#line 194
  ef->size = size;
#line 195
  if ((int )size > 0) {
    {
#line 196
    __cil_tmp7 = _zip_memdup((void const   *)data, (size_t )size, (zip_error_t *)((void *)0));
#line 196
    ef->data = (zip_uint8_t *)__cil_tmp7;
    }
#line 196
    if ((unsigned long )ef->data == (unsigned long )((void *)0)) {
      {
#line 197
      free((void *)ef);
      }
#line 198
      return ((zip_extra_field_t *)((void *)0));
    }
  } else {
#line 202
    ef->data = (zip_uint8_t *)((void *)0);
  }
#line 204
  return (ef);
}
}
#line 209 "/root/patchweave_new/24/lib/zip_extra_field.c"
int _zip_ef_parse(zip_uint8_t *data , zip_uint16_t len , zip_flags_t flags , zip_extra_field_t **ef_head_p ,
                  zip_error_t *error ) 
{ 
  zip_buffer_t *buffer ;
  zip_extra_field_t *ef ;
  zip_extra_field_t *ef2 ;
  zip_extra_field_t *ef_head ;
  int __cil_tmp11 ;
  zip_uint64_t __cil_tmp12 ;
  zip_uint16_t fid ;
  zip_uint16_t flen ;
  zip_uint8_t *ef_data ;
  int __cil_tmp20 ;
  size_t glen ;
  zip_uint64_t __cil_tmp22 ;
  zip_uint8_t *garbage ;
  int __cil_tmp25 ;

  {
  {
#line 214
  buffer = _zip_buffer_new(data, (zip_uint64_t )len);
  }
#line 214
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 215
    zip_error_set(error, 14, 0);
    }
#line 216
    return (0);
  }
#line 219
  ef = (zip_extra_field_t *)((void *)0);
#line 219
  ef_head = ef;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 221
    __cil_tmp12 = _zip_buffer_left(buffer);
#line 221
    __cil_tmp11 = _zip_buffer_ok(buffer);
    }
#line 221
    if (__cil_tmp11) {
#line 221
      if (! (__cil_tmp12 >= 4UL)) {
#line 221
        goto while_break;
      }
    } else {
#line 221
      goto while_break;
    }
    {
#line 225
    fid = _zip_buffer_get_16(buffer);
#line 226
    flen = _zip_buffer_get_16(buffer);
#line 227
    ef_data = _zip_buffer_get(buffer, (zip_uint64_t )flen);
    }
#line 229
    if ((unsigned long )ef_data == (unsigned long )((void *)0)) {
      {
#line 230
      zip_error_set(error, 21, 0);
#line 231
      _zip_buffer_free(buffer);
#line 232
      _zip_ef_free(ef_head);
      }
#line 233
      return (0);
    }
    {
#line 236
    ef2 = _zip_ef_new(fid, flen, ef_data, flags);
    }
#line 236
    if ((unsigned long )ef2 == (unsigned long )((void *)0)) {
      {
#line 237
      zip_error_set(error, 14, 0);
#line 238
      _zip_buffer_free(buffer);
#line 239
      _zip_ef_free(ef_head);
      }
#line 240
      return (0);
    }
#line 243
    if (ef_head) {
#line 244
      ef->next = ef2;
#line 245
      ef = ef2;
    } else {
#line 248
      ef = ef2;
#line 248
      ef_head = ef;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 251
  __cil_tmp20 = _zip_buffer_eof(buffer);
  }
#line 251
  if (! __cil_tmp20) {
    {
#line 254
    __cil_tmp22 = _zip_buffer_left(buffer);
#line 254
    glen = __cil_tmp22;
#line 256
    garbage = _zip_buffer_get(buffer, glen);
#line 257
    __cil_tmp25 = memcmp((void const   *)garbage, (void const   *)"", glen);
    }
#line 257
    if ((unsigned long )garbage == (unsigned long )((void *)0)) {
      {
#line 258
      zip_error_set(error, 21, 0);
#line 259
      _zip_buffer_free(buffer);
#line 260
      _zip_ef_free(ef_head);
      }
#line 261
      return (0);
    } else
#line 257
    if (glen >= 4UL) {
      {
#line 258
      zip_error_set(error, 21, 0);
#line 259
      _zip_buffer_free(buffer);
#line 260
      _zip_ef_free(ef_head);
      }
#line 261
      return (0);
    } else
#line 257
    if (__cil_tmp25 != 0) {
      {
#line 258
      zip_error_set(error, 21, 0);
#line 259
      _zip_buffer_free(buffer);
#line 260
      _zip_ef_free(ef_head);
      }
#line 261
      return (0);
    }
  }
  {
#line 265
  _zip_buffer_free(buffer);
  }
#line 267
  if (ef_head_p) {
#line 268
    *ef_head_p = ef_head;
  } else {
    {
#line 271
    _zip_ef_free(ef_head);
    }
  }
#line 274
  return (1);
}
}
#line 279 "/root/patchweave_new/24/lib/zip_extra_field.c"
zip_extra_field_t *_zip_ef_remove_internal(zip_extra_field_t *ef ) 
{ 
  zip_extra_field_t *ef_head ;
  zip_extra_field_t *prev ;
  zip_extra_field_t *next ;

  {
#line 284
  ef_head = ef;
#line 285
  prev = (zip_extra_field_t *)((void *)0);
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;

#line 287
    if (! ef) {
#line 287
      goto while_break;
    }
#line 288
    if ((int )ef->id == 25461) {
      _L: 
#line 289
      next = ef->next;
#line 290
      if ((unsigned long )ef_head == (unsigned long )ef) {
#line 291
        ef_head = next;
      }
      {
#line 292
      ef->next = (zip_extra_field_t *)((void *)0);
#line 293
      _zip_ef_free(ef);
      }
#line 294
      if (prev) {
#line 295
        prev->next = next;
      }
#line 296
      ef = next;
    } else
#line 288
    if ((int )ef->id == 28789) {
#line 288
      goto _L;
    } else
#line 288
    if ((int )ef->id == 39169) {
#line 288
      goto _L;
    } else
#line 288
    if ((int )ef->id == 1) {
#line 288
      goto _L;
    } else {
#line 299
      prev = ef;
#line 300
      ef = ef->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 304
  return (ef_head);
}
}
#line 309 "/root/patchweave_new/24/lib/zip_extra_field.c"
zip_uint16_t _zip_ef_size(zip_extra_field_t *ef , zip_flags_t flags ) 
{ 
  zip_uint16_t size ;

  {
#line 313
  size = (zip_uint16_t )0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;

#line 314
    if (! ef) {
#line 314
      goto while_break;
    }
#line 315
    if ((ef->flags & flags) & 768U) {
#line 316
      size = (zip_uint16_t )(((int )size + 4) + (int )ef->size);
    }
#line 314
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 319
  return (size);
}
}
#line 324 "/root/patchweave_new/24/lib/zip_extra_field.c"
int _zip_ef_write(zip_t *za___0 , zip_extra_field_t *ef , zip_flags_t flags ) 
{ 
  zip_uint8_t b[4] ;
  zip_buffer_t *buffer ;
  zip_buffer_t *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 327
  __cil_tmp6 = _zip_buffer_new(b, sizeof(b));
#line 327
  buffer = __cil_tmp6;
  }
#line 329
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 330
    return (-1);
  }
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;

#line 333
    if (! ef) {
#line 333
      goto while_break;
    }
#line 334
    if ((ef->flags & flags) & 768U) {
      {
#line 335
      _zip_buffer_set_offset(buffer, (zip_uint64_t )0);
#line 336
      _zip_buffer_put_16(buffer, ef->id);
#line 337
      _zip_buffer_put_16(buffer, ef->size);
#line 338
      __cil_tmp7 = _zip_buffer_ok(buffer);
      }
#line 338
      if (! __cil_tmp7) {
        {
#line 339
        zip_error_set(& za___0->error, 20, 0);
#line 340
        _zip_buffer_free(buffer);
        }
#line 341
        return (-1);
      }
      {
#line 343
      __cil_tmp8 = _zip_write(za___0, (void const   *)(b), (zip_uint64_t )4);
      }
#line 343
      if (__cil_tmp8 < 0) {
        {
#line 344
        _zip_buffer_free(buffer);
        }
#line 345
        return (-1);
      }
#line 347
      if ((int )ef->size > 0) {
        {
#line 348
        __cil_tmp9 = _zip_write(za___0, (void const   *)ef->data, (zip_uint64_t )ef->size);
        }
#line 348
        if (__cil_tmp9 < 0) {
          {
#line 349
          _zip_buffer_free(buffer);
          }
#line 350
          return (-1);
        }
      }
    }
#line 333
    ef = ef->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 356
  _zip_buffer_free(buffer);
  }
#line 357
  return (0);
}
}
#line 362 "/root/patchweave_new/24/lib/zip_extra_field.c"
int _zip_read_local_ef(zip_t *za___0 , zip_uint64_t idx ) 
{ 
  zip_entry_t *e ;
  unsigned char b[4] ;
  zip_buffer_t *buffer ;
  zip_uint16_t fname_len ;
  zip_uint16_t ef_len ;
  int __cil_tmp8 ;
  int __cil_tmp12 ;
  zip_extra_field_t *ef ;
  zip_uint8_t *ef_raw ;
  int __cil_tmp15 ;
  int *__cil_tmp16 ;
  int __cil_tmp18 ;

  {
#line 369
  if (idx >= za___0->nentry) {
    {
#line 370
    zip_error_set(& za___0->error, 18, 0);
    }
#line 371
    return (-1);
  }
#line 374
  e = za___0->entry + idx;
#line 376
  if ((unsigned long )e->orig == (unsigned long )((void *)0)) {
#line 377
    return (0);
  } else
#line 376
  if ((e->orig)->local_extra_fields_read) {
#line 377
    return (0);
  }
#line 379
  if ((e->orig)->offset + 26UL > 0xffffffffffffffffUL) {
    {
#line 380
    zip_error_set(& za___0->error, 4, 27);
    }
#line 381
    return (-1);
  }
  {
#line 384
  __cil_tmp8 = zip_source_seek(za___0->src, (zip_int64_t )((e->orig)->offset + 26UL),
                               0);
  }
#line 384
  if (__cil_tmp8 < 0) {
    {
#line 385
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 386
    return (-1);
  }
  {
#line 389
  buffer = _zip_buffer_new_from_source(za___0->src, sizeof(b), b, & za___0->error);
  }
#line 389
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 390
    return (-1);
  }
  {
#line 393
  fname_len = _zip_buffer_get_16(buffer);
#line 394
  ef_len = _zip_buffer_get_16(buffer);
#line 396
  __cil_tmp12 = _zip_buffer_eof(buffer);
  }
#line 396
  if (! __cil_tmp12) {
    {
#line 397
    _zip_buffer_free(buffer);
#line 398
    zip_error_set(& za___0->error, 20, 0);
    }
#line 399
    return (-1);
  }
  {
#line 402
  _zip_buffer_free(buffer);
  }
#line 404
  if ((int )ef_len > 0) {
    {
#line 408
    __cil_tmp15 = zip_source_seek(za___0->src, (zip_int64_t )fname_len, 1);
    }
#line 408
    if (__cil_tmp15 < 0) {
      {
#line 409
      __cil_tmp16 = __errno_location();
#line 409
      zip_error_set(& za___0->error, 4, *__cil_tmp16);
      }
#line 410
      return (-1);
    }
    {
#line 413
    ef_raw = _zip_read_data((zip_buffer_t *)((void *)0), za___0->src, (size_t )ef_len,
                            0, & za___0->error);
    }
#line 415
    if ((unsigned long )ef_raw == (unsigned long )((void *)0)) {
#line 416
      return (-1);
    }
    {
#line 418
    __cil_tmp18 = _zip_ef_parse(ef_raw, ef_len, 256U, & ef, & za___0->error);
    }
#line 418
    if (! __cil_tmp18) {
      {
#line 419
      free((void *)ef_raw);
      }
#line 420
      return (-1);
    }
    {
#line 422
    free((void *)ef_raw);
    }
#line 424
    if (ef) {
      {
#line 425
      ef = _zip_ef_remove_internal(ef);
#line 426
      (e->orig)->extra_fields = _zip_ef_merge((e->orig)->extra_fields, ef);
      }
    }
  }
#line 430
  (e->orig)->local_extra_fields_read = 1;
#line 432
  if (e->changes) {
#line 432
    if ((e->changes)->local_extra_fields_read == 0) {
#line 433
      (e->changes)->extra_fields = (e->orig)->extra_fields;
#line 434
      (e->changes)->local_extra_fields_read = 1;
    }
  }
#line 437
  return (0);
}
}
#line 44 "/root/patchweave_new/24/lib/zip_error_to_str.c"
int zip_error_to_str(char *buf , zip_uint64_t len , int ze , int se ) 
{ 
  char const   *zs ;
  char const   *ss ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int __cil_tmp12 ;

  {
#line 48
  if (ze < 0) {
    {
#line 49
    __cil_tmp7 = snprintf(buf, len, "Unknown error %d\230\001", ze);
    }
#line 49
    return (__cil_tmp7);
  } else
#line 48
  if (ze >= (int )_zip_nerr_str) {
    {
#line 49
    __cil_tmp7 = snprintf(buf, len, "Unknown error %d\230\001", ze);
    }
#line 49
    return (__cil_tmp7);
  }
#line 51
  zs = (char const   *)_zip_err_str[ze];
#line 54
  if (_zip_err_type[ze] == 1) {
#line 54
    goto case_1;
  }
#line 58
  if (_zip_err_type[ze] == 2) {
#line 58
    goto case_2;
  }
#line 62
  goto switch_default;
  case_1: 
  {
#line 55
  __cil_tmp8 = strerror(se);
#line 55
  ss = (char const   *)__cil_tmp8;
  }
#line 56
  goto switch_break;
  case_2: 
  {
#line 59
  ss = zError(se);
  }
#line 60
  goto switch_break;
  switch_default: 
#line 63
  ss = (char const   *)((void *)0);
  switch_break: ;
#line 66
  if (ss) {
#line 66
    tmp = ": ";
  } else {
#line 66
    tmp = "\220";
  }
#line 66
  if (ss) {
#line 66
    tmp___0 = ss;
  } else {
#line 66
    tmp___0 = "\220";
  }
  {
#line 66
  __cil_tmp12 = snprintf(buf, len, "%s%s%s", zs, tmp, tmp___0);
  }
#line 66
  return (__cil_tmp12);
}
}
#line 43 "/root/patchweave_new/24/lib/zip_error_strerror.c"
char const   *zip_error_strerror(zip_error_t *err ) 
{ 
  char const   *zs ;
  char const   *ss ;
  char buf[128] ;
  char *s ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long tmp ;
  void *__cil_tmp11 ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 48
  zip_error_fini(err);
  }
#line 50
  if (err->zip_err < 0) {
    {
#line 51
    sprintf(buf, "Unknown error %d\230\001", err->zip_err);
#line 52
    zs = (char const   *)((void *)0);
#line 53
    ss = (char const   *)(buf);
    }
  } else
#line 50
  if (err->zip_err >= (int )_zip_nerr_str) {
    {
#line 51
    sprintf(buf, "Unknown error %d\230\001", err->zip_err);
#line 52
    zs = (char const   *)((void *)0);
#line 53
    ss = (char const   *)(buf);
    }
  } else {
#line 56
    zs = (char const   *)_zip_err_str[err->zip_err];
#line 59
    if (_zip_err_type[err->zip_err] == 1) {
#line 59
      goto case_1;
    }
#line 63
    if (_zip_err_type[err->zip_err] == 2) {
#line 63
      goto case_2;
    }
#line 67
    goto switch_default;
    case_1: 
    {
#line 60
    __cil_tmp6 = strerror(err->sys_err);
#line 60
    ss = (char const   *)__cil_tmp6;
    }
#line 61
    goto switch_break;
    case_2: 
    {
#line 64
    ss = zError(err->sys_err);
    }
#line 65
    goto switch_break;
    switch_default: 
#line 68
    ss = (char const   *)((void *)0);
    switch_break: ;
  }
#line 72
  if ((unsigned long )ss == (unsigned long )((void *)0)) {
#line 73
    return (zs);
  } else {
#line 75
    if (zs) {
      {
#line 75
      __cil_tmp9 = strlen(zs);
#line 75
      tmp = __cil_tmp9 + 2UL;
      }
    } else {
#line 75
      tmp = 0UL;
    }
    {
#line 75
    __cil_tmp8 = strlen(ss);
#line 75
    __cil_tmp11 = malloc((__cil_tmp8 + tmp) + 1UL);
#line 75
    s = (char *)__cil_tmp11;
    }
#line 75
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 77
      return ((char const   *)_zip_err_str[14]);
    }
#line 79
    if (zs) {
#line 79
      tmp___0 = zs;
    } else {
#line 79
      tmp___0 = "\220";
    }
#line 79
    if (zs) {
#line 79
      tmp___1 = ": ";
    } else {
#line 79
      tmp___1 = "";
    }
    {
#line 79
    sprintf(s, "%s%s%s", tmp___0, tmp___1, ss);
#line 83
    err->str = s;
    }
#line 85
    return ((char const   *)s);
  }
}
}
#line 39 "/root/patchweave_new/24/lib/zip_error_get_sys_type.c"
int zip_error_get_sys_type(int ze ) 
{ 


  {
#line 41
  if (ze < 0) {
#line 42
    return (0);
  } else
#line 41
  if (ze >= (int )_zip_nerr_str) {
#line 42
    return (0);
  }
#line 44
  return ((int )_zip_err_type[ze]);
}
}
#line 40 "/root/patchweave_new/24/lib/zip_error_get.c"
void zip_error_get(zip_t *za___0 , int *zep , int *sep ) 
{ 


  {
  {
#line 42
  _zip_error_get(& za___0->error, zep, sep);
  }
#line 44
  return;
}
}
#line 47 "/root/patchweave_new/24/lib/zip_error_get.c"
zip_error_t *zip_get_error(zip_t *za___0 ) 
{ 


  {
#line 49
  return (& za___0->error);
}
}
#line 54 "/root/patchweave_new/24/lib/zip_error_get.c"
zip_error_t *zip_file_get_error(zip_file_t *f ) 
{ 


  {
#line 56
  return (& f->error);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_error_clear.c"
void zip_error_clear(zip_t *za___0 ) 
{ 


  {
#line 41
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 42
    return;
  }
  {
#line 44
  _zip_error_clear(& za___0->error);
  }
#line 46
  return;
}
}
#line 40 "/root/patchweave_new/24/lib/zip_error.c"
int zip_error_code_system(zip_error_t *error ) 
{ 


  {
#line 41
  return (error->sys_err);
}
}
#line 46 "/root/patchweave_new/24/lib/zip_error.c"
int zip_error_code_zip(zip_error_t *error ) 
{ 


  {
#line 47
  return (error->zip_err);
}
}
#line 52 "/root/patchweave_new/24/lib/zip_error.c"
void zip_error_fini(zip_error_t *err ) 
{ 


  {
  {
#line 54
  free((void *)err->str);
#line 55
  err->str = (char *)((void *)0);
  }
#line 57
  return;
}
}
#line 60 "/root/patchweave_new/24/lib/zip_error.c"
void zip_error_init(zip_error_t *err ) 
{ 


  {
#line 62
  err->zip_err = 0;
#line 63
  err->sys_err = 0;
#line 64
  err->str = (char *)((void *)0);
#line 65
  return;
}
}
#line 68 "/root/patchweave_new/24/lib/zip_error.c"
void zip_error_init_with_code(zip_error_t *error , int ze ) 
{ 
  int __cil_tmp3 ;
  int *tmp ;

  {
  {
#line 70
  zip_error_init(error);
#line 71
  error->zip_err = ze;
#line 72
  __cil_tmp3 = zip_error_system_type(error);
  }
#line 73
  if (__cil_tmp3 == 1) {
#line 73
    goto case_1;
  }
#line 77
  goto switch_default;
  case_1: 
  {
#line 74
  tmp = __errno_location();
#line 74
  error->sys_err = (int )tmp;
  }
#line 75
  goto switch_break;
  switch_default: 
#line 78
  error->sys_err = 0;
#line 79
  goto switch_break;
  switch_break: ;
#line 82
  return;
}
}
#line 85 "/root/patchweave_new/24/lib/zip_error.c"
int zip_error_system_type(zip_error_t *error ) 
{ 


  {
#line 86
  if (error->zip_err < 0) {
#line 87
    return (0);
  } else
#line 86
  if (error->zip_err >= (int )_zip_nerr_str) {
#line 87
    return (0);
  }
#line 89
  return ((int )_zip_err_type[error->zip_err]);
}
}
#line 94 "/root/patchweave_new/24/lib/zip_error.c"
void _zip_error_clear(zip_error_t *err ) 
{ 


  {
#line 96
  if ((unsigned long )err == (unsigned long )((void *)0)) {
#line 97
    return;
  }
#line 99
  err->zip_err = 0;
#line 100
  err->sys_err = 0;
#line 101
  return;
}
}
#line 105 "/root/patchweave_new/24/lib/zip_error.c"
void _zip_error_copy(zip_error_t *dst , zip_error_t *src ) 
{ 


  {
#line 107
  dst->zip_err = src->zip_err;
#line 108
  dst->sys_err = src->sys_err;
#line 109
  return;
}
}
#line 113 "/root/patchweave_new/24/lib/zip_error.c"
void _zip_error_get(zip_error_t *err , int *zep , int *sep ) 
{ 
  int __cil_tmp4 ;

  {
#line 115
  if (zep) {
#line 116
    *zep = err->zip_err;
  }
#line 117
  if (sep) {
    {
#line 118
    __cil_tmp4 = zip_error_system_type(err);
    }
#line 118
    if (__cil_tmp4 != 0) {
#line 119
      *sep = err->sys_err;
    } else {
#line 121
      *sep = 0;
    }
  }
#line 124
  return;
}
}
#line 127 "/root/patchweave_new/24/lib/zip_error.c"
void zip_error_set(zip_error_t *err , int ze , int se ) 
{ 


  {
#line 129
  if (err) {
#line 130
    err->zip_err = ze;
#line 131
    err->sys_err = se;
  }
#line 133
  return;
}
}
#line 137 "/root/patchweave_new/24/lib/zip_error.c"
void _zip_error_set_from_source(zip_error_t *err , zip_source_t *src ) 
{ 
  zip_error_t *__cil_tmp3 ;

  {
  {
#line 139
  __cil_tmp3 = zip_source_error(src);
#line 139
  _zip_error_copy(err, __cil_tmp3);
  }
#line 141
  return;
}
}
#line 144 "/root/patchweave_new/24/lib/zip_error.c"
zip_int64_t zip_error_to_data(zip_error_t *error , void *data , zip_uint64_t length ) 
{ 
  int *e ;

  {
#line 146
  e = (int *)data;
#line 148
  if (length < sizeof(int ) * 2UL) {
#line 149
    return ((zip_int64_t )-1);
  }
  {
#line 152
  *(e + 0) = zip_error_code_zip(error);
#line 153
  *(e + 1) = zip_error_code_system(error);
  }
#line 154
  return ((zip_int64_t )(sizeof(int ) * 2UL));
}
}
#line 8 "/root/patchweave_new/24/lib/zip_err_str.c"
char const   * const  _zip_err_str[32]  = 
#line 8 "/root/patchweave_new/24/lib/zip_err_str.c"
  {      (char const   */* const  */)"No error",      (char const   */* const  */)"Multi-disk zip archives not supported",      (char const   */* const  */)"Renaming temporary file failed",      (char const   */* const  */)"Closing zip archive failed", 
        (char const   */* const  */)"Seek error",      (char const   */* const  */)"Read error",      (char const   */* const  */)"Write error",      (char const   */* const  */)"CRC error", 
        (char const   */* const  */)"Containing zip archive was closed",      (char const   */* const  */)"No such file",      (char const   */* const  */)"File already exists",      (char const   */* const  */)"Can\'t open file", 
        (char const   */* const  */)"Failure to create temporary file\323\001 ",      (char const   */* const  */)"Zlib error",      (char const   */* const  */)"Malloc failure",      (char const   */* const  */)"Entry has been changed", 
        (char const   */* const  */)"Compression method not supported\200\217.\317\342U",      (char const   */* const  */)"Premature end of file",      (char const   */* const  */)"Invalid argument\323\001 ",      (char const   */* const  */)"Not a zip archive", 
        (char const   */* const  */)"Internal error",      (char const   */* const  */)"Zip archive inconsistent\323\001 ",      (char const   */* const  */)"Can\'t remove file",      (char const   */* const  */)"Entry has been deleted", 
        (char const   */* const  */)"Encryption method not supported",      (char const   */* const  */)"Read-only archive",      (char const   */* const  */)"No password provided",      (char const   */* const  */)"Wrong password provided", 
        (char const   */* const  */)"Operation not supported",      (char const   */* const  */)"Resource still in use",      (char const   */* const  */)"Tell error",      (char const   */* const  */)"Compressed data invalid"};
#line 43 "/root/patchweave_new/24/lib/zip_err_str.c"
int const   _zip_nerr_str  =    (int const   )((int )(sizeof(_zip_err_str) / sizeof(_zip_err_str[0])));
#line 49 "/root/patchweave_new/24/lib/zip_err_str.c"
int const   _zip_err_type[32]  = 
#line 49
  {      (int const   )0,      (int const   )0,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )1,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )0};
#line 38 "/root/patchweave_new/24/lib/zip_entry.c"
void _zip_entry_finalize(zip_entry_t *e ) 
{ 


  {
  {
#line 40
  _zip_unchange_data(e);
#line 41
  _zip_dirent_free(e->orig);
#line 42
  _zip_dirent_free(e->changes);
  }
#line 44
  return;
}
}
#line 47 "/root/patchweave_new/24/lib/zip_entry.c"
void _zip_entry_init(zip_entry_t *e ) 
{ 


  {
#line 49
  e->orig = (zip_dirent_t *)((void *)0);
#line 50
  e->changes = (zip_dirent_t *)((void *)0);
#line 51
  e->source = (zip_source_t *)((void *)0);
#line 52
  e->deleted = 0;
#line 53
  return;
}
}
#line 45 "/root/patchweave_new/24/lib/zip_discard.c"
void zip_discard(zip_t *za___0 ) 
{ 
  zip_uint64_t i ;

  {
#line 49
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 50
    return;
  }
#line 52
  if (za___0->src) {
    {
#line 53
    zip_source_close(za___0->src);
#line 54
    zip_source_free(za___0->src);
    }
  }
  {
#line 57
  free((void *)za___0->default_password);
#line 58
  _zip_string_free(za___0->comment_orig);
#line 59
  _zip_string_free(za___0->comment_changes);
#line 61
  _zip_hash_free(za___0->names);
  }
#line 63
  if (za___0->entry) {
#line 64
    i = (zip_uint64_t )0;
    {
#line 64
    while (1) {
      while_continue: /* CIL Label */ ;

#line 64
      if (! (i < za___0->nentry)) {
#line 64
        goto while_break;
      }
      {
#line 65
      _zip_entry_finalize(za___0->entry + i);
#line 64
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 66
    free((void *)za___0->entry);
    }
  }
#line 69
  i = (zip_uint64_t )0;
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 69
    if (! (i < (unsigned long )za___0->nopen_source)) {
#line 69
      goto while_break___0;
    }
    {
#line 70
    _zip_source_invalidate(*(za___0->open_source + i));
#line 69
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 72
  free((void *)za___0->open_source);
#line 74
  _zip_progress_free(za___0->progress);
#line 76
  zip_error_fini(& za___0->error);
#line 78
  free((void *)za___0);
  }
#line 80
  return;
}
}
#line 44 "/root/patchweave_new/24/lib/zip_dirent.c"
static time_t _zip_d2u_time(zip_uint16_t dtime , zip_uint16_t ddate ) ;
#line 45
static zip_string_t *_zip_dirent_process_ef_utf_8(zip_dirent_t *de , zip_uint16_t id ,
                                                  zip_string_t *str ) ;
#line 46
static zip_extra_field_t *_zip_ef_utf8(zip_uint16_t id , zip_string_t *str , zip_error_t *error ) ;
#line 47
static int _zip_dirent_process_winzip_aes(zip_dirent_t *de , zip_error_t *error ) ;
#line 51 "/root/patchweave_new/24/lib/zip_dirent.c"
void _zip_cdir_free(zip_cdir_t *cd ) 
{ 
  zip_uint64_t i ;

  {
#line 55
  if (! cd) {
#line 56
    return;
  }
#line 58
  i = (zip_uint64_t )0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;

#line 58
    if (! (i < cd->nentry)) {
#line 58
      goto while_break;
    }
    {
#line 59
    _zip_entry_finalize(cd->entry + i);
#line 58
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 60
  free((void *)cd->entry);
#line 61
  _zip_string_free(cd->comment);
#line 62
  free((void *)cd);
  }
#line 64
  return;
}
}
#line 67 "/root/patchweave_new/24/lib/zip_dirent.c"
zip_cdir_t *_zip_cdir_new(zip_uint64_t nentry , zip_error_t *error ) 
{ 
  zip_cdir_t *cd ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = malloc(sizeof(*cd));
#line 71
  cd = (zip_cdir_t *)__cil_tmp4;
  }
#line 71
  if ((unsigned long )cd == (unsigned long )((void *)0)) {
    {
#line 72
    zip_error_set(error, 14, 0);
    }
#line 73
    return ((zip_cdir_t *)((void *)0));
  }
  {
#line 76
  cd->entry = (zip_entry_t *)((void *)0);
#line 77
  cd->nentry_alloc = (zip_uint64_t )0;
#line 77
  cd->nentry = cd->nentry_alloc;
#line 78
  cd->offset = (zip_uint64_t )0;
#line 78
  cd->size = cd->offset;
#line 79
  cd->comment = (zip_string_t *)((void *)0);
#line 80
  cd->is_zip64 = 0;
#line 82
  __cil_tmp5 = _zip_cdir_grow(cd, nentry, error);
  }
#line 82
  if (! __cil_tmp5) {
    {
#line 83
    _zip_cdir_free(cd);
    }
#line 84
    return ((zip_cdir_t *)((void *)0));
  }
#line 87
  return (cd);
}
}
#line 92 "/root/patchweave_new/24/lib/zip_dirent.c"
int _zip_cdir_grow(zip_cdir_t *cd , zip_uint64_t additional_entries , zip_error_t *error ) 
{ 
  zip_uint64_t i ;
  zip_uint64_t new_alloc ;
  zip_entry_t *new_entry ;
  void *__cil_tmp7 ;

  {
#line 97
  if (additional_entries == 0UL) {
#line 98
    return (1);
  }
#line 101
  new_alloc = cd->nentry_alloc + additional_entries;
#line 103
  if (new_alloc < additional_entries) {
    {
#line 104
    zip_error_set(error, 14, 0);
    }
#line 105
    return (0);
  } else
#line 103
  if (new_alloc > 0xffffffffffffffffUL / sizeof(*(cd->entry))) {
    {
#line 104
    zip_error_set(error, 14, 0);
    }
#line 105
    return (0);
  }
  {
#line 108
  __cil_tmp7 = realloc((void *)cd->entry, sizeof(*(cd->entry)) * new_alloc);
#line 108
  new_entry = (zip_entry_t *)__cil_tmp7;
  }
#line 108
  if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
    {
#line 109
    zip_error_set(error, 14, 0);
    }
#line 110
    return (0);
  }
#line 113
  cd->entry = new_entry;
#line 115
  i = cd->nentry;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;

#line 115
    if (! (i < new_alloc)) {
#line 115
      goto while_break;
    }
    {
#line 116
    _zip_entry_init(cd->entry + i);
#line 115
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 119
  cd->nentry_alloc = new_alloc;
#line 119
  cd->nentry = cd->nentry_alloc;
#line 121
  return (1);
}
}
#line 126 "/root/patchweave_new/24/lib/zip_dirent.c"
zip_int64_t _zip_cdir_write(zip_t *za___0 , zip_filelist_t *filelist , zip_uint64_t survivors ) 
{ 
  zip_uint64_t offset ;
  zip_uint64_t size ;
  zip_string_t *comment ;
  zip_uint8_t buf[98] ;
  zip_buffer_t *buffer ;
  zip_int64_t off ;
  zip_uint64_t i ;
  int is_zip64 ;
  int ret ;
  zip_entry_t *entry ;
  zip_dirent_t *tmp ;
  int __cil_tmp16 ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  zip_string_t *tmp___4 ;
  int tmp___5 ;
  int __cil_tmp26 ;
  zip_uint8_t *__cil_tmp27 ;
  zip_uint64_t __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
  {
#line 137
  off = zip_source_tell_write(za___0->src);
  }
#line 137
  if (off < 0L) {
    {
#line 138
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 139
    return ((zip_int64_t )-1);
  }
#line 141
  offset = (zip_uint64_t )off;
#line 143
  is_zip64 = 0;
#line 145
  i = (zip_uint64_t )0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;

#line 145
    if (! (i < survivors)) {
#line 145
      goto while_break;
    }
#line 146
    entry = za___0->entry + (filelist + i)->idx;
#line 148
    if (entry->changes) {
#line 148
      tmp = entry->changes;
    } else {
#line 148
      tmp = entry->orig;
    }
    {
#line 148
    __cil_tmp16 = _zip_dirent_write(za___0, tmp, 512U);
#line 148
    ret = __cil_tmp16;
    }
#line 148
    if (ret < 0) {
#line 149
      return ((zip_int64_t )-1);
    }
#line 150
    if (ret) {
#line 151
      is_zip64 = 1;
    }
#line 145
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 154
  off = zip_source_tell_write(za___0->src);
  }
#line 154
  if (off < 0L) {
    {
#line 155
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 156
    return ((zip_int64_t )-1);
  }
#line 158
  size = (zip_uint64_t )off - offset;
#line 160
  if (offset > 4294967295UL) {
#line 161
    is_zip64 = 1;
  } else
#line 160
  if (survivors > 65535UL) {
#line 161
    is_zip64 = 1;
  }
  {
#line 164
  buffer = _zip_buffer_new(buf, sizeof(buf));
  }
#line 164
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 165
    zip_error_set(& za___0->error, 14, 0);
    }
#line 166
    return ((zip_int64_t )-1);
  }
#line 169
  if (is_zip64) {
    {
#line 170
    _zip_buffer_put(buffer, (void const   *)"PK\006\006", (size_t )4);
#line 171
    _zip_buffer_put_64(buffer, (zip_uint64_t )44);
#line 172
    _zip_buffer_put_16(buffer, (zip_uint16_t )45);
#line 173
    _zip_buffer_put_16(buffer, (zip_uint16_t )45);
#line 174
    _zip_buffer_put_32(buffer, (zip_uint32_t )0);
#line 175
    _zip_buffer_put_32(buffer, (zip_uint32_t )0);
#line 176
    _zip_buffer_put_64(buffer, survivors);
#line 177
    _zip_buffer_put_64(buffer, survivors);
#line 178
    _zip_buffer_put_64(buffer, size);
#line 179
    _zip_buffer_put_64(buffer, offset);
#line 180
    _zip_buffer_put(buffer, (void const   *)"PK\006\a", (size_t )4);
#line 181
    _zip_buffer_put_32(buffer, (zip_uint32_t )0);
#line 182
    _zip_buffer_put_64(buffer, offset + size);
#line 183
    _zip_buffer_put_32(buffer, (zip_uint32_t )1);
    }
  }
  {
#line 186
  _zip_buffer_put(buffer, (void const   *)"PK\005\006", (size_t )4);
#line 187
  _zip_buffer_put_32(buffer, (zip_uint32_t )0);
  }
#line 188
  if (survivors >= 65535UL) {
#line 188
    tmp___0 = 65535UL;
  } else {
#line 188
    tmp___0 = survivors;
  }
  {
#line 188
  _zip_buffer_put_16(buffer, (zip_uint16_t )tmp___0);
  }
#line 189
  if (survivors >= 65535UL) {
#line 189
    tmp___1 = 65535UL;
  } else {
#line 189
    tmp___1 = survivors;
  }
  {
#line 189
  _zip_buffer_put_16(buffer, (zip_uint16_t )tmp___1);
  }
#line 190
  if (size >= 4294967295UL) {
#line 190
    tmp___2 = 4294967295U;
  } else {
#line 190
    tmp___2 = (zip_uint32_t )size;
  }
  {
#line 190
  _zip_buffer_put_32(buffer, tmp___2);
  }
#line 191
  if (offset >= 4294967295UL) {
#line 191
    tmp___3 = 4294967295U;
  } else {
#line 191
    tmp___3 = (zip_uint32_t )offset;
  }
  {
#line 191
  _zip_buffer_put_32(buffer, tmp___3);
  }
#line 193
  if (za___0->comment_changed) {
#line 193
    tmp___4 = za___0->comment_changes;
  } else {
#line 193
    tmp___4 = za___0->comment_orig;
  }
#line 193
  comment = tmp___4;
#line 195
  if (comment) {
#line 195
    tmp___5 = (int )comment->length;
  } else {
#line 195
    tmp___5 = 0;
  }
  {
#line 195
  _zip_buffer_put_16(buffer, (zip_uint16_t )tmp___5);
#line 197
  __cil_tmp26 = _zip_buffer_ok(buffer);
  }
#line 197
  if (! __cil_tmp26) {
    {
#line 198
    zip_error_set(& za___0->error, 20, 0);
#line 199
    _zip_buffer_free(buffer);
    }
#line 200
    return ((zip_int64_t )-1);
  }
  {
#line 203
  __cil_tmp27 = _zip_buffer_data(buffer);
#line 203
  __cil_tmp28 = _zip_buffer_offset(buffer);
#line 203
  __cil_tmp29 = _zip_write(za___0, (void const   *)__cil_tmp27, __cil_tmp28);
  }
#line 203
  if (__cil_tmp29 < 0) {
    {
#line 204
    _zip_buffer_free(buffer);
    }
#line 205
    return ((zip_int64_t )-1);
  }
  {
#line 208
  _zip_buffer_free(buffer);
  }
#line 210
  if (comment) {
    {
#line 211
    __cil_tmp30 = _zip_write(za___0, (void const   *)comment->raw, (zip_uint64_t )comment->length);
    }
#line 211
    if (__cil_tmp30 < 0) {
#line 212
      return ((zip_int64_t )-1);
    }
  }
#line 216
  return ((zip_int64_t )size);
}
}
#line 221 "/root/patchweave_new/24/lib/zip_dirent.c"
zip_dirent_t *_zip_dirent_clone(zip_dirent_t *sde ) 
{ 
  zip_dirent_t *tde ;
  void *__cil_tmp3 ;

  {
  {
#line 225
  __cil_tmp3 = malloc(sizeof(*tde));
#line 225
  tde = (zip_dirent_t *)__cil_tmp3;
  }
#line 225
  if ((unsigned long )tde == (unsigned long )((void *)0)) {
#line 226
    return ((zip_dirent_t *)((void *)0));
  }
#line 228
  if (sde) {
    {
#line 229
    memcpy((void *)tde, (void const   *)sde, sizeof(*sde));
    }
  } else {
    {
#line 231
    _zip_dirent_init(tde);
    }
  }
#line 233
  tde->changed = (zip_uint32_t )0;
#line 234
  tde->cloned = 1;
#line 236
  return (tde);
}
}
#line 241 "/root/patchweave_new/24/lib/zip_dirent.c"
void _zip_dirent_finalize(zip_dirent_t *zde ) 
{ 
  unsigned long __cil_tmp2 ;

  {
#line 243
  if (! zde->cloned) {
    {
#line 244
    _zip_string_free(zde->filename);
#line 245
    zde->filename = (zip_string_t *)((void *)0);
    }
  } else
#line 243
  if (zde->changed & 2U) {
    {
#line 244
    _zip_string_free(zde->filename);
#line 245
    zde->filename = (zip_string_t *)((void *)0);
    }
  }
#line 247
  if (! zde->cloned) {
    {
#line 248
    _zip_ef_free(zde->extra_fields);
#line 249
    zde->extra_fields = (zip_extra_field_t *)((void *)0);
    }
  } else
#line 247
  if (zde->changed & 8U) {
    {
#line 248
    _zip_ef_free(zde->extra_fields);
#line 249
    zde->extra_fields = (zip_extra_field_t *)((void *)0);
    }
  }
#line 251
  if (! zde->cloned) {
    {
#line 252
    _zip_string_free(zde->comment);
#line 253
    zde->comment = (zip_string_t *)((void *)0);
    }
  } else
#line 251
  if (zde->changed & 4U) {
    {
#line 252
    _zip_string_free(zde->comment);
#line 253
    zde->comment = (zip_string_t *)((void *)0);
    }
  }
#line 255
  if (! zde->cloned) {
    _L: 
#line 256
    if (zde->password) {
      {
#line 257
      __cil_tmp2 = strlen((char const   *)zde->password);
#line 257
      explicit_bzero((void *)zde->password, __cil_tmp2);
      }
    }
    {
#line 259
    free((void *)zde->password);
#line 260
    zde->password = (char *)((void *)0);
    }
  } else
#line 255
  if (zde->changed & 128U) {
#line 255
    goto _L;
  }
#line 257
  return;
}
}
#line 266 "/root/patchweave_new/24/lib/zip_dirent.c"
void _zip_dirent_free(zip_dirent_t *zde ) 
{ 


  {
#line 268
  if ((unsigned long )zde == (unsigned long )((void *)0)) {
#line 269
    return;
  }
  {
#line 271
  _zip_dirent_finalize(zde);
#line 272
  free((void *)zde);
  }
#line 274
  return;
}
}
#line 277 "/root/patchweave_new/24/lib/zip_dirent.c"
void _zip_dirent_init(zip_dirent_t *de ) 
{ 


  {
#line 279
  de->changed = (zip_uint32_t )0;
#line 280
  de->local_extra_fields_read = 0;
#line 281
  de->cloned = 0;
#line 283
  de->crc_valid = 1;
#line 284
  de->version_madeby = (zip_uint16_t )(63U | (3U << 8));
#line 285
  de->version_needed = (zip_uint16_t )10;
#line 286
  de->bitflags = (zip_uint16_t )0;
#line 287
  de->comp_method = -1;
#line 288
  de->last_mod = (time_t )0;
#line 289
  de->crc = (zip_uint32_t )0;
#line 290
  de->comp_size = (zip_uint64_t )0;
#line 291
  de->uncomp_size = (zip_uint64_t )0;
#line 292
  de->filename = (zip_string_t *)((void *)0);
#line 293
  de->extra_fields = (zip_extra_field_t *)((void *)0);
#line 294
  de->comment = (zip_string_t *)((void *)0);
#line 295
  de->disk_number = (zip_uint32_t )0;
#line 296
  de->int_attrib = (zip_uint16_t )0;
#line 297
  de->ext_attrib = 33206U << 16;
#line 298
  de->offset = (zip_uint64_t )0;
#line 299
  de->compression_level = (zip_uint16_t )0;
#line 300
  de->encryption_method = (zip_uint16_t )0;
#line 301
  de->password = (char *)((void *)0);
#line 302
  return;
}
}
#line 306 "/root/patchweave_new/24/lib/zip_dirent.c"
int _zip_dirent_needs_zip64(zip_dirent_t *de , zip_flags_t flags ) 
{ 


  {
#line 308
  if (de->uncomp_size >= 4294967295UL) {
#line 310
    return (1);
  } else
#line 308
  if (de->comp_size >= 4294967295UL) {
#line 310
    return (1);
  } else
#line 308
  if (flags & 512U) {
#line 308
    if (de->offset >= 4294967295UL) {
#line 310
      return (1);
    }
  }
#line 312
  return (0);
}
}
#line 317 "/root/patchweave_new/24/lib/zip_dirent.c"
zip_dirent_t *_zip_dirent_new(void) 
{ 
  zip_dirent_t *de ;
  void *__cil_tmp2 ;

  {
  {
#line 321
  __cil_tmp2 = malloc(sizeof(*de));
#line 321
  de = (zip_dirent_t *)__cil_tmp2;
  }
#line 321
  if ((unsigned long )de == (unsigned long )((void *)0)) {
#line 322
    return ((zip_dirent_t *)((void *)0));
  }
  {
#line 324
  _zip_dirent_init(de);
  }
#line 325
  return (de);
}
}
#line 340 "/root/patchweave_new/24/lib/zip_dirent.c"
zip_int64_t _zip_dirent_read(zip_dirent_t *zde , zip_source_t *src , zip_buffer_t *buffer ,
                             int local , zip_error_t *error ) 
{ 
  zip_uint8_t buf[46] ;
  zip_uint16_t dostime ;
  zip_uint16_t dosdate ;
  zip_uint32_t size ;
  zip_uint32_t variable_size ;
  zip_uint16_t filename_len ;
  zip_uint16_t comment_len ;
  zip_uint16_t ef_len ;
  int from_buffer ;
  unsigned int tmp ;
  zip_uint64_t __cil_tmp16 ;
  zip_uint8_t *__cil_tmp18 ;
  char const   *tmp___0 ;
  int __cil_tmp20 ;
  zip_uint16_t __cil_tmp24 ;
  zip_uint32_t __cil_tmp29 ;
  zip_uint32_t __cil_tmp30 ;
  zip_uint16_t __cil_tmp34 ;
  zip_uint32_t __cil_tmp37 ;
  int __cil_tmp38 ;
  zip_uint64_t __cil_tmp39 ;
  int __cil_tmp42 ;
  enum zip_encoding_type __cil_tmp43 ;
  zip_uint8_t *ef ;
  zip_uint8_t *__cil_tmp45 ;
  unsigned int tmp___1 ;
  int __cil_tmp47 ;
  enum zip_encoding_type __cil_tmp49 ;
  zip_uint16_t got_len ;
  zip_buffer_t *ef_buffer ;
  zip_uint8_t *ef___0 ;
  unsigned int tmp___2 ;
  zip_uint8_t *__cil_tmp56 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;

  {
#line 347
  from_buffer = (unsigned long )buffer != (unsigned long )((void *)0);
#line 349
  if (local) {
#line 349
    tmp = 30U;
  } else {
#line 349
    tmp = 46U;
  }
#line 349
  size = tmp;
#line 351
  if (buffer) {
    {
#line 352
    __cil_tmp16 = _zip_buffer_left(buffer);
    }
#line 352
    if (__cil_tmp16 < (unsigned long )size) {
      {
#line 353
      zip_error_set(error, 19, 0);
      }
#line 354
      return ((zip_int64_t )-1);
    }
  } else {
    {
#line 358
    buffer = _zip_buffer_new_from_source(src, (zip_uint64_t )size, buf, error);
    }
#line 358
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 359
      return ((zip_int64_t )-1);
    }
  }
  {
#line 363
  __cil_tmp18 = _zip_buffer_get(buffer, (zip_uint64_t )4);
  }
#line 363
  if (local) {
#line 363
    tmp___0 = "PK\003\004";
  } else {
#line 363
    tmp___0 = "PK\001\002";
  }
  {
#line 363
  __cil_tmp20 = memcmp((void const   *)__cil_tmp18, (void const   *)tmp___0, 4UL);
  }
#line 363
  if (__cil_tmp20 != 0) {
    {
#line 364
    zip_error_set(error, 19, 0);
    }
#line 365
    if (! from_buffer) {
      {
#line 366
      _zip_buffer_free(buffer);
      }
    }
#line 368
    return ((zip_int64_t )-1);
  }
  {
#line 373
  _zip_dirent_init(zde);
  }
#line 374
  if (! local) {
    {
#line 375
    zde->version_madeby = _zip_buffer_get_16(buffer);
    }
  } else {
#line 377
    zde->version_madeby = (zip_uint16_t )0;
  }
  {
#line 378
  zde->version_needed = _zip_buffer_get_16(buffer);
#line 379
  zde->bitflags = _zip_buffer_get_16(buffer);
#line 380
  __cil_tmp24 = _zip_buffer_get_16(buffer);
#line 380
  zde->comp_method = (zip_int32_t )__cil_tmp24;
#line 383
  dostime = _zip_buffer_get_16(buffer);
#line 384
  dosdate = _zip_buffer_get_16(buffer);
#line 385
  zde->last_mod = _zip_d2u_time(dostime, dosdate);
#line 387
  zde->crc = _zip_buffer_get_32(buffer);
#line 388
  __cil_tmp29 = _zip_buffer_get_32(buffer);
#line 388
  zde->comp_size = (zip_uint64_t )__cil_tmp29;
#line 389
  __cil_tmp30 = _zip_buffer_get_32(buffer);
#line 389
  zde->uncomp_size = (zip_uint64_t )__cil_tmp30;
#line 391
  filename_len = _zip_buffer_get_16(buffer);
#line 392
  ef_len = _zip_buffer_get_16(buffer);
  }
#line 394
  if (local) {
#line 395
    comment_len = (zip_uint16_t )0;
#line 396
    zde->disk_number = (zip_uint32_t )0;
#line 397
    zde->int_attrib = (zip_uint16_t )0;
#line 398
    zde->ext_attrib = (zip_uint32_t )0;
#line 399
    zde->offset = (zip_uint64_t )0;
  } else {
    {
#line 401
    comment_len = _zip_buffer_get_16(buffer);
#line 402
    __cil_tmp34 = _zip_buffer_get_16(buffer);
#line 402
    zde->disk_number = (zip_uint32_t )__cil_tmp34;
#line 403
    zde->int_attrib = _zip_buffer_get_16(buffer);
#line 404
    zde->ext_attrib = _zip_buffer_get_32(buffer);
#line 405
    __cil_tmp37 = _zip_buffer_get_32(buffer);
#line 405
    zde->offset = (zip_uint64_t )__cil_tmp37;
    }
  }
  {
#line 408
  __cil_tmp38 = _zip_buffer_ok(buffer);
  }
#line 408
  if (! __cil_tmp38) {
    {
#line 409
    zip_error_set(error, 20, 0);
    }
#line 410
    if (! from_buffer) {
      {
#line 411
      _zip_buffer_free(buffer);
      }
    }
#line 413
    return ((zip_int64_t )-1);
  }
#line 416
  if ((unsigned int )zde->bitflags & 1U) {
#line 417
    if ((unsigned int )zde->bitflags & 64U) {
#line 419
      zde->encryption_method = (zip_uint16_t )65535;
    } else {
#line 422
      zde->encryption_method = (zip_uint16_t )1;
    }
  } else {
#line 426
    zde->encryption_method = (zip_uint16_t )0;
  }
#line 429
  zde->filename = (zip_string_t *)((void *)0);
#line 430
  zde->extra_fields = (zip_extra_field_t *)((void *)0);
#line 431
  zde->comment = (zip_string_t *)((void *)0);
#line 433
  variable_size = ((zip_uint32_t )filename_len + (zip_uint32_t )ef_len) + (zip_uint32_t )comment_len;
#line 435
  if (from_buffer) {
    {
#line 436
    __cil_tmp39 = _zip_buffer_left(buffer);
    }
#line 436
    if (__cil_tmp39 < (unsigned long )variable_size) {
      {
#line 437
      zip_error_set(error, 21, 0);
      }
#line 438
      return ((zip_int64_t )-1);
    }
  } else {
    {
#line 442
    _zip_buffer_free(buffer);
#line 444
    buffer = _zip_buffer_new_from_source(src, (zip_uint64_t )variable_size, (zip_uint8_t *)((void *)0),
                                         error);
    }
#line 444
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 445
      return ((zip_int64_t )-1);
    }
  }
#line 449
  if (filename_len) {
    {
#line 450
    zde->filename = _zip_read_string(buffer, src, filename_len, 1, error);
    }
#line 451
    if (! zde->filename) {
      {
#line 452
      __cil_tmp42 = zip_error_code_zip(error);
      }
#line 452
      if (__cil_tmp42 == 17) {
        {
#line 453
        zip_error_set(error, 21, 0);
        }
      }
#line 455
      if (! from_buffer) {
        {
#line 456
        _zip_buffer_free(buffer);
        }
      }
#line 458
      return ((zip_int64_t )-1);
    }
#line 461
    if ((unsigned int )zde->bitflags & 2048U) {
      {
#line 462
      __cil_tmp43 = _zip_guess_encoding(zde->filename, (enum zip_encoding_type )2);
      }
#line 462
      if ((unsigned int )__cil_tmp43 == 5U) {
        {
#line 463
        zip_error_set(error, 21, 0);
        }
#line 464
        if (! from_buffer) {
          {
#line 465
          _zip_buffer_free(buffer);
          }
        }
#line 467
        return ((zip_int64_t )-1);
      }
    }
  }
#line 472
  if (ef_len) {
    {
#line 473
    __cil_tmp45 = _zip_read_data(buffer, src, (size_t )ef_len, 0, error);
#line 473
    ef = __cil_tmp45;
    }
#line 475
    if ((unsigned long )ef == (unsigned long )((void *)0)) {
#line 476
      if (! from_buffer) {
        {
#line 477
        _zip_buffer_free(buffer);
        }
      }
#line 479
      return ((zip_int64_t )-1);
    }
#line 481
    if (local) {
#line 481
      tmp___1 = 256U;
    } else {
#line 481
      tmp___1 = 512U;
    }
    {
#line 481
    __cil_tmp47 = _zip_ef_parse(ef, ef_len, tmp___1, & zde->extra_fields, error);
    }
#line 481
    if (! __cil_tmp47) {
      {
#line 482
      free((void *)ef);
      }
#line 483
      if (! from_buffer) {
        {
#line 484
        _zip_buffer_free(buffer);
        }
      }
#line 486
      return ((zip_int64_t )-1);
    }
    {
#line 488
    free((void *)ef);
    }
#line 489
    if (local) {
#line 490
      zde->local_extra_fields_read = 1;
    }
  }
#line 493
  if (comment_len) {
    {
#line 494
    zde->comment = _zip_read_string(buffer, src, comment_len, 0, error);
    }
#line 495
    if (! zde->comment) {
#line 496
      if (! from_buffer) {
        {
#line 497
        _zip_buffer_free(buffer);
        }
      }
#line 499
      return ((zip_int64_t )-1);
    }
#line 501
    if ((unsigned int )zde->bitflags & 2048U) {
      {
#line 502
      __cil_tmp49 = _zip_guess_encoding(zde->comment, (enum zip_encoding_type )2);
      }
#line 502
      if ((unsigned int )__cil_tmp49 == 5U) {
        {
#line 503
        zip_error_set(error, 21, 0);
        }
#line 504
        if (! from_buffer) {
          {
#line 505
          _zip_buffer_free(buffer);
          }
        }
#line 507
        return ((zip_int64_t )-1);
      }
    }
  }
  {
#line 512
  zde->filename = _zip_dirent_process_ef_utf_8(zde, (zip_uint16_t )28789, zde->filename);
#line 513
  zde->comment = _zip_dirent_process_ef_utf_8(zde, (zip_uint16_t )25461, zde->comment);
  }
#line 517
  if (zde->uncomp_size == 4294967295UL) {
    _L: 
#line 520
    if (local) {
#line 520
      tmp___2 = 256U;
    } else {
#line 520
      tmp___2 = 512U;
    }
    {
#line 520
    __cil_tmp56 = _zip_ef_get_by_id(zde->extra_fields, & got_len, (zip_uint16_t )1,
                                    (zip_uint16_t )0, tmp___2, error);
#line 520
    ef___0 = __cil_tmp56;
    }
#line 522
    if ((unsigned long )ef___0 == (unsigned long )((void *)0)) {
#line 523
      if (! from_buffer) {
        {
#line 524
        _zip_buffer_free(buffer);
        }
      }
#line 526
      return ((zip_int64_t )-1);
    }
    {
#line 529
    ef_buffer = _zip_buffer_new(ef___0, (zip_uint64_t )got_len);
    }
#line 529
    if ((unsigned long )ef_buffer == (unsigned long )((void *)0)) {
      {
#line 530
      zip_error_set(error, 14, 0);
      }
#line 531
      if (! from_buffer) {
        {
#line 532
        _zip_buffer_free(buffer);
        }
      }
#line 534
      return ((zip_int64_t )-1);
    }
#line 537
    if (zde->uncomp_size == 4294967295UL) {
      {
#line 538
      zde->uncomp_size = _zip_buffer_get_64(ef_buffer);
      }
    } else
#line 539
    if (local) {
      {
#line 542
      _zip_buffer_skip(ef_buffer, (zip_uint64_t )8);
      }
    }
#line 544
    if (zde->comp_size == 4294967295UL) {
      {
#line 545
      zde->comp_size = _zip_buffer_get_64(ef_buffer);
      }
    }
#line 546
    if (! local) {
#line 547
      if (zde->offset == 4294967295UL) {
        {
#line 548
        zde->offset = _zip_buffer_get_64(ef_buffer);
        }
      }
#line 549
      if (zde->disk_number == 65535U) {
        {
#line 550
        zde->disk_number = _zip_buffer_get_32(buffer);
        }
      }
    }
    {
#line 553
    __cil_tmp62 = _zip_buffer_eof(ef_buffer);
    }
#line 553
    if (! __cil_tmp62) {
      {
#line 554
      zip_error_set(error, 21, 0);
#line 555
      _zip_buffer_free(ef_buffer);
      }
#line 556
      if (! from_buffer) {
        {
#line 557
        _zip_buffer_free(buffer);
        }
      }
#line 559
      return ((zip_int64_t )-1);
    }
    {
#line 561
    _zip_buffer_free(ef_buffer);
    }
  } else
#line 517
  if (zde->comp_size == 4294967295UL) {
#line 517
    goto _L;
  } else
#line 517
  if (zde->offset == 4294967295UL) {
#line 517
    goto _L;
  }
  {
#line 564
  __cil_tmp63 = _zip_buffer_ok(buffer);
  }
#line 564
  if (! __cil_tmp63) {
    {
#line 565
    zip_error_set(error, 20, 0);
    }
#line 566
    if (! from_buffer) {
      {
#line 567
      _zip_buffer_free(buffer);
      }
    }
#line 569
    return ((zip_int64_t )-1);
  }
#line 571
  if (! from_buffer) {
    {
#line 572
    _zip_buffer_free(buffer);
    }
  }
#line 576
  if (zde->offset > 0xffffffffffffffffUL) {
    {
#line 577
    zip_error_set(error, 4, 27);
    }
#line 578
    return ((zip_int64_t )-1);
  }
  {
#line 581
  __cil_tmp64 = _zip_dirent_process_winzip_aes(zde, error);
  }
#line 581
  if (! __cil_tmp64) {
#line 582
    return ((zip_int64_t )-1);
  }
  {
#line 585
  zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);
  }
#line 587
  return ((zip_int64_t )(size + variable_size));
}
}
#line 592 "/root/patchweave_new/24/lib/zip_dirent.c"
static zip_string_t *_zip_dirent_process_ef_utf_8(zip_dirent_t *de , zip_uint16_t id ,
                                                  zip_string_t *str ) 
{ 
  zip_uint16_t ef_len ;
  zip_uint32_t ef_crc ;
  zip_buffer_t *buffer ;
  zip_uint8_t *ef ;
  zip_uint8_t *__cil_tmp8 ;
  zip_uint32_t __cil_tmp11 ;
  zip_uint16_t len ;
  zip_uint64_t __cil_tmp13 ;
  zip_string_t *ef_str ;
  zip_uint8_t *__cil_tmp15 ;
  zip_string_t *__cil_tmp16 ;

  {
  {
#line 598
  __cil_tmp8 = _zip_ef_get_by_id(de->extra_fields, & ef_len, id, (zip_uint16_t )0,
                                 768U, (zip_error_t *)((void *)0));
#line 598
  ef = __cil_tmp8;
  }
#line 600
  if ((unsigned long )ef == (unsigned long )((void *)0)) {
#line 601
    return (str);
  } else
#line 600
  if ((int )ef_len < 5) {
#line 601
    return (str);
  } else
#line 600
  if ((int )*(ef + 0) != 1) {
#line 601
    return (str);
  }
  {
#line 604
  buffer = _zip_buffer_new(ef, (zip_uint64_t )ef_len);
  }
#line 604
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 605
    return (str);
  }
  {
#line 608
  _zip_buffer_get_8(buffer);
#line 609
  ef_crc = _zip_buffer_get_32(buffer);
#line 611
  __cil_tmp11 = _zip_string_crc32(str);
  }
#line 611
  if (__cil_tmp11 == ef_crc) {
    {
#line 612
    __cil_tmp13 = _zip_buffer_left(buffer);
#line 612
    len = (zip_uint16_t )__cil_tmp13;
#line 613
    __cil_tmp15 = _zip_buffer_get(buffer, (zip_uint64_t )len);
#line 613
    __cil_tmp16 = _zip_string_new(__cil_tmp15, len, 2048U, (zip_error_t *)((void *)0));
#line 613
    ef_str = __cil_tmp16;
    }
#line 615
    if ((unsigned long )ef_str != (unsigned long )((void *)0)) {
      {
#line 616
      _zip_string_free(str);
#line 617
      str = ef_str;
      }
    }
  }
  {
#line 621
  _zip_buffer_free(buffer);
  }
#line 623
  return (str);
}
}
#line 628 "/root/patchweave_new/24/lib/zip_dirent.c"
static int _zip_dirent_process_winzip_aes(zip_dirent_t *de , zip_error_t *error ) 
{ 
  zip_uint16_t ef_len ;
  zip_buffer_t *buffer ;
  zip_uint8_t *ef ;
  int crc_valid ;
  zip_uint16_t enc_method ;
  zip_uint16_t __cil_tmp10 ;
  zip_uint8_t *__cil_tmp11 ;
  int __cil_tmp12 ;
  zip_uint8_t __cil_tmp13 ;
  zip_uint16_t __cil_tmp14 ;

  {
#line 637
  if (de->comp_method != 99) {
#line 638
    return (1);
  }
  {
#line 641
  ef = _zip_ef_get_by_id(de->extra_fields, & ef_len, (zip_uint16_t )39169, (zip_uint16_t )0,
                         768U, (zip_error_t *)((void *)0));
  }
#line 643
  if ((unsigned long )ef == (unsigned long )((void *)0)) {
    {
#line 644
    zip_error_set(error, 21, 0);
    }
#line 645
    return (0);
  } else
#line 643
  if ((int )ef_len < 7) {
    {
#line 644
    zip_error_set(error, 21, 0);
    }
#line 645
    return (0);
  }
  {
#line 648
  buffer = _zip_buffer_new(ef, (zip_uint64_t )ef_len);
  }
#line 648
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 649
    zip_error_set(error, 20, 0);
    }
#line 650
    return (0);
  }
  {
#line 655
  crc_valid = 1;
#line 656
  __cil_tmp10 = _zip_buffer_get_16(buffer);
  }
#line 657
  if ((int )__cil_tmp10 == 1) {
#line 657
    goto case_1;
  }
#line 660
  if ((int )__cil_tmp10 == 2) {
#line 660
    goto case_2;
  }
#line 666
  goto switch_default;
  case_1: 
#line 658
  goto switch_break;
  case_2: 
#line 661
  if (de->uncomp_size < 20UL) {
#line 662
    crc_valid = 0;
  }
#line 664
  goto switch_break;
  switch_default: 
  {
#line 667
  zip_error_set(error, 24, 0);
#line 668
  _zip_buffer_free(buffer);
  }
#line 669
  return (0);
  switch_break: 
  {
#line 673
  __cil_tmp11 = _zip_buffer_get(buffer, (zip_uint64_t )2);
#line 673
  __cil_tmp12 = memcmp((void const   *)__cil_tmp11, (void const   *)"AE\203\317\342U",
                       2UL);
  }
#line 673
  if (__cil_tmp12 != 0) {
    {
#line 674
    zip_error_set(error, 24, 0);
#line 675
    _zip_buffer_free(buffer);
    }
#line 676
    return (0);
  }
  {
#line 680
  __cil_tmp13 = _zip_buffer_get_8(buffer);
  }
#line 681
  if ((int )__cil_tmp13 == 1) {
#line 681
    goto case_1___0;
  }
#line 684
  if ((int )__cil_tmp13 == 2) {
#line 684
    goto case_2___0;
  }
#line 687
  if ((int )__cil_tmp13 == 3) {
#line 687
    goto case_3;
  }
#line 690
  goto switch_default___0;
  case_1___0: 
#line 682
  enc_method = (zip_uint16_t )257;
#line 683
  goto switch_break___0;
  case_2___0: 
#line 685
  enc_method = (zip_uint16_t )258;
#line 686
  goto switch_break___0;
  case_3: 
#line 688
  enc_method = (zip_uint16_t )259;
#line 689
  goto switch_break___0;
  switch_default___0: 
  {
#line 691
  zip_error_set(error, 24, 0);
#line 692
  _zip_buffer_free(buffer);
  }
#line 693
  return (0);
  switch_break___0: ;
#line 696
  if ((int )ef_len != 7) {
    {
#line 697
    zip_error_set(error, 21, 0);
#line 698
    _zip_buffer_free(buffer);
    }
#line 699
    return (0);
  }
  {
#line 702
  de->crc_valid = crc_valid;
#line 703
  de->encryption_method = enc_method;
#line 704
  __cil_tmp14 = _zip_buffer_get_16(buffer);
#line 704
  de->comp_method = (zip_int32_t )__cil_tmp14;
#line 706
  _zip_buffer_free(buffer);
  }
#line 707
  return (1);
}
}
#line 712 "/root/patchweave_new/24/lib/zip_dirent.c"
zip_int32_t _zip_dirent_size(zip_source_t *src , zip_uint16_t flags , zip_error_t *error ) 
{ 
  zip_int32_t size ;
  int local ;
  int i ;
  zip_uint8_t b[6] ;
  zip_buffer_t *buffer ;
  unsigned int tmp ;
  int tmp___0 ;
  int __cil_tmp11 ;
  int tmp___1 ;
  zip_buffer_t *__cil_tmp13 ;
  int tmp___2 ;
  zip_uint16_t __cil_tmp15 ;
  int __cil_tmp17 ;

  {
#line 715
  local = ((unsigned int )flags & 256U) != 0U;
#line 720
  if (local) {
#line 720
    tmp = 30U;
  } else {
#line 720
    tmp = 46U;
  }
#line 720
  size = (zip_int32_t )tmp;
#line 722
  if (local) {
#line 722
    tmp___0 = 26;
  } else {
#line 722
    tmp___0 = 28;
  }
  {
#line 722
  __cil_tmp11 = zip_source_seek(src, (zip_int64_t )tmp___0, 1);
  }
#line 722
  if (__cil_tmp11 < 0) {
    {
#line 723
    _zip_error_set_from_source(error, src);
    }
#line 724
    return (-1);
  }
#line 727
  if (local) {
#line 727
    tmp___1 = 4;
  } else {
#line 727
    tmp___1 = 6;
  }
  {
#line 727
  __cil_tmp13 = _zip_buffer_new_from_source(src, (zip_uint64_t )tmp___1, b, error);
#line 727
  buffer = __cil_tmp13;
  }
#line 727
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 728
    return (-1);
  }
#line 731
  i = 0;
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;

#line 731
    if (! (i < tmp___2)) {
#line 731
      goto while_break;
    }
    {
#line 732
    __cil_tmp15 = _zip_buffer_get_16(buffer);
#line 732
    size += (int )__cil_tmp15;
#line 731
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 735
  __cil_tmp17 = _zip_buffer_eof(buffer);
  }
#line 735
  if (! __cil_tmp17) {
    {
#line 736
    zip_error_set(error, 20, 0);
#line 737
    _zip_buffer_free(buffer);
    }
#line 738
    return (-1);
  }
  {
#line 741
  _zip_buffer_free(buffer);
  }
#line 742
  return (size);
}
}
#line 757 "/root/patchweave_new/24/lib/zip_dirent.c"
int _zip_dirent_write(zip_t *za___0 , zip_dirent_t *de , zip_flags_t flags ) 
{ 
  zip_uint16_t dostime ;
  zip_uint16_t dosdate ;
  zip_encoding_type_t com_enc ;
  zip_encoding_type_t name_enc ;
  zip_extra_field_t *ef ;
  zip_extra_field_t *ef64 ;
  zip_uint32_t ef_total_size ;
  int is_zip64 ;
  int is_really_zip64 ;
  int is_winzip_aes ;
  zip_uint8_t buf[46] ;
  zip_buffer_t *buffer ;
  zip_extra_field_t *ef2 ;
  zip_extra_field_t *__cil_tmp20 ;
  zip_uint8_t ef_zip64[28] ;
  zip_buffer_t *ef_buffer ;
  zip_buffer_t *__cil_tmp24 ;
  int __cil_tmp25 ;
  zip_uint64_t __cil_tmp26 ;
  zip_extra_field_t *__cil_tmp27 ;
  zip_uint8_t data[7] ;
  zip_buffer_t *ef_buffer___0 ;
  zip_buffer_t *__cil_tmp30 ;
  zip_extra_field_t *ef_winzip ;
  int __cil_tmp32 ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  zip_uint16_t __cil_tmp38 ;
  zip_uint16_t __cil_tmp39 ;
  zip_uint16_t __cil_tmp40 ;
  zip_uint16_t __cil_tmp41 ;
  int __cil_tmp42 ;
  zip_uint64_t __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 770
  ef = (zip_extra_field_t *)((void *)0);
#line 772
  name_enc = _zip_guess_encoding(de->filename, (enum zip_encoding_type )0);
#line 773
  com_enc = _zip_guess_encoding(de->comment, (enum zip_encoding_type )0);
  }
#line 775
  if ((unsigned int )name_enc == 2U) {
#line 775
    if ((unsigned int )com_enc == 1U) {
#line 778
      de->bitflags = (zip_uint16_t )((unsigned int )de->bitflags | 2048U);
    } else {
#line 775
      goto _L___18;
    }
  } else
  _L___18: 
#line 775
  if ((unsigned int )name_enc == 1U) {
#line 775
    if ((unsigned int )com_enc == 2U) {
#line 778
      de->bitflags = (zip_uint16_t )((unsigned int )de->bitflags | 2048U);
    } else {
#line 775
      goto _L___17;
    }
  } else
  _L___17: 
#line 775
  if ((unsigned int )name_enc == 2U) {
#line 775
    if ((unsigned int )com_enc == 2U) {
#line 778
      de->bitflags = (zip_uint16_t )((unsigned int )de->bitflags | 2048U);
    } else {
#line 775
      goto _L;
    }
  } else {
    _L: 
#line 780
    de->bitflags = (zip_uint16_t )((int )de->bitflags & 63487);
#line 781
    if ((unsigned int )name_enc == 2U) {
      {
#line 782
      ef = _zip_ef_utf8((zip_uint16_t )28789, de->filename, & za___0->error);
      }
#line 783
      if ((unsigned long )ef == (unsigned long )((void *)0)) {
#line 784
        return (-1);
      }
    }
#line 786
    if ((flags & 256U) == 0U) {
#line 786
      if ((unsigned int )com_enc == 2U) {
        {
#line 787
        __cil_tmp20 = _zip_ef_utf8((zip_uint16_t )25461, de->comment, & za___0->error);
#line 787
        ef2 = __cil_tmp20;
        }
#line 788
        if ((unsigned long )ef2 == (unsigned long )((void *)0)) {
          {
#line 789
          _zip_ef_free(ef);
          }
#line 790
          return (-1);
        }
#line 792
        ef2->next = ef;
#line 793
        ef = ef2;
      }
    }
  }
#line 797
  if ((int )de->encryption_method == 0) {
#line 798
    de->bitflags = (zip_uint16_t )((int )de->bitflags & 65534);
  } else {
#line 801
    de->bitflags = (zip_uint16_t )((int )de->bitflags | 1);
  }
  {
#line 804
  is_really_zip64 = _zip_dirent_needs_zip64(de, flags);
  }
#line 805
  if ((flags & 1280U) == 1280U) {
#line 805
    tmp___2 = 1;
  } else
#line 805
  if (is_really_zip64) {
#line 805
    tmp___2 = 1;
  } else {
#line 805
    tmp___2 = 0;
  }
#line 805
  is_zip64 = tmp___2;
#line 806
  if ((int )de->encryption_method == 257) {
#line 806
    tmp___3 = 1;
  } else
#line 806
  if ((int )de->encryption_method == 258) {
#line 806
    tmp___3 = 1;
  } else
#line 806
  if ((int )de->encryption_method == 259) {
#line 806
    tmp___3 = 1;
  } else {
#line 806
    tmp___3 = 0;
  }
#line 806
  is_winzip_aes = tmp___3;
#line 808
  if (is_zip64) {
    {
#line 810
    __cil_tmp24 = _zip_buffer_new(ef_zip64, sizeof(ef_zip64));
#line 810
    ef_buffer = __cil_tmp24;
    }
#line 811
    if ((unsigned long )ef_buffer == (unsigned long )((void *)0)) {
      {
#line 812
      zip_error_set(& za___0->error, 14, 0);
#line 813
      _zip_ef_free(ef);
      }
#line 814
      return (-1);
    }
#line 817
    if (flags & 256U) {
#line 818
      if (flags & 1024U) {
        {
#line 819
        _zip_buffer_put_64(ef_buffer, de->uncomp_size);
#line 820
        _zip_buffer_put_64(ef_buffer, de->comp_size);
        }
      } else
#line 818
      if (de->comp_size > 4294967295UL) {
        {
#line 819
        _zip_buffer_put_64(ef_buffer, de->uncomp_size);
#line 820
        _zip_buffer_put_64(ef_buffer, de->comp_size);
        }
      } else
#line 818
      if (de->uncomp_size > 4294967295UL) {
        {
#line 819
        _zip_buffer_put_64(ef_buffer, de->uncomp_size);
#line 820
        _zip_buffer_put_64(ef_buffer, de->comp_size);
        }
      }
    } else
#line 824
    if (flags & 1024U) {
      _L___19: 
#line 825
      if (de->uncomp_size >= 4294967295UL) {
        {
#line 826
        _zip_buffer_put_64(ef_buffer, de->uncomp_size);
        }
      }
#line 828
      if (de->comp_size >= 4294967295UL) {
        {
#line 829
        _zip_buffer_put_64(ef_buffer, de->comp_size);
        }
      }
#line 831
      if (de->offset >= 4294967295UL) {
        {
#line 832
        _zip_buffer_put_64(ef_buffer, de->offset);
        }
      }
    } else
#line 824
    if (de->comp_size > 4294967295UL) {
#line 824
      goto _L___19;
    } else
#line 824
    if (de->uncomp_size > 4294967295UL) {
#line 824
      goto _L___19;
    } else
#line 824
    if (de->offset > 4294967295UL) {
#line 824
      goto _L___19;
    }
    {
#line 837
    __cil_tmp25 = _zip_buffer_ok(ef_buffer);
    }
#line 837
    if (! __cil_tmp25) {
      {
#line 838
      zip_error_set(& za___0->error, 20, 0);
#line 839
      _zip_buffer_free(ef_buffer);
#line 840
      _zip_ef_free(ef);
      }
#line 841
      return (-1);
    }
    {
#line 844
    __cil_tmp26 = _zip_buffer_offset(ef_buffer);
#line 844
    __cil_tmp27 = _zip_ef_new((zip_uint16_t )1, (zip_uint16_t )__cil_tmp26, ef_zip64,
                              768U);
#line 844
    ef64 = __cil_tmp27;
#line 845
    _zip_buffer_free(ef_buffer);
#line 846
    ef64->next = ef;
#line 847
    ef = ef64;
    }
  }
#line 850
  if (is_winzip_aes) {
    {
#line 852
    __cil_tmp30 = _zip_buffer_new(data, sizeof(data));
#line 852
    ef_buffer___0 = __cil_tmp30;
    }
#line 855
    if ((unsigned long )ef_buffer___0 == (unsigned long )((void *)0)) {
      {
#line 856
      zip_error_set(& za___0->error, 14, 0);
#line 857
      _zip_ef_free(ef);
      }
#line 858
      return (-1);
    }
    {
#line 861
    _zip_buffer_put_16(ef_buffer___0, (zip_uint16_t )2);
#line 862
    _zip_buffer_put(ef_buffer___0, (void const   *)"AE", (size_t )2);
#line 863
    _zip_buffer_put_8(ef_buffer___0, (zip_uint8_t )((int )de->encryption_method & 255));
#line 864
    _zip_buffer_put_16(ef_buffer___0, (zip_uint16_t )de->comp_method);
#line 866
    __cil_tmp32 = _zip_buffer_ok(ef_buffer___0);
    }
#line 866
    if (! __cil_tmp32) {
      {
#line 867
      zip_error_set(& za___0->error, 20, 0);
#line 868
      _zip_buffer_free(ef_buffer___0);
#line 869
      _zip_ef_free(ef);
      }
#line 870
      return (-1);
    }
    {
#line 873
    ef_winzip = _zip_ef_new((zip_uint16_t )39169, (zip_uint16_t )7, data, 768U);
#line 874
    _zip_buffer_free(ef_buffer___0);
#line 875
    ef_winzip->next = ef;
#line 876
    ef = ef_winzip;
    }
  }
  {
#line 879
  buffer = _zip_buffer_new(buf, sizeof(buf));
  }
#line 879
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 880
    zip_error_set(& za___0->error, 14, 0);
#line 881
    _zip_ef_free(ef);
    }
#line 882
    return (-1);
  }
#line 885
  if (flags & 256U) {
#line 885
    tmp = "PK\003\004";
  } else {
#line 885
    tmp = "PK\001\002";
  }
  {
#line 885
  _zip_buffer_put(buffer, (void const   *)tmp, (size_t )4);
  }
#line 887
  if ((flags & 256U) == 0U) {
#line 888
    if (is_really_zip64) {
#line 888
      tmp___0 = 45;
    } else {
#line 888
      tmp___0 = (int )de->version_madeby;
    }
    {
#line 888
    _zip_buffer_put_16(buffer, (zip_uint16_t )tmp___0);
    }
  }
#line 890
  if (is_really_zip64) {
#line 890
    tmp___1 = 45;
  } else {
#line 890
    tmp___1 = (int )de->version_needed;
  }
  {
#line 890
  _zip_buffer_put_16(buffer, (zip_uint16_t )tmp___1);
#line 891
  _zip_buffer_put_16(buffer, de->bitflags);
  }
#line 892
  if (is_winzip_aes) {
    {
#line 893
    _zip_buffer_put_16(buffer, (zip_uint16_t )99);
    }
  } else {
    {
#line 896
    _zip_buffer_put_16(buffer, (zip_uint16_t )de->comp_method);
    }
  }
  {
#line 899
  _zip_u2d_time(de->last_mod, & dostime, & dosdate);
#line 900
  _zip_buffer_put_16(buffer, dostime);
#line 901
  _zip_buffer_put_16(buffer, dosdate);
  }
#line 903
  if (is_winzip_aes) {
#line 903
    if (de->uncomp_size < 20UL) {
      {
#line 904
      _zip_buffer_put_32(buffer, (zip_uint32_t )0);
      }
    } else {
      {
#line 907
      _zip_buffer_put_32(buffer, de->crc);
      }
    }
  } else {
    {
#line 907
    _zip_buffer_put_32(buffer, de->crc);
    }
  }
#line 910
  if ((flags & 256U) == 256U) {
#line 910
    if (de->comp_size >= 4294967295UL) {
      {
#line 916
      _zip_buffer_put_32(buffer, 4294967295U);
#line 917
      _zip_buffer_put_32(buffer, 4294967295U);
      }
    } else
#line 910
    if (de->uncomp_size >= 4294967295UL) {
      {
#line 916
      _zip_buffer_put_32(buffer, 4294967295U);
#line 917
      _zip_buffer_put_32(buffer, 4294967295U);
      }
    } else {
#line 910
      goto _L___22;
    }
  } else {
    _L___22: 
#line 920
    if (de->comp_size < 4294967295UL) {
      {
#line 921
      _zip_buffer_put_32(buffer, (zip_uint32_t )de->comp_size);
      }
    } else {
      {
#line 924
      _zip_buffer_put_32(buffer, 4294967295U);
      }
    }
#line 926
    if (de->uncomp_size < 4294967295UL) {
      {
#line 927
      _zip_buffer_put_32(buffer, (zip_uint32_t )de->uncomp_size);
      }
    } else {
      {
#line 930
      _zip_buffer_put_32(buffer, 4294967295U);
      }
    }
  }
  {
#line 934
  __cil_tmp38 = _zip_string_length(de->filename);
#line 934
  _zip_buffer_put_16(buffer, __cil_tmp38);
#line 936
  __cil_tmp40 = _zip_ef_size(ef, 768U);
#line 936
  __cil_tmp39 = _zip_ef_size(de->extra_fields, flags);
#line 936
  ef_total_size = (zip_uint32_t )__cil_tmp39 + (zip_uint32_t )__cil_tmp40;
#line 937
  _zip_buffer_put_16(buffer, (zip_uint16_t )ef_total_size);
  }
#line 939
  if ((flags & 256U) == 0U) {
    {
#line 940
    __cil_tmp41 = _zip_string_length(de->comment);
#line 940
    _zip_buffer_put_16(buffer, __cil_tmp41);
#line 941
    _zip_buffer_put_16(buffer, (zip_uint16_t )de->disk_number);
#line 942
    _zip_buffer_put_16(buffer, de->int_attrib);
#line 943
    _zip_buffer_put_32(buffer, de->ext_attrib);
    }
#line 944
    if (de->offset < 4294967295UL) {
      {
#line 945
      _zip_buffer_put_32(buffer, (zip_uint32_t )de->offset);
      }
    } else {
      {
#line 947
      _zip_buffer_put_32(buffer, 4294967295U);
      }
    }
  }
  {
#line 950
  __cil_tmp42 = _zip_buffer_ok(buffer);
  }
#line 950
  if (! __cil_tmp42) {
    {
#line 951
    zip_error_set(& za___0->error, 20, 0);
#line 952
    _zip_buffer_free(buffer);
#line 953
    _zip_ef_free(ef);
    }
#line 954
    return (-1);
  }
  {
#line 957
  __cil_tmp43 = _zip_buffer_offset(buffer);
#line 957
  __cil_tmp44 = _zip_write(za___0, (void const   *)(buf), __cil_tmp43);
  }
#line 957
  if (__cil_tmp44 < 0) {
    {
#line 958
    _zip_buffer_free(buffer);
#line 959
    _zip_ef_free(ef);
    }
#line 960
    return (-1);
  }
  {
#line 963
  _zip_buffer_free(buffer);
  }
#line 965
  if (de->filename) {
    {
#line 966
    __cil_tmp45 = _zip_string_write(za___0, de->filename);
    }
#line 966
    if (__cil_tmp45 < 0) {
      {
#line 967
      _zip_ef_free(ef);
      }
#line 968
      return (-1);
    }
  }
#line 972
  if (ef) {
    {
#line 973
    __cil_tmp46 = _zip_ef_write(za___0, ef, 768U);
    }
#line 973
    if (__cil_tmp46 < 0) {
      {
#line 974
      _zip_ef_free(ef);
      }
#line 975
      return (-1);
    }
  }
  {
#line 978
  _zip_ef_free(ef);
  }
#line 979
  if (de->extra_fields) {
    {
#line 980
    __cil_tmp47 = _zip_ef_write(za___0, de->extra_fields, flags);
    }
#line 980
    if (__cil_tmp47 < 0) {
#line 981
      return (-1);
    }
  }
#line 985
  if ((flags & 256U) == 0U) {
#line 986
    if (de->comment) {
      {
#line 987
      __cil_tmp48 = _zip_string_write(za___0, de->comment);
      }
#line 987
      if (__cil_tmp48 < 0) {
#line 988
        return (-1);
      }
    }
  }
#line 994
  return (is_zip64);
}
}
#line 999 "/root/patchweave_new/24/lib/zip_dirent.c"
static time_t _zip_d2u_time(zip_uint16_t dtime , zip_uint16_t ddate ) 
{ 
  struct tm tm ;
  time_t __cil_tmp4 ;

  {
  {
#line 1003
  memset((void *)(& tm), 0, sizeof(tm));
#line 1006
  tm.tm_isdst = -1;
#line 1008
  tm.tm_year = ((((int )ddate >> 9) & 127) + 1980) - 1900;
#line 1009
  tm.tm_mon = (((int )ddate >> 5) & 15) - 1;
#line 1010
  tm.tm_mday = (int )ddate & 31;
#line 1012
  tm.tm_hour = ((int )dtime >> 11) & 31;
#line 1013
  tm.tm_min = ((int )dtime >> 5) & 63;
#line 1014
  tm.tm_sec = ((int )dtime << 1) & 62;
#line 1016
  __cil_tmp4 = mktime(& tm);
  }
#line 1016
  return (__cil_tmp4);
}
}
#line 1021 "/root/patchweave_new/24/lib/zip_dirent.c"
static zip_extra_field_t *_zip_ef_utf8(zip_uint16_t id , zip_string_t *str , zip_error_t *error ) 
{ 
  zip_uint8_t *raw ;
  zip_uint32_t len ;
  zip_buffer_t *buffer ;
  zip_extra_field_t *ef ;
  zip_uint32_t __cil_tmp10 ;
  int __cil_tmp11 ;
  zip_uint64_t __cil_tmp12 ;
  zip_uint8_t *__cil_tmp13 ;
  zip_extra_field_t *__cil_tmp14 ;

  {
  {
#line 1028
  raw = _zip_string_get(str, & len, 64U, (zip_error_t *)((void *)0));
  }
#line 1028
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
#line 1030
    return ((zip_extra_field_t *)((void *)0));
  }
#line 1033
  if (len + 5U > 65535U) {
    {
#line 1034
    zip_error_set(error, 18, 0);
    }
#line 1035
    return ((zip_extra_field_t *)((void *)0));
  }
  {
#line 1038
  buffer = _zip_buffer_new((zip_uint8_t *)((void *)0), (zip_uint64_t )(len + 5U));
  }
#line 1038
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 1039
    zip_error_set(error, 14, 0);
    }
#line 1040
    return ((zip_extra_field_t *)((void *)0));
  }
  {
#line 1043
  _zip_buffer_put_8(buffer, (zip_uint8_t )1);
#line 1044
  __cil_tmp10 = _zip_string_crc32(str);
#line 1044
  _zip_buffer_put_32(buffer, __cil_tmp10);
#line 1045
  _zip_buffer_put(buffer, (void const   *)raw, (size_t )len);
#line 1047
  __cil_tmp11 = _zip_buffer_ok(buffer);
  }
#line 1047
  if (! __cil_tmp11) {
    {
#line 1048
    zip_error_set(error, 20, 0);
#line 1049
    _zip_buffer_free(buffer);
    }
#line 1050
    return ((zip_extra_field_t *)((void *)0));
  }
  {
#line 1053
  __cil_tmp12 = _zip_buffer_offset(buffer);
#line 1053
  __cil_tmp13 = _zip_buffer_data(buffer);
#line 1053
  __cil_tmp14 = _zip_ef_new(id, (zip_uint16_t )__cil_tmp12, __cil_tmp13, 768U);
#line 1053
  ef = __cil_tmp14;
#line 1054
  _zip_buffer_free(buffer);
  }
#line 1056
  return (ef);
}
}
#line 1061 "/root/patchweave_new/24/lib/zip_dirent.c"
zip_dirent_t *_zip_get_dirent(zip_t *za___0 , zip_uint64_t idx , zip_flags_t flags ,
                              zip_error_t *error ) 
{ 


  {
#line 1063
  if ((unsigned long )error == (unsigned long )((void *)0)) {
#line 1064
    error = & za___0->error;
  }
#line 1066
  if (idx >= za___0->nentry) {
    {
#line 1067
    zip_error_set(error, 18, 0);
    }
#line 1068
    return ((zip_dirent_t *)((void *)0));
  }
#line 1071
  if ((unsigned long )(za___0->entry + idx)->changes == (unsigned long )((void *)0)) {
    _L: 
#line 1072
    if ((unsigned long )(za___0->entry + idx)->orig == (unsigned long )((void *)0)) {
      {
#line 1073
      zip_error_set(error, 18, 0);
      }
#line 1074
      return ((zip_dirent_t *)((void *)0));
    }
#line 1076
    if ((za___0->entry + idx)->deleted) {
#line 1076
      if ((flags & 8U) == 0U) {
        {
#line 1077
        zip_error_set(error, 23, 0);
        }
#line 1078
        return ((zip_dirent_t *)((void *)0));
      }
    }
#line 1080
    return ((za___0->entry + idx)->orig);
  } else
#line 1071
  if (flags & 8U) {
#line 1071
    goto _L;
  } else {
#line 1083
    return ((za___0->entry + idx)->changes);
  }
}
}
#line 1090 "/root/patchweave_new/24/lib/zip_dirent.c"
void _zip_u2d_time(time_t intime , zip_uint16_t *dtime , zip_uint16_t *ddate ) 
{ 
  struct tm *tm ;

  {
  {
#line 1094
  tm = localtime(& intime);
  }
#line 1095
  if (tm->tm_year < 80) {
#line 1096
    tm->tm_year = 80;
  }
#line 1099
  *ddate = (zip_uint16_t )(((((tm->tm_year + 1900) - 1980) << 9) + ((tm->tm_mon + 1) << 5)) + tm->tm_mday);
#line 1100
  *dtime = (zip_uint16_t )(((tm->tm_hour << 11) + (tm->tm_min << 5)) + (tm->tm_sec >> 1));
#line 1102
  return;
}
}
#line 1107 "/root/patchweave_new/24/lib/zip_dirent.c"
void _zip_dirent_set_version_needed(zip_dirent_t *de , int force_zip64 ) 
{ 
  zip_uint16_t length ;
  int __cil_tmp4 ;

  {
#line 1110
  if (de->comp_method == 14) {
#line 1111
    de->version_needed = (zip_uint16_t )63;
#line 1112
    return;
  }
#line 1115
  if (de->comp_method == 12) {
#line 1116
    de->version_needed = (zip_uint16_t )46;
#line 1117
    return;
  }
  {
#line 1120
  __cil_tmp4 = _zip_dirent_needs_zip64(de, (zip_flags_t )0);
  }
#line 1120
  if (force_zip64) {
#line 1121
    de->version_needed = (zip_uint16_t )45;
#line 1122
    return;
  } else
#line 1120
  if (__cil_tmp4) {
#line 1121
    de->version_needed = (zip_uint16_t )45;
#line 1122
    return;
  }
#line 1125
  if (de->comp_method == 8) {
#line 1126
    de->version_needed = (zip_uint16_t )20;
#line 1127
    return;
  } else
#line 1125
  if ((int )de->encryption_method == 1) {
#line 1126
    de->version_needed = (zip_uint16_t )20;
#line 1127
    return;
  }
  {
#line 1131
  length = _zip_string_length(de->filename);
  }
#line 1131
  if ((int )length > 0) {
#line 1132
    if ((int )*((de->filename)->raw + ((int )length - 1)) == 47) {
#line 1133
      de->version_needed = (zip_uint16_t )20;
#line 1134
      return;
    }
  }
#line 1138
  de->version_needed = (zip_uint16_t )10;
#line 1139
  return;
}
}
#line 44 "/root/patchweave_new/24/lib/zip_dir_add.c"
zip_int64_t zip_dir_add(zip_t *za___0 , char const   *name , zip_flags_t flags ) 
{ 
  size_t len ;
  zip_int64_t idx ;
  char *s ;
  zip_source_t *source ;
  void *__cil_tmp9 ;
  char *tmp ;
  zip_int64_t __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 51
  if (za___0->ch_flags & 2U) {
    {
#line 52
    zip_error_set(& za___0->error, 25, 0);
    }
#line 53
    return ((zip_int64_t )-1);
  }
#line 56
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 57
    zip_error_set(& za___0->error, 18, 0);
    }
#line 58
    return ((zip_int64_t )-1);
  }
  {
#line 61
  s = (char *)((void *)0);
#line 62
  len = strlen(name);
  }
#line 64
  if ((int )*(name + (len - 1UL)) != 47) {
    {
#line 65
    __cil_tmp9 = malloc(len + 2UL);
#line 65
    s = (char *)__cil_tmp9;
    }
#line 65
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
#line 66
      zip_error_set(& za___0->error, 14, 0);
      }
#line 67
      return ((zip_int64_t )-1);
    }
    {
#line 69
    strcpy(s, name);
#line 70
    *(s + len) = (char )'/';
#line 71
    *(s + (len + 1UL)) = (char )'\000';
    }
  }
  {
#line 74
  source = zip_source_buffer(za___0, (void const   *)((void *)0), (zip_uint64_t )0,
                             0);
  }
#line 74
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    {
#line 75
    free((void *)s);
    }
#line 76
    return ((zip_int64_t )-1);
  }
#line 79
  if (s) {
#line 79
    tmp = s;
  } else {
#line 79
    tmp = (char *)name;
  }
  {
#line 79
  __cil_tmp12 = _zip_file_replace(za___0, 0xffffffffffffffffUL, (char const   *)((int )tmp),
                                  source, flags);
#line 79
  idx = __cil_tmp12;
#line 81
  free((void *)s);
  }
#line 83
  if (idx < 0L) {
    {
#line 84
    zip_source_free(source);
    }
  } else {
    {
#line 86
    __cil_tmp13 = zip_file_set_external_attributes(za___0, (zip_uint64_t )idx, (zip_flags_t )0,
                                                   (zip_uint8_t )3U, 16895U << 16);
    }
#line 86
    if (__cil_tmp13 < 0) {
      {
#line 87
      zip_delete(za___0, (zip_uint64_t )idx);
      }
#line 88
      return ((zip_int64_t )-1);
    }
  }
#line 92
  return (idx);
}
}
#line 39 "/root/patchweave_new/24/lib/zip_delete.c"
int zip_delete(zip_t *za___0 , zip_uint64_t idx ) 
{ 
  char const   *name ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 43
  if (idx >= za___0->nentry) {
    {
#line 44
    zip_error_set(& za___0->error, 18, 0);
    }
#line 45
    return (-1);
  }
#line 48
  if (za___0->ch_flags & 2U) {
    {
#line 49
    zip_error_set(& za___0->error, 25, 0);
    }
#line 50
    return (-1);
  }
  {
#line 53
  name = _zip_get_name(za___0, idx, (zip_flags_t )0, & za___0->error);
  }
#line 53
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 54
    return (-1);
  }
  {
#line 57
  __cil_tmp5 = _zip_hash_delete(za___0->names, (zip_uint8_t *)name, & za___0->error);
  }
#line 57
  if (! __cil_tmp5) {
#line 58
    return (-1);
  }
  {
#line 63
  __cil_tmp6 = _zip_unchange(za___0, idx, 1);
  }
#line 63
  if (__cil_tmp6 != 0) {
#line 64
    return (-1);
  }
#line 66
  (za___0->entry + idx)->deleted = 1;
#line 68
  return (0);
}
}
#line 54 "/root/patchweave_new/24/lib/zip_close.c"
static int add_data(zip_t *za___0 , zip_source_t *src , zip_dirent_t *de ) ;
#line 55
static int copy_data(zip_t *za___0 , zip_uint64_t len ) ;
#line 56
static int copy_source(zip_t *za___0 , zip_source_t *src , zip_int64_t data_length ) ;
#line 57
static int write_cdir(zip_t *za___0 , zip_filelist_t *filelist , zip_uint64_t survivors ) ;
#line 60 "/root/patchweave_new/24/lib/zip_close.c"
int zip_close(zip_t *za___0 ) 
{ 
  zip_uint64_t i ;
  zip_uint64_t j ;
  zip_uint64_t survivors ;
  zip_int64_t off ;
  int error ;
  zip_filelist_t *filelist ;
  int changed ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp14 ;
  int new_data ;
  zip_entry_t *entry ;
  zip_dirent_t *de ;
  int __cil_tmp19 ;
  zip_source_t *zs ;
  zip_source_t *tmp ;
  int __cil_tmp24 ;
  zip_uint64_t offset ;
  int __cil_tmp26 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int tmp___0 ;

  {
#line 68
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 69
    return (-1);
  }
  {
#line 71
  changed = _zip_changed(za___0, & survivors);
  }
#line 74
  if (survivors == 0UL) {
#line 75
    if (za___0->open_flags & 8U) {
      _L: 
      {
#line 76
      __cil_tmp10 = zip_source_remove(za___0->src);
      }
#line 76
      if (__cil_tmp10 < 0) {
        {
#line 77
        _zip_error_set_from_source(& za___0->error, za___0->src);
        }
#line 78
        return (-1);
      }
    } else
#line 75
    if (changed) {
#line 75
      goto _L;
    }
    {
#line 81
    zip_discard(za___0);
    }
#line 82
    return (0);
  }
#line 85
  if (! changed) {
    {
#line 86
    zip_discard(za___0);
    }
#line 87
    return (0);
  }
#line 90
  if (survivors > za___0->nentry) {
    {
#line 91
    zip_error_set(& za___0->error, 20, 0);
    }
#line 92
    return (-1);
  }
  {
#line 95
  __cil_tmp11 = malloc(sizeof(*(filelist + 0)) * survivors);
#line 95
  filelist = (zip_filelist_t *)__cil_tmp11;
  }
#line 95
  if ((unsigned long )filelist == (unsigned long )((void *)0)) {
#line 96
    return (-1);
  }
#line 99
  j = (zip_uint64_t )0;
#line 99
  i = j;
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 99
    if (! (i < za___0->nentry)) {
#line 99
      goto while_break;
    }
#line 100
    if ((za___0->entry + i)->deleted) {
#line 101
      goto while_continue;
    }
#line 103
    if (j >= survivors) {
      {
#line 104
      free((void *)filelist);
#line 105
      zip_error_set(& za___0->error, 20, 0);
      }
#line 106
      return (-1);
    }
#line 109
    (filelist + j)->idx = i;
#line 110
    j ++;
#line 99
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 112
  if (j < survivors) {
    {
#line 113
    free((void *)filelist);
#line 114
    zip_error_set(& za___0->error, 20, 0);
    }
#line 115
    return (-1);
  }
  {
#line 118
  __cil_tmp14 = zip_source_begin_write(za___0->src);
  }
#line 118
  if (__cil_tmp14 < 0) {
    {
#line 119
    _zip_error_set_from_source(& za___0->error, za___0->src);
#line 120
    free((void *)filelist);
    }
#line 121
    return (-1);
  }
  {
#line 124
  _zip_progress_start(za___0->progress);
#line 125
  error = 0;
#line 126
  j = (zip_uint64_t )0;
  }
  {
#line 126
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 126
    if (! (j < survivors)) {
#line 126
      goto while_break___0;
    }
    {
#line 131
    _zip_progress_subrange(za___0->progress, (double )j / (double )survivors, (double )(j + 1UL) / (double )survivors);
#line 133
    i = (filelist + j)->idx;
#line 134
    entry = za___0->entry + i;
    }
#line 136
    if ((unsigned long )entry->source != (unsigned long )((void *)0)) {
#line 136
      tmp___0 = 1;
    } else
#line 136
    if (entry->changes) {
#line 136
      if ((entry->changes)->changed & 1U) {
#line 136
        tmp___0 = 1;
      } else {
#line 136
        goto _L___23;
      }
    } else
    _L___23: /* CIL Label */ 
#line 136
    if (entry->changes) {
#line 136
      if ((entry->changes)->changed & 64U) {
#line 136
        tmp___0 = 1;
      } else {
#line 136
        tmp___0 = 0;
      }
    } else {
#line 136
      tmp___0 = 0;
    }
#line 136
    new_data = tmp___0;
#line 139
    if ((unsigned long )entry->changes == (unsigned long )((void *)0)) {
      {
#line 140
      entry->changes = _zip_dirent_clone(entry->orig);
      }
#line 140
      if ((unsigned long )entry->changes == (unsigned long )((void *)0)) {
        {
#line 141
        zip_error_set(& za___0->error, 14, 0);
#line 142
        error = 1;
        }
#line 143
        goto while_break___0;
      }
    }
    {
#line 146
    de = entry->changes;
#line 148
    __cil_tmp19 = _zip_read_local_ef(za___0, i);
    }
#line 148
    if (__cil_tmp19 < 0) {
#line 149
      error = 1;
#line 150
      goto while_break___0;
    }
    {
#line 153
    off = zip_source_tell_write(za___0->src);
    }
#line 153
    if (off < 0L) {
#line 154
      error = 1;
#line 155
      goto while_break___0;
    }
#line 157
    de->offset = (zip_uint64_t )off;
#line 159
    if (new_data) {
#line 162
      zs = (zip_source_t *)((void *)0);
#line 163
      if (! ((unsigned long )entry->source != (unsigned long )((void *)0))) {
        {
#line 164
        zs = _zip_source_zip_new(za___0, za___0, i, 8U, (zip_uint64_t )0, (zip_uint64_t )0,
                                 (char const   *)((void *)0));
        }
#line 164
        if ((unsigned long )zs == (unsigned long )((void *)0)) {
#line 165
          error = 1;
#line 166
          goto while_break___0;
        }
      }
#line 171
      if (zs) {
#line 171
        tmp = zs;
      } else {
#line 171
        tmp = entry->source;
      }
      {
#line 171
      __cil_tmp24 = add_data(za___0, tmp, de);
      }
#line 171
      if (__cil_tmp24 < 0) {
#line 172
        error = 1;
#line 173
        if (zs) {
          {
#line 174
          zip_source_free(zs);
          }
        }
#line 175
        goto while_break___0;
      }
#line 177
      if (zs) {
        {
#line 178
        zip_source_free(zs);
        }
      }
    } else {
      {
#line 184
      de->bitflags = (zip_uint16_t )((int )de->bitflags & 65527);
#line 185
      __cil_tmp26 = _zip_dirent_write(za___0, de, 256U);
      }
#line 185
      if (__cil_tmp26 < 0) {
#line 186
        error = 1;
#line 187
        goto while_break___0;
      }
      {
#line 189
      offset = _zip_file_get_offset(za___0, i, & za___0->error);
      }
#line 189
      if (offset == 0UL) {
#line 190
        error = 1;
#line 191
        goto while_break___0;
      }
      {
#line 193
      __cil_tmp28 = zip_source_seek(za___0->src, (zip_int64_t )offset, 0);
      }
#line 193
      if (__cil_tmp28 < 0) {
        {
#line 194
        _zip_error_set_from_source(& za___0->error, za___0->src);
#line 195
        error = 1;
        }
#line 196
        goto while_break___0;
      }
      {
#line 198
      __cil_tmp29 = copy_data(za___0, de->comp_size);
      }
#line 198
      if (__cil_tmp29 < 0) {
#line 199
        error = 1;
#line 200
        goto while_break___0;
      }
    }
#line 126
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 205
  if (! error) {
    {
#line 206
    __cil_tmp31 = write_cdir(za___0, filelist, survivors);
    }
#line 206
    if (__cil_tmp31 < 0) {
#line 207
      error = 1;
    }
  }
  {
#line 210
  free((void *)filelist);
  }
#line 212
  if (! error) {
    {
#line 213
    __cil_tmp32 = zip_source_commit_write(za___0->src);
    }
#line 213
    if (__cil_tmp32 != 0) {
      {
#line 214
      _zip_error_set_from_source(& za___0->error, za___0->src);
#line 215
      error = 1;
      }
    }
  }
#line 219
  if (error) {
    {
#line 220
    zip_source_rollback_write(za___0->src);
    }
#line 221
    return (-1);
  }
  {
#line 224
  _zip_progress_end(za___0->progress);
#line 226
  zip_discard(za___0);
  }
#line 228
  return (0);
}
}
#line 233 "/root/patchweave_new/24/lib/zip_close.c"
static int add_data(zip_t *za___0 , zip_source_t *src , zip_dirent_t *de ) 
{ 
  zip_int64_t offstart ;
  zip_int64_t offdata ;
  zip_int64_t offend ;
  zip_int64_t data_length ;
  struct zip_stat st ;
  zip_source_t *src_final ;
  zip_source_t *src_tmp ;
  int ret ;
  int is_zip64 ;
  zip_flags_t flags ;
  zip_int8_t compression_flags___0 ;
  int needs_recompress ;
  int needs_decompress ;
  int needs_crc ;
  int needs_compress ;
  int needs_reencrypt ;
  int needs_decrypt ;
  int needs_encrypt ;
  int __cil_tmp22 ;
  zip_uint64_t max_size ;
  int tmp ;
  int tmp___0 ;
  zip_source_t *(*impl)(zip_t * , zip_source_t * , zip_uint16_t  , int  , char const   * ) ;
  zip_source_t *(*impl___0)(zip_t * , zip_source_t * , zip_uint16_t  , int  , char const   * ) ;
  char const   *password ;
  int __cil_tmp40 ;
  int __cil_tmp43 ;
  int __cil_tmp45 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 244
  __cil_tmp22 = zip_source_stat(src, & st);
  }
#line 244
  if (__cil_tmp22 < 0) {
    {
#line 245
    _zip_error_set_from_source(& za___0->error, src);
    }
#line 246
    return (-1);
  }
#line 249
  if ((st.valid & 64UL) == 0UL) {
#line 250
    st.valid |= 64UL;
#line 251
    st.comp_method = (zip_uint16_t )0;
  }
#line 254
  if (de->comp_method == -1) {
    _L___23: 
#line 254
    if ((int )st.comp_method != 0) {
#line 255
      de->comp_method = (zip_int32_t )st.comp_method;
    } else {
#line 254
      goto _L;
    }
  } else
#line 254
  if (de->comp_method == -2) {
#line 254
    goto _L___23;
  } else
  _L: 
#line 256
  if (de->comp_method == 0) {
#line 256
    if (st.valid & 4UL) {
#line 257
      st.valid |= 8UL;
#line 258
      st.comp_size = st.size;
    } else {
#line 262
      st.valid &= 4294967287UL;
    }
  } else {
#line 262
    st.valid &= 4294967287UL;
  }
#line 265
  if ((st.valid & 128UL) == 0UL) {
#line 266
    st.valid |= 128UL;
#line 267
    st.encryption_method = (zip_uint16_t )0;
  }
#line 270
  flags = 256U;
#line 272
  if ((st.valid & 4UL) == 0UL) {
#line 273
    flags |= 1024U;
#line 274
    data_length = (zip_int64_t )-1;
  } else {
#line 277
    de->uncomp_size = st.size;
#line 279
    data_length = (zip_int64_t )st.size;
#line 281
    if ((st.valid & 8UL) == 0UL) {
#line 284
      if (de->comp_method == -1) {
#line 284
        tmp = 8;
      } else
#line 284
      if (de->comp_method == -2) {
#line 284
        tmp = 8;
      } else {
#line 284
        tmp = de->comp_method;
      }
#line 285
      if ((int )((zip_uint16_t )tmp) == 12) {
#line 285
        goto case_12;
      }
#line 291
      if ((int )((zip_uint16_t )tmp) == 8) {
#line 291
        goto case_8;
      }
#line 296
      if ((int )((zip_uint16_t )tmp) == 0) {
#line 296
        goto case_0;
      }
#line 300
      goto switch_default;
      case_12: 
#line 288
      max_size = (zip_uint64_t )4269351188U;
#line 289
      goto switch_break;
      case_8: 
#line 293
      max_size = (zip_uint64_t )4293656963U;
#line 294
      goto switch_break;
      case_0: 
#line 297
      max_size = (zip_uint64_t )4294967295U;
#line 298
      goto switch_break;
      switch_default: 
#line 301
      max_size = (zip_uint64_t )0;
      switch_break: ;
#line 304
      if (st.size > max_size) {
#line 305
        flags |= 1024U;
      }
    } else {
#line 309
      de->comp_size = st.comp_size;
    }
  }
  {
#line 312
  offstart = zip_source_tell_write(za___0->src);
  }
#line 312
  if (offstart < 0L) {
    {
#line 313
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 314
    return (-1);
  }
  {
#line 318
  de->bitflags = (zip_uint16_t )((int )de->bitflags & 65527);
#line 319
  is_zip64 = _zip_dirent_write(za___0, de, flags);
  }
#line 319
  if (is_zip64 < 0) {
#line 320
    return (-1);
  }
#line 323
  if (de->comp_method == -1) {
#line 323
    tmp___0 = 8;
  } else
#line 323
  if (de->comp_method == -2) {
#line 323
    tmp___0 = 8;
  } else {
#line 323
    tmp___0 = de->comp_method;
  }
#line 323
  needs_recompress = (int )st.comp_method != (int )((zip_uint16_t )tmp___0);
#line 324
  if (needs_recompress) {
#line 324
    if ((int )st.comp_method != 0) {
#line 324
      tmp___1 = 1;
    } else {
#line 324
      tmp___1 = 0;
    }
  } else {
#line 324
    tmp___1 = 0;
  }
#line 324
  needs_decompress = tmp___1;
#line 325
  if ((int )st.comp_method == 0) {
#line 325
    tmp___2 = 1;
  } else
#line 325
  if (needs_decompress) {
#line 325
    tmp___2 = 1;
  } else {
#line 325
    tmp___2 = 0;
  }
#line 325
  needs_crc = tmp___2;
#line 326
  if (needs_recompress) {
#line 326
    if (de->comp_method != 0) {
#line 326
      tmp___3 = 1;
    } else {
#line 326
      tmp___3 = 0;
    }
  } else {
#line 326
    tmp___3 = 0;
  }
#line 326
  needs_compress = tmp___3;
#line 328
  if (needs_recompress) {
#line 328
    tmp___4 = 1;
  } else
#line 328
  if (de->changed & 128U) {
#line 328
    tmp___4 = 1;
  } else
#line 328
  if ((int )de->encryption_method != (int )st.encryption_method) {
#line 328
    tmp___4 = 1;
  } else {
#line 328
    tmp___4 = 0;
  }
#line 328
  needs_reencrypt = tmp___4;
#line 329
  if (needs_reencrypt) {
#line 329
    if ((int )st.encryption_method != 0) {
#line 329
      tmp___5 = 1;
    } else {
#line 329
      tmp___5 = 0;
    }
  } else {
#line 329
    tmp___5 = 0;
  }
#line 329
  needs_decrypt = tmp___5;
#line 330
  if (needs_reencrypt) {
#line 330
    if ((int )de->encryption_method != 0) {
#line 330
      tmp___6 = 1;
    } else {
#line 330
      tmp___6 = 0;
    }
  } else {
#line 330
    tmp___6 = 0;
  }
  {
#line 330
  needs_encrypt = tmp___6;
#line 332
  src_final = src;
#line 333
  zip_source_keep(src_final);
  }
#line 335
  if (needs_decrypt) {
    {
#line 338
    impl = _zip_get_encryption_implementation(st.encryption_method, 0);
    }
#line 338
    if ((unsigned long )impl == (unsigned long )((void *)0)) {
      {
#line 339
      zip_error_set(& za___0->error, 24, 0);
#line 340
      zip_source_free(src_final);
      }
#line 341
      return (-1);
    }
    {
#line 343
    src_tmp = (*impl)(za___0, src_final, st.encryption_method, 0, (char const   *)za___0->default_password);
    }
#line 343
    if ((unsigned long )src_tmp == (unsigned long )((void *)0)) {
      {
#line 345
      zip_source_free(src_final);
      }
#line 346
      return (-1);
    }
    {
#line 349
    zip_source_free(src_final);
#line 350
    src_final = src_tmp;
    }
  }
#line 353
  if (needs_decompress) {
    {
#line 354
    src_tmp = zip_source_decompress(za___0, src_final, (zip_int32_t )st.comp_method);
    }
#line 354
    if ((unsigned long )src_tmp == (unsigned long )((void *)0)) {
      {
#line 355
      zip_source_free(src_final);
      }
#line 356
      return (-1);
    }
    {
#line 359
    zip_source_free(src_final);
#line 360
    src_final = src_tmp;
    }
  }
#line 363
  if (needs_crc) {
    {
#line 364
    src_tmp = zip_source_crc(za___0, src_final, 0);
    }
#line 364
    if ((unsigned long )src_tmp == (unsigned long )((void *)0)) {
      {
#line 365
      zip_source_free(src_final);
      }
#line 366
      return (-1);
    }
    {
#line 369
    zip_source_free(src_final);
#line 370
    src_final = src_tmp;
    }
  }
#line 373
  if (needs_compress) {
    {
#line 374
    src_tmp = zip_source_compress(za___0, src_final, de->comp_method, (int )de->compression_level);
    }
#line 374
    if ((unsigned long )src_tmp == (unsigned long )((void *)0)) {
      {
#line 375
      zip_source_free(src_final);
      }
#line 376
      return (-1);
    }
    {
#line 379
    zip_source_free(src_final);
#line 380
    src_final = src_tmp;
    }
  }
#line 384
  if (needs_encrypt) {
#line 386
    password = (char const   *)((void *)0);
#line 388
    if (de->password) {
#line 389
      password = (char const   *)de->password;
    } else
#line 390
    if (za___0->default_password) {
#line 391
      password = (char const   *)za___0->default_password;
    }
    {
#line 394
    impl___0 = _zip_get_encryption_implementation(de->encryption_method, 1);
    }
#line 394
    if ((unsigned long )impl___0 == (unsigned long )((void *)0)) {
      {
#line 395
      zip_error_set(& za___0->error, 24, 0);
#line 396
      zip_source_free(src_final);
      }
#line 397
      return (-1);
    }
    {
#line 399
    src_tmp = (*impl___0)(za___0, src_final, de->encryption_method, 1, password);
    }
#line 399
    if ((unsigned long )src_tmp == (unsigned long )((void *)0)) {
      {
#line 401
      zip_source_free(src_final);
      }
#line 402
      return (-1);
    }
    {
#line 405
    zip_source_free(src_final);
#line 406
    src_final = src_tmp;
    }
  }
  {
#line 410
  offdata = zip_source_tell_write(za___0->src);
  }
#line 410
  if (offdata < 0L) {
    {
#line 411
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 412
    return (-1);
  }
  {
#line 415
  ret = copy_source(za___0, src_final, data_length);
#line 417
  __cil_tmp40 = zip_source_stat(src_final, & st);
  }
#line 417
  if (__cil_tmp40 < 0) {
    {
#line 418
    _zip_error_set_from_source(& za___0->error, src_final);
#line 419
    ret = -1;
    }
  }
  {
#line 422
  compression_flags___0 = zip_source_get_compression_flags(src_final);
  }
#line 422
  if ((int )compression_flags___0 < 0) {
    {
#line 423
    _zip_error_set_from_source(& za___0->error, src_final);
#line 424
    ret = -1;
    }
  }
  {
#line 427
  zip_source_free(src_final);
  }
#line 429
  if (ret < 0) {
#line 430
    return (-1);
  }
  {
#line 433
  offend = zip_source_tell_write(za___0->src);
  }
#line 433
  if (offend < 0L) {
    {
#line 434
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 435
    return (-1);
  }
  {
#line 438
  __cil_tmp43 = zip_source_seek_write(za___0->src, offstart, 0);
  }
#line 438
  if (__cil_tmp43 < 0) {
    {
#line 439
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 440
    return (-1);
  }
#line 443
  if ((st.valid & 100UL) != 100UL) {
    {
#line 444
    zip_error_set(& za___0->error, 20, 0);
    }
#line 445
    return (-1);
  }
#line 448
  if ((de->changed & 32U) == 0U) {
#line 449
    if (st.valid & 16UL) {
#line 450
      de->last_mod = st.mtime;
    } else {
      {
#line 452
      time(& de->last_mod);
      }
    }
  }
  {
#line 454
  de->comp_method = (zip_int32_t )st.comp_method;
#line 455
  de->crc = st.crc;
#line 456
  de->uncomp_size = st.size;
#line 457
  de->comp_size = (zip_uint64_t )(offend - offdata);
#line 458
  de->bitflags = (zip_uint16_t )(((int )de->bitflags & 65529) | ((int )((zip_uint8_t )compression_flags___0) << 1));
#line 459
  _zip_dirent_set_version_needed(de, (flags & 1024U) != 0U);
#line 461
  ret = _zip_dirent_write(za___0, de, flags);
  }
#line 461
  if (ret < 0) {
#line 462
    return (-1);
  }
#line 464
  if (is_zip64 != ret) {
    {
#line 466
    zip_error_set(& za___0->error, 20, 0);
    }
#line 467
    return (-1);
  }
  {
#line 470
  __cil_tmp45 = zip_source_seek_write(za___0->src, offend, 0);
  }
#line 470
  if (__cil_tmp45 < 0) {
    {
#line 471
    _zip_error_set_from_source(& za___0->error, za___0->src);
    }
#line 472
    return (-1);
  }
#line 475
  return (0);
}
}
#line 480 "/root/patchweave_new/24/lib/zip_close.c"
static int copy_data(zip_t *za___0 , zip_uint64_t len ) 
{ 
  zip_uint8_t buf[8192] ;
  size_t n ;
  double total ;
  unsigned long tmp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 484
  total = (double )len;
  {
#line 486
  while (1) {
    while_continue: /* CIL Label */ ;

#line 486
    if (! (len > 0UL)) {
#line 486
      goto while_break;
    }
#line 487
    if (len > sizeof(buf)) {
#line 487
      tmp = sizeof(buf);
    } else {
#line 487
      tmp = len;
    }
    {
#line 487
    n = tmp;
#line 488
    __cil_tmp7 = _zip_read(za___0->src, buf, n, & za___0->error);
    }
#line 488
    if (__cil_tmp7 < 0) {
#line 489
      return (-1);
    }
    {
#line 492
    __cil_tmp8 = _zip_write(za___0, (void const   *)(buf), n);
    }
#line 492
    if (__cil_tmp8 < 0) {
#line 493
      return (-1);
    }
    {
#line 496
    len -= n;
#line 498
    _zip_progress_update(za___0->progress, (total - (double )len) / total);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 501
  return (0);
}
}
#line 506 "/root/patchweave_new/24/lib/zip_close.c"
static int copy_source(zip_t *za___0 , zip_source_t *src , zip_int64_t data_length ) 
{ 
  zip_uint8_t buf[8192] ;
  zip_int64_t n ;
  zip_int64_t current ;
  int ret ;
  int __cil_tmp8 ;
  int __cil_tmp10 ;

  {
  {
#line 512
  __cil_tmp8 = zip_source_open(src);
  }
#line 512
  if (__cil_tmp8 < 0) {
    {
#line 513
    _zip_error_set_from_source(& za___0->error, src);
    }
#line 514
    return (-1);
  }
#line 517
  ret = 0;
#line 518
  current = (zip_int64_t )0;
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 519
    n = zip_source_read(src, (void *)(buf), sizeof(buf));
    }
#line 519
    if (! (n > 0L)) {
#line 519
      goto while_break;
    }
    {
#line 520
    __cil_tmp10 = _zip_write(za___0, (void const   *)(buf), (zip_uint64_t )n);
    }
#line 520
    if (__cil_tmp10 < 0) {
#line 521
      ret = -1;
#line 522
      goto while_break;
    }
#line 524
    if (za___0->progress) {
#line 524
      if ((unsigned long )n == sizeof(buf)) {
#line 524
        if (data_length > 0L) {
          {
#line 525
          current += n;
#line 526
          _zip_progress_update(za___0->progress, (double )current / (double )data_length);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 530
  if (n < 0L) {
    {
#line 531
    _zip_error_set_from_source(& za___0->error, src);
#line 532
    ret = -1;
    }
  }
  {
#line 535
  zip_source_close(src);
  }
#line 537
  return (ret);
}
}
#line 541 "/root/patchweave_new/24/lib/zip_close.c"
static int write_cdir(zip_t *za___0 , zip_filelist_t *filelist , zip_uint64_t survivors ) 
{ 
  zip_int64_t cd_start ;
  zip_int64_t end___0 ;
  zip_int64_t size ;

  {
  {
#line 545
  cd_start = zip_source_tell_write(za___0->src);
  }
#line 545
  if (cd_start < 0L) {
#line 546
    return (-1);
  }
  {
#line 549
  size = _zip_cdir_write(za___0, filelist, survivors);
  }
#line 549
  if (size < 0L) {
#line 550
    return (-1);
  }
  {
#line 553
  end___0 = zip_source_tell_write(za___0->src);
  }
#line 553
  if (end___0 < 0L) {
#line 554
    return (-1);
  }
#line 557
  return (0);
}
}
#line 562 "/root/patchweave_new/24/lib/zip_close.c"
int _zip_changed(zip_t *za___0 , zip_uint64_t *survivorsp ) 
{ 
  int changed ;
  zip_uint64_t i ;
  zip_uint64_t survivors ;

  {
#line 567
  changed = 0;
#line 568
  survivors = (zip_uint64_t )0;
#line 570
  if (za___0->comment_changed) {
#line 571
    changed = 1;
  } else
#line 570
  if (za___0->ch_flags != za___0->flags) {
#line 571
    changed = 1;
  }
#line 573
  i = (zip_uint64_t )0;
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;

#line 573
    if (! (i < za___0->nentry)) {
#line 573
      goto while_break;
    }
#line 574
    if ((za___0->entry + i)->source) {
#line 575
      changed = 1;
    } else
#line 574
    if ((za___0->entry + i)->deleted) {
#line 575
      changed = 1;
    } else
#line 574
    if ((za___0->entry + i)->changes) {
#line 574
      if (((za___0->entry + i)->changes)->changed != 0U) {
#line 575
        changed = 1;
      }
    }
#line 576
    if (! (za___0->entry + i)->deleted) {
#line 577
      survivors ++;
    }
#line 573
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 580
  if (survivorsp) {
#line 581
    *survivorsp = survivors;
  }
#line 583
  return (changed);
}
}
#line 40 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_uint8_t *_zip_buffer_data(zip_buffer_t *buffer ) 
{ 


  {
#line 42
  return (buffer->data);
}
}
#line 47 "/root/patchweave_new/24/lib/zip_buffer.c"
void _zip_buffer_free(zip_buffer_t *buffer ) 
{ 


  {
#line 49
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 50
    return;
  }
#line 53
  if (buffer->free_data) {
    {
#line 54
    free((void *)buffer->data);
    }
  }
  {
#line 57
  free((void *)buffer);
  }
#line 59
  return;
}
}
#line 62 "/root/patchweave_new/24/lib/zip_buffer.c"
int _zip_buffer_eof(zip_buffer_t *buffer ) 
{ 
  int tmp ;

  {
#line 64
  if (buffer->ok) {
#line 64
    if (buffer->offset == buffer->size) {
#line 64
      tmp = 1;
    } else {
#line 64
      tmp = 0;
    }
  } else {
#line 64
    tmp = 0;
  }
#line 64
  return (tmp);
}
}
#line 69 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_uint8_t *_zip_buffer_get(zip_buffer_t *buffer , zip_uint64_t length ) 
{ 
  zip_uint8_t *data ;

  {
  {
#line 73
  data = _zip_buffer_peek(buffer, length);
  }
#line 75
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 76
    buffer->offset += length;
  }
#line 79
  return (data);
}
}
#line 84 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_uint16_t _zip_buffer_get_16(zip_buffer_t *buffer ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp3 ;

  {
  {
#line 86
  __cil_tmp3 = _zip_buffer_get(buffer, (zip_uint64_t )2);
#line 86
  data = __cil_tmp3;
  }
#line 88
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 89
    return ((zip_uint16_t )0);
  }
#line 92
  return ((zip_uint16_t )((int )*(data + 0) + ((int )*(data + 1) << 8)));
}
}
#line 97 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_uint32_t _zip_buffer_get_32(zip_buffer_t *buffer ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp3 ;

  {
  {
#line 99
  __cil_tmp3 = _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 99
  data = __cil_tmp3;
  }
#line 101
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 102
    return ((zip_uint32_t )0);
  }
#line 105
  return (((((((zip_uint32_t )*(data + 3) << 8) + (unsigned int )*(data + 2)) << 8) + (unsigned int )*(data + 1)) << 8) + (unsigned int )*(data + 0));
}
}
#line 110 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_uint64_t _zip_buffer_get_64(zip_buffer_t *buffer ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp3 ;

  {
  {
#line 112
  __cil_tmp3 = _zip_buffer_get(buffer, (zip_uint64_t )8);
#line 112
  data = __cil_tmp3;
  }
#line 114
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 115
    return ((zip_uint64_t )0);
  }
#line 118
  return (((((((((zip_uint64_t )*(data + 7) << 56) + ((zip_uint64_t )*(data + 6) << 48)) + ((zip_uint64_t )*(data + 5) << 40)) + ((zip_uint64_t )*(data + 4) << 32)) + ((zip_uint64_t )*(data + 3) << 24)) + ((zip_uint64_t )*(data + 2) << 16)) + ((zip_uint64_t )*(data + 1) << 8)) + (zip_uint64_t )*(data + 0));
}
}
#line 124 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_uint8_t _zip_buffer_get_8(zip_buffer_t *buffer ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp3 ;

  {
  {
#line 126
  __cil_tmp3 = _zip_buffer_get(buffer, (zip_uint64_t )1);
#line 126
  data = __cil_tmp3;
  }
#line 128
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 129
    return ((zip_uint8_t )0);
  }
#line 132
  return (*(data + 0));
}
}
#line 137 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_uint64_t _zip_buffer_left(zip_buffer_t *buffer ) 
{ 
  zip_uint64_t tmp ;

  {
#line 139
  if (buffer->ok) {
#line 139
    tmp = buffer->size - buffer->offset;
  } else {
#line 139
    tmp = 0UL;
  }
#line 139
  return (tmp);
}
}
#line 144 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_uint64_t _zip_buffer_read(zip_buffer_t *buffer , zip_uint8_t *data , zip_uint64_t length ) 
{ 
  zip_uint64_t __cil_tmp4 ;
  zip_uint8_t *__cil_tmp6 ;

  {
  {
#line 146
  __cil_tmp4 = _zip_buffer_left(buffer);
  }
#line 146
  if (__cil_tmp4 < length) {
    {
#line 147
    length = _zip_buffer_left(buffer);
    }
  }
  {
#line 150
  __cil_tmp6 = _zip_buffer_get(buffer, length);
#line 150
  memcpy((void *)data, (void const   *)__cil_tmp6, length);
  }
#line 152
  return (length);
}
}
#line 157 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_buffer_t *_zip_buffer_new(zip_uint8_t *data , zip_uint64_t size ) 
{ 
  int free_data ;
  zip_buffer_t *buffer ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
#line 159
  free_data = (unsigned long )data == (unsigned long )((void *)0);
#line 162
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 163
    __cil_tmp5 = malloc(size);
#line 163
    data = (zip_uint8_t *)__cil_tmp5;
    }
#line 163
    if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 164
      return ((zip_buffer_t *)((void *)0));
    }
  }
  {
#line 168
  __cil_tmp6 = malloc(sizeof(*buffer));
#line 168
  buffer = (zip_buffer_t *)__cil_tmp6;
  }
#line 168
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 169
    if (free_data) {
      {
#line 170
      free((void *)data);
      }
    }
#line 172
    return ((zip_buffer_t *)((void *)0));
  }
#line 175
  buffer->ok = 1;
#line 176
  buffer->data = data;
#line 177
  buffer->size = size;
#line 178
  buffer->offset = (zip_uint64_t )0;
#line 179
  buffer->free_data = free_data;
#line 181
  return (buffer);
}
}
#line 186 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_buffer_t *_zip_buffer_new_from_source(zip_source_t *src , zip_uint64_t size ,
                                          zip_uint8_t *buf , zip_error_t *error ) 
{ 
  zip_buffer_t *buffer ;
  int __cil_tmp7 ;

  {
  {
#line 190
  buffer = _zip_buffer_new(buf, size);
  }
#line 190
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 191
    zip_error_set(error, 14, 0);
    }
#line 192
    return ((zip_buffer_t *)((void *)0));
  }
  {
#line 195
  __cil_tmp7 = _zip_read(src, buffer->data, size, error);
  }
#line 195
  if (__cil_tmp7 < 0) {
    {
#line 196
    _zip_buffer_free(buffer);
    }
#line 197
    return ((zip_buffer_t *)((void *)0));
  }
#line 200
  return (buffer);
}
}
#line 205 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_uint64_t _zip_buffer_offset(zip_buffer_t *buffer ) 
{ 
  zip_uint64_t tmp ;

  {
#line 207
  if (buffer->ok) {
#line 207
    tmp = buffer->offset;
  } else {
#line 207
    tmp = 0UL;
  }
#line 207
  return (tmp);
}
}
#line 212 "/root/patchweave_new/24/lib/zip_buffer.c"
int _zip_buffer_ok(zip_buffer_t *buffer ) 
{ 


  {
#line 214
  return (buffer->ok);
}
}
#line 220 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_uint8_t *_zip_buffer_peek(zip_buffer_t *buffer , zip_uint64_t length ) 
{ 
  zip_uint8_t *data ;

  {
#line 224
  if (! buffer->ok) {
#line 225
    buffer->ok = 0;
#line 226
    return ((zip_uint8_t *)((void *)0));
  } else
#line 224
  if (buffer->offset + length < length) {
#line 225
    buffer->ok = 0;
#line 226
    return ((zip_uint8_t *)((void *)0));
  } else
#line 224
  if (buffer->offset + length > buffer->size) {
#line 225
    buffer->ok = 0;
#line 226
    return ((zip_uint8_t *)((void *)0));
  }
#line 229
  data = buffer->data + buffer->offset;
#line 230
  return (data);
}
}
#line 234 "/root/patchweave_new/24/lib/zip_buffer.c"
int _zip_buffer_put(zip_buffer_t *buffer , void const   *src , size_t length ) 
{ 
  zip_uint8_t *dst ;
  zip_uint8_t *__cil_tmp5 ;

  {
  {
#line 236
  __cil_tmp5 = _zip_buffer_get(buffer, length);
#line 236
  dst = __cil_tmp5;
  }
#line 238
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 239
    return (-1);
  }
  {
#line 242
  memcpy((void *)dst, src, length);
  }
#line 243
  return (0);
}
}
#line 248 "/root/patchweave_new/24/lib/zip_buffer.c"
int _zip_buffer_put_16(zip_buffer_t *buffer , zip_uint16_t i ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp4 ;

  {
  {
#line 250
  __cil_tmp4 = _zip_buffer_get(buffer, (zip_uint64_t )2);
#line 250
  data = __cil_tmp4;
  }
#line 252
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 253
    return (-1);
  }
#line 256
  *(data + 0) = (zip_uint8_t )((int )i & 255);
#line 257
  *(data + 1) = (zip_uint8_t )(((int )i >> 8) & 255);
#line 259
  return (0);
}
}
#line 264 "/root/patchweave_new/24/lib/zip_buffer.c"
int _zip_buffer_put_32(zip_buffer_t *buffer , zip_uint32_t i ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp4 ;

  {
  {
#line 266
  __cil_tmp4 = _zip_buffer_get(buffer, (zip_uint64_t )4);
#line 266
  data = __cil_tmp4;
  }
#line 268
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 269
    return (-1);
  }
#line 272
  *(data + 0) = (zip_uint8_t )(i & 255U);
#line 273
  *(data + 1) = (zip_uint8_t )((i >> 8) & 255U);
#line 274
  *(data + 2) = (zip_uint8_t )((i >> 16) & 255U);
#line 275
  *(data + 3) = (zip_uint8_t )((i >> 24) & 255U);
#line 277
  return (0);
}
}
#line 282 "/root/patchweave_new/24/lib/zip_buffer.c"
int _zip_buffer_put_64(zip_buffer_t *buffer , zip_uint64_t i ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp4 ;

  {
  {
#line 284
  __cil_tmp4 = _zip_buffer_get(buffer, (zip_uint64_t )8);
#line 284
  data = __cil_tmp4;
  }
#line 286
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 287
    return (-1);
  }
#line 290
  *(data + 0) = (zip_uint8_t )(i & 255UL);
#line 291
  *(data + 1) = (zip_uint8_t )((i >> 8) & 255UL);
#line 292
  *(data + 2) = (zip_uint8_t )((i >> 16) & 255UL);
#line 293
  *(data + 3) = (zip_uint8_t )((i >> 24) & 255UL);
#line 294
  *(data + 4) = (zip_uint8_t )((i >> 32) & 255UL);
#line 295
  *(data + 5) = (zip_uint8_t )((i >> 40) & 255UL);
#line 296
  *(data + 6) = (zip_uint8_t )((i >> 48) & 255UL);
#line 297
  *(data + 7) = (zip_uint8_t )((i >> 56) & 255UL);
#line 299
  return (0);
}
}
#line 304 "/root/patchweave_new/24/lib/zip_buffer.c"
int _zip_buffer_put_8(zip_buffer_t *buffer , zip_uint8_t i ) 
{ 
  zip_uint8_t *data ;
  zip_uint8_t *__cil_tmp4 ;

  {
  {
#line 306
  __cil_tmp4 = _zip_buffer_get(buffer, (zip_uint64_t )1);
#line 306
  data = __cil_tmp4;
  }
#line 308
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 309
    return (-1);
  }
#line 312
  *(data + 0) = i;
#line 314
  return (0);
}
}
#line 319 "/root/patchweave_new/24/lib/zip_buffer.c"
int _zip_buffer_set_offset(zip_buffer_t *buffer , zip_uint64_t offset ) 
{ 


  {
#line 321
  if (offset > buffer->size) {
#line 322
    buffer->ok = 0;
#line 323
    return (-1);
  }
#line 326
  buffer->ok = 1;
#line 327
  buffer->offset = offset;
#line 329
  return (0);
}
}
#line 334 "/root/patchweave_new/24/lib/zip_buffer.c"
int _zip_buffer_skip(zip_buffer_t *buffer , zip_uint64_t length ) 
{ 
  zip_uint64_t offset ;
  int __cil_tmp4 ;

  {
#line 335
  offset = buffer->offset + length;
#line 337
  if (offset < buffer->offset) {
#line 338
    buffer->ok = 0;
#line 339
    return (-1);
  }
  {
#line 341
  __cil_tmp4 = _zip_buffer_set_offset(buffer, offset);
  }
#line 341
  return (__cil_tmp4);
}
}
#line 345 "/root/patchweave_new/24/lib/zip_buffer.c"
zip_uint64_t _zip_buffer_size(zip_buffer_t *buffer ) 
{ 


  {
#line 347
  return (buffer->size);
}
}
#line 50 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
static void *allocate(int compress___0 , int compression_flags___0 , zip_error_t *error ) 
{ 
  struct ctx *ctx ;
  void *__cil_tmp5 ;

  {
  {
#line 53
  __cil_tmp5 = malloc(sizeof(*ctx));
#line 53
  ctx = (struct ctx *)__cil_tmp5;
  }
#line 53
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 54
    return ((void *)0);
  }
#line 57
  ctx->error = error;
#line 58
  ctx->compress = compress___0;
#line 59
  ctx->compression_flags = compression_flags___0;
#line 60
  if (ctx->compression_flags < 1) {
#line 61
    ctx->compression_flags = 9;
  } else
#line 60
  if (ctx->compression_flags > 9) {
#line 61
    ctx->compression_flags = 9;
  }
#line 63
  ctx->end_of_input = 0;
#line 65
  ctx->zstr.zalloc = (voidpf (*)(voidpf  , uInt  , uInt  ))0;
#line 66
  ctx->zstr.zfree = (void (*)(voidpf  , voidpf  ))0;
#line 67
  ctx->zstr.opaque = (void *)0;
#line 69
  return ((void *)ctx);
}
}
#line 74 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
static void *compress_allocate(zip_uint16_t method , int compression_flags___0 , zip_error_t *error ) 
{ 
  void *__cil_tmp4 ;

  {
  {
#line 75
  __cil_tmp4 = allocate(1, compression_flags___0, error);
  }
#line 75
  return (__cil_tmp4);
}
}
#line 80 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
static void *decompress_allocate(zip_uint16_t method , int compression_flags___0 ,
                                 zip_error_t *error ) 
{ 
  void *__cil_tmp4 ;

  {
  {
#line 81
  __cil_tmp4 = allocate(0, compression_flags___0, error);
  }
#line 81
  return (__cil_tmp4);
}
}
#line 86 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
static void deallocate(void *ud ) 
{ 
  struct ctx *ctx ;

  {
  {
#line 87
  ctx = (struct ctx *)ud;
#line 89
  free((void *)ctx);
  }
#line 91
  return;
}
}
#line 94 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
static int compression_flags(void *ud ) 
{ 
  struct ctx *ctx ;

  {
#line 95
  ctx = (struct ctx *)ud;
#line 97
  if (! ctx->compress) {
#line 98
    return (0);
  }
#line 101
  if (ctx->compression_flags < 3) {
#line 102
    return (2);
  } else
#line 104
  if (ctx->compression_flags > 7) {
#line 105
    return (1);
  }
#line 107
  return (0);
}
}
#line 112 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
static int start(void *ud ) 
{ 
  struct ctx *ctx ;
  int ret ;

  {
#line 113
  ctx = (struct ctx *)ud;
#line 116
  ctx->zstr.avail_in = (uInt )0;
#line 117
  ctx->zstr.next_in = (Bytef *)((void *)0);
#line 118
  ctx->zstr.avail_out = (uInt )0;
#line 119
  ctx->zstr.next_out = (Bytef *)((void *)0);
#line 121
  if (ctx->compress) {
    {
#line 123
    ret = deflateInit2_(& ctx->zstr, ctx->compression_flags, 8, -15, 9, 0, "1.2.11",
                        (int )sizeof(z_stream ));
    }
  } else {
    {
#line 126
    ret = inflateInit2_(& ctx->zstr, -15, "1.2.11", (int )sizeof(z_stream ));
    }
  }
#line 129
  if (ret != 0) {
    {
#line 130
    zip_error_set(ctx->error, 13, ret);
    }
#line 131
    return (0);
  }
#line 135
  return (1);
}
}
#line 140 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
static int end(void *ud ) 
{ 
  struct ctx *ctx ;
  int err ;

  {
#line 141
  ctx = (struct ctx *)ud;
#line 144
  if (ctx->compress) {
    {
#line 145
    err = deflateEnd(& ctx->zstr);
    }
  } else {
    {
#line 148
    err = inflateEnd(& ctx->zstr);
    }
  }
#line 151
  if (err != 0) {
    {
#line 152
    zip_error_set(ctx->error, 13, err);
    }
#line 153
    return (0);
  }
#line 156
  return (1);
}
}
#line 160 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
static int input(void *ud , zip_uint8_t *data , zip_uint64_t length ) 
{ 
  struct ctx *ctx ;

  {
#line 161
  ctx = (struct ctx *)ud;
#line 163
  if (length > 4294967295UL) {
    {
#line 164
    zip_error_set(ctx->error, 18, 0);
    }
#line 165
    return (0);
  } else
#line 163
  if (ctx->zstr.avail_in > 0U) {
    {
#line 164
    zip_error_set(ctx->error, 18, 0);
    }
#line 165
    return (0);
  }
#line 168
  ctx->zstr.avail_in = (uInt )length;
#line 169
  ctx->zstr.next_in = data;
#line 171
  return (1);
}
}
#line 175 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
static void end_of_input(void *ud ) 
{ 
  struct ctx *ctx ;

  {
#line 176
  ctx = (struct ctx *)ud;
#line 178
  ctx->end_of_input = 1;
#line 179
  return;
}
}
#line 183 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
static zip_compression_status_t process(void *ud , zip_uint8_t *data , zip_uint64_t *length ) 
{ 
  struct ctx *ctx ;
  int ret ;
  unsigned long tmp ;
  int tmp___0 ;
  int __cil_tmp8 ;

  {
#line 184
  ctx = (struct ctx *)ud;
#line 188
  if (4294967295UL < *length) {
#line 188
    tmp = 4294967295UL;
  } else {
#line 188
    tmp = *length;
  }
#line 188
  ctx->zstr.avail_out = (uInt )tmp;
#line 189
  ctx->zstr.next_out = data;
#line 191
  if (ctx->compress) {
#line 192
    if (ctx->end_of_input) {
#line 192
      tmp___0 = 4;
    } else {
#line 192
      tmp___0 = 0;
    }
    {
#line 192
    __cil_tmp8 = deflate(& ctx->zstr, tmp___0);
#line 192
    ret = __cil_tmp8;
    }
  } else {
    {
#line 195
    ret = inflate(& ctx->zstr, 2);
    }
  }
#line 198
  *length -= (unsigned long )ctx->zstr.avail_out;
#line 201
  if (ret == 0) {
#line 201
    goto case_0;
  }
#line 204
  if (ret == 1) {
#line 204
    goto case_1;
  }
#line 207
  if (ret == -5) {
#line 207
    goto case_exp;
  }
#line 214
  goto switch_default;
  case_0: 
#line 202
  return ((zip_compression_status_t )0);
  case_1: 
#line 205
  return ((zip_compression_status_t )1);
  case_exp: 
#line 208
  if (ctx->zstr.avail_in == 0U) {
#line 209
    return ((zip_compression_status_t )3);
  }
  switch_default: 
  {
#line 215
  zip_error_set(ctx->error, 13, ret);
  }
#line 216
  return ((zip_compression_status_t )2);

#line 220
  return ((enum zip_compression_status )0);
}
}
#line 221 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
zip_compression_algorithm_t zip_algorithm_deflate_compress  = 
#line 221
     {& compress_allocate, & deallocate, & compression_flags, & start, & end, & input,
    & end_of_input, & process};
#line 233 "/root/patchweave_new/24/lib/zip_algorithm_deflate.c"
zip_compression_algorithm_t zip_algorithm_deflate_decompress  = 
#line 233
     {& decompress_allocate, & deallocate, & compression_flags, & start, & end, & input,
    & end_of_input, & process};
#line 43 "/root/patchweave_new/24/lib/zip_add_entry.c"
zip_int64_t _zip_add_entry(zip_t *za___0 ) 
{ 
  zip_uint64_t idx ;
  zip_entry_t *rentries ;
  zip_uint64_t nalloc ;
  zip_uint64_t additional_entries ;
  zip_uint64_t realloc_size ;
  void *__cil_tmp7 ;
  zip_uint64_t __cil_tmp8 ;

  {
#line 47
  if (za___0->nentry + 1UL >= za___0->nentry_alloc) {
#line 49
    nalloc = za___0->nentry_alloc;
#line 50
    additional_entries = 2UL * nalloc;
#line 53
    if (additional_entries < 16UL) {
#line 54
      additional_entries = (zip_uint64_t )16;
    } else
#line 56
    if (additional_entries > 1024UL) {
#line 57
      additional_entries = (zip_uint64_t )1024;
    }
#line 60
    nalloc += additional_entries;
#line 61
    realloc_size = sizeof(struct zip_entry ) * nalloc;
#line 63
    if (sizeof(struct zip_entry ) * za___0->nentry_alloc > realloc_size) {
      {
#line 64
      zip_error_set(& za___0->error, 14, 0);
      }
#line 65
      return ((zip_int64_t )-1);
    }
    {
#line 67
    __cil_tmp7 = realloc((void *)za___0->entry, sizeof(struct zip_entry ) * nalloc);
#line 67
    rentries = (zip_entry_t *)__cil_tmp7;
    }
#line 68
    if (! rentries) {
      {
#line 69
      zip_error_set(& za___0->error, 14, 0);
      }
#line 70
      return ((zip_int64_t )-1);
    }
#line 72
    za___0->entry = rentries;
#line 73
    za___0->nentry_alloc = nalloc;
  }
  {
#line 76
  __cil_tmp8 = za___0->nentry;
#line 76
  (za___0->nentry) ++;
#line 76
  idx = __cil_tmp8;
#line 78
  _zip_entry_init(za___0->entry + idx);
  }
#line 80
  return ((zip_int64_t )idx);
}
}
#line 42 "/root/patchweave_new/24/lib/zip_add_dir.c"
zip_int64_t zip_add_dir(zip_t *za___0 , char const   *name ) 
{ 
  zip_int64_t __cil_tmp3 ;

  {
  {
#line 44
  __cil_tmp3 = zip_dir_add(za___0, name, (zip_flags_t )0);
  }
#line 44
  return (__cil_tmp3);
}
}
#line 47 "/root/patchweave_new/24/lib/zip_add.c"
zip_int64_t zip_add(zip_t *za___0 , char const   *name , zip_source_t *source ) 
{ 
  zip_int64_t __cil_tmp4 ;

  {
  {
#line 49
  __cil_tmp4 = zip_file_add(za___0, name, source, (zip_flags_t )0);
  }
#line 49
  return (__cil_tmp4);
}
}
#line 45 "/root/patchweave_new/24/lib/zip_source_file.c"
zip_source_t *zip_source_file(zip_t *za___0 , char const   *fname , zip_uint64_t start___0 ,
                              zip_int64_t len ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 47
  if ((unsigned long )za___0 == (unsigned long )((void *)0)) {
#line 48
    return ((zip_source_t *)((void *)0));
  }
  {
#line 50
  __cil_tmp5 = zip_source_file_create(fname, start___0, len, & za___0->error);
  }
#line 50
  return (__cil_tmp5);
}
}
#line 55 "/root/patchweave_new/24/lib/zip_source_file.c"
zip_source_t *zip_source_file_create(char const   *fname , zip_uint64_t start___0 ,
                                     zip_int64_t length , zip_error_t *error ) 
{ 
  zip_source_t *__cil_tmp5 ;

  {
#line 57
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
    {
#line 58
    zip_error_set(error, 18, 0);
    }
#line 59
    return ((zip_source_t *)((void *)0));
  } else
#line 57
  if (length < -1L) {
    {
#line 58
    zip_error_set(error, 18, 0);
    }
#line 59
    return ((zip_source_t *)((void *)0));
  }
  {
#line 62
  __cil_tmp5 = _zip_source_file_or_p(fname, (FILE *)((void *)0), start___0, length,
                                     (zip_stat_t *)((void *)0), error);
  }
#line 62
  return (__cil_tmp5);
}
}
#line 168 "/usr/include/fcntl.h"
__inline extern int ( __attribute__((__gnu_inline__)) open)(char const   *__path ,
                                                            int __oflag  , ...) ;
#line 192
__inline extern int ( __attribute__((__gnu_inline__)) openat)(int __fd , char const   *__path ,
                                                              int __oflag  , ...) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__gnu_inline__)) open)(char const   *__path ,
                                                            int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
#line 46
  __cil_tmp4 = 0;
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = (int )__builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = (int )__builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__gnu_inline__)) openat)(int __fd , char const   *__path ,
                                                              int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
#line 122
  __cil_tmp5 = 0;
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = (int )__builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = (int )__builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 40 "/root/patchweave_new/24/lib/zip_random_unix.c"
int zip_random(zip_uint8_t *buffer , zip_uint16_t length ) 
{ 
  int fd ;
  ssize_t __cil_tmp5 ;

  {
  {
#line 44
  fd = open("/dev/urandom", 0);
  }
#line 44
  if (fd < 0) {
#line 45
    return (0);
  }
  {
#line 48
  __cil_tmp5 = read(fd, (void *)buffer, (size_t )length);
  }
#line 48
  if (__cil_tmp5 != (long )length) {
    {
#line 49
    close(fd);
    }
#line 50
    return (0);
  }
  {
#line 53
  close(fd);
  }
#line 54
  return (1);
}
}
#line 56 "/root/patchweave_new/24/src/ziptool.c"
zip_source_t *source_hole_create(char const   *fname , int flags , zip_error_t *error ) ;
#line 72
static zip_flags_t get_flags(char const   *arg ) ;
#line 73
static zip_int32_t get_compression_method(char const   *arg ) ;
#line 74
static zip_uint16_t get_encryption_method(char const   *arg ) ;
#line 75
static void hexdump(zip_uint8_t *data , zip_uint16_t len ) ;
#line 76
static zip_t *read_to_memory(char const   *archive , int flags , zip_error_t *error ,
                             zip_source_t **srcp ) ;
#line 77
static zip_source_t *source_nul(zip_t *zs , zip_uint64_t length ) ;
#line 79 "/root/patchweave_new/24/src/ziptool.c"
zip_t *za  ;
#line 79 "/root/patchweave_new/24/src/ziptool.c"
zip_t *z_in[16]  ;
#line 80 "/root/patchweave_new/24/src/ziptool.c"
unsigned int z_in_count  ;
#line 81 "/root/patchweave_new/24/src/ziptool.c"
zip_flags_t stat_flags  ;
#line 84 "/root/patchweave_new/24/src/ziptool.c"
static int add(int argc , char **argv ) 
{ 
  zip_source_t *zs ;
  unsigned long __cil_tmp4 ;
  zip_source_t *__cil_tmp5 ;
  char const   *__cil_tmp6 ;
  zip_int64_t __cil_tmp7 ;
  char const   *__cil_tmp8 ;

  {
  {
#line 87
  __cil_tmp4 = strlen((char const   *)*(argv + 1));
#line 87
  __cil_tmp5 = zip_source_buffer(za, (void const   *)*(argv + 1), __cil_tmp4, 0);
#line 87
  zs = __cil_tmp5;
  }
#line 87
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 88
    __cil_tmp6 = zip_strerror(za);
#line 88
    fprintf(stderr, "can\'t create zip_source from buffer: %s\n\230", __cil_tmp6);
    }
#line 89
    return (-1);
  }
  {
#line 92
  __cil_tmp7 = zip_add(za, (char const   *)*(argv + 0), zs);
  }
#line 92
  if (__cil_tmp7 == -1L) {
    {
#line 93
    zip_source_free(zs);
#line 94
    __cil_tmp8 = zip_strerror(za);
#line 94
    fprintf(stderr, "can\'t add file \'%s\': %s\n\230\001", *(argv + 0), __cil_tmp8);
    }
#line 95
    return (-1);
  }
#line 97
  return (0);
}
}
#line 101 "/root/patchweave_new/24/src/ziptool.c"
static int add_dir(int argc , char **argv ) 
{ 
  zip_int64_t __cil_tmp3 ;
  char const   *__cil_tmp4 ;

  {
  {
#line 103
  __cil_tmp3 = zip_add_dir(za, (char const   *)*(argv + 0));
  }
#line 103
  if (__cil_tmp3 < 0L) {
    {
#line 104
    __cil_tmp4 = zip_strerror(za);
#line 104
    fprintf(stderr, "can\'t add directory \'%s\': %s\n", *(argv + 0), __cil_tmp4);
    }
#line 105
    return (-1);
  }
#line 107
  return (0);
}
}
#line 111 "/root/patchweave_new/24/src/ziptool.c"
static int add_file(int argc , char **argv ) 
{ 
  zip_source_t *zs ;
  zip_uint64_t start___0 ;
  unsigned long long __cil_tmp5 ;
  zip_int64_t len ;
  long long __cil_tmp7 ;
  int __cil_tmp8 ;
  char const   *__cil_tmp10 ;
  char const   *__cil_tmp12 ;
  zip_int64_t __cil_tmp13 ;
  char const   *__cil_tmp14 ;

  {
  {
#line 113
  __cil_tmp5 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 113
  start___0 = (zip_uint64_t )__cil_tmp5;
#line 114
  __cil_tmp7 = strtoll((char const   *)*(argv + 3), (char **)((void *)0), 10);
#line 114
  len = (zip_int64_t )__cil_tmp7;
#line 116
  __cil_tmp8 = strcmp((char const   *)*(argv + 1), "/dev/stdin\311\320\342U");
  }
#line 116
  if (__cil_tmp8 == 0) {
    {
#line 117
    zs = zip_source_filep(za, stdin, start___0, len);
    }
#line 117
    if ((unsigned long )zs == (unsigned long )((void *)0)) {
      {
#line 118
      __cil_tmp10 = zip_strerror(za);
#line 118
      fprintf(stderr, "can\'t create zip_source from stdin: %s\n", __cil_tmp10);
      }
#line 119
      return (-1);
    }
  } else {
    {
#line 122
    zs = zip_source_file(za, (char const   *)*(argv + 1), start___0, len);
    }
#line 122
    if ((unsigned long )zs == (unsigned long )((void *)0)) {
      {
#line 123
      __cil_tmp12 = zip_strerror(za);
#line 123
      fprintf(stderr, "can\'t create zip_source from file: %s\n", __cil_tmp12);
      }
#line 124
      return (-1);
    }
  }
  {
#line 128
  __cil_tmp13 = zip_add(za, (char const   *)*(argv + 0), zs);
  }
#line 128
  if (__cil_tmp13 == -1L) {
    {
#line 129
    zip_source_free(zs);
#line 130
    __cil_tmp14 = zip_strerror(za);
#line 130
    fprintf(stderr, "can\'t add file \'%s\': %s\n\230\001", *(argv + 0), __cil_tmp14);
    }
#line 131
    return (-1);
  }
#line 133
  return (0);
}
}
#line 137 "/root/patchweave_new/24/src/ziptool.c"
static int add_from_zip(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  zip_uint64_t start___0 ;
  zip_int64_t len ;
  int err ;
  zip_source_t *zs ;
  unsigned long long __cil_tmp8 ;
  unsigned long long __cil_tmp9 ;
  long long __cil_tmp10 ;
  zip_error_t error ;
  char const   *__cil_tmp13 ;
  char const   *__cil_tmp15 ;
  zip_int64_t __cil_tmp16 ;
  char const   *__cil_tmp17 ;

  {
  {
#line 143
  __cil_tmp8 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 143
  idx = (zip_uint64_t )__cil_tmp8;
#line 144
  __cil_tmp9 = strtoull((char const   *)*(argv + 3), (char **)((void *)0), 10);
#line 144
  start___0 = (zip_uint64_t )__cil_tmp9;
#line 145
  __cil_tmp10 = strtoll((char const   *)*(argv + 4), (char **)((void *)0), 10);
#line 145
  len = (zip_int64_t )__cil_tmp10;
#line 146
  z_in[z_in_count] = zip_open((char const   *)*(argv + 1), 4, & err);
  }
#line 146
  if ((unsigned long )z_in[z_in_count] == (unsigned long )((void *)0)) {
    {
#line 148
    zip_error_init_with_code(& error, err);
#line 149
    __cil_tmp13 = zip_error_strerror(& error);
#line 149
    fprintf(stderr, "can\'t open zip archive \'%s\': %s\n\230\001", *(argv + 1), __cil_tmp13);
#line 150
    zip_error_fini(& error);
    }
#line 151
    return (-1);
  }
  {
#line 153
  zs = zip_source_zip(za, z_in[z_in_count], idx, (zip_flags_t )0, start___0, len);
  }
#line 153
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 154
    __cil_tmp15 = zip_strerror(za);
#line 154
    fprintf(stderr, "error creating file source from \'%s\' index \'%lu\': %s\n",
            *(argv + 1), idx, __cil_tmp15);
#line 155
    zip_close(z_in[z_in_count]);
    }
#line 156
    return (-1);
  }
  {
#line 158
  __cil_tmp16 = zip_add(za, (char const   *)*(argv + 0), zs);
  }
#line 158
  if (__cil_tmp16 == -1L) {
    {
#line 159
    __cil_tmp17 = zip_strerror(za);
#line 159
    fprintf(stderr, "can\'t add file \'%s\': %s\n\230\001", *(argv + 0), __cil_tmp17);
#line 160
    zip_source_free(zs);
#line 161
    zip_close(z_in[z_in_count]);
    }
#line 162
    return (-1);
  }
#line 164
  z_in_count ++;
#line 165
  return (0);
}
}
#line 169 "/root/patchweave_new/24/src/ziptool.c"
static int add_nul(int argc , char **argv ) 
{ 
  zip_source_t *zs ;
  zip_uint64_t length ;
  unsigned long long __cil_tmp5 ;
  char const   *__cil_tmp7 ;
  zip_int64_t __cil_tmp8 ;
  char const   *__cil_tmp9 ;

  {
  {
#line 171
  __cil_tmp5 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 171
  length = (zip_uint64_t )__cil_tmp5;
#line 173
  zs = source_nul(za, length);
  }
#line 173
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 174
    __cil_tmp7 = zip_strerror(za);
#line 174
    fprintf(stderr, "can\'t create zip_source for length: %s\n", __cil_tmp7);
    }
#line 175
    return (-1);
  }
  {
#line 178
  __cil_tmp8 = zip_add(za, (char const   *)*(argv + 0), zs);
  }
#line 178
  if (__cil_tmp8 == -1L) {
    {
#line 179
    zip_source_free(zs);
#line 180
    __cil_tmp9 = zip_strerror(za);
#line 180
    fprintf(stderr, "can\'t add file \'%s\': %s\n\230\001", *(argv + 0), __cil_tmp9);
    }
#line 181
    return (-1);
  }
#line 183
  return (0);
}
}
#line 187 "/root/patchweave_new/24/src/ziptool.c"
static int cat(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  zip_int64_t n ;
  zip_file_t *zf ;
  char buf[8192] ;
  int err ;
  unsigned long long __cil_tmp8 ;
  char const   *__cil_tmp10 ;
  unsigned long __cil_tmp12 ;
  int *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char const   *__cil_tmp15 ;
  zip_error_t error ;
  char const   *__cil_tmp18 ;

  {
  {
#line 194
  __cil_tmp8 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 194
  idx = (zip_uint64_t )__cil_tmp8;
#line 200
  zf = zip_fopen_index(za, idx, (zip_flags_t )0);
  }
#line 200
  if ((unsigned long )zf == (unsigned long )((void *)0)) {
    {
#line 201
    __cil_tmp10 = zip_strerror(za);
#line 201
    fprintf(stderr, "can\'t open file at index \'%lu\': %s\n", idx, __cil_tmp10);
    }
#line 202
    return (-1);
  }
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 204
    n = zip_fread(zf, (void *)(buf), sizeof(buf));
    }
#line 204
    if (! (n > 0L)) {
#line 204
      goto while_break;
    }
    {
#line 205
    __cil_tmp12 = fwrite((void const   *)(buf), (size_t )n, 1UL, stdout);
    }
#line 205
    if (__cil_tmp12 != 1UL) {
      {
#line 206
      zip_fclose(zf);
#line 207
      __cil_tmp13 = __errno_location();
#line 207
      __cil_tmp14 = strerror(*__cil_tmp13);
#line 207
      fprintf(stderr, "can\'t write file contents to stdout: %s\n\230", __cil_tmp14);
      }
#line 208
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 211
  if (n == -1L) {
    {
#line 212
    __cil_tmp15 = zip_file_strerror(zf);
#line 212
    fprintf(stderr, "can\'t read file at index \'%lu\': %s\n", idx, __cil_tmp15);
#line 213
    zip_fclose(zf);
    }
#line 214
    return (-1);
  }
  {
#line 216
  err = zip_fclose(zf);
  }
#line 216
  if (err != 0) {
    {
#line 219
    zip_error_init_with_code(& error, err);
#line 220
    __cil_tmp18 = zip_error_strerror(& error);
#line 220
    fprintf(stderr, "can\'t close file at index \'%lu\': %s\n\230\001", idx, __cil_tmp18);
    }
#line 221
    return (-1);
  }
#line 224
  return (0);
}
}
#line 228 "/root/patchweave_new/24/src/ziptool.c"
static int count_extra(int argc , char **argv ) 
{ 
  zip_int16_t count ;
  zip_uint64_t idx ;
  zip_flags_t ceflags ;
  unsigned long long __cil_tmp6 ;
  char const   *__cil_tmp9 ;

  {
  {
#line 231
  ceflags = (zip_flags_t )0;
#line 232
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 232
  idx = (zip_uint64_t )__cil_tmp6;
#line 233
  ceflags = get_flags((char const   *)*(argv + 1));
#line 234
  count = zip_file_extra_fields_count(za, idx, ceflags);
  }
#line 234
  if ((int )count < 0) {
    {
#line 235
    __cil_tmp9 = zip_strerror(za);
#line 235
    fprintf(stderr, "can\'t get extra field count for file at index \'%lu\': %s\n",
            idx, __cil_tmp9);
    }
#line 236
    return (-1);
  } else {
    {
#line 238
    printf("Extra field count: %d\n", (int )count);
    }
  }
#line 240
  return (0);
}
}
#line 244 "/root/patchweave_new/24/src/ziptool.c"
static int count_extra_by_id(int argc , char **argv ) 
{ 
  zip_int16_t count ;
  zip_uint16_t eid ;
  zip_flags_t ceflags ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp7 ;
  unsigned long long __cil_tmp8 ;
  char const   *__cil_tmp11 ;

  {
  {
#line 247
  ceflags = (zip_flags_t )0;
#line 249
  __cil_tmp7 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 249
  idx = (zip_uint64_t )__cil_tmp7;
#line 250
  __cil_tmp8 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 250
  eid = (zip_uint16_t )__cil_tmp8;
#line 251
  ceflags = get_flags((char const   *)*(argv + 2));
#line 252
  count = zip_file_extra_fields_count_by_id(za, idx, eid, ceflags);
  }
#line 252
  if ((int )count < 0) {
    {
#line 253
    __cil_tmp11 = zip_strerror(za);
#line 253
    fprintf(stderr, "can\'t get extra field count for file at index \'%lu\' and for id \'%d\': %s\n\342U",
            idx, (int )eid, __cil_tmp11);
    }
#line 254
    return (-1);
  } else {
    {
#line 256
    printf("Extra field count: %d\n", (int )count);
    }
  }
#line 258
  return (0);
}
}
#line 262 "/root/patchweave_new/24/src/ziptool.c"
static int delete(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  unsigned long long __cil_tmp4 ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;

  {
  {
#line 264
  __cil_tmp4 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 264
  idx = (zip_uint64_t )__cil_tmp4;
#line 265
  __cil_tmp5 = zip_delete(za, idx);
  }
#line 265
  if (__cil_tmp5 < 0) {
    {
#line 266
    __cil_tmp6 = zip_strerror(za);
#line 266
    fprintf(stderr, "can\'t delete file at index \'%lu\': %s\n", idx, __cil_tmp6);
    }
#line 267
    return (-1);
  }
#line 269
  return (0);
}
}
#line 273 "/root/patchweave_new/24/src/ziptool.c"
static int delete_extra(int argc , char **argv ) 
{ 
  zip_flags_t geflags ;
  zip_uint16_t eid ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp6 ;
  unsigned long long __cil_tmp7 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;

  {
  {
#line 277
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 277
  idx = (zip_uint64_t )__cil_tmp6;
#line 278
  __cil_tmp7 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 278
  eid = (zip_uint16_t )__cil_tmp7;
#line 279
  geflags = get_flags((char const   *)*(argv + 2));
#line 280
  __cil_tmp9 = zip_file_extra_field_delete(za, idx, eid, geflags);
  }
#line 280
  if (__cil_tmp9 < 0) {
    {
#line 281
    __cil_tmp10 = zip_strerror(za);
#line 281
    fprintf(stderr, "can\'t delete extra field data for file at index \'%lu\', extra field id \'%d\': %s\n",
            idx, (int )eid, __cil_tmp10);
    }
#line 282
    return (-1);
  }
#line 284
  return (0);
}
}
#line 288 "/root/patchweave_new/24/src/ziptool.c"
static int delete_extra_by_id(int argc , char **argv ) 
{ 
  zip_flags_t geflags ;
  zip_uint16_t eid ;
  zip_uint16_t eidx ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp7 ;
  unsigned long long __cil_tmp8 ;
  unsigned long long __cil_tmp9 ;
  int __cil_tmp11 ;
  char const   *__cil_tmp12 ;

  {
  {
#line 292
  __cil_tmp7 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 292
  idx = (zip_uint64_t )__cil_tmp7;
#line 293
  __cil_tmp8 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 293
  eid = (zip_uint16_t )__cil_tmp8;
#line 294
  __cil_tmp9 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 294
  eidx = (zip_uint16_t )__cil_tmp9;
#line 295
  geflags = get_flags((char const   *)*(argv + 3));
#line 296
  __cil_tmp11 = zip_file_extra_field_delete_by_id(za, idx, eid, eidx, geflags);
  }
#line 296
  if (__cil_tmp11 < 0) {
    {
#line 297
    __cil_tmp12 = zip_strerror(za);
#line 297
    fprintf(stderr, "can\'t delete extra field data for file at index \'%lu\', extra field id \'%d\', extra field idx \'%d\': %s\n",
            idx, (int )eid, (int )eidx, __cil_tmp12);
    }
#line 298
    return (-1);
  }
#line 300
  return (0);
}
}
#line 304 "/root/patchweave_new/24/src/ziptool.c"
static int get_archive_comment(int argc , char **argv ) 
{ 
  char const   *comment ;
  int len ;

  {
  {
#line 308
  comment = zip_get_archive_comment(za, & len, (zip_flags_t )0);
  }
#line 308
  if ((unsigned long )comment == (unsigned long )((void *)0)) {
    {
#line 309
    printf("No archive comment\n");
    }
  } else {
    {
#line 311
    printf("Archive comment: %.*s\n", len, comment);
    }
  }
#line 312
  return (0);
}
}
#line 316 "/root/patchweave_new/24/src/ziptool.c"
static int get_extra(int argc , char **argv ) 
{ 
  zip_flags_t geflags ;
  zip_uint16_t id ;
  zip_uint16_t eidx ;
  zip_uint16_t eflen ;
  zip_uint8_t *efdata ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp9 ;
  unsigned long long __cil_tmp10 ;
  char const   *__cil_tmp13 ;

  {
  {
#line 322
  __cil_tmp9 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 322
  idx = (zip_uint64_t )__cil_tmp9;
#line 323
  __cil_tmp10 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 323
  eidx = (zip_uint16_t )__cil_tmp10;
#line 324
  geflags = get_flags((char const   *)*(argv + 2));
#line 325
  efdata = zip_file_extra_field_get(za, idx, eidx, & id, & eflen, geflags);
  }
#line 325
  if ((unsigned long )efdata == (unsigned long )((void *)0)) {
    {
#line 326
    __cil_tmp13 = zip_strerror(za);
#line 326
    fprintf(stderr, "can\'t get extra field data for file at index %lu, extra field %d, flags %u: %s\n",
            idx, (int )eidx, geflags, __cil_tmp13);
    }
#line 327
    return (-1);
  }
  {
#line 329
  printf("Extra field 0x%04x: len %d", (int )id, (int )eflen);
  }
#line 330
  if ((int )eflen > 0) {
    {
#line 331
    printf(", data ");
#line 332
    hexdump(efdata, eflen);
    }
  }
  {
#line 334
  printf("\n\365\262\320\342U");
  }
#line 335
  return (0);
}
}
#line 339 "/root/patchweave_new/24/src/ziptool.c"
static int get_extra_by_id(int argc , char **argv ) 
{ 
  zip_flags_t geflags ;
  zip_uint16_t eid ;
  zip_uint16_t eidx ;
  zip_uint16_t eflen ;
  zip_uint8_t *efdata ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp9 ;
  unsigned long long __cil_tmp10 ;
  unsigned long long __cil_tmp11 ;
  char const   *__cil_tmp14 ;

  {
  {
#line 344
  __cil_tmp9 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 344
  idx = (zip_uint64_t )__cil_tmp9;
#line 345
  __cil_tmp10 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 345
  eid = (zip_uint16_t )__cil_tmp10;
#line 346
  __cil_tmp11 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 346
  eidx = (zip_uint16_t )__cil_tmp11;
#line 347
  geflags = get_flags((char const   *)*(argv + 3));
#line 348
  efdata = zip_file_extra_field_get_by_id(za, idx, eid, eidx, & eflen, geflags);
  }
#line 348
  if ((unsigned long )efdata == (unsigned long )((void *)0)) {
    {
#line 349
    __cil_tmp14 = zip_strerror(za);
#line 349
    fprintf(stderr, "can\'t get extra field data for file at index %lu, extra field id %d, ef index %d, flags %u: %s\n",
            idx, (int )eid, (int )eidx, geflags, __cil_tmp14);
    }
#line 350
    return (-1);
  }
  {
#line 352
  printf("Extra field 0x%04x: len %d", (int )eid, (int )eflen);
  }
#line 353
  if ((int )eflen > 0) {
    {
#line 354
    printf(", data ");
#line 355
    hexdump(efdata, eflen);
    }
  }
  {
#line 357
  printf("\n");
  }
#line 358
  return (0);
}
}
#line 362 "/root/patchweave_new/24/src/ziptool.c"
static int get_file_comment(int argc , char **argv ) 
{ 
  char const   *comment ;
  int len ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp6 ;
  char const   *__cil_tmp8 ;
  char const   *__cil_tmp9 ;
  char const   *__cil_tmp10 ;
  char const   *__cil_tmp11 ;

  {
  {
#line 367
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 367
  idx = (zip_uint64_t )__cil_tmp6;
#line 368
  comment = zip_get_file_comment(za, idx, & len, 0);
  }
#line 368
  if ((unsigned long )comment == (unsigned long )((void *)0)) {
    {
#line 369
    __cil_tmp8 = zip_get_name(za, idx, (zip_flags_t )0);
#line 369
    __cil_tmp9 = zip_strerror(za);
#line 369
    fprintf(stderr, "can\'t get comment for \'%s\': %s\n", __cil_tmp8, __cil_tmp9);
    }
#line 370
    return (-1);
  } else
#line 371
  if (len == 0) {
    {
#line 372
    __cil_tmp10 = zip_get_name(za, idx, (zip_flags_t )0);
#line 372
    printf("No comment for \'%s\'\n\342U", __cil_tmp10);
    }
  } else {
    {
#line 374
    __cil_tmp11 = zip_get_name(za, idx, (zip_flags_t )0);
#line 374
    printf("File comment for \'%s\': %.*s\n", __cil_tmp11, len, comment);
    }
  }
#line 375
  return (0);
}
}
#line 379 "/root/patchweave_new/24/src/ziptool.c"
static int get_num_entries(int argc , char **argv ) 
{ 
  zip_int64_t count ;
  zip_flags_t flags ;
  char const   *tmp ;

  {
  {
#line 383
  flags = get_flags((char const   *)*(argv + 0));
#line 384
  count = zip_get_num_entries(za, flags);
  }
#line 385
  if (count == 1L) {
#line 385
    tmp = "y";
  } else {
#line 385
    tmp = "ies";
  }
  {
#line 385
  printf("%ld entr%s in archive\n", count, tmp);
  }
#line 386
  return (0);
}
}
#line 390 "/root/patchweave_new/24/src/ziptool.c"
static int name_locate(int argc , char **argv ) 
{ 
  zip_flags_t flags ;
  zip_int64_t idx ;

  {
  {
#line 393
  flags = get_flags((char const   *)*(argv + 1));
#line 395
  idx = zip_name_locate(za, (char const   *)*(argv + 0), flags);
  }
#line 395
  if (idx < 0L) {
    {
#line 396
    fprintf(stderr, "can\'t find entry with name \'%s\' using flags \'%s\'\nT\313\320\342U",
            *(argv + 0), *(argv + 1));
    }
  } else {
    {
#line 398
    printf("name \'%s\' using flags \'%s\' found at index %ld\n", *(argv + 0), *(argv + 1),
           idx);
    }
  }
#line 401
  return (0);
}
}
#line 405 "/root/patchweave_new/24/src/ziptool.c"
static void progress_callback(zip_t *za___0 , double percentage , void *ud ) 
{ 


  {
  {
#line 406
  printf("%.1lf%% done\nU", percentage * (double )100);
  }
#line 408
  return;
}
}
#line 410 "/root/patchweave_new/24/src/ziptool.c"
static int print_progress(int argc , char **argv ) 
{ 


  {
  {
#line 411
  zip_register_progress_callback_with_state(za, 0.00100000000001, & progress_callback,
                                            (void (*)(void * ))((void *)0), (void *)0);
  }
#line 412
  return (0);
}
}
#line 416 "/root/patchweave_new/24/src/ziptool.c"
static int zrename(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  unsigned long long __cil_tmp4 ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;

  {
  {
#line 418
  __cil_tmp4 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 418
  idx = (zip_uint64_t )__cil_tmp4;
#line 419
  __cil_tmp5 = zip_rename(za, idx, (char const   *)*(argv + 1));
  }
#line 419
  if (__cil_tmp5 < 0) {
    {
#line 420
    __cil_tmp6 = zip_strerror(za);
#line 420
    fprintf(stderr, "can\'t rename file at index \'%lu\' to \'%s\': %s\n", idx, *(argv + 1),
            __cil_tmp6);
    }
#line 421
    return (-1);
  }
#line 423
  return (0);
}
}
#line 427 "/root/patchweave_new/24/src/ziptool.c"
static int replace_file_contents(int argc , char **argv ) 
{ 
  char const   *content ;
  zip_source_t *s ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  zip_source_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;

  {
  {
#line 432
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 432
  idx = (zip_uint64_t )__cil_tmp6;
#line 433
  content = (char const   *)*(argv + 1);
#line 434
  __cil_tmp9 = zip_file_replace(za, idx, s, (zip_flags_t )0);
#line 434
  __cil_tmp7 = strlen(content);
#line 434
  __cil_tmp8 = zip_source_buffer(za, (void const   *)content, __cil_tmp7, 0);
#line 434
  s = __cil_tmp8;
  }
#line 434
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 436
    zip_source_free(s);
#line 437
    __cil_tmp10 = zip_strerror(za);
#line 437
    fprintf(stderr, "error replacing file data: %s\n", __cil_tmp10);
    }
#line 438
    return (-1);
  } else
#line 434
  if (__cil_tmp9 < 0) {
    {
#line 436
    zip_source_free(s);
#line 437
    __cil_tmp10 = zip_strerror(za);
#line 437
    fprintf(stderr, "error replacing file data: %s\n", __cil_tmp10);
    }
#line 438
    return (-1);
  }
#line 440
  return (0);
}
}
#line 444 "/root/patchweave_new/24/src/ziptool.c"
static int set_extra(int argc , char **argv ) 
{ 
  zip_flags_t geflags ;
  zip_uint16_t eid ;
  zip_uint16_t eidx ;
  zip_uint8_t *efdata ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp8 ;
  unsigned long long __cil_tmp9 ;
  unsigned long long __cil_tmp10 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  char const   *__cil_tmp14 ;

  {
  {
#line 449
  __cil_tmp8 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 449
  idx = (zip_uint64_t )__cil_tmp8;
#line 450
  __cil_tmp9 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 450
  eid = (zip_uint16_t )__cil_tmp9;
#line 451
  __cil_tmp10 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 451
  eidx = (zip_uint16_t )__cil_tmp10;
#line 452
  geflags = get_flags((char const   *)*(argv + 3));
#line 453
  efdata = (zip_uint8_t *)*(argv + 4);
#line 454
  __cil_tmp12 = strlen((char const   *)efdata);
#line 454
  __cil_tmp13 = zip_file_extra_field_set(za, idx, eid, eidx, efdata, (zip_uint16_t )__cil_tmp12,
                                         geflags);
  }
#line 454
  if (__cil_tmp13 < 0) {
    {
#line 455
    __cil_tmp14 = zip_strerror(za);
#line 455
    fprintf(stderr, "can\'t set extra field data for file at index \'%lu\', extra field id \'%d\', index \'%d\': %s\n",
            idx, (int )eid, (int )eidx, __cil_tmp14);
    }
#line 456
    return (-1);
  }
#line 458
  return (0);
}
}
#line 462 "/root/patchweave_new/24/src/ziptool.c"
static int set_archive_comment(int argc , char **argv ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
  {
#line 463
  __cil_tmp3 = strlen((char const   *)*(argv + 0));
#line 463
  __cil_tmp4 = zip_set_archive_comment(za, (char const   *)*(argv + 0), (zip_uint16_t )__cil_tmp3);
  }
#line 463
  if (__cil_tmp4 < 0) {
    {
#line 464
    __cil_tmp5 = zip_strerror(za);
#line 464
    fprintf(stderr, "can\'t set archive comment to \'%s\': %s\n", *(argv + 0), __cil_tmp5);
    }
#line 465
    return (-1);
  }
#line 467
  return (0);
}
}
#line 471 "/root/patchweave_new/24/src/ziptool.c"
static int set_file_comment(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  unsigned long long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  char const   *__cil_tmp7 ;

  {
  {
#line 473
  __cil_tmp4 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 473
  idx = (zip_uint64_t )__cil_tmp4;
#line 474
  __cil_tmp5 = strlen((char const   *)*(argv + 1));
#line 474
  __cil_tmp6 = zip_file_set_comment(za, idx, (char const   *)*(argv + 1), (zip_uint16_t )__cil_tmp5,
                                    (zip_flags_t )0);
  }
#line 474
  if (__cil_tmp6 < 0) {
    {
#line 475
    __cil_tmp7 = zip_strerror(za);
#line 475
    fprintf(stderr, "can\'t set file comment at index \'%lu\' to \'%s\': %s\n", idx,
            *(argv + 1), __cil_tmp7);
    }
#line 476
    return (-1);
  }
#line 478
  return (0);
}
}
#line 482 "/root/patchweave_new/24/src/ziptool.c"
static int set_file_compression(int argc , char **argv ) 
{ 
  zip_int32_t method ;
  zip_uint32_t flags ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp6 ;
  unsigned long long __cil_tmp8 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;

  {
  {
#line 486
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 486
  idx = (zip_uint64_t )__cil_tmp6;
#line 487
  method = get_compression_method((char const   *)*(argv + 1));
#line 488
  __cil_tmp8 = strtoull((char const   *)*(argv + 2), (char **)((void *)0), 10);
#line 488
  flags = (zip_uint32_t )__cil_tmp8;
#line 489
  __cil_tmp9 = zip_set_file_compression(za, idx, method, flags);
  }
#line 489
  if (__cil_tmp9 < 0) {
    {
#line 490
    __cil_tmp10 = zip_strerror(za);
#line 490
    fprintf(stderr, "can\'t set file compression method at index \'%lu\' to \'%s\', flags \'%d\': %s\n",
            idx, *(argv + 1), flags, __cil_tmp10);
    }
#line 491
    return (-1);
  }
#line 493
  return (0);
}
}
#line 497 "/root/patchweave_new/24/src/ziptool.c"
static int set_file_encryption(int argc , char **argv ) 
{ 
  zip_int32_t method ;
  zip_uint64_t idx ;
  char *password ;
  unsigned long long __cil_tmp6 ;
  zip_uint16_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;

  {
  {
#line 501
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 501
  idx = (zip_uint64_t )__cil_tmp6;
#line 502
  __cil_tmp7 = get_encryption_method((char const   *)*(argv + 1));
#line 502
  method = (zip_int32_t )__cil_tmp7;
#line 503
  password = *(argv + 2);
#line 504
  __cil_tmp8 = strlen((char const   *)password);
  }
#line 504
  if (__cil_tmp8 == 0UL) {
#line 505
    password = (char *)((void *)0);
  }
  {
#line 507
  __cil_tmp9 = zip_file_set_encryption(za, idx, (zip_uint16_t )method, (char const   *)password);
  }
#line 507
  if (__cil_tmp9 < 0) {
    {
#line 508
    __cil_tmp10 = zip_strerror(za);
#line 508
    fprintf(stderr, "can\'t set file encryption method at index \'%lu\' to \'%s\': %s\n\230\001",
            idx, *(argv + 1), __cil_tmp10);
    }
#line 509
    return (-1);
  }
#line 511
  return (0);
}
}
#line 515 "/root/patchweave_new/24/src/ziptool.c"
static int set_file_mtime(int argc , char **argv ) 
{ 
  time_t mtime ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp5 ;
  unsigned long long __cil_tmp6 ;
  int __cil_tmp7 ;
  char const   *__cil_tmp8 ;

  {
  {
#line 519
  __cil_tmp5 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 519
  idx = (zip_uint64_t )__cil_tmp5;
#line 520
  __cil_tmp6 = strtoull((char const   *)*(argv + 1), (char **)((void *)0), 10);
#line 520
  mtime = (time_t )__cil_tmp6;
#line 521
  __cil_tmp7 = zip_file_set_mtime(za, idx, mtime, (zip_flags_t )0);
  }
#line 521
  if (__cil_tmp7 < 0) {
    {
#line 522
    __cil_tmp8 = zip_strerror(za);
#line 522
    fprintf(stderr, "can\'t set file mtime at index \'%lu\' to \'%ld\': %s\n", idx,
            mtime, __cil_tmp8);
    }
#line 523
    return (-1);
  }
#line 525
  return (0);
}
}
#line 529 "/root/patchweave_new/24/src/ziptool.c"
static int set_file_mtime_all(int argc , char **argv ) 
{ 
  time_t mtime ;
  zip_int64_t num_entries ;
  zip_uint64_t idx ;
  unsigned long long __cil_tmp6 ;
  char const   *__cil_tmp8 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;

  {
  {
#line 534
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 534
  mtime = (time_t )__cil_tmp6;
#line 536
  num_entries = zip_get_num_entries(za, (zip_flags_t )0);
  }
#line 536
  if (num_entries < 0L) {
    {
#line 537
    __cil_tmp8 = zip_strerror(za);
#line 537
    fprintf(stderr, "can\'t get number of entries: %s\n\230", __cil_tmp8);
    }
#line 538
    return (-1);
  }
#line 540
  idx = (zip_uint64_t )0;
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;

#line 540
    if (! (idx < (zip_uint64_t )num_entries)) {
#line 540
      goto while_break;
    }
    {
#line 541
    __cil_tmp9 = zip_file_set_mtime(za, idx, mtime, (zip_flags_t )0);
    }
#line 541
    if (__cil_tmp9 < 0) {
      {
#line 542
      __cil_tmp10 = zip_strerror(za);
#line 542
      fprintf(stderr, "can\'t set file mtime at index \'%lu\' to \'%ld\': %s\n", idx,
              mtime, __cil_tmp10);
      }
#line 543
      return (-1);
    }
#line 540
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 546
  return (0);
}
}
#line 550 "/root/patchweave_new/24/src/ziptool.c"
static int set_password(int argc , char **argv ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 552
  __cil_tmp3 = zip_set_default_password(za, (char const   *)*(argv + 0));
  }
#line 552
  if (__cil_tmp3 < 0) {
    {
#line 553
    fprintf(stderr, "can\'t set default password to \'%s\'\n", *(argv + 0));
    }
#line 554
    return (-1);
  }
#line 556
  return (0);
}
}
#line 560 "/root/patchweave_new/24/src/ziptool.c"
static int zstat(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  char buf[100] ;
  struct zip_stat sb ;
  unsigned long long __cil_tmp6 ;
  int __cil_tmp7 ;
  char const   *__cil_tmp8 ;
  struct tm *tpm ;

  {
  {
#line 564
  __cil_tmp6 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 564
  idx = (zip_uint64_t )__cil_tmp6;
#line 566
  __cil_tmp7 = zip_stat_index(za, idx, stat_flags, & sb);
  }
#line 566
  if (__cil_tmp7 < 0) {
    {
#line 567
    __cil_tmp8 = zip_strerror(za);
#line 567
    fprintf(stderr, "zip_stat_index failed on \'%lu\' failed: %s\n", idx, __cil_tmp8);
    }
#line 568
    return (-1);
  }
#line 571
  if (sb.valid & 1UL) {
    {
#line 572
    printf("name: \'%s\'\n", sb.name);
    }
  }
#line 573
  if (sb.valid & 2UL) {
    {
#line 574
    printf("index: \'%lu\'\n", sb.index);
    }
  }
#line 575
  if (sb.valid & 4UL) {
    {
#line 576
    printf("size: \'%lu\'\n\230\001", sb.size);
    }
  }
#line 577
  if (sb.valid & 8UL) {
    {
#line 578
    printf("compressed size: \'%lu\'\n\320\342U", sb.comp_size);
    }
  }
#line 579
  if (sb.valid & 16UL) {
    {
#line 581
    tpm = localtime(& sb.mtime);
#line 582
    strftime(buf, sizeof(buf), "%a %b %d %Y %H:%M:%S", tpm);
#line 583
    printf("mtime: \'%s\'\n", buf);
    }
  }
#line 585
  if (sb.valid & 32UL) {
    {
#line 586
    printf("crc: \'%0x\'\n", sb.crc);
    }
  }
#line 587
  if (sb.valid & 64UL) {
    {
#line 588
    printf("compression method: \'%d\'\n", (int )sb.comp_method);
    }
  }
#line 589
  if (sb.valid & 128UL) {
    {
#line 590
    printf("encryption method: \'%d\'\n\230\001", (int )sb.encryption_method);
    }
  }
#line 591
  if (sb.valid & 256UL) {
    {
#line 592
    printf("flags: \'%ld\'\n", (long )sb.flags);
    }
  }
  {
#line 593
  printf("\n");
  }
#line 595
  return (0);
}
}
#line 599 "/root/patchweave_new/24/src/ziptool.c"
static int unchange_all(int argc , char **argv ) 
{ 
  int __cil_tmp3 ;
  char const   *__cil_tmp4 ;

  {
  {
#line 600
  __cil_tmp3 = zip_unchange_all(za);
  }
#line 600
  if (__cil_tmp3 < 0) {
    {
#line 601
    __cil_tmp4 = zip_strerror(za);
#line 601
    fprintf(stderr, "can\'t revert changes to archive: %s\n", __cil_tmp4);
    }
#line 602
    return (-1);
  }
#line 604
  return (0);
}
}
#line 608 "/root/patchweave_new/24/src/ziptool.c"
static int zin_close(int argc , char **argv ) 
{ 
  zip_uint64_t idx ;
  unsigned long long __cil_tmp4 ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;
  unsigned int __cil_tmp7 ;

  {
  {
#line 611
  __cil_tmp4 = strtoull((char const   *)*(argv + 0), (char **)((void *)0), 10);
#line 611
  idx = (zip_uint64_t )__cil_tmp4;
  }
#line 612
  if (idx >= (unsigned long )z_in_count) {
    {
#line 613
    fprintf(stderr, "invalid argument \'%lu\', only %d zip sources open\n", idx, z_in_count);
    }
#line 614
    return (-1);
  }
  {
#line 616
  __cil_tmp5 = zip_close(z_in[idx]);
  }
#line 616
  if (__cil_tmp5 < 0) {
    {
#line 617
    __cil_tmp6 = zip_strerror(z_in[idx]);
#line 617
    fprintf(stderr, "can\'t close source archive: %s\n", __cil_tmp6);
    }
#line 618
    return (-1);
  }
#line 620
  z_in[idx] = z_in[z_in_count];
#line 621
  __cil_tmp7 = z_in_count;
#line 621
  z_in_count --;
#line 623
  return (0);
}
}
#line 627 "/root/patchweave_new/24/src/ziptool.c"
static zip_flags_t get_flags(char const   *arg ) 
{ 
  zip_flags_t flags ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 629
  flags = (zip_flags_t )0;
#line 630
  __cil_tmp3 = strchr(arg, 'C');
  }
#line 630
  if ((unsigned long )__cil_tmp3 != (unsigned long )((void *)0)) {
#line 631
    flags |= 1U;
  }
  {
#line 632
  __cil_tmp4 = strchr(arg, 'c');
  }
#line 632
  if ((unsigned long )__cil_tmp4 != (unsigned long )((void *)0)) {
#line 633
    flags |= 512U;
  }
  {
#line 634
  __cil_tmp5 = strchr(arg, 'd');
  }
#line 634
  if ((unsigned long )__cil_tmp5 != (unsigned long )((void *)0)) {
#line 635
    flags |= 2U;
  }
  {
#line 636
  __cil_tmp6 = strchr(arg, 'l');
  }
#line 636
  if ((unsigned long )__cil_tmp6 != (unsigned long )((void *)0)) {
#line 637
    flags |= 256U;
  }
  {
#line 638
  __cil_tmp7 = strchr(arg, 'u');
  }
#line 638
  if ((unsigned long )__cil_tmp7 != (unsigned long )((void *)0)) {
#line 639
    flags |= 8U;
  }
#line 640
  return (flags);
}
}
#line 644 "/root/patchweave_new/24/src/ziptool.c"
static zip_int32_t get_compression_method(char const   *arg ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 646
  __cil_tmp2 = strcmp(arg, "default");
  }
#line 646
  if (__cil_tmp2 == 0) {
#line 647
    return (-1);
  } else {
    {
#line 648
    __cil_tmp3 = strcmp(arg, "store");
    }
#line 648
    if (__cil_tmp3 == 0) {
#line 649
      return (0);
    } else {
      {
#line 650
      __cil_tmp4 = strcmp(arg, "deflate");
      }
#line 650
      if (__cil_tmp4 == 0) {
#line 651
        return (8);
      } else {
        {
#line 656
        __cil_tmp5 = strcmp(arg, "unknown");
        }
#line 656
        if (__cil_tmp5 == 0) {
#line 657
          return (100);
        }
      }
    }
  }
#line 658
  return (0);
}
}
#line 662 "/root/patchweave_new/24/src/ziptool.c"
static zip_uint16_t get_encryption_method(char const   *arg ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 664
  __cil_tmp2 = strcmp(arg, "none");
  }
#line 664
  if (__cil_tmp2 == 0) {
#line 665
    return ((zip_uint16_t )0);
  } else {
    {
#line 666
    __cil_tmp3 = strcmp(arg, "AES-128");
    }
#line 666
    if (__cil_tmp3 == 0) {
#line 667
      return ((zip_uint16_t )257);
    } else {
      {
#line 668
      __cil_tmp4 = strcmp(arg, "AES-192");
      }
#line 668
      if (__cil_tmp4 == 0) {
#line 669
        return ((zip_uint16_t )258);
      } else {
        {
#line 670
        __cil_tmp5 = strcmp(arg, "AES-256");
        }
#line 670
        if (__cil_tmp5 == 0) {
#line 671
          return ((zip_uint16_t )259);
        } else {
          {
#line 672
          __cil_tmp6 = strcmp(arg, "unknown");
          }
#line 672
          if (__cil_tmp6 == 0) {
#line 673
            return ((zip_uint16_t )100);
          }
        }
      }
    }
  }
#line 674
  return ((zip_uint16_t )-1);
}
}
#line 678 "/root/patchweave_new/24/src/ziptool.c"
static void hexdump(zip_uint8_t *data , zip_uint16_t len ) 
{ 
  zip_uint16_t i ;

  {
#line 682
  if ((int )len <= 0) {
#line 683
    return;
  }
  {
#line 685
  printf("0x\314\320\342U");
#line 687
  i = (zip_uint16_t )0;
  }
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;

#line 687
    if (! ((int )i < (int )len)) {
#line 687
      goto while_break;
    }
    {
#line 688
    printf("%02x", (int )*(data + (int )i));
#line 687
    i = (zip_uint16_t )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 690
  return;
}
}
#line 695 "/root/patchweave_new/24/src/ziptool.c"
static zip_t *read_from_file(char const   *archive , int flags , zip_error_t *error ,
                             zip_uint64_t offset , zip_uint64_t length ) 
{ 
  zip_t *zaa ;
  zip_source_t *source ;
  int err ;
  int __cil_tmp9 ;
  int *__cil_tmp12 ;

  {
#line 701
  if (offset == 0UL) {
#line 701
    if (length == 0UL) {
      {
#line 702
      __cil_tmp9 = strcmp(archive, "/dev/stdin\314\320\342U");
      }
#line 702
      if (__cil_tmp9 == 0) {
        {
#line 703
        zaa = zip_fdopen(0, flags & -2, & err);
        }
      } else {
        {
#line 706
        zaa = zip_open(archive, flags, & err);
        }
      }
#line 708
      if ((unsigned long )zaa == (unsigned long )((void *)0)) {
        {
#line 709
        __cil_tmp12 = __errno_location();
#line 709
        zip_error_set(error, err, *__cil_tmp12);
        }
#line 710
        return ((zip_t *)((void *)0));
      }
    } else {
#line 701
      goto _L;
    }
  } else {
    _L: 
#line 714
    if (length > 0xffffffffffffffffUL) {
      {
#line 715
      zip_error_set(error, 18, 0);
      }
#line 716
      return ((zip_t *)((void *)0));
    }
    {
#line 718
    zaa = zip_open_from_source(source, flags, error);
#line 718
    source = zip_source_file_create(archive, offset, (zip_int64_t )length, error);
    }
#line 718
    if ((unsigned long )source == (unsigned long )((void *)0)) {
      {
#line 720
      zip_source_free(source);
      }
#line 721
      return ((zip_t *)((void *)0));
    } else
#line 718
    if ((unsigned long )zaa == (unsigned long )((void *)0)) {
      {
#line 720
      zip_source_free(source);
      }
#line 721
      return ((zip_t *)((void *)0));
    }
  }
#line 725
  return (zaa);
}
}
#line 730 "/root/patchweave_new/24/src/ziptool.c"
static zip_t *read_hole(char const   *archive , int flags , zip_error_t *error ) 
{ 
  zip_source_t *src ;
  zip_t *zs ;
  int __cil_tmp6 ;

  {
  {
#line 732
  src = (zip_source_t *)((void *)0);
#line 733
  zs = (zip_t *)((void *)0);
#line 735
  __cil_tmp6 = strcmp(archive, "/dev/stdin\314\320\342U");
  }
#line 735
  if (__cil_tmp6 == 0) {
    {
#line 736
    zip_error_set(error, 28, 0);
    }
#line 737
    return ((zip_t *)((void *)0));
  }
  {
#line 740
  zs = zip_open_from_source(src, flags, error);
#line 740
  src = source_hole_create(archive, flags, error);
  }
#line 740
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 742
    zip_source_free(src);
    }
  } else
#line 740
  if ((unsigned long )zs == (unsigned long )((void *)0)) {
    {
#line 742
    zip_source_free(src);
    }
  }
#line 745
  return (zs);
}
}
#line 750 "/root/patchweave_new/24/src/ziptool.c"
static zip_t *read_to_memory(char const   *archive , int flags , zip_error_t *error ,
                             zip_source_t **srcp ) 
{ 
  struct stat st ;
  zip_source_t *src ;
  zip_t *zb ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int *__cil_tmp10 ;
  int *__cil_tmp12 ;
  char *buf ;
  FILE *fp ;
  int *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int *__cil_tmp19 ;
  void *tmp ;

  {
  {
#line 756
  __cil_tmp8 = strcmp(archive, "/dev/stdin");
  }
#line 756
  if (__cil_tmp8 == 0) {
    {
#line 757
    zip_error_set(error, 28, 0);
    }
#line 758
    return ((zip_t *)((void *)0));
  }
  {
#line 761
  __cil_tmp9 = stat(archive, & st);
  }
#line 761
  if (__cil_tmp9 < 0) {
    {
#line 762
    __cil_tmp10 = __errno_location();
    }
#line 762
    if (*__cil_tmp10 == 2) {
      {
#line 763
      src = zip_source_buffer_create((void const   *)((void *)0), (zip_uint64_t )0,
                                     0, error);
      }
    } else {
      {
#line 766
      __cil_tmp12 = __errno_location();
#line 766
      zip_error_set(error, 11, *__cil_tmp12);
      }
#line 767
      return ((zip_t *)((void *)0));
    }
  } else {
    {
#line 773
    tmp = malloc((size_t )st.st_size);
#line 773
    buf = (char *)tmp;
    }
#line 773
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 774
      zip_error_set(error, 14, 0);
      }
#line 775
      return ((zip_t *)((void *)0));
    }
    {
#line 777
    fp = fopen(archive, "r\316\314\320\342U");
    }
#line 777
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 778
      free((void *)buf);
#line 779
      __cil_tmp17 = __errno_location();
#line 779
      zip_error_set(error, 5, *__cil_tmp17);
      }
#line 780
      return ((zip_t *)((void *)0));
    }
    {
#line 782
    __cil_tmp18 = fread((void *)buf, (size_t )st.st_size, 1UL, fp);
    }
#line 782
    if (__cil_tmp18 < 1UL) {
      {
#line 783
      free((void *)buf);
#line 784
      fclose(fp);
#line 785
      __cil_tmp19 = __errno_location();
#line 785
      zip_error_set(error, 5, *__cil_tmp19);
      }
#line 786
      return ((zip_t *)((void *)0));
    }
    {
#line 788
    fclose(fp);
#line 789
    src = zip_source_buffer_create((void const   *)buf, (zip_uint64_t )st.st_size,
                                   1, error);
    }
#line 790
    if ((unsigned long )src == (unsigned long )((void *)0)) {
      {
#line 791
      free((void *)buf);
      }
    }
  }
#line 794
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 795
    return ((zip_t *)((void *)0));
  }
  {
#line 797
  zb = zip_open_from_source(src, flags, error);
  }
#line 798
  if ((unsigned long )zb == (unsigned long )((void *)0)) {
    {
#line 799
    zip_source_free(src);
    }
#line 800
    return ((zip_t *)((void *)0));
  }
  {
#line 802
  zip_source_keep(src);
#line 803
  *srcp = src;
  }
#line 804
  return (zb);
}
}
#line 815 "/root/patchweave_new/24/src/ziptool.c"
static zip_int64_t source_nul_cb(void *ud , void *data , zip_uint64_t length , zip_source_cmd_t command ) 
{ 
  source_nul_t *ctx ;
  zip_int64_t __cil_tmp6 ;
  zip_stat_t *st ;
  zip_stat_t *tmp ;
  zip_int64_t __cil_tmp9 ;

  {
#line 817
  ctx = (source_nul_t *)ud;
#line 820
  if ((unsigned int )command == 2U) {
#line 820
    goto case_2;
  }
#line 823
  if ((unsigned int )command == 4U) {
#line 823
    goto case_4;
  }
#line 826
  if ((unsigned int )command == 5U) {
#line 826
    goto case_5;
  }
#line 830
  if ((unsigned int )command == 0U) {
#line 830
    goto case_0;
  }
#line 834
  if ((unsigned int )command == 1U) {
#line 834
    goto case_1;
  }
#line 848
  if ((unsigned int )command == 3U) {
#line 848
    goto case_3;
  }
#line 861
  if ((unsigned int )command == 14U) {
#line 861
    goto case_14;
  }
#line 864
  goto switch_default;
  case_2: 
#line 821
  return ((zip_int64_t )0);
  case_4: 
  {
#line 824
  __cil_tmp6 = zip_error_to_data(& ctx->error, data, length);
  }
#line 824
  return (__cil_tmp6);
  case_5: 
  {
#line 827
  free((void *)ctx);
  }
#line 828
  return ((zip_int64_t )0);
  case_0: 
#line 831
  ctx->offset = (zip_uint64_t )0;
#line 832
  return ((zip_int64_t )0);
  case_1: 
#line 835
  if (length > 0xffffffffffffffffUL) {
    {
#line 836
    zip_error_set(& ctx->error, 18, 0);
    }
#line 837
    return ((zip_int64_t )-1);
  }
#line 840
  if (length > ctx->length - ctx->offset) {
#line 841
    length = ctx->length - ctx->offset;
  }
  {
#line 844
  memset(data, 0, length);
#line 845
  ctx->offset += length;
  }
#line 846
  return ((zip_int64_t )length);
  case_3: 
#line 849
  if (length < sizeof(zip_stat_t )) {
    {
#line 849
    zip_error_set(& ctx->error, 18, 0);
#line 849
    tmp = (zip_stat_t *)((void *)0);
    }
  } else {
#line 849
    tmp = (zip_stat_t *)data;
  }
#line 849
  st = tmp;
#line 851
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 852
    return ((zip_int64_t )-1);
  }
#line 855
  st->valid |= 4UL;
#line 856
  st->size = ctx->length;
#line 858
  return ((zip_int64_t )0);
  case_14: 
  {
#line 862
  __cil_tmp9 = zip_source_make_command_bitmap((zip_source_cmd_t )2, 4, 5, 0, 1, 3,
                                              -1);
  }
#line 862
  return (__cil_tmp9);
  switch_default: 
  {
#line 865
  zip_error_set(& ctx->error, 28, 0);
  }
#line 866
  return ((zip_int64_t )-1);

#line 870
  return (0L);
}
}
#line 871 "/root/patchweave_new/24/src/ziptool.c"
static zip_source_t *source_nul(zip_t *zs , zip_uint64_t length ) 
{ 
  source_nul_t *ctx ;
  zip_source_t *src ;
  void *__cil_tmp5 ;
  zip_error_t *__cil_tmp6 ;

  {
  {
#line 876
  __cil_tmp5 = malloc(sizeof(*ctx));
#line 876
  ctx = (source_nul_t *)__cil_tmp5;
  }
#line 876
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 877
    __cil_tmp6 = zip_get_error(zs);
#line 877
    zip_error_set(__cil_tmp6, 14, 0);
    }
#line 878
    return ((zip_source_t *)((void *)0));
  }
  {
#line 881
  zip_error_init(& ctx->error);
#line 882
  ctx->length = length;
#line 883
  ctx->offset = (zip_uint64_t )0;
#line 885
  src = zip_source_function(zs, & source_nul_cb, (void *)ctx);
  }
#line 885
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 886
    free((void *)ctx);
    }
#line 887
    return ((zip_source_t *)((void *)0));
  }
#line 890
  return (src);
}
}
#line 895 "/root/patchweave_new/24/src/ziptool.c"
static int write_memory_src_to_file(char const   *archive , zip_source_t *src ) 
{ 
  zip_stat_t zst ;
  char *buf ;
  FILE *fp ;
  int __cil_tmp6 ;
  zip_error_t *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  int __cil_tmp9 ;
  zip_error_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int *__cil_tmp13 ;
  int *__cil_tmp14 ;
  char *__cil_tmp15 ;
  zip_error_t *__cil_tmp16 ;
  char const   *__cil_tmp17 ;
  int *__cil_tmp19 ;
  char *__cil_tmp20 ;
  zip_int64_t __cil_tmp21 ;
  zip_error_t *__cil_tmp22 ;
  char const   *__cil_tmp23 ;
  int *__cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int *__cil_tmp28 ;
  char *__cil_tmp29 ;
  int __cil_tmp30 ;
  int *__cil_tmp31 ;
  char *__cil_tmp32 ;
  void *tmp ;

  {
  {
#line 901
  __cil_tmp6 = zip_source_stat(src, & zst);
  }
#line 901
  if (__cil_tmp6 < 0) {
    {
#line 902
    __cil_tmp7 = zip_source_error(src);
#line 902
    __cil_tmp8 = zip_error_strerror(__cil_tmp7);
#line 902
    fprintf(stderr, "zip_source_stat on buffer failed: %s\nU", __cil_tmp8);
    }
#line 903
    return (-1);
  }
  {
#line 905
  __cil_tmp9 = zip_source_open(src);
  }
#line 905
  if (__cil_tmp9 < 0) {
    {
#line 906
    __cil_tmp10 = zip_source_error(src);
#line 906
    __cil_tmp11 = zip_error_code_zip(__cil_tmp10);
    }
#line 906
    if (__cil_tmp11 == 23) {
      {
#line 907
      __cil_tmp13 = __errno_location();
#line 907
      __cil_tmp12 = unlink(archive);
      }
#line 907
      if (__cil_tmp12 < 0) {
#line 907
        if (*__cil_tmp13 != 2) {
          {
#line 908
          __cil_tmp14 = __errno_location();
#line 908
          __cil_tmp15 = strerror(*__cil_tmp14);
#line 908
          fprintf(stderr, "unlink failed: %s\n\314\320\342U", __cil_tmp15);
          }
#line 909
          return (-1);
        }
      }
#line 911
      return (0);
    }
    {
#line 913
    __cil_tmp16 = zip_source_error(src);
#line 913
    __cil_tmp17 = zip_error_strerror(__cil_tmp16);
#line 913
    fprintf(stderr, "zip_source_open on buffer failed: %s\nU", __cil_tmp17);
    }
#line 914
    return (-1);
  }
  {
#line 916
  tmp = malloc(zst.size);
#line 916
  buf = (char *)tmp;
  }
#line 916
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 917
    __cil_tmp19 = __errno_location();
#line 917
    __cil_tmp20 = strerror(*__cil_tmp19);
#line 917
    fprintf(stderr, "malloc failed: %s\n\315\320\342U", __cil_tmp20);
#line 918
    zip_source_close(src);
    }
#line 919
    return (-1);
  }
  {
#line 921
  __cil_tmp21 = zip_source_read(src, (void *)buf, zst.size);
  }
#line 921
  if (__cil_tmp21 < (zip_int64_t )zst.size) {
    {
#line 922
    __cil_tmp22 = zip_source_error(src);
#line 922
    __cil_tmp23 = zip_error_strerror(__cil_tmp22);
#line 922
    fprintf(stderr, "zip_source_read on buffer failed: %s\nU", __cil_tmp23);
#line 923
    zip_source_close(src);
#line 924
    free((void *)buf);
    }
#line 925
    return (-1);
  }
  {
#line 927
  zip_source_close(src);
#line 928
  fp = fopen(archive, "wb");
  }
#line 928
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 929
    __cil_tmp25 = __errno_location();
#line 929
    __cil_tmp26 = strerror(*__cil_tmp25);
#line 929
    fprintf(stderr, "fopen failed: %s\n", __cil_tmp26);
#line 930
    free((void *)buf);
    }
#line 931
    return (-1);
  }
  {
#line 933
  __cil_tmp27 = fwrite((void const   *)buf, zst.size, 1UL, fp);
  }
#line 933
  if (__cil_tmp27 < 1UL) {
    {
#line 934
    __cil_tmp28 = __errno_location();
#line 934
    __cil_tmp29 = strerror(*__cil_tmp28);
#line 934
    fprintf(stderr, "fwrite failed: %s\n", __cil_tmp29);
#line 935
    free((void *)buf);
#line 936
    fclose(fp);
    }
#line 937
    return (-1);
  }
  {
#line 939
  free((void *)buf);
#line 940
  __cil_tmp30 = fclose(fp);
  }
#line 940
  if (__cil_tmp30 != 0) {
    {
#line 941
    __cil_tmp31 = __errno_location();
#line 941
    __cil_tmp32 = strerror(*__cil_tmp31);
#line 941
    fprintf(stderr, "fclose failed: %s\n", __cil_tmp32);
    }
#line 942
    return (-1);
  }
#line 944
  return (0);
}
}
#line 947 "/root/patchweave_new/24/src/ziptool.c"
dispatch_table_t dispatch_table[31]  = 
#line 947
  {      {"add", 2, "name content", "add file called name using content", & add}, 
        {"add_dir", 1, "name", "add directoryU", & add_dir}, 
        {"add_file\251", 4, "name file_to_add offset len", "add file to archive, len bytes starting from offset",
      & add_file}, 
        {"add_from_zip", 5, "name archivename index offset len", "add file from another archive, len bytes starting from offsetU",
      & add_from_zip}, 
        {"add_nul", 2, "name length", "add NUL bytes", & add_nul}, 
        {"cat\320\342U", 1, "index", "output file contents to stdout", & cat}, 
        {"count_extra\320\342U", 2, "index flags", "show number of extra fields for archive entryU",
      & count_extra}, 
        {"count_extra_by_idO\315\320\342U", 3, "index extra_id flags\342U", "show number of extra fields of type extra_id for archive entry",
      & count_extra_by_id}, 
        {"delete", 1, "indexU", "remove entry", & delete}, 
        {"delete_extra", 3, "index extra_idx flagsU", "remove extra field\315\320\342U",
      & delete_extra}, 
        {"delete_extra_by_id", 4, "index extra_id extra_index flags\323\001 ", "remove extra field of type extra_id",
      & delete_extra_by_id}, 
        {"get_archive_comment\320\342U", 0, "\323\001 \320\001", "show archive comment",
      & get_archive_comment}, 
        {"get_extra", 3, "index extra_index flags", "show extra field\230", & get_extra}, 
        {"get_extra_by_id",
      4, "index extra_id extra_index flags\323\001 \320\001", "show extra field of type extra_id",
      & get_extra_by_id}, 
        {"get_file_comment\251", 1, "indexU", "get file comment\230", & get_file_comment}, 
        {"get_num_entries",
      1, "flags", "get number of entries in archive\230", & get_num_entries}, 
        {"name_locate\320\342U", 2, "name flags", "find entry in archive", & name_locate}, 
        {"print_progress",
      0, "\323\001 ", "print progress during zip_close()", & print_progress}, 
        {"rename", 2, "index name", "rename entry\342U", & zrename}, 
        {"replace_file_contents", 2, "index data\315\320\342U", "replace entry with data",
      & replace_file_contents}, 
        {"set_archive_comment", 1, "comment", "set archive comment", & set_archive_comment}, 
        {"set_extra`\315\320\342U",
      5, "index extra_id extra_index flags value", "set extra field", & set_extra}, 
        {"set_file_comment\251",
      2, "index comment", "set file comment\230", & set_file_comment}, 
        {"set_file_compression", 3, "index method compression_flags", "set file compression method",
      & set_file_compression}, 
        {"set_file_encryption\320\342U", 3, "index method passwordU", "set file encryption method",
      & set_file_encryption}, 
        {"set_file_mtime", 2, "index timestamp", "set file modification time\315\320\342U",
      & set_file_mtime}, 
        {"set_file_mtime_all\315\320\342U", 1, "timestamp", "set file modification time for all files\230",
      & set_file_mtime_all}, 
        {"set_password\342U", 1, "password\323\001 ", "set default password for encryption\320\342U",
      & set_password}, 
        {"stat\342U", 1, "indexU", "print information about entry", & zstat}, 
        {"unchange_all", 0, "\323\001 ", "revert all changes\315\320\342U", & unchange_all}, 
        {"zin_close(\315\320\342U",
      1, "indexU", "close input zip_source (for internal tests)", & zin_close}};
#line 982 "/root/patchweave_new/24/src/ziptool.c"
static int dispatch(int argc , char **argv ) 
{ 
  unsigned int i ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp7 ;

  {
#line 985
  i = 0U;
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;

#line 985
    if (! ((unsigned long )i < sizeof(dispatch_table) / sizeof(dispatch_table_t ))) {
#line 985
      goto while_break;
    }
    {
#line 986
    __cil_tmp4 = strcmp(dispatch_table[i].cmdline_name, (char const   *)*(argv + 0));
    }
#line 986
    if (__cil_tmp4 == 0) {
#line 987
      __cil_tmp5 = argc;
#line 987
      argc --;
#line 988
      argv ++;
#line 990
      if (argc < dispatch_table[i].argument_count) {
        {
#line 991
        fprintf(stderr, "not enough arguments for command \'%s\': %d available, %d needed\n",
                dispatch_table[i].cmdline_name, argc, dispatch_table[i].argument_count);
        }
#line 992
        return (-1);
      }
      {
#line 994
      __cil_tmp7 = (*(dispatch_table[i].function))(argc, argv);
      }
#line 994
      if (__cil_tmp7 == 0) {
#line 995
        return (1 + dispatch_table[i].argument_count);
      }
#line 996
      return (-1);
    }
#line 985
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1000
  fprintf(stderr, "unknown command \'%s\'\n", *(argv + 0));
  }
#line 1001
  return (-1);
}
}
#line 1006 "/root/patchweave_new/24/src/ziptool.c"
static void usage(char const   *progname , char const   *reason ) 
{ 
  unsigned int i ;
  FILE *out ;

  {
#line 1010
  if ((unsigned long )reason == (unsigned long )((void *)0)) {
#line 1011
    out = stdout;
  } else {
#line 1013
    out = stderr;
  }
  {
#line 1014
  fprintf(out, "usage: %s [-cegHhmnrst] [-l len] [-o offset] archive command1 [args] [command2 [args] ...]\n",
          progname);
  }
#line 1015
  if ((unsigned long )reason != (unsigned long )((void *)0)) {
    {
#line 1016
    fprintf(out, "%s\n", reason);
#line 1017
    exit(1);
    }
  }
  {
#line 1020
  fprintf(out, "\nSupported options are:\n\t-c\t\tcheck consistency\n\t-e\t\terror if archive already exists (only useful with -n)\n\t-g\t\tguess file name encoding (for stat)\n\t-H\t\twrite files with holes compactly\n\t-h\t\tdisplay this usage\n\t-l len\t\tonly use len bytes of file\n\t-m\t\tread archive into memory, and modify there; write out at end\n\t-n\t\tcreate archive if it doesn\'t exist\n\t-o offset\tstart reading file at offset\n\t-r\t\tprint raw file name encoding without translation (for stat)\n\t-s\t\tfollow file name convention strictly (for stat)\n\t-t\t\tdisregard current archive contents, if any\n");
#line 1033
  fprintf(out, "\nSupported commands and arguments are:\n");
#line 1034
  i = 0U;
  }
  {
#line 1034
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1034
    if (! ((unsigned long )i < sizeof(dispatch_table) / sizeof(dispatch_table_t ))) {
#line 1034
      goto while_break;
    }
    {
#line 1035
    fprintf(out, "\t%s %s\n\t    %s\n\n\230\001", dispatch_table[i].cmdline_name,
            dispatch_table[i].arg_names, dispatch_table[i].description);
#line 1034
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1037
  fprintf(out, "\nSupported flags are:\n\t0\t(no flags)\n\tC\tZIP_FL_NOCASE\n\tc\tZIP_FL_CENTRAL\n\td\tZIP_FL_NODIR\n\tl\tZIP_FL_LOCAL\n\tu\tZIP_FL_UNCHANGED\n");
#line 1044
  fprintf(out, "\nSupported compression methods are:\n\tdefault\n\tdeflate\n\tstore\n");
#line 1051
  fprintf(out, "\nSupported compression methods are:\n\tnone\n\tAES-128\n\tAES-192\n\tAES-256\n");
#line 1056
  fprintf(out, "\nThe index is zero-based.\n");
#line 1057
  exit(0);
  }
}
}
#line 1061 "/root/patchweave_new/24/src/ziptool.c"
int main(int argc , char **argv ) 
{ 
  char const   *archive ;
  zip_source_t *memory_src ;
  unsigned int i ;
  int c ;
  int arg ;
  int err ;
  int flags ;
  char const   *prg ;
  source_type_t source_type ;
  zip_uint64_t len ;
  zip_uint64_t offset ;
  zip_error_t error ;
  unsigned long long __cil_tmp16 ;
  unsigned long long __cil_tmp17 ;
  char reason[128] ;
  int __cil_tmp19 ;
  char const   *__cil_tmp23 ;
  int ret ;
  int __cil_tmp26 ;
  char const   *__cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;

  {
#line 1068
  source_type = (source_type_t )0;
#line 1069
  len = (zip_uint64_t )0;
#line 1069
  offset = (zip_uint64_t )0;
#line 1072
  flags = 0;
#line 1073
  prg = (char const   *)*(argv + 0);
  {
#line 1075
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1075
    c = getopt(argc, (char * const  *)argv, "cegHhl:mno:rst");
    }
#line 1075
    if (! (c != -1)) {
#line 1075
      goto while_break;
    }
#line 1077
    if (c == 99) {
#line 1077
      goto case_99;
    }
#line 1080
    if (c == 101) {
#line 1080
      goto case_101;
    }
#line 1083
    if (c == 103) {
#line 1083
      goto case_103;
    }
#line 1086
    if (c == 72) {
#line 1086
      goto case_72;
    }
#line 1089
    if (c == 104) {
#line 1089
      goto case_104;
    }
#line 1092
    if (c == 108) {
#line 1092
      goto case_108;
    }
#line 1095
    if (c == 109) {
#line 1095
      goto case_109;
    }
#line 1098
    if (c == 110) {
#line 1098
      goto case_110;
    }
#line 1101
    if (c == 111) {
#line 1101
      goto case_111;
    }
#line 1104
    if (c == 114) {
#line 1104
      goto case_114;
    }
#line 1107
    if (c == 115) {
#line 1107
      goto case_115;
    }
#line 1110
    if (c == 116) {
#line 1110
      goto case_116;
    }
#line 1114
    goto switch_default;
    case_99: 
#line 1078
    flags |= 4;
#line 1079
    goto switch_break;
    case_101: 
#line 1081
    flags |= 2;
#line 1082
    goto switch_break;
    case_103: 
#line 1084
    stat_flags = 0U;
#line 1085
    goto switch_break;
    case_72: 
#line 1087
    source_type = (source_type_t )2;
#line 1088
    goto switch_break;
    case_104: 
    {
#line 1090
    usage(prg, (char const   *)((void *)0));
    }
#line 1091
    goto switch_break;
    case_108: 
    {
#line 1093
    __cil_tmp16 = strtoull((char const   *)optarg, (char **)((void *)0), 10);
#line 1093
    len = (zip_uint64_t )__cil_tmp16;
    }
#line 1094
    goto switch_break;
    case_109: 
#line 1096
    source_type = (source_type_t )1;
#line 1097
    goto switch_break;
    case_110: 
#line 1099
    flags |= 1;
#line 1100
    goto switch_break;
    case_111: 
    {
#line 1102
    __cil_tmp17 = strtoull((char const   *)optarg, (char **)((void *)0), 10);
#line 1102
    offset = (zip_uint64_t )__cil_tmp17;
    }
#line 1103
    goto switch_break;
    case_114: 
#line 1105
    stat_flags = 64U;
#line 1106
    goto switch_break;
    case_115: 
#line 1108
    stat_flags = 128U;
#line 1109
    goto switch_break;
    case_116: 
#line 1111
    flags |= 8;
#line 1112
    goto switch_break;
    switch_default: 
    {
#line 1117
    snprintf(reason, sizeof(reason), "invalid option -%c", optopt);
#line 1118
    usage(prg, (char const   *)(reason));
    }
    switch_break: ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 1123
  if (optind >= argc - 1) {
    {
#line 1124
    usage(prg, "too few arguments");
    }
  }
#line 1126
  arg = optind;
#line 1128
  __cil_tmp19 = arg;
#line 1128
  arg ++;
#line 1128
  archive = (char const   *)*(argv + __cil_tmp19);
#line 1130
  if (flags == 0) {
#line 1131
    flags = 1;
  }
  {
#line 1133
  zip_error_init(& error);
  }
#line 1135
  if ((unsigned int )source_type == 0U) {
#line 1135
    goto case_0;
  }
#line 1139
  if ((unsigned int )source_type == 1U) {
#line 1139
    goto case_1;
  }
#line 1143
  if ((unsigned int )source_type == 2U) {
#line 1143
    goto case_2;
  }
#line 1134
  goto switch_break___0;
  case_0: 
  {
#line 1136
  za = read_from_file(archive, flags, & error, offset, len);
  }
#line 1137
  goto switch_break___0;
  case_1: 
  {
#line 1140
  za = read_to_memory(archive, flags, & error, & memory_src);
  }
#line 1141
  goto switch_break___0;
  case_2: 
  {
#line 1144
  za = read_hole(archive, flags, & error);
  }
#line 1145
  goto switch_break___0;
  switch_break___0: ;
#line 1147
  if ((unsigned long )za == (unsigned long )((void *)0)) {
    {
#line 1148
    __cil_tmp23 = zip_error_strerror(& error);
#line 1148
    fprintf(stderr, "can\'t open zip archive \'%s\': %s\n\230\001", archive, __cil_tmp23);
#line 1149
    zip_error_fini(& error);
    }
#line 1150
    return (1);
  }
  {
#line 1152
  zip_error_fini(& error);
#line 1154
  err = 0;
  }
  {
#line 1155
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1155
    if (! (arg < argc)) {
#line 1155
      goto while_break___0;
    }
    {
#line 1157
    ret = dispatch(argc - arg, argv + arg);
    }
#line 1158
    if (ret > 0) {
#line 1159
      arg += ret;
    } else {
#line 1161
      err = 1;
#line 1162
      goto while_break___0;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1166
  __cil_tmp26 = zip_close(za);
  }
#line 1166
  if (__cil_tmp26 == -1) {
    {
#line 1167
    __cil_tmp27 = zip_strerror(za);
#line 1167
    fprintf(stderr, "can\'t close zip archive \'%s\': %s\n", archive, __cil_tmp27);
    }
#line 1168
    return (1);
  }
#line 1170
  if ((unsigned int )source_type == 1U) {
    {
#line 1171
    __cil_tmp28 = write_memory_src_to_file(archive, memory_src);
    }
#line 1171
    if (__cil_tmp28 < 0) {
#line 1172
      err = 1;
    }
    {
#line 1174
    zip_source_free(memory_src);
    }
  }
#line 1177
  i = 0U;
  {
#line 1177
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1177
    if (! (i < z_in_count)) {
#line 1177
      goto while_break___1;
    }
    {
#line 1178
    __cil_tmp29 = zip_close(z_in[i]);
    }
#line 1178
    if (__cil_tmp29 < 0) {
#line 1179
      err = 1;
    }
#line 1177
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 1183
  return (err);
}
}
#line 69 "/root/patchweave_new/24/src/source_hole.c"
static void buffer_free___0(buffer_t___0 *buffer ) ;
#line 70
static buffer_t___0 *buffer_from_file(char const   *fname , int flags , zip_error_t *error ) ;
#line 71
static buffer_t___0 *buffer_new___0(void) ;
#line 72
static zip_int64_t buffer_read___0(buffer_t___0 *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                   zip_error_t *error ) ;
#line 73
static int buffer_read_file(buffer_t___0 *buffer , FILE *f , zip_error_t *error ) ;
#line 74
static zip_int64_t buffer_seek___0(buffer_t___0 *buffer , void *data , zip_uint64_t length ,
                                   zip_error_t *error ) ;
#line 75
static int buffer_to_file(buffer_t___0 *buffer , char const   *fname , zip_error_t *error ) ;
#line 76
static zip_int64_t buffer_write___0(buffer_t___0 *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                    zip_error_t *error ) ;
#line 77
static zip_uint64_t get_u64(zip_uint8_t *b ) ;
#line 78
static int only_nul(zip_uint8_t *data , zip_uint64_t length ) ;
#line 79
static int write_nuls(zip_uint64_t n , FILE *f ) ;
#line 80
static int write_u64(zip_uint64_t u64 , FILE *f ) ;
#line 90
static hole_t *hole_new(char const   *fname , int flags , zip_error_t *error ) ;
#line 91
static zip_int64_t source_hole_cb(void *ud , void *data , zip_uint64_t length , zip_source_cmd_t command ) ;
#line 94 "/root/patchweave_new/24/src/source_hole.c"
zip_source_t *source_hole_create(char const   *fname , int flags , zip_error_t *error ) 
{ 
  hole_t *ud ;
  hole_t *__cil_tmp5 ;
  zip_source_t *__cil_tmp6 ;

  {
  {
#line 96
  __cil_tmp5 = hole_new(fname, flags, error);
#line 96
  ud = __cil_tmp5;
  }
#line 98
  if ((unsigned long )ud == (unsigned long )((void *)0)) {
#line 99
    return ((zip_source_t *)((void *)0));
  }
  {
#line 101
  __cil_tmp6 = zip_source_function_create(& source_hole_cb, (void *)ud, error);
  }
#line 101
  return (__cil_tmp6);
}
}
#line 106 "/root/patchweave_new/24/src/source_hole.c"
static void buffer_free___0(buffer_t___0 *buffer ) 
{ 
  zip_uint64_t i ;

  {
#line 110
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 111
    return;
  }
#line 114
  if (buffer->fragment) {
#line 115
    i = (zip_uint64_t )0;
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;

#line 115
      if (! (i < buffer->nfragments)) {
#line 115
        goto while_break;
      }
      {
#line 116
      free((void *)*(buffer->fragment + i));
#line 115
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 118
    free((void *)buffer->fragment);
    }
  }
  {
#line 120
  free((void *)buffer);
  }
#line 122
  return;
}
}
#line 125 "/root/patchweave_new/24/src/source_hole.c"
static buffer_t___0 *buffer_from_file(char const   *fname , int flags , zip_error_t *error ) 
{ 
  buffer_t___0 *buffer ;
  FILE *f ;
  int *__cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 130
  buffer = buffer_new___0();
  }
#line 130
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 131
    zip_error_set(error, 14, 0);
    }
#line 132
    return ((buffer_t___0 *)((void *)0));
  }
#line 136
  if ((flags & 8) == 0) {
    {
#line 137
    f = fopen(fname, "rb");
    }
#line 137
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 138
      __cil_tmp8 = __errno_location();
      }
#line 138
      if (*__cil_tmp8 == 2) {
#line 138
        if (! (flags & 1)) {
          {
#line 139
          buffer_free___0(buffer);
          }
#line 140
          return ((buffer_t___0 *)((void *)0));
        }
      } else {
        {
#line 139
        buffer_free___0(buffer);
        }
#line 140
        return ((buffer_t___0 *)((void *)0));
      }
    } else {
      {
#line 144
      __cil_tmp9 = buffer_read_file(buffer, f, error);
      }
#line 144
      if (__cil_tmp9 < 0) {
        {
#line 145
        buffer_free___0(buffer);
#line 146
        fclose(f);
        }
#line 147
        return ((buffer_t___0 *)((void *)0));
      }
      {
#line 149
      fclose(f);
      }
    }
  }
#line 153
  return (buffer);
}
}
#line 158 "/root/patchweave_new/24/src/source_hole.c"
static buffer_t___0 *buffer_new___0(void) 
{ 
  buffer_t___0 *buffer ;
  void *__cil_tmp2 ;

  {
  {
#line 162
  __cil_tmp2 = malloc(sizeof(*buffer));
#line 162
  buffer = (buffer_t___0 *)__cil_tmp2;
  }
#line 162
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 163
    return ((buffer_t___0 *)((void *)0));
  }
#line 166
  buffer->fragment = (zip_uint8_t **)((void *)0);
#line 167
  buffer->nfragments = (zip_uint64_t )0;
#line 168
  buffer->fragment_size = (zip_uint64_t )8192;
#line 169
  buffer->size = (zip_uint64_t )0;
#line 170
  buffer->offset = (zip_uint64_t )0;
#line 172
  return (buffer);
}
}
#line 177 "/root/patchweave_new/24/src/source_hole.c"
static zip_int64_t buffer_read___0(buffer_t___0 *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                   zip_error_t *error ) 
{ 
  zip_uint64_t n ;
  zip_uint64_t i ;
  zip_uint64_t fragment_offset ;
  zip_uint64_t tmp ;
  zip_uint64_t left ;
  zip_uint64_t tmp___0 ;

  {
#line 181
  if (length < buffer->size - buffer->offset) {
#line 181
    tmp = length;
  } else {
#line 181
    tmp = buffer->size - buffer->offset;
  }
#line 181
  length = tmp;
#line 183
  if (length == 0UL) {
#line 184
    return ((zip_int64_t )0);
  }
#line 186
  if (length > 0xffffffffffffffffUL) {
#line 187
    return ((zip_int64_t )-1);
  }
#line 190
  i = buffer->offset / buffer->fragment_size;
#line 191
  fragment_offset = buffer->offset % buffer->fragment_size;
#line 192
  n = (zip_uint64_t )0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;

#line 193
    if (! (n < length)) {
#line 193
      goto while_break;
    }
#line 194
    if (length - n < buffer->fragment_size - fragment_offset) {
#line 194
      tmp___0 = length - n;
    } else {
#line 194
      tmp___0 = buffer->fragment_size - fragment_offset;
    }
#line 194
    left = tmp___0;
#line 196
    if (*(buffer->fragment + i)) {
      {
#line 197
      memcpy((void *)(data + n), (void const   *)(*(buffer->fragment + i) + fragment_offset),
             left);
      }
    } else {
      {
#line 200
      memset((void *)(data + n), 0, left);
      }
    }
#line 203
    n += left;
#line 204
    i ++;
#line 205
    fragment_offset = (zip_uint64_t )0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 208
  buffer->offset += n;
#line 209
  return ((zip_int64_t )n);
}
}
#line 214 "/root/patchweave_new/24/src/source_hole.c"
static int buffer_read_file(buffer_t___0 *buffer , FILE *f , zip_error_t *error ) 
{ 
  zip_uint8_t b[20] ;
  zip_uint64_t i ;
  unsigned long __cil_tmp6 ;
  int *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp13 ;
  int *__cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int *__cil_tmp18 ;
  int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int *__cil_tmp22 ;
  zip_uint64_t __cil_tmp23 ;

  {
  {
#line 219
  __cil_tmp6 = fread((void *)(b), 20UL, 1UL, f);
  }
#line 219
  if (__cil_tmp6 != 1UL) {
    {
#line 220
    __cil_tmp7 = __errno_location();
#line 220
    zip_error_set(error, 5, *__cil_tmp7);
    }
#line 221
    return (-1);
  }
  {
#line 224
  __cil_tmp8 = memcmp((void const   *)(b), (void const   *)"NiH0", 4UL);
  }
#line 224
  if (__cil_tmp8 != 0) {
    {
#line 225
    zip_error_set(error, 5, 22);
    }
#line 226
    return (-1);
  }
  {
#line 229
  buffer->fragment_size = get_u64(b + 4);
#line 230
  buffer->size = get_u64(b + 12);
  }
#line 232
  if (buffer->size + buffer->fragment_size < buffer->size) {
    {
#line 233
    zip_error_set(error, 14, 0);
    }
#line 234
    return (-1);
  }
  {
#line 236
  buffer->nfragments = ((buffer->size + buffer->fragment_size) - 1UL) / buffer->fragment_size;
#line 237
  __cil_tmp11 = malloc(sizeof(*(buffer->fragment + 0)) * buffer->nfragments);
#line 237
  buffer->fragment = (zip_uint8_t **)__cil_tmp11;
  }
#line 237
  if ((unsigned long )buffer->fragment == (unsigned long )((void *)0)) {
    {
#line 239
    zip_error_set(error, 14, 0);
    }
#line 240
    return (-1);
  } else
#line 237
  if (buffer->nfragments > 0xffffffffffffffffUL / sizeof(*(buffer->fragment + 0))) {
    {
#line 239
    zip_error_set(error, 14, 0);
    }
#line 240
    return (-1);
  }
#line 243
  i = (zip_uint64_t )0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;

#line 243
    if (! (i < buffer->nfragments)) {
#line 243
      goto while_break;
    }
#line 244
    *(buffer->fragment + i) = (zip_uint8_t *)((void *)0);
#line 243
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 247
  i = (zip_uint64_t )0;
  {
#line 248
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 248
    if (! (i < buffer->nfragments)) {
#line 248
      goto while_break___0;
    }
    {
#line 249
    __cil_tmp13 = fread((void *)(b), 4UL, 1UL, f);
    }
#line 249
    if (__cil_tmp13 != 1UL) {
      {
#line 250
      __cil_tmp14 = __errno_location();
#line 250
      zip_error_set(error, 5, *__cil_tmp14);
      }
#line 251
      return (-1);
    }
    {
#line 254
    __cil_tmp15 = memcmp((void const   *)(b), (void const   *)"NiH1\342U", 4UL);
    }
#line 254
    if (__cil_tmp15 == 0) {
#line 255
      if (buffer->fragment_size > 0xffffffffffffffffUL) {
        {
#line 256
        zip_error_set(error, 14, 0);
        }
#line 257
        return (-1);
      }
      {
#line 259
      __cil_tmp16 = malloc(buffer->fragment_size);
#line 259
      *(buffer->fragment + i) = (zip_uint8_t *)__cil_tmp16;
      }
#line 259
      if ((unsigned long )*(buffer->fragment + i) == (unsigned long )((void *)0)) {
        {
#line 260
        zip_error_set(error, 14, 0);
        }
#line 261
        return (-1);
      }
      {
#line 263
      __cil_tmp17 = fread((void *)*(buffer->fragment + i), buffer->fragment_size,
                          1UL, f);
      }
#line 263
      if (__cil_tmp17 != 1UL) {
        {
#line 264
        __cil_tmp18 = __errno_location();
#line 264
        zip_error_set(error, 5, *__cil_tmp18);
        }
#line 265
        return (-1);
      }
#line 267
      i ++;
    } else {
      {
#line 269
      __cil_tmp20 = memcmp((void const   *)(b), (void const   *)"NiH2\342U", 4UL);
      }
#line 269
      if (__cil_tmp20 == 0) {
        {
#line 270
        __cil_tmp21 = fread((void *)(b), 8UL, 1UL, f);
        }
#line 270
        if (__cil_tmp21 != 1UL) {
          {
#line 271
          __cil_tmp22 = __errno_location();
#line 271
          zip_error_set(error, 5, *__cil_tmp22);
          }
#line 272
          return (-1);
        }
        {
#line 274
        __cil_tmp23 = get_u64(b);
#line 274
        i += __cil_tmp23;
        }
      } else {
        {
#line 277
        zip_error_set(error, 5, 22);
        }
#line 278
        return (-1);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 282
  return (0);
}
}
#line 286 "/root/patchweave_new/24/src/source_hole.c"
static zip_int64_t buffer_seek___0(buffer_t___0 *buffer , void *data , zip_uint64_t length ,
                                   zip_error_t *error ) 
{ 
  zip_int64_t new_offset ;
  zip_int64_t __cil_tmp6 ;

  {
  {
#line 288
  __cil_tmp6 = zip_source_seek_compute_offset(buffer->offset, buffer->size, data,
                                              length, error);
#line 288
  new_offset = __cil_tmp6;
  }
#line 290
  if (new_offset < 0L) {
#line 291
    return ((zip_int64_t )-1);
  }
#line 294
  buffer->offset = (zip_uint64_t )new_offset;
#line 295
  return ((zip_int64_t )0);
}
}
#line 300 "/root/patchweave_new/24/src/source_hole.c"
static int buffer_to_file(buffer_t___0 *buffer , char const   *fname , zip_error_t *error ) 
{ 
  FILE *f ;
  FILE *__cil_tmp5 ;
  zip_uint64_t i ;
  zip_uint64_t nul_run ;
  int *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp12 ;
  int *__cil_tmp13 ;

  {
  {
#line 302
  __cil_tmp5 = fopen(fname, "wb");
#line 302
  f = __cil_tmp5;
  }
#line 306
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 307
    __cil_tmp8 = __errno_location();
#line 307
    zip_error_set(error, 11, *__cil_tmp8);
    }
#line 308
    return (-1);
  }
  {
#line 311
  fwrite((void const   *)"NiH0", 4UL, 1UL, f);
#line 312
  write_u64(buffer->fragment_size, f);
#line 313
  write_u64(buffer->size, f);
#line 315
  nul_run = (zip_uint64_t )0;
#line 316
  i = (zip_uint64_t )0;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;

#line 316
    if (! (i * buffer->fragment_size < buffer->size)) {
#line 316
      goto while_break;
    }
    {
#line 317
    __cil_tmp9 = only_nul(*(buffer->fragment + i), buffer->fragment_size);
    }
#line 317
    if ((unsigned long )*(buffer->fragment + i) == (unsigned long )((void *)0)) {
#line 318
      nul_run ++;
    } else
#line 317
    if (__cil_tmp9) {
#line 318
      nul_run ++;
    } else {
#line 321
      if (nul_run > 0UL) {
        {
#line 322
        write_nuls(nul_run, f);
#line 323
        nul_run = (zip_uint64_t )0;
        }
      }
      {
#line 325
      fwrite((void const   *)"NiH1", 4UL, 1UL, f);
#line 327
      fwrite((void const   *)*(buffer->fragment + i), 1UL, buffer->fragment_size,
             f);
      }
    }
#line 316
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 331
  if (nul_run > 0UL) {
    {
#line 332
    write_nuls(nul_run, f);
    }
  }
  {
#line 335
  __cil_tmp12 = fclose(f);
  }
#line 335
  if (__cil_tmp12 != 0) {
    {
#line 336
    __cil_tmp13 = __errno_location();
#line 336
    zip_error_set(error, 6, *__cil_tmp13);
    }
#line 337
    return (-1);
  }
#line 340
  return (0);
}
}
#line 345 "/root/patchweave_new/24/src/source_hole.c"
static zip_int64_t buffer_write___0(buffer_t___0 *buffer , zip_uint8_t *data , zip_uint64_t length ,
                                    zip_error_t *error ) 
{ 
  zip_uint8_t **fragment ;
  zip_uint64_t needed_fragments ;
  zip_uint64_t new_capacity ;
  zip_uint64_t i ;
  int __cil_tmp11 ;
  zip_uint64_t idx ;
  zip_uint64_t n ;
  zip_uint64_t fragment_offset ;
  zip_uint64_t left ;
  zip_uint64_t tmp ;
  void *__cil_tmp17 ;
  void *tmp___0 ;

  {
#line 348
  if (buffer->offset + length > buffer->nfragments * buffer->fragment_size) {
#line 349
    needed_fragments = (((buffer->offset + length) + buffer->fragment_size) - 1UL) / buffer->fragment_size;
#line 350
    new_capacity = buffer->nfragments;
#line 353
    if (new_capacity == 0UL) {
#line 354
      new_capacity = (zip_uint64_t )4;
    }
    {
#line 356
    while (1) {
      while_continue: /* CIL Label */ ;

#line 356
      if (! (new_capacity < needed_fragments)) {
#line 356
        goto while_break;
      }
#line 357
      new_capacity *= 2UL;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
    {
#line 360
    tmp___0 = realloc((void *)buffer->fragment, new_capacity * sizeof(*fragment));
#line 360
    fragment = (zip_uint8_t **)tmp___0;
    }
#line 362
    if ((unsigned long )fragment == (unsigned long )((void *)0)) {
      {
#line 363
      zip_error_set(error, 14, 0);
      }
#line 364
      return ((zip_int64_t )-1);
    }
#line 367
    i = buffer->nfragments;
    {
#line 367
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 367
      if (! (i < new_capacity)) {
#line 367
        goto while_break___0;
      }
#line 368
      *(fragment + i) = (zip_uint8_t *)((void *)0);
#line 367
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 371
    buffer->fragment = fragment;
#line 372
    buffer->nfragments = new_capacity;
  }
  {
#line 375
  __cil_tmp11 = only_nul(data, length);
  }
#line 375
  if (! __cil_tmp11) {
#line 378
    idx = buffer->offset / buffer->fragment_size;
#line 379
    fragment_offset = buffer->offset % buffer->fragment_size;
#line 380
    n = (zip_uint64_t )0;
    {
#line 382
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 382
      if (! (n < length)) {
#line 382
        goto while_break___1;
      }
#line 383
      if (length - n < buffer->fragment_size - fragment_offset) {
#line 383
        tmp = length - n;
      } else {
#line 383
        tmp = buffer->fragment_size - fragment_offset;
      }
#line 383
      left = tmp;
#line 385
      if ((unsigned long )*(buffer->fragment + idx) == (unsigned long )((void *)0)) {
        {
#line 386
        __cil_tmp17 = malloc(buffer->fragment_size);
#line 386
        *(buffer->fragment + idx) = (zip_uint8_t *)__cil_tmp17;
        }
#line 386
        if ((unsigned long )*(buffer->fragment + idx) == (unsigned long )((void *)0)) {
          {
#line 387
          zip_error_set(error, 14, 0);
          }
#line 388
          return ((zip_int64_t )-1);
        }
        {
#line 390
        memset((void *)*(buffer->fragment + idx), 0, buffer->fragment_size);
        }
      }
      {
#line 392
      memcpy((void *)(*(buffer->fragment + idx) + fragment_offset), (void const   *)(data + n),
             left);
#line 394
      n += left;
#line 395
      idx ++;
#line 396
      fragment_offset = (zip_uint64_t )0;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 400
  buffer->offset += length;
#line 401
  if (buffer->offset > buffer->size) {
#line 402
    buffer->size = buffer->offset;
  }
#line 405
  return ((zip_int64_t )length);
}
}
#line 410 "/root/patchweave_new/24/src/source_hole.c"
static zip_uint64_t get_u64(zip_uint8_t *b ) 
{ 
  zip_uint64_t i ;

  {
#line 414
  i = ((((((((zip_uint64_t )*(b + 0) << 56) | ((zip_uint64_t )*(b + 1) << 48)) | ((zip_uint64_t )*(b + 2) << 40)) | ((zip_uint64_t )*(b + 3) << 32)) | ((zip_uint64_t )*(b + 4) << 24)) | ((zip_uint64_t )*(b + 5) << 16)) | ((zip_uint64_t )*(b + 6) << 8)) | (zip_uint64_t )*(b + 7);
#line 416
  return (i);
}
}
#line 421 "/root/patchweave_new/24/src/source_hole.c"
static int only_nul(zip_uint8_t *data , zip_uint64_t length ) 
{ 
  zip_uint64_t i ;

  {
#line 425
  i = (zip_uint64_t )0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;

#line 425
    if (! (i < length)) {
#line 425
      goto while_break;
    }
#line 426
    if ((int )*(data + i) != 0) {
#line 427
      return (0);
    }
#line 425
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 431
  return (1);
}
}
#line 436 "/root/patchweave_new/24/src/source_hole.c"
static int write_nuls(zip_uint64_t n , FILE *f ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 438
  __cil_tmp3 = fwrite((void const   *)"NiH2\342U", 4UL, 1UL, f);
  }
#line 438
  if (__cil_tmp3 != 1UL) {
#line 439
    return (-1);
  }
  {
#line 441
  __cil_tmp4 = write_u64(n, f);
  }
#line 441
  return (__cil_tmp4);
}
}
#line 446 "/root/patchweave_new/24/src/source_hole.c"
static int write_u64(zip_uint64_t u64 , FILE *f ) 
{ 
  zip_uint8_t b[8] ;
  unsigned long __cil_tmp4 ;
  int tmp ;

  {
  {
#line 450
  b[0] = (zip_uint8_t )((u64 >> 56) & 255UL);
#line 451
  b[1] = (zip_uint8_t )((u64 >> 48) & 255UL);
#line 452
  b[2] = (zip_uint8_t )((u64 >> 40) & 255UL);
#line 453
  b[3] = (zip_uint8_t )((u64 >> 32) & 255UL);
#line 454
  b[4] = (zip_uint8_t )((u64 >> 24) & 255UL);
#line 455
  b[5] = (zip_uint8_t )((u64 >> 16) & 255UL);
#line 456
  b[6] = (zip_uint8_t )((u64 >> 8) & 255UL);
#line 457
  b[7] = (zip_uint8_t )(u64 & 255UL);
#line 459
  __cil_tmp4 = fwrite((void const   *)(b), 8UL, 1UL, f);
  }
#line 459
  if (__cil_tmp4 == 1UL) {
#line 459
    tmp = 0;
  } else {
#line 459
    tmp = -1;
  }
#line 459
  return (tmp);
}
}
#line 464 "/root/patchweave_new/24/src/source_hole.c"
static void hole_free(hole_t *hole ) 
{ 


  {
#line 465
  if ((unsigned long )hole == (unsigned long )((void *)0)) {
#line 466
    return;
  }
  {
#line 468
  zip_error_fini(& hole->error);
#line 469
  buffer_free___0(hole->in);
#line 470
  buffer_free___0(hole->out);
#line 471
  free((void *)hole->fname);
#line 472
  free((void *)hole);
  }
#line 474
  return;
}
}
#line 477 "/root/patchweave_new/24/src/source_hole.c"
static hole_t *hole_new(char const   *fname , int flags , zip_error_t *error ) 
{ 
  hole_t *ctx ;
  void *__cil_tmp5 ;

  {
  {
#line 479
  __cil_tmp5 = malloc(sizeof(*ctx));
#line 479
  ctx = (hole_t *)__cil_tmp5;
  }
#line 481
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 482
    zip_error_set(error, 14, 0);
    }
#line 483
    return ((hole_t *)((void *)0));
  }
  {
#line 486
  ctx->fname = strdup(fname);
  }
#line 486
  if ((unsigned long )ctx->fname == (unsigned long )((void *)0)) {
    {
#line 487
    free((void *)ctx);
#line 488
    zip_error_set(error, 14, 0);
    }
#line 489
    return ((hole_t *)((void *)0));
  }
  {
#line 492
  ctx->in = buffer_from_file(fname, flags, error);
  }
#line 492
  if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
    {
#line 493
    free((void *)ctx);
    }
#line 494
    return ((hole_t *)((void *)0));
  }
  {
#line 497
  zip_error_init(& ctx->error);
#line 498
  ctx->out = (buffer_t___0 *)((void *)0);
  }
#line 500
  return (ctx);
}
}
#line 505 "/root/patchweave_new/24/src/source_hole.c"
static zip_int64_t source_hole_cb(void *ud , void *data , zip_uint64_t length , zip_source_cmd_t command ) 
{ 
  hole_t *ctx ;
  int __cil_tmp7 ;
  zip_int64_t __cil_tmp8 ;
  zip_int64_t __cil_tmp9 ;
  zip_int64_t __cil_tmp11 ;
  zip_int64_t __cil_tmp12 ;
  zip_stat_t *st ;
  zip_stat_t *tmp ;
  zip_int64_t __cil_tmp15 ;
  zip_int64_t __cil_tmp16 ;

  {
#line 507
  ctx = (hole_t *)ud;
#line 510
  if ((unsigned int )command == 8U) {
#line 510
    goto case_8;
  }
#line 514
  if ((unsigned int )command == 2U) {
#line 514
    goto case_2;
  }
#line 517
  if ((unsigned int )command == 9U) {
#line 517
    goto case_9;
  }
#line 526
  if ((unsigned int )command == 4U) {
#line 526
    goto case_4;
  }
#line 529
  if ((unsigned int )command == 5U) {
#line 529
    goto case_5;
  }
#line 533
  if ((unsigned int )command == 0U) {
#line 533
    goto case_0;
  }
#line 537
  if ((unsigned int )command == 1U) {
#line 537
    goto case_1;
  }
#line 540
  if ((unsigned int )command == 15U) {
#line 540
    goto case_15;
  }
#line 548
  if ((unsigned int )command == 10U) {
#line 548
    goto case_10;
  }
#line 553
  if ((unsigned int )command == 6U) {
#line 553
    goto case_6;
  }
#line 556
  if ((unsigned int )command == 12U) {
#line 556
    goto case_12;
  }
#line 559
  if ((unsigned int )command == 3U) {
#line 559
    goto case_3;
  }
#line 573
  if ((unsigned int )command == 7U) {
#line 573
    goto case_7;
  }
#line 576
  if ((unsigned int )command == 13U) {
#line 576
    goto case_13;
  }
#line 579
  if ((unsigned int )command == 11U) {
#line 579
    goto case_11;
  }
#line 582
  if ((unsigned int )command == 14U) {
#line 582
    goto case_14;
  }
#line 585
  goto switch_default;
  case_8: 
  {
#line 511
  ctx->out = buffer_new___0();
  }
#line 512
  return ((zip_int64_t )0);
  case_2: 
#line 515
  return ((zip_int64_t )0);
  case_9: 
  {
#line 518
  __cil_tmp7 = buffer_to_file(ctx->out, (char const   *)ctx->fname, & ctx->error);
  }
#line 518
  if (__cil_tmp7 < 0) {
#line 519
    return ((zip_int64_t )-1);
  }
  {
#line 521
  buffer_free___0(ctx->in);
#line 522
  ctx->in = ctx->out;
#line 523
  ctx->out = (buffer_t___0 *)((void *)0);
  }
#line 524
  return ((zip_int64_t )0);
  case_4: 
  {
#line 527
  __cil_tmp8 = zip_error_to_data(& ctx->error, data, length);
  }
#line 527
  return (__cil_tmp8);
  case_5: 
  {
#line 530
  hole_free(ctx);
  }
#line 531
  return ((zip_int64_t )0);
  case_0: 
#line 534
  (ctx->in)->offset = (zip_uint64_t )0;
#line 535
  return ((zip_int64_t )0);
  case_1: 
  {
#line 538
  __cil_tmp9 = buffer_read___0(ctx->in, (zip_uint8_t *)data, length, & ctx->error);
  }
#line 538
  return (__cil_tmp9);
  case_15: 
  {
#line 541
  buffer_free___0(ctx->in);
#line 542
  ctx->in = buffer_new___0();
#line 543
  buffer_free___0(ctx->out);
#line 544
  ctx->out = (buffer_t___0 *)((void *)0);
#line 545
  remove((char const   *)ctx->fname);
  }
#line 546
  return ((zip_int64_t )0);
  case_10: 
  {
#line 549
  buffer_free___0(ctx->out);
#line 550
  ctx->out = (buffer_t___0 *)((void *)0);
  }
#line 551
  return ((zip_int64_t )0);
  case_6: 
  {
#line 554
  __cil_tmp11 = buffer_seek___0(ctx->in, data, length, & ctx->error);
  }
#line 554
  return (__cil_tmp11);
  case_12: 
  {
#line 557
  __cil_tmp12 = buffer_seek___0(ctx->out, data, length, & ctx->error);
  }
#line 557
  return (__cil_tmp12);
  case_3: 
#line 560
  if (length < sizeof(zip_stat_t )) {
    {
#line 560
    zip_error_set(& ctx->error, 18, 0);
#line 560
    tmp = (zip_stat_t *)((void *)0);
    }
  } else {
#line 560
    tmp = (zip_stat_t *)data;
  }
#line 560
  st = tmp;
#line 562
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 563
    return ((zip_int64_t )-1);
  }
#line 568
  st->valid |= 4UL;
#line 569
  st->size = (ctx->in)->size;
#line 570
  return ((zip_int64_t )0);
  case_7: 
#line 574
  return ((zip_int64_t )(ctx->in)->offset);
  case_13: 
#line 577
  return ((zip_int64_t )(ctx->out)->offset);
  case_11: 
  {
#line 580
  __cil_tmp15 = buffer_write___0(ctx->out, (zip_uint8_t *)data, length, & ctx->error);
  }
#line 580
  return (__cil_tmp15);
  case_14: 
  {
#line 583
  __cil_tmp16 = zip_source_make_command_bitmap((zip_source_cmd_t )8, 9, 2, 4, 5, 0,
                                               1, 15, 10, 6, 12, 3, 7, 13, 11, -1);
  }
#line 583
  return (__cil_tmp16);
  switch_default: 
  {
#line 586
  zip_error_set(& ctx->error, 28, 0);
  }
#line 587
  return ((zip_int64_t )-1);

#line 591
  return (0L);
}
}
