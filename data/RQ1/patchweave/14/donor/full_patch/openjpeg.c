/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__1 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef int wchar_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__2 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__2 idtype_t;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_3 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_3 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_4 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_4 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_5 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_5 lldiv_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 108 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_6 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_6 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_7 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_7 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_9 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_8 {
   unsigned long long __wseq ;
   struct __anonstruct_9 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_11 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_10 {
   unsigned long long __g1_start ;
   struct __anonstruct_11 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_8  ;
   unsigned long long __wseq ;
   struct __anonstruct_9 __wseq32 ;
   union __anonunion_10  ;
   unsigned long long __g1_start ;
   struct __anonstruct_11 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_15 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_15 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_18 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_18 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_19 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_19 pthread_barrierattr_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_21 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_20 {
   int __count ;
   union __anonunion_21 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_20 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 63 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef int opj_bool;
#line 99
enum RSIZ_CAPABILITIES {
    STD_RSIZ = 0,
    CINEMA2K = 3,
    CINEMA4K = 4
} ;
#line 103 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 108
enum CINEMA_MODE {
    OFF = 0,
    CINEMA2K_24 = 1,
    CINEMA2K_48 = 2,
    CINEMA4K_24 = 3
} ;
#line 113 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 118
enum PROG_ORDER {
    PROG_UNKNOWN = -1,
    LRCP = 0,
    RLCP = 1,
    RPCL = 2,
    PCRL = 3,
    CPRL = 4
} ;
#line 125 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 130
enum COLOR_SPACE {
    CLRSPC_UNKNOWN = -1,
    CLRSPC_UNSPECIFIED = 0,
    CLRSPC_SRGB = 1,
    CLRSPC_GRAY = 2,
    CLRSPC_SYCC = 3
} ;
#line 136 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 145
enum CODEC_FORMAT {
    CODEC_UNKNOWN = -1,
    CODEC_J2K = 0,
    CODEC_JPT = 1,
    CODEC_JP2 = 2
} ;
#line 150 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 155
enum LIMIT_DECODING {
    NO_LIMITATION = 0,
    LIMIT_TO_MAIN_HEADER = 1,
    DECODE_ALL_BUT_PACKETS = 2
} ;
#line 159 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef enum LIMIT_DECODING OPJ_LIMIT_DECODING;
#line 172 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef void (*opj_msg_callback)(char const   * , void * );
#line 183 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_event_mgr {
   opj_msg_callback error_handler ;
   opj_msg_callback warning_handler ;
   opj_msg_callback info_handler ;
};
#line 190 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 202 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_poc {
   int resno0 ;
   int compno0 ;
   int layno1 ;
   int resno1 ;
   int compno1 ;
   int layno0 ;
   int precno0 ;
   int precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   char progorder[5] ;
   int tile ;
   int tx0 ;
   int tx1 ;
   int ty0 ;
   int ty1 ;
   int layS ;
   int resS ;
   int compS ;
   int prcS ;
   int layE ;
   int resE ;
   int compE ;
   int prcE ;
   int txS ;
   int txE ;
   int tyS ;
   int tyE ;
   int dx ;
   int dy ;
   int lay_t ;
   int res_t ;
   int comp_t ;
   int prc_t ;
   int tx0_t ;
   int ty0_t ;
};
#line 225 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 230 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_cparameters {
   opj_bool tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   int numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   opj_bool jpip_on ;
};
#line 356 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 363 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_dparameters {
   int cp_reduce ;
   int cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   OPJ_LIMIT_DECODING cp_limit_decoding ;
   unsigned int flags ;
};
#line 413 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 430 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_common_struct {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 436 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_common_struct opj_common_struct_t;
#line 438 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef opj_common_struct_t *opj_common_ptr;
#line 443 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_cinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 447 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_cinfo opj_cinfo_t;
#line 452 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_dinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 456 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_dinfo opj_dinfo_t;
#line 475 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_cio {
   opj_common_ptr cinfo ;
   int openmode ;
   unsigned char *buffer ;
   int length ;
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
};
#line 492 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_cio opj_cio_t;
#line 503 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_image_comp {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
   int resno_decoded ;
   int factor ;
   int *data ;
};
#line 528 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 533 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_image {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
};
#line 552 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 557 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_image_comptparm {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
};
#line 576 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 587 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_packet_info {
   int start_pos ;
   int end_ph_pos ;
   int end_pos ;
   double disto ;
};
#line 596 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 603 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_marker_info_t {
   unsigned short type ;
   int pos ;
   int len ;
};
#line 610 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_marker_info_t opj_marker_info_t;
#line 616 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 627 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 632 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 667 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 672 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 719 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 47 "/root/patchweave_new/14/libopenjpeg/bio.h"
struct opj_bio {
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
   unsigned int buf ;
   int ct ;
};
#line 58 "/root/patchweave_new/14/libopenjpeg/bio.h"
typedef struct opj_bio opj_bio_t;
#line 100 "/root/patchweave_new/14/libopenjpeg/j2k.h"
enum J2K_STATUS {
    J2K_STATE_MHSOC = 1,
    J2K_STATE_MHSIZ = 2,
    J2K_STATE_MH = 4,
    J2K_STATE_TPHSOT = 8,
    J2K_STATE_TPH = 16,
    J2K_STATE_MT = 32,
    J2K_STATE_NEOC = 64,
    J2K_STATE_ERR = 128
} ;
#line 109 "/root/patchweave_new/14/libopenjpeg/j2k.h"
typedef enum J2K_STATUS J2K_STATUS;
#line 116
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 119 "/root/patchweave_new/14/libopenjpeg/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 124 "/root/patchweave_new/14/libopenjpeg/j2k.h"
struct opj_stepsize {
   int expn ;
   int mant ;
};
#line 129 "/root/patchweave_new/14/libopenjpeg/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 134 "/root/patchweave_new/14/libopenjpeg/j2k.h"
struct opj_tccp {
   int csty ;
   int numresolutions ;
   int cblkw ;
   int cblkh ;
   int cblksty ;
   int qmfbid ;
   int qntsty ;
   opj_stepsize_t stepsizes[97] ;
   int numgbits ;
   int roishift ;
   int prcw[33] ;
   int prch[33] ;
};
#line 159 "/root/patchweave_new/14/libopenjpeg/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 166 "/root/patchweave_new/14/libopenjpeg/j2k.h"
struct opj_tcp {
   int first ;
   int csty ;
   OPJ_PROG_ORDER prg ;
   int numlayers ;
   int mct ;
   float rates[100] ;
   int numpocs ;
   int POC ;
   opj_poc_t pocs[32] ;
   unsigned char *ppt_data ;
   unsigned char *ppt_data_first ;
   int ppt ;
   int ppt_store ;
   int ppt_len ;
   float distoratio[100] ;
   opj_tccp_t *tccps ;
};
#line 199 "/root/patchweave_new/14/libopenjpeg/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 204 "/root/patchweave_new/14/libopenjpeg/j2k.h"
struct opj_cp {
   OPJ_CINEMA_MODE cinema ;
   int max_comp_size ;
   int img_size ;
   OPJ_RSIZ_CAPABILITIES rsiz ;
   char tp_on ;
   char tp_flag ;
   int tp_pos ;
   int disto_alloc ;
   int fixed_alloc ;
   int fixed_quality ;
   int reduce ;
   int layer ;
   OPJ_LIMIT_DECODING limit_decoding ;
   int tx0 ;
   int ty0 ;
   int tdx ;
   int tdy ;
   char *comment ;
   int tw ;
   int th ;
   int *tileno ;
   int tileno_size ;
   unsigned char *ppm_data ;
   unsigned char *ppm_data_first ;
   int ppm ;
   int ppm_store ;
   int ppm_previous ;
   int ppm_len ;
   opj_tcp_t *tcps ;
   int *matrice ;
};
#line 309 "/root/patchweave_new/14/libopenjpeg/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 314 "/root/patchweave_new/14/libopenjpeg/j2k.h"
struct opj_j2k {
   opj_common_ptr cinfo ;
   int state ;
   int curtileno ;
   int tp_num ;
   int cur_tp_num ;
   int *cur_totnum_tp ;
   int tlm_start ;
   int totnum_tp ;
   unsigned char *eot ;
   int sot_start ;
   int sod_start ;
   int pos_correction ;
   unsigned char **tile_data ;
   int *tile_len ;
   opj_tcp_t *default_tcp ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_codestream_info_t *cstr_info ;
   opj_cio_t *cio ;
};
#line 369 "/root/patchweave_new/14/libopenjpeg/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 60 "/root/patchweave_new/14/libopenjpeg/jp2.h"
struct opj_jp2_cdef_info {
   unsigned short cn ;
   unsigned short typ ;
   unsigned short asoc ;
};
#line 63 "/root/patchweave_new/14/libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 68 "/root/patchweave_new/14/libopenjpeg/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   unsigned short n ;
};
#line 72 "/root/patchweave_new/14/libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 77 "/root/patchweave_new/14/libopenjpeg/jp2.h"
struct opj_jp2_cmap_comp {
   unsigned short cmp ;
   unsigned char mtyp ;
   unsigned char pcol ;
};
#line 81 "/root/patchweave_new/14/libopenjpeg/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 86 "/root/patchweave_new/14/libopenjpeg/jp2.h"
struct opj_jp2_pclr {
   unsigned int *entries ;
   unsigned char *channel_sign ;
   unsigned char *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   unsigned short nr_entries ;
   unsigned short nr_channels ;
};
#line 93 "/root/patchweave_new/14/libopenjpeg/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 98 "/root/patchweave_new/14/libopenjpeg/jp2.h"
struct opj_jp2_color {
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   unsigned char jp2_has_colr ;
};
#line 106 "/root/patchweave_new/14/libopenjpeg/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 111 "/root/patchweave_new/14/libopenjpeg/jp2.h"
struct opj_jp2_comps {
   int depth ;
   int sgnd ;
   int bpcc ;
};
#line 115 "/root/patchweave_new/14/libopenjpeg/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 120 "/root/patchweave_new/14/libopenjpeg/jp2.h"
struct opj_jp2 {
   opj_common_ptr cinfo ;
   opj_j2k_t *j2k ;
   unsigned int w ;
   unsigned int h ;
   unsigned int numcomps ;
   unsigned int bpc ;
   unsigned int C ;
   unsigned int UnkC ;
   unsigned int IPR ;
   unsigned int meth ;
   unsigned int approx ;
   unsigned int enumcs ;
   unsigned int precedence ;
   unsigned int brand ;
   unsigned int minversion ;
   unsigned int numcl ;
   unsigned int *cl ;
   opj_jp2_comps_t *comps ;
   unsigned int j2k_codestream_offset ;
   unsigned int j2k_codestream_length ;
   opj_bool jpip_on ;
   opj_bool ignore_pclr_cmap_cdef ;
};
#line 145 "/root/patchweave_new/14/libopenjpeg/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 150 "/root/patchweave_new/14/libopenjpeg/jp2.h"
struct opj_jp2_box {
   int length ;
   int type ;
   int init_pos ;
};
#line 154 "/root/patchweave_new/14/libopenjpeg/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 42 "/root/patchweave_new/14/libopenjpeg/jpt.h"
struct opj_jpt_msg_header {
   unsigned int Id ;
   unsigned int last_byte ;
   unsigned int Class_Id ;
   unsigned int CSn_Id ;
   unsigned int Msg_offset ;
   unsigned int Msg_length ;
   unsigned int Layer_nb ;
};
#line 57 "/root/patchweave_new/14/libopenjpeg/jpt.h"
typedef struct opj_jpt_msg_header opj_jpt_msg_header_t;
#line 48 "/root/patchweave_new/14/libopenjpeg/mqc.h"
struct opj_mqc_state {
   unsigned int qeval ;
   int mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 57 "/root/patchweave_new/14/libopenjpeg/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 64 "/root/patchweave_new/14/libopenjpeg/mqc.h"
struct opj_mqc {
   unsigned int c ;
   unsigned int a ;
   unsigned int ct ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
};
#line 76 "/root/patchweave_new/14/libopenjpeg/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 46 "/root/patchweave_new/14/libopenjpeg/raw.h"
struct opj_raw {
   unsigned char c ;
   unsigned int ct ;
   unsigned int lenmax ;
   unsigned int len ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
};
#line 61 "/root/patchweave_new/14/libopenjpeg/raw.h"
typedef struct opj_raw opj_raw_t;
#line 48 "/root/patchweave_new/14/libopenjpeg/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   int value ;
   int low ;
   int known ;
};
#line 53 "/root/patchweave_new/14/libopenjpeg/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 58 "/root/patchweave_new/14/libopenjpeg/tgt.h"
struct opj_tgt_tree {
   int numleafsh ;
   int numleafsv ;
   int numnodes ;
   opj_tgt_node_t *nodes ;
};
#line 63 "/root/patchweave_new/14/libopenjpeg/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 49 "/root/patchweave_new/14/libopenjpeg/pi.h"
struct opj_pi_resolution {
   int pdx ;
   int pdy ;
   int pw ;
   int ph ;
};
#line 52 "/root/patchweave_new/14/libopenjpeg/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 57 "/root/patchweave_new/14/libopenjpeg/pi.h"
struct opj_pi_comp {
   int dx ;
   int dy ;
   int numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 62 "/root/patchweave_new/14/libopenjpeg/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 67 "/root/patchweave_new/14/libopenjpeg/pi.h"
struct opj_pi_iterator {
   char tp_on ;
   short *include ;
   int step_l ;
   int step_r ;
   int step_c ;
   int step_p ;
   int compno ;
   int resno ;
   int precno ;
   int layno ;
   int first ;
   opj_poc_t poc ;
   int numcomps ;
   opj_pi_comp_t *comps ;
   int tx0 ;
   int ty0 ;
   int tx1 ;
   int ty1 ;
   int x ;
   int y ;
   int dx ;
   int dy ;
};
#line 98 "/root/patchweave_new/14/libopenjpeg/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 47 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd_seg {
   unsigned char **data ;
   int dataindex ;
   int numpasses ;
   int len ;
   int maxpasses ;
   int numnewpasses ;
   int newlen ;
};
#line 55 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 60 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd_pass {
   int rate ;
   double distortiondec ;
   int term ;
   int len ;
};
#line 64 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 69 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd_layer {
   int numpasses ;
   int len ;
   double disto ;
   unsigned char *data ;
};
#line 74 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 79 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd_cblk_enc {
   unsigned char *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int numpasses ;
   int numpassesinlayers ;
   int totalpasses ;
};
#line 89 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 91 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd_cblk_dec {
   unsigned char *data ;
   opj_tcd_seg_t *segs ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int len ;
   int numnewpasses ;
   int numsegs ;
};
#line 100 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 108 "/root/patchweave_new/14/libopenjpeg/tcd.h"
union __anonunion_23 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
};
#line 105 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd_precinct {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int cw ;
   int ch ;
   union __anonunion_23 cblks ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 114 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 119 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd_band {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int bandno ;
   opj_tcd_precinct_t *precincts ;
   int numbps ;
   float stepsize ;
};
#line 125 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 130 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd_resolution {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int pw ;
   int ph ;
   int numbands ;
   opj_tcd_band_t bands[3] ;
};
#line 135 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 140 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd_tilecomp {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numresolutions ;
   opj_tcd_resolution_t *resolutions ;
   int *data ;
   int numpix ;
};
#line 146 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 151 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd_tile {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   opj_tcd_tilecomp_t *comps ;
   int numpix ;
   double distotile ;
   double distolayer[100] ;
   int packno ;
};
#line 160 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 165 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd_image {
   int tw ;
   int th ;
   opj_tcd_tile_t *tiles ;
};
#line 168 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 173 "/root/patchweave_new/14/libopenjpeg/tcd.h"
struct opj_tcd {
   int tp_pos ;
   int tp_num ;
   int cur_tp_num ;
   int cur_totnum_tp ;
   int cur_pino ;
   opj_common_ptr cinfo ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcd_tile_t *tcd_tile ;
   opj_tcp_t *tcp ;
   int tcd_tileno ;
   double encoding_time ;
};
#line 201 "/root/patchweave_new/14/libopenjpeg/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 88 "/root/patchweave_new/14/libopenjpeg/t1.h"
typedef short flag_t;
#line 93 "/root/patchweave_new/14/libopenjpeg/t1.h"
struct opj_t1 {
   opj_common_ptr cinfo ;
   opj_mqc_t *mqc ;
   opj_raw_t *raw ;
   int *data ;
   flag_t *flags ;
   int w ;
   int h ;
   int datasize ;
   int flagssize ;
   int flags_stride ;
};
#line 109 "/root/patchweave_new/14/libopenjpeg/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 45 "/root/patchweave_new/14/libopenjpeg/t2.h"
struct opj_t2 {
   opj_common_ptr cinfo ;
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 53 "/root/patchweave_new/14/libopenjpeg/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 853 "/usr/include/math.h"
enum __anonenum__45 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__46 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__68 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__69 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__70 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___0 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___1 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___0 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___2 {
    _ISupper___4 = 256,
    _ISlower___4 = 512,
    _ISalpha___4 = 1024,
    _ISdigit___4 = 2048,
    _ISxdigit___4 = 4096,
    _ISspace___4 = 8192,
    _ISprint___4 = 16384,
    _ISgraph___4 = 32768,
    _ISblank___4 = 1,
    _IScntrl___4 = 2,
    _ISpunct___4 = 4,
    _ISalnum___4 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__100 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__103 {
    _ISupper___5 = 256,
    _ISlower___5 = 512,
    _ISalpha___5 = 1024,
    _ISdigit___5 = 2048,
    _ISxdigit___5 = 4096,
    _ISspace___5 = 8192,
    _ISprint___5 = 16384,
    _ISgraph___5 = 32768,
    _ISblank___5 = 1,
    _IScntrl___5 = 2,
    _ISpunct___5 = 4,
    _ISalnum___5 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___1 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___3 {
    _ISupper___6 = 256,
    _ISlower___6 = 512,
    _ISalpha___6 = 1024,
    _ISdigit___6 = 2048,
    _ISxdigit___6 = 4096,
    _ISspace___6 = 8192,
    _ISprint___6 = 16384,
    _ISgraph___6 = 32768,
    _ISblank___6 = 1,
    _IScntrl___6 = 2,
    _ISpunct___6 = 4,
    _ISalnum___6 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___2 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___4 {
    _ISupper___7 = 256,
    _ISlower___7 = 512,
    _ISalpha___7 = 1024,
    _ISdigit___7 = 2048,
    _ISxdigit___7 = 4096,
    _ISspace___7 = 8192,
    _ISprint___7 = 16384,
    _ISgraph___7 = 32768,
    _ISblank___7 = 1,
    _IScntrl___7 = 2,
    _ISpunct___7 = 4,
    _ISalnum___7 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___3 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___5 {
    _ISupper___8 = 256,
    _ISlower___8 = 512,
    _ISalpha___8 = 1024,
    _ISdigit___8 = 2048,
    _ISxdigit___8 = 4096,
    _ISspace___8 = 8192,
    _ISprint___8 = 16384,
    _ISgraph___8 = 32768,
    _ISblank___8 = 1,
    _IScntrl___8 = 2,
    _ISpunct___8 = 4,
    _ISalnum___8 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___4 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___6 {
    _ISupper___9 = 256,
    _ISlower___9 = 512,
    _ISalpha___9 = 1024,
    _ISdigit___9 = 2048,
    _ISxdigit___9 = 4096,
    _ISspace___9 = 8192,
    _ISprint___9 = 16384,
    _ISgraph___9 = 32768,
    _ISblank___9 = 1,
    _IScntrl___9 = 2,
    _ISpunct___9 = 4,
    _ISalnum___9 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___5 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___7 {
    _ISupper___10 = 256,
    _ISlower___10 = 512,
    _ISalpha___10 = 1024,
    _ISdigit___10 = 2048,
    _ISxdigit___10 = 4096,
    _ISspace___10 = 8192,
    _ISprint___10 = 16384,
    _ISgraph___10 = 32768,
    _ISblank___10 = 1,
    _IScntrl___10 = 2,
    _ISpunct___10 = 4,
    _ISalnum___10 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___6 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___8 {
    _ISupper___11 = 256,
    _ISlower___11 = 512,
    _ISalpha___11 = 1024,
    _ISdigit___11 = 2048,
    _ISxdigit___11 = 4096,
    _ISspace___11 = 8192,
    _ISprint___11 = 16384,
    _ISgraph___11 = 32768,
    _ISblank___11 = 1,
    _IScntrl___11 = 2,
    _ISpunct___11 = 4,
    _ISalnum___11 = 8
} ;
#line 42 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __m64;
#line 45 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __m64_u;
#line 48 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v2si;
#line 49 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v4hi;
#line 50 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v8qi;
#line 51 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v1di;
#line 52 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v2sf;
#line 37 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
enum _mm_hint {
    _MM_HINT_ET0 = 7,
    _MM_HINT_ET1 = 6,
    _MM_HINT_T0 = 3,
    _MM_HINT_T1 = 2,
    _MM_HINT_T2 = 1,
    _MM_HINT_NTA = 0
} ;
#line 69 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __m128;
#line 72 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __m128_u;
#line 75 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __v4sf;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2df;
#line 41 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2di;
#line 42 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2du;
#line 43 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v4si;
#line 44 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v4su;
#line 45 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v8hi;
#line 46 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v8hu;
#line 47 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v16qi;
#line 48 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v16qs;
#line 49 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v16qu;
#line 53 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128i;
#line 54 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128d;
#line 57 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128i_u;
#line 58 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128d_u;
#line 853 "/usr/include/math.h"
enum __anonenum__124 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__127 {
    _ISupper___12 = 256,
    _ISlower___12 = 512,
    _ISalpha___12 = 1024,
    _ISdigit___12 = 2048,
    _ISxdigit___12 = 4096,
    _ISspace___12 = 8192,
    _ISprint___12 = 16384,
    _ISgraph___12 = 32768,
    _ISblank___12 = 1,
    _IScntrl___12 = 2,
    _ISpunct___12 = 4,
    _ISalnum___12 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___7 {
    FP_NAN___13 = 0,
    FP_INFINITE___13 = 1,
    FP_ZERO___13 = 2,
    FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___9 {
    _ISupper___13 = 256,
    _ISlower___13 = 512,
    _ISalpha___13 = 1024,
    _ISdigit___13 = 2048,
    _ISxdigit___13 = 4096,
    _ISspace___13 = 8192,
    _ISprint___13 = 16384,
    _ISgraph___13 = 32768,
    _ISblank___13 = 1,
    _IScntrl___13 = 2,
    _ISpunct___13 = 4,
    _ISalnum___13 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___8 {
    FP_NAN___14 = 0,
    FP_INFINITE___14 = 1,
    FP_ZERO___14 = 2,
    FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___10 {
    _ISupper___14 = 256,
    _ISlower___14 = 512,
    _ISalpha___14 = 1024,
    _ISdigit___14 = 2048,
    _ISxdigit___14 = 4096,
    _ISspace___14 = 8192,
    _ISprint___14 = 16384,
    _ISgraph___14 = 32768,
    _ISblank___14 = 1,
    _IScntrl___14 = 2,
    _ISpunct___14 = 4,
    _ISalnum___14 = 8
} ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 89
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 105 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 158
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1
} ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_131 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_132 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_133 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_134 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_135 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_136 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_137 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_138 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_139 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_140 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_141 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_142 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_143 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_144 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_131  ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_132  ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_133  ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_134  ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_135  ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_136  ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_137  ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_138  ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_139  ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_140  ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_141  ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_142  ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_143  ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_144  ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 32 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__161 {
    FP_NAN___15 = 0,
    FP_INFINITE___15 = 1,
    FP_ZERO___15 = 2,
    FP_SUBNORMAL___15 = 3,
    FP_NORMAL___15 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__164 {
    _ISupper___15 = 256,
    _ISlower___15 = 512,
    _ISalpha___15 = 1024,
    _ISdigit___15 = 2048,
    _ISxdigit___15 = 4096,
    _ISspace___15 = 8192,
    _ISprint___15 = 16384,
    _ISgraph___15 = 32768,
    _ISblank___15 = 1,
    _IScntrl___15 = 2,
    _ISpunct___15 = 4,
    _ISalnum___15 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___9 {
    FP_NAN___16 = 0,
    FP_INFINITE___16 = 1,
    FP_ZERO___16 = 2,
    FP_SUBNORMAL___16 = 3,
    FP_NORMAL___16 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___11 {
    _ISupper___16 = 256,
    _ISlower___16 = 512,
    _ISalpha___16 = 1024,
    _ISdigit___16 = 2048,
    _ISxdigit___16 = 4096,
    _ISspace___16 = 8192,
    _ISprint___16 = 16384,
    _ISgraph___16 = 32768,
    _ISblank___16 = 1,
    _IScntrl___16 = 2,
    _ISpunct___16 = 4,
    _ISalnum___16 = 8
} ;
#line 256 "/root/patchweave_new/14/libopenjpeg/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 259 "/root/patchweave_new/14/libopenjpeg/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1716 "/root/patchweave_new/14/libopenjpeg/j2k.c"
struct opj_dec_mstabent {
   int id ;
   int states ;
   void (*handler)(opj_j2k_t * ) ;
};
#line 1723 "/root/patchweave_new/14/libopenjpeg/j2k.c"
typedef struct opj_dec_mstabent opj_dec_mstabent_t;
#line 853 "/usr/include/math.h"
enum __anonenum__92___10 {
    FP_NAN___17 = 0,
    FP_INFINITE___17 = 1,
    FP_ZERO___17 = 2,
    FP_SUBNORMAL___17 = 3,
    FP_NORMAL___17 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___12 {
    _ISupper___17 = 256,
    _ISlower___17 = 512,
    _ISalpha___17 = 1024,
    _ISdigit___17 = 2048,
    _ISxdigit___17 = 4096,
    _ISspace___17 = 8192,
    _ISprint___17 = 16384,
    _ISgraph___17 = 32768,
    _ISblank___17 = 1,
    _IScntrl___17 = 2,
    _ISpunct___17 = 4,
    _ISalnum___17 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___11 {
    FP_NAN___18 = 0,
    FP_INFINITE___18 = 1,
    FP_ZERO___18 = 2,
    FP_SUBNORMAL___18 = 3,
    FP_NORMAL___18 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___13 {
    _ISupper___18 = 256,
    _ISlower___18 = 512,
    _ISalpha___18 = 1024,
    _ISdigit___18 = 2048,
    _ISxdigit___18 = 4096,
    _ISspace___18 = 8192,
    _ISprint___18 = 16384,
    _ISgraph___18 = 32768,
    _ISblank___18 = 1,
    _IScntrl___18 = 2,
    _ISpunct___18 = 4,
    _ISalnum___18 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__124___0 {
    FP_NAN___19 = 0,
    FP_INFINITE___19 = 1,
    FP_ZERO___19 = 2,
    FP_SUBNORMAL___19 = 3,
    FP_NORMAL___19 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__127___0 {
    _ISupper___19 = 256,
    _ISlower___19 = 512,
    _ISalpha___19 = 1024,
    _ISdigit___19 = 2048,
    _ISxdigit___19 = 4096,
    _ISspace___19 = 8192,
    _ISprint___19 = 16384,
    _ISgraph___19 = 32768,
    _ISblank___19 = 1,
    _IScntrl___19 = 2,
    _ISpunct___19 = 4,
    _ISalnum___19 = 8
} ;
#line 49 "/root/patchweave_new/14/libopenjpeg/dwt.c"
struct dwt_local {
   int *mem ;
   int dn ;
   int sn ;
   int cas ;
};
#line 54 "/root/patchweave_new/14/libopenjpeg/dwt.c"
typedef struct dwt_local dwt_t;
#line 56 "/root/patchweave_new/14/libopenjpeg/dwt.c"
union __anonunion_166 {
   float f[4] ;
};
#line 58 "/root/patchweave_new/14/libopenjpeg/dwt.c"
typedef union __anonunion_166 v4;
#line 60 "/root/patchweave_new/14/libopenjpeg/dwt.c"
struct v4dwt_local {
   v4 *wavelet ;
   int dn ;
   int sn ;
   int cas ;
};
#line 65 "/root/patchweave_new/14/libopenjpeg/dwt.c"
typedef struct v4dwt_local v4dwt_t;
#line 81 "/root/patchweave_new/14/libopenjpeg/dwt.c"
typedef void (*DWT1DFN)(dwt_t * );
#line 853 "/usr/include/math.h"
enum __anonenum__92___12 {
    FP_NAN___20 = 0,
    FP_INFINITE___20 = 1,
    FP_ZERO___20 = 2,
    FP_SUBNORMAL___20 = 3,
    FP_NORMAL___20 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___14 {
    _ISupper___20 = 256,
    _ISlower___20 = 512,
    _ISalpha___20 = 1024,
    _ISdigit___20 = 2048,
    _ISxdigit___20 = 4096,
    _ISspace___20 = 8192,
    _ISprint___20 = 16384,
    _ISgraph___20 = 32768,
    _ISblank___20 = 1,
    _IScntrl___20 = 2,
    _ISpunct___20 = 4,
    _ISalnum___20 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___13 {
    FP_NAN___21 = 0,
    FP_INFINITE___21 = 1,
    FP_ZERO___21 = 2,
    FP_SUBNORMAL___21 = 3,
    FP_NORMAL___21 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___15 {
    _ISupper___21 = 256,
    _ISlower___21 = 512,
    _ISalpha___21 = 1024,
    _ISdigit___21 = 2048,
    _ISxdigit___21 = 4096,
    _ISspace___21 = 8192,
    _ISprint___21 = 16384,
    _ISgraph___21 = 32768,
    _ISblank___21 = 1,
    _IScntrl___21 = 2,
    _ISpunct___21 = 4,
    _ISalnum___21 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__45___0 {
    FP_NAN___22 = 0,
    FP_INFINITE___22 = 1,
    FP_ZERO___22 = 2,
    FP_SUBNORMAL___22 = 3,
    FP_NORMAL___22 = 4
} ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__185 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 6 "../../applications/common/opj_getopt.h"
struct opj_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 12 "../../applications/common/opj_getopt.h"
typedef struct opj_option opj_option_t;
#line 36 "/root/patchweave_new/14/applications/codec/convert.h"
struct raw_cparameters {
   int rawWidth ;
   int rawHeight ;
   int rawComp ;
   int rawBitDepth ;
   opj_bool rawSigned ;
};
#line 48 "/root/patchweave_new/14/applications/codec/convert.h"
typedef struct raw_cparameters raw_cparameters_t;
#line 56 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 61 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
typedef struct dircnt dircnt_t;
#line 64 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
struct img_folder {
   char *imgdirpath ;
   char const   *out_format ;
   char set_imgdir ;
   char set_out_format ;
};
#line 74 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
typedef struct img_folder img_fol_t;
#line 853 "/usr/include/math.h"
enum __anonenum__186 {
    FP_NAN___23 = 0,
    FP_INFINITE___23 = 1,
    FP_ZERO___23 = 2,
    FP_SUBNORMAL___23 = 3,
    FP_NORMAL___23 = 4
} ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size(__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size(__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 784
extern int system(char const   *__command ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 75
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 78
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 119
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 139
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 149
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 153
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 166
extern char *tzname[2] ;
#line 170
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 174
extern int daylight ;
#line 175
extern long timezone ;
#line 190
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 193
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 196
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 205
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 210
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 213
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 216
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 224
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 229
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 234
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 239
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 242
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 247
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 251
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 257
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 152
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 192
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 326
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 341
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 379
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 510
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 775
extern void perror(char const   *__s ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 786 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 791
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 28
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 36
  __cil_tmp4 = __builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 55
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 58
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 93
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = __builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = __builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 259
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 259
    if (! __cil_tmp5) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size(__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size(__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 289
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 289
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 289
    if (! __cil_tmp6) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 350
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 350
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 350
    if (! __cil_tmp6) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
  {
#line 362
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 362
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;
#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break: /* CIL Label */ ;
          }
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 732 "/root/patchweave_new/14/libopenjpeg/openjpeg.h"
char const   *opj_version(void) ;
#line 747
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) ;
#line 753
void opj_image_destroy(opj_image_t *image ) ;
#line 772
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) ;
#line 778
void opj_cio_close(opj_cio_t *cio ) ;
#line 785
int cio_tell(opj_cio_t *cio ) ;
#line 791
void cio_seek(opj_cio_t *cio , int pos ) ;
#line 799
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) ;
#line 811
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) ;
#line 816
void opj_destroy_decompress(opj_dinfo_t *dinfo ) ;
#line 821
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 828
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) ;
#line 835
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) ;
#line 844
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 850
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) ;
#line 855
void opj_destroy_compress(opj_cinfo_t *cinfo ) ;
#line 877
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 884
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 893
opj_bool opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index___0 ) ;
#line 902
opj_bool opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                              opj_codestream_info_t *cstr_info ) ;
#line 907
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) ;
#line 46 "/root/patchweave_new/14/libopenjpeg/j2k_lib.h"
double opj_clock(void) ;
#line 52 "/root/patchweave_new/14/libopenjpeg/event.h"
opj_bool opj_event_msg(opj_common_ptr cinfo , int event_type , char const   *fmt 
                       , ...) ;
#line 67 "/root/patchweave_new/14/libopenjpeg/bio.h"
opj_bio_t *bio_create(void) ;
#line 72
void bio_destroy(opj_bio_t *bio ) ;
#line 78
int bio_numbytes(opj_bio_t *bio ) ;
#line 85
void bio_init_enc(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 92
void bio_init_dec(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 99
void bio_write(opj_bio_t *bio , int v , int n ) ;
#line 106
int bio_read(opj_bio_t *bio , int n ) ;
#line 112
int bio_flush(opj_bio_t *bio ) ;
#line 118
int bio_inalign(opj_bio_t *bio ) ;
#line 59 "/root/patchweave_new/14/libopenjpeg/cio.h"
int cio_numbytesleft(opj_cio_t *cio ) ;
#line 65
unsigned char *cio_getbp(opj_cio_t *cio ) ;
#line 73
unsigned int cio_write(opj_cio_t *cio , unsigned long long v , int n ) ;
#line 80
unsigned int cio_read(opj_cio_t *cio , int n ) ;
#line 86
void cio_skip(opj_cio_t *cio , int n ) ;
#line 43 "/root/patchweave_new/14/libopenjpeg/image.h"
opj_image_t *opj_image_create0(void) ;
#line 379 "/root/patchweave_new/14/libopenjpeg/j2k.h"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) ;
#line 384
void j2k_destroy_decompress(opj_j2k_t *j2k ) ;
#line 391
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 399
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 407
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 413
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) ;
#line 418
void j2k_destroy_compress(opj_j2k_t *j2k ) ;
#line 426
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 430
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 439
opj_bool j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 164 "/root/patchweave_new/14/libopenjpeg/jp2.h"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 172
opj_bool jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) ;
#line 178
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) ;
#line 183
void jp2_destroy_decompress(opj_jp2_t *jp2 ) ;
#line 190
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 198
opj_image_t *opj_jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 204
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) ;
#line 209
void jp2_destroy_compress(opj_jp2_t *jp2 ) ;
#line 217
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 226
opj_bool opj_jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 65 "/root/patchweave_new/14/libopenjpeg/jpt.h"
void jpt_init_msg_header(opj_jpt_msg_header_t *header ) ;
#line 73
void jpt_read_msg_header(opj_common_ptr cinfo , opj_cio_t *cio , opj_jpt_msg_header_t *header ) ;
#line 85 "/root/patchweave_new/14/libopenjpeg/mqc.h"
opj_mqc_t *mqc_create(void) ;
#line 90
void mqc_destroy(opj_mqc_t *mqc ) ;
#line 96
int mqc_numbytes(opj_mqc_t *mqc ) ;
#line 102
void mqc_resetstates(opj_mqc_t *mqc ) ;
#line 110
void mqc_setstate(opj_mqc_t *mqc , int ctxno , int msb , int prob ) ;
#line 116
void mqc_init_enc(opj_mqc_t *mqc , unsigned char *bp ) ;
#line 128
void mqc_encode(opj_mqc_t *mqc , int d ) ;
#line 133
void mqc_flush(opj_mqc_t *mqc ) ;
#line 140
void mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 148
void mqc_bypass_enc(opj_mqc_t *mqc , int d ) ;
#line 155
int mqc_bypass_flush_enc(opj_mqc_t *mqc ) ;
#line 160
void mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 166
int mqc_restart_enc(opj_mqc_t *mqc ) ;
#line 171
void mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 176
void mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 181
void mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 188
void mqc_init_dec(opj_mqc_t *mqc , unsigned char *bp , int len ) ;
#line 194
int mqc_decode(opj_mqc_t *mqc ) ;
#line 70 "/root/patchweave_new/14/libopenjpeg/raw.h"
opj_raw_t *raw_create(void) ;
#line 75
void raw_destroy(opj_raw_t *raw ) ;
#line 81
int raw_numbytes(opj_raw_t *raw ) ;
#line 88
void raw_init_dec(opj_raw_t *raw , unsigned char *bp , int len ) ;
#line 94
int raw_decode(opj_raw_t *raw ) ;
#line 74 "/root/patchweave_new/14/libopenjpeg/tgt.h"
opj_tgt_tree_t *tgt_create(int numleafsh , int numleafsv ) ;
#line 79
void tgt_destroy(opj_tgt_tree_t *tree ) ;
#line 84
void tgt_reset(opj_tgt_tree_t *tree ) ;
#line 91
void tgt_setvalue(opj_tgt_tree_t *tree , int leafno , int value ) ;
#line 99
void tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 108
int tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 112 "/root/patchweave_new/14/libopenjpeg/pi.h"
opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , int tileno ,
                                        J2K_T2_MODE t2_mode ) ;
#line 125
opj_bool pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno , int pino ,
                          int tpnum , int tppos , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 134
opj_pi_iterator_t *pi_create_decode(opj_image_t *image , opj_cp_t *cp , int tileno ) ;
#line 143
void pi_destroy(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno ) ;
#line 150
opj_bool pi_next(opj_pi_iterator_t *pi ) ;
#line 210 "/root/patchweave_new/14/libopenjpeg/tcd.h"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) ;
#line 216
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) ;
#line 221
void tcd_destroy(opj_tcd_t *tcd ) ;
#line 229
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 234
void tcd_free_encode(opj_tcd_t *tcd ) ;
#line 242
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 249
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) ;
#line 250
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) ;
#line 251
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) ;
#line 252
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) ;
#line 253
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) ;
#line 254
opj_bool tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) ;
#line 264
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) ;
#line 273
opj_bool tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno ,
                         opj_codestream_info_t *cstr_info ) ;
#line 278
void tcd_free_decode(opj_tcd_t *tcd ) ;
#line 279
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) ;
#line 122 "/root/patchweave_new/14/libopenjpeg/t1.h"
opj_t1_t *t1_create(opj_common_ptr cinfo ) ;
#line 127
void t1_destroy(opj_t1_t *t1 ) ;
#line 134
void t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ) ;
#line 141
void t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) ;
#line 55 "/root/patchweave_new/14/libopenjpeg/dwt.h"
void dwt_encode(opj_tcd_tilecomp_t *tilec ) ;
#line 62
void dwt_decode(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 68
int dwt_getgain(int orient ) ;
#line 75
double dwt_getnorm(int level , int orient ) ;
#line 81
void dwt_encode_real(opj_tcd_tilecomp_t *tilec ) ;
#line 88
void dwt_decode_real(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 94
int dwt_getgain_real(int orient ) ;
#line 101
double dwt_getnorm_real(int level , int orient ) ;
#line 107
void dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , int prec ) ;
#line 74 "/root/patchweave_new/14/libopenjpeg/t2.h"
int t2_encode_packets(opj_t2_t *t2 , int tileno , opj_tcd_tile_t *tile , int maxlayers ,
                      unsigned char *dest , int len , opj_codestream_info_t *cstr_info ,
                      int tpnum , int tppos , int pino , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 84
int t2_decode_packets(opj_t2_t *t2 , unsigned char *src , int len , int tileno , opj_tcd_tile_t *tile ,
                      opj_codestream_info_t *cstr_info ) ;
#line 93
opj_t2_t *t2_create(opj_common_ptr cinfo , opj_image_t *image , opj_cp_t *cp ) ;
#line 98
void t2_destroy(opj_t2_t *t2 ) ;
#line 55 "/root/patchweave_new/14/libopenjpeg/mct.h"
void mct_encode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 63
void mct_decode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 69
double mct_getnorm(int compno ) ;
#line 78
void mct_encode_real(int *c0 , int *c1 , int *c2 , int n ) ;
#line 86
void mct_decode_real(float *c0 , float *c1 , float *c2 , int n ) ;
#line 92
double mct_getnorm_real(int compno ) ;
#line 50 "/root/patchweave_new/14/libopenjpeg/int.h"
__inline static int int_min(int a , int b ) 
{ 
  int tmp ;

  {
#line 51
  if (a < b) {
#line 51
    tmp = a;
  } else {
#line 51
    tmp = b;
  }
#line 51
  return (tmp);
}
}
#line 57 "/root/patchweave_new/14/libopenjpeg/int.h"
__inline static int int_max(int a , int b ) 
{ 
  int tmp ;

  {
#line 58
  if (a > b) {
#line 58
    tmp = a;
  } else {
#line 58
    tmp = b;
  }
#line 58
  return (tmp);
}
}
#line 69 "/root/patchweave_new/14/libopenjpeg/int.h"
__inline static int int_clamp(int a , int min , int max ) 
{ 


  {
#line 70
  if (a < min) {
#line 71
    return (min);
  }
#line 72
  if (a > max) {
#line 73
    return (max);
  }
#line 74
  return (a);
}
}
#line 79 "/root/patchweave_new/14/libopenjpeg/int.h"
__inline static int int_abs(int a ) 
{ 
  int tmp ;

  {
#line 80
  if (a < 0) {
#line 80
    tmp = - a;
  } else {
#line 80
    tmp = a;
  }
#line 80
  return (tmp);
}
}
#line 86 "/root/patchweave_new/14/libopenjpeg/int.h"
__inline static int int_ceildiv(int a , int b ) 
{ 


  {
#line 87
  return (((a + b) - 1) / b);
}
}
#line 93 "/root/patchweave_new/14/libopenjpeg/int.h"
__inline static int int_ceildivpow2(int a , int b ) 
{ 


  {
#line 94
  return (((a + (1 << b)) - 1) >> b);
}
}
#line 100 "/root/patchweave_new/14/libopenjpeg/int.h"
__inline static int int_floordivpow2(int a , int b ) 
{ 


  {
#line 101
  return (a >> b);
}
}
#line 107 "/root/patchweave_new/14/libopenjpeg/int.h"
__inline static int int_floorlog2(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 109
  l = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (a > 1)) {
#line 109
      goto while_break;
    }
#line 110
    a >>= 1;
#line 109
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (l);
}
}
#line 56 "/root/patchweave_new/14/libopenjpeg/fix.h"
__inline static int fix_mul(int a , int b ) 
{ 
  long long temp ;

  {
#line 57
  temp = (long long )a * (long long )b;
#line 58
  temp += temp & 4096LL;
#line 59
  return ((int )(temp >> 13));
}
}
#line 53 "/root/patchweave_new/14/libopenjpeg/cidx_manager.h"
int write_cidx(int offset , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t cstr_info ,
               int j2klen ) ;
#line 68 "/root/patchweave_new/14/libopenjpeg/indexbox_manager.h"
int write_tpix(int coff , opj_codestream_info_t cstr_info , int j2klen , opj_cio_t *cio ) ;
#line 79
int write_thix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) ;
#line 92
int write_ppix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) ;
#line 105
int write_phix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) ;
#line 115
void write_manf(int second , int v , opj_jp2_box_t *box , opj_cio_t *cio ) ;
#line 52 "/root/patchweave_new/14/libopenjpeg/tpix_manager.c"
int write_tpixfaix(int coff , int compno , opj_codestream_info_t cstr_info , int j2klen ,
                   opj_cio_t *cio ) ;
#line 55 "/root/patchweave_new/14/libopenjpeg/tpix_manager.c"
int write_tpix(int coff , opj_codestream_info_t cstr_info , int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 58
  lenp = cio_tell(cio);
#line 59
  cio_skip(cio, 4);
#line 60
  cio_write(cio, (unsigned long long )1953524088, 4);
#line 62
  write_tpixfaix(coff, 0, cstr_info, j2klen, cio);
#line 64
  __cil_tmp8 = cio_tell(cio);
#line 64
  len = __cil_tmp8 - lenp;
#line 65
  cio_seek(cio, lenp);
#line 66
  cio_write(cio, (unsigned long long )len, 4);
#line 67
  cio_seek(cio, lenp + len);
  }
#line 69
  return (len);
}
}
#line 79
int get_num_max_tile_parts(opj_codestream_info_t cstr_info ) ;
#line 81 "/root/patchweave_new/14/libopenjpeg/tpix_manager.c"
int write_tpixfaix(int coff , int compno , opj_codestream_info_t cstr_info , int j2klen ,
                   opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int j ;
  int Aux ;
  int num_max_tile_parts ;
  int size_of_coding ;
  opj_tp_info_t tp ;
  int version ;
  int __cil_tmp15 ;
  double __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;

  {
  {
#line 91
  num_max_tile_parts = get_num_max_tile_parts(cstr_info);
#line 93
  __cil_tmp16 = pow((double )2, (double )32);
  }
#line 93
  if ((double )j2klen > __cil_tmp16) {
#line 94
    size_of_coding = 8;
#line 95
    if (num_max_tile_parts == 1) {
#line 95
      tmp = 1;
    } else {
#line 95
      tmp = 3;
    }
#line 95
    version = tmp;
  } else {
#line 98
    size_of_coding = 4;
#line 99
    if (num_max_tile_parts == 1) {
#line 99
      tmp___0 = 0;
    } else {
#line 99
      tmp___0 = 2;
    }
#line 99
    version = tmp___0;
  }
  {
#line 102
  lenp = cio_tell(cio);
#line 103
  cio_skip(cio, 4);
#line 104
  cio_write(cio, (unsigned long long )1717660024, 4);
#line 105
  cio_write(cio, (unsigned long long )version, 1);
#line 107
  cio_write(cio, (unsigned long long )num_max_tile_parts, size_of_coding);
#line 108
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 109
  i = 0;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i < cstr_info.tw * cstr_info.th)) {
#line 109
      goto while_break;
    }
#line 110
    j = 0;
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      if (! (j < (cstr_info.tile + i)->num_tps)) {
#line 110
        goto while_break___0;
      }
      {
#line 111
      tp = *((cstr_info.tile + i)->tp + j);
#line 112
      cio_write(cio, (unsigned long long )(tp.tp_start_pos - coff), size_of_coding);
#line 113
      cio_write(cio, (unsigned long long )((tp.tp_end_pos - tp.tp_start_pos) + 1),
                size_of_coding);
      }
#line 114
      if (version & 2) {
#line 115
        if ((cstr_info.tile + i)->num_tps == 1) {
#line 115
          if (*(cstr_info.numdecompos + compno) > 1) {
#line 116
            Aux = *(cstr_info.numdecompos + compno) + 1;
          } else {
#line 118
            Aux = j + 1;
          }
        } else {
#line 118
          Aux = j + 1;
        }
        {
#line 120
        cio_write(cio, (unsigned long long )Aux, 4);
        }
      }
#line 110
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 127
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 127
      if (! (j < num_max_tile_parts)) {
#line 127
        goto while_break___1;
      }
      {
#line 128
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 129
      cio_write(cio, (unsigned long long )0, size_of_coding);
      }
#line 130
      if (version & 2) {
        {
#line 131
        cio_write(cio, (unsigned long long )0, 4);
        }
      }
#line 132
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 109
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  __cil_tmp23 = cio_tell(cio);
#line 136
  len = __cil_tmp23 - lenp;
#line 137
  cio_seek(cio, lenp);
#line 138
  cio_write(cio, (unsigned long long )len, 4);
#line 139
  cio_seek(cio, lenp + len);
  }
#line 141
  return (len);
}
}
#line 145 "/root/patchweave_new/14/libopenjpeg/tpix_manager.c"
int get_num_max_tile_parts(opj_codestream_info_t cstr_info ) 
{ 
  int num_max_tp ;
  int i ;
  int tmp ;
  int __cil_tmp5 ;

  {
#line 147
  num_max_tp = 0;
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < cstr_info.tw * cstr_info.th)) {
#line 149
      goto while_break;
    }
#line 150
    if ((cstr_info.tile + i)->num_tps > num_max_tp) {
#line 150
      tmp = (cstr_info.tile + i)->num_tps;
    } else {
#line 150
      tmp = num_max_tp;
    }
#line 150
    num_max_tp = tmp;
#line 149
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return (num_max_tp);
}
}
#line 50 "/root/patchweave_new/14/libopenjpeg/thix_manager.c"
int write_tilemhix(int coff , opj_codestream_info_t cstr_info , int tileno , opj_cio_t *cio ) ;
#line 52 "/root/patchweave_new/14/libopenjpeg/thix_manager.c"
int write_thix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int tileno ;
  opj_jp2_box_t *box ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 58
  lenp = 0;
#line 59
  __cil_tmp9 = calloc((unsigned long )(cstr_info.tw * cstr_info.th), sizeof(opj_jp2_box_t ));
#line 59
  box = (opj_jp2_box_t *)__cil_tmp9;
#line 61
  i = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (i < 2)) {
#line 61
      goto while_break;
    }
#line 62
    if (i) {
      {
#line 63
      cio_seek(cio, lenp);
      }
    }
    {
#line 65
    lenp = cio_tell(cio);
#line 66
    cio_skip(cio, 4);
#line 67
    cio_write(cio, (unsigned long long )1952999800, 4);
#line 68
    write_manf(i, cstr_info.tw * cstr_info.th, box, cio);
#line 70
    tileno = 0;
    }
    {
#line 70
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 70
      if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 70
        goto while_break___0;
      }
      {
#line 71
      (box + tileno)->length = write_tilemhix(coff, cstr_info, tileno, cio);
#line 72
      (box + tileno)->type = 1835559288;
      }
#line 70
      tileno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 75
    __cil_tmp13 = cio_tell(cio);
#line 75
    len = __cil_tmp13 - lenp;
#line 76
    cio_seek(cio, lenp);
#line 77
    cio_write(cio, (unsigned long long )len, 4);
#line 78
    cio_seek(cio, lenp + len);
    }
#line 61
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  free(box);
  }
#line 83
  return (len);
}
}
#line 86 "/root/patchweave_new/14/libopenjpeg/thix_manager.c"
int write_tilemhix(int coff , opj_codestream_info_t cstr_info , int tileno , opj_cio_t *cio ) 
{ 
  int i ;
  opj_tile_info_t tile ;
  opj_tp_info_t tp ;
  int len ;
  int lenp ;
  opj_marker_info_t *marker ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 94
  lenp = cio_tell(cio);
#line 95
  cio_skip(cio, 4);
#line 96
  cio_write(cio, (unsigned long long )1835559288, 4);
#line 98
  tile = *(cstr_info.tile + tileno);
#line 99
  tp = *(tile.tp + 0);
#line 101
  cio_write(cio, (unsigned long long )((tp.tp_end_header - tp.tp_start_pos) + 1),
            8);
#line 103
  marker = (cstr_info.tile + tileno)->marker;
#line 105
  i = 0;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < (cstr_info.tile + tileno)->marknum)) {
#line 105
      goto while_break;
    }
    {
#line 106
    cio_write(cio, (unsigned long long )(marker + i)->type, 2);
#line 107
    cio_write(cio, (unsigned long long )0, 2);
#line 108
    cio_write(cio, (unsigned long long )((marker + i)->pos - coff), 8);
#line 109
    cio_write(cio, (unsigned long long )(marker + i)->len, 2);
    }
#line 105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  __cil_tmp13 = cio_tell(cio);
#line 114
  len = __cil_tmp13 - lenp;
#line 115
  cio_seek(cio, lenp);
#line 116
  cio_write(cio, (unsigned long long )len, 4);
#line 117
  cio_seek(cio, lenp + len);
  }
#line 119
  return (len);
}
}
#line 52 "/root/patchweave_new/14/libopenjpeg/ppix_manager.c"
int write_ppixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) ;
#line 54 "/root/patchweave_new/14/libopenjpeg/ppix_manager.c"
int write_ppix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int compno ;
  int i ;
  opj_jp2_box_t *box ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 61
  lenp = - 1;
#line 62
  __cil_tmp11 = calloc((unsigned long )cstr_info.numcomps, sizeof(opj_jp2_box_t ));
#line 62
  box = (opj_jp2_box_t *)__cil_tmp11;
#line 64
  i = 0;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < 2)) {
#line 64
      goto while_break;
    }
#line 65
    if (i) {
      {
#line 65
      cio_seek(cio, lenp);
      }
    }
    {
#line 67
    lenp = cio_tell(cio);
#line 68
    cio_skip(cio, 4);
#line 69
    cio_write(cio, (unsigned long long )1886415224, 4);
#line 71
    write_manf(i, cstr_info.numcomps, box, cio);
#line 73
    compno = 0;
    }
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 73
      if (! (compno < cstr_info.numcomps)) {
#line 73
        goto while_break___0;
      }
      {
#line 74
      (box + compno)->length = write_ppixfaix(coff, compno, cstr_info, EPHused, j2klen,
                                              cio);
#line 75
      (box + compno)->type = 1717660024;
      }
#line 73
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 78
    __cil_tmp15 = cio_tell(cio);
#line 78
    len = __cil_tmp15 - lenp;
#line 79
    cio_seek(cio, lenp);
#line 80
    cio_write(cio, (unsigned long long )len, 4);
#line 81
    cio_seek(cio, lenp + len);
    }
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  free(box);
  }
#line 86
  return (len);
}
}
#line 89 "/root/patchweave_new/14/libopenjpeg/ppix_manager.c"
int write_ppixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int tileno ;
  int version ;
  int i ;
  int nmax ;
  int size_of_coding ;
  opj_tile_info_t *tile_Idx ;
  opj_packet_info_t packet ;
  int resno ;
  int precno ;
  int layno ;
  int num_packet ;
  int numOfres ;
  int numOfprec ;
  int numOflayers ;
  double __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
  {
#line 96
  packet.start_pos = - 1;
#line 96
  packet.end_ph_pos = packet.start_pos;
#line 96
  packet.end_pos = packet.end_ph_pos;
#line 99
  __cil_tmp23 = pow((double )2, (double )32);
  }
#line 99
  if ((double )j2klen > __cil_tmp23) {
#line 100
    size_of_coding = 8;
#line 101
    version = 1;
  } else {
#line 104
    size_of_coding = 4;
#line 105
    version = 0;
  }
  {
#line 108
  lenp = cio_tell(cio);
#line 109
  cio_skip(cio, 4);
#line 110
  cio_write(cio, (unsigned long long )1717660024, 4);
#line 111
  cio_write(cio, (unsigned long long )version, 1);
#line 113
  nmax = 0;
#line 114
  i = 0;
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i <= *(cstr_info.numdecompos + compno))) {
#line 114
      goto while_break;
    }
#line 115
    nmax += ((cstr_info.tile + 0)->ph[i] * (cstr_info.tile + 0)->pw[i]) * cstr_info.numlayers;
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  cio_write(cio, (unsigned long long )nmax, size_of_coding);
#line 118
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 120
  tileno = 0;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 120
      goto while_break___0;
    }
#line 121
    tile_Idx = cstr_info.tile + tileno;
#line 123
    num_packet = 0;
#line 124
    numOfres = *(cstr_info.numdecompos + compno) + 1;
#line 126
    resno = 0;
    {
#line 126
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 126
      if (! (resno < numOfres)) {
#line 126
        goto while_break___1;
      }
#line 127
      numOfprec = tile_Idx->pw[resno] * tile_Idx->ph[resno];
#line 128
      precno = 0;
      {
#line 128
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 128
        if (! (precno < numOfprec)) {
#line 128
          goto while_break___2;
        }
#line 129
        numOflayers = cstr_info.numlayers;
#line 130
        layno = 0;
        {
#line 130
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 130
          if (! (layno < numOflayers)) {
#line 130
            goto while_break___3;
          }
          {
#line 133
          if ((int )cstr_info.prog == 0) {
#line 133
            goto case_0;
          }
#line 136
          if ((int )cstr_info.prog == 1) {
#line 136
            goto case_1;
          }
#line 139
          if ((int )cstr_info.prog == 2) {
#line 139
            goto case_2;
          }
#line 142
          if ((int )cstr_info.prog == 3) {
#line 142
            goto case_3;
          }
#line 145
          if ((int )cstr_info.prog == 4) {
#line 145
            goto case_4;
          }
#line 148
          goto switch_default;
          case_0: /* CIL Label */ 
#line 134
          packet = *(tile_Idx->packet + (((layno * numOfres + resno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 135
          goto switch_break;
          case_1: /* CIL Label */ 
#line 137
          packet = *(tile_Idx->packet + (((resno * numOflayers + layno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 138
          goto switch_break;
          case_2: /* CIL Label */ 
#line 140
          packet = *(tile_Idx->packet + (((resno * numOfprec + precno) * cstr_info.numcomps + compno) * numOflayers + layno));
#line 141
          goto switch_break;
          case_3: /* CIL Label */ 
#line 143
          packet = *(tile_Idx->packet + (((precno * cstr_info.numcomps + compno) * numOfres + resno) * numOflayers + layno));
#line 144
          goto switch_break;
          case_4: /* CIL Label */ 
#line 146
          packet = *(tile_Idx->packet + (((compno * numOfprec + precno) * numOfres + resno) * numOflayers + layno));
#line 147
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 149
          fprintf(stderr, "failed to ppix indexing\n\220");
          }
          switch_break: /* CIL Label */ ;
          }
          {
#line 152
          cio_write(cio, (unsigned long long )(packet.start_pos - coff), size_of_coding);
#line 153
          cio_write(cio, (unsigned long long )((packet.end_pos - packet.start_pos) + 1),
                    size_of_coding);
#line 155
          num_packet ++;
          }
#line 130
          layno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 128
        precno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 126
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 160
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 160
      if (! (num_packet < nmax)) {
#line 160
        goto while_break___4;
      }
      {
#line 161
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 162
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 163
      num_packet ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 120
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 167
  __cil_tmp32 = cio_tell(cio);
#line 167
  len = __cil_tmp32 - lenp;
#line 168
  cio_seek(cio, lenp);
#line 169
  cio_write(cio, (unsigned long long )len, 4);
#line 170
  cio_seek(cio, lenp + len);
  }
#line 172
  return (len);
}
}
#line 51 "/root/patchweave_new/14/libopenjpeg/phix_manager.c"
int write_phixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) ;
#line 53 "/root/patchweave_new/14/libopenjpeg/phix_manager.c"
int write_phix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int compno ;
  int i ;
  opj_jp2_box_t *box ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 55
  lenp = 0;
#line 58
  __cil_tmp11 = calloc((unsigned long )cstr_info.numcomps, sizeof(opj_jp2_box_t ));
#line 58
  box = (opj_jp2_box_t *)__cil_tmp11;
#line 60
  i = 0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < 2)) {
#line 60
      goto while_break;
    }
#line 61
    if (i) {
      {
#line 61
      cio_seek(cio, lenp);
      }
    }
    {
#line 63
    lenp = cio_tell(cio);
#line 64
    cio_skip(cio, 4);
#line 65
    cio_write(cio, (unsigned long long )1885890936, 4);
#line 67
    write_manf(i, cstr_info.numcomps, box, cio);
#line 69
    compno = 0;
    }
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 69
      if (! (compno < cstr_info.numcomps)) {
#line 69
        goto while_break___0;
      }
      {
#line 70
      (box + compno)->length = write_phixfaix(coff, compno, cstr_info, EPHused, j2klen,
                                              cio);
#line 71
      (box + compno)->type = 1717660024;
      }
#line 69
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 74
    __cil_tmp15 = cio_tell(cio);
#line 74
    len = __cil_tmp15 - lenp;
#line 75
    cio_seek(cio, lenp);
#line 76
    cio_write(cio, (unsigned long long )len, 4);
#line 77
    cio_seek(cio, lenp + len);
    }
#line 60
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  free(box);
  }
#line 82
  return (len);
}
}
#line 85 "/root/patchweave_new/14/libopenjpeg/phix_manager.c"
int write_phixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int tileno ;
  int version ;
  int i ;
  int nmax ;
  int size_of_coding ;
  opj_tile_info_t *tile_Idx ;
  opj_packet_info_t packet ;
  int resno ;
  int precno ;
  int layno ;
  int num_packet ;
  int numOfres ;
  int numOfprec ;
  int numOflayers ;
  double __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
  {
#line 92
  packet.start_pos = - 1;
#line 92
  packet.end_ph_pos = packet.start_pos;
#line 95
  __cil_tmp23 = pow((double )2, (double )32);
  }
#line 95
  if ((double )j2klen > __cil_tmp23) {
#line 96
    size_of_coding = 8;
#line 97
    version = 1;
  } else {
#line 100
    size_of_coding = 4;
#line 101
    version = 0;
  }
  {
#line 104
  lenp = cio_tell(cio);
#line 105
  cio_skip(cio, 4);
#line 106
  cio_write(cio, (unsigned long long )1717660024, 4);
#line 107
  cio_write(cio, (unsigned long long )version, 1);
#line 109
  nmax = 0;
#line 110
  i = 0;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i <= *(cstr_info.numdecompos + compno))) {
#line 110
      goto while_break;
    }
#line 111
    nmax += ((cstr_info.tile + 0)->ph[i] * (cstr_info.tile + 0)->pw[i]) * cstr_info.numlayers;
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  cio_write(cio, (unsigned long long )nmax, size_of_coding);
#line 114
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 116
  tileno = 0;
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 116
    if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 116
      goto while_break___0;
    }
#line 117
    tile_Idx = cstr_info.tile + tileno;
#line 119
    num_packet = 0;
#line 120
    numOfres = *(cstr_info.numdecompos + compno) + 1;
#line 122
    resno = 0;
    {
#line 122
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 122
      if (! (resno < numOfres)) {
#line 122
        goto while_break___1;
      }
#line 123
      numOfprec = tile_Idx->pw[resno] * tile_Idx->ph[resno];
#line 124
      precno = 0;
      {
#line 124
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 124
        if (! (precno < numOfprec)) {
#line 124
          goto while_break___2;
        }
#line 125
        numOflayers = cstr_info.numlayers;
#line 126
        layno = 0;
        {
#line 126
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 126
          if (! (layno < numOflayers)) {
#line 126
            goto while_break___3;
          }
          {
#line 129
          if ((int )cstr_info.prog == 0) {
#line 129
            goto case_0;
          }
#line 132
          if ((int )cstr_info.prog == 1) {
#line 132
            goto case_1;
          }
#line 135
          if ((int )cstr_info.prog == 2) {
#line 135
            goto case_2;
          }
#line 138
          if ((int )cstr_info.prog == 3) {
#line 138
            goto case_3;
          }
#line 141
          if ((int )cstr_info.prog == 4) {
#line 141
            goto case_4;
          }
#line 144
          goto switch_default;
          case_0: /* CIL Label */ 
#line 130
          packet = *(tile_Idx->packet + (((layno * numOfres + resno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 131
          goto switch_break;
          case_1: /* CIL Label */ 
#line 133
          packet = *(tile_Idx->packet + (((resno * numOflayers + layno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 134
          goto switch_break;
          case_2: /* CIL Label */ 
#line 136
          packet = *(tile_Idx->packet + (((resno * numOfprec + precno) * cstr_info.numcomps + compno) * numOflayers + layno));
#line 137
          goto switch_break;
          case_3: /* CIL Label */ 
#line 139
          packet = *(tile_Idx->packet + (((precno * cstr_info.numcomps + compno) * numOfres + resno) * numOflayers + layno));
#line 140
          goto switch_break;
          case_4: /* CIL Label */ 
#line 142
          packet = *(tile_Idx->packet + (((compno * numOfprec + precno) * numOfres + resno) * numOflayers + layno));
#line 143
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 145
          fprintf(stderr, "failed to ppix indexing\n\220");
          }
          switch_break: /* CIL Label */ ;
          }
          {
#line 148
          cio_write(cio, (unsigned long long )(packet.start_pos - coff), size_of_coding);
#line 149
          cio_write(cio, (unsigned long long )((packet.end_ph_pos - packet.start_pos) + 1),
                    size_of_coding);
#line 151
          num_packet ++;
          }
#line 126
          layno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 124
        precno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 122
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 157
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 157
      if (! (num_packet < nmax)) {
#line 157
        goto while_break___4;
      }
      {
#line 158
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 159
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 160
      num_packet ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 116
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 164
  __cil_tmp32 = cio_tell(cio);
#line 164
  len = __cil_tmp32 - lenp;
#line 165
  cio_seek(cio, lenp);
#line 166
  cio_write(cio, (unsigned long long )len, 4);
#line 167
  cio_seek(cio, lenp + len);
  }
#line 169
  return (len);
}
}
#line 42 "/root/patchweave_new/14/libopenjpeg/cidx_manager.c"
void write_cptr(int coff , int clen , opj_cio_t *cio ) ;
#line 53
int write_mainmhix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) ;
#line 65
opj_bool check_EPHuse(int coff , opj_marker_info_t *markers , int marknum , opj_cio_t *cio ) ;
#line 68 "/root/patchweave_new/14/libopenjpeg/cidx_manager.c"
int write_cidx(int offset , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t cstr_info ,
               int j2klen ) 
{ 
  int len ;
  int i ;
  int lenp ;
  opj_jp2_box_t *box ;
  int num_box ;
  opj_bool EPHused ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_bool __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;

  {
  {
#line 72
  num_box = 0;
#line 76
  lenp = - 1;
#line 77
  __cil_tmp12 = calloc((unsigned long )32, sizeof(opj_jp2_box_t ));
#line 77
  box = (opj_jp2_box_t *)__cil_tmp12;
#line 79
  i = 0;
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 2)) {
#line 79
      goto while_break;
    }
#line 81
    if (i) {
      {
#line 82
      cio_seek(cio, lenp);
      }
    }
    {
#line 84
    lenp = cio_tell(cio);
#line 86
    cio_skip(cio, 4);
#line 87
    cio_write(cio, (unsigned long long )1667851384, 4);
#line 88
    write_cptr(offset, cstr_info.codestream_size, cio);
#line 90
    write_manf(i, num_box, box, cio);
#line 92
    num_box = 0;
#line 93
    (box + num_box)->length = write_mainmhix(offset, cstr_info, cio);
#line 94
    (box + num_box)->type = 1835559288;
#line 95
    num_box ++;
#line 97
    (box + num_box)->length = write_tpix(offset, cstr_info, j2klen, cio);
#line 98
    (box + num_box)->type = 1953524088;
#line 99
    num_box ++;
#line 101
    (box + num_box)->length = write_thix(offset, cstr_info, cio);
#line 102
    (box + num_box)->type = 1952999800;
#line 103
    num_box ++;
#line 105
    EPHused = check_EPHuse(offset, cstr_info.marker, cstr_info.marknum, cio);
#line 107
    (box + num_box)->length = write_ppix(offset, cstr_info, EPHused, j2klen, cio);
#line 108
    (box + num_box)->type = 1886415224;
#line 109
    num_box ++;
#line 111
    (box + num_box)->length = write_phix(offset, cstr_info, EPHused, j2klen, cio);
#line 112
    (box + num_box)->type = 1885890936;
#line 113
    num_box ++;
#line 115
    __cil_tmp25 = cio_tell(cio);
#line 115
    len = __cil_tmp25 - lenp;
#line 116
    cio_seek(cio, lenp);
#line 117
    cio_write(cio, (unsigned long long )len, 4);
#line 118
    cio_seek(cio, lenp + len);
    }
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  free(box);
  }
#line 123
  return (len);
}
}
#line 126 "/root/patchweave_new/14/libopenjpeg/cidx_manager.c"
void write_cptr(int coff , int clen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 130
  lenp = cio_tell(cio);
#line 131
  cio_skip(cio, 4);
#line 132
  cio_write(cio, (unsigned long long )1668314226, 4);
#line 133
  cio_write(cio, (unsigned long long )0, 2);
#line 134
  cio_write(cio, (unsigned long long )0, 2);
#line 135
  cio_write(cio, (unsigned long long )coff, 8);
#line 136
  cio_write(cio, (unsigned long long )clen, 8);
#line 137
  __cil_tmp7 = cio_tell(cio);
#line 137
  len = __cil_tmp7 - lenp;
#line 138
  cio_seek(cio, lenp);
#line 139
  cio_write(cio, (unsigned long long )len, 4);
#line 140
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 143 "/root/patchweave_new/14/libopenjpeg/cidx_manager.c"
void write_manf(int second , int v , opj_jp2_box_t *box , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 147
  lenp = cio_tell(cio);
#line 148
  cio_skip(cio, 4);
#line 149
  cio_write(cio, (unsigned long long )1835101798, 4);
  }
#line 151
  if (second) {
#line 152
    i = 0;
    {
#line 152
    while (1) {
      while_continue: /* CIL Label */ ;
#line 152
      if (! (i < v)) {
#line 152
        goto while_break;
      }
      {
#line 153
      cio_write(cio, (unsigned long long )(box + i)->length, 4);
#line 154
      cio_write(cio, (unsigned long long )(box + i)->type, 4);
      }
#line 152
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 158
  __cil_tmp10 = cio_tell(cio);
#line 158
  len = __cil_tmp10 - lenp;
#line 159
  cio_seek(cio, lenp);
#line 160
  cio_write(cio, (unsigned long long )len, 4);
#line 161
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 164 "/root/patchweave_new/14/libopenjpeg/cidx_manager.c"
int write_mainmhix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) 
{ 
  int i ;
  int len ;
  int lenp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 169
  lenp = cio_tell(cio);
#line 170
  cio_skip(cio, 4);
#line 171
  cio_write(cio, (unsigned long long )1835559288, 4);
#line 173
  cio_write(cio, (unsigned long long )((cstr_info.main_head_end - cstr_info.main_head_start) + 1),
            8);
#line 175
  i = 1;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < cstr_info.marknum)) {
#line 175
      goto while_break;
    }
    {
#line 176
    cio_write(cio, (unsigned long long )(cstr_info.marker + i)->type, 2);
#line 177
    cio_write(cio, (unsigned long long )0, 2);
#line 178
    cio_write(cio, (unsigned long long )((cstr_info.marker + i)->pos - coff), 8);
#line 179
    cio_write(cio, (unsigned long long )(cstr_info.marker + i)->len, 2);
    }
#line 175
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 182
  __cil_tmp9 = cio_tell(cio);
#line 182
  len = __cil_tmp9 - lenp;
#line 183
  cio_seek(cio, lenp);
#line 184
  cio_write(cio, (unsigned long long )len, 4);
#line 185
  cio_seek(cio, lenp + len);
  }
#line 187
  return (len);
}
}
#line 190 "/root/patchweave_new/14/libopenjpeg/cidx_manager.c"
opj_bool check_EPHuse(int coff , opj_marker_info_t *markers , int marknum , opj_cio_t *cio ) 
{ 
  opj_bool EPHused ;
  int i ;
  int org_pos ;
  unsigned int Scod ;
  int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 192
  EPHused = 0;
#line 193
  i = 0;
#line 197
  i = 0;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i < marknum)) {
#line 197
      goto while_break;
    }
#line 198
    if ((int )(markers + i)->type == 65362) {
      {
#line 199
      org_pos = cio_tell(cio);
#line 200
      cio_seek(cio, (coff + (markers + i)->pos) + 2);
#line 202
      Scod = cio_read(cio, 1);
      }
#line 203
      if ((Scod >> 2) & 1U) {
#line 204
        EPHused = 1;
      }
      {
#line 205
      cio_seek(cio, org_pos);
      }
#line 207
      goto while_break;
    }
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return (EPHused);
}
}
#line 40 "/root/patchweave_new/14/libopenjpeg/tgt.c"
opj_tgt_tree_t *tgt_create(int numleafsh , int numleafsv ) 
{ 
  int nplh[32] ;
  int nplv[32] ;
  opj_tgt_node_t *node ;
  opj_tgt_node_t *parentnode ;
  opj_tgt_node_t *parentnode0 ;
  opj_tgt_tree_t *tree ;
  int i ;
  int j ;
  int k ;
  int numlvls ;
  int n ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 43
  node = (opj_tgt_node_t *)((void *)0);
#line 44
  parentnode = (opj_tgt_node_t *)((void *)0);
#line 45
  parentnode0 = (opj_tgt_node_t *)((void *)0);
#line 46
  tree = (opj_tgt_tree_t *)((void *)0);
#line 51
  __cil_tmp14 = malloc(sizeof(opj_tgt_tree_t ));
#line 51
  tree = (opj_tgt_tree_t *)__cil_tmp14;
  }
#line 52
  if (! tree) {
#line 52
    return ((opj_tgt_tree_t *)((void *)0));
  }
#line 53
  tree->numleafsh = numleafsh;
#line 54
  tree->numleafsv = numleafsv;
#line 56
  numlvls = 0;
#line 57
  nplh[0] = numleafsh;
#line 58
  nplv[0] = numleafsv;
#line 59
  tree->numnodes = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    n = nplh[numlvls] * nplv[numlvls];
#line 62
    nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
#line 63
    nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
#line 64
    tree->numnodes += n;
#line 65
    numlvls ++;
#line 60
    if (! (n > 1)) {
#line 60
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if (tree->numnodes == 0) {
    {
#line 70
    free(tree);
    }
#line 71
    return ((opj_tgt_tree_t *)((void *)0));
  }
  {
#line 74
  __cil_tmp15 = calloc((unsigned long )tree->numnodes, sizeof(opj_tgt_node_t ));
#line 74
  tree->nodes = (opj_tgt_node_t *)__cil_tmp15;
  }
#line 75
  if (! tree->nodes) {
    {
#line 76
    free(tree);
    }
#line 77
    return ((opj_tgt_tree_t *)((void *)0));
  }
#line 80
  node = tree->nodes;
#line 81
  parentnode = tree->nodes + tree->numleafsh * tree->numleafsv;
#line 82
  parentnode0 = parentnode;
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (i < numlvls - 1)) {
#line 84
      goto while_break___0;
    }
#line 85
    j = 0;
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 85
      if (! (j < nplv[i])) {
#line 85
        goto while_break___1;
      }
#line 86
      k = nplh[i];
      {
#line 87
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 87
        k --;
#line 87
        if (! (k >= 0)) {
#line 87
          goto while_break___2;
        }
#line 88
        node->parent = parentnode;
#line 89
        node ++;
#line 90
        k --;
#line 90
        if (k >= 0) {
#line 91
          node->parent = parentnode;
#line 92
          node ++;
        }
#line 94
        parentnode ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 96
      if (j & 1) {
#line 97
        parentnode0 = parentnode;
      } else
#line 96
      if (j == nplv[i] - 1) {
#line 97
        parentnode0 = parentnode;
      } else {
#line 99
        parentnode = parentnode0;
#line 100
        parentnode0 += nplh[i];
      }
#line 85
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 84
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 104
  node->parent = (struct opj_tgt_node *)0;
#line 106
  tgt_reset(tree);
  }
#line 108
  return (tree);
}
}
#line 111 "/root/patchweave_new/14/libopenjpeg/tgt.c"
void tgt_destroy(opj_tgt_tree_t *tree ) 
{ 


  {
  {
#line 112
  free(tree->nodes);
#line 113
  free(tree);
  }
  return;
}
}
#line 116 "/root/patchweave_new/14/libopenjpeg/tgt.c"
void tgt_reset(opj_tgt_tree_t *tree ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 119
  if ((void *)0 == tree) {
#line 120
    return;
  }
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i < tree->numnodes)) {
#line 122
      goto while_break;
    }
#line 123
    (tree->nodes + i)->value = 999;
#line 124
    (tree->nodes + i)->low = 0;
#line 125
    (tree->nodes + i)->known = 0;
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 129 "/root/patchweave_new/14/libopenjpeg/tgt.c"
void tgt_setvalue(opj_tgt_tree_t *tree , int leafno , int value ) 
{ 
  opj_tgt_node_t *node ;

  {
#line 131
  node = tree->nodes + leafno;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (node && node->value > value)) {
#line 132
      goto while_break;
    }
#line 133
    node->value = value;
#line 134
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 138 "/root/patchweave_new/14/libopenjpeg/tgt.c"
void tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  int low ;
  opj_tgt_node_t **__cil_tmp9 ;

  {
#line 144
  stkptr = (opj_tgt_node_t **)stk;
#line 145
  node = tree->nodes + leafno;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! node->parent) {
#line 146
      goto while_break;
    }
#line 147
    __cil_tmp9 = stkptr;
#line 147
    stkptr ++;
#line 147
    *__cil_tmp9 = node;
#line 148
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  low = 0;
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    if (! 1) {
#line 152
      goto while_break___0;
    }
#line 153
    if (low > node->low) {
#line 154
      node->low = low;
    } else {
#line 156
      low = node->low;
    }
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 159
      if (! (low < threshold)) {
#line 159
        goto while_break___1;
      }
#line 160
      if (low >= node->value) {
#line 161
        if (! node->known) {
          {
#line 162
          bio_write(bio, 1, 1);
#line 163
          node->known = 1;
          }
        }
#line 165
        goto while_break___1;
      }
      {
#line 167
      bio_write(bio, 0, 1);
#line 168
      low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 171
    node->low = low;
#line 172
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 173
      goto while_break___0;
    }
#line 174
    stkptr --;
#line 174
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 178 "/root/patchweave_new/14/libopenjpeg/tgt.c"
int tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  int low ;
  opj_tgt_node_t **__cil_tmp9 ;
  int __cil_tmp10 ;
  int tmp ;

  {
#line 184
  stkptr = (opj_tgt_node_t **)stk;
#line 185
  node = tree->nodes + leafno;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! node->parent) {
#line 186
      goto while_break;
    }
#line 187
    __cil_tmp9 = stkptr;
#line 187
    stkptr ++;
#line 187
    *__cil_tmp9 = node;
#line 188
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  low = 0;
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    if (! 1) {
#line 192
      goto while_break___0;
    }
#line 193
    if (low > node->low) {
#line 194
      node->low = low;
    } else {
#line 196
      low = node->low;
    }
    {
#line 198
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 198
      if (! (low < threshold && low < node->value)) {
#line 198
        goto while_break___1;
      }
      {
#line 199
      __cil_tmp10 = bio_read(bio, 1);
      }
#line 199
      if (__cil_tmp10) {
#line 200
        node->value = low;
      } else {
#line 202
        low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 205
    node->low = low;
#line 206
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 207
      goto while_break___0;
    }
#line 209
    stkptr --;
#line 209
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 212
  if (node->value < threshold) {
#line 212
    tmp = 1;
  } else {
#line 212
    tmp = 0;
  }
#line 212
  return (tmp);
}
}
#line 36 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 39
  fprintf(fd, "image {\n\220");
#line 40
  fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", img->tw, img->th, (tcd->image)->x0,
          (tcd->image)->x1, (tcd->image)->y0, (tcd->image)->y1);
#line 43
  tileno = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (tileno < img->th * img->tw)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tile = (tcd->tcd_image)->tiles + tileno;
#line 45
    fprintf(fd, "  tile {\n");
#line 46
    fprintf(fd, "    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\n", tile->x0, tile->y0,
            tile->x1, tile->y1, tile->numcomps);
#line 48
    compno = 0;
    }
    {
#line 48
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 48
      if (! (compno < tile->numcomps)) {
#line 48
        goto while_break___0;
      }
      {
#line 49
      tilec = tile->comps + compno;
#line 50
      fprintf(fd, "    tilec {\n");
#line 51
      fprintf(fd, "      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\n", tilec->x0,
              tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);
#line 54
      resno = 0;
      }
      {
#line 54
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 54
        if (! (resno < tilec->numresolutions)) {
#line 54
          goto while_break___1;
        }
        {
#line 55
        res = tilec->resolutions + resno;
#line 56
        fprintf(fd, "\n   res {\n");
#line 57
        fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\n\230\001",
                res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);
#line 60
        bandno = 0;
        }
        {
#line 60
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 60
          if (! (bandno < res->numbands)) {
#line 60
            goto while_break___2;
          }
          {
#line 61
          band = & res->bands[bandno];
#line 62
          fprintf(fd, "        band {\n");
#line 63
          fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\n",
                  band->x0, band->y0, band->x1, band->y1, (double )band->stepsize,
                  band->numbps);
#line 66
          precno = 0;
          }
          {
#line 66
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 66
            if (! (precno < res->pw * res->ph)) {
#line 66
              goto while_break___3;
            }
            {
#line 67
            prec = band->precincts + precno;
#line 68
            fprintf(fd, "          prec {\n");
#line 69
            fprintf(fd, "            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
                    prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
#line 82
            fprintf(fd, "          }\n");
            }
#line 66
            precno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 84
          fprintf(fd, "        }\n");
          }
#line 60
          bandno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 86
        fprintf(fd, "      }\n\220");
        }
#line 54
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 88
      fprintf(fd, "    }\n");
      }
#line 48
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 90
    fprintf(fd, "  }\n");
    }
#line 43
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  fprintf(fd, "}\n");
  }
  return;
}
}
#line 100 "/root/patchweave_new/14/libopenjpeg/tcd.c"
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) 
{ 
  opj_tcd_t *tcd ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 102
  __cil_tmp3 = malloc(sizeof(opj_tcd_t ));
#line 102
  tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 103
  if (! tcd) {
#line 103
    return ((opj_tcd_t *)((void *)0));
  }
  {
#line 104
  tcd->cinfo = cinfo;
#line 105
  __cil_tmp4 = malloc(sizeof(opj_tcd_image_t ));
#line 105
  tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp4;
  }
#line 106
  if (! tcd->tcd_image) {
    {
#line 107
    free(tcd);
    }
#line 108
    return ((opj_tcd_t *)((void *)0));
  }
#line 111
  return (tcd);
}
}
#line 117 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 118
  if (tcd) {
    {
#line 119
    free(tcd->tcd_image);
#line 120
    free(tcd);
    }
  }
  return;
}
}
#line 126 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  void *__cil_tmp11 ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  float tmp ;
  float tmp___0 ;
  int __cil_tmp23 ;
  void *__cil_tmp24 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int tmp___1 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int x0b ;
  int y0b ;
  int i ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int tmp___5 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int tmp___6 ;
  double __cil_tmp86 ;
  void *__cil_tmp87 ;
  int __cil_tmp88 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  void *__cil_tmp106 ;
  opj_tgt_tree_t *__cil_tmp107 ;
  opj_tgt_tree_t *__cil_tmp108 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  void *__cil_tmp118 ;
  void *__cil_tmp119 ;
  void *__cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  int __cil_tmp123 ;
  int __cil_tmp124 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;

  {
  {
#line 129
  tcd->image = image;
#line 130
  tcd->cp = cp;
#line 131
  (tcd->tcd_image)->tw = cp->tw;
#line 132
  (tcd->tcd_image)->th = cp->th;
#line 133
  __cil_tmp11 = malloc(sizeof(opj_tcd_tile_t ));
#line 133
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp11;
#line 135
  tileno = 0;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (tileno < 1)) {
#line 135
      goto while_break;
    }
    {
#line 136
    tcp = cp->tcps + curtileno;
#line 140
    p = curtileno % cp->tw;
#line 141
    q = curtileno / cp->tw;
#line 144
    tile = (tcd->tcd_image)->tiles;
#line 147
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 148
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 149
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 150
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 151
    tile->numcomps = image->numcomps;
#line 155
    j = 0;
    }
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 155
      if (! (j < tcp->numlayers)) {
#line 155
        goto while_break___0;
      }
#line 156
      if (tcp->rates[j]) {
#line 156
        if ((int )cp->tp_on) {
#line 156
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 156
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 156
        tmp___0 = tmp;
      } else {
#line 156
        tmp___0 = (float )0;
      }
#line 156
      tcp->rates[j] = tmp___0;
#line 171
      if (tcp->rates[j]) {
#line 172
        if (j) {
#line 172
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 173
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 172
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 175
        if (! j) {
#line 175
          if (tcp->rates[j] < (float )30) {
#line 176
            tcp->rates[j] = (float )30;
          }
        }
#line 179
        if (j == tcp->numlayers - 1) {
#line 180
          tcp->rates[j] -= (float )2;
        }
      }
#line 155
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 186
    __cil_tmp24 = malloc((unsigned long )image->numcomps * sizeof(opj_tcd_tilecomp_t ));
#line 186
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp24;
#line 187
    compno = 0;
    }
    {
#line 187
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 187
      if (! (compno < tile->numcomps)) {
#line 187
        goto while_break___1;
      }
      {
#line 188
      tccp = tcp->tccps + compno;
#line 190
      tilec = tile->comps + compno;
#line 193
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 194
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 195
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 196
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 198
      __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 198
      tilec->data = (int *)__cil_tmp31;
#line 199
      tilec->numresolutions = tccp->numresolutions;
#line 201
      __cil_tmp32 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 201
      tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp32;
#line 203
      resno = 0;
      }
      {
#line 203
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 203
        if (! (resno < tilec->numresolutions)) {
#line 203
          goto while_break___2;
        }
        {
#line 205
        levelno = (tilec->numresolutions - 1) - resno;
#line 211
        res = tilec->resolutions + resno;
#line 214
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 215
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 216
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 217
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 219
        if (resno == 0) {
#line 219
          tmp___1 = 1;
        } else {
#line 219
          tmp___1 = 3;
        }
#line 219
        res->numbands = tmp___1;
#line 221
        if (tccp->csty & 1) {
#line 222
          pdx = tccp->prcw[resno];
#line 223
          pdy = tccp->prch[resno];
        } else {
#line 225
          pdx = 15;
#line 226
          pdy = 15;
        }
        {
#line 229
        __cil_tmp54 = int_floordivpow2(res->x0, pdx);
#line 229
        tlprcxstart = __cil_tmp54 << pdx;
#line 230
        __cil_tmp55 = int_floordivpow2(res->y0, pdy);
#line 230
        tlprcystart = __cil_tmp55 << pdy;
#line 232
        __cil_tmp56 = int_ceildivpow2(res->x1, pdx);
#line 232
        brprcxend = __cil_tmp56 << pdx;
#line 233
        __cil_tmp57 = int_ceildivpow2(res->y1, pdy);
#line 233
        brprcyend = __cil_tmp57 << pdy;
#line 235
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 236
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 238
        if (resno == 0) {
#line 239
          tlcbgxstart = tlprcxstart;
#line 240
          tlcbgystart = tlprcystart;
#line 241
          brcbgxend = brprcxend;
#line 242
          brcbgyend = brprcyend;
#line 243
          cbgwidthexpn = pdx;
#line 244
          cbgheightexpn = pdy;
        } else {
          {
#line 246
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 247
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 248
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 249
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 250
          cbgwidthexpn = pdx - 1;
#line 251
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 256
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 257
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 259
        bandno = 0;
        }
        {
#line 259
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 259
          if (! (bandno < res->numbands)) {
#line 259
            goto while_break___3;
          }
#line 262
          ss = (opj_stepsize_t *)((void *)0);
#line 264
          band = & res->bands[bandno];
#line 266
          if (resno == 0) {
#line 266
            tmp___2 = 0;
          } else {
#line 266
            tmp___2 = bandno + 1;
          }
#line 266
          band->bandno = tmp___2;
#line 267
          if (band->bandno == 1 || band->bandno == 3) {
#line 267
            tmp___3 = 1;
          } else {
#line 267
            tmp___3 = 0;
          }
#line 267
          x0b = tmp___3;
#line 268
          if (band->bandno == 2 || band->bandno == 3) {
#line 268
            tmp___4 = 1;
          } else {
#line 268
            tmp___4 = 0;
          }
#line 268
          y0b = tmp___4;
#line 270
          if (band->bandno == 0) {
            {
#line 272
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 273
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 274
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 275
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 278
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 279
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 280
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 281
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 284
          if (resno == 0) {
#line 284
            tmp___5 = 0;
          } else {
#line 284
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 284
          ss = & tccp->stepsizes[tmp___5];
#line 285
          if (tccp->qmfbid == 0) {
            {
#line 285
            __cil_tmp83 = dwt_getgain_real(band->bandno);
#line 285
            tmp___6 = __cil_tmp83;
            }
          } else {
            {
#line 285
            __cil_tmp84 = dwt_getgain(band->bandno);
#line 285
            tmp___6 = __cil_tmp84;
            }
          }
          {
#line 285
          gain = tmp___6;
#line 286
          numbps = (image->comps + compno)->prec + gain;
#line 288
          __cil_tmp86 = pow(2., (double )(numbps - ss->expn));
#line 288
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp86);
#line 289
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 291
          __cil_tmp87 = malloc((unsigned long )((3 * res->pw) * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 291
          band->precincts = (opj_tcd_precinct_t *)__cil_tmp87;
#line 293
          i = 0;
          }
          {
#line 293
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 293
            if (! (i < (res->pw * res->ph) * 3)) {
#line 293
              goto while_break___4;
            }
#line 294
            (band->precincts + i)->imsbtree = (opj_tgt_tree_t *)((void *)0);
#line 295
            (band->precincts + i)->incltree = (opj_tgt_tree_t *)((void *)0);
#line 296
            (band->precincts + i)->cblks.enc = (opj_tcd_cblk_enc_t *)((void *)0);
#line 293
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 299
          precno = 0;
          {
#line 299
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 299
            if (! (precno < res->pw * res->ph)) {
#line 299
              goto while_break___5;
            }
            {
#line 302
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 303
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 304
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 305
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 307
            prc = band->precincts + precno;
#line 310
            prc->x0 = int_max(cbgxstart, band->x0);
#line 311
            prc->y0 = int_max(cbgystart, band->y0);
#line 312
            prc->x1 = int_min(cbgxend, band->x1);
#line 313
            prc->y1 = int_min(cbgyend, band->y1);
#line 315
            __cil_tmp102 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 315
            tlcblkxstart = __cil_tmp102 << cblkwidthexpn;
#line 316
            __cil_tmp103 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 316
            tlcblkystart = __cil_tmp103 << cblkheightexpn;
#line 317
            __cil_tmp104 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 317
            brcblkxend = __cil_tmp104 << cblkwidthexpn;
#line 318
            __cil_tmp105 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 318
            brcblkyend = __cil_tmp105 << cblkheightexpn;
#line 319
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 320
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 322
            __cil_tmp106 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 322
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp106;
#line 323
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 324
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 326
            cblkno = 0;
            }
            {
#line 326
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 326
              if (! (cblkno < prc->cw * prc->ch)) {
#line 326
                goto while_break___6;
              }
              {
#line 327
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 328
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 329
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 330
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 332
              cblk = prc->cblks.enc + cblkno;
#line 335
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 336
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 337
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 338
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 339
              __cil_tmp118 = calloc((unsigned long )9730, sizeof(unsigned char ));
#line 339
              cblk->data = (unsigned char *)__cil_tmp118;
#line 341
              *(cblk->data + 0) = (unsigned char )0;
#line 342
              *(cblk->data + 1) = (unsigned char )0;
#line 343
              cblk->data += 2;
#line 344
              __cil_tmp119 = calloc((unsigned long )100, sizeof(opj_tcd_layer_t ));
#line 344
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp119;
#line 345
              __cil_tmp120 = calloc((unsigned long )100, sizeof(opj_tcd_pass_t ));
#line 345
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp120;
              }
#line 326
              cblkno ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 299
            precno ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 259
          bandno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 203
        resno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 187
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 135
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 356 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_free_encode(opj_tcd_t *tcd ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 359
  tileno = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (tileno < 1)) {
#line 359
      goto while_break;
    }
#line 360
    tile = (tcd->tcd_image)->tiles;
#line 362
    compno = 0;
    {
#line 362
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 362
      if (! (compno < tile->numcomps)) {
#line 362
        goto while_break___0;
      }
#line 363
      tilec = tile->comps + compno;
#line 365
      resno = 0;
      {
#line 365
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 365
        if (! (resno < tilec->numresolutions)) {
#line 365
          goto while_break___1;
        }
#line 366
        res = tilec->resolutions + resno;
#line 368
        bandno = 0;
        {
#line 368
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 368
          if (! (bandno < res->numbands)) {
#line 368
            goto while_break___2;
          }
#line 369
          band = & res->bands[bandno];
#line 371
          precno = 0;
          {
#line 371
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 371
            if (! (precno < res->pw * res->ph)) {
#line 371
              goto while_break___3;
            }
#line 372
            prc = band->precincts + precno;
#line 374
            if (prc->incltree != (void *)0) {
              {
#line 375
              tgt_destroy(prc->incltree);
#line 376
              prc->incltree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 378
            if (prc->imsbtree != (void *)0) {
              {
#line 379
              tgt_destroy(prc->imsbtree);
#line 380
              prc->imsbtree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 382
            cblkno = 0;
            {
#line 382
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 382
              if (! (cblkno < prc->cw * prc->ch)) {
#line 382
                goto while_break___4;
              }
              {
#line 383
              free((prc->cblks.enc + cblkno)->data - 2);
#line 384
              free((prc->cblks.enc + cblkno)->layers);
#line 385
              free((prc->cblks.enc + cblkno)->passes);
              }
#line 382
              cblkno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 387
            free(prc->cblks.enc);
            }
#line 371
            precno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 389
          free(band->precincts);
#line 390
          band->precincts = (opj_tcd_precinct_t *)((void *)0);
          }
#line 368
          bandno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 365
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 393
      free(tilec->resolutions);
#line 394
      tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
      }
#line 362
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 396
    free(tile->comps);
#line 397
    tile->comps = (opj_tcd_tilecomp_t *)((void *)0);
    }
#line 359
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 399
  free((tcd->tcd_image)->tiles);
#line 400
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)((void *)0);
  }
  return;
}
}
#line 403 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  float tmp ;
  float tmp___0 ;
  int __cil_tmp22 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int tmp___1 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int tmp___5 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int tmp___6 ;
  double __cil_tmp82 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  void *__cil_tmp100 ;
  opj_tgt_tree_t *__cil_tmp101 ;
  opj_tgt_tree_t *__cil_tmp102 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  void *__cil_tmp112 ;
  void *__cil_tmp113 ;
  void *__cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  int __cil_tmp118 ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;

  {
#line 406
  tileno = 0;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! (tileno < 1)) {
#line 406
      goto while_break;
    }
    {
#line 407
    tcp = cp->tcps + curtileno;
#line 410
    p = curtileno % cp->tw;
#line 411
    q = curtileno / cp->tw;
#line 413
    tile = (tcd->tcd_image)->tiles;
#line 416
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 417
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 418
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 419
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 421
    tile->numcomps = image->numcomps;
#line 425
    j = 0;
    }
    {
#line 425
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 425
      if (! (j < tcp->numlayers)) {
#line 425
        goto while_break___0;
      }
#line 426
      if (tcp->rates[j]) {
#line 426
        if ((int )cp->tp_on) {
#line 426
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 426
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 426
        tmp___0 = tmp;
      } else {
#line 426
        tmp___0 = (float )0;
      }
#line 426
      tcp->rates[j] = tmp___0;
#line 441
      if (tcp->rates[j]) {
#line 442
        if (j) {
#line 442
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 443
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 442
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 445
        if (! j) {
#line 445
          if (tcp->rates[j] < (float )30) {
#line 446
            tcp->rates[j] = (float )30;
          }
        }
      }
#line 425
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    compno = 0;
    {
#line 453
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 453
      if (! (compno < tile->numcomps)) {
#line 453
        goto while_break___1;
      }
      {
#line 454
      tccp = tcp->tccps + compno;
#line 456
      tilec = tile->comps + compno;
#line 459
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 460
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 461
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 462
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 464
      __cil_tmp29 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 464
      tilec->data = (int *)__cil_tmp29;
#line 465
      tilec->numresolutions = tccp->numresolutions;
#line 467
      resno = 0;
      }
      {
#line 467
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 467
        if (! (resno < tilec->numresolutions)) {
#line 467
          goto while_break___2;
        }
        {
#line 470
        levelno = (tilec->numresolutions - 1) - resno;
#line 476
        res = tilec->resolutions + resno;
#line 479
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 480
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 481
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 482
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 483
        if (resno == 0) {
#line 483
          tmp___1 = 1;
        } else {
#line 483
          tmp___1 = 3;
        }
#line 483
        res->numbands = tmp___1;
#line 486
        if (tccp->csty & 1) {
#line 487
          pdx = tccp->prcw[resno];
#line 488
          pdy = tccp->prch[resno];
        } else {
#line 490
          pdx = 15;
#line 491
          pdy = 15;
        }
        {
#line 494
        __cil_tmp51 = int_floordivpow2(res->x0, pdx);
#line 494
        tlprcxstart = __cil_tmp51 << pdx;
#line 495
        __cil_tmp52 = int_floordivpow2(res->y0, pdy);
#line 495
        tlprcystart = __cil_tmp52 << pdy;
#line 496
        __cil_tmp53 = int_ceildivpow2(res->x1, pdx);
#line 496
        brprcxend = __cil_tmp53 << pdx;
#line 497
        __cil_tmp54 = int_ceildivpow2(res->y1, pdy);
#line 497
        brprcyend = __cil_tmp54 << pdy;
#line 499
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 500
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 502
        if (resno == 0) {
#line 503
          tlcbgxstart = tlprcxstart;
#line 504
          tlcbgystart = tlprcystart;
#line 505
          brcbgxend = brprcxend;
#line 506
          brcbgyend = brprcyend;
#line 507
          cbgwidthexpn = pdx;
#line 508
          cbgheightexpn = pdy;
        } else {
          {
#line 510
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 511
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 512
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 513
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 514
          cbgwidthexpn = pdx - 1;
#line 515
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 520
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 521
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 523
        bandno = 0;
        }
        {
#line 523
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 523
          if (! (bandno < res->numbands)) {
#line 523
            goto while_break___3;
          }
#line 526
          ss = (opj_stepsize_t *)((void *)0);
#line 528
          band = & res->bands[bandno];
#line 530
          if (resno == 0) {
#line 530
            tmp___2 = 0;
          } else {
#line 530
            tmp___2 = bandno + 1;
          }
#line 530
          band->bandno = tmp___2;
#line 531
          if (band->bandno == 1 || band->bandno == 3) {
#line 531
            tmp___3 = 1;
          } else {
#line 531
            tmp___3 = 0;
          }
#line 531
          x0b = tmp___3;
#line 532
          if (band->bandno == 2 || band->bandno == 3) {
#line 532
            tmp___4 = 1;
          } else {
#line 532
            tmp___4 = 0;
          }
#line 532
          y0b = tmp___4;
#line 534
          if (band->bandno == 0) {
            {
#line 536
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 537
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 538
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 539
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 541
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 542
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 543
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 544
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 547
          if (resno == 0) {
#line 547
            tmp___5 = 0;
          } else {
#line 547
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 547
          ss = & tccp->stepsizes[tmp___5];
#line 548
          if (tccp->qmfbid == 0) {
            {
#line 548
            __cil_tmp79 = dwt_getgain_real(band->bandno);
#line 548
            tmp___6 = __cil_tmp79;
            }
          } else {
            {
#line 548
            __cil_tmp80 = dwt_getgain(band->bandno);
#line 548
            tmp___6 = __cil_tmp80;
            }
          }
          {
#line 548
          gain = tmp___6;
#line 549
          numbps = (image->comps + compno)->prec + gain;
#line 550
          __cil_tmp82 = pow(2., (double )(numbps - ss->expn));
#line 550
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp82);
#line 551
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 553
          precno = 0;
          }
          {
#line 553
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 553
            if (! (precno < res->pw * res->ph)) {
#line 553
              goto while_break___4;
            }
            {
#line 556
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 557
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 558
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 559
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 561
            prc = band->precincts + precno;
#line 564
            prc->x0 = int_max(cbgxstart, band->x0);
#line 565
            prc->y0 = int_max(cbgystart, band->y0);
#line 566
            prc->x1 = int_min(cbgxend, band->x1);
#line 567
            prc->y1 = int_min(cbgyend, band->y1);
#line 569
            __cil_tmp96 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 569
            tlcblkxstart = __cil_tmp96 << cblkwidthexpn;
#line 570
            __cil_tmp97 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 570
            tlcblkystart = __cil_tmp97 << cblkheightexpn;
#line 571
            __cil_tmp98 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 571
            brcblkxend = __cil_tmp98 << cblkwidthexpn;
#line 572
            __cil_tmp99 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 572
            brcblkyend = __cil_tmp99 << cblkheightexpn;
#line 573
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 574
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 576
            free(prc->cblks.enc);
#line 577
            __cil_tmp100 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 577
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp100;
            }
#line 579
            if (prc->incltree != (void *)0) {
              {
#line 580
              tgt_destroy(prc->incltree);
              }
            }
#line 582
            if (prc->imsbtree != (void *)0) {
              {
#line 583
              tgt_destroy(prc->imsbtree);
              }
            }
            {
#line 586
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 587
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 589
            cblkno = 0;
            }
            {
#line 589
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 589
              if (! (cblkno < prc->cw * prc->ch)) {
#line 589
                goto while_break___5;
              }
              {
#line 590
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 591
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 592
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 593
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 595
              cblk = prc->cblks.enc + cblkno;
#line 598
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 599
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 600
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 601
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 602
              __cil_tmp112 = calloc((unsigned long )8194, sizeof(unsigned char ));
#line 602
              cblk->data = (unsigned char *)__cil_tmp112;
#line 604
              *(cblk->data + 0) = (unsigned char )0;
#line 605
              *(cblk->data + 1) = (unsigned char )0;
#line 606
              cblk->data += 2;
#line 607
              __cil_tmp113 = calloc((unsigned long )100, sizeof(opj_tcd_layer_t ));
#line 607
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp113;
#line 608
              __cil_tmp114 = calloc((unsigned long )100, sizeof(opj_tcd_pass_t ));
#line 608
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp114;
              }
#line 589
              cblkno ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 553
            precno ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 523
          bandno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 467
        resno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 453
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 406
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 619 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int p ;
  int q ;
  unsigned int x0 ;
  unsigned int y0___0 ;
  unsigned int x1 ;
  unsigned int y1___0 ;
  unsigned int w ;
  unsigned int h ;
  void *__cil_tmp15 ;
  opj_tcd_tile_t *tile ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  opj_tcd_tile_t *tile___0 ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int tmp ;
  int __cil_tmp31 ;
  int tmp___0 ;
  int __cil_tmp33 ;
  int tmp___1 ;
  int __cil_tmp35 ;
  int tmp___2 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;

  {
#line 621
  x0 = (unsigned int )0;
#line 621
  y0___0 = (unsigned int )0;
#line 621
  x1 = (unsigned int )0;
  {
#line 621
  y1___0 = (unsigned int )0;
#line 623
  tcd->image = image;
#line 624
  (tcd->tcd_image)->tw = cp->tw;
#line 625
  (tcd->tcd_image)->th = cp->th;
#line 626
  __cil_tmp15 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcd_tile_t ));
#line 626
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp15;
#line 633
  j = 0;
  }
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 633
    if (! (j < cp->tileno_size)) {
#line 633
      goto while_break;
    }
    {
#line 636
    tileno = *(cp->tileno + j);
#line 637
    tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 638
    tile->numcomps = image->numcomps;
#line 639
    __cil_tmp17 = calloc((unsigned long )image->numcomps, sizeof(opj_tcd_tilecomp_t ));
#line 639
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp17;
    }
#line 633
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  i = 0;
  {
#line 642
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 642
    if (! (i < image->numcomps)) {
#line 642
      goto while_break___0;
    }
#line 643
    j = 0;
    {
#line 643
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 643
      if (! (j < cp->tileno_size)) {
#line 643
        goto while_break___1;
      }
      {
#line 649
      tileno = *(cp->tileno + j);
#line 651
      tile___0 = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 652
      tilec = tile___0->comps + i;
#line 654
      p = tileno % cp->tw;
#line 655
      q = tileno / cp->tw;
#line 658
      tile___0->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 659
      tile___0->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 660
      tile___0->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 661
      tile___0->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 663
      tilec->x0 = int_ceildiv(tile___0->x0, (image->comps + i)->dx);
#line 664
      tilec->y0 = int_ceildiv(tile___0->y0, (image->comps + i)->dy);
#line 665
      tilec->x1 = int_ceildiv(tile___0->x1, (image->comps + i)->dx);
#line 666
      tilec->y1 = int_ceildiv(tile___0->y1, (image->comps + i)->dy);
      }
#line 668
      if (j == 0) {
#line 668
        tmp = tilec->x0;
      } else {
        {
#line 668
        __cil_tmp29 = int_min((int )x0, (int )((unsigned int )tilec->x0));
#line 668
        tmp = __cil_tmp29;
        }
      }
#line 668
      x0 = (unsigned int )tmp;
#line 669
      if (j == 0) {
#line 669
        tmp___0 = tilec->y0;
      } else {
        {
#line 669
        __cil_tmp31 = int_min((int )y0___0, (int )((unsigned int )tilec->y0));
#line 669
        tmp___0 = __cil_tmp31;
        }
      }
#line 669
      y0___0 = (unsigned int )tmp___0;
#line 670
      if (j == 0) {
#line 670
        tmp___1 = tilec->x1;
      } else {
        {
#line 670
        __cil_tmp33 = int_max((int )x1, (int )((unsigned int )tilec->x1));
#line 670
        tmp___1 = __cil_tmp33;
        }
      }
#line 670
      x1 = (unsigned int )tmp___1;
#line 671
      if (j == 0) {
#line 671
        tmp___2 = tilec->y1;
      } else {
        {
#line 671
        __cil_tmp35 = int_max((int )y1___0, (int )((unsigned int )tilec->y1));
#line 671
        tmp___2 = __cil_tmp35;
        }
      }
#line 671
      y1___0 = (unsigned int )tmp___2;
#line 643
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 674
    __cil_tmp38 = int_ceildivpow2((int )(x1 - x0), (image->comps + i)->factor);
#line 674
    w = (unsigned int )__cil_tmp38;
#line 675
    __cil_tmp39 = int_ceildivpow2((int )(y1___0 - y0___0), (image->comps + i)->factor);
#line 675
    h = (unsigned int )__cil_tmp39;
#line 677
    (image->comps + i)->w = (int )w;
#line 678
    (image->comps + i)->h = (int )h;
#line 679
    (image->comps + i)->x0 = (int )x0;
#line 680
    (image->comps + i)->y0 = (int )y0___0;
    }
#line 642
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 684 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  opj_tcd_tile_t *tile ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int tmp ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int tmp___5 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int tmp___6 ;
  double __cil_tmp74 ;
  void *__cil_tmp75 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  void *__cil_tmp93 ;
  opj_tgt_tree_t *__cil_tmp94 ;
  opj_tgt_tree_t *__cil_tmp95 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;

  {
#line 691
  tcd->cp = cp;
#line 693
  tcp = cp->tcps + *(cp->tileno + tileno);
#line 694
  tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 696
  tileno = *(cp->tileno + tileno);
#line 698
  compno = 0;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! (compno < tile->numcomps)) {
#line 698
      goto while_break;
    }
#line 699
    tccp = tcp->tccps + compno;
#line 700
    tilec = tile->comps + compno;
#line 702
    if (tccp->numresolutions <= 0) {
#line 704
      *(cp->tileno + tileno) = - 1;
#line 705
      return;
    }
    {
#line 709
    tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 710
    tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 711
    tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 712
    tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 714
    tilec->numresolutions = tccp->numresolutions;
#line 715
    __cil_tmp19 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 715
    tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp19;
#line 717
    resno = 0;
    }
    {
#line 717
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 717
      if (! (resno < tilec->numresolutions)) {
#line 717
        goto while_break___0;
      }
      {
#line 719
      levelno = (tilec->numresolutions - 1) - resno;
#line 725
      res = tilec->resolutions + resno;
#line 728
      res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 729
      res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 730
      res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 731
      res->y1 = int_ceildivpow2(tilec->y1, levelno);
      }
#line 732
      if (resno == 0) {
#line 732
        tmp = 1;
      } else {
#line 732
        tmp = 3;
      }
#line 732
      res->numbands = tmp;
#line 735
      if (tccp->csty & 1) {
#line 736
        pdx = tccp->prcw[resno];
#line 737
        pdy = tccp->prch[resno];
      } else {
#line 739
        pdx = 15;
#line 740
        pdy = 15;
      }
      {
#line 744
      __cil_tmp41 = int_floordivpow2(res->x0, pdx);
#line 744
      tlprcxstart = __cil_tmp41 << pdx;
#line 745
      __cil_tmp42 = int_floordivpow2(res->y0, pdy);
#line 745
      tlprcystart = __cil_tmp42 << pdy;
#line 746
      __cil_tmp43 = int_ceildivpow2(res->x1, pdx);
#line 746
      brprcxend = __cil_tmp43 << pdx;
#line 747
      __cil_tmp44 = int_ceildivpow2(res->y1, pdy);
#line 747
      brprcyend = __cil_tmp44 << pdy;
      }
#line 749
      if (res->x0 == res->x1) {
#line 749
        tmp___0 = 0;
      } else {
#line 749
        tmp___0 = (brprcxend - tlprcxstart) >> pdx;
      }
#line 749
      res->pw = tmp___0;
#line 750
      if (res->y0 == res->y1) {
#line 750
        tmp___1 = 0;
      } else {
#line 750
        tmp___1 = (brprcyend - tlprcystart) >> pdy;
      }
#line 750
      res->ph = tmp___1;
#line 752
      if (resno == 0) {
#line 753
        tlcbgxstart = tlprcxstart;
#line 754
        tlcbgystart = tlprcystart;
#line 755
        brcbgxend = brprcxend;
#line 756
        brcbgyend = brprcyend;
#line 757
        cbgwidthexpn = pdx;
#line 758
        cbgheightexpn = pdy;
      } else {
        {
#line 760
        tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 761
        tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 762
        brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 763
        brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 764
        cbgwidthexpn = pdx - 1;
#line 765
        cbgheightexpn = pdy - 1;
        }
      }
      {
#line 770
      cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 771
      cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 773
      bandno = 0;
      }
      {
#line 773
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 773
        if (! (bandno < res->numbands)) {
#line 773
          goto while_break___1;
        }
#line 776
        ss = (opj_stepsize_t *)((void *)0);
#line 778
        band = & res->bands[bandno];
#line 779
        if (resno == 0) {
#line 779
          tmp___2 = 0;
        } else {
#line 779
          tmp___2 = bandno + 1;
        }
#line 779
        band->bandno = tmp___2;
#line 780
        if (band->bandno == 1 || band->bandno == 3) {
#line 780
          tmp___3 = 1;
        } else {
#line 780
          tmp___3 = 0;
        }
#line 780
        x0b = tmp___3;
#line 781
        if (band->bandno == 2 || band->bandno == 3) {
#line 781
          tmp___4 = 1;
        } else {
#line 781
          tmp___4 = 0;
        }
#line 781
        y0b = tmp___4;
#line 783
        if (band->bandno == 0) {
          {
#line 785
          band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 786
          band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 787
          band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 788
          band->y1 = int_ceildivpow2(tilec->y1, levelno);
          }
        } else {
          {
#line 791
          band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 792
          band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 793
          band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 794
          band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
          }
        }
#line 797
        if (resno == 0) {
#line 797
          tmp___5 = 0;
        } else {
#line 797
          tmp___5 = (3 * (resno - 1) + bandno) + 1;
        }
#line 797
        ss = & tccp->stepsizes[tmp___5];
#line 798
        if (tccp->qmfbid == 0) {
          {
#line 798
          __cil_tmp71 = dwt_getgain_real(band->bandno);
#line 798
          tmp___6 = __cil_tmp71;
          }
        } else {
          {
#line 798
          __cil_tmp72 = dwt_getgain(band->bandno);
#line 798
          tmp___6 = __cil_tmp72;
          }
        }
        {
#line 798
        gain = tmp___6;
#line 799
        numbps = (image->comps + compno)->prec + gain;
#line 800
        __cil_tmp74 = pow(2., (double )(numbps - ss->expn));
#line 800
        band->stepsize = (float )(((1. + (double )ss->mant / 2048.) * __cil_tmp74) * 0.5);
#line 801
        band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 803
        __cil_tmp75 = malloc((unsigned long )(res->pw * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 803
        band->precincts = (opj_tcd_precinct_t *)__cil_tmp75;
#line 805
        precno = 0;
        }
        {
#line 805
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 805
          if (! (precno < res->pw * res->ph)) {
#line 805
            goto while_break___2;
          }
          {
#line 807
          cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 808
          cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 809
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 810
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 812
          prc = band->precincts + precno;
#line 814
          prc->x0 = int_max(cbgxstart, band->x0);
#line 815
          prc->y0 = int_max(cbgystart, band->y0);
#line 816
          prc->x1 = int_min(cbgxend, band->x1);
#line 817
          prc->y1 = int_min(cbgyend, band->y1);
#line 819
          __cil_tmp89 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 819
          tlcblkxstart = __cil_tmp89 << cblkwidthexpn;
#line 820
          __cil_tmp90 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 820
          tlcblkystart = __cil_tmp90 << cblkheightexpn;
#line 821
          __cil_tmp91 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 821
          brcblkxend = __cil_tmp91 << cblkwidthexpn;
#line 822
          __cil_tmp92 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 822
          brcblkyend = __cil_tmp92 << cblkheightexpn;
#line 823
          prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 824
          prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 826
          __cil_tmp93 = malloc((unsigned long )(prc->cw * prc->ch) * sizeof(opj_tcd_cblk_dec_t ));
#line 826
          prc->cblks.dec = (opj_tcd_cblk_dec_t *)__cil_tmp93;
#line 828
          prc->incltree = tgt_create(prc->cw, prc->ch);
#line 829
          prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 831
          cblkno = 0;
          }
          {
#line 831
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 831
            if (! (cblkno < prc->cw * prc->ch)) {
#line 831
              goto while_break___3;
            }
            {
#line 832
            cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 833
            cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 834
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 835
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 837
            cblk = prc->cblks.dec + cblkno;
#line 838
            cblk->data = (unsigned char *)((void *)0);
#line 839
            cblk->segs = (opj_tcd_seg_t *)((void *)0);
#line 841
            cblk->x0 = int_max(cblkxstart, prc->x0);
#line 842
            cblk->y0 = int_max(cblkystart, prc->y0);
#line 843
            cblk->x1 = int_min(cblkxend, prc->x1);
#line 844
            cblk->y1 = int_min(cblkyend, prc->y1);
#line 845
            cblk->numsegs = 0;
            }
#line 831
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 805
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 773
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 717
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 698
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 854 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int value ;
  int matrice[10][10][3] ;
  int i ;
  int j ;
  int k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int imsb ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 860
  cp = tcd->cp;
#line 861
  tcd_tile = tcd->tcd_tile;
#line 862
  tcd_tcp = tcd->tcp;
#line 866
  compno = 0;
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! (compno < tcd_tile->numcomps)) {
#line 866
      goto while_break;
    }
#line 867
    tilec = tcd_tile->comps + compno;
#line 868
    i = 0;
    {
#line 868
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 868
      if (! (i < tcd_tcp->numlayers)) {
#line 868
        goto while_break___0;
      }
#line 869
      j = 0;
      {
#line 869
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 869
        if (! (j < tilec->numresolutions)) {
#line 869
          goto while_break___1;
        }
#line 870
        k = 0;
        {
#line 870
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 870
          if (! (k < 3)) {
#line 870
            goto while_break___2;
          }
#line 871
          matrice[i][j][k] = (int )((float )*(cp->matrice + (((i * tilec->numresolutions) * 3 + j * 3) + k)) * (float )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 870
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 869
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 868
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 878
    resno = 0;
    {
#line 878
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 878
      if (! (resno < tilec->numresolutions)) {
#line 878
        goto while_break___3;
      }
#line 879
      res = tilec->resolutions + resno;
#line 880
      bandno = 0;
      {
#line 880
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 880
        if (! (bandno < res->numbands)) {
#line 880
          goto while_break___4;
        }
#line 881
        band = & res->bands[bandno];
#line 882
        precno = 0;
        {
#line 882
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 882
          if (! (precno < res->pw * res->ph)) {
#line 882
            goto while_break___5;
          }
#line 883
          prc = band->precincts + precno;
#line 884
          cblkno = 0;
          {
#line 884
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 884
            if (! (cblkno < prc->cw * prc->ch)) {
#line 884
              goto while_break___6;
            }
#line 885
            cblk = prc->cblks.enc + cblkno;
#line 886
            layer = cblk->layers + layno;
#line 888
            imsb = ((tcd->image)->comps + compno)->prec - cblk->numbps;
#line 890
            if (layno == 0) {
#line 891
              value = matrice[layno][resno][bandno];
#line 892
              if (imsb >= value) {
#line 893
                value = 0;
              } else {
#line 895
                value -= imsb;
              }
            } else {
#line 898
              value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];
#line 899
              if (imsb >= matrice[layno - 1][resno][bandno]) {
#line 900
                value -= imsb - matrice[layno - 1][resno][bandno];
#line 901
                if (value < 0) {
#line 902
                  value = 0;
                }
              }
            }
#line 907
            if (layno == 0) {
#line 908
              cblk->numpassesinlayers = 0;
            }
#line 911
            n = cblk->numpassesinlayers;
#line 912
            if (cblk->numpassesinlayers == 0) {
#line 913
              if (value != 0) {
#line 914
                n = (3 * value - 2) + cblk->numpassesinlayers;
              } else {
#line 916
                n = cblk->numpassesinlayers;
              }
            } else {
#line 919
              n = 3 * value + cblk->numpassesinlayers;
            }
#line 922
            layer->numpasses = n - cblk->numpassesinlayers;
#line 924
            if (! layer->numpasses) {
#line 925
              goto while_continue___6;
            }
#line 927
            if (cblk->numpassesinlayers == 0) {
#line 928
              layer->len = (cblk->passes + (n - 1))->rate;
#line 929
              layer->data = cblk->data;
            } else {
#line 931
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 932
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
            }
#line 934
            if (final) {
#line 935
              cblk->numpassesinlayers = n;
            }
#line 884
            cblkno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 882
          precno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 880
        bandno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 878
      resno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 866
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 943 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  int layno ;
  int __cil_tmp3 ;

  {
#line 945
  layno = 0;
  {
#line 945
  while (1) {
    while_continue: /* CIL Label */ ;
#line 945
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 945
      goto while_break;
    }
    {
#line 946
    tcd_makelayer_fixed(tcd, layno, 1);
    }
#line 945
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 950 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int dr ;
  double dd ;
  opj_tcd_pass_t *pass ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;

  {
#line 953
  tcd_tile = tcd->tcd_tile;
#line 955
  tcd_tile->distolayer[layno] = (double )0;
#line 957
  compno = 0;
  {
#line 957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 957
    if (! (compno < tcd_tile->numcomps)) {
#line 957
      goto while_break;
    }
#line 958
    tilec = tcd_tile->comps + compno;
#line 959
    resno = 0;
    {
#line 959
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 959
      if (! (resno < tilec->numresolutions)) {
#line 959
        goto while_break___0;
      }
#line 960
      res = tilec->resolutions + resno;
#line 961
      bandno = 0;
      {
#line 961
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 961
        if (! (bandno < res->numbands)) {
#line 961
          goto while_break___1;
        }
#line 962
        band = & res->bands[bandno];
#line 963
        precno = 0;
        {
#line 963
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 963
          if (! (precno < res->pw * res->ph)) {
#line 963
            goto while_break___2;
          }
#line 964
          prc = band->precincts + precno;
#line 965
          cblkno = 0;
          {
#line 965
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 965
            if (! (cblkno < prc->cw * prc->ch)) {
#line 965
              goto while_break___3;
            }
#line 966
            cblk = prc->cblks.enc + cblkno;
#line 967
            layer = cblk->layers + layno;
#line 970
            if (layno == 0) {
#line 971
              cblk->numpassesinlayers = 0;
            }
#line 973
            n = cblk->numpassesinlayers;
#line 974
            passno = cblk->numpassesinlayers;
            {
#line 974
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 974
              if (! (passno < cblk->totalpasses)) {
#line 974
                goto while_break___4;
              }
#line 977
              pass = cblk->passes + passno;
#line 978
              if (n == 0) {
#line 979
                dr = pass->rate;
#line 980
                dd = pass->distortiondec;
              } else {
#line 982
                dr = pass->rate - (cblk->passes + (n - 1))->rate;
#line 983
                dd = pass->distortiondec - (cblk->passes + (n - 1))->distortiondec;
              }
#line 985
              if (! dr) {
#line 986
                if (dd != (double )0) {
#line 987
                  n = passno + 1;
                }
#line 988
                goto while_continue___4;
              }
#line 990
              if (dd / (double )dr >= thresh) {
#line 991
                n = passno + 1;
              }
#line 974
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 993
            layer->numpasses = n - cblk->numpassesinlayers;
#line 995
            if (! layer->numpasses) {
#line 996
              layer->disto = (double )0;
#line 997
              goto while_continue___3;
            }
#line 999
            if (cblk->numpassesinlayers == 0) {
#line 1000
              layer->len = (cblk->passes + (n - 1))->rate;
#line 1001
              layer->data = cblk->data;
#line 1002
              layer->disto = (cblk->passes + (n - 1))->distortiondec;
            } else {
#line 1004
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 1005
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 1006
              layer->disto = (cblk->passes + (n - 1))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1))->distortiondec;
            }
#line 1009
            tcd_tile->distolayer[layno] += layer->disto;
#line 1011
            if (final) {
#line 1012
              cblk->numpassesinlayers = n;
            }
#line 965
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 963
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 961
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 959
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 957
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1020 "/root/patchweave_new/14/libopenjpeg/tcd.c"
opj_bool tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  int layno ;
  double min ;
  double max ;
  double cumdisto[100] ;
  double K___0 ;
  double maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  int dr ;
  double dd ;
  double rdslope ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp36 ;
  double lo ;
  double hi ;
  int success ;
  int maxlen ;
  double __cil_tmp41 ;
  int __cil_tmp42 ;
  int tmp ;
  double goodthresh ;
  double stable_thresh ;
  int i ;
  double distotarget ;
  double __cil_tmp48 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp50 ;
  double thresh ;
  int l ;
  double distoachieved ;
  int __cil_tmp54 ;
  double tmp___0 ;
  double tmp___1 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  double tmp___2 ;
  double tmp___3 ;
  int __cil_tmp61 ;

  {
#line 1024
  K___0 = (double )1;
#line 1025
  maxSE = (double )0;
#line 1027
  cp = tcd->cp;
#line 1028
  tcd_tile = tcd->tcd_tile;
#line 1029
  tcd_tcp = tcd->tcp;
#line 1031
  min = (double )1.79769313487e+308L;
#line 1032
  max = (double )0;
#line 1034
  tcd_tile->numpix = 0;
#line 1036
  compno = 0;
  {
#line 1036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1036
    if (! (compno < tcd_tile->numcomps)) {
#line 1036
      goto while_break;
    }
#line 1037
    tilec = tcd_tile->comps + compno;
#line 1038
    tilec->numpix = 0;
#line 1040
    resno = 0;
    {
#line 1040
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1040
      if (! (resno < tilec->numresolutions)) {
#line 1040
        goto while_break___0;
      }
#line 1041
      res = tilec->resolutions + resno;
#line 1043
      bandno = 0;
      {
#line 1043
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1043
        if (! (bandno < res->numbands)) {
#line 1043
          goto while_break___1;
        }
#line 1044
        band = & res->bands[bandno];
#line 1046
        precno = 0;
        {
#line 1046
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1046
          if (! (precno < res->pw * res->ph)) {
#line 1046
            goto while_break___2;
          }
#line 1047
          prc = band->precincts + precno;
#line 1049
          cblkno = 0;
          {
#line 1049
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1049
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1049
              goto while_break___3;
            }
#line 1050
            cblk = prc->cblks.enc + cblkno;
#line 1052
            passno = 0;
            {
#line 1052
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1052
              if (! (passno < cblk->totalpasses)) {
#line 1052
                goto while_break___4;
              }
#line 1053
              pass = cblk->passes + passno;
#line 1056
              if (passno == 0) {
#line 1057
                dr = pass->rate;
#line 1058
                dd = pass->distortiondec;
              } else {
#line 1060
                dr = pass->rate - (cblk->passes + (passno - 1))->rate;
#line 1061
                dd = pass->distortiondec - (cblk->passes + (passno - 1))->distortiondec;
              }
#line 1063
              if (dr == 0) {
#line 1064
                goto while_continue___4;
              }
#line 1066
              rdslope = dd / (double )dr;
#line 1067
              if (rdslope < min) {
#line 1068
                min = rdslope;
              }
#line 1070
              if (rdslope > max) {
#line 1071
                max = rdslope;
              }
#line 1052
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1076
            tcd_tile->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1077
            tilec->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1049
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1046
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1043
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1040
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1083
    maxSE += (((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (double )tilec->numpix;
#line 1036
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1089
  if (cstr_info) {
    {
#line 1090
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 1091
    tile_info->numpix = tcd_tile->numpix;
#line 1092
    tile_info->distotile = tcd_tile->distotile;
#line 1093
    __cil_tmp36 = malloc((unsigned long )tcd_tcp->numlayers * sizeof(double ));
#line 1093
    tile_info->thresh = (double *)__cil_tmp36;
    }
  }
#line 1096
  layno = 0;
  {
#line 1096
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1096
    if (! (layno < tcd_tcp->numlayers)) {
#line 1096
      goto while_break___5;
    }
#line 1097
    lo = min;
#line 1098
    hi = max;
#line 1099
    success = 0;
#line 1100
    if (tcd_tcp->rates[layno]) {
      {
#line 1100
      __cil_tmp41 = ceil((double )tcd_tcp->rates[layno]);
#line 1100
      __cil_tmp42 = int_min((int )__cil_tmp41, len);
#line 1100
      tmp = __cil_tmp42;
      }
    } else {
#line 1100
      tmp = len;
    }
    {
#line 1100
    maxlen = tmp;
#line 1101
    goodthresh = (double )0;
#line 1102
    stable_thresh = (double )0;
#line 1107
    __cil_tmp48 = pow((double )((float )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 1107
    distotarget = tcd_tile->distotile - (K___0 * maxSE) / __cil_tmp48;
    }
#line 1113
    if (cp->disto_alloc == 1) {
#line 1113
      if (tcd_tcp->rates[layno] > (float )0) {
        _L: /* CIL Label */ 
        {
#line 1114
        __cil_tmp50 = t2_create(tcd->cinfo, tcd->image, cp);
#line 1114
        t2 = __cil_tmp50;
#line 1115
        thresh = (double )0;
#line 1117
        i = 0;
        }
        {
#line 1117
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1117
          if (! (i < 128)) {
#line 1117
            goto while_break___6;
          }
          {
#line 1118
          l = 0;
#line 1119
          distoachieved = (double )0;
#line 1120
          thresh = (lo + hi) / (double )2;
#line 1122
          tcd_makelayer(tcd, layno, thresh, 0);
          }
#line 1124
          if (cp->fixed_quality) {
#line 1125
            if (cp->cinema) {
              {
#line 1126
              l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                    maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                    tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
              }
#line 1127
              if (l == -999) {
#line 1128
                lo = thresh;
#line 1129
                goto while_continue___6;
              } else {
#line 1131
                if (layno == 0) {
#line 1131
                  tmp___0 = tcd_tile->distolayer[0];
                } else {
#line 1131
                  tmp___0 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
                }
#line 1131
                distoachieved = tmp___0;
#line 1133
                if (distoachieved < distotarget) {
#line 1134
                  hi = thresh;
#line 1135
                  stable_thresh = thresh;
#line 1136
                  goto while_continue___6;
                } else {
#line 1138
                  lo = thresh;
                }
              }
            } else {
#line 1142
              if (layno == 0) {
#line 1142
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 1142
                tmp___1 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
              }
#line 1142
              distoachieved = tmp___1;
#line 1144
              if (distoachieved < distotarget) {
#line 1145
                hi = thresh;
#line 1146
                stable_thresh = thresh;
#line 1147
                goto while_continue___6;
              }
#line 1149
              lo = thresh;
            }
          } else {
            {
#line 1152
            l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                  maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                  tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
            }
#line 1155
            if (l == -999) {
#line 1156
              lo = thresh;
#line 1157
              goto while_continue___6;
            }
#line 1159
            hi = thresh;
#line 1160
            stable_thresh = thresh;
          }
#line 1117
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1163
        success = 1;
#line 1164
        if (stable_thresh == (double )0) {
#line 1164
          tmp___2 = thresh;
        } else {
#line 1164
          tmp___2 = stable_thresh;
        }
        {
#line 1164
        goodthresh = tmp___2;
#line 1165
        t2_destroy(t2);
        }
      } else {
#line 1113
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1113
    if (cp->fixed_quality == 1) {
#line 1113
      if (tcd_tcp->distoratio[layno] > (float )0) {
#line 1113
        goto _L;
      } else {
#line 1167
        success = 1;
#line 1168
        goodthresh = min;
      }
    } else {
#line 1167
      success = 1;
#line 1168
      goodthresh = min;
    }
#line 1171
    if (! success) {
#line 1172
      return (0);
    }
#line 1175
    if (cstr_info) {
#line 1176
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 1178
    tcd_makelayer(tcd, layno, goodthresh, 1);
    }
#line 1181
    if (layno == 0) {
#line 1181
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 1181
      tmp___3 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
    }
#line 1181
    cumdisto[layno] = tmp___3;
#line 1096
    layno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1184
  return (1);
}
}
#line 1187 "/root/patchweave_new/14/libopenjpeg/tcd.c"
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int l ;
  int i ;
  int numpacks ;
  opj_tcd_tile_t *tile ;
  opj_tcp_t *tcd_tcp ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_image_t *image ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  double __cil_tmp18 ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  int x ;
  int y ;
  int adjust ;
  int tmp ;
  int offset_x ;
  int __cil_tmp28 ;
  int offset_y ;
  int __cil_tmp30 ;
  opj_tcd_tilecomp_t *tilec ;
  int tw ;
  int w ;
  int __cil_tmp34 ;
  int *data ;
  int *tile_data ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int *data___0 ;
  int *tile_data___0 ;
  int *__cil_tmp43 ;
  int *__cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int samples ;
  opj_tcd_tilecomp_t *tilec___0 ;
  int __cil_tmp50 ;
  opj_t1_t *__cil_tmp51 ;
  opj_t2_t *__cil_tmp52 ;
  int __cil_tmp53 ;
  double __cil_tmp54 ;
  opj_tcd_tilecomp_t *tilec___1 ;
  int __cil_tmp56 ;

  {
#line 1189
  numpacks = 0;
#line 1190
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1191
  tcd_tcp = (opj_tcp_t *)((void *)0);
#line 1192
  cp = (opj_cp_t *)((void *)0);
#line 1194
  tcp = (tcd->cp)->tcps + 0;
#line 1195
  tccp = tcp->tccps + 0;
#line 1196
  image = tcd->image;
#line 1198
  t1 = (opj_t1_t *)((void *)0);
#line 1199
  t2 = (opj_t2_t *)((void *)0);
#line 1201
  tcd->tcd_tileno = tileno;
#line 1202
  tcd->tcd_tile = (tcd->tcd_image)->tiles;
#line 1203
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1205
  tile = tcd->tcd_tile;
#line 1206
  tcd_tcp = tcd->tcp;
#line 1207
  cp = tcd->cp;
#line 1209
  if (tcd->cur_tp_num == 0) {
    {
#line 1210
    tcd->encoding_time = opj_clock();
    }
#line 1212
    if (cstr_info) {
#line 1213
      tilec_idx = tile->comps + 0;
#line 1214
      i = 0;
      {
#line 1214
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1214
        if (! (i < tilec_idx->numresolutions)) {
#line 1214
          goto while_break;
        }
#line 1215
        res_idx = tilec_idx->resolutions + i;
#line 1217
        (cstr_info->tile + tileno)->pw[i] = res_idx->pw;
#line 1218
        (cstr_info->tile + tileno)->ph[i] = res_idx->ph;
#line 1220
        numpacks += res_idx->pw * res_idx->ph;
#line 1222
        (cstr_info->tile + tileno)->pdx[i] = tccp->prcw[i];
#line 1223
        (cstr_info->tile + tileno)->pdy[i] = tccp->prch[i];
#line 1214
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1225
      __cil_tmp22 = calloc((unsigned long )((cstr_info->numcomps * cstr_info->numlayers) * numpacks),
                           sizeof(opj_packet_info_t ));
#line 1225
      (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp22;
      }
    }
#line 1231
    compno = 0;
    {
#line 1231
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1231
      if (! (compno < tile->numcomps)) {
#line 1231
        goto while_break___0;
      }
#line 1234
      if ((image->comps + compno)->sgnd) {
#line 1234
        tmp = 0;
      } else {
#line 1234
        tmp = 1 << ((image->comps + compno)->prec - 1);
      }
      {
#line 1234
      adjust = tmp;
#line 1235
      __cil_tmp28 = int_ceildiv(image->x0, (image->comps + compno)->dx);
#line 1235
      offset_x = __cil_tmp28;
#line 1236
      __cil_tmp30 = int_ceildiv(image->y0, (image->comps + compno)->dy);
#line 1236
      offset_y = __cil_tmp30;
#line 1238
      tilec = tile->comps + compno;
#line 1239
      tw = tilec->x1 - tilec->x0;
#line 1240
      __cil_tmp34 = int_ceildiv(image->x1 - image->x0, (image->comps + compno)->dx);
#line 1240
      w = __cil_tmp34;
      }
#line 1244
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
#line 1245
        y = tilec->y0;
        {
#line 1245
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1245
          if (! (y < tilec->y1)) {
#line 1245
            goto while_break___1;
          }
#line 1247
          data = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1249
          tile_data = tilec->data + (y - tilec->y0) * tw;
#line 1250
          x = tilec->x0;
          {
#line 1250
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1250
            if (! (x < tilec->x1)) {
#line 1250
              goto while_break___2;
            }
#line 1251
            __cil_tmp38 = data;
#line 1251
            data ++;
#line 1251
            __cil_tmp37 = tile_data;
#line 1251
            tile_data ++;
#line 1251
            *__cil_tmp37 = *__cil_tmp38 - adjust;
#line 1250
            x ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1245
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 1254
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
#line 1255
        y = tilec->y0;
        {
#line 1255
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1255
          if (! (y < tilec->y1)) {
#line 1255
            goto while_break___3;
          }
#line 1257
          data___0 = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1259
          tile_data___0 = tilec->data + (y - tilec->y0) * tw;
#line 1260
          x = tilec->x0;
          {
#line 1260
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1260
            if (! (x < tilec->x1)) {
#line 1260
              goto while_break___4;
            }
#line 1261
            __cil_tmp44 = data___0;
#line 1261
            data___0 ++;
#line 1261
            __cil_tmp43 = tile_data___0;
#line 1261
            tile_data___0 ++;
#line 1261
            *__cil_tmp43 = (*__cil_tmp44 - adjust) << 11;
#line 1260
            x ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1255
          y ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1231
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1269
    if (tcd_tcp->mct) {
#line 1270
      samples = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1271
      if ((tcd_tcp->tccps + 0)->qmfbid == 0) {
        {
#line 1272
        mct_encode_real((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                        samples);
        }
      } else {
        {
#line 1274
        mct_encode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                   samples);
        }
      }
    }
#line 1280
    compno = 0;
    {
#line 1280
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1280
      if (! (compno < tile->numcomps)) {
#line 1280
        goto while_break___5;
      }
#line 1281
      tilec___0 = tile->comps + compno;
#line 1282
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
        {
#line 1283
        dwt_encode(tilec___0);
        }
      } else
#line 1284
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
        {
#line 1285
        dwt_encode_real(tilec___0);
        }
      }
#line 1280
      compno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1290
    t1 = t1_create(tcd->cinfo);
#line 1291
    t1_encode_cblks(t1, tile, tcd_tcp);
#line 1292
    t1_destroy(t1);
    }
#line 1297
    if (cstr_info) {
#line 1298
      cstr_info->index_write = 0;
    }
#line 1300
    if (cp->disto_alloc) {
      {
      {
#line 1302
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
      }
    } else
#line 1300
    if (cp->fixed_quality) {
      {
      {
#line 1302
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
      }
    } else {
      {
#line 1305
      tcd_rateallocate_fixed(tcd);
      }
    }
  }
#line 1311
  if (cstr_info) {
#line 1312
    cstr_info->index_write = 1;
  }
  {
#line 1315
  t2 = t2_create(tcd->cinfo, image, cp);
#line 1316
  l = t2_encode_packets(t2, tileno, tile, tcd_tcp->numlayers, dest, len, cstr_info,
                        tcd->tp_num, tcd->tp_pos, tcd->cur_pino, (J2K_T2_MODE )1,
                        tcd->cur_totnum_tp);
#line 1317
  t2_destroy(t2);
  }
#line 1322
  if (tcd->cur_tp_num == tcd->cur_totnum_tp - 1) {
    {
#line 1323
    __cil_tmp54 = opj_clock();
#line 1323
    tcd->encoding_time = __cil_tmp54 - tcd->encoding_time;
#line 1324
    opj_event_msg(tcd->cinfo, 4, "- tile encoded in %f s\n", tcd->encoding_time);
#line 1327
    compno = 0;
    }
    {
#line 1327
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1327
      if (! (compno < tile->numcomps)) {
#line 1327
        goto while_break___6;
      }
      {
#line 1328
      tilec___1 = tile->comps + compno;
#line 1329
      free(tilec___1->data);
      }
#line 1327
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1333
  return (l);
}
}
#line 1336 "/root/patchweave_new/14/libopenjpeg/tcd.c"
opj_bool tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno ,
                         opj_codestream_info_t *cstr_info ) 
{ 
  int l ;
  int compno ;
  int eof ;
  double tile_time ;
  double t1_time ;
  double dwt_time ;
  opj_tcd_tile_t *tile ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  double __cil_tmp15 ;
  int resno ;
  int compno___1 ;
  int numprec ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  void *__cil_tmp25 ;
  opj_t2_t *__cil_tmp26 ;
  int __cil_tmp27 ;
  double __cil_tmp28 ;
  opj_t1_t *__cil_tmp29 ;
  opj_tcd_tilecomp_t *tilec ;
  void *__cil_tmp31 ;
  double __cil_tmp32 ;
  double __cil_tmp33 ;
  opj_tcd_tilecomp_t *tilec___0 ;
  int numres2decode ;
  int __cil_tmp36 ;
  double __cil_tmp37 ;
  int n ;
  opj_tcd_tilecomp_t *tilec___1 ;
  opj_image_comp_t *imagec ;
  opj_tcd_resolution_t *res ;
  int adjust ;
  int tmp ;
  int min ;
  int tmp___0 ;
  int max ;
  int tmp___1 ;
  int tw ;
  int w ;
  int offset_x ;
  int __cil_tmp51 ;
  int offset_y ;
  int __cil_tmp53 ;
  int i ;
  int j ;
  void *__cil_tmp56 ;
  int v ;
  int __cil_tmp58 ;
  float tmp___2 ;
  int v___0 ;
  long __cil_tmp61 ;
  int __cil_tmp62 ;
  double __cil_tmp63 ;

  {
  {
#line 1339
  eof = 0;
#line 1341
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1343
  t1 = (opj_t1_t *)((void *)0);
#line 1344
  t2 = (opj_t2_t *)((void *)0);
#line 1346
  tcd->tcd_tileno = tileno;
#line 1347
  tcd->tcd_tile = (tcd->tcd_image)->tiles + tileno;
#line 1348
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1349
  tile = tcd->tcd_tile;
#line 1351
  tile_time = opj_clock();
#line 1352
  opj_event_msg(tcd->cinfo, 4, "tile %d of %d\n", tileno + 1, (tcd->cp)->tw * (tcd->cp)->th);
  }
#line 1355
  if (cstr_info) {
#line 1356
    numprec = 0;
#line 1357
    compno___1 = 0;
    {
#line 1357
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1357
      if (! (compno___1 < cstr_info->numcomps)) {
#line 1357
        goto while_break;
      }
#line 1358
      tcp = (tcd->cp)->tcps + 0;
#line 1359
      tccp = tcp->tccps + compno___1;
#line 1360
      tilec_idx = tile->comps + compno___1;
#line 1361
      resno = 0;
      {
#line 1361
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1361
        if (! (resno < tilec_idx->numresolutions)) {
#line 1361
          goto while_break___0;
        }
#line 1362
        res_idx = tilec_idx->resolutions + resno;
#line 1363
        (cstr_info->tile + tileno)->pw[resno] = res_idx->pw;
#line 1364
        (cstr_info->tile + tileno)->ph[resno] = res_idx->ph;
#line 1365
        numprec += res_idx->pw * res_idx->ph;
#line 1366
        if (tccp->csty & 1) {
#line 1367
          (cstr_info->tile + tileno)->pdx[resno] = tccp->prcw[resno];
#line 1368
          (cstr_info->tile + tileno)->pdy[resno] = tccp->prch[resno];
        } else {
#line 1371
          (cstr_info->tile + tileno)->pdx[resno] = 15;
#line 1372
          (cstr_info->tile + tileno)->pdy[resno] = 15;
        }
#line 1361
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1357
      compno___1 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1376
    __cil_tmp25 = malloc((unsigned long )(cstr_info->numlayers * numprec) * sizeof(opj_packet_info_t ));
#line 1376
    (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp25;
#line 1377
    cstr_info->packno = 0;
    }
  }
  {
#line 1383
  t2 = t2_create(tcd->cinfo, tcd->image, tcd->cp);
#line 1384
  l = t2_decode_packets(t2, src, len, tileno, tile, cstr_info);
#line 1385
  t2_destroy(t2);
  }
#line 1387
  if (l == -999) {
    {
#line 1388
    eof = 1;
#line 1389
    opj_event_msg(tcd->cinfo, 1, "tcd_decode: incomplete bistream\n\220");
    }
#line 1390
    return (0);
  }
  {
#line 1395
  t1_time = opj_clock();
#line 1396
  t1 = t1_create(tcd->cinfo);
  }
#line 1397
  if (t1 == (void *)0) {
    {
#line 1399
    opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
#line 1400
    t1_destroy(t1);
    }
#line 1401
    return (0);
  }
#line 1404
  compno = 0;
  {
#line 1404
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1404
    if (! (compno < tile->numcomps)) {
#line 1404
      goto while_break___1;
    }
    {
#line 1405
    tilec = tile->comps + compno;
#line 1407
    __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) + 3) * sizeof(int ));
#line 1407
    tilec->data = (int *)__cil_tmp31;
    }
#line 1408
    if (tilec->data == (void *)0) {
      {
#line 1410
      opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
#line 1411
      t1_destroy(t1);
      }
#line 1412
      return (0);
    }
    {
#line 1415
    t1_decode_cblks(t1, tilec, (tcd->tcp)->tccps + compno);
    }
#line 1404
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1417
  t1_destroy(t1);
#line 1418
  __cil_tmp32 = opj_clock();
#line 1418
  t1_time = __cil_tmp32 - t1_time;
#line 1419
  opj_event_msg(tcd->cinfo, 4, "- tiers-1 took %f s\n", t1_time);
#line 1423
  dwt_time = opj_clock();
#line 1424
  compno = 0;
  }
  {
#line 1424
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1424
    if (! (compno < tile->numcomps)) {
#line 1424
      goto while_break___2;
    }
#line 1425
    tilec___0 = tile->comps + compno;
#line 1428
    if ((tcd->cp)->reduce != 0) {
#line 1429
      if ((tile->comps + compno)->numresolutions < (tcd->cp)->reduce - 1) {
        {
#line 1430
        opj_event_msg(tcd->cinfo, 1, "Error decoding tile. The number of resolutions to remove [%d+1] is higher than the number  of resolutions in the original codestream [%d]\nModify the cp_reduce parameter.\n",
                      (tcd->cp)->reduce, (tile->comps + compno)->numresolutions);
        }
#line 1432
        return (0);
      } else {
#line 1435
        ((tcd->image)->comps + compno)->resno_decoded = ((tile->comps + compno)->numresolutions - (tcd->cp)->reduce) - 1;
      }
    }
#line 1440
    numres2decode = ((tcd->image)->comps + compno)->resno_decoded + 1;
#line 1441
    if (numres2decode > 0) {
#line 1442
      if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
        {
#line 1443
        dwt_decode(tilec___0, numres2decode);
        }
      } else {
        {
#line 1445
        dwt_decode_real(tilec___0, numres2decode);
        }
      }
    }
#line 1424
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1449
  __cil_tmp37 = opj_clock();
#line 1449
  dwt_time = __cil_tmp37 - dwt_time;
#line 1450
  opj_event_msg(tcd->cinfo, 4, "- dwt took %f s\n\230\001", dwt_time);
  }
#line 1454
  if ((tcd->tcp)->mct) {
#line 1455
    n = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1457
    if (tile->numcomps >= 3) {
#line 1459
      if (((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0) < n) {
        {
        {
        {
#line 1462
        opj_event_msg(tcd->cinfo, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n\342U");
        }
        }
        }
#line 1463
        return (0);
      } else
#line 1459
      if (((tile->comps + 1)->x1 - (tile->comps + 1)->x0) * ((tile->comps + 1)->y1 - (tile->comps + 1)->y0) < n) {
        {
        {
        {
#line 1462
        opj_event_msg(tcd->cinfo, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n\342U");
        }
        }
        }
#line 1463
        return (0);
      } else
#line 1459
      if (((tile->comps + 2)->x1 - (tile->comps + 2)->x0) * ((tile->comps + 2)->y1 - (tile->comps + 2)->y0) < n) {
        {
        {
        {
#line 1462
        opj_event_msg(tcd->cinfo, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n\342U");
        }
        }
        }
#line 1463
        return (0);
      }
#line 1465
      if (((tcd->tcp)->tccps + 0)->qmfbid == 1) {
        {
#line 1466
        mct_decode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                   n);
        }
      } else {
        {
#line 1472
        mct_decode_real((float *)(tile->comps + 0)->data, (float *)(tile->comps + 1)->data,
                        (float *)(tile->comps + 2)->data, n);
        }
      }
    } else {
      {
#line 1479
      opj_event_msg(tcd->cinfo, 2, "Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n",
                    tile->numcomps);
      }
    }
  }
#line 1485
  compno = 0;
  {
#line 1485
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1485
    if (! (compno < tile->numcomps)) {
#line 1485
      goto while_break___3;
    }
#line 1486
    tilec___1 = tile->comps + compno;
#line 1487
    imagec = (tcd->image)->comps + compno;
#line 1488
    res = tilec___1->resolutions + imagec->resno_decoded;
#line 1489
    if (imagec->sgnd) {
#line 1489
      tmp = 0;
    } else {
#line 1489
      tmp = 1 << (imagec->prec - 1);
    }
#line 1489
    adjust = tmp;
#line 1490
    if (imagec->sgnd) {
#line 1490
      tmp___0 = - (1 << (imagec->prec - 1));
    } else {
#line 1490
      tmp___0 = 0;
    }
#line 1490
    min = tmp___0;
#line 1491
    if (imagec->sgnd) {
#line 1491
      tmp___1 = (1 << (imagec->prec - 1)) - 1;
    } else {
#line 1491
      tmp___1 = (1 << imagec->prec) - 1;
    }
    {
#line 1491
    max = tmp___1;
#line 1493
    tw = tilec___1->x1 - tilec___1->x0;
#line 1494
    w = imagec->w;
#line 1496
    __cil_tmp51 = int_ceildivpow2(imagec->x0, imagec->factor);
#line 1496
    offset_x = __cil_tmp51;
#line 1497
    __cil_tmp53 = int_ceildivpow2(imagec->y0, imagec->factor);
#line 1497
    offset_y = __cil_tmp53;
    }
#line 1500
    if (! imagec->data) {
      {
#line 1501
      __cil_tmp56 = malloc((unsigned long )(imagec->w * imagec->h) * sizeof(int ));
#line 1501
      imagec->data = (int *)__cil_tmp56;
      }
    }
#line 1503
    if (! imagec->data) {
      {
#line 1505
      opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
      }
#line 1506
      return (0);
    }
#line 1508
    if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
#line 1509
      j = res->y0;
      {
#line 1509
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1509
        if (! (j < res->y1)) {
#line 1509
          goto while_break___4;
        }
#line 1510
        i = res->x0;
        {
#line 1510
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1510
          if (! (i < res->x1)) {
#line 1510
            goto while_break___5;
          }
          {
#line 1511
          v = *(tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1512
          v += adjust;
#line 1513
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v, min,
                                                                              max);
          }
#line 1510
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1509
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 1517
      j = res->y0;
      {
#line 1517
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1517
        if (! (j < res->y1)) {
#line 1517
          goto while_break___6;
        }
#line 1518
        i = res->x0;
        {
#line 1518
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1518
          if (! (i < res->x1)) {
#line 1518
            goto while_break___7;
          }
          {
#line 1519
          tmp___2 = *((float *)tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1520
          __cil_tmp61 = lrintf(tmp___2);
#line 1520
          v___0 = (int )__cil_tmp61;
#line 1521
          v___0 += adjust;
#line 1522
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v___0,
                                                                              min,
                                                                              max);
          }
#line 1518
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1517
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 1526
    free(tilec___1->data);
    }
#line 1485
    compno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1529
  __cil_tmp63 = opj_clock();
#line 1529
  tile_time = __cil_tmp63 - tile_time;
#line 1530
  opj_event_msg(tcd->cinfo, 4, "- tile decoded in %f s\n", tile_time);
  }
#line 1532
  if (eof) {
#line 1533
    return (0);
  }
#line 1536
  return (1);
}
}
#line 1539 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_free_decode(opj_tcd_t *tcd ) 
{ 
  opj_tcd_image_t *tcd_image ;
  int i ;
  int __cil_tmp4 ;

  {
#line 1540
  tcd_image = tcd->tcd_image;
#line 1541
  i = 0;
#line 1542
  i = 0;
  {
#line 1542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1542
    if (! (i < tcd_image->tw * tcd_image->th)) {
#line 1542
      goto while_break;
    }
    {
#line 1544
    tcd_free_decode_tile(tcd, i);
    }
#line 1542
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1547
  free(tcd_image->tiles);
  }
  return;
}
}
#line 1550 "/root/patchweave_new/14/libopenjpeg/tcd.c"
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_image_t *tcd_image ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 1553
  tcd_image = tcd->tcd_image;
#line 1555
  tile = tcd_image->tiles + tileno;
#line 1556
  if (tile->comps != (void *)0) {
#line 1557
    compno = 0;
    {
#line 1557
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1557
      if (! (compno < tile->numcomps)) {
#line 1557
        goto while_break;
      }
#line 1558
      tilec = tile->comps + compno;
#line 1559
      resno = 0;
      {
#line 1559
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1559
        if (! (resno < tilec->numresolutions)) {
#line 1559
          goto while_break___0;
        }
#line 1560
        res = tilec->resolutions + resno;
#line 1561
        bandno = 0;
        {
#line 1561
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1561
          if (! (bandno < res->numbands)) {
#line 1561
            goto while_break___1;
          }
#line 1562
          band = & res->bands[bandno];
#line 1563
          precno = 0;
          {
#line 1563
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1563
            if (! (precno < res->ph * res->pw)) {
#line 1563
              goto while_break___2;
            }
#line 1564
            prec = band->precincts + precno;
#line 1565
            if (prec->cblks.dec != (void *)0) {
#line 1566
              cblkno = 0;
              {
#line 1566
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1566
                if (! (cblkno < prec->cw * prec->ch)) {
#line 1566
                  goto while_break___3;
                }
                {
#line 1567
                cblk = prec->cblks.dec + cblkno;
#line 1568
                free(cblk->data);
#line 1569
                free(cblk->segs);
                }
#line 1566
                cblkno ++;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 1571
              free(prec->cblks.dec);
              }
            }
#line 1573
            if (prec->imsbtree != (void *)0) {
              {
#line 1573
              tgt_destroy(prec->imsbtree);
              }
            }
#line 1574
            if (prec->incltree != (void *)0) {
              {
#line 1574
              tgt_destroy(prec->incltree);
              }
            }
#line 1563
            precno ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1578
          free(band->precincts);
          }
#line 1561
          bandno ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1559
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1581
      free(tilec->resolutions);
      }
#line 1557
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1583
    free(tile->comps);
#line 1584
    tile->comps = (opj_tcd_tilecomp_t *)((void *)0);
    }
  }
  return;
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__)) void __assert_fail(char const   *__assertion ,
                                                        char const   *__file , unsigned int __line ,
                                                        char const   *__function ) ;
#line 74
extern  __attribute__((__nothrow__)) void __assert_perror_fail(int __errnum , char const   *__file ,
                                                               unsigned int __line ,
                                                               char const   *__function ) ;
#line 81
extern  __attribute__((__nothrow__)) void __assert(char const   *__assertion , char const   *__file ,
                                                   int __line ) ;
#line 41 "/root/patchweave_new/14/libopenjpeg/t2.c"
static void t2_putcommacode(opj_bio_t *bio , int n ) ;
#line 42
static int t2_getcommacode(opj_bio_t *bio ) ;
#line 48
static void t2_putnumpasses(opj_bio_t *bio , int n ) ;
#line 49
static int t2_getnumpasses(opj_bio_t *bio ) ;
#line 61
static int t2_encode_packet(opj_tcd_tile_t *tile , opj_tcp_t *tcp , opj_pi_iterator_t *pi ,
                            unsigned char *dest , int length , opj_codestream_info_t *cstr_info ,
                            int tileno ) ;
#line 68
static opj_bool t2_init_seg(opj_tcd_cblk_dec_t *cblk , int index___0 , int cblksty ,
                            int first ) ;
#line 80
static int t2_decode_packet(opj_t2_t *t2 , unsigned char *src , int len , opj_tcd_tile_t *tile ,
                            opj_tcp_t *tcp , opj_pi_iterator_t *pi , opj_packet_info_t *pack_info ) ;
#line 91 "/root/patchweave_new/14/libopenjpeg/t2.c"
static void t2_putcommacode(opj_bio_t *bio , int n ) 
{ 


  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    n --;
#line 92
    if (! (n >= 0)) {
#line 92
      goto while_break;
    }
    {
#line 93
    bio_write(bio, 1, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  bio_write(bio, 0, 1);
  }
  return;
}
}
#line 98 "/root/patchweave_new/14/libopenjpeg/t2.c"
static int t2_getcommacode(opj_bio_t *bio ) 
{ 
  int n ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 100
  n = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! __cil_tmp3) {
#line 100
      goto while_break;
    }

#line 100
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (n);
}
}
#line 106 "/root/patchweave_new/14/libopenjpeg/t2.c"
static void t2_putnumpasses(opj_bio_t *bio , int n ) 
{ 


  {
#line 107
  if (n == 1) {
    {
#line 108
    bio_write(bio, 0, 1);
    }
  } else
#line 109
  if (n == 2) {
    {
#line 110
    bio_write(bio, 2, 2);
    }
  } else
#line 111
  if (n <= 5) {
    {
#line 112
    bio_write(bio, 12 | (n - 3), 4);
    }
  } else
#line 113
  if (n <= 36) {
    {
#line 114
    bio_write(bio, 480 | (n - 6), 9);
    }
  } else
#line 115
  if (n <= 164) {
    {
#line 116
    bio_write(bio, 65408 | (n - 37), 16);
    }
  }
  return;
}
}
#line 120 "/root/patchweave_new/14/libopenjpeg/t2.c"
static int t2_getnumpasses(opj_bio_t *bio ) 
{ 
  int n ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 122
  __cil_tmp3 = bio_read(bio, 1);
  }
#line 122
  if (! __cil_tmp3) {
#line 123
    return (1);
  }
  {
#line 124
  __cil_tmp4 = bio_read(bio, 1);
  }
#line 124
  if (! __cil_tmp4) {
#line 125
    return (2);
  }
  {
#line 126
  n = bio_read(bio, 2);
  }
#line 126
  if (n != 3) {
#line 127
    return (3 + n);
  }
  {
#line 128
  n = bio_read(bio, 5);
  }
#line 128
  if (n != 31) {
#line 129
    return (6 + n);
  }
  {
#line 130
  __cil_tmp7 = bio_read(bio, 7);
  }
#line 130
  return (37 + __cil_tmp7);
}
}
#line 133 "/root/patchweave_new/14/libopenjpeg/t2.c"
static int t2_encode_packet(opj_tcd_tile_t *tile , opj_tcp_t *tcp , opj_pi_iterator_t *pi ,
                            unsigned char *dest , int length , opj_codestream_info_t *cstr_info ,
                            int tileno ) 
{ 
  int bandno ;
  int cblkno ;
  unsigned char *c ;
  int compno ;
  int resno ;
  int precno ;
  int layno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_bio_t *bio ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  opj_bio_t *__cil_tmp23 ;
  opj_tcd_band_t *band___0 ;
  opj_tcd_precinct_t *prc___0 ;
  opj_tcd_cblk_enc_t *cblk___0 ;
  opj_tcd_layer_t *layer ;
  int __cil_tmp28 ;
  opj_tcd_cblk_enc_t *cblk___1 ;
  opj_tcd_layer_t *layer___0 ;
  int increment ;
  int nump ;
  int len ;
  int passno ;
  opj_tcd_pass_t *pass ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  opj_tcd_pass_t *pass___0 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  opj_packet_info_t *info_PK ;
  opj_tcd_band_t *band___1 ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_cblk_enc_t *cblk___2 ;
  opj_tcd_layer_t *layer___1 ;
  opj_packet_info_t *info_PK___0 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;

  {
#line 135
  c = dest;
#line 137
  compno = pi->compno;
#line 138
  resno = pi->resno;
#line 139
  precno = pi->precno;
#line 140
  layno = pi->layno;
#line 142
  tilec = tile->comps + compno;
#line 143
  res = tilec->resolutions + resno;
#line 145
  bio = (opj_bio_t *)((void *)0);
#line 148
  if (tcp->csty & 2) {
#line 149
    *(c + 0) = (unsigned char )255;
#line 150
    *(c + 1) = (unsigned char )145;
#line 151
    *(c + 2) = (unsigned char )0;
#line 152
    *(c + 3) = (unsigned char )4;
#line 153
    *(c + 4) = (unsigned char )((tile->packno % 65536) / 256);
#line 154
    *(c + 5) = (unsigned char )((tile->packno % 65536) % 256);
#line 155
    c += 6;
  }
#line 159
  if (! layno) {
#line 160
    bandno = 0;
    {
#line 160
    while (1) {
      while_continue: /* CIL Label */ ;
#line 160
      if (! (bandno < res->numbands)) {
#line 160
        goto while_break;
      }
      {
#line 161
      band = & res->bands[bandno];
#line 162
      prc = band->precincts + precno;
#line 163
      tgt_reset(prc->incltree);
#line 164
      tgt_reset(prc->imsbtree);
#line 165
      cblkno = 0;
      }
      {
#line 165
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 165
        if (! (cblkno < prc->cw * prc->ch)) {
#line 165
          goto while_break___0;
        }
        {
#line 166
        cblk = prc->cblks.enc + cblkno;
#line 167
        cblk->numpasses = 0;
#line 168
        tgt_setvalue(prc->imsbtree, cblkno, band->numbps - cblk->numbps);
        }
#line 165
        cblkno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 160
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 173
  bio = bio_create();
#line 174
  bio_init_enc(bio, c, length);
#line 175
  bio_write(bio, 1, 1);
#line 178
  bandno = 0;
  }
  {
#line 178
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 178
    if (! (bandno < res->numbands)) {
#line 178
      goto while_break___1;
    }
#line 179
    band___0 = & res->bands[bandno];
#line 180
    prc___0 = band___0->precincts + precno;
#line 181
    cblkno = 0;
    {
#line 181
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 181
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 181
        goto while_break___2;
      }
#line 182
      cblk___0 = prc___0->cblks.enc + cblkno;
#line 183
      layer = cblk___0->layers + layno;
#line 184
      if (! cblk___0->numpasses) {
#line 184
        if (layer->numpasses) {
          {
#line 185
          tgt_setvalue(prc___0->incltree, cblkno, layno);
          }
        }
      }
#line 181
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 188
    cblkno = 0;
    {
#line 188
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 188
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 188
        goto while_break___3;
      }
#line 189
      cblk___1 = prc___0->cblks.enc + cblkno;
#line 190
      layer___0 = cblk___1->layers + layno;
#line 191
      increment = 0;
#line 192
      nump = 0;
#line 193
      len = 0;
#line 195
      if (! cblk___1->numpasses) {
        {
#line 196
        tgt_encode(bio, prc___0->incltree, cblkno, layno + 1);
        }
      } else {
        {
#line 198
        bio_write(bio, layer___0->numpasses != 0, 1);
        }
      }
#line 201
      if (! layer___0->numpasses) {
#line 202
        goto while_continue___3;
      }
#line 205
      if (! cblk___1->numpasses) {
        {
#line 206
        cblk___1->numlenbits = 3;
#line 207
        tgt_encode(bio, prc___0->imsbtree, cblkno, 999);
        }
      }
      {
#line 210
      t2_putnumpasses(bio, layer___0->numpasses);
#line 213
      passno = cblk___1->numpasses;
      }
      {
#line 213
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 213
        if (! (passno < cblk___1->numpasses + layer___0->numpasses)) {
#line 213
          goto while_break___4;
        }
#line 214
        pass = cblk___1->passes + passno;
#line 215
        nump ++;
#line 216
        len += pass->len;
#line 217
        if (pass->term) {
          _L: /* CIL Label */ 
          {
#line 218
          __cil_tmp38 = int_floorlog2(nump);
          }
          {
#line 218
          __cil_tmp37 = int_floorlog2(len);
#line 218
          __cil_tmp39 = int_max(increment, (__cil_tmp37 + 1) - (cblk___1->numlenbits + __cil_tmp38));
#line 218
          increment = __cil_tmp39;
#line 219
          len = 0;
#line 220
          nump = 0;
          }
        } else
#line 217
        if (passno == (cblk___1->numpasses + layer___0->numpasses) - 1) {
#line 217
          goto _L;
        }
#line 213
        passno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 223
      t2_putcommacode(bio, increment);
#line 226
      cblk___1->numlenbits += increment;
#line 229
      passno = cblk___1->numpasses;
      }
      {
#line 229
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 229
        if (! (passno < cblk___1->numpasses + layer___0->numpasses)) {
#line 229
          goto while_break___5;
        }
#line 230
        pass___0 = cblk___1->passes + passno;
#line 231
        nump ++;
#line 232
        len += pass___0->len;
#line 233
        if (pass___0->term) {
          {
          {
#line 234
          __cil_tmp43 = int_floorlog2(nump);
          }
          {
#line 234
          bio_write(bio, len, cblk___1->numlenbits + __cil_tmp43);
          }
#line 235
          len = 0;
#line 236
          nump = 0;
          }
        } else
#line 233
        if (passno == (cblk___1->numpasses + layer___0->numpasses) - 1) {
          {
          {
#line 234
          __cil_tmp43 = int_floorlog2(nump);
          }
          {
#line 234
          bio_write(bio, len, cblk___1->numlenbits + __cil_tmp43);
          }
#line 235
          len = 0;
#line 236
          nump = 0;
          }
        }
#line 229
        passno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 188
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 178
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  __cil_tmp47 = bio_flush(bio);
  }
#line 242
  if (__cil_tmp47) {
    {
#line 243
    bio_destroy(bio);
    }
#line 244
    return (- 999);
  }
  {
#line 247
  __cil_tmp48 = bio_numbytes(bio);
  }
  {
#line 247
  c += __cil_tmp48;
#line 248
  bio_destroy(bio);
  }
#line 251
  if (tcp->csty & 4) {
#line 252
    *(c + 0) = (unsigned char )255;
#line 253
    *(c + 1) = (unsigned char )146;
#line 254
    c += 2;
  }
#line 261
  if (cstr_info) {
#line 261
    if (cstr_info->index_write) {
#line 262
      info_PK = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 263
      info_PK->end_ph_pos = (int )(c - dest);
    }
  }
#line 269
  bandno = 0;
  {
#line 269
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 269
    if (! (bandno < res->numbands)) {
#line 269
      goto while_break___6;
    }
#line 270
    band___1 = & res->bands[bandno];
#line 271
    prc___1 = band___1->precincts + precno;
#line 272
    cblkno = 0;
    {
#line 272
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 272
      if (! (cblkno < prc___1->cw * prc___1->ch)) {
#line 272
        goto while_break___7;
      }
#line 273
      cblk___2 = prc___1->cblks.enc + cblkno;
#line 274
      layer___1 = cblk___2->layers + layno;
#line 275
      if (! layer___1->numpasses) {
#line 276
        goto while_continue___7;
      }
#line 278
      if (c + layer___1->len > dest + length) {
#line 279
        return (- 999);
      }
      {
#line 282
      memcpy(c, layer___1->data, (unsigned long )layer___1->len);
#line 283
      cblk___2->numpasses += layer___1->numpasses;
#line 284
      c += layer___1->len;
      }
#line 286
      if (cstr_info) {
#line 286
        if (cstr_info->index_write) {
#line 287
          info_PK___0 = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 288
          info_PK___0->disto += layer___1->disto;
#line 289
          if (cstr_info->D_max < info_PK___0->disto) {
#line 290
            cstr_info->D_max = info_PK___0->disto;
          }
        }
      }
#line 272
      cblkno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 269
    bandno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 297
  return ((int )(c - dest));
}
}
#line 300 "/root/patchweave_new/14/libopenjpeg/t2.c"
static opj_bool t2_init_seg(opj_tcd_cblk_dec_t *cblk , int index___0 , int cblksty ,
                            int first ) 
{ 
  opj_tcd_seg_t *seg ;
  opj_tcd_seg_t *segs ;
  void *__cil_tmp7 ;
  int tmp ;

  {
  {
#line 303
  __cil_tmp7 = realloc(cblk->segs, (unsigned long )(index___0 + 1) * sizeof(opj_tcd_seg_t ));
#line 303
  segs = (opj_tcd_seg_t *)__cil_tmp7;
  }
#line 305
  if (segs == (void *)0) {
#line 307
    return (0);
  }
#line 309
  cblk->segs = segs;
#line 311
  seg = cblk->segs + index___0;
#line 312
  seg->data = (unsigned char **)((void *)0);
#line 313
  seg->dataindex = 0;
#line 314
  seg->numpasses = 0;
#line 315
  seg->len = 0;
#line 316
  if (cblksty & 4) {
#line 317
    seg->maxpasses = 1;
  } else
#line 319
  if (cblksty & 1) {
#line 320
    if (first) {
#line 321
      seg->maxpasses = 10;
    } else {
#line 323
      if ((seg - 1)->maxpasses == 1 || (seg - 1)->maxpasses == 10) {
#line 323
        tmp = 2;
      } else {
#line 323
        tmp = 1;
      }
#line 323
      seg->maxpasses = tmp;
    }
  } else {
#line 326
    seg->maxpasses = 109;
  }
#line 329
  return (1);
}
}
#line 332 "/root/patchweave_new/14/libopenjpeg/t2.c"
static int t2_decode_packet(opj_t2_t *t2 , unsigned char *src , int len , opj_tcd_tile_t *tile ,
                            opj_tcp_t *tcp , opj_pi_iterator_t *pi , opj_packet_info_t *pack_info ) 
{ 
  int bandno ;
  int cblkno ;
  unsigned char *c ;
  opj_cp_t *cp ;
  int compno ;
  int resno ;
  int precno ;
  int layno ;
  unsigned char *hd ;
  int present ;
  opj_bio_t *bio ;
  opj_tcd_resolution_t *res ;
  int tmp ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  opj_bio_t *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  opj_tcd_band_t *band___0 ;
  opj_tcd_precinct_t *prc___0 ;
  int included ;
  int increment ;
  int n ;
  int segno ;
  opj_tcd_cblk_dec_t *cblk___0 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int i ;
  int numimsbs ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  opj_bool __cil_tmp44 ;
  opj_bool __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  opj_bool __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  opj_tcd_band_t *band___1 ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_cblk_dec_t *cblk___1 ;
  opj_tcd_seg_t *seg ;
  int __cil_tmp58 ;
  opj_tcd_seg_t *__cil_tmp59 ;
  int __cil_tmp60 ;
  void *__cil_tmp61 ;
  opj_tcd_seg_t *__cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;

  {
#line 335
  c = src;
#line 337
  cp = t2->cp;
#line 339
  compno = pi->compno;
#line 340
  resno = pi->resno;
#line 341
  precno = pi->precno;
#line 342
  layno = pi->layno;
#line 344
  hd = (unsigned char *)((void *)0);
#line 347
  bio = (opj_bio_t *)((void *)0);
#line 351
  res = (tile->comps + compno)->resolutions + resno;
#line 353
  if (layno == 0) {
#line 354
    bandno = 0;
    {
#line 354
    while (1) {
      while_continue: /* CIL Label */ ;
#line 354
      if (! (bandno < res->numbands)) {
#line 354
        goto while_break;
      }
#line 355
      band = & res->bands[bandno];
#line 356
      prc = band->precincts + precno;
#line 358
      if (band->x1 - band->x0 == 0) {
#line 358
        goto while_continue;
      } else
#line 358
      if (band->y1 - band->y0 == 0) {
#line 358
        goto while_continue;
      }
      {
#line 360
      tgt_reset(prc->incltree);
#line 361
      tgt_reset(prc->imsbtree);
#line 362
      cblkno = 0;
      }
      {
#line 362
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 362
        if (! (cblkno < prc->cw * prc->ch)) {
#line 362
          goto while_break___0;
        }
#line 363
        cblk = prc->cblks.dec + cblkno;
#line 364
        cblk->numsegs = 0;
#line 362
        cblkno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 354
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 371
  if (tcp->csty & 2) {
#line 372
    if ((int )*c != 255) {
      {
      {
#line 373
      opj_event_msg(t2->cinfo, 2, "Expected SOP marker\n\342U");
      }
      }
    } else
#line 372
    if ((int )*(c + 1) != 145) {
      {
      {
#line 373
      opj_event_msg(t2->cinfo, 2, "Expected SOP marker\n\342U");
      }
      }
    } else {
#line 375
      c += 6;
    }
  }
  {
#line 388
  bio = bio_create();
  }
#line 390
  if (cp->ppm == 1) {
    {
#line 391
    hd = cp->ppm_data;
#line 392
    bio_init_dec(bio, hd, cp->ppm_len);
    }
  } else
#line 393
  if (tcp->ppt == 1) {
    {
#line 394
    hd = tcp->ppt_data;
#line 395
    bio_init_dec(bio, hd, tcp->ppt_len);
    }
  } else {
    {
#line 397
    hd = c;
#line 398
    bio_init_dec(bio, hd, (int )((src + len) - hd));
    }
  }
  {
#line 401
  present = bio_read(bio, 1);
  }
#line 403
  if (! present) {
    {
#line 404
    bio_inalign(bio);
#line 405
    __cil_tmp28 = bio_numbytes(bio);
    }
    {
#line 405
    hd += __cil_tmp28;
#line 406
    bio_destroy(bio);
    }
#line 410
    if (tcp->csty & 4) {
#line 411
      if ((int )*hd != 255) {
        {
        {
#line 412
        printf("Error : expected EPH marker\n");
        }
        }
      } else
#line 411
      if ((int )*(hd + 1) != 146) {
        {
        {
#line 412
        printf("Error : expected EPH marker\n");
        }
        }
      } else {
#line 414
        hd += 2;
      }
    }
#line 421
    if (pack_info) {
#line 422
      pack_info->end_ph_pos = (int )(c - src);
    }
#line 426
    if (cp->ppm == 1) {
#line 427
      cp->ppm_len += cp->ppm_data - hd;
#line 428
      cp->ppm_data = hd;
#line 429
      return ((int )(c - src));
    }
#line 431
    if (tcp->ppt == 1) {
#line 432
      tcp->ppt_len += tcp->ppt_data - hd;
#line 433
      tcp->ppt_data = hd;
#line 434
      return ((int )(c - src));
    }
#line 437
    return ((int )(hd - src));
  }
#line 440
  bandno = 0;
  {
#line 440
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 440
    if (! (bandno < res->numbands)) {
#line 440
      goto while_break___1;
    }
#line 441
    band___0 = & res->bands[bandno];
#line 442
    prc___0 = band___0->precincts + precno;
#line 444
    if (band___0->x1 - band___0->x0 == 0) {
#line 444
      goto while_continue___1;
    } else
#line 444
    if (band___0->y1 - band___0->y0 == 0) {
#line 444
      goto while_continue___1;
    }
#line 446
    cblkno = 0;
    {
#line 446
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 446
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 446
        goto while_break___2;
      }
#line 448
      cblk___0 = prc___0->cblks.dec + cblkno;
#line 450
      if (! cblk___0->numsegs) {
        {
#line 451
        included = tgt_decode(bio, prc___0->incltree, cblkno, layno + 1);
        }
      } else {
        {
#line 454
        included = bio_read(bio, 1);
        }
      }
#line 457
      if (! included) {
#line 458
        cblk___0->numnewpasses = 0;
#line 459
        goto while_continue___2;
      }
#line 462
      if (! cblk___0->numsegs) {
#line 464
        i = 0;
        {
#line 464
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 464
          if (! (! __cil_tmp40)) {
#line 464
            goto while_break___3;
          }

#line 464
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 467
        numimsbs = i - 1;
#line 468
        cblk___0->numbps = band___0->numbps - numimsbs;
#line 469
        cblk___0->numlenbits = 3;
      }
      {
#line 472
      cblk___0->numnewpasses = t2_getnumpasses(bio);
#line 473
      increment = t2_getcommacode(bio);
#line 475
      cblk___0->numlenbits += increment;
#line 476
      segno = 0;
      }
#line 477
      if (! cblk___0->numsegs) {
        {
#line 478
        __cil_tmp44 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                  1);
        }
#line 478
        if (! __cil_tmp44) {
          {
#line 480
          opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 481
          bio_destroy(bio);
          }
#line 482
          return (- 999);
        }
      } else {
#line 485
        segno = cblk___0->numsegs - 1;
#line 486
        if ((cblk___0->segs + segno)->numpasses == (cblk___0->segs + segno)->maxpasses) {
          {
#line 487
          segno ++;
#line 488
          __cil_tmp45 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                    0);
          }
#line 488
          if (! __cil_tmp45) {
            {
#line 490
            opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 491
            bio_destroy(bio);
            }
#line 492
            return (- 999);
          }
        }
      }
#line 496
      n = cblk___0->numnewpasses;
      {
#line 498
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 499
        (cblk___0->segs + segno)->numnewpasses = int_min((cblk___0->segs + segno)->maxpasses - (cblk___0->segs + segno)->numpasses,
                                                         n);
#line 500
        __cil_tmp47 = int_floorlog2((cblk___0->segs + segno)->numnewpasses);
#line 500
        __cil_tmp48 = bio_read(bio, cblk___0->numlenbits + __cil_tmp47);
#line 500
        (cblk___0->segs + segno)->newlen = __cil_tmp48;
#line 501
        n -= (cblk___0->segs + segno)->numnewpasses;
        }
#line 502
        if (n > 0) {
          {
#line 503
          segno ++;
#line 504
          __cil_tmp49 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                    0);
          }
#line 504
          if (! __cil_tmp49) {
            {
#line 506
            opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 507
            bio_destroy(bio);
            }
#line 508
            return (- 999);
          }
        }
#line 498
        if (! (n > 0)) {
#line 498
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 446
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 440
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 515
  __cil_tmp52 = bio_inalign(bio);
  }
#line 515
  if (__cil_tmp52) {
    {
#line 516
    bio_destroy(bio);
    }
#line 517
    return (- 999);
  }
  {
#line 520
  __cil_tmp53 = bio_numbytes(bio);
  }
  {
#line 520
  hd += __cil_tmp53;
#line 521
  bio_destroy(bio);
  }
#line 524
  if (tcp->csty & 4) {
#line 525
    if ((int )*hd != 255) {
      {
      {
#line 526
      opj_event_msg(t2->cinfo, 1, "Expected EPH marker\n");
      }
      }
#line 527
      return (- 999);
    } else
#line 525
    if ((int )*(hd + 1) != 146) {
      {
      {
#line 526
      opj_event_msg(t2->cinfo, 1, "Expected EPH marker\n");
      }
      }
#line 527
      return (- 999);
    } else {
#line 529
      hd += 2;
    }
  }
#line 536
  if (pack_info) {
#line 537
    pack_info->end_ph_pos = (int )(hd - src);
  }
#line 541
  if (cp->ppm == 1) {
#line 542
    cp->ppm_len += cp->ppm_data - hd;
#line 543
    cp->ppm_data = hd;
  } else
#line 544
  if (tcp->ppt == 1) {
#line 545
    tcp->ppt_len += tcp->ppt_data - hd;
#line 546
    tcp->ppt_data = hd;
  } else {
#line 548
    c = hd;
  }
#line 551
  bandno = 0;
  {
#line 551
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 551
    if (! (bandno < res->numbands)) {
#line 551
      goto while_break___5;
    }
#line 552
    band___1 = & res->bands[bandno];
#line 553
    prc___1 = band___1->precincts + precno;
#line 555
    if (band___1->x1 - band___1->x0 == 0) {
#line 555
      goto while_continue___5;
    } else
#line 555
    if (band___1->y1 - band___1->y0 == 0) {
#line 555
      goto while_continue___5;
    }
#line 557
    cblkno = 0;
    {
#line 557
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 557
      if (! (cblkno < prc___1->cw * prc___1->ch)) {
#line 557
        goto while_break___6;
      }
#line 558
      cblk___1 = prc___1->cblks.dec + cblkno;
#line 559
      seg = (opj_tcd_seg_t *)((void *)0);
#line 560
      if (! cblk___1->numnewpasses) {
#line 561
        goto while_continue___6;
      }
#line 562
      if (! cblk___1->numsegs) {
#line 563
        seg = cblk___1->segs + 0;
#line 564
        (cblk___1->numsegs) ++;
#line 565
        cblk___1->len = 0;
      } else {
#line 567
        seg = cblk___1->segs + (cblk___1->numsegs - 1);
#line 568
        if (seg->numpasses == seg->maxpasses) {
#line 569
          seg ++;
#line 570
          (cblk___1->numsegs) ++;
        }
      }
      {
#line 574
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 575
        if (c + seg->newlen > src + len) {
#line 576
          return (- 999);
        }
        {
#line 599
        __cil_tmp61 = realloc(cblk___1->data, (unsigned long )(cblk___1->len + seg->newlen) * sizeof(unsigned char ));
#line 599
        cblk___1->data = (unsigned char *)__cil_tmp61;
#line 600
        memcpy(cblk___1->data + cblk___1->len, c, (unsigned long )seg->newlen);
        }
#line 601
        if (seg->numpasses == 0) {
#line 602
          seg->data = & cblk___1->data;
#line 603
          seg->dataindex = cblk___1->len;
        }
#line 605
        c += seg->newlen;
#line 606
        cblk___1->len += seg->newlen;
#line 607
        seg->len += seg->newlen;
#line 608
        seg->numpasses += seg->numnewpasses;
#line 609
        cblk___1->numnewpasses -= seg->numnewpasses;
#line 610
        if (cblk___1->numnewpasses > 0) {
#line 611
          seg ++;
#line 612
          (cblk___1->numsegs) ++;
        }
#line 574
        if (! (cblk___1->numnewpasses > 0)) {
#line 574
          goto while_break___7;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 557
      cblkno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 551
    bandno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 618
  return ((int )(c - src));
}
}
#line 623 "/root/patchweave_new/14/libopenjpeg/t2.c"
int t2_encode_packets(opj_t2_t *t2 , int tileno , opj_tcd_tile_t *tile , int maxlayers ,
                      unsigned char *dest , int len , opj_codestream_info_t *cstr_info ,
                      int tpnum , int tppos , int pino , J2K_T2_MODE t2_mode , int cur_totnum_tp ) 
{ 
  unsigned char *c ;
  int e ;
  int compno ;
  opj_pi_iterator_t *pi ;
  int poc ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  int pocno ;
  int tmp ;
  int maxcomp ;
  int tmp___0 ;
  opj_pi_iterator_t *__cil_tmp25 ;
  int comp_len ;
  int tpnum___2 ;
  opj_bool __cil_tmp28 ;
  opj_bool __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  opj_bool __cil_tmp33 ;
  int __cil_tmp34 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  int tmp___1 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
#line 624
  c = dest;
#line 625
  e = 0;
#line 627
  pi = (opj_pi_iterator_t *)((void *)0);
#line 629
  image = t2->image;
#line 630
  cp = t2->cp;
#line 631
  tcp = cp->tcps + tileno;
#line 632
  if ((unsigned int )cp->cinema == 3U) {
#line 632
    tmp = 2;
  } else {
#line 632
    tmp = 1;
  }
#line 632
  pocno = tmp;
#line 633
  if (cp->max_comp_size > 0) {
#line 633
    tmp___0 = image->numcomps;
  } else {
#line 633
    tmp___0 = 1;
  }
  {
#line 633
  maxcomp = tmp___0;
#line 635
  pi = pi_initialise_encode(image, cp, tileno, t2_mode);
  }
#line 636
  if (! pi) {
#line 638
    return (- 999);
  }
#line 641
  if ((unsigned int )t2_mode == 0U) {
#line 642
    compno = 0;
    {
#line 642
    while (1) {
      while_continue: /* CIL Label */ ;
#line 642
      if (! (compno < maxcomp)) {
#line 642
        goto while_break;
      }
#line 643
      poc = 0;
      {
#line 643
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 643
        if (! (poc < pocno)) {
#line 643
          goto while_break___0;
        }
        {
#line 644
        comp_len = 0;
#line 645
        tpnum___2 = compno;
#line 646
        __cil_tmp28 = pi_create_encode(pi, cp, tileno, poc, tpnum___2, tppos, t2_mode,
                                       cur_totnum_tp);
        }
#line 646
        if (__cil_tmp28) {
          {
#line 647
          opj_event_msg(t2->cinfo, 1, "Error initializing Packet Iterator\n\334\342U");
#line 648
          pi_destroy(pi, cp, tileno);
          }
#line 649
          return (- 999);
        }
        {
#line 651
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 651
          __cil_tmp29 = pi_next(pi + poc);
          }
#line 651
          if (! __cil_tmp29) {
#line 651
            goto while_break___1;
          }
#line 652
          if ((pi + poc)->layno < maxlayers) {
            {
#line 653
            e = t2_encode_packet(tile, cp->tcps + tileno, pi + poc, c, (int )((dest + len) - c),
                                 cstr_info, tileno);
#line 654
            comp_len += e;
            }
#line 655
            if (e == -999) {
#line 656
              goto while_break___1;
            } else {
#line 658
              c += e;
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 662
        if (e == -999) {
#line 662
          goto while_break___0;
        }
#line 663
        if (cp->max_comp_size) {
#line 664
          if (comp_len > cp->max_comp_size) {
#line 665
            e = - 999;
#line 666
            goto while_break___0;
          }
        }
#line 643
        poc ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 670
      if (e == -999) {
#line 670
        goto while_break;
      }
#line 642
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 673
    pi_create_encode(pi, cp, tileno, pino, tpnum, tppos, t2_mode, cur_totnum_tp);
    }
    {
#line 674
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 674
      __cil_tmp33 = pi_next(pi + pino);
      }
#line 674
      if (! __cil_tmp33) {
#line 674
        goto while_break___2;
      }
#line 675
      if ((pi + pino)->layno < maxlayers) {
        {
#line 676
        e = t2_encode_packet(tile, cp->tcps + tileno, pi + pino, c, (int )((dest + len) - c),
                             cstr_info, tileno);
        }
#line 677
        if (e == -999) {
#line 678
          goto while_break___2;
        } else {
#line 680
          c += e;
        }
#line 683
        if (cstr_info) {
#line 684
          if (cstr_info->index_write) {
#line 685
            info_TL = cstr_info->tile + tileno;
#line 686
            info_PK = info_TL->packet + cstr_info->packno;
#line 687
            if (! cstr_info->packno) {
#line 688
              info_PK->start_pos = info_TL->end_header + 1;
            } else {
#line 690
              if ((int )cp->tp_on | tcp->POC && info_PK->start_pos) {
#line 690
                tmp___1 = info_PK->start_pos;
              } else {
#line 690
                tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
              }
#line 690
              info_PK->start_pos = tmp___1;
            }
#line 692
            info_PK->end_pos = (info_PK->start_pos + e) - 1;
#line 693
            info_PK->end_ph_pos += info_PK->start_pos - 1;
          }
#line 697
          (cstr_info->packno) ++;
        }
#line 700
        (tile->packno) ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 705
  pi_destroy(pi, cp, tileno);
  }
#line 707
  if (e == -999) {
#line 708
    return (e);
  }
#line 711
  return ((int )(c - dest));
}
}
#line 714 "/root/patchweave_new/14/libopenjpeg/t2.c"
int t2_decode_packets(opj_t2_t *t2 , unsigned char *src , int len , int tileno , opj_tcd_tile_t *tile ,
                      opj_codestream_info_t *cstr_info ) 
{ 
  unsigned char *c ;
  opj_pi_iterator_t *pi ;
  int pino ;
  int e ;
  int n ;
  int curtp ;
  int tp_start_packno ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  opj_pi_iterator_t *__cil_tmp16 ;
  opj_bool __cil_tmp17 ;
  opj_packet_info_t *pack_info ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;
  int __cil_tmp22 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  int __cil_tmp25 ;
  int tmp___0 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;

  {
#line 715
  c = src;
#line 717
  e = 0;
#line 718
  n = 0;
  {
#line 718
  curtp = 0;
#line 721
  image = t2->image;
#line 722
  cp = t2->cp;
#line 725
  pi = pi_create_decode(image, cp, tileno);
  }
#line 726
  if (! pi) {
#line 728
    return (- 999);
  }
#line 731
  tp_start_packno = 0;
#line 733
  pino = 0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! (pino <= (cp->tcps + tileno)->numpocs)) {
#line 733
      goto while_break;
    }
    {
#line 734
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 734
      __cil_tmp17 = pi_next(pi + pino);
      }
#line 734
      if (! __cil_tmp17) {
#line 734
        goto while_break___0;
      }
#line 735
      if (cp->layer == 0) {
        _L: /* CIL Label */ 
#line 737
        if (cstr_info) {
#line 738
          pack_info = (cstr_info->tile + tileno)->packet + cstr_info->packno;
        } else {
#line 740
          pack_info = (opj_packet_info_t *)((void *)0);
        }
        {
#line 741
        e = t2_decode_packet(t2, c, (int )((src + len) - c), tile, cp->tcps + tileno,
                             pi + pino, pack_info);
        }
      } else
#line 735
      if (cp->layer >= (pi + pino)->layno + 1) {
#line 735
        goto _L;
      } else {
#line 743
        e = 0;
      }
#line 745
      if (e == -999) {
        {
#line 747
        pi_destroy(pi, cp, tileno);
        }
#line 748
        return (- 999);
      }
#line 751
      if (e > 0) {
        {
#line 751
        __cil_tmp20 = int_max((pi + pino)->resno, (image->comps + (pi + pino)->compno)->resno_decoded);
#line 751
        tmp = __cil_tmp20;
        }
      } else {
#line 751
        tmp = (image->comps + (pi + pino)->compno)->resno_decoded;
      }
#line 751
      (image->comps + (pi + pino)->compno)->resno_decoded = tmp;
#line 755
      n ++;
#line 758
      if (cstr_info) {
#line 759
        info_TL = cstr_info->tile + tileno;
#line 760
        info_PK = info_TL->packet + cstr_info->packno;
#line 761
        if (! cstr_info->packno) {
#line 762
          info_PK->start_pos = info_TL->end_header + 1;
        } else
#line 763
        if ((info_TL->packet + (cstr_info->packno - 1))->end_pos >= (int )((cstr_info->tile + tileno)->tp + curtp)->tp_end_pos) {
#line 764
          (info_TL->tp + curtp)->tp_numpacks = cstr_info->packno - tp_start_packno;
#line 765
          (info_TL->tp + curtp)->tp_start_pack = tp_start_packno;
#line 766
          tp_start_packno = cstr_info->packno;
#line 767
          curtp ++;
#line 768
          info_PK->start_pos = ((cstr_info->tile + tileno)->tp + curtp)->tp_end_header + 1;
        } else {
#line 770
          if ((int )cp->tp_on && info_PK->start_pos) {
#line 770
            tmp___0 = info_PK->start_pos;
          } else {
#line 770
            tmp___0 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
          }
#line 770
          info_PK->start_pos = tmp___0;
        }
#line 772
        info_PK->end_pos = (info_PK->start_pos + e) - 1;
#line 773
        info_PK->end_ph_pos += info_PK->start_pos - 1;
#line 775
        (cstr_info->packno) ++;
      }
#line 779
      if (e == -999) {
#line 780
        goto while_break___0;
      } else {
#line 782
        c += e;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 733
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  if (cstr_info) {
#line 788
    ((cstr_info->tile + tileno)->tp + curtp)->tp_numpacks = cstr_info->packno - tp_start_packno;
#line 789
    ((cstr_info->tile + tileno)->tp + curtp)->tp_start_pack = tp_start_packno;
  }
  {
#line 794
  pi_destroy(pi, cp, tileno);
  }
#line 796
  if (e == -999) {
#line 797
    return (e);
  }
#line 800
  return ((int )(c - src));
}
}
#line 805 "/root/patchweave_new/14/libopenjpeg/t2.c"
opj_t2_t *t2_create(opj_common_ptr cinfo , opj_image_t *image , opj_cp_t *cp ) 
{ 
  opj_t2_t *t2 ;
  void *__cil_tmp5 ;

  {
  {
#line 807
  __cil_tmp5 = malloc(sizeof(opj_t2_t ));
#line 807
  t2 = (opj_t2_t *)__cil_tmp5;
  }
#line 808
  if (! t2) {
#line 808
    return ((opj_t2_t *)((void *)0));
  }
#line 809
  t2->cinfo = cinfo;
#line 810
  t2->image = image;
#line 811
  t2->cp = cp;
#line 813
  return (t2);
}
}
#line 816 "/root/patchweave_new/14/libopenjpeg/t2.c"
void t2_destroy(opj_t2_t *t2 ) 
{ 


  {
#line 817
  if (t2) {
    {
#line 818
    free(t2);
    }
  }
  return;
}
}
#line 3 "/root/patchweave_new/14/libopenjpeg/t1_luts.h"
static char lut_ctxno_zc[1024]  = 
#line 3 "/root/patchweave_new/14/libopenjpeg/t1_luts.h"
  {      (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )3,      (char )3,      (char )6, 
        (char )3,      (char )6,      (char )6,      (char )8, 
        (char )3,      (char )6,      (char )6,      (char )8, 
        (char )6,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8};
#line 38 "/root/patchweave_new/14/libopenjpeg/t1_luts.h"
static char lut_ctxno_sc[256]  = 
#line 38
  {      (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )13,      (char )13,      (char )13,      (char )13, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )13,      (char )12,      (char )13,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )13,      (char )13,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )13,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )11,      (char )12,      (char )11,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )11,      (char )11,      (char )11,      (char )11, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )11,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )11,      (char )11,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )11,      (char )11,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )11,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )11,      (char )11,      (char )11,      (char )11, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )11,      (char )12,      (char )11,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )13,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )13,      (char )13,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )13,      (char )12,      (char )13,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )13,      (char )13,      (char )13,      (char )13};
#line 57 "/root/patchweave_new/14/libopenjpeg/t1_luts.h"
static char lut_spb[256]  = 
#line 57
  {      (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )0, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )1, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )1,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1};
#line 68 "/root/patchweave_new/14/libopenjpeg/t1_luts.h"
static short lut_nmsedec_sig[128]  = 
#line 68
  {      (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )384,      (short )768,      (short )1152, 
        (short )1536,      (short )1920,      (short )2304,      (short )2688, 
        (short )3072,      (short )3456,      (short )3840,      (short )4224, 
        (short )4608,      (short )4992,      (short )5376,      (short )5760, 
        (short )6144,      (short )6528,      (short )6912,      (short )7296, 
        (short )7680,      (short )8064,      (short )8448,      (short )8832, 
        (short )9216,      (short )9600,      (short )9984,      (short )10368, 
        (short )10752,      (short )11136,      (short )11520,      (short )11904, 
        (short )12288,      (short )12672,      (short )13056,      (short )13440, 
        (short )13824,      (short )14208,      (short )14592,      (short )14976, 
        (short )15360,      (short )15744,      (short )16128,      (short )16512, 
        (short )16896,      (short )17280,      (short )17664,      (short )18048, 
        (short )18432,      (short )18816,      (short )19200,      (short )19584, 
        (short )19968,      (short )20352,      (short )20736,      (short )21120, 
        (short )21504,      (short )21888,      (short )22272,      (short )22656, 
        (short )23040,      (short )23424,      (short )23808,      (short )24192, 
        (short )24576,      (short )24960,      (short )25344,      (short )25728, 
        (short )26112,      (short )26496,      (short )26880,      (short )27264, 
        (short )27648,      (short )28032,      (short )28416,      (short )28800, 
        (short )29184,      (short )29568,      (short )29952,      (short )30336};
#line 87 "/root/patchweave_new/14/libopenjpeg/t1_luts.h"
static short lut_nmsedec_sig0[128]  = 
#line 87
  {      (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )128,      (short )128, 
        (short )128,      (short )128,      (short )256,      (short )256, 
        (short )256,      (short )384,      (short )384,      (short )512, 
        (short )512,      (short )640,      (short )640,      (short )768, 
        (short )768,      (short )896,      (short )1024,      (short )1024, 
        (short )1152,      (short )1280,      (short )1408,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2944,      (short )3072, 
        (short )3200,      (short )3328,      (short )3584,      (short )3712, 
        (short )3840,      (short )4096,      (short )4224,      (short )4480, 
        (short )4608,      (short )4864,      (short )4992,      (short )5248, 
        (short )5376,      (short )5632,      (short )5888,      (short )6016, 
        (short )6272,      (short )6528,      (short )6784,      (short )6912, 
        (short )7168,      (short )7424,      (short )7680,      (short )7936, 
        (short )8192,      (short )8448,      (short )8704,      (short )8960, 
        (short )9216,      (short )9472,      (short )9856,      (short )10112, 
        (short )10368,      (short )10624,      (short )11008,      (short )11264, 
        (short )11520,      (short )11904,      (short )12160,      (short )12544, 
        (short )12800,      (short )13184,      (short )13440,      (short )13824, 
        (short )14080,      (short )14464,      (short )14848,      (short )15104, 
        (short )15488,      (short )15872,      (short )16256,      (short )16512, 
        (short )16896,      (short )17280,      (short )17664,      (short )18048, 
        (short )18432,      (short )18816,      (short )19200,      (short )19584, 
        (short )19968,      (short )20352,      (short )20864,      (short )21248, 
        (short )21632,      (short )22016,      (short )22528,      (short )22912, 
        (short )23296,      (short )23808,      (short )24192,      (short )24704, 
        (short )25088,      (short )25600,      (short )25984,      (short )26496, 
        (short )26880,      (short )27392,      (short )27904,      (short )28288, 
        (short )28800,      (short )29312,      (short )29824,      (short )30208, 
        (short )30720,      (short )31232,      (short )31744,      (short )32256};
#line 106 "/root/patchweave_new/14/libopenjpeg/t1_luts.h"
static short lut_nmsedec_ref[128]  = 
#line 106
  {      (short )6144,      (short )6016,      (short )5888,      (short )5760, 
        (short )5632,      (short )5504,      (short )5376,      (short )5248, 
        (short )5120,      (short )4992,      (short )4864,      (short )4736, 
        (short )4608,      (short )4480,      (short )4352,      (short )4224, 
        (short )4096,      (short )3968,      (short )3840,      (short )3712, 
        (short )3584,      (short )3456,      (short )3328,      (short )3200, 
        (short )3072,      (short )2944,      (short )2816,      (short )2688, 
        (short )2560,      (short )2432,      (short )2304,      (short )2176, 
        (short )2048,      (short )1920,      (short )1792,      (short )1664, 
        (short )1536,      (short )1408,      (short )1280,      (short )1152, 
        (short )1024,      (short )896,      (short )768,      (short )640, 
        (short )512,      (short )384,      (short )256,      (short )128, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )128,      (short )256,      (short )384, 
        (short )512,      (short )640,      (short )768,      (short )896, 
        (short )1024,      (short )1152,      (short )1280,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2816,      (short )2944, 
        (short )3072,      (short )3200,      (short )3328,      (short )3456, 
        (short )3584,      (short )3712,      (short )3840,      (short )3968, 
        (short )4096,      (short )4224,      (short )4352,      (short )4480, 
        (short )4608,      (short )4736,      (short )4864,      (short )4992, 
        (short )5120,      (short )5248,      (short )5376,      (short )5504, 
        (short )5632,      (short )5760,      (short )5888,      (short )6016};
#line 125 "/root/patchweave_new/14/libopenjpeg/t1_luts.h"
static short lut_nmsedec_ref0[128]  = 
#line 125
  {      (short )8192,      (short )7936,      (short )7680,      (short )7424, 
        (short )7168,      (short )6912,      (short )6784,      (short )6528, 
        (short )6272,      (short )6016,      (short )5888,      (short )5632, 
        (short )5376,      (short )5248,      (short )4992,      (short )4864, 
        (short )4608,      (short )4480,      (short )4224,      (short )4096, 
        (short )3840,      (short )3712,      (short )3584,      (short )3328, 
        (short )3200,      (short )3072,      (short )2944,      (short )2688, 
        (short )2560,      (short )2432,      (short )2304,      (short )2176, 
        (short )2048,      (short )1920,      (short )1792,      (short )1664, 
        (short )1536,      (short )1408,      (short )1408,      (short )1280, 
        (short )1152,      (short )1024,      (short )1024,      (short )896, 
        (short )768,      (short )768,      (short )640,      (short )640, 
        (short )512,      (short )512,      (short )384,      (short )384, 
        (short )256,      (short )256,      (short )256,      (short )128, 
        (short )128,      (short )128,      (short )128,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )128,      (short )128, 
        (short )128,      (short )128,      (short )256,      (short )256, 
        (short )256,      (short )384,      (short )384,      (short )512, 
        (short )512,      (short )640,      (short )640,      (short )768, 
        (short )768,      (short )896,      (short )1024,      (short )1024, 
        (short )1152,      (short )1280,      (short )1408,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2944,      (short )3072, 
        (short )3200,      (short )3328,      (short )3584,      (short )3712, 
        (short )3840,      (short )4096,      (short )4224,      (short )4480, 
        (short )4608,      (short )4864,      (short )4992,      (short )5248, 
        (short )5376,      (short )5632,      (short )5888,      (short )6016, 
        (short )6272,      (short )6528,      (short )6784,      (short )6912, 
        (short )7168,      (short )7424,      (short )7680,      (short )7936};
#line 42 "/root/patchweave_new/14/libopenjpeg/t1.c"
static char t1_getctxno_zc(int f , int orient ) ;
#line 43
static char t1_getctxno_sc(int f ) ;
#line 44
static int t1_getctxno_mag(int f ) ;
#line 45
static char t1_getspb(int f ) ;
#line 46
static short t1_getnmsedec_sig(int x , int bitpos ) ;
#line 47
static short t1_getnmsedec_ref(int x , int bitpos ) ;
#line 48
static void t1_updateflags(flag_t *flagsp , int s , int stride ) ;
#line 52
static void t1_enc_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , char type , int vsc ) ;
#line 65
__inline static void t1_dec_sigpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf , int vsc ) ;
#line 72
__inline static void t1_dec_sigpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf ) ;
#line 78
__inline static void t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int orient , int oneplushalf , int vsc ) ;
#line 88
static void t1_enc_sigpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , char type ,
                           int cblksty ) ;
#line 98
static void t1_dec_sigpass_raw(opj_t1_t *t1 , int bpno , int orient , int cblksty ) ;
#line 103
static void t1_dec_sigpass_mqc(opj_t1_t *t1 , int bpno , int orient ) ;
#line 107
static void t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , int bpno , int orient ) ;
#line 114
static void t1_enc_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int bpno ,
                                int one , int *nmsedec , char type , int vsc ) ;
#line 126
__inline static void t1_dec_refpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf , int vsc ) ;
#line 133
__inline static void t1_dec_refpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf ) ;
#line 139
__inline static void t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int poshalf , int neghalf , int vsc ) ;
#line 150
static void t1_enc_refpass(opj_t1_t *t1 , int bpno , int *nmsedec , char type , int cblksty ) ;
#line 159
static void t1_dec_refpass_raw(opj_t1_t *t1 , int bpno , int cblksty ) ;
#line 163
static void t1_dec_refpass_mqc(opj_t1_t *t1 , int bpno ) ;
#line 166
static void t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , int bpno ) ;
#line 172
static void t1_enc_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , int partial ,
                                int vsc ) ;
#line 185
static void t1_dec_clnpass_step_partial(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                        int orient , int oneplushalf ) ;
#line 191
static void t1_dec_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf ) ;
#line 197
static void t1_dec_clnpass_step_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                    int oneplushalf , int partial , int vsc ) ;
#line 208
static void t1_enc_clnpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , int cblksty ) ;
#line 217
static void t1_dec_clnpass(opj_t1_t *t1 , int bpno , int orient , int cblksty ) ;
#line 222
static double t1_getwmsedec(int nmsedec , int compno , int level , int orient , int bpno ,
                            int qmfbid , double stepsize , int numcomps , int mct ) ;
#line 246
static void t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , int orient ,
                           int compno , int level , int qmfbid , double stepsize ,
                           int cblksty , int numcomps , int mct , opj_tcd_tile_t *tile ) ;
#line 266
static void t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , int orient ,
                           int roishift , int cblksty ) ;
#line 279 "/root/patchweave_new/14/libopenjpeg/t1.c"
static char t1_getctxno_zc(int f , int orient ) 
{ 


  {
#line 280
  return (lut_ctxno_zc[(orient << 8) | (f & 255)]);
}
}
#line 283 "/root/patchweave_new/14/libopenjpeg/t1.c"
static char t1_getctxno_sc(int f ) 
{ 


  {
#line 284
  return (lut_ctxno_sc[(f & 4080) >> 4]);
}
}
#line 287 "/root/patchweave_new/14/libopenjpeg/t1.c"
static int t1_getctxno_mag(int f ) 
{ 
  int tmp1 ;
  int tmp ;
  int tmp2 ;
  int tmp___0 ;

  {
#line 288
  if (f & 255) {
#line 288
    tmp = 15;
  } else {
#line 288
    tmp = 14;
  }
#line 288
  tmp1 = tmp;
#line 289
  if (f & 8192) {
#line 289
    tmp___0 = 16;
  } else {
#line 289
    tmp___0 = tmp1;
  }
#line 289
  tmp2 = tmp___0;
#line 290
  return (tmp2);
}
}
#line 293 "/root/patchweave_new/14/libopenjpeg/t1.c"
static char t1_getspb(int f ) 
{ 


  {
#line 294
  return (lut_spb[(f & 4080) >> 4]);
}
}
#line 297 "/root/patchweave_new/14/libopenjpeg/t1.c"
static short t1_getnmsedec_sig(int x , int bitpos ) 
{ 


  {
#line 298
  if (bitpos > 6) {
#line 299
    return (lut_nmsedec_sig[(x >> (bitpos - 6)) & ((1 << 7) - 1)]);
  }
#line 302
  return (lut_nmsedec_sig0[x & ((1 << 7) - 1)]);
}
}
#line 305 "/root/patchweave_new/14/libopenjpeg/t1.c"
static short t1_getnmsedec_ref(int x , int bitpos ) 
{ 


  {
#line 306
  if (bitpos > 6) {
#line 307
    return (lut_nmsedec_ref[(x >> (bitpos - 6)) & ((1 << 7) - 1)]);
  }
#line 310
  return (lut_nmsedec_ref0[x & ((1 << 7) - 1)]);
}
}
#line 313 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_updateflags(flag_t *flagsp , int s , int stride ) 
{ 
  flag_t *np ;
  flag_t *sp ;
  static flag_t mod[8] ;

  {
#line 314
  np = flagsp - stride;
#line 315
  sp = flagsp + stride;
#line 317
  mod[0] = (flag_t )64;
#line 317
  mod[1] = (flag_t )1088;
#line 317
  mod[2] = (flag_t )32;
#line 317
  mod[3] = (flag_t )544;
#line 317
  mod[4] = (flag_t )128;
#line 317
  mod[5] = (flag_t )2176;
#line 317
  mod[6] = (flag_t )16;
#line 317
  mod[7] = (flag_t )272;
#line 324
  *(np + - 1) |= 2;
#line 325
  *(np + 0) |= (int )mod[s];
#line 326
  *(np + 1) |= 4;
#line 328
  *(flagsp + - 1) |= (int )mod[s + 2];
#line 329
  *(flagsp + 0) |= 4096;
#line 330
  *(flagsp + 1) |= (int )mod[s + 4];
#line 332
  *(sp + - 1) |= 1;
#line 333
  *(sp + 0) |= (int )mod[s + 6];
#line 334
  *(sp + 1) |= 8;
  return;
}
}
#line 337 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_enc_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , char type , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp14 ;
  int tmp___0 ;
  char __cil_tmp16 ;
  int tmp___1 ;
  int __cil_tmp18 ;
  short __cil_tmp19 ;
  char __cil_tmp20 ;
  char __cil_tmp21 ;

  {
#line 350
  mqc = t1->mqc;
#line 352
  if (vsc) {
#line 352
    tmp = (int )*flagsp & -1095;
  } else {
#line 352
    tmp = (int )*flagsp;
  }
#line 352
  flag = tmp;
#line 353
  if (flag & 255) {
#line 353
    if (! (flag & 20480)) {
      {
#line 354
      __cil_tmp14 = int_abs(*datap);
      }
#line 354
      if (__cil_tmp14 & one) {
#line 354
        tmp___0 = 1;
      } else {
#line 354
        tmp___0 = 0;
      }
      {
#line 354
      v = tmp___0;
#line 355
      __cil_tmp16 = t1_getctxno_zc(flag, orient);
#line 355
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp16];
      }
#line 356
      if ((int )type == 1) {
        {
#line 357
        mqc_bypass_enc(mqc, v);
        }
      } else {
        {
#line 359
        mqc_encode(mqc, v);
        }
      }
#line 361
      if (v) {
#line 362
        if (*datap < 0) {
#line 362
          tmp___1 = 1;
        } else {
#line 362
          tmp___1 = 0;
        }
        {
#line 362
        v = tmp___1;
#line 363
        __cil_tmp18 = int_abs(*datap);
#line 363
        __cil_tmp19 = t1_getnmsedec_sig(__cil_tmp18, bpno + 6);
        }
        {
#line 363
        *nmsedec += (int )__cil_tmp19;
#line 364
        __cil_tmp20 = t1_getctxno_sc(flag);
#line 364
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp20];
        }
#line 365
        if ((int )type == 1) {
          {
#line 366
          mqc_bypass_enc(mqc, v);
          }
        } else {
          {
#line 368
          __cil_tmp21 = t1_getspb(flag);
#line 368
          mqc_encode(mqc, v ^ (int )__cil_tmp21);
          }
        }
        {
#line 370
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 372
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 376 "/root/patchweave_new/14/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_raw_t *raw ;
  int tmp ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int tmp___0 ;

  {
#line 385
  raw = t1->raw;
#line 389
  if (vsc) {
#line 389
    tmp = (int )*flagsp & -1095;
  } else {
#line 389
    tmp = (int )*flagsp;
  }
#line 389
  flag = tmp;
#line 390
  if (flag & 255) {
#line 390
    if (! (flag & 20480)) {
      {
#line 391
      __cil_tmp11 = raw_decode(raw);
      }
#line 391
      if (__cil_tmp11) {
        {
#line 392
        v = raw_decode(raw);
        }
#line 393
        if (v) {
#line 393
          tmp___0 = - oneplushalf;
        } else {
#line 393
          tmp___0 = oneplushalf;
        }
        {
#line 393
        *datap = tmp___0;
#line 394
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 396
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 400 "/root/patchweave_new/14/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int tmp ;

  {
#line 409
  mqc = t1->mqc;
#line 411
  flag = (int )*flagsp;
#line 412
  if (flag & 255) {
#line 412
    if (! (flag & 20480)) {
      {
#line 413
      __cil_tmp9 = t1_getctxno_zc(flag, orient);
#line 413
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 414
      __cil_tmp10 = mqc_decode(mqc);
      }
#line 414
      if (__cil_tmp10) {
        {
#line 415
        __cil_tmp11 = t1_getctxno_sc(flag);
#line 415
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 416
        __cil_tmp13 = t1_getspb(flag);
        }
        {
#line 416
        __cil_tmp12 = mqc_decode(mqc);
#line 416
        v = __cil_tmp12 ^ (int )__cil_tmp13;
        }
#line 417
        if (v) {
#line 417
          tmp = - oneplushalf;
        } else {
#line 417
          tmp = oneplushalf;
        }
        {
#line 417
        *datap = tmp;
#line 418
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 420
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 424 "/root/patchweave_new/14/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int orient , int oneplushalf , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int __cil_tmp14 ;
  char __cil_tmp15 ;
  int tmp___0 ;

  {
#line 434
  mqc = t1->mqc;
#line 436
  if (vsc) {
#line 436
    tmp = (int )*flagsp & -1095;
  } else {
#line 436
    tmp = (int )*flagsp;
  }
#line 436
  flag = tmp;
#line 437
  if (flag & 255) {
#line 437
    if (! (flag & 20480)) {
      {
#line 438
      __cil_tmp11 = t1_getctxno_zc(flag, orient);
#line 438
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 439
      __cil_tmp12 = mqc_decode(mqc);
      }
#line 439
      if (__cil_tmp12) {
        {
#line 440
        __cil_tmp13 = t1_getctxno_sc(flag);
#line 440
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp13];
#line 441
        __cil_tmp15 = t1_getspb(flag);
        }
        {
#line 441
        __cil_tmp14 = mqc_decode(mqc);
#line 441
        v = __cil_tmp14 ^ (int )__cil_tmp15;
        }
#line 442
        if (v) {
#line 442
          tmp___0 = - oneplushalf;
        } else {
#line 442
          tmp___0 = oneplushalf;
        }
        {
#line 442
        *datap = tmp___0;
#line 443
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 445
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 449 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_enc_sigpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , char type ,
                           int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int vsc ;
  int tmp ;

  {
#line 458
  *nmsedec = 0;
#line 459
  one = 1 << (bpno + 6);
#line 460
  k = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (k < t1->h)) {
#line 460
      goto while_break;
    }
#line 461
    i = 0;
    {
#line 461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 461
      if (! (i < t1->w)) {
#line 461
        goto while_break___0;
      }
#line 462
      j = k;
      {
#line 462
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 462
        if (! (j < k + 4 && j < t1->h)) {
#line 462
          goto while_break___1;
        }
#line 463
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 463
          tmp = 1;
        } else {
#line 463
          tmp = 0;
        }
        {
#line 463
        vsc = tmp;
#line 464
        t1_enc_sigpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                            type, vsc);
        }
#line 462
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 461
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 460
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 479 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_dec_sigpass_raw(opj_t1_t *t1 , int bpno , int orient , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int vsc ;
  int tmp ;

  {
#line 486
  one = 1 << bpno;
#line 487
  half = one >> 1;
#line 488
  oneplushalf = one | half;
#line 489
  k = 0;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (k < t1->h)) {
#line 489
      goto while_break;
    }
#line 490
    i = 0;
    {
#line 490
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 490
      if (! (i < t1->w)) {
#line 490
        goto while_break___0;
      }
#line 491
      j = k;
      {
#line 491
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 491
        if (! (j < k + 4 && j < t1->h)) {
#line 491
          goto while_break___1;
        }
#line 492
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 492
          tmp = 1;
        } else {
#line 492
          tmp = 0;
        }
        {
#line 492
        vsc = tmp;
#line 493
        t1_dec_sigpass_step_raw(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                t1->data + (j * t1->w + i), orient, oneplushalf, vsc);
        }
#line 491
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 490
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 489
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 505 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_dec_sigpass_mqc(opj_t1_t *t1 , int bpno , int orient ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int *data1 ;
  flag_t *flags1 ;
  int *data2 ;
  flag_t *flags2 ;
  int *data2___0 ;
  flag_t *flags2___0 ;

  {
#line 511
  data1 = t1->data;
#line 512
  flags1 = t1->flags + 1;
#line 513
  one = 1 << bpno;
#line 514
  half = one >> 1;
#line 515
  oneplushalf = one | half;
#line 516
  k = 0;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (k < (t1->h & -4))) {
#line 516
      goto while_break;
    }
#line 517
    i = 0;
    {
#line 517
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 517
      if (! (i < t1->w)) {
#line 517
        goto while_break___0;
      }
      {
#line 518
      data2 = data1 + i;
#line 519
      flags2 = flags1 + i;
#line 520
      flags2 += t1->flags_stride;
#line 521
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 522
      data2 += t1->w;
#line 523
      flags2 += t1->flags_stride;
#line 524
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 525
      data2 += t1->w;
#line 526
      flags2 += t1->flags_stride;
#line 527
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 528
      data2 += t1->w;
#line 529
      flags2 += t1->flags_stride;
#line 530
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 531
      data2 += t1->w;
      }
#line 517
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 533
    data1 += t1->w << 2;
#line 534
    flags1 += t1->flags_stride << 2;
#line 516
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  i = 0;
  {
#line 536
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 536
    if (! (i < t1->w)) {
#line 536
      goto while_break___1;
    }
#line 537
    data2___0 = data1 + i;
#line 538
    flags2___0 = flags1 + i;
#line 539
    j = k;
    {
#line 539
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 539
      if (! (j < t1->h)) {
#line 539
        goto while_break___2;
      }
      {
#line 540
      flags2___0 += t1->flags_stride;
#line 541
      t1_dec_sigpass_step_mqc(t1, flags2___0, data2___0, orient, oneplushalf);
#line 542
      data2___0 += t1->w;
      }
#line 539
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 536
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 547 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , int bpno , int orient ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int vsc ;
  int tmp ;

  {
#line 553
  one = 1 << bpno;
#line 554
  half = one >> 1;
#line 555
  oneplushalf = one | half;
#line 556
  k = 0;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! (k < t1->h)) {
#line 556
      goto while_break;
    }
#line 557
    i = 0;
    {
#line 557
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      if (! (i < t1->w)) {
#line 557
        goto while_break___0;
      }
#line 558
      j = k;
      {
#line 558
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 558
        if (! (j < k + 4 && j < t1->h)) {
#line 558
          goto while_break___1;
        }
#line 559
        if (j == k + 3 || j == t1->h - 1) {
#line 559
          tmp = 1;
        } else {
#line 559
          tmp = 0;
        }
        {
#line 559
        vsc = tmp;
#line 560
        t1_dec_sigpass_step_mqc_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                    t1->data + (j * t1->w + i), orient, oneplushalf,
                                    vsc);
        }
#line 558
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 557
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 556
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 572 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_enc_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int bpno ,
                                int one , int *nmsedec , char type , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp13 ;
  short __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int __cil_tmp17 ;

  {
#line 584
  mqc = t1->mqc;
#line 586
  if (vsc) {
#line 586
    tmp = (int )*flagsp & -1095;
  } else {
#line 586
    tmp = (int )*flagsp;
  }
#line 586
  flag = tmp;
#line 587
  if ((flag & 20480) == 4096) {
    {
#line 588
    __cil_tmp13 = int_abs(*datap);
#line 588
    __cil_tmp14 = t1_getnmsedec_ref(__cil_tmp13, bpno + 6);
    }
    {
#line 588
    *nmsedec += (int )__cil_tmp14;
#line 589
    __cil_tmp15 = int_abs(*datap);
    }
#line 589
    if (__cil_tmp15 & one) {
#line 589
      tmp___0 = 1;
    } else {
#line 589
      tmp___0 = 0;
    }
    {
#line 589
    v = tmp___0;
#line 590
    __cil_tmp17 = t1_getctxno_mag(flag);
#line 590
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp17];
    }
#line 591
    if ((int )type == 1) {
      {
#line 592
      mqc_bypass_enc(mqc, v);
      }
    } else {
      {
#line 594
      mqc_encode(mqc, v);
      }
    }
#line 596
    *flagsp |= 8192;
  }
  return;
}
}
#line 600 "/root/patchweave_new/14/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf , int vsc ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_raw_t *raw ;
  int tmp ;
  int __cil_tmp12 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 610
  raw = t1->raw;
#line 612
  if (vsc) {
#line 612
    tmp = (int )*flagsp & -1095;
  } else {
#line 612
    tmp = (int )*flagsp;
  }
#line 612
  flag = tmp;
#line 613
  if ((flag & 20480) == 4096) {
    {
#line 614
    v = raw_decode(raw);
    }
#line 615
    if (v) {
#line 615
      tmp___0 = poshalf;
    } else {
#line 615
      tmp___0 = neghalf;
    }
#line 615
    t = tmp___0;
#line 616
    if (*datap < 0) {
#line 616
      tmp___1 = - t;
    } else {
#line 616
      tmp___1 = t;
    }
#line 616
    *datap += tmp___1;
#line 617
    *flagsp |= 8192;
  }
  return;
}
}
#line 621 "/root/patchweave_new/14/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_mqc_t *mqc ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int tmp ;
  int tmp___0 ;

  {
#line 630
  mqc = t1->mqc;
#line 632
  flag = (int )*flagsp;
#line 633
  if ((flag & 20480) == 4096) {
    {
#line 634
    __cil_tmp10 = t1_getctxno_mag(flag);
#line 634
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp10];
#line 635
    v = mqc_decode(mqc);
    }
#line 636
    if (v) {
#line 636
      tmp = poshalf;
    } else {
#line 636
      tmp = neghalf;
    }
#line 636
    t = tmp;
#line 637
    if (*datap < 0) {
#line 637
      tmp___0 = - t;
    } else {
#line 637
      tmp___0 = t;
    }
#line 637
    *datap += tmp___0;
#line 638
    *flagsp |= 8192;
  }
  return;
}
}
#line 642 "/root/patchweave_new/14/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int poshalf , int neghalf , int vsc ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 652
  mqc = t1->mqc;
#line 654
  if (vsc) {
#line 654
    tmp = (int )*flagsp & -1095;
  } else {
#line 654
    tmp = (int )*flagsp;
  }
#line 654
  flag = tmp;
#line 655
  if ((flag & 20480) == 4096) {
    {
#line 656
    __cil_tmp12 = t1_getctxno_mag(flag);
#line 656
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp12];
#line 657
    v = mqc_decode(mqc);
    }
#line 658
    if (v) {
#line 658
      tmp___0 = poshalf;
    } else {
#line 658
      tmp___0 = neghalf;
    }
#line 658
    t = tmp___0;
#line 659
    if (*datap < 0) {
#line 659
      tmp___1 = - t;
    } else {
#line 659
      tmp___1 = t;
    }
#line 659
    *datap += tmp___1;
#line 660
    *flagsp |= 8192;
  }
  return;
}
}
#line 664 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_enc_refpass(opj_t1_t *t1 , int bpno , int *nmsedec , char type , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int vsc ;
  int tmp ;

  {
#line 672
  *nmsedec = 0;
#line 673
  one = 1 << (bpno + 6);
#line 674
  k = 0;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! (k < t1->h)) {
#line 674
      goto while_break;
    }
#line 675
    i = 0;
    {
#line 675
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 675
      if (! (i < t1->w)) {
#line 675
        goto while_break___0;
      }
#line 676
      j = k;
      {
#line 676
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 676
        if (! (j < k + 4 && j < t1->h)) {
#line 676
          goto while_break___1;
        }
#line 677
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 677
          tmp = 1;
        } else {
#line 677
          tmp = 0;
        }
        {
#line 677
        vsc = tmp;
#line 678
        t1_enc_refpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), bpno, one, nmsedec, type,
                            vsc);
        }
#line 676
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 675
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 674
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 692 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_dec_refpass_raw(opj_t1_t *t1 , int bpno , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int vsc ;
  int tmp ;
  int tmp___0 ;

  {
#line 699
  one = 1 << bpno;
#line 700
  poshalf = one >> 1;
#line 701
  if (bpno > 0) {
#line 701
    tmp = - poshalf;
  } else {
#line 701
    tmp = - 1;
  }
#line 701
  neghalf = tmp;
#line 702
  k = 0;
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 702
    if (! (k < t1->h)) {
#line 702
      goto while_break;
    }
#line 703
    i = 0;
    {
#line 703
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 703
      if (! (i < t1->w)) {
#line 703
        goto while_break___0;
      }
#line 704
      j = k;
      {
#line 704
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 704
        if (! (j < k + 4 && j < t1->h)) {
#line 704
          goto while_break___1;
        }
#line 705
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 705
          tmp___0 = 1;
        } else {
#line 705
          tmp___0 = 0;
        }
        {
#line 705
        vsc = tmp___0;
#line 706
        t1_dec_refpass_step_raw(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                t1->data + (j * t1->w + i), poshalf, neghalf, vsc);
        }
#line 704
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 703
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 702
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 718 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_dec_refpass_mqc(opj_t1_t *t1 , int bpno ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int *data1 ;
  flag_t *flags1 ;
  int tmp ;
  int *data2 ;
  flag_t *flags2 ;
  int *data2___0 ;
  flag_t *flags2___0 ;

  {
#line 723
  data1 = t1->data;
#line 724
  flags1 = t1->flags + 1;
#line 725
  one = 1 << bpno;
#line 726
  poshalf = one >> 1;
#line 727
  if (bpno > 0) {
#line 727
    tmp = - poshalf;
  } else {
#line 727
    tmp = - 1;
  }
#line 727
  neghalf = tmp;
#line 728
  k = 0;
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 728
    if (! (k < (t1->h & -4))) {
#line 728
      goto while_break;
    }
#line 729
    i = 0;
    {
#line 729
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 729
      if (! (i < t1->w)) {
#line 729
        goto while_break___0;
      }
      {
#line 730
      data2 = data1 + i;
#line 731
      flags2 = flags1 + i;
#line 732
      flags2 += t1->flags_stride;
#line 733
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 734
      data2 += t1->w;
#line 735
      flags2 += t1->flags_stride;
#line 736
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 737
      data2 += t1->w;
#line 738
      flags2 += t1->flags_stride;
#line 739
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 740
      data2 += t1->w;
#line 741
      flags2 += t1->flags_stride;
#line 742
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 743
      data2 += t1->w;
      }
#line 729
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 745
    data1 += t1->w << 2;
#line 746
    flags1 += t1->flags_stride << 2;
#line 728
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  i = 0;
  {
#line 748
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 748
    if (! (i < t1->w)) {
#line 748
      goto while_break___1;
    }
#line 749
    data2___0 = data1 + i;
#line 750
    flags2___0 = flags1 + i;
#line 751
    j = k;
    {
#line 751
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 751
      if (! (j < t1->h)) {
#line 751
        goto while_break___2;
      }
      {
#line 752
      flags2___0 += t1->flags_stride;
#line 753
      t1_dec_refpass_step_mqc(t1, flags2___0, data2___0, poshalf, neghalf);
#line 754
      data2___0 += t1->w;
      }
#line 751
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 748
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 759 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , int bpno ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int vsc ;
  int tmp ;
  int tmp___0 ;

  {
#line 765
  one = 1 << bpno;
#line 766
  poshalf = one >> 1;
#line 767
  if (bpno > 0) {
#line 767
    tmp = - poshalf;
  } else {
#line 767
    tmp = - 1;
  }
#line 767
  neghalf = tmp;
#line 768
  k = 0;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (! (k < t1->h)) {
#line 768
      goto while_break;
    }
#line 769
    i = 0;
    {
#line 769
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 769
      if (! (i < t1->w)) {
#line 769
        goto while_break___0;
      }
#line 770
      j = k;
      {
#line 770
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 770
        if (! (j < k + 4 && j < t1->h)) {
#line 770
          goto while_break___1;
        }
#line 771
        if (j == k + 3 || j == t1->h - 1) {
#line 771
          tmp___0 = 1;
        } else {
#line 771
          tmp___0 = 0;
        }
        {
#line 771
        vsc = tmp___0;
#line 772
        t1_dec_refpass_step_mqc_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                    t1->data + (j * t1->w + i), poshalf, neghalf,
                                    vsc);
        }
#line 770
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 769
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 768
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 784 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_enc_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , int partial ,
                                int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int __cil_tmp17 ;
  short __cil_tmp18 ;
  char __cil_tmp19 ;
  int tmp___1 ;
  char __cil_tmp21 ;

  {
#line 797
  mqc = t1->mqc;
#line 799
  if (vsc) {
#line 799
    tmp = (int )*flagsp & -1095;
  } else {
#line 799
    tmp = (int )*flagsp;
  }
#line 799
  flag = tmp;
#line 800
  if (partial) {
#line 801
    goto LABEL_PARTIAL;
  }
#line 803
  if (! ((int )*flagsp & 20480)) {
    {
#line 804
    __cil_tmp14 = t1_getctxno_zc(flag, orient);
#line 804
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp14];
#line 805
    __cil_tmp15 = int_abs(*datap);
    }
#line 805
    if (__cil_tmp15 & one) {
#line 805
      tmp___0 = 1;
    } else {
#line 805
      tmp___0 = 0;
    }
    {
#line 805
    v = tmp___0;
#line 806
    mqc_encode(mqc, v);
    }
#line 807
    if (v) {
      LABEL_PARTIAL: 
      {
#line 809
      __cil_tmp17 = int_abs(*datap);
#line 809
      __cil_tmp18 = t1_getnmsedec_sig(__cil_tmp17, bpno + 6);
      }
      {
#line 809
      *nmsedec += (int )__cil_tmp18;
#line 810
      __cil_tmp19 = t1_getctxno_sc(flag);
#line 810
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp19];
      }
#line 811
      if (*datap < 0) {
#line 811
        tmp___1 = 1;
      } else {
#line 811
        tmp___1 = 0;
      }
      {
#line 811
      v = tmp___1;
#line 812
      __cil_tmp21 = t1_getspb(flag);
#line 812
      mqc_encode(mqc, v ^ (int )__cil_tmp21);
#line 813
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 816
  *flagsp &= ~ 16384;
  return;
}
}
#line 819 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_dec_clnpass_step_partial(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                        int orient , int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int tmp ;

  {
  {
#line 827
  mqc = t1->mqc;
#line 831
  flag = (int )*flagsp;
#line 832
  __cil_tmp9 = t1_getctxno_sc(flag);
#line 832
  mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 833
  __cil_tmp11 = t1_getspb(flag);
  }
  {
#line 833
  __cil_tmp10 = mqc_decode(mqc);
#line 833
  v = __cil_tmp10 ^ (int )__cil_tmp11;
  }
#line 834
  if (v) {
#line 834
    tmp = - oneplushalf;
  } else {
#line 834
    tmp = oneplushalf;
  }
  {
#line 834
  *datap = tmp;
#line 835
  t1_updateflags(flagsp, v, t1->flags_stride);
#line 836
  *flagsp &= ~ 16384;
  }
  return;
}
}
#line 839 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_dec_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int tmp ;

  {
#line 848
  mqc = t1->mqc;
#line 850
  flag = (int )*flagsp;
#line 851
  if (! (flag & 20480)) {
    {
#line 852
    __cil_tmp9 = t1_getctxno_zc(flag, orient);
#line 852
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 853
    __cil_tmp10 = mqc_decode(mqc);
    }
#line 853
    if (__cil_tmp10) {
      {
#line 854
      __cil_tmp11 = t1_getctxno_sc(flag);
#line 854
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 855
      __cil_tmp13 = t1_getspb(flag);
      }
      {
#line 855
      __cil_tmp12 = mqc_decode(mqc);
#line 855
      v = __cil_tmp12 ^ (int )__cil_tmp13;
      }
#line 856
      if (v) {
#line 856
        tmp = - oneplushalf;
      } else {
#line 856
        tmp = oneplushalf;
      }
      {
#line 856
      *datap = tmp;
#line 857
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 860
  *flagsp &= ~ 16384;
  return;
}
}
#line 863 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_dec_clnpass_step_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                    int oneplushalf , int partial , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp12 ;
  int __cil_tmp13 ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  char __cil_tmp16 ;
  int tmp___0 ;

  {
#line 874
  mqc = t1->mqc;
#line 876
  if (vsc) {
#line 876
    tmp = (int )*flagsp & -1095;
  } else {
#line 876
    tmp = (int )*flagsp;
  }
#line 876
  flag = tmp;
#line 877
  if (partial) {
#line 878
    goto LABEL_PARTIAL;
  }
#line 880
  if (! (flag & 20480)) {
    {
#line 881
    __cil_tmp12 = t1_getctxno_zc(flag, orient);
#line 881
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp12];
#line 882
    __cil_tmp13 = mqc_decode(mqc);
    }
#line 882
    if (__cil_tmp13) {
      LABEL_PARTIAL: 
      {
#line 884
      __cil_tmp14 = t1_getctxno_sc(flag);
#line 884
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp14];
      }
      {
#line 885
      __cil_tmp16 = t1_getspb(flag);
      }
      {
#line 885
      __cil_tmp15 = mqc_decode(mqc);
#line 885
      v = __cil_tmp15 ^ (int )__cil_tmp16;
      }
#line 886
      if (v) {
#line 886
        tmp___0 = - oneplushalf;
      } else {
#line 886
        tmp___0 = oneplushalf;
      }
      {
#line 886
      *datap = tmp___0;
#line 887
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 890
  *flagsp &= ~ 16384;
  return;
}
}
#line 893 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_enc_clnpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int agg ;
  int runlen ;
  int vsc ;
  opj_mqc_t *mqc ;
  int __cil_tmp14 ;
  int tmp ;

  {
#line 902
  mqc = t1->mqc;
#line 904
  *nmsedec = 0;
#line 905
  one = 1 << (bpno + 6);
#line 906
  k = 0;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! (k < t1->h)) {
#line 906
      goto while_break;
    }
#line 907
    i = 0;
    {
#line 907
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 907
      if (! (i < t1->w)) {
#line 907
        goto while_break___0;
      }
#line 908
      if (k + 3 < t1->h) {
#line 909
        if (cblksty & 8) {
#line 910
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || ((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & -1095) & 20735);
        } else {
#line 916
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & 20735);
        }
      } else {
#line 922
        agg = 0;
      }
#line 924
      if (agg) {
#line 925
        runlen = 0;
        {
#line 925
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 925
          if (! (runlen < 4)) {
#line 925
            goto while_break___1;
          }
          {
#line 926
          __cil_tmp14 = int_abs(*(t1->data + ((k + runlen) * t1->w + i)));
          }
#line 926
          if (__cil_tmp14 & one) {
#line 927
            goto while_break___1;
          }
#line 925
          runlen ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 929
        mqc->curctx = & mqc->ctxs[(int )17];
#line 930
        mqc_encode(mqc, runlen != 4);
        }
#line 931
        if (runlen == 4) {
#line 932
          goto while_continue___0;
        }
        {
#line 934
        mqc->curctx = & mqc->ctxs[(int )18];
#line 935
        mqc_encode(mqc, runlen >> 1);
#line 936
        mqc_encode(mqc, runlen & 1);
        }
      } else {
#line 938
        runlen = 0;
      }
#line 940
      j = k + runlen;
      {
#line 940
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 940
        if (! (j < k + 4 && j < t1->h)) {
#line 940
          goto while_break___2;
        }
#line 941
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 941
          tmp = 1;
        } else {
#line 941
          tmp = 0;
        }
        {
#line 941
        vsc = tmp;
#line 942
        t1_enc_clnpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                            agg && j == k + runlen, vsc);
        }
#line 940
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 907
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 906
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 957 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_dec_clnpass(opj_t1_t *t1 , int bpno , int orient , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int agg ;
  int runlen ;
  int vsc ;
  int segsym ;
  opj_mqc_t *mqc ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int tmp ;
  int *data1 ;
  flag_t *flags1 ;
  int *data2 ;
  flag_t *flags2 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int *data2___0 ;
  flag_t *flags2___0 ;
  int v ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;

  {
#line 964
  segsym = cblksty & 32;
#line 966
  mqc = t1->mqc;
#line 968
  one = 1 << bpno;
#line 969
  half = one >> 1;
#line 970
  oneplushalf = one | half;
#line 971
  if (cblksty & 8) {
#line 972
    k = 0;
    {
#line 972
    while (1) {
      while_continue: /* CIL Label */ ;
#line 972
      if (! (k < t1->h)) {
#line 972
        goto while_break;
      }
#line 973
      i = 0;
      {
#line 973
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 973
        if (! (i < t1->w)) {
#line 973
          goto while_break___0;
        }
#line 974
        if (k + 3 < t1->h) {
#line 975
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || ((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & -1095) & 20735);
        } else {
#line 981
          agg = 0;
        }
#line 983
        if (agg) {
          {
#line 984
          mqc->curctx = & mqc->ctxs[(int )17];
#line 985
          __cil_tmp16 = mqc_decode(mqc);
          }
#line 985
          if (! __cil_tmp16) {
#line 986
            goto while_continue___0;
          }
          {
#line 988
          mqc->curctx = & mqc->ctxs[(int )18];
#line 989
          runlen = mqc_decode(mqc);
#line 990
          __cil_tmp18 = mqc_decode(mqc);
#line 990
          runlen = (runlen << 1) | __cil_tmp18;
          }
        } else {
#line 992
          runlen = 0;
        }
#line 994
        j = k + runlen;
        {
#line 994
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 994
          if (! (j < k + 4 && j < t1->h)) {
#line 994
            goto while_break___1;
          }
#line 995
          if (j == k + 3 || j == t1->h - 1) {
#line 995
            tmp = 1;
          } else {
#line 995
            tmp = 0;
          }
          {
#line 995
          vsc = tmp;
#line 996
          t1_dec_clnpass_step_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                  t1->data + (j * t1->w + i), orient, oneplushalf,
                                  agg && j == k + runlen, vsc);
          }
#line 994
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 973
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 972
      k += 4;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1008
    data1 = t1->data;
#line 1009
    flags1 = t1->flags + 1;
#line 1010
    k = 0;
    {
#line 1010
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1010
      if (! (k < (t1->h & -4))) {
#line 1010
        goto while_break___2;
      }
#line 1011
      i = 0;
      {
#line 1011
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1011
        if (! (i < t1->w)) {
#line 1011
          goto while_break___3;
        }
#line 1012
        data2 = data1 + i;
#line 1013
        flags2 = flags1 + i;
#line 1014
        agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & 20735);
#line 1018
        if (agg) {
          {
#line 1019
          mqc->curctx = & mqc->ctxs[(int )17];
#line 1020
          __cil_tmp24 = mqc_decode(mqc);
          }
#line 1020
          if (! __cil_tmp24) {
#line 1021
            goto while_continue___3;
          }
          {
#line 1023
          mqc->curctx = & mqc->ctxs[(int )18];
#line 1024
          runlen = mqc_decode(mqc);
#line 1025
          __cil_tmp26 = mqc_decode(mqc);
#line 1025
          runlen = (runlen << 1) | __cil_tmp26;
#line 1026
          flags2 += runlen * t1->flags_stride;
#line 1027
          data2 += runlen * t1->w;
#line 1028
          j = k + runlen;
          }
          {
#line 1028
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1028
            if (! (j < k + 4 && j < t1->h)) {
#line 1028
              goto while_break___4;
            }
#line 1029
            flags2 += t1->flags_stride;
#line 1030
            if (agg) {
#line 1030
              if (j == k + runlen) {
                {
#line 1031
                t1_dec_clnpass_step_partial(t1, flags2, data2, orient, oneplushalf);
                }
              } else {
                {
                {
#line 1033
                t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
                }
                }
              }
            } else {
              {
              {
#line 1033
              t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
              }
              }
            }
#line 1035
            data2 += t1->w;
#line 1028
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
          {
#line 1038
          flags2 += t1->flags_stride;
#line 1039
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1040
          data2 += t1->w;
#line 1041
          flags2 += t1->flags_stride;
#line 1042
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1043
          data2 += t1->w;
#line 1044
          flags2 += t1->flags_stride;
#line 1045
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1046
          data2 += t1->w;
#line 1047
          flags2 += t1->flags_stride;
#line 1048
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1049
          data2 += t1->w;
          }
        }
#line 1011
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1052
      data1 += t1->w << 2;
#line 1053
      flags1 += t1->flags_stride << 2;
#line 1010
      k += 4;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1055
    i = 0;
    {
#line 1055
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1055
      if (! (i < t1->w)) {
#line 1055
        goto while_break___5;
      }
#line 1056
      data2___0 = data1 + i;
#line 1057
      flags2___0 = flags1 + i;
#line 1058
      j = k;
      {
#line 1058
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1058
        if (! (j < t1->h)) {
#line 1058
          goto while_break___6;
        }
        {
#line 1059
        flags2___0 += t1->flags_stride;
#line 1060
        t1_dec_clnpass_step(t1, flags2___0, data2___0, orient, oneplushalf);
#line 1061
        data2___0 += t1->w;
        }
#line 1058
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1055
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1066
  if (segsym) {
    {
#line 1067
    v = 0;
#line 1068
    mqc->curctx = & mqc->ctxs[(int )18];
#line 1069
    v = mqc_decode(mqc);
#line 1070
    __cil_tmp31 = mqc_decode(mqc);
#line 1070
    v = (v << 1) | __cil_tmp31;
#line 1071
    __cil_tmp32 = mqc_decode(mqc);
#line 1071
    v = (v << 1) | __cil_tmp32;
#line 1072
    __cil_tmp33 = mqc_decode(mqc);
#line 1072
    v = (v << 1) | __cil_tmp33;
    }
  }
  return;
}
}
#line 1083 "/root/patchweave_new/14/libopenjpeg/t1.c"
static double t1_getwmsedec(int nmsedec , int compno , int level , int orient , int bpno ,
                            int qmfbid , double stepsize , int numcomps , int mct ) 
{ 
  double w1 ;
  double w2 ;
  double wmsedec ;
  double __cil_tmp13 ;
  double tmp ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  double tmp___0 ;
  double __cil_tmp18 ;

  {
#line 1095
  if (qmfbid == 1) {
#line 1096
    if (mct && numcomps == 3) {
      {
#line 1096
      __cil_tmp13 = mct_getnorm(compno);
#line 1096
      tmp = __cil_tmp13;
      }
    } else {
#line 1096
      tmp = 1.;
    }
    {
#line 1096
    w1 = tmp;
#line 1097
    w2 = dwt_getnorm(level, orient);
    }
  } else {
#line 1099
    if (mct && numcomps == 3) {
      {
#line 1099
      __cil_tmp16 = mct_getnorm_real(compno);
#line 1099
      tmp___0 = __cil_tmp16;
      }
    } else {
#line 1099
      tmp___0 = 1.;
    }
    {
#line 1099
    w1 = tmp___0;
#line 1100
    w2 = dwt_getnorm_real(level, orient);
    }
  }
#line 1102
  wmsedec = ((w1 * w2) * stepsize) * (double )(1 << bpno);
#line 1103
  wmsedec *= (wmsedec * (double )nmsedec) / 8192.;
#line 1105
  return (wmsedec);
}
}
#line 1108 "/root/patchweave_new/14/libopenjpeg/t1.c"
static opj_bool allocate_buffers(opj_t1_t *t1 , int w , int h ) 
{ 
  int datasize ;
  int flagssize ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 1113
  datasize = w * h;
#line 1116
  if (datasize > t1->datasize) {
    {
#line 1117
    free(t1->data);
#line 1118
    __cil_tmp6 = malloc((unsigned long )datasize * sizeof(int ));
#line 1118
    t1->data = (int *)__cil_tmp6;
    }
#line 1119
    if (! t1->data) {
#line 1120
      return (0);
    }
#line 1122
    t1->datasize = datasize;
  }
  {
#line 1124
  memset(t1->data, 0, (unsigned long )datasize * sizeof(int ));
#line 1126
  t1->flags_stride = w + 2;
#line 1127
  flagssize = t1->flags_stride * (h + 2);
  }
#line 1129
  if (flagssize > t1->flagssize) {
    {
#line 1130
    free(t1->flags);
#line 1131
    __cil_tmp7 = malloc((unsigned long )flagssize * sizeof(flag_t ));
#line 1131
    t1->flags = (flag_t *)__cil_tmp7;
    }
#line 1132
    if (! t1->flags) {
#line 1133
      return (0);
    }
#line 1135
    t1->flagssize = flagssize;
  }
  {
#line 1137
  memset(t1->flags, 0, (unsigned long )flagssize * sizeof(flag_t ));
#line 1139
  t1->w = w;
#line 1140
  t1->h = h;
  }
#line 1142
  return (1);
}
}
#line 1146 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , int orient ,
                           int compno , int level , int qmfbid , double stepsize ,
                           int cblksty , int numcomps , int mct , opj_tcd_tile_t *tile ) 
{ 
  double cumwmsedec ;
  opj_mqc_t *mqc ;
  int passno ;
  int bpno ;
  int passtype ;
  int nmsedec ;
  int i ;
  int max ;
  char type ;
  double tempwmsedec ;
  int tmp ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int tmp___0 ;
  opj_tcd_pass_t *pass ;
  int correction ;
  int tmp___1 ;
  double __cil_tmp30 ;
  int __cil_tmp31 ;
  int tmp___2 ;
  int __cil_tmp33 ;
  opj_tcd_pass_t *pass___0 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int tmp___3 ;
  int __cil_tmp39 ;

  {
#line 1159
  cumwmsedec = 0.;
#line 1161
  mqc = t1->mqc;
#line 1164
  nmsedec = 0;
#line 1166
  type = (char )0;
#line 1169
  max = 0;
#line 1170
  i = 0;
  {
#line 1170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1170
    if (! (i < t1->w * t1->h)) {
#line 1170
      goto while_break;
    }
    {
#line 1171
    __cil_tmp23 = abs(*(t1->data + i));
#line 1171
    tmp = __cil_tmp23;
#line 1172
    max = int_max(max, tmp);
    }
#line 1170
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1175
  if (max) {
    {
#line 1175
    __cil_tmp25 = int_floorlog2(max);
#line 1175
    tmp___0 = (__cil_tmp25 + 1) - 6;
    }
  } else {
#line 1175
    tmp___0 = 0;
  }
  {
#line 1175
  cblk->numbps = tmp___0;
#line 1177
  bpno = cblk->numbps - 1;
#line 1178
  passtype = 2;
#line 1180
  mqc_resetstates(mqc);
#line 1181
  mqc_setstate(mqc, 18, 0, 46);
#line 1182
  mqc_setstate(mqc, 17, 0, 3);
#line 1183
  mqc_setstate(mqc, 0, 0, 4);
#line 1184
  mqc_init_enc(mqc, cblk->data);
#line 1186
  passno = 0;
  }
  {
#line 1186
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1186
    if (! (bpno >= 0)) {
#line 1186
      goto while_break___0;
    }
#line 1187
    pass = cblk->passes + passno;
#line 1188
    correction = 3;
#line 1189
    if ((bpno < cblk->numbps - 4 && passtype < 2) && cblksty & 1) {
#line 1189
      tmp___1 = 1;
    } else {
#line 1189
      tmp___1 = 0;
    }
#line 1189
    type = (char )tmp___1;
    {
#line 1192
    if (passtype == 0) {
#line 1192
      goto case_0;
    }
#line 1195
    if (passtype == 1) {
#line 1195
      goto case_1;
    }
#line 1198
    if (passtype == 2) {
#line 1198
      goto case_2;
    }
#line 1191
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1193
    t1_enc_sigpass(t1, bpno, orient, & nmsedec, type, cblksty);
    }
#line 1194
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1196
    t1_enc_refpass(t1, bpno, & nmsedec, type, cblksty);
    }
#line 1197
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1199
    t1_enc_clnpass(t1, bpno, orient, & nmsedec, cblksty);
    }
#line 1201
    if (cblksty & 32) {
      {
#line 1202
      mqc_segmark_enc(mqc);
      }
    }
#line 1203
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1207
    tempwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize,
                                numcomps, mct);
#line 1208
    cumwmsedec += tempwmsedec;
#line 1209
    tile->distotile += tempwmsedec;
    }
#line 1212
    if (cblksty & 4) {
#line 1212
      if (! (passtype == 2 && bpno - 1 < 0)) {
#line 1213
        if ((int )type == 1) {
          {
#line 1214
          mqc_flush(mqc);
#line 1215
          correction = 1;
          }
        } else {
          {
#line 1218
          mqc_flush(mqc);
#line 1219
          correction = 1;
          }
        }
#line 1221
        pass->term = 1;
      } else {
#line 1212
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1223
    if (bpno < cblk->numbps - 4) {
#line 1223
      if (passtype > 0) {
        _L: /* CIL Label */ 
#line 1223
        if (cblksty & 1) {
#line 1225
          if ((int )type == 1) {
            {
#line 1226
            mqc_flush(mqc);
#line 1227
            correction = 1;
            }
          } else {
            {
#line 1230
            mqc_flush(mqc);
#line 1231
            correction = 1;
            }
          }
#line 1233
          pass->term = 1;
        } else {
#line 1235
          pass->term = 0;
        }
      } else {
#line 1223
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1223
    if (bpno == cblk->numbps - 4) {
#line 1223
      if (passtype == 2) {
#line 1223
        goto _L;
      } else {
#line 1235
        pass->term = 0;
      }
    } else {
#line 1235
      pass->term = 0;
    }
#line 1239
    passtype ++;
#line 1239
    if (passtype == 3) {
#line 1240
      passtype = 0;
#line 1241
      __cil_tmp31 = bpno;
#line 1241
      bpno --;
    }
#line 1244
    if (pass->term) {
#line 1244
      if (bpno > 0) {
#line 1245
        if ((bpno < cblk->numbps - 4 && passtype < 2) && cblksty & 1) {
#line 1245
          tmp___2 = 1;
        } else {
#line 1245
          tmp___2 = 0;
        }
#line 1245
        type = (char )tmp___2;
#line 1246
        if ((int )type == 1) {
          {
#line 1247
          mqc_bypass_init_enc(mqc);
          }
        } else {
          {
#line 1249
          mqc_restart_init_enc(mqc);
          }
        }
      }
    }
    {
#line 1252
    pass->distortiondec = cumwmsedec;
#line 1253
    __cil_tmp33 = mqc_numbytes(mqc);
#line 1253
    pass->rate = __cil_tmp33 + correction;
    }
#line 1256
    if (cblksty & 2) {
      {
#line 1257
      mqc_reset_enc(mqc);
      }
    }
#line 1186
    passno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1261
  if (cblksty & 16) {
    {
#line 1262
    mqc_erterm_enc(mqc);
    }
  } else
#line 1263
  if (! (cblksty & 1)) {
    {
#line 1264
    mqc_flush(mqc);
    }
  }
#line 1266
  cblk->totalpasses = passno;
#line 1268
  passno = 0;
  {
#line 1268
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1268
    if (! (passno < cblk->totalpasses)) {
#line 1268
      goto while_break___1;
    }
    {
#line 1269
    pass___0 = cblk->passes + passno;
#line 1270
    __cil_tmp35 = mqc_numbytes(mqc);
    }
#line 1270
    if (pass___0->rate > __cil_tmp35) {
      {
#line 1271
      pass___0->rate = mqc_numbytes(mqc);
      }
    }
#line 1273
    if (pass___0->rate > 1) {
#line 1273
      if ((int )*(cblk->data + (pass___0->rate - 1)) == 255) {
#line 1274
        __cil_tmp37 = pass___0->rate;
#line 1274
        (pass___0->rate) --;
      }
    }
#line 1276
    if (passno == 0) {
#line 1276
      tmp___3 = 0;
    } else {
#line 1276
      tmp___3 = (cblk->passes + (passno - 1))->rate;
    }
#line 1276
    pass___0->len = pass___0->rate - tmp___3;
#line 1268
    passno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 1280 "/root/patchweave_new/14/libopenjpeg/t1.c"
static void t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , int orient ,
                           int roishift , int cblksty ) 
{ 
  opj_raw_t *raw ;
  opj_mqc_t *mqc ;
  int bpno ;
  int passtype ;
  int segno ;
  int passno ;
  char type ;
  opj_bool __cil_tmp13 ;
  opj_tcd_seg_t *seg ;
  int tmp ;
  int __cil_tmp16 ;

  {
  {
#line 1287
  raw = t1->raw;
#line 1288
  mqc = t1->mqc;
#line 1292
  type = (char )0;
#line 1294
  __cil_tmp13 = allocate_buffers(t1, cblk->x1 - cblk->x0, cblk->y1 - cblk->y0);
  }
#line 1294
  if (! __cil_tmp13) {
#line 1299
    return;
  }
  {
#line 1302
  bpno = (roishift + cblk->numbps) - 1;
#line 1303
  passtype = 2;
#line 1305
  mqc_resetstates(mqc);
#line 1306
  mqc_setstate(mqc, 18, 0, 46);
#line 1307
  mqc_setstate(mqc, 17, 0, 3);
#line 1308
  mqc_setstate(mqc, 0, 0, 4);
#line 1310
  segno = 0;
  }
  {
#line 1310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1310
    if (! (segno < cblk->numsegs)) {
#line 1310
      goto while_break;
    }
#line 1311
    seg = cblk->segs + segno;
#line 1314
    if ((bpno <= (cblk->numbps - 1) - 4 && passtype < 2) && cblksty & 1) {
#line 1314
      tmp = 1;
    } else {
#line 1314
      tmp = 0;
    }
#line 1314
    type = (char )tmp;
#line 1316
    if (seg->data == (void *)0) {
#line 1317
      goto while_continue;
    }
#line 1319
    if ((int )type == 1) {
      {
#line 1320
      raw_init_dec(raw, *(seg->data) + seg->dataindex, seg->len);
      }
    } else {
      {
#line 1322
      mqc_init_dec(mqc, *(seg->data) + seg->dataindex, seg->len);
      }
    }
#line 1325
    passno = 0;
    {
#line 1325
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1325
      if (! (passno < seg->numpasses)) {
#line 1325
        goto while_break___0;
      }
      {
#line 1327
      if (passtype == 0) {
#line 1327
        goto case_0;
      }
#line 1338
      if (passtype == 1) {
#line 1338
        goto case_1;
      }
#line 1349
      if (passtype == 2) {
#line 1349
        goto case_2;
      }
#line 1326
      goto switch_break;
      case_0: /* CIL Label */ 
#line 1328
      if ((int )type == 1) {
        {
#line 1329
        t1_dec_sigpass_raw(t1, bpno + 1, orient, cblksty);
        }
      } else
#line 1331
      if (cblksty & 8) {
        {
#line 1332
        t1_dec_sigpass_mqc_vsc(t1, bpno + 1, orient);
        }
      } else {
        {
#line 1334
        t1_dec_sigpass_mqc(t1, bpno + 1, orient);
        }
      }
#line 1337
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1339
      if ((int )type == 1) {
        {
#line 1340
        t1_dec_refpass_raw(t1, bpno + 1, cblksty);
        }
      } else
#line 1342
      if (cblksty & 8) {
        {
#line 1343
        t1_dec_refpass_mqc_vsc(t1, bpno + 1);
        }
      } else {
        {
#line 1345
        t1_dec_refpass_mqc(t1, bpno + 1);
        }
      }
#line 1348
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1350
      t1_dec_clnpass(t1, bpno + 1, orient, cblksty);
      }
#line 1351
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1354
      if (cblksty & 2) {
#line 1354
        if ((int )type == 0) {
          {
#line 1355
          mqc_resetstates(mqc);
#line 1356
          mqc_setstate(mqc, 18, 0, 46);
#line 1357
          mqc_setstate(mqc, 17, 0, 3);
#line 1358
          mqc_setstate(mqc, 0, 0, 4);
          }
        }
      }
#line 1360
      passtype ++;
#line 1360
      if (passtype == 3) {
#line 1361
        passtype = 0;
#line 1362
        __cil_tmp16 = bpno;
#line 1362
        bpno --;
      }
#line 1325
      passno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1310
    segno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1370 "/root/patchweave_new/14/libopenjpeg/t1.c"
opj_t1_t *t1_create(opj_common_ptr cinfo ) 
{ 
  opj_t1_t *t1 ;
  void *__cil_tmp3 ;
  opj_mqc_t *__cil_tmp4 ;
  opj_raw_t *__cil_tmp5 ;

  {
  {
#line 1371
  __cil_tmp3 = malloc(sizeof(opj_t1_t ));
#line 1371
  t1 = (opj_t1_t *)__cil_tmp3;
  }
#line 1372
  if (! t1) {
#line 1373
    return ((opj_t1_t *)((void *)0));
  }
  {
#line 1375
  t1->cinfo = cinfo;
#line 1377
  t1->mqc = mqc_create();
#line 1378
  t1->raw = raw_create();
#line 1380
  t1->data = (int *)((void *)0);
#line 1381
  t1->flags = (flag_t *)((void *)0);
#line 1382
  t1->datasize = 0;
#line 1383
  t1->flagssize = 0;
  }
#line 1385
  return (t1);
}
}
#line 1388 "/root/patchweave_new/14/libopenjpeg/t1.c"
void t1_destroy(opj_t1_t *t1 ) 
{ 


  {
#line 1389
  if (t1) {
    {
#line 1391
    mqc_destroy(t1->mqc);
#line 1392
    raw_destroy(t1->raw);
#line 1393
    free(t1->data);
#line 1394
    free(t1->flags);
#line 1395
    free(t1);
    }
  }
  return;
}
}
#line 1399 "/root/patchweave_new/14/libopenjpeg/t1.c"
void t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tccp_t *tccp ;
  int tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  int bandconst ;
  double __cil_tmp15 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  int *datap ;
  int *tiledp ;
  int cblk_w ;
  int cblk_h ;
  int i ;
  int j ;
  int x ;
  int y ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  opj_bool __cil_tmp28 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp31 ;

  {
#line 1406
  tile->distotile = (double )0;
#line 1408
  compno = 0;
  {
#line 1408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1408
    if (! (compno < tile->numcomps)) {
#line 1408
      goto while_break;
    }
#line 1409
    tilec = tile->comps + compno;
#line 1410
    tccp = tcp->tccps + compno;
#line 1411
    tile_w = tilec->x1 - tilec->x0;
#line 1413
    resno = 0;
    {
#line 1413
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1413
      if (! (resno < tilec->numresolutions)) {
#line 1413
        goto while_break___0;
      }
#line 1414
      res = tilec->resolutions + resno;
#line 1416
      bandno = 0;
      {
#line 1416
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1416
        if (! (bandno < res->numbands)) {
#line 1416
          goto while_break___1;
        }
        {
#line 1417
        band = & res->bands[bandno];
#line 1418
        __cil_tmp15 = floor((double )(band->stepsize * (float )8192));
#line 1418
        bandconst = 67108864 / (int )__cil_tmp15;
#line 1420
        precno = 0;
        }
        {
#line 1420
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1420
          if (! (precno < res->pw * res->ph)) {
#line 1420
            goto while_break___2;
          }
#line 1421
          prc = band->precincts + precno;
#line 1423
          cblkno = 0;
          {
#line 1423
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1423
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1423
              goto while_break___3;
            }
#line 1424
            cblk = prc->cblks.enc + cblkno;
#line 1431
            x = cblk->x0 - band->x0;
#line 1432
            y = cblk->y0 - band->y0;
#line 1433
            if (band->bandno & 1) {
#line 1434
              pres = tilec->resolutions + (resno - 1);
#line 1435
              x += pres->x1 - pres->x0;
            }
#line 1437
            if (band->bandno & 2) {
#line 1438
              pres___0 = tilec->resolutions + (resno - 1);
#line 1439
              y += pres___0->y1 - pres___0->y0;
            }
            {
#line 1442
            __cil_tmp28 = allocate_buffers(t1, cblk->x1 - cblk->x0, cblk->y1 - cblk->y0);
            }
#line 1442
            if (! __cil_tmp28) {
#line 1447
              return;
            }
#line 1450
            datap = t1->data;
#line 1451
            cblk_w = t1->w;
#line 1452
            cblk_h = t1->h;
#line 1454
            tiledp = tilec->data + (y * tile_w + x);
#line 1455
            if (tccp->qmfbid == 1) {
#line 1456
              j = 0;
              {
#line 1456
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1456
                if (! (j < cblk_h)) {
#line 1456
                  goto while_break___4;
                }
#line 1457
                i = 0;
                {
#line 1457
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 1457
                  if (! (i < cblk_w)) {
#line 1457
                    goto while_break___5;
                  }
#line 1458
                  tmp = *(tiledp + (j * tile_w + i));
#line 1459
                  *(datap + (j * cblk_w + i)) = tmp << 6;
#line 1457
                  i ++;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 1456
                j ++;
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
#line 1463
              j = 0;
              {
#line 1463
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1463
                if (! (j < cblk_h)) {
#line 1463
                  goto while_break___6;
                }
#line 1464
                i = 0;
                {
#line 1464
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 1464
                  if (! (i < cblk_w)) {
#line 1464
                    goto while_break___7;
                  }
                  {
#line 1465
                  tmp___0 = *(tiledp + (j * tile_w + i));
#line 1466
                  __cil_tmp31 = fix_mul(tmp___0, bandconst);
#line 1466
                  *(datap + (j * cblk_w + i)) = __cil_tmp31 >> 5;
                  }
#line 1464
                  i ++;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 1463
                j ++;
              }
              while_break___6: /* CIL Label */ ;
              }
            }
            {
#line 1474
            t1_encode_cblk(t1, cblk, band->bandno, compno, (tilec->numresolutions - 1) - resno,
                           tccp->qmfbid, (double )band->stepsize, tccp->cblksty, tile->numcomps,
                           tcp->mct, tile);
            }
#line 1423
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1420
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1416
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1413
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1408
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1494 "/root/patchweave_new/14/libopenjpeg/t1.c"
void t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) 
{ 
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *precinct ;
  opj_tcd_cblk_dec_t *cblk ;
  int *datap ;
  int cblk_w ;
  int cblk_h ;
  int x ;
  int y ;
  int i ;
  int j ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  int thresh ;
  int val ;
  int mag ;
  int __cil_tmp25 ;
  int tmp ;
  int *tiledp ;
  int tmp___0 ;
  float *tiledp___0 ;
  float *tiledp2 ;
  float tmp___1 ;
  int *__cil_tmp32 ;
  float *__cil_tmp33 ;

  {
#line 1501
  tile_w = tilec->x1 - tilec->x0;
#line 1503
  resno = 0;
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    if (! (resno < tilec->numresolutions)) {
#line 1503
      goto while_break;
    }
#line 1504
    res = tilec->resolutions + resno;
#line 1506
    bandno = 0;
    {
#line 1506
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1506
      if (! (bandno < res->numbands)) {
#line 1506
        goto while_break___0;
      }
#line 1507
      band = & res->bands[bandno];
#line 1509
      precno = 0;
      {
#line 1509
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1509
        if (! (precno < res->pw * res->ph)) {
#line 1509
          goto while_break___1;
        }
#line 1510
        precinct = band->precincts + precno;
#line 1512
        cblkno = 0;
        {
#line 1512
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1512
          if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1512
            goto while_break___2;
          }
          {
#line 1513
          cblk = precinct->cblks.dec + cblkno;
#line 1519
          t1_decode_cblk(t1, cblk, band->bandno, tccp->roishift, tccp->cblksty);
#line 1526
          x = cblk->x0 - band->x0;
#line 1527
          y = cblk->y0 - band->y0;
          }
#line 1528
          if (band->bandno & 1) {
#line 1529
            pres = tilec->resolutions + (resno - 1);
#line 1530
            x += pres->x1 - pres->x0;
          }
#line 1532
          if (band->bandno & 2) {
#line 1533
            pres___0 = tilec->resolutions + (resno - 1);
#line 1534
            y += pres___0->y1 - pres___0->y0;
          }
#line 1537
          datap = t1->data;
#line 1538
          cblk_w = t1->w;
#line 1539
          cblk_h = t1->h;
#line 1541
          if (tccp->roishift) {
#line 1542
            thresh = 1 << tccp->roishift;
#line 1543
            j = 0;
            {
#line 1543
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1543
              if (! (j < cblk_h)) {
#line 1543
                goto while_break___3;
              }
#line 1544
              i = 0;
              {
#line 1544
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1544
                if (! (i < cblk_w)) {
#line 1544
                  goto while_break___4;
                }
                {
#line 1545
                val = *(datap + (j * cblk_w + i));
#line 1546
                __cil_tmp25 = abs(val);
#line 1546
                mag = __cil_tmp25;
                }
#line 1547
                if (mag >= thresh) {
#line 1548
                  mag >>= tccp->roishift;
#line 1549
                  if (val < 0) {
#line 1549
                    tmp = - mag;
                  } else {
#line 1549
                    tmp = mag;
                  }
#line 1549
                  *(datap + (j * cblk_w + i)) = tmp;
                }
#line 1544
                i ++;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 1543
              j ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 1555
          if (tccp->qmfbid == 1) {
#line 1556
            tiledp = tilec->data + (y * tile_w + x);
#line 1557
            j = 0;
            {
#line 1557
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 1557
              if (! (j < cblk_h)) {
#line 1557
                goto while_break___5;
              }
#line 1558
              i = 0;
              {
#line 1558
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1558
                if (! (i < cblk_w)) {
#line 1558
                  goto while_break___6;
                }
#line 1559
                tmp___0 = *(datap + (j * cblk_w + i));
#line 1560
                *((int *)tiledp + (j * tile_w + i)) = tmp___0 / 2;
#line 1558
                i ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 1557
              j ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          } else {
#line 1564
            tiledp___0 = (float *)(tilec->data + (y * tile_w + x));
#line 1565
            j = 0;
            {
#line 1565
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 1565
              if (! (j < cblk_h)) {
#line 1565
                goto while_break___7;
              }
#line 1566
              tiledp2 = tiledp___0;
#line 1567
              i = 0;
              {
#line 1567
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 1567
                if (! (i < cblk_w)) {
#line 1567
                  goto while_break___8;
                }
#line 1568
                tmp___1 = (float )*datap * band->stepsize;
#line 1569
                *tiledp2 = tmp___1;
#line 1570
                datap ++;
#line 1571
                tiledp2 ++;
#line 1567
                i ++;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 1573
              tiledp___0 += tile_w;
#line 1565
              j ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
          {
#line 1576
          free(cblk->data);
#line 1577
          free(cblk->segs);
          }
#line 1512
          cblkno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1579
        free(precinct->cblks.dec);
#line 1580
        precinct->cblks.dec = (opj_tcd_cblk_dec_t *)((void *)0);
        }
#line 1509
        precno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1506
      bandno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1503
    resno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 45 "/root/patchweave_new/14/libopenjpeg/raw.c"
opj_raw_t *raw_create(void) 
{ 
  opj_raw_t *raw ;
  void *__cil_tmp2 ;

  {
  {
#line 46
  __cil_tmp2 = malloc(sizeof(opj_raw_t ));
#line 46
  raw = (opj_raw_t *)__cil_tmp2;
  }
#line 47
  return (raw);
}
}
#line 50 "/root/patchweave_new/14/libopenjpeg/raw.c"
void raw_destroy(opj_raw_t *raw ) 
{ 


  {
#line 51
  if (raw) {
    {
#line 52
    free(raw);
    }
  }
  return;
}
}
#line 56 "/root/patchweave_new/14/libopenjpeg/raw.c"
int raw_numbytes(opj_raw_t *raw ) 
{ 


  {
#line 57
  return ((int )(raw->bp - raw->start));
}
}
#line 60 "/root/patchweave_new/14/libopenjpeg/raw.c"
void raw_init_dec(opj_raw_t *raw , unsigned char *bp , int len ) 
{ 


  {
#line 61
  raw->start = bp;
#line 62
  raw->lenmax = (unsigned int )len;
#line 63
  raw->len = (unsigned int )0;
#line 64
  raw->c = (unsigned char )0;
#line 65
  raw->ct = (unsigned int )0;
  return;
}
}
#line 68 "/root/patchweave_new/14/libopenjpeg/raw.c"
int raw_decode(opj_raw_t *raw ) 
{ 
  int d ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;

  {
#line 70
  if (raw->ct == 0U) {
#line 71
    raw->ct = (unsigned int )8;
#line 72
    if (raw->len == raw->lenmax) {
#line 73
      raw->c = (unsigned char )255;
    } else {
#line 75
      if ((int )raw->c == 255) {
#line 76
        raw->ct = (unsigned int )7;
      }
#line 78
      raw->c = *(raw->start + raw->len);
#line 79
      (raw->len) ++;
    }
  }
#line 82
  __cil_tmp4 = raw->ct;
#line 82
  (raw->ct) --;
#line 83
  d = ((int )raw->c >> raw->ct) & 1;
#line 85
  return (d);
}
}
#line 46 "/root/patchweave_new/14/libopenjpeg/pi.c"
static opj_bool pi_next_lrcp(opj_pi_iterator_t *pi ) ;
#line 52
static opj_bool pi_next_rlcp(opj_pi_iterator_t *pi ) ;
#line 58
static opj_bool pi_next_rpcl(opj_pi_iterator_t *pi ) ;
#line 64
static opj_bool pi_next_pcrl(opj_pi_iterator_t *pi ) ;
#line 70
static opj_bool pi_next_cprl(opj_pi_iterator_t *pi ) ;
#line 82 "/root/patchweave_new/14/libopenjpeg/pi.c"
static opj_bool pi_next_lrcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___5 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 83
  comp = (opj_pi_comp_t *)((void *)0);
#line 84
  res = (opj_pi_resolution_t *)((void *)0);
#line 85
  index___5 = (long )0;
#line 87
  if (! pi->first) {
#line 88
    comp = pi->comps + pi->compno;
#line 89
    res = comp->resolutions + pi->resno;
#line 90
    goto LABEL_SKIP;
  } else {
#line 92
    pi->first = 0;
  }
#line 95
  pi->layno = pi->poc.layno0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (pi->layno < pi->poc.layno1)) {
#line 95
      goto while_break;
    }
#line 96
    pi->resno = pi->poc.resno0;
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! (pi->resno < pi->poc.resno1)) {
#line 96
        goto while_break___0;
      }
#line 98
      pi->compno = pi->poc.compno0;
      {
#line 98
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 98
        if (! (pi->compno < pi->poc.compno1)) {
#line 98
          goto while_break___1;
        }
#line 99
        comp = pi->comps + pi->compno;
#line 100
        if (pi->resno >= comp->numresolutions) {
#line 101
          goto while_continue___1;
        }
#line 103
        res = comp->resolutions + pi->resno;
#line 104
        if (! pi->tp_on) {
#line 105
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 107
        pi->precno = pi->poc.precno0;
        {
#line 107
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 107
          if (! (pi->precno < pi->poc.precno1)) {
#line 107
            goto while_break___2;
          }
#line 108
          index___5 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 109
          if (! *(pi->include + index___5)) {
#line 110
            *(pi->include + index___5) = (short )1;
#line 111
            return (1);
          }
          LABEL_SKIP: ;
#line 107
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 98
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 97
      (pi->resno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 95
    (pi->layno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (0);
}
}
#line 122 "/root/patchweave_new/14/libopenjpeg/pi.c"
static opj_bool pi_next_rlcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___6 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 123
  comp = (opj_pi_comp_t *)((void *)0);
#line 124
  res = (opj_pi_resolution_t *)((void *)0);
#line 125
  index___6 = (long )0;
#line 127
  if (! pi->first) {
#line 128
    comp = pi->comps + pi->compno;
#line 129
    res = comp->resolutions + pi->resno;
#line 130
    goto LABEL_SKIP;
  } else {
#line 132
    pi->first = 0;
  }
#line 135
  pi->resno = pi->poc.resno0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (pi->resno < pi->poc.resno1)) {
#line 135
      goto while_break;
    }
#line 136
    pi->layno = pi->poc.layno0;
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (pi->layno < pi->poc.layno1)) {
#line 136
        goto while_break___0;
      }
#line 137
      pi->compno = pi->poc.compno0;
      {
#line 137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 137
        if (! (pi->compno < pi->poc.compno1)) {
#line 137
          goto while_break___1;
        }
#line 138
        comp = pi->comps + pi->compno;
#line 139
        if (pi->resno >= comp->numresolutions) {
#line 140
          goto while_continue___1;
        }
#line 142
        res = comp->resolutions + pi->resno;
#line 143
        if (! pi->tp_on) {
#line 144
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 146
        pi->precno = pi->poc.precno0;
        {
#line 146
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 146
          if (! (pi->precno < pi->poc.precno1)) {
#line 146
            goto while_break___2;
          }
#line 147
          index___6 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 148
          if (! *(pi->include + index___6)) {
#line 149
            *(pi->include + index___6) = (short )1;
#line 150
            return (1);
          }
          LABEL_SKIP: ;
#line 146
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 137
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 136
      (pi->layno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 135
    (pi->resno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (0);
}
}
#line 161 "/root/patchweave_new/14/libopenjpeg/pi.c"
static opj_bool pi_next_rpcl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___7 ;
  int compno ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;

  {
#line 162
  comp = (opj_pi_comp_t *)((void *)0);
#line 163
  res = (opj_pi_resolution_t *)((void *)0);
#line 164
  index___7 = (long )0;
#line 166
  if (! pi->first) {
#line 167
    goto LABEL_SKIP;
  } else {
#line 170
    pi->first = 0;
#line 171
    pi->dx = 0;
#line 172
    pi->dy = 0;
#line 173
    compno = 0;
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 173
      if (! (compno < pi->numcomps)) {
#line 173
        goto while_break;
      }
#line 174
      comp = pi->comps + compno;
#line 175
      resno = 0;
      {
#line 175
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 175
        if (! (resno < comp->numresolutions)) {
#line 175
          goto while_break___0;
        }
#line 177
        res = comp->resolutions + resno;
#line 178
        dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 179
        dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 180
        if (! pi->dx) {
#line 180
          tmp = dx;
        } else {
          {
#line 180
          __cil_tmp9 = int_min(pi->dx, dx);
#line 180
          tmp = __cil_tmp9;
          }
        }
#line 180
        pi->dx = tmp;
#line 181
        if (! pi->dy) {
#line 181
          tmp___0 = dy;
        } else {
          {
#line 181
          __cil_tmp11 = int_min(pi->dy, dy);
#line 181
          tmp___0 = __cil_tmp11;
          }
        }
#line 181
        pi->dy = tmp___0;
#line 175
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 173
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 185
  if (! pi->tp_on) {
#line 186
    pi->poc.ty0 = pi->ty0;
#line 187
    pi->poc.tx0 = pi->tx0;
#line 188
    pi->poc.ty1 = pi->ty1;
#line 189
    pi->poc.tx1 = pi->tx1;
  }
#line 191
  pi->resno = pi->poc.resno0;
  {
#line 191
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 191
    if (! (pi->resno < pi->poc.resno1)) {
#line 191
      goto while_break___1;
    }
#line 192
    pi->y = pi->poc.ty0;
    {
#line 192
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 192
      if (! (pi->y < pi->poc.ty1)) {
#line 192
        goto while_break___2;
      }
#line 193
      pi->x = pi->poc.tx0;
      {
#line 193
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 193
        if (! (pi->x < pi->poc.tx1)) {
#line 193
          goto while_break___3;
        }
#line 194
        pi->compno = pi->poc.compno0;
        {
#line 194
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 194
          if (! (pi->compno < pi->poc.compno1)) {
#line 194
            goto while_break___4;
          }
#line 200
          comp = pi->comps + pi->compno;
#line 201
          if (pi->resno >= comp->numresolutions) {
#line 202
            goto while_continue___4;
          }
          {
#line 204
          res = comp->resolutions + pi->resno;
#line 205
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 206
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 207
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 208
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 209
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 210
          rpx = res->pdx + levelno;
#line 211
          rpy = res->pdy + levelno;
          }
#line 212
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 213
            goto while_continue___4;
          }
#line 215
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 216
            goto while_continue___4;
          }
#line 219
          if (res->pw == 0) {
#line 219
            goto while_continue___4;
          } else
#line 219
          if (res->ph == 0) {
#line 219
            goto while_continue___4;
          }
#line 221
          if (trx0 == trx1) {
#line 221
            goto while_continue___4;
          } else
#line 221
          if (try0 == try1) {
#line 221
            goto while_continue___4;
          }
          {
#line 223
          __cil_tmp30 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 223
          __cil_tmp28 = int_ceildiv(pi->x, comp->dx << levelno);
#line 223
          __cil_tmp29 = int_floordivpow2(__cil_tmp28, res->pdx);
#line 223
          prci = __cil_tmp29 - __cil_tmp30;
#line 225
          __cil_tmp33 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 225
          __cil_tmp31 = int_ceildiv(pi->y, comp->dy << levelno);
#line 225
          __cil_tmp32 = int_floordivpow2(__cil_tmp31, res->pdy);
#line 225
          prcj = __cil_tmp32 - __cil_tmp33;
#line 227
          pi->precno = prci + prcj * res->pw;
#line 228
          pi->layno = pi->poc.layno0;
          }
          {
#line 228
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 228
            if (! (pi->layno < pi->poc.layno1)) {
#line 228
              goto while_break___5;
            }
#line 229
            index___7 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 230
            if (! *(pi->include + index___7)) {
#line 231
              *(pi->include + index___7) = (short )1;
#line 232
              return (1);
            }
            LABEL_SKIP: ;
#line 228
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 194
          (pi->compno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 193
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 192
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 191
    (pi->resno) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 241
  return (0);
}
}
#line 244 "/root/patchweave_new/14/libopenjpeg/pi.c"
static opj_bool pi_next_pcrl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___8 ;
  int compno ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;

  {
#line 245
  comp = (opj_pi_comp_t *)((void *)0);
#line 246
  res = (opj_pi_resolution_t *)((void *)0);
#line 247
  index___8 = (long )0;
#line 249
  if (! pi->first) {
#line 250
    comp = pi->comps + pi->compno;
#line 251
    goto LABEL_SKIP;
  } else {
#line 254
    pi->first = 0;
#line 255
    pi->dx = 0;
#line 256
    pi->dy = 0;
#line 257
    compno = 0;
    {
#line 257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 257
      if (! (compno < pi->numcomps)) {
#line 257
        goto while_break;
      }
#line 258
      comp = pi->comps + compno;
#line 259
      resno = 0;
      {
#line 259
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 259
        if (! (resno < comp->numresolutions)) {
#line 259
          goto while_break___0;
        }
#line 261
        res = comp->resolutions + resno;
#line 262
        dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 263
        dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 264
        if (! pi->dx) {
#line 264
          tmp = dx;
        } else {
          {
#line 264
          __cil_tmp9 = int_min(pi->dx, dx);
#line 264
          tmp = __cil_tmp9;
          }
        }
#line 264
        pi->dx = tmp;
#line 265
        if (! pi->dy) {
#line 265
          tmp___0 = dy;
        } else {
          {
#line 265
          __cil_tmp11 = int_min(pi->dy, dy);
#line 265
          tmp___0 = __cil_tmp11;
          }
        }
#line 265
        pi->dy = tmp___0;
#line 259
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 257
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 269
  if (! pi->tp_on) {
#line 270
    pi->poc.ty0 = pi->ty0;
#line 271
    pi->poc.tx0 = pi->tx0;
#line 272
    pi->poc.ty1 = pi->ty1;
#line 273
    pi->poc.tx1 = pi->tx1;
  }
#line 275
  pi->y = pi->poc.ty0;
  {
#line 275
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 275
    if (! (pi->y < pi->poc.ty1)) {
#line 275
      goto while_break___1;
    }
#line 276
    pi->x = pi->poc.tx0;
    {
#line 276
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 276
      if (! (pi->x < pi->poc.tx1)) {
#line 276
        goto while_break___2;
      }
#line 277
      pi->compno = pi->poc.compno0;
      {
#line 277
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 277
        if (! (pi->compno < pi->poc.compno1)) {
#line 277
          goto while_break___3;
        }
#line 278
        comp = pi->comps + pi->compno;
#line 279
        pi->resno = pi->poc.resno0;
        {
#line 279
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 279
          if (! (pi->resno < __cil_tmp15)) {
#line 279
            goto while_break___4;
          }
          {
#line 285
          res = comp->resolutions + pi->resno;
#line 286
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 287
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 288
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 289
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 290
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 291
          rpx = res->pdx + levelno;
#line 292
          rpy = res->pdy + levelno;
          }
#line 293
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 294
            goto while_continue___4;
          }
#line 296
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 297
            goto while_continue___4;
          }
#line 300
          if (res->pw == 0) {
#line 300
            goto while_continue___4;
          } else
#line 300
          if (res->ph == 0) {
#line 300
            goto while_continue___4;
          }
#line 302
          if (trx0 == trx1) {
#line 302
            goto while_continue___4;
          } else
#line 302
          if (try0 == try1) {
#line 302
            goto while_continue___4;
          }
          {
#line 304
          __cil_tmp31 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 304
          __cil_tmp29 = int_ceildiv(pi->x, comp->dx << levelno);
#line 304
          __cil_tmp30 = int_floordivpow2(__cil_tmp29, res->pdx);
#line 304
          prci = __cil_tmp30 - __cil_tmp31;
#line 306
          __cil_tmp34 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 306
          __cil_tmp32 = int_ceildiv(pi->y, comp->dy << levelno);
#line 306
          __cil_tmp33 = int_floordivpow2(__cil_tmp32, res->pdy);
#line 306
          prcj = __cil_tmp33 - __cil_tmp34;
#line 308
          pi->precno = prci + prcj * res->pw;
#line 309
          pi->layno = pi->poc.layno0;
          }
          {
#line 309
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 309
            if (! (pi->layno < pi->poc.layno1)) {
#line 309
              goto while_break___5;
            }
#line 310
            index___8 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 311
            if (! *(pi->include + index___8)) {
#line 312
              *(pi->include + index___8) = (short )1;
#line 313
              return (1);
            }
            LABEL_SKIP: ;
#line 309
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 279
          (pi->resno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 277
        (pi->compno) ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 276
      pi->x += pi->dx - pi->x % pi->dx;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 275
    pi->y += pi->dy - pi->y % pi->dy;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  return (0);
}
}
#line 325 "/root/patchweave_new/14/libopenjpeg/pi.c"
static opj_bool pi_next_cprl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___9 ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp8 ;
  int tmp ;
  int __cil_tmp10 ;
  int tmp___0 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;

  {
#line 326
  comp = (opj_pi_comp_t *)((void *)0);
#line 327
  res = (opj_pi_resolution_t *)((void *)0);
#line 328
  index___9 = (long )0;
#line 330
  if (! pi->first) {
#line 331
    comp = pi->comps + pi->compno;
#line 332
    goto LABEL_SKIP;
  } else {
#line 334
    pi->first = 0;
  }
#line 337
  pi->compno = pi->poc.compno0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (pi->compno < pi->poc.compno1)) {
#line 337
      goto while_break;
    }
#line 339
    comp = pi->comps + pi->compno;
#line 340
    pi->dx = 0;
#line 341
    pi->dy = 0;
#line 342
    resno = 0;
    {
#line 342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 342
      if (! (resno < comp->numresolutions)) {
#line 342
        goto while_break___0;
      }
#line 344
      res = comp->resolutions + resno;
#line 345
      dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 346
      dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 347
      if (! pi->dx) {
#line 347
        tmp = dx;
      } else {
        {
#line 347
        __cil_tmp8 = int_min(pi->dx, dx);
#line 347
        tmp = __cil_tmp8;
        }
      }
#line 347
      pi->dx = tmp;
#line 348
      if (! pi->dy) {
#line 348
        tmp___0 = dy;
      } else {
        {
#line 348
        __cil_tmp10 = int_min(pi->dy, dy);
#line 348
        tmp___0 = __cil_tmp10;
        }
      }
#line 348
      pi->dy = tmp___0;
#line 342
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 350
    if (! pi->tp_on) {
#line 351
      pi->poc.ty0 = pi->ty0;
#line 352
      pi->poc.tx0 = pi->tx0;
#line 353
      pi->poc.ty1 = pi->ty1;
#line 354
      pi->poc.tx1 = pi->tx1;
    }
#line 356
    pi->y = pi->poc.ty0;
    {
#line 356
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 356
      if (! (pi->y < pi->poc.ty1)) {
#line 356
        goto while_break___1;
      }
#line 357
      pi->x = pi->poc.tx0;
      {
#line 357
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 357
        if (! (pi->x < pi->poc.tx1)) {
#line 357
          goto while_break___2;
        }
#line 358
        pi->resno = pi->poc.resno0;
        {
#line 358
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 358
          if (! (pi->resno < __cil_tmp13)) {
#line 358
            goto while_break___3;
          }
          {
#line 364
          res = comp->resolutions + pi->resno;
#line 365
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 366
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 367
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 368
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 369
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 370
          rpx = res->pdx + levelno;
#line 371
          rpy = res->pdy + levelno;
          }
#line 372
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 373
            goto while_continue___3;
          }
#line 375
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 376
            goto while_continue___3;
          }
#line 379
          if (res->pw == 0) {
#line 379
            goto while_continue___3;
          } else
#line 379
          if (res->ph == 0) {
#line 379
            goto while_continue___3;
          }
#line 381
          if (trx0 == trx1) {
#line 381
            goto while_continue___3;
          } else
#line 381
          if (try0 == try1) {
#line 381
            goto while_continue___3;
          }
          {
#line 383
          __cil_tmp29 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 383
          __cil_tmp27 = int_ceildiv(pi->x, comp->dx << levelno);
#line 383
          __cil_tmp28 = int_floordivpow2(__cil_tmp27, res->pdx);
#line 383
          prci = __cil_tmp28 - __cil_tmp29;
#line 385
          __cil_tmp32 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 385
          __cil_tmp30 = int_ceildiv(pi->y, comp->dy << levelno);
#line 385
          __cil_tmp31 = int_floordivpow2(__cil_tmp30, res->pdy);
#line 385
          prcj = __cil_tmp31 - __cil_tmp32;
#line 387
          pi->precno = prci + prcj * res->pw;
#line 388
          pi->layno = pi->poc.layno0;
          }
          {
#line 388
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 388
            if (! (pi->layno < pi->poc.layno1)) {
#line 388
              goto while_break___4;
            }
#line 389
            index___9 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 390
            if (! *(pi->include + index___9)) {
#line 391
              *(pi->include + index___9) = (short )1;
#line 392
              return (1);
            }
            LABEL_SKIP: ;
#line 388
            (pi->layno) ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 358
          (pi->resno) ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 357
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 356
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 337
    (pi->compno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return (0);
}
}
#line 410 "/root/patchweave_new/14/libopenjpeg/pi.c"
opj_pi_iterator_t *pi_create_decode(opj_image_t *image , opj_cp_t *cp , int tileno ) 
{ 
  int p ;
  int q ;
  int compno ;
  int resno ;
  int pino ;
  opj_pi_iterator_t *pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  void *__cil_tmp12 ;
  int maxres ;
  int maxprec ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int tcx0 ;
  int tcy0 ;
  int tcx1 ;
  int tcy1 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int levelno ;
  int rx0 ;
  int ry0 ;
  int rx1 ;
  int ry1 ;
  int px0 ;
  int py0 ;
  int px1 ;
  int py1 ;
  opj_pi_resolution_t *res ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  void *__cil_tmp52 ;
  int __cil_tmp53 ;

  {
  {
#line 413
  pi = (opj_pi_iterator_t *)((void *)0);
#line 414
  tcp = (opj_tcp_t *)((void *)0);
#line 415
  tccp = (opj_tccp_t *)((void *)0);
#line 417
  tcp = cp->tcps + tileno;
#line 419
  __cil_tmp12 = calloc((unsigned long )(tcp->numpocs + 1), sizeof(opj_pi_iterator_t ));
#line 419
  pi = (opj_pi_iterator_t *)__cil_tmp12;
  }
#line 420
  if (! pi) {
#line 422
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 425
  pino = 0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (pino < tcp->numpocs + 1)) {
#line 425
      goto while_break;
    }
    {
#line 426
    maxres = 0;
#line 427
    maxprec = 0;
#line 428
    p = tileno % cp->tw;
#line 429
    q = tileno / cp->tw;
#line 431
    (pi + pino)->tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 432
    (pi + pino)->ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 433
    (pi + pino)->tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 434
    (pi + pino)->ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 435
    (pi + pino)->numcomps = image->numcomps;
#line 437
    __cil_tmp19 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 437
    (pi + pino)->comps = (opj_pi_comp_t *)__cil_tmp19;
    }
#line 438
    if (! (pi + pino)->comps) {
      {
#line 440
      pi_destroy(pi, cp, tileno);
      }
#line 441
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 444
    compno = 0;
    {
#line 444
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 444
      if (! (compno < pi->numcomps)) {
#line 444
        goto while_break___0;
      }
      {
#line 446
      comp = (pi + pino)->comps + compno;
#line 447
      tccp = tcp->tccps + compno;
#line 448
      comp->dx = (image->comps + compno)->dx;
#line 449
      comp->dy = (image->comps + compno)->dy;
#line 450
      comp->numresolutions = tccp->numresolutions;
#line 452
      __cil_tmp25 = calloc((unsigned long )comp->numresolutions, sizeof(opj_pi_resolution_t ));
#line 452
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp25;
      }
#line 453
      if (! comp->resolutions) {
        {
#line 455
        pi_destroy(pi, cp, tileno);
        }
#line 456
        return ((opj_pi_iterator_t *)((void *)0));
      }
      {
#line 459
      tcx0 = int_ceildiv(pi->tx0, comp->dx);
#line 460
      tcy0 = int_ceildiv(pi->ty0, comp->dy);
#line 461
      tcx1 = int_ceildiv(pi->tx1, comp->dx);
#line 462
      tcy1 = int_ceildiv(pi->ty1, comp->dy);
      }
#line 463
      if (comp->numresolutions > maxres) {
#line 464
        maxres = comp->numresolutions;
      }
#line 467
      resno = 0;
      {
#line 467
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 467
        if (! (resno < comp->numresolutions)) {
#line 467
          goto while_break___1;
        }
#line 471
        res = comp->resolutions + resno;
#line 472
        if (tccp->csty & 1) {
#line 473
          res->pdx = tccp->prcw[resno];
#line 474
          res->pdy = tccp->prch[resno];
        } else {
#line 476
          res->pdx = 15;
#line 477
          res->pdy = 15;
        }
        {
#line 479
        levelno = (comp->numresolutions - 1) - resno;
#line 480
        rx0 = int_ceildivpow2(tcx0, levelno);
#line 481
        ry0 = int_ceildivpow2(tcy0, levelno);
#line 482
        rx1 = int_ceildivpow2(tcx1, levelno);
#line 483
        ry1 = int_ceildivpow2(tcy1, levelno);
#line 484
        __cil_tmp44 = int_floordivpow2(rx0, res->pdx);
#line 484
        px0 = __cil_tmp44 << res->pdx;
#line 485
        __cil_tmp45 = int_floordivpow2(ry0, res->pdy);
#line 485
        py0 = __cil_tmp45 << res->pdy;
#line 486
        __cil_tmp46 = int_ceildivpow2(rx1, res->pdx);
#line 486
        px1 = __cil_tmp46 << res->pdx;
#line 487
        __cil_tmp47 = int_ceildivpow2(ry1, res->pdy);
#line 487
        py1 = __cil_tmp47 << res->pdy;
        }
#line 488
        if (rx0 == rx1) {
#line 488
          tmp = 0;
        } else {
#line 488
          tmp = (px1 - px0) >> res->pdx;
        }
#line 488
        res->pw = tmp;
#line 489
        if (ry0 == ry1) {
#line 489
          tmp___0 = 0;
        } else {
#line 489
          tmp___0 = (py1 - py0) >> res->pdy;
        }
#line 489
        res->ph = tmp___0;
#line 491
        if (res->pw * res->ph > maxprec) {
#line 492
          maxprec = res->pw * res->ph;
        }
#line 467
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 444
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 498
    tccp = tcp->tccps + 0;
#line 499
    (pi + pino)->step_p = 1;
#line 500
    (pi + pino)->step_c = maxprec * (pi + pino)->step_p;
#line 501
    (pi + pino)->step_r = image->numcomps * (pi + pino)->step_c;
#line 502
    (pi + pino)->step_l = maxres * (pi + pino)->step_r;
#line 504
    if (pino == 0) {
      {
#line 505
      __cil_tmp52 = calloc((unsigned long )(((image->numcomps * maxres) * tcp->numlayers) * maxprec),
                           sizeof(short ));
#line 505
      (pi + pino)->include = (short *)__cil_tmp52;
      }
#line 506
      if (! (pi + pino)->include) {
        {
#line 508
        pi_destroy(pi, cp, tileno);
        }
#line 509
        return ((opj_pi_iterator_t *)((void *)0));
      }
    } else {
#line 513
      (pi + pino)->include = (pi + (pino - 1))->include;
    }
#line 516
    if (tcp->POC == 0) {
#line 517
      (pi + pino)->first = 1;
#line 518
      (pi + pino)->poc.resno0 = 0;
#line 519
      (pi + pino)->poc.compno0 = 0;
#line 520
      (pi + pino)->poc.layno1 = tcp->numlayers;
#line 521
      (pi + pino)->poc.resno1 = maxres;
#line 522
      (pi + pino)->poc.compno1 = image->numcomps;
#line 523
      (pi + pino)->poc.prg = tcp->prg;
    } else {
#line 525
      (pi + pino)->first = 1;
#line 526
      (pi + pino)->poc.resno0 = tcp->pocs[pino].resno0;
#line 527
      (pi + pino)->poc.compno0 = tcp->pocs[pino].compno0;
#line 528
      (pi + pino)->poc.layno1 = tcp->pocs[pino].layno1;
#line 529
      (pi + pino)->poc.resno1 = tcp->pocs[pino].resno1;
#line 530
      (pi + pino)->poc.compno1 = tcp->pocs[pino].compno1;
#line 531
      (pi + pino)->poc.prg = tcp->pocs[pino].prg;
    }
#line 533
    (pi + pino)->poc.layno0 = 0;
#line 534
    (pi + pino)->poc.precno0 = 0;
#line 535
    (pi + pino)->poc.precno1 = maxprec;
#line 425
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return (pi);
}
}
#line 543 "/root/patchweave_new/14/libopenjpeg/pi.c"
opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , int tileno ,
                                        J2K_T2_MODE t2_mode ) 
{ 
  int p ;
  int q ;
  int pino ;
  int compno ;
  int resno ;
  int maxres ;
  int maxprec ;
  opj_pi_iterator_t *pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  int tcx0 ;
  int tcy0 ;
  int tcx1 ;
  int tcy1 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int levelno ;
  int rx0 ;
  int ry0 ;
  int rx1 ;
  int ry1 ;
  int px0 ;
  int py0 ;
  int px1 ;
  int py1 ;
  opj_pi_resolution_t *res ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  opj_pi_comp_t *comp___0 ;
  int dx ;
  int dy ;
  opj_pi_resolution_t *res___0 ;
  int __cil_tmp57 ;
  int tmp___1 ;
  int __cil_tmp59 ;
  int tmp___2 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  void *__cil_tmp63 ;
  int tmp___3 ;
  int __cil_tmp65 ;

  {
  {
#line 546
  maxres = 0;
#line 547
  maxprec = 0;
#line 548
  pi = (opj_pi_iterator_t *)((void *)0);
#line 549
  tcp = (opj_tcp_t *)((void *)0);
#line 550
  tccp = (opj_tccp_t *)((void *)0);
#line 552
  tcp = cp->tcps + tileno;
#line 554
  __cil_tmp15 = calloc((unsigned long )(tcp->numpocs + 1), sizeof(opj_pi_iterator_t ));
#line 554
  pi = (opj_pi_iterator_t *)__cil_tmp15;
  }
#line 555
  if (! pi) {
#line 555
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 556
  pi->tp_on = cp->tp_on;
#line 558
  pino = 0;
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (pino < tcp->numpocs + 1)) {
#line 558
      goto while_break;
    }
    {
#line 559
    p = tileno % cp->tw;
#line 560
    q = tileno / cp->tw;
#line 562
    (pi + pino)->tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 563
    (pi + pino)->ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 564
    (pi + pino)->tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 565
    (pi + pino)->ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 566
    (pi + pino)->numcomps = image->numcomps;
#line 568
    __cil_tmp20 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 568
    (pi + pino)->comps = (opj_pi_comp_t *)__cil_tmp20;
    }
#line 569
    if (! (pi + pino)->comps) {
      {
#line 570
      pi_destroy(pi, cp, tileno);
      }
#line 571
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 574
    compno = 0;
    {
#line 574
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 574
      if (! (compno < (pi + pino)->numcomps)) {
#line 574
        goto while_break___0;
      }
      {
#line 576
      comp = (pi + pino)->comps + compno;
#line 577
      tccp = tcp->tccps + compno;
#line 578
      comp->dx = (image->comps + compno)->dx;
#line 579
      comp->dy = (image->comps + compno)->dy;
#line 580
      comp->numresolutions = tccp->numresolutions;
#line 582
      __cil_tmp26 = malloc((unsigned long )comp->numresolutions * sizeof(opj_pi_resolution_t ));
#line 582
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp26;
      }
#line 583
      if (! comp->resolutions) {
        {
#line 584
        pi_destroy(pi, cp, tileno);
        }
#line 585
        return ((opj_pi_iterator_t *)((void *)0));
      }
      {
#line 588
      tcx0 = int_ceildiv((pi + pino)->tx0, comp->dx);
#line 589
      tcy0 = int_ceildiv((pi + pino)->ty0, comp->dy);
#line 590
      tcx1 = int_ceildiv((pi + pino)->tx1, comp->dx);
#line 591
      tcy1 = int_ceildiv((pi + pino)->ty1, comp->dy);
      }
#line 592
      if (comp->numresolutions > maxres) {
#line 593
        maxres = comp->numresolutions;
      }
#line 596
      resno = 0;
      {
#line 596
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 596
        if (! (resno < comp->numresolutions)) {
#line 596
          goto while_break___1;
        }
#line 600
        res = comp->resolutions + resno;
#line 601
        if (tccp->csty & 1) {
#line 602
          res->pdx = tccp->prcw[resno];
#line 603
          res->pdy = tccp->prch[resno];
        } else {
#line 605
          res->pdx = 15;
#line 606
          res->pdy = 15;
        }
        {
#line 608
        levelno = (comp->numresolutions - 1) - resno;
#line 609
        rx0 = int_ceildivpow2(tcx0, levelno);
#line 610
        ry0 = int_ceildivpow2(tcy0, levelno);
#line 611
        rx1 = int_ceildivpow2(tcx1, levelno);
#line 612
        ry1 = int_ceildivpow2(tcy1, levelno);
#line 613
        __cil_tmp45 = int_floordivpow2(rx0, res->pdx);
#line 613
        px0 = __cil_tmp45 << res->pdx;
#line 614
        __cil_tmp46 = int_floordivpow2(ry0, res->pdy);
#line 614
        py0 = __cil_tmp46 << res->pdy;
#line 615
        __cil_tmp47 = int_ceildivpow2(rx1, res->pdx);
#line 615
        px1 = __cil_tmp47 << res->pdx;
#line 616
        __cil_tmp48 = int_ceildivpow2(ry1, res->pdy);
#line 616
        py1 = __cil_tmp48 << res->pdy;
        }
#line 617
        if (rx0 == rx1) {
#line 617
          tmp = 0;
        } else {
#line 617
          tmp = (px1 - px0) >> res->pdx;
        }
#line 617
        res->pw = tmp;
#line 618
        if (ry0 == ry1) {
#line 618
          tmp___0 = 0;
        } else {
#line 618
          tmp___0 = (py1 - py0) >> res->pdy;
        }
#line 618
        res->ph = tmp___0;
#line 620
        if (res->pw * res->ph > maxprec) {
#line 621
          maxprec = res->pw * res->ph;
        }
#line 596
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 574
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 626
    tccp = tcp->tccps + 0;
#line 627
    (pi + pino)->step_p = 1;
#line 628
    (pi + pino)->step_c = maxprec * (pi + pino)->step_p;
#line 629
    (pi + pino)->step_r = image->numcomps * (pi + pino)->step_c;
#line 630
    (pi + pino)->step_l = maxres * (pi + pino)->step_r;
#line 632
    compno = 0;
    {
#line 632
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 632
      if (! (compno < pi->numcomps)) {
#line 632
        goto while_break___2;
      }
#line 633
      comp___0 = pi->comps + compno;
#line 634
      resno = 0;
      {
#line 634
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 634
        if (! (resno < comp___0->numresolutions)) {
#line 634
          goto while_break___3;
        }
#line 636
        res___0 = comp___0->resolutions + resno;
#line 637
        dx = comp___0->dx * (1 << (((res___0->pdx + comp___0->numresolutions) - 1) - resno));
#line 638
        dy = comp___0->dy * (1 << (((res___0->pdy + comp___0->numresolutions) - 1) - resno));
#line 639
        if (! pi->dx) {
#line 639
          tmp___1 = dx;
        } else {
          {
#line 639
          __cil_tmp57 = int_min(pi->dx, dx);
#line 639
          tmp___1 = __cil_tmp57;
          }
        }
#line 639
        (pi + pino)->dx = tmp___1;
#line 640
        if (! pi->dy) {
#line 640
          tmp___2 = dy;
        } else {
          {
#line 640
          __cil_tmp59 = int_min(pi->dy, dy);
#line 640
          tmp___2 = __cil_tmp59;
          }
        }
#line 640
        (pi + pino)->dy = tmp___2;
#line 634
        resno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 632
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 644
    if (pino == 0) {
      {
#line 645
      __cil_tmp63 = calloc((unsigned long )(tcp->numlayers * (pi + pino)->step_l),
                           sizeof(short ));
#line 645
      (pi + pino)->include = (short *)__cil_tmp63;
      }
#line 646
      if (! (pi + pino)->include) {
        {
#line 647
        pi_destroy(pi, cp, tileno);
        }
#line 648
        return ((opj_pi_iterator_t *)((void *)0));
      }
    } else {
#line 652
      (pi + pino)->include = (pi + (pino - 1))->include;
    }
#line 656
    if (tcp->POC) {
#line 656
      if ((unsigned int )cp->cinema) {
        _L___10: /* CIL Label */ 
#line 657
        tcp->pocs[pino].compS = tcp->pocs[pino].compno0;
#line 658
        tcp->pocs[pino].compE = tcp->pocs[pino].compno1;
#line 659
        tcp->pocs[pino].resS = tcp->pocs[pino].resno0;
#line 660
        tcp->pocs[pino].resE = tcp->pocs[pino].resno1;
#line 661
        tcp->pocs[pino].layE = tcp->pocs[pino].layno1;
#line 662
        tcp->pocs[pino].prg = tcp->pocs[pino].prg1;
#line 663
        if (pino > 0) {
#line 664
          if (tcp->pocs[pino].layE > tcp->pocs[pino - 1].layE) {
#line 664
            tmp___3 = tcp->pocs[pino - 1].layE;
          } else {
#line 664
            tmp___3 = 0;
          }
#line 664
          tcp->pocs[pino].layS = tmp___3;
        }
      } else
#line 656
      if (! cp->cinema) {
#line 656
        if ((unsigned int )t2_mode == 1U) {
#line 656
          goto _L___10;
        } else {
#line 656
          goto _L;
        }
      } else {
#line 656
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 666
      tcp->pocs[pino].compS = 0;
#line 667
      tcp->pocs[pino].compE = image->numcomps;
#line 668
      tcp->pocs[pino].resS = 0;
#line 669
      tcp->pocs[pino].resE = maxres;
#line 670
      tcp->pocs[pino].layS = 0;
#line 671
      tcp->pocs[pino].layE = tcp->numlayers;
#line 672
      tcp->pocs[pino].prg = tcp->prg;
    }
#line 674
    tcp->pocs[pino].prcS = 0;
#line 675
    tcp->pocs[pino].prcE = maxprec;
#line 676
    tcp->pocs[pino].txS = (pi + pino)->tx0;
#line 677
    tcp->pocs[pino].txE = (pi + pino)->tx1;
#line 678
    tcp->pocs[pino].tyS = (pi + pino)->ty0;
#line 679
    tcp->pocs[pino].tyE = (pi + pino)->ty1;
#line 680
    tcp->pocs[pino].dx = (pi + pino)->dx;
#line 681
    tcp->pocs[pino].dy = (pi + pino)->dy;
#line 558
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  return (pi);
}
}
#line 688 "/root/patchweave_new/14/libopenjpeg/pi.c"
void pi_destroy(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno ) 
{ 
  int compno ;
  int pino ;
  opj_tcp_t *tcp ;
  opj_pi_comp_t *comp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 690
  tcp = cp->tcps + tileno;
#line 691
  if (pi) {
#line 692
    pino = 0;
    {
#line 692
    while (1) {
      while_continue: /* CIL Label */ ;
#line 692
      if (! (pino < tcp->numpocs + 1)) {
#line 692
        goto while_break;
      }
#line 693
      if ((pi + pino)->comps) {
#line 694
        compno = 0;
        {
#line 694
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 694
          if (! (compno < pi->numcomps)) {
#line 694
            goto while_break___0;
          }
#line 695
          comp = (pi + pino)->comps + compno;
#line 696
          if (comp->resolutions) {
            {
#line 697
            free(comp->resolutions);
            }
          }
#line 694
          compno ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 700
        free((pi + pino)->comps);
        }
      }
#line 692
      pino ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 703
    if (pi->include) {
      {
#line 704
      free(pi->include);
      }
    }
    {
#line 706
    free(pi);
    }
  }
  return;
}
}
#line 710 "/root/patchweave_new/14/libopenjpeg/pi.c"
opj_bool pi_next(opj_pi_iterator_t *pi ) 
{ 
  opj_bool __cil_tmp2 ;
  opj_bool __cil_tmp3 ;
  opj_bool __cil_tmp4 ;
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;

  {
  {
#line 712
  if ((int )pi->poc.prg == 0) {
#line 712
    goto case_0;
  }
#line 714
  if ((int )pi->poc.prg == 1) {
#line 714
    goto case_1;
  }
#line 716
  if ((int )pi->poc.prg == 2) {
#line 716
    goto case_2;
  }
#line 718
  if ((int )pi->poc.prg == 3) {
#line 718
    goto case_3;
  }
#line 720
  if ((int )pi->poc.prg == 4) {
#line 720
    goto case_4;
  }
#line 722
  if ((int )pi->poc.prg == -1) {
#line 722
    goto case_neg_1;
  }
#line 711
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 713
  __cil_tmp2 = pi_next_lrcp(pi);
  }
#line 713
  return (__cil_tmp2);
  case_1: /* CIL Label */ 
  {
#line 715
  __cil_tmp3 = pi_next_rlcp(pi);
  }
#line 715
  return (__cil_tmp3);
  case_2: /* CIL Label */ 
  {
#line 717
  __cil_tmp4 = pi_next_rpcl(pi);
  }
#line 717
  return (__cil_tmp4);
  case_3: /* CIL Label */ 
  {
#line 719
  __cil_tmp5 = pi_next_pcrl(pi);
  }
#line 719
  return (__cil_tmp5);
  case_4: /* CIL Label */ 
  {
#line 721
  __cil_tmp6 = pi_next_cprl(pi);
  }
#line 721
  return (__cil_tmp6);
  case_neg_1: /* CIL Label */ 
#line 723
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 726
  return (0);
}
}
#line 729 "/root/patchweave_new/14/libopenjpeg/pi.c"
opj_bool pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno , int pino ,
                          int tpnum , int tppos , J2K_T2_MODE t2_mode , int cur_totnum_tp ) 
{ 
  char prog[4] ;
  int i ;
  int incr_top ;
  int resetX ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  int __cil_tmp15 ;

  {
#line 732
  incr_top = 1;
#line 732
  resetX = 0;
#line 733
  tcps = cp->tcps + tileno;
#line 734
  tcp = & tcps->pocs[pino];
#line 736
  (pi + pino)->first = 1;
#line 737
  (pi + pino)->poc.prg = tcp->prg;
  {
#line 740
  if ((int )tcp->prg == 4) {
#line 740
    goto case_4;
  }
#line 742
  if ((int )tcp->prg == 0) {
#line 742
    goto case_0;
  }
#line 744
  if ((int )tcp->prg == 3) {
#line 744
    goto case_3;
  }
#line 746
  if ((int )tcp->prg == 1) {
#line 746
    goto case_1;
  }
#line 748
  if ((int )tcp->prg == 2) {
#line 748
    goto case_2;
  }
#line 750
  if ((int )tcp->prg == -1) {
#line 750
    goto case_neg_1;
  }
#line 739
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 740
  strncpy((char *)prog, "CPRL\342U", (unsigned long )4);
  }
#line 741
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 742
  strncpy((char *)prog, "LRCP\342U", (unsigned long )4);
  }
#line 743
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 744
  strncpy((char *)prog, "PCRL", (unsigned long )4);
  }
#line 745
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 746
  strncpy((char *)prog, "RLCP\342U", (unsigned long )4);
  }
#line 747
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 748
  strncpy((char *)prog, "RPCL\342U", (unsigned long )4);
  }
#line 749
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 751
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 754
  if (! ((int )cp->tp_on && ((! cp->cinema && (unsigned int )t2_mode == 1U) || (unsigned int )cp->cinema))) {
#line 755
    (pi + pino)->poc.resno0 = tcp->resS;
#line 756
    (pi + pino)->poc.resno1 = tcp->resE;
#line 757
    (pi + pino)->poc.compno0 = tcp->compS;
#line 758
    (pi + pino)->poc.compno1 = tcp->compE;
#line 759
    (pi + pino)->poc.layno0 = tcp->layS;
#line 760
    (pi + pino)->poc.layno1 = tcp->layE;
#line 761
    (pi + pino)->poc.precno0 = tcp->prcS;
#line 762
    (pi + pino)->poc.precno1 = tcp->prcE;
#line 763
    (pi + pino)->poc.tx0 = tcp->txS;
#line 764
    (pi + pino)->poc.ty0 = tcp->tyS;
#line 765
    (pi + pino)->poc.tx1 = tcp->txE;
#line 766
    (pi + pino)->poc.ty1 = tcp->tyE;
  } else
#line 768
  if (tpnum < cur_totnum_tp) {
#line 769
    i = 3;
    {
#line 769
    while (1) {
      while_continue: /* CIL Label */ ;
#line 769
      if (! (i >= 0)) {
#line 769
        goto while_break;
      }
      {
#line 771
      if ((int )prog[i] == 'C') {
#line 771
        goto case_67;
      }
#line 803
      if ((int )prog[i] == 'R') {
#line 803
        goto case_82;
      }
#line 835
      if ((int )prog[i] == 'L') {
#line 835
        goto case_76;
      }
#line 867
      if ((int )prog[i] == 'P') {
#line 867
        goto case_80;
      }
#line 870
      if ((int )prog[i] == 1) {
#line 870
        goto case_1___0;
      }
#line 870
      if ((int )prog[i] == 0) {
#line 870
        goto case_1___0;
      }
#line 901
      goto switch_default;
      case_67: /* CIL Label */ 
#line 772
      if (i > tppos) {
#line 773
        (pi + pino)->poc.compno0 = tcp->compS;
#line 774
        (pi + pino)->poc.compno1 = tcp->compE;
      } else
#line 776
      if (tpnum == 0) {
#line 777
        tcp->comp_t = tcp->compS;
#line 778
        (pi + pino)->poc.compno0 = tcp->comp_t;
#line 779
        (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 780
        (tcp->comp_t) ++;
      } else
#line 782
      if (incr_top == 1) {
#line 783
        if (tcp->comp_t == tcp->compE) {
#line 784
          tcp->comp_t = tcp->compS;
#line 785
          (pi + pino)->poc.compno0 = tcp->comp_t;
#line 786
          (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 787
          (tcp->comp_t) ++;
#line 788
          incr_top = 1;
        } else {
#line 790
          (pi + pino)->poc.compno0 = tcp->comp_t;
#line 791
          (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 792
          (tcp->comp_t) ++;
#line 793
          incr_top = 0;
        }
      } else {
#line 796
        (pi + pino)->poc.compno0 = tcp->comp_t - 1;
#line 797
        (pi + pino)->poc.compno1 = tcp->comp_t;
      }
#line 801
      goto switch_break___0;
      case_82: /* CIL Label */ 
#line 804
      if (i > tppos) {
#line 805
        (pi + pino)->poc.resno0 = tcp->resS;
#line 806
        (pi + pino)->poc.resno1 = tcp->resE;
      } else
#line 808
      if (tpnum == 0) {
#line 809
        tcp->res_t = tcp->resS;
#line 810
        (pi + pino)->poc.resno0 = tcp->res_t;
#line 811
        (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 812
        (tcp->res_t) ++;
      } else
#line 814
      if (incr_top == 1) {
#line 815
        if (tcp->res_t == tcp->resE) {
#line 816
          tcp->res_t = tcp->resS;
#line 817
          (pi + pino)->poc.resno0 = tcp->res_t;
#line 818
          (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 819
          (tcp->res_t) ++;
#line 820
          incr_top = 1;
        } else {
#line 822
          (pi + pino)->poc.resno0 = tcp->res_t;
#line 823
          (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 824
          (tcp->res_t) ++;
#line 825
          incr_top = 0;
        }
      } else {
#line 828
        (pi + pino)->poc.resno0 = tcp->res_t - 1;
#line 829
        (pi + pino)->poc.resno1 = tcp->res_t;
      }
#line 833
      goto switch_break___0;
      case_76: /* CIL Label */ 
#line 836
      if (i > tppos) {
#line 837
        (pi + pino)->poc.layno0 = tcp->layS;
#line 838
        (pi + pino)->poc.layno1 = tcp->layE;
      } else
#line 840
      if (tpnum == 0) {
#line 841
        tcp->lay_t = tcp->layS;
#line 842
        (pi + pino)->poc.layno0 = tcp->lay_t;
#line 843
        (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 844
        (tcp->lay_t) ++;
      } else
#line 846
      if (incr_top == 1) {
#line 847
        if (tcp->lay_t == tcp->layE) {
#line 848
          tcp->lay_t = tcp->layS;
#line 849
          (pi + pino)->poc.layno0 = tcp->lay_t;
#line 850
          (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 851
          (tcp->lay_t) ++;
#line 852
          incr_top = 1;
        } else {
#line 854
          (pi + pino)->poc.layno0 = tcp->lay_t;
#line 855
          (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 856
          (tcp->lay_t) ++;
#line 857
          incr_top = 0;
        }
      } else {
#line 860
        (pi + pino)->poc.layno0 = tcp->lay_t - 1;
#line 861
        (pi + pino)->poc.layno1 = tcp->lay_t;
      }
#line 865
      goto switch_break___0;
      case_80: /* CIL Label */ 
      {
#line 870
      if ((int )tcp->prg == 1) {
#line 870
        goto case_1___0;
      }
#line 870
      if ((int )tcp->prg == 0) {
#line 870
        goto case_1___0;
      }
#line 901
      goto switch_default;
      case_1___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
#line 871
      if (i > tppos) {
#line 872
        (pi + pino)->poc.precno0 = tcp->prcS;
#line 873
        (pi + pino)->poc.precno1 = tcp->prcE;
      } else
#line 875
      if (tpnum == 0) {
#line 876
        tcp->prc_t = tcp->prcS;
#line 877
        (pi + pino)->poc.precno0 = tcp->prc_t;
#line 878
        (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 879
        (tcp->prc_t) ++;
      } else
#line 881
      if (incr_top == 1) {
#line 882
        if (tcp->prc_t == tcp->prcE) {
#line 883
          tcp->prc_t = tcp->prcS;
#line 884
          (pi + pino)->poc.precno0 = tcp->prc_t;
#line 885
          (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 886
          (tcp->prc_t) ++;
#line 887
          incr_top = 1;
        } else {
#line 889
          (pi + pino)->poc.precno0 = tcp->prc_t;
#line 890
          (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 891
          (tcp->prc_t) ++;
#line 892
          incr_top = 0;
        }
      } else {
#line 895
        (pi + pino)->poc.precno0 = tcp->prc_t - 1;
#line 896
        (pi + pino)->poc.precno1 = tcp->prc_t;
      }
#line 900
      goto switch_break___1;
      switch_default: /* CIL Label */ 
#line 902
      if (i > tppos) {
#line 903
        (pi + pino)->poc.tx0 = tcp->txS;
#line 904
        (pi + pino)->poc.ty0 = tcp->tyS;
#line 905
        (pi + pino)->poc.tx1 = tcp->txE;
#line 906
        (pi + pino)->poc.ty1 = tcp->tyE;
      } else
#line 908
      if (tpnum == 0) {
#line 909
        tcp->tx0_t = tcp->txS;
#line 910
        tcp->ty0_t = tcp->tyS;
#line 911
        (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 912
        (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 913
        (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 914
        (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 915
        tcp->tx0_t = (pi + pino)->poc.tx1;
#line 916
        tcp->ty0_t = (pi + pino)->poc.ty1;
      } else
#line 918
      if (incr_top == 1) {
#line 919
        if (tcp->tx0_t >= tcp->txE) {
#line 920
          if (tcp->ty0_t >= tcp->tyE) {
#line 921
            tcp->ty0_t = tcp->tyS;
#line 922
            (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 923
            (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 924
            tcp->ty0_t = (pi + pino)->poc.ty1;
#line 925
            incr_top = 1;
#line 925
            resetX = 1;
          } else {
#line 927
            (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 928
            (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 929
            tcp->ty0_t = (pi + pino)->poc.ty1;
#line 930
            incr_top = 0;
#line 930
            resetX = 1;
          }
#line 932
          if (resetX == 1) {
#line 933
            tcp->tx0_t = tcp->txS;
#line 934
            (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 935
            (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 936
            tcp->tx0_t = (pi + pino)->poc.tx1;
          }
        } else {
#line 939
          (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 940
          (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 941
          tcp->tx0_t = (pi + pino)->poc.tx1;
#line 942
          (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 943
          (pi + pino)->poc.ty1 = tcp->ty0_t;
#line 944
          incr_top = 0;
        }
      } else {
#line 947
        (pi + pino)->poc.tx0 = (tcp->tx0_t - tcp->dx) - tcp->tx0_t % tcp->dx;
#line 948
        (pi + pino)->poc.tx1 = tcp->tx0_t;
#line 949
        (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 950
        (pi + pino)->poc.ty1 = tcp->ty0_t;
      }
#line 954
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 956
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 769
      __cil_tmp15 = i;
#line 769
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 961
  return (0);
}
}
#line 61 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
char const   *opj_version(void) 
{ 


  {
#line 62
  return ("1.5.2");
}
}
#line 65 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) 
{ 
  opj_dinfo_t *dinfo ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 66
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_dinfo_t ));
#line 66
  dinfo = (opj_dinfo_t *)__cil_tmp3;
  }
#line 67
  if (! dinfo) {
#line 67
    return ((opj_dinfo_t *)((void *)0));
  }
#line 68
  dinfo->is_decompressor = 1;
  {
#line 71
  if ((int )format == 1) {
#line 71
    goto case_1;
  }
#line 71
  if ((int )format == 0) {
#line 71
    goto case_1;
  }
#line 79
  if ((int )format == 2) {
#line 79
    goto case_2;
  }
#line 88
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 73
  __cil_tmp4 = j2k_create_decompress((opj_common_ptr )dinfo);
#line 73
  dinfo->j2k_handle = (void *)__cil_tmp4;
  }
#line 74
  if (! dinfo->j2k_handle) {
    {
#line 75
    free(dinfo);
    }
#line 76
    return ((opj_dinfo_t *)((void *)0));
  }
#line 78
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 81
  __cil_tmp5 = jp2_create_decompress((opj_common_ptr )dinfo);
#line 81
  dinfo->jp2_handle = (void *)__cil_tmp5;
  }
#line 82
  if (! dinfo->jp2_handle) {
    {
#line 83
    free(dinfo);
    }
#line 84
    return ((opj_dinfo_t *)((void *)0));
  }
#line 86
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  {
#line 89
  free(dinfo);
  }
#line 90
  return ((opj_dinfo_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 93
  dinfo->codec_format = format;
#line 95
  return (dinfo);
}
}
#line 98 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
void opj_destroy_decompress(opj_dinfo_t *dinfo ) 
{ 


  {
#line 99
  if (dinfo) {
    {
#line 103
    if ((int )dinfo->codec_format == 1) {
#line 103
      goto case_1;
    }
#line 103
    if ((int )dinfo->codec_format == 0) {
#line 103
      goto case_1;
    }
#line 106
    if ((int )dinfo->codec_format == 2) {
#line 106
      goto case_2;
    }
#line 110
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 104
    j2k_destroy_decompress((opj_j2k_t *)dinfo->j2k_handle);
    }
#line 105
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 107
    jp2_destroy_decompress((opj_jp2_t *)dinfo->jp2_handle);
    }
#line 108
    goto switch_break;
    switch_default: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 111
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 114
    free(dinfo);
    }
  }
  return;
}
}
#line 118 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) 
{ 


  {
#line 119
  if (parameters) {
    {
#line 120
    memset(parameters, 0, sizeof(opj_dparameters_t ));
#line 122
    parameters->cp_layer = 0;
#line 123
    parameters->cp_reduce = 0;
#line 124
    parameters->cp_limit_decoding = (OPJ_LIMIT_DECODING )0;
#line 126
    parameters->decod_format = - 1;
#line 127
    parameters->cod_format = - 1;
#line 128
    parameters->flags = (unsigned int )0;
    }
  }
  return;
}
}
#line 139 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) 
{ 


  {
#line 140
  if (dinfo) {
#line 140
    if (parameters) {
      {
#line 143
      if ((int )dinfo->codec_format == 1) {
#line 143
        goto case_1;
      }
#line 143
      if ((int )dinfo->codec_format == 0) {
#line 143
        goto case_1;
      }
#line 146
      if ((int )dinfo->codec_format == 2) {
#line 146
        goto case_2;
      }
#line 150
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
      {
#line 144
      j2k_setup_decoder((opj_j2k_t *)dinfo->j2k_handle, parameters);
      }
#line 145
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 147
      jp2_setup_decoder((opj_jp2_t *)dinfo->jp2_handle, parameters);
      }
#line 148
      goto switch_break;
      switch_default: /* CIL Label */ 
      case_neg_1: /* CIL Label */ 
#line 151
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 156 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) 
{ 
  opj_image_t *__cil_tmp3 ;

  {
  {
#line 157
  __cil_tmp3 = opj_decode_with_info(dinfo, cio, (opj_codestream_info_t *)((void *)0));
  }
#line 157
  return (__cil_tmp3);
}
}
#line 160 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *__cil_tmp4 ;
  opj_image_t *__cil_tmp5 ;
  opj_image_t *__cil_tmp6 ;

  {
#line 161
  if (dinfo) {
#line 161
    if (cio) {
      {
#line 163
      if ((int )dinfo->codec_format == 0) {
#line 163
        goto case_0;
      }
#line 165
      if ((int )dinfo->codec_format == 1) {
#line 165
        goto case_1;
      }
#line 167
      if ((int )dinfo->codec_format == 2) {
#line 167
        goto case_2;
      }
#line 170
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 164
      __cil_tmp4 = j2k_decode((opj_j2k_t *)dinfo->j2k_handle, cio, cstr_info);
      }
#line 164
      return (__cil_tmp4);
      case_1: /* CIL Label */ 
      {
#line 166
      __cil_tmp5 = j2k_decode_jpt_stream((opj_j2k_t *)dinfo->j2k_handle, cio, cstr_info);
      }
#line 166
      return (__cil_tmp5);
      case_2: /* CIL Label */ 
      {
#line 168
      __cil_tmp6 = opj_jp2_decode((opj_jp2_t *)dinfo->jp2_handle, cio, cstr_info);
      }
#line 168
      return (__cil_tmp6);
      switch_default: /* CIL Label */ 
      case_neg_1: /* CIL Label */ 
#line 171
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 174
  return ((opj_image_t *)((void *)0));
}
}
#line 177 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) 
{ 
  opj_cinfo_t *cinfo ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 178
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_cinfo_t ));
#line 178
  cinfo = (opj_cinfo_t *)__cil_tmp3;
  }
#line 179
  if (! cinfo) {
#line 179
    return ((opj_cinfo_t *)((void *)0));
  }
#line 180
  cinfo->is_decompressor = 0;
  {
#line 182
  if ((int )format == 0) {
#line 182
    goto case_0;
  }
#line 190
  if ((int )format == 2) {
#line 190
    goto case_2;
  }
#line 200
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 184
  __cil_tmp4 = j2k_create_compress((opj_common_ptr )cinfo);
#line 184
  cinfo->j2k_handle = (void *)__cil_tmp4;
  }
#line 185
  if (! cinfo->j2k_handle) {
    {
#line 186
    free(cinfo);
    }
#line 187
    return ((opj_cinfo_t *)((void *)0));
  }
#line 189
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 192
  __cil_tmp5 = jp2_create_compress((opj_common_ptr )cinfo);
#line 192
  cinfo->jp2_handle = (void *)__cil_tmp5;
  }
#line 193
  if (! cinfo->jp2_handle) {
    {
#line 194
    free(cinfo);
    }
#line 195
    return ((opj_cinfo_t *)((void *)0));
  }
#line 197
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 201
  free(cinfo);
  }
#line 202
  return ((opj_cinfo_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 205
  cinfo->codec_format = format;
#line 207
  return (cinfo);
}
}
#line 210 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
void opj_destroy_compress(opj_cinfo_t *cinfo ) 
{ 


  {
#line 211
  if (cinfo) {
    {
#line 214
    if ((int )cinfo->codec_format == 0) {
#line 214
      goto case_0;
    }
#line 217
    if ((int )cinfo->codec_format == 2) {
#line 217
      goto case_2;
    }
#line 222
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 215
    j2k_destroy_compress((opj_j2k_t *)cinfo->j2k_handle);
    }
#line 216
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 218
    jp2_destroy_compress((opj_jp2_t *)cinfo->jp2_handle);
    }
#line 219
    goto switch_break;
    switch_default: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 223
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 226
    free(cinfo);
    }
  }
  return;
}
}
#line 230 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 231
  if (parameters) {
    {
#line 232
    memset(parameters, 0, sizeof(opj_cparameters_t ));
#line 234
    parameters->cp_cinema = (OPJ_CINEMA_MODE )0;
#line 235
    parameters->max_comp_size = 0;
#line 236
    parameters->numresolution = 6;
#line 237
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 238
    parameters->cblockw_init = 64;
#line 239
    parameters->cblockh_init = 64;
#line 240
    parameters->prog_order = (OPJ_PROG_ORDER )0;
#line 241
    parameters->roi_compno = - 1;
#line 242
    parameters->subsampling_dx = 1;
#line 243
    parameters->subsampling_dy = 1;
#line 244
    parameters->tp_on = (char )0;
#line 245
    parameters->decod_format = - 1;
#line 246
    parameters->cod_format = - 1;
#line 247
    parameters->tcp_rates[0] = (float )0;
#line 248
    parameters->tcp_numlayers = 0;
#line 249
    parameters->cp_disto_alloc = 0;
#line 250
    parameters->cp_fixed_alloc = 0;
#line 251
    parameters->cp_fixed_quality = 0;
#line 252
    parameters->jpip_on = 0;
    }
  }
  return;
}
}
#line 288 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 


  {
#line 289
  if (cinfo) {
#line 289
    if (parameters) {
#line 289
      if (image) {
        {
#line 291
        if ((int )cinfo->codec_format == 0) {
#line 291
          goto case_0;
        }
#line 294
        if ((int )cinfo->codec_format == 2) {
#line 294
          goto case_2;
        }
#line 299
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 292
        j2k_setup_encoder((opj_j2k_t *)cinfo->j2k_handle, parameters, image);
        }
#line 293
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 295
        jp2_setup_encoder((opj_jp2_t *)cinfo->jp2_handle, parameters, image);
        }
#line 296
        goto switch_break;
        switch_default: /* CIL Label */ 
        case_neg_1: /* CIL Label */ 
        case_1: /* CIL Label */ 
#line 300
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  return;
}
}
#line 305 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
opj_bool opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index___0 ) 
{ 
  opj_bool __cil_tmp5 ;

  {
#line 306
  if (index___0 != (void *)0) {
    {
#line 307
    opj_event_msg((opj_common_ptr )cinfo, 2, "Set index to NULL when calling the opj_encode function.\nTo extract the index, use the opj_encode_with_info() function.\nNo index will be generated during this encoding\n");
    }
  }
  {
#line 310
  __cil_tmp5 = opj_encode_with_info(cinfo, cio, image, (opj_codestream_info_t *)((void *)0));
  }
#line 310
  return (__cil_tmp5);
}
}
#line 313 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
opj_bool opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                              opj_codestream_info_t *cstr_info ) 
{ 
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;

  {
#line 314
  if (cinfo) {
#line 314
    if (cio) {
#line 314
      if (image) {
        {
#line 316
        if ((int )cinfo->codec_format == 0) {
#line 316
          goto case_0;
        }
#line 318
        if ((int )cinfo->codec_format == 2) {
#line 318
          goto case_2;
        }
#line 322
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 317
        __cil_tmp5 = j2k_encode((opj_j2k_t *)cinfo->j2k_handle, cio, image, cstr_info);
        }
#line 317
        return (__cil_tmp5);
        case_2: /* CIL Label */ 
        {
#line 319
        __cil_tmp6 = opj_jp2_encode((opj_jp2_t *)cinfo->jp2_handle, cio, image, cstr_info);
        }
#line 319
        return (__cil_tmp6);
        switch_default: /* CIL Label */ 
        case_neg_1: /* CIL Label */ 
        case_1: /* CIL Label */ 
#line 323
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 326
  return (0);
}
}
#line 329 "/root/patchweave_new/14/libopenjpeg/openjpeg.c"
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) 
{ 
  int tileno ;
  opj_tile_info_t *tile_info ;
  int __cil_tmp4 ;

  {
#line 330
  if (cstr_info) {
#line 332
    tileno = 0;
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 332
        goto while_break;
      }
      {
#line 333
      tile_info = cstr_info->tile + tileno;
#line 334
      free(tile_info->thresh);
#line 335
      free(tile_info->packet);
#line 336
      free(tile_info->tp);
#line 337
      free(tile_info->marker);
      }
#line 332
      tileno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 339
    free(cstr_info->tile);
#line 340
    free(cstr_info->marker);
#line 341
    free(cstr_info->numdecompos);
    }
  }
  return;
}
}
#line 45 "/root/patchweave_new/14/libopenjpeg/mqc.c"
static void mqc_byteout(opj_mqc_t *mqc ) ;
#line 50
static void mqc_renorme(opj_mqc_t *mqc ) ;
#line 55
static void mqc_codemps(opj_mqc_t *mqc ) ;
#line 60
static void mqc_codelps(opj_mqc_t *mqc ) ;
#line 65
static void mqc_setbits(opj_mqc_t *mqc ) ;
#line 71
__inline static int mqc_mpsexchange(opj_mqc_t *mqc ) ;
#line 77
__inline static int mqc_lpsexchange(opj_mqc_t *mqc ) ;
#line 82
static void mqc_bytein(opj_mqc_t *mqc ) ;
#line 87
__inline static void mqc_renormd(opj_mqc_t *mqc ) ;
#line 95 "/root/patchweave_new/14/libopenjpeg/mqc.c"
static opj_mqc_state_t mqc_states[94]  = 
#line 95
  {      {(unsigned int )22017, 0, & mqc_states[2], & mqc_states[3]}, 
        {(unsigned int )22017, 1, & mqc_states[3], & mqc_states[2]}, 
        {(unsigned int )13313, 0, & mqc_states[4], & mqc_states[12]}, 
        {(unsigned int )13313, 1, & mqc_states[5], & mqc_states[13]}, 
        {(unsigned int )6145, 0, & mqc_states[6], & mqc_states[18]}, 
        {(unsigned int )6145, 1, & mqc_states[7], & mqc_states[19]}, 
        {(unsigned int )2753, 0, & mqc_states[8], & mqc_states[24]}, 
        {(unsigned int )2753, 1, & mqc_states[9], & mqc_states[25]}, 
        {(unsigned int )1313, 0, & mqc_states[10], & mqc_states[58]}, 
        {(unsigned int )1313, 1, & mqc_states[11], & mqc_states[59]}, 
        {(unsigned int )545, 0, & mqc_states[76], & mqc_states[66]}, 
        {(unsigned int )545, 1, & mqc_states[77], & mqc_states[67]}, 
        {(unsigned int )22017, 0, & mqc_states[14], & mqc_states[13]}, 
        {(unsigned int )22017, 1, & mqc_states[15], & mqc_states[12]}, 
        {(unsigned int )21505, 0, & mqc_states[16], & mqc_states[28]}, 
        {(unsigned int )21505, 1, & mqc_states[17], & mqc_states[29]}, 
        {(unsigned int )18433, 0, & mqc_states[18], & mqc_states[28]}, 
        {(unsigned int )18433, 1, & mqc_states[19], & mqc_states[29]}, 
        {(unsigned int )14337, 0, & mqc_states[20], & mqc_states[28]}, 
        {(unsigned int )14337, 1, & mqc_states[21], & mqc_states[29]}, 
        {(unsigned int )12289, 0, & mqc_states[22], & mqc_states[34]}, 
        {(unsigned int )12289, 1, & mqc_states[23], & mqc_states[35]}, 
        {(unsigned int )9217, 0, & mqc_states[24], & mqc_states[36]}, 
        {(unsigned int )9217, 1, & mqc_states[25], & mqc_states[37]}, 
        {(unsigned int )7169, 0, & mqc_states[26], & mqc_states[40]}, 
        {(unsigned int )7169, 1, & mqc_states[27], & mqc_states[41]}, 
        {(unsigned int )5633, 0, & mqc_states[58], & mqc_states[42]}, 
        {(unsigned int )5633, 1, & mqc_states[59], & mqc_states[43]}, 
        {(unsigned int )22017, 0, & mqc_states[30], & mqc_states[29]}, 
        {(unsigned int )22017, 1, & mqc_states[31], & mqc_states[28]}, 
        {(unsigned int )21505, 0, & mqc_states[32], & mqc_states[28]}, 
        {(unsigned int )21505, 1, & mqc_states[33], & mqc_states[29]}, 
        {(unsigned int )20737, 0, & mqc_states[34], & mqc_states[30]}, 
        {(unsigned int )20737, 1, & mqc_states[35], & mqc_states[31]}, 
        {(unsigned int )18433, 0, & mqc_states[36], & mqc_states[32]}, 
        {(unsigned int )18433, 1, & mqc_states[37], & mqc_states[33]}, 
        {(unsigned int )14337, 0, & mqc_states[38], & mqc_states[34]}, 
        {(unsigned int )14337, 1, & mqc_states[39], & mqc_states[35]}, 
        {(unsigned int )13313, 0, & mqc_states[40], & mqc_states[36]}, 
        {(unsigned int )13313, 1, & mqc_states[41], & mqc_states[37]}, 
        {(unsigned int )12289, 0, & mqc_states[42], & mqc_states[38]}, 
        {(unsigned int )12289, 1, & mqc_states[43], & mqc_states[39]}, 
        {(unsigned int )10241, 0, & mqc_states[44], & mqc_states[38]}, 
        {(unsigned int )10241, 1, & mqc_states[45], & mqc_states[39]}, 
        {(unsigned int )9217, 0, & mqc_states[46], & mqc_states[40]}, 
        {(unsigned int )9217, 1, & mqc_states[47], & mqc_states[41]}, 
        {(unsigned int )8705, 0, & mqc_states[48], & mqc_states[42]}, 
        {(unsigned int )8705, 1, & mqc_states[49], & mqc_states[43]}, 
        {(unsigned int )7169, 0, & mqc_states[50], & mqc_states[44]}, 
        {(unsigned int )7169, 1, & mqc_states[51], & mqc_states[45]}, 
        {(unsigned int )6145, 0, & mqc_states[52], & mqc_states[46]}, 
        {(unsigned int )6145, 1, & mqc_states[53], & mqc_states[47]}, 
        {(unsigned int )5633, 0, & mqc_states[54], & mqc_states[48]}, 
        {(unsigned int )5633, 1, & mqc_states[55], & mqc_states[49]}, 
        {(unsigned int )5121, 0, & mqc_states[56], & mqc_states[50]}, 
        {(unsigned int )5121, 1, & mqc_states[57], & mqc_states[51]}, 
        {(unsigned int )4609, 0, & mqc_states[58], & mqc_states[52]}, 
        {(unsigned int )4609, 1, & mqc_states[59], & mqc_states[53]}, 
        {(unsigned int )4353, 0, & mqc_states[60], & mqc_states[54]}, 
        {(unsigned int )4353, 1, & mqc_states[61], & mqc_states[55]}, 
        {(unsigned int )2753, 0, & mqc_states[62], & mqc_states[56]}, 
        {(unsigned int )2753, 1, & mqc_states[63], & mqc_states[57]}, 
        {(unsigned int )2497, 0, & mqc_states[64], & mqc_states[58]}, 
        {(unsigned int )2497, 1, & mqc_states[65], & mqc_states[59]}, 
        {(unsigned int )2209, 0, & mqc_states[66], & mqc_states[60]}, 
        {(unsigned int )2209, 1, & mqc_states[67], & mqc_states[61]}, 
        {(unsigned int )1313, 0, & mqc_states[68], & mqc_states[62]}, 
        {(unsigned int )1313, 1, & mqc_states[69], & mqc_states[63]}, 
        {(unsigned int )1089, 0, & mqc_states[70], & mqc_states[64]}, 
        {(unsigned int )1089, 1, & mqc_states[71], & mqc_states[65]}, 
        {(unsigned int )673, 0, & mqc_states[72], & mqc_states[66]}, 
        {(unsigned int )673, 1, & mqc_states[73], & mqc_states[67]}, 
        {(unsigned int )545, 0, & mqc_states[74], & mqc_states[68]}, 
        {(unsigned int )545, 1, & mqc_states[75], & mqc_states[69]}, 
        {(unsigned int )321, 0, & mqc_states[76], & mqc_states[70]}, 
        {(unsigned int )321, 1, & mqc_states[77], & mqc_states[71]}, 
        {(unsigned int )273, 0, & mqc_states[78], & mqc_states[72]}, 
        {(unsigned int )273, 1, & mqc_states[79], & mqc_states[73]}, 
        {(unsigned int )133, 0, & mqc_states[80], & mqc_states[74]}, 
        {(unsigned int )133, 1, & mqc_states[81], & mqc_states[75]}, 
        {(unsigned int )73, 0, & mqc_states[82], & mqc_states[76]}, 
        {(unsigned int )73, 1, & mqc_states[83], & mqc_states[77]}, 
        {(unsigned int )37, 0, & mqc_states[84], & mqc_states[78]}, 
        {(unsigned int )37, 1, & mqc_states[85], & mqc_states[79]}, 
        {(unsigned int )21, 0, & mqc_states[86], & mqc_states[80]}, 
        {(unsigned int )21, 1, & mqc_states[87], & mqc_states[81]}, 
        {(unsigned int )9, 0, & mqc_states[88], & mqc_states[82]}, 
        {(unsigned int )9, 1, & mqc_states[89], & mqc_states[83]}, 
        {(unsigned int )5, 0, & mqc_states[90], & mqc_states[84]}, 
        {(unsigned int )5, 1, & mqc_states[91], & mqc_states[85]}, 
        {(unsigned int )1, 0, & mqc_states[90], & mqc_states[86]}, 
        {(unsigned int )1, 1, & mqc_states[91], & mqc_states[87]}, 
        {(unsigned int )22017, 0, & mqc_states[92], & mqc_states[92]}, 
        {(unsigned int )22017, 1, & mqc_states[93], & mqc_states[93]}};
#line 198 "/root/patchweave_new/14/libopenjpeg/mqc.c"
static void mqc_byteout(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;
  unsigned char *__cil_tmp3 ;
  unsigned char __cil_tmp4 ;
  unsigned char *__cil_tmp5 ;
  unsigned char *__cil_tmp6 ;

  {
#line 199
  if ((int )*(mqc->bp) == 255) {
#line 200
    (mqc->bp) ++;
#line 201
    *(mqc->bp) = (unsigned char )(mqc->c >> 20);
#line 202
    mqc->c &= (unsigned int )1048575;
#line 203
    mqc->ct = (unsigned int )7;
  } else
#line 205
  if ((mqc->c & 134217728U) == 0U) {
#line 206
    (mqc->bp) ++;
#line 207
    *(mqc->bp) = (unsigned char )(mqc->c >> 19);
#line 208
    mqc->c &= (unsigned int )524287;
#line 209
    mqc->ct = (unsigned int )8;
  } else {
#line 211
    (*(mqc->bp)) ++;
#line 212
    if ((int )*(mqc->bp) == 255) {
#line 213
      mqc->c &= (unsigned int )134217727;
#line 214
      (mqc->bp) ++;
#line 215
      *(mqc->bp) = (unsigned char )(mqc->c >> 20);
#line 216
      mqc->c &= (unsigned int )1048575;
#line 217
      mqc->ct = (unsigned int )7;
    } else {
#line 219
      (mqc->bp) ++;
#line 220
      *(mqc->bp) = (unsigned char )(mqc->c >> 19);
#line 221
      mqc->c &= (unsigned int )524287;
#line 222
      mqc->ct = (unsigned int )8;
    }
  }
  return;
}
}
#line 228 "/root/patchweave_new/14/libopenjpeg/mqc.c"
static void mqc_renorme(opj_mqc_t *mqc ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    mqc->a <<= 1;
#line 231
    mqc->c <<= 1;
#line 232
    __cil_tmp2 = mqc->ct;
#line 232
    (mqc->ct) --;
#line 233
    if (mqc->ct == 0U) {
      {
#line 234
      mqc_byteout(mqc);
      }
    }
#line 229
    if (! ((mqc->a & 32768U) == 0U)) {
#line 229
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 239 "/root/patchweave_new/14/libopenjpeg/mqc.c"
static void mqc_codemps(opj_mqc_t *mqc ) 
{ 


  {
#line 240
  mqc->a -= (*(mqc->curctx))->qeval;
#line 241
  if ((mqc->a & 32768U) == 0U) {
#line 242
    if (mqc->a < (*(mqc->curctx))->qeval) {
#line 243
      mqc->a = (*(mqc->curctx))->qeval;
    } else {
#line 245
      mqc->c += (*(mqc->curctx))->qeval;
    }
    {
#line 247
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
#line 248
    mqc_renorme(mqc);
    }
  } else {
#line 250
    mqc->c += (*(mqc->curctx))->qeval;
  }
  return;
}
}
#line 254 "/root/patchweave_new/14/libopenjpeg/mqc.c"
static void mqc_codelps(opj_mqc_t *mqc ) 
{ 


  {
#line 255
  mqc->a -= (*(mqc->curctx))->qeval;
#line 256
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 257
    mqc->c += (*(mqc->curctx))->qeval;
  } else {
#line 259
    mqc->a = (*(mqc->curctx))->qeval;
  }
  {
#line 261
  *(mqc->curctx) = (*(mqc->curctx))->nlps;
#line 262
  mqc_renorme(mqc);
  }
  return;
}
}
#line 265 "/root/patchweave_new/14/libopenjpeg/mqc.c"
static void mqc_setbits(opj_mqc_t *mqc ) 
{ 
  unsigned int tempc ;

  {
#line 266
  tempc = mqc->c + mqc->a;
#line 267
  mqc->c |= (unsigned int )65535;
#line 268
  if (mqc->c >= tempc) {
#line 269
    mqc->c -= (unsigned int )32768;
  }
  return;
}
}
#line 273 "/root/patchweave_new/14/libopenjpeg/mqc.c"
__inline static int mqc_mpsexchange(opj_mqc_t *mqc ) 
{ 
  int d ;

  {
#line 275
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 276
    d = 1 - (*(mqc->curctx))->mps;
#line 277
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  } else {
#line 279
    d = (*(mqc->curctx))->mps;
#line 280
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  }
#line 283
  return (d);
}
}
#line 286 "/root/patchweave_new/14/libopenjpeg/mqc.c"
__inline static int mqc_lpsexchange(opj_mqc_t *mqc ) 
{ 
  int d ;

  {
#line 288
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 289
    mqc->a = (*(mqc->curctx))->qeval;
#line 290
    d = (*(mqc->curctx))->mps;
#line 291
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  } else {
#line 293
    mqc->a = (*(mqc->curctx))->qeval;
#line 294
    d = 1 - (*(mqc->curctx))->mps;
#line 295
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  }
#line 298
  return (d);
}
}
#line 309 "/root/patchweave_new/14/libopenjpeg/mqc.c"
static void mqc_bytein(opj_mqc_t *mqc ) 
{ 
  unsigned int c ;
  unsigned char *__cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 310
  if (mqc->bp != mqc->end) {
#line 312
    if (mqc->bp + 1 != mqc->end) {
#line 313
      c = (unsigned int )*(mqc->bp + 1);
    } else {
#line 315
      c = (unsigned int )255;
    }
#line 317
    if ((int )*(mqc->bp) == 255) {
#line 318
      if (c > 143U) {
#line 319
        mqc->c += (unsigned int )65280;
#line 320
        mqc->ct = (unsigned int )8;
      } else {
#line 322
        (mqc->bp) ++;
#line 323
        mqc->c += c << 9;
#line 324
        mqc->ct = (unsigned int )7;
      }
    } else {
#line 327
      (mqc->bp) ++;
#line 328
      mqc->c += c << 8;
#line 329
      mqc->ct = (unsigned int )8;
    }
  } else {
#line 332
    mqc->c += (unsigned int )65280;
#line 333
    mqc->ct = (unsigned int )8;
  }
  return;
}
}
#line 338 "/root/patchweave_new/14/libopenjpeg/mqc.c"
__inline static void mqc_renormd(opj_mqc_t *mqc ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (mqc->ct == 0U) {
      {
#line 341
      mqc_bytein(mqc);
      }
    }
#line 343
    mqc->a <<= 1;
#line 344
    mqc->c <<= 1;
#line 345
    __cil_tmp2 = mqc->ct;
#line 345
    (mqc->ct) --;
#line 339
    if (! (mqc->a < 32768U)) {
#line 339
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 355 "/root/patchweave_new/14/libopenjpeg/mqc.c"
opj_mqc_t *mqc_create(void) 
{ 
  opj_mqc_t *mqc ;
  void *__cil_tmp2 ;

  {
  {
#line 356
  __cil_tmp2 = malloc(sizeof(opj_mqc_t ));
#line 356
  mqc = (opj_mqc_t *)__cil_tmp2;
  }
#line 360
  return (mqc);
}
}
#line 363 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_destroy(opj_mqc_t *mqc ) 
{ 


  {
#line 364
  if (mqc) {
    {
#line 370
    free(mqc);
    }
  }
  return;
}
}
#line 374 "/root/patchweave_new/14/libopenjpeg/mqc.c"
int mqc_numbytes(opj_mqc_t *mqc ) 
{ 


  {
#line 375
  return ((int )(mqc->bp - mqc->start));
}
}
#line 378 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_init_enc(opj_mqc_t *mqc , unsigned char *bp ) 
{ 


  {
#line 379
  mqc->curctx = & mqc->ctxs[(int )0];
#line 380
  mqc->a = (unsigned int )32768;
#line 381
  mqc->c = (unsigned int )0;
#line 382
  mqc->bp = bp - 1;
#line 383
  mqc->ct = (unsigned int )12;
#line 384
  if ((int )*(mqc->bp) == 255) {
#line 385
    mqc->ct = (unsigned int )13;
  }
#line 387
  mqc->start = bp;
  return;
}
}
#line 390 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_encode(opj_mqc_t *mqc , int d ) 
{ 


  {
#line 391
  if ((*(mqc->curctx))->mps == d) {
    {
#line 392
    mqc_codemps(mqc);
    }
  } else {
    {
#line 394
    mqc_codelps(mqc);
    }
  }
  return;
}
}
#line 398 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_flush(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
  {
#line 399
  mqc_setbits(mqc);
#line 400
  mqc->c <<= mqc->ct;
#line 401
  mqc_byteout(mqc);
#line 402
  mqc->c <<= mqc->ct;
#line 403
  mqc_byteout(mqc);
  }
#line 405
  if ((int )*(mqc->bp) != 255) {
#line 406
    (mqc->bp) ++;
  }
  return;
}
}
#line 410 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_bypass_init_enc(opj_mqc_t *mqc ) 
{ 


  {
#line 411
  mqc->c = (unsigned int )0;
#line 412
  mqc->ct = (unsigned int )8;
  return;
}
}
#line 418 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_bypass_enc(opj_mqc_t *mqc , int d ) 
{ 
  unsigned int __cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 419
  __cil_tmp3 = mqc->ct;
#line 419
  (mqc->ct) --;
#line 420
  mqc->c += (unsigned int )(d << mqc->ct);
#line 421
  if (mqc->ct == 0U) {
#line 422
    (mqc->bp) ++;
#line 423
    *(mqc->bp) = (unsigned char )mqc->c;
#line 424
    mqc->ct = (unsigned int )8;
#line 425
    if ((int )*(mqc->bp) == 255) {
#line 426
      mqc->ct = (unsigned int )7;
    }
#line 428
    mqc->c = (unsigned int )0;
  }
  return;
}
}
#line 432 "/root/patchweave_new/14/libopenjpeg/mqc.c"
int mqc_bypass_flush_enc(opj_mqc_t *mqc ) 
{ 
  unsigned char bit_padding ;
  unsigned int __cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 435
  bit_padding = (unsigned char )0;
#line 437
  if (mqc->ct != 0U) {
    {
#line 438
    while (1) {
      while_continue: /* CIL Label */ ;
#line 438
      if (! (mqc->ct > 0U)) {
#line 438
        goto while_break;
      }
#line 439
      __cil_tmp3 = mqc->ct;
#line 439
      (mqc->ct) --;
#line 440
      mqc->c += (unsigned int )((int )bit_padding << mqc->ct);
#line 441
      bit_padding = (unsigned char )(((int )bit_padding + 1) & 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 443
    (mqc->bp) ++;
#line 444
    *(mqc->bp) = (unsigned char )mqc->c;
#line 445
    mqc->ct = (unsigned int )8;
#line 446
    mqc->c = (unsigned int )0;
  }
#line 449
  return (1);
}
}
#line 452 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_reset_enc(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 453
  mqc_resetstates(mqc);
#line 454
  mqc_setstate(mqc, 18, 0, 46);
#line 455
  mqc_setstate(mqc, 17, 0, 3);
#line 456
  mqc_setstate(mqc, 0, 0, 4);
  }
  return;
}
}
#line 459 "/root/patchweave_new/14/libopenjpeg/mqc.c"
int mqc_restart_enc(opj_mqc_t *mqc ) 
{ 
  int correction ;
  int n ;

  {
#line 460
  correction = 1;
#line 463
  n = (int )(12U - mqc->ct);
#line 464
  mqc->c <<= mqc->ct;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (n > 0)) {
#line 465
      goto while_break;
    }
    {
#line 466
    mqc_byteout(mqc);
#line 467
    n -= mqc->ct;
#line 468
    mqc->c <<= mqc->ct;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 470
  mqc_byteout(mqc);
  }
#line 472
  return (correction);
}
}
#line 475 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_restart_init_enc(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
#line 477
  mqc->curctx = & mqc->ctxs[(int )0];
#line 478
  mqc->a = (unsigned int )32768;
#line 479
  mqc->c = (unsigned int )0;
#line 480
  mqc->ct = (unsigned int )12;
#line 481
  __cil_tmp2 = mqc->bp;
#line 481
  (mqc->bp) --;
#line 482
  if ((int )*(mqc->bp) == 255) {
#line 483
    mqc->ct = (unsigned int )13;
  }
  return;
}
}
#line 487 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_erterm_enc(opj_mqc_t *mqc ) 
{ 
  int k ;

  {
#line 488
  k = (int )((11U - mqc->ct) + 1U);
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (k > 0)) {
#line 490
      goto while_break;
    }
    {
#line 491
    mqc->c <<= mqc->ct;
#line 492
    mqc->ct = (unsigned int )0;
#line 493
    mqc_byteout(mqc);
#line 494
    k -= mqc->ct;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 497
  if ((int )*(mqc->bp) != 255) {
    {
#line 498
    mqc_byteout(mqc);
    }
  }
  return;
}
}
#line 502 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_segmark_enc(opj_mqc_t *mqc ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 504
  mqc->curctx = & mqc->ctxs[(int )18];
#line 506
  i = 1;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i < 5)) {
#line 506
      goto while_break;
    }
    {
#line 507
    mqc_encode(mqc, i % 2);
    }
#line 506
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 511 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_init_dec(opj_mqc_t *mqc , unsigned char *bp , int len ) 
{ 


  {
#line 512
  mqc->curctx = & mqc->ctxs[(int )0];
#line 513
  mqc->start = bp;
#line 514
  mqc->end = bp + len;
#line 515
  mqc->bp = bp;
#line 516
  if (len == 0) {
#line 516
    mqc->c = (unsigned int )(255 << 16);
  } else {
#line 517
    mqc->c = (unsigned int )((int )*(mqc->bp) << 16);
  }
  {
#line 556
  mqc_bytein(mqc);
#line 557
  mqc->c <<= 7;
#line 558
  mqc->ct -= (unsigned int )7;
#line 559
  mqc->a = (unsigned int )32768;
  }
  return;
}
}
#line 562 "/root/patchweave_new/14/libopenjpeg/mqc.c"
int mqc_decode(opj_mqc_t *mqc ) 
{ 
  int d ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 564
  mqc->a -= (*(mqc->curctx))->qeval;
#line 565
  if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
    {
#line 566
    d = mqc_lpsexchange(mqc);
#line 567
    mqc_renormd(mqc);
    }
  } else {
#line 569
    mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 570
    if ((mqc->a & 32768U) == 0U) {
      {
#line 571
      d = mqc_mpsexchange(mqc);
#line 572
      mqc_renormd(mqc);
      }
    } else {
#line 574
      d = (*(mqc->curctx))->mps;
    }
  }
#line 578
  return (d);
}
}
#line 581 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_resetstates(opj_mqc_t *mqc ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 583
  i = 0;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! (i < 19)) {
#line 583
      goto while_break;
    }
#line 584
    mqc->ctxs[i] = (opj_mqc_state_t *)mqc_states;
#line 583
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 588 "/root/patchweave_new/14/libopenjpeg/mqc.c"
void mqc_setstate(opj_mqc_t *mqc , int ctxno , int msb , int prob ) 
{ 


  {
#line 589
  mqc->ctxs[ctxno] = & mqc_states[msb + (prob << 1)];
  return;
}
}
#line 56 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void _mm_empty(void)  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void _mm_empty(void) 
{ 


  {
  {
#line 58
  __builtin_ia32_emms();
  }
  return;
}
}
#line 62
__inline extern void _m_empty(void)  __attribute__((__gnu_inline__)) ;
#line 62 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void _m_empty(void) 
{ 


  {
  {
#line 64
  _mm_empty();
  }
  return;
}
}
#line 69
__inline extern __m64 _mm_cvtsi32_si64(int __i )  __attribute__((__gnu_inline__)) ;
#line 69 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_cvtsi32_si64(int __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 71
  __cil_tmp2 = __builtin_ia32_vec_init_v2si(__i, 0);
  }
#line 71
  return ((__m64 )__cil_tmp2);
}
}
#line 75
__inline extern __m64 _m_from_int(int __i )  __attribute__((__gnu_inline__)) ;
#line 75 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_from_int(int __i ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 77
  __cil_tmp2 = _mm_cvtsi32_si64(__i);
  }
#line 77
  return (__cil_tmp2);
}
}
#line 85
__inline extern __m64 _m_from_int64(long long __i )  __attribute__((__gnu_inline__)) ;
#line 85 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_from_int64(long long __i ) 
{ 


  {
#line 87
  return ((__m64 )__i);
}
}
#line 112
__inline extern int _mm_cvtsi64_si32(__m64 __i )  __attribute__((__gnu_inline__)) ;
#line 112 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern int _mm_cvtsi64_si32(__m64 __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 114
  __cil_tmp2 = __builtin_ia32_vec_ext_v2si((__v2si )__i, 0);
  }
#line 114
  return (__cil_tmp2);
}
}
#line 118
__inline extern int _m_to_int(__m64 __i )  __attribute__((__gnu_inline__)) ;
#line 118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern int _m_to_int(__m64 __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 120
  __cil_tmp2 = _mm_cvtsi64_si32(__i);
  }
#line 120
  return (__cil_tmp2);
}
}
#line 128
__inline extern long long _m_to_int64(__m64 __i )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern long long _m_to_int64(__m64 __i ) 
{ 


  {
#line 130
  return ((long long )__i);
}
}
#line 151
__inline extern __m64 _mm_packs_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 151 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_packs_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 153
  __cil_tmp3 = __builtin_ia32_packsswb((__v4hi )__m1, (__v4hi )__m2);
  }
#line 153
  return ((__m64 )__cil_tmp3);
}
}
#line 157
__inline extern __m64 _m_packsswb(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 157 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_packsswb(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 159
  __cil_tmp3 = _mm_packs_pi16(__m1, __m2);
  }
#line 159
  return (__cil_tmp3);
}
}
#line 166
__inline extern __m64 _mm_packs_pi32(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 166 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_packs_pi32(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 168
  __cil_tmp3 = __builtin_ia32_packssdw((__v2si )__m1, (__v2si )__m2);
  }
#line 168
  return ((__m64 )__cil_tmp3);
}
}
#line 172
__inline extern __m64 _m_packssdw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 172 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_packssdw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 174
  __cil_tmp3 = _mm_packs_pi32(__m1, __m2);
  }
#line 174
  return (__cil_tmp3);
}
}
#line 181
__inline extern __m64 _mm_packs_pu16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 181 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_packs_pu16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 183
  __cil_tmp3 = __builtin_ia32_packuswb((__v4hi )__m1, (__v4hi )__m2);
  }
#line 183
  return ((__m64 )__cil_tmp3);
}
}
#line 187
__inline extern __m64 _m_packuswb(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 187 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_packuswb(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 189
  __cil_tmp3 = _mm_packs_pu16(__m1, __m2);
  }
#line 189
  return (__cil_tmp3);
}
}
#line 195
__inline extern __m64 _mm_unpackhi_pi8(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 195 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_unpackhi_pi8(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 197
  __cil_tmp3 = __builtin_ia32_punpckhbw((__v8qi )__m1, (__v8qi )__m2);
  }
#line 197
  return ((__m64 )__cil_tmp3);
}
}
#line 201
__inline extern __m64 _m_punpckhbw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 201 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_punpckhbw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 203
  __cil_tmp3 = _mm_unpackhi_pi8(__m1, __m2);
  }
#line 203
  return (__cil_tmp3);
}
}
#line 209
__inline extern __m64 _mm_unpackhi_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 209 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_unpackhi_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 211
  __cil_tmp3 = __builtin_ia32_punpckhwd((__v4hi )__m1, (__v4hi )__m2);
  }
#line 211
  return ((__m64 )__cil_tmp3);
}
}
#line 215
__inline extern __m64 _m_punpckhwd(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 215 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_punpckhwd(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 217
  __cil_tmp3 = _mm_unpackhi_pi16(__m1, __m2);
  }
#line 217
  return (__cil_tmp3);
}
}
#line 223
__inline extern __m64 _mm_unpackhi_pi32(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 223 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_unpackhi_pi32(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 225
  __cil_tmp3 = __builtin_ia32_punpckhdq((__v2si )__m1, (__v2si )__m2);
  }
#line 225
  return ((__m64 )__cil_tmp3);
}
}
#line 229
__inline extern __m64 _m_punpckhdq(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 229 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_punpckhdq(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 231
  __cil_tmp3 = _mm_unpackhi_pi32(__m1, __m2);
  }
#line 231
  return (__cil_tmp3);
}
}
#line 237
__inline extern __m64 _mm_unpacklo_pi8(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 237 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_unpacklo_pi8(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 239
  __cil_tmp3 = __builtin_ia32_punpcklbw((__v8qi )__m1, (__v8qi )__m2);
  }
#line 239
  return ((__m64 )__cil_tmp3);
}
}
#line 243
__inline extern __m64 _m_punpcklbw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 243 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_punpcklbw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 245
  __cil_tmp3 = _mm_unpacklo_pi8(__m1, __m2);
  }
#line 245
  return (__cil_tmp3);
}
}
#line 251
__inline extern __m64 _mm_unpacklo_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 251 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_unpacklo_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 253
  __cil_tmp3 = __builtin_ia32_punpcklwd((__v4hi )__m1, (__v4hi )__m2);
  }
#line 253
  return ((__m64 )__cil_tmp3);
}
}
#line 257
__inline extern __m64 _m_punpcklwd(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 257 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_punpcklwd(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 259
  __cil_tmp3 = _mm_unpacklo_pi16(__m1, __m2);
  }
#line 259
  return (__cil_tmp3);
}
}
#line 265
__inline extern __m64 _mm_unpacklo_pi32(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_unpacklo_pi32(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_ia32_punpckldq((__v2si )__m1, (__v2si )__m2);
  }
#line 267
  return ((__m64 )__cil_tmp3);
}
}
#line 271
__inline extern __m64 _m_punpckldq(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 271 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_punpckldq(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 273
  __cil_tmp3 = _mm_unpacklo_pi32(__m1, __m2);
  }
#line 273
  return (__cil_tmp3);
}
}
#line 278
__inline extern __m64 _mm_add_pi8(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 278 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_add_pi8(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 280
  __cil_tmp3 = __builtin_ia32_paddb((__v8qi )__m1, (__v8qi )__m2);
  }
#line 280
  return ((__m64 )__cil_tmp3);
}
}
#line 284
__inline extern __m64 _m_paddb(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 284 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_paddb(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 286
  __cil_tmp3 = _mm_add_pi8(__m1, __m2);
  }
#line 286
  return (__cil_tmp3);
}
}
#line 291
__inline extern __m64 _mm_add_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 291 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_add_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 293
  __cil_tmp3 = __builtin_ia32_paddw((__v4hi )__m1, (__v4hi )__m2);
  }
#line 293
  return ((__m64 )__cil_tmp3);
}
}
#line 297
__inline extern __m64 _m_paddw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 297 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_paddw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 299
  __cil_tmp3 = _mm_add_pi16(__m1, __m2);
  }
#line 299
  return (__cil_tmp3);
}
}
#line 304
__inline extern __m64 _mm_add_pi32(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 304 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_add_pi32(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 306
  __cil_tmp3 = __builtin_ia32_paddd((__v2si )__m1, (__v2si )__m2);
  }
#line 306
  return ((__m64 )__cil_tmp3);
}
}
#line 310
__inline extern __m64 _m_paddd(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 310 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_paddd(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 312
  __cil_tmp3 = _mm_add_pi32(__m1, __m2);
  }
#line 312
  return (__cil_tmp3);
}
}
#line 323
__inline extern __m64 _mm_add_si64(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 323 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_add_si64(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 325
  __cil_tmp3 = __builtin_ia32_paddq((__v1di )__m1, (__v1di )__m2);
  }
#line 325
  return ((__m64 )__cil_tmp3);
}
}
#line 335
__inline extern __m64 _mm_adds_pi8(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 335 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_adds_pi8(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 337
  __cil_tmp3 = __builtin_ia32_paddsb((__v8qi )__m1, (__v8qi )__m2);
  }
#line 337
  return ((__m64 )__cil_tmp3);
}
}
#line 341
__inline extern __m64 _m_paddsb(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 341 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_paddsb(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 343
  __cil_tmp3 = _mm_adds_pi8(__m1, __m2);
  }
#line 343
  return (__cil_tmp3);
}
}
#line 349
__inline extern __m64 _mm_adds_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 349 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_adds_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 351
  __cil_tmp3 = __builtin_ia32_paddsw((__v4hi )__m1, (__v4hi )__m2);
  }
#line 351
  return ((__m64 )__cil_tmp3);
}
}
#line 355
__inline extern __m64 _m_paddsw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 355 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_paddsw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 357
  __cil_tmp3 = _mm_adds_pi16(__m1, __m2);
  }
#line 357
  return (__cil_tmp3);
}
}
#line 363
__inline extern __m64 _mm_adds_pu8(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 363 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_adds_pu8(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 365
  __cil_tmp3 = __builtin_ia32_paddusb((__v8qi )__m1, (__v8qi )__m2);
  }
#line 365
  return ((__m64 )__cil_tmp3);
}
}
#line 369
__inline extern __m64 _m_paddusb(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 369 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_paddusb(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 371
  __cil_tmp3 = _mm_adds_pu8(__m1, __m2);
  }
#line 371
  return (__cil_tmp3);
}
}
#line 377
__inline extern __m64 _mm_adds_pu16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 377 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_adds_pu16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 379
  __cil_tmp3 = __builtin_ia32_paddusw((__v4hi )__m1, (__v4hi )__m2);
  }
#line 379
  return ((__m64 )__cil_tmp3);
}
}
#line 383
__inline extern __m64 _m_paddusw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 383 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_paddusw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 385
  __cil_tmp3 = _mm_adds_pu16(__m1, __m2);
  }
#line 385
  return (__cil_tmp3);
}
}
#line 390
__inline extern __m64 _mm_sub_pi8(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 390 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_sub_pi8(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 392
  __cil_tmp3 = __builtin_ia32_psubb((__v8qi )__m1, (__v8qi )__m2);
  }
#line 392
  return ((__m64 )__cil_tmp3);
}
}
#line 396
__inline extern __m64 _m_psubb(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 396 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psubb(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 398
  __cil_tmp3 = _mm_sub_pi8(__m1, __m2);
  }
#line 398
  return (__cil_tmp3);
}
}
#line 403
__inline extern __m64 _mm_sub_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 403 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_sub_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 405
  __cil_tmp3 = __builtin_ia32_psubw((__v4hi )__m1, (__v4hi )__m2);
  }
#line 405
  return ((__m64 )__cil_tmp3);
}
}
#line 409
__inline extern __m64 _m_psubw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 409 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psubw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 411
  __cil_tmp3 = _mm_sub_pi16(__m1, __m2);
  }
#line 411
  return (__cil_tmp3);
}
}
#line 416
__inline extern __m64 _mm_sub_pi32(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 416 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_sub_pi32(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 418
  __cil_tmp3 = __builtin_ia32_psubd((__v2si )__m1, (__v2si )__m2);
  }
#line 418
  return ((__m64 )__cil_tmp3);
}
}
#line 422
__inline extern __m64 _m_psubd(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 422 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psubd(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 424
  __cil_tmp3 = _mm_sub_pi32(__m1, __m2);
  }
#line 424
  return (__cil_tmp3);
}
}
#line 435
__inline extern __m64 _mm_sub_si64(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 435 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_sub_si64(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 437
  __cil_tmp3 = __builtin_ia32_psubq((__v1di )__m1, (__v1di )__m2);
  }
#line 437
  return ((__m64 )__cil_tmp3);
}
}
#line 447
__inline extern __m64 _mm_subs_pi8(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 447 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_subs_pi8(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 449
  __cil_tmp3 = __builtin_ia32_psubsb((__v8qi )__m1, (__v8qi )__m2);
  }
#line 449
  return ((__m64 )__cil_tmp3);
}
}
#line 453
__inline extern __m64 _m_psubsb(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 453 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psubsb(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = _mm_subs_pi8(__m1, __m2);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 461
__inline extern __m64 _mm_subs_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 461 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_subs_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 463
  __cil_tmp3 = __builtin_ia32_psubsw((__v4hi )__m1, (__v4hi )__m2);
  }
#line 463
  return ((__m64 )__cil_tmp3);
}
}
#line 467
__inline extern __m64 _m_psubsw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 467 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psubsw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 469
  __cil_tmp3 = _mm_subs_pi16(__m1, __m2);
  }
#line 469
  return (__cil_tmp3);
}
}
#line 475
__inline extern __m64 _mm_subs_pu8(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 475 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_subs_pu8(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 477
  __cil_tmp3 = __builtin_ia32_psubusb((__v8qi )__m1, (__v8qi )__m2);
  }
#line 477
  return ((__m64 )__cil_tmp3);
}
}
#line 481
__inline extern __m64 _m_psubusb(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 481 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psubusb(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 483
  __cil_tmp3 = _mm_subs_pu8(__m1, __m2);
  }
#line 483
  return (__cil_tmp3);
}
}
#line 489
__inline extern __m64 _mm_subs_pu16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 489 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_subs_pu16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 491
  __cil_tmp3 = __builtin_ia32_psubusw((__v4hi )__m1, (__v4hi )__m2);
  }
#line 491
  return ((__m64 )__cil_tmp3);
}
}
#line 495
__inline extern __m64 _m_psubusw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 495 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psubusw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 497
  __cil_tmp3 = _mm_subs_pu16(__m1, __m2);
  }
#line 497
  return (__cil_tmp3);
}
}
#line 504
__inline extern __m64 _mm_madd_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 504 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_madd_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 506
  __cil_tmp3 = __builtin_ia32_pmaddwd((__v4hi )__m1, (__v4hi )__m2);
  }
#line 506
  return ((__m64 )__cil_tmp3);
}
}
#line 510
__inline extern __m64 _m_pmaddwd(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pmaddwd(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 512
  __cil_tmp3 = _mm_madd_pi16(__m1, __m2);
  }
#line 512
  return (__cil_tmp3);
}
}
#line 518
__inline extern __m64 _mm_mulhi_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 518 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_mulhi_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 520
  __cil_tmp3 = __builtin_ia32_pmulhw((__v4hi )__m1, (__v4hi )__m2);
  }
#line 520
  return ((__m64 )__cil_tmp3);
}
}
#line 524
__inline extern __m64 _m_pmulhw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 524 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pmulhw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 526
  __cil_tmp3 = _mm_mulhi_pi16(__m1, __m2);
  }
#line 526
  return (__cil_tmp3);
}
}
#line 532
__inline extern __m64 _mm_mullo_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 532 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_mullo_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 534
  __cil_tmp3 = __builtin_ia32_pmullw((__v4hi )__m1, (__v4hi )__m2);
  }
#line 534
  return ((__m64 )__cil_tmp3);
}
}
#line 538
__inline extern __m64 _m_pmullw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 538 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pmullw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 540
  __cil_tmp3 = _mm_mullo_pi16(__m1, __m2);
  }
#line 540
  return (__cil_tmp3);
}
}
#line 545
__inline extern __m64 _mm_sll_pi16(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 545 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_sll_pi16(__m64 __m , __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 547
  __cil_tmp3 = __builtin_ia32_psllw((__v4hi )__m, (__v4hi )__count);
  }
#line 547
  return ((__m64 )__cil_tmp3);
}
}
#line 551
__inline extern __m64 _m_psllw(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 551 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psllw(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 553
  __cil_tmp3 = _mm_sll_pi16(__m, __count);
  }
#line 553
  return (__cil_tmp3);
}
}
#line 557
__inline extern __m64 _mm_slli_pi16(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 557 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_slli_pi16(__m64 __m , int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 559
  __cil_tmp3 = __builtin_ia32_psllwi((__v4hi )__m, __count);
  }
#line 559
  return ((__m64 )__cil_tmp3);
}
}
#line 563
__inline extern __m64 _m_psllwi(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 563 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psllwi(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 565
  __cil_tmp3 = _mm_slli_pi16(__m, __count);
  }
#line 565
  return (__cil_tmp3);
}
}
#line 570
__inline extern __m64 _mm_sll_pi32(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 570 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_sll_pi32(__m64 __m , __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 572
  __cil_tmp3 = __builtin_ia32_pslld((__v2si )__m, (__v2si )__count);
  }
#line 572
  return ((__m64 )__cil_tmp3);
}
}
#line 576
__inline extern __m64 _m_pslld(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 576 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pslld(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 578
  __cil_tmp3 = _mm_sll_pi32(__m, __count);
  }
#line 578
  return (__cil_tmp3);
}
}
#line 582
__inline extern __m64 _mm_slli_pi32(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 582 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_slli_pi32(__m64 __m , int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 584
  __cil_tmp3 = __builtin_ia32_pslldi((__v2si )__m, __count);
  }
#line 584
  return ((__m64 )__cil_tmp3);
}
}
#line 588
__inline extern __m64 _m_pslldi(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 588 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pslldi(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 590
  __cil_tmp3 = _mm_slli_pi32(__m, __count);
  }
#line 590
  return (__cil_tmp3);
}
}
#line 595
__inline extern __m64 _mm_sll_si64(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 595 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_sll_si64(__m64 __m , __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 597
  __cil_tmp3 = __builtin_ia32_psllq((__v1di )__m, (__v1di )__count);
  }
#line 597
  return ((__m64 )__cil_tmp3);
}
}
#line 601
__inline extern __m64 _m_psllq(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 601 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psllq(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 603
  __cil_tmp3 = _mm_sll_si64(__m, __count);
  }
#line 603
  return (__cil_tmp3);
}
}
#line 607
__inline extern __m64 _mm_slli_si64(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 607 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_slli_si64(__m64 __m , int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 609
  __cil_tmp3 = __builtin_ia32_psllqi((__v1di )__m, __count);
  }
#line 609
  return ((__m64 )__cil_tmp3);
}
}
#line 613
__inline extern __m64 _m_psllqi(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 613 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psllqi(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 615
  __cil_tmp3 = _mm_slli_si64(__m, __count);
  }
#line 615
  return (__cil_tmp3);
}
}
#line 620
__inline extern __m64 _mm_sra_pi16(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 620 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_sra_pi16(__m64 __m , __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 622
  __cil_tmp3 = __builtin_ia32_psraw((__v4hi )__m, (__v4hi )__count);
  }
#line 622
  return ((__m64 )__cil_tmp3);
}
}
#line 626
__inline extern __m64 _m_psraw(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 626 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psraw(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 628
  __cil_tmp3 = _mm_sra_pi16(__m, __count);
  }
#line 628
  return (__cil_tmp3);
}
}
#line 632
__inline extern __m64 _mm_srai_pi16(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 632 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_srai_pi16(__m64 __m , int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 634
  __cil_tmp3 = __builtin_ia32_psrawi((__v4hi )__m, __count);
  }
#line 634
  return ((__m64 )__cil_tmp3);
}
}
#line 638
__inline extern __m64 _m_psrawi(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 638 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psrawi(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 640
  __cil_tmp3 = _mm_srai_pi16(__m, __count);
  }
#line 640
  return (__cil_tmp3);
}
}
#line 645
__inline extern __m64 _mm_sra_pi32(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 645 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_sra_pi32(__m64 __m , __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 647
  __cil_tmp3 = __builtin_ia32_psrad((__v2si )__m, (__v2si )__count);
  }
#line 647
  return ((__m64 )__cil_tmp3);
}
}
#line 651
__inline extern __m64 _m_psrad(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 651 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psrad(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 653
  __cil_tmp3 = _mm_sra_pi32(__m, __count);
  }
#line 653
  return (__cil_tmp3);
}
}
#line 657
__inline extern __m64 _mm_srai_pi32(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 657 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_srai_pi32(__m64 __m , int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 659
  __cil_tmp3 = __builtin_ia32_psradi((__v2si )__m, __count);
  }
#line 659
  return ((__m64 )__cil_tmp3);
}
}
#line 663
__inline extern __m64 _m_psradi(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 663 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psradi(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 665
  __cil_tmp3 = _mm_srai_pi32(__m, __count);
  }
#line 665
  return (__cil_tmp3);
}
}
#line 670
__inline extern __m64 _mm_srl_pi16(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_srl_pi16(__m64 __m , __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 672
  __cil_tmp3 = __builtin_ia32_psrlw((__v4hi )__m, (__v4hi )__count);
  }
#line 672
  return ((__m64 )__cil_tmp3);
}
}
#line 676
__inline extern __m64 _m_psrlw(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 676 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psrlw(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 678
  __cil_tmp3 = _mm_srl_pi16(__m, __count);
  }
#line 678
  return (__cil_tmp3);
}
}
#line 682
__inline extern __m64 _mm_srli_pi16(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 682 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_srli_pi16(__m64 __m , int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 684
  __cil_tmp3 = __builtin_ia32_psrlwi((__v4hi )__m, __count);
  }
#line 684
  return ((__m64 )__cil_tmp3);
}
}
#line 688
__inline extern __m64 _m_psrlwi(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 688 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psrlwi(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 690
  __cil_tmp3 = _mm_srli_pi16(__m, __count);
  }
#line 690
  return (__cil_tmp3);
}
}
#line 695
__inline extern __m64 _mm_srl_pi32(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 695 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_srl_pi32(__m64 __m , __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 697
  __cil_tmp3 = __builtin_ia32_psrld((__v2si )__m, (__v2si )__count);
  }
#line 697
  return ((__m64 )__cil_tmp3);
}
}
#line 701
__inline extern __m64 _m_psrld(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 701 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psrld(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 703
  __cil_tmp3 = _mm_srl_pi32(__m, __count);
  }
#line 703
  return (__cil_tmp3);
}
}
#line 707
__inline extern __m64 _mm_srli_pi32(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 707 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_srli_pi32(__m64 __m , int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 709
  __cil_tmp3 = __builtin_ia32_psrldi((__v2si )__m, __count);
  }
#line 709
  return ((__m64 )__cil_tmp3);
}
}
#line 713
__inline extern __m64 _m_psrldi(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 713 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psrldi(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 715
  __cil_tmp3 = _mm_srli_pi32(__m, __count);
  }
#line 715
  return (__cil_tmp3);
}
}
#line 720
__inline extern __m64 _mm_srl_si64(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 720 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_srl_si64(__m64 __m , __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 722
  __cil_tmp3 = __builtin_ia32_psrlq((__v1di )__m, (__v1di )__count);
  }
#line 722
  return ((__m64 )__cil_tmp3);
}
}
#line 726
__inline extern __m64 _m_psrlq(__m64 __m , __m64 __count )  __attribute__((__gnu_inline__)) ;
#line 726 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psrlq(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 728
  __cil_tmp3 = _mm_srl_si64(__m, __count);
  }
#line 728
  return (__cil_tmp3);
}
}
#line 732
__inline extern __m64 _mm_srli_si64(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 732 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_srli_si64(__m64 __m , int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 734
  __cil_tmp3 = __builtin_ia32_psrlqi((__v1di )__m, __count);
  }
#line 734
  return ((__m64 )__cil_tmp3);
}
}
#line 738
__inline extern __m64 _m_psrlqi(__m64 __m , int __count )  __attribute__((__gnu_inline__)) ;
#line 738 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_psrlqi(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 740
  __cil_tmp3 = _mm_srli_si64(__m, __count);
  }
#line 740
  return (__cil_tmp3);
}
}
#line 745
__inline extern __m64 _mm_and_si64(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 745 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_and_si64(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 747
  __cil_tmp3 = __builtin_ia32_pand(__m1, __m2);
  }
#line 747
  return (__cil_tmp3);
}
}
#line 751
__inline extern __m64 _m_pand(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 751 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pand(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 753
  __cil_tmp3 = _mm_and_si64(__m1, __m2);
  }
#line 753
  return (__cil_tmp3);
}
}
#line 759
__inline extern __m64 _mm_andnot_si64(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 759 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_andnot_si64(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 761
  __cil_tmp3 = __builtin_ia32_pandn(__m1, __m2);
  }
#line 761
  return (__cil_tmp3);
}
}
#line 765
__inline extern __m64 _m_pandn(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 765 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pandn(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 767
  __cil_tmp3 = _mm_andnot_si64(__m1, __m2);
  }
#line 767
  return (__cil_tmp3);
}
}
#line 772
__inline extern __m64 _mm_or_si64(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 772 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_or_si64(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 774
  __cil_tmp3 = __builtin_ia32_por(__m1, __m2);
  }
#line 774
  return (__cil_tmp3);
}
}
#line 778
__inline extern __m64 _m_por(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 778 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_por(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 780
  __cil_tmp3 = _mm_or_si64(__m1, __m2);
  }
#line 780
  return (__cil_tmp3);
}
}
#line 785
__inline extern __m64 _mm_xor_si64(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 785 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_xor_si64(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 787
  __cil_tmp3 = __builtin_ia32_pxor(__m1, __m2);
  }
#line 787
  return (__cil_tmp3);
}
}
#line 791
__inline extern __m64 _m_pxor(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 791 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pxor(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 793
  __cil_tmp3 = _mm_xor_si64(__m1, __m2);
  }
#line 793
  return (__cil_tmp3);
}
}
#line 799
__inline extern __m64 _mm_cmpeq_pi8(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 799 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_cmpeq_pi8(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 801
  __cil_tmp3 = __builtin_ia32_pcmpeqb((__v8qi )__m1, (__v8qi )__m2);
  }
#line 801
  return ((__m64 )__cil_tmp3);
}
}
#line 805
__inline extern __m64 _m_pcmpeqb(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 805 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pcmpeqb(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 807
  __cil_tmp3 = _mm_cmpeq_pi8(__m1, __m2);
  }
#line 807
  return (__cil_tmp3);
}
}
#line 811
__inline extern __m64 _mm_cmpgt_pi8(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 811 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_cmpgt_pi8(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 813
  __cil_tmp3 = __builtin_ia32_pcmpgtb((__v8qi )__m1, (__v8qi )__m2);
  }
#line 813
  return ((__m64 )__cil_tmp3);
}
}
#line 817
__inline extern __m64 _m_pcmpgtb(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 817 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pcmpgtb(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 819
  __cil_tmp3 = _mm_cmpgt_pi8(__m1, __m2);
  }
#line 819
  return (__cil_tmp3);
}
}
#line 825
__inline extern __m64 _mm_cmpeq_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 825 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_cmpeq_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 827
  __cil_tmp3 = __builtin_ia32_pcmpeqw((__v4hi )__m1, (__v4hi )__m2);
  }
#line 827
  return ((__m64 )__cil_tmp3);
}
}
#line 831
__inline extern __m64 _m_pcmpeqw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 831 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pcmpeqw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 833
  __cil_tmp3 = _mm_cmpeq_pi16(__m1, __m2);
  }
#line 833
  return (__cil_tmp3);
}
}
#line 837
__inline extern __m64 _mm_cmpgt_pi16(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 837 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_cmpgt_pi16(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 839
  __cil_tmp3 = __builtin_ia32_pcmpgtw((__v4hi )__m1, (__v4hi )__m2);
  }
#line 839
  return ((__m64 )__cil_tmp3);
}
}
#line 843
__inline extern __m64 _m_pcmpgtw(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 843 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pcmpgtw(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 845
  __cil_tmp3 = _mm_cmpgt_pi16(__m1, __m2);
  }
#line 845
  return (__cil_tmp3);
}
}
#line 851
__inline extern __m64 _mm_cmpeq_pi32(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 851 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_cmpeq_pi32(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 853
  __cil_tmp3 = __builtin_ia32_pcmpeqd((__v2si )__m1, (__v2si )__m2);
  }
#line 853
  return ((__m64 )__cil_tmp3);
}
}
#line 857
__inline extern __m64 _m_pcmpeqd(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 857 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pcmpeqd(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 859
  __cil_tmp3 = _mm_cmpeq_pi32(__m1, __m2);
  }
#line 859
  return (__cil_tmp3);
}
}
#line 863
__inline extern __m64 _mm_cmpgt_pi32(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 863 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_cmpgt_pi32(__m64 __m1 , __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 865
  __cil_tmp3 = __builtin_ia32_pcmpgtd((__v2si )__m1, (__v2si )__m2);
  }
#line 865
  return ((__m64 )__cil_tmp3);
}
}
#line 869
__inline extern __m64 _m_pcmpgtd(__m64 __m1 , __m64 __m2 )  __attribute__((__gnu_inline__)) ;
#line 869 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _m_pcmpgtd(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 871
  __cil_tmp3 = _mm_cmpgt_pi32(__m1, __m2);
  }
#line 871
  return (__cil_tmp3);
}
}
#line 876
__inline extern __m64 _mm_setzero_si64(void)  __attribute__((__gnu_inline__)) ;
#line 876 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_setzero_si64(void) 
{ 


  {
#line 878
  return ((__m64 )0LL);
}
}
#line 883
__inline extern __m64 _mm_set_pi32(int __i1 , int __i0 )  __attribute__((__gnu_inline__)) ;
#line 883 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_set_pi32(int __i1 , int __i0 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 885
  __cil_tmp3 = __builtin_ia32_vec_init_v2si(__i0, __i1);
  }
#line 885
  return ((__m64 )__cil_tmp3);
}
}
#line 890
__inline extern __m64 _mm_set_pi16(short __w3 , short __w2 , short __w1 , short __w0 )  __attribute__((__gnu_inline__)) ;
#line 890 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_set_pi16(short __w3 , short __w2 , short __w1 , short __w0 ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 892
  __cil_tmp5 = __builtin_ia32_vec_init_v4hi(__w0, __w1, __w2, __w3);
  }
#line 892
  return ((__m64 )__cil_tmp5);
}
}
#line 897
__inline extern __m64 _mm_set_pi8(char __b7 , char __b6 , char __b5 , char __b4 ,
                                  char __b3 , char __b2 , char __b1 , char __b0 )  __attribute__((__gnu_inline__)) ;
#line 897 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_set_pi8(char __b7 , char __b6 , char __b5 , char __b4 ,
                                  char __b3 , char __b2 , char __b1 , char __b0 ) 
{ 
  int __cil_tmp9 ;

  {
  {
#line 900
  __cil_tmp9 = __builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3, __b4, __b5, __b6,
                                            __b7);
  }
#line 900
  return ((__m64 )__cil_tmp9);
}
}
#line 906
__inline extern __m64 _mm_setr_pi32(int __i0 , int __i1 )  __attribute__((__gnu_inline__)) ;
#line 906 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_setr_pi32(int __i0 , int __i1 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 908
  __cil_tmp3 = _mm_set_pi32(__i1, __i0);
  }
#line 908
  return (__cil_tmp3);
}
}
#line 912
__inline extern __m64 _mm_setr_pi16(short __w0 , short __w1 , short __w2 , short __w3 )  __attribute__((__gnu_inline__)) ;
#line 912 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_setr_pi16(short __w0 , short __w1 , short __w2 , short __w3 ) 
{ 
  __m64 __cil_tmp5 ;

  {
  {
#line 914
  __cil_tmp5 = _mm_set_pi16(__w3, __w2, __w1, __w0);
  }
#line 914
  return (__cil_tmp5);
}
}
#line 918
__inline extern __m64 _mm_setr_pi8(char __b0 , char __b1 , char __b2 , char __b3 ,
                                   char __b4 , char __b5 , char __b6 , char __b7 )  __attribute__((__gnu_inline__)) ;
#line 918 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_setr_pi8(char __b0 , char __b1 , char __b2 , char __b3 ,
                                   char __b4 , char __b5 , char __b6 , char __b7 ) 
{ 
  __m64 __cil_tmp9 ;

  {
  {
#line 921
  __cil_tmp9 = _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
  }
#line 921
  return (__cil_tmp9);
}
}
#line 926
__inline extern __m64 _mm_set1_pi32(int __i )  __attribute__((__gnu_inline__)) ;
#line 926 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_set1_pi32(int __i ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 928
  __cil_tmp2 = _mm_set_pi32(__i, __i);
  }
#line 928
  return (__cil_tmp2);
}
}
#line 933
__inline extern __m64 _mm_set1_pi16(short __w )  __attribute__((__gnu_inline__)) ;
#line 933 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_set1_pi16(short __w ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 935
  __cil_tmp2 = _mm_set_pi16(__w, __w, __w, __w);
  }
#line 935
  return (__cil_tmp2);
}
}
#line 940
__inline extern __m64 _mm_set1_pi8(char __b )  __attribute__((__gnu_inline__)) ;
#line 940 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 _mm_set1_pi8(char __b ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 942
  __cil_tmp2 = _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
  }
#line 942
  return (__cil_tmp2);
}
}
#line 38 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mm_malloc.h"
__inline static void *_mm_malloc(size_t __size , size_t __alignment ) 
{ 
  void *__ptr ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 41
  if (__alignment == 1UL) {
    {
#line 42
    __cil_tmp4 = malloc(__size);
    }
#line 42
    return (__cil_tmp4);
  }
#line 43
  if (__alignment == 2UL) {
#line 44
    __alignment = sizeof(void *);
  } else
#line 43
  if (sizeof(void *) == 8UL) {
#line 43
    if (__alignment == 4UL) {
#line 44
      __alignment = sizeof(void *);
    }
  }
  {
#line 45
  __cil_tmp5 = posix_memalign(& __ptr, __alignment, __size);
  }
#line 45
  if (__cil_tmp5 == 0) {
#line 46
    return (__ptr);
  } else {
#line 48
    return ((void *)0);
  }
}
}
#line 52 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mm_malloc.h"
__inline static void _mm_free(void *__ptr ) 
{ 


  {
  {
#line 54
  free(__ptr);
  }
  return;
}
}
#line 52 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_prefetch(void const   *__P , enum _mm_hint __I )  __attribute__((__gnu_inline__)) ;
#line 52 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_prefetch(void const   *__P , enum _mm_hint __I ) 
{ 


  {
  return;
}
}
#line 110
__inline extern __m128 _mm_undefined_ps(void)  __attribute__((__gnu_inline__)) ;
#line 110 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_undefined_ps(void) 
{ 
  __m128 __Y ;

  {
#line 112
  __Y = __Y;
#line 113
  return (__Y);
}
}
#line 118
__inline extern __m128 _mm_setzero_ps(void)  __attribute__((__gnu_inline__)) ;
#line 118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_setzero_ps(void) 
{ 
  __m128 tmp ;

  {
#line 120
  return (tmp);
}
}
#line 128
__inline extern __m128 _mm_add_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_add_ss(__m128 __A , __m128 __B ) 
{ 


  {
  return;
}
}
#line 152
__inline extern __m128 _mm_sqrt_ss(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 152 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_sqrt_ss(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 154
  __cil_tmp2 = __builtin_ia32_sqrtss((__v4sf )__A);
  }
#line 154
  return ((__m128 )__cil_tmp2);
}
}
#line 158
__inline extern __m128 _mm_rcp_ss(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 158 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_rcp_ss(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 160
  __cil_tmp2 = __builtin_ia32_rcpss((__v4sf )__A);
  }
#line 160
  return ((__m128 )__cil_tmp2);
}
}
#line 164
__inline extern __m128 _mm_rsqrt_ss(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 164 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_rsqrt_ss(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 166
  __cil_tmp2 = __builtin_ia32_rsqrtss((__v4sf )__A);
  }
#line 166
  return ((__m128 )__cil_tmp2);
}
}
#line 170
__inline extern __m128 _mm_min_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 170 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_min_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 172
  __cil_tmp3 = __builtin_ia32_minss((__v4sf )__A, (__v4sf )__B);
  }
#line 172
  return ((__m128 )__cil_tmp3);
}
}
#line 176
__inline extern __m128 _mm_max_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 176 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_max_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 178
  __cil_tmp3 = __builtin_ia32_maxss((__v4sf )__A, (__v4sf )__B);
  }
#line 178
  return ((__m128 )__cil_tmp3);
}
}
#line 184
__inline extern __m128 _mm_add_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 184 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_add_ps(__m128 __A , __m128 __B ) 
{ 


  {
#line 186
  return ((__m128 )((__v4sf )__A + (__v4sf )__B));
}
}
#line 190
__inline extern __m128 _mm_sub_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 190 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_sub_ps(__m128 __A , __m128 __B ) 
{ 


  {
#line 192
  return ((__m128 )((__v4sf )__A - (__v4sf )__B));
}
}
#line 196
__inline extern __m128 _mm_mul_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 196 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_mul_ps(__m128 __A , __m128 __B ) 
{ 


  {
#line 198
  return ((__m128 )((__v4sf )__A * (__v4sf )__B));
}
}
#line 202
__inline extern __m128 _mm_div_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 202 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_div_ps(__m128 __A , __m128 __B ) 
{ 


  {
#line 204
  return ((__m128 )((__v4sf )__A / (__v4sf )__B));
}
}
#line 208
__inline extern __m128 _mm_sqrt_ps(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 208 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_sqrt_ps(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 210
  __cil_tmp2 = __builtin_ia32_sqrtps((__v4sf )__A);
  }
#line 210
  return ((__m128 )__cil_tmp2);
}
}
#line 214
__inline extern __m128 _mm_rcp_ps(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 214 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_rcp_ps(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 216
  __cil_tmp2 = __builtin_ia32_rcpps((__v4sf )__A);
  }
#line 216
  return ((__m128 )__cil_tmp2);
}
}
#line 220
__inline extern __m128 _mm_rsqrt_ps(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 220 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_rsqrt_ps(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 222
  __cil_tmp2 = __builtin_ia32_rsqrtps((__v4sf )__A);
  }
#line 222
  return ((__m128 )__cil_tmp2);
}
}
#line 226
__inline extern __m128 _mm_min_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 226 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_min_ps(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 228
  __cil_tmp3 = __builtin_ia32_minps((__v4sf )__A, (__v4sf )__B);
  }
#line 228
  return ((__m128 )__cil_tmp3);
}
}
#line 232
__inline extern __m128 _mm_max_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_max_ps(__m128 __A , __m128 __B ) 
{ 
  float __attribute__((____vector_size____(16)))  __cil_tmp3 ;

  {
  {
#line 234
  __cil_tmp3 = __builtin_ia32_maxps((__v4sf )__A, (__v4sf )__B);
  }
#line 234
  return ((__m128 )__cil_tmp3);
}
}
#line 268
__inline extern __m128 _mm_cmpeq_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 268 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpeq_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 270
  __cil_tmp3 = __builtin_ia32_cmpeqss((__v4sf )__A, (__v4sf )__B);
  }
#line 270
  return ((__m128 )__cil_tmp3);
}
}
#line 274
__inline extern __m128 _mm_cmplt_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 274 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmplt_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 276
  __cil_tmp3 = __builtin_ia32_cmpltss((__v4sf )__A, (__v4sf )__B);
  }
#line 276
  return ((__m128 )__cil_tmp3);
}
}
#line 280
__inline extern __m128 _mm_cmple_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 280 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmple_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 282
  __cil_tmp3 = __builtin_ia32_cmpless((__v4sf )__A, (__v4sf )__B);
  }
#line 282
  return ((__m128 )__cil_tmp3);
}
}
#line 306
__inline extern __m128 _mm_cmpneq_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 306 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpneq_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 308
  __cil_tmp3 = __builtin_ia32_cmpneqss((__v4sf )__A, (__v4sf )__B);
  }
#line 308
  return ((__m128 )__cil_tmp3);
}
}
#line 312
__inline extern __m128 _mm_cmpnlt_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 312 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpnlt_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 314
  __cil_tmp3 = __builtin_ia32_cmpnltss((__v4sf )__A, (__v4sf )__B);
  }
#line 314
  return ((__m128 )__cil_tmp3);
}
}
#line 318
__inline extern __m128 _mm_cmpnle_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 318 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpnle_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 320
  __cil_tmp3 = __builtin_ia32_cmpnless((__v4sf )__A, (__v4sf )__B);
  }
#line 320
  return ((__m128 )__cil_tmp3);
}
}
#line 344
__inline extern __m128 _mm_cmpord_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 344 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpord_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_ia32_cmpordss((__v4sf )__A, (__v4sf )__B);
  }
#line 346
  return ((__m128 )__cil_tmp3);
}
}
#line 350
__inline extern __m128 _mm_cmpunord_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 350 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpunord_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 352
  __cil_tmp3 = __builtin_ia32_cmpunordss((__v4sf )__A, (__v4sf )__B);
  }
#line 352
  return ((__m128 )__cil_tmp3);
}
}
#line 360
__inline extern __m128 _mm_cmpeq_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 360 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpeq_ps(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 362
  __cil_tmp3 = __builtin_ia32_cmpeqps((__v4sf )__A, (__v4sf )__B);
  }
#line 362
  return ((__m128 )__cil_tmp3);
}
}
#line 366
__inline extern __m128 _mm_cmplt_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmplt_ps(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 368
  __cil_tmp3 = __builtin_ia32_cmpltps((__v4sf )__A, (__v4sf )__B);
  }
#line 368
  return ((__m128 )__cil_tmp3);
}
}
#line 372
__inline extern __m128 _mm_cmple_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 372 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmple_ps(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 374
  __cil_tmp3 = __builtin_ia32_cmpleps((__v4sf )__A, (__v4sf )__B);
  }
#line 374
  return ((__m128 )__cil_tmp3);
}
}
#line 390
__inline extern __m128 _mm_cmpneq_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 390 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpneq_ps(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 392
  __cil_tmp3 = __builtin_ia32_cmpneqps((__v4sf )__A, (__v4sf )__B);
  }
#line 392
  return ((__m128 )__cil_tmp3);
}
}
#line 396
__inline extern __m128 _mm_cmpnlt_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 396 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpnlt_ps(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 398
  __cil_tmp3 = __builtin_ia32_cmpnltps((__v4sf )__A, (__v4sf )__B);
  }
#line 398
  return ((__m128 )__cil_tmp3);
}
}
#line 402
__inline extern __m128 _mm_cmpnle_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 402 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpnle_ps(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 404
  __cil_tmp3 = __builtin_ia32_cmpnleps((__v4sf )__A, (__v4sf )__B);
  }
#line 404
  return ((__m128 )__cil_tmp3);
}
}
#line 420
__inline extern __m128 _mm_cmpord_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 420 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpord_ps(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 422
  __cil_tmp3 = __builtin_ia32_cmpordps((__v4sf )__A, (__v4sf )__B);
  }
#line 422
  return ((__m128 )__cil_tmp3);
}
}
#line 426
__inline extern __m128 _mm_cmpunord_ps(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cmpunord_ps(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 428
  __cil_tmp3 = __builtin_ia32_cmpunordps((__v4sf )__A, (__v4sf )__B);
  }
#line 428
  return ((__m128 )__cil_tmp3);
}
}
#line 435
__inline extern int _mm_comieq_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 435 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_comieq_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 437
  __cil_tmp3 = __builtin_ia32_comieq((__v4sf )__A, (__v4sf )__B);
  }
#line 437
  return (__cil_tmp3);
}
}
#line 441
__inline extern int _mm_comilt_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 441 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_comilt_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 443
  __cil_tmp3 = __builtin_ia32_comilt((__v4sf )__A, (__v4sf )__B);
  }
#line 443
  return (__cil_tmp3);
}
}
#line 447
__inline extern int _mm_comile_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 447 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_comile_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 449
  __cil_tmp3 = __builtin_ia32_comile((__v4sf )__A, (__v4sf )__B);
  }
#line 449
  return (__cil_tmp3);
}
}
#line 453
__inline extern int _mm_comigt_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 453 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_comigt_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = __builtin_ia32_comigt((__v4sf )__A, (__v4sf )__B);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 459
__inline extern int _mm_comige_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 459 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_comige_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 461
  __cil_tmp3 = __builtin_ia32_comige((__v4sf )__A, (__v4sf )__B);
  }
#line 461
  return (__cil_tmp3);
}
}
#line 465
__inline extern int _mm_comineq_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 465 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_comineq_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 467
  __cil_tmp3 = __builtin_ia32_comineq((__v4sf )__A, (__v4sf )__B);
  }
#line 467
  return (__cil_tmp3);
}
}
#line 471
__inline extern int _mm_ucomieq_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 471 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_ucomieq_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 473
  __cil_tmp3 = __builtin_ia32_ucomieq((__v4sf )__A, (__v4sf )__B);
  }
#line 473
  return (__cil_tmp3);
}
}
#line 477
__inline extern int _mm_ucomilt_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 477 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_ucomilt_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 479
  __cil_tmp3 = __builtin_ia32_ucomilt((__v4sf )__A, (__v4sf )__B);
  }
#line 479
  return (__cil_tmp3);
}
}
#line 483
__inline extern int _mm_ucomile_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 483 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_ucomile_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 485
  __cil_tmp3 = __builtin_ia32_ucomile((__v4sf )__A, (__v4sf )__B);
  }
#line 485
  return (__cil_tmp3);
}
}
#line 489
__inline extern int _mm_ucomigt_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 489 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_ucomigt_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 491
  __cil_tmp3 = __builtin_ia32_ucomigt((__v4sf )__A, (__v4sf )__B);
  }
#line 491
  return (__cil_tmp3);
}
}
#line 495
__inline extern int _mm_ucomige_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 495 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_ucomige_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 497
  __cil_tmp3 = __builtin_ia32_ucomige((__v4sf )__A, (__v4sf )__B);
  }
#line 497
  return (__cil_tmp3);
}
}
#line 501
__inline extern int _mm_ucomineq_ss(__m128 __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 501 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_ucomineq_ss(__m128 __A , __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 503
  __cil_tmp3 = __builtin_ia32_ucomineq((__v4sf )__A, (__v4sf )__B);
  }
#line 503
  return (__cil_tmp3);
}
}
#line 509
__inline extern int _mm_cvtss_si32(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 509 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_cvtss_si32(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 511
  __cil_tmp2 = __builtin_ia32_cvtss2si((__v4sf )__A);
  }
#line 511
  return (__cil_tmp2);
}
}
#line 515
__inline extern int _mm_cvt_ss2si(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 515 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_cvt_ss2si(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 517
  __cil_tmp2 = _mm_cvtss_si32(__A);
  }
#line 517
  return (__cil_tmp2);
}
}
#line 526
__inline extern long long _mm_cvtss_si64(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 526 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern long long _mm_cvtss_si64(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 528
  __cil_tmp2 = __builtin_ia32_cvtss2si64((__v4sf )__A);
  }
#line 528
  return (__cil_tmp2);
}
}
#line 542
__inline extern __m64 _mm_cvtps_pi32(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 542 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_cvtps_pi32(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 544
  __cil_tmp2 = __builtin_ia32_cvtps2pi((__v4sf )__A);
  }
#line 544
  return ((__m64 )__cil_tmp2);
}
}
#line 548
__inline extern __m64 _mm_cvt_ps2pi(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 548 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_cvt_ps2pi(__m128 __A ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 550
  __cil_tmp2 = _mm_cvtps_pi32(__A);
  }
#line 550
  return (__cil_tmp2);
}
}
#line 555
__inline extern int _mm_cvttss_si32(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 555 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_cvttss_si32(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 557
  __cil_tmp2 = __builtin_ia32_cvttss2si((__v4sf )__A);
  }
#line 557
  return (__cil_tmp2);
}
}
#line 561
__inline extern int _mm_cvtt_ss2si(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 561 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_cvtt_ss2si(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 563
  __cil_tmp2 = _mm_cvttss_si32(__A);
  }
#line 563
  return (__cil_tmp2);
}
}
#line 571
__inline extern long long _mm_cvttss_si64(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 571 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern long long _mm_cvttss_si64(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 573
  __cil_tmp2 = __builtin_ia32_cvttss2si64((__v4sf )__A);
  }
#line 573
  return (__cil_tmp2);
}
}
#line 587
__inline extern __m64 _mm_cvttps_pi32(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 587 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_cvttps_pi32(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 589
  __cil_tmp2 = __builtin_ia32_cvttps2pi((__v4sf )__A);
  }
#line 589
  return ((__m64 )__cil_tmp2);
}
}
#line 593
__inline extern __m64 _mm_cvtt_ps2pi(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 593 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_cvtt_ps2pi(__m128 __A ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 595
  __cil_tmp2 = _mm_cvttps_pi32(__A);
  }
#line 595
  return (__cil_tmp2);
}
}
#line 600
__inline extern __m128 _mm_cvtsi32_ss(__m128 __A , int __B )  __attribute__((__gnu_inline__)) ;
#line 600 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cvtsi32_ss(__m128 __A , int __B ) 
{ 


  {
  return;
}
}
#line 606
__inline extern __m128 _mm_cvt_si2ss(__m128 __A , int __B )  __attribute__((__gnu_inline__)) ;
#line 606 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cvt_si2ss(__m128 __A , int __B ) 
{ 
  __m128 __cil_tmp3 ;

  {
  {
#line 608
  __cil_tmp3 = _mm_cvtsi32_ss(__A, __B);
  }
#line 608
  return (__cil_tmp3);
}
}
#line 616
__inline extern __m128 _mm_cvtsi64_ss(__m128 __A , long long __B )  __attribute__((__gnu_inline__)) ;
#line 616 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cvtsi64_ss(__m128 __A , long long __B ) 
{ 


  {
  return;
}
}
#line 632
__inline extern __m128 _mm_cvtpi32_ps(__m128 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 632 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cvtpi32_ps(__m128 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 634
  __cil_tmp3 = __builtin_ia32_cvtpi2ps((__v4sf )__A, (__v2si )__B);
  }
#line 634
  return ((__m128 )__cil_tmp3);
}
}
#line 638
__inline extern __m128 _mm_cvt_pi2ps(__m128 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 638 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cvt_pi2ps(__m128 __A , __m64 __B ) 
{ 
  __m128 __cil_tmp3 ;

  {
  {
#line 640
  __cil_tmp3 = _mm_cvtpi32_ps(__A, __B);
  }
#line 640
  return (__cil_tmp3);
}
}
#line 645
__inline extern __m128 _mm_cvtpi16_ps(__m64 __A )  __attribute__((__gnu_inline__)) ;
#line 645 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cvtpi16_ps(__m64 __A ) 
{ 
  __v4hi __sign ;
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  __m128 __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 654
  __sign = __builtin_ia32_pcmpgtw((__v4hi )0LL, (__v4hi )__A);
#line 657
  __cil_tmp9 = __builtin_ia32_punpcklwd((__v4hi )__A, __sign);
#line 657
  __losi = (__v2si )__cil_tmp9;
#line 658
  __cil_tmp10 = __builtin_ia32_punpckhwd((__v4hi )__A, __sign);
#line 658
  __hisi = (__v2si )__cil_tmp10;
#line 661
  __cil_tmp11 = _mm_setzero_ps();
#line 661
  __zero = (__v4sf )__cil_tmp11;
#line 662
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
#line 663
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  }
  return;
}
}
#line 670
__inline extern __m128 _mm_cvtpu16_ps(__m64 __A )  __attribute__((__gnu_inline__)) ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cvtpu16_ps(__m64 __A ) 
{ 
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  __m128 __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 676
  __cil_tmp7 = __builtin_ia32_punpcklwd((__v4hi )__A, (__v4hi )0LL);
#line 676
  __losi = (__v2si )__cil_tmp7;
#line 677
  __cil_tmp8 = __builtin_ia32_punpckhwd((__v4hi )__A, (__v4hi )0LL);
#line 677
  __hisi = (__v2si )__cil_tmp8;
#line 680
  __cil_tmp9 = _mm_setzero_ps();
#line 680
  __zero = (__v4sf )__cil_tmp9;
#line 681
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
#line 682
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  }
  return;
}
}
#line 689
__inline extern __m128 _mm_cvtpi8_ps(__m64 __A )  __attribute__((__gnu_inline__)) ;
#line 689 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cvtpi8_ps(__m64 __A ) 
{ 
  __v8qi __sign ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  __m128 __cil_tmp5 ;

  {
  {
#line 696
  __sign = __builtin_ia32_pcmpgtb((__v8qi )0LL, (__v8qi )__A);
#line 699
  __cil_tmp4 = __builtin_ia32_punpcklbw((__v8qi )__A, __sign);
#line 699
  __A = (__m64 )__cil_tmp4;
#line 701
  __cil_tmp5 = _mm_cvtpi16_ps(__A);
  }
#line 701
  return (__cil_tmp5);
}
}
#line 706
__inline extern __m128 _mm_cvtpu8_ps(__m64 __A )  __attribute__((__gnu_inline__)) ;
#line 706 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cvtpu8_ps(__m64 __A ) 
{ 
  int __cil_tmp2 ;
  __m128 __cil_tmp3 ;

  {
  {
#line 708
  __cil_tmp2 = __builtin_ia32_punpcklbw((__v8qi )__A, (__v8qi )0LL);
#line 708
  __A = (__m64 )__cil_tmp2;
#line 709
  __cil_tmp3 = _mm_cvtpu16_ps(__A);
  }
#line 709
  return (__cil_tmp3);
}
}
#line 714
__inline extern __m128 _mm_cvtpi32x2_ps(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 714 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_cvtpi32x2_ps(__m64 __A , __m64 __B ) 
{ 
  __v4sf __zero ;
  __m128 __cil_tmp4 ;
  __v4sf __sfa ;
  int __cil_tmp6 ;
  __v4sf __sfb ;
  int __cil_tmp8 ;

  {
  {
#line 716
  __cil_tmp4 = _mm_setzero_ps();
#line 716
  __zero = (__v4sf )__cil_tmp4;
#line 717
  __cil_tmp6 = __builtin_ia32_cvtpi2ps(__zero, (__v2si )__A);
#line 717
  __sfa = __cil_tmp6;
#line 718
  __cil_tmp8 = __builtin_ia32_cvtpi2ps(__sfa, (__v2si )__B);
#line 718
  __sfb = __cil_tmp8;
  }
  return;
}
}
#line 724
__inline extern __m64 _mm_cvtps_pi16(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 724 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_cvtps_pi16(__m128 __A ) 
{ 
  __v4sf __hisf ;
  __v4sf __losf ;
  __v2si __hisi ;
  int __cil_tmp5 ;
  __v2si __losi ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 726
  __hisf = (__v4sf )__A;
#line 727
  __losf = 0;
#line 728
  __cil_tmp5 = __builtin_ia32_cvtps2pi(__hisf);
#line 728
  __hisi = __cil_tmp5;
#line 729
  __cil_tmp7 = __builtin_ia32_cvtps2pi(__losf);
#line 729
  __losi = __cil_tmp7;
#line 730
  __cil_tmp8 = __builtin_ia32_packssdw(__hisi, __losi);
  }
#line 730
  return ((__m64 )__cil_tmp8);
}
}
#line 735
__inline extern __m64 _mm_cvtps_pi8(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 735 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_cvtps_pi8(__m128 __A ) 
{ 
  __v4hi __tmp ;
  __m64 __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 737
  __cil_tmp3 = _mm_cvtps_pi16(__A);
#line 737
  __tmp = (__v4hi )__cil_tmp3;
#line 738
  __cil_tmp4 = __builtin_ia32_packsswb(__tmp, (__v4hi )0LL);
  }
#line 738
  return ((__m64 )__cil_tmp4);
}
}
#line 744
__inline extern __m128 _mm_shuffle_ps(__m128 __A , __m128 __B , int __mask )  __attribute__((__gnu_inline__)) ;
#line 744 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_shuffle_ps(__m128 __A , __m128 __B , int __mask ) 
{ 


  {
#line 746
  return ((__m128 )0);
}
}
#line 771
__inline extern __m128 _mm_loadh_pi(__m128 __A , __m64 *__P )  __attribute__((__gnu_inline__)) ;
#line 771 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_loadh_pi(__m128 __A , __m64 *__P ) 
{ 


  {
  return;
}
}
#line 778
__inline extern void _mm_storeh_pi(__m64 *__P , __m128 __A )  __attribute__((__gnu_inline__)) ;
#line 778 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_storeh_pi(__m64 *__P , __m128 __A ) 
{ 


  {
  {
#line 780
  __builtin_ia32_storehps((__v2sf *)__P, (__v4sf )__A);
  }
  return;
}
}
#line 807
__inline extern void _mm_storel_pi(__m64 *__P , __m128 __A )  __attribute__((__gnu_inline__)) ;
#line 807 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_storel_pi(__m64 *__P , __m128 __A ) 
{ 


  {
  {
#line 809
  __builtin_ia32_storelps((__v2sf *)__P, (__v4sf )__A);
  }
  return;
}
}
#line 814
__inline extern int _mm_movemask_ps(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 814 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_movemask_ps(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 816
  __cil_tmp2 = __builtin_ia32_movmskps((__v4sf )__A);
  }
#line 816
  return (__cil_tmp2);
}
}
#line 821
__inline extern  __attribute__((__nothrow__)) unsigned int _mm_getcsr(void)  __attribute__((__gnu_inline__)) ;
#line 821 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern unsigned int _mm_getcsr(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 823
  __cil_tmp1 = __builtin_ia32_stmxcsr();
  }
#line 823
  return (__cil_tmp1);
}
}
#line 828
__inline extern unsigned int _MM_GET_EXCEPTION_STATE(void)  __attribute__((__gnu_inline__)) ;
#line 828 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern unsigned int _MM_GET_EXCEPTION_STATE(void) 
{ 


  {
  return (0U);
}
}
#line 853
__inline extern  __attribute__((__nothrow__)) void _mm_setcsr(unsigned int __I )  __attribute__((__gnu_inline__)) ;
#line 853 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_setcsr(unsigned int __I ) 
{ 


  {
  {
#line 855
  __builtin_ia32_ldmxcsr(__I);
  }
  return;
}
}
#line 860
__inline extern void _MM_SET_EXCEPTION_STATE(unsigned int __mask )  __attribute__((__gnu_inline__)) ;
#line 860 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _MM_SET_EXCEPTION_STATE(unsigned int __mask ) 
{ 


  {
  return;
}
}
#line 885
__inline extern __m128 _mm_set_ss(float __F )  __attribute__((__gnu_inline__)) ;
#line 885 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_set_ss(float __F ) 
{ 
  __v4sf tmp ;

  {
#line 887
  return ((__m128 )tmp);
}
}
#line 898
__inline extern __m128 _mm_set_ps1(float __F )  __attribute__((__gnu_inline__)) ;
#line 898 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_set_ps1(float __F ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 900
  __cil_tmp2 = _mm_set_ss(__F);
  }
#line 900
  return (__cil_tmp2);
}
}
#line 905
__inline extern __m128 _mm_load_ss(float const   *__P )  __attribute__((__gnu_inline__)) ;
#line 905 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_load_ss(float const   *__P ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 907
  __cil_tmp2 = _mm_set_ss(*__P);
  }
#line 907
  return (__cil_tmp2);
}
}
#line 918
__inline extern __m128 _mm_load_ps1(float const   *__P )  __attribute__((__gnu_inline__)) ;
#line 918 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_load_ps1(float const   *__P ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 920
  __cil_tmp2 = _mm_load_ss(__P);
  }
#line 920
  return (__cil_tmp2);
}
}
#line 925
__inline extern __m128 _mm_load_ps(float const   *__P )  __attribute__((__gnu_inline__)) ;
#line 925 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_load_ps(float const   *__P ) 
{ 


  {
#line 927
  return (*((__m128 *)__P));
}
}
#line 932
__inline extern __m128 _mm_loadu_ps(float const   *__P )  __attribute__((__gnu_inline__)) ;
#line 932 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_loadu_ps(float const   *__P ) 
{ 


  {
#line 934
  return (*((__m128_u *)__P));
}
}
#line 939
__inline extern __m128 _mm_loadr_ps(float const   *__P )  __attribute__((__gnu_inline__)) ;
#line 939 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_loadr_ps(float const   *__P ) 
{ 
  __v4sf __tmp ;
  int __cil_tmp3 ;

  {
  {
#line 941
  __tmp = *((__v4sf *)__P);
#line 942
  __cil_tmp3 = __builtin_ia32_shufps(__tmp, __tmp, ((1 << 4) | (2 << 2)) | 3);
  }
#line 942
  return ((__m128 )__cil_tmp3);
}
}
#line 947
__inline extern __m128 _mm_set_ps(float __Z , float __Y , float __X , float __W )  __attribute__((__gnu_inline__)) ;
#line 947 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 _mm_set_ps(float __Z , float __Y , float __X , float __W ) 
{ 
  __v4sf tmp ;

  {
#line 949
  return ((__m128 )tmp);
}
}
#line 961
__inline extern void _mm_store_ss(float *__P , __m128 __A )  __attribute__((__gnu_inline__)) ;
#line 961 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_store_ss(float *__P , __m128 __A ) 
{ 
  int __cil_tmp3 ;

  {
#line 963
  *__P = __cil_tmp3;
  return;
}
}
#line 967
__inline extern float _mm_cvtss_f32(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 967 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern float _mm_cvtss_f32(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 969
  return (__cil_tmp2);
}
}
#line 974
__inline extern void _mm_store_ps(float *__P , __m128 __A )  __attribute__((__gnu_inline__)) ;
#line 974 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_store_ps(float *__P , __m128 __A ) 
{ 


  {
#line 976
  *((__m128 *)__P) = __A;
  return;
}
}
#line 981
__inline extern void _mm_storeu_ps(float *__P , __m128 __A )  __attribute__((__gnu_inline__)) ;
#line 981 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_storeu_ps(float *__P , __m128 __A ) 
{ 


  {
#line 983
  *((__m128_u *)__P) = __A;
  return;
}
}
#line 988
__inline extern void _mm_store1_ps(float *__P , __m128 __A )  __attribute__((__gnu_inline__)) ;
#line 988 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_store1_ps(float *__P , __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int __cil_tmp5 ;

  {
  {
#line 990
  __va = (__v4sf )__A;
#line 991
  __cil_tmp5 = __builtin_ia32_shufps(__va, __va, 0);
#line 991
  __tmp = __cil_tmp5;
#line 992
  _mm_storeu_ps(__P, __tmp);
  }
  return;
}
}
#line 996
__inline extern void _mm_store_ps1(float *__P , __m128 __A )  __attribute__((__gnu_inline__)) ;
#line 996 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_store_ps1(float *__P , __m128 __A ) 
{ 


  {
  {
#line 998
  _mm_store1_ps(__P, __A);
  }
  return;
}
}
#line 1003
__inline extern void _mm_storer_ps(float *__P , __m128 __A )  __attribute__((__gnu_inline__)) ;
#line 1003 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_storer_ps(float *__P , __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int __cil_tmp5 ;

  {
  {
#line 1005
  __va = (__v4sf )__A;
#line 1006
  __cil_tmp5 = __builtin_ia32_shufps(__va, __va, ((1 << 4) | (2 << 2)) | 3);
#line 1006
  __tmp = __cil_tmp5;
#line 1007
  _mm_store_ps(__P, __tmp);
  }
  return;
}
}
#line 1020
__inline extern int _mm_extract_pi16(__m64 __A , int __N )  __attribute__((__gnu_inline__)) ;
#line 1020 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_extract_pi16(__m64 __A , int __N ) 
{ 


  {
#line 1022
  return (0);
}
}
#line 1026
__inline extern int _m_pextrw(__m64 __A , int __N )  __attribute__((__gnu_inline__)) ;
#line 1026 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _m_pextrw(__m64 __A , int __N ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1028
  __cil_tmp3 = _mm_extract_pi16(__A, __N);
  }
#line 1028
  return (__cil_tmp3);
}
}
#line 1041
__inline extern __m64 _mm_insert_pi16(__m64 __A , int __D , int __N )  __attribute__((__gnu_inline__)) ;
#line 1041 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_insert_pi16(__m64 __A , int __D , int __N ) 
{ 


  {
#line 1043
  return ((__m64 )0);
}
}
#line 1047
__inline extern __m64 _m_pinsrw(__m64 __A , int __D , int __N )  __attribute__((__gnu_inline__)) ;
#line 1047 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _m_pinsrw(__m64 __A , int __D , int __N ) 
{ 
  __m64 __cil_tmp4 ;

  {
  {
#line 1049
  __cil_tmp4 = _mm_insert_pi16(__A, __D, __N);
  }
#line 1049
  return (__cil_tmp4);
}
}
#line 1061
__inline extern __m64 _mm_max_pi16(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1061 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_max_pi16(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1063
  __cil_tmp3 = __builtin_ia32_pmaxsw((__v4hi )__A, (__v4hi )__B);
  }
#line 1063
  return ((__m64 )__cil_tmp3);
}
}
#line 1067
__inline extern __m64 _m_pmaxsw(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1067 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _m_pmaxsw(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1069
  __cil_tmp3 = _mm_max_pi16(__A, __B);
  }
#line 1069
  return (__cil_tmp3);
}
}
#line 1074
__inline extern __m64 _mm_max_pu8(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1074 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_max_pu8(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1076
  __cil_tmp3 = __builtin_ia32_pmaxub((__v8qi )__A, (__v8qi )__B);
  }
#line 1076
  return ((__m64 )__cil_tmp3);
}
}
#line 1080
__inline extern __m64 _m_pmaxub(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1080 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _m_pmaxub(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1082
  __cil_tmp3 = _mm_max_pu8(__A, __B);
  }
#line 1082
  return (__cil_tmp3);
}
}
#line 1087
__inline extern __m64 _mm_min_pi16(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1087 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_min_pi16(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1089
  __cil_tmp3 = __builtin_ia32_pminsw((__v4hi )__A, (__v4hi )__B);
  }
#line 1089
  return ((__m64 )__cil_tmp3);
}
}
#line 1093
__inline extern __m64 _m_pminsw(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1093 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _m_pminsw(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1095
  __cil_tmp3 = _mm_min_pi16(__A, __B);
  }
#line 1095
  return (__cil_tmp3);
}
}
#line 1100
__inline extern __m64 _mm_min_pu8(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_min_pu8(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1102
  __cil_tmp3 = __builtin_ia32_pminub((__v8qi )__A, (__v8qi )__B);
  }
#line 1102
  return ((__m64 )__cil_tmp3);
}
}
#line 1106
__inline extern __m64 _m_pminub(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1106 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _m_pminub(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1108
  __cil_tmp3 = _mm_min_pu8(__A, __B);
  }
#line 1108
  return (__cil_tmp3);
}
}
#line 1113
__inline extern int _mm_movemask_pi8(__m64 __A )  __attribute__((__gnu_inline__)) ;
#line 1113 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _mm_movemask_pi8(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1115
  __cil_tmp2 = __builtin_ia32_pmovmskb((__v8qi )__A);
  }
#line 1115
  return (__cil_tmp2);
}
}
#line 1119
__inline extern int _m_pmovmskb(__m64 __A )  __attribute__((__gnu_inline__)) ;
#line 1119 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int _m_pmovmskb(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1121
  __cil_tmp2 = _mm_movemask_pi8(__A);
  }
#line 1121
  return (__cil_tmp2);
}
}
#line 1127
__inline extern __m64 _mm_mulhi_pu16(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1127 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_mulhi_pu16(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1129
  __cil_tmp3 = __builtin_ia32_pmulhuw((__v4hi )__A, (__v4hi )__B);
  }
#line 1129
  return ((__m64 )__cil_tmp3);
}
}
#line 1133
__inline extern __m64 _m_pmulhuw(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1133 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _m_pmulhuw(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1135
  __cil_tmp3 = _mm_mulhi_pu16(__A, __B);
  }
#line 1135
  return (__cil_tmp3);
}
}
#line 1142
__inline extern __m64 _mm_shuffle_pi16(__m64 __A , int __N )  __attribute__((__gnu_inline__)) ;
#line 1142 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_shuffle_pi16(__m64 __A , int __N ) 
{ 


  {
#line 1144
  return ((__m64 )0);
}
}
#line 1148
__inline extern __m64 _m_pshufw(__m64 __A , int __N )  __attribute__((__gnu_inline__)) ;
#line 1148 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _m_pshufw(__m64 __A , int __N ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1150
  __cil_tmp3 = _mm_shuffle_pi16(__A, __N);
  }
#line 1150
  return (__cil_tmp3);
}
}
#line 1163
__inline extern void _mm_maskmove_si64(__m64 __A , __m64 __N , char *__P )  __attribute__((__gnu_inline__)) ;
#line 1163 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_maskmove_si64(__m64 __A , __m64 __N , char *__P ) 
{ 


  {
  {
#line 1165
  __builtin_ia32_maskmovq((__v8qi )__A, (__v8qi )__N, __P);
  }
  return;
}
}
#line 1169
__inline extern void _m_maskmovq(__m64 __A , __m64 __N , char *__P )  __attribute__((__gnu_inline__)) ;
#line 1169 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _m_maskmovq(__m64 __A , __m64 __N , char *__P ) 
{ 


  {
  {
#line 1171
  _mm_maskmove_si64(__A, __N, __P);
  }
  return;
}
}
#line 1176
__inline extern __m64 _mm_avg_pu8(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1176 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_avg_pu8(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1178
  __cil_tmp3 = __builtin_ia32_pavgb((__v8qi )__A, (__v8qi )__B);
  }
#line 1178
  return ((__m64 )__cil_tmp3);
}
}
#line 1182
__inline extern __m64 _m_pavgb(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1182 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _m_pavgb(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1184
  __cil_tmp3 = _mm_avg_pu8(__A, __B);
  }
#line 1184
  return (__cil_tmp3);
}
}
#line 1189
__inline extern __m64 _mm_avg_pu16(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1189 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_avg_pu16(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1191
  __cil_tmp3 = __builtin_ia32_pavgw((__v4hi )__A, (__v4hi )__B);
  }
#line 1191
  return ((__m64 )__cil_tmp3);
}
}
#line 1195
__inline extern __m64 _m_pavgw(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1195 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _m_pavgw(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1197
  __cil_tmp3 = _mm_avg_pu16(__A, __B);
  }
#line 1197
  return (__cil_tmp3);
}
}
#line 1204
__inline extern __m64 _mm_sad_pu8(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1204 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _mm_sad_pu8(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1206
  __cil_tmp3 = __builtin_ia32_psadbw((__v8qi )__A, (__v8qi )__B);
  }
#line 1206
  return ((__m64 )__cil_tmp3);
}
}
#line 1210
__inline extern __m64 _m_psadbw(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1210 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 _m_psadbw(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1212
  __cil_tmp3 = _mm_sad_pu8(__A, __B);
  }
#line 1212
  return (__cil_tmp3);
}
}
#line 1217
__inline extern void _mm_stream_pi(__m64 *__P , __m64 __A )  __attribute__((__gnu_inline__)) ;
#line 1217 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_stream_pi(__m64 *__P , __m64 __A ) 
{ 


  {
  return;
}
}
#line 1224
__inline extern void _mm_stream_ps(float *__P , __m128 __A )  __attribute__((__gnu_inline__)) ;
#line 1224 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_stream_ps(float *__P , __m128 __A ) 
{ 


  {
  {
#line 1226
  __builtin_ia32_movntps(__P, (__v4sf )__A);
  }
  return;
}
}
#line 1232
__inline extern  __attribute__((__nothrow__)) void _mm_sfence(void)  __attribute__((__gnu_inline__)) ;
#line 1232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_sfence(void) 
{ 


  {
  {
#line 1234
  __builtin_ia32_sfence();
  }
  return;
}
}
#line 66 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_set_sd(double __F )  __attribute__((__gnu_inline__)) ;
#line 66 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_set_sd(double __F ) 
{ 
  __m128d tmp ;

  {
#line 68
  return (tmp);
}
}
#line 79
__inline extern __m128d _mm_set_pd1(double __F )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_set_pd1(double __F ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 81
  __cil_tmp2 = _mm_set_sd(__F);
  }
#line 81
  return (__cil_tmp2);
}
}
#line 86
__inline extern __m128d _mm_set_pd(double __W , double __X )  __attribute__((__gnu_inline__)) ;
#line 86 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_set_pd(double __W , double __X ) 
{ 
  __m128d tmp ;

  {
#line 88
  return (tmp);
}
}
#line 100
__inline extern __m128d _mm_undefined_pd(void)  __attribute__((__gnu_inline__)) ;
#line 100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_undefined_pd(void) 
{ 
  __m128d __Y ;

  {
#line 102
  __Y = __Y;
#line 103
  return (__Y);
}
}
#line 108
__inline extern __m128d _mm_setzero_pd(void)  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_setzero_pd(void) 
{ 
  __m128d tmp ;

  {
#line 110
  return (tmp);
}
}
#line 115
__inline extern __m128d _mm_move_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 115 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_move_sd(__m128d __A , __m128d __B ) 
{ 


  {
  return;
}
}
#line 122
__inline extern __m128d _mm_load_pd(double const   *__P )  __attribute__((__gnu_inline__)) ;
#line 122 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_load_pd(double const   *__P ) 
{ 


  {
#line 124
  return (*((__m128d *)__P));
}
}
#line 129
__inline extern __m128d _mm_loadu_pd(double const   *__P )  __attribute__((__gnu_inline__)) ;
#line 129 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_loadu_pd(double const   *__P ) 
{ 


  {
#line 131
  return (*((__m128d_u *)__P));
}
}
#line 136
__inline extern __m128d _mm_load1_pd(double const   *__P )  __attribute__((__gnu_inline__)) ;
#line 136 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_load1_pd(double const   *__P ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 138
  __cil_tmp2 = _mm_set_sd(*__P);
  }
#line 138
  return (__cil_tmp2);
}
}
#line 149
__inline extern __m128d _mm_load_pd1(double const   *__P )  __attribute__((__gnu_inline__)) ;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_load_pd1(double const   *__P ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 151
  __cil_tmp2 = _mm_load1_pd(__P);
  }
#line 151
  return (__cil_tmp2);
}
}
#line 156
__inline extern __m128d _mm_loadr_pd(double const   *__P )  __attribute__((__gnu_inline__)) ;
#line 156 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_loadr_pd(double const   *__P ) 
{ 
  __m128d __tmp ;
  __m128d __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 158
  __cil_tmp3 = _mm_load_pd(__P);
#line 158
  __tmp = __cil_tmp3;
#line 159
  __cil_tmp4 = __builtin_ia32_shufpd(__tmp, __tmp, 1);
  }
#line 159
  return (__cil_tmp4);
}
}
#line 164
__inline extern void _mm_store_pd(double *__P , __m128d __A )  __attribute__((__gnu_inline__)) ;
#line 164 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_store_pd(double *__P , __m128d __A ) 
{ 


  {
#line 166
  *((__m128d *)__P) = __A;
  return;
}
}
#line 171
__inline extern void _mm_storeu_pd(double *__P , __m128d __A )  __attribute__((__gnu_inline__)) ;
#line 171 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_storeu_pd(double *__P , __m128d __A ) 
{ 


  {
#line 173
  *((__m128d_u *)__P) = __A;
  return;
}
}
#line 178
__inline extern void _mm_store_sd(double *__P , __m128d __A )  __attribute__((__gnu_inline__)) ;
#line 178 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_store_sd(double *__P , __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
#line 180
  *__P = __cil_tmp3;
  return;
}
}
#line 184
__inline extern double _mm_cvtsd_f64(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 184 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern double _mm_cvtsd_f64(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 186
  return (__cil_tmp2);
}
}
#line 190
__inline extern void _mm_storel_pd(double *__P , __m128d __A )  __attribute__((__gnu_inline__)) ;
#line 190 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_storel_pd(double *__P , __m128d __A ) 
{ 


  {
  {
#line 192
  _mm_store_sd(__P, __A);
  }
  return;
}
}
#line 205
__inline extern void _mm_store1_pd(double *__P , __m128d __A )  __attribute__((__gnu_inline__)) ;
#line 205 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_store1_pd(double *__P , __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 207
  __cil_tmp3 = __builtin_ia32_shufpd(__A, __A, 0);
#line 207
  _mm_store_pd(__P, __cil_tmp3);
  }
  return;
}
}
#line 211
__inline extern void _mm_store_pd1(double *__P , __m128d __A )  __attribute__((__gnu_inline__)) ;
#line 211 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_store_pd1(double *__P , __m128d __A ) 
{ 


  {
  {
#line 213
  _mm_store1_pd(__P, __A);
  }
  return;
}
}
#line 218
__inline extern void _mm_storer_pd(double *__P , __m128d __A )  __attribute__((__gnu_inline__)) ;
#line 218 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_storer_pd(double *__P , __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 220
  __cil_tmp3 = __builtin_ia32_shufpd(__A, __A, 1);
#line 220
  _mm_store_pd(__P, __cil_tmp3);
  }
  return;
}
}
#line 224
__inline extern int _mm_cvtsi128_si32(__m128i __A )  __attribute__((__gnu_inline__)) ;
#line 224 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_cvtsi128_si32(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 226
  __cil_tmp2 = __builtin_ia32_vec_ext_v4si((__v4si )__A, 0);
  }
#line 226
  return (__cil_tmp2);
}
}
#line 232
__inline extern long long _mm_cvtsi128_si64(__m128i __A )  __attribute__((__gnu_inline__)) ;
#line 232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long _mm_cvtsi128_si64(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 234
  return (__cil_tmp2);
}
}
#line 246
__inline extern __m128d _mm_add_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 246 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_add_pd(__m128d __A , __m128d __B ) 
{ 


  {
#line 248
  return ((__m128d )((__v2df )__A + (__v2df )__B));
}
}
#line 258
__inline extern __m128d _mm_sub_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 258 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_sub_pd(__m128d __A , __m128d __B ) 
{ 


  {
#line 260
  return ((__m128d )((__v2df )__A - (__v2df )__B));
}
}
#line 270
__inline extern __m128d _mm_mul_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 270 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_mul_pd(__m128d __A , __m128d __B ) 
{ 


  {
#line 272
  return ((__m128d )((__v2df )__A * (__v2df )__B));
}
}
#line 282
__inline extern __m128d _mm_div_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 282 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_div_pd(__m128d __A , __m128d __B ) 
{ 


  {
#line 284
  return ((__m128d )((__v2df )__A / (__v2df )__B));
}
}
#line 294
__inline extern __m128d _mm_sqrt_pd(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 294 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_sqrt_pd(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 296
  __cil_tmp2 = __builtin_ia32_sqrtpd((__v2df )__A);
  }
#line 296
  return ((__m128d )__cil_tmp2);
}
}
#line 301
__inline extern __m128d _mm_sqrt_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 301 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_sqrt_sd(__m128d __A , __m128d __B ) 
{ 
  __v2df __tmp ;
  int __cil_tmp4 ;

  {
  {
#line 303
  __tmp = 0;
#line 304
  __cil_tmp4 = __builtin_ia32_sqrtsd((__v2df )__tmp);
  }
#line 304
  return ((__m128d )__cil_tmp4);
}
}
#line 308
__inline extern __m128d _mm_min_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 308 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_min_pd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 310
  __cil_tmp3 = __builtin_ia32_minpd((__v2df )__A, (__v2df )__B);
  }
#line 310
  return ((__m128d )__cil_tmp3);
}
}
#line 314
__inline extern __m128d _mm_min_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 314 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_min_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 316
  __cil_tmp3 = __builtin_ia32_minsd((__v2df )__A, (__v2df )__B);
  }
#line 316
  return ((__m128d )__cil_tmp3);
}
}
#line 320
__inline extern __m128d _mm_max_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 320 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_max_pd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 322
  __cil_tmp3 = __builtin_ia32_maxpd((__v2df )__A, (__v2df )__B);
  }
#line 322
  return ((__m128d )__cil_tmp3);
}
}
#line 326
__inline extern __m128d _mm_max_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 326 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_max_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 328
  __cil_tmp3 = __builtin_ia32_maxsd((__v2df )__A, (__v2df )__B);
  }
#line 328
  return ((__m128d )__cil_tmp3);
}
}
#line 356
__inline extern __m128d _mm_cmpeq_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 356 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpeq_pd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 358
  __cil_tmp3 = __builtin_ia32_cmpeqpd((__v2df )__A, (__v2df )__B);
  }
#line 358
  return ((__m128d )__cil_tmp3);
}
}
#line 362
__inline extern __m128d _mm_cmplt_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmplt_pd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 364
  __cil_tmp3 = __builtin_ia32_cmpltpd((__v2df )__A, (__v2df )__B);
  }
#line 364
  return ((__m128d )__cil_tmp3);
}
}
#line 368
__inline extern __m128d _mm_cmple_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 368 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmple_pd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 370
  __cil_tmp3 = __builtin_ia32_cmplepd((__v2df )__A, (__v2df )__B);
  }
#line 370
  return ((__m128d )__cil_tmp3);
}
}
#line 386
__inline extern __m128d _mm_cmpneq_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 386 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpneq_pd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 388
  __cil_tmp3 = __builtin_ia32_cmpneqpd((__v2df )__A, (__v2df )__B);
  }
#line 388
  return ((__m128d )__cil_tmp3);
}
}
#line 392
__inline extern __m128d _mm_cmpnlt_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 392 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpnlt_pd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 394
  __cil_tmp3 = __builtin_ia32_cmpnltpd((__v2df )__A, (__v2df )__B);
  }
#line 394
  return ((__m128d )__cil_tmp3);
}
}
#line 398
__inline extern __m128d _mm_cmpnle_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 398 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpnle_pd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 400
  __cil_tmp3 = __builtin_ia32_cmpnlepd((__v2df )__A, (__v2df )__B);
  }
#line 400
  return ((__m128d )__cil_tmp3);
}
}
#line 416
__inline extern __m128d _mm_cmpord_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 416 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpord_pd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 418
  __cil_tmp3 = __builtin_ia32_cmpordpd((__v2df )__A, (__v2df )__B);
  }
#line 418
  return ((__m128d )__cil_tmp3);
}
}
#line 422
__inline extern __m128d _mm_cmpunord_pd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 422 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpunord_pd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 424
  __cil_tmp3 = __builtin_ia32_cmpunordpd((__v2df )__A, (__v2df )__B);
  }
#line 424
  return ((__m128d )__cil_tmp3);
}
}
#line 428
__inline extern __m128d _mm_cmpeq_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 428 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpeq_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 430
  __cil_tmp3 = __builtin_ia32_cmpeqsd((__v2df )__A, (__v2df )__B);
  }
#line 430
  return ((__m128d )__cil_tmp3);
}
}
#line 434
__inline extern __m128d _mm_cmplt_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 434 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmplt_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 436
  __cil_tmp3 = __builtin_ia32_cmpltsd((__v2df )__A, (__v2df )__B);
  }
#line 436
  return ((__m128d )__cil_tmp3);
}
}
#line 440
__inline extern __m128d _mm_cmple_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 440 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmple_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 442
  __cil_tmp3 = __builtin_ia32_cmplesd((__v2df )__A, (__v2df )__B);
  }
#line 442
  return ((__m128d )__cil_tmp3);
}
}
#line 466
__inline extern __m128d _mm_cmpneq_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 466 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpneq_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 468
  __cil_tmp3 = __builtin_ia32_cmpneqsd((__v2df )__A, (__v2df )__B);
  }
#line 468
  return ((__m128d )__cil_tmp3);
}
}
#line 472
__inline extern __m128d _mm_cmpnlt_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 472 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpnlt_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 474
  __cil_tmp3 = __builtin_ia32_cmpnltsd((__v2df )__A, (__v2df )__B);
  }
#line 474
  return ((__m128d )__cil_tmp3);
}
}
#line 478
__inline extern __m128d _mm_cmpnle_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 478 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpnle_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 480
  __cil_tmp3 = __builtin_ia32_cmpnlesd((__v2df )__A, (__v2df )__B);
  }
#line 480
  return ((__m128d )__cil_tmp3);
}
}
#line 504
__inline extern __m128d _mm_cmpord_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 504 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpord_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 506
  __cil_tmp3 = __builtin_ia32_cmpordsd((__v2df )__A, (__v2df )__B);
  }
#line 506
  return ((__m128d )__cil_tmp3);
}
}
#line 510
__inline extern __m128d _mm_cmpunord_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cmpunord_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 512
  __cil_tmp3 = __builtin_ia32_cmpunordsd((__v2df )__A, (__v2df )__B);
  }
#line 512
  return ((__m128d )__cil_tmp3);
}
}
#line 516
__inline extern int _mm_comieq_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 516 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_comieq_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 518
  __cil_tmp3 = __builtin_ia32_comisdeq((__v2df )__A, (__v2df )__B);
  }
#line 518
  return (__cil_tmp3);
}
}
#line 522
__inline extern int _mm_comilt_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 522 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_comilt_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 524
  __cil_tmp3 = __builtin_ia32_comisdlt((__v2df )__A, (__v2df )__B);
  }
#line 524
  return (__cil_tmp3);
}
}
#line 528
__inline extern int _mm_comile_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 528 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_comile_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 530
  __cil_tmp3 = __builtin_ia32_comisdle((__v2df )__A, (__v2df )__B);
  }
#line 530
  return (__cil_tmp3);
}
}
#line 534
__inline extern int _mm_comigt_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 534 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_comigt_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 536
  __cil_tmp3 = __builtin_ia32_comisdgt((__v2df )__A, (__v2df )__B);
  }
#line 536
  return (__cil_tmp3);
}
}
#line 540
__inline extern int _mm_comige_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 540 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_comige_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 542
  __cil_tmp3 = __builtin_ia32_comisdge((__v2df )__A, (__v2df )__B);
  }
#line 542
  return (__cil_tmp3);
}
}
#line 546
__inline extern int _mm_comineq_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 546 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_comineq_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 548
  __cil_tmp3 = __builtin_ia32_comisdneq((__v2df )__A, (__v2df )__B);
  }
#line 548
  return (__cil_tmp3);
}
}
#line 552
__inline extern int _mm_ucomieq_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 552 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_ucomieq_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 554
  __cil_tmp3 = __builtin_ia32_ucomisdeq((__v2df )__A, (__v2df )__B);
  }
#line 554
  return (__cil_tmp3);
}
}
#line 558
__inline extern int _mm_ucomilt_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 558 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_ucomilt_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 560
  __cil_tmp3 = __builtin_ia32_ucomisdlt((__v2df )__A, (__v2df )__B);
  }
#line 560
  return (__cil_tmp3);
}
}
#line 564
__inline extern int _mm_ucomile_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 564 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_ucomile_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 566
  __cil_tmp3 = __builtin_ia32_ucomisdle((__v2df )__A, (__v2df )__B);
  }
#line 566
  return (__cil_tmp3);
}
}
#line 570
__inline extern int _mm_ucomigt_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 570 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_ucomigt_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 572
  __cil_tmp3 = __builtin_ia32_ucomisdgt((__v2df )__A, (__v2df )__B);
  }
#line 572
  return (__cil_tmp3);
}
}
#line 576
__inline extern int _mm_ucomige_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 576 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_ucomige_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 578
  __cil_tmp3 = __builtin_ia32_ucomisdge((__v2df )__A, (__v2df )__B);
  }
#line 578
  return (__cil_tmp3);
}
}
#line 582
__inline extern int _mm_ucomineq_sd(__m128d __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 582 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_ucomineq_sd(__m128d __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 584
  __cil_tmp3 = __builtin_ia32_ucomisdneq((__v2df )__A, (__v2df )__B);
  }
#line 584
  return (__cil_tmp3);
}
}
#line 590
__inline extern __m128i _mm_set_epi64x(long long __q1 , long long __q0 )  __attribute__((__gnu_inline__)) ;
#line 590 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_set_epi64x(long long __q1 , long long __q0 ) 
{ 
  __v2di tmp ;

  {
#line 592
  return ((__m128i )tmp);
}
}
#line 596
__inline extern __m128i _mm_set_epi64(__m64 __q1 , __m64 __q0 )  __attribute__((__gnu_inline__)) ;
#line 596 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_set_epi64(__m64 __q1 , __m64 __q0 ) 
{ 
  __m128i __cil_tmp3 ;

  {
  {
#line 598
  __cil_tmp3 = _mm_set_epi64x((long long )__q1, (long long )__q0);
  }
#line 598
  return (__cil_tmp3);
}
}
#line 602
__inline extern __m128i _mm_set_epi32(int __q3 , int __q2 , int __q1 , int __q0 )  __attribute__((__gnu_inline__)) ;
#line 602 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_set_epi32(int __q3 , int __q2 , int __q1 , int __q0 ) 
{ 
  __v4si tmp ;

  {
#line 604
  return ((__m128i )tmp);
}
}
#line 608
__inline extern __m128i _mm_set_epi16(short __q7 , short __q6 , short __q5 , short __q4 ,
                                      short __q3 , short __q2 , short __q1 , short __q0 )  __attribute__((__gnu_inline__)) ;
#line 608 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_set_epi16(short __q7 , short __q6 , short __q5 , short __q4 ,
                                      short __q3 , short __q2 , short __q1 , short __q0 ) 
{ 
  __v8hi tmp ;

  {
#line 611
  return ((__m128i )tmp);
}
}
#line 616
__inline extern __m128i _mm_set_epi8(char __q15 , char __q14 , char __q13 , char __q12 ,
                                     char __q11 , char __q10 , char __q09 , char __q08 ,
                                     char __q07 , char __q06 , char __q05 , char __q04 ,
                                     char __q03 , char __q02 , char __q01 , char __q00 )  __attribute__((__gnu_inline__)) ;
#line 616 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_set_epi8(char __q15 , char __q14 , char __q13 , char __q12 ,
                                     char __q11 , char __q10 , char __q09 , char __q08 ,
                                     char __q07 , char __q06 , char __q05 , char __q04 ,
                                     char __q03 , char __q02 , char __q01 , char __q00 ) 
{ 
  __v16qi tmp ;

  {
#line 621
  return ((__m128i )tmp);
}
}
#line 630
__inline extern __m128i _mm_set1_epi64x(long long __A )  __attribute__((__gnu_inline__)) ;
#line 630 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_set1_epi64x(long long __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 632
  __cil_tmp2 = _mm_set_epi64x(__A, __A);
  }
#line 632
  return (__cil_tmp2);
}
}
#line 636
__inline extern __m128i _mm_set1_epi64(__m64 __A )  __attribute__((__gnu_inline__)) ;
#line 636 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_set1_epi64(__m64 __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 638
  __cil_tmp2 = _mm_set_epi64(__A, __A);
  }
#line 638
  return (__cil_tmp2);
}
}
#line 642
__inline extern __m128i _mm_set1_epi32(int __A )  __attribute__((__gnu_inline__)) ;
#line 642 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_set1_epi32(int __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 644
  __cil_tmp2 = _mm_set_epi32(__A, __A, __A, __A);
  }
#line 644
  return (__cil_tmp2);
}
}
#line 648
__inline extern __m128i _mm_set1_epi16(short __A )  __attribute__((__gnu_inline__)) ;
#line 648 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_set1_epi16(short __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 650
  __cil_tmp2 = _mm_set_epi16(__A, __A, __A, __A, __A, __A, __A, __A);
  }
#line 650
  return (__cil_tmp2);
}
}
#line 654
__inline extern __m128i _mm_set1_epi8(char __A )  __attribute__((__gnu_inline__)) ;
#line 654 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_set1_epi8(char __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 656
  __cil_tmp2 = _mm_set_epi8(__A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A,
                            __A, __A, __A, __A, __A);
  }
#line 656
  return (__cil_tmp2);
}
}
#line 664
__inline extern __m128i _mm_setr_epi64(__m64 __q0 , __m64 __q1 )  __attribute__((__gnu_inline__)) ;
#line 664 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_setr_epi64(__m64 __q0 , __m64 __q1 ) 
{ 
  __m128i __cil_tmp3 ;

  {
  {
#line 666
  __cil_tmp3 = _mm_set_epi64(__q1, __q0);
  }
#line 666
  return (__cil_tmp3);
}
}
#line 670
__inline extern __m128i _mm_setr_epi32(int __q0 , int __q1 , int __q2 , int __q3 )  __attribute__((__gnu_inline__)) ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_setr_epi32(int __q0 , int __q1 , int __q2 , int __q3 ) 
{ 
  __m128i __cil_tmp5 ;

  {
  {
#line 672
  __cil_tmp5 = _mm_set_epi32(__q3, __q2, __q1, __q0);
  }
#line 672
  return (__cil_tmp5);
}
}
#line 676
__inline extern __m128i _mm_setr_epi16(short __q0 , short __q1 , short __q2 , short __q3 ,
                                       short __q4 , short __q5 , short __q6 , short __q7 )  __attribute__((__gnu_inline__)) ;
#line 676 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_setr_epi16(short __q0 , short __q1 , short __q2 , short __q3 ,
                                       short __q4 , short __q5 , short __q6 , short __q7 ) 
{ 
  __m128i __cil_tmp9 ;

  {
  {
#line 679
  __cil_tmp9 = _mm_set_epi16(__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
  }
#line 679
  return (__cil_tmp9);
}
}
#line 683
__inline extern __m128i _mm_setr_epi8(char __q00 , char __q01 , char __q02 , char __q03 ,
                                      char __q04 , char __q05 , char __q06 , char __q07 ,
                                      char __q08 , char __q09 , char __q10 , char __q11 ,
                                      char __q12 , char __q13 , char __q14 , char __q15 )  __attribute__((__gnu_inline__)) ;
#line 683 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_setr_epi8(char __q00 , char __q01 , char __q02 , char __q03 ,
                                      char __q04 , char __q05 , char __q06 , char __q07 ,
                                      char __q08 , char __q09 , char __q10 , char __q11 ,
                                      char __q12 , char __q13 , char __q14 , char __q15 ) 
{ 
  __m128i __cil_tmp17 ;

  {
  {
#line 688
  __cil_tmp17 = _mm_set_epi8(__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,
                             __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
  }
#line 688
  return (__cil_tmp17);
}
}
#line 695
__inline extern __m128i _mm_load_si128(__m128i *__P )  __attribute__((__gnu_inline__)) ;
#line 695 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_load_si128(__m128i *__P ) 
{ 


  {
#line 697
  return (*__P);
}
}
#line 701
__inline extern __m128i _mm_loadu_si128(__m128i_u *__P )  __attribute__((__gnu_inline__)) ;
#line 701 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_loadu_si128(__m128i_u *__P ) 
{ 


  {
#line 703
  return (*__P);
}
}
#line 707
__inline extern __m128i _mm_loadl_epi64(__m128i_u *__P )  __attribute__((__gnu_inline__)) ;
#line 707 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_loadl_epi64(__m128i_u *__P ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 709
  __cil_tmp2 = _mm_set_epi64((__m64 )0LL, *((__m64_u *)__P));
  }
#line 709
  return (__cil_tmp2);
}
}
#line 713
__inline extern void _mm_store_si128(__m128i *__P , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 713 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_store_si128(__m128i *__P , __m128i __B ) 
{ 


  {
#line 715
  *__P = __B;
  return;
}
}
#line 719
__inline extern void _mm_storeu_si128(__m128i_u *__P , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 719 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_storeu_si128(__m128i_u *__P , __m128i __B ) 
{ 


  {
#line 721
  *__P = __B;
  return;
}
}
#line 725
__inline extern void _mm_storel_epi64(__m128i_u *__P , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 725 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_storel_epi64(__m128i_u *__P , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
#line 727
  *((__m64_u *)__P) = (__m64 )__cil_tmp3;
  return;
}
}
#line 731
__inline extern __m64 _mm_movepi64_pi64(__m128i __B )  __attribute__((__gnu_inline__)) ;
#line 731 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 _mm_movepi64_pi64(__m128i __B ) 
{ 
  int __cil_tmp2 ;

  {
#line 733
  return ((__m64 )__cil_tmp2);
}
}
#line 737
__inline extern __m128i _mm_movpi64_epi64(__m64 __A )  __attribute__((__gnu_inline__)) ;
#line 737 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_movpi64_epi64(__m64 __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 739
  __cil_tmp2 = _mm_set_epi64((__m64 )0LL, __A);
  }
#line 739
  return (__cil_tmp2);
}
}
#line 743
__inline extern __m128i _mm_move_epi64(__m128i __A )  __attribute__((__gnu_inline__)) ;
#line 743 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_move_epi64(__m128i __A ) 
{ 


  {
  return;
}
}
#line 750
__inline extern __m128i _mm_undefined_si128(void)  __attribute__((__gnu_inline__)) ;
#line 750 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_undefined_si128(void) 
{ 
  __m128i __Y ;

  {
#line 752
  __Y = __Y;
#line 753
  return (__Y);
}
}
#line 758
__inline extern __m128i _mm_setzero_si128(void)  __attribute__((__gnu_inline__)) ;
#line 758 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_setzero_si128(void) 
{ 
  __v4si tmp ;

  {
#line 760
  return ((__m128i )tmp);
}
}
#line 764
__inline extern __m128d _mm_cvtepi32_pd(__m128i __A )  __attribute__((__gnu_inline__)) ;
#line 764 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cvtepi32_pd(__m128i __A ) 
{ 


  {
  return;
}
}
#line 770
__inline extern __m128 _mm_cvtepi32_ps(__m128i __A )  __attribute__((__gnu_inline__)) ;
#line 770 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 _mm_cvtepi32_ps(__m128i __A ) 
{ 


  {
  return;
}
}
#line 776
__inline extern __m128i _mm_cvtpd_epi32(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 776 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cvtpd_epi32(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 778
  __cil_tmp2 = __builtin_ia32_cvtpd2dq((__v2df )__A);
  }
#line 778
  return ((__m128i )__cil_tmp2);
}
}
#line 782
__inline extern __m64 _mm_cvtpd_pi32(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 782 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 _mm_cvtpd_pi32(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 784
  __cil_tmp2 = __builtin_ia32_cvtpd2pi((__v2df )__A);
  }
#line 784
  return ((__m64 )__cil_tmp2);
}
}
#line 788
__inline extern __m128 _mm_cvtpd_ps(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 788 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 _mm_cvtpd_ps(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 790
  __cil_tmp2 = __builtin_ia32_cvtpd2ps((__v2df )__A);
  }
#line 790
  return ((__m128 )__cil_tmp2);
}
}
#line 794
__inline extern __m128i _mm_cvttpd_epi32(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 794 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cvttpd_epi32(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 796
  __cil_tmp2 = __builtin_ia32_cvttpd2dq((__v2df )__A);
  }
#line 796
  return ((__m128i )__cil_tmp2);
}
}
#line 800
__inline extern __m64 _mm_cvttpd_pi32(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 800 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 _mm_cvttpd_pi32(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 802
  __cil_tmp2 = __builtin_ia32_cvttpd2pi((__v2df )__A);
  }
#line 802
  return ((__m64 )__cil_tmp2);
}
}
#line 806
__inline extern __m128d _mm_cvtpi32_pd(__m64 __A )  __attribute__((__gnu_inline__)) ;
#line 806 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cvtpi32_pd(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 808
  __cil_tmp2 = __builtin_ia32_cvtpi2pd((__v2si )__A);
  }
#line 808
  return ((__m128d )__cil_tmp2);
}
}
#line 812
__inline extern __m128i _mm_cvtps_epi32(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 812 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cvtps_epi32(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 814
  __cil_tmp2 = __builtin_ia32_cvtps2dq((__v4sf )__A);
  }
#line 814
  return ((__m128i )__cil_tmp2);
}
}
#line 818
__inline extern __m128i _mm_cvttps_epi32(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 818 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cvttps_epi32(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 820
  __cil_tmp2 = __builtin_ia32_cvttps2dq((__v4sf )__A);
  }
#line 820
  return ((__m128i )__cil_tmp2);
}
}
#line 824
__inline extern __m128d _mm_cvtps_pd(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 824 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cvtps_pd(__m128 __A ) 
{ 


  {
  return;
}
}
#line 830
__inline extern int _mm_cvtsd_si32(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 830 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_cvtsd_si32(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 832
  __cil_tmp2 = __builtin_ia32_cvtsd2si((__v2df )__A);
  }
#line 832
  return (__cil_tmp2);
}
}
#line 838
__inline extern long long _mm_cvtsd_si64(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 838 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long _mm_cvtsd_si64(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 840
  __cil_tmp2 = __builtin_ia32_cvtsd2si64((__v2df )__A);
  }
#line 840
  return (__cil_tmp2);
}
}
#line 852
__inline extern int _mm_cvttsd_si32(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 852 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_cvttsd_si32(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 854
  __cil_tmp2 = __builtin_ia32_cvttsd2si((__v2df )__A);
  }
#line 854
  return (__cil_tmp2);
}
}
#line 860
__inline extern long long _mm_cvttsd_si64(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 860 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long _mm_cvttsd_si64(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 862
  __cil_tmp2 = __builtin_ia32_cvttsd2si64((__v2df )__A);
  }
#line 862
  return (__cil_tmp2);
}
}
#line 874
__inline extern __m128 _mm_cvtsd_ss(__m128 __A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 874 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 _mm_cvtsd_ss(__m128 __A , __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 876
  __cil_tmp3 = __builtin_ia32_cvtsd2ss((__v4sf )__A, (__v2df )__B);
  }
#line 876
  return ((__m128 )__cil_tmp3);
}
}
#line 880
__inline extern __m128d _mm_cvtsi32_sd(__m128d __A , int __B )  __attribute__((__gnu_inline__)) ;
#line 880 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cvtsi32_sd(__m128d __A , int __B ) 
{ 


  {
  return;
}
}
#line 888
__inline extern __m128d _mm_cvtsi64_sd(__m128d __A , long long __B )  __attribute__((__gnu_inline__)) ;
#line 888 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cvtsi64_sd(__m128d __A , long long __B ) 
{ 


  {
  return;
}
}
#line 902
__inline extern __m128d _mm_cvtss_sd(__m128d __A , __m128 __B )  __attribute__((__gnu_inline__)) ;
#line 902 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_cvtss_sd(__m128d __A , __m128 __B ) 
{ 


  {
  return;
}
}
#line 909
__inline extern __m128d _mm_shuffle_pd(__m128d __A , __m128d __B , int __mask )  __attribute__((__gnu_inline__)) ;
#line 909 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_shuffle_pd(__m128d __A , __m128d __B , int __mask ) 
{ 


  {
#line 911
  return ((__m128d )0);
}
}
#line 932
__inline extern __m128d _mm_loadh_pd(__m128d __A , double const   *__B )  __attribute__((__gnu_inline__)) ;
#line 932 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_loadh_pd(__m128d __A , double const   *__B ) 
{ 


  {
  return;
}
}
#line 944
__inline extern int _mm_movemask_pd(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 944 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_movemask_pd(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 946
  __cil_tmp2 = __builtin_ia32_movmskpd((__v2df )__A);
  }
#line 946
  return (__cil_tmp2);
}
}
#line 950
__inline extern __m128i _mm_packs_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 950 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_packs_epi16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 952
  __cil_tmp3 = __builtin_ia32_packsswb128((__v8hi )__A, (__v8hi )__B);
  }
#line 952
  return ((__m128i )__cil_tmp3);
}
}
#line 956
__inline extern __m128i _mm_packs_epi32(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 956 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_packs_epi32(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 958
  __cil_tmp3 = __builtin_ia32_packssdw128((__v4si )__A, (__v4si )__B);
  }
#line 958
  return ((__m128i )__cil_tmp3);
}
}
#line 962
__inline extern __m128i _mm_packus_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 962 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_packus_epi16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 964
  __cil_tmp3 = __builtin_ia32_packuswb128((__v8hi )__A, (__v8hi )__B);
  }
#line 964
  return ((__m128i )__cil_tmp3);
}
}
#line 968
__inline extern __m128i _mm_unpackhi_epi8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 968 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_unpackhi_epi8(__m128i __A , __m128i __B ) 
{ 


  {
  return;
}
}
#line 1016
__inline extern __m128i _mm_add_epi8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1016 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_add_epi8(__m128i __A , __m128i __B ) 
{ 


  {
#line 1018
  return ((__m128i )((__v16qu )__A + (__v16qu )__B));
}
}
#line 1022
__inline extern __m128i _mm_add_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1022 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_add_epi16(__m128i __A , __m128i __B ) 
{ 


  {
#line 1024
  return ((__m128i )((__v8hu )__A + (__v8hu )__B));
}
}
#line 1028
__inline extern __m128i _mm_add_epi32(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1028 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_add_epi32(__m128i __A , __m128i __B ) 
{ 


  {
#line 1030
  return ((__m128i )((__v4su )__A + (__v4su )__B));
}
}
#line 1034
__inline extern __m128i _mm_add_epi64(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1034 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_add_epi64(__m128i __A , __m128i __B ) 
{ 


  {
#line 1036
  return ((__m128i )((__v2du )__A + (__v2du )__B));
}
}
#line 1040
__inline extern __m128i _mm_adds_epi8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1040 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_adds_epi8(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1042
  __cil_tmp3 = __builtin_ia32_paddsb128((__v16qi )__A, (__v16qi )__B);
  }
#line 1042
  return ((__m128i )__cil_tmp3);
}
}
#line 1046
__inline extern __m128i _mm_adds_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1046 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_adds_epi16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1048
  __cil_tmp3 = __builtin_ia32_paddsw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1048
  return ((__m128i )__cil_tmp3);
}
}
#line 1052
__inline extern __m128i _mm_adds_epu8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1052 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_adds_epu8(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1054
  __cil_tmp3 = __builtin_ia32_paddusb128((__v16qi )__A, (__v16qi )__B);
  }
#line 1054
  return ((__m128i )__cil_tmp3);
}
}
#line 1058
__inline extern __m128i _mm_adds_epu16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1058 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_adds_epu16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1060
  __cil_tmp3 = __builtin_ia32_paddusw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1060
  return ((__m128i )__cil_tmp3);
}
}
#line 1064
__inline extern __m128i _mm_sub_epi8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1064 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_sub_epi8(__m128i __A , __m128i __B ) 
{ 


  {
#line 1066
  return ((__m128i )((__v16qu )__A - (__v16qu )__B));
}
}
#line 1070
__inline extern __m128i _mm_sub_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1070 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_sub_epi16(__m128i __A , __m128i __B ) 
{ 


  {
#line 1072
  return ((__m128i )((__v8hu )__A - (__v8hu )__B));
}
}
#line 1076
__inline extern __m128i _mm_sub_epi32(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1076 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_sub_epi32(__m128i __A , __m128i __B ) 
{ 


  {
#line 1078
  return ((__m128i )((__v4su )__A - (__v4su )__B));
}
}
#line 1082
__inline extern __m128i _mm_sub_epi64(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1082 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_sub_epi64(__m128i __A , __m128i __B ) 
{ 


  {
#line 1084
  return ((__m128i )((__v2du )__A - (__v2du )__B));
}
}
#line 1088
__inline extern __m128i _mm_subs_epi8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1088 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_subs_epi8(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1090
  __cil_tmp3 = __builtin_ia32_psubsb128((__v16qi )__A, (__v16qi )__B);
  }
#line 1090
  return ((__m128i )__cil_tmp3);
}
}
#line 1094
__inline extern __m128i _mm_subs_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1094 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_subs_epi16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1096
  __cil_tmp3 = __builtin_ia32_psubsw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1096
  return ((__m128i )__cil_tmp3);
}
}
#line 1100
__inline extern __m128i _mm_subs_epu8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_subs_epu8(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1102
  __cil_tmp3 = __builtin_ia32_psubusb128((__v16qi )__A, (__v16qi )__B);
  }
#line 1102
  return ((__m128i )__cil_tmp3);
}
}
#line 1106
__inline extern __m128i _mm_subs_epu16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1106 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_subs_epu16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1108
  __cil_tmp3 = __builtin_ia32_psubusw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1108
  return ((__m128i )__cil_tmp3);
}
}
#line 1112
__inline extern __m128i _mm_madd_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1112 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_madd_epi16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1114
  __cil_tmp3 = __builtin_ia32_pmaddwd128((__v8hi )__A, (__v8hi )__B);
  }
#line 1114
  return ((__m128i )__cil_tmp3);
}
}
#line 1118
__inline extern __m128i _mm_mulhi_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_mulhi_epi16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1120
  __cil_tmp3 = __builtin_ia32_pmulhw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1120
  return ((__m128i )__cil_tmp3);
}
}
#line 1124
__inline extern __m128i _mm_mullo_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1124 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_mullo_epi16(__m128i __A , __m128i __B ) 
{ 


  {
#line 1126
  return ((__m128i )((__v8hu )__A * (__v8hu )__B));
}
}
#line 1130
__inline extern __m64 _mm_mul_su32(__m64 __A , __m64 __B )  __attribute__((__gnu_inline__)) ;
#line 1130 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 _mm_mul_su32(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1132
  __cil_tmp3 = __builtin_ia32_pmuludq((__v2si )__A, (__v2si )__B);
  }
#line 1132
  return ((__m64 )__cil_tmp3);
}
}
#line 1136
__inline extern __m128i _mm_mul_epu32(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1136 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_mul_epu32(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1138
  __cil_tmp3 = __builtin_ia32_pmuludq128((__v4si )__A, (__v4si )__B);
  }
#line 1138
  return ((__m128i )__cil_tmp3);
}
}
#line 1142
__inline extern __m128i _mm_slli_epi16(__m128i __A , int __B )  __attribute__((__gnu_inline__)) ;
#line 1142 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_slli_epi16(__m128i __A , int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1144
  __cil_tmp3 = __builtin_ia32_psllwi128((__v8hi )__A, __B);
  }
#line 1144
  return ((__m128i )__cil_tmp3);
}
}
#line 1148
__inline extern __m128i _mm_slli_epi32(__m128i __A , int __B )  __attribute__((__gnu_inline__)) ;
#line 1148 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_slli_epi32(__m128i __A , int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1150
  __cil_tmp3 = __builtin_ia32_pslldi128((__v4si )__A, __B);
  }
#line 1150
  return ((__m128i )__cil_tmp3);
}
}
#line 1154
__inline extern __m128i _mm_slli_epi64(__m128i __A , int __B )  __attribute__((__gnu_inline__)) ;
#line 1154 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_slli_epi64(__m128i __A , int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1156
  __cil_tmp3 = __builtin_ia32_psllqi128((__v2di )__A, __B);
  }
#line 1156
  return ((__m128i )__cil_tmp3);
}
}
#line 1160
__inline extern __m128i _mm_srai_epi16(__m128i __A , int __B )  __attribute__((__gnu_inline__)) ;
#line 1160 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_srai_epi16(__m128i __A , int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1162
  __cil_tmp3 = __builtin_ia32_psrawi128((__v8hi )__A, __B);
  }
#line 1162
  return ((__m128i )__cil_tmp3);
}
}
#line 1166
__inline extern __m128i _mm_srai_epi32(__m128i __A , int __B )  __attribute__((__gnu_inline__)) ;
#line 1166 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_srai_epi32(__m128i __A , int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1168
  __cil_tmp3 = __builtin_ia32_psradi128((__v4si )__A, __B);
  }
#line 1168
  return ((__m128i )__cil_tmp3);
}
}
#line 1173
__inline extern __m128i _mm_bsrli_si128(__m128i __A , int __N )  __attribute__((__gnu_inline__)) ;
#line 1173 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_bsrli_si128(__m128i __A , int __N ) 
{ 


  {
  return;
}
}
#line 1207
__inline extern __m128i _mm_srli_epi16(__m128i __A , int __B )  __attribute__((__gnu_inline__)) ;
#line 1207 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_srli_epi16(__m128i __A , int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1209
  __cil_tmp3 = __builtin_ia32_psrlwi128((__v8hi )__A, __B);
  }
#line 1209
  return ((__m128i )__cil_tmp3);
}
}
#line 1213
__inline extern __m128i _mm_srli_epi32(__m128i __A , int __B )  __attribute__((__gnu_inline__)) ;
#line 1213 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_srli_epi32(__m128i __A , int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1215
  __cil_tmp3 = __builtin_ia32_psrldi128((__v4si )__A, __B);
  }
#line 1215
  return ((__m128i )__cil_tmp3);
}
}
#line 1219
__inline extern __m128i _mm_srli_epi64(__m128i __A , int __B )  __attribute__((__gnu_inline__)) ;
#line 1219 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_srli_epi64(__m128i __A , int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1221
  __cil_tmp3 = __builtin_ia32_psrlqi128((__v2di )__A, __B);
  }
#line 1221
  return ((__m128i )__cil_tmp3);
}
}
#line 1225
__inline extern __m128i _mm_sll_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1225 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_sll_epi16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1227
  __cil_tmp3 = __builtin_ia32_psllw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1227
  return ((__m128i )__cil_tmp3);
}
}
#line 1231
__inline extern __m128i _mm_sll_epi32(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1231 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_sll_epi32(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1233
  __cil_tmp3 = __builtin_ia32_pslld128((__v4si )__A, (__v4si )__B);
  }
#line 1233
  return ((__m128i )__cil_tmp3);
}
}
#line 1237
__inline extern __m128i _mm_sll_epi64(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1237 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_sll_epi64(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1239
  __cil_tmp3 = __builtin_ia32_psllq128((__v2di )__A, (__v2di )__B);
  }
#line 1239
  return ((__m128i )__cil_tmp3);
}
}
#line 1243
__inline extern __m128i _mm_sra_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1243 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_sra_epi16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1245
  __cil_tmp3 = __builtin_ia32_psraw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1245
  return ((__m128i )__cil_tmp3);
}
}
#line 1249
__inline extern __m128i _mm_sra_epi32(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1249 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_sra_epi32(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1251
  __cil_tmp3 = __builtin_ia32_psrad128((__v4si )__A, (__v4si )__B);
  }
#line 1251
  return ((__m128i )__cil_tmp3);
}
}
#line 1255
__inline extern __m128i _mm_srl_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1255 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_srl_epi16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1257
  __cil_tmp3 = __builtin_ia32_psrlw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1257
  return ((__m128i )__cil_tmp3);
}
}
#line 1261
__inline extern __m128i _mm_srl_epi32(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1261 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_srl_epi32(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1263
  __cil_tmp3 = __builtin_ia32_psrld128((__v4si )__A, (__v4si )__B);
  }
#line 1263
  return ((__m128i )__cil_tmp3);
}
}
#line 1267
__inline extern __m128i _mm_srl_epi64(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1267 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_srl_epi64(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1269
  __cil_tmp3 = __builtin_ia32_psrlq128((__v2di )__A, (__v2di )__B);
  }
#line 1269
  return ((__m128i )__cil_tmp3);
}
}
#line 1273
__inline extern __m128i _mm_and_si128(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1273 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_and_si128(__m128i __A , __m128i __B ) 
{ 


  {
#line 1275
  return ((__m128i )((__v2du )__A & (__v2du )__B));
}
}
#line 1285
__inline extern __m128i _mm_or_si128(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1285 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_or_si128(__m128i __A , __m128i __B ) 
{ 


  {
#line 1287
  return ((__m128i )((__v2du )__A | (__v2du )__B));
}
}
#line 1291
__inline extern __m128i _mm_xor_si128(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1291 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_xor_si128(__m128i __A , __m128i __B ) 
{ 


  {
#line 1293
  return ((__m128i )((__v2du )__A ^ (__v2du )__B));
}
}
#line 1297
__inline extern __m128i _mm_cmpeq_epi8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1297 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cmpeq_epi8(__m128i __A , __m128i __B ) 
{ 


  {
#line 1299
  return ((__m128i )((__v16qi )__A == (__v16qi )__B));
}
}
#line 1303
__inline extern __m128i _mm_cmpeq_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1303 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cmpeq_epi16(__m128i __A , __m128i __B ) 
{ 


  {
#line 1305
  return ((__m128i )((__v8hi )__A == (__v8hi )__B));
}
}
#line 1309
__inline extern __m128i _mm_cmpeq_epi32(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1309 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cmpeq_epi32(__m128i __A , __m128i __B ) 
{ 


  {
#line 1311
  return ((__m128i )((__v4si )__A == (__v4si )__B));
}
}
#line 1315
__inline extern __m128i _mm_cmplt_epi8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1315 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cmplt_epi8(__m128i __A , __m128i __B ) 
{ 


  {
#line 1317
  return ((__m128i )((__v16qs )__A < (__v16qs )__B));
}
}
#line 1321
__inline extern __m128i _mm_cmplt_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1321 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cmplt_epi16(__m128i __A , __m128i __B ) 
{ 


  {
#line 1323
  return ((__m128i )((__v8hi )__A < (__v8hi )__B));
}
}
#line 1327
__inline extern __m128i _mm_cmplt_epi32(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1327 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cmplt_epi32(__m128i __A , __m128i __B ) 
{ 


  {
#line 1329
  return ((__m128i )((__v4si )__A < (__v4si )__B));
}
}
#line 1333
__inline extern __m128i _mm_cmpgt_epi8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1333 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cmpgt_epi8(__m128i __A , __m128i __B ) 
{ 


  {
#line 1335
  return ((__m128i )((__v16qs )__A > (__v16qs )__B));
}
}
#line 1339
__inline extern __m128i _mm_cmpgt_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1339 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cmpgt_epi16(__m128i __A , __m128i __B ) 
{ 


  {
#line 1341
  return ((__m128i )((__v8hi )__A > (__v8hi )__B));
}
}
#line 1345
__inline extern __m128i _mm_cmpgt_epi32(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1345 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cmpgt_epi32(__m128i __A , __m128i __B ) 
{ 


  {
#line 1347
  return ((__m128i )((__v4si )__A > (__v4si )__B));
}
}
#line 1352
__inline extern int _mm_extract_epi16(__m128i __A , int __N )  __attribute__((__gnu_inline__)) ;
#line 1352 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_extract_epi16(__m128i __A , int __N ) 
{ 


  {
#line 1354
  return ((int )((unsigned short )0));
}
}
#line 1358
__inline extern __m128i _mm_insert_epi16(__m128i __A , int __D , int __N )  __attribute__((__gnu_inline__)) ;
#line 1358 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_insert_epi16(__m128i __A , int __D , int __N ) 
{ 


  {
#line 1360
  return ((__m128i )0);
}
}
#line 1371
__inline extern __m128i _mm_max_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1371 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_max_epi16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1373
  __cil_tmp3 = __builtin_ia32_pmaxsw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1373
  return ((__m128i )__cil_tmp3);
}
}
#line 1377
__inline extern __m128i _mm_max_epu8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1377 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_max_epu8(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1379
  __cil_tmp3 = __builtin_ia32_pmaxub128((__v16qi )__A, (__v16qi )__B);
  }
#line 1379
  return ((__m128i )__cil_tmp3);
}
}
#line 1383
__inline extern __m128i _mm_min_epi16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1383 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_min_epi16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1385
  __cil_tmp3 = __builtin_ia32_pminsw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1385
  return ((__m128i )__cil_tmp3);
}
}
#line 1389
__inline extern __m128i _mm_min_epu8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1389 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_min_epu8(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1391
  __cil_tmp3 = __builtin_ia32_pminub128((__v16qi )__A, (__v16qi )__B);
  }
#line 1391
  return ((__m128i )__cil_tmp3);
}
}
#line 1395
__inline extern int _mm_movemask_epi8(__m128i __A )  __attribute__((__gnu_inline__)) ;
#line 1395 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int _mm_movemask_epi8(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1397
  __cil_tmp2 = __builtin_ia32_pmovmskb128((__v16qi )__A);
  }
#line 1397
  return (__cil_tmp2);
}
}
#line 1401
__inline extern __m128i _mm_mulhi_epu16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1401 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_mulhi_epu16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1403
  __cil_tmp3 = __builtin_ia32_pmulhuw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1403
  return ((__m128i )__cil_tmp3);
}
}
#line 1408
__inline extern __m128i _mm_shufflehi_epi16(__m128i __A , int __mask )  __attribute__((__gnu_inline__)) ;
#line 1408 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_shufflehi_epi16(__m128i __A , int __mask ) 
{ 


  {
#line 1410
  return ((__m128i )0);
}
}
#line 1434
__inline extern void _mm_maskmoveu_si128(__m128i __A , __m128i __B , char *__C )  __attribute__((__gnu_inline__)) ;
#line 1434 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_maskmoveu_si128(__m128i __A , __m128i __B , char *__C ) 
{ 


  {
  {
#line 1436
  __builtin_ia32_maskmovdqu((__v16qi )__A, (__v16qi )__B, __C);
  }
  return;
}
}
#line 1440
__inline extern __m128i _mm_avg_epu8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1440 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_avg_epu8(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1442
  __cil_tmp3 = __builtin_ia32_pavgb128((__v16qi )__A, (__v16qi )__B);
  }
#line 1442
  return ((__m128i )__cil_tmp3);
}
}
#line 1446
__inline extern __m128i _mm_avg_epu16(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1446 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_avg_epu16(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1448
  __cil_tmp3 = __builtin_ia32_pavgw128((__v8hi )__A, (__v8hi )__B);
  }
#line 1448
  return ((__m128i )__cil_tmp3);
}
}
#line 1452
__inline extern __m128i _mm_sad_epu8(__m128i __A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1452 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_sad_epu8(__m128i __A , __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1454
  __cil_tmp3 = __builtin_ia32_psadbw128((__v16qi )__A, (__v16qi )__B);
  }
#line 1454
  return ((__m128i )__cil_tmp3);
}
}
#line 1458
__inline extern void _mm_stream_si32(int *__A , int __B )  __attribute__((__gnu_inline__)) ;
#line 1458 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_stream_si32(int *__A , int __B ) 
{ 


  {
  {
#line 1460
  __builtin_ia32_movnti(__A, __B);
  }
  return;
}
}
#line 1465
__inline extern void _mm_stream_si64(long long *__A , long long __B )  __attribute__((__gnu_inline__)) ;
#line 1465 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_stream_si64(long long *__A , long long __B ) 
{ 


  {
  {
#line 1467
  __builtin_ia32_movnti64(__A, __B);
  }
  return;
}
}
#line 1472
__inline extern void _mm_stream_si128(__m128i *__A , __m128i __B )  __attribute__((__gnu_inline__)) ;
#line 1472 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_stream_si128(__m128i *__A , __m128i __B ) 
{ 


  {
  {
#line 1474
  __builtin_ia32_movntdq((__v2di *)__A, (__v2di )__B);
  }
  return;
}
}
#line 1478
__inline extern void _mm_stream_pd(double *__A , __m128d __B )  __attribute__((__gnu_inline__)) ;
#line 1478 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_stream_pd(double *__A , __m128d __B ) 
{ 


  {
  {
#line 1480
  __builtin_ia32_movntpd(__A, (__v2df )__B);
  }
  return;
}
}
#line 1484
__inline extern  __attribute__((__nothrow__)) void _mm_clflush(void const   *__A )  __attribute__((__gnu_inline__)) ;
#line 1484 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_clflush(void const   *__A ) 
{ 


  {
  {
#line 1486
  __builtin_ia32_clflush(__A);
  }
  return;
}
}
#line 1490
__inline extern  __attribute__((__nothrow__)) void _mm_lfence(void)  __attribute__((__gnu_inline__)) ;
#line 1490 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_lfence(void) 
{ 


  {
  {
#line 1492
  __builtin_ia32_lfence();
  }
  return;
}
}
#line 1496
__inline extern  __attribute__((__nothrow__)) void _mm_mfence(void)  __attribute__((__gnu_inline__)) ;
#line 1496 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void _mm_mfence(void) 
{ 


  {
  {
#line 1498
  __builtin_ia32_mfence();
  }
  return;
}
}
#line 1502
__inline extern __m128i _mm_cvtsi32_si128(int __A )  __attribute__((__gnu_inline__)) ;
#line 1502 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cvtsi32_si128(int __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 1504
  __cil_tmp2 = _mm_set_epi32(0, 0, 0, __A);
  }
#line 1504
  return (__cil_tmp2);
}
}
#line 1510
__inline extern __m128i _mm_cvtsi64_si128(long long __A )  __attribute__((__gnu_inline__)) ;
#line 1510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_cvtsi64_si128(long long __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 1512
  __cil_tmp2 = _mm_set_epi64x((long long )0, __A);
  }
#line 1512
  return (__cil_tmp2);
}
}
#line 1526
__inline extern __m128 _mm_castpd_ps(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 1526 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 _mm_castpd_ps(__m128d __A ) 
{ 


  {
#line 1528
  return ((__m128 )__A);
}
}
#line 1532
__inline extern __m128i _mm_castpd_si128(__m128d __A )  __attribute__((__gnu_inline__)) ;
#line 1532 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_castpd_si128(__m128d __A ) 
{ 


  {
#line 1534
  return ((__m128i )__A);
}
}
#line 1538
__inline extern __m128d _mm_castps_pd(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 1538 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_castps_pd(__m128 __A ) 
{ 


  {
#line 1540
  return ((__m128d )__A);
}
}
#line 1544
__inline extern __m128i _mm_castps_si128(__m128 __A )  __attribute__((__gnu_inline__)) ;
#line 1544 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i _mm_castps_si128(__m128 __A ) 
{ 


  {
#line 1546
  return ((__m128i )__A);
}
}
#line 1550
__inline extern __m128 _mm_castsi128_ps(__m128i __A )  __attribute__((__gnu_inline__)) ;
#line 1550 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 _mm_castsi128_ps(__m128i __A ) 
{ 


  {
#line 1552
  return ((__m128 )__A);
}
}
#line 1556
__inline extern __m128d _mm_castsi128_pd(__m128i __A )  __attribute__((__gnu_inline__)) ;
#line 1556 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d _mm_castsi128_pd(__m128i __A ) 
{ 


  {
#line 1558
  return ((__m128d )__A);
}
}
#line 1265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern  __attribute__((__nothrow__)) void _mm_pause(void)  __attribute__((__gnu_inline__)) ;
#line 1265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void _mm_pause(void) 
{ 


  {
  {
#line 1267
  __builtin_ia32_pause();
  }
  return;
}
}
#line 41 "/root/patchweave_new/14/libopenjpeg/mct.c"
static double const   mct_norms[3]  = {      1.732,      0.829200000001,      0.829200000001};
#line 46 "/root/patchweave_new/14/libopenjpeg/mct.c"
static double const   mct_norms_real[3]  = {      1.732,      1.805,      1.573};
#line 51 "/root/patchweave_new/14/libopenjpeg/mct.c"
void mct_encode(int *c0 , int *c1 , int *c2 , int n ) 
{ 
  int i ;
  int r ;
  int g ;
  int b ;
  int y ;
  int u ;
  int v ;

  {
#line 58
  i = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < n)) {
#line 58
      goto while_break;
    }
#line 59
    r = *(c0 + i);
#line 60
    g = *(c1 + i);
#line 61
    b = *(c2 + i);
#line 62
    y = ((r + g * 2) + b) >> 2;
#line 63
    u = b - g;
#line 64
    v = r - g;
#line 65
    *(c0 + i) = y;
#line 66
    *(c1 + i) = u;
#line 67
    *(c2 + i) = v;
#line 58
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 74 "/root/patchweave_new/14/libopenjpeg/mct.c"
void mct_decode(int *c0 , int *c1 , int *c2 , int n ) 
{ 
  int i ;
  int y ;
  int u ;
  int v ;
  int g ;
  int r ;
  int b ;

  {
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < n)) {
#line 81
      goto while_break;
    }
#line 82
    y = *(c0 + i);
#line 83
    u = *(c1 + i);
#line 84
    v = *(c2 + i);
#line 85
    g = y - ((u + v) >> 2);
#line 86
    r = v + g;
#line 87
    b = u + g;
#line 88
    *(c0 + i) = r;
#line 89
    *(c1 + i) = g;
#line 90
    *(c2 + i) = b;
#line 81
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 97 "/root/patchweave_new/14/libopenjpeg/mct.c"
double mct_getnorm(int compno ) 
{ 


  {
#line 98
  return (mct_norms[compno]);
}
}
#line 104 "/root/patchweave_new/14/libopenjpeg/mct.c"
void mct_encode_real(int *c0 , int *c1 , int *c2 , int n ) 
{ 
  int i ;
  int r ;
  int g ;
  int b ;
  int y ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int u ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int v ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < n)) {
#line 111
      goto while_break;
    }
    {
#line 112
    r = *(c0 + i);
#line 113
    g = *(c1 + i);
#line 114
    b = *(c2 + i);
#line 115
    __cil_tmp12 = fix_mul(b, 934);
    }
    {
#line 115
    __cil_tmp11 = fix_mul(g, 4809);
    }
    {
#line 115
    __cil_tmp10 = fix_mul(r, 2449);
#line 115
    y = (__cil_tmp10 + __cil_tmp11) + __cil_tmp12;
#line 116
    __cil_tmp16 = fix_mul(b, 4096);
    }
    {
#line 116
    __cil_tmp15 = fix_mul(g, 2714);
    }
    {
#line 116
    __cil_tmp14 = fix_mul(r, 1382);
#line 116
    u = (- __cil_tmp14 - __cil_tmp15) + __cil_tmp16;
#line 117
    __cil_tmp20 = fix_mul(b, 666);
    }
    {
#line 117
    __cil_tmp19 = fix_mul(g, 3430);
    }
    {
#line 117
    __cil_tmp18 = fix_mul(r, 4096);
#line 117
    v = (__cil_tmp18 - __cil_tmp19) - __cil_tmp20;
#line 118
    *(c0 + i) = y;
#line 119
    *(c1 + i) = u;
#line 120
    *(c2 + i) = v;
    }
#line 111
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 127 "/root/patchweave_new/14/libopenjpeg/mct.c"
void mct_decode_real(float *c0 , float *c1 , float *c2 , int n ) 
{ 
  int i ;
  __m128 vrv ;
  __m128 vgu ;
  __m128 vgv ;
  __m128 vbu ;
  __m128 __cil_tmp10 ;
  __m128 __cil_tmp11 ;
  __m128 __cil_tmp12 ;
  __m128 __cil_tmp13 ;
  __m128 vy ;
  __m128 vu ;
  __m128 vv ;
  __m128 vr ;
  __m128 vg ;
  __m128 vb ;
  __m128 __cil_tmp20 ;
  __m128 __cil_tmp21 ;
  __m128 __cil_tmp22 ;
  __m128 __cil_tmp23 ;
  __m128 __cil_tmp24 ;
  __m128 __cil_tmp25 ;
  __m128 __cil_tmp26 ;
  __m128 __cil_tmp27 ;
  __m128 __cil_tmp28 ;
  __m128 __cil_tmp29 ;
  __m128 __cil_tmp30 ;
  __m128 __cil_tmp31 ;
  __m128 __cil_tmp32 ;
  __m128 __cil_tmp33 ;
  __m128 __cil_tmp34 ;
  __m128 __cil_tmp35 ;
  __m128 __cil_tmp36 ;
  __m128 __cil_tmp37 ;
  __m128 __cil_tmp38 ;
  __m128 __cil_tmp39 ;
  __m128 __cil_tmp40 ;
  __m128 __cil_tmp41 ;
  float y ;
  float u ;
  float v ;
  float r ;
  float g ;
  float b ;

  {
  {
#line 136
  vrv = _mm_set_ss(1.40199995041f);
#line 137
  vgu = _mm_set_ss(0.344130009413f);
#line 138
  vgv = _mm_set_ss(0.71413999796f);
#line 139
  vbu = _mm_set_ss(1.77199995518f);
#line 140
  i = 0;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < n >> 3)) {
#line 140
      goto while_break;
    }
    {
#line 144
    vy = _mm_load_ps((float const   *)c0);
#line 145
    vu = _mm_load_ps((float const   *)c1);
#line 146
    vv = _mm_load_ps((float const   *)c2);
#line 147
    __cil_tmp23 = _mm_mul_ps(vv, vrv);
#line 147
    __cil_tmp24 = _mm_add_ps(vy, __cil_tmp23);
#line 147
    vr = __cil_tmp24;
#line 148
    __cil_tmp25 = _mm_mul_ps(vu, vgu);
#line 148
    __cil_tmp26 = _mm_sub_ps(vy, __cil_tmp25);
    }
    {
#line 148
    __cil_tmp27 = _mm_mul_ps(vv, vgv);
#line 148
    __cil_tmp28 = _mm_sub_ps(__cil_tmp26, __cil_tmp27);
#line 148
    vg = __cil_tmp28;
#line 149
    __cil_tmp29 = _mm_mul_ps(vu, vbu);
#line 149
    __cil_tmp30 = _mm_add_ps(vy, __cil_tmp29);
#line 149
    vb = __cil_tmp30;
#line 150
    _mm_store_ps(c0, vr);
#line 151
    _mm_store_ps(c1, vg);
#line 152
    _mm_store_ps(c2, vb);
#line 153
    c0 += 4;
#line 154
    c1 += 4;
#line 155
    c2 += 4;
#line 157
    vy = _mm_load_ps((float const   *)c0);
#line 158
    vu = _mm_load_ps((float const   *)c1);
#line 159
    vv = _mm_load_ps((float const   *)c2);
#line 160
    __cil_tmp34 = _mm_mul_ps(vv, vrv);
#line 160
    __cil_tmp35 = _mm_add_ps(vy, __cil_tmp34);
#line 160
    vr = __cil_tmp35;
#line 161
    __cil_tmp36 = _mm_mul_ps(vu, vgu);
#line 161
    __cil_tmp37 = _mm_sub_ps(vy, __cil_tmp36);
    }
    {
#line 161
    __cil_tmp38 = _mm_mul_ps(vv, vgv);
#line 161
    __cil_tmp39 = _mm_sub_ps(__cil_tmp37, __cil_tmp38);
#line 161
    vg = __cil_tmp39;
#line 162
    __cil_tmp40 = _mm_mul_ps(vu, vbu);
#line 162
    __cil_tmp41 = _mm_add_ps(vy, __cil_tmp40);
#line 162
    vb = __cil_tmp41;
#line 163
    _mm_store_ps(c0, vr);
#line 164
    _mm_store_ps(c1, vg);
#line 165
    _mm_store_ps(c2, vb);
#line 166
    c0 += 4;
#line 167
    c1 += 4;
#line 168
    c2 += 4;
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  n &= 7;
#line 172
  i = 0;
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 172
    if (! (i < n)) {
#line 172
      goto while_break___0;
    }
#line 173
    y = *(c0 + i);
#line 174
    u = *(c1 + i);
#line 175
    v = *(c2 + i);
#line 176
    r = y + v * 1.40199995041f;
#line 177
    g = (y - u * 0.344130009413f) - v * 0.71413999796f;
#line 178
    b = y + u * 1.77199995518f;
#line 179
    *(c0 + i) = r;
#line 180
    *(c1 + i) = g;
#line 181
    *(c2 + i) = b;
#line 172
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 188 "/root/patchweave_new/14/libopenjpeg/mct.c"
double mct_getnorm_real(int compno ) 
{ 


  {
#line 189
  return (mct_norms_real[compno]);
}
}
#line 37 "/root/patchweave_new/14/libopenjpeg/jpt.c"
unsigned int jpt_read_VBAS_info(opj_cio_t *cio , unsigned int value ) 
{ 
  unsigned char elmt ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = cio_read(cio, 1);
#line 40
  elmt = (unsigned char )__cil_tmp4;
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((int )elmt >> 7 == 1)) {
#line 41
      goto while_break;
    }
    {
#line 42
    value <<= 7;
#line 43
    value |= (unsigned int )((int )elmt & 127);
#line 44
    __cil_tmp5 = cio_read(cio, 1);
#line 44
    elmt = (unsigned char )__cil_tmp5;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  value <<= 7;
#line 47
  value |= (unsigned int )((int )elmt & 127);
#line 49
  return (value);
}
}
#line 56 "/root/patchweave_new/14/libopenjpeg/jpt.c"
void jpt_init_msg_header(opj_jpt_msg_header_t *header ) 
{ 


  {
#line 57
  header->Id = (unsigned int )0;
#line 58
  header->last_byte = (unsigned int )0;
#line 59
  header->Class_Id = (unsigned int )0;
#line 60
  header->CSn_Id = (unsigned int )0;
#line 61
  header->Msg_offset = (unsigned int )0;
#line 62
  header->Msg_length = (unsigned int )0;
#line 63
  header->Layer_nb = (unsigned int )0;
  return;
}
}
#line 72 "/root/patchweave_new/14/libopenjpeg/jpt.c"
void jpt_reinit_msg_header(opj_jpt_msg_header_t *header ) 
{ 


  {
#line 73
  header->Id = (unsigned int )0;
#line 74
  header->last_byte = (unsigned int )0;
#line 75
  header->Msg_offset = (unsigned int )0;
#line 76
  header->Msg_length = (unsigned int )0;
  return;
}
}
#line 83 "/root/patchweave_new/14/libopenjpeg/jpt.c"
void jpt_read_msg_header(opj_common_ptr cinfo , opj_cio_t *cio , opj_jpt_msg_header_t *header ) 
{ 
  unsigned char elmt ;
  unsigned char Class ;
  unsigned char CSn ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 84
  Class = (unsigned char )0;
  {
#line 84
  CSn = (unsigned char )0;
#line 85
  jpt_reinit_msg_header(header);
#line 90
  __cil_tmp7 = cio_read(cio, 1);
#line 90
  elmt = (unsigned char )__cil_tmp7;
  }
  {
#line 94
  if ((((int )elmt >> 5) & 3) == 0) {
#line 94
    goto case_0;
  }
#line 97
  if ((((int )elmt >> 5) & 3) == 1) {
#line 97
    goto case_1;
  }
#line 101
  if ((((int )elmt >> 5) & 3) == 2) {
#line 101
    goto case_2;
  }
#line 105
  if ((((int )elmt >> 5) & 3) == 3) {
#line 105
    goto case_3;
  }
#line 109
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 95
  opj_event_msg(cinfo, 1, "Forbidden value encounter in message header !!\n");
  }
#line 96
  goto switch_break;
  case_1: /* CIL Label */ 
#line 98
  Class = (unsigned char )0;
#line 99
  CSn = (unsigned char )0;
#line 100
  goto switch_break;
  case_2: /* CIL Label */ 
#line 102
  Class = (unsigned char )1;
#line 103
  CSn = (unsigned char )0;
#line 104
  goto switch_break;
  case_3: /* CIL Label */ 
#line 106
  Class = (unsigned char )1;
#line 107
  CSn = (unsigned char )1;
#line 108
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 110
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 114
  if ((((int )elmt >> 4) & 1) == 1) {
#line 115
    header->last_byte = (unsigned int )1;
  }
#line 118
  header->Id |= (unsigned int )((int )elmt & 15);
#line 119
  if ((int )elmt >> 7 == 1) {
    {
#line 120
    header->Id = jpt_read_VBAS_info(cio, header->Id);
    }
  }
#line 125
  if ((int )Class == 1) {
    {
#line 126
    header->Class_Id = (unsigned int )0;
#line 127
    header->Class_Id = jpt_read_VBAS_info(cio, header->Class_Id);
    }
  }
#line 133
  if ((int )CSn == 1) {
    {
#line 134
    header->CSn_Id = (unsigned int )0;
#line 135
    header->CSn_Id = jpt_read_VBAS_info(cio, header->CSn_Id);
    }
  }
  {
#line 141
  header->Msg_offset = jpt_read_VBAS_info(cio, header->Msg_offset);
#line 146
  header->Msg_length = jpt_read_VBAS_info(cio, header->Msg_length);
  }
#line 151
  if ((header->Class_Id & 1U) == 1U) {
    {
#line 152
    header->Layer_nb = (unsigned int )0;
#line 153
    header->Layer_nb = jpt_read_VBAS_info(cio, header->Layer_nb);
    }
  }
  return;
}
}
#line 48 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) ;
#line 56
static opj_bool jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 57
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 58
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 59
static opj_bool jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 60
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 66
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 73
static opj_bool jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 74
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 75
static opj_bool jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                              unsigned int *j2k_codestream_offset ) ;
#line 76
static void jp2_write_jp(opj_cio_t *cio ) ;
#line 83
static opj_bool jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 91
static opj_bool jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) ;
#line 98
static void jp2_apply_pclr(opj_jp2_color_t *color , opj_image_t *image , opj_common_ptr cinfo ) ;
#line 107
static opj_bool jp2_read_pclr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 117
static opj_bool jp2_read_cmap(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 127
static opj_bool jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 138
static int write_fidx(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                      opj_cio_t *cio ) ;
#line 145
static void write_iptr(int offset , int length , opj_cio_t *cio ) ;
#line 154
static void write_prxy(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                       opj_cio_t *cio ) ;
#line 161 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) 
{ 
  int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 162
  box->init_pos = cio_tell(cio);
#line 163
  __cil_tmp5 = cio_read(cio, 4);
#line 163
  box->length = (int )__cil_tmp5;
#line 164
  __cil_tmp6 = cio_read(cio, 4);
#line 164
  box->type = (int )__cil_tmp6;
  }
#line 165
  if (box->length == 1) {
    {
#line 166
    __cil_tmp7 = cio_read(cio, 4);
    }
#line 166
    if (__cil_tmp7 != 0U) {
      {
#line 167
      opj_event_msg(cinfo, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 168
      return (0);
    }
    {
#line 170
    __cil_tmp8 = cio_read(cio, 4);
#line 170
    box->length = (int )__cil_tmp8;
    }
#line 171
    if (box->length == 0) {
      {
#line 172
      __cil_tmp9 = cio_numbytesleft(cio);
#line 172
      box->length = __cil_tmp9 + 12;
      }
    }
  } else
#line 174
  if (box->length == 0) {
    {
#line 175
    __cil_tmp10 = cio_numbytesleft(cio);
#line 175
    box->length = __cil_tmp10 + 8;
    }
  } else
#line 176
  if (box->length < 0) {
    {
#line 177
    opj_event_msg(cinfo, 1, "Integer overflow in box->length\n\220");
    }
#line 178
    return (0);
  }
#line 181
  return (1);
}
}
#line 208 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 211
  cinfo = jp2->cinfo;
#line 213
  __cil_tmp5 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 213
  if (__cil_tmp5 == 0) {
    {
#line 214
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 215
    return (0);
  }
#line 217
  if (1768449138 != box.type) {
    {
#line 218
    opj_event_msg(cinfo, 1, "Expected IHDR Marker\n");
    }
#line 219
    return (0);
  }
  {
#line 222
  jp2->h = cio_read(cio, 4);
#line 223
  jp2->w = cio_read(cio, 4);
#line 224
  jp2->numcomps = cio_read(cio, 2);
#line 225
  __cil_tmp9 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 225
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp9;
#line 227
  jp2->bpc = cio_read(cio, 1);
#line 229
  jp2->C = cio_read(cio, 1);
#line 230
  jp2->UnkC = cio_read(cio, 1);
#line 231
  jp2->IPR = cio_read(cio, 1);
#line 233
  __cil_tmp14 = cio_tell(cio);
  }
#line 233
  if (__cil_tmp14 - box.init_pos != box.length) {
    {
#line 234
    opj_event_msg(cinfo, 1, "Error with IHDR Box\n");
    }
#line 235
    return (0);
  }
#line 238
  return (1);
}
}
#line 241 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 244
  box.init_pos = cio_tell(cio);
#line 245
  cio_skip(cio, 4);
#line 246
  cio_write(cio, (unsigned long long )1768449138, 4);
#line 248
  cio_write(cio, (unsigned long long )jp2->h, 4);
#line 249
  cio_write(cio, (unsigned long long )jp2->w, 4);
#line 250
  cio_write(cio, (unsigned long long )jp2->numcomps, 2);
#line 252
  cio_write(cio, (unsigned long long )jp2->bpc, 1);
#line 254
  cio_write(cio, (unsigned long long )jp2->C, 1);
#line 255
  cio_write(cio, (unsigned long long )jp2->UnkC, 1);
#line 256
  cio_write(cio, (unsigned long long )jp2->IPR, 1);
#line 258
  __cil_tmp5 = cio_tell(cio);
#line 258
  box.length = __cil_tmp5 - box.init_pos;
#line 259
  cio_seek(cio, box.init_pos);
#line 260
  cio_write(cio, (unsigned long long )box.length, 4);
#line 261
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 264 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 268
  box.init_pos = cio_tell(cio);
#line 269
  cio_skip(cio, 4);
#line 270
  cio_write(cio, (unsigned long long )1651532643, 4);
#line 272
  i = (unsigned int )0;
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < jp2->numcomps)) {
#line 272
      goto while_break;
    }
    {
#line 273
    cio_write(cio, (unsigned long long )(jp2->comps + i)->bpcc, 1);
    }
#line 272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  __cil_tmp7 = cio_tell(cio);
#line 276
  box.length = __cil_tmp7 - box.init_pos;
#line 277
  cio_seek(cio, box.init_pos);
#line 278
  cio_write(cio, (unsigned long long )box.length, 4);
#line 279
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 283 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 287
  cinfo = jp2->cinfo;
#line 289
  __cil_tmp6 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 289
  if (__cil_tmp6 == 0) {
    {
#line 290
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 291
    return (0);
  }
#line 293
  if (1651532643 != box.type) {
    {
#line 294
    opj_event_msg(cinfo, 1, "Expected BPCC Marker\n");
    }
#line 295
    return (0);
  }
#line 298
  i = (unsigned int )0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i < jp2->numcomps)) {
#line 298
      goto while_break;
    }
    {
#line 299
    __cil_tmp7 = cio_read(cio, 1);
#line 299
    (jp2->comps + i)->bpcc = (int )__cil_tmp7;
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 302
  __cil_tmp9 = cio_tell(cio);
  }
#line 302
  if (__cil_tmp9 - box.init_pos != box.length) {
    {
#line 303
    opj_event_msg(cinfo, 1, "Error with BPCC Box\n");
    }
#line 304
    return (0);
  }
#line 307
  return (1);
}
}
#line 310 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 313
  box.init_pos = cio_tell(cio);
#line 314
  cio_skip(cio, 4);
#line 315
  cio_write(cio, (unsigned long long )1668246642, 4);
#line 317
  cio_write(cio, (unsigned long long )jp2->meth, 1);
#line 318
  cio_write(cio, (unsigned long long )jp2->precedence, 1);
#line 319
  cio_write(cio, (unsigned long long )jp2->approx, 1);
  }
#line 321
  if (jp2->meth == 2U) {
#line 322
    jp2->enumcs = (unsigned int )0;
  }
  {
#line 324
  cio_write(cio, (unsigned long long )jp2->enumcs, 4);
#line 326
  __cil_tmp5 = cio_tell(cio);
#line 326
  box.length = __cil_tmp5 - box.init_pos;
#line 327
  cio_seek(cio, box.init_pos);
#line 328
  cio_write(cio, (unsigned long long )box.length, 4);
#line 329
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 332 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static void jp2_free_pclr(opj_jp2_color_t *color ) 
{ 


  {
  {
#line 334
  free((color->jp2_pclr)->channel_sign);
#line 335
  free((color->jp2_pclr)->channel_size);
#line 336
  free((color->jp2_pclr)->entries);
  }
#line 338
  if ((color->jp2_pclr)->cmap) {
    {
#line 338
    free((color->jp2_pclr)->cmap);
    }
  }
  {
#line 340
  free(color->jp2_pclr);
#line 340
  color->jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
  }
  return;
}
}
#line 343 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static void free_color_data(opj_jp2_color_t *color ) 
{ 


  {
#line 345
  if (color->jp2_pclr) {
    {
#line 347
    jp2_free_pclr(color);
    }
  }
#line 349
  if (color->jp2_cdef) {
#line 351
    if ((color->jp2_cdef)->info) {
      {
#line 351
      free((color->jp2_cdef)->info);
      }
    }
    {
#line 352
    free(color->jp2_cdef);
    }
  }
#line 354
  if (color->icc_profile_buf) {
    {
#line 354
    free(color->icc_profile_buf);
    }
  }
  return;
}
}
#line 357 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static void jp2_apply_pclr(opj_jp2_color_t *color , opj_image_t *image , opj_common_ptr cinfo ) 
{ 
  opj_image_comp_t *old_comps ;
  opj_image_comp_t *new_comps ;
  unsigned char *channel_size ;
  unsigned char *channel_sign ;
  unsigned int *entries ;
  opj_jp2_cmap_comp_t *cmap ;
  int *src ;
  int *dst ;
  unsigned int j ;
  unsigned int max ;
  unsigned short i ;
  unsigned short nr_channels ;
  unsigned short cmp ;
  unsigned short pcol ;
  int k ;
  int top_k ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
  {
#line 368
  channel_size = (color->jp2_pclr)->channel_size;
#line 369
  channel_sign = (color->jp2_pclr)->channel_sign;
#line 370
  entries = (color->jp2_pclr)->entries;
#line 371
  cmap = (color->jp2_pclr)->cmap;
#line 372
  nr_channels = (color->jp2_pclr)->nr_channels;
#line 374
  old_comps = image->comps;
#line 375
  __cil_tmp20 = malloc((unsigned long )nr_channels * sizeof(opj_image_comp_t ));
#line 375
  new_comps = (opj_image_comp_t *)__cil_tmp20;
#line 378
  i = (unsigned short )0;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((int )i < (int )nr_channels)) {
#line 378
      goto while_break;
    }
#line 380
    pcol = (unsigned short )(cmap + i)->pcol;
#line 380
    cmp = (cmap + i)->cmp;
#line 382
    if ((int )pcol < (int )nr_channels) {
#line 383
      *(new_comps + pcol) = *(old_comps + cmp);
    } else {
      {
#line 386
      opj_event_msg(cinfo, 1, "Error with pcol value %d (max: %d). skipping\n", (int )pcol,
                    (int )nr_channels);
      }
#line 387
      goto while_continue;
    }
#line 390
    if ((int )(cmap + i)->mtyp == 0) {
#line 392
      (old_comps + cmp)->data = (int *)((void *)0);
#line 392
      goto while_continue;
    }
    {
#line 395
    __cil_tmp21 = malloc((unsigned long )((old_comps + cmp)->w * (old_comps + cmp)->h) * sizeof(int ));
#line 395
    (new_comps + pcol)->data = (int *)__cil_tmp21;
#line 397
    (new_comps + pcol)->prec = (int )*(channel_size + i);
#line 398
    (new_comps + pcol)->sgnd = (int )*(channel_sign + i);
    }
#line 378
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  top_k = (int )(color->jp2_pclr)->nr_entries - 1;
#line 402
  i = (unsigned short )0;
  {
#line 402
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 402
    if (! ((int )i < (int )nr_channels)) {
#line 402
      goto while_break___0;
    }
#line 405
    if ((int )(cmap + i)->mtyp == 0) {
#line 405
      goto while_continue___0;
    }
#line 408
    cmp = (cmap + i)->cmp;
#line 408
    pcol = (unsigned short )(cmap + i)->pcol;
#line 409
    src = (old_comps + cmp)->data;
#line 410
    dst = (new_comps + pcol)->data;
#line 411
    max = (unsigned int )((new_comps + pcol)->w * (new_comps + pcol)->h);
#line 413
    j = (unsigned int )0;
    {
#line 413
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 413
      if (! (j < max)) {
#line 413
        goto while_break___1;
      }
#line 416
      k = *(src + j);
#line 416
      if (k < 0) {
#line 416
        k = 0;
      } else
#line 416
      if (k > top_k) {
#line 416
        k = top_k;
      }
#line 418
      *(dst + j) = (int )*(entries + (k * (int )nr_channels + (int )pcol));
#line 413
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 402
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 421
  max = (unsigned int )image->numcomps;
#line 422
  i = (unsigned short )0;
  {
#line 422
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 422
    if (! ((unsigned int )i < max)) {
#line 422
      goto while_break___2;
    }
#line 424
    if ((old_comps + i)->data) {
      {
#line 424
      free((old_comps + i)->data);
      }
    }
#line 422
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 426
  free(old_comps);
#line 427
  image->comps = new_comps;
#line 428
  image->numcomps = (int )nr_channels;
#line 430
  jp2_free_pclr(color);
  }
  return;
}
}
#line 434 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_pclr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_pclr_t *jp2_pclr ;
  unsigned char *channel_size ;
  unsigned char *channel_sign ;
  unsigned int *entries ;
  unsigned short nr_entries ;
  unsigned short nr_channels ;
  unsigned short i ;
  unsigned short j ;
  unsigned char uc ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  int tmp ;
  unsigned int *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;

  {
#line 450
  if (color->jp2_pclr) {
#line 450
    return (0);
  }
  {
#line 452
  __cil_tmp14 = cio_read(cio, 2);
#line 452
  nr_entries = (unsigned short )__cil_tmp14;
#line 453
  __cil_tmp15 = cio_read(cio, 1);
#line 453
  nr_channels = (unsigned short )__cil_tmp15;
#line 455
  __cil_tmp16 = malloc((unsigned long )((int )nr_channels * (int )nr_entries) * sizeof(unsigned int ));
#line 455
  entries = (unsigned int *)__cil_tmp16;
#line 457
  __cil_tmp17 = malloc((unsigned long )nr_channels);
#line 457
  channel_size = (unsigned char *)__cil_tmp17;
#line 458
  __cil_tmp18 = malloc((unsigned long )nr_channels);
#line 458
  channel_sign = (unsigned char *)__cil_tmp18;
#line 460
  __cil_tmp19 = malloc(sizeof(opj_jp2_pclr_t ));
#line 460
  jp2_pclr = (opj_jp2_pclr_t *)__cil_tmp19;
#line 461
  jp2_pclr->channel_sign = channel_sign;
#line 462
  jp2_pclr->channel_size = channel_size;
#line 463
  jp2_pclr->entries = entries;
#line 464
  jp2_pclr->nr_entries = nr_entries;
#line 465
  jp2_pclr->nr_channels = nr_channels;
#line 466
  jp2_pclr->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
#line 468
  color->jp2_pclr = jp2_pclr;
#line 470
  i = (unsigned short )0;
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! ((int )i < (int )nr_channels)) {
#line 470
      goto while_break;
    }
    {
#line 472
    __cil_tmp20 = cio_read(cio, 1);
#line 472
    uc = (unsigned char )__cil_tmp20;
#line 473
    *(channel_size + i) = (unsigned char )(((int )uc & 127) + 1);
    }
#line 474
    if ((int )uc & 128) {
#line 474
      tmp = 1;
    } else {
#line 474
      tmp = 0;
    }
#line 474
    *(channel_sign + i) = (unsigned char )tmp;
#line 470
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  j = (unsigned short )0;
  {
#line 477
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 477
    if (! ((int )j < (int )nr_entries)) {
#line 477
      goto while_break___0;
    }
#line 479
    i = (unsigned short )0;
    {
#line 479
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 479
      if (! ((int )i < (int )nr_channels)) {
#line 479
        goto while_break___1;
      }
      {
#line 482
      __cil_tmp22 = entries;
#line 482
      entries ++;
#line 482
      *__cil_tmp22 = cio_read(cio, ((int )*(channel_size + i) + 7) >> 3);
      }
#line 479
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 477
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 486
  return (1);
}
}
#line 489 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_cmap(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_cmap_comp_t *cmap ;
  unsigned short i ;
  unsigned short nr_channels ;
  void *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;

  {
#line 499
  if (color->jp2_pclr == (void *)0) {
#line 499
    return (0);
  }
#line 504
  if ((color->jp2_pclr)->cmap) {
#line 504
    return (0);
  }
  {
#line 506
  nr_channels = (color->jp2_pclr)->nr_channels;
#line 507
  __cil_tmp8 = malloc((unsigned long )nr_channels * sizeof(opj_jp2_cmap_comp_t ));
#line 507
  cmap = (opj_jp2_cmap_comp_t *)__cil_tmp8;
#line 510
  i = (unsigned short )0;
  }
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! ((int )i < (int )nr_channels)) {
#line 510
      goto while_break;
    }
    {
#line 512
    __cil_tmp9 = cio_read(cio, 2);
#line 512
    (cmap + i)->cmp = (unsigned short )__cil_tmp9;
#line 513
    __cil_tmp10 = cio_read(cio, 1);
#line 513
    (cmap + i)->mtyp = (unsigned char )__cil_tmp10;
#line 514
    __cil_tmp11 = cio_read(cio, 1);
#line 514
    (cmap + i)->pcol = (unsigned char )__cil_tmp11;
    }
#line 510
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  (color->jp2_pclr)->cmap = cmap;
#line 519
  return (1);
}
}
#line 522 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static void jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  unsigned short i ;
  unsigned short n ;
  unsigned short cn ;
  unsigned short typ ;
  unsigned short asoc ;
  unsigned short acn ;
  opj_image_comp_t saved ;

  {
#line 527
  info = (color->jp2_cdef)->info;
#line 528
  n = (color->jp2_cdef)->n;
#line 530
  i = (unsigned short )0;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! ((int )i < (int )n)) {
#line 530
      goto while_break;
    }
#line 533
    asoc = (info + i)->asoc;
#line 533
    if ((int )asoc == 0) {
#line 533
      goto while_continue;
    }
#line 535
    cn = (info + i)->cn;
#line 535
    typ = (info + i)->typ;
#line 535
    acn = (unsigned short )((int )asoc - 1);
#line 538
    if ((int )cn != (int )acn) {
      {
#line 542
      memcpy(& saved, image->comps + cn, sizeof(opj_image_comp_t ));
#line 543
      memcpy(image->comps + cn, image->comps + acn, sizeof(opj_image_comp_t ));
#line 544
      memcpy(image->comps + acn, & saved, sizeof(opj_image_comp_t ));
#line 546
      (info + i)->asoc = (unsigned short )((int )cn + 1);
#line 547
      (info + acn)->asoc = (unsigned short )((int )(info + acn)->cn + 1);
      }
    }
#line 530
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 550
  if ((color->jp2_cdef)->info) {
    {
#line 550
    free((color->jp2_cdef)->info);
    }
  }
  {
#line 552
  free(color->jp2_cdef);
#line 552
  color->jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
  }
  return;
}
}
#line 556 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_cdef(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  unsigned short i ;
  unsigned short n ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 568
  if (color->jp2_cdef) {
#line 568
    return (0);
  }
  {
#line 570
  __cil_tmp8 = cio_read(cio, 2);
#line 570
  n = (unsigned short )__cil_tmp8;
  }
#line 570
  if ((int )n == 0) {
#line 570
    return (0);
  }
  {
#line 572
  __cil_tmp9 = malloc((unsigned long )n * sizeof(opj_jp2_cdef_info_t ));
#line 572
  info = (opj_jp2_cdef_info_t *)__cil_tmp9;
#line 575
  __cil_tmp10 = malloc(sizeof(opj_jp2_cdef_t ));
#line 575
  color->jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp10;
#line 576
  (color->jp2_cdef)->info = info;
#line 577
  (color->jp2_cdef)->n = n;
#line 579
  i = (unsigned short )0;
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 579
    if (! ((int )i < (int )n)) {
#line 579
      goto while_break;
    }
    {
#line 581
    __cil_tmp11 = cio_read(cio, 2);
#line 581
    (info + i)->cn = (unsigned short )__cil_tmp11;
#line 582
    __cil_tmp12 = cio_read(cio, 2);
#line 582
    (info + i)->typ = (unsigned short )__cil_tmp12;
#line 583
    __cil_tmp13 = cio_read(cio, 2);
#line 583
    (info + i)->asoc = (unsigned short )__cil_tmp13;
    }
#line 579
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 586
  return (1);
}
}
#line 589 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  int skip_len ;
  opj_common_ptr cinfo ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned char *start ;
  unsigned char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 598
  if (color->jp2_has_colr) {
#line 598
    return (0);
  }
  {
#line 600
  cinfo = jp2->cinfo;
#line 602
  jp2->meth = cio_read(cio, 1);
#line 603
  jp2->precedence = cio_read(cio, 1);
#line 604
  jp2->approx = cio_read(cio, 1);
  }
#line 606
  if (jp2->meth == 1U) {
    {
#line 608
    jp2->enumcs = cio_read(cio, 4);
    }
  } else
#line 611
  if (jp2->meth == 2U) {
    {
#line 614
    __cil_tmp11 = cio_tell(cio);
#line 614
    skip_len = (box->init_pos + box->length) - __cil_tmp11;
    }
#line 615
    if (skip_len < 0) {
      {
#line 617
      opj_event_msg(cinfo, 1, "Error with COLR box size\n");
      }
#line 618
      return (0);
    }
#line 620
    if (skip_len > 0) {
      {
#line 624
      start = cio_getbp(cio);
#line 625
      __cil_tmp14 = malloc((unsigned long )skip_len);
#line 625
      color->icc_profile_buf = (unsigned char *)__cil_tmp14;
#line 626
      color->icc_profile_len = skip_len;
#line 628
      __cil_tmp15 = cio_tell(cio);
#line 628
      cio_skip(cio, (box->init_pos + box->length) - __cil_tmp15);
#line 630
      memcpy(color->icc_profile_buf, start, (unsigned long )skip_len);
      }
    }
  }
  {
#line 634
  __cil_tmp16 = cio_tell(cio);
  }
#line 634
  if (__cil_tmp16 - box->init_pos != box->length) {
    {
#line 636
    opj_event_msg(cinfo, 1, "Error with COLR Box\n");
    }
#line 637
    return (0);
  }
#line 639
  color->jp2_has_colr = (unsigned char )1;
#line 641
  return (1);
}
}
#line 644 "/root/patchweave_new/14/libopenjpeg/jp2.c"
opj_bool jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) 
{ 
  opj_jp2_box_t box ;
  int jp2h_end ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp7 ;
  opj_bool __cil_tmp8 ;
  opj_bool __cil_tmp9 ;
  opj_bool __cil_tmp10 ;
  opj_bool __cil_tmp11 ;
  int __cil_tmp12 ;
  opj_bool __cil_tmp13 ;
  opj_bool __cil_tmp14 ;
  opj_bool __cil_tmp15 ;
  opj_bool __cil_tmp16 ;
  opj_bool __cil_tmp17 ;
  opj_bool __cil_tmp18 ;
  opj_bool __cil_tmp19 ;
  opj_bool __cil_tmp20 ;
  opj_bool __cil_tmp21 ;

  {
  {
#line 649
  cinfo = jp2->cinfo;
#line 651
  __cil_tmp7 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 651
  if (__cil_tmp7 == 0) {
#line 651
    return (0);
  }
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if (1785737832 != box.type) {
#line 655
      if (box.type == 1785737827) {
        {
#line 657
        opj_event_msg(cinfo, 1, "Expected JP2H Marker\n");
        }
#line 658
        return (0);
      }
#line 660
      if (box.length <= 8) {
#line 660
        return (0);
      }
      {
#line 661
      cio_skip(cio, box.length - 8);
      }
#line 663
      if (cio->bp >= cio->end) {
#line 663
        return (0);
      }
      {
#line 665
      __cil_tmp8 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 665
      if (__cil_tmp8 == 0) {
#line 665
        return (0);
      }
    }
#line 652
    if (! (1785737832 != box.type)) {
#line 652
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 669
  __cil_tmp9 = jp2_read_ihdr(jp2, cio);
  }
#line 669
  if (! __cil_tmp9) {
#line 670
    return (0);
  }
#line 671
  jp2h_end = box.init_pos + box.length;
#line 673
  if (jp2->bpc == 255U) {
    {
#line 675
    __cil_tmp10 = jp2_read_bpcc(jp2, cio);
    }
#line 675
    if (! __cil_tmp10) {
#line 676
      return (0);
    }
  }
  {
#line 678
  __cil_tmp11 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 678
  if (__cil_tmp11 == 0) {
#line 678
    return (0);
  }
  {
#line 680
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 680
    __cil_tmp12 = cio_tell(cio);
    }
#line 680
    if (! (__cil_tmp12 < jp2h_end)) {
#line 680
      goto while_break___0;
    }
#line 682
    if (box.type == 1668246642) {
      {
#line 684
      __cil_tmp13 = jp2_read_colr(jp2, cio, & box, color);
      }
#line 684
      if (! __cil_tmp13) {
#line 686
        if (box.length <= 8) {
#line 686
          return (0);
        }
        {
#line 687
        cio_seek(cio, box.init_pos + 8);
#line 688
        cio_skip(cio, box.length - 8);
        }
      }
      {
#line 690
      __cil_tmp14 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 690
      if (__cil_tmp14 == 0) {
#line 690
        return (0);
      }
#line 691
      goto while_continue___0;
    }
#line 693
    if (box.type == 1667523942) {
#line 693
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 695
        __cil_tmp15 = jp2_read_cdef(jp2, cio, & box, color);
        }
#line 695
        if (! __cil_tmp15) {
#line 697
          if (box.length <= 8) {
#line 697
            return (0);
          }
          {
#line 698
          cio_seek(cio, box.init_pos + 8);
#line 699
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 701
        __cil_tmp16 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 701
        if (__cil_tmp16 == 0) {
#line 701
          return (0);
        }
#line 702
        goto while_continue___0;
      }
    }
#line 704
    if (box.type == 1885564018) {
#line 704
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 706
        __cil_tmp17 = jp2_read_pclr(jp2, cio, & box, color);
        }
#line 706
        if (! __cil_tmp17) {
#line 708
          if (box.length <= 8) {
#line 708
            return (0);
          }
          {
#line 709
          cio_seek(cio, box.init_pos + 8);
#line 710
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 712
        __cil_tmp18 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 712
        if (__cil_tmp18 == 0) {
#line 712
          return (0);
        }
#line 713
        goto while_continue___0;
      }
    }
#line 715
    if (box.type == 1668112752) {
#line 715
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 717
        __cil_tmp19 = jp2_read_cmap(jp2, cio, & box, color);
        }
#line 717
        if (! __cil_tmp19) {
#line 719
          if (box.length <= 8) {
#line 719
            return (0);
          }
          {
#line 720
          cio_seek(cio, box.init_pos + 8);
#line 721
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 723
        __cil_tmp20 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 723
        if (__cil_tmp20 == 0) {
#line 723
          return (0);
        }
#line 724
        goto while_continue___0;
      }
    }
#line 726
    if (box.length <= 8) {
#line 726
      return (0);
    }
    {
#line 727
    cio_seek(cio, box.init_pos + 8);
#line 728
    cio_skip(cio, box.length - 8);
#line 729
    __cil_tmp21 = jp2_read_boxhdr(cinfo, cio, & box);
    }
#line 729
    if (__cil_tmp21 == 0) {
#line 729
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 733
  cio_seek(cio, jp2h_end);
  }
#line 736
  return ((int )color->jp2_has_colr == 1);
}
}
#line 740 "/root/patchweave_new/14/libopenjpeg/jp2.c"
opj_image_t *opj_jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_common_ptr cinfo ;
  opj_image_t *image ;
  opj_jp2_color_t color ;
  opj_bool __cil_tmp7 ;
  opj_image_t *__cil_tmp8 ;

  {
#line 744
  image = (opj_image_t *)((void *)0);
#line 747
  if (! jp2) {
#line 749
    return ((opj_image_t *)((void *)0));
  } else
#line 747
  if (! cio) {
#line 749
    return ((opj_image_t *)((void *)0));
  }
  {
#line 751
  memset(& color, 0, sizeof(opj_jp2_color_t ));
#line 752
  cinfo = jp2->cinfo;
#line 755
  __cil_tmp7 = jp2_read_struct(jp2, cio, & color);
  }
#line 755
  if (! __cil_tmp7) {
    {
#line 757
    free_color_data(& color);
#line 758
    opj_event_msg(cinfo, 1, "Failed to decode jp2 structure\n");
    }
#line 759
    return ((opj_image_t *)((void *)0));
  }
  {
#line 763
  image = j2k_decode(jp2->j2k, cio, cstr_info);
  }
#line 765
  if (! image) {
    {
#line 767
    free_color_data(& color);
#line 768
    opj_event_msg(cinfo, 1, "Failed to decode J2K image\n");
    }
#line 769
    return ((opj_image_t *)((void *)0));
  }
#line 772
  if (! jp2->ignore_pclr_cmap_cdef) {
#line 775
    if (jp2->enumcs == 16U) {
#line 776
      image->color_space = (OPJ_COLOR_SPACE )1;
    } else
#line 777
    if (jp2->enumcs == 17U) {
#line 778
      image->color_space = (OPJ_COLOR_SPACE )2;
    } else
#line 779
    if (jp2->enumcs == 18U) {
#line 780
      image->color_space = (OPJ_COLOR_SPACE )3;
    } else {
#line 782
      image->color_space = (OPJ_COLOR_SPACE )-1;
    }
#line 784
    if (color.jp2_cdef) {
      {
#line 786
      jp2_apply_cdef(image, & color);
      }
    }
#line 788
    if (color.jp2_pclr) {
#line 791
      if (! (color.jp2_pclr)->cmap) {
        {
#line 792
        jp2_free_pclr(& color);
        }
      } else {
        {
#line 794
        jp2_apply_pclr(& color, image, cinfo);
        }
      }
    }
#line 796
    if (color.icc_profile_buf) {
#line 798
      image->icc_profile_buf = color.icc_profile_buf;
#line 799
      color.icc_profile_buf = (unsigned char *)((void *)0);
#line 800
      image->icc_profile_len = color.icc_profile_len;
    }
  }
#line 804
  return (image);
}
}
#line 809 "/root/patchweave_new/14/libopenjpeg/jp2.c"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 812
  box.init_pos = cio_tell(cio);
#line 813
  cio_skip(cio, 4);
#line 814
  cio_write(cio, (unsigned long long )1785737832, 4);
#line 816
  jp2_write_ihdr(jp2, cio);
  }
#line 818
  if (jp2->bpc == 255U) {
    {
#line 819
    jp2_write_bpcc(jp2, cio);
    }
  }
  {
#line 821
  jp2_write_colr(jp2, cio);
#line 823
  __cil_tmp5 = cio_tell(cio);
#line 823
  box.length = __cil_tmp5 - box.init_pos;
#line 824
  cio_seek(cio, box.init_pos);
#line 825
  cio_write(cio, (unsigned long long )box.length, 4);
#line 826
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 829 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 833
  box.init_pos = cio_tell(cio);
#line 834
  cio_skip(cio, 4);
#line 835
  cio_write(cio, (unsigned long long )1718909296, 4);
#line 837
  cio_write(cio, (unsigned long long )jp2->brand, 4);
#line 838
  cio_write(cio, (unsigned long long )jp2->minversion, 4);
#line 840
  i = (unsigned int )0;
  }
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < jp2->numcl)) {
#line 840
      goto while_break;
    }
    {
#line 841
    cio_write(cio, (unsigned long long )*(jp2->cl + i), 4);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 844
  __cil_tmp7 = cio_tell(cio);
#line 844
  box.length = __cil_tmp7 - box.init_pos;
#line 845
  cio_seek(cio, box.init_pos);
#line 846
  cio_write(cio, (unsigned long long )box.length, 4);
#line 847
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 850 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 854
  cinfo = jp2->cinfo;
#line 856
  __cil_tmp6 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 856
  if (__cil_tmp6 == 0) {
    {
#line 857
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 858
    return (0);
  }
#line 860
  if (1718909296 != box.type) {
    {
#line 861
    opj_event_msg(cinfo, 1, "Expected FTYP Marker\nU");
    }
#line 862
    return (0);
  }
  {
#line 865
  jp2->brand = cio_read(cio, 4);
#line 866
  jp2->minversion = cio_read(cio, 4);
#line 867
  jp2->numcl = (unsigned int )((box.length - 16) / 4);
#line 870
  __cil_tmp9 = cio_numbytesleft(cio);
  }
#line 870
  if (__cil_tmp9 < (int )jp2->numcl * 4) {
    {
#line 871
    __cil_tmp10 = cio_numbytesleft(cio);
#line 871
    opj_event_msg(cinfo, 1, "Not enough bytes in FTYP Box (expected %d, but only %d left)\n\025\316\335\342U",
                  (int )jp2->numcl * 4, __cil_tmp10);
    }
#line 874
    return (0);
  }
  {
#line 876
  __cil_tmp11 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 876
  jp2->cl = (unsigned int *)__cil_tmp11;
#line 878
  i = 0;
  }
  {
#line 878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 878
    if (! (i < (int )jp2->numcl)) {
#line 878
      goto while_break;
    }
    {
#line 879
    *(jp2->cl + i) = cio_read(cio, 4);
    }
#line 878
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 882
  __cil_tmp14 = cio_tell(cio);
  }
#line 882
  if (__cil_tmp14 - box.init_pos != box.length) {
    {
#line 883
    opj_event_msg(cinfo, 1, "Error with FTYP Box\n");
    }
#line 884
    return (0);
  }
#line 887
  return (1);
}
}
#line 890 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  unsigned int j2k_codestream_offset ;
  unsigned int j2k_codestream_length ;
  opj_jp2_box_t box ;
  opj_j2k_t *j2k ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  opj_bool __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 894
  j2k = jp2->j2k;
#line 896
  box.init_pos = cio_tell(cio);
#line 897
  cio_skip(cio, 4);
#line 898
  cio_write(cio, (unsigned long long )1785737827, 4);
#line 901
  __cil_tmp10 = cio_tell(cio);
#line 901
  j2k_codestream_offset = (unsigned int )__cil_tmp10;
#line 902
  __cil_tmp11 = j2k_encode(j2k, cio, image, cstr_info);
  }
#line 902
  if (! __cil_tmp11) {
    {
#line 903
    opj_event_msg(j2k->cinfo, 1, "Failed to encode image\n");
    }
#line 904
    return (0);
  }
  {
#line 906
  __cil_tmp12 = cio_tell(cio);
#line 906
  j2k_codestream_length = (unsigned int )__cil_tmp12 - j2k_codestream_offset;
#line 908
  jp2->j2k_codestream_offset = j2k_codestream_offset;
#line 909
  jp2->j2k_codestream_length = j2k_codestream_length;
#line 911
  box.length = (int )(8U + jp2->j2k_codestream_length);
#line 912
  cio_seek(cio, box.init_pos);
#line 913
  cio_write(cio, (unsigned long long )box.length, 4);
#line 914
  cio_seek(cio, box.init_pos + box.length);
  }
#line 916
  return (box.length);
}
}
#line 919 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                              unsigned int *j2k_codestream_offset ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp7 ;
  opj_bool __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 922
  cinfo = jp2->cinfo;
#line 924
  __cil_tmp7 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 924
  if (__cil_tmp7 == 0) {
    {
#line 925
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 926
    return (0);
  }
  {
#line 928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 929
    if (1785737827 != box.type) {
#line 930
      if (box.length <= 8) {
#line 930
        return (0);
      }
      {
#line 931
      cio_skip(cio, box.length - 8);
#line 932
      __cil_tmp8 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 932
      if (__cil_tmp8 == 0) {
#line 932
        return (0);
      }
    }
#line 928
    if (! (1785737827 != box.type)) {
#line 928
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 936
  __cil_tmp9 = cio_tell(cio);
#line 936
  *j2k_codestream_offset = (unsigned int )__cil_tmp9;
  }
#line 937
  if (box.length <= 8) {
#line 937
    return (0);
  }
#line 938
  *j2k_codestream_length = (unsigned int )(box.length - 8);
#line 940
  return (1);
}
}
#line 943 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static void jp2_write_jp(opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 946
  box.init_pos = cio_tell(cio);
#line 947
  cio_skip(cio, 4);
#line 948
  cio_write(cio, (unsigned long long )1783636000, 4);
#line 949
  cio_write(cio, (unsigned long long )218793738, 4);
#line 951
  __cil_tmp4 = cio_tell(cio);
#line 951
  box.length = __cil_tmp4 - box.init_pos;
#line 952
  cio_seek(cio, box.init_pos);
#line 953
  cio_write(cio, (unsigned long long )box.length, 4);
#line 954
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 957 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 960
  cinfo = jp2->cinfo;
#line 962
  __cil_tmp5 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 962
  if (__cil_tmp5 == 0) {
    {
#line 963
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 964
    return (0);
  }
#line 966
  if (1783636000 != box.type) {
    {
#line 967
    opj_event_msg(cinfo, 1, "Expected JP Marker\n\335\342U");
    }
#line 968
    return (0);
  }
  {
#line 970
  __cil_tmp6 = cio_read(cio, 4);
  }
#line 970
  if (218793738U != __cil_tmp6) {
    {
#line 971
    opj_event_msg(cinfo, 1, "Error with JP Marker\nU");
    }
#line 972
    return (0);
  }
  {
#line 974
  __cil_tmp7 = cio_tell(cio);
  }
#line 974
  if (__cil_tmp7 - box.init_pos != box.length) {
    {
#line 975
    opj_event_msg(cinfo, 1, "Error with JP Box size\n");
    }
#line 976
    return (0);
  }
#line 979
  return (1);
}
}
#line 983 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static opj_bool jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) 
{ 
  opj_bool __cil_tmp4 ;
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;
  opj_bool __cil_tmp7 ;

  {
  {
#line 985
  __cil_tmp4 = jp2_read_jp(jp2, cio);
  }
#line 985
  if (! __cil_tmp4) {
#line 986
    return (0);
  }
  {
#line 987
  __cil_tmp5 = jp2_read_ftyp(jp2, cio);
  }
#line 987
  if (! __cil_tmp5) {
#line 988
    return (0);
  }
  {
#line 989
  __cil_tmp6 = jp2_read_jp2h(jp2, cio, color);
  }
#line 989
  if (! __cil_tmp6) {
#line 990
    return (0);
  }
  {
#line 991
  __cil_tmp7 = jp2_read_jp2c(jp2, cio, & jp2->j2k_codestream_length, & jp2->j2k_codestream_offset);
  }
#line 991
  if (! __cil_tmp7) {
#line 992
    return (0);
  }
#line 994
  return (1);
}
}
#line 998 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static int write_fidx(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                      opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1002
  lenp = cio_tell(cio);
#line 1003
  cio_skip(cio, 4);
#line 1004
  cio_write(cio, (unsigned long long )1718183032, 4);
#line 1006
  write_prxy(offset_jp2c, length_jp2c, offset_idx, length_idx, cio);
#line 1008
  __cil_tmp9 = cio_tell(cio);
#line 1008
  len = __cil_tmp9 - lenp;
#line 1009
  cio_seek(cio, lenp);
#line 1010
  cio_write(cio, (unsigned long long )len, 4);
#line 1011
  cio_seek(cio, lenp + len);
  }
#line 1013
  return (len);
}
}
#line 1016 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static void write_prxy(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                       opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1020
  lenp = cio_tell(cio);
#line 1021
  cio_skip(cio, 4);
#line 1022
  cio_write(cio, (unsigned long long )1886550137, 4);
#line 1024
  cio_write(cio, (unsigned long long )offset_jp2c, 8);
#line 1025
  cio_write(cio, (unsigned long long )length_jp2c, 4);
#line 1026
  cio_write(cio, (unsigned long long )1785737827, 4);
#line 1028
  cio_write(cio, (unsigned long long )1, 1);
#line 1030
  cio_write(cio, (unsigned long long )offset_idx, 8);
#line 1031
  cio_write(cio, (unsigned long long )length_idx, 4);
#line 1032
  cio_write(cio, (unsigned long long )1667851384, 4);
#line 1034
  __cil_tmp9 = cio_tell(cio);
#line 1034
  len = __cil_tmp9 - lenp;
#line 1035
  cio_seek(cio, lenp);
#line 1036
  cio_write(cio, (unsigned long long )len, 4);
#line 1037
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 1040 "/root/patchweave_new/14/libopenjpeg/jp2.c"
static void write_iptr(int offset , int length , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1044
  lenp = cio_tell(cio);
#line 1045
  cio_skip(cio, 4);
#line 1046
  cio_write(cio, (unsigned long long )1768977522, 4);
#line 1048
  cio_write(cio, (unsigned long long )offset, 8);
#line 1049
  cio_write(cio, (unsigned long long )length, 8);
#line 1051
  __cil_tmp7 = cio_tell(cio);
#line 1051
  len = __cil_tmp7 - lenp;
#line 1052
  cio_seek(cio, lenp);
#line 1053
  cio_write(cio, (unsigned long long )len, 4);
#line 1054
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 1062 "/root/patchweave_new/14/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;

  {
  {
#line 1063
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_jp2_t ));
#line 1063
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 1064
  if (jp2) {
    {
#line 1065
    jp2->cinfo = cinfo;
#line 1067
    jp2->j2k = j2k_create_decompress(cinfo);
    }
#line 1068
    if (jp2->j2k == (void *)0) {
      {
#line 1069
      jp2_destroy_decompress(jp2);
      }
#line 1070
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 1073
  return (jp2);
}
}
#line 1076 "/root/patchweave_new/14/libopenjpeg/jp2.c"
void jp2_destroy_decompress(opj_jp2_t *jp2 ) 
{ 


  {
#line 1077
  if (jp2) {
    {
#line 1079
    j2k_destroy_decompress(jp2->j2k);
    }
#line 1081
    if (jp2->comps) {
      {
#line 1082
      free(jp2->comps);
      }
    }
#line 1084
    if (jp2->cl) {
      {
#line 1085
      free(jp2->cl);
      }
    }
    {
#line 1087
    free(jp2);
    }
  }
  return;
}
}
#line 1091 "/root/patchweave_new/14/libopenjpeg/jp2.c"
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) 
{ 


  {
  {
#line 1093
  j2k_setup_decoder(jp2->j2k, parameters);
#line 1095
  jp2->ignore_pclr_cmap_cdef = (opj_bool )(parameters->flags & 1U);
  }
  return;
}
}
#line 1102 "/root/patchweave_new/14/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;

  {
  {
#line 1103
  __cil_tmp3 = malloc(sizeof(opj_jp2_t ));
#line 1103
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 1104
  if (jp2) {
    {
#line 1105
    memset(jp2, 0, sizeof(opj_jp2_t ));
#line 1106
    jp2->cinfo = cinfo;
#line 1108
    jp2->j2k = j2k_create_compress(cinfo);
    }
#line 1109
    if (jp2->j2k == (void *)0) {
      {
#line 1110
      jp2_destroy_compress(jp2);
      }
#line 1111
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 1114
  return (jp2);
}
}
#line 1117 "/root/patchweave_new/14/libopenjpeg/jp2.c"
void jp2_destroy_compress(opj_jp2_t *jp2 ) 
{ 


  {
#line 1118
  if (jp2) {
    {
#line 1120
    j2k_destroy_compress(jp2->j2k);
    }
#line 1122
    if (jp2->comps) {
      {
#line 1123
      free(jp2->comps);
      }
    }
#line 1125
    if (jp2->cl) {
      {
#line 1126
      free(jp2->cl);
      }
    }
    {
#line 1128
    free(jp2);
    }
  }
  return;
}
}
#line 1132 "/root/patchweave_new/14/libopenjpeg/jp2.c"
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int depth_0 ;
  int sign ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  int depth ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1136
  if (! jp2) {
#line 1137
    return;
  } else
#line 1136
  if (! parameters) {
#line 1137
    return;
  } else
#line 1136
  if (! image) {
#line 1137
    return;
  }
#line 1143
  if (image->numcomps < 1) {
    {
    {
#line 1144
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
    }
#line 1145
    return;
  } else
#line 1143
  if (image->numcomps > 16384) {
    {
    {
#line 1144
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
    }
#line 1145
    return;
  }
  {
#line 1148
  j2k_setup_encoder(jp2->j2k, parameters, image);
#line 1155
  jp2->brand = (unsigned int )1785737760;
#line 1156
  jp2->minversion = (unsigned int )0;
#line 1157
  jp2->numcl = (unsigned int )1;
#line 1158
  __cil_tmp7 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 1158
  jp2->cl = (unsigned int *)__cil_tmp7;
#line 1159
  *(jp2->cl + 0) = (unsigned int )1785737760;
#line 1163
  jp2->numcomps = (unsigned int )image->numcomps;
#line 1164
  __cil_tmp8 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 1164
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8;
#line 1165
  jp2->h = (unsigned int )(image->y1 - image->y0);
#line 1166
  jp2->w = (unsigned int )(image->x1 - image->x0);
#line 1168
  depth_0 = (image->comps + 0)->prec - 1;
#line 1169
  sign = (image->comps + 0)->sgnd;
#line 1170
  jp2->bpc = (unsigned int )(depth_0 + (sign << 7));
#line 1171
  i = 1;
  }
  {
#line 1171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1171
    if (! (i < image->numcomps)) {
#line 1171
      goto while_break;
    }
#line 1172
    depth = (image->comps + i)->prec - 1;
#line 1173
    sign = (image->comps + i)->sgnd;
#line 1174
    if (depth_0 != depth) {
#line 1175
      jp2->bpc = (unsigned int )255;
    }
#line 1171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1177
  jp2->C = (unsigned int )7;
#line 1178
  jp2->UnkC = (unsigned int )0;
#line 1179
  jp2->IPR = (unsigned int )0;
#line 1183
  i = 0;
  {
#line 1183
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1183
    if (! (i < image->numcomps)) {
#line 1183
      goto while_break___0;
    }
#line 1184
    (jp2->comps + i)->bpcc = ((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7);
#line 1183
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1186
  jp2->meth = (unsigned int )1;
#line 1187
  if ((int )image->color_space == 1) {
#line 1188
    jp2->enumcs = (unsigned int )16;
  } else
#line 1189
  if ((int )image->color_space == 2) {
#line 1190
    jp2->enumcs = (unsigned int )17;
  } else
#line 1191
  if ((int )image->color_space == 3) {
#line 1192
    jp2->enumcs = (unsigned int )18;
  }
#line 1193
  jp2->precedence = (unsigned int )0;
#line 1194
  jp2->approx = (unsigned int )0;
#line 1196
  jp2->jpip_on = parameters->jpip_on;
  return;
}
}
#line 1199 "/root/patchweave_new/14/libopenjpeg/jp2.c"
opj_bool opj_jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int pos_iptr ;
  int pos_cidx ;
  int pos_jp2c ;
  int len_jp2c ;
  int len_cidx ;
  int end_pos ;
  int pos_fidx ;
  int len_fidx ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 1202
  pos_iptr = - 1;
#line 1202
  pos_jp2c = pos_iptr;
#line 1207
  jp2_write_jp(cio);
#line 1209
  jp2_write_ftyp(jp2, cio);
#line 1211
  jp2_write_jp2h(jp2, cio);
  }
#line 1213
  if (jp2->jpip_on) {
    {
#line 1214
    pos_iptr = cio_tell(cio);
#line 1215
    cio_skip(cio, 24);
#line 1217
    pos_jp2c = cio_tell(cio);
    }
  }
  {
#line 1221
  len_jp2c = jp2_write_jp2c(jp2, cio, image, cstr_info);
  }
#line 1221
  if (! len_jp2c) {
    {
#line 1222
    opj_event_msg(jp2->cinfo, 1, "Failed to encode image\n");
    }
#line 1223
    return (0);
  }
#line 1226
  if (jp2->jpip_on) {
    {
#line 1227
    pos_cidx = cio_tell(cio);
#line 1229
    len_cidx = write_cidx(pos_jp2c + 8, cio, image, *cstr_info, len_jp2c - 8);
#line 1231
    pos_fidx = cio_tell(cio);
#line 1232
    len_fidx = write_fidx(pos_jp2c, len_jp2c, pos_cidx, len_cidx, cio);
#line 1234
    end_pos = cio_tell(cio);
#line 1236
    cio_seek(cio, pos_iptr);
#line 1237
    write_iptr(pos_fidx, len_fidx, cio);
#line 1239
    cio_seek(cio, end_pos);
    }
  }
#line 1242
  return (1);
}
}
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 75
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 83
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 123
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 129
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 136
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 141
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 145
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 87
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 93
extern  __attribute__((__nothrow__)) int getpriority(__priority_which_t __which ,
                                                     id_t __who ) ;
#line 97
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 46 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 36 "/root/patchweave_new/14/libopenjpeg/j2k_lib.c"
double opj_clock(void) 
{ 
  struct rusage t ;
  double procTime ;

  {
  {
#line 51
  getrusage(0, & t);
#line 54
  procTime = (double )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 56
  return (procTime + (double )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 47 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) ;
#line 52
static void j2k_read_soc(opj_j2k_t *j2k ) ;
#line 57
static void j2k_write_siz(opj_j2k_t *j2k ) ;
#line 62
static void j2k_read_siz(opj_j2k_t *j2k ) ;
#line 67
static void j2k_write_com(opj_j2k_t *j2k ) ;
#line 72
static void j2k_read_com(opj_j2k_t *j2k ) ;
#line 78
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) ;
#line 84
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) ;
#line 89
static void j2k_write_cod(opj_j2k_t *j2k ) ;
#line 94
static void j2k_read_cod(opj_j2k_t *j2k ) ;
#line 100
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) ;
#line 105
static void j2k_read_coc(opj_j2k_t *j2k ) ;
#line 111
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) ;
#line 118
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) ;
#line 123
static void j2k_write_qcd(opj_j2k_t *j2k ) ;
#line 128
static void j2k_read_qcd(opj_j2k_t *j2k ) ;
#line 134
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) ;
#line 139
static void j2k_read_qcc(opj_j2k_t *j2k ) ;
#line 144
static void j2k_write_poc(opj_j2k_t *j2k ) ;
#line 149
static void j2k_read_poc(opj_j2k_t *j2k ) ;
#line 154
static void j2k_read_crg(opj_j2k_t *j2k ) ;
#line 159
static void j2k_read_tlm(opj_j2k_t *j2k ) ;
#line 164
static void j2k_read_plm(opj_j2k_t *j2k ) ;
#line 169
static void j2k_read_plt(opj_j2k_t *j2k ) ;
#line 174
static void j2k_read_ppm(opj_j2k_t *j2k ) ;
#line 179
static void j2k_read_ppt(opj_j2k_t *j2k ) ;
#line 184
static void j2k_write_tlm(opj_j2k_t *j2k ) ;
#line 189
static void j2k_write_sot(opj_j2k_t *j2k ) ;
#line 194
static void j2k_read_sot(opj_j2k_t *j2k ) ;
#line 200
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) ;
#line 205
static void j2k_read_sod(opj_j2k_t *j2k ) ;
#line 212
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) ;
#line 217
static void j2k_read_rgn(opj_j2k_t *j2k ) ;
#line 222
static void j2k_write_eoc(opj_j2k_t *j2k ) ;
#line 227
static void j2k_read_eoc(opj_j2k_t *j2k ) ;
#line 232
static void j2k_read_unk(opj_j2k_t *j2k ) ;
#line 240
static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) ;
#line 249
static void j2k_add_tlmarker(int tileno , opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) ;
#line 261 "/root/patchweave_new/14/libopenjpeg/j2k.c"
j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {"CPRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )0, {"LRCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )3, {"PCRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )1, {"RLCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )2, {"RPCL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )(- 1), {"\250", (char )0, (char )0, (char )0, (char )0}}};
#line 270 "/root/patchweave_new/14/libopenjpeg/j2k.c"
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;
  j2k_prog_order_t *__cil_tmp3 ;

  {
#line 272
  po = (j2k_prog_order_t *)j2k_prog_order_list;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! ((int )po->enum_prog != -1)) {
#line 272
      goto while_break;
    }
#line 273
    if ((int )po->enum_prog == (int )prg_order) {
#line 274
      goto while_break;
    }
#line 272
    po ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return ((char *)po->str_prog);
}
}
#line 281 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static int j2k_get_num_tp(opj_cp_t *cp , int pino , int tileno ) 
{ 
  char *prog ;
  int i ;
  int tpnum ;
  int tpend ;
  opj_tcp_t *tcp ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 284
  tpnum = 1;
  {
#line 284
  tpend = 0;
#line 285
  tcp = cp->tcps + tileno;
#line 286
  prog = j2k_convert_progression_order(tcp->prg);
  }
#line 288
  if ((int )cp->tp_on == 1) {
#line 289
    i = 0;
    {
#line 289
    while (1) {
      while_continue: /* CIL Label */ ;
#line 289
      if (! (i < 4)) {
#line 289
        goto while_break;
      }
#line 290
      if (tpend != 1) {
#line 291
        if ((int )cp->tp_flag == (int )*(prog + i)) {
#line 292
          tpend = 1;
#line 292
          cp->tp_pos = i;
        }
        {
#line 295
        if ((int )*(prog + i) == 'C') {
#line 295
          goto case_67;
        }
#line 298
        if ((int )*(prog + i) == 'R') {
#line 298
          goto case_82;
        }
#line 301
        if ((int )*(prog + i) == 'P') {
#line 301
          goto case_80;
        }
#line 304
        if ((int )*(prog + i) == 'L') {
#line 304
          goto case_76;
        }
#line 294
        goto switch_break;
        case_67: /* CIL Label */ 
#line 296
        tpnum *= tcp->pocs[pino].compE;
#line 297
        goto switch_break;
        case_82: /* CIL Label */ 
#line 299
        tpnum *= tcp->pocs[pino].resE;
#line 300
        goto switch_break;
        case_80: /* CIL Label */ 
#line 302
        tpnum *= tcp->pocs[pino].prcE;
#line 303
        goto switch_break;
        case_76: /* CIL Label */ 
#line 305
        tpnum *= tcp->pocs[pino].layE;
#line 306
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 289
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 311
    tpnum = 1;
  }
#line 313
  return (tpnum);
}
}
#line 317 "/root/patchweave_new/14/libopenjpeg/j2k.c"
int j2k_calculate_tp(opj_cp_t *cp , int img_numcomp , opj_image_t *image , opj_j2k_t *j2k ) 
{ 
  int pino ;
  int tileno ;
  int totnum_tp ;
  void *__cil_tmp8 ;
  int cur_totnum_tp ;
  opj_tcp_t *tcp ;
  int tp_num ;
  opj_pi_iterator_t *pi ;
  opj_pi_iterator_t *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 318
  totnum_tp = 0;
#line 322
  __cil_tmp8 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 322
  j2k->cur_totnum_tp = (int *)__cil_tmp8;
#line 323
  tileno = 0;
  }
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (tileno < cp->tw * cp->th)) {
#line 323
      goto while_break;
    }
#line 324
    cur_totnum_tp = 0;
#line 325
    tcp = cp->tcps + tileno;
#line 326
    pino = 0;
    {
#line 326
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 326
      if (! (pino <= tcp->numpocs)) {
#line 326
        goto while_break___0;
      }
      {
#line 327
      tp_num = 0;
#line 328
      __cil_tmp13 = pi_initialise_encode(image, cp, tileno, (J2K_T2_MODE )1);
#line 328
      pi = __cil_tmp13;
      }
#line 329
      if (! pi) {
#line 329
        return (- 1);
      }
      {
#line 330
      tp_num = j2k_get_num_tp(cp, pino, tileno);
#line 331
      totnum_tp += tp_num;
#line 332
      cur_totnum_tp += tp_num;
#line 333
      pi_destroy(pi, cp, tileno);
      }
#line 326
      pino ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 335
    *(j2k->cur_totnum_tp + tileno) = cur_totnum_tp;
#line 337
    if (j2k->cstr_info) {
      {
#line 338
      ((j2k->cstr_info)->tile + tileno)->num_tps = cur_totnum_tp;
#line 339
      __cil_tmp16 = malloc((unsigned long )cur_totnum_tp * sizeof(opj_tp_info_t ));
#line 339
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp16;
      }
    }
#line 323
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (totnum_tp);
}
}
#line 346 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;
  int __cil_tmp3 ;

  {
  {
#line 347
  cio = j2k->cio;
#line 348
  cio_write(cio, (unsigned long long )65359, 2);
  }
#line 350
  if (j2k->cstr_info) {
    {
#line 351
    __cil_tmp3 = cio_tell(cio);
#line 351
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65359, __cil_tmp3, 0);
    }
  }
  return;
}
}
#line 362 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_soc(opj_j2k_t *j2k ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 363
  j2k->state = 2;
#line 365
  if (j2k->cstr_info) {
    {
#line 366
    __cil_tmp2 = cio_tell(j2k->cio);
#line 366
    (j2k->cstr_info)->main_head_start = __cil_tmp2 - 2;
#line 367
    __cil_tmp3 = cio_numbytesleft(j2k->cio);
#line 367
    (j2k->cstr_info)->codestream_size = (__cil_tmp3 + 2) - (j2k->cstr_info)->main_head_start;
    }
  }
  return;
}
}
#line 371 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_siz(opj_j2k_t *j2k ) 
{ 
  int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 375
  cio = j2k->cio;
#line 376
  image = j2k->image;
#line 377
  cp = j2k->cp;
#line 379
  cio_write(cio, (unsigned long long )65361, 2);
#line 380
  lenp = cio_tell(cio);
#line 381
  cio_skip(cio, 2);
#line 382
  cio_write(cio, (unsigned long long )cp->rsiz, 2);
#line 383
  cio_write(cio, (unsigned long long )image->x1, 4);
#line 384
  cio_write(cio, (unsigned long long )image->y1, 4);
#line 385
  cio_write(cio, (unsigned long long )image->x0, 4);
#line 386
  cio_write(cio, (unsigned long long )image->y0, 4);
#line 387
  cio_write(cio, (unsigned long long )cp->tdx, 4);
#line 388
  cio_write(cio, (unsigned long long )cp->tdy, 4);
#line 389
  cio_write(cio, (unsigned long long )cp->tx0, 4);
#line 390
  cio_write(cio, (unsigned long long )cp->ty0, 4);
#line 391
  cio_write(cio, (unsigned long long )image->numcomps, 2);
#line 392
  i = 0;
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (i < image->numcomps)) {
#line 392
      goto while_break;
    }
    {
#line 393
    cio_write(cio, (unsigned long long )(((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7)),
              1);
#line 394
    cio_write(cio, (unsigned long long )(image->comps + i)->dx, 1);
#line 395
    cio_write(cio, (unsigned long long )(image->comps + i)->dy, 1);
    }
#line 392
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 397
  __cil_tmp10 = cio_tell(cio);
#line 397
  len = __cil_tmp10 - lenp;
#line 398
  cio_seek(cio, lenp);
#line 399
  cio_write(cio, (unsigned long long )len, 2);
#line 400
  cio_seek(cio, lenp + len);
  }
#line 402
  if (j2k->cstr_info) {
    {
#line 403
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65361, lenp, len);
    }
  }
  return;
}
}
#line 406 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_siz(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int n_comps ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  int tmp ;
  unsigned int __cil_tmp18 ;
  int tmp___0 ;
  void *__cil_tmp20 ;
  int tmp___1 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int __cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp37 ;

  {
  {
#line 410
  cio = j2k->cio;
#line 411
  image = j2k->image;
#line 412
  cp = j2k->cp;
#line 414
  __cil_tmp8 = cio_read(cio, 2);
#line 414
  len = (int )__cil_tmp8;
#line 415
  cio_read(cio, 2);
#line 416
  __cil_tmp9 = cio_read(cio, 4);
#line 416
  image->x1 = (int )__cil_tmp9;
#line 417
  __cil_tmp10 = cio_read(cio, 4);
#line 417
  image->y1 = (int )__cil_tmp10;
#line 418
  __cil_tmp11 = cio_read(cio, 4);
#line 418
  image->x0 = (int )__cil_tmp11;
#line 419
  __cil_tmp12 = cio_read(cio, 4);
#line 419
  image->y0 = (int )__cil_tmp12;
#line 420
  __cil_tmp13 = cio_read(cio, 4);
#line 420
  cp->tdx = (int )__cil_tmp13;
#line 421
  __cil_tmp14 = cio_read(cio, 4);
#line 421
  cp->tdy = (int )__cil_tmp14;
#line 422
  __cil_tmp15 = cio_read(cio, 4);
#line 422
  cp->tx0 = (int )__cil_tmp15;
#line 423
  __cil_tmp16 = cio_read(cio, 4);
#line 423
  cp->ty0 = (int )__cil_tmp16;
  }
#line 425
  if (image->x0 < 0) {
    {
    {
    {
    {
#line 426
    opj_event_msg(j2k->cinfo, 1, "invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n\230\001",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 429
    return;
  } else
#line 425
  if (image->x1 < 0) {
    {
    {
    {
    {
#line 426
    opj_event_msg(j2k->cinfo, 1, "invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n\230\001",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 429
    return;
  } else
#line 425
  if (image->y0 < 0) {
    {
    {
    {
    {
#line 426
    opj_event_msg(j2k->cinfo, 1, "invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n\230\001",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 429
    return;
  } else
#line 425
  if (image->y1 < 0) {
    {
    {
    {
    {
#line 426
    opj_event_msg(j2k->cinfo, 1, "invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n\230\001",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 429
    return;
  }
  {
#line 432
  n_comps = ((len - 36) - 2) / 3;
#line 434
  __cil_tmp18 = cio_read(cio, 2);
#line 434
  image->numcomps = (int )__cil_tmp18;
  }
#line 438
  if (image->x0 > image->x1) {
    {
    {
#line 439
    opj_event_msg(j2k->cinfo, 1, "Error with SIZ marker: negative image size (%d x %d)\n",
                  image->x1 - image->x0, image->y1 - image->y0);
    }
    }
#line 440
    return;
  } else
#line 438
  if (image->y0 > image->y1) {
    {
    {
#line 439
    opj_event_msg(j2k->cinfo, 1, "Error with SIZ marker: negative image size (%d x %d)\n",
                  image->x1 - image->x0, image->y1 - image->y0);
    }
    }
#line 440
    return;
  }
#line 443
  if (! (cp->tdx * cp->tdy)) {
    {
#line 444
    opj_event_msg(j2k->cinfo, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n",
                  cp->tdx, cp->tdy);
    }
#line 445
    return;
  }
#line 449
  if ((long long )image->x1 * (long long )image->y1 != (long long )(image->x1 * image->y1)) {
    {
#line 450
    opj_event_msg(j2k->cinfo, 1, "Prevent buffer overflow (x1: %d, y1: %d)\n", image->x1,
                  image->y1);
    }
#line 451
    return;
  }
#line 496
  if (! (cp->tdx * cp->tdy)) {
    {
#line 497
    opj_event_msg(j2k->cinfo, 1, "invalid tile size (tdx: %d, tdy: %d)\n", cp->tdx,
                  cp->tdy);
    }
#line 498
    return;
  }
  {
#line 501
  __cil_tmp20 = calloc((unsigned long )image->numcomps, sizeof(opj_image_comp_t ));
#line 501
  image->comps = (opj_image_comp_t *)__cil_tmp20;
#line 502
  i = 0;
  }
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < image->numcomps)) {
#line 502
      goto while_break;
    }
    {
#line 504
    __cil_tmp22 = cio_read(cio, 1);
#line 504
    tmp___1 = (int )__cil_tmp22;
#line 505
    (image->comps + i)->prec = (tmp___1 & 127) + 1;
#line 506
    (image->comps + i)->sgnd = tmp___1 >> 7;
#line 507
    __cil_tmp23 = cio_read(cio, 1);
#line 507
    (image->comps + i)->dx = (int )__cil_tmp23;
#line 508
    __cil_tmp24 = cio_read(cio, 1);
#line 508
    (image->comps + i)->dy = (int )__cil_tmp24;
    }
#line 540
    if (! ((image->comps + i)->dx * (image->comps + i)->dy)) {
      {
#line 541
      opj_event_msg(j2k->cinfo, 1, "JPWL: invalid component size (dx: %d, dy: %d)\n",
                    (image->comps + i)->dx, (image->comps + i)->dy);
      }
#line 542
      return;
    }
#line 545
    (image->comps + i)->resno_decoded = 0;
#line 546
    (image->comps + i)->factor = cp->reduce;
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
#line 550
  cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
#line 592
  __cil_tmp28 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 592
  cp->tcps = (opj_tcp_t *)__cil_tmp28;
  }
#line 593
  if (cp->tcps == (void *)0) {
    {
#line 595
    opj_event_msg(j2k->cinfo, 1, "Out of memory\n");
    }
#line 596
    return;
  }
  {
#line 598
  __cil_tmp29 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 598
  cp->tileno = (int *)__cil_tmp29;
  }
#line 599
  if (cp->tileno == (void *)0) {
    {
#line 601
    opj_event_msg(j2k->cinfo, 1, "Out of memory\n");
    }
#line 602
    return;
  }
#line 604
  cp->tileno_size = 0;
#line 619
  i = 0;
  {
#line 619
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 619
    if (! (i < cp->tw * cp->th)) {
#line 619
      goto while_break___0;
    }
#line 620
    (cp->tcps + i)->POC = 0;
#line 621
    (cp->tcps + i)->numpocs = 0;
#line 622
    (cp->tcps + i)->first = 1;
#line 619
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 626
  cp->ppm = 0;
#line 627
  cp->ppm_data = (unsigned char *)((void *)0);
#line 628
  cp->ppm_data_first = (unsigned char *)((void *)0);
#line 629
  cp->ppm_previous = 0;
#line 630
  cp->ppm_store = 0;
#line 632
  __cil_tmp31 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 632
  (j2k->default_tcp)->tccps = (opj_tccp_t *)__cil_tmp31;
#line 633
  i = 0;
  }
  {
#line 633
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 633
    if (! (i < cp->tw * cp->th)) {
#line 633
      goto while_break___1;
    }
    {
#line 634
    __cil_tmp32 = malloc((unsigned long )image->numcomps * sizeof(opj_tccp_t ));
#line 634
    (cp->tcps + i)->tccps = (opj_tccp_t *)__cil_tmp32;
    }
#line 633
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 636
  __cil_tmp34 = calloc((unsigned long )(cp->tw * cp->th), sizeof(unsigned char *));
#line 636
  j2k->tile_data = (unsigned char **)__cil_tmp34;
#line 637
  __cil_tmp35 = calloc((unsigned long )(cp->tw * cp->th), sizeof(int ));
#line 637
  j2k->tile_len = (int *)__cil_tmp35;
#line 638
  j2k->state = 4;
  }
#line 641
  if (j2k->cstr_info) {
    {
#line 642
    cstr_info = j2k->cstr_info;
#line 643
    cstr_info->image_w = image->x1 - image->x0;
#line 644
    cstr_info->image_h = image->y1 - image->y0;
#line 645
    cstr_info->numcomps = image->numcomps;
#line 646
    cstr_info->tw = cp->tw;
#line 647
    cstr_info->th = cp->th;
#line 648
    cstr_info->tile_x = cp->tdx;
#line 649
    cstr_info->tile_y = cp->tdy;
#line 650
    cstr_info->tile_Ox = cp->tx0;
#line 651
    cstr_info->tile_Oy = cp->ty0;
#line 652
    __cil_tmp37 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tile_info_t ));
#line 652
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp37;
    }
  }
  return;
}
}
#line 656 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_com(opj_j2k_t *j2k ) 
{ 
  unsigned int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  char *comment ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 660
  if ((j2k->cp)->comment) {
    {
#line 661
    cio = j2k->cio;
#line 662
    comment = (j2k->cp)->comment;
#line 664
    cio_write(cio, (unsigned long long )65380, 2);
#line 665
    lenp = cio_tell(cio);
#line 666
    cio_skip(cio, 2);
#line 667
    cio_write(cio, (unsigned long long )1, 2);
#line 668
    i = (unsigned int )0;
    }
    {
#line 668
    while (1) {
      while_continue: /* CIL Label */ ;
#line 668
      if (! ((unsigned long )i < __cil_tmp8)) {
#line 668
        goto while_break;
      }
      {
#line 669
      cio_write(cio, (unsigned long long )*(comment + i), 1);
      }
#line 668
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 671
    __cil_tmp10 = cio_tell(cio);
#line 671
    len = __cil_tmp10 - lenp;
#line 672
    cio_seek(cio, lenp);
#line 673
    cio_write(cio, (unsigned long long )len, 2);
#line 674
    cio_seek(cio, lenp + len);
    }
#line 677
    if (j2k->cstr_info) {
      {
#line 678
      j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65380, lenp, len);
      }
    }
  }
  return;
}
}
#line 683 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_com(opj_j2k_t *j2k ) 
{ 
  int len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp4 ;

  {
  {
#line 686
  cio = j2k->cio;
#line 688
  __cil_tmp4 = cio_read(cio, 2);
#line 688
  len = (int )__cil_tmp4;
#line 689
  cio_skip(cio, len - 2);
  }
  return;
}
}
#line 692 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int __cil_tmp8 ;

  {
  {
#line 695
  cp = j2k->cp;
#line 696
  tcp = cp->tcps + j2k->curtileno;
#line 697
  tccp = tcp->tccps + compno;
#line 698
  cio = j2k->cio;
#line 700
  cio_write(cio, (unsigned long long )(tccp->numresolutions - 1), 1);
#line 701
  cio_write(cio, (unsigned long long )(tccp->cblkw - 2), 1);
#line 702
  cio_write(cio, (unsigned long long )(tccp->cblkh - 2), 1);
#line 703
  cio_write(cio, (unsigned long long )tccp->cblksty, 1);
#line 704
  cio_write(cio, (unsigned long long )tccp->qmfbid, 1);
  }
#line 706
  if (tccp->csty & 1) {
#line 707
    i = 0;
    {
#line 707
    while (1) {
      while_continue: /* CIL Label */ ;
#line 707
      if (! (i < tccp->numresolutions)) {
#line 707
        goto while_break;
      }
      {
#line 708
      cio_write(cio, (unsigned long long )(tccp->prcw[i] + (tccp->prch[i] << 4)),
                1);
      }
#line 707
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 713 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int tmp___0 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 716
  cp = j2k->cp;
#line 717
  if (j2k->state == 16) {
#line 717
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 717
    tmp = j2k->default_tcp;
  }
  {
#line 717
  tcp = tmp;
#line 718
  tccp = tcp->tccps + compno;
#line 719
  cio = j2k->cio;
#line 721
  __cil_tmp9 = cio_read(cio, 1);
#line 721
  tccp->numresolutions = (int )(__cil_tmp9 + 1U);
  }
#line 724
  if (cp->reduce >= tccp->numresolutions) {
    {
#line 725
    opj_event_msg(j2k->cinfo, 1, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number of resolutions of this component\nModify the cp_reduce parameter.\n\n",
                  compno);
#line 727
    j2k->state |= 128;
    }
  }
#line 729
  if (tccp->numresolutions > 33) {
    {
#line 730
    opj_event_msg(j2k->cinfo, 1, "Error decoding component %d.\nThe number of resolutions is too big: %d vs max= %d. Truncating.\n\n",
                  compno, tccp->numresolutions, 33);
#line 732
    j2k->state |= 128;
#line 733
    tccp->numresolutions = 33;
    }
  }
  {
#line 736
  __cil_tmp10 = cio_read(cio, 1);
#line 736
  tccp->cblkw = (int )(__cil_tmp10 + 2U);
#line 737
  __cil_tmp11 = cio_read(cio, 1);
#line 737
  tccp->cblkh = (int )(__cil_tmp11 + 2U);
#line 738
  __cil_tmp12 = cio_read(cio, 1);
#line 738
  tccp->cblksty = (int )__cil_tmp12;
#line 739
  __cil_tmp13 = cio_read(cio, 1);
#line 739
  tccp->qmfbid = (int )__cil_tmp13;
  }
#line 740
  if (tccp->csty & 1) {
#line 741
    i = 0;
    {
#line 741
    while (1) {
      while_continue: /* CIL Label */ ;
#line 741
      if (! (i < tccp->numresolutions)) {
#line 741
        goto while_break;
      }
      {
#line 742
      __cil_tmp15 = cio_read(cio, 1);
#line 742
      tmp___0 = (int )__cil_tmp15;
#line 743
      tccp->prcw[i] = tmp___0 & 15;
#line 744
      tccp->prch[i] = tmp___0 >> 4;
      }
#line 741
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  if (j2k->cstr_info) {
#line 749
    if (compno == 0) {
#line 750
      i = 0;
      {
#line 750
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 750
        if (! (i < tccp->numresolutions)) {
#line 750
          goto while_break___0;
        }
#line 751
        if (tccp->csty & 1) {
#line 752
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = tccp->prcw[i];
#line 753
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdy[i] = tccp->prch[i];
        } else {
#line 756
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
#line 757
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
        }
#line 750
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 764 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_cod(opj_j2k_t *j2k ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 765
  cp = (opj_cp_t *)((void *)0);
#line 766
  tcp = (opj_tcp_t *)((void *)0);
#line 769
  cio = j2k->cio;
#line 771
  cio_write(cio, (unsigned long long )65362, 2);
#line 773
  lenp = cio_tell(cio);
#line 774
  cio_skip(cio, 2);
#line 776
  cp = j2k->cp;
#line 777
  tcp = cp->tcps + j2k->curtileno;
#line 779
  cio_write(cio, (unsigned long long )tcp->csty, 1);
#line 780
  cio_write(cio, (unsigned long long )tcp->prg, 1);
#line 781
  cio_write(cio, (unsigned long long )tcp->numlayers, 2);
#line 782
  cio_write(cio, (unsigned long long )tcp->mct, 1);
#line 784
  j2k_write_cox(j2k, 0);
#line 785
  __cil_tmp8 = cio_tell(cio);
#line 785
  len = __cil_tmp8 - lenp;
#line 786
  cio_seek(cio, lenp);
#line 787
  cio_write(cio, (unsigned long long )len, 2);
#line 788
  cio_seek(cio, lenp + len);
  }
#line 790
  if (j2k->cstr_info) {
    {
#line 791
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65362, lenp, len);
    }
  }
  return;
}
}
#line 795 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_cod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 798
  cio = j2k->cio;
#line 799
  cp = j2k->cp;
#line 800
  if (j2k->state == 16) {
#line 800
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 800
    tmp = j2k->default_tcp;
  }
  {
#line 800
  tcp = tmp;
#line 801
  image = j2k->image;
#line 803
  __cil_tmp10 = cio_read(cio, 2);
#line 803
  len = (int )__cil_tmp10;
#line 805
  __cil_tmp11 = cio_read(cio, 1);
#line 805
  tcp->csty = (int )__cil_tmp11;
#line 806
  __cil_tmp12 = cio_read(cio, 1);
#line 806
  tcp->prg = (OPJ_PROG_ORDER )__cil_tmp12;
#line 807
  __cil_tmp13 = cio_read(cio, 2);
#line 807
  tcp->numlayers = (int )__cil_tmp13;
#line 808
  __cil_tmp14 = cio_read(cio, 1);
#line 808
  tcp->mct = (int )__cil_tmp14;
#line 810
  pos = cio_tell(cio);
#line 811
  i = 0;
  }
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 811
    if (! (i < image->numcomps)) {
#line 811
      goto while_break;
    }
    {
#line 812
    (tcp->tccps + i)->csty = tcp->csty & 1;
#line 813
    cio_seek(cio, pos);
#line 814
    j2k_read_cox(j2k, i);
    }
#line 811
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 818
  if (j2k->cstr_info) {
    {
#line 819
    cstr_info = j2k->cstr_info;
#line 820
    cstr_info->prog = tcp->prg;
#line 821
    cstr_info->numlayers = tcp->numlayers;
#line 822
    __cil_tmp18 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 822
    cstr_info->numdecompos = (int *)__cil_tmp18;
#line 823
    i = 0;
    }
    {
#line 823
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 823
      if (! (i < image->numcomps)) {
#line 823
        goto while_break___0;
      }
#line 824
      *(cstr_info->numdecompos + i) = (tcp->tccps + i)->numresolutions - 1;
#line 823
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 829 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;

  {
  {
#line 832
  cp = j2k->cp;
#line 833
  tcp = cp->tcps + j2k->curtileno;
#line 834
  image = j2k->image;
#line 835
  cio = j2k->cio;
#line 837
  cio_write(cio, (unsigned long long )65363, 2);
#line 838
  lenp = cio_tell(cio);
#line 839
  cio_skip(cio, 2);
  }
#line 840
  if (image->numcomps <= 256) {
#line 840
    tmp = 1;
  } else {
#line 840
    tmp = 2;
  }
  {
#line 840
  cio_write(cio, (unsigned long long )compno, tmp);
#line 841
  cio_write(cio, (unsigned long long )(tcp->tccps + compno)->csty, 1);
#line 842
  j2k_write_cox(j2k, compno);
#line 843
  __cil_tmp11 = cio_tell(cio);
#line 843
  len = __cil_tmp11 - lenp;
#line 844
  cio_seek(cio, lenp);
#line 845
  cio_write(cio, (unsigned long long )len, 2);
#line 846
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 849 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_coc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  int tmp___0 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;

  {
#line 852
  cp = j2k->cp;
#line 853
  if (j2k->state == 16) {
#line 853
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 853
    tmp = j2k->default_tcp;
  }
  {
#line 853
  tcp = tmp;
#line 854
  image = j2k->image;
#line 855
  cio = j2k->cio;
#line 857
  __cil_tmp9 = cio_read(cio, 2);
#line 857
  len = (int )__cil_tmp9;
  }
#line 859
  if (image->numcomps <= 256) {
#line 859
    tmp___0 = 1;
  } else {
#line 859
    tmp___0 = 2;
  }
  {
#line 859
  __cil_tmp11 = cio_read(cio, tmp___0);
#line 859
  compno = (int )__cil_tmp11;
  }
#line 860
  if (compno >= image->numcomps) {
    {
#line 861
    opj_event_msg(j2k->cinfo, 1, "bad component number in COC (%d out of a maximum of %d)\n\230\001",
                  compno, image->numcomps);
    }
#line 864
    return;
  }
  {
#line 866
  __cil_tmp12 = cio_read(cio, 1);
#line 866
  (tcp->tccps + compno)->csty = (int )__cil_tmp12;
#line 867
  j2k_read_cox(j2k, compno);
  }
  return;
}
}
#line 870 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) 
{ 
  int bandno ;
  int numbands ;
  int expn ;
  int mant ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;
  int __cil_tmp12 ;

  {
  {
#line 874
  cp = j2k->cp;
#line 875
  tcp = cp->tcps + j2k->curtileno;
#line 876
  tccp = tcp->tccps + compno;
#line 877
  cio = j2k->cio;
#line 879
  cio_write(cio, (unsigned long long )(tccp->qntsty + (tccp->numgbits << 5)), 1);
  }
#line 880
  if (tccp->qntsty == 1) {
#line 880
    tmp = 1;
  } else {
#line 880
    tmp = tccp->numresolutions * 3 - 2;
  }
#line 880
  numbands = tmp;
#line 882
  bandno = 0;
  {
#line 882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (! (bandno < numbands)) {
#line 882
      goto while_break;
    }
#line 883
    expn = tccp->stepsizes[bandno].expn;
#line 884
    mant = tccp->stepsizes[bandno].mant;
#line 886
    if (tccp->qntsty == 0) {
      {
#line 887
      cio_write(cio, (unsigned long long )(expn << 3), 1);
      }
    } else {
      {
#line 889
      cio_write(cio, (unsigned long long )((expn << 11) + mant), 2);
      }
    }
#line 882
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 894 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) 
{ 
  int tmp ;
  int bandno ;
  int numbands ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp___11 ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  int tmp___12 ;
  int tmp___13 ;
  int expn ;
  int mant ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp___14 ;
  int __cil_tmp21 ;

  {
#line 898
  cp = j2k->cp;
#line 899
  if (j2k->state == 16) {
#line 899
    tmp___11 = cp->tcps + j2k->curtileno;
  } else {
#line 899
    tmp___11 = j2k->default_tcp;
  }
  {
#line 899
  tcp = tmp___11;
#line 900
  tccp = tcp->tccps + compno;
#line 901
  cio = j2k->cio;
#line 903
  __cil_tmp12 = cio_read(cio, 1);
#line 903
  tmp = (int )__cil_tmp12;
#line 904
  tccp->qntsty = tmp & 31;
#line 905
  tccp->numgbits = tmp >> 5;
  }
#line 906
  if (tccp->qntsty == 1) {
#line 906
    tmp___13 = 1;
  } else {
#line 906
    if (tccp->qntsty == 0) {
#line 906
      tmp___12 = len - 1;
    } else {
#line 906
      tmp___12 = (len - 1) / 2;
    }
#line 906
    tmp___13 = tmp___12;
  }
#line 906
  numbands = tmp___13;
#line 932
  if (numbands < 0) {
    {
    {
#line 933
    opj_event_msg(j2k->cinfo, 2, "bad number of subbands in Sqcx (%d) regarding to J2K_MAXBANDS (%d) \n- limiting number of bands to J2K_MAXBANDS and try to move to the next markers\n",
                  numbands, 97);
    }
#line 937
    numbands = 1;
    }
  } else
#line 932
  if (numbands >= 97) {
    {
    {
#line 933
    opj_event_msg(j2k->cinfo, 2, "bad number of subbands in Sqcx (%d) regarding to J2K_MAXBANDS (%d) \n- limiting number of bands to J2K_MAXBANDS and try to move to the next markers\n",
                  numbands, 97);
    }
#line 937
    numbands = 1;
    }
  }
#line 942
  bandno = 0;
  {
#line 942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 942
    if (! (bandno < numbands)) {
#line 942
      goto while_break;
    }
#line 944
    if (tccp->qntsty == 0) {
      {
#line 945
      __cil_tmp17 = cio_read(cio, 1);
#line 945
      expn = (int )(__cil_tmp17 >> 3);
#line 946
      mant = 0;
      }
    } else {
      {
#line 948
      __cil_tmp18 = cio_read(cio, 2);
#line 948
      tmp = (int )__cil_tmp18;
#line 949
      expn = tmp >> 11;
#line 950
      mant = tmp & 2047;
      }
    }
#line 952
    if (bandno < 97) {
#line 953
      tccp->stepsizes[bandno].expn = expn;
#line 954
      tccp->stepsizes[bandno].mant = mant;
    }
#line 942
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 959
  if (tccp->qntsty == 1) {
#line 960
    bandno = 1;
    {
#line 960
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 960
      if (! (bandno < 97)) {
#line 960
        goto while_break___0;
      }
#line 961
      if (tccp->stepsizes[0].expn - (bandno - 1) / 3 > 0) {
#line 961
        tmp___14 = tccp->stepsizes[0].expn - (bandno - 1) / 3;
      } else {
#line 961
        tmp___14 = 0;
      }
#line 961
      tccp->stepsizes[bandno].expn = tmp___14;
#line 964
      tccp->stepsizes[bandno].mant = tccp->stepsizes[0].mant;
#line 960
      bandno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 970 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_qcd(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 973
  cio = j2k->cio;
#line 975
  cio_write(cio, (unsigned long long )65372, 2);
#line 976
  lenp = cio_tell(cio);
#line 977
  cio_skip(cio, 2);
#line 978
  j2k_write_qcx(j2k, 0);
#line 979
  __cil_tmp6 = cio_tell(cio);
#line 979
  len = __cil_tmp6 - lenp;
#line 980
  cio_seek(cio, lenp);
#line 981
  cio_write(cio, (unsigned long long )len, 2);
#line 982
  cio_seek(cio, lenp + len);
  }
#line 984
  if (j2k->cstr_info) {
    {
#line 985
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65372, lenp, len);
    }
  }
  return;
}
}
#line 988 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_qcd(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  unsigned int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 991
  cio = j2k->cio;
#line 992
  image = j2k->image;
#line 994
  __cil_tmp7 = cio_read(cio, 2);
#line 994
  len = (int )__cil_tmp7;
#line 995
  pos = cio_tell(cio);
#line 996
  i = 0;
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 996
    if (! (i < image->numcomps)) {
#line 996
      goto while_break;
    }
    {
#line 997
    cio_seek(cio, pos);
#line 998
    j2k_read_qcx(j2k, i, len - 2);
    }
#line 996
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1002 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp6 ;
  int tmp ;
  int __cil_tmp8 ;

  {
  {
#line 1005
  cio = j2k->cio;
#line 1007
  cio_write(cio, (unsigned long long )65373, 2);
#line 1008
  lenp = cio_tell(cio);
#line 1009
  cio_skip(cio, 2);
  }
#line 1010
  if ((j2k->image)->numcomps <= 256) {
#line 1010
    tmp = 1;
  } else {
#line 1010
    tmp = 2;
  }
  {
#line 1010
  cio_write(cio, (unsigned long long )compno, tmp);
#line 1011
  j2k_write_qcx(j2k, compno);
#line 1012
  __cil_tmp8 = cio_tell(cio);
#line 1012
  len = __cil_tmp8 - lenp;
#line 1013
  cio_seek(cio, lenp);
#line 1014
  cio_write(cio, (unsigned long long )len, 2);
#line 1015
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 1018 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_qcc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int numcomp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp6 ;
  int tmp ;
  unsigned int __cil_tmp8 ;
  int tmp___0 ;

  {
  {
#line 1020
  numcomp = (j2k->image)->numcomps;
#line 1021
  cio = j2k->cio;
#line 1023
  __cil_tmp6 = cio_read(cio, 2);
#line 1023
  len = (int )__cil_tmp6;
  }
#line 1024
  if (numcomp <= 256) {
#line 1024
    tmp = 1;
  } else {
#line 1024
    tmp = 2;
  }
  {
#line 1024
  __cil_tmp8 = cio_read(cio, tmp);
#line 1024
  compno = (int )__cil_tmp8;
  }
#line 1052
  if (compno < 0) {
    {
    {
#line 1053
    opj_event_msg(j2k->cinfo, 1, "bad component number in QCC (%d out of a maximum of %d)\n\230\001",
                  compno, (j2k->image)->numcomps);
    }
    }
#line 1056
    return;
  } else
#line 1052
  if (compno >= numcomp) {
    {
    {
#line 1053
    opj_event_msg(j2k->cinfo, 1, "bad component number in QCC (%d out of a maximum of %d)\n\230\001",
                  compno, (j2k->image)->numcomps);
    }
    }
#line 1056
    return;
  }
#line 1059
  if (numcomp <= 256) {
#line 1059
    tmp___0 = 1;
  } else {
#line 1059
    tmp___0 = 2;
  }
  {
#line 1059
  j2k_read_qcx(j2k, compno, (len - 2) - tmp___0);
  }
  return;
}
}
#line 1062 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;
  opj_poc_t *poc ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp___1 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 1065
  numcomps = (j2k->image)->numcomps;
#line 1067
  cp = j2k->cp;
#line 1068
  tcp = cp->tcps + j2k->curtileno;
#line 1069
  tccp = tcp->tccps + 0;
#line 1070
  cio = j2k->cio;
#line 1072
  numpchgs = 1 + tcp->numpocs;
#line 1073
  cio_write(cio, (unsigned long long )65375, 2);
  }
#line 1074
  if (numcomps <= 256) {
#line 1074
    tmp = 1;
  } else {
#line 1074
    tmp = 2;
  }
  {
#line 1074
  len = 2 + (5 + 2 * tmp) * numpchgs;
#line 1075
  cio_write(cio, (unsigned long long )len, 2);
#line 1076
  i = 0;
  }
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < numpchgs)) {
#line 1076
      goto while_break;
    }
    {
#line 1077
    poc = & tcp->pocs[i];
#line 1078
    cio_write(cio, (unsigned long long )poc->resno0, 1);
    }
#line 1079
    if (numcomps <= 256) {
#line 1079
      tmp___0 = 1;
    } else {
#line 1079
      tmp___0 = 2;
    }
    {
#line 1079
    cio_write(cio, (unsigned long long )poc->compno0, tmp___0);
#line 1080
    cio_write(cio, (unsigned long long )poc->layno1, 2);
#line 1081
    poc->layno1 = int_min(poc->layno1, tcp->numlayers);
#line 1082
    cio_write(cio, (unsigned long long )poc->resno1, 1);
#line 1083
    poc->resno1 = int_min(poc->resno1, tccp->numresolutions);
    }
#line 1084
    if (numcomps <= 256) {
#line 1084
      tmp___1 = 1;
    } else {
#line 1084
      tmp___1 = 2;
    }
    {
#line 1084
    cio_write(cio, (unsigned long long )poc->compno1, tmp___1);
#line 1085
    poc->compno1 = int_min(poc->compno1, numcomps);
#line 1086
    cio_write(cio, (unsigned long long )poc->prg, 1);
    }
#line 1076
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1090 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int old_poc ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  int tmp___1 ;
  opj_poc_t *poc ;
  unsigned int __cil_tmp15 ;
  int tmp___2 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int tmp___3 ;
  unsigned int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 1093
  numcomps = (j2k->image)->numcomps;
#line 1095
  cp = j2k->cp;
#line 1096
  if (j2k->state == 16) {
#line 1096
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1096
    tmp = j2k->default_tcp;
  }
#line 1096
  tcp = tmp;
#line 1097
  cio = j2k->cio;
#line 1099
  if (tcp->POC) {
#line 1099
    tmp___0 = tcp->numpocs + 1;
  } else {
#line 1099
    tmp___0 = 0;
  }
  {
#line 1099
  old_poc = tmp___0;
#line 1100
  tcp->POC = 1;
#line 1101
  __cil_tmp12 = cio_read(cio, 2);
#line 1101
  len = (int )__cil_tmp12;
  }
#line 1102
  if (numcomps <= 256) {
#line 1102
    tmp___1 = 1;
  } else {
#line 1102
    tmp___1 = 2;
  }
#line 1102
  numpchgs = (len - 2) / (5 + 2 * tmp___1);
#line 1104
  if (numpchgs >= 32) {
    {
#line 1107
    opj_event_msg(j2k->cinfo, 1, "bad number of POCS (%d out of a maximum of %d)\n",
                  numpchgs, 32);
#line 1110
    numpchgs = 0;
    }
  }
#line 1113
  i = old_poc;
  {
#line 1113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1113
    if (! (i < numpchgs + old_poc)) {
#line 1113
      goto while_break;
    }
    {
#line 1115
    poc = & tcp->pocs[i];
#line 1116
    __cil_tmp15 = cio_read(cio, 1);
#line 1116
    poc->resno0 = (int )__cil_tmp15;
    }
#line 1117
    if (numcomps <= 256) {
#line 1117
      tmp___2 = 1;
    } else {
#line 1117
      tmp___2 = 2;
    }
    {
#line 1117
    __cil_tmp17 = cio_read(cio, tmp___2);
#line 1117
    poc->compno0 = (int )__cil_tmp17;
#line 1118
    __cil_tmp18 = cio_read(cio, 2);
#line 1118
    poc->layno1 = (int )__cil_tmp18;
#line 1119
    __cil_tmp19 = cio_read(cio, 1);
#line 1119
    poc->resno1 = (int )__cil_tmp19;
    }
#line 1120
    if (numcomps <= 256) {
#line 1120
      tmp___3 = 1;
    } else {
#line 1120
      tmp___3 = 2;
    }
    {
#line 1120
    __cil_tmp21 = cio_read(cio, tmp___3);
#line 1120
    __cil_tmp22 = int_min((int )__cil_tmp21, (int )((unsigned int )numcomps));
#line 1120
    poc->compno1 = __cil_tmp22;
#line 1122
    __cil_tmp23 = cio_read(cio, 1);
#line 1122
    poc->prg = (OPJ_PROG_ORDER )__cil_tmp23;
    }
#line 1113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1125
  tcp->numpocs = (numpchgs + old_poc) - 1;
  return;
}
}
#line 1128 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_crg(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Xcrg_i ;
  int Ycrg_i ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1131
  cio = j2k->cio;
#line 1132
  numcomps = (j2k->image)->numcomps;
#line 1134
  __cil_tmp8 = cio_read(cio, 2);
#line 1134
  len = (int )__cil_tmp8;
#line 1136
  i = 0;
  }
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    if (! (i < numcomps)) {
#line 1136
      goto while_break;
    }
    {
#line 1137
    __cil_tmp9 = cio_read(cio, 2);
#line 1137
    Xcrg_i = (int )__cil_tmp9;
#line 1139
    __cil_tmp10 = cio_read(cio, 2);
#line 1139
    Ycrg_i = (int )__cil_tmp10;
    }
#line 1136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1144 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_tlm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Ztlm ;
  int Stlm ;
  int ST ;
  int SP ;
  int tile_tlm ;
  int i ;
  long Ttlm_i ;
  long Ptlm_i ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int tmp ;
  unsigned int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 1148
  cio = j2k->cio;
#line 1150
  __cil_tmp12 = cio_read(cio, 2);
#line 1150
  len = (int )__cil_tmp12;
#line 1151
  __cil_tmp13 = cio_read(cio, 1);
#line 1151
  Ztlm = (int )__cil_tmp13;
#line 1153
  __cil_tmp14 = cio_read(cio, 1);
#line 1153
  Stlm = (int )__cil_tmp14;
#line 1154
  ST = ((Stlm >> 4) & 1) + ((Stlm >> 4) & 2);
#line 1155
  SP = (Stlm >> 6) & 1;
#line 1156
  tile_tlm = (len - 4) / ((SP + 1) * 2 + ST);
#line 1157
  i = 0;
  }
  {
#line 1157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1157
    if (! (i < tile_tlm)) {
#line 1157
      goto while_break;
    }
    {
#line 1158
    __cil_tmp15 = cio_read(cio, ST);
#line 1158
    Ttlm_i = (long )__cil_tmp15;
    }
#line 1160
    if (SP) {
#line 1160
      tmp = 4;
    } else {
#line 1160
      tmp = 2;
    }
    {
#line 1160
    __cil_tmp17 = cio_read(cio, tmp);
#line 1160
    Ptlm_i = (long )__cil_tmp17;
    }
#line 1157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1165 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_plm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplm ;
  int Nplm ;
  int add ;
  int packet_len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 1166
  packet_len = 0;
#line 1168
  cio = j2k->cio;
#line 1170
  __cil_tmp9 = cio_read(cio, 2);
#line 1170
  len = (int )__cil_tmp9;
#line 1171
  __cil_tmp10 = cio_read(cio, 1);
#line 1171
  Zplm = (int )__cil_tmp10;
#line 1173
  len -= 3;
  }
  {
#line 1174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1174
    if (! (len > 0)) {
#line 1174
      goto while_break;
    }
    {
#line 1175
    __cil_tmp11 = cio_read(cio, 4);
#line 1175
    Nplm = (int )__cil_tmp11;
#line 1176
    len -= 4;
#line 1177
    i = Nplm;
    }
    {
#line 1177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1177
      if (! (i > 0)) {
#line 1177
        goto while_break___0;
      }
      {
#line 1178
      __cil_tmp12 = cio_read(cio, 1);
#line 1178
      add = (int )__cil_tmp12;
#line 1179
      __cil_tmp13 = len;
#line 1179
      len --;
#line 1180
      packet_len = (packet_len << 7) + add;
      }
#line 1181
      if ((add & 128) == 0) {
#line 1183
        packet_len = 0;
      }
#line 1185
      if (len <= 0) {
#line 1186
        goto while_break___0;
      }
#line 1177
      __cil_tmp14 = i;
#line 1177
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1191 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_plt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplt ;
  int packet_len ;
  int add ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1192
  packet_len = 0;
#line 1194
  cio = j2k->cio;
#line 1196
  __cil_tmp8 = cio_read(cio, 2);
#line 1196
  len = (int )__cil_tmp8;
#line 1197
  __cil_tmp9 = cio_read(cio, 1);
#line 1197
  Zplt = (int )__cil_tmp9;
#line 1199
  i = len - 3;
  }
  {
#line 1199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1199
    if (! (i > 0)) {
#line 1199
      goto while_break;
    }
    {
#line 1200
    __cil_tmp10 = cio_read(cio, 1);
#line 1200
    add = (int )__cil_tmp10;
#line 1201
    packet_len = (packet_len << 7) + add;
    }
#line 1202
    if ((add & 128) == 0) {
#line 1204
      packet_len = 0;
    }
#line 1199
    __cil_tmp11 = i;
#line 1199
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1209 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_ppm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppm ;
  int i ;
  int j ;
  int N_ppm ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 1213
  cp = j2k->cp;
#line 1214
  cio = j2k->cio;
#line 1216
  __cil_tmp9 = cio_read(cio, 2);
#line 1216
  len = (int )__cil_tmp9;
#line 1217
  cp->ppm = 1;
#line 1219
  __cil_tmp10 = cio_read(cio, 1);
#line 1219
  Z_ppm = (int )__cil_tmp10;
#line 1220
  len -= 3;
  }
  {
#line 1221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1221
    if (! (len > 0)) {
#line 1221
      goto while_break;
    }
#line 1222
    if (cp->ppm_previous == 0) {
      {
#line 1223
      __cil_tmp11 = cio_read(cio, 4);
#line 1223
      N_ppm = (int )__cil_tmp11;
#line 1224
      len -= 4;
      }
    } else {
#line 1226
      N_ppm = cp->ppm_previous;
    }
#line 1228
    j = cp->ppm_store;
#line 1229
    if (Z_ppm == 0) {
      {
#line 1230
      __cil_tmp12 = malloc((unsigned long )N_ppm * sizeof(unsigned char ));
#line 1230
      cp->ppm_data = (unsigned char *)__cil_tmp12;
#line 1231
      cp->ppm_data_first = cp->ppm_data;
#line 1232
      cp->ppm_len = N_ppm;
      }
    } else {
      {
#line 1234
      __cil_tmp13 = realloc(cp->ppm_data, (unsigned long )(N_ppm + cp->ppm_store) * sizeof(unsigned char ));
#line 1234
      cp->ppm_data = (unsigned char *)__cil_tmp13;
#line 1252
      cp->ppm_data_first = cp->ppm_data;
#line 1253
      cp->ppm_len = N_ppm + cp->ppm_store;
      }
    }
#line 1255
    i = N_ppm;
    {
#line 1255
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1255
      if (! (i > 0)) {
#line 1255
        goto while_break___0;
      }
      {
#line 1256
      __cil_tmp14 = cio_read(cio, 1);
#line 1256
      *(cp->ppm_data + j) = (unsigned char )__cil_tmp14;
#line 1257
      j ++;
#line 1258
      __cil_tmp16 = len;
#line 1258
      len --;
      }
#line 1259
      if (len == 0) {
#line 1260
        goto while_break___0;
      }
#line 1255
      __cil_tmp17 = i;
#line 1255
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1262
    cp->ppm_previous = i - 1;
#line 1263
    cp->ppm_store = j;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1267 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_ppt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppt ;
  int i ;
  int j ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 1268
  j = 0;
#line 1270
  cp = j2k->cp;
#line 1271
  tcp = cp->tcps + j2k->curtileno;
#line 1272
  cio = j2k->cio;
#line 1274
  __cil_tmp9 = cio_read(cio, 2);
#line 1274
  len = (int )__cil_tmp9;
#line 1275
  __cil_tmp10 = cio_read(cio, 1);
#line 1275
  Z_ppt = (int )__cil_tmp10;
#line 1276
  tcp->ppt = 1;
  }
#line 1277
  if (Z_ppt == 0) {
    {
#line 1278
    __cil_tmp11 = malloc((unsigned long )(len - 3) * sizeof(unsigned char ));
#line 1278
    tcp->ppt_data = (unsigned char *)__cil_tmp11;
#line 1279
    tcp->ppt_data_first = tcp->ppt_data;
#line 1280
    tcp->ppt_store = 0;
#line 1281
    tcp->ppt_len = len - 3;
    }
  } else {
    {
#line 1283
    __cil_tmp12 = realloc(tcp->ppt_data, (unsigned long )((len - 3) + tcp->ppt_store) * sizeof(unsigned char ));
#line 1283
    tcp->ppt_data = (unsigned char *)__cil_tmp12;
#line 1284
    tcp->ppt_data_first = tcp->ppt_data;
#line 1285
    tcp->ppt_len = (len - 3) + tcp->ppt_store;
    }
  }
#line 1287
  j = tcp->ppt_store;
#line 1288
  i = len - 3;
  {
#line 1288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1288
    if (! (i > 0)) {
#line 1288
      goto while_break;
    }
    {
#line 1289
    __cil_tmp13 = cio_read(cio, 1);
#line 1289
    *(tcp->ppt_data + j) = (unsigned char )__cil_tmp13;
#line 1290
    j ++;
    }
#line 1288
    __cil_tmp15 = i;
#line 1288
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1292
  tcp->ppt_store = j;
  return;
}
}
#line 1295 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_tlm(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  opj_cio_t *cio ;
  int __cil_tmp4 ;

  {
  {
#line 1297
  cio = j2k->cio;
#line 1298
  j2k->tlm_start = cio_tell(cio);
#line 1299
  cio_write(cio, (unsigned long long )65365, 2);
#line 1300
  lenp = 4 + 5 * j2k->totnum_tp;
#line 1301
  cio_write(cio, (unsigned long long )lenp, 2);
#line 1302
  cio_write(cio, (unsigned long long )0, 1);
#line 1303
  cio_write(cio, (unsigned long long )80, 1);
#line 1304
  cio_skip(cio, 5 * j2k->totnum_tp);
  }
  return;
}
}
#line 1307 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_sot(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1310
  cio = j2k->cio;
#line 1312
  j2k->sot_start = cio_tell(cio);
#line 1313
  cio_write(cio, (unsigned long long )65424, 2);
#line 1314
  lenp = cio_tell(cio);
#line 1315
  cio_skip(cio, 2);
#line 1316
  cio_write(cio, (unsigned long long )j2k->curtileno, 2);
#line 1317
  cio_skip(cio, 4);
#line 1318
  cio_write(cio, (unsigned long long )j2k->cur_tp_num, 1);
#line 1319
  cio_write(cio, (unsigned long long )*(j2k->cur_totnum_tp + j2k->curtileno), 1);
#line 1320
  __cil_tmp7 = cio_tell(cio);
#line 1320
  len = __cil_tmp7 - lenp;
#line 1321
  cio_seek(cio, lenp);
#line 1322
  cio_write(cio, (unsigned long long )len, 2);
#line 1323
  cio_seek(cio, lenp + len);
  }
#line 1332
  if (j2k->cstr_info) {
#line 1332
    if (j2k->cur_tp_num == 0) {
      {
#line 1333
      j2k_add_tlmarker(j2k->curtileno, j2k->cstr_info, (unsigned short )65424, lenp,
                       len);
      }
    }
  }
  return;
}
}
#line 1337 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_sot(opj_j2k_t *j2k ) 
{ 
  int len ;
  int tileno ;
  int totlen ;
  int partno ;
  int numparts ;
  int i ;
  opj_tcp_t *tcp ;
  char status ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  opj_tccp_t *tmp___0 ;
  int __cil_tmp31 ;

  {
  {
#line 1339
  tcp = (opj_tcp_t *)((void *)0);
#line 1340
  status = (char )0;
#line 1342
  cp = j2k->cp;
#line 1343
  cio = j2k->cio;
#line 1345
  __cil_tmp12 = cio_read(cio, 2);
#line 1345
  len = (int )__cil_tmp12;
#line 1347
  __cil_tmp13 = cio_read(cio, 2);
#line 1347
  tileno = (int )__cil_tmp13;
  }
#line 1377
  if (tileno < 0) {
    {
    {
#line 1378
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile number (%d out of a maximum of %d)\n",
                  tileno, cp->tw * cp->th);
    }
    }
#line 1381
    return;
  } else
#line 1377
  if (tileno >= cp->tw * cp->th) {
    {
    {
#line 1378
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile number (%d out of a maximum of %d)\n",
                  tileno, cp->tw * cp->th);
    }
    }
#line 1381
    return;
  }
#line 1385
  if (cp->tileno_size == 0) {
#line 1386
    *(cp->tileno + cp->tileno_size) = tileno;
#line 1387
    (cp->tileno_size) ++;
  } else {
#line 1389
    i = 0;
    {
#line 1390
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1390
      if (! (i < cp->tileno_size && (int )status == 0)) {
#line 1390
        goto while_break;
      }
#line 1391
      if (*(cp->tileno + i) == tileno) {
#line 1391
        tmp = 1;
      } else {
#line 1391
        tmp = 0;
      }
#line 1391
      status = (char )tmp;
#line 1392
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1394
    if ((int )status == 0) {
#line 1395
      *(cp->tileno + cp->tileno_size) = tileno;
#line 1396
      (cp->tileno_size) ++;
    }
  }
  {
#line 1400
  __cil_tmp18 = cio_read(cio, 4);
#line 1400
  totlen = (int )__cil_tmp18;
#line 1426
  __cil_tmp19 = cio_numbytesleft(cio);
  }
#line 1426
  if (totlen < 0) {
    {
    {
#line 1427
    __cil_tmp20 = cio_numbytesleft(cio);
    }
    {
#line 1427
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
                  totlen, __cil_tmp20 + 8);
    }
    }
#line 1430
    return;
  } else
#line 1426
  if (totlen > __cil_tmp19 + 8) {
    {
    {
#line 1427
    __cil_tmp20 = cio_numbytesleft(cio);
    }
    {
#line 1427
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
                  totlen, __cil_tmp20 + 8);
    }
    }
#line 1430
    return;
  }
#line 1434
  if (! totlen) {
    {
#line 1435
    __cil_tmp21 = cio_numbytesleft(cio);
#line 1435
    totlen = __cil_tmp21 + 8;
    }
  }
  {
#line 1437
  __cil_tmp22 = cio_read(cio, 1);
#line 1437
  partno = (int )__cil_tmp22;
#line 1438
  __cil_tmp23 = cio_read(cio, 1);
#line 1438
  numparts = (int )__cil_tmp23;
  }
#line 1440
  if (partno >= numparts) {
    {
#line 1441
    opj_event_msg(j2k->cinfo, 2, "SOT marker inconsistency in tile %d: tile-part index greater (%d) than number of tile-parts (%d)\n",
                  tileno, partno, numparts);
#line 1442
    numparts = partno + 1;
    }
  }
  {
#line 1445
  j2k->curtileno = tileno;
#line 1446
  j2k->cur_tp_num = partno;
#line 1447
  __cil_tmp24 = cio_getbp(cio);
#line 1447
  j2k->eot = (__cil_tmp24 - 12) + totlen;
#line 1448
  j2k->state = 16;
#line 1449
  tcp = cp->tcps + j2k->curtileno;
  }
#line 1452
  if (j2k->cstr_info) {
#line 1453
    if (tcp->first) {
#line 1454
      if (tileno == 0) {
        {
#line 1455
        __cil_tmp25 = cio_tell(cio);
#line 1455
        (j2k->cstr_info)->main_head_end = __cil_tmp25 - 13;
        }
      }
      {
#line 1456
      ((j2k->cstr_info)->tile + tileno)->tileno = tileno;
#line 1457
      __cil_tmp26 = cio_tell(cio);
#line 1457
      ((j2k->cstr_info)->tile + tileno)->start_pos = __cil_tmp26 - 12;
#line 1458
      ((j2k->cstr_info)->tile + tileno)->end_pos = (((j2k->cstr_info)->tile + tileno)->start_pos + totlen) - 1;
      }
    } else {
#line 1460
      ((j2k->cstr_info)->tile + tileno)->end_pos += totlen;
    }
#line 1462
    ((j2k->cstr_info)->tile + tileno)->num_tps = numparts;
#line 1463
    if (numparts) {
      {
#line 1464
      __cil_tmp27 = realloc(((j2k->cstr_info)->tile + tileno)->tp, (unsigned long )numparts * sizeof(opj_tp_info_t ));
#line 1464
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp27;
      }
    } else {
      {
#line 1466
      __cil_tmp28 = realloc(((j2k->cstr_info)->tile + tileno)->tp, 10UL * sizeof(opj_tp_info_t ));
#line 1466
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp28;
      }
    }
    {
#line 1467
    __cil_tmp29 = cio_tell(cio);
#line 1467
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos = __cil_tmp29 - 12;
#line 1468
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_end_pos = ((((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos + totlen) - 1;
    }
  }
#line 1472
  if (tcp->first == 1) {
    {
#line 1474
    tmp___0 = tcp->tccps;
#line 1475
    memcpy(tcp, j2k->default_tcp, sizeof(opj_tcp_t ));
#line 1476
    tcp->ppt = 0;
#line 1477
    tcp->ppt_data = (unsigned char *)((void *)0);
#line 1478
    tcp->ppt_data_first = (unsigned char *)((void *)0);
#line 1479
    tcp->tccps = tmp___0;
#line 1481
    i = 0;
    }
    {
#line 1481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1481
      if (! (i < (j2k->image)->numcomps)) {
#line 1481
        goto while_break___0;
      }
#line 1482
      *(tcp->tccps + i) = *((j2k->default_tcp)->tccps + i);
#line 1481
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1484
    (cp->tcps + j2k->curtileno)->first = 0;
  }
  return;
}
}
#line 1488 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) 
{ 
  int l ;
  int layno ;
  int totlen ;
  opj_tcp_t *tcp ;
  opj_codestream_info_t *cstr_info ;
  opj_tcd_t *tcd ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 1491
  tcp = (opj_tcp_t *)((void *)0);
#line 1492
  cstr_info = (opj_codestream_info_t *)((void *)0);
#line 1494
  tcd = (opj_tcd_t *)tile_coder;
#line 1495
  cp = j2k->cp;
#line 1496
  cio = j2k->cio;
#line 1498
  tcd->tp_num = j2k->tp_num;
#line 1499
  tcd->cur_tp_num = j2k->cur_tp_num;
#line 1501
  cio_write(cio, (unsigned long long )65427, 2);
  }
#line 1503
  if (j2k->cstr_info) {
#line 1503
    if (j2k->cur_tp_num == 0) {
      {
#line 1504
      __cil_tmp11 = cio_tell(cio);
#line 1504
      j2k_add_tlmarker(j2k->curtileno, j2k->cstr_info, (unsigned short )65427, __cil_tmp11,
                       0);
      }
    }
  }
#line 1507
  if (j2k->curtileno == 0) {
    {
#line 1508
    __cil_tmp12 = cio_tell(cio);
#line 1508
    j2k->sod_start = __cil_tmp12 + j2k->pos_correction;
    }
  }
#line 1512
  cstr_info = j2k->cstr_info;
#line 1513
  if (cstr_info) {
#line 1514
    if (! j2k->cur_tp_num) {
      {
#line 1515
      __cil_tmp13 = cio_tell(cio);
#line 1515
      (cstr_info->tile + j2k->curtileno)->end_header = (__cil_tmp13 + j2k->pos_correction) - 1;
#line 1516
      ((j2k->cstr_info)->tile + j2k->curtileno)->tileno = j2k->curtileno;
      }
    } else {
      {
#line 1519
      __cil_tmp14 = cio_tell(cio);
      }
#line 1519
      if (((cstr_info->tile + j2k->curtileno)->packet + (cstr_info->packno - 1))->end_pos < __cil_tmp14) {
        {
#line 1520
        ((cstr_info->tile + j2k->curtileno)->packet + cstr_info->packno)->start_pos = cio_tell(cio);
        }
      }
    }
  }
#line 1531
  tcp = cp->tcps + j2k->curtileno;
#line 1532
  layno = 0;
  {
#line 1532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1532
    if (! (layno < tcp->numlayers)) {
#line 1532
      goto while_break;
    }
#line 1533
    if (tcp->rates[layno] > (float )(j2k->sod_start / (cp->th * cp->tw))) {
#line 1534
      tcp->rates[layno] -= (float )(j2k->sod_start / (cp->th * cp->tw));
    } else
#line 1535
    if (tcp->rates[layno]) {
#line 1536
      tcp->rates[layno] = (float )1;
    }
#line 1532
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1539
  if (j2k->cur_tp_num == 0) {
#line 1540
    ((tcd->tcd_image)->tiles)->packno = 0;
#line 1541
    if (cstr_info) {
#line 1542
      cstr_info->packno = 0;
    }
  }
  {
#line 1545
  __cil_tmp17 = cio_getbp(cio);
  }
  {
#line 1545
  __cil_tmp18 = cio_numbytesleft(cio);
#line 1545
  __cil_tmp19 = tcd_encode_tile(tcd, j2k->curtileno, __cil_tmp17, __cil_tmp18 - 2,
                                cstr_info);
#line 1545
  l = __cil_tmp19;
#line 1548
  __cil_tmp20 = cio_tell(cio);
#line 1548
  totlen = (__cil_tmp20 + l) - j2k->sot_start;
#line 1549
  cio_seek(cio, j2k->sot_start + 6);
#line 1550
  cio_write(cio, (unsigned long long )totlen, 4);
#line 1551
  cio_seek(cio, j2k->sot_start + totlen);
  }
#line 1553
  if (cp->cinema) {
    {
#line 1554
    cio_seek(cio, (j2k->tlm_start + 6) + 5 * j2k->cur_tp_num);
#line 1555
    cio_write(cio, (unsigned long long )j2k->curtileno, 1);
#line 1556
    cio_write(cio, (unsigned long long )totlen, 4);
    }
  }
  {
#line 1558
  cio_seek(cio, j2k->sot_start + totlen);
  }
  return;
}
}
#line 1561 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_sod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int truncate ;
  int i ;
  unsigned char *data ;
  unsigned char *data_ptr ;
  opj_cio_t *cio ;
  int curtileno ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 1562
  truncate = 0;
#line 1563
  data = (unsigned char *)((void *)0);
#line 1563
  data_ptr = (unsigned char *)((void *)0);
#line 1565
  cio = j2k->cio;
#line 1566
  curtileno = j2k->curtileno;
#line 1569
  if (j2k->cstr_info) {
    {
#line 1570
    __cil_tmp9 = cio_tell(cio);
#line 1570
    (((j2k->cstr_info)->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp9 + j2k->pos_correction) - 1;
    }
#line 1572
    if (j2k->cur_tp_num == 0) {
      {
#line 1573
      __cil_tmp10 = cio_tell(cio);
#line 1573
      ((j2k->cstr_info)->tile + j2k->curtileno)->end_header = (__cil_tmp10 + j2k->pos_correction) - 1;
      }
    }
#line 1574
    (j2k->cstr_info)->packno = 0;
  }
  {
#line 1577
  __cil_tmp11 = cio_getbp(cio);
  }
  {
#line 1577
  __cil_tmp12 = cio_numbytesleft(cio);
#line 1577
  __cil_tmp13 = int_min((int )(j2k->eot - __cil_tmp11), __cil_tmp12 + 1);
#line 1577
  len = __cil_tmp13;
#line 1579
  __cil_tmp14 = cio_numbytesleft(cio);
  }
#line 1579
  if (len == __cil_tmp14 + 1) {
#line 1580
    truncate = 1;
  }
  {
#line 1583
  data = *(j2k->tile_data + curtileno);
#line 1584
  data_ptr = data;
#line 1585
  __cil_tmp15 = realloc(data, (unsigned long )(*(j2k->tile_len + curtileno) + len) * sizeof(unsigned char ));
#line 1585
  data = (unsigned char *)__cil_tmp15;
  }
#line 1586
  if (data == (void *)0) {
    {
#line 1587
    opj_event_msg(j2k->cinfo, 1, "Could not reallocated\n");
#line 1588
    free(data_ptr);
    }
#line 1589
    return;
  }
#line 1592
  data_ptr = data + *(j2k->tile_len + curtileno);
#line 1593
  i = 0;
  {
#line 1593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1593
    if (! (i < len)) {
#line 1593
      goto while_break;
    }
    {
#line 1594
    __cil_tmp16 = cio_read(cio, 1);
#line 1594
    *(data_ptr + i) = (unsigned char )__cil_tmp16;
    }
#line 1593
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1597
  *(j2k->tile_len + curtileno) += len;
#line 1598
  *(j2k->tile_data + curtileno) = data;
#line 1600
  if (! truncate) {
#line 1601
    j2k->state = 8;
  } else {
#line 1603
    j2k->state = 64;
  }
#line 1605
  (j2k->cur_tp_num) ++;
  return;
}
}
#line 1608 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  int numcomps ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1609
  cp = j2k->cp;
#line 1610
  tcp = cp->tcps + tileno;
#line 1611
  cio = j2k->cio;
#line 1612
  numcomps = (j2k->image)->numcomps;
#line 1614
  cio_write(cio, (unsigned long long )65374, 2);
  }
#line 1615
  if (numcomps <= 256) {
#line 1615
    tmp = 5;
  } else {
#line 1615
    tmp = 6;
  }
  {
#line 1615
  cio_write(cio, (unsigned long long )tmp, 2);
  }
#line 1616
  if (numcomps <= 256) {
#line 1616
    tmp___0 = 1;
  } else {
#line 1616
    tmp___0 = 2;
  }
  {
#line 1616
  cio_write(cio, (unsigned long long )compno, tmp___0);
#line 1617
  cio_write(cio, (unsigned long long )0, 1);
#line 1618
  cio_write(cio, (unsigned long long )(tcp->tccps + compno)->roishift, 1);
  }
  return;
}
}
#line 1621 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_rgn(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int roisty ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp10 ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 1624
  cp = j2k->cp;
#line 1625
  if (j2k->state == 16) {
#line 1625
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1625
    tmp = j2k->default_tcp;
  }
  {
#line 1625
  tcp = tmp;
#line 1626
  cio = j2k->cio;
#line 1627
  numcomps = (j2k->image)->numcomps;
#line 1629
  __cil_tmp10 = cio_read(cio, 2);
#line 1629
  len = (int )__cil_tmp10;
  }
#line 1631
  if (numcomps <= 256) {
#line 1631
    tmp___0 = 1;
  } else {
#line 1631
    tmp___0 = 2;
  }
  {
#line 1631
  __cil_tmp12 = cio_read(cio, tmp___0);
#line 1631
  compno = (int )__cil_tmp12;
#line 1632
  __cil_tmp13 = cio_read(cio, 1);
#line 1632
  roisty = (int )__cil_tmp13;
  }
#line 1650
  if (compno >= numcomps) {
    {
#line 1651
    opj_event_msg(j2k->cinfo, 1, "bad component number in RGN (%d out of a maximum of %d)\n\230\001",
                  compno, (j2k->image)->numcomps);
    }
#line 1654
    return;
  }
  {
#line 1657
  __cil_tmp14 = cio_read(cio, 1);
#line 1657
  (tcp->tccps + compno)->roishift = (int )__cil_tmp14;
  }
  return;
}
}
#line 1660 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_write_eoc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;

  {
  {
#line 1661
  cio = j2k->cio;
#line 1663
  cio_write(cio, (unsigned long long )65497, 2);
  }
  return;
}
}
#line 1673 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_eoc(opj_j2k_t *j2k ) 
{ 
  int i ;
  int tileno ;
  opj_bool success ;
  opj_tcd_t *tcd ;
  opj_tcd_t *__cil_tmp6 ;
  opj_bool __cil_tmp7 ;
  int tmp ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 1675
  success = 0;
#line 1678
  if ((unsigned int )(j2k->cp)->limit_decoding != 2U) {
    {
#line 1679
    __cil_tmp6 = tcd_create(j2k->cinfo);
#line 1679
    tcd = __cil_tmp6;
#line 1680
    tcd_malloc_decode(tcd, j2k->image, j2k->cp);
#line 1681
    i = 0;
    }
    {
#line 1681
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1681
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1681
        goto while_break;
      }
      {
#line 1682
      tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
      }
#line 1683
      if (*((j2k->cp)->tileno + i) != -1) {
        {
#line 1685
        tileno = *((j2k->cp)->tileno + i);
#line 1686
        success = tcd_decode_tile(tcd, *(j2k->tile_data + tileno), *(j2k->tile_len + tileno),
                                  tileno, j2k->cstr_info);
#line 1688
        free(*(j2k->tile_data + tileno));
#line 1689
        *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
#line 1690
        tcd_free_decode_tile(tcd, i);
        }
      } else {
#line 1693
        success = 0;
      }
#line 1694
      if (success == 0) {
#line 1695
        j2k->state |= 128;
#line 1696
        goto while_break;
      }
#line 1681
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1699
    tcd_free_decode(tcd);
#line 1700
    tcd_destroy(tcd);
    }
  } else {
#line 1704
    i = 0;
    {
#line 1704
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1704
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1704
        goto while_break___0;
      }
      {
#line 1705
      tileno = *((j2k->cp)->tileno + i);
#line 1706
      free(*(j2k->tile_data + tileno));
#line 1707
      *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
      }
#line 1704
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1710
  if (j2k->state & 128) {
#line 1711
    j2k->state = 160;
  } else {
#line 1713
    j2k->state = 32;
  }
  return;
}
}
#line 1725 "/root/patchweave_new/14/libopenjpeg/j2k.c"
opj_dec_mstabent_t j2k_dec_mstab[20]  = 
#line 1725
  {      {65359, 1, & j2k_read_soc}, 
        {65424, 12, & j2k_read_sot}, 
        {65427, 16, & j2k_read_sod}, 
        {65497, 8, & j2k_read_eoc}, 
        {65361, 2, & j2k_read_siz}, 
        {65362, 20, & j2k_read_cod}, 
        {65363, 20, & j2k_read_coc}, 
        {65374, 20, & j2k_read_rgn}, 
        {65372, 20, & j2k_read_qcd}, 
        {65373, 20, & j2k_read_qcc}, 
        {65375, 20, & j2k_read_poc}, 
        {65365, 4, & j2k_read_tlm}, 
        {65367, 4, & j2k_read_plm}, 
        {65368, 16, & j2k_read_plt}, 
        {65376, 4, & j2k_read_ppm}, 
        {65377, 16, & j2k_read_ppt}, 
        {65425, 0, (void (*)(opj_j2k_t * ))0}, 
        {65379, 4, & j2k_read_crg}, 
        {65380, 20, & j2k_read_com}, 
        {0, 20, & j2k_read_unk}};
#line 1760 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_read_unk(opj_j2k_t *j2k ) 
{ 


  {
  {
#line 1761
  opj_event_msg(j2k->cinfo, 2, "Unknown marker\n");
  }
  return;
}
}
#line 1826 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static opj_dec_mstabent_t *j2k_dec_mstab_lookup(int id ) 
{ 
  opj_dec_mstabent_t *e ;
  opj_dec_mstabent_t *__cil_tmp3 ;

  {
#line 1828
  e = (opj_dec_mstabent_t *)j2k_dec_mstab;
  {
#line 1828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1828
    if (! (e->id != 0)) {
#line 1828
      goto while_break;
    }
#line 1829
    if (e->id == id) {
#line 1830
      goto while_break;
    }
#line 1828
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1833
  return (e);
}
}
#line 1840 "/root/patchweave_new/14/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 1841
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 1841
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 1842
  if (! j2k) {
#line 1843
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 1845
  __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_tcp_t ));
#line 1845
  j2k->default_tcp = (opj_tcp_t *)__cil_tmp4;
  }
#line 1846
  if (! j2k->default_tcp) {
    {
#line 1847
    free(j2k);
    }
#line 1848
    return ((opj_j2k_t *)((void *)0));
  }
#line 1851
  j2k->cinfo = cinfo;
#line 1852
  j2k->tile_data = (unsigned char **)((void *)0);
#line 1854
  return (j2k);
}
}
#line 1857 "/root/patchweave_new/14/libopenjpeg/j2k.c"
void j2k_destroy_decompress(opj_j2k_t *j2k ) 
{ 
  int i ;
  int tileno ;
  int __cil_tmp4 ;
  opj_tcp_t *default_tcp ;
  opj_cp_t *cp ;
  int __cil_tmp7 ;

  {
#line 1858
  i = 0;
#line 1860
  if (j2k->tile_len != (void *)0) {
    {
#line 1861
    free(j2k->tile_len);
    }
  }
#line 1863
  if (j2k->tile_data != (void *)0) {
#line 1864
    if (j2k->cp != (void *)0) {
#line 1865
      i = 0;
      {
#line 1865
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1865
        if (! (i < (j2k->cp)->tileno_size)) {
#line 1865
          goto while_break;
        }
#line 1866
        tileno = *((j2k->cp)->tileno + i);
#line 1867
        if (tileno != -1) {
          {
#line 1869
          free(*(j2k->tile_data + tileno));
#line 1870
          *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
          }
        }
#line 1865
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1875
    free(j2k->tile_data);
    }
  }
#line 1877
  if (j2k->default_tcp != (void *)0) {
#line 1878
    default_tcp = j2k->default_tcp;
#line 1879
    if (default_tcp->ppt_data_first != (void *)0) {
      {
#line 1880
      free(default_tcp->ppt_data_first);
      }
    }
#line 1882
    if ((j2k->default_tcp)->tccps != (void *)0) {
      {
#line 1883
      free((j2k->default_tcp)->tccps);
      }
    }
    {
#line 1885
    free(j2k->default_tcp);
    }
  }
#line 1887
  if (j2k->cp != (void *)0) {
#line 1888
    cp = j2k->cp;
#line 1889
    if (cp->tcps != (void *)0) {
#line 1890
      i = 0;
      {
#line 1890
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1890
        if (! (i < cp->tw * cp->th)) {
#line 1890
          goto while_break___0;
        }
#line 1891
        if ((cp->tcps + i)->ppt_data_first != (void *)0) {
          {
#line 1892
          free((cp->tcps + i)->ppt_data_first);
          }
        }
#line 1894
        if ((cp->tcps + i)->tccps != (void *)0) {
          {
#line 1895
          free((cp->tcps + i)->tccps);
          }
        }
#line 1890
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1898
      free(cp->tcps);
      }
    }
#line 1900
    if (cp->ppm_data_first != (void *)0) {
      {
#line 1901
      free(cp->ppm_data_first);
      }
    }
#line 1903
    if (cp->tileno != (void *)0) {
      {
#line 1904
      free(cp->tileno);
      }
    }
#line 1906
    if (cp->comment != (void *)0) {
      {
#line 1907
      free(cp->comment);
      }
    }
    {
#line 1910
    free(cp);
    }
  }
  {
#line 1912
  free(j2k);
  }
  return;
}
}
#line 1915 "/root/patchweave_new/14/libopenjpeg/j2k.c"
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 
  opj_cp_t *cp ;
  void *__cil_tmp4 ;

  {
#line 1916
  if (j2k) {
#line 1916
    if (parameters) {
      {
#line 1918
      __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_cp_t ));
#line 1918
      cp = (opj_cp_t *)__cil_tmp4;
#line 1919
      cp->reduce = parameters->cp_reduce;
#line 1920
      cp->layer = parameters->cp_layer;
#line 1921
      cp->limit_decoding = parameters->cp_limit_decoding;
#line 1931
      j2k->cp = cp;
      }
    }
  }
  return;
}
}
#line 1935 "/root/patchweave_new/14/libopenjpeg/j2k.c"
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_common_ptr cinfo ;
  opj_image_t *__cil_tmp6 ;
  opj_dec_mstabent_t *e ;
  int id ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  opj_dec_mstabent_t *__cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 1936
  image = (opj_image_t *)((void *)0);
#line 1938
  cinfo = j2k->cinfo;
#line 1940
  j2k->cio = cio;
#line 1941
  j2k->cstr_info = cstr_info;
#line 1942
  if (cstr_info) {
    {
#line 1943
    memset(cstr_info, 0, sizeof(opj_codestream_info_t ));
    }
  }
  {
#line 1946
  image = opj_image_create0();
#line 1947
  j2k->image = image;
#line 1949
  j2k->state = 1;
  }
  {
#line 1951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1951
    if (! 1) {
#line 1951
      goto while_break;
    }
    {
#line 1953
    __cil_tmp9 = cio_read(cio, 2);
#line 1953
    id = (int )__cil_tmp9;
    }
#line 1993
    if (id >> 8 != 255) {
      {
#line 1994
      __cil_tmp10 = cio_numbytesleft(cio);
      }
#line 1994
      if (__cil_tmp10 != 0) {
        {
#line 1996
        __cil_tmp11 = cio_tell(cio);
#line 1996
        opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp11 - 2,
                      id);
#line 1997
        opj_image_destroy(image);
        }
#line 1998
        return ((opj_image_t *)0);
      }
      {
#line 2000
      __cil_tmp12 = cio_tell(cio);
#line 2000
      opj_event_msg(cinfo, 2, "%.8x: expected a marker instead of %x\n", __cil_tmp12 - 2,
                    id);
#line 2001
      j2k->state = 64;
      }
#line 2002
      goto while_break;
    }
    {
#line 2004
    e = j2k_dec_mstab_lookup(id);
    }
#line 2006
    if (! (j2k->state & e->states)) {
      {
#line 2007
      opj_image_destroy(image);
#line 2008
      __cil_tmp14 = cio_tell(cio);
#line 2008
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\n", __cil_tmp14 - 2, id);
      }
#line 2009
      return ((opj_image_t *)0);
    }
#line 2012
    if (e->id == 65424) {
#line 2012
      if ((unsigned int )(j2k->cp)->limit_decoding == 1U) {
        {
#line 2013
        opj_event_msg(cinfo, 4, "Main Header decoded.\n");
        }
#line 2014
        return (image);
      }
    }
#line 2017
    if (e->handler) {
      {
#line 2018
      (*(e->handler))(j2k);
      }
    }
#line 2020
    if (j2k->state & 128) {
      {
#line 2022
      opj_image_destroy(image);
      }
#line 2023
      return ((opj_image_t *)((void *)0));
    }
#line 2026
    if (j2k->state == 32) {
#line 2027
      goto while_break;
    }
#line 2029
    if (j2k->state == 64) {
#line 2030
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2033
  if (j2k->state == 64) {
    {
#line 2034
    j2k_read_eoc(j2k);
    }
#line 2036
    if (j2k->state & 128) {
      {
#line 2037
      opj_image_destroy(image);
      }
#line 2038
      return ((opj_image_t *)((void *)0));
    }
  }
#line 2042
  if (j2k->state != 32) {
    {
#line 2043
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 2045
  return (image);
}
}
#line 2052 "/root/patchweave_new/14/libopenjpeg/j2k.c"
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_jpt_msg_header_t header ;
  int position ;
  opj_common_ptr cinfo ;
  opj_image_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  opj_dec_mstabent_t *e ;
  int id ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  opj_dec_mstabent_t *__cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 2053
  image = (opj_image_t *)((void *)0);
#line 2056
  cinfo = j2k->cinfo;
#line 2060
  j2k->cio = cio;
#line 2063
  image = opj_image_create0();
#line 2064
  j2k->image = image;
#line 2066
  j2k->state = 1;
#line 2069
  jpt_init_msg_header(& header);
#line 2071
  jpt_read_msg_header(cinfo, cio, & header);
#line 2073
  position = cio_tell(cio);
  }
#line 2074
  if (header.Class_Id != 6U) {
    {
#line 2075
    opj_image_destroy(image);
#line 2076
    opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Main header first [class_Id %d] !\n",
                  header.Class_Id);
    }
#line 2077
    return ((opj_image_t *)0);
  }
  {
#line 2080
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2080
    if (! 1) {
#line 2080
      goto while_break;
    }
    {
#line 2081
    e = (opj_dec_mstabent_t *)((void *)0);
#line 2084
    __cil_tmp12 = cio_numbytesleft(cio);
    }
#line 2084
    if (! __cil_tmp12) {
      {
#line 2085
      j2k_read_eoc(j2k);
      }
#line 2086
      return (image);
    }
    {
#line 2089
    __cil_tmp13 = cio_tell(cio);
    }
#line 2089
    if ((unsigned int )(__cil_tmp13 - position) == header.Msg_length) {
      {
#line 2090
      jpt_read_msg_header(cinfo, cio, & header);
#line 2091
      position = cio_tell(cio);
      }
#line 2092
      if (header.Class_Id != 4U) {
        {
#line 2093
        opj_image_destroy(image);
#line 2094
        opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Tile info !\nU");
        }
#line 2095
        return ((opj_image_t *)0);
      }
    }
    {
#line 2099
    __cil_tmp15 = cio_read(cio, 2);
#line 2099
    id = (int )__cil_tmp15;
    }
#line 2100
    if (id >> 8 != 255) {
      {
#line 2101
      __cil_tmp16 = cio_numbytesleft(cio);
      }
#line 2101
      if (__cil_tmp16 != 0) {
        {
#line 2103
        __cil_tmp17 = cio_tell(cio);
#line 2103
        opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp17 - 2,
                      id);
#line 2104
        opj_image_destroy(image);
        }
#line 2105
        return ((opj_image_t *)0);
      }
      {
#line 2107
      __cil_tmp18 = cio_tell(cio);
#line 2107
      opj_event_msg(cinfo, 2, "%.8x: expected a marker instead of %x\n", __cil_tmp18 - 2,
                    id);
#line 2108
      j2k->state = 64;
      }
#line 2109
      goto while_break;
    }
    {
#line 2111
    e = j2k_dec_mstab_lookup(id);
    }
#line 2112
    if (! (j2k->state & e->states)) {
      {
#line 2113
      opj_image_destroy(image);
#line 2114
      __cil_tmp20 = cio_tell(cio);
#line 2114
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\n\336\342U", __cil_tmp20 - 2,
                    id);
      }
#line 2115
      return ((opj_image_t *)0);
    }
#line 2117
    if (e->handler) {
      {
#line 2118
      (*(e->handler))(j2k);
      }
    }
#line 2120
    if (j2k->state == 32) {
#line 2121
      goto while_break;
    }
#line 2123
    if (j2k->state == 64) {
#line 2124
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2127
  if (j2k->state == 64) {
    {
#line 2128
    j2k_read_eoc(j2k);
    }
  }
#line 2131
  if (j2k->state != 32) {
    {
#line 2132
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 2135
  return (image);
}
}
#line 2142 "/root/patchweave_new/14/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;

  {
  {
#line 2143
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 2143
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 2144
  if (j2k) {
#line 2145
    j2k->cinfo = cinfo;
  }
#line 2147
  return (j2k);
}
}
#line 2150 "/root/patchweave_new/14/libopenjpeg/j2k.c"
void j2k_destroy_compress(opj_j2k_t *j2k ) 
{ 
  int tileno ;
  opj_cp_t *cp ;
  int __cil_tmp4 ;

  {
#line 2153
  if (! j2k) {
#line 2153
    return;
  }
#line 2154
  if (j2k->cp != (void *)0) {
#line 2155
    cp = j2k->cp;
#line 2157
    if (cp->comment) {
      {
#line 2158
      free(cp->comment);
      }
    }
#line 2160
    if (cp->matrice) {
      {
#line 2161
      free(cp->matrice);
      }
    }
#line 2163
    tileno = 0;
    {
#line 2163
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2163
      if (! (tileno < cp->tw * cp->th)) {
#line 2163
        goto while_break;
      }
      {
#line 2164
      free((cp->tcps + tileno)->tccps);
      }
#line 2163
      tileno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2166
    free(cp->tcps);
#line 2167
    free(cp);
    }
  }
  {
#line 2170
  free(j2k);
  }
  return;
}
}
#line 2173 "/root/patchweave_new/14/libopenjpeg/j2k.c"
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int numpocs_tile ;
  opj_cp_t *cp ;
  void *__cil_tmp9 ;
  size_t array_size ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  opj_tcp_t *tcp ;
  int __cil_tmp19 ;
  opj_poc_t *tcp_poc ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  void *__cil_tmp23 ;
  opj_tccp_t *tccp ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp29 ;
  int p ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int res_spec ;
  int size_prcw ;
  int size_prch ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;

  {
#line 2175
  cp = (opj_cp_t *)((void *)0);
#line 2177
  if (! j2k) {
#line 2178
    return;
  } else
#line 2177
  if (! parameters) {
#line 2178
    return;
  } else
#line 2177
  if (! image) {
#line 2178
    return;
  }
  {
#line 2182
  __cil_tmp9 = calloc((unsigned long )1, sizeof(opj_cp_t ));
#line 2182
  cp = (opj_cp_t *)__cil_tmp9;
#line 2185
  j2k->cp = cp;
#line 2188
  cp->tw = 1;
#line 2189
  cp->th = 1;
#line 2194
  cp->cinema = parameters->cp_cinema;
#line 2195
  cp->max_comp_size = parameters->max_comp_size;
#line 2196
  cp->rsiz = parameters->cp_rsiz;
#line 2197
  cp->disto_alloc = parameters->cp_disto_alloc;
#line 2198
  cp->fixed_alloc = parameters->cp_fixed_alloc;
#line 2199
  cp->fixed_quality = parameters->cp_fixed_quality;
  }
#line 2202
  if (parameters->cp_matrice) {
    {
#line 2203
    array_size = (unsigned long )((parameters->tcp_numlayers * parameters->numresolution) * 3) * sizeof(int );
#line 2204
    __cil_tmp11 = malloc(array_size);
#line 2204
    cp->matrice = (int *)__cil_tmp11;
#line 2205
    memcpy(cp->matrice, parameters->cp_matrice, array_size);
    }
  }
#line 2209
  cp->tdx = parameters->cp_tdx;
#line 2210
  cp->tdy = parameters->cp_tdy;
#line 2213
  cp->tx0 = parameters->cp_tx0;
#line 2214
  cp->ty0 = parameters->cp_ty0;
#line 2217
  if (parameters->cp_comment) {
    {
#line 2218
    __cil_tmp12 = strlen((char const   *)parameters->cp_comment);
#line 2218
    __cil_tmp13 = malloc(__cil_tmp12 + 1UL);
#line 2218
    cp->comment = (char *)__cil_tmp13;
    }
#line 2219
    if (cp->comment) {
      {
#line 2220
      strcpy(cp->comment, (char const   *)parameters->cp_comment);
      }
    }
  }
#line 2228
  if (parameters->tile_size_on) {
    {
#line 2229
    cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
#line 2230
    cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
    }
  } else {
#line 2232
    cp->tdx = image->x1 - cp->tx0;
#line 2233
    cp->tdy = image->y1 - cp->ty0;
  }
#line 2236
  if (parameters->tp_on) {
#line 2237
    cp->tp_flag = parameters->tp_flag;
#line 2238
    cp->tp_on = (char )1;
  }
#line 2241
  cp->img_size = 0;
#line 2242
  i = 0;
  {
#line 2242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2242
    if (! (i < image->numcomps)) {
#line 2242
      goto while_break;
    }
#line 2243
    cp->img_size += ((image->comps + i)->w * (image->comps + i)->h) * (image->comps + i)->prec;
#line 2242
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2306
  __cil_tmp17 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 2306
  cp->tcps = (opj_tcp_t *)__cil_tmp17;
#line 2308
  tileno = 0;
  }
  {
#line 2308
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2308
    if (! (tileno < cp->tw * cp->th)) {
#line 2308
      goto while_break___0;
    }
#line 2309
    tcp = cp->tcps + tileno;
#line 2310
    tcp->numlayers = parameters->tcp_numlayers;
#line 2311
    j = 0;
    {
#line 2311
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2311
      if (! (j < tcp->numlayers)) {
#line 2311
        goto while_break___1;
      }
#line 2312
      if (cp->cinema) {
#line 2313
        if (cp->fixed_quality) {
#line 2314
          tcp->distoratio[j] = parameters->tcp_distoratio[j];
        }
#line 2316
        tcp->rates[j] = parameters->tcp_rates[j];
      } else
#line 2318
      if (cp->fixed_quality) {
#line 2319
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 2321
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 2311
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2325
    tcp->csty = parameters->csty;
#line 2326
    tcp->prg = parameters->prog_order;
#line 2327
    tcp->mct = (int )parameters->tcp_mct;
#line 2329
    numpocs_tile = 0;
#line 2330
    tcp->POC = 0;
#line 2331
    if (parameters->numpocs) {
#line 2333
      tcp->POC = 1;
#line 2334
      i = 0;
      {
#line 2334
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2334
        if (! (i < parameters->numpocs)) {
#line 2334
          goto while_break___2;
        }
#line 2335
        if (tileno == parameters->POC[i].tile - 1) {
          _L: /* CIL Label */ 
#line 2336
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 2337
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 2338
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 2339
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 2340
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 2341
          tcp_poc->compno1 = parameters->POC[numpocs_tile].compno1;
#line 2342
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 2343
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 2344
          numpocs_tile ++;
        } else
#line 2335
        if (parameters->POC[i].tile == -1) {
#line 2335
          goto _L;
        }
#line 2334
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2347
      tcp->numpocs = numpocs_tile - 1;
    } else {
#line 2349
      tcp->numpocs = 0;
    }
    {
#line 2352
    __cil_tmp23 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 2352
    tcp->tccps = (opj_tccp_t *)__cil_tmp23;
#line 2354
    i = 0;
    }
    {
#line 2354
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2354
      if (! (i < image->numcomps)) {
#line 2354
        goto while_break___3;
      }
      {
#line 2355
      tccp = tcp->tccps + i;
#line 2356
      tccp->csty = parameters->csty & 1;
#line 2357
      tccp->numresolutions = parameters->numresolution;
#line 2358
      tccp->cblkw = int_floorlog2(parameters->cblockw_init);
#line 2359
      tccp->cblkh = int_floorlog2(parameters->cblockh_init);
#line 2360
      tccp->cblksty = parameters->mode;
      }
#line 2361
      if (parameters->irreversible) {
#line 2361
        tmp = 0;
      } else {
#line 2361
        tmp = 1;
      }
#line 2361
      tccp->qmfbid = tmp;
#line 2362
      if (parameters->irreversible) {
#line 2362
        tmp___0 = 2;
      } else {
#line 2362
        tmp___0 = 0;
      }
#line 2362
      tccp->qntsty = tmp___0;
#line 2363
      tccp->numgbits = 2;
#line 2364
      if (i == parameters->roi_compno) {
#line 2365
        tccp->roishift = parameters->roi_shift;
      } else {
#line 2367
        tccp->roishift = 0;
      }
#line 2370
      if (parameters->cp_cinema) {
#line 2373
        tccp->prcw[0] = 7;
#line 2374
        tccp->prch[0] = 7;
#line 2376
        j = 1;
        {
#line 2376
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2376
          if (! (j < tccp->numresolutions)) {
#line 2376
            goto while_break___4;
          }
#line 2377
          tccp->prcw[j] = 8;
#line 2378
          tccp->prch[j] = 8;
#line 2376
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 2381
      if (parameters->csty & 1) {
#line 2382
        p = 0;
#line 2383
        j = tccp->numresolutions - 1;
        {
#line 2383
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2383
          if (! (j >= 0)) {
#line 2383
            goto while_break___5;
          }
#line 2384
          if (p < parameters->res_spec) {
#line 2386
            if (parameters->prcw_init[p] < 1) {
#line 2387
              tccp->prcw[j] = 1;
            } else {
              {
#line 2389
              tccp->prcw[j] = int_floorlog2(parameters->prcw_init[p]);
              }
            }
#line 2392
            if (parameters->prch_init[p] < 1) {
#line 2393
              tccp->prch[j] = 1;
            } else {
              {
#line 2395
              tccp->prch[j] = int_floorlog2(parameters->prch_init[p]);
              }
            }
          } else {
#line 2399
            res_spec = parameters->res_spec;
#line 2400
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2401
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2403
            if (size_prcw < 1) {
#line 2404
              tccp->prcw[j] = 1;
            } else {
              {
#line 2406
              tccp->prcw[j] = int_floorlog2(size_prcw);
              }
            }
#line 2409
            if (size_prch < 1) {
#line 2410
              tccp->prch[j] = 1;
            } else {
              {
#line 2412
              tccp->prch[j] = int_floorlog2(size_prch);
              }
            }
          }
#line 2415
          p ++;
#line 2383
          __cil_tmp39 = j;
#line 2383
          j --;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 2419
        j = 0;
        {
#line 2419
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2419
          if (! (j < tccp->numresolutions)) {
#line 2419
            goto while_break___6;
          }
#line 2420
          tccp->prcw[j] = 15;
#line 2421
          tccp->prch[j] = 15;
#line 2419
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 2426
      dwt_calc_explicit_stepsizes(tccp, (image->comps + i)->prec);
      }
#line 2354
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2308
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 2431 "/root/patchweave_new/14/libopenjpeg/j2k.c"
opj_bool j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int tileno ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcd_t *tcd ;
  int compno___15 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  opj_tcp_t *tcp ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_tcd_t *__cil_tmp20 ;
  int pino ;
  int tilepartno ;
  int acc_pack_num ;
  opj_tcp_t *tcp___0 ;
  int __cil_tmp25 ;
  void *__cil_tmp26 ;
  int tot_num_tp ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;

  {
#line 2433
  cp = (opj_cp_t *)((void *)0);
#line 2435
  tcd = (opj_tcd_t *)((void *)0);
#line 2437
  j2k->cio = cio;
#line 2438
  j2k->image = image;
#line 2440
  cp = j2k->cp;
#line 2443
  j2k->cstr_info = cstr_info;
#line 2444
  if (cstr_info) {
    {
#line 2446
    __cil_tmp10 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(opj_tile_info_t ));
#line 2446
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp10;
#line 2447
    cstr_info->image_w = image->x1 - image->x0;
#line 2448
    cstr_info->image_h = image->y1 - image->y0;
#line 2449
    cstr_info->prog = (cp->tcps + 0)->prg;
#line 2450
    cstr_info->tw = cp->tw;
#line 2451
    cstr_info->th = cp->th;
#line 2452
    cstr_info->tile_x = cp->tdx;
#line 2453
    cstr_info->tile_y = cp->tdy;
#line 2454
    cstr_info->tile_Ox = cp->tx0;
#line 2455
    cstr_info->tile_Oy = cp->ty0;
#line 2456
    cstr_info->numcomps = image->numcomps;
#line 2457
    cstr_info->numlayers = (cp->tcps + 0)->numlayers;
#line 2458
    __cil_tmp11 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 2458
    cstr_info->numdecompos = (int *)__cil_tmp11;
#line 2459
    compno___15 = 0;
    }
    {
#line 2459
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2459
      if (! (compno___15 < image->numcomps)) {
#line 2459
        goto while_break;
      }
#line 2460
      *(cstr_info->numdecompos + compno___15) = ((cp->tcps + 0)->tccps)->numresolutions - 1;
#line 2459
      compno___15 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2462
    cstr_info->D_max = 0.;
#line 2463
    cstr_info->main_head_start = cio_tell(cio);
#line 2464
    cstr_info->maxmarknum = 100;
#line 2465
    __cil_tmp14 = malloc((unsigned long )cstr_info->maxmarknum * sizeof(opj_marker_info_t ));
#line 2465
    cstr_info->marker = (opj_marker_info_t *)__cil_tmp14;
#line 2466
    cstr_info->marknum = 0;
    }
  }
  {
#line 2470
  j2k_write_soc(j2k);
#line 2471
  j2k_write_siz(j2k);
#line 2472
  j2k_write_cod(j2k);
#line 2473
  j2k_write_qcd(j2k);
  }
#line 2475
  if (cp->cinema) {
#line 2476
    compno = 1;
    {
#line 2476
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2476
      if (! (compno < image->numcomps)) {
#line 2476
        goto while_break___0;
      }
      {
#line 2477
      j2k_write_coc(j2k, compno);
#line 2478
      j2k_write_qcc(j2k, compno);
      }
#line 2476
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2482
  compno = 0;
  {
#line 2482
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2482
    if (! (compno < image->numcomps)) {
#line 2482
      goto while_break___1;
    }
#line 2483
    tcp = cp->tcps + 0;
#line 2484
    if ((tcp->tccps + compno)->roishift) {
      {
#line 2485
      j2k_write_rgn(j2k, compno, 0);
      }
    }
#line 2482
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2487
  if (cp->comment != (void *)0) {
    {
#line 2488
    j2k_write_com(j2k);
    }
  }
  {
#line 2491
  j2k->totnum_tp = j2k_calculate_tp(cp, image->numcomps, image, j2k);
  }
#line 2493
  if (cp->cinema) {
    {
#line 2494
    j2k_write_tlm(j2k);
    }
#line 2495
    if ((unsigned int )cp->cinema == 3U) {
      {
#line 2496
      j2k_write_poc(j2k);
      }
    }
  }
#line 2504
  if (cstr_info) {
    {
#line 2505
    __cil_tmp19 = cio_tell(cio);
#line 2505
    cstr_info->main_head_end = __cil_tmp19 - 1;
    }
  }
  {
#line 2511
  tcd = tcd_create(j2k->cinfo);
#line 2514
  tileno = 0;
  }
  {
#line 2514
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2514
    if (! (tileno < cp->tw * cp->th)) {
#line 2514
      goto while_break___2;
    }
    {
#line 2516
    tilepartno = 0;
#line 2518
    acc_pack_num = 0;
#line 2522
    tcp___0 = cp->tcps + tileno;
#line 2523
    opj_event_msg(j2k->cinfo, 4, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th);
#line 2525
    j2k->curtileno = tileno;
#line 2526
    j2k->cur_tp_num = 0;
#line 2527
    tcd->cur_totnum_tp = *(j2k->cur_totnum_tp + j2k->curtileno);
    }
#line 2529
    if (tileno == 0) {
      {
#line 2530
      tcd_malloc_encode(tcd, image, cp, j2k->curtileno);
      }
    } else {
      {
#line 2532
      tcd_init_encode(tcd, image, cp, j2k->curtileno);
      }
    }
#line 2536
    if (cstr_info) {
      {
#line 2537
      __cil_tmp25 = cio_tell(cio);
#line 2537
      (cstr_info->tile + j2k->curtileno)->start_pos = __cil_tmp25 + j2k->pos_correction;
#line 2538
      (cstr_info->tile + j2k->curtileno)->maxmarknum = 10;
#line 2539
      __cil_tmp26 = malloc((unsigned long )(cstr_info->tile + j2k->curtileno)->maxmarknum * sizeof(opj_marker_info_t ));
#line 2539
      (cstr_info->tile + j2k->curtileno)->marker = (opj_marker_info_t *)__cil_tmp26;
#line 2540
      (cstr_info->tile + j2k->curtileno)->marknum = 0;
      }
    }
#line 2544
    pino = 0;
    {
#line 2544
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2544
      if (! (pino <= tcp___0->numpocs)) {
#line 2544
        goto while_break___3;
      }
      {
#line 2546
      tcd->cur_pino = pino;
#line 2549
      tot_num_tp = j2k_get_num_tp(cp, pino, tileno);
#line 2550
      tcd->tp_pos = cp->tp_pos;
#line 2552
      tilepartno = 0;
      }
      {
#line 2552
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2552
        if (! (tilepartno < tot_num_tp)) {
#line 2552
          goto while_break___4;
        }
#line 2553
        j2k->tp_num = tilepartno;
#line 2555
        if (cstr_info) {
          {
#line 2556
          __cil_tmp29 = cio_tell(cio);
#line 2556
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pos = __cil_tmp29 + j2k->pos_correction;
          }
        }
        {
#line 2559
        j2k_write_sot(j2k);
        }
#line 2561
        if (j2k->cur_tp_num == 0) {
#line 2561
          if ((unsigned int )cp->cinema == 0U) {
#line 2562
            compno = 1;
            {
#line 2562
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 2562
              if (! (compno < image->numcomps)) {
#line 2562
                goto while_break___5;
              }
              {
#line 2563
              j2k_write_coc(j2k, compno);
#line 2564
              j2k_write_qcc(j2k, compno);
              }
#line 2562
              compno ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 2566
            if ((cp->tcps + tileno)->numpocs) {
              {
#line 2567
              j2k_write_poc(j2k);
              }
            }
          }
        }
#line 2572
        if (cstr_info) {
          {
#line 2573
          __cil_tmp31 = cio_tell(cio);
#line 2573
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp31 + j2k->pos_correction) + 1;
          }
        }
        {
#line 2577
        j2k_write_sod(j2k, tcd);
        }
#line 2580
        if (cstr_info) {
          {
#line 2581
          __cil_tmp32 = cio_tell(cio);
#line 2581
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_pos = (__cil_tmp32 + j2k->pos_correction) - 1;
#line 2583
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pack = acc_pack_num;
#line 2585
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_numpacks = cstr_info->packno - acc_pack_num;
#line 2587
          acc_pack_num = cstr_info->packno;
          }
        }
#line 2591
        (j2k->cur_tp_num) ++;
#line 2552
        tilepartno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2544
      pino ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2594
    if (cstr_info) {
      {
#line 2595
      __cil_tmp36 = cio_tell(cio);
#line 2595
      (cstr_info->tile + j2k->curtileno)->end_pos = (__cil_tmp36 + j2k->pos_correction) - 1;
      }
    }
#line 2514
    tileno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2618
  tcd_free_encode(tcd);
#line 2619
  tcd_destroy(tcd);
#line 2621
  free(j2k->cur_totnum_tp);
#line 2623
  j2k_write_eoc(j2k);
  }
#line 2625
  if (cstr_info) {
    {
#line 2626
    __cil_tmp38 = cio_tell(cio);
#line 2626
    cstr_info->codestream_size = __cil_tmp38 + j2k->pos_correction;
#line 2631
    cstr_info->codestream_size -= cstr_info->main_head_start;
    }
  }
#line 2647
  return (1);
}
}
#line 2650 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) 
{ 
  void *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 2652
  if (! cstr_info) {
#line 2653
    return;
  }
#line 2656
  if (cstr_info->marknum + 1 > cstr_info->maxmarknum) {
    {
#line 2657
    cstr_info->maxmarknum = 100 + (int )((float )cstr_info->maxmarknum * 1.f);
#line 2658
    __cil_tmp5 = realloc(cstr_info->marker, (unsigned long )cstr_info->maxmarknum);
#line 2658
    cstr_info->marker = (opj_marker_info_t *)__cil_tmp5;
    }
  }
#line 2662
  (cstr_info->marker + cstr_info->marknum)->type = type;
#line 2663
  (cstr_info->marker + cstr_info->marknum)->pos = pos;
#line 2664
  (cstr_info->marker + cstr_info->marknum)->len = len;
#line 2665
  (cstr_info->marknum) ++;
  return;
}
}
#line 2669 "/root/patchweave_new/14/libopenjpeg/j2k.c"
static void j2k_add_tlmarker(int tileno , opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) 
{ 
  opj_marker_info_t *marker ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 2673
  if (! cstr_info) {
#line 2674
    return;
  }
#line 2677
  if ((cstr_info->tile + tileno)->marknum + 1 > (cstr_info->tile + tileno)->maxmarknum) {
    {
#line 2678
    (cstr_info->tile + tileno)->maxmarknum = 100 + (int )((float )(cstr_info->tile + tileno)->maxmarknum * 1.f);
#line 2679
    __cil_tmp7 = realloc((cstr_info->tile + tileno)->marker, (unsigned long )cstr_info->maxmarknum);
#line 2679
    (cstr_info->tile + tileno)->marker = (opj_marker_info_t *)__cil_tmp7;
    }
  }
#line 2682
  marker = (cstr_info->tile + tileno)->marker + (cstr_info->tile + tileno)->marknum;
#line 2685
  marker->type = type;
#line 2686
  marker->pos = pos;
#line 2687
  marker->len = len;
#line 2688
  ((cstr_info->tile + tileno)->marknum) ++;
  return;
}
}
#line 29 "/root/patchweave_new/14/libopenjpeg/image.c"
opj_image_t *opj_image_create0(void) 
{ 
  opj_image_t *image ;
  void *__cil_tmp2 ;

  {
  {
#line 30
  __cil_tmp2 = calloc((unsigned long )1, sizeof(opj_image_t ));
#line 30
  image = (opj_image_t *)__cil_tmp2;
  }
#line 31
  return (image);
}
}
#line 34 "/root/patchweave_new/14/libopenjpeg/image.c"
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) 
{ 
  int compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 36
  image = (opj_image_t *)((void *)0);
#line 38
  __cil_tmp6 = calloc((unsigned long )1, sizeof(opj_image_t ));
#line 38
  image = (opj_image_t *)__cil_tmp6;
  }
#line 39
  if (image) {
    {
#line 40
    image->color_space = clrspc;
#line 41
    image->numcomps = numcmpts;
#line 43
    __cil_tmp7 = calloc((unsigned long )1, (unsigned long )image->numcomps * sizeof(opj_image_comp_t ));
#line 43
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 44
    if (! image->comps) {
      {
#line 45
      fprintf(stderr, "Unable to allocate memory for image.\n");
#line 46
      opj_image_destroy(image);
      }
#line 47
      return ((opj_image_t *)((void *)0));
    }
#line 50
    compno = 0;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (compno < numcmpts)) {
#line 50
        goto while_break;
      }
      {
#line 51
      comp = image->comps + compno;
#line 52
      comp->dx = (cmptparms + compno)->dx;
#line 53
      comp->dy = (cmptparms + compno)->dy;
#line 54
      comp->w = (cmptparms + compno)->w;
#line 55
      comp->h = (cmptparms + compno)->h;
#line 56
      comp->x0 = (cmptparms + compno)->x0;
#line 57
      comp->y0 = (cmptparms + compno)->y0;
#line 58
      comp->prec = (cmptparms + compno)->prec;
#line 59
      comp->bpp = (cmptparms + compno)->bpp;
#line 60
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 61
      __cil_tmp9 = calloc((unsigned long )(comp->w * comp->h), sizeof(int ));
#line 61
      comp->data = (int *)__cil_tmp9;
      }
#line 62
      if (! comp->data) {
        {
#line 63
        fprintf(stderr, "Unable to allocate memory for image.\n");
#line 64
        opj_image_destroy(image);
        }
#line 65
        return ((opj_image_t *)((void *)0));
      }
#line 50
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 70
  return (image);
}
}
#line 73 "/root/patchweave_new/14/libopenjpeg/image.c"
void opj_image_destroy(opj_image_t *image ) 
{ 
  int i ;
  opj_image_comp_t *image_comp ;
  int __cil_tmp4 ;

  {
#line 75
  if (image) {
#line 76
    if (image->comps) {
#line 78
      i = 0;
      {
#line 78
      while (1) {
        while_continue: /* CIL Label */ ;
#line 78
        if (! (i < image->numcomps)) {
#line 78
          goto while_break;
        }
#line 79
        image_comp = image->comps + i;
#line 80
        if (image_comp->data) {
          {
#line 81
          free(image_comp->data);
          }
        }
#line 78
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 84
      free(image->comps);
      }
    }
    {
#line 86
    free(image);
    }
  }
  return;
}
}
#line 65 "/root/patchweave_new/14/libopenjpeg/event.c"
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) 
{ 
  opj_event_mgr_t *previous ;

  {
#line 66
  if (cinfo) {
#line 67
    previous = cinfo->event_mgr;
#line 68
    cinfo->event_mgr = event_mgr;
#line 69
    cinfo->client_data = context;
#line 70
    return (previous);
  }
#line 73
  return ((opj_event_mgr_t *)((void *)0));
}
}
#line 76 "/root/patchweave_new/14/libopenjpeg/event.c"
opj_bool opj_event_msg(opj_common_ptr cinfo , int event_type , char const   *fmt 
                       , ...) 
{ 
  opj_msg_callback msg_handler ;
  opj_event_mgr_t *event_mgr ;
  va_list arg ;
  int str_length ;
  char message[512] ;
  int __cil_tmp9 ;

  {
#line 78
  msg_handler = (opj_msg_callback )((void *)0);
#line 80
  event_mgr = cinfo->event_mgr;
#line 81
  if (event_mgr != (void *)0) {
    {
#line 83
    if (event_type == 1) {
#line 83
      goto case_1;
    }
#line 86
    if (event_type == 2) {
#line 86
      goto case_2;
    }
#line 89
    if (event_type == 4) {
#line 89
      goto case_4;
    }
#line 92
    goto switch_default;
    case_1: /* CIL Label */ 
#line 84
    msg_handler = event_mgr->error_handler;
#line 85
    goto switch_break;
    case_2: /* CIL Label */ 
#line 87
    msg_handler = event_mgr->warning_handler;
#line 88
    goto switch_break;
    case_4: /* CIL Label */ 
#line 90
    msg_handler = event_mgr->info_handler;
#line 91
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 93
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 95
    if (msg_handler == (void *)0) {
#line 96
      return (0);
    }
  } else {
#line 99
    return (0);
  }
#line 102
  if (fmt != (void *)0) {
#line 102
    if (event_mgr != (void *)0) {
      {
#line 107
      __builtin_va_start((void *)arg, fmt);
#line 109
      str_length = vsnprintf((char *)message, (unsigned long )512, fmt, (void *)arg);
#line 111
      __builtin_va_end((void *)arg);
      }
#line 114
      if (str_length > -1) {
#line 114
        if (str_length < 512) {
          {
#line 115
          (*msg_handler)((char const   *)((char *)message), cinfo->client_data);
          }
        } else {
#line 116
          return (0);
        }
      } else {
#line 116
        return (0);
      }
    }
  }
#line 119
  return (1);
}
}
#line 67 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static float const   dwt_alpha  =    1.58613431454f;
#line 68 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static float const   dwt_beta  =    0.0529801174999f;
#line 69 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static float const   dwt_gamma  =    - 0.882911086083f;
#line 70 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static float const   dwt_delta  =    - 0.443506866694f;
#line 72 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static float const   K  =    1.23017406464f;
#line 74 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static float const   c13318  =    1.62573242188f;
#line 89
static void dwt_deinterleave_h(int *a , int *b , int dn , int sn , int cas ) ;
#line 93
static void dwt_deinterleave_v(int *a , int *b , int dn , int sn , int x , int cas ) ;
#line 97
static void dwt_interleave_h(dwt_t *h , int *a ) ;
#line 101
static void dwt_interleave_v(dwt_t *v , int *a , int x ) ;
#line 105
static void dwt_encode_1(int *a , int dn , int sn , int cas ) ;
#line 109
static void dwt_decode_1(dwt_t *v ) ;
#line 113
static void dwt_encode_1_real(int *a , int dn , int sn , int cas ) ;
#line 117
static void dwt_encode_stepsize(int stepsize , int numbps , opj_stepsize_t *bandno_stepsize ) ;
#line 121
static void dwt_decode_tile(opj_tcd_tilecomp_t *tilec , int numres , DWT1DFN dwt_1D ) ;
#line 138 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static double const   dwt_norms[4][10]  = { {        1.,        1.5,        2.75,        5.375, 
            10.68,        21.34,        42.6700000001,        85.33, 
            170.7,        341.300000001}, 
   {        1.03800000001,        1.59200000001,        2.91900000001,        5.70300000001, 
            11.3300000001,        22.6400000001,        45.25,        90.4800000001, 
            180.900000001}, 
   {        1.03800000001,        1.59200000001,        2.91900000001,        5.70300000001, 
            11.3300000001,        22.6400000001,        45.25,        90.4800000001, 
            180.900000001}, 
   {        0.718600000001,        0.9218,        1.58600000001,        3.04300000001, 
            6.01900000001,        12.01,        24.,        47.97, 
            95.9300000001}};
#line 148 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static double const   dwt_norms_real[4][10]  = { {        1.,        1.96500000001,        4.177,        8.40300000001, 
            16.9,        33.8400000001,        67.69,        135.300000001, 
            270.600000001,        540.9}, 
   {        2.022,        3.989,        8.35500000001,        17.04, 
            34.2700000001,        68.63,        137.300000001,        274.600000001, 
            549.}, 
   {        2.022,        3.989,        8.35500000001,        17.04, 
            34.2700000001,        68.63,        137.300000001,        274.600000001, 
            549.}, 
   {        2.08000000001,        3.86500000001,        8.30700000001,        17.18, 
            34.7100000001,        69.5900000001,        139.300000001,        278.600000001, 
            557.200000001}};
#line 164 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void dwt_deinterleave_h(int *a , int *b , int dn , int sn , int cas ) 
{ 
  int i ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 166
  i = 0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (i < sn)) {
#line 166
      goto while_break;
    }
#line 166
    *(b + i) = *(a + (2 * i + cas));
#line 166
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  i = 0;
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (i < dn)) {
#line 167
      goto while_break___0;
    }
#line 167
    *(b + (sn + i)) = *(a + ((2 * i + 1) - cas));
#line 167
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 173 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void dwt_deinterleave_v(int *a , int *b , int dn , int sn , int x , int cas ) 
{ 
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < sn)) {
#line 175
      goto while_break;
    }
#line 175
    *(b + i * x) = *(a + (2 * i + cas));
#line 175
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 176
    if (! (i < dn)) {
#line 176
      goto while_break___0;
    }
#line 176
    *(b + (sn + i) * x) = *(a + ((2 * i + 1) - cas));
#line 176
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 182 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void dwt_interleave_h(dwt_t *h , int *a ) 
{ 
  int *ai ;
  int *bi ;
  int i ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;
  int __cil_tmp8 ;
  int *__cil_tmp9 ;

  {
#line 183
  ai = a;
#line 184
  bi = h->mem + h->cas;
#line 185
  i = h->sn;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    __cil_tmp6 = i;
#line 186
    i --;
#line 186
    if (! __cil_tmp6) {
#line 186
      goto while_break;
    }
#line 187
    __cil_tmp7 = ai;
#line 187
    ai ++;
#line 187
    *bi = *__cil_tmp7;
#line 188
    bi += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  ai = a + h->sn;
#line 191
  bi = (h->mem + 1) - h->cas;
#line 192
  i = h->dn;
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 193
    __cil_tmp8 = i;
#line 193
    i --;
#line 193
    if (! __cil_tmp8) {
#line 193
      goto while_break___0;
    }
#line 194
    __cil_tmp9 = ai;
#line 194
    ai ++;
#line 194
    *bi = *__cil_tmp9;
#line 195
    bi += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 202 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void dwt_interleave_v(dwt_t *v , int *a , int x ) 
{ 
  int *ai ;
  int *bi ;
  int i ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 203
  ai = a;
#line 204
  bi = v->mem + v->cas;
#line 205
  i = v->sn;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    __cil_tmp7 = i;
#line 206
    i --;
#line 206
    if (! __cil_tmp7) {
#line 206
      goto while_break;
    }
#line 207
    *bi = *ai;
#line 208
    bi += 2;
#line 209
    ai += x;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  ai = a + v->sn * x;
#line 212
  bi = (v->mem + 1) - v->cas;
#line 213
  i = v->dn;
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 214
    __cil_tmp8 = i;
#line 214
    i --;
#line 214
    if (! __cil_tmp8) {
#line 214
      goto while_break___0;
    }
#line 215
    *bi = *ai;
#line 216
    bi += 2;
#line 217
    ai += x;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 225 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void dwt_encode_1(int *a , int dn , int sn , int cas ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp10 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int __cil_tmp15 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int __cil_tmp20 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int __cil_tmp25 ;

  {
#line 228
  if (! cas) {
#line 229
    if (dn > 0) {
      _L: /* CIL Label */ 
#line 230
      i = 0;
      {
#line 230
      while (1) {
        while_continue: /* CIL Label */ ;
#line 230
        if (! (i < dn)) {
#line 230
          goto while_break;
        }
#line 230
        if (i + 1 < 0) {
#line 230
          tmp___2 = *(a + 0);
        } else {
#line 230
          if (i + 1 >= sn) {
#line 230
            tmp___1 = *(a + (sn - 1) * 2);
          } else {
#line 230
            tmp___1 = *(a + (i + 1) * 2);
          }
#line 230
          tmp___2 = tmp___1;
        }
#line 230
        if (i < 0) {
#line 230
          tmp___0 = *(a + 0);
        } else {
#line 230
          if (i >= sn) {
#line 230
            tmp = *(a + (sn - 1) * 2);
          } else {
#line 230
            tmp = *(a + i * 2);
          }
#line 230
          tmp___0 = tmp;
        }
#line 230
        *(a + (1 + i * 2)) -= (tmp___0 + tmp___2) >> 1;
#line 230
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 231
      i = 0;
      {
#line 231
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 231
        if (! (i < sn)) {
#line 231
          goto while_break___0;
        }
#line 231
        if (i < 0) {
#line 231
          tmp___6 = *(a + 1);
        } else {
#line 231
          if (i >= dn) {
#line 231
            tmp___5 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 231
            tmp___5 = *(a + (1 + i * 2));
          }
#line 231
          tmp___6 = tmp___5;
        }
#line 231
        if (i - 1 < 0) {
#line 231
          tmp___4 = *(a + 1);
        } else {
#line 231
          if (i - 1 >= dn) {
#line 231
            tmp___3 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 231
            tmp___3 = *(a + (1 + (i - 1) * 2));
          }
#line 231
          tmp___4 = tmp___3;
        }
#line 231
        *(a + i * 2) += ((tmp___4 + tmp___6) + 2) >> 2;
#line 231
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 229
    if (sn > 1) {
#line 229
      goto _L;
    }
  } else
#line 234
  if (! sn) {
#line 234
    if (dn == 1) {
#line 235
      *(a + 0) *= 2;
    } else {
#line 234
      goto _L___16;
    }
  } else {
    _L___16: /* CIL Label */ 
#line 237
    i = 0;
    {
#line 237
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 237
      if (! (i < dn)) {
#line 237
        goto while_break___1;
      }
#line 237
      if (i - 1 < 0) {
#line 237
        tmp___10 = *(a + 1);
      } else {
#line 237
        if (i - 1 >= sn) {
#line 237
          tmp___9 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 237
          tmp___9 = *(a + (1 + (i - 1) * 2));
        }
#line 237
        tmp___10 = tmp___9;
      }
#line 237
      if (i < 0) {
#line 237
        tmp___8 = *(a + 1);
      } else {
#line 237
        if (i >= sn) {
#line 237
          tmp___7 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 237
          tmp___7 = *(a + (1 + i * 2));
        }
#line 237
        tmp___8 = tmp___7;
      }
#line 237
      *(a + i * 2) -= (tmp___8 + tmp___10) >> 1;
#line 237
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 238
    i = 0;
    {
#line 238
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 238
      if (! (i < sn)) {
#line 238
        goto while_break___2;
      }
#line 238
      if (i + 1 < 0) {
#line 238
        tmp___14 = *(a + 0);
      } else {
#line 238
        if (i + 1 >= dn) {
#line 238
          tmp___13 = *(a + (dn - 1) * 2);
        } else {
#line 238
          tmp___13 = *(a + (i + 1) * 2);
        }
#line 238
        tmp___14 = tmp___13;
      }
#line 238
      if (i < 0) {
#line 238
        tmp___12 = *(a + 0);
      } else {
#line 238
        if (i >= dn) {
#line 238
          tmp___11 = *(a + (dn - 1) * 2);
        } else {
#line 238
          tmp___11 = *(a + i * 2);
        }
#line 238
        tmp___12 = tmp___11;
      }
#line 238
      *(a + (1 + i * 2)) += ((tmp___12 + tmp___14) + 2) >> 2;
#line 238
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 246 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void dwt_decode_1_(int *a , int dn , int sn , int cas ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp10 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int __cil_tmp15 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int __cil_tmp20 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int __cil_tmp25 ;

  {
#line 249
  if (! cas) {
#line 250
    if (dn > 0) {
      _L: /* CIL Label */ 
#line 251
      i = 0;
      {
#line 251
      while (1) {
        while_continue: /* CIL Label */ ;
#line 251
        if (! (i < sn)) {
#line 251
          goto while_break;
        }
#line 251
        if (i < 0) {
#line 251
          tmp___2 = *(a + 1);
        } else {
#line 251
          if (i >= dn) {
#line 251
            tmp___1 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 251
            tmp___1 = *(a + (1 + i * 2));
          }
#line 251
          tmp___2 = tmp___1;
        }
#line 251
        if (i - 1 < 0) {
#line 251
          tmp___0 = *(a + 1);
        } else {
#line 251
          if (i - 1 >= dn) {
#line 251
            tmp = *(a + (1 + (dn - 1) * 2));
          } else {
#line 251
            tmp = *(a + (1 + (i - 1) * 2));
          }
#line 251
          tmp___0 = tmp;
        }
#line 251
        *(a + i * 2) -= ((tmp___0 + tmp___2) + 2) >> 2;
#line 251
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 252
      i = 0;
      {
#line 252
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 252
        if (! (i < dn)) {
#line 252
          goto while_break___0;
        }
#line 252
        if (i + 1 < 0) {
#line 252
          tmp___6 = *(a + 0);
        } else {
#line 252
          if (i + 1 >= sn) {
#line 252
            tmp___5 = *(a + (sn - 1) * 2);
          } else {
#line 252
            tmp___5 = *(a + (i + 1) * 2);
          }
#line 252
          tmp___6 = tmp___5;
        }
#line 252
        if (i < 0) {
#line 252
          tmp___4 = *(a + 0);
        } else {
#line 252
          if (i >= sn) {
#line 252
            tmp___3 = *(a + (sn - 1) * 2);
          } else {
#line 252
            tmp___3 = *(a + i * 2);
          }
#line 252
          tmp___4 = tmp___3;
        }
#line 252
        *(a + (1 + i * 2)) += (tmp___4 + tmp___6) >> 1;
#line 252
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 250
    if (sn > 1) {
#line 250
      goto _L;
    }
  } else
#line 255
  if (! sn) {
#line 255
    if (dn == 1) {
#line 256
      *(a + 0) /= 2;
    } else {
#line 255
      goto _L___17;
    }
  } else {
    _L___17: /* CIL Label */ 
#line 258
    i = 0;
    {
#line 258
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 258
      if (! (i < sn)) {
#line 258
        goto while_break___1;
      }
#line 258
      if (i + 1 < 0) {
#line 258
        tmp___10 = *(a + 0);
      } else {
#line 258
        if (i + 1 >= dn) {
#line 258
          tmp___9 = *(a + (dn - 1) * 2);
        } else {
#line 258
          tmp___9 = *(a + (i + 1) * 2);
        }
#line 258
        tmp___10 = tmp___9;
      }
#line 258
      if (i < 0) {
#line 258
        tmp___8 = *(a + 0);
      } else {
#line 258
        if (i >= dn) {
#line 258
          tmp___7 = *(a + (dn - 1) * 2);
        } else {
#line 258
          tmp___7 = *(a + i * 2);
        }
#line 258
        tmp___8 = tmp___7;
      }
#line 258
      *(a + (1 + i * 2)) -= ((tmp___8 + tmp___10) + 2) >> 2;
#line 258
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 259
    i = 0;
    {
#line 259
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 259
      if (! (i < dn)) {
#line 259
        goto while_break___2;
      }
#line 259
      if (i - 1 < 0) {
#line 259
        tmp___14 = *(a + 1);
      } else {
#line 259
        if (i - 1 >= sn) {
#line 259
          tmp___13 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 259
          tmp___13 = *(a + (1 + (i - 1) * 2));
        }
#line 259
        tmp___14 = tmp___13;
      }
#line 259
      if (i < 0) {
#line 259
        tmp___12 = *(a + 1);
      } else {
#line 259
        if (i >= sn) {
#line 259
          tmp___11 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 259
          tmp___11 = *(a + (1 + i * 2));
        }
#line 259
        tmp___12 = tmp___11;
      }
#line 259
      *(a + i * 2) += (tmp___12 + tmp___14) >> 1;
#line 259
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 267 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void dwt_decode_1(dwt_t *v ) 
{ 


  {
  {
#line 268
  dwt_decode_1_(v->mem, v->dn, v->sn, v->cas);
  }
  return;
}
}
#line 274 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void dwt_encode_1_real(int *a , int dn , int sn , int cas ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;

  {
#line 276
  if (! cas) {
#line 277
    if (dn > 0) {
      _L: /* CIL Label */ 
#line 278
      i = 0;
      {
#line 278
      while (1) {
        while_continue: /* CIL Label */ ;
#line 278
        if (! (i < dn)) {
#line 278
          goto while_break;
        }
#line 279
        if (i + 1 < 0) {
#line 279
          tmp___2 = *(a + 0);
        } else {
#line 279
          if (i + 1 >= sn) {
#line 279
            tmp___1 = *(a + (sn - 1) * 2);
          } else {
#line 279
            tmp___1 = *(a + (i + 1) * 2);
          }
#line 279
          tmp___2 = tmp___1;
        }
#line 279
        if (i < 0) {
#line 279
          tmp___0 = *(a + 0);
        } else {
#line 279
          if (i >= sn) {
#line 279
            tmp = *(a + (sn - 1) * 2);
          } else {
#line 279
            tmp = *(a + i * 2);
          }
#line 279
          tmp___0 = tmp;
        }
        {
#line 279
        __cil_tmp10 = fix_mul(tmp___0 + tmp___2, 12993);
        }
#line 279
        *(a + (1 + i * 2)) -= __cil_tmp10;
#line 278
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 280
      i = 0;
      {
#line 280
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 280
        if (! (i < sn)) {
#line 280
          goto while_break___0;
        }
#line 281
        if (i < 0) {
#line 281
          tmp___6 = *(a + 1);
        } else {
#line 281
          if (i >= dn) {
#line 281
            tmp___5 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 281
            tmp___5 = *(a + (1 + i * 2));
          }
#line 281
          tmp___6 = tmp___5;
        }
#line 281
        if (i - 1 < 0) {
#line 281
          tmp___4 = *(a + 1);
        } else {
#line 281
          if (i - 1 >= dn) {
#line 281
            tmp___3 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 281
            tmp___3 = *(a + (1 + (i - 1) * 2));
          }
#line 281
          tmp___4 = tmp___3;
        }
        {
#line 281
        __cil_tmp16 = fix_mul(tmp___4 + tmp___6, 434);
        }
#line 281
        *(a + i * 2) -= __cil_tmp16;
#line 280
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 282
      i = 0;
      {
#line 282
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 282
        if (! (i < dn)) {
#line 282
          goto while_break___1;
        }
#line 283
        if (i + 1 < 0) {
#line 283
          tmp___10 = *(a + 0);
        } else {
#line 283
          if (i + 1 >= sn) {
#line 283
            tmp___9 = *(a + (sn - 1) * 2);
          } else {
#line 283
            tmp___9 = *(a + (i + 1) * 2);
          }
#line 283
          tmp___10 = tmp___9;
        }
#line 283
        if (i < 0) {
#line 283
          tmp___8 = *(a + 0);
        } else {
#line 283
          if (i >= sn) {
#line 283
            tmp___7 = *(a + (sn - 1) * 2);
          } else {
#line 283
            tmp___7 = *(a + i * 2);
          }
#line 283
          tmp___8 = tmp___7;
        }
        {
#line 283
        __cil_tmp22 = fix_mul(tmp___8 + tmp___10, 7233);
        }
#line 283
        *(a + (1 + i * 2)) += __cil_tmp22;
#line 282
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 284
      i = 0;
      {
#line 284
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 284
        if (! (i < sn)) {
#line 284
          goto while_break___2;
        }
#line 285
        if (i < 0) {
#line 285
          tmp___14 = *(a + 1);
        } else {
#line 285
          if (i >= dn) {
#line 285
            tmp___13 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 285
            tmp___13 = *(a + (1 + i * 2));
          }
#line 285
          tmp___14 = tmp___13;
        }
#line 285
        if (i - 1 < 0) {
#line 285
          tmp___12 = *(a + 1);
        } else {
#line 285
          if (i - 1 >= dn) {
#line 285
            tmp___11 = *(a + (1 + (dn - 1) * 2));
          } else {
#line 285
            tmp___11 = *(a + (1 + (i - 1) * 2));
          }
#line 285
          tmp___12 = tmp___11;
        }
        {
#line 285
        __cil_tmp28 = fix_mul(tmp___12 + tmp___14, 3633);
        }
#line 285
        *(a + i * 2) += __cil_tmp28;
#line 284
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 286
      i = 0;
      {
#line 286
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 286
        if (! (i < dn)) {
#line 286
          goto while_break___3;
        }
        {
#line 287
        *(a + (1 + i * 2)) = fix_mul(*(a + (1 + i * 2)), 5038);
        }
#line 286
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 288
      i = 0;
      {
#line 288
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 288
        if (! (i < sn)) {
#line 288
          goto while_break___4;
        }
        {
#line 289
        *(a + i * 2) = fix_mul(*(a + i * 2), 6659);
        }
#line 288
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 277
    if (sn > 1) {
#line 277
      goto _L;
    }
  } else
#line 292
  if (sn > 0) {
    _L___18: /* CIL Label */ 
#line 293
    i = 0;
    {
#line 293
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 293
      if (! (i < dn)) {
#line 293
        goto while_break___5;
      }
#line 294
      if (i - 1 < 0) {
#line 294
        tmp___18 = *(a + 1);
      } else {
#line 294
        if (i - 1 >= sn) {
#line 294
          tmp___17 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 294
          tmp___17 = *(a + (1 + (i - 1) * 2));
        }
#line 294
        tmp___18 = tmp___17;
      }
#line 294
      if (i < 0) {
#line 294
        tmp___16 = *(a + 1);
      } else {
#line 294
        if (i >= sn) {
#line 294
          tmp___15 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 294
          tmp___15 = *(a + (1 + i * 2));
        }
#line 294
        tmp___16 = tmp___15;
      }
      {
#line 294
      __cil_tmp38 = fix_mul(tmp___16 + tmp___18, 12993);
      }
#line 294
      *(a + i * 2) -= __cil_tmp38;
#line 293
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 295
    i = 0;
    {
#line 295
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 295
      if (! (i < sn)) {
#line 295
        goto while_break___6;
      }
#line 296
      if (i + 1 < 0) {
#line 296
        tmp___22 = *(a + 0);
      } else {
#line 296
        if (i + 1 >= dn) {
#line 296
          tmp___21 = *(a + (dn - 1) * 2);
        } else {
#line 296
          tmp___21 = *(a + (i + 1) * 2);
        }
#line 296
        tmp___22 = tmp___21;
      }
#line 296
      if (i < 0) {
#line 296
        tmp___20 = *(a + 0);
      } else {
#line 296
        if (i >= dn) {
#line 296
          tmp___19 = *(a + (dn - 1) * 2);
        } else {
#line 296
          tmp___19 = *(a + i * 2);
        }
#line 296
        tmp___20 = tmp___19;
      }
      {
#line 296
      __cil_tmp44 = fix_mul(tmp___20 + tmp___22, 434);
      }
#line 296
      *(a + (1 + i * 2)) -= __cil_tmp44;
#line 295
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 297
    i = 0;
    {
#line 297
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 297
      if (! (i < dn)) {
#line 297
        goto while_break___7;
      }
#line 298
      if (i - 1 < 0) {
#line 298
        tmp___26 = *(a + 1);
      } else {
#line 298
        if (i - 1 >= sn) {
#line 298
          tmp___25 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 298
          tmp___25 = *(a + (1 + (i - 1) * 2));
        }
#line 298
        tmp___26 = tmp___25;
      }
#line 298
      if (i < 0) {
#line 298
        tmp___24 = *(a + 1);
      } else {
#line 298
        if (i >= sn) {
#line 298
          tmp___23 = *(a + (1 + (sn - 1) * 2));
        } else {
#line 298
          tmp___23 = *(a + (1 + i * 2));
        }
#line 298
        tmp___24 = tmp___23;
      }
      {
#line 298
      __cil_tmp50 = fix_mul(tmp___24 + tmp___26, 7233);
      }
#line 298
      *(a + i * 2) += __cil_tmp50;
#line 297
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 299
    i = 0;
    {
#line 299
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 299
      if (! (i < sn)) {
#line 299
        goto while_break___8;
      }
#line 300
      if (i + 1 < 0) {
#line 300
        tmp___30 = *(a + 0);
      } else {
#line 300
        if (i + 1 >= dn) {
#line 300
          tmp___29 = *(a + (dn - 1) * 2);
        } else {
#line 300
          tmp___29 = *(a + (i + 1) * 2);
        }
#line 300
        tmp___30 = tmp___29;
      }
#line 300
      if (i < 0) {
#line 300
        tmp___28 = *(a + 0);
      } else {
#line 300
        if (i >= dn) {
#line 300
          tmp___27 = *(a + (dn - 1) * 2);
        } else {
#line 300
          tmp___27 = *(a + i * 2);
        }
#line 300
        tmp___28 = tmp___27;
      }
      {
#line 300
      __cil_tmp56 = fix_mul(tmp___28 + tmp___30, 3633);
      }
#line 300
      *(a + (1 + i * 2)) += __cil_tmp56;
#line 299
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 301
    i = 0;
    {
#line 301
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 301
      if (! (i < dn)) {
#line 301
        goto while_break___9;
      }
      {
#line 302
      *(a + i * 2) = fix_mul(*(a + i * 2), 5038);
      }
#line 301
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 303
    i = 0;
    {
#line 303
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 303
      if (! (i < sn)) {
#line 303
        goto while_break___10;
      }
      {
#line 304
      *(a + (1 + i * 2)) = fix_mul(*(a + (1 + i * 2)), 6659);
      }
#line 303
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
  } else
#line 292
  if (dn > 1) {
#line 292
    goto _L___18;
  }
  return;
}
}
#line 309 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void dwt_encode_stepsize(int stepsize , int numbps , opj_stepsize_t *bandno_stepsize ) 
{ 
  int p ;
  int n ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
  {
#line 311
  __cil_tmp6 = int_floorlog2(stepsize);
#line 311
  p = __cil_tmp6 - 13;
#line 312
  __cil_tmp7 = int_floorlog2(stepsize);
#line 312
  n = 11 - __cil_tmp7;
  }
#line 313
  if (n < 0) {
#line 313
    tmp = stepsize >> - n;
  } else {
#line 313
    tmp = stepsize << n;
  }
#line 313
  bandno_stepsize->mant = tmp & 2047;
#line 314
  bandno_stepsize->expn = numbps - p;
  return;
}
}
#line 326 "/root/patchweave_new/14/libopenjpeg/dwt.c"
void dwt_encode(opj_tcd_tilecomp_t *tilec ) 
{ 
  int i ;
  int j ;
  int k ;
  int *a ;
  int *aj ;
  int *bj ;
  int w ;
  int l ;
  int rw ;
  int rh ;
  int rw1 ;
  int rh1 ;
  int cas_col ;
  int cas_row ;
  int dn ;
  int sn ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 328
  a = (int *)((void *)0);
#line 329
  aj = (int *)((void *)0);
#line 330
  bj = (int *)((void *)0);
#line 333
  w = tilec->x1 - tilec->x0;
#line 334
  l = tilec->numresolutions - 1;
#line 335
  a = tilec->data;
#line 337
  i = 0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (i < l)) {
#line 337
      goto while_break;
    }
    {
#line 346
    rw = (tilec->resolutions + (l - i))->x1 - (tilec->resolutions + (l - i))->x0;
#line 347
    rh = (tilec->resolutions + (l - i))->y1 - (tilec->resolutions + (l - i))->y0;
#line 348
    rw1 = (tilec->resolutions + ((l - i) - 1))->x1 - (tilec->resolutions + ((l - i) - 1))->x0;
#line 349
    rh1 = (tilec->resolutions + ((l - i) - 1))->y1 - (tilec->resolutions + ((l - i) - 1))->y0;
#line 351
    cas_row = (tilec->resolutions + (l - i))->x0 % 2;
#line 352
    cas_col = (tilec->resolutions + (l - i))->y0 % 2;
#line 354
    sn = rh1;
#line 355
    dn = rh - rh1;
#line 356
    __cil_tmp18 = malloc((unsigned long )rh * sizeof(int ));
#line 356
    bj = (int *)__cil_tmp18;
#line 357
    j = 0;
    }
    {
#line 357
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 357
      if (! (j < rw)) {
#line 357
        goto while_break___0;
      }
#line 358
      aj = a + j;
#line 359
      k = 0;
      {
#line 359
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 359
        if (! (k < rh)) {
#line 359
          goto while_break___1;
        }
#line 359
        *(bj + k) = *(aj + k * w);
#line 359
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 360
      dwt_encode_1(bj, dn, sn, cas_col);
#line 361
      dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
      }
#line 357
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 363
    free(bj);
#line 365
    sn = rw1;
#line 366
    dn = rw - rw1;
#line 367
    __cil_tmp21 = malloc((unsigned long )rw * sizeof(int ));
#line 367
    bj = (int *)__cil_tmp21;
#line 368
    j = 0;
    }
    {
#line 368
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 368
      if (! (j < rh)) {
#line 368
        goto while_break___2;
      }
#line 369
      aj = a + j * w;
#line 370
      k = 0;
      {
#line 370
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 370
        if (! (k < rw)) {
#line 370
          goto while_break___3;
        }
#line 370
        *(bj + k) = *(aj + k);
#line 370
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 371
      dwt_encode_1(bj, dn, sn, cas_row);
#line 372
      dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
      }
#line 368
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 374
    free(bj);
    }
#line 337
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 382 "/root/patchweave_new/14/libopenjpeg/dwt.c"
void dwt_decode(opj_tcd_tilecomp_t *tilec , int numres ) 
{ 


  {
  {
#line 383
  dwt_decode_tile(tilec, numres, & dwt_decode_1);
  }
  return;
}
}
#line 390 "/root/patchweave_new/14/libopenjpeg/dwt.c"
int dwt_getgain(int orient ) 
{ 


  {
#line 391
  if (orient == 0) {
#line 392
    return (0);
  }
#line 393
  if (orient == 1) {
#line 394
    return (1);
  } else
#line 393
  if (orient == 2) {
#line 394
    return (1);
  }
#line 395
  return (2);
}
}
#line 401 "/root/patchweave_new/14/libopenjpeg/dwt.c"
double dwt_getnorm(int level , int orient ) 
{ 


  {
#line 402
  return (dwt_norms[orient][level]);
}
}
#line 409 "/root/patchweave_new/14/libopenjpeg/dwt.c"
void dwt_encode_real(opj_tcd_tilecomp_t *tilec ) 
{ 
  int i ;
  int j ;
  int k ;
  int *a ;
  int *aj ;
  int *bj ;
  int w ;
  int l ;
  int rw ;
  int rh ;
  int rw1 ;
  int rh1 ;
  int cas_col ;
  int cas_row ;
  int dn ;
  int sn ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 411
  a = (int *)((void *)0);
#line 412
  aj = (int *)((void *)0);
#line 413
  bj = (int *)((void *)0);
#line 416
  w = tilec->x1 - tilec->x0;
#line 417
  l = tilec->numresolutions - 1;
#line 418
  a = tilec->data;
#line 420
  i = 0;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! (i < l)) {
#line 420
      goto while_break;
    }
    {
#line 429
    rw = (tilec->resolutions + (l - i))->x1 - (tilec->resolutions + (l - i))->x0;
#line 430
    rh = (tilec->resolutions + (l - i))->y1 - (tilec->resolutions + (l - i))->y0;
#line 431
    rw1 = (tilec->resolutions + ((l - i) - 1))->x1 - (tilec->resolutions + ((l - i) - 1))->x0;
#line 432
    rh1 = (tilec->resolutions + ((l - i) - 1))->y1 - (tilec->resolutions + ((l - i) - 1))->y0;
#line 434
    cas_row = (tilec->resolutions + (l - i))->x0 % 2;
#line 435
    cas_col = (tilec->resolutions + (l - i))->y0 % 2;
#line 437
    sn = rh1;
#line 438
    dn = rh - rh1;
#line 439
    __cil_tmp18 = malloc((unsigned long )rh * sizeof(int ));
#line 439
    bj = (int *)__cil_tmp18;
#line 440
    j = 0;
    }
    {
#line 440
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 440
      if (! (j < rw)) {
#line 440
        goto while_break___0;
      }
#line 441
      aj = a + j;
#line 442
      k = 0;
      {
#line 442
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 442
        if (! (k < rh)) {
#line 442
          goto while_break___1;
        }
#line 442
        *(bj + k) = *(aj + k * w);
#line 442
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 443
      dwt_encode_1_real(bj, dn, sn, cas_col);
#line 444
      dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
      }
#line 440
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 446
    free(bj);
#line 448
    sn = rw1;
#line 449
    dn = rw - rw1;
#line 450
    __cil_tmp21 = malloc((unsigned long )rw * sizeof(int ));
#line 450
    bj = (int *)__cil_tmp21;
#line 451
    j = 0;
    }
    {
#line 451
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 451
      if (! (j < rh)) {
#line 451
        goto while_break___2;
      }
#line 452
      aj = a + j * w;
#line 453
      k = 0;
      {
#line 453
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 453
        if (! (k < rw)) {
#line 453
          goto while_break___3;
        }
#line 453
        *(bj + k) = *(aj + k);
#line 453
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 454
      dwt_encode_1_real(bj, dn, sn, cas_row);
#line 455
      dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
      }
#line 451
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 457
    free(bj);
    }
#line 420
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 465 "/root/patchweave_new/14/libopenjpeg/dwt.c"
int dwt_getgain_real(int orient ) 
{ 


  {
#line 467
  return (0);
}
}
#line 473 "/root/patchweave_new/14/libopenjpeg/dwt.c"
double dwt_getnorm_real(int level , int orient ) 
{ 


  {
#line 474
  return (dwt_norms_real[orient][level]);
}
}
#line 477 "/root/patchweave_new/14/libopenjpeg/dwt.c"
void dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , int prec ) 
{ 
  int numbands ;
  int bandno ;
  double stepsize ;
  int resno ;
  int level ;
  int orient ;
  int gain ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double norm ;
  double __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 479
  numbands = 3 * tccp->numresolutions - 2;
#line 480
  bandno = 0;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (bandno < numbands)) {
#line 480
      goto while_break;
    }
#line 484
    if (bandno == 0) {
#line 484
      tmp = 0;
    } else {
#line 484
      tmp = (bandno - 1) / 3 + 1;
    }
#line 484
    resno = tmp;
#line 485
    if (bandno == 0) {
#line 485
      tmp___0 = 0;
    } else {
#line 485
      tmp___0 = (bandno - 1) % 3 + 1;
    }
#line 485
    orient = tmp___0;
#line 486
    level = (tccp->numresolutions - 1) - resno;
#line 487
    if (tccp->qmfbid == 0) {
#line 487
      tmp___3 = 0;
    } else {
#line 487
      if (orient == 0) {
#line 487
        tmp___2 = 0;
      } else {
#line 487
        if (orient == 1 || orient == 2) {
#line 487
          tmp___1 = 1;
        } else {
#line 487
          tmp___1 = 2;
        }
#line 487
        tmp___2 = tmp___1;
      }
#line 487
      tmp___3 = tmp___2;
    }
#line 487
    gain = tmp___3;
#line 488
    if (tccp->qntsty == 0) {
#line 489
      stepsize = 1.;
    } else {
#line 491
      norm = dwt_norms_real[orient][level];
#line 492
      stepsize = (double )(1 << gain) / norm;
    }
    {
#line 494
    __cil_tmp16 = floor(stepsize * 8192.);
#line 494
    dwt_encode_stepsize((int )__cil_tmp16, prec + gain, & tccp->stepsizes[bandno]);
    }
#line 480
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 502 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static int dwt_decode_max_resolution(opj_tcd_resolution_t *r , int i ) 
{ 
  int mr ;
  int w ;
  opj_tcd_resolution_t *__cil_tmp5 ;

  {
#line 503
  mr = 1;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    i --;
#line 505
    if (! i) {
#line 505
      goto while_break;
    }
#line 506
    r ++;
#line 507
    w = r->x1 - r->x0;
#line 507
    if (mr < w) {
#line 508
      mr = w;
    }
#line 509
    w = r->y1 - r->y0;
#line 509
    if (mr < w) {
#line 510
      mr = w;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  return (mr);
}
}
#line 519 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void dwt_decode_tile(opj_tcd_tilecomp_t *tilec , int numres , DWT1DFN dwt_1D ) 
{ 
  dwt_t h ;
  dwt_t v ;
  opj_tcd_resolution_t *tr ;
  int rw ;
  int rh ;
  int w ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  int *tiledp ;
  int j ;
  int k ;

  {
  {
#line 523
  tr = tilec->resolutions;
#line 525
  rw = tr->x1 - tr->x0;
#line 526
  rh = tr->y1 - tr->y0;
#line 528
  w = tilec->x1 - tilec->x0;
#line 530
  __cil_tmp10 = dwt_decode_max_resolution(tr, numres);
#line 530
  __cil_tmp11 = malloc((unsigned long )__cil_tmp10 * sizeof(int ));
#line 530
  h.mem = (int *)__cil_tmp11;
#line 531
  v.mem = h.mem;
  }
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    numres --;
#line 533
    if (! numres) {
#line 533
      goto while_break;
    }
#line 534
    tiledp = tilec->data;
#line 537
    tr ++;
#line 538
    h.sn = rw;
#line 539
    v.sn = rh;
#line 541
    rw = tr->x1 - tr->x0;
#line 542
    rh = tr->y1 - tr->y0;
#line 544
    h.dn = rw - h.sn;
#line 545
    h.cas = tr->x0 % 2;
#line 547
    j = 0;
    {
#line 547
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 547
      if (! (j < rh)) {
#line 547
        goto while_break___0;
      }
      {
#line 548
      dwt_interleave_h(& h, tiledp + j * w);
#line 549
      (*dwt_1D)(& h);
#line 550
      memcpy(tiledp + j * w, h.mem, (unsigned long )rw * sizeof(int ));
      }
#line 547
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 553
    v.dn = rh - v.sn;
#line 554
    v.cas = tr->y0 % 2;
#line 556
    j = 0;
    {
#line 556
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 556
      if (! (j < rw)) {
#line 556
        goto while_break___1;
      }
      {
#line 558
      dwt_interleave_v(& v, tiledp + j, w);
#line 559
      (*dwt_1D)(& v);
#line 560
      k = 0;
      }
      {
#line 560
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 560
        if (! (k < rh)) {
#line 560
          goto while_break___2;
        }
#line 561
        *(tiledp + (k * w + j)) = *(v.mem + k);
#line 560
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 556
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 565
  free(h.mem);
  }
  return;
}
}
#line 568 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void v4dwt_interleave_h(v4dwt_t *w , float *a , int x , int size ) 
{ 
  float *bi ;
  int count ;
  int i ;
  int k ;
  int j ;
  int j___0 ;

  {
#line 569
  bi = (float *)(w->wavelet + w->cas);
#line 570
  count = w->sn;
#line 572
  k = 0;
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    if (! (k < 2)) {
#line 572
      goto while_break;
    }
#line 573
    if (count + 3 * x < size) {
#line 573
      if (((size_t )a & 15UL) == 0UL) {
#line 573
        if (((size_t )bi & 15UL) == 0UL) {
#line 573
          if ((x & 15) == 0) {
#line 575
            i = 0;
            {
#line 575
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 575
              if (! (i < count)) {
#line 575
                goto while_break___0;
              }
#line 576
              j = i;
#line 577
              *(bi + i * 8) = *(a + j);
#line 578
              j += x;
#line 579
              *(bi + (i * 8 + 1)) = *(a + j);
#line 580
              j += x;
#line 581
              *(bi + (i * 8 + 2)) = *(a + j);
#line 582
              j += x;
#line 583
              *(bi + (i * 8 + 3)) = *(a + j);
#line 575
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
#line 573
            goto _L;
          }
        } else {
#line 573
          goto _L;
        }
      } else {
#line 573
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      _L___19: /* CIL Label */ 
      _L___20: /* CIL Label */ 
#line 587
      i = 0;
      {
#line 587
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 587
        if (! (i < count)) {
#line 587
          goto while_break___1;
        }
#line 588
        j___0 = i;
#line 589
        *(bi + i * 8) = *(a + j___0);
#line 590
        j___0 += x;
#line 591
        if (j___0 > size) {
#line 591
          goto while_continue___1;
        }
#line 592
        *(bi + (i * 8 + 1)) = *(a + j___0);
#line 593
        j___0 += x;
#line 594
        if (j___0 > size) {
#line 594
          goto while_continue___1;
        }
#line 595
        *(bi + (i * 8 + 2)) = *(a + j___0);
#line 596
        j___0 += x;
#line 597
        if (j___0 > size) {
#line 597
          goto while_continue___1;
        }
#line 598
        *(bi + (i * 8 + 3)) = *(a + j___0);
#line 587
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 601
    bi = (float *)((w->wavelet + 1) - w->cas);
#line 602
    a += w->sn;
#line 603
    size -= w->sn;
#line 604
    count = w->dn;
#line 572
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 608 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void v4dwt_interleave_v(v4dwt_t *v , float *a , int x ) 
{ 
  v4 *bi ;
  int i ;

  {
#line 609
  bi = v->wavelet + v->cas;
#line 611
  i = 0;
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (! (i < v->sn)) {
#line 611
      goto while_break;
    }
    {
#line 612
    memcpy(bi + i * 2, a + i * x, 4UL * sizeof(float ));
    }
#line 611
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 614
  a += v->sn * x;
#line 615
  bi = (v->wavelet + 1) - v->cas;
#line 616
  i = 0;
  {
#line 616
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 616
    if (! (i < v->dn)) {
#line 616
      goto while_break___0;
    }
    {
#line 617
    memcpy(bi + i * 2, a + i * x, 4UL * sizeof(float ));
    }
#line 616
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 623 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void v4dwt_decode_step1_sse(v4 *w , int count , __m128 c ) 
{ 
  __m128 *vw ;
  int i ;
  __m128 __cil_tmp6 ;
  __m128 __cil_tmp7 ;
  __m128 __cil_tmp8 ;
  __m128 __cil_tmp9 ;
  __m128 __cil_tmp10 ;

  {
#line 624
  vw = (__m128 *)w;
#line 627
  i = 0;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (i < count >> 2)) {
#line 627
      goto while_break;
    }
    {
#line 628
    *vw = _mm_mul_ps(*vw, c);
#line 629
    vw += 2;
#line 630
    *vw = _mm_mul_ps(*vw, c);
#line 631
    vw += 2;
#line 632
    *vw = _mm_mul_ps(*vw, c);
#line 633
    vw += 2;
#line 634
    *vw = _mm_mul_ps(*vw, c);
#line 635
    vw += 2;
    }
#line 627
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  count &= 3;
#line 638
  i = 0;
  {
#line 638
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 638
    if (! (i < count)) {
#line 638
      goto while_break___0;
    }
    {
#line 639
    *vw = _mm_mul_ps(*vw, c);
#line 640
    vw += 2;
    }
#line 638
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 644 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void v4dwt_decode_step2_sse(v4 *l , v4 *w , int k , int m , __m128 c ) 
{ 
  __m128 *vl ;
  __m128 *vw ;
  int i ;
  __m128 tmp1 ;
  __m128 tmp2 ;
  __m128 tmp3 ;
  __m128 __cil_tmp12 ;
  __m128 __cil_tmp13 ;
  __m128 __cil_tmp14 ;
  __m128 __cil_tmp15 ;
  __m128 __cil_tmp16 ;
  __m128 tmp ;
  __m128 __cil_tmp18 ;

  {
#line 645
  vl = (__m128 *)l;
#line 646
  vw = (__m128 *)w;
#line 649
  tmp1 = *(vl + 0);
#line 650
  i = 0;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (i < m)) {
#line 650
      goto while_break;
    }
    {
#line 651
    tmp2 = *(vw + - 1);
#line 652
    tmp3 = *(vw + 0);
#line 653
    __cil_tmp12 = _mm_add_ps(tmp1, tmp3);
#line 653
    __cil_tmp13 = _mm_mul_ps(__cil_tmp12, c);
#line 653
    __cil_tmp14 = _mm_add_ps(tmp2, __cil_tmp13);
#line 653
    *(vw + - 1) = __cil_tmp14;
#line 654
    tmp1 = tmp3;
#line 655
    vw += 2;
    }
#line 650
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  vl = vw - 2;
#line 658
  if (m >= k) {
#line 659
    return;
  }
  {
#line 661
  c = _mm_add_ps(c, c);
#line 662
  c = _mm_mul_ps(c, *(vl + 0));
  }
  {
#line 663
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 663
    if (! (m < k)) {
#line 663
      goto while_break___0;
    }
    {
#line 664
    tmp = *(vw + - 1);
#line 665
    *(vw + - 1) = _mm_add_ps(tmp, c);
#line 666
    vw += 2;
    }
#line 663
    m ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 740 "/root/patchweave_new/14/libopenjpeg/dwt.c"
static void v4dwt_decode(v4dwt_t *dwt ) 
{ 
  int a ;
  int b ;
  __m128 __cil_tmp4 ;
  __m128 __cil_tmp5 ;
  int __cil_tmp6 ;
  __m128 __cil_tmp7 ;
  int __cil_tmp8 ;
  __m128 __cil_tmp9 ;
  int __cil_tmp10 ;
  __m128 __cil_tmp11 ;
  int __cil_tmp12 ;
  __m128 __cil_tmp13 ;

  {
#line 742
  if (dwt->cas == 0) {
#line 743
    if (! (dwt->dn > 0 || dwt->sn > 1)) {
#line 744
      return;
    }
#line 746
    a = 0;
#line 747
    b = 1;
  } else {
#line 749
    if (! (dwt->sn > 0 || dwt->dn > 1)) {
#line 750
      return;
    }
#line 752
    a = 1;
#line 753
    b = 0;
  }
  {
#line 756
  __cil_tmp4 = _mm_set_ss(K);
#line 756
  v4dwt_decode_step1_sse(dwt->wavelet + a, dwt->sn, __cil_tmp4);
#line 757
  __cil_tmp5 = _mm_set_ss(c13318);
#line 757
  v4dwt_decode_step1_sse(dwt->wavelet + b, dwt->dn, __cil_tmp5);
#line 758
  __cil_tmp6 = int_min(dwt->sn, dwt->dn - a);
  }
  {
#line 758
  __cil_tmp7 = _mm_set_ss(dwt_delta);
#line 758
  v4dwt_decode_step2_sse(dwt->wavelet + b, (dwt->wavelet + a) + 1, dwt->sn, __cil_tmp6,
                         __cil_tmp7);
#line 759
  __cil_tmp8 = int_min(dwt->dn, dwt->sn - b);
  }
  {
#line 759
  __cil_tmp9 = _mm_set_ss(dwt_gamma);
#line 759
  v4dwt_decode_step2_sse(dwt->wavelet + a, (dwt->wavelet + b) + 1, dwt->dn, __cil_tmp8,
                         __cil_tmp9);
#line 760
  __cil_tmp10 = int_min(dwt->sn, dwt->dn - a);
  }
  {
#line 760
  __cil_tmp11 = _mm_set_ss(dwt_beta);
#line 760
  v4dwt_decode_step2_sse(dwt->wavelet + b, (dwt->wavelet + a) + 1, dwt->sn, __cil_tmp10,
                         __cil_tmp11);
#line 761
  __cil_tmp12 = int_min(dwt->dn, dwt->sn - b);
  }
  {
#line 761
  __cil_tmp13 = _mm_set_ss(dwt_alpha);
#line 761
  v4dwt_decode_step2_sse(dwt->wavelet + a, (dwt->wavelet + b) + 1, dwt->dn, __cil_tmp12,
                         __cil_tmp13);
  }
  return;
}
}
#line 775 "/root/patchweave_new/14/libopenjpeg/dwt.c"
void dwt_decode_real(opj_tcd_tilecomp_t *tilec , int numres ) 
{ 
  v4dwt_t h ;
  v4dwt_t v ;
  opj_tcd_resolution_t *res ;
  int rw ;
  int rh ;
  int w ;
  int __cil_tmp9 ;
  void *__cil_tmp10 ;
  float *aj ;
  int bufsize ;
  int j ;
  int k ;
  int k___0 ;
  int k___1 ;
  int k___2 ;

  {
  {
#line 779
  res = tilec->resolutions;
#line 781
  rw = res->x1 - res->x0;
#line 782
  rh = res->y1 - res->y0;
#line 784
  w = tilec->x1 - tilec->x0;
#line 786
  __cil_tmp9 = dwt_decode_max_resolution(res, numres);
#line 786
  __cil_tmp10 = malloc((unsigned long )(__cil_tmp9 + 5) * sizeof(v4 ));
#line 786
  h.wavelet = (v4 *)__cil_tmp10;
#line 787
  v.wavelet = h.wavelet;
  }
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    numres --;
#line 789
    if (! numres) {
#line 789
      goto while_break;
    }
#line 790
    aj = (float *)tilec->data;
#line 791
    bufsize = (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0);
#line 794
    h.sn = rw;
#line 795
    v.sn = rh;
#line 797
    res ++;
#line 799
    rw = res->x1 - res->x0;
#line 800
    rh = res->y1 - res->y0;
#line 802
    h.dn = rw - h.sn;
#line 803
    h.cas = res->x0 % 2;
#line 805
    j = rh;
    {
#line 805
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 805
      if (! (j > 3)) {
#line 805
        goto while_break___0;
      }
      {
#line 807
      v4dwt_interleave_h(& h, aj, w, bufsize);
#line 808
      v4dwt_decode(& h);
#line 809
      k = rw;
      }
      {
#line 809
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 809
        if (! (k >= 0)) {
#line 809
          goto while_break___1;
        }
#line 810
        *(aj + k) = (h.wavelet + k)->f[0];
#line 811
        *(aj + (k + w)) = (h.wavelet + k)->f[1];
#line 812
        *(aj + (k + w * 2)) = (h.wavelet + k)->f[2];
#line 813
        *(aj + (k + w * 3)) = (h.wavelet + k)->f[3];
      }
      while_break___1: /* CIL Label */ ;
      }
#line 815
      aj += w * 4;
#line 816
      bufsize -= w * 4;
#line 805
      j -= 4;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 818
    if (rh & 3) {
      {
#line 820
      j = rh & 3;
#line 821
      v4dwt_interleave_h(& h, aj, w, bufsize);
#line 822
      v4dwt_decode(& h);
#line 823
      k___0 = rw;
      }
      {
#line 823
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 823
        if (! (k___0 >= 0)) {
#line 823
          goto while_break___2;
        }
        {
#line 825
        if (j == 3) {
#line 825
          goto case_3;
        }
#line 826
        if (j == 2) {
#line 826
          goto case_2;
        }
#line 827
        if (j == 1) {
#line 827
          goto case_1;
        }
#line 824
        goto switch_break;
        case_3: /* CIL Label */ 
#line 825
        *(aj + (k___0 + w * 2)) = (h.wavelet + k___0)->f[2];
        case_2: /* CIL Label */ 
#line 826
        *(aj + (k___0 + w)) = (h.wavelet + k___0)->f[1];
        case_1: /* CIL Label */ 
#line 827
        *(aj + k___0) = (h.wavelet + k___0)->f[0];
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 832
    v.dn = rh - v.sn;
#line 833
    v.cas = res->y0 % 2;
#line 835
    aj = (float *)tilec->data;
#line 836
    j = rw;
    {
#line 836
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 836
      if (! (j > 3)) {
#line 836
        goto while_break___3;
      }
      {
#line 838
      v4dwt_interleave_v(& v, aj, w);
#line 839
      v4dwt_decode(& v);
#line 840
      k___1 = 0;
      }
      {
#line 840
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 840
        if (! (k___1 < rh)) {
#line 840
          goto while_break___4;
        }
        {
#line 841
        memcpy(aj + k___1 * w, v.wavelet + k___1, 4UL * sizeof(float ));
        }
#line 840
        k___1 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 843
      aj += 4;
#line 836
      j -= 4;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 845
    if (rw & 3) {
      {
#line 847
      j = rw & 3;
#line 848
      v4dwt_interleave_v(& v, aj, w);
#line 849
      v4dwt_decode(& v);
#line 850
      k___2 = 0;
      }
      {
#line 850
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 850
        if (! (k___2 < rh)) {
#line 850
          goto while_break___5;
        }
        {
#line 851
        memcpy(aj + k___2 * w, v.wavelet + k___2, (unsigned long )j * sizeof(float ));
        }
#line 850
        k___2 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 856
  free(h.wavelet);
  }
  return;
}
}
#line 37 "/root/patchweave_new/14/libopenjpeg/cio.c"
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) 
{ 
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 38
  cp = (opj_cp_t *)((void *)0);
#line 39
  __cil_tmp6 = malloc(sizeof(opj_cio_t ));
#line 39
  cio = (opj_cio_t *)__cil_tmp6;
  }
#line 40
  if (! cio) {
#line 40
    return ((opj_cio_t *)((void *)0));
  }
#line 41
  cio->cinfo = cinfo;
#line 42
  if (buffer) {
#line 42
    if (length) {
#line 44
      cio->openmode = 1;
#line 45
      cio->buffer = buffer;
#line 46
      cio->length = length;
    } else {
#line 42
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 48
  if (! buffer) {
#line 48
    if (! length) {
#line 48
      if (cinfo) {
#line 50
        cio->openmode = 2;
        {
#line 52
        if ((int )cinfo->codec_format == 0) {
#line 52
          goto case_0;
        }
#line 55
        if ((int )cinfo->codec_format == 2) {
#line 55
          goto case_2;
        }
#line 58
        goto switch_default;
        case_0: /* CIL Label */ 
#line 53
        cp = ((opj_j2k_t *)cinfo->j2k_handle)->cp;
#line 54
        goto switch_break;
        case_2: /* CIL Label */ 
#line 56
        cp = (((opj_jp2_t *)cinfo->jp2_handle)->j2k)->cp;
#line 57
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 59
        free(cio);
        }
#line 60
        return ((opj_cio_t *)((void *)0));
        switch_break: /* CIL Label */ ;
        }
        {
#line 62
        cio->length = (int )((unsigned int )(0.162500000001 * (double )cp->img_size + (double )2000));
#line 63
        __cil_tmp7 = malloc((unsigned long )cio->length);
#line 63
        cio->buffer = (unsigned char *)__cil_tmp7;
        }
#line 64
        if (! cio->buffer) {
          {
#line 65
          opj_event_msg(cio->cinfo, 1, "Error allocating memory for compressed bitstream\n\327");
#line 66
          free(cio);
          }
#line 67
          return ((opj_cio_t *)((void *)0));
        }
      } else {
        {
        {
        {
#line 71
        free(cio);
        }
        }
        }
#line 72
        return ((opj_cio_t *)((void *)0));
      }
    } else {
      {
      {
      {
#line 71
      free(cio);
      }
      }
      }
#line 72
      return ((opj_cio_t *)((void *)0));
    }
  } else {
    {
    {
    {
#line 71
    free(cio);
    }
    }
    }
#line 72
    return ((opj_cio_t *)((void *)0));
  }
#line 76
  cio->start = cio->buffer;
#line 77
  cio->end = cio->buffer + cio->length;
#line 78
  cio->bp = cio->buffer;
#line 80
  return (cio);
}
}
#line 83 "/root/patchweave_new/14/libopenjpeg/cio.c"
void opj_cio_close(opj_cio_t *cio ) 
{ 


  {
#line 84
  if (cio) {
#line 85
    if (cio->openmode == 2) {
      {
#line 87
      free(cio->buffer);
      }
    }
    {
#line 90
    free(cio);
    }
  }
  return;
}
}
#line 100 "/root/patchweave_new/14/libopenjpeg/cio.c"
int cio_tell(opj_cio_t *cio ) 
{ 


  {
#line 101
  return ((int )(cio->bp - cio->start));
}
}
#line 109 "/root/patchweave_new/14/libopenjpeg/cio.c"
void cio_seek(opj_cio_t *cio , int pos ) 
{ 
  int tmp ;

  {
#line 111
  cio->bp = cio->start + pos;
  return;
}
}
#line 117 "/root/patchweave_new/14/libopenjpeg/cio.c"
int cio_numbytesleft(opj_cio_t *cio ) 
{ 
  int tmp ;

  {
#line 119
  return ((int )(cio->end - cio->bp));
}
}
#line 125 "/root/patchweave_new/14/libopenjpeg/cio.c"
unsigned char *cio_getbp(opj_cio_t *cio ) 
{ 


  {
#line 126
  return (cio->bp);
}
}
#line 132 "/root/patchweave_new/14/libopenjpeg/cio.c"
opj_bool cio_byteout(opj_cio_t *cio , unsigned char v ) 
{ 
  unsigned char *__cil_tmp3 ;

  {
#line 133
  if (cio->bp >= cio->end) {
    {
#line 134
    opj_event_msg(cio->cinfo, 1, "write error\n\342U");
    }
#line 135
    return (0);
  }
#line 137
  __cil_tmp3 = cio->bp;
#line 137
  (cio->bp) ++;
#line 137
  *__cil_tmp3 = v;
#line 138
  return (1);
}
}
#line 144 "/root/patchweave_new/14/libopenjpeg/cio.c"
unsigned char cio_bytein(opj_cio_t *cio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 146
  if (cio->bp >= cio->end) {
    {
#line 147
    opj_event_msg(cio->cinfo, 1, "read error: passed the end of the codestream (start = %d, current = %d, end = %d\n",
                  cio->start, cio->bp, cio->end);
    }
#line 148
    return ((unsigned char )0);
  }
#line 150
  __cil_tmp3 = cio->bp;
#line 150
  (cio->bp) ++;
#line 150
  return (*__cil_tmp3);
}
}
#line 159 "/root/patchweave_new/14/libopenjpeg/cio.c"
unsigned int cio_write(opj_cio_t *cio , unsigned long long v , int n ) 
{ 
  int i ;
  opj_bool __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 161
  i = n - 1;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i >= 0)) {
#line 161
      goto while_break;
    }
    {
#line 162
    __cil_tmp5 = cio_byteout(cio, (unsigned char )((v >> (i << 3)) & 255ULL));
    }
#line 162
    if (! __cil_tmp5) {
#line 163
      return ((unsigned int )0);
    }
#line 161
    __cil_tmp6 = i;
#line 161
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return ((unsigned int )n);
}
}
#line 175 "/root/patchweave_new/14/libopenjpeg/cio.c"
unsigned int cio_read(opj_cio_t *cio , int n ) 
{ 
  int i ;
  unsigned int v ;
  unsigned char __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 178
  v = (unsigned int )0;
#line 179
  i = n - 1;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i >= 0)) {
#line 179
      goto while_break;
    }
    {
#line 180
    __cil_tmp5 = cio_bytein(cio);
    }
#line 180
    v += (unsigned int )__cil_tmp5 << (i << 3);
#line 179
    __cil_tmp6 = i;
#line 179
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return (v);
}
}
#line 190 "/root/patchweave_new/14/libopenjpeg/cio.c"
void cio_skip(opj_cio_t *cio , int n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 192
  if (! (cio->bp + n < cio->start)) {
#line 192
    if (cio->bp + n > cio->end) {

    }
  }
#line 195
  cio->bp += n;
  return;
}
}
#line 45 "/root/patchweave_new/14/libopenjpeg/bio.c"
static void bio_putbit(opj_bio_t *bio , unsigned int b ) ;
#line 51
static int bio_getbit(opj_bio_t *bio ) ;
#line 57
static int bio_byteout(opj_bio_t *bio ) ;
#line 63
static int bio_bytein(opj_bio_t *bio ) ;
#line 75 "/root/patchweave_new/14/libopenjpeg/bio.c"
static int bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 76
  bio->buf = (bio->buf << 8) & 65535U;
#line 77
  if (bio->buf == 65280U) {
#line 77
    tmp = 7;
  } else {
#line 77
    tmp = 8;
  }
#line 77
  bio->ct = tmp;
#line 78
  if (bio->bp >= bio->end) {
#line 79
    return (1);
  }
#line 81
  __cil_tmp3 = bio->bp;
#line 81
  (bio->bp) ++;
#line 81
  *__cil_tmp3 = (unsigned char )(bio->buf >> 8);
#line 82
  return (0);
}
}
#line 85 "/root/patchweave_new/14/libopenjpeg/bio.c"
static int bio_bytein(opj_bio_t *bio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 86
  bio->buf = (bio->buf << 8) & 65535U;
#line 87
  if (bio->buf == 65280U) {
#line 87
    tmp = 7;
  } else {
#line 87
    tmp = 8;
  }
#line 87
  bio->ct = tmp;
#line 88
  if (bio->bp >= bio->end) {
#line 89
    return (1);
  }
#line 91
  __cil_tmp3 = bio->bp;
#line 91
  (bio->bp) ++;
#line 91
  bio->buf |= (unsigned int )*__cil_tmp3;
#line 92
  return (0);
}
}
#line 95 "/root/patchweave_new/14/libopenjpeg/bio.c"
static void bio_putbit(opj_bio_t *bio , unsigned int b ) 
{ 
  int __cil_tmp3 ;

  {
#line 96
  if (bio->ct == 0) {
    {
#line 97
    bio_byteout(bio);
    }
  }
#line 99
  __cil_tmp3 = bio->ct;
#line 99
  (bio->ct) --;
#line 100
  bio->buf |= b << bio->ct;
  return;
}
}
#line 103 "/root/patchweave_new/14/libopenjpeg/bio.c"
static int bio_getbit(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;

  {
#line 104
  if (bio->ct == 0) {
    {
#line 105
    bio_bytein(bio);
    }
  }
#line 107
  __cil_tmp2 = bio->ct;
#line 107
  (bio->ct) --;
#line 108
  return ((int )((bio->buf >> bio->ct) & 1U));
}
}
#line 117 "/root/patchweave_new/14/libopenjpeg/bio.c"
opj_bio_t *bio_create(void) 
{ 
  opj_bio_t *bio ;
  void *__cil_tmp2 ;

  {
  {
#line 118
  __cil_tmp2 = malloc(sizeof(opj_bio_t ));
#line 118
  bio = (opj_bio_t *)__cil_tmp2;
  }
#line 119
  return (bio);
}
}
#line 122 "/root/patchweave_new/14/libopenjpeg/bio.c"
void bio_destroy(opj_bio_t *bio ) 
{ 


  {
#line 123
  if (bio) {
    {
#line 124
    free(bio);
    }
  }
  return;
}
}
#line 128 "/root/patchweave_new/14/libopenjpeg/bio.c"
int bio_numbytes(opj_bio_t *bio ) 
{ 


  {
#line 129
  return ((int )(bio->bp - bio->start));
}
}
#line 132 "/root/patchweave_new/14/libopenjpeg/bio.c"
void bio_init_enc(opj_bio_t *bio , unsigned char *bp , int len ) 
{ 


  {
#line 133
  bio->start = bp;
#line 134
  bio->end = bp + len;
#line 135
  bio->bp = bp;
#line 136
  bio->buf = (unsigned int )0;
#line 137
  bio->ct = 8;
  return;
}
}
#line 140 "/root/patchweave_new/14/libopenjpeg/bio.c"
void bio_init_dec(opj_bio_t *bio , unsigned char *bp , int len ) 
{ 


  {
#line 141
  bio->start = bp;
#line 142
  bio->end = bp + len;
#line 143
  bio->bp = bp;
#line 144
  bio->buf = (unsigned int )0;
#line 145
  bio->ct = 0;
  return;
}
}
#line 148 "/root/patchweave_new/14/libopenjpeg/bio.c"
void bio_write(opj_bio_t *bio , int v , int n ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 150
  i = n - 1;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i >= 0)) {
#line 150
      goto while_break;
    }
    {
#line 151
    bio_putbit(bio, (unsigned int )((v >> i) & 1));
    }
#line 150
    __cil_tmp5 = i;
#line 150
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 155 "/root/patchweave_new/14/libopenjpeg/bio.c"
int bio_read(opj_bio_t *bio , int n ) 
{ 
  int i ;
  int v ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 157
  v = 0;
#line 158
  i = n - 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    __cil_tmp5 = bio_getbit(bio);
    }
#line 159
    v += __cil_tmp5 << i;
#line 158
    __cil_tmp6 = i;
#line 158
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (v);
}
}
#line 164 "/root/patchweave_new/14/libopenjpeg/bio.c"
int bio_flush(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 165
  bio->ct = 0;
#line 166
  __cil_tmp2 = bio_byteout(bio);
  }
#line 166
  if (__cil_tmp2) {
#line 167
    return (1);
  }
#line 169
  if (bio->ct == 7) {
    {
#line 170
    bio->ct = 0;
#line 171
    __cil_tmp3 = bio_byteout(bio);
    }
#line 171
    if (__cil_tmp3) {
#line 172
      return (1);
    }
  }
#line 175
  return (0);
}
}
#line 178 "/root/patchweave_new/14/libopenjpeg/bio.c"
int bio_inalign(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;

  {
#line 179
  bio->ct = 0;
#line 180
  if ((bio->buf & 255U) == 255U) {
    {
#line 181
    __cil_tmp2 = bio_bytein(bio);
    }
#line 181
    if (__cil_tmp2) {
#line 182
      return (1);
    }
#line 184
    bio->ct = 0;
  }
#line 186
  return (0);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 255
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 18 "../../applications/common/opj_getopt.h"
int opj_opterr ;
#line 19
int opj_optind ;
#line 20
int opj_optopt ;
#line 21
int opj_optreset ;
#line 22
char *opj_optarg ;
#line 24
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 25
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) ;
#line 27
void reset_options_reading(void) ;
#line 51 "/root/patchweave_new/14/applications/codec/convert.h"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 52
int imagetotga(opj_image_t *image , char const   *outfile ) ;
#line 55
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 56
int imagetobmp(opj_image_t *image , char const   *outfile ) ;
#line 59
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 60
int imagetotif(opj_image_t *image , char const   *outfile ) ;
#line 67
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 68
int imagetopgx(opj_image_t *image , char const   *outfile ) ;
#line 70
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 71
int imagetopnm(opj_image_t *image , char const   *outfile ) ;
#line 74
int imagetoraw(opj_image_t *image , char const   *outfile ) ;
#line 75
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) ;
#line 78
extern int imagetopng(opj_image_t *image , char const   *write_idf ) ;
#line 79
extern opj_image_t *pngtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 42 "/root/patchweave_new/14/applications/codec/index.h"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) ;
#line 76 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
void decode_help_display(void) 
{ 


  {
  {
#line 77
  fprintf(stdout, "HELP for j2k_dump\n----\n\n\220");
#line 78
  fprintf(stdout, "- the -h option displays this help information on screen\n\n");
#line 81
  fprintf(stdout, "List of parameters for the JPEG 2000 decoder:\n");
#line 87
  fprintf(stdout, "\n");
#line 88
  fprintf(stdout, "\n");
#line 89
  fprintf(stdout, "  -ImgDir \n");
#line 90
  fprintf(stdout, "\tImage file Directory path \n");
#line 91
  fprintf(stdout, "  -i <compressed file>\n");
#line 92
  fprintf(stdout, "    REQUIRED only if an Input image directory not specified\n");
#line 93
  fprintf(stdout, "    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n\220");
#line 94
  fprintf(stdout, "    is identified based on its suffix.\n");
#line 95
  fprintf(stdout, "  -o <output file>\n");
#line 96
  fprintf(stdout, "    OPTIONAL\n");
#line 97
  fprintf(stdout, "    Output file where file info will be dump.\n");
#line 98
  fprintf(stdout, "    By default it will be in the stdout.\n");
#line 99
  fprintf(stdout, "\n");
  }
  return;
}
}
#line 103
static void j2k_dump_image(FILE *fd , opj_image_t *img ) ;
#line 104
static void j2k_dump_cp(FILE *fd , opj_image_t *img , opj_cp_t *cp ) ;
#line 106 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int num_images ;
  DIR *__cil_tmp5 ;
  struct dirent *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 109
  num_images = 0;
#line 113
  dir = opendir((char const   *)imgdirpath);
  }
#line 114
  if (! dir) {
    {
#line 115
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 116
    return (0);
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 119
    content = readdir(dir);
    }
#line 119
    if (! (content != (void *)0)) {
#line 119
      goto while_break;
    }
    {
#line 120
    __cil_tmp8 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 120
    __cil_tmp7 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 120
    if (__cil_tmp7 == 0) {
#line 121
      goto while_continue;
    } else
#line 120
    if (__cil_tmp8 == 0) {
#line 121
      goto while_continue;
    }
#line 122
    num_images ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  closedir(dir);
  }
#line 125
  return (num_images);
}
}
#line 128 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
int load_images(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  DIR *__cil_tmp6 ;
  struct dirent *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 131
  i = 0;
#line 135
  dir = opendir((char const   *)imgdirpath);
  }
#line 136
  if (! dir) {
    {
#line 137
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 138
    return (1);
  } else {
    {
#line 140
    fprintf(stderr, "Folder opened successfully\n\336\342U");
    }
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    content = readdir(dir);
    }
#line 143
    if (! (content != (void *)0)) {
#line 143
      goto while_break;
    }
    {
#line 144
    __cil_tmp9 = strcmp("..\307\336\342U", (char const   *)((char *)content->d_name));
    }
    {
#line 144
    __cil_tmp8 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 144
    if (__cil_tmp8 == 0) {
#line 145
      goto while_continue;
    } else
#line 144
    if (__cil_tmp9 == 0) {
#line 145
      goto while_continue;
    }
    {
#line 147
    strcpy(*(dirptr->filename + i), (char const   *)((char *)content->d_name));
#line 148
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  closedir(dir);
  }
#line 151
  return (0);
}
}
#line 154 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
int get_file_format(char *filename ) 
{ 
  unsigned int i ;
  static char const   *extension[14] ;
  static int const   format[14] ;
  char *ext ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;

  {
  {
#line 156
  extension[0] = "pgx\336\342U";
#line 156
  extension[1] = "pnm\336\342U";
#line 156
  extension[2] = "pgm\336\342U";
#line 156
  extension[3] = "ppm\336\342U";
#line 156
  extension[4] = "bmp\336\342U";
#line 156
  extension[5] = "tif\336\342U";
#line 156
  extension[6] = "raw\336\342U";
#line 156
  extension[7] = "tga\336\342U";
#line 156
  extension[8] = "png\336\342U";
#line 156
  extension[9] = "j2k\336\342U";
#line 156
  extension[10] = "jp2\336\342U";
#line 156
  extension[11] = "jpt";
#line 156
  extension[12] = "j2c";
#line 156
  extension[13] = "jpc";
#line 157
  format[0] = 11;
#line 157
  format[1] = 10;
#line 157
  format[2] = 10;
#line 157
  format[3] = 10;
#line 157
  format[4] = 12;
#line 157
  format[5] = 14;
#line 157
  format[6] = 15;
#line 157
  format[7] = 16;
#line 157
  format[8] = 17;
#line 157
  format[9] = 0;
#line 157
  format[10] = 1;
#line 157
  format[11] = 2;
#line 157
  format[12] = 0;
#line 157
  format[13] = 0;
#line 158
  __cil_tmp6 = strrchr((char const   *)filename, '.');
#line 158
  ext = __cil_tmp6;
  }
#line 159
  if (ext == (void *)0) {
#line 160
    return (- 1);
  }
#line 161
  ext ++;
#line 162
  if (ext) {
#line 163
    i = (unsigned int )0;
    {
#line 163
    while (1) {
      while_continue: /* CIL Label */ ;
#line 163
      if (! ((unsigned long )i < sizeof(format) / sizeof(*((int const   *)format)))) {
#line 163
        goto while_break;
      }
      {
#line 164
      __cil_tmp8 = strncasecmp((char const   *)ext, extension[i], (unsigned long )3);
      }
#line 164
      if (__cil_tmp8 == 0) {
#line 165
        return (format[i]);
      }
#line 163
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 170
  return (- 1);
}
}
#line 173 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_dparameters_t *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 175
  temp1 = "\002";
#line 177
  strcpy((char *)image_filename, (char const   *)*(dirptr->filename + imageno));
#line 178
  fprintf(stderr, "File Number %d \"%s\"\n", imageno, (char *)image_filename);
#line 179
  parameters->decod_format = get_file_format((char *)image_filename);
  }
#line 180
  if (parameters->decod_format == -1) {
#line 181
    return ((char )1);
  }
  {
#line 182
  sprintf((char *)infilename, "%s/%sU", img_fol->imgdirpath, (char *)image_filename);
#line 183
  strncpy((char *)parameters->infile, (char const   *)((char *)infilename), sizeof(infilename));
#line 186
  __cil_tmp12 = strtok((char *)image_filename, ".");
#line 186
  strcpy((char *)temp_ofname, (char const   *)__cil_tmp12);
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    temp_p = strtok((char *)((void *)0), ".");
    }
#line 187
    if (! (temp_p != (void *)0)) {
#line 187
      goto while_break;
    }
    {
#line 188
    strcat((char *)temp_ofname, (char const   *)((char *)temp1));
#line 189
    sprintf((char *)temp1, ".%s", temp_p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  if ((int )img_fol->set_out_format == 1) {
    {
#line 192
    sprintf((char *)outfilename, "%s/%s.%s\230\001", img_fol->imgdirpath, (char *)temp_ofname,
            img_fol->out_format);
#line 193
    strncpy((char *)parameters->outfile, (char const   *)((char *)outfilename), sizeof(outfilename));
    }
  }
#line 195
  return ((char )0);
}
}
#line 199 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                          img_fol_t *img_fol , char *indexfilename ) 
{ 
  int totlen ;
  int c ;
  opj_option_t long_option[1] ;
  char const   optlist[6] ;
  int __cil_tmp10 ;
  char *infile ;
  int __cil_tmp12 ;
  char *outfile ;
  unsigned long __cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 202
  long_option[0].name = "ImgDir";
#line 202
  long_option[0].has_arg = 1;
#line 202
  long_option[0].flag = (int *)((void *)0);
#line 202
  long_option[0].val = 'y';
#line 205
  optlist = "i:o:h";
#line 209
  totlen = (int )sizeof(long_option);
#line 210
  img_fol->set_out_format = (char )0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    c = opj_getopt_long(argc, (char * const  [])argv, (char const   *)optlist, (opj_option_t *)long_option,
                        totlen);
    }
#line 213
    if (c == -1) {
#line 214
      goto while_break;
    }
    {
#line 216
    if (c == 'i') {
#line 216
      goto case_105;
    }
#line 223
    if (c == 2) {
#line 223
      goto case_2;
    }
#line 223
    if (c == 1) {
#line 223
      goto case_2;
    }
#line 223
    if (c == 0) {
#line 223
      goto case_2;
    }
#line 237
    if (c == 'o') {
#line 237
      goto case_111;
    }
#line 246
    if (c == 'h') {
#line 246
      goto case_104;
    }
#line 252
    if (c == 'y') {
#line 252
      goto case_121;
    }
#line 262
    goto switch_default___0;
    case_105: /* CIL Label */ 
    {
#line 218
    infile = opj_optarg;
#line 219
    parameters->decod_format = get_file_format(infile);
    }
    {
#line 223
    if (parameters->decod_format == 2) {
#line 223
      goto case_2;
    }
#line 223
    if (parameters->decod_format == 1) {
#line 223
      goto case_2;
    }
#line 223
    if (parameters->decod_format == 0) {
#line 223
      goto case_2;
    }
#line 225
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 224
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 226
    fprintf(stderr, "!! Unrecognized format for infile : %s [accept only *.j2k, *.jp2, *.jpc or *.jpt] !!\n\n",
            infile);
    }
#line 229
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 231
    strncpy((char *)parameters->infile, (char const   *)infile, sizeof(parameters->infile) - 1UL);
    }
#line 233
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 239
    outfile = opj_optarg;
#line 240
    strncpy((char *)parameters->outfile, (char const   *)outfile, sizeof(parameters->outfile) - 1UL);
    }
#line 242
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 247
    decode_help_display();
    }
#line 248
    return (1);
    case_121: /* CIL Label */ 
    {
#line 254
    __cil_tmp14 = strlen((char const   *)opj_optarg);
#line 254
    __cil_tmp15 = malloc(__cil_tmp14 + 1UL);
#line 254
    img_fol->imgdirpath = (char *)__cil_tmp15;
#line 255
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 256
    img_fol->set_imgdir = (char )1;
    }
#line 258
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 263
    fprintf(stderr, "WARNING -> this option is not valid \"-%c %s\"\nU", c, opj_optarg);
    }
#line 264
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 211
    if (! (c != -1)) {
#line 211
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  if ((int )img_fol->set_imgdir == 1) {
#line 270
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 271
      fprintf(stderr, "Error: options -ImgDir and -i cannot be used together !!\n");
      }
#line 272
      return (1);
    }
#line 274
    if ((int )img_fol->set_out_format == 0) {
      {
#line 275
      fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
#line 276
      fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA!!\n");
      }
#line 277
      return (1);
    }
#line 279
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 280
      fprintf(stderr, "Error: options -ImgDir and -o cannot be used together !!\nP\307\336\342U");
      }
#line 281
      return (1);
    }
  } else
#line 284
  if ((int )parameters->infile[0] == 0) {
    {
#line 285
    fprintf(stderr, "Example: %s -i image.j2k\n\236\307\336\342U", *(argv + 0));
#line 286
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
#line 287
    return (1);
  }
#line 291
  return (0);
}
}
#line 299 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
void error_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 300
  stream = (FILE *)client_data;
#line 301
  fprintf(stream, "[ERROR] %s", msg);
  }
  return;
}
}
#line 306 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
void warning_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 307
  stream = (FILE *)client_data;
#line 308
  fprintf(stream, "[WARNING] %s", msg);
  }
  return;
}
}
#line 313 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
void info_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 315
  fprintf(stdout, "[INFO] %s\224\307\336\342U", msg);
  }
  return;
}
}
#line 320 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
int main(int argc , char *argv[] ) 
{ 
  opj_dparameters_t parameters ;
  img_fol_t img_fol ;
  opj_event_mgr_t event_mgr ;
  opj_image_t *image ;
  FILE *fsrc ;
  FILE *fout ;
  unsigned char *src ;
  int file_length ;
  int num_images ;
  int i ;
  int imageno ;
  dircnt_t *dirptr ;
  opj_dinfo_t *dinfo ;
  opj_cio_t *cio ;
  opj_codestream_info_t cstr_info ;
  char indexfilename[4096] ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  FILE *__cil_tmp26 ;
  char __cil_tmp27 ;
  FILE *__cil_tmp28 ;
  long __cil_tmp29 ;
  void *__cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  opj_dinfo_t *__cil_tmp32 ;
  opj_cio_t *__cil_tmp33 ;
  opj_image_t *__cil_tmp34 ;
  opj_image_t *__cil_tmp35 ;
  opj_bool bSuccess ;
  int __cil_tmp37 ;
  opj_dinfo_t *__cil_tmp38 ;
  opj_cio_t *__cil_tmp39 ;
  opj_image_t *__cil_tmp40 ;
  opj_image_t *__cil_tmp41 ;
  opj_bool bSuccess___0 ;
  int __cil_tmp43 ;
  opj_dinfo_t *__cil_tmp44 ;
  opj_cio_t *__cil_tmp45 ;
  opj_image_t *__cil_tmp46 ;
  opj_image_t *__cil_tmp47 ;
  opj_bool bSuccess___1 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;

  {
#line 325
  image = (opj_image_t *)((void *)0);
#line 326
  fsrc = (FILE *)((void *)0);
  {
#line 326
  fout = (FILE *)((void *)0);
#line 327
  src = (unsigned char *)((void *)0);
#line 331
  dirptr = (dircnt_t *)((void *)0);
#line 332
  dinfo = (opj_dinfo_t *)((void *)0);
#line 333
  cio = (opj_cio_t *)((void *)0);
#line 338
  memset(& event_mgr, 0, sizeof(opj_event_mgr_t ));
#line 339
  event_mgr.error_handler = & error_callback;
#line 340
  event_mgr.warning_handler = & warning_callback;
#line 341
  event_mgr.info_handler = & info_callback;
#line 344
  opj_set_default_decoder_parameters(& parameters);
#line 347
  *((char *)indexfilename) = (char )0;
#line 348
  memset(& img_fol, 0, sizeof(img_fol_t ));
#line 351
  __cil_tmp19 = parse_cmdline_decoder(argc, argv, & parameters, & img_fol, (char *)indexfilename);
  }
#line 351
  if (__cil_tmp19 == 1) {
#line 352
    return (1);
  }
#line 356
  if ((int )img_fol.set_imgdir == 1) {
    {
#line 357
    num_images = get_num_images(img_fol.imgdirpath);
#line 359
    __cil_tmp21 = malloc(sizeof(dircnt_t ));
#line 359
    dirptr = (dircnt_t *)__cil_tmp21;
    }
#line 360
    if (dirptr) {
      {
#line 361
      __cil_tmp22 = malloc((unsigned long )(num_images * 4096) * sizeof(char ));
#line 361
      dirptr->filename_buf = (char *)__cil_tmp22;
#line 362
      __cil_tmp23 = malloc((unsigned long )num_images * sizeof(char *));
#line 362
      dirptr->filename = (char **)__cil_tmp23;
      }
#line 364
      if (! dirptr->filename_buf) {
#line 365
        return (1);
      }
#line 367
      i = 0;
      {
#line 367
      while (1) {
        while_continue: /* CIL Label */ ;
#line 367
        if (! (i < num_images)) {
#line 367
          goto while_break;
        }
#line 368
        *(dirptr->filename + i) = dirptr->filename_buf + i * 4096;
#line 367
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 371
    __cil_tmp25 = load_images(dirptr, img_fol.imgdirpath);
    }
#line 371
    if (__cil_tmp25 == 1) {
#line 372
      return (1);
    }
#line 374
    if (num_images == 0) {
      {
#line 375
      fprintf(stdout, "Folder is empty\n\220");
      }
#line 376
      return (1);
    }
  } else {
#line 379
    num_images = 1;
  }
#line 383
  if ((int )parameters.outfile[0] != 0) {
    {
#line 385
    fout = fopen((char const   *)((char *)parameters.outfile), "w");
    }
#line 386
    if (! fout) {
      {
#line 388
      fprintf(stderr, "ERROR -> failed to open %s for reading\n", (char *)parameters.outfile);
      }
#line 389
      return (1);
    }
  } else {
#line 393
    fout = stdout;
  }
#line 396
  imageno = 0;
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! (imageno < num_images)) {
#line 396
      goto while_break___0;
    }
    {
#line 398
    image = (opj_image_t *)((void *)0);
#line 399
    fprintf(stderr, "\n\366\001");
    }
#line 401
    if ((int )img_fol.set_imgdir == 1) {
      {
#line 402
      __cil_tmp27 = get_next_file(imageno, dirptr, & img_fol, & parameters);
      }
#line 402
      if (__cil_tmp27) {
        {
#line 403
        fprintf(stderr, "skipping file...\n");
        }
#line 404
        goto while_continue___0;
      }
    }
    {
#line 410
    fsrc = fopen((char const   *)((char *)parameters.infile), "rb");
    }
#line 411
    if (! fsrc) {
      {
#line 412
      fprintf(stderr, "ERROR -> failed to open %s for reading\n", (char *)parameters.infile);
      }
#line 413
      return (1);
    }
    {
#line 415
    fseek(fsrc, (long )0, 2);
#line 416
    __cil_tmp29 = ftell(fsrc);
#line 416
    file_length = (int )__cil_tmp29;
#line 417
    fseek(fsrc, (long )0, 0);
#line 418
    __cil_tmp30 = malloc((unsigned long )file_length);
#line 418
    src = (unsigned char *)__cil_tmp30;
#line 419
    __cil_tmp31 = fread(src, (unsigned long )1, (unsigned long )file_length, fsrc);
    }
#line 419
    if (__cil_tmp31 != (size_t )file_length) {
      {
#line 421
      free(src);
#line 422
      fclose(fsrc);
#line 423
      fclose(fout);
#line 424
      fprintf(stderr, "\nERROR: fread return a number of element different from the expected.\n");
      }
#line 425
      return (1);
    }
    {
#line 427
    fclose(fsrc);
    }
    {
#line 433
    if (parameters.decod_format == 0) {
#line 433
      goto case_0;
    }
#line 482
    if (parameters.decod_format == 1) {
#line 482
      goto case_1;
    }
#line 535
    if (parameters.decod_format == 2) {
#line 535
      goto case_2;
    }
#line 579
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 438
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )0);
#line 441
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 444
    opj_setup_decoder(dinfo, & parameters);
#line 447
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 450
    if (*((char *)indexfilename)) {
      {
#line 451
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 453
      image = opj_decode(dinfo, cio);
      }
    }
#line 454
    if (! image) {
      {
#line 455
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 456
      opj_destroy_decompress(dinfo);
#line 457
      opj_cio_close(cio);
#line 458
      fclose(fout);
#line 459
      free(src);
      }
#line 460
      return (1);
    }
    {
#line 463
    j2k_dump_image(fout, image);
#line 466
    j2k_dump_cp(fout, image, ((opj_j2k_t *)dinfo->j2k_handle)->cp);
#line 469
    opj_cio_close(cio);
    }
#line 472
    if (*((char *)indexfilename)) {
      {
#line 474
      bSuccess = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 475
      if (bSuccess) {
        {
#line 476
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 480
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 487
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )2);
#line 490
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 493
    opj_setup_decoder(dinfo, & parameters);
#line 496
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 499
    if (*((char *)indexfilename)) {
      {
#line 500
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 502
      image = opj_decode(dinfo, cio);
      }
    }
#line 503
    if (! image) {
      {
#line 504
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 505
      opj_destroy_decompress(dinfo);
#line 506
      opj_cio_close(cio);
#line 507
      fclose(fout);
#line 508
      free(src);
      }
#line 509
      return (1);
    }
#line 512
    if (image->icc_profile_buf) {
      {
#line 514
      free(image->icc_profile_buf);
#line 514
      image->icc_profile_buf = (unsigned char *)((void *)0);
      }
    }
    {
#line 516
    j2k_dump_image(fout, image);
#line 519
    j2k_dump_cp(fout, image, (((opj_jp2_t *)dinfo->jp2_handle)->j2k)->cp);
#line 522
    opj_cio_close(cio);
    }
#line 525
    if (*((char *)indexfilename)) {
      {
#line 527
      bSuccess___0 = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 528
      if (bSuccess___0) {
        {
#line 529
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 533
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 540
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )1);
#line 543
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 546
    opj_setup_decoder(dinfo, & parameters);
#line 549
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 552
    if (*((char *)indexfilename)) {
      {
#line 553
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 555
      image = opj_decode(dinfo, cio);
      }
    }
#line 556
    if (! image) {
      {
#line 557
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 558
      opj_destroy_decompress(dinfo);
#line 559
      opj_cio_close(cio);
#line 560
      fclose(fout);
#line 561
      free(src);
      }
#line 562
      return (1);
    }
    {
#line 566
    opj_cio_close(cio);
    }
#line 569
    if (*((char *)indexfilename)) {
      {
#line 571
      bSuccess___1 = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 572
      if (bSuccess___1) {
        {
#line 573
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 577
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 580
    fprintf(stderr, "skipping file..\n\220");
    }
#line 581
    goto while_continue___0;
    switch_break: /* CIL Label */ ;
    }
    {
#line 585
    free(src);
#line 586
    src = (unsigned char *)((void *)0);
    }
#line 589
    if (dinfo) {
      {
#line 590
      opj_destroy_decompress(dinfo);
      }
    }
#line 593
    if (*((char *)indexfilename)) {
      {
#line 594
      opj_destroy_cstr_info(& cstr_info);
      }
    }
    {
#line 596
    opj_image_destroy(image);
    }
#line 396
    imageno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 600
  fclose(fout);
  }
#line 602
  return (0);
}
}
#line 606 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
static void j2k_dump_image(FILE *fd , opj_image_t *img ) 
{ 
  int compno ;
  opj_image_comp_t *comp ;
  int __cil_tmp5 ;

  {
  {
#line 608
  fprintf(fd, "image {\n\220");
#line 609
  fprintf(fd, "  x0=%d, y0=%d, x1=%d, y1=%d\n", img->x0, img->y0, img->x1, img->y1);
#line 610
  fprintf(fd, "  numcomps=%d\n", img->numcomps);
#line 611
  compno = 0;
  }
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (! (compno < img->numcomps)) {
#line 611
      goto while_break;
    }
    {
#line 612
    comp = img->comps + compno;
#line 613
    fprintf(fd, "  comp %d {\n", compno);
#line 614
    fprintf(fd, "    dx=%d, dy=%d\n", comp->dx, comp->dy);
#line 615
    fprintf(fd, "    prec=%d\n", comp->prec);
#line 617
    fprintf(fd, "    sgnd=%d\n", comp->sgnd);
#line 618
    fprintf(fd, "  }\n");
    }
#line 611
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 620
  fprintf(fd, "}\n");
  }
  return;
}
}
#line 623 "/root/patchweave_new/14/applications/codec/j2k_dump.c"
static void j2k_dump_cp(FILE *fd , opj_image_t *img , opj_cp_t *cp ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int bandno ;
  int resno ;
  int numbands ;
  opj_tcp_t *tcp ;
  int __cil_tmp11 ;
  opj_tccp_t *tccp ;
  int tmp ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 625
  fprintf(fd, "coding parameters {\n");
#line 626
  fprintf(fd, "  tx0=%d, ty0=%d\n", cp->tx0, cp->ty0);
#line 627
  fprintf(fd, "  tdx=%d, tdy=%d\n\307\274\336\342U", cp->tdx, cp->tdy);
#line 628
  fprintf(fd, "  tw=%d, th=%d\n", cp->tw, cp->th);
#line 629
  tileno = 0;
  }
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 629
    if (! (tileno < cp->tw * cp->th)) {
#line 629
      goto while_break;
    }
    {
#line 630
    tcp = cp->tcps + tileno;
#line 631
    fprintf(fd, "  tile %d {\n\342U", tileno);
#line 632
    fprintf(fd, "    csty=%x\n\342U", tcp->csty);
#line 633
    fprintf(fd, "    prg=%d\n", (int )tcp->prg);
#line 634
    fprintf(fd, "    numlayers=%d\n\275\274\336\342U", tcp->numlayers);
#line 635
    fprintf(fd, "    mct=%d\n", tcp->mct);
#line 636
    fprintf(fd, "    rates=");
#line 637
    layno = 0;
    }
    {
#line 637
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 637
      if (! (layno < tcp->numlayers)) {
#line 637
        goto while_break___0;
      }
      {
#line 638
      fprintf(fd, "%.1f ", (double )tcp->rates[layno]);
      }
#line 637
      layno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 640
    fprintf(fd, "\n");
#line 641
    compno = 0;
    }
    {
#line 641
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 641
      if (! (compno < img->numcomps)) {
#line 641
        goto while_break___1;
      }
      {
#line 642
      tccp = tcp->tccps + compno;
#line 643
      fprintf(fd, "    comp %d {\n", compno);
#line 644
      fprintf(fd, "      csty=%x\n", tccp->csty);
#line 645
      fprintf(fd, "      numresolutions=%d\n\230\001", tccp->numresolutions);
#line 646
      fprintf(fd, "      cblkw=%d\n", tccp->cblkw);
#line 647
      fprintf(fd, "      cblkh=%d\n", tccp->cblkh);
#line 648
      fprintf(fd, "      cblksty=%x\n\273\310\336\342U", tccp->cblksty);
#line 649
      fprintf(fd, "      qmfbid=%d\n\230\001", tccp->qmfbid);
#line 650
      fprintf(fd, "      qntsty=%d\n\230\001", tccp->qntsty);
#line 651
      fprintf(fd, "      numgbits=%d\n", tccp->numgbits);
#line 652
      fprintf(fd, "      roishift=%d\n\310\336\342U", tccp->roishift);
#line 653
      fprintf(fd, "      stepsizes=\220");
      }
#line 654
      if (tccp->qntsty == 1) {
#line 654
        tmp = 1;
      } else {
#line 654
        tmp = tccp->numresolutions * 3 - 2;
      }
#line 654
      numbands = tmp;
#line 655
      bandno = 0;
      {
#line 655
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 655
        if (! (bandno < numbands)) {
#line 655
          goto while_break___2;
        }
        {
#line 656
        fprintf(fd, "(%d,%d) \230\001", tccp->stepsizes[bandno].mant, tccp->stepsizes[bandno].expn);
        }
#line 655
        bandno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 659
      fprintf(fd, "\n\201\310\336\342U");
      }
#line 661
      if (tccp->csty & 1) {
        {
#line 662
        fprintf(fd, "      prcw=");
#line 663
        resno = 0;
        }
        {
#line 663
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 663
          if (! (resno < tccp->numresolutions)) {
#line 663
            goto while_break___3;
          }
          {
#line 664
          fprintf(fd, "%d ", tccp->prcw[resno]);
          }
#line 663
          resno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 666
        fprintf(fd, "\n");
#line 667
        fprintf(fd, "      prch=");
#line 668
        resno = 0;
        }
        {
#line 668
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 668
          if (! (resno < tccp->numresolutions)) {
#line 668
            goto while_break___4;
          }
          {
#line 669
          fprintf(fd, "%d \336\342U", tccp->prch[resno]);
          }
#line 668
          resno ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 671
        fprintf(fd, "\n");
        }
      }
      {
#line 673
      fprintf(fd, "    }\n");
      }
#line 641
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 675
    fprintf(fd, "  }\n");
    }
#line 629
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 677
  fprintf(fd, "}\n");
  }
  return;
}
}
#line 43 "/root/patchweave_new/14/applications/codec/index.c"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int resno ;
  int precno ;
  int pack_nb ;
  int x ;
  int y ;
  FILE *stream ;
  double total_disto ;
  int tilepartno ;
  char disto_on ;
  char numpix_on ;
  FILE *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int start_pos ;
  int end_ph_pos ;
  int end_pos ;
  double disto ;
  int max_numdecompos ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int prec_max ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int prec_max___0 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int numprec ;
  int x0 ;
  double __cil_tmp40 ;
  int y0___21 ;
  double __cil_tmp42 ;
  int x1 ;
  int y1___22 ;
  int pcnx ;
  int pcx ;
  double __cil_tmp47 ;
  int pcy ;
  double __cil_tmp49 ;
  int precno_x ;
  double __cil_tmp51 ;
  int precno_y ;
  double __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0___0 ;
  double __cil_tmp62 ;
  int y0___23 ;
  double __cil_tmp64 ;
  int x1___0 ;
  int y1___24 ;
  int max_numprec ;
  int numprec___0 ;
  int __cil_tmp69 ;
  int numprec___1 ;
  int pcnx___0 ;
  int pcx___0 ;
  double __cil_tmp73 ;
  int pcy___0 ;
  double __cil_tmp75 ;
  int precno_x___0 ;
  double __cil_tmp77 ;
  int precno_y___0 ;
  double __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int max_numprec___0 ;
  int numprec___2 ;
  int __cil_tmp89 ;
  int x0___1 ;
  double __cil_tmp91 ;
  int y0___25 ;
  double __cil_tmp93 ;
  int x1___1 ;
  int y1___26 ;
  int numprec___3 ;
  int pcnx___1 ;
  int pcx___1 ;
  double __cil_tmp99 ;
  int pcy___1 ;
  double __cil_tmp101 ;
  int precno_x___1 ;
  double __cil_tmp103 ;
  int precno_y___1 ;
  double __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;

  {
#line 45
  stream = (FILE *)((void *)0);
#line 46
  total_disto = (double )0;
#line 57
  if (! cstr_info) {
#line 58
    return (1);
  }
  {
#line 60
  stream = fopen((char const   *)index___0, "w");
  }
#line 61
  if (! stream) {
    {
#line 62
    fprintf(stderr, "failed to open index file [%s] for writing\n", index___0);
    }
#line 63
    return (1);
  }
#line 66
  if ((cstr_info->tile + 0)->distotile) {
#line 67
    disto_on = (char )1;
  } else {
#line 69
    disto_on = (char )0;
  }
#line 71
  if ((cstr_info->tile + 0)->numpix) {
#line 72
    numpix_on = (char )1;
  } else {
#line 74
    numpix_on = (char )0;
  }
  {
#line 76
  fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
#line 77
  fprintf(stream, "%d\n", (int )cstr_info->prog);
#line 78
  fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
#line 79
  fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
#line 80
  fprintf(stream, "%d\n", cstr_info->numcomps);
#line 81
  fprintf(stream, "%d\n", cstr_info->numlayers);
#line 82
  fprintf(stream, "%d\n", *(cstr_info->numdecompos + 0));
#line 84
  resno = *(cstr_info->numdecompos + 0);
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (resno >= 0)) {
#line 84
      goto while_break;
    }
    {
#line 85
    fprintf(stream, "[%d,%d] \251", 1 << (cstr_info->tile + 0)->pdx[resno], 1 << (cstr_info->tile + 0)->pdx[resno]);
    }
#line 84
    __cil_tmp17 = resno;
#line 84
    resno --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  fprintf(stream, "\n");
#line 91
  fprintf(stream, "%d\n", cstr_info->main_head_start);
#line 93
  fprintf(stream, "%d\n", cstr_info->main_head_end);
#line 94
  fprintf(stream, "%d\n", cstr_info->codestream_size);
#line 96
  fprintf(stream, "\nINFO ON TILES\n");
#line 97
  fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
  }
#line 98
  if (disto_on) {
    {
#line 99
    fprintf(stream, "         disto");
    }
  }
#line 100
  if (numpix_on) {
    {
#line 101
    fprintf(stream, "     nbpix");
    }
  }
#line 102
  if ((int )disto_on) {
#line 102
    if ((int )numpix_on) {
      {
#line 103
      fprintf(stream, "  disto/nbpix");
      }
    }
  }
  {
#line 104
  fprintf(stream, "\n");
#line 106
  tileno = 0;
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 106
      goto while_break___0;
    }
    {
#line 107
    fprintf(stream, "%4d %9d %9d %9d %9d", (cstr_info->tile + tileno)->tileno, (cstr_info->tile + tileno)->start_pos,
            (cstr_info->tile + tileno)->end_header, (cstr_info->tile + tileno)->end_pos,
            (cstr_info->tile + tileno)->num_tps);
    }
#line 113
    if (disto_on) {
      {
#line 114
      fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile);
      }
    }
#line 115
    if (numpix_on) {
      {
#line 116
      fprintf(stream, " %9d", (cstr_info->tile + tileno)->numpix);
      }
    }
#line 117
    if ((int )disto_on) {
#line 117
      if ((int )numpix_on) {
        {
#line 118
        fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile / (double )(cstr_info->tile + tileno)->numpix);
        }
      }
    }
    {
#line 119
    fprintf(stream, "\n");
    }
#line 106
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  tileno = 0;
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 122
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 122
      goto while_break___1;
    }
#line 124
    disto = (double )0;
#line 125
    max_numdecompos = 0;
#line 126
    pack_nb = 0;
#line 128
    compno = 0;
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 128
      if (! (compno < cstr_info->numcomps)) {
#line 128
        goto while_break___2;
      }
#line 129
      if (max_numdecompos < *(cstr_info->numdecompos + compno)) {
#line 130
        max_numdecompos = *(cstr_info->numdecompos + compno);
      }
#line 128
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 133
    fprintf(stream, "\nTILE %d DETAILS\n", tileno);
#line 134
    fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
#line 135
    tilepartno = 0;
    }
    {
#line 135
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 135
      if (! (tilepartno < (cstr_info->tile + tileno)->num_tps)) {
#line 135
        goto while_break___3;
      }
      {
#line 136
      fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n\230\001", tilepartno, tileno,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pack, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_numpacks,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pos, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_header,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_pos);
      }
#line 135
      tilepartno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 145
    if ((int )cstr_info->prog == 0) {
      {
#line 146
      fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
      }
#line 147
      if (disto_on) {
        {
#line 148
        fprintf(stream, " disto");
        }
      }
      {
#line 149
      fprintf(stream, "\n");
#line 151
      layno = 0;
      }
      {
#line 151
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 151
        if (! (layno < cstr_info->numlayers)) {
#line 151
          goto while_break___4;
        }
#line 152
        resno = 0;
        {
#line 152
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 152
          if (! (resno < max_numdecompos + 1)) {
#line 152
            goto while_break___5;
          }
#line 153
          compno = 0;
          {
#line 153
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 153
            if (! (compno < cstr_info->numcomps)) {
#line 153
              goto while_break___6;
            }
#line 155
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 156
              goto while_break___6;
            }
#line 157
            prec_max = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 158
            precno = 0;
            {
#line 158
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 158
              if (! (precno < prec_max)) {
#line 158
                goto while_break___7;
              }
              {
#line 159
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 160
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 161
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 162
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 163
              fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d", pack_nb,
                      tileno, layno, resno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 165
              if (disto_on) {
                {
#line 166
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 167
              fprintf(stream, "\n");
#line 168
              total_disto += disto;
#line 169
              pack_nb ++;
              }
#line 158
              precno ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 153
            compno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 152
          resno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 151
        layno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 176
    if ((int )cstr_info->prog == 1) {
      {
#line 177
      fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
      }
#line 178
      if (disto_on) {
        {
#line 179
        fprintf(stream, " disto");
        }
      }
      {
#line 180
      fprintf(stream, "\n");
#line 182
      resno = 0;
      }
      {
#line 182
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 182
        if (! (resno < max_numdecompos + 1)) {
#line 182
          goto while_break___8;
        }
#line 183
        layno = 0;
        {
#line 183
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 183
          if (! (layno < cstr_info->numlayers)) {
#line 183
            goto while_break___9;
          }
#line 184
          compno = 0;
          {
#line 184
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 184
            if (! (compno < cstr_info->numcomps)) {
#line 184
              goto while_break___10;
            }
#line 186
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 187
              goto while_break___10;
            }
#line 188
            prec_max___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 189
            precno = 0;
            {
#line 189
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 189
              if (! (precno < prec_max___0)) {
#line 189
                goto while_break___11;
              }
              {
#line 190
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 191
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 192
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 193
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 194
              fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d", pack_nb, tileno,
                      resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
              }
#line 196
              if (disto_on) {
                {
#line 197
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 198
              fprintf(stream, "\n");
#line 199
              total_disto += disto;
#line 200
              pack_nb ++;
              }
#line 189
              precno ++;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 184
            compno ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 183
          layno ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 182
        resno ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 207
    if ((int )cstr_info->prog == 2) {
      {
#line 209
      fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos");
      }
#line 210
      if (disto_on) {
        {
#line 211
        fprintf(stream, " disto");
        }
      }
      {
#line 212
      fprintf(stream, "\n");
#line 214
      resno = 0;
      }
      {
#line 214
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 214
        if (! (resno < max_numdecompos + 1)) {
#line 214
          goto while_break___12;
        }
#line 215
        numprec = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 216
        precno = 0;
        {
#line 216
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 216
          if (! (precno < numprec)) {
#line 216
            goto while_break___13;
          }
          {
#line 218
          __cil_tmp40 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 218
          x0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp40 * cstr_info->tw) * cstr_info->tile_x;
#line 219
          __cil_tmp42 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 219
          y0___21 = cstr_info->tile_Ox + (int )__cil_tmp42 * cstr_info->tile_y;
#line 220
          x1 = x0 + cstr_info->tile_x;
#line 221
          y1___22 = y0___21 + cstr_info->tile_y;
#line 222
          compno = 0;
          }
          {
#line 222
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 222
            if (! (compno < cstr_info->numcomps)) {
#line 222
              goto while_break___14;
            }
            {
#line 223
            pcnx = (cstr_info->tile + tileno)->pw[resno];
#line 224
            __cil_tmp47 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 224
            pcx = (int )__cil_tmp47;
#line 225
            __cil_tmp49 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 225
            pcy = (int )__cil_tmp49;
#line 226
            __cil_tmp51 = floor((double )((float )precno / (float )pcnx));
#line 226
            precno_x = precno - (int )__cil_tmp51 * pcnx;
#line 227
            __cil_tmp53 = floor((double )((float )precno / (float )pcnx));
#line 227
            precno_y = (int )__cil_tmp53;
            }
#line 228
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 229
              goto while_break___14;
            }
#line 230
            y = y0___21;
            {
#line 230
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 230
              if (! (y < y1___22)) {
#line 230
                goto while_break___15;
              }
#line 231
              if (precno_y * pcy == y) {
#line 232
                x = x0;
                {
#line 232
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 232
                  if (! (x < x1)) {
#line 232
                    goto while_break___16;
                  }
#line 233
                  if (precno_x * pcx == x) {
#line 234
                    layno = 0;
                    {
#line 234
                    while (1) {
                      while_continue___17: /* CIL Label */ ;
#line 234
                      if (! (layno < cstr_info->numlayers)) {
#line 234
                        goto while_break___17;
                      }
                      {
#line 235
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 236
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 237
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 238
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 239
                      fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d", pack_nb,
                              tileno, resno, precno, compno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 241
                      if (disto_on) {
                        {
#line 242
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 243
                      fprintf(stream, "\n");
#line 244
                      total_disto += disto;
#line 245
                      pack_nb ++;
                      }
#line 234
                      layno ++;
                    }
                    while_break___17: /* CIL Label */ ;
                    }
                  }
#line 232
                  x ++;
                }
                while_break___16: /* CIL Label */ ;
                }
              }
#line 230
              y ++;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 222
            compno ++;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 216
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 214
        resno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    } else
#line 256
    if ((int )cstr_info->prog == 3) {
      {
#line 258
      __cil_tmp62 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 258
      x0___0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp62 * cstr_info->tw) * cstr_info->tile_x;
#line 259
      __cil_tmp64 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 259
      y0___23 = cstr_info->tile_Ox + (int )__cil_tmp64 * cstr_info->tile_y;
#line 260
      x1___0 = x0___0 + cstr_info->tile_x;
#line 261
      y1___24 = y0___23 + cstr_info->tile_y;
#line 264
      max_numprec = 0;
#line 265
      resno = 0;
      }
      {
#line 265
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 265
        if (! (resno < max_numdecompos + 1)) {
#line 265
          goto while_break___18;
        }
#line 266
        numprec___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 267
        if (numprec___0 > max_numprec) {
#line 268
          max_numprec = numprec___0;
        }
#line 265
        resno ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 271
      fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos");
      }
#line 272
      if (disto_on) {
        {
#line 273
        fprintf(stream, " disto");
        }
      }
      {
#line 274
      fprintf(stream, "\n");
#line 276
      precno = 0;
      }
      {
#line 276
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 276
        if (! (precno < max_numprec)) {
#line 276
          goto while_break___19;
        }
#line 277
        compno = 0;
        {
#line 277
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 277
          if (! (compno < cstr_info->numcomps)) {
#line 277
            goto while_break___20;
          }
#line 278
          resno = 0;
          {
#line 278
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 278
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 278
              goto while_break___21;
            }
            {
#line 279
            numprec___1 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 280
            pcnx___0 = (cstr_info->tile + tileno)->pw[resno];
#line 281
            __cil_tmp73 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 281
            pcx___0 = (int )__cil_tmp73;
#line 282
            __cil_tmp75 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 282
            pcy___0 = (int )__cil_tmp75;
#line 283
            __cil_tmp77 = floor((double )((float )precno / (float )pcnx___0));
#line 283
            precno_x___0 = precno - (int )__cil_tmp77 * pcnx___0;
#line 284
            __cil_tmp79 = floor((double )((float )precno / (float )pcnx___0));
#line 284
            precno_y___0 = (int )__cil_tmp79;
            }
#line 285
            if (precno >= numprec___1) {
#line 286
              goto while_continue___21;
            }
#line 287
            y = y0___23;
            {
#line 287
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 287
              if (! (y < y1___24)) {
#line 287
                goto while_break___22;
              }
#line 288
              if (precno_y___0 * pcy___0 == y) {
#line 289
                x = x0___0;
                {
#line 289
                while (1) {
                  while_continue___23: /* CIL Label */ ;
#line 289
                  if (! (x < x1___0)) {
#line 289
                    goto while_break___23;
                  }
#line 290
                  if (precno_x___0 * pcx___0 == x) {
#line 291
                    layno = 0;
                    {
#line 291
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 291
                      if (! (layno < cstr_info->numlayers)) {
#line 291
                        goto while_break___24;
                      }
                      {
#line 292
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 293
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 294
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 295
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 296
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d", pack_nb,
                              tileno, precno, compno, resno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 298
                      if (disto_on) {
                        {
#line 299
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 300
                      fprintf(stream, "\n");
#line 301
                      total_disto += disto;
#line 302
                      pack_nb ++;
                      }
#line 291
                      layno ++;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                  }
#line 289
                  x ++;
                }
                while_break___23: /* CIL Label */ ;
                }
              }
#line 287
              y ++;
            }
            while_break___22: /* CIL Label */ ;
            }
#line 278
            resno ++;
          }
          while_break___21: /* CIL Label */ ;
          }
#line 277
          compno ++;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 276
        precno ++;
      }
      while_break___19: /* CIL Label */ ;
      }
    } else {
#line 315
      max_numprec___0 = 0;
#line 316
      resno = 0;
      {
#line 316
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 316
        if (! (resno < max_numdecompos + 1)) {
#line 316
          goto while_break___25;
        }
#line 317
        numprec___2 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 318
        if (numprec___2 > max_numprec___0) {
#line 319
          max_numprec___0 = numprec___2;
        }
#line 316
        resno ++;
      }
      while_break___25: /* CIL Label */ ;
      }
      {
#line 322
      fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos");
      }
#line 323
      if (disto_on) {
        {
#line 324
        fprintf(stream, " disto");
        }
      }
      {
#line 325
      fprintf(stream, "\n");
#line 327
      compno = 0;
      }
      {
#line 327
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 327
        if (! (compno < cstr_info->numcomps)) {
#line 327
          goto while_break___26;
        }
        {
#line 329
        __cil_tmp91 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 329
        x0___1 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp91 * cstr_info->tw) * cstr_info->tile_x;
#line 330
        __cil_tmp93 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 330
        y0___25 = cstr_info->tile_Ox + (int )__cil_tmp93 * cstr_info->tile_y;
#line 331
        x1___1 = x0___1 + cstr_info->tile_x;
#line 332
        y1___26 = y0___25 + cstr_info->tile_y;
#line 334
        precno = 0;
        }
        {
#line 334
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 334
          if (! (precno < max_numprec___0)) {
#line 334
            goto while_break___27;
          }
#line 335
          resno = 0;
          {
#line 335
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 335
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 335
              goto while_break___28;
            }
            {
#line 336
            numprec___3 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 337
            pcnx___1 = (cstr_info->tile + tileno)->pw[resno];
#line 338
            __cil_tmp99 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 338
            pcx___1 = (int )__cil_tmp99;
#line 339
            __cil_tmp101 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 339
            pcy___1 = (int )__cil_tmp101;
#line 340
            __cil_tmp103 = floor((double )((float )precno / (float )pcnx___1));
#line 340
            precno_x___1 = precno - (int )__cil_tmp103 * pcnx___1;
#line 341
            __cil_tmp105 = floor((double )((float )precno / (float )pcnx___1));
#line 341
            precno_y___1 = (int )__cil_tmp105;
            }
#line 342
            if (precno >= numprec___3) {
#line 343
              goto while_continue___28;
            }
#line 345
            y = y0___25;
            {
#line 345
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 345
              if (! (y < y1___26)) {
#line 345
                goto while_break___29;
              }
#line 346
              if (precno_y___1 * pcy___1 == y) {
#line 347
                x = x0___1;
                {
#line 347
                while (1) {
                  while_continue___30: /* CIL Label */ ;
#line 347
                  if (! (x < x1___1)) {
#line 347
                    goto while_break___30;
                  }
#line 348
                  if (precno_x___1 * pcx___1 == x) {
#line 349
                    layno = 0;
                    {
#line 349
                    while (1) {
                      while_continue___31: /* CIL Label */ ;
#line 349
                      if (! (layno < cstr_info->numlayers)) {
#line 349
                        goto while_break___31;
                      }
                      {
#line 350
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 351
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 352
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 353
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 354
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d", pack_nb,
                              tileno, compno, precno, resno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 356
                      if (disto_on) {
                        {
#line 357
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 358
                      fprintf(stream, "\n");
#line 359
                      total_disto += disto;
#line 360
                      pack_nb ++;
                      }
#line 349
                      layno ++;
                    }
                    while_break___31: /* CIL Label */ ;
                    }
                  }
#line 347
                  x ++;
                }
                while_break___30: /* CIL Label */ ;
                }
              }
#line 345
              y ++;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 335
            resno ++;
          }
          while_break___28: /* CIL Label */ ;
          }
#line 334
          precno ++;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 327
        compno ++;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 122
    tileno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 372
  if (disto_on) {
    {
#line 373
    fprintf(stream, "%8e\n", cstr_info->D_max);
#line 374
    fprintf(stream, "%.8e\n", total_disto);
    }
  }
#line 378
  if (cstr_info->marknum) {
    {
#line 379
    fprintf(stream, "\nMARKER LIST\n");
#line 380
    fprintf(stream, "%d\n", cstr_info->marknum);
#line 381
    fprintf(stream, "type\tstart_pos    length\n");
#line 382
    x = 0;
    }
    {
#line 382
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 382
      if (! (x < cstr_info->marknum)) {
#line 382
        goto while_break___32;
      }
      {
#line 383
      fprintf(stream, "%X\t%9d %9d\n", (int )(cstr_info->marker + x)->type, (cstr_info->marker + x)->pos,
              (cstr_info->marker + x)->len);
      }
#line 382
      x ++;
    }
    while_break___32: /* CIL Label */ ;
    }
  }
  {
#line 386
  fclose(stream);
#line 388
  fprintf(stderr, "Generated index file %s\n\230\001", index___0);
  }
#line 390
  return (0);
}
}
#line 41 "/root/patchweave_new/14/applications/codec/../common/opj_getopt.c"
int opj_opterr  =    1;
#line 42 "/root/patchweave_new/14/applications/codec/../common/opj_getopt.c"
int opj_optind  =    1;
#line 49 "/root/patchweave_new/14/applications/codec/../common/opj_getopt.c"
static char EMSG[1]  = {      "\250"};
#line 52 "/root/patchweave_new/14/applications/codec/../common/opj_getopt.c"
void reset_options_reading(void) 
{ 


  {
#line 53
  opj_opterr = 1;
#line 54
  opj_optind = 1;
  return;
}
}
#line 61 "/root/patchweave_new/14/applications/codec/../common/opj_getopt.c"
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ 
  static char *place ;
  char *oli ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 63
  place = (char *)EMSG;
#line 64
  oli = (char *)((void *)0);
#line 66
  if (opj_optreset) {
    _L: /* CIL Label */ 
#line 67
    opj_optreset = 0;
#line 68
    place = *(nargv + opj_optind);
#line 68
    if (opj_optind >= nargc) {
#line 69
      place = (char *)EMSG;
#line 70
      return (- 1);
    } else
#line 68
    if ((int )*place != 45) {
#line 69
      place = (char *)EMSG;
#line 70
      return (- 1);
    }
#line 72
    place ++;
#line 72
    if ((int )*(place + 1)) {
#line 72
      if ((int )*place == 45) {
#line 73
        opj_optind ++;
#line 74
        place = (char *)EMSG;
#line 75
        return (- 1);
      }
    }
  } else
#line 66
  if (! *place) {
#line 66
    goto _L;
  }
  {
#line 78
  oli = strchr(ostr, opj_optopt);
  }
#line 78
  __cil_tmp6 = place;
#line 78
  place ++;
#line 78
  opj_optopt = (int )*__cil_tmp6;
#line 78
  if (! oli) {
    _L___27: /* CIL Label */ 
#line 84
    if (opj_optopt == 45) {
#line 85
      return (- 1);
    }
#line 86
    if (! *place) {
#line 87
      opj_optind ++;
    }
#line 88
    if (opj_opterr) {
#line 88
      if ((int )*ostr != 58) {
        {
#line 89
        fprintf(stderr, "%s: illegal option -- %c\ny\353\336\342U", *(nargv + 0),
                opj_optopt);
        }
#line 91
        return ((int )'?');
      }
    }
  } else
#line 78
  if (opj_optopt == 58) {
#line 78
    goto _L___27;
  }
#line 94
  oli ++;
#line 94
  if ((int )*oli != 58) {
#line 95
    opj_optarg = (char *)((void *)0);
#line 96
    if (! *place) {
#line 97
      opj_optind ++;
    }
  } else {
#line 99
    if (*place) {
#line 100
      opj_optarg = place;
    } else {
#line 101
      opj_optind ++;
#line 101
      if (nargc <= opj_optind) {
#line 102
        place = (char *)EMSG;
#line 103
        if ((int )*ostr == 58) {
#line 104
          return ((int )':');
        }
#line 105
        if (opj_opterr) {
          {
#line 106
          fprintf(stderr, "%s: option requires an argument -- %c\n", *(nargv + 0),
                  opj_optopt);
          }
#line 109
          return ((int )'?');
        }
      } else {
#line 112
        opj_optarg = *(nargv + opj_optind);
      }
    }
#line 113
    place = (char *)EMSG;
#line 114
    opj_optind ++;
  }
#line 116
  return (opj_optopt);
}
}
#line 120 "/root/patchweave_new/14/applications/codec/../common/opj_getopt.c"
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) 
{ 
  static int lastidx ;
  static int lastofs ;
  char *tmp ;
  int i ;
  int len ;
  char param ;
  char *arg ;
  opj_option_t *o ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_option_t *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 125
  param = (char )1;
  again: 
#line 128
  if (! argv[opj_optind]) {
#line 129
    return (- 1);
  } else
#line 128
  if (opj_optind >= argc) {
#line 129
    return (- 1);
  } else
#line 128
  if ((int )*(argv[opj_optind]) != 45) {
#line 129
    return (- 1);
  }
#line 131
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 131
    if ((int )*(argv[opj_optind] + 1) == 0) {
#line 132
      if (opj_optind >= argc - 1) {
#line 133
        param = (char )0;
      } else
#line 136
      if ((int )*(argv[opj_optind + 1] + 0) == 45) {
#line 137
        param = (char )0;
      } else {
#line 140
        param = (char )2;
      }
    }
  }
#line 145
  if ((int )param == 0) {
#line 146
    opj_optind ++;
#line 147
    return ((int )'?');
  }
#line 150
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 151
    arg = argv[opj_optind] + 1;
#line 153
    o = longopts;
#line 154
    len = (int )sizeof(*(longopts + 0));
#line 156
    if ((int )param > 1) {
#line 157
      arg = argv[opj_optind + 1];
#line 158
      opj_optind ++;
    } else {
#line 161
      arg = argv[opj_optind] + 1;
    }
    {
#line 163
    __cil_tmp15 = strlen((char const   *)arg);
    }
#line 163
    if (__cil_tmp15 > 1UL) {
#line 164
      i = 0;
      {
#line 164
      while (1) {
        while_continue: /* CIL Label */ ;
#line 164
        if (! (i < totlen)) {
#line 164
          goto while_break;
        }
        {
#line 165
        __cil_tmp16 = strcmp(o->name, (char const   *)arg);
        }
#line 165
        if (! __cil_tmp16) {
#line 166
          if (o->has_arg == 0) {
#line 167
            if (argv[opj_optind + 1]) {
#line 167
              if (! ((int )*(argv[opj_optind + 1] + 0) == 45)) {
                {
#line 168
                fprintf(stderr, "%s: option does not require an argument. Ignoring %s\n",
                        arg, argv[opj_optind + 1]);
#line 169
                opj_optind ++;
                }
              }
            }
          } else {
#line 172
            opj_optarg = argv[opj_optind + 1];
#line 173
            if (opj_optarg) {
#line 174
              if ((int )*(opj_optarg + 0) == 45) {
#line 175
                if (opj_opterr) {
                  {
#line 176
                  fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                  }
#line 177
                  return ((int )'?');
                }
              }
            }
#line 181
            if (! opj_optarg) {
#line 181
              if (o->has_arg == 1) {
#line 182
                if (opj_opterr) {
                  {
#line 183
                  fprintf(stderr, "%s: option requires an argument \n", arg);
                  }
#line 184
                  return ((int )'?');
                }
              }
            }
#line 187
            opj_optind ++;
          }
#line 189
          opj_optind ++;
#line 190
          if (o->flag) {
#line 191
            *(o->flag) = o->val;
          } else {
#line 193
            return (o->val);
          }
#line 194
          return (0);
        }
#line 164
        __cil_tmp17 = o;
#line 164
        o ++;
#line 164
        i += len;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 197
      fprintf(stderr, "Invalid option %s\n", arg);
#line 198
      opj_optind ++;
      }
#line 199
      return ((int )'?');
    } else {
#line 201
      if ((int )*optstring == 58) {
#line 201
        return (':');
      }
#line 202
      if (lastidx != opj_optind) {
#line 203
        lastidx = opj_optind;
#line 203
        lastofs = 0;
      }
      {
#line 205
      opj_optopt = (int )*(argv[opj_optind] + (lastofs + 1));
#line 206
      tmp = strchr(optstring, opj_optopt);
      }
#line 206
      if (tmp) {
#line 207
        if ((int )*tmp == 0) {
#line 208
          opj_optind ++;
#line 209
          goto again;
        }
#line 211
        if ((int )*(tmp + 1) == 58) {
#line 212
          if ((int )*(tmp + 2) == 58) {
            _L: /* CIL Label */ 
#line 213
            opj_optarg = (argv[opj_optind] + lastofs) + 2;
#line 213
            if (! *opj_optarg) {
#line 213
              opj_optarg = (char *)0;
            }
#line 214
            goto found;
          } else
#line 212
          if ((int )*(argv[opj_optind] + (lastofs + 2))) {
#line 212
            goto _L;
          }
#line 216
          opj_optarg = argv[opj_optind + 1];
#line 217
          if (opj_optarg) {
#line 218
            if ((int )*(opj_optarg + 0) == 45) {
#line 219
              if (opj_opterr) {
                {
#line 220
                fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                }
#line 221
                return ((int )'?');
              }
            }
          }
#line 225
          if (! opj_optarg) {
#line 226
            if (opj_opterr) {
              {
#line 227
              fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
              }
#line 228
              return ((int )'?');
            }
          }
#line 231
          opj_optind ++;
        } else {
#line 233
          lastofs ++;
#line 234
          return (opj_optopt);
        }
        found: 
#line 237
        opj_optind ++;
#line 238
        return (opj_optopt);
      } else {
        {
#line 240
        fprintf(stderr, "Invalid option %s\n", arg);
#line 241
        opj_optind ++;
        }
#line 242
        return ((int )'?');
      }
    }
  }
  {
#line 247
  fprintf(stderr, "Invalid option\n");
#line 248
  opj_optind ++;
  }
#line 249
  return ((int )'?');

}
}
