/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 823
struct obstack ;
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef int wchar_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 323 "/root/patchweave_donee/23/src/sndfile.h"
struct SNDFILE_tag ;
#line 323 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct SNDFILE_tag SNDFILE;
#line 336 "/root/patchweave_donee/23/src/sndfile.h"
typedef int64_t sf_count_t;
#line 346 "/root/patchweave_donee/23/src/sndfile.h"
struct SF_INFO {
   sf_count_t frames ;
   int samplerate ;
   int channels ;
   int format ;
   int sections ;
   int seekable ;
};
#line 355 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct SF_INFO SF_INFO;
#line 368 "/root/patchweave_donee/23/src/sndfile.h"
struct __anonstruct_29 {
   int format ;
   char const   *name ;
   char const   *extension ;
};
#line 372 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct __anonstruct_29 SF_FORMAT_INFO;
#line 389 "/root/patchweave_donee/23/src/sndfile.h"
struct __anonstruct_31 {
   int type ;
   double level ;
   char const   *name ;
};
#line 393 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct __anonstruct_31 SF_DITHER_INFO;
#line 399 "/root/patchweave_donee/23/src/sndfile.h"
struct __anonstruct_32 {
   sf_count_t offset ;
   sf_count_t length ;
};
#line 402 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct __anonstruct_32 SF_EMBED_FILE_INFO;
#line 425 "/root/patchweave_donee/23/src/sndfile.h"
struct __anonstruct_35 {
   int mode ;
   uint32_t start ;
   uint32_t end ;
   uint32_t count ;
};
#line 418 "/root/patchweave_donee/23/src/sndfile.h"
struct __anonstruct_34 {
   int gain ;
   char basenote ;
   char detune ;
   char velocity_lo ;
   char velocity_hi ;
   char key_lo ;
   char key_hi ;
   int loop_count ;
   struct __anonstruct_35 loops[16] ;
};
#line 431 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct __anonstruct_34 SF_INSTRUMENT;
#line 436 "/root/patchweave_donee/23/src/sndfile.h"
struct __anonstruct_36 {
   short time_sig_num ;
   short time_sig_den ;
   int loop_mode ;
   int num_beats ;
   float bpm ;
   int root_key ;
   int future[6] ;
};
#line 452 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct __anonstruct_36 SF_LOOP_INFO;
#line 475 "/root/patchweave_donee/23/src/sndfile.h"
struct __anonstruct_37 {
   char description[256] ;
   char originator[32] ;
   char originator_reference[32] ;
   char origination_date[10] ;
   char origination_time[8] ;
   uint32_t time_reference_low ;
   uint32_t time_reference_high ;
   short version ;
   char umid[64] ;
   char reserved[190] ;
   uint32_t coding_history_size ;
   char coding_history[256] ;
};
#line 475 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct __anonstruct_37 SF_BROADCAST_INFO;
#line 477 "/root/patchweave_donee/23/src/sndfile.h"
struct SF_CART_TIMER {
   char usage[4] ;
   int32_t value ;
};
#line 482 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct SF_CART_TIMER SF_CART_TIMER;
#line 509 "/root/patchweave_donee/23/src/sndfile.h"
struct __anonstruct_38 {
   char version[4] ;
   char title[64] ;
   char artist[64] ;
   char cut_id[64] ;
   char client_id[64] ;
   char category[64] ;
   char classification[64] ;
   char out_cue[64] ;
   char start_date[10] ;
   char start_time[8] ;
   char end_date[10] ;
   char end_time[8] ;
   char producer_app_id[64] ;
   char producer_app_version[64] ;
   char user_def[64] ;
   int32_t level_reference ;
   SF_CART_TIMER post_timers[8] ;
   char reserved[276] ;
   char url[1024] ;
   uint32_t tag_text_size ;
   char tag_text[256] ;
};
#line 509 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct __anonstruct_38 SF_CART_INFO;
#line 519 "/root/patchweave_donee/23/src/sndfile.h"
struct SF_VIRTUAL_IO {
   sf_count_t (*get_filelen)(void * ) ;
   sf_count_t (*seek)(sf_count_t  , int  , void * ) ;
   sf_count_t (*read)(void * , sf_count_t  , void * ) ;
   sf_count_t (*write)(void const   * , sf_count_t  , void * ) ;
   sf_count_t (*tell)(void * ) ;
};
#line 527 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct SF_VIRTUAL_IO SF_VIRTUAL_IO;
#line 742 "/root/patchweave_donee/23/src/sndfile.h"
struct SF_CHUNK_INFO {
   char id[64] ;
   unsigned int id_size ;
   unsigned int datalen ;
   void *data ;
};
#line 749 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct SF_CHUNK_INFO SF_CHUNK_INFO;
#line 761
struct SF_CHUNK_ITERATOR ;
#line 761 "/root/patchweave_donee/23/src/sndfile.h"
typedef struct SF_CHUNK_ITERATOR SF_CHUNK_ITERATOR;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 180 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_43 {
   unsigned int kuki_offset ;
   unsigned int pakt_offset ;
   unsigned int bits_per_sample ;
   unsigned int frames_per_packet ;
   int64_t packets ;
   int64_t valid_frames ;
   int32_t priming_frames ;
   int32_t remainder_frames ;
};
#line 191 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_43 ALAC_DECODER_INFO;
#line 198 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_44 {
   double value ;
   sf_count_t position ;
};
#line 201 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_44 PEAK_POS;
#line 203 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_45 {
   int peak_loc ;
   unsigned int version ;
   unsigned int timestamp ;
   unsigned int edit_number ;
   PEAK_POS peaks[] ;
};
#line 216 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_45 PEAK_INFO;
#line 223 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_46 {
   int type ;
   int flags ;
   size_t offset ;
};
#line 227 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_46 STR_DATA;
#line 229 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_47 {
   int64_t hash ;
   char id[64] ;
   unsigned int id_size ;
   uint32_t mark32 ;
   sf_count_t offset ;
   uint32_t len ;
};
#line 236 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_47 READ_CHUNK;
#line 238 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_48 {
   int64_t hash ;
   uint32_t mark32 ;
   uint32_t len ;
   void *data ;
};
#line 243 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_48 WRITE_CHUNK;
#line 245 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_49 {
   uint32_t count ;
   uint32_t used ;
   READ_CHUNK *chunks ;
};
#line 249 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_49 READ_CHUNKS;
#line 250 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_50 {
   uint32_t count ;
   uint32_t used ;
   WRITE_CHUNK *chunks ;
};
#line 254 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_50 WRITE_CHUNKS;
#line 256 "/root/patchweave_donee/23/src/common.h"
struct SF_CHUNK_ITERATOR {
   uint32_t current ;
   int64_t hash ;
   char id[64] ;
   unsigned int id_size ;
   SNDFILE *sndfile ;
};
#line 269 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_51 {
   char description[256] ;
   char originator[32] ;
   char originator_reference[32] ;
   char origination_date[10] ;
   char origination_time[8] ;
   uint32_t time_reference_low ;
   uint32_t time_reference_high ;
   short version ;
   char umid[64] ;
   char reserved[190] ;
   uint32_t coding_history_size ;
   char coding_history[16384] ;
};
#line 269 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_51 SF_BROADCAST_INFO_16K;
#line 271 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_52 {
   char version[4] ;
   char title[64] ;
   char artist[64] ;
   char cut_id[64] ;
   char client_id[64] ;
   char category[64] ;
   char classification[64] ;
   char out_cue[64] ;
   char start_date[10] ;
   char start_time[8] ;
   char end_date[10] ;
   char end_time[8] ;
   char producer_app_id[64] ;
   char producer_app_version[64] ;
   char user_def[64] ;
   int32_t level_reference ;
   SF_CART_TIMER post_timers[8] ;
   char reserved[276] ;
   char url[1024] ;
   uint32_t tag_text_size ;
   char tag_text[16384] ;
};
#line 271 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_52 SF_CART_INFO_16K;
#line 276 "/root/patchweave_donee/23/src/common.h"
typedef int16_t sfwchar_t;
#line 303 "/root/patchweave_donee/23/src/common.h"
union __anonunion_54 {
   char c[1024] ;
   sfwchar_t wc[1024] ;
};
#line 308 "/root/patchweave_donee/23/src/common.h"
union __anonunion_55 {
   char c[1024] ;
   sfwchar_t wc[1024] ;
};
#line 313 "/root/patchweave_donee/23/src/common.h"
union __anonunion_56 {
   char c[256] ;
   sfwchar_t wc[256] ;
};
#line 301 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_53 {
   union __anonunion_54 path ;
   union __anonunion_55 dir ;
   union __anonunion_56 name ;
   int filedes ;
   int savedes ;
   int do_not_close_descriptor ;
   int mode ;
};
#line 333 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_53 PSF_FILE;
#line 337 "/root/patchweave_donee/23/src/common.h"
union __anonunion_57 {
   double dbuf[1024] ;
   int64_t lbuf[1024] ;
   float fbuf[2048] ;
   int ibuf[2048] ;
   short sbuf[4096] ;
   char cbuf[8192] ;
   signed char scbuf[8192] ;
   unsigned char ucbuf[8192] ;
};
#line 350 "/root/patchweave_donee/23/src/common.h"
typedef union __anonunion_57 BUF_UNION;
#line 357 "/root/patchweave_donee/23/src/common.h"
union __anonunion_58 {
   double d[2] ;
   char c[16] ;
};
#line 370 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_59 {
   char buf[2048] ;
   int indx ;
};
#line 381 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_60 {
   STR_DATA data[32] ;
   char *storage ;
   size_t storage_len ;
   size_t storage_used ;
   uint32_t flags ;
};
#line 354 "/root/patchweave_donee/23/src/common.h"
struct sf_private_tag {
   union __anonunion_58 canary ;
   PSF_FILE file ;
   PSF_FILE rsrc ;
   char syserr[256] ;
   struct __anonstruct_59 parselog ;
   unsigned char header[12292] ;
   int rwf_endian ;
   struct __anonstruct_60 strings ;
   int Magick ;
   unsigned int unique_id ;
   int headindex ;
   int headend ;
   int has_text ;
   int error ;
   int endian ;
   int data_endswap ;
   int float_int_mult ;
   float float_max ;
   int scale_int_float ;
   int is_pipe ;
   sf_count_t pipeoffset ;
   int add_clipping ;
   SF_INFO sf ;
   int have_written ;
   PEAK_INFO *peak_info ;
   SF_LOOP_INFO *loop_info ;
   SF_INSTRUMENT *instrument ;
   SF_BROADCAST_INFO_16K *broadcast_16k ;
   SF_CART_INFO_16K *cart_16k ;
   int *channel_map ;
   sf_count_t filelength ;
   sf_count_t fileoffset ;
   sf_count_t rsrclength ;
   sf_count_t dataoffset ;
   sf_count_t datalength ;
   sf_count_t dataend ;
   int blockwidth ;
   int bytewidth ;
   void *dither ;
   void *interleave ;
   int last_op ;
   sf_count_t read_current ;
   sf_count_t write_current ;
   void *container_data ;
   void *codec_data ;
   SF_DITHER_INFO write_dither ;
   SF_DITHER_INFO read_dither ;
   int norm_double ;
   int norm_float ;
   int auto_header ;
   int ieee_replace ;
   sf_count_t (*read_short)(struct sf_private_tag * , short * , sf_count_t  ) ;
   sf_count_t (*read_int)(struct sf_private_tag * , int * , sf_count_t  ) ;
   sf_count_t (*read_float)(struct sf_private_tag * , float * , sf_count_t  ) ;
   sf_count_t (*read_double)(struct sf_private_tag * , double * , sf_count_t  ) ;
   sf_count_t (*write_short)(struct sf_private_tag * , short const   * , sf_count_t  ) ;
   sf_count_t (*write_int)(struct sf_private_tag * , int const   * , sf_count_t  ) ;
   sf_count_t (*write_float)(struct sf_private_tag * , float const   * , sf_count_t  ) ;
   sf_count_t (*write_double)(struct sf_private_tag * , double const   * , sf_count_t  ) ;
   sf_count_t (*seek)(struct sf_private_tag * , int  , sf_count_t  ) ;
   int (*write_header)(struct sf_private_tag * , int  ) ;
   int (*command)(struct sf_private_tag * , int  , void * , int  ) ;
   int (*byterate)(struct sf_private_tag * ) ;
   int (*codec_close)(struct sf_private_tag * ) ;
   int (*container_close)(struct sf_private_tag * ) ;
   char *format_desc ;
   int virtual_io ;
   SF_VIRTUAL_IO vio ;
   void *vio_user_data ;
   SF_CHUNK_ITERATOR *iterator ;
   READ_CHUNKS rchunks ;
   WRITE_CHUNKS wchunks ;
   int (*set_chunk)(struct sf_private_tag * , SF_CHUNK_INFO * ) ;
   SF_CHUNK_ITERATOR *(*next_chunk_iterator)(struct sf_private_tag * , SF_CHUNK_ITERATOR * ) ;
   int (*get_chunk_size)(struct sf_private_tag * , SF_CHUNK_ITERATOR * , SF_CHUNK_INFO * ) ;
   int (*get_chunk_data)(struct sf_private_tag * , SF_CHUNK_ITERATOR * , SF_CHUNK_INFO * ) ;
};
#line 514 "/root/patchweave_donee/23/src/common.h"
typedef struct sf_private_tag SF_PRIVATE;
#line 977 "/root/patchweave_donee/23/src/common.h"
struct __anonstruct_62 {
   int channels ;
   int endianness ;
};
#line 980 "/root/patchweave_donee/23/src/common.h"
typedef struct __anonstruct_62 AUDIO_DETECT;
#line 26 "/root/patchweave_donee/23/src/ima_oki_adpcm.h"
struct __anonstruct_64 {
   int mask ;
   int last_output ;
   int step_index ;
   int max_step_index ;
   int const   *steps ;
   int errors ;
   int code_count ;
   int pcm_count ;
   unsigned char codes[256] ;
   short pcm[512] ;
};
#line 41 "/root/patchweave_donee/23/src/ima_oki_adpcm.h"
typedef struct __anonstruct_64 IMA_OKI_ADPCM;
#line 43
enum __anonenum__65 {
    IMA_OKI_ADPCM_TYPE_IMA = 0,
    IMA_OKI_ADPCM_TYPE_OKI = 1
} ;
#line 46 "/root/patchweave_donee/23/src/ima_oki_adpcm.h"
typedef enum __anonenum__65 IMA_OKI_ADPCM_TYPE;
#line 31 "/root/patchweave_donee/23/src/pcm.c"
typedef void tribyte;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 23 "/usr/include/ogg/config_types.h"
typedef int64_t ogg_int64_t;
#line 31 "/usr/include/ogg/ogg.h"
struct __anonstruct_279 {
   long endbyte ;
   int endbit ;
   unsigned char *buffer ;
   unsigned char *ptr ;
   long storage ;
};
#line 38 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_279 oggpack_buffer;
#line 42 "/usr/include/ogg/ogg.h"
struct __anonstruct_280 {
   unsigned char *header ;
   long header_len ;
   unsigned char *body ;
   long body_len ;
};
#line 47 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_280 ogg_page;
#line 52 "/usr/include/ogg/ogg.h"
struct __anonstruct_281 {
   unsigned char *body_data ;
   long body_storage ;
   long body_fill ;
   long body_returned ;
   int *lacing_vals ;
   ogg_int64_t *granule_vals ;
   long lacing_storage ;
   long lacing_fill ;
   long lacing_packet ;
   long lacing_returned ;
   unsigned char header[282] ;
   int header_fill ;
   int e_o_s ;
   int b_o_s ;
   long serialno ;
   long pageno ;
   ogg_int64_t packetno ;
   ogg_int64_t granulepos ;
};
#line 84 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_281 ogg_stream_state;
#line 89 "/usr/include/ogg/ogg.h"
struct __anonstruct_282 {
   unsigned char *packet ;
   long bytes ;
   long b_o_s ;
   long e_o_s ;
   ogg_int64_t granulepos ;
   ogg_int64_t packetno ;
};
#line 102 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_282 ogg_packet;
#line 104 "/usr/include/ogg/ogg.h"
struct __anonstruct_283 {
   unsigned char *data ;
   int storage ;
   int fill ;
   int returned ;
   int unsynced ;
   int headerbytes ;
   int bodybytes ;
};
#line 113 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_283 ogg_sync_state;
#line 31 "/root/patchweave_donee/23/src/ogg.h"
struct __anonstruct_285 {
   ogg_sync_state osync ;
   ogg_stream_state ostream ;
   ogg_page opage ;
   ogg_packet opacket ;
   int eos ;
   int codec ;
};
#line 42 "/root/patchweave_donee/23/src/ogg.h"
typedef struct __anonstruct_285 OGG_PRIVATE;
#line 203 "/root/patchweave_donee/23/src/ogg.c"
struct __anonstruct_286 {
   char const   *str ;
   char const   *name ;
   int len ;
   int codec ;
};
#line 153 "/root/patchweave_donee/23/src/wav_w64.h"
struct __anonstruct_287 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
};
#line 160 "/root/patchweave_donee/23/src/wav_w64.h"
typedef struct __anonstruct_287 MIN_WAV_FMT;
#line 162 "/root/patchweave_donee/23/src/wav_w64.h"
struct __anonstruct_288 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short dummy ;
};
#line 171 "/root/patchweave_donee/23/src/wav_w64.h"
typedef struct __anonstruct_288 WAV_FMT_SIZE20;
#line 183 "/root/patchweave_donee/23/src/wav_w64.h"
struct __anonstruct_290 {
   short coeff1 ;
   short coeff2 ;
};
#line 173 "/root/patchweave_donee/23/src/wav_w64.h"
struct __anonstruct_289 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short samplesperblock ;
   unsigned short numcoeffs ;
   struct __anonstruct_290 coeffs[7] ;
};
#line 187 "/root/patchweave_donee/23/src/wav_w64.h"
typedef struct __anonstruct_289 MS_ADPCM_WAV_FMT;
#line 189 "/root/patchweave_donee/23/src/wav_w64.h"
struct __anonstruct_291 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short samplesperblock ;
};
#line 198 "/root/patchweave_donee/23/src/wav_w64.h"
typedef struct __anonstruct_291 IMA_ADPCM_WAV_FMT;
#line 200 "/root/patchweave_donee/23/src/wav_w64.h"
struct __anonstruct_292 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short auxblocksize ;
};
#line 209 "/root/patchweave_donee/23/src/wav_w64.h"
typedef struct __anonstruct_292 G72x_ADPCM_WAV_FMT;
#line 212 "/root/patchweave_donee/23/src/wav_w64.h"
struct __anonstruct_293 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short samplesperblock ;
};
#line 221 "/root/patchweave_donee/23/src/wav_w64.h"
typedef struct __anonstruct_293 GSM610_WAV_FMT;
#line 223 "/root/patchweave_donee/23/src/wav_w64.h"
struct __anonstruct_294 {
   unsigned int esf_field1 ;
   unsigned short esf_field2 ;
   unsigned short esf_field3 ;
   char esf_field4[8] ;
};
#line 228 "/root/patchweave_donee/23/src/wav_w64.h"
typedef struct __anonstruct_294 EXT_SUBFORMAT;
#line 230 "/root/patchweave_donee/23/src/wav_w64.h"
struct __anonstruct_295 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short validbits ;
   unsigned int channelmask ;
   EXT_SUBFORMAT esf ;
};
#line 241 "/root/patchweave_donee/23/src/wav_w64.h"
typedef struct __anonstruct_295 EXTENSIBLE_WAV_FMT;
#line 243 "/root/patchweave_donee/23/src/wav_w64.h"
union __anonunion_296 {
   unsigned short format ;
   MIN_WAV_FMT min ;
   IMA_ADPCM_WAV_FMT ima ;
   MS_ADPCM_WAV_FMT msadpcm ;
   G72x_ADPCM_WAV_FMT g72x ;
   EXTENSIBLE_WAV_FMT ext ;
   GSM610_WAV_FMT gsm610 ;
   WAV_FMT_SIZE20 size20 ;
   char padding[512] ;
};
#line 253 "/root/patchweave_donee/23/src/wav_w64.h"
typedef union __anonunion_296 WAV_FMT;
#line 255 "/root/patchweave_donee/23/src/wav_w64.h"
struct __anonstruct_297 {
   int frames ;
};
#line 257 "/root/patchweave_donee/23/src/wav_w64.h"
typedef struct __anonstruct_297 FACT_CHUNK;
#line 259 "/root/patchweave_donee/23/src/wav_w64.h"
struct __anonstruct_298 {
   int wavex_ambisonic ;
   unsigned int wavex_channelmask ;
   int fmt_is_broken ;
   WAV_FMT wav_fmt ;
   int rf64_downgrade ;
};
#line 273 "/root/patchweave_donee/23/src/wav_w64.h"
typedef struct __anonstruct_298 WAV_PRIVATE;
#line 41 "/root/patchweave_donee/23/src/ms_adpcm.c"
struct __anonstruct_299 {
   int channels ;
   int blocksize ;
   int samplesperblock ;
   int blocks ;
   int dataremaining ;
   int blockcount ;
   int sync_error ;
   sf_count_t samplecount ;
   short *samples ;
   unsigned char *block ;
   short dummydata[] ;
};
#line 49 "/root/patchweave_donee/23/src/ms_adpcm.c"
typedef struct __anonstruct_299 MSADPCM_PRIVATE;
#line 28 "/root/patchweave_donee/23/src/interleave.c"
struct __anonstruct_361 {
   double buffer[1024] ;
   sf_count_t channel_len ;
   sf_count_t (*read_short)(SF_PRIVATE * , short * , sf_count_t  ) ;
   sf_count_t (*read_int)(SF_PRIVATE * , int * , sf_count_t  ) ;
   sf_count_t (*read_float)(SF_PRIVATE * , float * , sf_count_t  ) ;
   sf_count_t (*read_double)(SF_PRIVATE * , double * , sf_count_t  ) ;
};
#line 38 "/root/patchweave_donee/23/src/interleave.c"
typedef struct __anonstruct_361 INTERLEAVE_DATA;
#line 30 "/root/patchweave_donee/23/src/ima_adpcm.c"
struct IMA_ADPCM_PRIVATE_tag {
   int (*decode_block)(SF_PRIVATE * , struct IMA_ADPCM_PRIVATE_tag * ) ;
   int (*encode_block)(SF_PRIVATE * , struct IMA_ADPCM_PRIVATE_tag * ) ;
   int channels ;
   int blocksize ;
   int samplesperblock ;
   int blocks ;
   int blockcount ;
   int samplecount ;
   int previous[2] ;
   int stepindx[2] ;
   unsigned char *block ;
   short *samples ;
   short data[] ;
};
#line 41 "/root/patchweave_donee/23/src/ima_adpcm.c"
typedef struct IMA_ADPCM_PRIVATE_tag IMA_ADPCM_PRIVATE;
#line 16 "/root/patchweave_donee/23/src/GSM610/gsm.h"
struct gsm_state ;
#line 16 "/root/patchweave_donee/23/src/GSM610/gsm.h"
typedef struct gsm_state *gsm;
#line 17 "/root/patchweave_donee/23/src/GSM610/gsm.h"
typedef short gsm_signal;
#line 18 "/root/patchweave_donee/23/src/GSM610/gsm.h"
typedef unsigned char gsm_byte;
#line 35 "/root/patchweave_donee/23/src/gsm610.c"
struct gsm610_tag {
   int blocks ;
   int blockcount ;
   int samplecount ;
   int samplesperblock ;
   int blocksize ;
   int (*decode_block)(SF_PRIVATE * , struct gsm610_tag * ) ;
   int (*encode_block)(SF_PRIVATE * , struct gsm610_tag * ) ;
   short samples[320] ;
   unsigned char block[65] ;
   gsm gsm_data ;
};
#line 48 "/root/patchweave_donee/23/src/gsm610.c"
typedef struct gsm610_tag GSM610_PRIVATE;
#line 410 "/root/patchweave_donee/23/src/float32.c"
union __anonunion_484 {
   float f ;
   int i ;
   unsigned char c[4] ;
};
#line 44 "/root/patchweave_donee/23/src/dwvw.c"
struct __anonstruct_530 {
   int index ;
   int end ;
   unsigned char buffer[256] ;
};
#line 40 "/root/patchweave_donee/23/src/dwvw.c"
struct __anonstruct_64___0 {
   int bit_width ;
   int dwm_maxsize ;
   int max_delta ;
   int span ;
   int samplecount ;
   int bit_count ;
   int bits ;
   int last_delta_width ;
   int last_sample ;
   struct __anonstruct_530 b ;
};
#line 48 "/root/patchweave_donee/23/src/dwvw.c"
typedef struct __anonstruct_64___0 DWVW_PRIVATE;
#line 459 "/root/patchweave_donee/23/src/double64.c"
union __anonunion_531 {
   double d ;
   unsigned char c[8] ;
};
#line 59 "/root/patchweave_donee/23/src/dither.c"
struct __anonstruct_594 {
   int read_short_dither_bits ;
   int read_int_dither_bits ;
   int write_short_dither_bits ;
   int write_int_dither_bits ;
   double read_float_dither_scale ;
   double read_double_dither_bits ;
   double write_float_dither_scale ;
   double write_double_dither_bits ;
   sf_count_t (*read_short)(SF_PRIVATE * , short * , sf_count_t  ) ;
   sf_count_t (*read_int)(SF_PRIVATE * , int * , sf_count_t  ) ;
   sf_count_t (*read_float)(SF_PRIVATE * , float * , sf_count_t  ) ;
   sf_count_t (*read_double)(SF_PRIVATE * , double * , sf_count_t  ) ;
   sf_count_t (*write_short)(SF_PRIVATE * , short const   * , sf_count_t  ) ;
   sf_count_t (*write_int)(SF_PRIVATE * , int const   * , sf_count_t  ) ;
   sf_count_t (*write_float)(SF_PRIVATE * , float const   * , sf_count_t  ) ;
   sf_count_t (*write_double)(SF_PRIVATE * , double const   * , sf_count_t  ) ;
   double buffer[1024] ;
};
#line 76 "/root/patchweave_donee/23/src/dither.c"
typedef struct __anonstruct_594 DITHER_DATA;
#line 158 "/root/patchweave_donee/23/src/chunk.c"
union __anonunion_704 {
   uint32_t marker ;
   char str[5] ;
};
#line 195 "/root/patchweave_donee/23/src/chunk.c"
union __anonunion_705 {
   uint32_t marker ;
   char str[5] ;
};
#line 219 "/root/patchweave_donee/23/src/chunk.c"
union __anonunion_706 {
   uint32_t marker ;
   char str[5] ;
};
#line 19 "/root/patchweave_donee/23/src/chanmap.h"
struct __anonstruct_747 {
   int channel_layout_tag ;
   int const   *channel_map ;
   char const   *name ;
};
#line 27 "/root/patchweave_donee/23/src/chanmap.h"
typedef struct __anonstruct_747 AIFF_CAF_CHANNEL_MAP;
#line 208 "/root/patchweave_donee/23/src/chanmap.c"
struct __anonstruct_748 {
   AIFF_CAF_CHANNEL_MAP *map ;
   int len ;
};
#line 211 "/root/patchweave_donee/23/src/chanmap.c"
typedef struct __anonstruct_748 MAP_MAP;
#line 34 "/root/patchweave_donee/23/src/audio_detect.c"
struct __anonstruct_807 {
   int le_float ;
   int be_float ;
   int le_int_24_32 ;
   int be_int_24_32 ;
};
#line 39 "/root/patchweave_donee/23/src/audio_detect.c"
typedef struct __anonstruct_807 VOTE;
#line 88 "/root/patchweave_donee/23/src/ALAC/ALACAudioTypes.h"
typedef uint32_t ALACChannelLayoutTag;
#line 109 "/root/patchweave_donee/23/src/ALAC/ALACAudioTypes.h"
typedef double alac_float64_t;
#line 138 "/root/patchweave_donee/23/src/ALAC/ALACAudioTypes.h"
struct ALACAudioChannelLayout {
   ALACChannelLayoutTag mChannelLayoutTag ;
   uint32_t mChannelBitmap ;
   uint32_t mNumberChannelDescriptions ;
};
#line 143 "/root/patchweave_donee/23/src/ALAC/ALACAudioTypes.h"
typedef struct ALACAudioChannelLayout ALACAudioChannelLayout;
#line 145 "/root/patchweave_donee/23/src/ALAC/ALACAudioTypes.h"
struct AudioFormatDescription {
   alac_float64_t mSampleRate ;
   uint32_t mFormatID ;
   uint32_t mFormatFlags ;
   uint32_t mBytesPerPacket ;
   uint32_t mFramesPerPacket ;
   uint32_t mBytesPerFrame ;
   uint32_t mChannelsPerFrame ;
   uint32_t mBitsPerChannel ;
   uint32_t mReserved ;
};
#line 157 "/root/patchweave_donee/23/src/ALAC/ALACAudioTypes.h"
typedef struct AudioFormatDescription AudioFormatDescription;
#line 171 "/root/patchweave_donee/23/src/ALAC/ALACAudioTypes.h"
struct ALACSpecificConfig {
   uint32_t frameLength ;
   uint8_t compatibleVersion ;
   uint8_t bitDepth ;
   uint8_t pb ;
   uint8_t mb ;
   uint8_t kb ;
   uint8_t numChannels ;
   uint16_t maxRun ;
   uint32_t maxFrameBytes ;
   uint32_t avgBitRate ;
   uint32_t sampleRate ;
};
#line 185 "/root/patchweave_donee/23/src/ALAC/ALACAudioTypes.h"
typedef struct ALACSpecificConfig ALACSpecificConfig;
#line 35 "/root/patchweave_donee/23/src/ALAC/alac_codec.h"
struct BitBuffer ;
#line 47 "/root/patchweave_donee/23/src/ALAC/alac_codec.h"
union __anonunion_855 {
   int32_t mPredictor[4096] ;
   uint16_t mShiftBuffer[4096] ;
};
#line 37 "/root/patchweave_donee/23/src/ALAC/alac_codec.h"
struct alac_decoder_s {
   ALACSpecificConfig mConfig ;
   uint16_t mActiveElements ;
   int32_t mMixBufferU[4096] ;
   int32_t mMixBufferV[4096] ;
   union __anonunion_855 __annonCompField3 ;
   int32_t mPredictor[4096] ;
   uint16_t mShiftBuffer[4096] ;
   uint32_t mNumChannels ;
};
#line 53 "/root/patchweave_donee/23/src/ALAC/alac_codec.h"
typedef struct alac_decoder_s ALAC_DECODER;
#line 55 "/root/patchweave_donee/23/src/ALAC/alac_codec.h"
struct alac_encoder_s {
   int16_t mBitDepth ;
   int16_t mLastMixRes[8] ;
   int32_t mFastMode ;
   int32_t mMixBufferU[4096] ;
   int32_t mMixBufferV[4096] ;
   int32_t mPredictorU[4096] ;
   int32_t mPredictorV[4096] ;
   uint16_t mShiftBufferUV[8192] ;
   uint8_t mWorkBuffer[16384] ;
   int16_t mCoefsU[8][16][16] ;
   int16_t mCoefsV[8][16][16] ;
   uint32_t mTotalBytesGenerated ;
   uint32_t mAvgBitRate ;
   uint32_t mMaxFrameBytes ;
   uint32_t mFrameSize ;
   uint32_t mMaxOutputBytes ;
   uint32_t mNumChannels ;
   uint32_t mOutputSampleRate ;
};
#line 85 "/root/patchweave_donee/23/src/ALAC/alac_codec.h"
typedef struct alac_encoder_s ALAC_ENCODER;
#line 61 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.h"
struct BitBuffer {
   uint8_t *cur ;
   uint8_t *end ;
   uint32_t bitIndex ;
   uint32_t byteSize ;
};
#line 68 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.h"
typedef struct BitBuffer BitBuffer;
#line 37 "/root/patchweave_donee/23/src/alac.c"
struct __anonstruct_858 {
   uint32_t current ;
   uint32_t count ;
   uint32_t allocated ;
   uint32_t packet_size[] ;
};
#line 40 "/root/patchweave_donee/23/src/alac.c"
typedef struct __anonstruct_858 PAKT_INFO;
#line 56 "/root/patchweave_donee/23/src/alac.c"
union __anonunion_860 {
   ALAC_DECODER decoder ;
   ALAC_ENCODER encoder ;
};
#line 42 "/root/patchweave_donee/23/src/alac.c"
struct __anonstruct_859 {
   sf_count_t input_data_pos ;
   PAKT_INFO *pakt_info ;
   int channels ;
   int final_write_block ;
   uint32_t frames_this_block ;
   uint32_t partial_block_frames ;
   uint32_t frames_per_block ;
   uint32_t bits_per_sample ;
   uint32_t kuki_size ;
   union __anonunion_860 __annonCompField4 ;
   ALAC_DECODER decoder ;
   ALAC_ENCODER encoder ;
   char enctmpname[512] ;
   FILE *enctmp ;
   int buffer[] ;
};
#line 66 "/root/patchweave_donee/23/src/alac.c"
typedef struct __anonstruct_859 ALAC_PRIVATE;
#line 239 "/root/patchweave_donee/23/src/alac.c"
union __anonunion_861 {
   uint8_t kuki[512] ;
   uint32_t alignment ;
};
#line 57 "/root/patchweave_donee/23/src/ALAC/aglib.h"
struct AGParamRec {
   uint32_t mb ;
   uint32_t mb0 ;
   uint32_t pb ;
   uint32_t kb ;
   uint32_t wb ;
   uint32_t qb ;
   uint32_t fw ;
   uint32_t sw ;
   uint32_t maxrun ;
};
#line 66 "/root/patchweave_donee/23/src/ALAC/aglib.h"
typedef struct AGParamRec AGParamRec;
#line 66 "/root/patchweave_donee/23/src/ALAC/aglib.h"
typedef struct AGParamRec *AGParamRecPtr;
#line 47 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
enum __anonenum__902 {
    false = 0,
    true = 1
} ;
#line 51 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
typedef enum __anonenum__902 bool;
#line 64 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
typedef int16_t (*SearchCoefs)[16];
#line 64 "/root/patchweave_donee/23/src/G72x/g72x.h"
struct g72x_state ;
#line 44 "/root/patchweave_donee/23/src/G72x/g72x_priv.h"
struct g72x_state {
   long yl ;
   short yu ;
   short dms ;
   short dml ;
   short ap ;
   short a[2] ;
   short b[6] ;
   short pk[2] ;
   short dq[6] ;
   short sr[2] ;
   char td ;
   int (*encoder)(int  , struct g72x_state * ) ;
   int (*decoder)(int  , struct g72x_state * ) ;
   int codec_bits ;
   int blocksize ;
   int samplesperblock ;
};
#line 81 "/root/patchweave_donee/23/src/G72x/g72x_priv.h"
typedef struct g72x_state G72x_STATE;
#line 28 "/root/patchweave_donee/23/src/GSM610/gsm610_priv.h"
struct gsm_state {
   int16_t dp0[280] ;
   int16_t z1 ;
   int32_t L_z2 ;
   int mp ;
   int16_t u[8] ;
   int16_t LARpp[2][8] ;
   int16_t j ;
   int16_t ltp_cut ;
   int16_t nrp ;
   int16_t v[9] ;
   int16_t msr ;
   char verbose ;
   char fast ;
   char wav_fmt ;
   unsigned char frame_index ;
   unsigned char frame_chain ;
   int16_t e[50] ;
};
#line 27 "/usr/include/vorbis/codec.h"
struct vorbis_info {
   int version ;
   int channels ;
   long rate ;
   long bitrate_upper ;
   long bitrate_nominal ;
   long bitrate_lower ;
   long bitrate_window ;
   void *codec_setup ;
};
#line 53 "/usr/include/vorbis/codec.h"
typedef struct vorbis_info vorbis_info;
#line 58 "/usr/include/vorbis/codec.h"
struct vorbis_dsp_state {
   int analysisp ;
   vorbis_info *vi ;
   float **pcm ;
   float **pcmret ;
   int pcm_storage ;
   int pcm_current ;
   int pcm_returned ;
   int preextrapolate ;
   int eofflag ;
   long lW ;
   long W ;
   long nW ;
   long centerW ;
   ogg_int64_t granulepos ;
   ogg_int64_t sequence ;
   ogg_int64_t glue_bits ;
   ogg_int64_t time_bits ;
   ogg_int64_t floor_bits ;
   ogg_int64_t res_bits ;
   void *backend_state ;
};
#line 85 "/usr/include/vorbis/codec.h"
typedef struct vorbis_dsp_state vorbis_dsp_state;
#line 109
struct alloc_chain ;
#line 87 "/usr/include/vorbis/codec.h"
struct vorbis_block {
   float **pcm ;
   oggpack_buffer opb ;
   long lW ;
   long W ;
   long nW ;
   int pcmend ;
   int mode ;
   int eofflag ;
   ogg_int64_t granulepos ;
   ogg_int64_t sequence ;
   vorbis_dsp_state *vd ;
   void *localstore ;
   long localtop ;
   long localalloc ;
   long totaluse ;
   struct alloc_chain *reap ;
   long glue_bits ;
   long time_bits ;
   long floor_bits ;
   long res_bits ;
   void *internal ;
};
#line 119 "/usr/include/vorbis/codec.h"
typedef struct vorbis_block vorbis_block;
#line 126 "/usr/include/vorbis/codec.h"
struct alloc_chain {
   void *ptr ;
   struct alloc_chain *next ;
};
#line 139 "/usr/include/vorbis/codec.h"
struct vorbis_comment {
   char **user_comments ;
   int *comment_lengths ;
   int comments ;
   char *vendor ;
};
#line 147 "/usr/include/vorbis/codec.h"
typedef struct vorbis_comment vorbis_comment;
#line 79 "/root/patchweave_donee/23/src/ogg_vorbis.c"
typedef int convert_func(SF_PRIVATE * , int  , void * , int  , int  , float ** );
#line 98 "/root/patchweave_donee/23/src/ogg_vorbis.c"
struct __anonstruct_1010 {
   int id ;
   char const   *name ;
};
#line 101 "/root/patchweave_donee/23/src/ogg_vorbis.c"
typedef struct __anonstruct_1010 STR_PAIRS;
#line 116 "/root/patchweave_donee/23/src/ogg_vorbis.c"
struct __anonstruct_1011 {
   sf_count_t loc ;
   vorbis_info vinfo ;
   vorbis_comment vcomment ;
   vorbis_dsp_state vdsp ;
   vorbis_block vblock ;
   double quality ;
};
#line 130 "/root/patchweave_donee/23/src/ogg_vorbis.c"
typedef struct __anonstruct_1011 VORBIS_PRIVATE;
#line 920 "/root/patchweave_donee/23/src/ogg_vorbis.c"
struct __anonstruct_1012 {
   int isillegal ;
   int shownillegal ;
   int isnew ;
   int end ;
   uint32_t serial ;
   ogg_stream_state ostream ;
   vorbis_info vinfo ;
   vorbis_comment vcomment ;
   sf_count_t lastgranulepos ;
   int doneheaders ;
};
#line 934 "/root/patchweave_donee/23/src/ogg_vorbis.c"
typedef struct __anonstruct_1012 stream_processor;
#line 936 "/root/patchweave_donee/23/src/ogg_vorbis.c"
struct __anonstruct_1013 {
   stream_processor *streams ;
   int allocated ;
   int used ;
   int in_headers ;
};
#line 942 "/root/patchweave_donee/23/src/ogg_vorbis.c"
typedef struct __anonstruct_1013 stream_set;
#line 38 "/root/patchweave_donee/23/src/xi.c"
struct __anonstruct_1072 {
   char filename[22] ;
   char software[20] ;
   char sample_name[22] ;
   int loop_begin ;
   int loop_end ;
   int sample_flags ;
   short last_16 ;
};
#line 49 "/root/patchweave_donee/23/src/xi.c"
typedef struct __anonstruct_1072 XI_PRIVATE;
#line 76 "/root/patchweave_donee/23/src/wav_w64.c"
struct chanmap_s {
   int id ;
   char const   *name ;
};
#line 538 "/root/patchweave_donee/23/src/wav_w64.c"
struct __anonstruct_1201 {
   int ID ;
   char const   *name ;
};
#line 541 "/root/patchweave_donee/23/src/wav_w64.c"
typedef struct __anonstruct_1201 WAV_FORMAT_DESC;
#line 57 "/root/patchweave_donee/23/src/voc.c"
struct __anonstruct_1215 {
   int samples ;
   int offset ;
};
#line 60 "/root/patchweave_donee/23/src/voc.c"
typedef struct __anonstruct_1215 SND_DATA_BLOCKS;
#line 62 "/root/patchweave_donee/23/src/voc.c"
struct __anonstruct_1216 {
   unsigned int sections ;
   unsigned int section_types ;
   int samplerate ;
   int channels ;
   int bitwidth ;
   SND_DATA_BLOCKS blocks[200] ;
};
#line 66 "/root/patchweave_donee/23/src/voc.c"
typedef struct __anonstruct_1216 VOC_DATA;
#line 54 "/root/patchweave_donee/23/src/svx.c"
struct __anonstruct_1275 {
   unsigned int oneShotHiSamples ;
   unsigned int repeatHiSamples ;
   unsigned int samplesPerHiCycle ;
   unsigned short samplesPerSec ;
   unsigned char octave ;
   unsigned char compression ;
   unsigned int volume ;
};
#line 59 "/root/patchweave_donee/23/src/svx.c"
typedef struct __anonstruct_1275 VHDR_CHUNK;
#line 47 "/root/patchweave_donee/23/src/sds.c"
struct tag_SDS_PRIVATE {
   int bitwidth ;
   int frames ;
   int samplesperblock ;
   int total_blocks ;
   int (*reader)(SF_PRIVATE * , struct tag_SDS_PRIVATE * ) ;
   int (*writer)(SF_PRIVATE * , struct tag_SDS_PRIVATE * ) ;
   int read_block ;
   int read_count ;
   unsigned char read_data[127] ;
   int read_samples[63] ;
   int write_block ;
   int write_count ;
   int total_written ;
   unsigned char write_data[127] ;
   int write_samples[63] ;
};
#line 62 "/root/patchweave_donee/23/src/sds.c"
typedef struct tag_SDS_PRIVATE SDS_PRIVATE;
#line 58 "/root/patchweave_donee/23/src/sd2.c"
struct __anonstruct_1316 {
   unsigned char *rsrc_data ;
   int rsrc_len ;
   int need_to_free_rsrc_data ;
   int data_offset ;
   int data_length ;
   int map_offset ;
   int map_length ;
   int type_count ;
   int type_offset ;
   int item_offset ;
   int str_index ;
   int str_count ;
   int string_offset ;
   int sample_size ;
   int sample_rate ;
   int channels ;
};
#line 75 "/root/patchweave_donee/23/src/sd2.c"
typedef struct __anonstruct_1316 SD2_RSRC;
#line 77 "/root/patchweave_donee/23/src/sd2.c"
struct __anonstruct_1317 {
   int type ;
   int id ;
   char name[32] ;
   char value[32] ;
   int value_len ;
};
#line 83 "/root/patchweave_donee/23/src/sd2.c"
typedef struct __anonstruct_1317 STR_RSRC;
#line 52 "/root/patchweave_donee/23/src/paf.c"
struct __anonstruct_1072___0 {
   int version ;
   int endianness ;
   int samplerate ;
   int format ;
   int channels ;
   int source ;
};
#line 59 "/root/patchweave_donee/23/src/paf.c"
typedef struct __anonstruct_1072___0 PAF_FMT;
#line 61 "/root/patchweave_donee/23/src/paf.c"
struct __anonstruct_1373 {
   int max_blocks ;
   int channels ;
   int blocksize ;
   int read_block ;
   int write_block ;
   int read_count ;
   int write_count ;
   sf_count_t sample_count ;
   int *samples ;
   unsigned char *block ;
   int data[] ;
};
#line 68 "/root/patchweave_donee/23/src/paf.c"
typedef struct __anonstruct_1373 PAF24_PRIVATE;
#line 35 "/root/patchweave_donee/23/src/g72x.c"
struct __anonstruct_1481 {
   struct g72x_state *private ;
   int blocksize ;
   int samplesperblock ;
   int bytesperblock ;
   int blocks_total ;
   int block_curr ;
   int sample_curr ;
   unsigned char block[120] ;
   short samples[120] ;
};
#line 46 "/root/patchweave_donee/23/src/g72x.c"
typedef struct __anonstruct_1481 G72x_PRIVATE;
#line 58 "/usr/include/FLAC/ordinals.h"
typedef uint8_t FLAC__uint8;
#line 61 "/usr/include/FLAC/ordinals.h"
typedef int32_t FLAC__int32;
#line 63 "/usr/include/FLAC/ordinals.h"
typedef uint16_t FLAC__uint16;
#line 64 "/usr/include/FLAC/ordinals.h"
typedef uint32_t FLAC__uint32;
#line 65 "/usr/include/FLAC/ordinals.h"
typedef uint64_t FLAC__uint64;
#line 69 "/usr/include/FLAC/ordinals.h"
typedef int FLAC__bool;
#line 71 "/usr/include/FLAC/ordinals.h"
typedef FLAC__uint8 FLAC__byte;
#line 194 "/usr/include/FLAC/format.h"
enum __anonenum__1505 {
    FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE = 0,
    FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2 = 1
} ;
#line 202 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1505 FLAC__EntropyCodingMethodType;
#line 214 "/usr/include/FLAC/format.h"
struct __anonstruct_1506 {
   uint32_t *parameters ;
   uint32_t *raw_bits ;
   uint32_t capacity_by_order ;
};
#line 229 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1506 FLAC__EntropyCodingMethod_PartitionedRiceContents;
#line 233 "/usr/include/FLAC/format.h"
struct __anonstruct_1507 {
   uint32_t order ;
   FLAC__EntropyCodingMethod_PartitionedRiceContents *contents ;
};
#line 241 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1507 FLAC__EntropyCodingMethod_PartitionedRice;
#line 257 "/usr/include/FLAC/format.h"
union __anonunion_1509 {
   FLAC__EntropyCodingMethod_PartitionedRice partitioned_rice ;
};
#line 255 "/usr/include/FLAC/format.h"
struct __anonstruct_1508 {
   FLAC__EntropyCodingMethodType type ;
   union __anonunion_1509 data ;
};
#line 260 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1508 FLAC__EntropyCodingMethod;
#line 267
enum __anonenum__1510 {
    FLAC__SUBFRAME_TYPE_CONSTANT = 0,
    FLAC__SUBFRAME_TYPE_VERBATIM = 1,
    FLAC__SUBFRAME_TYPE_FIXED = 2,
    FLAC__SUBFRAME_TYPE_LPC = 3
} ;
#line 272 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1510 FLAC__SubframeType;
#line 284 "/usr/include/FLAC/format.h"
struct __anonstruct_1511 {
   FLAC__int32 value ;
};
#line 286 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1511 FLAC__Subframe_Constant;
#line 291 "/usr/include/FLAC/format.h"
struct __anonstruct_1512 {
   FLAC__int32 *data ;
};
#line 293 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1512 FLAC__Subframe_Verbatim;
#line 298 "/usr/include/FLAC/format.h"
struct __anonstruct_1513 {
   FLAC__EntropyCodingMethod entropy_coding_method ;
   uint32_t order ;
   FLAC__int32 warmup[4] ;
   FLAC__int32 *residual ;
};
#line 310 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1513 FLAC__Subframe_Fixed;
#line 315 "/usr/include/FLAC/format.h"
struct __anonstruct_1514 {
   FLAC__EntropyCodingMethod entropy_coding_method ;
   uint32_t order ;
   uint32_t qlp_coeff_precision ;
   int quantization_level ;
   FLAC__int32 qlp_coeff[32] ;
   FLAC__int32 warmup[32] ;
   FLAC__int32 *residual ;
};
#line 336 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1514 FLAC__Subframe_LPC;
#line 346 "/usr/include/FLAC/format.h"
union __anonunion_1516 {
   FLAC__Subframe_Constant constant ;
   FLAC__Subframe_Fixed fixed ;
   FLAC__Subframe_LPC lpc ;
   FLAC__Subframe_Verbatim verbatim ;
};
#line 344 "/usr/include/FLAC/format.h"
struct __anonstruct_1515 {
   FLAC__SubframeType type ;
   union __anonunion_1516 data ;
   uint32_t wasted_bits ;
};
#line 353 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1515 FLAC__Subframe;
#line 381
enum __anonenum__1517 {
    FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT = 0,
    FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE = 1,
    FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE = 2,
    FLAC__CHANNEL_ASSIGNMENT_MID_SIDE = 3
} ;
#line 386 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1517 FLAC__ChannelAssignment;
#line 396
enum __anonenum__1518 {
    FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER = 0,
    FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER = 1
} ;
#line 399 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1518 FLAC__FrameNumberType;
#line 432 "/usr/include/FLAC/format.h"
union __anonunion_1520 {
   FLAC__uint32 frame_number ;
   FLAC__uint64 sample_number ;
};
#line 411 "/usr/include/FLAC/format.h"
struct __anonstruct_1519 {
   uint32_t blocksize ;
   uint32_t sample_rate ;
   uint32_t channels ;
   FLAC__ChannelAssignment channel_assignment ;
   uint32_t bits_per_sample ;
   FLAC__FrameNumberType number_type ;
   union __anonunion_1520 number ;
   FLAC__uint8 crc ;
};
#line 444 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1519 FLAC__FrameHeader;
#line 460 "/usr/include/FLAC/format.h"
struct __anonstruct_1521 {
   FLAC__uint16 crc ;
};
#line 466 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1521 FLAC__FrameFooter;
#line 473 "/usr/include/FLAC/format.h"
struct __anonstruct_1522 {
   FLAC__FrameHeader header ;
   FLAC__Subframe subframes[8] ;
   FLAC__FrameFooter footer ;
};
#line 477 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1522 FLAC__Frame;
#line 489
enum __anonenum__1523 {
    FLAC__METADATA_TYPE_STREAMINFO = 0,
    FLAC__METADATA_TYPE_PADDING = 1,
    FLAC__METADATA_TYPE_APPLICATION = 2,
    FLAC__METADATA_TYPE_SEEKTABLE = 3,
    FLAC__METADATA_TYPE_VORBIS_COMMENT = 4,
    FLAC__METADATA_TYPE_CUESHEET = 5,
    FLAC__METADATA_TYPE_PICTURE = 6,
    FLAC__METADATA_TYPE_UNDEFINED = 7,
    FLAC__MAX_METADATA_TYPE = 126
} ;
#line 517 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1523 FLAC__MetadataType;
#line 529 "/usr/include/FLAC/format.h"
struct __anonstruct_1524 {
   uint32_t min_blocksize ;
   uint32_t max_blocksize ;
   uint32_t min_framesize ;
   uint32_t max_framesize ;
   uint32_t sample_rate ;
   uint32_t channels ;
   uint32_t bits_per_sample ;
   FLAC__uint64 total_samples ;
   FLAC__byte md5sum[16] ;
};
#line 537 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1524 FLAC__StreamMetadata_StreamInfo;
#line 554 "/usr/include/FLAC/format.h"
struct __anonstruct_1525 {
   int dummy ;
};
#line 560 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1525 FLAC__StreamMetadata_Padding;
#line 565 "/usr/include/FLAC/format.h"
struct __anonstruct_1526 {
   FLAC__byte id[4] ;
   FLAC__byte *data ;
};
#line 568 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1526 FLAC__StreamMetadata_Application;
#line 574 "/usr/include/FLAC/format.h"
struct __anonstruct_1527 {
   FLAC__uint64 sample_number ;
   FLAC__uint64 stream_offset ;
   uint32_t frame_samples ;
};
#line 584 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1527 FLAC__StreamMetadata_SeekPoint;
#line 612 "/usr/include/FLAC/format.h"
struct __anonstruct_1528 {
   uint32_t num_points ;
   FLAC__StreamMetadata_SeekPoint *points ;
};
#line 615 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1528 FLAC__StreamMetadata_SeekTable;
#line 624 "/usr/include/FLAC/format.h"
struct __anonstruct_1529 {
   FLAC__uint32 length ;
   FLAC__byte *entry ;
};
#line 627 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1529 FLAC__StreamMetadata_VorbisComment_Entry;
#line 634 "/usr/include/FLAC/format.h"
struct __anonstruct_1530 {
   FLAC__StreamMetadata_VorbisComment_Entry vendor_string ;
   FLAC__uint32 num_comments ;
   FLAC__StreamMetadata_VorbisComment_Entry *comments ;
};
#line 638 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1530 FLAC__StreamMetadata_VorbisComment;
#line 647 "/usr/include/FLAC/format.h"
struct __anonstruct_1531 {
   FLAC__uint64 offset ;
   FLAC__byte number ;
};
#line 655 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1531 FLAC__StreamMetadata_CueSheet_Index;
#line 666 "/usr/include/FLAC/format.h"
struct __anonstruct_1532 {
   FLAC__uint64 offset ;
   FLAC__byte number ;
   char isrc[13] ;
   uint32_t type ;
   uint32_t pre_emphasis ;
   FLAC__byte num_indices ;
   FLAC__StreamMetadata_CueSheet_Index *indices ;
};
#line 688 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1532 FLAC__StreamMetadata_CueSheet_Track;
#line 703 "/usr/include/FLAC/format.h"
struct __anonstruct_1533 {
   char media_catalog_number[129] ;
   FLAC__uint64 lead_in ;
   FLAC__bool is_cd ;
   uint32_t num_tracks ;
   FLAC__StreamMetadata_CueSheet_Track *tracks ;
};
#line 722 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1533 FLAC__StreamMetadata_CueSheet;
#line 732
enum __anonenum__1534 {
    FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER = 0,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD = 1,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON = 2,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER = 3,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER = 4,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE = 5,
    FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA = 6,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST = 7,
    FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST = 8,
    FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR = 9,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BAND = 10,
    FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER = 11,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST = 12,
    FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION = 13,
    FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING = 14,
    FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE = 15,
    FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE = 16,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FISH = 17,
    FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION = 18,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE = 19,
    FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE = 20,
    FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED = 21
} ;
#line 755 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1534 FLAC__StreamMetadata_Picture_Type;
#line 769 "/usr/include/FLAC/format.h"
struct __anonstruct_1535 {
   FLAC__StreamMetadata_Picture_Type type ;
   char *mime_type ;
   FLAC__byte *description ;
   FLAC__uint32 width ;
   FLAC__uint32 height ;
   FLAC__uint32 depth ;
   FLAC__uint32 colors ;
   FLAC__uint32 data_length ;
   FLAC__byte *data ;
};
#line 811 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1535 FLAC__StreamMetadata_Picture;
#line 827 "/usr/include/FLAC/format.h"
struct __anonstruct_1536 {
   FLAC__byte *data ;
};
#line 829 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1536 FLAC__StreamMetadata_Unknown;
#line 846 "/usr/include/FLAC/format.h"
union __anonunion_1538 {
   FLAC__StreamMetadata_StreamInfo stream_info ;
   FLAC__StreamMetadata_Padding padding ;
   FLAC__StreamMetadata_Application application ;
   FLAC__StreamMetadata_SeekTable seek_table ;
   FLAC__StreamMetadata_VorbisComment vorbis_comment ;
   FLAC__StreamMetadata_CueSheet cue_sheet ;
   FLAC__StreamMetadata_Picture picture ;
   FLAC__StreamMetadata_Unknown unknown ;
};
#line 834 "/usr/include/FLAC/format.h"
struct __anonstruct_1537 {
   FLAC__MetadataType type ;
   FLAC__bool is_last ;
   uint32_t length ;
   union __anonunion_1538 data ;
};
#line 858 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1537 FLAC__StreamMetadata;
#line 202 "/usr/include/FLAC/stream_decoder.h"
enum __anonenum__1539 {
    FLAC__STREAM_DECODER_SEARCH_FOR_METADATA = 0,
    FLAC__STREAM_DECODER_READ_METADATA = 1,
    FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC = 2,
    FLAC__STREAM_DECODER_READ_FRAME = 3,
    FLAC__STREAM_DECODER_END_OF_STREAM = 4,
    FLAC__STREAM_DECODER_OGG_ERROR = 5,
    FLAC__STREAM_DECODER_SEEK_ERROR = 6,
    FLAC__STREAM_DECODER_ABORTED = 7,
    FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR = 8,
    FLAC__STREAM_DECODER_UNINITIALIZED = 9
} ;
#line 244 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1539 FLAC__StreamDecoderState;
#line 256
enum __anonenum__1540 {
    FLAC__STREAM_DECODER_INIT_STATUS_OK = 0,
    FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER = 1,
    FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS = 2,
    FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR = 3,
    FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE = 4,
    FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED = 5
} ;
#line 282 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1540 FLAC__StreamDecoderInitStatus;
#line 294
enum __anonenum__1541 {
    FLAC__STREAM_DECODER_READ_STATUS_CONTINUE = 0,
    FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM = 1,
    FLAC__STREAM_DECODER_READ_STATUS_ABORT = 2
} ;
#line 313 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1541 FLAC__StreamDecoderReadStatus;
#line 325
enum __anonenum__1542 {
    FLAC__STREAM_DECODER_SEEK_STATUS_OK = 0,
    FLAC__STREAM_DECODER_SEEK_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED = 2
} ;
#line 336 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1542 FLAC__StreamDecoderSeekStatus;
#line 348
enum __anonenum__1543 {
    FLAC__STREAM_DECODER_TELL_STATUS_OK = 0,
    FLAC__STREAM_DECODER_TELL_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED = 2
} ;
#line 359 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1543 FLAC__StreamDecoderTellStatus;
#line 371
enum __anonenum__1544 {
    FLAC__STREAM_DECODER_LENGTH_STATUS_OK = 0,
    FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED = 2
} ;
#line 382 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1544 FLAC__StreamDecoderLengthStatus;
#line 394
enum __anonenum__1545 {
    FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE = 0,
    FLAC__STREAM_DECODER_WRITE_STATUS_ABORT = 1
} ;
#line 402 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1545 FLAC__StreamDecoderWriteStatus;
#line 427
enum __anonenum__1546 {
    FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC = 0,
    FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER = 1,
    FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH = 2,
    FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM = 3
} ;
#line 441 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1546 FLAC__StreamDecoderErrorStatus;
#line 457
struct FLAC__StreamDecoderProtected ;
#line 458
struct FLAC__StreamDecoderPrivate ;
#line 463 "/usr/include/FLAC/stream_decoder.h"
struct __anonstruct_1547 {
   struct FLAC__StreamDecoderProtected *protected_ ;
   struct FLAC__StreamDecoderPrivate *private_ ;
};
#line 466 "/usr/include/FLAC/stream_decoder.h"
typedef struct __anonstruct_1547 FLAC__StreamDecoder;
#line 293 "/usr/include/FLAC/stream_encoder.h"
enum __anonenum__1549 {
    FLAC__STREAM_ENCODER_INIT_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR = 1,
    FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER = 2,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS = 3,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS = 4,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE = 5,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE = 6,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE = 7,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER = 8,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION = 9,
    FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER = 10,
    FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE = 11,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA = 12,
    FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED = 13
} ;
#line 351 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1549 FLAC__StreamEncoderInitStatus;
#line 389
enum __anonenum__1551 {
    FLAC__STREAM_ENCODER_WRITE_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR = 1
} ;
#line 397 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1551 FLAC__StreamEncoderWriteStatus;
#line 409
enum __anonenum__1552 {
    FLAC__STREAM_ENCODER_SEEK_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR = 1,
    FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED = 2
} ;
#line 420 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1552 FLAC__StreamEncoderSeekStatus;
#line 432
enum __anonenum__1553 {
    FLAC__STREAM_ENCODER_TELL_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_TELL_STATUS_ERROR = 1,
    FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED = 2
} ;
#line 443 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1553 FLAC__StreamEncoderTellStatus;
#line 459
struct FLAC__StreamEncoderProtected ;
#line 460
struct FLAC__StreamEncoderPrivate ;
#line 465 "/usr/include/FLAC/stream_encoder.h"
struct __anonstruct_1554 {
   struct FLAC__StreamEncoderProtected *protected_ ;
   struct FLAC__StreamEncoderPrivate *private_ ;
};
#line 468 "/usr/include/FLAC/stream_encoder.h"
typedef struct __anonstruct_1554 FLAC__StreamEncoder;
#line 46 "/root/patchweave_donee/23/src/flac.c"
enum __anonenum__1558 {
    PFLAC_PCM_SHORT = 50,
    PFLAC_PCM_INT = 51,
    PFLAC_PCM_FLOAT = 52,
    PFLAC_PCM_DOUBLE = 53
} ;
#line 51 "/root/patchweave_donee/23/src/flac.c"
typedef enum __anonenum__1558 PFLAC_PCM;
#line 53 "/root/patchweave_donee/23/src/flac.c"
struct __anonstruct_1559 {
   FLAC__StreamDecoder *fsd ;
   FLAC__StreamEncoder *fse ;
   PFLAC_PCM pcmtype ;
   void *ptr ;
   unsigned int pos ;
   unsigned int len ;
   unsigned int remain ;
   FLAC__StreamMetadata *metadata ;
   FLAC__int32 * const  *wbuffer ;
   FLAC__int32 *rbuffer[8] ;
   FLAC__int32 *encbuffer ;
   unsigned int bufferpos ;
   FLAC__Frame *frame ;
   FLAC__bool bufferbackup ;
   unsigned int compression ;
};
#line 74 "/root/patchweave_donee/23/src/flac.c"
typedef struct __anonstruct_1559 FLAC_PRIVATE;
#line 76 "/root/patchweave_donee/23/src/flac.c"
struct __anonstruct_1560 {
   char const   *tag ;
   int type ;
};
#line 79 "/root/patchweave_donee/23/src/flac.c"
typedef struct __anonstruct_1560 FLAC_TAG;
#line 77 "/root/patchweave_donee/23/src/caf.c"
struct __anonstruct_1605 {
   uint8_t srate[8] ;
   uint32_t fmt_id ;
   uint32_t fmt_flags ;
   uint32_t pkt_bytes ;
   uint32_t frames_per_packet ;
   uint32_t channels_per_frame ;
   uint32_t bits_per_chan ;
};
#line 85 "/root/patchweave_donee/23/src/caf.c"
typedef struct __anonstruct_1605 DESC_CHUNK;
#line 87 "/root/patchweave_donee/23/src/caf.c"
struct __anonstruct_1606 {
   int chanmap_tag ;
   ALAC_DECODER_INFO alac ;
};
#line 91 "/root/patchweave_donee/23/src/caf.c"
typedef struct __anonstruct_1606 CAF_PRIVATE;
#line 42 "/root/patchweave_donee/23/src/avr.c"
struct __anonstruct_1666 {
   int marker ;
   char name[8] ;
   short mono ;
   short rez ;
   short sign ;
   short loop ;
   short midi ;
   int srate ;
   int frames ;
   int lbeg ;
   int lend ;
   short res1 ;
   short res2 ;
   short res3 ;
   char ext[20] ;
   char user[64] ;
};
#line 64 "/root/patchweave_donee/23/src/avr.c"
typedef struct __anonstruct_1666 AVR_HEADER;
#line 80 "/root/patchweave_donee/23/src/au.c"
struct __anonstruct_1667 {
   int dataoffset ;
   int datasize ;
   int encoding ;
   int samplerate ;
   int channels ;
};
#line 86 "/root/patchweave_donee/23/src/au.c"
typedef struct __anonstruct_1667 AU_FMT;
#line 125 "/root/patchweave_donee/23/src/aiff.c"
struct __anonstruct_1671 {
   unsigned int size ;
   short numChannels ;
   unsigned int numSampleFrames ;
   short sampleSize ;
   unsigned char sampleRate[10] ;
   unsigned int encoding ;
   char zero_bytes[2] ;
};
#line 133 "/root/patchweave_donee/23/src/aiff.c"
typedef struct __anonstruct_1671 COMM_CHUNK;
#line 135 "/root/patchweave_donee/23/src/aiff.c"
struct __anonstruct_1672 {
   unsigned int offset ;
   unsigned int blocksize ;
};
#line 138 "/root/patchweave_donee/23/src/aiff.c"
typedef struct __anonstruct_1672 SSND_CHUNK;
#line 140 "/root/patchweave_donee/23/src/aiff.c"
struct __anonstruct_1673 {
   short playMode ;
   unsigned short beginLoop ;
   unsigned short endLoop ;
};
#line 144 "/root/patchweave_donee/23/src/aiff.c"
typedef struct __anonstruct_1673 INST_LOOP;
#line 146 "/root/patchweave_donee/23/src/aiff.c"
struct __anonstruct_1674 {
   char baseNote ;
   char detune ;
   char lowNote ;
   char highNote ;
   char lowVelocity ;
   char highVelocity ;
   short gain ;
   INST_LOOP sustain_loop ;
   INST_LOOP release_loop ;
};
#line 156 "/root/patchweave_donee/23/src/aiff.c"
typedef struct __anonstruct_1674 INST_CHUNK;
#line 172 "/root/patchweave_donee/23/src/aiff.c"
struct __anonstruct_1677 {
   unsigned int version ;
   unsigned int numBeats ;
   unsigned short rootNote ;
   unsigned short scaleType ;
   unsigned short sigNumerator ;
   unsigned short sigDenominator ;
   unsigned short loopType ;
};
#line 180 "/root/patchweave_donee/23/src/aiff.c"
typedef struct __anonstruct_1677 basc_CHUNK;
#line 182 "/root/patchweave_donee/23/src/aiff.c"
struct __anonstruct_1678 {
   unsigned short markerID ;
   unsigned int position ;
};
#line 185 "/root/patchweave_donee/23/src/aiff.c"
typedef struct __anonstruct_1678 MARK_ID_POS;
#line 187 "/root/patchweave_donee/23/src/aiff.c"
struct __anonstruct_1679 {
   sf_count_t comm_offset ;
   sf_count_t ssnd_offset ;
   int chanmap_tag ;
   MARK_ID_POS *markstr ;
};
#line 194 "/root/patchweave_donee/23/src/aiff.c"
typedef struct __anonstruct_1679 AIFF_PRIVATE;
#line 51 "/root/patchweave_donee/23/src/sndfile.c"
struct __anonstruct_1721 {
   int error ;
   char const   *str ;
};
#line 54 "/root/patchweave_donee/23/src/sndfile.c"
typedef struct __anonstruct_1721 ErrorStruct;
#line 37 "/root/patchweave_donee/23/programs/common.h"
struct __anonstruct_1739 {
   char const   *title ;
   char const   *copyright ;
   char const   *artist ;
   char const   *comment ;
   char const   *date ;
   char const   *album ;
   char const   *license ;
   int has_bext_fields ;
   int coding_hist_append ;
   char const   *description ;
   char const   *originator ;
   char const   *originator_reference ;
   char const   *origination_date ;
   char const   *origination_time ;
   char const   *umid ;
   char const   *coding_history ;
   char const   *time_ref ;
};
#line 59 "/root/patchweave_donee/23/programs/common.h"
typedef struct __anonstruct_1739 METADATA_INFO;
#line 61 "/root/patchweave_donee/23/programs/common.h"
struct __anonstruct_1740 {
   char description[256] ;
   char originator[32] ;
   char originator_reference[32] ;
   char origination_date[10] ;
   char origination_time[8] ;
   uint32_t time_reference_low ;
   uint32_t time_reference_high ;
   short version ;
   char umid[64] ;
   char reserved[190] ;
   uint32_t coding_history_size ;
   char coding_history[2048] ;
};
#line 61 "/root/patchweave_donee/23/programs/common.h"
typedef struct __anonstruct_1740 SF_BROADCAST_INFO_2K;
#line 279 "/root/patchweave_donee/23/programs/common.c"
struct __anonstruct_1741 {
   char const   *ext ;
   int len ;
   int format ;
};
#line 283 "/root/patchweave_donee/23/programs/common.c"
typedef struct __anonstruct_1741 OUTPUT_FORMAT_MAP;
#line 50 "/root/patchweave_donee/23/src/chunk.c"
union __anonunion_703 ;
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 326
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 366
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vasprintf)(char **__ptr ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 372
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) asprintf)(char **__ptr ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 379
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 382
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 499
extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 500
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 510
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) ;
#line 587
__inline extern char *( __attribute__((__gnu_inline__)) fgets_unlocked)(char *__s ,
                                                                        int __n ,
                                                                        FILE *__stream ) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char **__lineptr ,
                                                                     size_t *__n ,
                                                                     FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 646
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 826
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) obstack_printf)(struct obstack *__obstack ,
                                                                                                    char const   *__fmt 
                                                                                                    , ...) ;
#line 829
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) obstack_vprintf)(struct obstack *__obstack ,
                                                                                                     char const   *__fmt ,
                                                                                                     __gnuc_va_list __ap ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                                0L);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                                0L);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                                0L);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                                0L);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 118 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char **__lineptr ,
                                                                     size_t *__n ,
                                                                     FILE *__stream ) 
{ 
  __ssize_t __cil_tmp4 ;

  {
  {
#line 120
  __cil_tmp4 = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 120
  return (__cil_tmp4);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) sprintf)(char *__s , char const   *__fmt 
                                                               , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
#line 36
  __cil_tmp4 = (int )__builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) snprintf)(char *__s , size_t __n ,
                                                                char const   *__fmt 
                                                                , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 67
  __cil_tmp5 = (int )__builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s , size_t __n ,
                                                                 char const   *__fmt ,
                                                                 __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = (int )__builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 161
extern  __attribute__((__nothrow__)) int __asprintf_chk(char **__ptr , int __flag ,
                                                        char const   *__fmt  , ...) ;
#line 164
extern  __attribute__((__nothrow__)) int __vasprintf_chk(char **__ptr , int __flag ,
                                                         char const   *__fmt , __gnuc_va_list __arg ) ;
#line 167
extern  __attribute__((__nothrow__)) int __obstack_printf_chk(struct obstack *__obstack ,
                                                              int __flag , char const   *__format 
                                                              , ...) ;
#line 171
extern  __attribute__((__nothrow__)) int __obstack_vprintf_chk(struct obstack *__obstack ,
                                                               int __flag , char const   *__format ,
                                                               __gnuc_va_list __args ) ;
#line 179
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) asprintf)(char **__ptr ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 179 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) asprintf)(char **__ptr , char const   *__fmt 
                                                                , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 181
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 181
  __cil_tmp4 = __asprintf_chk(__ptr, 1, __fmt, __cil_tmp3);
  }
#line 181
  return (__cil_tmp4);
}
}
#line 194
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) obstack_printf)(struct obstack *__obstack ,
                                                                                                    char const   *__fmt 
                                                                                                    , ...) ;
#line 194 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) obstack_printf)(struct obstack *__obstack ,
                                                                      char const   *__fmt 
                                                                      , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 197
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 197
  __cil_tmp4 = __obstack_printf_chk(__obstack, 1, __fmt, __cil_tmp3);
  }
#line 197
  return (__cil_tmp4);
}
}
#line 210
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vasprintf)(char **__ptr ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 210 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vasprintf)(char **__ptr , char const   *__fmt ,
                                                                 __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 213
  __cil_tmp4 = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  }
#line 213
  return (__cil_tmp4);
}
}
#line 217
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) obstack_vprintf)(struct obstack *__obstack ,
                                                                                                     char const   *__fmt ,
                                                                                                     __gnuc_va_list __ap ) ;
#line 217 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) obstack_vprintf)(struct obstack *__obstack ,
                                                                       char const   *__fmt ,
                                                                       __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 220
  __cil_tmp4 = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  }
#line 220
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 259
    __cil_tmp5 = 0;
#line 259
    if (! __cil_tmp5) {
      {
#line 260
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
#line 260
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size((void *)__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size((void *)__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 289
    __cil_tmp7 = 0;
#line 289
    __cil_tmp6 = 0;
#line 289
    if (! __cil_tmp6) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 301
extern char *__fgets_unlocked_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 303
extern char *__fgets_unlocked_alias(char *__s , int __n , FILE *__stream ) ;
#line 306
extern char *__fgets_unlocked_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 313 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__gnu_inline__)) fgets_unlocked)(char *__s ,
                                                                        int __n ,
                                                                        FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 315
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
  }
#line 315
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 317
    __cil_tmp5 = 0;
#line 317
    if (! __cil_tmp5) {
      {
#line 318
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 318
      __cil_tmp7 = __fgets_unlocked_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 318
      return (__cil_tmp7);
    } else
#line 317
    if (__n <= 0) {
      {
#line 318
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 318
      __cil_tmp7 = __fgets_unlocked_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 318
      return (__cil_tmp7);
    }
    {
#line 320
    __cil_tmp8 = __builtin_object_size((void *)__s, 1);
    }
#line 320
    if ((size_t )__n > __cil_tmp8) {
      {
#line 321
      __cil_tmp9 = __builtin_object_size((void *)__s, 1);
#line 321
      __cil_tmp10 = __fgets_unlocked_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 321
      return (__cil_tmp10);
    }
  }
  {
#line 323
  __cil_tmp11 = __fgets_unlocked_alias(__s, __n, __stream);
  }
#line 323
  return (__cil_tmp11);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 350
    __cil_tmp7 = 0;
#line 350
    __cil_tmp6 = 0;
#line 350
    if (! __cil_tmp6) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
#line 362
  __cil_tmp14 = 0;
#line 362
  __cil_tmp13 = 0;
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;

#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: ;
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 820
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;

#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 42
  return ((void *)0);
}
}
#line 840 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 992
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                  char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size((void *)__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size((void *)__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd , char *__buf ,
                                                                 size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 68
    __cil_tmp5 = 0;
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 92
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                   char const   *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    __cil_tmp5 = 0;
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst , wchar_t *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 149
    __cil_tmp5 = 0;
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 378
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) mempcpy)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 38 "/usr/include/strings.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                              void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 27
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) bzero)(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
#line 33
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                                                     size_t __len ) ;
#line 452
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest , void const   *__src ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memmove)(void *__dest , void const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 45
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) mempcpy)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 45 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) mempcpy)(void *__dest , void const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 48
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 48
  __cil_tmp5 = __builtin___mempcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 48
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memset)(void *__dest , int __ch ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
extern  __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                               size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                                                     size_t __len ) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                       size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
#line 85
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 95
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) stpcpy)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 97
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 97
  __cil_tmp4 = __builtin___stpcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 97
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                                                 size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size((void *)__dest, 1);
#line 118
  __cil_tmp5 = 0;
#line 118
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcat)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncat)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 98 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 536 "/root/patchweave_donee/23/src/sndfile.h"
SNDFILE *sf_open(char const   *path , int mode , SF_INFO *sfinfo ) ;
#line 551
SNDFILE *sf_open_fd(int fd , int mode , SF_INFO *sfinfo , int close_desc ) ;
#line 553
SNDFILE *sf_open_virtual(SF_VIRTUAL_IO *sfvirtual , int mode , SF_INFO *sfinfo , void *user_data ) ;
#line 560
int sf_error(SNDFILE *sndfile ) ;
#line 567
char const   *sf_strerror(SNDFILE *sndfile ) ;
#line 575
char const   *sf_error_number(int errnum ) ;
#line 583
int sf_perror(SNDFILE *sndfile ) ;
#line 584
int sf_error_str(SNDFILE *sndfile , char *str___0 , size_t maxlen ) ;
#line 589
int sf_command(SNDFILE *sndfile , int command , void *data , int datasize ) ;
#line 594
int sf_format_check(SF_INFO *info ) ;
#line 615
sf_count_t sf_seek(SNDFILE *sndfile , sf_count_t offset , int whence ) ;
#line 626
int sf_set_string(SNDFILE *sndfile , int str_type , char const   *str___0 ) ;
#line 628
char const   *sf_get_string(SNDFILE *sndfile , int str_type ) ;
#line 633
char const   *sf_version_string(void) ;
#line 646
int sf_current_byterate(SNDFILE *sndfile ) ;
#line 651
sf_count_t sf_read_raw(SNDFILE *sndfile , void *ptr , sf_count_t bytes ) ;
#line 652
sf_count_t sf_write_raw(SNDFILE *sndfile , void const   *ptr , sf_count_t len ) ;
#line 665
sf_count_t sf_readf_short(SNDFILE *sndfile , short *ptr , sf_count_t frames ) ;
#line 666
sf_count_t sf_writef_short(SNDFILE *sndfile , short const   *ptr , sf_count_t frames ) ;
#line 668
sf_count_t sf_readf_int(SNDFILE *sndfile , int *ptr , sf_count_t frames ) ;
#line 669
sf_count_t sf_writef_int(SNDFILE *sndfile , int const   *ptr , sf_count_t frames ) ;
#line 671
sf_count_t sf_readf_float(SNDFILE *sndfile , float *ptr , sf_count_t frames ) ;
#line 672
sf_count_t sf_writef_float(SNDFILE *sndfile , float const   *ptr , sf_count_t frames ) ;
#line 674
sf_count_t sf_readf_double(SNDFILE *sndfile , double *ptr , sf_count_t frames ) ;
#line 675
sf_count_t sf_writef_double(SNDFILE *sndfile , double const   *ptr , sf_count_t frames ) ;
#line 683
sf_count_t sf_read_short(SNDFILE *sndfile , short *ptr , sf_count_t len ) ;
#line 684
sf_count_t sf_write_short(SNDFILE *sndfile , short const   *ptr , sf_count_t len ) ;
#line 686
sf_count_t sf_read_int(SNDFILE *sndfile , int *ptr , sf_count_t len ) ;
#line 687
sf_count_t sf_write_int(SNDFILE *sndfile , int const   *ptr , sf_count_t len ) ;
#line 689
sf_count_t sf_read_float(SNDFILE *sndfile , float *ptr , sf_count_t len ) ;
#line 690
sf_count_t sf_write_float(SNDFILE *sndfile , float const   *ptr , sf_count_t len ) ;
#line 692
sf_count_t sf_read_double(SNDFILE *sndfile , double *ptr , sf_count_t len ) ;
#line 693
sf_count_t sf_write_double(SNDFILE *sndfile , double const   *ptr , sf_count_t len ) ;
#line 701
int sf_close(SNDFILE *sndfile ) ;
#line 709
void sf_write_sync(SNDFILE *sndfile ) ;
#line 756
int sf_set_chunk(SNDFILE *sndfile , SF_CHUNK_INFO *chunk_info ) ;
#line 780
SF_CHUNK_ITERATOR *sf_get_chunk_iterator(SNDFILE *sndfile , SF_CHUNK_INFO *chunk_info ) ;
#line 794
SF_CHUNK_ITERATOR *sf_next_chunk_iterator(SF_CHUNK_ITERATOR *iterator ) ;
#line 809
int sf_get_chunk_size(SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 823
int sf_get_chunk_data(SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 297 "/usr/include/inttypes.h"
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                      char **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                       char **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                      __gwchar_t **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                       __gwchar_t **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 31 "/root/patchweave_donee/23/src/sfendian.h"
__inline static int16_t ENDSWAP_16(int16_t x ) 
{ 
  int16_t y ;

  {
#line 36
  __asm__  ("asm":);
#line 34
  return (y);
}
}
#line 38 "/root/patchweave_donee/23/src/sfendian.h"
__inline static int32_t ENDSWAP_32(int32_t x ) 
{ 
  int32_t y ;

  {
#line 43
  __asm__  ("asm":);
#line 41
  return (y);
}
}
#line 47 "/root/patchweave_donee/23/src/sfendian.h"
__inline static int64_t ENDSWAP_64X(int64_t x ) 
{ 
  int64_t y ;

  {
#line 52
  __asm__  ("asm":);
#line 50
  return (y);
}
}
#line 146 "/root/patchweave_donee/23/src/sfendian.h"
__inline static void psf_put_be64(uint8_t *ptr , int offset , int64_t value ) 
{ 


  {
#line 148
  *(ptr + offset) = (uint8_t )(value >> 56);
#line 149
  *(ptr + (offset + 1)) = (uint8_t )(value >> 48);
#line 150
  *(ptr + (offset + 2)) = (uint8_t )(value >> 40);
#line 151
  *(ptr + (offset + 3)) = (uint8_t )(value >> 32);
#line 152
  *(ptr + (offset + 4)) = (uint8_t )(value >> 24);
#line 153
  *(ptr + (offset + 5)) = (uint8_t )(value >> 16);
#line 154
  *(ptr + (offset + 6)) = (uint8_t )(value >> 8);
#line 155
  *(ptr + (offset + 7)) = (uint8_t )value;
#line 156
  return;
}
}
#line 159 "/root/patchweave_donee/23/src/sfendian.h"
__inline static void psf_put_be32(uint8_t *ptr , int offset , int32_t value ) 
{ 


  {
#line 161
  *(ptr + offset) = (uint8_t )(value >> 24);
#line 162
  *(ptr + (offset + 1)) = (uint8_t )(value >> 16);
#line 163
  *(ptr + (offset + 2)) = (uint8_t )(value >> 8);
#line 164
  *(ptr + (offset + 3)) = (uint8_t )value;
#line 165
  return;
}
}
#line 175 "/root/patchweave_donee/23/src/sfendian.h"
__inline static int64_t psf_get_be64(uint8_t *ptr , int offset ) 
{ 
  int64_t value ;

  {
#line 178
  value = (int64_t )((uint32_t )*(ptr + offset) << 24);
#line 179
  value += (long )((int )*(ptr + (offset + 1)) << 16);
#line 180
  value += (long )((int )*(ptr + (offset + 2)) << 8);
#line 181
  value += (long )*(ptr + (offset + 3));
#line 183
  value = (int64_t )((uint64_t )value << 32);
#line 185
  value += (long )((uint32_t )*(ptr + (offset + 4)) << 24);
#line 186
  value += (long )((int )*(ptr + (offset + 5)) << 16);
#line 187
  value += (long )((int )*(ptr + (offset + 6)) << 8);
#line 188
  value += (long )*(ptr + (offset + 7));
#line 189
  return (value);
}
}
#line 193 "/root/patchweave_donee/23/src/sfendian.h"
__inline static int64_t psf_get_le64(uint8_t *ptr , int offset ) 
{ 
  int64_t value ;

  {
#line 196
  value = (int64_t )((uint32_t )*(ptr + (offset + 7)) << 24);
#line 197
  value += (long )((int )*(ptr + (offset + 6)) << 16);
#line 198
  value += (long )((int )*(ptr + (offset + 5)) << 8);
#line 199
  value += (long )*(ptr + (offset + 4));
#line 201
  value = (int64_t )((uint64_t )value << 32);
#line 203
  value += (long )((uint32_t )*(ptr + (offset + 3)) << 24);
#line 204
  value += (long )((int )*(ptr + (offset + 2)) << 16);
#line 205
  value += (long )((int )*(ptr + (offset + 1)) << 8);
#line 206
  value += (long )*(ptr + offset);
#line 207
  return (value);
}
}
#line 211 "/root/patchweave_donee/23/src/sfendian.h"
__inline static int32_t psf_get_be32(uint8_t *ptr , int offset ) 
{ 
  int32_t value ;

  {
#line 214
  value = (int32_t )((uint32_t )*(ptr + offset) << 24);
#line 215
  value += (int )*(ptr + (offset + 1)) << 16;
#line 216
  value += (int )*(ptr + (offset + 2)) << 8;
#line 217
  value += (int )*(ptr + (offset + 3));
#line 218
  return (value);
}
}
#line 222 "/root/patchweave_donee/23/src/sfendian.h"
__inline static int32_t psf_get_le32(uint8_t *ptr , int offset ) 
{ 
  int32_t value ;

  {
#line 225
  value = (int32_t )((uint32_t )*(ptr + (offset + 3)) << 24);
#line 226
  value += (int )*(ptr + (offset + 2)) << 16;
#line 227
  value += (int )*(ptr + (offset + 1)) << 8;
#line 228
  value += (int )*(ptr + offset);
#line 229
  return (value);
}
}
#line 233 "/root/patchweave_donee/23/src/sfendian.h"
__inline static int32_t psf_get_be24(uint8_t *ptr , int offset ) 
{ 
  int32_t value ;

  {
#line 236
  value = (int32_t )((uint32_t )*(ptr + offset) << 24);
#line 237
  value += (int )*(ptr + (offset + 1)) << 16;
#line 238
  value += (int )*(ptr + (offset + 2)) << 8;
#line 239
  return (value);
}
}
#line 243 "/root/patchweave_donee/23/src/sfendian.h"
__inline static int32_t psf_get_le24(uint8_t *ptr , int offset ) 
{ 
  int32_t value ;

  {
#line 246
  value = (int32_t )((uint32_t )*(ptr + (offset + 2)) << 24);
#line 247
  value += (int )*(ptr + (offset + 1)) << 16;
#line 248
  value += (int )*(ptr + offset) << 8;
#line 249
  return (value);
}
}
#line 253 "/root/patchweave_donee/23/src/sfendian.h"
__inline static int16_t psf_get_be16(uint8_t *ptr , int offset ) 
{ 


  {
#line 254
  return ((int16_t )(((int )*(ptr + offset) << 8) + (int )*(ptr + (offset + 1))));
}
}
#line 262 "/root/patchweave_donee/23/src/sfendian.h"
__inline static void endswap_short_array(short *ptr , int len ) 
{ 
  short temp ;

  {
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    len --;
#line 265
    if (! (len >= 0)) {
#line 265
      goto while_break;
    }
    {
#line 266
    temp = *(ptr + len);
#line 267
    *(ptr + len) = ENDSWAP_16(temp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 273
  return;
}
}
#line 272 "/root/patchweave_donee/23/src/sfendian.h"
__inline static void endswap_short_copy(short *dest , short const   *src , int len ) 
{ 


  {
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    len --;
#line 274
    if (! (len >= 0)) {
#line 274
      goto while_break;
    }
    {
#line 275
    *(dest + len) = ENDSWAP_16((int16_t )*(src + len));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 281
  return;
}
}
#line 280 "/root/patchweave_donee/23/src/sfendian.h"
__inline static void endswap_int_array(int *ptr , int len ) 
{ 
  int temp ;

  {
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    len --;
#line 283
    if (! (len >= 0)) {
#line 283
      goto while_break;
    }
    {
#line 284
    temp = *(ptr + len);
#line 285
    *(ptr + len) = ENDSWAP_32(temp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 291
  return;
}
}
#line 290 "/root/patchweave_donee/23/src/sfendian.h"
__inline static void endswap_int_copy(int *dest , int const   *src , int len ) 
{ 


  {
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    len --;
#line 292
    if (! (len >= 0)) {
#line 292
      goto while_break;
    }
    {
#line 293
    *(dest + len) = ENDSWAP_32((int32_t )*(src + len));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 299
  return;
}
}
#line 301 "/root/patchweave_donee/23/src/sfendian.h"
__inline static void endswap_int64_t_array(int64_t *ptr , int len ) 
{ 
  int64_t value ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    len --;
#line 304
    if (! (len >= 0)) {
#line 304
      goto while_break;
    }
    {
#line 305
    value = *(ptr + len);
#line 306
    *(ptr + len) = ENDSWAP_64X(value);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 312
  return;
}
}
#line 311 "/root/patchweave_donee/23/src/sfendian.h"
__inline static void endswap_int64_t_copy(int64_t *dest , int64_t *src , int len ) 
{ 
  int64_t value ;

  {
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    len --;
#line 314
    if (! (len >= 0)) {
#line 314
      goto while_break;
    }
    {
#line 315
    value = *(src + len);
#line 316
    *(dest + len) = ENDSWAP_64X(value);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 322
  return;
}
}
#line 328 "/root/patchweave_donee/23/src/sfendian.h"
__inline static void endswap_double_array(double *ptr , int len ) 
{ 


  {
  {
#line 329
  endswap_int64_t_array((int64_t *)ptr, len);
  }
#line 331
  return;
}
}
#line 338 "/root/patchweave_donee/23/src/sfendian.h"
__inline static void endswap_double_copy(double *dest , double const   *src , int len ) 
{ 


  {
  {
#line 339
  endswap_int64_t_copy((int64_t *)dest, (int64_t *)src, len);
  }
#line 341
  return;
}
}
#line 219 "/root/patchweave_donee/23/src/common.h"
__inline static PEAK_INFO *peak_info_calloc(int channels ) 
{ 
  void *__cil_tmp2 ;

  {
  {
#line 220
  __cil_tmp2 = calloc(1UL, sizeof(PEAK_INFO ) + (unsigned long )channels * sizeof(PEAK_POS ));
  }
#line 220
  return ((PEAK_INFO *)__cil_tmp2);
}
}
#line 265 "/root/patchweave_donee/23/src/common.h"
__inline static size_t make_size_t(int x ) 
{ 


  {
#line 266
  return ((size_t )x);
}
}
#line 281 "/root/patchweave_donee/23/src/common.h"
__inline static void *psf_memdup(void const   *src , size_t n ) 
{ 
  void *mem ;
  size_t tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
#line 282
  if (n & 3UL) {
#line 282
    tmp = (n + 4UL) - (n & 3UL);
  } else {
#line 282
    tmp = n;
  }
  {
#line 282
  __cil_tmp5 = calloc(1UL, tmp);
#line 282
  mem = __cil_tmp5;
#line 283
  __cil_tmp6 = memcpy(mem, src, n);
  }
#line 283
  return (__cil_tmp6);
}
}
#line 291 "/root/patchweave_donee/23/src/common.h"
__inline static int psf_isprint(int ch ) 
{ 
  int tmp ;

  {
#line 292
  if (ch >= 32) {
#line 292
    if (ch <= 126) {
#line 292
      tmp = 1;
    } else {
#line 292
      tmp = 0;
    }
  } else {
#line 292
    tmp = 0;
  }
#line 292
  return (tmp);
}
}
#line 722
int subformat_to_bytewidth(int format ) ;
#line 723
int s_bitwidth_to_subformat(int bits ) ;
#line 724
int u_bitwidth_to_subformat(int bits ) ;
#line 729
float float32_be_read(unsigned char const   *cptr ) ;
#line 730
float float32_le_read(unsigned char const   *cptr ) ;
#line 731
void float32_be_write(float in , unsigned char *out ) ;
#line 732
void float32_le_write(float in , unsigned char *out ) ;
#line 734
double double64_be_read(unsigned char const   *cptr ) ;
#line 735
double double64_le_read(unsigned char const   *cptr ) ;
#line 736
void double64_be_write(double in , unsigned char *out ) ;
#line 737
void double64_le_write(double in , unsigned char *out ) ;
#line 741
void psf_log_printf(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 742
void psf_log_SF_INFO(SF_PRIVATE *psf ) ;
#line 744
int32_t psf_rand_int32(void) ;
#line 746
void append_snprintf(char *dest , size_t maxlen , char const   *fmt  , ...) ;
#line 747
void psf_strlcpy_crlf(char *dest , char const   *src , size_t destmax , size_t srcmax ) ;
#line 749
sf_count_t psf_decode_frame_count(SF_PRIVATE *psf ) ;
#line 753
int psf_binheader_writef(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 754
void psf_asciiheader_printf(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 758
int psf_binheader_readf(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 768
int psf_get_format_simple_count(void) ;
#line 769
int psf_get_format_simple(SF_FORMAT_INFO *data ) ;
#line 771
int psf_get_format_info(SF_FORMAT_INFO *data ) ;
#line 773
int psf_get_format_major_count(void) ;
#line 774
int psf_get_format_major(SF_FORMAT_INFO *data ) ;
#line 776
int psf_get_format_subtype_count(void) ;
#line 777
int psf_get_format_subtype(SF_FORMAT_INFO *data ) ;
#line 781
double psf_calc_signal_max(SF_PRIVATE *psf , int normalize ) ;
#line 782
int psf_calc_max_all_channels(SF_PRIVATE *psf , double *peaks , int normalize ) ;
#line 784
int psf_get_signal_max(SF_PRIVATE *psf , double *peak ) ;
#line 785
int psf_get_max_all_channels(SF_PRIVATE *psf , double *peaks ) ;
#line 789
char const   *psf_get_string(SF_PRIVATE *psf , int str_type ) ;
#line 790
int psf_set_string(SF_PRIVATE *psf , int str_type , char const   *str ) ;
#line 791
int psf_store_string(SF_PRIVATE *psf , int str_type , char const   *str ) ;
#line 792
int psf_location_string_count(SF_PRIVATE *psf , int location ) ;
#line 795
sf_count_t psf_default_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t samples_from_start ) ;
#line 797
int macos_guess_file_type(SF_PRIVATE *psf , char const   *filename___0 ) ;
#line 804
int psf_fopen(SF_PRIVATE *psf ) ;
#line 805
int psf_set_stdio(SF_PRIVATE *psf ) ;
#line 806
int psf_file_valid(SF_PRIVATE *psf ) ;
#line 807
void psf_set_file(SF_PRIVATE *psf , int fd ) ;
#line 808
void psf_init_files(SF_PRIVATE *psf ) ;
#line 809
void psf_use_rsrc(SF_PRIVATE *psf , int on_off ) ;
#line 811
SNDFILE *psf_open_file(SF_PRIVATE *psf , SF_INFO *sfinfo ) ;
#line 813
sf_count_t psf_fseek(SF_PRIVATE *psf , sf_count_t offset , int whence ) ;
#line 814
sf_count_t psf_fread(void *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) ;
#line 815
sf_count_t psf_fwrite(void const   *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) ;
#line 816
sf_count_t psf_fgets(char *buffer , sf_count_t bufsize , SF_PRIVATE *psf ) ;
#line 817
sf_count_t psf_ftell(SF_PRIVATE *psf ) ;
#line 818
sf_count_t psf_get_filelen(SF_PRIVATE *psf ) ;
#line 820
void psf_fsync(SF_PRIVATE *psf ) ;
#line 822
int psf_is_pipe(SF_PRIVATE *psf ) ;
#line 824
int psf_ftruncate(SF_PRIVATE *psf , sf_count_t len ) ;
#line 825
int psf_fclose(SF_PRIVATE *psf ) ;
#line 828
int psf_open_rsrc(SF_PRIVATE *psf ) ;
#line 829
int psf_close_rsrc(SF_PRIVATE *psf ) ;
#line 840
int aiff_open(SF_PRIVATE *psf ) ;
#line 841
int au_open(SF_PRIVATE *psf ) ;
#line 842
int avr_open(SF_PRIVATE *psf ) ;
#line 843
int htk_open(SF_PRIVATE *psf ) ;
#line 844
int ircam_open(SF_PRIVATE *psf ) ;
#line 845
int mat4_open(SF_PRIVATE *psf ) ;
#line 846
int mat5_open(SF_PRIVATE *psf ) ;
#line 847
int nist_open(SF_PRIVATE *psf ) ;
#line 848
int paf_open(SF_PRIVATE *psf ) ;
#line 849
int pvf_open(SF_PRIVATE *psf ) ;
#line 850
int raw_open(SF_PRIVATE *psf ) ;
#line 851
int sd2_open(SF_PRIVATE *psf ) ;
#line 852
int sds_open(SF_PRIVATE *psf ) ;
#line 853
int svx_open(SF_PRIVATE *psf ) ;
#line 854
int voc_open(SF_PRIVATE *psf ) ;
#line 855
int w64_open(SF_PRIVATE *psf ) ;
#line 856
int wav_open(SF_PRIVATE *psf ) ;
#line 857
int xi_open(SF_PRIVATE *psf ) ;
#line 858
int flac_open(SF_PRIVATE *psf ) ;
#line 859
int caf_open(SF_PRIVATE *psf ) ;
#line 860
int mpc2k_open(SF_PRIVATE *psf ) ;
#line 861
int rf64_open(SF_PRIVATE *psf ) ;
#line 863
int ogg_vorbis_open(SF_PRIVATE *psf ) ;
#line 864
int ogg_speex_open(SF_PRIVATE *psf ) ;
#line 865
int ogg_pcm_open(SF_PRIVATE *psf ) ;
#line 866
int ogg_opus_open(SF_PRIVATE *psf ) ;
#line 867
int ogg_open(SF_PRIVATE *psf ) ;
#line 873
int rx2_open(SF_PRIVATE *psf ) ;
#line 874
int txw_open(SF_PRIVATE *psf ) ;
#line 875
int wve_open(SF_PRIVATE *psf ) ;
#line 876
int dwd_open(SF_PRIVATE *psf ) ;
#line 878
int macbinary3_open(SF_PRIVATE *UNUSED_psf ) ;
#line 884
int pcm_init(SF_PRIVATE *psf ) ;
#line 885
int ulaw_init(SF_PRIVATE *psf ) ;
#line 886
int alaw_init(SF_PRIVATE *psf ) ;
#line 887
int float32_init(SF_PRIVATE *psf ) ;
#line 888
int double64_init(SF_PRIVATE *psf ) ;
#line 889
int dwvw_init(SF_PRIVATE *psf , int bitwidth ) ;
#line 890
int gsm610_init(SF_PRIVATE *psf ) ;
#line 891
int vox_adpcm_init(SF_PRIVATE *psf ) ;
#line 892
int flac_init(SF_PRIVATE *psf ) ;
#line 893
int g72x_init(SF_PRIVATE *psf ) ;
#line 894
int alac_init(SF_PRIVATE *psf , ALAC_DECODER_INFO *info ) ;
#line 896
int dither_init(SF_PRIVATE *psf , int mode ) ;
#line 898
int wav_w64_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 899
int wav_w64_msadpcm_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 901
int aiff_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 903
int interleave_init(SF_PRIVATE *psf ) ;
#line 909
SF_CHUNK_ITERATOR *psf_get_chunk_iterator(SF_PRIVATE *psf , char const   *marker_str ) ;
#line 910
SF_CHUNK_ITERATOR *psf_next_chunk_iterator(READ_CHUNKS *pchk , SF_CHUNK_ITERATOR *iterator ) ;
#line 911
int psf_store_read_chunk_u32(READ_CHUNKS *pchk , uint32_t marker , sf_count_t offset ,
                             uint32_t len ) ;
#line 912
int psf_store_read_chunk_str(READ_CHUNKS *pchk , char const   *marker_str , sf_count_t offset ,
                             uint32_t len ) ;
#line 913
int psf_save_write_chunk(WRITE_CHUNKS *pchk , SF_CHUNK_INFO *chunk_info ) ;
#line 914
int psf_find_read_chunk_str(READ_CHUNKS *pchk , char const   *marker_str ) ;
#line 915
int psf_find_read_chunk_m32(READ_CHUNKS *pchk , uint32_t marker ) ;
#line 916
int psf_find_read_chunk_iterator(READ_CHUNKS *pchk , SF_CHUNK_ITERATOR *marker ) ;
#line 944 "/root/patchweave_donee/23/src/common.h"
__inline static void psf_strlcat(char *dest , size_t n , char const   *src ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 945
  __cil_tmp4 = strlen((char const   *)dest);
#line 945
  strncat(dest, src, (n - __cil_tmp4) - 1UL);
#line 946
  *(dest + (n - 1UL)) = (char)0;
  }
#line 948
  return;
}
}
#line 950 "/root/patchweave_donee/23/src/common.h"
__inline static void psf_strlcpy(char *dest , size_t n , char const   *src ) 
{ 


  {
  {
#line 951
  strncpy(dest, src, n - 1UL);
#line 952
  *(dest + (n - 1UL)) = (char)0;
  }
#line 954
  return;
}
}
#line 959
void *psf_memset(void *s , int c , sf_count_t len ) ;
#line 961
SF_INSTRUMENT *psf_instrument_alloc(void) ;
#line 963
void psf_sanitize_string(char *cptr , int len ) ;
#line 966
void psf_get_date_str(char *str , int maxlen ) ;
#line 968
SF_BROADCAST_INFO_16K *broadcast_var_alloc(void) ;
#line 969
int broadcast_var_set(SF_PRIVATE *psf , SF_BROADCAST_INFO *info , size_t datasize ) ;
#line 970
int broadcast_var_get(SF_PRIVATE *psf , SF_BROADCAST_INFO *data , size_t datasize ) ;
#line 973
SF_CART_INFO_16K *cart_var_alloc(void) ;
#line 974
int cart_var_set(SF_PRIVATE *psf , SF_CART_INFO *info , size_t datasize ) ;
#line 975
int cart_var_get(SF_PRIVATE *psf , SF_CART_INFO *data , size_t datasize ) ;
#line 982
int audio_detect(SF_PRIVATE *psf , AUDIO_DETECT *ad , unsigned char const   *data ,
                 int datalen ) ;
#line 983
int id3_skip(SF_PRIVATE *psf ) ;
#line 985
void alac_get_desc_chunk_items(int subformat , uint32_t *fmt_flags , uint32_t *frames_per_packet ) ;
#line 987
FILE *psf_open_tmpfile(char *fname , size_t fnamelen ) ;
#line 993
void psf_hexdump(void const   *ptr , int len ) ;
#line 995
char const   *str_of_major_format(int format ) ;
#line 996
char const   *str_of_minor_format(int format ) ;
#line 997
char const   *str_of_open_mode(int mode ) ;
#line 998
char const   *str_of_endianness(int end ) ;
#line 1027
void psf_f2s_array(float const   *src , short *dest , int count___0 , int normalize ) ;
#line 1028
void psf_f2s_clip_array(float const   *src , short *dest , int count___0 , int normalize ) ;
#line 1030
void psf_d2s_array(double const   *src , short *dest , int count___0 , int normalize ) ;
#line 1031
void psf_d2s_clip_array(double const   *src , short *dest , int count___0 , int normalize ) ;
#line 1033
void psf_f2i_array(float const   *src , int *dest , int count___0 , int normalize ) ;
#line 1034
void psf_f2i_clip_array(float const   *src , int *dest , int count___0 , int normalize ) ;
#line 1036
void psf_d2i_array(double const   *src , int *dest , int count___0 , int normalize ) ;
#line 1037
void psf_d2i_clip_array(double const   *src , int *dest , int count___0 , int normalize ) ;
#line 1053 "/root/patchweave_donee/23/src/common.h"
__inline static int32_t arith_shift_left(int32_t x , int shift ) 
{ 


  {
#line 1054
  return ((int32_t )((uint32_t )x << shift));
}
}
#line 48 "/root/patchweave_donee/23/src/ima_oki_adpcm.h"
void ima_oki_adpcm_init(IMA_OKI_ADPCM *state , IMA_OKI_ADPCM_TYPE type ) ;
#line 50
int adpcm_decode(IMA_OKI_ADPCM *state , int code ) ;
#line 51
int adpcm_encode(IMA_OKI_ADPCM *state , int sample ) ;
#line 53
void ima_oki_adpcm_decode_block(IMA_OKI_ADPCM *state ) ;
#line 54
void ima_oki_adpcm_encode_block(IMA_OKI_ADPCM *state ) ;
#line 45 "/root/patchweave_donee/23/src/vox_adpcm.c"
static sf_count_t vox_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 46
static sf_count_t vox_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 47
static sf_count_t vox_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 48
static sf_count_t vox_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 50
static sf_count_t vox_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 51
static sf_count_t vox_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 52
static sf_count_t vox_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 53
static sf_count_t vox_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 55
static int vox_read_block(SF_PRIVATE *psf , IMA_OKI_ADPCM *pvox , short *ptr , int len ) ;
#line 61 "/root/patchweave_donee/23/src/vox_adpcm.c"
static int codec_close(SF_PRIVATE *psf ) 
{ 
  IMA_OKI_ADPCM *p ;

  {
#line 63
  p = (IMA_OKI_ADPCM *)psf->codec_data;
#line 65
  if (p->errors) {
    {
#line 66
    psf_log_printf(psf, "*** Warning : ADPCM state errors: %d\n", p->errors);
    }
  }
#line 67
  return (p->errors);
}
}
#line 71 "/root/patchweave_donee/23/src/vox_adpcm.c"
int vox_adpcm_init(SF_PRIVATE *psf ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  sf_count_t __cil_tmp4 ;
  void *tmp ;

  {
#line 72
  pvox = (IMA_OKI_ADPCM *)((void *)0);
#line 74
  if (psf->file.mode == 48) {
#line 75
    return (24);
  }
#line 77
  if (psf->file.mode == 32) {
#line 77
    if (psf->sf.channels != 1) {
#line 78
      return (34);
    }
  }
  {
#line 80
  tmp = malloc(sizeof(IMA_OKI_ADPCM ));
#line 80
  pvox = (IMA_OKI_ADPCM *)tmp;
  }
#line 80
  if ((unsigned long )pvox == (unsigned long )((void *)0)) {
#line 81
    return (17);
  }
  {
#line 83
  psf->codec_data = (void *)pvox;
#line 84
  memset((void *)pvox, 0, sizeof(IMA_OKI_ADPCM ));
  }
#line 86
  if (psf->file.mode == 32) {
#line 87
    psf->write_short = & vox_write_s;
#line 88
    psf->write_int = & vox_write_i;
#line 89
    psf->write_float = & vox_write_f;
#line 90
    psf->write_double = & vox_write_d;
  } else {
    {
#line 93
    psf_log_printf(psf, "Header-less OKI Dialogic ADPCM encoded file.\n");
#line 94
    psf_log_printf(psf, "Setting up for 8kHz, mono, Vox ADPCM.\n");
#line 96
    psf->read_short = & vox_read_s;
#line 97
    psf->read_int = & vox_read_i;
#line 98
    psf->read_float = & vox_read_f;
#line 99
    psf->read_double = & vox_read_d;
    }
  }
#line 103
  if (psf->sf.samplerate < 1) {
#line 104
    psf->sf.samplerate = 8000;
  }
  {
#line 105
  psf->sf.channels = 1;
#line 107
  psf->sf.frames = psf->filelength * 2L;
#line 109
  psf->sf.seekable = 0;
#line 110
  psf->codec_close = & codec_close;
#line 113
  __cil_tmp4 = psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 113
  if (__cil_tmp4 == -1L) {
#line 114
    return (39);
  }
  {
#line 116
  ima_oki_adpcm_init(pvox, (IMA_OKI_ADPCM_TYPE )1);
  }
#line 118
  return (0);
}
}
#line 125 "/root/patchweave_donee/23/src/vox_adpcm.c"
static int vox_read_block(SF_PRIVATE *psf , IMA_OKI_ADPCM *pvox , short *ptr , int len ) 
{ 
  int indx ;
  int k ;
  int tmp ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 126
  indx = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;

#line 128
    if (! (indx < len)) {
#line 128
      goto while_break;
    }
#line 129
    if (len - indx > 512) {
#line 129
      tmp = 256;
    } else {
#line 129
      tmp = ((len - indx) + 1) / 2;
    }
    {
#line 129
    pvox->code_count = tmp;
#line 131
    __cil_tmp8 = psf_fread((void *)(pvox->codes), (sf_count_t )1, (sf_count_t )pvox->code_count,
                           psf);
#line 131
    k = (int )__cil_tmp8;
    }
#line 131
    if (k != pvox->code_count) {
      {
#line 132
      __cil_tmp9 = psf_ftell(psf);
      }
#line 132
      if (__cil_tmp9 != psf->filelength) {
        {
#line 133
        psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, pvox->code_count);
        }
      }
#line 134
      if (k == 0) {
#line 135
        goto while_break;
      }
    }
    {
#line 138
    pvox->code_count = k;
#line 140
    ima_oki_adpcm_decode_block(pvox);
#line 142
    memcpy((void *)(ptr + indx), (void const   *)(pvox->pcm), (unsigned long )pvox->pcm_count * sizeof(short ));
#line 143
    indx += pvox->pcm_count;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 146
  return (indx);
}
}
#line 151 "/root/patchweave_donee/23/src/vox_adpcm.c"
static sf_count_t vox_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;

  {
#line 154
  total = (sf_count_t )0;
#line 156
  if (! psf->codec_data) {
#line 157
    return ((sf_count_t )0);
  }
#line 158
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;

#line 160
    if (! (len > 0L)) {
#line 160
      goto while_break;
    }
#line 161
    if (len > 268435456L) {
#line 161
      tmp = 268435456;
    } else {
#line 161
      tmp = (int )len;
    }
    {
#line 161
    readcount = tmp;
#line 163
    count = vox_read_block(psf, pvox, ptr, readcount);
#line 165
    total += (long )count;
#line 166
    len -= (long )count;
    }
#line 167
    if (count != readcount) {
#line 168
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 171
  return (total);
}
}
#line 175 "/root/patchweave_donee/23/src/vox_adpcm.c"
static sf_count_t vox_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;

  {
#line 180
  total = (sf_count_t )0;
#line 182
  if (! psf->codec_data) {
#line 183
    return ((sf_count_t )0);
  }
#line 184
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 186
  sptr = ubuf.sbuf;
#line 187
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;

#line 188
    if (! (len > 0L)) {
#line 188
      goto while_break;
    }
#line 189
    if (len >= (long )bufferlen) {
#line 189
      tmp = bufferlen;
    } else {
#line 189
      tmp = (int )len;
    }
    {
#line 189
    readcount = tmp;
#line 190
    count = vox_read_block(psf, pvox, sptr, readcount);
#line 191
    k = 0;
    }
    {
#line 191
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 191
      if (! (k < readcount)) {
#line 191
        goto while_break___0;
      }
      {
#line 192
      *(ptr + (total + (long )k)) = arith_shift_left((int32_t )*(sptr + k), 16);
#line 191
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 193
    total += (long )count;
#line 194
    len -= (long )readcount;
#line 195
    if (count != readcount) {
#line 196
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 199
  return (total);
}
}
#line 203 "/root/patchweave_donee/23/src/vox_adpcm.c"
static sf_count_t vox_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;

  {
#line 208
  total = (sf_count_t )0;
#line 211
  if (! psf->codec_data) {
#line 212
    return ((sf_count_t )0);
  }
#line 213
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 215
  if (psf->norm_float == 1) {
#line 215
    tmp = 1. / (double )((float )32768);
  } else {
#line 215
    tmp = 1.;
  }
#line 215
  normfact = (float )tmp;
#line 217
  sptr = ubuf.sbuf;
#line 218
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;

#line 219
    if (! (len > 0L)) {
#line 219
      goto while_break;
    }
#line 220
    if (len >= (long )bufferlen) {
#line 220
      tmp___0 = bufferlen;
    } else {
#line 220
      tmp___0 = (int )len;
    }
    {
#line 220
    readcount = tmp___0;
#line 221
    count = vox_read_block(psf, pvox, sptr, readcount);
#line 222
    k = 0;
    }
    {
#line 222
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 222
      if (! (k < readcount)) {
#line 222
        goto while_break___0;
      }
#line 223
      *(ptr + (total + (long )k)) = normfact * (float )*(sptr + k);
#line 222
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 224
    total += (long )count;
#line 225
    len -= (long )readcount;
#line 226
    if (count != readcount) {
#line 227
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 230
  return (total);
}
}
#line 234 "/root/patchweave_donee/23/src/vox_adpcm.c"
static sf_count_t vox_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;

  {
#line 239
  total = (sf_count_t )0;
#line 242
  if (! psf->codec_data) {
#line 243
    return ((sf_count_t )0);
  }
#line 244
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 246
  if (psf->norm_double == 1) {
#line 246
    tmp = 1. / (double )32768;
  } else {
#line 246
    tmp = 1.;
  }
#line 246
  normfact = tmp;
#line 248
  sptr = ubuf.sbuf;
#line 249
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;

#line 250
    if (! (len > 0L)) {
#line 250
      goto while_break;
    }
#line 251
    if (len >= (long )bufferlen) {
#line 251
      tmp___0 = bufferlen;
    } else {
#line 251
      tmp___0 = (int )len;
    }
    {
#line 251
    readcount = tmp___0;
#line 252
    count = vox_read_block(psf, pvox, sptr, readcount);
#line 253
    k = 0;
    }
    {
#line 253
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 253
      if (! (k < readcount)) {
#line 253
        goto while_break___0;
      }
#line 254
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 253
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 255
    total += (long )count;
#line 256
    len -= (long )readcount;
#line 257
    if (count != readcount) {
#line 258
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 261
  return (total);
}
}
#line 268 "/root/patchweave_donee/23/src/vox_adpcm.c"
static int vox_write_block(SF_PRIVATE *psf , IMA_OKI_ADPCM *pvox , short const   *ptr ,
                           int len ) 
{ 
  int indx ;
  int k ;
  int tmp ;
  sf_count_t __cil_tmp8 ;

  {
#line 269
  indx = 0;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;

#line 271
    if (! (indx < len)) {
#line 271
      goto while_break;
    }
#line 272
    if (len - indx > 512) {
#line 272
      tmp = 512;
    } else {
#line 272
      tmp = len - indx;
    }
    {
#line 272
    pvox->pcm_count = tmp;
#line 274
    memcpy((void *)(pvox->pcm), (void const   *)(ptr + indx), (unsigned long )pvox->pcm_count * sizeof(short ));
#line 276
    ima_oki_adpcm_encode_block(pvox);
#line 278
    __cil_tmp8 = psf_fwrite((void const   *)(pvox->codes), (sf_count_t )1, (sf_count_t )pvox->code_count,
                            psf);
#line 278
    k = (int )__cil_tmp8;
    }
#line 278
    if (k != pvox->code_count) {
      {
#line 279
      psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pvox->code_count);
      }
    }
#line 281
    indx += pvox->pcm_count;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 284
  return (indx);
}
}
#line 288 "/root/patchweave_donee/23/src/vox_adpcm.c"
static sf_count_t vox_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;

  {
#line 291
  total = (sf_count_t )0;
#line 293
  if (! psf->codec_data) {
#line 294
    return ((sf_count_t )0);
  }
#line 295
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;

#line 297
    if (! len) {
#line 297
      goto while_break;
    }
#line 298
    if (len > 268435456L) {
#line 298
      tmp = 268435456;
    } else {
#line 298
      tmp = (int )len;
    }
    {
#line 298
    writecount = tmp;
#line 300
    count = vox_write_block(psf, pvox, ptr, writecount);
#line 302
    total += (long )count;
#line 303
    len -= (long )count;
    }
#line 304
    if (count != writecount) {
#line 305
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 308
  return (total);
}
}
#line 312 "/root/patchweave_donee/23/src/vox_adpcm.c"
static sf_count_t vox_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;

  {
#line 317
  total = (sf_count_t )0;
#line 319
  if (! psf->codec_data) {
#line 320
    return ((sf_count_t )0);
  }
#line 321
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 323
  sptr = ubuf.sbuf;
#line 324
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;

#line 325
    if (! (len > 0L)) {
#line 325
      goto while_break;
    }
#line 326
    if (len >= (long )bufferlen) {
#line 326
      tmp = bufferlen;
    } else {
#line 326
      tmp = (int )len;
    }
#line 326
    writecount = tmp;
#line 327
    k = 0;
    {
#line 327
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 327
      if (! (k < writecount)) {
#line 327
        goto while_break___0;
      }
#line 328
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 327
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 329
    count = vox_write_block(psf, pvox, (short const   *)sptr, writecount);
#line 330
    total += (long )count;
#line 331
    len -= (long )writecount;
    }
#line 332
    if (count != writecount) {
#line 333
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 336
  return (total);
}
}
#line 340 "/root/patchweave_donee/23/src/vox_adpcm.c"
static sf_count_t vox_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp15 ;

  {
#line 345
  total = (sf_count_t )0;
#line 348
  if (! psf->codec_data) {
#line 349
    return ((sf_count_t )0);
  }
#line 350
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 352
  if (psf->norm_float == 1) {
#line 352
    tmp = 1. * (double )32767;
  } else {
#line 352
    tmp = 1.;
  }
#line 352
  normfact = (float )tmp;
#line 354
  sptr = ubuf.sbuf;
#line 355
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;

#line 356
    if (! (len > 0L)) {
#line 356
      goto while_break;
    }
#line 357
    if (len >= (long )bufferlen) {
#line 357
      tmp___0 = bufferlen;
    } else {
#line 357
      tmp___0 = (int )len;
    }
#line 357
    writecount = tmp___0;
#line 358
    k = 0;
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 358
      if (! (k < writecount)) {
#line 358
        goto while_break___0;
      }
      {
#line 359
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 359
      *(sptr + k) = (short )__cil_tmp15;
#line 358
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 360
    count = vox_write_block(psf, pvox, (short const   *)sptr, writecount);
#line 361
    total += (long )count;
#line 362
    len -= (long )writecount;
    }
#line 363
    if (count != writecount) {
#line 364
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 367
  return (total);
}
}
#line 371 "/root/patchweave_donee/23/src/vox_adpcm.c"
static sf_count_t vox_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp15 ;

  {
#line 376
  total = (sf_count_t )0;
#line 379
  if (! psf->codec_data) {
#line 380
    return ((sf_count_t )0);
  }
#line 381
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 383
  if (psf->norm_double == 1) {
#line 383
    tmp = 1. * (double )32767;
  } else {
#line 383
    tmp = 1.;
  }
#line 383
  normfact = tmp;
#line 385
  sptr = ubuf.sbuf;
#line 386
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;

#line 387
    if (! (len > 0L)) {
#line 387
      goto while_break;
    }
#line 388
    if (len >= (long )bufferlen) {
#line 388
      tmp___0 = bufferlen;
    } else {
#line 388
      tmp___0 = (int )len;
    }
#line 388
    writecount = tmp___0;
#line 389
    k = 0;
    {
#line 389
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 389
      if (! (k < writecount)) {
#line 389
        goto while_break___0;
      }
      {
#line 390
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 390
      *(sptr + k) = (short )__cil_tmp15;
#line 389
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 391
    count = vox_write_block(psf, pvox, (short const   *)sptr, writecount);
#line 392
    total += (long )count;
#line 393
    len -= (long )writecount;
    }
#line 394
    if (count != writecount) {
#line 395
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 398
  return (total);
}
}
#line 26 "/root/patchweave_donee/23/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 27
static sf_count_t ulaw_read_ulaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 28
static sf_count_t ulaw_read_ulaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 29
static sf_count_t ulaw_read_ulaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 31
static sf_count_t ulaw_write_s2ulaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 32
static sf_count_t ulaw_write_i2ulaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 33
static sf_count_t ulaw_write_f2ulaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 34
static sf_count_t ulaw_write_d2ulaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 37 "/root/patchweave_donee/23/src/ulaw.c"
int ulaw_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;
  sf_count_t tmp___0 ;

  {
#line 39
  if (psf->file.mode == 16) {
#line 40
    psf->read_short = & ulaw_read_ulaw2s;
#line 41
    psf->read_int = & ulaw_read_ulaw2i;
#line 42
    psf->read_float = & ulaw_read_ulaw2f;
#line 43
    psf->read_double = & ulaw_read_ulaw2d;
  } else
#line 39
  if (psf->file.mode == 48) {
#line 40
    psf->read_short = & ulaw_read_ulaw2s;
#line 41
    psf->read_int = & ulaw_read_ulaw2i;
#line 42
    psf->read_float = & ulaw_read_ulaw2f;
#line 43
    psf->read_double = & ulaw_read_ulaw2d;
  }
#line 46
  if (psf->file.mode == 32) {
#line 47
    psf->write_short = & ulaw_write_s2ulaw;
#line 48
    psf->write_int = & ulaw_write_i2ulaw;
#line 49
    psf->write_float = & ulaw_write_f2ulaw;
#line 50
    psf->write_double = & ulaw_write_d2ulaw;
  } else
#line 46
  if (psf->file.mode == 48) {
#line 47
    psf->write_short = & ulaw_write_s2ulaw;
#line 48
    psf->write_int = & ulaw_write_i2ulaw;
#line 49
    psf->write_float = & ulaw_write_f2ulaw;
#line 50
    psf->write_double = & ulaw_write_d2ulaw;
  }
#line 53
  psf->bytewidth = 1;
#line 54
  psf->blockwidth = psf->sf.channels;
#line 56
  if (psf->filelength > psf->dataoffset) {
#line 57
    if (psf->dataend) {
#line 57
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 57
      tmp = psf->filelength - psf->dataoffset;
    }
#line 57
    psf->datalength = tmp;
  } else {
#line 60
    psf->datalength = (sf_count_t )0;
  }
#line 62
  if (psf->blockwidth > 0) {
#line 62
    tmp___0 = psf->datalength / (long )psf->blockwidth;
  } else {
#line 62
    tmp___0 = 0L;
  }
#line 62
  psf->sf.frames = tmp___0;
#line 64
  return (0);
}
}
#line 70 "/root/patchweave_donee/23/src/ulaw.c"
static short ulaw_decode[256]  = 
#line 70
  {      (short)-32124,      (short)-31100,      (short)-30076,      (short)-29052, 
        (short)-28028,      (short)-27004,      (short)-25980,      (short)-24956, 
        (short)-23932,      (short)-22908,      (short)-21884,      (short)-20860, 
        (short)-19836,      (short)-18812,      (short)-17788,      (short)-16764, 
        (short)-15996,      (short)-15484,      (short)-14972,      (short)-14460, 
        (short)-13948,      (short)-13436,      (short)-12924,      (short)-12412, 
        (short)-11900,      (short)-11388,      (short)-10876,      (short)-10364, 
        (short)-9852,      (short)-9340,      (short)-8828,      (short)-8316, 
        (short)-7932,      (short)-7676,      (short)-7420,      (short)-7164, 
        (short)-6908,      (short)-6652,      (short)-6396,      (short)-6140, 
        (short)-5884,      (short)-5628,      (short)-5372,      (short)-5116, 
        (short)-4860,      (short)-4604,      (short)-4348,      (short)-4092, 
        (short)-3900,      (short)-3772,      (short)-3644,      (short)-3516, 
        (short)-3388,      (short)-3260,      (short)-3132,      (short)-3004, 
        (short)-2876,      (short)-2748,      (short)-2620,      (short)-2492, 
        (short)-2364,      (short)-2236,      (short)-2108,      (short)-1980, 
        (short)-1884,      (short)-1820,      (short)-1756,      (short)-1692, 
        (short)-1628,      (short)-1564,      (short)-1500,      (short)-1436, 
        (short)-1372,      (short)-1308,      (short)-1244,      (short)-1180, 
        (short)-1116,      (short)-1052,      (short)-988,      (short)-924, 
        (short)-876,      (short)-844,      (short)-812,      (short)-780, 
        (short)-748,      (short)-716,      (short)-684,      (short)-652, 
        (short)-620,      (short)-588,      (short)-556,      (short)-524, 
        (short)-492,      (short)-460,      (short)-428,      (short)-396, 
        (short)-372,      (short)-356,      (short)-340,      (short)-324, 
        (short)-308,      (short)-292,      (short)-276,      (short)-260, 
        (short)-244,      (short)-228,      (short)-212,      (short)-196, 
        (short)-180,      (short)-164,      (short)-148,      (short)-132, 
        (short)-120,      (short)-112,      (short)-104,      (short)-96, 
        (short)-88,      (short)-80,      (short)-72,      (short)-64, 
        (short)-56,      (short)-48,      (short)-40,      (short)-32, 
        (short)-24,      (short)-16,      (short)-8,      (short)0, 
        (short)32124,      (short)31100,      (short)30076,      (short)29052, 
        (short)28028,      (short)27004,      (short)25980,      (short)24956, 
        (short)23932,      (short)22908,      (short)21884,      (short)20860, 
        (short)19836,      (short)18812,      (short)17788,      (short)16764, 
        (short)15996,      (short)15484,      (short)14972,      (short)14460, 
        (short)13948,      (short)13436,      (short)12924,      (short)12412, 
        (short)11900,      (short)11388,      (short)10876,      (short)10364, 
        (short)9852,      (short)9340,      (short)8828,      (short)8316, 
        (short)7932,      (short)7676,      (short)7420,      (short)7164, 
        (short)6908,      (short)6652,      (short)6396,      (short)6140, 
        (short)5884,      (short)5628,      (short)5372,      (short)5116, 
        (short)4860,      (short)4604,      (short)4348,      (short)4092, 
        (short)3900,      (short)3772,      (short)3644,      (short)3516, 
        (short)3388,      (short)3260,      (short)3132,      (short)3004, 
        (short)2876,      (short)2748,      (short)2620,      (short)2492, 
        (short)2364,      (short)2236,      (short)2108,      (short)1980, 
        (short)1884,      (short)1820,      (short)1756,      (short)1692, 
        (short)1628,      (short)1564,      (short)1500,      (short)1436, 
        (short)1372,      (short)1308,      (short)1244,      (short)1180, 
        (short)1116,      (short)1052,      (short)988,      (short)924, 
        (short)876,      (short)844,      (short)812,      (short)780, 
        (short)748,      (short)716,      (short)684,      (short)652, 
        (short)620,      (short)588,      (short)556,      (short)524, 
        (short)492,      (short)460,      (short)428,      (short)396, 
        (short)372,      (short)356,      (short)340,      (short)324, 
        (short)308,      (short)292,      (short)276,      (short)260, 
        (short)244,      (short)228,      (short)212,      (short)196, 
        (short)180,      (short)164,      (short)148,      (short)132, 
        (short)120,      (short)112,      (short)104,      (short)96, 
        (short)88,      (short)80,      (short)72,      (short)64, 
        (short)56,      (short)48,      (short)40,      (short)32, 
        (short)24,      (short)16,      (short)8,      (short)0};
#line 107 "/root/patchweave_donee/23/src/ulaw.c"
static unsigned char ulaw_encode[8193]  = 
#line 107
  {      (unsigned char)255,      (unsigned char)254,      (unsigned char)254,      (unsigned char)253, 
        (unsigned char)253,      (unsigned char)252,      (unsigned char)252,      (unsigned char)251, 
        (unsigned char)251,      (unsigned char)250,      (unsigned char)250,      (unsigned char)249, 
        (unsigned char)249,      (unsigned char)248,      (unsigned char)248,      (unsigned char)247, 
        (unsigned char)247,      (unsigned char)246,      (unsigned char)246,      (unsigned char)245, 
        (unsigned char)245,      (unsigned char)244,      (unsigned char)244,      (unsigned char)243, 
        (unsigned char)243,      (unsigned char)242,      (unsigned char)242,      (unsigned char)241, 
        (unsigned char)241,      (unsigned char)240,      (unsigned char)240,      (unsigned char)239, 
        (unsigned char)239,      (unsigned char)239,      (unsigned char)239,      (unsigned char)238, 
        (unsigned char)238,      (unsigned char)238,      (unsigned char)238,      (unsigned char)237, 
        (unsigned char)237,      (unsigned char)237,      (unsigned char)237,      (unsigned char)236, 
        (unsigned char)236,      (unsigned char)236,      (unsigned char)236,      (unsigned char)235, 
        (unsigned char)235,      (unsigned char)235,      (unsigned char)235,      (unsigned char)234, 
        (unsigned char)234,      (unsigned char)234,      (unsigned char)234,      (unsigned char)233, 
        (unsigned char)233,      (unsigned char)233,      (unsigned char)233,      (unsigned char)232, 
        (unsigned char)232,      (unsigned char)232,      (unsigned char)232,      (unsigned char)231, 
        (unsigned char)231,      (unsigned char)231,      (unsigned char)231,      (unsigned char)230, 
        (unsigned char)230,      (unsigned char)230,      (unsigned char)230,      (unsigned char)229, 
        (unsigned char)229,      (unsigned char)229,      (unsigned char)229,      (unsigned char)228, 
        (unsigned char)228,      (unsigned char)228,      (unsigned char)228,      (unsigned char)227, 
        (unsigned char)227,      (unsigned char)227,      (unsigned char)227,      (unsigned char)226, 
        (unsigned char)226,      (unsigned char)226,      (unsigned char)226,      (unsigned char)225, 
        (unsigned char)225,      (unsigned char)225,      (unsigned char)225,      (unsigned char)224, 
        (unsigned char)224,      (unsigned char)224,      (unsigned char)224,      (unsigned char)223, 
        (unsigned char)223,      (unsigned char)223,      (unsigned char)223,      (unsigned char)223, 
        (unsigned char)223,      (unsigned char)223,      (unsigned char)223,      (unsigned char)222, 
        (unsigned char)222,      (unsigned char)222,      (unsigned char)222,      (unsigned char)222, 
        (unsigned char)222,      (unsigned char)222,      (unsigned char)222,      (unsigned char)221, 
        (unsigned char)221,      (unsigned char)221,      (unsigned char)221,      (unsigned char)221, 
        (unsigned char)221,      (unsigned char)221,      (unsigned char)221,      (unsigned char)220, 
        (unsigned char)220,      (unsigned char)220,      (unsigned char)220,      (unsigned char)220, 
        (unsigned char)220,      (unsigned char)220,      (unsigned char)220,      (unsigned char)219, 
        (unsigned char)219,      (unsigned char)219,      (unsigned char)219,      (unsigned char)219, 
        (unsigned char)219,      (unsigned char)219,      (unsigned char)219,      (unsigned char)218, 
        (unsigned char)218,      (unsigned char)218,      (unsigned char)218,      (unsigned char)218, 
        (unsigned char)218,      (unsigned char)218,      (unsigned char)218,      (unsigned char)217, 
        (unsigned char)217,      (unsigned char)217,      (unsigned char)217,      (unsigned char)217, 
        (unsigned char)217,      (unsigned char)217,      (unsigned char)217,      (unsigned char)216, 
        (unsigned char)216,      (unsigned char)216,      (unsigned char)216,      (unsigned char)216, 
        (unsigned char)216,      (unsigned char)216,      (unsigned char)216,      (unsigned char)215, 
        (unsigned char)215,      (unsigned char)215,      (unsigned char)215,      (unsigned char)215, 
        (unsigned char)215,      (unsigned char)215,      (unsigned char)215,      (unsigned char)214, 
        (unsigned char)214,      (unsigned char)214,      (unsigned char)214,      (unsigned char)214, 
        (unsigned char)214,      (unsigned char)214,      (unsigned char)214,      (unsigned char)213, 
        (unsigned char)213,      (unsigned char)213,      (unsigned char)213,      (unsigned char)213, 
        (unsigned char)213,      (unsigned char)213,      (unsigned char)213,      (unsigned char)212, 
        (unsigned char)212,      (unsigned char)212,      (unsigned char)212,      (unsigned char)212, 
        (unsigned char)212,      (unsigned char)212,      (unsigned char)212,      (unsigned char)211, 
        (unsigned char)211,      (unsigned char)211,      (unsigned char)211,      (unsigned char)211, 
        (unsigned char)211,      (unsigned char)211,      (unsigned char)211,      (unsigned char)210, 
        (unsigned char)210,      (unsigned char)210,      (unsigned char)210,      (unsigned char)210, 
        (unsigned char)210,      (unsigned char)210,      (unsigned char)210,      (unsigned char)209, 
        (unsigned char)209,      (unsigned char)209,      (unsigned char)209,      (unsigned char)209, 
        (unsigned char)209,      (unsigned char)209,      (unsigned char)209,      (unsigned char)208, 
        (unsigned char)208,      (unsigned char)208,      (unsigned char)208,      (unsigned char)208, 
        (unsigned char)208,      (unsigned char)208,      (unsigned char)208,      (unsigned char)207, 
        (unsigned char)207,      (unsigned char)207,      (unsigned char)207,      (unsigned char)207, 
        (unsigned char)207,      (unsigned char)207,      (unsigned char)207,      (unsigned char)207, 
        (unsigned char)207,      (unsigned char)207,      (unsigned char)207,      (unsigned char)207, 
        (unsigned char)207,      (unsigned char)207,      (unsigned char)207,      (unsigned char)206, 
        (unsigned char)206,      (unsigned char)206,      (unsigned char)206,      (unsigned char)206, 
        (unsigned char)206,      (unsigned char)206,      (unsigned char)206,      (unsigned char)206, 
        (unsigned char)206,      (unsigned char)206,      (unsigned char)206,      (unsigned char)206, 
        (unsigned char)206,      (unsigned char)206,      (unsigned char)206,      (unsigned char)205, 
        (unsigned char)205,      (unsigned char)205,      (unsigned char)205,      (unsigned char)205, 
        (unsigned char)205,      (unsigned char)205,      (unsigned char)205,      (unsigned char)205, 
        (unsigned char)205,      (unsigned char)205,      (unsigned char)205,      (unsigned char)205, 
        (unsigned char)205,      (unsigned char)205,      (unsigned char)205,      (unsigned char)204, 
        (unsigned char)204,      (unsigned char)204,      (unsigned char)204,      (unsigned char)204, 
        (unsigned char)204,      (unsigned char)204,      (unsigned char)204,      (unsigned char)204, 
        (unsigned char)204,      (unsigned char)204,      (unsigned char)204,      (unsigned char)204, 
        (unsigned char)204,      (unsigned char)204,      (unsigned char)204,      (unsigned char)203, 
        (unsigned char)203,      (unsigned char)203,      (unsigned char)203,      (unsigned char)203, 
        (unsigned char)203,      (unsigned char)203,      (unsigned char)203,      (unsigned char)203, 
        (unsigned char)203,      (unsigned char)203,      (unsigned char)203,      (unsigned char)203, 
        (unsigned char)203,      (unsigned char)203,      (unsigned char)203,      (unsigned char)202, 
        (unsigned char)202,      (unsigned char)202,      (unsigned char)202,      (unsigned char)202, 
        (unsigned char)202,      (unsigned char)202,      (unsigned char)202,      (unsigned char)202, 
        (unsigned char)202,      (unsigned char)202,      (unsigned char)202,      (unsigned char)202, 
        (unsigned char)202,      (unsigned char)202,      (unsigned char)202,      (unsigned char)201, 
        (unsigned char)201,      (unsigned char)201,      (unsigned char)201,      (unsigned char)201, 
        (unsigned char)201,      (unsigned char)201,      (unsigned char)201,      (unsigned char)201, 
        (unsigned char)201,      (unsigned char)201,      (unsigned char)201,      (unsigned char)201, 
        (unsigned char)201,      (unsigned char)201,      (unsigned char)201,      (unsigned char)200, 
        (unsigned char)200,      (unsigned char)200,      (unsigned char)200,      (unsigned char)200, 
        (unsigned char)200,      (unsigned char)200,      (unsigned char)200,      (unsigned char)200, 
        (unsigned char)200,      (unsigned char)200,      (unsigned char)200,      (unsigned char)200, 
        (unsigned char)200,      (unsigned char)200,      (unsigned char)200,      (unsigned char)199, 
        (unsigned char)199,      (unsigned char)199,      (unsigned char)199,      (unsigned char)199, 
        (unsigned char)199,      (unsigned char)199,      (unsigned char)199,      (unsigned char)199, 
        (unsigned char)199,      (unsigned char)199,      (unsigned char)199,      (unsigned char)199, 
        (unsigned char)199,      (unsigned char)199,      (unsigned char)199,      (unsigned char)198, 
        (unsigned char)198,      (unsigned char)198,      (unsigned char)198,      (unsigned char)198, 
        (unsigned char)198,      (unsigned char)198,      (unsigned char)198,      (unsigned char)198, 
        (unsigned char)198,      (unsigned char)198,      (unsigned char)198,      (unsigned char)198, 
        (unsigned char)198,      (unsigned char)198,      (unsigned char)198,      (unsigned char)197, 
        (unsigned char)197,      (unsigned char)197,      (unsigned char)197,      (unsigned char)197, 
        (unsigned char)197,      (unsigned char)197,      (unsigned char)197,      (unsigned char)197, 
        (unsigned char)197,      (unsigned char)197,      (unsigned char)197,      (unsigned char)197, 
        (unsigned char)197,      (unsigned char)197,      (unsigned char)197,      (unsigned char)196, 
        (unsigned char)196,      (unsigned char)196,      (unsigned char)196,      (unsigned char)196, 
        (unsigned char)196,      (unsigned char)196,      (unsigned char)196,      (unsigned char)196, 
        (unsigned char)196,      (unsigned char)196,      (unsigned char)196,      (unsigned char)196, 
        (unsigned char)196,      (unsigned char)196,      (unsigned char)196,      (unsigned char)195, 
        (unsigned char)195,      (unsigned char)195,      (unsigned char)195,      (unsigned char)195, 
        (unsigned char)195,      (unsigned char)195,      (unsigned char)195,      (unsigned char)195, 
        (unsigned char)195,      (unsigned char)195,      (unsigned char)195,      (unsigned char)195, 
        (unsigned char)195,      (unsigned char)195,      (unsigned char)195,      (unsigned char)194, 
        (unsigned char)194,      (unsigned char)194,      (unsigned char)194,      (unsigned char)194, 
        (unsigned char)194,      (unsigned char)194,      (unsigned char)194,      (unsigned char)194, 
        (unsigned char)194,      (unsigned char)194,      (unsigned char)194,      (unsigned char)194, 
        (unsigned char)194,      (unsigned char)194,      (unsigned char)194,      (unsigned char)193, 
        (unsigned char)193,      (unsigned char)193,      (unsigned char)193,      (unsigned char)193, 
        (unsigned char)193,      (unsigned char)193,      (unsigned char)193,      (unsigned char)193, 
        (unsigned char)193,      (unsigned char)193,      (unsigned char)193,      (unsigned char)193, 
        (unsigned char)193,      (unsigned char)193,      (unsigned char)193,      (unsigned char)192, 
        (unsigned char)192,      (unsigned char)192,      (unsigned char)192,      (unsigned char)192, 
        (unsigned char)192,      (unsigned char)192,      (unsigned char)192,      (unsigned char)192, 
        (unsigned char)192,      (unsigned char)192,      (unsigned char)192,      (unsigned char)192, 
        (unsigned char)192,      (unsigned char)192,      (unsigned char)192,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128};
#line 794 "/root/patchweave_donee/23/src/ulaw.c"
__inline static void ulaw2s_array(unsigned char *buffer , int count , short *ptr ) 
{ 


  {
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    count --;
#line 795
    if (! (count >= 0)) {
#line 795
      goto while_break;
    }
#line 796
    *(ptr + count) = ulaw_decode[(int )*(buffer + count)];
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 800
  return;
}
}
#line 800 "/root/patchweave_donee/23/src/ulaw.c"
__inline static void ulaw2i_array(unsigned char *buffer , int count , int *ptr ) 
{ 


  {
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 801
    count --;
#line 801
    if (! (count >= 0)) {
#line 801
      goto while_break;
    }
#line 802
    *(ptr + count) = (int )((uint32_t )ulaw_decode[*(buffer + count)] << 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 806
  return;
}
}
#line 806 "/root/patchweave_donee/23/src/ulaw.c"
__inline static void ulaw2f_array(unsigned char *buffer , int count , float *ptr ,
                                  float normfact ) 
{ 


  {
  {
#line 807
  while (1) {
    while_continue: /* CIL Label */ ;
#line 807
    count --;
#line 807
    if (! (count >= 0)) {
#line 807
      goto while_break;
    }
#line 808
    *(ptr + count) = normfact * (float )((int )ulaw_decode[(int )*(buffer + count)]);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 812
  return;
}
}
#line 812 "/root/patchweave_donee/23/src/ulaw.c"
__inline static void ulaw2d_array(unsigned char const   *buffer , int count , double *ptr ,
                                  double normfact ) 
{ 


  {
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    count --;
#line 813
    if (! (count >= 0)) {
#line 813
      goto while_break;
    }
#line 814
    *(ptr + count) = normfact * (double )((int )ulaw_decode[(int )*(buffer + count)]);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 818
  return;
}
}
#line 818 "/root/patchweave_donee/23/src/ulaw.c"
__inline static void s2ulaw_array(short const   *ptr , int count , unsigned char *buffer ) 
{ 


  {
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    count --;
#line 819
    if (! (count >= 0)) {
#line 819
      goto while_break;
    }
#line 820
    if ((int )*(ptr + count) >= 0) {
#line 821
      *(buffer + count) = ulaw_encode[(int )*(ptr + count) / 4];
    } else {
#line 823
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[(int )*(ptr + count) / -4]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 829
  return;
}
}
#line 828 "/root/patchweave_donee/23/src/ulaw.c"
__inline static void i2ulaw_array(int const   *ptr , int count , unsigned char *buffer ) 
{ 


  {
  {
#line 829
  while (1) {
    while_continue: /* CIL Label */ ;
#line 829
    count --;
#line 829
    if (! (count >= 0)) {
#line 829
      goto while_break;
    }
#line 830
    if (*(ptr + count) >= 0) {
#line 831
      *(buffer + count) = ulaw_encode[*(ptr + count) >> 18];
    } else {
#line 833
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[- *(ptr + count) >> 18]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 839
  return;
}
}
#line 838 "/root/patchweave_donee/23/src/ulaw.c"
__inline static void f2ulaw_array(float const   *ptr , int count , unsigned char *buffer ,
                                  float normfact ) 
{ 
  long __cil_tmp6 ;
  long tmp ;

  {
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 839
    count --;
#line 839
    if (! (count >= 0)) {
#line 839
      goto while_break;
    }
#line 840
    if (*(ptr + count) >= (float const   )((float )0)) {
      {
#line 841
      tmp = lrintf(normfact * (float )*(ptr + count));
#line 841
      *(buffer + count) = (unsigned char )tmp;
      }
    } else {
      {
#line 843
      __cil_tmp6 = lrintf(normfact * (float )*(ptr + count));
#line 843
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 850
  return;
}
}
#line 848 "/root/patchweave_donee/23/src/ulaw.c"
__inline static void d2ulaw_array(double const   *ptr , int count , unsigned char *buffer ,
                                  double normfact ) 
{ 
  long __cil_tmp6 ;
  long tmp ;

  {
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    count --;
#line 849
    if (! (count >= 0)) {
#line 849
      goto while_break;
    }
#line 850
    if (*(ptr + count) >= (double const   )((double )0)) {
      {
#line 851
      tmp = lrint(normfact * (double )*(ptr + count));
#line 851
      *(buffer + count) = (unsigned char )tmp;
      }
    } else {
      {
#line 853
      __cil_tmp6 = lrint(normfact * (double )*(ptr + count));
#line 853
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 860
  return;
}
}
#line 861 "/root/patchweave_donee/23/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 864
  total = (sf_count_t )0;
#line 866
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 868
  while (1) {
    while_continue: /* CIL Label */ ;

#line 868
    if (! (len > 0L)) {
#line 868
      goto while_break;
    }
#line 869
    if (len < (long )bufferlen) {
#line 870
      bufferlen = (int )len;
    }
    {
#line 871
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 871
    readcount = (int )__cil_tmp8;
#line 872
    ulaw2s_array(ubuf.ucbuf, readcount, ptr + total);
#line 873
    total += (long )readcount;
    }
#line 874
    if (readcount < bufferlen) {
#line 875
      goto while_break;
    }
#line 876
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 879
  return (total);
}
}
#line 883 "/root/patchweave_donee/23/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 886
  total = (sf_count_t )0;
#line 888
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 890
  while (1) {
    while_continue: /* CIL Label */ ;

#line 890
    if (! (len > 0L)) {
#line 890
      goto while_break;
    }
#line 891
    if (len < (long )bufferlen) {
#line 892
      bufferlen = (int )len;
    }
    {
#line 893
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 893
    readcount = (int )__cil_tmp8;
#line 894
    ulaw2i_array(ubuf.ucbuf, readcount, ptr + total);
#line 895
    total += (long )readcount;
    }
#line 896
    if (readcount < bufferlen) {
#line 897
      goto while_break;
    }
#line 898
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 901
  return (total);
}
}
#line 905 "/root/patchweave_donee/23/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 908
  total = (sf_count_t )0;
#line 911
  if (psf->norm_float == 1) {
#line 911
    tmp = 1. / (double )((float )32768);
  } else {
#line 911
    tmp = 1.;
  }
#line 911
  normfact = (float )tmp;
#line 913
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;

#line 915
    if (! (len > 0L)) {
#line 915
      goto while_break;
    }
#line 916
    if (len < (long )bufferlen) {
#line 917
      bufferlen = (int )len;
    }
    {
#line 918
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 918
    readcount = (int )__cil_tmp10;
#line 919
    ulaw2f_array(ubuf.ucbuf, readcount, ptr + total, normfact);
#line 920
    total += (long )readcount;
    }
#line 921
    if (readcount < bufferlen) {
#line 922
      goto while_break;
    }
#line 923
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 926
  return (total);
}
}
#line 930 "/root/patchweave_donee/23/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 933
  total = (sf_count_t )0;
#line 936
  if (psf->norm_double) {
#line 936
    tmp = 1. / (double )32768;
  } else {
#line 936
    tmp = 1.;
  }
#line 936
  normfact = tmp;
#line 937
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;

#line 939
    if (! (len > 0L)) {
#line 939
      goto while_break;
    }
#line 940
    if (len < (long )bufferlen) {
#line 941
      bufferlen = (int )len;
    }
    {
#line 942
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 942
    readcount = (int )__cil_tmp10;
#line 943
    ulaw2d_array((unsigned char const   *)(ubuf.ucbuf), readcount, ptr + total, normfact);
#line 944
    total += (long )readcount;
    }
#line 945
    if (readcount < bufferlen) {
#line 946
      goto while_break;
    }
#line 947
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 950
  return (total);
}
}
#line 957 "/root/patchweave_donee/23/src/ulaw.c"
static sf_count_t ulaw_write_s2ulaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 960
  total = (sf_count_t )0;
#line 962
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 964
  while (1) {
    while_continue: /* CIL Label */ ;

#line 964
    if (! (len > 0L)) {
#line 964
      goto while_break;
    }
#line 965
    if (len < (long )bufferlen) {
#line 966
      bufferlen = (int )len;
    }
    {
#line 967
    s2ulaw_array(ptr + total, bufferlen, ubuf.ucbuf);
#line 968
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 968
    writecount = (int )__cil_tmp8;
#line 969
    total += (long )writecount;
    }
#line 970
    if (writecount < bufferlen) {
#line 971
      goto while_break;
    }
#line 972
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 975
  return (total);
}
}
#line 979 "/root/patchweave_donee/23/src/ulaw.c"
static sf_count_t ulaw_write_i2ulaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 982
  total = (sf_count_t )0;
#line 984
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 986
  while (1) {
    while_continue: /* CIL Label */ ;

#line 986
    if (! (len > 0L)) {
#line 986
      goto while_break;
    }
#line 987
    if (len < (long )bufferlen) {
#line 988
      bufferlen = (int )len;
    }
    {
#line 989
    i2ulaw_array(ptr + total, bufferlen, ubuf.ucbuf);
#line 990
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 990
    writecount = (int )__cil_tmp8;
#line 991
    total += (long )writecount;
    }
#line 992
    if (writecount < bufferlen) {
#line 993
      goto while_break;
    }
#line 994
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 997
  return (total);
}
}
#line 1001 "/root/patchweave_donee/23/src/ulaw.c"
static sf_count_t ulaw_write_f2ulaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1004
  total = (sf_count_t )0;
#line 1008
  if (psf->norm_float == 1) {
#line 1008
    tmp = 0.25 * (double )32767;
  } else {
#line 1008
    tmp = 0.25;
  }
#line 1008
  normfact = (float )tmp;
#line 1010
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1012
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1012
    if (! (len > 0L)) {
#line 1012
      goto while_break;
    }
#line 1013
    if (len < (long )bufferlen) {
#line 1014
      bufferlen = (int )len;
    }
    {
#line 1015
    f2ulaw_array(ptr + total, bufferlen, ubuf.ucbuf, normfact);
#line 1016
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                             psf);
#line 1016
    writecount = (int )__cil_tmp10;
#line 1017
    total += (long )writecount;
    }
#line 1018
    if (writecount < bufferlen) {
#line 1019
      goto while_break;
    }
#line 1020
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1023
  return (total);
}
}
#line 1027 "/root/patchweave_donee/23/src/ulaw.c"
static sf_count_t ulaw_write_d2ulaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1030
  total = (sf_count_t )0;
#line 1034
  if (psf->norm_double) {
#line 1034
    tmp = 0.25 * (double )32767;
  } else {
#line 1034
    tmp = 0.25;
  }
#line 1034
  normfact = tmp;
#line 1036
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1038
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1038
    if (! (len > 0L)) {
#line 1038
      goto while_break;
    }
#line 1039
    if (len < (long )bufferlen) {
#line 1040
      bufferlen = (int )len;
    }
    {
#line 1041
    d2ulaw_array(ptr + total, bufferlen, ubuf.ucbuf, normfact);
#line 1042
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                             psf);
#line 1042
    writecount = (int )__cil_tmp10;
#line 1043
    total += (long )writecount;
    }
#line 1044
    if (writecount < bufferlen) {
#line 1045
      goto while_break;
    }
#line 1046
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1049
  return (total);
}
}
#line 34 "/root/patchweave_donee/23/src/strings.c"
int psf_store_string(SF_PRIVATE *psf , int str_type , char const   *str ) 
{ 
  char new_str[128] ;
  size_t str_len ;
  int k ;
  int str_flags ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  char *temp ;
  size_t newlen ;
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 39
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 40
    return (59);
  }
  {
#line 42
  str_len = strlen(str);
  }
#line 45
  if (psf->file.mode == 32) {
    _L: 
#line 46
    if ((psf->strings.flags & 256U) == 0U) {
#line 47
      return (53);
    }
#line 48
    if (psf->have_written) {
#line 48
      if ((psf->strings.flags & 512U) == 0U) {
#line 49
        return (53);
      }
    }
#line 51
    if (str_type != 3) {
#line 51
      if (str_len == 0UL) {
#line 52
        return (59);
      }
    }
  } else
#line 45
  if (psf->file.mode == 48) {
#line 45
    goto _L;
  }
#line 56
  k = 0;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;

#line 56
    if (! (k < 32)) {
#line 56
      goto while_break;
    }
#line 58
    if (psf->strings.data[k].type == str_type) {
#line 59
      psf->strings.data[k].type = -1;
    }
#line 61
    if (psf->strings.data[k].type == 0) {
#line 62
      goto while_break;
    }
#line 56
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 66
  str_flags = 1024;
#line 67
  if (psf->file.mode == 48) {
    _L___0: 
#line 68
    if ((psf->strings.flags & 512U) == 0U) {
#line 69
      return (58);
    }
#line 70
    str_flags = 2048;
  } else
#line 67
  if (psf->have_written) {
#line 67
    goto _L___0;
  }
#line 74
  if (k >= 32) {
#line 75
    return (56);
  }
#line 77
  if (k == 0) {
#line 77
    if (psf->strings.storage_used != 0UL) {
      {
#line 78
      psf_log_printf(psf, "SFE_STR_WEIRD : k == 0 && psf->strings.storage_used != 0\n");
      }
#line 79
      return (60);
    }
  }
#line 82
  if (k != 0) {
#line 82
    if (psf->strings.storage_used == 0UL) {
      {
#line 83
      psf_log_printf(psf, "SFE_STR_WEIRD : k != 0 && psf->strings.storage_used == 0\nV^`\375\177");
      }
#line 84
      return (60);
    }
  }
#line 88
  if (k == 0) {
#line 89
    psf->strings.storage_used = (size_t )0;
  }
#line 92
  if (str_type == 3) {
#line 92
    goto case_3;
  }
#line 120
  if (str_type == 16) {
#line 120
    goto case_16;
  }
#line 120
  if (str_type == 9) {
#line 120
    goto case_16;
  }
#line 120
  if (str_type == 8) {
#line 120
    goto case_16;
  }
#line 120
  if (str_type == 7) {
#line 120
    goto case_16;
  }
#line 120
  if (str_type == 6) {
#line 120
    goto case_16;
  }
#line 120
  if (str_type == 5) {
#line 120
    goto case_16;
  }
#line 120
  if (str_type == 4) {
#line 120
    goto case_16;
  }
#line 120
  if (str_type == 2) {
#line 120
    goto case_16;
  }
#line 120
  if (str_type == 1) {
#line 120
    goto case_16;
  }
#line 123
  goto switch_default;
  case_3: 
#line 94
  if (psf->file.mode == 32) {
    _L___1: 
    {
#line 95
    __cil_tmp10 = strstr(str, "libsndfile");
    }
#line 95
    if ((unsigned long )__cil_tmp10 == (unsigned long )((void *)0)) {
      {
#line 100
      __cil_tmp11 = strlen(str);
      }
#line 100
      if (__cil_tmp11 == 0UL) {
        {
#line 101
        snprintf(new_str, sizeof(new_str), "%s-%s", "libsndfile", "1.0.26");
        }
      } else {
        {
#line 103
        snprintf(new_str, sizeof(new_str), "%s (%s-%s)\277\321\204U", str, "libsndfile",
                 "1.0.26");
        }
      }
    } else {
      {
#line 106
      snprintf(new_str, sizeof(new_str), "%s\235\321\204U", str);
      }
    }
#line 108
    str = (char const   *)(new_str);
  } else
#line 94
  if (psf->file.mode == 48) {
#line 94
    goto _L___1;
  }
#line 110
  goto switch_break;
  case_16: 
#line 121
  goto switch_break;
  switch_default: 
  {
#line 124
  psf_log_printf(psf, "%s : SFE_STR_BAD_TYPE\n", "psf_store_string\312\001@");
  }
#line 125
  return (57);
  switch_break: 
  {
#line 129
  __cil_tmp12 = strlen(str);
#line 129
  str_len = __cil_tmp12 + 1UL;
  }
#line 131
  if ((psf->strings.storage_used + str_len) + 1UL > psf->strings.storage_len) {
#line 132
    temp = psf->strings.storage;
#line 133
    newlen = (2UL * psf->strings.storage_len + str_len) + 1UL;
#line 135
    if (newlen < 256UL) {
#line 135
      tmp = 256UL;
    } else {
#line 135
      tmp = newlen;
    }
    {
#line 135
    newlen = tmp;
#line 137
    tmp___0 = realloc((void *)temp, newlen);
#line 137
    psf->strings.storage = (char *)tmp___0;
    }
#line 137
    if ((unsigned long )psf->strings.storage == (unsigned long )((void *)0)) {
#line 138
      psf->strings.storage = temp;
#line 139
      return (17);
    }
#line 142
    psf->strings.storage_len = newlen;
  }
  {
#line 145
  psf->strings.data[k].type = str_type;
#line 146
  psf->strings.data[k].offset = psf->strings.storage_used;
#line 147
  psf->strings.data[k].flags = str_flags;
#line 149
  memcpy((void *)(psf->strings.storage + psf->strings.storage_used), (void const   *)str,
         str_len);
#line 150
  psf->strings.storage_used += str_len;
#line 152
  psf->strings.flags |= (unsigned int )str_flags;
  }
#line 163
  return (0);
}
}
#line 167 "/root/patchweave_donee/23/src/strings.c"
int psf_set_string(SF_PRIVATE *psf , int str_type , char const   *str ) 
{ 
  int __cil_tmp4 ;

  {
#line 168
  if (psf->file.mode == 16) {
#line 169
    return (54);
  }
  {
#line 171
  __cil_tmp4 = psf_store_string(psf, str_type, str);
  }
#line 171
  return (__cil_tmp4);
}
}
#line 175 "/root/patchweave_donee/23/src/strings.c"
char const   *psf_get_string(SF_PRIVATE *psf , int str_type ) 
{ 
  int k ;

  {
#line 178
  k = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;

#line 178
    if (! (k < 32)) {
#line 178
      goto while_break;
    }
#line 179
    if (str_type == psf->strings.data[k].type) {
#line 180
      return ((char const   *)(psf->strings.storage + psf->strings.data[k].offset));
    }
#line 178
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 182
  return ((char const   *)((void *)0));
}
}
#line 186 "/root/patchweave_donee/23/src/strings.c"
int psf_location_string_count(SF_PRIVATE *psf , int location ) 
{ 
  int k ;
  int count ;

  {
#line 187
  count = 0;
#line 189
  k = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;

#line 189
    if (! (k < 32)) {
#line 189
      goto while_break;
    }
#line 190
    if (psf->strings.data[k].type > 0) {
#line 190
      if (psf->strings.data[k].flags & location) {
#line 191
        count ++;
      }
    }
#line 189
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 193
  return (count);
}
}
#line 35 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_sc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 36
static sf_count_t pcm_read_uc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 37
static sf_count_t pcm_read_bes2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 38
static sf_count_t pcm_read_les2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 39
static sf_count_t pcm_read_bet2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 40
static sf_count_t pcm_read_let2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 41
static sf_count_t pcm_read_bei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 42
static sf_count_t pcm_read_lei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 44
static sf_count_t pcm_read_sc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 45
static sf_count_t pcm_read_uc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 46
static sf_count_t pcm_read_bes2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 47
static sf_count_t pcm_read_les2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 48
static sf_count_t pcm_read_bet2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 49
static sf_count_t pcm_read_let2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 50
static sf_count_t pcm_read_bei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 51
static sf_count_t pcm_read_lei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 53
static sf_count_t pcm_read_sc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 54
static sf_count_t pcm_read_uc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 55
static sf_count_t pcm_read_bes2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 56
static sf_count_t pcm_read_les2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 57
static sf_count_t pcm_read_bet2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 58
static sf_count_t pcm_read_let2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 59
static sf_count_t pcm_read_bei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 60
static sf_count_t pcm_read_lei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 62
static sf_count_t pcm_read_sc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 63
static sf_count_t pcm_read_uc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 64
static sf_count_t pcm_read_bes2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 65
static sf_count_t pcm_read_les2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 66
static sf_count_t pcm_read_bet2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 67
static sf_count_t pcm_read_let2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 68
static sf_count_t pcm_read_bei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 69
static sf_count_t pcm_read_lei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 71
static sf_count_t pcm_write_s2sc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 72
static sf_count_t pcm_write_s2uc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 73
static sf_count_t pcm_write_s2bes(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 74
static sf_count_t pcm_write_s2les(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 75
static sf_count_t pcm_write_s2bet(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 76
static sf_count_t pcm_write_s2let(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 77
static sf_count_t pcm_write_s2bei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 78
static sf_count_t pcm_write_s2lei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 80
static sf_count_t pcm_write_i2sc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 81
static sf_count_t pcm_write_i2uc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 82
static sf_count_t pcm_write_i2bes(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 83
static sf_count_t pcm_write_i2les(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 84
static sf_count_t pcm_write_i2bet(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 85
static sf_count_t pcm_write_i2let(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 86
static sf_count_t pcm_write_i2bei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 87
static sf_count_t pcm_write_i2lei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 89
static sf_count_t pcm_write_f2sc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 90
static sf_count_t pcm_write_f2uc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 91
static sf_count_t pcm_write_f2bes(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 92
static sf_count_t pcm_write_f2les(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 93
static sf_count_t pcm_write_f2bet(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 94
static sf_count_t pcm_write_f2let(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 95
static sf_count_t pcm_write_f2bei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 96
static sf_count_t pcm_write_f2lei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 98
static sf_count_t pcm_write_d2sc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 99
static sf_count_t pcm_write_d2uc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 100
static sf_count_t pcm_write_d2bes(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 101
static sf_count_t pcm_write_d2les(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 102
static sf_count_t pcm_write_d2bet(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 103
static sf_count_t pcm_write_d2let(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 104
static sf_count_t pcm_write_d2bei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 105
static sf_count_t pcm_write_d2lei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 120 "/root/patchweave_donee/23/src/pcm.c"
int pcm_init(SF_PRIVATE *psf ) 
{ 
  int chars ;
  int tmp___0 ;
  sf_count_t tmp___1 ;
  sf_count_t tmp___2 ;

  {
#line 121
  chars = 0;
#line 123
  if (psf->bytewidth == 0) {
    {
#line 124
    psf_log_printf(psf, "pcm_init : internal error : bytewitdh = %d, channels = %d\n",
                   psf->bytewidth, psf->sf.channels);
    }
#line 125
    return (30);
  } else
#line 123
  if (psf->sf.channels == 0) {
    {
#line 124
    psf_log_printf(psf, "pcm_init : internal error : bytewitdh = %d, channels = %d\n",
                   psf->bytewidth, psf->sf.channels);
    }
#line 125
    return (30);
  }
#line 128
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 130
  if ((psf->sf.format & 65535) == 1) {
#line 131
    chars = 200;
  } else
#line 132
  if ((psf->sf.format & 65535) == 5) {
#line 133
    chars = 201;
  }
#line 138
  if (psf->endian == 268435456) {
#line 138
    tmp___0 = 0;
  } else {
#line 138
    tmp___0 = 1;
  }
#line 138
  psf->data_endswap = tmp___0;
#line 140
  if (psf->file.mode == 16) {
    _L: 
#line 143
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501192) {
#line 143
      goto case_268501192;
    }
#line 143
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936648) {
#line 143
      goto case_268501192;
    }
#line 150
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501193) {
#line 150
      goto case_268501193;
    }
#line 150
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936649) {
#line 150
      goto case_268501193;
    }
#line 157
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537001984) {
#line 157
      goto case_537001984;
    }
#line 163
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537067520) {
#line 163
      goto case_537067520;
    }
#line 169
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537133056) {
#line 169
      goto case_537133056;
    }
#line 177
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268566528) {
#line 177
      goto case_268566528;
    }
#line 183
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268632064) {
#line 183
      goto case_268632064;
    }
#line 189
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268697600) {
#line 189
      goto case_268697600;
    }
#line 195
    goto switch_default;
    case_268501192: 
#line 144
    psf->read_short = & pcm_read_sc2s;
#line 145
    psf->read_int = & pcm_read_sc2i;
#line 146
    psf->read_float = & pcm_read_sc2f;
#line 147
    psf->read_double = & pcm_read_sc2d;
#line 148
    goto switch_break;
    case_268501193: 
#line 151
    psf->read_short = & pcm_read_uc2s;
#line 152
    psf->read_int = & pcm_read_uc2i;
#line 153
    psf->read_float = & pcm_read_uc2f;
#line 154
    psf->read_double = & pcm_read_uc2d;
#line 155
    goto switch_break;
    case_537001984: 
#line 158
    psf->read_short = & pcm_read_bes2s;
#line 159
    psf->read_int = & pcm_read_bes2i;
#line 160
    psf->read_float = & pcm_read_bes2f;
#line 161
    psf->read_double = & pcm_read_bes2d;
#line 162
    goto switch_break;
    case_537067520: 
#line 164
    psf->read_short = & pcm_read_bet2s;
#line 165
    psf->read_int = & pcm_read_bet2i;
#line 166
    psf->read_float = & pcm_read_bet2f;
#line 167
    psf->read_double = & pcm_read_bet2d;
#line 168
    goto switch_break;
    case_537133056: 
#line 171
    psf->read_short = & pcm_read_bei2s;
#line 172
    psf->read_int = & pcm_read_bei2i;
#line 173
    psf->read_float = & pcm_read_bei2f;
#line 174
    psf->read_double = & pcm_read_bei2d;
#line 175
    goto switch_break;
    case_268566528: 
#line 178
    psf->read_short = & pcm_read_les2s;
#line 179
    psf->read_int = & pcm_read_les2i;
#line 180
    psf->read_float = & pcm_read_les2f;
#line 181
    psf->read_double = & pcm_read_les2d;
#line 182
    goto switch_break;
    case_268632064: 
#line 184
    psf->read_short = & pcm_read_let2s;
#line 185
    psf->read_int = & pcm_read_let2i;
#line 186
    psf->read_float = & pcm_read_let2f;
#line 187
    psf->read_double = & pcm_read_let2d;
#line 188
    goto switch_break;
    case_268697600: 
#line 190
    psf->read_short = & pcm_read_lei2s;
#line 191
    psf->read_int = & pcm_read_lei2i;
#line 192
    psf->read_float = & pcm_read_lei2f;
#line 193
    psf->read_double = & pcm_read_lei2d;
#line 194
    goto switch_break;
    switch_default: 
    {
#line 196
    psf_log_printf(psf, "pcm.c returning SFE_UNIMPLEMENTED\nbytewidth %d    endian %d\n",
                   psf->bytewidth, psf->endian);
    }
#line 197
    return (18);
    switch_break: ;
  } else
#line 140
  if (psf->file.mode == 48) {
#line 140
    goto _L;
  }
#line 201
  if (psf->file.mode == 32) {
    _L___2: 
#line 204
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501192) {
#line 204
      goto case_268501192___0;
    }
#line 204
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936648) {
#line 204
      goto case_268501192___0;
    }
#line 211
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501193) {
#line 211
      goto case_268501193___0;
    }
#line 211
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936649) {
#line 211
      goto case_268501193___0;
    }
#line 218
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537001984) {
#line 218
      goto case_537001984___0;
    }
#line 225
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537067520) {
#line 225
      goto case_537067520___0;
    }
#line 232
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537133056) {
#line 232
      goto case_537133056___0;
    }
#line 239
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268566528) {
#line 239
      goto case_268566528___0;
    }
#line 246
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268632064) {
#line 246
      goto case_268632064___0;
    }
#line 253
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268697600) {
#line 253
      goto case_268697600___0;
    }
#line 260
    goto switch_default___0;
    case_268501192___0: 
#line 205
    psf->write_short = & pcm_write_s2sc;
#line 206
    psf->write_int = & pcm_write_i2sc;
#line 207
    psf->write_float = & pcm_write_f2sc;
#line 208
    psf->write_double = & pcm_write_d2sc;
#line 209
    goto switch_break___0;
    case_268501193___0: 
#line 212
    psf->write_short = & pcm_write_s2uc;
#line 213
    psf->write_int = & pcm_write_i2uc;
#line 214
    psf->write_float = & pcm_write_f2uc;
#line 215
    psf->write_double = & pcm_write_d2uc;
#line 216
    goto switch_break___0;
    case_537001984___0: 
#line 219
    psf->write_short = & pcm_write_s2bes;
#line 220
    psf->write_int = & pcm_write_i2bes;
#line 221
    psf->write_float = & pcm_write_f2bes;
#line 222
    psf->write_double = & pcm_write_d2bes;
#line 223
    goto switch_break___0;
    case_537067520___0: 
#line 226
    psf->write_short = & pcm_write_s2bet;
#line 227
    psf->write_int = & pcm_write_i2bet;
#line 228
    psf->write_float = & pcm_write_f2bet;
#line 229
    psf->write_double = & pcm_write_d2bet;
#line 230
    goto switch_break___0;
    case_537133056___0: 
#line 233
    psf->write_short = & pcm_write_s2bei;
#line 234
    psf->write_int = & pcm_write_i2bei;
#line 235
    psf->write_float = & pcm_write_f2bei;
#line 236
    psf->write_double = & pcm_write_d2bei;
#line 237
    goto switch_break___0;
    case_268566528___0: 
#line 240
    psf->write_short = & pcm_write_s2les;
#line 241
    psf->write_int = & pcm_write_i2les;
#line 242
    psf->write_float = & pcm_write_f2les;
#line 243
    psf->write_double = & pcm_write_d2les;
#line 244
    goto switch_break___0;
    case_268632064___0: 
#line 247
    psf->write_short = & pcm_write_s2let;
#line 248
    psf->write_int = & pcm_write_i2let;
#line 249
    psf->write_float = & pcm_write_f2let;
#line 250
    psf->write_double = & pcm_write_d2let;
#line 251
    goto switch_break___0;
    case_268697600___0: 
#line 254
    psf->write_short = & pcm_write_s2lei;
#line 255
    psf->write_int = & pcm_write_i2lei;
#line 256
    psf->write_float = & pcm_write_f2lei;
#line 257
    psf->write_double = & pcm_write_d2lei;
#line 258
    goto switch_break___0;
    switch_default___0: 
    {
#line 261
    psf_log_printf(psf, "pcm.c returning SFE_UNIMPLEMENTED\nbytewidth %s    endian %d\n",
                   psf->bytewidth, psf->endian);
    }
#line 262
    return (18);
    switch_break___0: ;
  } else
#line 201
  if (psf->file.mode == 48) {
#line 201
    goto _L___2;
  }
#line 267
  if (psf->filelength > psf->dataoffset) {
#line 268
    if (psf->dataend > 0L) {
#line 268
      tmp___1 = psf->dataend - psf->dataoffset;
    } else {
#line 268
      tmp___1 = psf->filelength - psf->dataoffset;
    }
#line 268
    psf->datalength = tmp___1;
  } else {
#line 272
    psf->datalength = (sf_count_t )0;
  }
#line 274
  if (psf->blockwidth > 0) {
#line 274
    tmp___2 = psf->datalength / (long )psf->blockwidth;
  } else {
#line 274
    tmp___2 = 0L;
  }
#line 274
  psf->sf.frames = tmp___2;
#line 276
  return (0);
}
}
#line 283 "/root/patchweave_donee/23/src/pcm.c"
__inline static void sc2s_array(signed char *src , int count , short *dest ) 
{ 


  {
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    count --;
#line 284
    if (! (count >= 0)) {
#line 284
      goto while_break;
    }
#line 285
    *(dest + count) = (short )((int )((uint16_t )*(src + count)) << 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 290
  return;
}
}
#line 290 "/root/patchweave_donee/23/src/pcm.c"
__inline static void uc2s_array(unsigned char *src , int count , short *dest ) 
{ 


  {
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    count --;
#line 291
    if (! (count >= 0)) {
#line 291
      goto while_break;
    }
#line 292
    *(dest + count) = (short )(((uint32_t )*(src + count) - 128U) << 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 297
  return;
}
}
#line 297 "/root/patchweave_donee/23/src/pcm.c"
__inline static void let2s_array(tribyte *src , int count , short *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 300
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    count --;
#line 301
    if (! (count >= 0)) {
#line 301
      goto while_break;
    }
#line 302
    ucptr -= 3;
#line 303
    *(dest + count) = (short )((int )*(ucptr + 1) + ((int )*(ucptr + 2) << 8));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 308
  return;
}
}
#line 308 "/root/patchweave_donee/23/src/pcm.c"
__inline static void bet2s_array(tribyte *src , int count , short *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 311
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    count --;
#line 312
    if (! (count >= 0)) {
#line 312
      goto while_break;
    }
#line 313
    ucptr -= 3;
#line 314
    *(dest + count) = (short )(((int )*(ucptr + 0) << 8) + (int )*(ucptr + 1));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 319
  return;
}
}
#line 319 "/root/patchweave_donee/23/src/pcm.c"
__inline static void lei2s_array(int *src , int count , short *dest ) 
{ 
  int value ;

  {
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    count --;
#line 322
    if (! (count >= 0)) {
#line 322
      goto while_break;
    }
#line 323
    value = *(src + count);
#line 324
    *(dest + count) = (short )(value >> 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 329
  return;
}
}
#line 329 "/root/patchweave_donee/23/src/pcm.c"
__inline static void bei2s_array(int *src , int count , short *dest ) 
{ 
  int value ;

  {
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    count --;
#line 332
    if (! (count >= 0)) {
#line 332
      goto while_break;
    }
    {
#line 333
    value = ENDSWAP_32(*(src + count));
#line 334
    *(dest + count) = (short )(value >> 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 340
  return;
}
}
#line 342 "/root/patchweave_donee/23/src/pcm.c"
__inline static void sc2i_array(signed char *src , int count , int *dest ) 
{ 


  {
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    count --;
#line 343
    if (! (count >= 0)) {
#line 343
      goto while_break;
    }
    {
#line 344
    *(dest + count) = arith_shift_left((int )*(src + count), 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 350
  return;
}
}
#line 349 "/root/patchweave_donee/23/src/pcm.c"
__inline static void uc2i_array(unsigned char *src , int count , int *dest ) 
{ 


  {
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    count --;
#line 350
    if (! (count >= 0)) {
#line 350
      goto while_break;
    }
    {
#line 351
    *(dest + count) = arith_shift_left((int )*(src + count) - 128, 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 357
  return;
}
}
#line 356 "/root/patchweave_donee/23/src/pcm.c"
__inline static void bes2i_array(short *src , int count , int *dest ) 
{ 
  short value ;

  {
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    count --;
#line 359
    if (! (count >= 0)) {
#line 359
      goto while_break;
    }
    {
#line 360
    value = ENDSWAP_16(*(src + count));
#line 361
    *(dest + count) = arith_shift_left((int32_t )value, 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 367
  return;
}
}
#line 366 "/root/patchweave_donee/23/src/pcm.c"
__inline static void les2i_array(short *src , int count , int *dest ) 
{ 
  short value ;

  {
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    count --;
#line 369
    if (! (count >= 0)) {
#line 369
      goto while_break;
    }
    {
#line 370
    value = *(src + count);
#line 371
    *(dest + count) = arith_shift_left((int32_t )value, 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 377
  return;
}
}
#line 376 "/root/patchweave_donee/23/src/pcm.c"
__inline static void bet2i_array(tribyte *src , int count , int *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 379
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    count --;
#line 380
    if (! (count >= 0)) {
#line 380
      goto while_break;
    }
    {
#line 381
    ucptr -= 3;
#line 382
    *(dest + count) = psf_get_be24(ucptr, 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 388
  return;
}
}
#line 387 "/root/patchweave_donee/23/src/pcm.c"
__inline static void let2i_array(tribyte *src , int count , int *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 390
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    count --;
#line 391
    if (! (count >= 0)) {
#line 391
      goto while_break;
    }
    {
#line 392
    ucptr -= 3;
#line 393
    *(dest + count) = psf_get_le24(ucptr, 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 399
  return;
}
}
#line 401 "/root/patchweave_donee/23/src/pcm.c"
__inline static void sc2f_array(signed char *src , int count , float *dest , float normfact ) 
{ 


  {
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    count --;
#line 402
    if (! (count >= 0)) {
#line 402
      goto while_break;
    }
#line 403
    *(dest + count) = (float )*(src + count) * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 407
  return;
}
}
#line 407 "/root/patchweave_donee/23/src/pcm.c"
__inline static void uc2f_array(unsigned char *src , int count , float *dest , float normfact ) 
{ 


  {
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    count --;
#line 408
    if (! (count >= 0)) {
#line 408
      goto while_break;
    }
#line 409
    *(dest + count) = (float )((int )*(src + count) - 128) * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 413
  return;
}
}
#line 413 "/root/patchweave_donee/23/src/pcm.c"
__inline static void les2f_array(short *src , int count , float *dest , float normfact ) 
{ 
  short value ;

  {
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    count --;
#line 416
    if (! (count >= 0)) {
#line 416
      goto while_break;
    }
#line 417
    value = *(src + count);
#line 418
    value = value;
#line 419
    *(dest + count) = (float )value * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 424
  return;
}
}
#line 424 "/root/patchweave_donee/23/src/pcm.c"
__inline static void bes2f_array(short *src , int count , float *dest , float normfact ) 
{ 
  short value ;

  {
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    count --;
#line 427
    if (! (count >= 0)) {
#line 427
      goto while_break;
    }
    {
#line 428
    value = *(src + count);
#line 429
    value = ENDSWAP_16(value);
#line 430
    *(dest + count) = (float )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 436
  return;
}
}
#line 435 "/root/patchweave_donee/23/src/pcm.c"
__inline static void let2f_array(tribyte *src , int count , float *dest , float normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 439
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    count --;
#line 440
    if (! (count >= 0)) {
#line 440
      goto while_break;
    }
    {
#line 441
    ucptr -= 3;
#line 442
    value = psf_get_le24(ucptr, 0);
#line 443
    *(dest + count) = (float )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 449
  return;
}
}
#line 448 "/root/patchweave_donee/23/src/pcm.c"
__inline static void bet2f_array(tribyte *src , int count , float *dest , float normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 452
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    count --;
#line 453
    if (! (count >= 0)) {
#line 453
      goto while_break;
    }
    {
#line 454
    ucptr -= 3;
#line 455
    value = psf_get_be24(ucptr, 0);
#line 456
    *(dest + count) = (float )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 462
  return;
}
}
#line 461 "/root/patchweave_donee/23/src/pcm.c"
__inline static void lei2f_array(int *src , int count , float *dest , float normfact ) 
{ 
  int value ;

  {
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    count --;
#line 464
    if (! (count >= 0)) {
#line 464
      goto while_break;
    }
#line 465
    value = *(src + count);
#line 466
    value = value;
#line 467
    *(dest + count) = (float )value * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 472
  return;
}
}
#line 472 "/root/patchweave_donee/23/src/pcm.c"
__inline static void bei2f_array(int *src , int count , float *dest , float normfact ) 
{ 
  int value ;

  {
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    count --;
#line 475
    if (! (count >= 0)) {
#line 475
      goto while_break;
    }
    {
#line 476
    value = *(src + count);
#line 477
    value = ENDSWAP_32(value);
#line 478
    *(dest + count) = (float )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 484
  return;
}
}
#line 486 "/root/patchweave_donee/23/src/pcm.c"
__inline static void sc2d_array(signed char *src , int count , double *dest , double normfact ) 
{ 


  {
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    count --;
#line 487
    if (! (count >= 0)) {
#line 487
      goto while_break;
    }
#line 488
    *(dest + count) = (double )*(src + count) * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 492
  return;
}
}
#line 492 "/root/patchweave_donee/23/src/pcm.c"
__inline static void uc2d_array(unsigned char *src , int count , double *dest , double normfact ) 
{ 


  {
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    count --;
#line 493
    if (! (count >= 0)) {
#line 493
      goto while_break;
    }
#line 494
    *(dest + count) = (double )((int )*(src + count) - 128) * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 498
  return;
}
}
#line 498 "/root/patchweave_donee/23/src/pcm.c"
__inline static void les2d_array(short *src , int count , double *dest , double normfact ) 
{ 
  short value ;

  {
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    count --;
#line 501
    if (! (count >= 0)) {
#line 501
      goto while_break;
    }
#line 502
    value = *(src + count);
#line 503
    value = value;
#line 504
    *(dest + count) = (double )value * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 509
  return;
}
}
#line 509 "/root/patchweave_donee/23/src/pcm.c"
__inline static void bes2d_array(short *src , int count , double *dest , double normfact ) 
{ 
  short value ;

  {
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    count --;
#line 512
    if (! (count >= 0)) {
#line 512
      goto while_break;
    }
    {
#line 513
    value = *(src + count);
#line 514
    value = ENDSWAP_16(value);
#line 515
    *(dest + count) = (double )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 521
  return;
}
}
#line 520 "/root/patchweave_donee/23/src/pcm.c"
__inline static void let2d_array(tribyte *src , int count , double *dest , double normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 524
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    count --;
#line 525
    if (! (count >= 0)) {
#line 525
      goto while_break;
    }
    {
#line 526
    ucptr -= 3;
#line 527
    value = psf_get_le24(ucptr, 0);
#line 528
    *(dest + count) = (double )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 534
  return;
}
}
#line 533 "/root/patchweave_donee/23/src/pcm.c"
__inline static void bet2d_array(tribyte *src , int count , double *dest , double normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 537
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    count --;
#line 538
    if (! (count >= 0)) {
#line 538
      goto while_break;
    }
    {
#line 539
    ucptr -= 3;
#line 540
    value = psf_get_be24(ucptr, 0);
#line 541
    *(dest + count) = (double )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 547
  return;
}
}
#line 546 "/root/patchweave_donee/23/src/pcm.c"
__inline static void lei2d_array(int *src , int count , double *dest , double normfact ) 
{ 
  int value ;

  {
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 549
    count --;
#line 549
    if (! (count >= 0)) {
#line 549
      goto while_break;
    }
#line 550
    value = *(src + count);
#line 551
    value = value;
#line 552
    *(dest + count) = (double )value * normfact;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 557
  return;
}
}
#line 557 "/root/patchweave_donee/23/src/pcm.c"
__inline static void bei2d_array(int *src , int count , double *dest , double normfact ) 
{ 
  int value ;

  {
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    count --;
#line 560
    if (! (count >= 0)) {
#line 560
      goto while_break;
    }
    {
#line 561
    value = *(src + count);
#line 562
    value = ENDSWAP_32(value);
#line 563
    *(dest + count) = (double )value * normfact;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 569
  return;
}
}
#line 571 "/root/patchweave_donee/23/src/pcm.c"
__inline static void s2sc_array(short const   *src , signed char *dest , int count ) 
{ 


  {
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    count --;
#line 572
    if (! (count >= 0)) {
#line 572
      goto while_break;
    }
#line 573
    *(dest + count) = (signed char )((int )*(src + count) >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 577
  return;
}
}
#line 577 "/root/patchweave_donee/23/src/pcm.c"
__inline static void s2uc_array(short const   *src , unsigned char *dest , int count ) 
{ 


  {
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 578
    count --;
#line 578
    if (! (count >= 0)) {
#line 578
      goto while_break;
    }
#line 579
    *(dest + count) = (unsigned char )(((int )*(src + count) >> 8) + 128);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 583
  return;
}
}
#line 583 "/root/patchweave_donee/23/src/pcm.c"
__inline static void s2let_array(short const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 586
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    count --;
#line 587
    if (! (count >= 0)) {
#line 587
      goto while_break;
    }
#line 588
    ucptr -= 3;
#line 589
    *(ucptr + 0) = (unsigned char)0;
#line 590
    *(ucptr + 1) = (unsigned char )*(src + count);
#line 591
    *(ucptr + 2) = (unsigned char )((int )*(src + count) >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 596
  return;
}
}
#line 596 "/root/patchweave_donee/23/src/pcm.c"
__inline static void s2bet_array(short const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 599
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    count --;
#line 600
    if (! (count >= 0)) {
#line 600
      goto while_break;
    }
#line 601
    ucptr -= 3;
#line 602
    *(ucptr + 2) = (unsigned char)0;
#line 603
    *(ucptr + 1) = (unsigned char )*(src + count);
#line 604
    *(ucptr + 0) = (unsigned char )((int )*(src + count) >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 609
  return;
}
}
#line 609 "/root/patchweave_donee/23/src/pcm.c"
__inline static void s2lei_array(short const   *src , int *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 612
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    count --;
#line 613
    if (! (count >= 0)) {
#line 613
      goto while_break;
    }
#line 614
    ucptr -= 4;
#line 615
    *(ucptr + 0) = (unsigned char)0;
#line 616
    *(ucptr + 1) = (unsigned char)0;
#line 617
    *(ucptr + 2) = (unsigned char )*(src + count);
#line 618
    *(ucptr + 3) = (unsigned char )((int )*(src + count) >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 623
  return;
}
}
#line 623 "/root/patchweave_donee/23/src/pcm.c"
__inline static void s2bei_array(short const   *src , int *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 626
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    count --;
#line 627
    if (! (count >= 0)) {
#line 627
      goto while_break;
    }
#line 628
    ucptr -= 4;
#line 629
    *(ucptr + 0) = (unsigned char )((int )*(src + count) >> 8);
#line 630
    *(ucptr + 1) = (unsigned char )*(src + count);
#line 631
    *(ucptr + 2) = (unsigned char)0;
#line 632
    *(ucptr + 3) = (unsigned char)0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 637
  return;
}
}
#line 640 "/root/patchweave_donee/23/src/pcm.c"
__inline static void i2sc_array(int const   *src , signed char *dest , int count ) 
{ 


  {
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    count --;
#line 641
    if (! (count >= 0)) {
#line 641
      goto while_break;
    }
#line 642
    *(dest + count) = (signed char )(*(src + count) >> 24);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 646
  return;
}
}
#line 646 "/root/patchweave_donee/23/src/pcm.c"
__inline static void i2uc_array(int const   *src , unsigned char *dest , int count ) 
{ 


  {
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    count --;
#line 647
    if (! (count >= 0)) {
#line 647
      goto while_break;
    }
#line 648
    *(dest + count) = (unsigned char )((*(src + count) >> 24) + 128);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 652
  return;
}
}
#line 652 "/root/patchweave_donee/23/src/pcm.c"
__inline static void i2bes_array(int const   *src , short *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 655
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    count --;
#line 656
    if (! (count >= 0)) {
#line 656
      goto while_break;
    }
#line 657
    ucptr -= 2;
#line 658
    *(ucptr + 0) = (unsigned char )(*(src + count) >> 24);
#line 659
    *(ucptr + 1) = (unsigned char )(*(src + count) >> 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 664
  return;
}
}
#line 664 "/root/patchweave_donee/23/src/pcm.c"
__inline static void i2les_array(int const   *src , short *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 667
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    count --;
#line 668
    if (! (count >= 0)) {
#line 668
      goto while_break;
    }
#line 669
    ucptr -= 2;
#line 670
    *(ucptr + 0) = (unsigned char )(*(src + count) >> 16);
#line 671
    *(ucptr + 1) = (unsigned char )(*(src + count) >> 24);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 676
  return;
}
}
#line 676 "/root/patchweave_donee/23/src/pcm.c"
__inline static void i2let_array(int const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 680
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 681
    count --;
#line 681
    if (! (count >= 0)) {
#line 681
      goto while_break;
    }
#line 682
    ucptr -= 3;
#line 683
    value = (int )(*(src + count) >> 8);
#line 684
    *(ucptr + 0) = (unsigned char )value;
#line 685
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 686
    *(ucptr + 2) = (unsigned char )(value >> 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 691
  return;
}
}
#line 691 "/root/patchweave_donee/23/src/pcm.c"
__inline static void i2bet_array(int const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 695
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    count --;
#line 696
    if (! (count >= 0)) {
#line 696
      goto while_break;
    }
#line 697
    ucptr -= 3;
#line 698
    value = (int )(*(src + count) >> 8);
#line 699
    *(ucptr + 2) = (unsigned char )value;
#line 700
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 701
    *(ucptr + 0) = (unsigned char )(value >> 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 706
  return;
}
}
#line 709 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_sc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 712
  total = (sf_count_t )0;
#line 714
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;

#line 716
    if (! (len > 0L)) {
#line 716
      goto while_break;
    }
#line 717
    if (len < (long )bufferlen) {
#line 718
      bufferlen = (int )len;
    }
    {
#line 719
    __cil_tmp8 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 719
    readcount = (int )__cil_tmp8;
#line 720
    sc2s_array(ubuf.scbuf, readcount, ptr + total);
#line 721
    total += (long )readcount;
    }
#line 722
    if (readcount < bufferlen) {
#line 723
      goto while_break;
    }
#line 724
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 727
  return (total);
}
}
#line 731 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_uc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 734
  total = (sf_count_t )0;
#line 736
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 738
  while (1) {
    while_continue: /* CIL Label */ ;

#line 738
    if (! (len > 0L)) {
#line 738
      goto while_break;
    }
#line 739
    if (len < (long )bufferlen) {
#line 740
      bufferlen = (int )len;
    }
    {
#line 741
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                           (sf_count_t )bufferlen, psf);
#line 741
    readcount = (int )__cil_tmp8;
#line 742
    uc2s_array(ubuf.ucbuf, readcount, ptr + total);
#line 743
    total += (long )readcount;
    }
#line 744
    if (readcount < bufferlen) {
#line 745
      goto while_break;
    }
#line 746
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 749
  return (total);
}
}
#line 753 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bes2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 756
  __cil_tmp5 = psf_fread((void *)ptr, (sf_count_t )sizeof(short ), len, psf);
#line 756
  total = (int )__cil_tmp5;
#line 758
  endswap_short_array(ptr, (int )len);
  }
#line 760
  return ((sf_count_t )total);
}
}
#line 764 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_les2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 767
  __cil_tmp5 = psf_fread((void *)ptr, (sf_count_t )sizeof(short ), len, psf);
#line 767
  total = (int )__cil_tmp5;
  }
#line 771
  return ((sf_count_t )total);
}
}
#line 775 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bet2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 778
  total = (sf_count_t )0;
#line 780
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;

#line 782
    if (! (len > 0L)) {
#line 782
      goto while_break;
    }
#line 783
    if (len < (long )bufferlen) {
#line 784
      bufferlen = (int )len;
    }
    {
#line 785
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 785
    readcount = (int )__cil_tmp8;
#line 786
    bet2s_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total);
#line 787
    total += (long )readcount;
    }
#line 788
    if (readcount < bufferlen) {
#line 789
      goto while_break;
    }
#line 790
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 793
  return (total);
}
}
#line 797 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_let2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 800
  total = (sf_count_t )0;
#line 802
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 804
  while (1) {
    while_continue: /* CIL Label */ ;

#line 804
    if (! (len > 0L)) {
#line 804
      goto while_break;
    }
#line 805
    if (len < (long )bufferlen) {
#line 806
      bufferlen = (int )len;
    }
    {
#line 807
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 807
    readcount = (int )__cil_tmp8;
#line 808
    let2s_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total);
#line 809
    total += (long )readcount;
    }
#line 810
    if (readcount < bufferlen) {
#line 811
      goto while_break;
    }
#line 812
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 815
  return (total);
}
}
#line 819 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 822
  total = (sf_count_t )0;
#line 824
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;

#line 826
    if (! (len > 0L)) {
#line 826
      goto while_break;
    }
#line 827
    if (len < (long )bufferlen) {
#line 828
      bufferlen = (int )len;
    }
    {
#line 829
    __cil_tmp8 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                           psf);
#line 829
    readcount = (int )__cil_tmp8;
#line 830
    bei2s_array(ubuf.ibuf, readcount, ptr + total);
#line 831
    total += (long )readcount;
    }
#line 832
    if (readcount < bufferlen) {
#line 833
      goto while_break;
    }
#line 834
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 837
  return (total);
}
}
#line 841 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_lei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 844
  total = (sf_count_t )0;
#line 846
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 848
  while (1) {
    while_continue: /* CIL Label */ ;

#line 848
    if (! (len > 0L)) {
#line 848
      goto while_break;
    }
#line 849
    if (len < (long )bufferlen) {
#line 850
      bufferlen = (int )len;
    }
    {
#line 851
    __cil_tmp8 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                           psf);
#line 851
    readcount = (int )__cil_tmp8;
#line 852
    lei2s_array(ubuf.ibuf, readcount, ptr + total);
#line 853
    total += (long )readcount;
    }
#line 854
    if (readcount < bufferlen) {
#line 855
      goto while_break;
    }
#line 856
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 859
  return (total);
}
}
#line 866 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_sc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 869
  total = (sf_count_t )0;
#line 871
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;

#line 873
    if (! (len > 0L)) {
#line 873
      goto while_break;
    }
#line 874
    if (len < (long )bufferlen) {
#line 875
      bufferlen = (int )len;
    }
    {
#line 876
    __cil_tmp8 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 876
    readcount = (int )__cil_tmp8;
#line 877
    sc2i_array(ubuf.scbuf, readcount, ptr + total);
#line 878
    total += (long )readcount;
    }
#line 879
    if (readcount < bufferlen) {
#line 880
      goto while_break;
    }
#line 881
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 884
  return (total);
}
}
#line 888 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_uc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 891
  total = (sf_count_t )0;
#line 893
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;

#line 895
    if (! (len > 0L)) {
#line 895
      goto while_break;
    }
#line 896
    if (len < (long )bufferlen) {
#line 897
      bufferlen = (int )len;
    }
    {
#line 898
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                           (sf_count_t )bufferlen, psf);
#line 898
    readcount = (int )__cil_tmp8;
#line 899
    uc2i_array(ubuf.ucbuf, readcount, ptr + total);
#line 900
    total += (long )readcount;
    }
#line 901
    if (readcount < bufferlen) {
#line 902
      goto while_break;
    }
#line 903
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 906
  return (total);
}
}
#line 910 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bes2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 913
  total = (sf_count_t )0;
#line 915
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 917
  while (1) {
    while_continue: /* CIL Label */ ;

#line 917
    if (! (len > 0L)) {
#line 917
      goto while_break;
    }
#line 918
    if (len < (long )bufferlen) {
#line 919
      bufferlen = (int )len;
    }
    {
#line 920
    __cil_tmp8 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 920
    readcount = (int )__cil_tmp8;
#line 921
    bes2i_array(ubuf.sbuf, readcount, ptr + total);
#line 922
    total += (long )readcount;
    }
#line 923
    if (readcount < bufferlen) {
#line 924
      goto while_break;
    }
#line 925
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 928
  return (total);
}
}
#line 932 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_les2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 935
  total = (sf_count_t )0;
#line 937
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;

#line 939
    if (! (len > 0L)) {
#line 939
      goto while_break;
    }
#line 940
    if (len < (long )bufferlen) {
#line 941
      bufferlen = (int )len;
    }
    {
#line 942
    __cil_tmp8 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 942
    readcount = (int )__cil_tmp8;
#line 943
    les2i_array(ubuf.sbuf, readcount, ptr + total);
#line 944
    total += (long )readcount;
    }
#line 945
    if (readcount < bufferlen) {
#line 946
      goto while_break;
    }
#line 947
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 950
  return (total);
}
}
#line 954 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bet2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 957
  total = (sf_count_t )0;
#line 959
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;

#line 961
    if (! (len > 0L)) {
#line 961
      goto while_break;
    }
#line 962
    if (len < (long )bufferlen) {
#line 963
      bufferlen = (int )len;
    }
    {
#line 964
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 964
    readcount = (int )__cil_tmp8;
#line 965
    bet2i_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total);
#line 966
    total += (long )readcount;
    }
#line 967
    if (readcount < bufferlen) {
#line 968
      goto while_break;
    }
#line 969
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 972
  return (total);
}
}
#line 976 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_let2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 979
  total = (sf_count_t )0;
#line 981
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 983
  while (1) {
    while_continue: /* CIL Label */ ;

#line 983
    if (! (len > 0L)) {
#line 983
      goto while_break;
    }
#line 984
    if (len < (long )bufferlen) {
#line 985
      bufferlen = (int )len;
    }
    {
#line 986
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 986
    readcount = (int )__cil_tmp8;
#line 987
    let2i_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total);
#line 988
    total += (long )readcount;
    }
#line 989
    if (readcount < bufferlen) {
#line 990
      goto while_break;
    }
#line 991
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 994
  return (total);
}
}
#line 998 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 1001
  __cil_tmp5 = psf_fread((void *)ptr, (sf_count_t )sizeof(int ), len, psf);
#line 1001
  total = (int )__cil_tmp5;
#line 1003
  endswap_int_array(ptr, (int )len);
  }
#line 1005
  return ((sf_count_t )total);
}
}
#line 1009 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_lei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 1012
  __cil_tmp5 = psf_fread((void *)ptr, (sf_count_t )sizeof(int ), len, psf);
#line 1012
  total = (int )__cil_tmp5;
  }
#line 1016
  return ((sf_count_t )total);
}
}
#line 1023 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_sc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1026
  total = (sf_count_t )0;
#line 1029
  if (psf->norm_float == 1) {
#line 1029
    tmp = 1. / (double )((float )128);
  } else {
#line 1029
    tmp = 1.;
  }
#line 1029
  normfact = (float )tmp;
#line 1031
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 1033
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1033
    if (! (len > 0L)) {
#line 1033
      goto while_break;
    }
#line 1034
    if (len < (long )bufferlen) {
#line 1035
      bufferlen = (int )len;
    }
    {
#line 1036
    __cil_tmp10 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1036
    readcount = (int )__cil_tmp10;
#line 1037
    sc2f_array(ubuf.scbuf, readcount, ptr + total, normfact);
#line 1038
    total += (long )readcount;
    }
#line 1039
    if (readcount < bufferlen) {
#line 1040
      goto while_break;
    }
#line 1041
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1044
  return (total);
}
}
#line 1048 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_uc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1051
  total = (sf_count_t )0;
#line 1054
  if (psf->norm_float == 1) {
#line 1054
    tmp = 1. / (double )((float )128);
  } else {
#line 1054
    tmp = 1.;
  }
#line 1054
  normfact = (float )tmp;
#line 1056
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1058
    if (! (len > 0L)) {
#line 1058
      goto while_break;
    }
#line 1059
    if (len < (long )bufferlen) {
#line 1060
      bufferlen = (int )len;
    }
    {
#line 1061
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                            (sf_count_t )bufferlen, psf);
#line 1061
    readcount = (int )__cil_tmp10;
#line 1062
    uc2f_array(ubuf.ucbuf, readcount, ptr + total, normfact);
#line 1063
    total += (long )readcount;
    }
#line 1064
    if (readcount < bufferlen) {
#line 1065
      goto while_break;
    }
#line 1066
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1069
  return (total);
}
}
#line 1073 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bes2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1076
  total = (sf_count_t )0;
#line 1079
  if (psf->norm_float == 1) {
#line 1079
    tmp = 1. / (double )((float )32768);
  } else {
#line 1079
    tmp = 1.;
  }
#line 1079
  normfact = (float )tmp;
#line 1081
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1083
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1083
    if (! (len > 0L)) {
#line 1083
      goto while_break;
    }
#line 1084
    if (len < (long )bufferlen) {
#line 1085
      bufferlen = (int )len;
    }
    {
#line 1086
    __cil_tmp10 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1086
    readcount = (int )__cil_tmp10;
#line 1087
    bes2f_array(ubuf.sbuf, readcount, ptr + total, normfact);
#line 1088
    total += (long )readcount;
    }
#line 1089
    if (readcount < bufferlen) {
#line 1090
      goto while_break;
    }
#line 1091
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1094
  return (total);
}
}
#line 1098 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_les2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1101
  total = (sf_count_t )0;
#line 1104
  if (psf->norm_float == 1) {
#line 1104
    tmp = 1. / (double )((float )32768);
  } else {
#line 1104
    tmp = 1.;
  }
#line 1104
  normfact = (float )tmp;
#line 1106
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1108
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1108
    if (! (len > 0L)) {
#line 1108
      goto while_break;
    }
#line 1109
    if (len < (long )bufferlen) {
#line 1110
      bufferlen = (int )len;
    }
    {
#line 1111
    __cil_tmp10 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1111
    readcount = (int )__cil_tmp10;
#line 1112
    les2f_array(ubuf.sbuf, readcount, ptr + total, normfact);
#line 1113
    total += (long )readcount;
    }
#line 1114
    if (readcount < bufferlen) {
#line 1115
      goto while_break;
    }
#line 1116
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1119
  return (total);
}
}
#line 1123 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bet2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1126
  total = (sf_count_t )0;
#line 1130
  if (psf->norm_float == 1) {
#line 1130
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1130
    tmp = 1. / 256.;
  }
#line 1130
  normfact = (float )tmp;
#line 1132
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1134
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1134
    if (! (len > 0L)) {
#line 1134
      goto while_break;
    }
#line 1135
    if (len < (long )bufferlen) {
#line 1136
      bufferlen = (int )len;
    }
    {
#line 1137
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1137
    readcount = (int )__cil_tmp10;
#line 1138
    bet2f_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total, normfact);
#line 1139
    total += (long )readcount;
    }
#line 1140
    if (readcount < bufferlen) {
#line 1141
      goto while_break;
    }
#line 1142
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1145
  return (total);
}
}
#line 1149 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_let2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1152
  total = (sf_count_t )0;
#line 1156
  if (psf->norm_float == 1) {
#line 1156
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1156
    tmp = 1. / 256.;
  }
#line 1156
  normfact = (float )tmp;
#line 1158
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1160
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1160
    if (! (len > 0L)) {
#line 1160
      goto while_break;
    }
#line 1161
    if (len < (long )bufferlen) {
#line 1162
      bufferlen = (int )len;
    }
    {
#line 1163
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1163
    readcount = (int )__cil_tmp10;
#line 1164
    let2f_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total, normfact);
#line 1165
    total += (long )readcount;
    }
#line 1166
    if (readcount < bufferlen) {
#line 1167
      goto while_break;
    }
#line 1168
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1171
  return (total);
}
}
#line 1175 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1178
  total = (sf_count_t )0;
#line 1181
  if (psf->norm_float == 1) {
#line 1181
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1181
    tmp = 1.;
  }
#line 1181
  normfact = (float )tmp;
#line 1183
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1185
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1185
    if (! (len > 0L)) {
#line 1185
      goto while_break;
    }
#line 1186
    if (len < (long )bufferlen) {
#line 1187
      bufferlen = (int )len;
    }
    {
#line 1188
    __cil_tmp10 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1188
    readcount = (int )__cil_tmp10;
#line 1189
    bei2f_array(ubuf.ibuf, readcount, ptr + total, normfact);
#line 1190
    total += (long )readcount;
    }
#line 1191
    if (readcount < bufferlen) {
#line 1192
      goto while_break;
    }
#line 1193
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1196
  return (total);
}
}
#line 1200 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_lei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1203
  total = (sf_count_t )0;
#line 1206
  if (psf->norm_float == 1) {
#line 1206
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1206
    tmp = 1.;
  }
#line 1206
  normfact = (float )tmp;
#line 1208
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1210
    if (! (len > 0L)) {
#line 1210
      goto while_break;
    }
#line 1211
    if (len < (long )bufferlen) {
#line 1212
      bufferlen = (int )len;
    }
    {
#line 1213
    __cil_tmp10 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1213
    readcount = (int )__cil_tmp10;
#line 1214
    lei2f_array(ubuf.ibuf, readcount, ptr + total, normfact);
#line 1215
    total += (long )readcount;
    }
#line 1216
    if (readcount < bufferlen) {
#line 1217
      goto while_break;
    }
#line 1218
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1221
  return (total);
}
}
#line 1228 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_sc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1231
  total = (sf_count_t )0;
#line 1234
  if (psf->norm_double == 1) {
#line 1234
    tmp = 1. / (double )128;
  } else {
#line 1234
    tmp = 1.;
  }
#line 1234
  normfact = tmp;
#line 1236
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 1238
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1238
    if (! (len > 0L)) {
#line 1238
      goto while_break;
    }
#line 1239
    if (len < (long )bufferlen) {
#line 1240
      bufferlen = (int )len;
    }
    {
#line 1241
    __cil_tmp10 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1241
    readcount = (int )__cil_tmp10;
#line 1242
    sc2d_array(ubuf.scbuf, readcount, ptr + total, normfact);
#line 1243
    total += (long )readcount;
    }
#line 1244
    if (readcount < bufferlen) {
#line 1245
      goto while_break;
    }
#line 1246
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1249
  return (total);
}
}
#line 1253 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_uc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1256
  total = (sf_count_t )0;
#line 1259
  if (psf->norm_double == 1) {
#line 1259
    tmp = 1. / (double )128;
  } else {
#line 1259
    tmp = 1.;
  }
#line 1259
  normfact = tmp;
#line 1261
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1263
    if (! (len > 0L)) {
#line 1263
      goto while_break;
    }
#line 1264
    if (len < (long )bufferlen) {
#line 1265
      bufferlen = (int )len;
    }
    {
#line 1266
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                            (sf_count_t )bufferlen, psf);
#line 1266
    readcount = (int )__cil_tmp10;
#line 1267
    uc2d_array(ubuf.ucbuf, readcount, ptr + total, normfact);
#line 1268
    total += (long )readcount;
    }
#line 1269
    if (readcount < bufferlen) {
#line 1270
      goto while_break;
    }
#line 1271
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1274
  return (total);
}
}
#line 1278 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bes2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1281
  total = (sf_count_t )0;
#line 1284
  if (psf->norm_double == 1) {
#line 1284
    tmp = 1. / (double )32768;
  } else {
#line 1284
    tmp = 1.;
  }
#line 1284
  normfact = tmp;
#line 1286
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1288
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1288
    if (! (len > 0L)) {
#line 1288
      goto while_break;
    }
#line 1289
    if (len < (long )bufferlen) {
#line 1290
      bufferlen = (int )len;
    }
    {
#line 1291
    __cil_tmp10 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1291
    readcount = (int )__cil_tmp10;
#line 1292
    bes2d_array(ubuf.sbuf, readcount, ptr + total, normfact);
#line 1293
    total += (long )readcount;
    }
#line 1294
    if (readcount < bufferlen) {
#line 1295
      goto while_break;
    }
#line 1296
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1299
  return (total);
}
}
#line 1303 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_les2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1306
  total = (sf_count_t )0;
#line 1309
  if (psf->norm_double == 1) {
#line 1309
    tmp = 1. / (double )32768;
  } else {
#line 1309
    tmp = 1.;
  }
#line 1309
  normfact = tmp;
#line 1311
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1313
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1313
    if (! (len > 0L)) {
#line 1313
      goto while_break;
    }
#line 1314
    if (len < (long )bufferlen) {
#line 1315
      bufferlen = (int )len;
    }
    {
#line 1316
    __cil_tmp10 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1316
    readcount = (int )__cil_tmp10;
#line 1317
    les2d_array(ubuf.sbuf, readcount, ptr + total, normfact);
#line 1318
    total += (long )readcount;
    }
#line 1319
    if (readcount < bufferlen) {
#line 1320
      goto while_break;
    }
#line 1321
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1324
  return (total);
}
}
#line 1328 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bet2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1331
  total = (sf_count_t )0;
#line 1334
  if (psf->norm_double == 1) {
#line 1334
    tmp = 1. / (double )2147483648U;
  } else {
#line 1334
    tmp = 1. / 256.;
  }
#line 1334
  normfact = tmp;
#line 1336
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1338
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1338
    if (! (len > 0L)) {
#line 1338
      goto while_break;
    }
#line 1339
    if (len < (long )bufferlen) {
#line 1340
      bufferlen = (int )len;
    }
    {
#line 1341
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1341
    readcount = (int )__cil_tmp10;
#line 1342
    bet2d_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total, normfact);
#line 1343
    total += (long )readcount;
    }
#line 1344
    if (readcount < bufferlen) {
#line 1345
      goto while_break;
    }
#line 1346
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1349
  return (total);
}
}
#line 1353 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_let2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1356
  total = (sf_count_t )0;
#line 1360
  if (psf->norm_double == 1) {
#line 1360
    tmp = 1. / (double )2147483648U;
  } else {
#line 1360
    tmp = 1. / 256.;
  }
#line 1360
  normfact = tmp;
#line 1362
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1364
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1364
    if (! (len > 0L)) {
#line 1364
      goto while_break;
    }
#line 1365
    if (len < (long )bufferlen) {
#line 1366
      bufferlen = (int )len;
    }
    {
#line 1367
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1367
    readcount = (int )__cil_tmp10;
#line 1368
    let2d_array((tribyte *)(ubuf.ucbuf), readcount, ptr + total, normfact);
#line 1369
    total += (long )readcount;
    }
#line 1370
    if (readcount < bufferlen) {
#line 1371
      goto while_break;
    }
#line 1372
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1375
  return (total);
}
}
#line 1379 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_bei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1382
  total = (sf_count_t )0;
#line 1385
  if (psf->norm_double == 1) {
#line 1385
    tmp = 1. / (double )2147483648U;
  } else {
#line 1385
    tmp = 1.;
  }
#line 1385
  normfact = tmp;
#line 1387
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1389
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1389
    if (! (len > 0L)) {
#line 1389
      goto while_break;
    }
#line 1390
    if (len < (long )bufferlen) {
#line 1391
      bufferlen = (int )len;
    }
    {
#line 1392
    __cil_tmp10 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1392
    readcount = (int )__cil_tmp10;
#line 1393
    bei2d_array(ubuf.ibuf, readcount, ptr + total, normfact);
#line 1394
    total += (long )readcount;
    }
#line 1395
    if (readcount < bufferlen) {
#line 1396
      goto while_break;
    }
#line 1397
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1400
  return (total);
}
}
#line 1404 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_read_lei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1407
  total = (sf_count_t )0;
#line 1410
  if (psf->norm_double == 1) {
#line 1410
    tmp = 1. / (double )2147483648U;
  } else {
#line 1410
    tmp = 1.;
  }
#line 1410
  normfact = tmp;
#line 1412
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1414
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1414
    if (! (len > 0L)) {
#line 1414
      goto while_break;
    }
#line 1415
    if (len < (long )bufferlen) {
#line 1416
      bufferlen = (int )len;
    }
    {
#line 1417
    __cil_tmp10 = psf_fread((void *)(ubuf.ibuf), (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1417
    readcount = (int )__cil_tmp10;
#line 1418
    lei2d_array(ubuf.ibuf, readcount, ptr + total, normfact);
#line 1419
    total += (long )readcount;
    }
#line 1420
    if (readcount < bufferlen) {
#line 1421
      goto while_break;
    }
#line 1422
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1425
  return (total);
}
}
#line 1434 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_s2sc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1437
  total = (sf_count_t )0;
#line 1439
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 1441
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1441
    if (! (len > 0L)) {
#line 1441
      goto while_break;
    }
#line 1442
    if (len < (long )bufferlen) {
#line 1443
      bufferlen = (int )len;
    }
    {
#line 1444
    s2sc_array(ptr + total, ubuf.scbuf, bufferlen);
#line 1445
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1445
    writecount = (int )__cil_tmp8;
#line 1446
    total += (long )writecount;
    }
#line 1447
    if (writecount < bufferlen) {
#line 1448
      goto while_break;
    }
#line 1449
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1452
  return (total);
}
}
#line 1456 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_s2uc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1459
  total = (sf_count_t )0;
#line 1461
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1463
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1463
    if (! (len > 0L)) {
#line 1463
      goto while_break;
    }
#line 1464
    if (len < (long )bufferlen) {
#line 1465
      bufferlen = (int )len;
    }
    {
#line 1466
    s2uc_array(ptr + total, ubuf.ucbuf, bufferlen);
#line 1467
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                            (sf_count_t )bufferlen, psf);
#line 1467
    writecount = (int )__cil_tmp8;
#line 1468
    total += (long )writecount;
    }
#line 1469
    if (writecount < bufferlen) {
#line 1470
      goto while_break;
    }
#line 1471
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1474
  return (total);
}
}
#line 1478 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_s2bes(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 1481
  total = (sf_count_t )0;
#line 1487
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1489
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1489
    if (! (len > 0L)) {
#line 1489
      goto while_break;
    }
#line 1490
    if (len < (long )bufferlen) {
#line 1491
      bufferlen = (int )len;
    }
    {
#line 1492
    endswap_short_copy(ubuf.sbuf, ptr + total, bufferlen);
#line 1493
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 1493
    writecount = (int )__cil_tmp9;
#line 1494
    total += (long )writecount;
    }
#line 1495
    if (writecount < bufferlen) {
#line 1496
      goto while_break;
    }
#line 1497
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1500
  return (total);
}
}
#line 1504 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_s2les(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
  {
#line 1507
  total = (sf_count_t )0;
#line 1510
  __cil_tmp8 = psf_fwrite((void const   *)ptr, (sf_count_t )sizeof(short ), len, psf);
  }
#line 1510
  return (__cil_tmp8);
#line 1512
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1514
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1514
    if (! (len > 0L)) {
#line 1514
      goto while_break;
    }
#line 1515
    if (len < (long )bufferlen) {
#line 1516
      bufferlen = (int )len;
    }
    {
#line 1517
    endswap_short_copy(ubuf.sbuf, ptr + total, bufferlen);
#line 1518
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 1518
    writecount = (int )__cil_tmp9;
#line 1519
    total += (long )writecount;
    }
#line 1520
    if (writecount < bufferlen) {
#line 1521
      goto while_break;
    }
#line 1522
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1525
  return (total);
}
}
#line 1529 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_s2bet(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1532
  total = (sf_count_t )0;
#line 1534
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1536
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1536
    if (! (len > 0L)) {
#line 1536
      goto while_break;
    }
#line 1537
    if (len < (long )bufferlen) {
#line 1538
      bufferlen = (int )len;
    }
    {
#line 1539
    s2bet_array(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen);
#line 1540
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1540
    writecount = (int )__cil_tmp8;
#line 1541
    total += (long )writecount;
    }
#line 1542
    if (writecount < bufferlen) {
#line 1543
      goto while_break;
    }
#line 1544
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1547
  return (total);
}
}
#line 1551 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_s2let(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1554
  total = (sf_count_t )0;
#line 1556
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1558
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1558
    if (! (len > 0L)) {
#line 1558
      goto while_break;
    }
#line 1559
    if (len < (long )bufferlen) {
#line 1560
      bufferlen = (int )len;
    }
    {
#line 1561
    s2let_array(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen);
#line 1562
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1562
    writecount = (int )__cil_tmp8;
#line 1563
    total += (long )writecount;
    }
#line 1564
    if (writecount < bufferlen) {
#line 1565
      goto while_break;
    }
#line 1566
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1569
  return (total);
}
}
#line 1573 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_s2bei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1576
  total = (sf_count_t )0;
#line 1578
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1580
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1580
    if (! (len > 0L)) {
#line 1580
      goto while_break;
    }
#line 1581
    if (len < (long )bufferlen) {
#line 1582
      bufferlen = (int )len;
    }
    {
#line 1583
    s2bei_array(ptr + total, ubuf.ibuf, bufferlen);
#line 1584
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                            (sf_count_t )bufferlen, psf);
#line 1584
    writecount = (int )__cil_tmp8;
#line 1585
    total += (long )writecount;
    }
#line 1586
    if (writecount < bufferlen) {
#line 1587
      goto while_break;
    }
#line 1588
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1591
  return (total);
}
}
#line 1595 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_s2lei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1598
  total = (sf_count_t )0;
#line 1600
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1602
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1602
    if (! (len > 0L)) {
#line 1602
      goto while_break;
    }
#line 1603
    if (len < (long )bufferlen) {
#line 1604
      bufferlen = (int )len;
    }
    {
#line 1605
    s2lei_array(ptr + total, ubuf.ibuf, bufferlen);
#line 1606
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                            (sf_count_t )bufferlen, psf);
#line 1606
    writecount = (int )__cil_tmp8;
#line 1607
    total += (long )writecount;
    }
#line 1608
    if (writecount < bufferlen) {
#line 1609
      goto while_break;
    }
#line 1610
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1613
  return (total);
}
}
#line 1620 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_i2sc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1623
  total = (sf_count_t )0;
#line 1625
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 1627
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1627
    if (! (len > 0L)) {
#line 1627
      goto while_break;
    }
#line 1628
    if (len < (long )bufferlen) {
#line 1629
      bufferlen = (int )len;
    }
    {
#line 1630
    i2sc_array(ptr + total, ubuf.scbuf, bufferlen);
#line 1631
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1631
    writecount = (int )__cil_tmp8;
#line 1632
    total += (long )writecount;
    }
#line 1633
    if (writecount < bufferlen) {
#line 1634
      goto while_break;
    }
#line 1635
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1638
  return (total);
}
}
#line 1642 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_i2uc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1645
  total = (sf_count_t )0;
#line 1647
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1649
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1649
    if (! (len > 0L)) {
#line 1649
      goto while_break;
    }
#line 1650
    if (len < (long )bufferlen) {
#line 1651
      bufferlen = (int )len;
    }
    {
#line 1652
    i2uc_array(ptr + total, ubuf.ucbuf, bufferlen);
#line 1653
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1653
    writecount = (int )__cil_tmp8;
#line 1654
    total += (long )writecount;
    }
#line 1655
    if (writecount < bufferlen) {
#line 1656
      goto while_break;
    }
#line 1657
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1660
  return (total);
}
}
#line 1664 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_i2bes(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1667
  total = (sf_count_t )0;
#line 1669
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1671
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1671
    if (! (len > 0L)) {
#line 1671
      goto while_break;
    }
#line 1672
    if (len < (long )bufferlen) {
#line 1673
      bufferlen = (int )len;
    }
    {
#line 1674
    i2bes_array(ptr + total, ubuf.sbuf, bufferlen);
#line 1675
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 1675
    writecount = (int )__cil_tmp8;
#line 1676
    total += (long )writecount;
    }
#line 1677
    if (writecount < bufferlen) {
#line 1678
      goto while_break;
    }
#line 1679
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1682
  return (total);
}
}
#line 1686 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_i2les(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1689
  total = (sf_count_t )0;
#line 1691
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1693
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1693
    if (! (len > 0L)) {
#line 1693
      goto while_break;
    }
#line 1694
    if (len < (long )bufferlen) {
#line 1695
      bufferlen = (int )len;
    }
    {
#line 1696
    i2les_array(ptr + total, ubuf.sbuf, bufferlen);
#line 1697
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 1697
    writecount = (int )__cil_tmp8;
#line 1698
    total += (long )writecount;
    }
#line 1699
    if (writecount < bufferlen) {
#line 1700
      goto while_break;
    }
#line 1701
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1704
  return (total);
}
}
#line 1708 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_i2bet(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1711
  total = (sf_count_t )0;
#line 1713
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1715
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1715
    if (! (len > 0L)) {
#line 1715
      goto while_break;
    }
#line 1716
    if (len < (long )bufferlen) {
#line 1717
      bufferlen = (int )len;
    }
    {
#line 1718
    i2bet_array(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen);
#line 1719
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1719
    writecount = (int )__cil_tmp8;
#line 1720
    total += (long )writecount;
    }
#line 1721
    if (writecount < bufferlen) {
#line 1722
      goto while_break;
    }
#line 1723
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1726
  return (total);
}
}
#line 1730 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_i2let(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1733
  total = (sf_count_t )0;
#line 1735
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 1737
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1737
    if (! (len > 0L)) {
#line 1737
      goto while_break;
    }
#line 1738
    if (len < (long )bufferlen) {
#line 1739
      bufferlen = (int )len;
    }
    {
#line 1740
    i2let_array(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen);
#line 1741
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1741
    writecount = (int )__cil_tmp8;
#line 1742
    total += (long )writecount;
    }
#line 1743
    if (writecount < bufferlen) {
#line 1744
      goto while_break;
    }
#line 1745
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1748
  return (total);
}
}
#line 1752 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_i2bei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 1755
  total = (sf_count_t )0;
#line 1760
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1762
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1762
    if (! (len > 0L)) {
#line 1762
      goto while_break;
    }
#line 1763
    if (len < (long )bufferlen) {
#line 1764
      bufferlen = (int )len;
    }
    {
#line 1765
    endswap_int_copy(ubuf.ibuf, ptr + total, bufferlen);
#line 1766
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                            (sf_count_t )bufferlen, psf);
#line 1766
    writecount = (int )__cil_tmp9;
#line 1767
    total += (long )writecount;
    }
#line 1768
    if (writecount < bufferlen) {
#line 1769
      goto while_break;
    }
#line 1770
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1773
  return (total);
}
}
#line 1777 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_i2lei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
  {
#line 1780
  total = (sf_count_t )0;
#line 1783
  __cil_tmp8 = psf_fwrite((void const   *)ptr, (sf_count_t )sizeof(int ), len, psf);
  }
#line 1783
  return (__cil_tmp8);
#line 1785
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 1787
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1787
    if (! (len > 0L)) {
#line 1787
      goto while_break;
    }
#line 1788
    if (len < (long )bufferlen) {
#line 1789
      bufferlen = (int )len;
    }
    {
#line 1790
    endswap_int_copy(ubuf.ibuf, ptr + total, bufferlen);
#line 1791
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                            (sf_count_t )bufferlen, psf);
#line 1791
    writecount = (int )__cil_tmp9;
#line 1792
    total += (long )writecount;
    }
#line 1793
    if (writecount < bufferlen) {
#line 1794
      goto while_break;
    }
#line 1795
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1798
  return (total);
}
}
#line 1807 "/root/patchweave_donee/23/src/pcm.c"
static void f2sc_array(float const   *src , signed char *dest , int count , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1810
  if (normalize) {
#line 1810
    tmp = 1. * (double )127;
  } else {
#line 1810
    tmp = 1.;
  }
#line 1810
  normfact = (float )tmp;
  {
#line 1812
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1812
    count --;
#line 1812
    if (! (count >= 0)) {
#line 1812
      goto while_break;
    }
    {
#line 1813
    __cil_tmp7 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 1813
    *(dest + count) = (signed char )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1819
  return;
}
}
#line 1818 "/root/patchweave_donee/23/src/pcm.c"
static void f2sc_clip_array(float const   *src , signed char *dest , int count , int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1821
  if (normalize) {
#line 1821
    tmp = 8. * (double )268435456;
  } else {
#line 1821
    tmp = 1. * (double )16777216;
  }
#line 1821
  normfact = (float )tmp;
  {
#line 1823
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1823
    count --;
#line 1823
    if (! (count >= 0)) {
#line 1823
      goto while_break;
    }
#line 1824
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 1825
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1826
      *(dest + count) = (signed char)127;
#line 1827
      goto while_continue;
    }
#line 1829
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1830
      *(dest + count) = (signed char)-128;
#line 1831
      goto while_continue;
    }
    {
#line 1834
    __cil_tmp8 = lrintf(scaled_value);
#line 1834
    *(dest + count) = (signed char )(__cil_tmp8 >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1840
  return;
}
}
#line 1839 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_f2sc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , signed char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , signed char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 1843
  total = (sf_count_t )0;
#line 1845
  if (psf->add_clipping) {
#line 1845
    tmp = & f2sc_clip_array;
  } else {
#line 1845
    tmp = & f2sc_array;
  }
#line 1845
  convert = tmp;
#line 1846
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 1848
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1848
    if (! (len > 0L)) {
#line 1848
      goto while_break;
    }
#line 1849
    if (len < (long )bufferlen) {
#line 1850
      bufferlen = (int )len;
    }
    {
#line 1851
    (*convert)(ptr + total, ubuf.scbuf, bufferlen, psf->norm_float);
#line 1852
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                             (sf_count_t )bufferlen, psf);
#line 1852
    writecount = (int )__cil_tmp10;
#line 1853
    total += (long )writecount;
    }
#line 1854
    if (writecount < bufferlen) {
#line 1855
      goto while_break;
    }
#line 1856
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1859
  return (total);
}
}
#line 1866 "/root/patchweave_donee/23/src/pcm.c"
static void f2uc_array(float const   *src , unsigned char *dest , int count , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1869
  if (normalize) {
#line 1869
    tmp = 1. * (double )127;
  } else {
#line 1869
    tmp = 1.;
  }
#line 1869
  normfact = (float )tmp;
  {
#line 1871
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1871
    count --;
#line 1871
    if (! (count >= 0)) {
#line 1871
      goto while_break;
    }
    {
#line 1872
    __cil_tmp7 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 1872
    *(dest + count) = (unsigned char )(__cil_tmp7 + 128L);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1878
  return;
}
}
#line 1877 "/root/patchweave_donee/23/src/pcm.c"
static void f2uc_clip_array(float const   *src , unsigned char *dest , int count ,
                            int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1880
  if (normalize) {
#line 1880
    tmp = 8. * (double )268435456;
  } else {
#line 1880
    tmp = 1. * (double )16777216;
  }
#line 1880
  normfact = (float )tmp;
  {
#line 1882
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1882
    count --;
#line 1882
    if (! (count >= 0)) {
#line 1882
      goto while_break;
    }
#line 1883
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 1884
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1885
      *(dest + count) = (unsigned char)255;
#line 1886
      goto while_continue;
    }
#line 1888
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1889
      *(dest + count) = (unsigned char)0;
#line 1890
      goto while_continue;
    }
    {
#line 1893
    __cil_tmp8 = lrintf(scaled_value);
#line 1893
    *(dest + count) = (unsigned char )((__cil_tmp8 >> 24) + 128L);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1899
  return;
}
}
#line 1898 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_f2uc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , unsigned char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , unsigned char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 1902
  total = (sf_count_t )0;
#line 1904
  if (psf->add_clipping) {
#line 1904
    tmp = & f2uc_clip_array;
  } else {
#line 1904
    tmp = & f2uc_array;
  }
#line 1904
  convert = tmp;
#line 1905
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 1907
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1907
    if (! (len > 0L)) {
#line 1907
      goto while_break;
    }
#line 1908
    if (len < (long )bufferlen) {
#line 1909
      bufferlen = (int )len;
    }
    {
#line 1910
    (*convert)(ptr + total, ubuf.ucbuf, bufferlen, psf->norm_float);
#line 1911
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                             (sf_count_t )bufferlen, psf);
#line 1911
    writecount = (int )__cil_tmp10;
#line 1912
    total += (long )writecount;
    }
#line 1913
    if (writecount < bufferlen) {
#line 1914
      goto while_break;
    }
#line 1915
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1918
  return (total);
}
}
#line 1925 "/root/patchweave_donee/23/src/pcm.c"
static void f2bes_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  short value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 1930
  if (normalize) {
#line 1930
    tmp = 1. * (double )32767;
  } else {
#line 1930
    tmp = 1.;
  }
#line 1930
  normfact = (float )tmp;
#line 1931
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 1933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1933
    count --;
#line 1933
    if (! (count >= 0)) {
#line 1933
      goto while_break;
    }
    {
#line 1934
    ucptr -= 2;
#line 1935
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 1935
    value = (short )__cil_tmp9;
#line 1936
    *(ucptr + 1) = (unsigned char )value;
#line 1937
    *(ucptr + 0) = (unsigned char )((int )value >> 8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1943
  return;
}
}
#line 1942 "/root/patchweave_donee/23/src/pcm.c"
static void f2bes_clip_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 1947
  if (normalize) {
#line 1947
    tmp = 8. * (double )268435456;
  } else {
#line 1947
    tmp = 1. * (double )65536;
  }
#line 1947
  normfact = (float )tmp;
#line 1948
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 1950
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1950
    count --;
#line 1950
    if (! (count >= 0)) {
#line 1950
      goto while_break;
    }
#line 1951
    ucptr -= 2;
#line 1952
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 1953
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1954
      *(ucptr + 1) = (unsigned char)255;
#line 1955
      *(ucptr + 0) = (unsigned char)127;
#line 1956
      goto while_continue;
    }
#line 1958
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1959
      *(ucptr + 1) = (unsigned char)0;
#line 1960
      *(ucptr + 0) = (unsigned char)128;
#line 1961
      goto while_continue;
    }
    {
#line 1964
    __cil_tmp10 = lrintf(scaled_value);
#line 1964
    value = (int )__cil_tmp10;
#line 1965
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 1966
    *(ucptr + 0) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1972
  return;
}
}
#line 1971 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_f2bes(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 1975
  total = (sf_count_t )0;
#line 1977
  if (psf->add_clipping) {
#line 1977
    tmp = & f2bes_clip_array;
  } else {
#line 1977
    tmp = & f2bes_array;
  }
#line 1977
  convert = tmp;
#line 1978
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 1980
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1980
    if (! (len > 0L)) {
#line 1980
      goto while_break;
    }
#line 1981
    if (len < (long )bufferlen) {
#line 1982
      bufferlen = (int )len;
    }
    {
#line 1983
    (*convert)(ptr + total, ubuf.sbuf, bufferlen, psf->norm_float);
#line 1984
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 1984
    writecount = (int )__cil_tmp10;
#line 1985
    total += (long )writecount;
    }
#line 1986
    if (writecount < bufferlen) {
#line 1987
      goto while_break;
    }
#line 1988
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1991
  return (total);
}
}
#line 1998 "/root/patchweave_donee/23/src/pcm.c"
static void f2les_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2003
  if (normalize) {
#line 2003
    tmp = 1. * (double )32767;
  } else {
#line 2003
    tmp = 1.;
  }
#line 2003
  normfact = (float )tmp;
#line 2004
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2006
    count --;
#line 2006
    if (! (count >= 0)) {
#line 2006
      goto while_break;
    }
    {
#line 2007
    ucptr -= 2;
#line 2008
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 2008
    value = (int )__cil_tmp9;
#line 2009
    *(ucptr + 0) = (unsigned char )value;
#line 2010
    *(ucptr + 1) = (unsigned char )(value >> 8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2016
  return;
}
}
#line 2015 "/root/patchweave_donee/23/src/pcm.c"
static void f2les_clip_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2020
  if (normalize) {
#line 2020
    tmp = 8. * (double )268435456;
  } else {
#line 2020
    tmp = 1. * (double )65536;
  }
#line 2020
  normfact = (float )tmp;
#line 2021
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2023
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2023
    count --;
#line 2023
    if (! (count >= 0)) {
#line 2023
      goto while_break;
    }
#line 2024
    ucptr -= 2;
#line 2025
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 2026
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2027
      *(ucptr + 0) = (unsigned char)255;
#line 2028
      *(ucptr + 1) = (unsigned char)127;
#line 2029
      goto while_continue;
    }
#line 2031
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2032
      *(ucptr + 0) = (unsigned char)0;
#line 2033
      *(ucptr + 1) = (unsigned char)128;
#line 2034
      goto while_continue;
    }
    {
#line 2037
    __cil_tmp10 = lrintf(scaled_value);
#line 2037
    value = (int )__cil_tmp10;
#line 2038
    *(ucptr + 0) = (unsigned char )(value >> 16);
#line 2039
    *(ucptr + 1) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2045
  return;
}
}
#line 2044 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_f2les(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2048
  total = (sf_count_t )0;
#line 2050
  if (psf->add_clipping) {
#line 2050
    tmp = & f2les_clip_array;
  } else {
#line 2050
    tmp = & f2les_array;
  }
#line 2050
  convert = tmp;
#line 2051
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 2053
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2053
    if (! (len > 0L)) {
#line 2053
      goto while_break;
    }
#line 2054
    if (len < (long )bufferlen) {
#line 2055
      bufferlen = (int )len;
    }
    {
#line 2056
    (*convert)(ptr + total, ubuf.sbuf, bufferlen, psf->norm_float);
#line 2057
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 2057
    writecount = (int )__cil_tmp10;
#line 2058
    total += (long )writecount;
    }
#line 2059
    if (writecount < bufferlen) {
#line 2060
      goto while_break;
    }
#line 2061
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2064
  return (total);
}
}
#line 2071 "/root/patchweave_donee/23/src/pcm.c"
static void f2let_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2076
  if (normalize) {
#line 2076
    tmp = 1. * (double )8388607;
  } else {
#line 2076
    tmp = 1.;
  }
#line 2076
  normfact = (float )tmp;
#line 2077
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2079
    count --;
#line 2079
    if (! (count >= 0)) {
#line 2079
      goto while_break;
    }
    {
#line 2080
    ucptr -= 3;
#line 2081
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 2081
    value = (int )__cil_tmp9;
#line 2082
    *(ucptr + 0) = (unsigned char )value;
#line 2083
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2084
    *(ucptr + 2) = (unsigned char )(value >> 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2090
  return;
}
}
#line 2089 "/root/patchweave_donee/23/src/pcm.c"
static void f2let_clip_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2094
  if (normalize) {
#line 2094
    tmp = 8. * (double )268435456;
  } else {
#line 2094
    tmp = 1. * (double )256;
  }
#line 2094
  normfact = (float )tmp;
#line 2095
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2097
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2097
    count --;
#line 2097
    if (! (count >= 0)) {
#line 2097
      goto while_break;
    }
#line 2098
    ucptr -= 3;
#line 2099
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 2100
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2101
      *(ucptr + 0) = (unsigned char)255;
#line 2102
      *(ucptr + 1) = (unsigned char)255;
#line 2103
      *(ucptr + 2) = (unsigned char)127;
#line 2104
      goto while_continue;
    }
#line 2106
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2107
      *(ucptr + 0) = (unsigned char)0;
#line 2108
      *(ucptr + 1) = (unsigned char)0;
#line 2109
      *(ucptr + 2) = (unsigned char)128;
#line 2110
      goto while_continue;
    }
    {
#line 2113
    __cil_tmp10 = lrintf(scaled_value);
#line 2113
    value = (int )__cil_tmp10;
#line 2114
    *(ucptr + 0) = (unsigned char )(value >> 8);
#line 2115
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2116
    *(ucptr + 2) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2122
  return;
}
}
#line 2121 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_f2let(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2125
  total = (sf_count_t )0;
#line 2127
  if (psf->add_clipping) {
#line 2127
    tmp = & f2let_clip_array;
  } else {
#line 2127
    tmp = & f2let_array;
  }
#line 2127
  convert = tmp;
#line 2128
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 2130
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2130
    if (! (len > 0L)) {
#line 2130
      goto while_break;
    }
#line 2131
    if (len < (long )bufferlen) {
#line 2132
      bufferlen = (int )len;
    }
    {
#line 2133
    (*convert)(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen, psf->norm_float);
#line 2134
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                             psf);
#line 2134
    writecount = (int )__cil_tmp10;
#line 2135
    total += (long )writecount;
    }
#line 2136
    if (writecount < bufferlen) {
#line 2137
      goto while_break;
    }
#line 2138
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2141
  return (total);
}
}
#line 2148 "/root/patchweave_donee/23/src/pcm.c"
static void f2bet_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2153
  if (normalize) {
#line 2153
    tmp = 1. * (double )8388607;
  } else {
#line 2153
    tmp = 1.;
  }
#line 2153
  normfact = (float )tmp;
#line 2154
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2156
    count --;
#line 2156
    if (! (count >= 0)) {
#line 2156
      goto while_break;
    }
    {
#line 2157
    ucptr -= 3;
#line 2158
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 2158
    value = (int )__cil_tmp9;
#line 2159
    *(ucptr + 0) = (unsigned char )(value >> 16);
#line 2160
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2161
    *(ucptr + 2) = (unsigned char )value;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2167
  return;
}
}
#line 2166 "/root/patchweave_donee/23/src/pcm.c"
static void f2bet_clip_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2171
  if (normalize) {
#line 2171
    tmp = 8. * (double )268435456;
  } else {
#line 2171
    tmp = 1. * (double )256;
  }
#line 2171
  normfact = (float )tmp;
#line 2172
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2174
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2174
    count --;
#line 2174
    if (! (count >= 0)) {
#line 2174
      goto while_break;
    }
#line 2175
    ucptr -= 3;
#line 2176
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 2177
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2178
      *(ucptr + 0) = (unsigned char)127;
#line 2179
      *(ucptr + 1) = (unsigned char)255;
#line 2180
      *(ucptr + 2) = (unsigned char)255;
#line 2181
      goto while_continue;
    }
#line 2183
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2184
      *(ucptr + 0) = (unsigned char)128;
#line 2185
      *(ucptr + 1) = (unsigned char)0;
#line 2186
      *(ucptr + 2) = (unsigned char)0;
#line 2187
      goto while_continue;
    }
    {
#line 2190
    __cil_tmp10 = lrint((double )scaled_value);
#line 2190
    value = (int )__cil_tmp10;
#line 2191
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2192
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2193
    *(ucptr + 2) = (unsigned char )(value >> 8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2199
  return;
}
}
#line 2198 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_f2bet(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2202
  total = (sf_count_t )0;
#line 2204
  if (psf->add_clipping) {
#line 2204
    tmp = & f2bet_clip_array;
  } else {
#line 2204
    tmp = & f2bet_array;
  }
#line 2204
  convert = tmp;
#line 2205
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 2207
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2207
    if (! (len > 0L)) {
#line 2207
      goto while_break;
    }
#line 2208
    if (len < (long )bufferlen) {
#line 2209
      bufferlen = (int )len;
    }
    {
#line 2210
    (*convert)(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen, psf->norm_float);
#line 2211
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                             psf);
#line 2211
    writecount = (int )__cil_tmp10;
#line 2212
    total += (long )writecount;
    }
#line 2213
    if (writecount < bufferlen) {
#line 2214
      goto while_break;
    }
#line 2215
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2218
  return (total);
}
}
#line 2225 "/root/patchweave_donee/23/src/pcm.c"
static void f2bei_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2230
  if (normalize) {
#line 2230
    tmp = 1. * (double )2147483647;
  } else {
#line 2230
    tmp = 1.;
  }
#line 2230
  normfact = (float )tmp;
#line 2231
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2232
    count --;
#line 2232
    if (! (count >= 0)) {
#line 2232
      goto while_break;
    }
    {
#line 2233
    ucptr -= 4;
#line 2234
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 2234
    value = (int )__cil_tmp9;
#line 2235
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2236
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2237
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2238
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2244
  return;
}
}
#line 2243 "/root/patchweave_donee/23/src/pcm.c"
static void f2bei_clip_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2248
  if (normalize) {
#line 2248
    tmp = 8. * (double )268435456;
  } else {
#line 2248
    tmp = 1.;
  }
#line 2248
  normfact = (float )tmp;
#line 2249
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2251
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2251
    count --;
#line 2251
    if (! (count >= 0)) {
#line 2251
      goto while_break;
    }
#line 2252
    ucptr -= 4;
#line 2253
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 2254
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2255
      *(ucptr + 0) = (unsigned char)127;
#line 2256
      *(ucptr + 1) = (unsigned char)255;
#line 2257
      *(ucptr + 2) = (unsigned char)255;
#line 2258
      *(ucptr + 3) = (unsigned char)255;
#line 2259
      goto while_continue;
    }
#line 2261
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2262
      *(ucptr + 0) = (unsigned char)128;
#line 2263
      *(ucptr + 1) = (unsigned char)0;
#line 2264
      *(ucptr + 2) = (unsigned char)0;
#line 2265
      *(ucptr + 3) = (unsigned char)0;
#line 2266
      goto while_continue;
    }
    {
#line 2269
    __cil_tmp10 = lrintf(scaled_value);
#line 2269
    value = (int )__cil_tmp10;
#line 2270
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2271
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2272
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2273
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2279
  return;
}
}
#line 2278 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_f2bei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2282
  total = (sf_count_t )0;
#line 2284
  if (psf->add_clipping) {
#line 2284
    tmp = & f2bei_clip_array;
  } else {
#line 2284
    tmp = & f2bei_array;
  }
#line 2284
  convert = tmp;
#line 2285
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 2287
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2287
    if (! (len > 0L)) {
#line 2287
      goto while_break;
    }
#line 2288
    if (len < (long )bufferlen) {
#line 2289
      bufferlen = (int )len;
    }
    {
#line 2290
    (*convert)(ptr + total, ubuf.ibuf, bufferlen, psf->norm_float);
#line 2291
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                             (sf_count_t )bufferlen, psf);
#line 2291
    writecount = (int )__cil_tmp10;
#line 2292
    total += (long )writecount;
    }
#line 2293
    if (writecount < bufferlen) {
#line 2294
      goto while_break;
    }
#line 2295
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2298
  return (total);
}
}
#line 2305 "/root/patchweave_donee/23/src/pcm.c"
static void f2lei_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2310
  if (normalize) {
#line 2310
    tmp = 1. * (double )2147483647;
  } else {
#line 2310
    tmp = 1.;
  }
#line 2310
  normfact = (float )tmp;
#line 2311
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2313
    count --;
#line 2313
    if (! (count >= 0)) {
#line 2313
      goto while_break;
    }
    {
#line 2314
    ucptr -= 4;
#line 2315
    __cil_tmp9 = lrintf((float )(*(src + count) * (float const   )normfact));
#line 2315
    value = (int )__cil_tmp9;
#line 2316
    *(ucptr + 0) = (unsigned char )value;
#line 2317
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2318
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2319
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2325
  return;
}
}
#line 2324 "/root/patchweave_donee/23/src/pcm.c"
static void f2lei_clip_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2329
  if (normalize) {
#line 2329
    tmp = 8. * (double )268435456;
  } else {
#line 2329
    tmp = 1.;
  }
#line 2329
  normfact = (float )tmp;
#line 2330
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2332
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2332
    count --;
#line 2332
    if (! (count >= 0)) {
#line 2332
      goto while_break;
    }
#line 2333
    ucptr -= 4;
#line 2334
    scaled_value = (float )(*(src + count) * (float const   )normfact);
#line 2335
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2336
      *(ucptr + 0) = (unsigned char)255;
#line 2337
      *(ucptr + 1) = (unsigned char)255;
#line 2338
      *(ucptr + 2) = (unsigned char)255;
#line 2339
      *(ucptr + 3) = (unsigned char)127;
#line 2340
      goto while_continue;
    }
#line 2342
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2343
      *(ucptr + 0) = (unsigned char)0;
#line 2344
      *(ucptr + 1) = (unsigned char)0;
#line 2345
      *(ucptr + 2) = (unsigned char)0;
#line 2346
      *(ucptr + 3) = (unsigned char)128;
#line 2347
      goto while_continue;
    }
    {
#line 2350
    __cil_tmp10 = lrintf(scaled_value);
#line 2350
    value = (int )__cil_tmp10;
#line 2351
    *(ucptr + 0) = (unsigned char )value;
#line 2352
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2353
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2354
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2360
  return;
}
}
#line 2359 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_f2lei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2363
  total = (sf_count_t )0;
#line 2365
  if (psf->add_clipping) {
#line 2365
    tmp = & f2lei_clip_array;
  } else {
#line 2365
    tmp = & f2lei_array;
  }
#line 2365
  convert = tmp;
#line 2366
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 2368
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2368
    if (! (len > 0L)) {
#line 2368
      goto while_break;
    }
#line 2369
    if (len < (long )bufferlen) {
#line 2370
      bufferlen = (int )len;
    }
    {
#line 2371
    (*convert)(ptr + total, ubuf.ibuf, bufferlen, psf->norm_float);
#line 2372
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                             (sf_count_t )bufferlen, psf);
#line 2372
    writecount = (int )__cil_tmp10;
#line 2373
    total += (long )writecount;
    }
#line 2374
    if (writecount < bufferlen) {
#line 2375
      goto while_break;
    }
#line 2376
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2379
  return (total);
}
}
#line 2386 "/root/patchweave_donee/23/src/pcm.c"
static void d2sc_array(double const   *src , signed char *dest , int count , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 2389
  if (normalize) {
#line 2389
    tmp = 1. * (double )127;
  } else {
#line 2389
    tmp = 1.;
  }
#line 2389
  normfact = tmp;
  {
#line 2391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2391
    count --;
#line 2391
    if (! (count >= 0)) {
#line 2391
      goto while_break;
    }
    {
#line 2392
    __cil_tmp7 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2392
    *(dest + count) = (signed char )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2398
  return;
}
}
#line 2397 "/root/patchweave_donee/23/src/pcm.c"
static void d2sc_clip_array(double const   *src , signed char *dest , int count ,
                            int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 2400
  if (normalize) {
#line 2400
    tmp = 8. * (double )268435456;
  } else {
#line 2400
    tmp = 1. * (double )16777216;
  }
#line 2400
  normfact = tmp;
  {
#line 2402
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2402
    count --;
#line 2402
    if (! (count >= 0)) {
#line 2402
      goto while_break;
    }
#line 2403
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2404
    if (scaled_value >= 1. * (double )2147483647) {
#line 2405
      *(dest + count) = (signed char)127;
#line 2406
      goto while_continue;
    }
#line 2408
    if (scaled_value <= - 8. * (double )268435456) {
#line 2409
      *(dest + count) = (signed char)-128;
#line 2410
      goto while_continue;
    }
    {
#line 2413
    __cil_tmp8 = lrintf((float )scaled_value);
#line 2413
    *(dest + count) = (signed char )(__cil_tmp8 >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2419
  return;
}
}
#line 2418 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_d2sc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , signed char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , signed char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2422
  total = (sf_count_t )0;
#line 2424
  if (psf->add_clipping) {
#line 2424
    tmp = & d2sc_clip_array;
  } else {
#line 2424
    tmp = & d2sc_array;
  }
#line 2424
  convert = tmp;
#line 2425
  bufferlen = (int )(sizeof(ubuf.scbuf) / sizeof(ubuf.scbuf[0]));
  {
#line 2427
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2427
    if (! (len > 0L)) {
#line 2427
      goto while_break;
    }
#line 2428
    if (len < (long )bufferlen) {
#line 2429
      bufferlen = (int )len;
    }
    {
#line 2430
    (*convert)(ptr + total, ubuf.scbuf, bufferlen, psf->norm_double);
#line 2431
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                             (sf_count_t )bufferlen, psf);
#line 2431
    writecount = (int )__cil_tmp10;
#line 2432
    total += (long )writecount;
    }
#line 2433
    if (writecount < bufferlen) {
#line 2434
      goto while_break;
    }
#line 2435
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2438
  return (total);
}
}
#line 2445 "/root/patchweave_donee/23/src/pcm.c"
static void d2uc_array(double const   *src , unsigned char *dest , int count , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 2448
  if (normalize) {
#line 2448
    tmp = 1. * (double )127;
  } else {
#line 2448
    tmp = 1.;
  }
#line 2448
  normfact = tmp;
  {
#line 2450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2450
    count --;
#line 2450
    if (! (count >= 0)) {
#line 2450
      goto while_break;
    }
    {
#line 2451
    __cil_tmp7 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2451
    *(dest + count) = (unsigned char )(__cil_tmp7 + 128L);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2457
  return;
}
}
#line 2456 "/root/patchweave_donee/23/src/pcm.c"
static void d2uc_clip_array(double const   *src , unsigned char *dest , int count ,
                            int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 2459
  if (normalize) {
#line 2459
    tmp = 8. * (double )268435456;
  } else {
#line 2459
    tmp = 1. * (double )16777216;
  }
#line 2459
  normfact = tmp;
  {
#line 2461
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2461
    count --;
#line 2461
    if (! (count >= 0)) {
#line 2461
      goto while_break;
    }
#line 2462
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2463
    if (scaled_value >= 1. * (double )2147483647) {
#line 2464
      *(dest + count) = (unsigned char)255;
#line 2465
      goto while_continue;
    }
#line 2467
    if (scaled_value <= - 8. * (double )268435456) {
#line 2468
      *(dest + count) = (unsigned char)0;
#line 2469
      goto while_continue;
    }
    {
#line 2472
    __cil_tmp8 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2472
    *(dest + count) = (unsigned char )((__cil_tmp8 >> 24) + 128L);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2478
  return;
}
}
#line 2477 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_d2uc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , unsigned char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , unsigned char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2481
  total = (sf_count_t )0;
#line 2483
  if (psf->add_clipping) {
#line 2483
    tmp = & d2uc_clip_array;
  } else {
#line 2483
    tmp = & d2uc_array;
  }
#line 2483
  convert = tmp;
#line 2484
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 2486
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2486
    if (! (len > 0L)) {
#line 2486
      goto while_break;
    }
#line 2487
    if (len < (long )bufferlen) {
#line 2488
      bufferlen = (int )len;
    }
    {
#line 2489
    (*convert)(ptr + total, ubuf.ucbuf, bufferlen, psf->norm_double);
#line 2490
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )sizeof(unsigned char ),
                             (sf_count_t )bufferlen, psf);
#line 2490
    writecount = (int )__cil_tmp10;
#line 2491
    total += (long )writecount;
    }
#line 2492
    if (writecount < bufferlen) {
#line 2493
      goto while_break;
    }
#line 2494
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2497
  return (total);
}
}
#line 2504 "/root/patchweave_donee/23/src/pcm.c"
static void d2bes_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  short value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2509
  if (normalize) {
#line 2509
    tmp = 1. * (double )32767;
  } else {
#line 2509
    tmp = 1.;
  }
#line 2509
  normfact = tmp;
#line 2510
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2512
    count --;
#line 2512
    if (! (count >= 0)) {
#line 2512
      goto while_break;
    }
    {
#line 2513
    ucptr -= 2;
#line 2514
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2514
    value = (short )__cil_tmp9;
#line 2515
    *(ucptr + 1) = (unsigned char )value;
#line 2516
    *(ucptr + 0) = (unsigned char )((int )value >> 8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2522
  return;
}
}
#line 2521 "/root/patchweave_donee/23/src/pcm.c"
static void d2bes_clip_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  double normfact ;
  double scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2526
  if (normalize) {
#line 2526
    tmp = 8. * (double )268435456;
  } else {
#line 2526
    tmp = 1. * (double )65536;
  }
#line 2526
  normfact = tmp;
#line 2527
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2529
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2529
    count --;
#line 2529
    if (! (count >= 0)) {
#line 2529
      goto while_break;
    }
#line 2530
    ucptr -= 2;
#line 2531
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2532
    if (scaled_value >= 1. * (double )2147483647) {
#line 2533
      *(ucptr + 1) = (unsigned char)255;
#line 2534
      *(ucptr + 0) = (unsigned char)127;
#line 2535
      goto while_continue;
    }
#line 2537
    if (scaled_value <= - 8. * (double )268435456) {
#line 2538
      *(ucptr + 1) = (unsigned char)0;
#line 2539
      *(ucptr + 0) = (unsigned char)128;
#line 2540
      goto while_continue;
    }
    {
#line 2543
    __cil_tmp10 = lrint(scaled_value);
#line 2543
    value = (int )__cil_tmp10;
#line 2544
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2545
    *(ucptr + 0) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2551
  return;
}
}
#line 2550 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_d2bes(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2554
  total = (sf_count_t )0;
#line 2556
  if (psf->add_clipping) {
#line 2556
    tmp = & d2bes_clip_array;
  } else {
#line 2556
    tmp = & d2bes_array;
  }
#line 2556
  convert = tmp;
#line 2557
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 2559
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2559
    if (! (len > 0L)) {
#line 2559
      goto while_break;
    }
#line 2560
    if (len < (long )bufferlen) {
#line 2561
      bufferlen = (int )len;
    }
    {
#line 2562
    (*convert)(ptr + total, ubuf.sbuf, bufferlen, psf->norm_double);
#line 2563
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 2563
    writecount = (int )__cil_tmp10;
#line 2564
    total += (long )writecount;
    }
#line 2565
    if (writecount < bufferlen) {
#line 2566
      goto while_break;
    }
#line 2567
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2570
  return (total);
}
}
#line 2577 "/root/patchweave_donee/23/src/pcm.c"
static void d2les_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  short value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2582
  if (normalize) {
#line 2582
    tmp = 1. * (double )32767;
  } else {
#line 2582
    tmp = 1.;
  }
#line 2582
  normfact = tmp;
#line 2583
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2585
    count --;
#line 2585
    if (! (count >= 0)) {
#line 2585
      goto while_break;
    }
    {
#line 2586
    ucptr -= 2;
#line 2587
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2587
    value = (short )__cil_tmp9;
#line 2588
    *(ucptr + 0) = (unsigned char )value;
#line 2589
    *(ucptr + 1) = (unsigned char )((int )value >> 8);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2595
  return;
}
}
#line 2594 "/root/patchweave_donee/23/src/pcm.c"
static void d2les_clip_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2599
  if (normalize) {
#line 2599
    tmp = 8. * (double )268435456;
  } else {
#line 2599
    tmp = 1. * (double )65536;
  }
#line 2599
  normfact = tmp;
#line 2600
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2602
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2602
    count --;
#line 2602
    if (! (count >= 0)) {
#line 2602
      goto while_break;
    }
#line 2603
    ucptr -= 2;
#line 2604
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2605
    if (scaled_value >= 1. * (double )2147483647) {
#line 2606
      *(ucptr + 0) = (unsigned char)255;
#line 2607
      *(ucptr + 1) = (unsigned char)127;
#line 2608
      goto while_continue;
    }
#line 2610
    if (scaled_value <= - 8. * (double )268435456) {
#line 2611
      *(ucptr + 0) = (unsigned char)0;
#line 2612
      *(ucptr + 1) = (unsigned char)128;
#line 2613
      goto while_continue;
    }
    {
#line 2616
    __cil_tmp10 = lrint(scaled_value);
#line 2616
    value = (int )__cil_tmp10;
#line 2617
    *(ucptr + 0) = (unsigned char )(value >> 16);
#line 2618
    *(ucptr + 1) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2624
  return;
}
}
#line 2623 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_d2les(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2627
  total = (sf_count_t )0;
#line 2629
  if (psf->add_clipping) {
#line 2629
    tmp = & d2les_clip_array;
  } else {
#line 2629
    tmp = & d2les_array;
  }
#line 2629
  convert = tmp;
#line 2630
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 2632
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2632
    if (! (len > 0L)) {
#line 2632
      goto while_break;
    }
#line 2633
    if (len < (long )bufferlen) {
#line 2634
      bufferlen = (int )len;
    }
    {
#line 2635
    (*convert)(ptr + total, ubuf.sbuf, bufferlen, psf->norm_double);
#line 2636
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 2636
    writecount = (int )__cil_tmp10;
#line 2637
    total += (long )writecount;
    }
#line 2638
    if (writecount < bufferlen) {
#line 2639
      goto while_break;
    }
#line 2640
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2643
  return (total);
}
}
#line 2650 "/root/patchweave_donee/23/src/pcm.c"
static void d2let_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2655
  if (normalize) {
#line 2655
    tmp = 1. * (double )8388607;
  } else {
#line 2655
    tmp = 1.;
  }
#line 2655
  normfact = tmp;
#line 2656
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2658
    count --;
#line 2658
    if (! (count >= 0)) {
#line 2658
      goto while_break;
    }
    {
#line 2659
    ucptr -= 3;
#line 2660
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2660
    value = (int )__cil_tmp9;
#line 2661
    *(ucptr + 0) = (unsigned char )value;
#line 2662
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2663
    *(ucptr + 2) = (unsigned char )(value >> 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2669
  return;
}
}
#line 2668 "/root/patchweave_donee/23/src/pcm.c"
static void d2let_clip_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2673
  if (normalize) {
#line 2673
    tmp = 8. * (double )268435456;
  } else {
#line 2673
    tmp = 1. * (double )256;
  }
#line 2673
  normfact = tmp;
#line 2674
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2676
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2676
    count --;
#line 2676
    if (! (count >= 0)) {
#line 2676
      goto while_break;
    }
#line 2677
    ucptr -= 3;
#line 2678
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2679
    if (scaled_value >= 1. * (double )2147483647) {
#line 2680
      *(ucptr + 0) = (unsigned char)255;
#line 2681
      *(ucptr + 1) = (unsigned char)255;
#line 2682
      *(ucptr + 2) = (unsigned char)127;
#line 2683
      goto while_continue;
    }
#line 2685
    if (scaled_value <= - 8. * (double )268435456) {
#line 2686
      *(ucptr + 0) = (unsigned char)0;
#line 2687
      *(ucptr + 1) = (unsigned char)0;
#line 2688
      *(ucptr + 2) = (unsigned char)128;
#line 2689
      goto while_continue;
    }
    {
#line 2692
    __cil_tmp10 = lrint(scaled_value);
#line 2692
    value = (int )__cil_tmp10;
#line 2693
    *(ucptr + 0) = (unsigned char )(value >> 8);
#line 2694
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2695
    *(ucptr + 2) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2701
  return;
}
}
#line 2700 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_d2let(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2704
  total = (sf_count_t )0;
#line 2706
  if (psf->add_clipping) {
#line 2706
    tmp = & d2let_clip_array;
  } else {
#line 2706
    tmp = & d2let_array;
  }
#line 2706
  convert = tmp;
#line 2707
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 2709
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2709
    if (! (len > 0L)) {
#line 2709
      goto while_break;
    }
#line 2710
    if (len < (long )bufferlen) {
#line 2711
      bufferlen = (int )len;
    }
    {
#line 2712
    (*convert)(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen, psf->norm_double);
#line 2713
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                             psf);
#line 2713
    writecount = (int )__cil_tmp10;
#line 2714
    total += (long )writecount;
    }
#line 2715
    if (writecount < bufferlen) {
#line 2716
      goto while_break;
    }
#line 2717
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2720
  return (total);
}
}
#line 2727 "/root/patchweave_donee/23/src/pcm.c"
static void d2bet_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2732
  if (normalize) {
#line 2732
    tmp = 1. * (double )8388607;
  } else {
#line 2732
    tmp = 1.;
  }
#line 2732
  normfact = tmp;
#line 2733
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2735
    count --;
#line 2735
    if (! (count >= 0)) {
#line 2735
      goto while_break;
    }
    {
#line 2736
    ucptr -= 3;
#line 2737
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2737
    value = (int )__cil_tmp9;
#line 2738
    *(ucptr + 2) = (unsigned char )value;
#line 2739
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2740
    *(ucptr + 0) = (unsigned char )(value >> 16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2746
  return;
}
}
#line 2745 "/root/patchweave_donee/23/src/pcm.c"
static void d2bet_clip_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2750
  if (normalize) {
#line 2750
    tmp = 8. * (double )268435456;
  } else {
#line 2750
    tmp = 1. * (double )256;
  }
#line 2750
  normfact = tmp;
#line 2751
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2753
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2753
    count --;
#line 2753
    if (! (count >= 0)) {
#line 2753
      goto while_break;
    }
#line 2754
    ucptr -= 3;
#line 2755
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2756
    if (scaled_value >= 1. * (double )2147483647) {
#line 2757
      *(ucptr + 2) = (unsigned char)255;
#line 2758
      *(ucptr + 1) = (unsigned char)255;
#line 2759
      *(ucptr + 0) = (unsigned char)127;
#line 2760
      goto while_continue;
    }
#line 2762
    if (scaled_value <= - 8. * (double )268435456) {
#line 2763
      *(ucptr + 2) = (unsigned char)0;
#line 2764
      *(ucptr + 1) = (unsigned char)0;
#line 2765
      *(ucptr + 0) = (unsigned char)128;
#line 2766
      goto while_continue;
    }
    {
#line 2769
    __cil_tmp10 = lrint(scaled_value);
#line 2769
    value = (int )__cil_tmp10;
#line 2770
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2771
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2772
    *(ucptr + 0) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2778
  return;
}
}
#line 2777 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_d2bet(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2781
  total = (sf_count_t )0;
#line 2783
  if (psf->add_clipping) {
#line 2783
    tmp = & d2bet_clip_array;
  } else {
#line 2783
    tmp = & d2bet_array;
  }
#line 2783
  convert = tmp;
#line 2784
  bufferlen = (int )(sizeof(ubuf.ucbuf) / 3UL);
  {
#line 2786
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2786
    if (! (len > 0L)) {
#line 2786
      goto while_break;
    }
#line 2787
    if (len < (long )bufferlen) {
#line 2788
      bufferlen = (int )len;
    }
    {
#line 2789
    (*convert)(ptr + total, (tribyte *)(ubuf.ucbuf), bufferlen, psf->norm_double);
#line 2790
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )3, (sf_count_t )bufferlen,
                             psf);
#line 2790
    writecount = (int )__cil_tmp10;
#line 2791
    total += (long )writecount;
    }
#line 2792
    if (writecount < bufferlen) {
#line 2793
      goto while_break;
    }
#line 2794
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2797
  return (total);
}
}
#line 2804 "/root/patchweave_donee/23/src/pcm.c"
static void d2bei_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2809
  if (normalize) {
#line 2809
    tmp = 1. * (double )2147483647;
  } else {
#line 2809
    tmp = 1.;
  }
#line 2809
  normfact = tmp;
#line 2810
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2812
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2812
    count --;
#line 2812
    if (! (count >= 0)) {
#line 2812
      goto while_break;
    }
    {
#line 2813
    ucptr -= 4;
#line 2814
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2814
    value = (int )__cil_tmp9;
#line 2815
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2816
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2817
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2818
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2824
  return;
}
}
#line 2823 "/root/patchweave_donee/23/src/pcm.c"
static void d2bei_clip_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2828
  if (normalize) {
#line 2828
    tmp = 8. * (double )268435456;
  } else {
#line 2828
    tmp = 1.;
  }
#line 2828
  normfact = tmp;
#line 2829
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2831
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2831
    count --;
#line 2831
    if (! (count >= 0)) {
#line 2831
      goto while_break;
    }
#line 2832
    ucptr -= 4;
#line 2833
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2834
    if (scaled_value >= 1. * (double )2147483647) {
#line 2835
      *(ucptr + 3) = (unsigned char)255;
#line 2836
      *(ucptr + 2) = (unsigned char)255;
#line 2837
      *(ucptr + 1) = (unsigned char)255;
#line 2838
      *(ucptr + 0) = (unsigned char)127;
#line 2839
      goto while_continue;
    }
#line 2841
    if (scaled_value <= - 8. * (double )268435456) {
#line 2842
      *(ucptr + 3) = (unsigned char)0;
#line 2843
      *(ucptr + 2) = (unsigned char)0;
#line 2844
      *(ucptr + 1) = (unsigned char)0;
#line 2845
      *(ucptr + 0) = (unsigned char)128;
#line 2846
      goto while_continue;
    }
    {
#line 2849
    __cil_tmp10 = lrint(scaled_value);
#line 2849
    value = (int )__cil_tmp10;
#line 2850
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2851
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2852
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2853
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2859
  return;
}
}
#line 2858 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_d2bei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2862
  total = (sf_count_t )0;
#line 2864
  if (psf->add_clipping) {
#line 2864
    tmp = & d2bei_clip_array;
  } else {
#line 2864
    tmp = & d2bei_array;
  }
#line 2864
  convert = tmp;
#line 2865
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 2867
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2867
    if (! (len > 0L)) {
#line 2867
      goto while_break;
    }
#line 2868
    if (len < (long )bufferlen) {
#line 2869
      bufferlen = (int )len;
    }
    {
#line 2870
    (*convert)(ptr + total, ubuf.ibuf, bufferlen, psf->norm_double);
#line 2871
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                             (sf_count_t )bufferlen, psf);
#line 2871
    writecount = (int )__cil_tmp10;
#line 2872
    total += (long )writecount;
    }
#line 2873
    if (writecount < bufferlen) {
#line 2874
      goto while_break;
    }
#line 2875
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2878
  return (total);
}
}
#line 2885 "/root/patchweave_donee/23/src/pcm.c"
static void d2lei_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2890
  if (normalize) {
#line 2890
    tmp = 1. * (double )2147483647;
  } else {
#line 2890
    tmp = 1.;
  }
#line 2890
  normfact = tmp;
#line 2891
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2893
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2893
    count --;
#line 2893
    if (! (count >= 0)) {
#line 2893
      goto while_break;
    }
    {
#line 2894
    ucptr -= 4;
#line 2895
    __cil_tmp9 = lrint((double )(*(src + count) * (double const   )normfact));
#line 2895
    value = (int )__cil_tmp9;
#line 2896
    *(ucptr + 0) = (unsigned char )value;
#line 2897
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2898
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2899
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2905
  return;
}
}
#line 2904 "/root/patchweave_donee/23/src/pcm.c"
static void d2lei_clip_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2909
  if (normalize) {
#line 2909
    tmp = 8. * (double )268435456;
  } else {
#line 2909
    tmp = 1.;
  }
#line 2909
  normfact = tmp;
#line 2910
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2912
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 2912
    count --;
#line 2912
    if (! (count >= 0)) {
#line 2912
      goto while_break;
    }
#line 2913
    ucptr -= 4;
#line 2914
    scaled_value = (double )(*(src + count) * (double const   )normfact);
#line 2915
    if (scaled_value >= 1. * (double )2147483647) {
#line 2916
      *(ucptr + 0) = (unsigned char)255;
#line 2917
      *(ucptr + 1) = (unsigned char)255;
#line 2918
      *(ucptr + 2) = (unsigned char)255;
#line 2919
      *(ucptr + 3) = (unsigned char)127;
#line 2920
      goto while_continue;
    }
#line 2922
    if (scaled_value <= - 8. * (double )268435456) {
#line 2923
      *(ucptr + 0) = (unsigned char)0;
#line 2924
      *(ucptr + 1) = (unsigned char)0;
#line 2925
      *(ucptr + 2) = (unsigned char)0;
#line 2926
      *(ucptr + 3) = (unsigned char)128;
#line 2927
      goto while_continue;
    }
    {
#line 2930
    __cil_tmp10 = lrint(scaled_value);
#line 2930
    value = (int )__cil_tmp10;
#line 2931
    *(ucptr + 0) = (unsigned char )value;
#line 2932
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2933
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2934
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2940
  return;
}
}
#line 2939 "/root/patchweave_donee/23/src/pcm.c"
static sf_count_t pcm_write_d2lei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp10 ;

  {
#line 2943
  total = (sf_count_t )0;
#line 2945
  if (psf->add_clipping) {
#line 2945
    tmp = & d2lei_clip_array;
  } else {
#line 2945
    tmp = & d2lei_array;
  }
#line 2945
  convert = tmp;
#line 2946
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 2948
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2948
    if (! (len > 0L)) {
#line 2948
      goto while_break;
    }
#line 2949
    if (len < (long )bufferlen) {
#line 2950
      bufferlen = (int )len;
    }
    {
#line 2951
    (*convert)(ptr + total, ubuf.ibuf, bufferlen, psf->norm_double);
#line 2952
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ibuf), (sf_count_t )sizeof(int ),
                             (sf_count_t )bufferlen, psf);
#line 2952
    writecount = (int )__cil_tmp10;
#line 2953
    total += (long )writecount;
    }
#line 2954
    if (writecount < bufferlen) {
#line 2955
      goto while_break;
    }
#line 2956
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2959
  return (total);
}
}
#line 168 "/usr/include/fcntl.h"
__inline extern int ( __attribute__((__gnu_inline__)) open)(char const   *__path ,
                                                            int __oflag  , ...) ;
#line 178
__inline extern int ( __attribute__((__gnu_inline__)) open64)(char const   *__path ,
                                                              int __oflag  , ...) ;
#line 192
__inline extern int ( __attribute__((__gnu_inline__)) openat)(int __fd , char const   *__path ,
                                                              int __oflag  , ...) ;
#line 203
__inline extern int ( __attribute__((__gnu_inline__)) openat64)(int __fd , char const   *__path ,
                                                                int __oflag  , ...) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__gnu_inline__)) open)(char const   *__path ,
                                                            int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
#line 46
  __cil_tmp4 = 0;
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = (int )__builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = (int )__builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 64
extern int __open64_2(char const   *__path , int __oflag ) ;
#line 65
extern int __open64_alias(char const   *__path , int __oflag  , ...) ;
#line 67
extern void __open64_too_many_args(void) ;
#line 69
extern void __open64_missing_mode(void) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__gnu_inline__)) open64)(char const   *__path ,
                                                              int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 75
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 75
  if (__cil_tmp3 > 1) {
    {
#line 76
    __open64_too_many_args();
    }
  }
#line 78
  __cil_tmp4 = 0;
#line 78
  if (__cil_tmp4) {
    {
#line 80
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 80
    if ((__oflag & 64) != 0) {
      _L: 
#line 80
      if (__cil_tmp5 < 1) {
        {
#line 82
        __open64_missing_mode();
#line 83
        __cil_tmp6 = __open64_2(__path, __oflag);
        }
#line 83
        return (__cil_tmp6);
      }
    } else
#line 80
    if ((__oflag & 4259840) == 4259840) {
#line 80
      goto _L;
    }
    {
#line 85
    __cil_tmp7 = (int )__builtin_va_arg_pack();
#line 85
    __cil_tmp8 = __open64_alias(__path, __oflag, __cil_tmp7);
    }
#line 85
    return (__cil_tmp8);
  }
  {
#line 88
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 88
  if (__cil_tmp9 < 1) {
    {
#line 89
    __cil_tmp10 = __open64_2(__path, __oflag);
    }
#line 89
    return (__cil_tmp10);
  }
  {
#line 91
  __cil_tmp11 = (int )__builtin_va_arg_pack();
#line 91
  __cil_tmp12 = __open64_alias(__path, __oflag, __cil_tmp11);
  }
#line 91
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__gnu_inline__)) openat)(int __fd , char const   *__path ,
                                                              int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
#line 122
  __cil_tmp5 = 0;
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = (int )__builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = (int )__builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 140
extern int __openat64_2(int __fd , char const   *__path , int __oflag ) ;
#line 142
extern int __openat64_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 145
extern void __openat64_too_many_args(void) ;
#line 147
extern void __openat64_missing_mode(void) ;
#line 151 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__gnu_inline__)) openat64)(int __fd , char const   *__path ,
                                                                int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 153
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 153
  if (__cil_tmp4 > 1) {
    {
#line 154
    __openat64_too_many_args();
    }
  }
#line 156
  __cil_tmp5 = 0;
#line 156
  if (__cil_tmp5) {
    {
#line 158
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 158
    if ((__oflag & 64) != 0) {
      _L: 
#line 158
      if (__cil_tmp6 < 1) {
        {
#line 160
        __openat64_missing_mode();
#line 161
        __cil_tmp7 = __openat64_2(__fd, __path, __oflag);
        }
#line 161
        return (__cil_tmp7);
      }
    } else
#line 158
    if ((__oflag & 4259840) == 4259840) {
#line 158
      goto _L;
    }
    {
#line 163
    __cil_tmp8 = (int )__builtin_va_arg_pack();
#line 163
    __cil_tmp9 = __openat64_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 163
    return (__cil_tmp9);
  }
  {
#line 166
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 166
  if (__cil_tmp10 < 1) {
    {
#line 167
    __cil_tmp11 = __openat64_2(__fd, __path, __oflag);
    }
#line 167
    return (__cil_tmp11);
  }
  {
#line 169
  __cil_tmp12 = (int )__builtin_va_arg_pack();
#line 169
  __cil_tmp13 = __openat64_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 169
  return (__cil_tmp13);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 207 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128) {
#line 209
    if (__c < 256) {
      {
#line 209
      __cil_tmp2 = __ctype_tolower_loc();
#line 209
      tmp = *(*__cil_tmp2 + __c);
      }
    } else {
#line 209
      tmp = __c;
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 213 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128) {
#line 215
    if (__c < 256) {
      {
#line 215
      __cil_tmp2 = __ctype_toupper_loc();
#line 215
      tmp = *(*__cil_tmp2 + __c);
      }
    } else {
#line 215
      tmp = __c;
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 334
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
__inline extern ssize_t ( __attribute__((__gnu_inline__)) read)(int __fd , void *__buf ,
                                                                size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 376
__inline extern ssize_t ( __attribute__((__gnu_inline__)) pread)(int __fd , void *__buf ,
                                                                 size_t __nbytes ,
                                                                 __off_t __offset ) ;
#line 404
__inline extern ssize_t ( __attribute__((__gnu_inline__)) pread64)(int __fd , void *__buf ,
                                                                   size_t __nbytes ,
                                                                   __off64_t __offset ) ;
#line 511
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf ,
                                                                                              size_t __size ) ;
#line 525
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) ;
#line 623
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) confstr)(int __name ,
                                                                                                char *__buf ,
                                                                                                size_t __len ) ;
#line 689
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getgroups)(int __size ,
                                                                                               __gid_t *__list ) ;
#line 774
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 808
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                                                  char *__buf ,
                                                                                                  size_t __len ) ;
#line 819
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    char *__buf ,
                                                                                                    size_t __len ) ;
#line 856
__inline extern int ( __attribute__((__gnu_inline__)) getlogin_r)(char *__buf , size_t __buflen ) ;
#line 877
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf ,
                                                                                                 size_t __buflen ) ;
#line 895
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                                                   size_t __buflen ) ;
#line 954
extern int fsync(int __fd ) ;
#line 1014
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 25
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 27
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__gnu_inline__)) read)(int __fd , void *__buf ,
                                                                size_t __nbytes ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__buf, 0);
  }
#line 36
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 38
    __cil_tmp5 = 0;
#line 38
    if (! __cil_tmp5) {
      {
#line 39
      __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 39
      __cil_tmp7 = __read_chk(__fd, __buf, __nbytes, __cil_tmp6);
      }
#line 39
      return (__cil_tmp7);
    }
    {
#line 41
    __cil_tmp8 = __builtin_object_size(__buf, 0);
    }
#line 41
    if (__nbytes > __cil_tmp8) {
      {
#line 42
      __cil_tmp9 = __builtin_object_size(__buf, 0);
#line 42
      __cil_tmp10 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp9);
      }
#line 42
      return (__cil_tmp10);
    }
  }
  {
#line 44
  __cil_tmp11 = __read_alias(__fd, __buf, __nbytes);
  }
#line 44
  return (__cil_tmp11);
}
}
#line 48
extern ssize_t __pread_chk(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                           size_t __bufsize ) ;
#line 50
extern ssize_t __pread64_chk(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                             size_t __bufsize ) ;
#line 52
extern ssize_t __pread_alias(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 55
extern ssize_t __pread64_alias(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) ;
#line 58
extern ssize_t __pread_chk_warn(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                                size_t __bufsize ) ;
#line 63
extern ssize_t __pread64_chk_warn(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                                  size_t __bufsize ) ;
#line 72 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__gnu_inline__)) pread)(int __fd , void *__buf ,
                                                                 size_t __nbytes ,
                                                                 __off_t __offset ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 74
  __cil_tmp5 = __builtin_object_size(__buf, 0);
  }
#line 74
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 76
    __cil_tmp6 = 0;
#line 76
    if (! __cil_tmp6) {
      {
#line 77
      __cil_tmp7 = __builtin_object_size(__buf, 0);
#line 77
      __cil_tmp8 = __pread_chk(__fd, __buf, __nbytes, __offset, __cil_tmp7);
      }
#line 77
      return (__cil_tmp8);
    }
    {
#line 79
    __cil_tmp9 = __builtin_object_size(__buf, 0);
    }
#line 79
    if (__nbytes > __cil_tmp9) {
      {
#line 80
      __cil_tmp10 = __builtin_object_size(__buf, 0);
#line 80
      __cil_tmp11 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp10);
      }
#line 80
      return (__cil_tmp11);
    }
  }
  {
#line 83
  __cil_tmp12 = __pread_alias(__fd, __buf, __nbytes, __offset);
  }
#line 83
  return (__cil_tmp12);
}
}
#line 105 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__gnu_inline__)) pread64)(int __fd , void *__buf ,
                                                                   size_t __nbytes ,
                                                                   __off64_t __offset ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 107
  __cil_tmp5 = __builtin_object_size(__buf, 0);
  }
#line 107
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 109
    __cil_tmp6 = 0;
#line 109
    if (! __cil_tmp6) {
      {
#line 110
      __cil_tmp7 = __builtin_object_size(__buf, 0);
#line 110
      __cil_tmp8 = __pread64_chk(__fd, __buf, __nbytes, __offset, __cil_tmp7);
      }
#line 110
      return (__cil_tmp8);
    }
    {
#line 112
    __cil_tmp9 = __builtin_object_size(__buf, 0);
    }
#line 112
    if (__nbytes > __cil_tmp9) {
      {
#line 113
      __cil_tmp10 = __builtin_object_size(__buf, 0);
#line 113
      __cil_tmp11 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp10);
      }
#line 113
      return (__cil_tmp11);
    }
  }
  {
#line 117
  __cil_tmp12 = __pread64_alias(__fd, __buf, __nbytes, __offset);
  }
#line 117
  return (__cil_tmp12);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 139
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                                                  char *__buf ,
                                                                                                  size_t __len ) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__gnu_inline__)) readlink)(char const   *__path ,
                                                                    char *__buf ,
                                                                    size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 142
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 142
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 144
    __cil_tmp5 = 0;
#line 144
    if (! __cil_tmp5) {
      {
#line 145
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 145
      __cil_tmp7 = __readlink_chk(__path, __buf, __len, __cil_tmp6);
      }
#line 145
      return (__cil_tmp7);
    }
    {
#line 147
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 147
    if (__len > __cil_tmp8) {
      {
#line 148
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 148
      __cil_tmp10 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp9);
      }
#line 148
      return (__cil_tmp10);
    }
  }
  {
#line 150
  __cil_tmp11 = __readlink_alias(__path, __buf, __len);
  }
#line 150
  return (__cil_tmp11);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 173
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    char *__buf ,
                                                                                                    size_t __len ) ;
#line 173 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__gnu_inline__)) readlinkat)(int __fd , char const   *__path ,
                                                                      char *__buf ,
                                                                      size_t __len ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 176
  __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
  }
#line 176
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 178
    __cil_tmp6 = 0;
#line 178
    if (! __cil_tmp6) {
      {
#line 179
      __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
#line 179
      __cil_tmp8 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp7);
      }
#line 179
      return (__cil_tmp8);
    }
    {
#line 181
    __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
    }
#line 181
    if (__len > __cil_tmp9) {
      {
#line 182
      __cil_tmp10 = __builtin_object_size((void *)__buf, 1);
#line 182
      __cil_tmp11 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp10);
      }
#line 182
      return (__cil_tmp11);
    }
  }
  {
#line 185
  __cil_tmp12 = __readlinkat_alias(__fd, __path, __buf, __len);
  }
#line 185
  return (__cil_tmp12);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 193
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf ,
                                                                                              size_t __size ) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__gnu_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 202
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 204
    __cil_tmp4 = 0;
#line 204
    if (! __cil_tmp4) {
      {
#line 205
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 205
      __cil_tmp6 = __getcwd_chk(__buf, __size, __cil_tmp5);
      }
#line 205
      return (__cil_tmp6);
    }
    {
#line 207
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 207
    if (__size > __cil_tmp7) {
      {
#line 208
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 208
      __cil_tmp9 = __getcwd_chk_warn(__buf, __size, __cil_tmp8);
      }
#line 208
      return (__cil_tmp9);
    }
  }
  {
#line 210
  __cil_tmp10 = __getcwd_alias(__buf, __size);
  }
#line 210
  return (__cil_tmp10);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 221
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) ;
#line 221 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__gnu_inline__)) getwd)(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 223
  __cil_tmp2 = __builtin_object_size((void *)__buf, 1);
  }
#line 223
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 224
    __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
#line 224
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 224
    return (__cil_tmp4);
  }
  {
#line 225
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 225
  return (__cil_tmp5);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) confstr)(int __name ,
                                                                                                char *__buf ,
                                                                                                size_t __len ) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) confstr)(int __name , char *__buf ,
                                                                  size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 242
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 242
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 244
    __cil_tmp5 = 0;
#line 244
    if (! __cil_tmp5) {
      {
#line 245
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 245
      __cil_tmp7 = __confstr_chk(__name, __buf, __len, __cil_tmp6);
      }
#line 245
      return (__cil_tmp7);
    }
    {
#line 247
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 247
    if (__cil_tmp8 < __len) {
      {
#line 248
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 248
      __cil_tmp10 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp9);
      }
#line 248
      return (__cil_tmp10);
    }
  }
  {
#line 250
  __cil_tmp11 = __confstr_alias(__name, __buf, __len);
  }
#line 250
  return (__cil_tmp11);
}
}
#line 254
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t *__list ,
                                                         size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t *__list ) ;
#line 258
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t *__list ,
                                                              size_t __listlen ) ;
#line 265
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getgroups)(int __size ,
                                                                                               __gid_t *__list ) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_object_size((void *)__list, 1);
  }
#line 267
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 269
    __cil_tmp4 = 0;
#line 269
    if (! __cil_tmp4) {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void *)__list, 1);
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
#line 270
      return (__cil_tmp6);
    } else
#line 269
    if (__size < 0) {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void *)__list, 1);
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
#line 270
      return (__cil_tmp6);
    }
    {
#line 272
    __cil_tmp7 = __builtin_object_size((void *)__list, 1);
    }
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > __cil_tmp7) {
      {
#line 273
      __cil_tmp8 = __builtin_object_size((void *)__list, 1);
#line 273
      __cil_tmp9 = __getgroups_chk_warn(__size, __list, __cil_tmp8);
      }
#line 273
      return (__cil_tmp9);
    }
  }
  {
#line 275
  __cil_tmp10 = __getgroups_alias(__size, __list);
  }
#line 275
  return (__cil_tmp10);
}
}
#line 279
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 284
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 291 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                                 size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 293
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 293
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 295
    __cil_tmp5 = 0;
#line 295
    if (! __cil_tmp5) {
      {
#line 296
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 296
      __cil_tmp7 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 296
      return (__cil_tmp7);
    }
    {
#line 298
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 298
    if (__buflen > __cil_tmp8) {
      {
#line 299
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 299
      __cil_tmp10 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 299
      return (__cil_tmp10);
    }
  }
  {
#line 301
  __cil_tmp11 = __ttyname_r_alias(__fd, __buf, __buflen);
  }
#line 301
  return (__cil_tmp11);
}
}
#line 306
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 308
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 310
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 317 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getlogin_r)(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 319
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 319
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 321
    __cil_tmp4 = 0;
#line 321
    if (! __cil_tmp4) {
      {
#line 322
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 322
      __cil_tmp6 = __getlogin_r_chk(__buf, __buflen, __cil_tmp5);
      }
#line 322
      return (__cil_tmp6);
    }
    {
#line 324
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 324
    if (__buflen > __cil_tmp7) {
      {
#line 325
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 325
      __cil_tmp9 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 325
      return (__cil_tmp9);
    }
  }
  {
#line 327
  __cil_tmp10 = __getlogin_r_alias(__buf, __buflen);
  }
#line 327
  return (__cil_tmp10);
}
}
#line 333
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 337
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf ,
                                                                                                 size_t __buflen ) ;
#line 344 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) gethostname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 346
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 348
    __cil_tmp4 = 0;
#line 348
    if (! __cil_tmp4) {
      {
#line 349
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 349
      __cil_tmp6 = __gethostname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 349
      return (__cil_tmp6);
    }
    {
#line 351
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 351
    if (__buflen > __cil_tmp7) {
      {
#line 352
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 352
      __cil_tmp9 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 352
      return (__cil_tmp9);
    }
  }
  {
#line 354
  __cil_tmp10 = __gethostname_alias(__buf, __buflen);
  }
#line 354
  return (__cil_tmp10);
}
}
#line 360
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 365
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                                                   size_t __buflen ) ;
#line 373 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__gnu_inline__)) getdomainname)(char *__buf ,
                                                                     size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 375
  __cil_tmp3 = __builtin_object_size((void *)__buf, 1);
  }
#line 375
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 377
    __cil_tmp4 = 0;
#line 377
    if (! __cil_tmp4) {
      {
#line 378
      __cil_tmp5 = __builtin_object_size((void *)__buf, 1);
#line 378
      __cil_tmp6 = __getdomainname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 378
      return (__cil_tmp6);
    }
    {
#line 380
    __cil_tmp7 = __builtin_object_size((void *)__buf, 1);
    }
#line 380
    if (__buflen > __cil_tmp7) {
      {
#line 381
      __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
#line 381
      __cil_tmp9 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 381
      return (__cil_tmp9);
    }
  }
  {
#line 383
  __cil_tmp10 = __getdomainname_alias(__buf, __buflen);
  }
#line 383
  return (__cil_tmp10);
}
}
#line 157 "/usr/include/ogg/ogg.h"
extern int ogg_stream_packetin(ogg_stream_state *os , ogg_packet *op ) ;
#line 160
extern int ogg_stream_pageout(ogg_stream_state *os , ogg_page *og ) ;
#line 162
extern int ogg_stream_flush(ogg_stream_state *os , ogg_page *og ) ;
#line 167
extern int ogg_sync_init(ogg_sync_state *oy ) ;
#line 168
extern int ogg_sync_clear(ogg_sync_state *oy ) ;
#line 169
extern int ogg_sync_reset(ogg_sync_state *oy ) ;
#line 173
extern char *ogg_sync_buffer(ogg_sync_state *oy , long size ) ;
#line 174
extern int ogg_sync_wrote(ogg_sync_state *oy , long bytes ) ;
#line 176
extern int ogg_sync_pageout(ogg_sync_state *oy , ogg_page *og ) ;
#line 177
extern int ogg_stream_pagein(ogg_stream_state *os , ogg_page *og ) ;
#line 178
extern int ogg_stream_packetout(ogg_stream_state *os , ogg_packet *op ) ;
#line 183
extern int ogg_stream_init(ogg_stream_state *os , int serialno ) ;
#line 184
extern int ogg_stream_clear(ogg_stream_state *os ) ;
#line 185
extern int ogg_stream_reset(ogg_stream_state *os ) ;
#line 196
extern int ogg_page_eos(ogg_page *og ) ;
#line 197
extern ogg_int64_t ogg_page_granulepos(ogg_page *og ) ;
#line 198
extern int ogg_page_serialno(ogg_page *og ) ;
#line 43 "/root/patchweave_donee/23/src/ogg.c"
static int ogg_close(SF_PRIVATE *psf ) ;
#line 44
static int ogg_stream_classify(SF_PRIVATE *psf , OGG_PRIVATE *odata ) ;
#line 45
static int ogg_page_classify(SF_PRIVATE *psf , ogg_page *og ) ;
#line 48 "/root/patchweave_donee/23/src/ogg.c"
int ogg_open(SF_PRIVATE *psf ) 
{ 
  OGG_PRIVATE *odata ;
  void *__cil_tmp3 ;
  sf_count_t pos ;
  sf_count_t __cil_tmp5 ;
  int error ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 49
  __cil_tmp3 = calloc(1UL, sizeof(OGG_PRIVATE ));
#line 49
  odata = (OGG_PRIVATE *)__cil_tmp3;
#line 50
  __cil_tmp5 = psf_ftell(psf);
#line 50
  pos = __cil_tmp5;
#line 51
  error = 0;
#line 53
  psf->container_data = (void *)odata;
#line 54
  psf->container_close = & ogg_close;
  }
#line 56
  if (psf->file.mode == 48) {
#line 57
    return (24);
  }
#line 59
  if (psf->file.mode == 16) {
    {
#line 60
    error = ogg_stream_classify(psf, odata);
    }
#line 60
    if (error != 0) {
#line 61
      return (error);
    }
  }
  {
#line 64
  ogg_sync_clear(& odata->osync);
#line 65
  ogg_stream_clear(& odata->ostream);
#line 66
  psf_fseek(psf, pos, 0);
  }
#line 68
  if ((psf->sf.format & 805306368) != 0) {
#line 69
    return (32);
  }
#line 72
  if (psf->sf.format == 2097248) {
#line 72
    goto case_2097248;
  }
#line 75
  if (psf->sf.format == 83886081) {
#line 75
    goto case_83886081;
  }
#line 90
  goto switch_default;
  case_2097248: 
  {
#line 73
  __cil_tmp8 = ogg_vorbis_open(psf);
  }
#line 73
  return (__cil_tmp8);
  case_83886081: 
  {
#line 76
  free(psf->container_data);
#line 77
  psf->container_data = (void *)0;
#line 78
  psf->container_close = (int (*)(struct sf_private_tag * ))((void *)0);
#line 79
  __cil_tmp9 = flac_open(psf);
  }
#line 79
  return (__cil_tmp9);
  switch_default: 
#line 91
  goto switch_break;
  switch_break: 
  {
#line 94
  psf_log_printf(psf, "%s : bad psf->sf.format 0x%x.\n", "ogg_open\312\001@", psf->sf.format);
  }
#line 95
  return (30);
}
}
#line 100 "/root/patchweave_donee/23/src/ogg.c"
static int ogg_close(SF_PRIVATE *psf ) 
{ 
  OGG_PRIVATE *odata ;

  {
  {
#line 101
  odata = (OGG_PRIVATE *)psf->container_data;
#line 103
  ogg_sync_clear(& odata->osync);
#line 104
  ogg_stream_clear(& odata->ostream);
  }
#line 106
  return (0);
}
}
#line 110 "/root/patchweave_donee/23/src/ogg.c"
static int ogg_stream_classify(SF_PRIVATE *psf , OGG_PRIVATE *odata ) 
{ 
  char *buffer ;
  int bytes ;
  int nn ;
  sf_count_t __cil_tmp7 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 115
  ogg_sync_init(& odata->osync);
#line 117
  odata->eos = 0;
#line 120
  ogg_stream_reset(& odata->ostream);
#line 121
  ogg_sync_reset(& odata->osync);
#line 131
  buffer = ogg_sync_buffer(& odata->osync, 4096L);
#line 134
  memcpy((void *)buffer, (void const   *)(psf->header), (unsigned long )psf->headindex);
#line 135
  bytes = psf->headindex;
#line 138
  __cil_tmp7 = psf_fread((void *)(buffer + psf->headindex), (sf_count_t )1, (sf_count_t )(4096 - psf->headindex),
                         psf);
#line 138
  bytes = (int )((sf_count_t )bytes + __cil_tmp7);
#line 139
  ogg_sync_wrote(& odata->osync, (long )bytes);
#line 142
  nn = ogg_sync_pageout(& odata->osync, & odata->opage);
  }
#line 142
  if (nn != 1) {
#line 145
    if (bytes < 4096) {
#line 146
      return (0);
    }
    {
#line 149
    psf_log_printf(psf, "Input does not appear to be an Ogg bitstream.\n");
    }
#line 150
    return (3);
  }
  {
#line 157
  ogg_stream_clear(& odata->ostream);
#line 158
  __cil_tmp9 = ogg_page_serialno(& odata->opage);
#line 158
  ogg_stream_init(& odata->ostream, __cil_tmp9);
#line 160
  __cil_tmp10 = ogg_stream_pagein(& odata->ostream, & odata->opage);
  }
#line 160
  if (__cil_tmp10 < 0) {
    {
#line 162
    psf_log_printf(psf, "Error reading first page of Ogg bitstream data\n");
    }
#line 163
    return (3);
  }
  {
#line 166
  __cil_tmp11 = ogg_stream_packetout(& odata->ostream, & odata->opacket);
  }
#line 166
  if (__cil_tmp11 != 1) {
    {
#line 168
    psf_log_printf(psf, "Error reading initial header packet.\n");
    }
#line 169
    return (3);
  }
  {
#line 172
  odata->codec = ogg_page_classify(psf, & odata->opage);
  }
#line 175
  if (odata->codec == 306) {
#line 175
    goto case_306;
  }
#line 180
  if (odata->codec == 303) {
#line 180
    goto case_303;
  }
#line 180
  if (odata->codec == 302) {
#line 180
    goto case_303;
  }
#line 184
  if (odata->codec == 305) {
#line 184
    goto case_305;
  }
#line 188
  if (odata->codec == 304) {
#line 188
    goto case_304;
  }
#line 192
  goto switch_default;
  case_306: 
#line 176
  psf->sf.format = 2097248;
#line 177
  return (0);
  case_303: 
#line 181
  psf->sf.format = 83886081;
#line 182
  return (0);
  case_305: 
#line 185
  psf->sf.format = 85983232;
#line 186
  return (0);
  case_304: 
  {
#line 189
  psf_log_printf(psf, "Detected Ogg/PCM data. This is not supported yet.\n");
  }
#line 190
  return (18);
  switch_default: 
#line 193
  goto switch_break;
  switch_break: 
  {
#line 196
  psf_log_printf(psf, "This Ogg bitstream contains some uknown data type.\n");
  }
#line 197
  return (18);
}
}
#line 206 "/root/patchweave_donee/23/src/ogg.c"
static struct __anonstruct_286 codec_lookup[7]  = {      {"Annodex", "Annodex", 8, 300}, 
        {"AnxData", "AnxData", 7, 301}, 
        {"\177FLAC", "Flac1", 5, 302}, 
        {"fLaC", "Flac0", 4, 303}, 
        {"PCM     \323\001 ", "PCM", 8, 304}, 
        {"Speex", "Speex", 5, 305}, 
        {"\001vorbis", "Vorbis", 7, 306}};
#line 217 "/root/patchweave_donee/23/src/ogg.c"
static int ogg_page_classify(SF_PRIVATE *psf , ogg_page *og ) 
{ 
  int k ;
  int len ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  long tmp ;
  unsigned short const   **__cil_tmp9 ;
  int tmp___0 ;

  {
#line 220
  k = 0;
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 220
    if (! (k < (int )(sizeof(codec_lookup) / sizeof(codec_lookup[0])))) {
#line 220
      goto while_break;
    }
#line 221
    if ((long )codec_lookup[k].len > og->body_len) {
#line 222
      goto while_continue;
    }
    {
#line 224
    __cil_tmp5 = memcmp((void const   *)og->body, (void const   *)codec_lookup[k].str,
                        (unsigned long )codec_lookup[k].len);
    }
#line 224
    if (__cil_tmp5 == 0) {
      {
#line 225
      psf_log_printf(psf, "Ogg stream data : %s\n", codec_lookup[k].name);
#line 226
      __cil_tmp6 = ogg_page_serialno(og);
#line 226
      psf_log_printf(psf, "Stream serialno : %u\n", (uint32_t )__cil_tmp6);
      }
#line 227
      return (codec_lookup[k].codec);
    }
#line 220
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 231
  if (og->body_len < 8L) {
#line 231
    tmp = og->body_len;
  } else {
#line 231
    tmp = 8L;
  }
  {
#line 231
  len = (int )tmp;
#line 233
  psf_log_printf(psf, "Ogg_stream data : \'");
#line 234
  k = 0;
  }
  {
#line 234
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 234
    if (! (k < len)) {
#line 234
      goto while_break___0;
    }
    {
#line 235
    __cil_tmp9 = __ctype_b_loc();
    }
#line 235
    if ((int )*(*__cil_tmp9 + (int )*(og->body + k)) & 16384) {
#line 235
      tmp___0 = (int )*(og->body + k);
    } else {
#line 235
      tmp___0 = '.';
    }
    {
#line 235
    psf_log_printf(psf, "%c", tmp___0);
#line 234
    k ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 236
  psf_log_printf(psf, "\'     ");
#line 237
  k = 0;
  }
  {
#line 237
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 237
    if (! (k < len)) {
#line 237
      goto while_break___1;
    }
    {
#line 238
    psf_log_printf(psf, " %02x", (int )*(og->body + k) & 255);
#line 237
    k ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 239
  psf_log_printf(psf, "\n");
  }
#line 241
  return (0);
}
}
#line 284 "/root/patchweave_donee/23/src/wav_w64.h"
void msadpcm_write_adapt_coeffs(SF_PRIVATE *psf ) ;
#line 290
int wav_w64_srate2blocksize(int srate_chan_product ) ;
#line 291
char const   *wav_w64_format_str(int k ) ;
#line 292
int wav_w64_read_fmt_chunk(SF_PRIVATE *psf , int fmtsize ) ;
#line 293
void wavex_write_guid(SF_PRIVATE *psf , EXT_SUBFORMAT *subformat ) ;
#line 294
void wav_w64_analyze(SF_PRIVATE *psf ) ;
#line 295
int wavex_gen_channel_mask(int const   *chan_map , int channels ) ;
#line 297
int wav_read_bext_chunk(SF_PRIVATE *psf , uint32_t chunksize ) ;
#line 298
int wav_write_bext_chunk(SF_PRIVATE *psf ) ;
#line 300
int wav_read_cart_chunk(SF_PRIVATE *psf , uint32_t chunksize ) ;
#line 301
int wav_write_cart_chunk(SF_PRIVATE *psf ) ;
#line 55 "/root/patchweave_donee/23/src/ms_adpcm.c"
static int AdaptationTable[16]  = 
#line 55 "/root/patchweave_donee/23/src/ms_adpcm.c"
  {      230,      230,      230,      230, 
        307,      409,      512,      614, 
        768,      614,      512,      409, 
        307,      230,      230,      230};
#line 64 "/root/patchweave_donee/23/src/ms_adpcm.c"
static int AdaptCoeff1[7]  = {      256,      512,      0,      192, 
        240,      460,      392};
#line 68 "/root/patchweave_donee/23/src/ms_adpcm.c"
static int AdaptCoeff2[7]  = {      0,      -256,      0,      64, 
        0,      -208,      -232};
#line 101
static int msadpcm_decode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) ;
#line 102
static sf_count_t msadpcm_read_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short *ptr ,
                                     int len ) ;
#line 104
static int msadpcm_encode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) ;
#line 105
static sf_count_t msadpcm_write_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short const   *ptr ,
                                      int len ) ;
#line 107
static sf_count_t msadpcm_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 108
static sf_count_t msadpcm_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 109
static sf_count_t msadpcm_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 110
static sf_count_t msadpcm_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 112
static sf_count_t msadpcm_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 113
static sf_count_t msadpcm_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 114
static sf_count_t msadpcm_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 115
static sf_count_t msadpcm_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 117
static sf_count_t msadpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 118
static int msadpcm_close(SF_PRIVATE *psf ) ;
#line 120
static void choose_predictor(unsigned int channels , short *data , int *block_pred ,
                             int *idelta ) ;
#line 127 "/root/patchweave_donee/23/src/ms_adpcm.c"
int wav_w64_msadpcm_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  MSADPCM_PRIVATE *pms ;
  unsigned int pmssize ;
  int count ;

  {
#line 132
  if ((unsigned long )psf->codec_data != (unsigned long )((void *)0)) {
    {
#line 133
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n");
    }
#line 134
    return (30);
  }
#line 137
  if (psf->file.mode == 32) {
#line 138
    samplesperblock = 2 + (2 * (blockalign - 7 * psf->sf.channels)) / psf->sf.channels;
  }
#line 140
  if (blockalign < 7 * psf->sf.channels) {
    {
#line 141
    psf_log_printf(psf, "*** Error blockalign (%d) should be > %d.\n", blockalign,
                   7 * psf->sf.channels);
    }
#line 142
    return (30);
  }
  {
#line 145
  pmssize = (unsigned int )((sizeof(MSADPCM_PRIVATE ) + (unsigned long )blockalign) + (unsigned long )((3 * psf->sf.channels) * samplesperblock));
#line 147
  psf->codec_data = calloc(1UL, (unsigned long )pmssize);
  }
#line 147
  if (! psf->codec_data) {
#line 148
    return (17);
  }
#line 149
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 151
  pms->sync_error = 0;
#line 152
  pms->samples = pms->dummydata;
#line 153
  pms->block = (unsigned char *)(pms->dummydata + psf->sf.channels * samplesperblock);
#line 155
  pms->channels = psf->sf.channels;
#line 156
  pms->blocksize = blockalign;
#line 157
  pms->samplesperblock = samplesperblock;
#line 159
  if (pms->blocksize <= 0) {
    {
#line 160
    psf_log_printf(psf, "*** Error : pms->blocksize should be > 0.\n");
    }
#line 161
    return (30);
  }
#line 164
  if (psf->file.mode == 16) {
#line 165
    pms->dataremaining = (int )psf->datalength;
#line 167
    if (psf->datalength % (long )pms->blocksize) {
#line 168
      pms->blocks = (int )(psf->datalength / (long )pms->blocksize + 1L);
    } else {
#line 170
      pms->blocks = (int )(psf->datalength / (long )pms->blocksize);
    }
#line 172
    count = (2 * (pms->blocksize - 6 * pms->channels)) / pms->channels;
#line 173
    if (pms->samplesperblock != count) {
      {
#line 174
      psf_log_printf(psf, "*** Error : samplesperblock should be %d.\n", count);
      }
#line 175
      return (30);
    }
    {
#line 178
    psf->sf.frames = (psf->datalength / (long )pms->blocksize) * (long )pms->samplesperblock;
#line 180
    msadpcm_decode_block(psf, pms);
#line 182
    psf->read_short = & msadpcm_read_s;
#line 183
    psf->read_int = & msadpcm_read_i;
#line 184
    psf->read_float = & msadpcm_read_f;
#line 185
    psf->read_double = & msadpcm_read_d;
    }
  }
#line 188
  if (psf->file.mode == 32) {
#line 189
    pms->samples = pms->dummydata;
#line 191
    pms->samplecount = (sf_count_t )0;
#line 193
    psf->write_short = & msadpcm_write_s;
#line 194
    psf->write_int = & msadpcm_write_i;
#line 195
    psf->write_float = & msadpcm_write_f;
#line 196
    psf->write_double = & msadpcm_write_d;
  }
#line 199
  psf->codec_close = & msadpcm_close;
#line 200
  psf->seek = & msadpcm_seek;
#line 202
  return (0);
}
}
#line 207 "/root/patchweave_donee/23/src/ms_adpcm.c"
__inline static short msadpcm_get_bpred(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , unsigned char value ) 
{ 


  {
#line 208
  if ((int )value >= 7) {
#line 209
    if (pms->sync_error == 0) {
      {
#line 210
      pms->sync_error = 1;
#line 211
      psf_log_printf(psf, "MS ADPCM synchronisation error (%u should be < %u).\n",
                     (int )value, 7);
      }
    }
#line 213
    return ((short)0);
  }
#line 215
  return ((short )value);
}
}
#line 220 "/root/patchweave_donee/23/src/ms_adpcm.c"
static int msadpcm_decode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) 
{ 
  int chan ;
  int k ;
  int blockindx ;
  int sampleindx ;
  short bytecode ;
  short bpred[2] ;
  short chan_idelta[2] ;
  int predict ;
  int current ;
  int idelta ;
  sf_count_t __cil_tmp14 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;

  {
#line 228
  (pms->blockcount) ++;
#line 229
  pms->samplecount = (sf_count_t )0;
#line 231
  if (pms->blockcount > pms->blocks) {
    {
#line 232
    memset((void *)pms->samples, 0, (unsigned long )(pms->samplesperblock * pms->channels));
    }
#line 233
    return (1);
  }
  {
#line 236
  __cil_tmp14 = psf_fread((void *)pms->block, (sf_count_t )1, (sf_count_t )pms->blocksize,
                          psf);
#line 236
  k = (int )__cil_tmp14;
  }
#line 236
  if (k != pms->blocksize) {
    {
#line 237
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, pms->blocksize);
    }
#line 238
    if (k <= 0) {
#line 239
      return (1);
    }
  }
#line 244
  if (pms->channels == 1) {
    {
#line 245
    bpred[0] = msadpcm_get_bpred(psf, pms, *(pms->block + 0));
#line 247
    chan_idelta[0] = (short )((int )*(pms->block + 1) | ((int )*(pms->block + 2) << 8));
#line 248
    chan_idelta[1] = (short)0;
#line 250
    *(pms->samples + 1) = (short )((int )*(pms->block + 3) | ((int )*(pms->block + 4) << 8));
#line 251
    *(pms->samples + 0) = (short )((int )*(pms->block + 5) | ((int )*(pms->block + 6) << 8));
#line 252
    blockindx = 7;
    }
  } else {
    {
#line 255
    bpred[0] = msadpcm_get_bpred(psf, pms, *(pms->block + 0));
#line 256
    bpred[1] = msadpcm_get_bpred(psf, pms, *(pms->block + 1));
#line 258
    chan_idelta[0] = (short )((int )*(pms->block + 2) | ((int )*(pms->block + 3) << 8));
#line 259
    chan_idelta[1] = (short )((int )*(pms->block + 4) | ((int )*(pms->block + 5) << 8));
#line 261
    *(pms->samples + 2) = (short )((int )*(pms->block + 6) | ((int )*(pms->block + 7) << 8));
#line 262
    *(pms->samples + 3) = (short )((int )*(pms->block + 8) | ((int )*(pms->block + 9) << 8));
#line 264
    *(pms->samples + 0) = (short )((int )*(pms->block + 10) | ((int )*(pms->block + 11) << 8));
#line 265
    *(pms->samples + 1) = (short )((int )*(pms->block + 12) | ((int )*(pms->block + 13) << 8));
#line 267
    blockindx = 14;
    }
  }
#line 285
  sampleindx = 2 * pms->channels;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;

#line 286
    if (! (blockindx < pms->blocksize)) {
#line 286
      goto while_break;
    }
#line 287
    __cil_tmp18 = blockindx;
#line 287
    blockindx ++;
#line 287
    bytecode = (short )*(pms->block + __cil_tmp18);
#line 288
    __cil_tmp19 = sampleindx;
#line 288
    sampleindx ++;
#line 288
    *(pms->samples + __cil_tmp19) = (short )(((int )bytecode >> 4) & 15);
#line 289
    __cil_tmp20 = sampleindx;
#line 289
    sampleindx ++;
#line 289
    *(pms->samples + __cil_tmp20) = (short )((int )bytecode & 15);
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 294
  k = 2 * pms->channels;
  {
#line 294
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 294
    if (! (k < pms->samplesperblock * pms->channels)) {
#line 294
      goto while_break___0;
    }
#line 295
    if (pms->channels > 1) {
#line 295
      tmp = k % 2;
    } else {
#line 295
      tmp = 0;
    }
#line 295
    chan = tmp;
#line 297
    bytecode = (short )((int )*(pms->samples + k) & 15);
#line 300
    idelta = (int )chan_idelta[chan];
#line 301
    chan_idelta[chan] = (short )(AdaptationTable[bytecode] * idelta >> 8);
#line 302
    if ((int )chan_idelta[chan] < 16) {
#line 303
      chan_idelta[chan] = (short)16;
    }
#line 304
    if ((int )bytecode & 8) {
#line 305
      bytecode = (short )((int )bytecode - 16);
    }
#line 307
    predict = ((int )*(pms->samples + (k - pms->channels)) * AdaptCoeff1[bpred[chan]] + (int )*(pms->samples + (k - 2 * pms->channels)) * AdaptCoeff2[bpred[chan]]) >> 8;
#line 309
    current = (int )bytecode * idelta + predict;
#line 311
    if (current > 32767) {
#line 312
      current = 32767;
    } else
#line 313
    if (current < -32768) {
#line 314
      current = -32768;
    }
#line 316
    *(pms->samples + k) = (short )current;
#line 294
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 319
  return (0);
}
}
#line 323 "/root/patchweave_donee/23/src/ms_adpcm.c"
static sf_count_t msadpcm_read_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short *ptr ,
                                     int len ) 
{ 
  int count ;
  int total ;
  int indx ;
  int __cil_tmp8 ;
  int tmp ;

  {
#line 324
  total = 0;
#line 324
  indx = 0;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;

#line 326
    if (! (indx < len)) {
#line 326
      goto while_break;
    }
#line 327
    if (pms->blockcount >= pms->blocks) {
#line 327
      if (pms->samplecount >= (long )pms->samplesperblock) {
        {
#line 328
        memset((void *)(ptr + indx), 0, (unsigned long )(len - indx) * sizeof(short ));
        }
#line 329
        return ((sf_count_t )total);
      }
    }
#line 332
    if (pms->samplecount >= (long )pms->samplesperblock) {
      {
#line 333
      __cil_tmp8 = msadpcm_decode_block(psf, pms);
      }
#line 333
      if (__cil_tmp8 != 0) {
#line 334
        return ((sf_count_t )total);
      }
    }
#line 336
    count = (int )(((long )pms->samplesperblock - pms->samplecount) * (long )pms->channels);
#line 337
    if (len - indx > count) {
#line 337
      tmp = count;
    } else {
#line 337
      tmp = len - indx;
    }
    {
#line 337
    count = tmp;
#line 339
    memcpy((void *)(ptr + indx), (void const   *)(pms->samples + pms->samplecount * (long )pms->channels),
           (unsigned long )count * sizeof(short ));
#line 340
    indx += count;
#line 341
    pms->samplecount += (long )(count / pms->channels);
#line 342
    total = indx;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 345
  return ((sf_count_t )total);
}
}
#line 349 "/root/patchweave_donee/23/src/ms_adpcm.c"
static sf_count_t msadpcm_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 352
  total = (sf_count_t )0;
#line 354
  if (! psf->codec_data) {
#line 355
    return ((sf_count_t )0);
  }
#line 356
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;

#line 358
    if (! (len > 0L)) {
#line 358
      goto while_break;
    }
#line 359
    if (len > 268435456L) {
#line 359
      tmp = 268435456;
    } else {
#line 359
      tmp = (int )len;
    }
    {
#line 359
    readcount = tmp;
#line 361
    __cil_tmp9 = msadpcm_read_block(psf, pms, ptr, readcount);
#line 361
    count = (int )__cil_tmp9;
    }
#line 361
    if (count <= 0) {
#line 362
      return ((sf_count_t )-1);
    }
#line 364
    total += (long )count;
#line 365
    len -= (long )count;
#line 366
    if (count != readcount) {
#line 367
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 370
  return (total);
}
}
#line 374 "/root/patchweave_donee/23/src/ms_adpcm.c"
static sf_count_t msadpcm_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  sf_count_t __cil_tmp13 ;

  {
#line 378
  readcount = 0;
#line 379
  total = (sf_count_t )0;
#line 381
  if (! psf->codec_data) {
#line 382
    return ((sf_count_t )0);
  }
#line 383
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 385
  sptr = ubuf.sbuf;
#line 386
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;

#line 387
    if (! (len > 0L)) {
#line 387
      goto while_break;
    }
#line 388
    if (len >= (long )bufferlen) {
#line 388
      tmp = (long )bufferlen;
    } else {
#line 388
      tmp = len;
    }
    {
#line 388
    readcount = (int )tmp;
#line 390
    __cil_tmp13 = msadpcm_read_block(psf, pms, sptr, readcount);
#line 390
    count = (int )__cil_tmp13;
    }
#line 390
    if (count <= 0) {
#line 391
      return ((sf_count_t )-1);
    }
#line 393
    k = 0;
    {
#line 393
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 393
      if (! (k < readcount)) {
#line 393
        goto while_break___0;
      }
      {
#line 394
      *(ptr + (total + (long )k)) = arith_shift_left((int32_t )*(sptr + k), 16);
#line 393
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 395
    total += (long )count;
#line 396
    len -= (long )readcount;
#line 397
    if (count != readcount) {
#line 398
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 400
  return (total);
}
}
#line 404 "/root/patchweave_donee/23/src/ms_adpcm.c"
static sf_count_t msadpcm_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  sf_count_t __cil_tmp15 ;

  {
#line 408
  readcount = 0;
#line 409
  total = (sf_count_t )0;
#line 412
  if (! psf->codec_data) {
#line 413
    return ((sf_count_t )0);
  }
#line 414
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 416
  if (psf->norm_float == 1) {
#line 416
    tmp = 1. / (double )((float )32768);
  } else {
#line 416
    tmp = 1.;
  }
#line 416
  normfact = (float )tmp;
#line 417
  sptr = ubuf.sbuf;
#line 418
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;

#line 419
    if (! (len > 0L)) {
#line 419
      goto while_break;
    }
#line 420
    if (len >= (long )bufferlen) {
#line 420
      tmp___0 = (long )bufferlen;
    } else {
#line 420
      tmp___0 = len;
    }
    {
#line 420
    readcount = (int )tmp___0;
#line 422
    __cil_tmp15 = msadpcm_read_block(psf, pms, sptr, readcount);
#line 422
    count = (int )__cil_tmp15;
    }
#line 422
    if (count <= 0) {
#line 423
      return ((sf_count_t )-1);
    }
#line 425
    k = 0;
    {
#line 425
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 425
      if (! (k < readcount)) {
#line 425
        goto while_break___0;
      }
#line 426
      *(ptr + (total + (long )k)) = normfact * (float )*(sptr + k);
#line 425
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 427
    total += (long )count;
#line 428
    len -= (long )readcount;
#line 429
    if (count != readcount) {
#line 430
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 432
  return (total);
}
}
#line 436 "/root/patchweave_donee/23/src/ms_adpcm.c"
static sf_count_t msadpcm_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  sf_count_t __cil_tmp15 ;

  {
#line 440
  readcount = 0;
#line 441
  total = (sf_count_t )0;
#line 444
  if (! psf->codec_data) {
#line 445
    return ((sf_count_t )0);
  }
#line 446
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 448
  if (psf->norm_double == 1) {
#line 448
    tmp = 1. / (double )32768;
  } else {
#line 448
    tmp = 1.;
  }
#line 448
  normfact = tmp;
#line 449
  sptr = ubuf.sbuf;
#line 450
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;

#line 451
    if (! (len > 0L)) {
#line 451
      goto while_break;
    }
#line 452
    if (len >= (long )bufferlen) {
#line 452
      tmp___0 = (long )bufferlen;
    } else {
#line 452
      tmp___0 = len;
    }
    {
#line 452
    readcount = (int )tmp___0;
#line 454
    __cil_tmp15 = msadpcm_read_block(psf, pms, sptr, readcount);
#line 454
    count = (int )__cil_tmp15;
    }
#line 454
    if (count <= 0) {
#line 455
      return ((sf_count_t )-1);
    }
#line 457
    k = 0;
    {
#line 457
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 457
      if (! (k < readcount)) {
#line 457
        goto while_break___0;
      }
#line 458
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 457
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 459
    total += (long )count;
#line 460
    len -= (long )readcount;
#line 461
    if (count != readcount) {
#line 462
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 465
  return (total);
}
}
#line 469 "/root/patchweave_donee/23/src/ms_adpcm.c"
static sf_count_t msadpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  MSADPCM_PRIVATE *pms ;
  int newblock ;
  int newsample ;

  {
#line 473
  if (! psf->codec_data) {
#line 474
    return ((sf_count_t )0);
  }
#line 475
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 477
  if (psf->datalength < 0L) {
#line 478
    psf->error = 39;
#line 479
    return ((sf_count_t )-1);
  } else
#line 477
  if (psf->dataoffset < 0L) {
#line 478
    psf->error = 39;
#line 479
    return ((sf_count_t )-1);
  }
#line 482
  if (offset == 0L) {
    {
#line 483
    psf_fseek(psf, psf->dataoffset, 0);
#line 484
    pms->blockcount = 0;
#line 485
    msadpcm_decode_block(psf, pms);
#line 486
    pms->samplecount = (sf_count_t )0;
    }
#line 487
    return ((sf_count_t )0);
  }
#line 490
  if (offset < 0L) {
#line 491
    psf->error = 39;
#line 492
    return ((sf_count_t )-1);
  } else
#line 490
  if (offset > (long )(pms->blocks * pms->samplesperblock)) {
#line 491
    psf->error = 39;
#line 492
    return ((sf_count_t )-1);
  }
#line 495
  newblock = (int )(offset / (long )pms->samplesperblock);
#line 496
  newsample = (int )(offset % (long )pms->samplesperblock);
#line 498
  if (mode == 16) {
    {
#line 499
    psf_fseek(psf, psf->dataoffset + (long )(newblock * pms->blocksize), 0);
#line 500
    pms->blockcount = newblock;
#line 501
    msadpcm_decode_block(psf, pms);
#line 502
    pms->samplecount = (sf_count_t )newsample;
    }
  } else {
#line 506
    psf->error = 39;
#line 507
    return ((sf_count_t )-1);
  }
#line 510
  return ((sf_count_t )(newblock * pms->samplesperblock + newsample));
}
}
#line 518 "/root/patchweave_donee/23/src/ms_adpcm.c"
void msadpcm_write_adapt_coeffs(SF_PRIVATE *psf ) 
{ 
  int k ;

  {
#line 521
  k = 0;
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;

#line 521
    if (! (k < 7)) {
#line 521
      goto while_break;
    }
    {
#line 522
    psf_binheader_writef(psf, "22", AdaptCoeff1[k], AdaptCoeff2[k]);
#line 521
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 525
  return;
}
}
#line 529 "/root/patchweave_donee/23/src/ms_adpcm.c"
static int msadpcm_encode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) 
{ 
  unsigned int blockindx ;
  unsigned char byte ;
  int chan ;
  int k ;
  int predict ;
  int bpred[2] ;
  int idelta[2] ;
  int errordelta ;
  int newsamp ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp14 ;
  sf_count_t __cil_tmp16 ;

  {
  {
#line 534
  choose_predictor((unsigned int )pms->channels, pms->samples, bpred, idelta);
  }
#line 538
  if (pms->channels == 1) {
#line 539
    *(pms->block + 0) = (unsigned char )bpred[0];
#line 540
    *(pms->block + 1) = (unsigned char )(idelta[0] & 255);
#line 541
    *(pms->block + 2) = (unsigned char )(idelta[0] >> 8);
#line 542
    *(pms->block + 3) = (unsigned char )((int )*(pms->samples + 1) & 255);
#line 543
    *(pms->block + 4) = (unsigned char )((int )*(pms->samples + 1) >> 8);
#line 544
    *(pms->block + 5) = (unsigned char )((int )*(pms->samples + 0) & 255);
#line 545
    *(pms->block + 6) = (unsigned char )((int )*(pms->samples + 0) >> 8);
#line 547
    blockindx = 7U;
#line 548
    byte = (unsigned char)0;
#line 552
    k = 2;
    {
#line 552
    while (1) {
      while_continue: /* CIL Label */ ;

#line 552
      if (! (k < pms->samplesperblock)) {
#line 552
        goto while_break;
      }
#line 553
      predict = ((int )*(pms->samples + (k - 1)) * AdaptCoeff1[bpred[0]] + (int )*(pms->samples + (k - 2)) * AdaptCoeff2[bpred[0]]) >> 8;
#line 554
      errordelta = ((int )*(pms->samples + k) - predict) / idelta[0];
#line 555
      if (errordelta < -8) {
#line 556
        errordelta = -8;
      } else
#line 557
      if (errordelta > 7) {
#line 558
        errordelta = 7;
      }
#line 559
      newsamp = predict + idelta[0] * errordelta;
#line 560
      if (newsamp > 32767) {
#line 561
        newsamp = 32767;
      } else
#line 562
      if (newsamp < -32768) {
#line 563
        newsamp = -32768;
      }
#line 564
      if (errordelta < 0) {
#line 565
        errordelta += 16;
      }
#line 567
      byte = (unsigned char )(((int )byte << 4) | (errordelta & 15));
#line 568
      if (k % 2) {
#line 569
        __cil_tmp12 = blockindx;
#line 569
        blockindx ++;
#line 569
        *(pms->block + __cil_tmp12) = byte;
#line 570
        byte = (unsigned char)0;
      }
#line 573
      idelta[0] = idelta[0] * AdaptationTable[errordelta] >> 8;
#line 574
      if (idelta[0] < 16) {
#line 575
        idelta[0] = 16;
      }
#line 576
      *(pms->samples + k) = (short )newsamp;
#line 552
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 581
    *(pms->block + 0) = (unsigned char )bpred[0];
#line 582
    *(pms->block + 1) = (unsigned char )bpred[1];
#line 584
    *(pms->block + 2) = (unsigned char )(idelta[0] & 255);
#line 585
    *(pms->block + 3) = (unsigned char )(idelta[0] >> 8);
#line 586
    *(pms->block + 4) = (unsigned char )(idelta[1] & 255);
#line 587
    *(pms->block + 5) = (unsigned char )(idelta[1] >> 8);
#line 589
    *(pms->block + 6) = (unsigned char )((int )*(pms->samples + 2) & 255);
#line 590
    *(pms->block + 7) = (unsigned char )((int )*(pms->samples + 2) >> 8);
#line 591
    *(pms->block + 8) = (unsigned char )((int )*(pms->samples + 3) & 255);
#line 592
    *(pms->block + 9) = (unsigned char )((int )*(pms->samples + 3) >> 8);
#line 594
    *(pms->block + 10) = (unsigned char )((int )*(pms->samples + 0) & 255);
#line 595
    *(pms->block + 11) = (unsigned char )((int )*(pms->samples + 0) >> 8);
#line 596
    *(pms->block + 12) = (unsigned char )((int )*(pms->samples + 1) & 255);
#line 597
    *(pms->block + 13) = (unsigned char )((int )*(pms->samples + 1) >> 8);
#line 599
    blockindx = 14U;
#line 600
    byte = (unsigned char)0;
#line 601
    chan = 1;
#line 603
    k = 4;
    {
#line 603
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 603
      if (! (k < 2 * pms->samplesperblock)) {
#line 603
        goto while_break___0;
      }
#line 604
      chan = k & 1;
#line 606
      predict = ((int )*(pms->samples + (k - 2)) * AdaptCoeff1[bpred[chan]] + (int )*(pms->samples + (k - 4)) * AdaptCoeff2[bpred[chan]]) >> 8;
#line 607
      errordelta = ((int )*(pms->samples + k) - predict) / idelta[chan];
#line 610
      if (errordelta < -8) {
#line 611
        errordelta = -8;
      } else
#line 612
      if (errordelta > 7) {
#line 613
        errordelta = 7;
      }
#line 614
      newsamp = predict + idelta[chan] * errordelta;
#line 615
      if (newsamp > 32767) {
#line 616
        newsamp = 32767;
      } else
#line 617
      if (newsamp < -32768) {
#line 618
        newsamp = -32768;
      }
#line 619
      if (errordelta < 0) {
#line 620
        errordelta += 16;
      }
#line 622
      byte = (unsigned char )(((int )byte << 4) | (errordelta & 15));
#line 624
      if (chan) {
#line 625
        __cil_tmp14 = blockindx;
#line 625
        blockindx ++;
#line 625
        *(pms->block + __cil_tmp14) = byte;
#line 626
        byte = (unsigned char)0;
      }
#line 629
      idelta[chan] = idelta[chan] * AdaptationTable[errordelta] >> 8;
#line 630
      if (idelta[chan] < 16) {
#line 631
        idelta[chan] = 16;
      }
#line 632
      *(pms->samples + k) = (short )newsamp;
#line 603
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  {
#line 638
  __cil_tmp16 = psf_fwrite((void const   *)pms->block, (sf_count_t )1, (sf_count_t )pms->blocksize,
                           psf);
#line 638
  k = (int )__cil_tmp16;
  }
#line 638
  if (k != pms->blocksize) {
    {
#line 639
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pms->blocksize);
    }
  }
  {
#line 641
  memset((void *)pms->samples, 0, (unsigned long )pms->samplesperblock * sizeof(short ));
#line 643
  (pms->blockcount) ++;
#line 644
  pms->samplecount = (sf_count_t )0;
  }
#line 646
  return (1);
}
}
#line 650 "/root/patchweave_donee/23/src/ms_adpcm.c"
static sf_count_t msadpcm_write_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short const   *ptr ,
                                      int len ) 
{ 
  int count ;
  int total ;
  int indx ;

  {
#line 651
  total = 0;
#line 651
  indx = 0;
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;

#line 653
    if (! (indx < len)) {
#line 653
      goto while_break;
    }
#line 654
    count = (int )(((long )pms->samplesperblock - pms->samplecount) * (long )pms->channels);
#line 656
    if (count > len - indx) {
#line 657
      count = len - indx;
    }
    {
#line 659
    memcpy((void *)(pms->samples + pms->samplecount * (long )pms->channels), (void const   *)(ptr + total),
           (unsigned long )count * sizeof(short ));
#line 660
    indx += count;
#line 661
    pms->samplecount += (long )(count / pms->channels);
#line 662
    total = indx;
    }
#line 664
    if (pms->samplecount >= (long )pms->samplesperblock) {
      {
#line 665
      msadpcm_encode_block(psf, pms);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 668
  return ((sf_count_t )total);
}
}
#line 672 "/root/patchweave_donee/23/src/ms_adpcm.c"
static sf_count_t msadpcm_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 675
  total = (sf_count_t )0;
#line 677
  if (! psf->codec_data) {
#line 678
    return ((sf_count_t )0);
  }
#line 679
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;

#line 681
    if (! (len > 0L)) {
#line 681
      goto while_break;
    }
#line 682
    if (len > 268435456L) {
#line 682
      tmp = 268435456;
    } else {
#line 682
      tmp = (int )len;
    }
    {
#line 682
    writecount = tmp;
#line 684
    __cil_tmp9 = msadpcm_write_block(psf, pms, ptr, writecount);
#line 684
    count = (int )__cil_tmp9;
#line 686
    total += (long )count;
#line 687
    len -= (long )count;
    }
#line 688
    if (count != writecount) {
#line 689
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 692
  return (total);
}
}
#line 696 "/root/patchweave_donee/23/src/ms_adpcm.c"
static sf_count_t msadpcm_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  sf_count_t __cil_tmp14 ;

  {
#line 701
  total = (sf_count_t )0;
#line 703
  if (! psf->codec_data) {
#line 704
    return ((sf_count_t )0);
  }
#line 705
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 707
  sptr = ubuf.sbuf;
#line 708
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;

#line 709
    if (! (len > 0L)) {
#line 709
      goto while_break;
    }
#line 710
    if (len >= (long )bufferlen) {
#line 710
      tmp = (long )bufferlen;
    } else {
#line 710
      tmp = len;
    }
#line 710
    writecount = (int )tmp;
#line 711
    k = 0;
    {
#line 711
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 711
      if (! (k < writecount)) {
#line 711
        goto while_break___0;
      }
#line 712
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 711
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 713
    __cil_tmp14 = msadpcm_write_block(psf, pms, (short const   *)sptr, writecount);
#line 713
    count = (int )__cil_tmp14;
#line 714
    total += (long )count;
#line 715
    len -= (long )writecount;
    }
#line 716
    if (count != writecount) {
#line 717
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 719
  return (total);
}
}
#line 723 "/root/patchweave_donee/23/src/ms_adpcm.c"
static sf_count_t msadpcm_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;
  sf_count_t __cil_tmp17 ;

  {
#line 728
  total = (sf_count_t )0;
#line 731
  if (! psf->codec_data) {
#line 732
    return ((sf_count_t )0);
  }
#line 733
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 735
  if (psf->norm_float == 1) {
#line 735
    tmp = 1. * (double )32767;
  } else {
#line 735
    tmp = 1.;
  }
#line 735
  normfact = (float )tmp;
#line 737
  sptr = ubuf.sbuf;
#line 738
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 739
  while (1) {
    while_continue: /* CIL Label */ ;

#line 739
    if (! (len > 0L)) {
#line 739
      goto while_break;
    }
#line 740
    if (len >= (long )bufferlen) {
#line 740
      tmp___0 = (long )bufferlen;
    } else {
#line 740
      tmp___0 = len;
    }
#line 740
    writecount = (int )tmp___0;
#line 741
    k = 0;
    {
#line 741
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 741
      if (! (k < writecount)) {
#line 741
        goto while_break___0;
      }
      {
#line 742
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 742
      *(sptr + k) = (short )__cil_tmp15;
#line 741
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 743
    __cil_tmp17 = msadpcm_write_block(psf, pms, (short const   *)sptr, writecount);
#line 743
    count = (int )__cil_tmp17;
#line 744
    total += (long )count;
#line 745
    len -= (long )writecount;
    }
#line 746
    if (count != writecount) {
#line 747
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 749
  return (total);
}
}
#line 753 "/root/patchweave_donee/23/src/ms_adpcm.c"
static sf_count_t msadpcm_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;
  sf_count_t __cil_tmp17 ;

  {
#line 758
  total = (sf_count_t )0;
#line 761
  if (psf->norm_double == 1) {
#line 761
    tmp = 1. * (double )32767;
  } else {
#line 761
    tmp = 1.;
  }
#line 761
  normfact = tmp;
#line 763
  if (! psf->codec_data) {
#line 764
    return ((sf_count_t )0);
  }
#line 765
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 767
  sptr = ubuf.sbuf;
#line 768
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 769
  while (1) {
    while_continue: /* CIL Label */ ;

#line 769
    if (! (len > 0L)) {
#line 769
      goto while_break;
    }
#line 770
    if (len >= (long )bufferlen) {
#line 770
      tmp___0 = (long )bufferlen;
    } else {
#line 770
      tmp___0 = len;
    }
#line 770
    writecount = (int )tmp___0;
#line 771
    k = 0;
    {
#line 771
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 771
      if (! (k < writecount)) {
#line 771
        goto while_break___0;
      }
      {
#line 772
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 772
      *(sptr + k) = (short )__cil_tmp15;
#line 771
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 773
    __cil_tmp17 = msadpcm_write_block(psf, pms, (short const   *)sptr, writecount);
#line 773
    count = (int )__cil_tmp17;
#line 774
    total += (long )count;
#line 775
    len -= (long )writecount;
    }
#line 776
    if (count != writecount) {
#line 777
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 779
  return (total);
}
}
#line 786 "/root/patchweave_donee/23/src/ms_adpcm.c"
static int msadpcm_close(SF_PRIVATE *psf ) 
{ 
  MSADPCM_PRIVATE *pms ;

  {
#line 789
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 791
  if (psf->file.mode == 32) {
#line 796
    if (pms->samplecount) {
#line 796
      if (pms->samplecount < (long )pms->samplesperblock) {
        {
#line 797
        msadpcm_encode_block(psf, pms);
        }
      }
    }
  }
#line 800
  return (0);
}
}
#line 826 "/root/patchweave_donee/23/src/ms_adpcm.c"
static void choose_predictor(unsigned int channels , short *data , int *block_pred ,
                             int *idelta ) 
{ 
  unsigned int chan ;
  unsigned int k ;
  unsigned int bpred ;
  unsigned int idelta_sum ;
  unsigned int best_bpred ;
  unsigned int best_idelta ;
  int __cil_tmp11 ;

  {
#line 829
  chan = 0U;
  {
#line 829
  while (1) {
    while_continue: /* CIL Label */ ;

#line 829
    if (! (chan < channels)) {
#line 829
      goto while_break;
    }
#line 830
    best_idelta = 0U;
#line 830
    best_bpred = best_idelta;
#line 832
    bpred = 0U;
    {
#line 832
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 832
      if (! (bpred < 7U)) {
#line 832
        goto while_break___0;
      }
#line 833
      idelta_sum = 0U;
#line 834
      k = 2U;
      {
#line 834
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 834
        if (! (k < 5U)) {
#line 834
          goto while_break___1;
        }
        {
#line 835
        __cil_tmp11 = abs((int )*(data + k * channels) - (((int )*(data + (k - 1U) * channels) * AdaptCoeff1[bpred] + (int )*(data + (k - 2U) * channels) * AdaptCoeff2[bpred]) >> 8));
#line 835
        idelta_sum += (unsigned int )__cil_tmp11;
#line 834
        k ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 836
      idelta_sum /= 12U;
#line 838
      if (bpred == 0U) {
#line 839
        best_bpred = bpred;
#line 840
        best_idelta = idelta_sum;
      } else
#line 838
      if (idelta_sum < best_idelta) {
#line 839
        best_bpred = bpred;
#line 840
        best_idelta = idelta_sum;
      }
#line 843
      if (! idelta_sum) {
#line 844
        best_bpred = bpred;
#line 845
        best_idelta = 16U;
#line 846
        goto while_break___0;
      }
#line 832
      bpred ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 850
    if (best_idelta < 16U) {
#line 851
      best_idelta = 16U;
    }
#line 853
    *(block_pred + chan) = (int )best_bpred;
#line 854
    *(idelta + chan) = (int )best_idelta;
#line 829
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 857
  return;
}
}
#line 42 "/root/patchweave_donee/23/src/interleave.c"
static sf_count_t interleave_read_short(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 43
static sf_count_t interleave_read_int(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 44
static sf_count_t interleave_read_float(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 45
static sf_count_t interleave_read_double(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 47
static sf_count_t interleave_seek(SF_PRIVATE *UNUSED_psf , int UNUSED_mode , sf_count_t samples_from_start ) ;
#line 53 "/root/patchweave_donee/23/src/interleave.c"
int interleave_init(SF_PRIVATE *psf ) 
{ 
  INTERLEAVE_DATA *pdata ;
  void *tmp ;

  {
#line 56
  if (psf->file.mode != 16) {
#line 57
    return (36);
  }
#line 59
  if (psf->interleave) {
    {
#line 60
    psf_log_printf(psf, "*** Weird, already have interleave.\n\204U");
    }
#line 61
    return (666);
  }
  {
#line 65
  tmp = malloc(sizeof(INTERLEAVE_DATA ));
#line 65
  pdata = (INTERLEAVE_DATA *)tmp;
  }
#line 65
  if (! pdata) {
#line 66
    return (17);
  }
  {
#line 68
  puts("interleave_init");
#line 70
  psf->interleave = (void *)pdata;
#line 73
  pdata->read_short = psf->read_short;
#line 74
  pdata->read_int = psf->read_int;
#line 75
  pdata->read_float = psf->read_float;
#line 76
  pdata->read_double = psf->read_double;
#line 78
  pdata->channel_len = psf->sf.frames * (long )psf->bytewidth;
#line 81
  psf->read_short = & interleave_read_short;
#line 82
  psf->read_int = & interleave_read_int;
#line 83
  psf->read_float = & interleave_read_float;
#line 84
  psf->read_double = & interleave_read_double;
#line 86
  psf->seek = & interleave_seek;
  }
#line 88
  return (0);
}
}
#line 95 "/root/patchweave_donee/23/src/interleave.c"
static sf_count_t interleave_read_short(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  short *inptr ;
  short *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;

  {
#line 101
  pdata = (INTERLEAVE_DATA *)psf->interleave;
#line 101
  if (! pdata) {
#line 102
    return ((sf_count_t )0);
  }
#line 104
  inptr = (short *)(pdata->buffer);
#line 106
  chan = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;

#line 106
    if (! (chan < psf->sf.channels)) {
#line 106
      goto while_break;
    }
    {
#line 107
    outptr = ptr + chan;
#line 109
    offset = psf->dataoffset + (long )(chan * psf->bytewidth) * psf->read_current;
#line 111
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 111
    if (__cil_tmp12 != offset) {
#line 112
      psf->error = 37;
#line 113
      return ((sf_count_t )0);
    }
#line 116
    templen = len / (long )psf->sf.channels;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 118
      if (! (templen > 0L)) {
#line 118
        goto while_break___0;
      }
#line 119
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(short ))) {
#line 120
        count = (int )sizeof(pdata->buffer) / (int )sizeof(short );
      } else {
#line 122
        count = (int )templen;
      }
      {
#line 124
      __cil_tmp13 = (*(pdata->read_short))(psf, inptr, (sf_count_t )count);
      }
#line 124
      if (__cil_tmp13 != (long )count) {
#line 125
        psf->error = 38;
#line 126
        return ((sf_count_t )0);
      }
#line 129
      k = 0;
      {
#line 129
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 129
        if (! (k < count)) {
#line 129
          goto while_break___1;
        }
#line 130
        *outptr = *(inptr + k);
#line 131
        outptr += psf->sf.channels;
#line 129
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 134
      templen -= (long )count;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 106
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 138
  return (len);
}
}
#line 142 "/root/patchweave_donee/23/src/interleave.c"
static sf_count_t interleave_read_int(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  int *inptr ;
  int *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;

  {
#line 148
  pdata = (INTERLEAVE_DATA *)psf->interleave;
#line 148
  if (! pdata) {
#line 149
    return ((sf_count_t )0);
  }
#line 151
  inptr = (int *)(pdata->buffer);
#line 153
  chan = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;

#line 153
    if (! (chan < psf->sf.channels)) {
#line 153
      goto while_break;
    }
    {
#line 154
    outptr = ptr + chan;
#line 156
    offset = psf->dataoffset + (long )(chan * psf->bytewidth) * psf->read_current;
#line 158
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 158
    if (__cil_tmp12 != offset) {
#line 159
      psf->error = 37;
#line 160
      return ((sf_count_t )0);
    }
#line 163
    templen = len / (long )psf->sf.channels;
    {
#line 165
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 165
      if (! (templen > 0L)) {
#line 165
        goto while_break___0;
      }
#line 166
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(int ))) {
#line 167
        count = (int )sizeof(pdata->buffer) / (int )sizeof(int );
      } else {
#line 169
        count = (int )templen;
      }
      {
#line 171
      __cil_tmp13 = (*(pdata->read_int))(psf, inptr, (sf_count_t )count);
      }
#line 171
      if (__cil_tmp13 != (long )count) {
#line 172
        psf->error = 38;
#line 173
        return ((sf_count_t )0);
      }
#line 176
      k = 0;
      {
#line 176
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 176
        if (! (k < count)) {
#line 176
          goto while_break___1;
        }
#line 177
        *outptr = *(inptr + k);
#line 178
        outptr += psf->sf.channels;
#line 176
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 181
      templen -= (long )count;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 153
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 185
  return (len);
}
}
#line 189 "/root/patchweave_donee/23/src/interleave.c"
static sf_count_t interleave_read_float(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  float *inptr ;
  float *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;

  {
#line 195
  pdata = (INTERLEAVE_DATA *)psf->interleave;
#line 195
  if (! pdata) {
#line 196
    return ((sf_count_t )0);
  }
#line 198
  inptr = (float *)(pdata->buffer);
#line 200
  chan = 0;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;

#line 200
    if (! (chan < psf->sf.channels)) {
#line 200
      goto while_break;
    }
    {
#line 201
    outptr = ptr + chan;
#line 203
    offset = (psf->dataoffset + pdata->channel_len * (long )chan) + psf->read_current * (long )psf->bytewidth;
#line 207
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 207
    if (__cil_tmp12 != offset) {
#line 208
      psf->error = 37;
#line 210
      return ((sf_count_t )0);
    }
#line 213
    templen = len / (long )psf->sf.channels;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 215
      if (! (templen > 0L)) {
#line 215
        goto while_break___0;
      }
#line 216
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(float ))) {
#line 217
        count = (int )sizeof(pdata->buffer) / (int )sizeof(float );
      } else {
#line 219
        count = (int )templen;
      }
      {
#line 221
      __cil_tmp13 = (*(pdata->read_float))(psf, inptr, (sf_count_t )count);
      }
#line 221
      if (__cil_tmp13 != (long )count) {
#line 222
        psf->error = 38;
#line 224
        return ((sf_count_t )0);
      }
#line 227
      k = 0;
      {
#line 227
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 227
        if (! (k < count)) {
#line 227
          goto while_break___1;
        }
#line 228
        *outptr = *(inptr + k);
#line 229
        outptr += psf->sf.channels;
#line 227
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 232
      templen -= (long )count;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 200
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 236
  return (len);
}
}
#line 240 "/root/patchweave_donee/23/src/interleave.c"
static sf_count_t interleave_read_double(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  double *inptr ;
  double *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;

  {
#line 246
  pdata = (INTERLEAVE_DATA *)psf->interleave;
#line 246
  if (! pdata) {
#line 247
    return ((sf_count_t )0);
  }
#line 249
  inptr = pdata->buffer;
#line 251
  chan = 0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;

#line 251
    if (! (chan < psf->sf.channels)) {
#line 251
      goto while_break;
    }
    {
#line 252
    outptr = ptr + chan;
#line 254
    offset = psf->dataoffset + (long )(chan * psf->bytewidth) * psf->read_current;
#line 256
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 256
    if (__cil_tmp12 != offset) {
#line 257
      psf->error = 37;
#line 258
      return ((sf_count_t )0);
    }
#line 261
    templen = len / (long )psf->sf.channels;
    {
#line 263
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 263
      if (! (templen > 0L)) {
#line 263
        goto while_break___0;
      }
#line 264
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(double ))) {
#line 265
        count = (int )sizeof(pdata->buffer) / (int )sizeof(double );
      } else {
#line 267
        count = (int )templen;
      }
      {
#line 269
      __cil_tmp13 = (*(pdata->read_double))(psf, inptr, (sf_count_t )count);
      }
#line 269
      if (__cil_tmp13 != (long )count) {
#line 270
        psf->error = 38;
#line 271
        return ((sf_count_t )0);
      }
#line 274
      k = 0;
      {
#line 274
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 274
        if (! (k < count)) {
#line 274
          goto while_break___1;
        }
#line 275
        *outptr = *(inptr + k);
#line 276
        outptr += psf->sf.channels;
#line 274
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 279
      templen -= (long )count;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 251
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 283
  return (len);
}
}
#line 290 "/root/patchweave_donee/23/src/interleave.c"
static sf_count_t interleave_seek(SF_PRIVATE *UNUSED_psf , int UNUSED_mode , sf_count_t samples_from_start ) 
{ 


  {
#line 297
  return (samples_from_start);
}
}
#line 34 "/root/patchweave_donee/23/src/ima_oki_adpcm.c"
static int const   ima_steps[89]  = 
#line 34 "/root/patchweave_donee/23/src/ima_oki_adpcm.c"
  {      (int const   )7,      (int const   )8,      (int const   )9,      (int const   )10, 
        (int const   )11,      (int const   )12,      (int const   )13,      (int const   )14, 
        (int const   )16,      (int const   )17,      (int const   )19,      (int const   )21, 
        (int const   )23,      (int const   )25,      (int const   )28,      (int const   )31, 
        (int const   )34,      (int const   )37,      (int const   )41,      (int const   )45, 
        (int const   )50,      (int const   )55,      (int const   )60,      (int const   )66, 
        (int const   )73,      (int const   )80,      (int const   )88,      (int const   )97, 
        (int const   )107,      (int const   )118,      (int const   )130,      (int const   )143, 
        (int const   )157,      (int const   )173,      (int const   )190,      (int const   )209, 
        (int const   )230,      (int const   )253,      (int const   )279,      (int const   )307, 
        (int const   )337,      (int const   )371,      (int const   )408,      (int const   )449, 
        (int const   )494,      (int const   )544,      (int const   )598,      (int const   )658, 
        (int const   )724,      (int const   )796,      (int const   )876,      (int const   )963, 
        (int const   )1060,      (int const   )1166,      (int const   )1282,      (int const   )1411, 
        (int const   )1552,      (int const   )1707,      (int const   )1878,      (int const   )2066, 
        (int const   )2272,      (int const   )2499,      (int const   )2749,      (int const   )3024, 
        (int const   )3327,      (int const   )3660,      (int const   )4026,      (int const   )4428, 
        (int const   )4871,      (int const   )5358,      (int const   )5894,      (int const   )6484, 
        (int const   )7132,      (int const   )7845,      (int const   )8630,      (int const   )9493, 
        (int const   )10442,      (int const   )11487,      (int const   )12635,      (int const   )13899, 
        (int const   )15289,      (int const   )16818,      (int const   )18500,      (int const   )20350, 
        (int const   )22385,      (int const   )24623,      (int const   )27086,      (int const   )29794, 
        (int const   )32767};
#line 44 "/root/patchweave_donee/23/src/ima_oki_adpcm.c"
static int const   oki_steps[49]  = 
#line 44
  {      (int const   )256,      (int const   )272,      (int const   )304,      (int const   )336, 
        (int const   )368,      (int const   )400,      (int const   )448,      (int const   )496, 
        (int const   )544,      (int const   )592,      (int const   )656,      (int const   )720, 
        (int const   )800,      (int const   )880,      (int const   )960,      (int const   )1056, 
        (int const   )1168,      (int const   )1280,      (int const   )1408,      (int const   )1552, 
        (int const   )1712,      (int const   )1888,      (int const   )2080,      (int const   )2288, 
        (int const   )2512,      (int const   )2768,      (int const   )3040,      (int const   )3344, 
        (int const   )3680,      (int const   )4048,      (int const   )4464,      (int const   )4912, 
        (int const   )5392,      (int const   )5936,      (int const   )6528,      (int const   )7184, 
        (int const   )7904,      (int const   )8704,      (int const   )9568,      (int const   )10528, 
        (int const   )11584,      (int const   )12736,      (int const   )14016,      (int const   )15408, 
        (int const   )16960,      (int const   )18656,      (int const   )20512,      (int const   )22576, 
        (int const   )24832};
#line 51 "/root/patchweave_donee/23/src/ima_oki_adpcm.c"
static int const   step_changes[8]  = 
#line 51
  {      (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )2,      (int const   )4,      (int const   )6,      (int const   )8};
#line 54 "/root/patchweave_donee/23/src/ima_oki_adpcm.c"
void ima_oki_adpcm_init(IMA_OKI_ADPCM *state , IMA_OKI_ADPCM_TYPE type ) 
{ 


  {
  {
#line 56
  memset((void *)state, 0, sizeof(*state));
  }
#line 58
  if ((unsigned int )type == 0U) {
#line 59
    state->max_step_index = (int )(sizeof(ima_steps) / sizeof(ima_steps[0])) - 1;
#line 60
    state->steps = ima_steps;
#line 61
    state->mask = ~ 0;
  } else {
    {
#line 64
    state->max_step_index = (int )(sizeof(oki_steps) / sizeof(oki_steps[0])) - 1;
#line 65
    state->steps = oki_steps;
#line 66
    state->mask = arith_shift_left(~ 0, 4);
    }
  }
#line 70
  return;
}
}
#line 73 "/root/patchweave_donee/23/src/ima_oki_adpcm.c"
int adpcm_decode(IMA_OKI_ADPCM *state , int code ) 
{ 
  int s ;
  int grace ;
  int tmp ;

  {
#line 76
  s = ((code & 7) << 1) | 1;
#line 77
  s = (int )((*(state->steps + state->step_index) * (int const   )s >> 3) & (int const   )state->mask);
#line 79
  if (code & 8) {
#line 80
    s = - s;
  }
#line 81
  s += state->last_output;
#line 83
  if (s < -32768) {
    _L: 
#line 86
    grace = (int )((*(state->steps + state->step_index) >> 3) & (int const   )state->mask);
#line 88
    if (s < -32768 - grace) {
#line 89
      (state->errors) ++;
    } else
#line 88
    if (s > 32767 + grace) {
#line 89
      (state->errors) ++;
    }
#line 91
    if (s < -32768) {
#line 91
      tmp = -32768;
    } else {
#line 91
      tmp = 32767;
    }
#line 91
    s = tmp;
  } else
#line 83
  if (s > 32767) {
#line 83
    goto _L;
  }
#line 94
  state->step_index += (int )step_changes[code & 7];
#line 95
  state->step_index = 0;
#line 96
  state->last_output = s;
#line 98
  return (s);
}
}
#line 102 "/root/patchweave_donee/23/src/ima_oki_adpcm.c"
int adpcm_encode(IMA_OKI_ADPCM *state , int sample ) 
{ 
  int delta ;
  int sign ;
  int code ;

  {
#line 103
  sign = 0;
#line 105
  delta = sample - state->last_output;
#line 107
  if (delta < 0) {
#line 108
    sign = 8;
#line 109
    delta = - delta;
  }
  {
#line 112
  code = (4 * delta) / (int )*(state->steps + state->step_index);
#line 113
  code = sign;
#line 114
  adpcm_decode(state, code);
  }
#line 116
  return (code);
}
}
#line 121 "/root/patchweave_donee/23/src/ima_oki_adpcm.c"
void ima_oki_adpcm_decode_block(IMA_OKI_ADPCM *state ) 
{ 
  unsigned char code ;
  int k ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 125
  k = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;

#line 125
    if (! (k < state->code_count)) {
#line 125
      goto while_break;
    }
    {
#line 126
    code = state->codes[k];
#line 127
    __cil_tmp4 = adpcm_decode(state, (int )code >> 4);
#line 127
    state->pcm[2 * k] = (short )__cil_tmp4;
#line 128
    __cil_tmp5 = adpcm_decode(state, (int )code);
#line 128
    state->pcm[2 * k + 1] = (short )__cil_tmp5;
#line 125
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 131
  state->pcm_count = 2 * k;
#line 132
  return;
}
}
#line 136 "/root/patchweave_donee/23/src/ima_oki_adpcm.c"
void ima_oki_adpcm_encode_block(IMA_OKI_ADPCM *state ) 
{ 
  unsigned char code ;
  int k ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 146
  if (state->pcm_count % 2 == 1) {
#line 147
    __cil_tmp4 = state->pcm_count;
#line 147
    (state->pcm_count) ++;
#line 147
    state->pcm[__cil_tmp4] = (short)0;
  }
#line 149
  k = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;

#line 149
    if (! (k < state->pcm_count / 2)) {
#line 149
      goto while_break;
    }
    {
#line 150
    __cil_tmp5 = adpcm_encode(state, (int )state->pcm[2 * k]);
#line 150
    code = (unsigned char )(__cil_tmp5 << 4);
#line 151
    __cil_tmp6 = adpcm_encode(state, (int )state->pcm[2 * k + 1]);
#line 151
    code = (unsigned char )((int )code | __cil_tmp6);
#line 152
    state->codes[k] = code;
#line 149
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 155
  state->code_count = k;
#line 156
  return;
}
}
#line 47 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int ima_indx_adjust[16]  = 
#line 47 "/root/patchweave_donee/23/src/ima_adpcm.c"
  {      -1,      -1,      -1,      -1, 
        2,      4,      6,      8, 
        -1,      -1,      -1,      -1, 
        2,      4,      6,      8};
#line 54 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int ima_step_size[89]  = 
#line 54
  {      7,      8,      9,      10, 
        11,      12,      13,      14, 
        16,      17,      19,      21, 
        23,      25,      28,      31, 
        34,      37,      41,      45, 
        50,      55,      60,      66, 
        73,      80,      88,      97, 
        107,      118,      130,      143, 
        157,      173,      190,      209, 
        230,      253,      279,      307, 
        337,      371,      408,      449, 
        494,      544,      598,      658, 
        724,      796,      876,      963, 
        1060,      1166,      1282,      1411, 
        1552,      1707,      1878,      2066, 
        2272,      2499,      2749,      3024, 
        3327,      3660,      4026,      4428, 
        4871,      5358,      5894,      6484, 
        7132,      7845,      8630,      9493, 
        10442,      11487,      12635,      13899, 
        15289,      16818,      18500,      20350, 
        22385,      24623,      27086,      29794, 
        32767};
#line 64
static int ima_reader_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 65
static int ima_writer_init(SF_PRIVATE *psf , int blockalign ) ;
#line 67
static int ima_read_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short *ptr ,
                          int len ) ;
#line 68
static int ima_write_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short const   *ptr ,
                           int len ) ;
#line 70
static sf_count_t ima_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 71
static sf_count_t ima_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 72
static sf_count_t ima_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 73
static sf_count_t ima_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 75
static sf_count_t ima_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 76
static sf_count_t ima_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 77
static sf_count_t ima_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 78
static sf_count_t ima_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 80
static sf_count_t aiff_ima_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 81
static sf_count_t wav_w64_ima_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 83
static int ima_close(SF_PRIVATE *psf ) ;
#line 85
static int wav_w64_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 86
static int wav_w64_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 89
static int aiff_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 90
static int aiff_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 94 "/root/patchweave_donee/23/src/ima_adpcm.c"
__inline static int clamp_ima_step_index(int indx ) 
{ 


  {
#line 95
  if (indx < 0) {
#line 96
    return (0);
  }
#line 97
  if (indx >= (int )(sizeof(ima_step_size) / sizeof(ima_step_size[0]))) {
#line 98
    return ((int )(sizeof(ima_step_size) / sizeof(ima_step_size[0])) - 1);
  }
#line 100
  return (indx);
}
}
#line 108 "/root/patchweave_donee/23/src/ima_adpcm.c"
int wav_w64_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  int error ;

  {
#line 111
  if ((unsigned long )psf->codec_data != (unsigned long )((void *)0)) {
    {
#line 112
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n");
    }
#line 113
    return (30);
  }
#line 116
  if (psf->file.mode == 48) {
#line 117
    return (24);
  }
#line 119
  if (psf->file.mode == 16) {
    {
#line 120
    error = ima_reader_init(psf, blockalign, samplesperblock);
    }
#line 120
    if (error) {
#line 121
      return (error);
    }
  }
#line 123
  if (psf->file.mode == 32) {
    {
#line 124
    error = ima_writer_init(psf, blockalign);
    }
#line 124
    if (error) {
#line 125
      return (error);
    }
  }
#line 127
  psf->codec_close = & ima_close;
#line 128
  psf->seek = & wav_w64_ima_seek;
#line 130
  return (0);
}
}
#line 134 "/root/patchweave_donee/23/src/ima_adpcm.c"
int aiff_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  int error ;

  {
#line 137
  if (psf->file.mode == 48) {
#line 138
    return (24);
  }
#line 140
  if (psf->file.mode == 16) {
    {
#line 141
    error = ima_reader_init(psf, blockalign, samplesperblock);
    }
#line 141
    if (error) {
#line 142
      return (error);
    }
  }
#line 144
  if (psf->file.mode == 32) {
    {
#line 145
    error = ima_writer_init(psf, blockalign);
    }
#line 145
    if (error) {
#line 146
      return (error);
    }
  }
#line 148
  psf->codec_close = & ima_close;
#line 149
  psf->seek = & aiff_ima_seek;
#line 151
  return (0);
}
}
#line 155 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int ima_close(SF_PRIVATE *psf ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;

  {
#line 158
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 160
  if (psf->file.mode == 32) {
#line 164
    if (pima->samplecount) {
#line 164
      if (pima->samplecount < pima->samplesperblock) {
        {
#line 165
        (*(pima->encode_block))(psf, pima);
        }
      }
    }
#line 167
    psf->sf.frames = (sf_count_t )((pima->samplesperblock * pima->blockcount) / psf->sf.channels);
  }
#line 170
  return (0);
}
}
#line 178 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int ima_reader_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int pimasize ;
  int count ;
  sf_count_t tmp ;
  void *tmp___0 ;

  {
#line 182
  if (psf->file.mode != 16) {
#line 183
    return (24);
  }
  {
#line 185
  pimasize = (int )((sizeof(IMA_ADPCM_PRIVATE ) + (unsigned long )(blockalign * psf->sf.channels)) + (unsigned long )((3 * psf->sf.channels) * samplesperblock));
#line 187
  tmp___0 = calloc(1UL, (unsigned long )pimasize);
#line 187
  pima = (IMA_ADPCM_PRIVATE *)tmp___0;
  }
#line 187
  if (! pima) {
#line 188
    return (17);
  }
  {
#line 190
  psf->codec_data = (void *)pima;
#line 192
  pima->samples = pima->data;
#line 193
  pima->block = (unsigned char *)(pima->data + samplesperblock * psf->sf.channels);
#line 195
  pima->channels = psf->sf.channels;
#line 196
  pima->blocksize = blockalign;
#line 197
  pima->samplesperblock = samplesperblock;
#line 199
  psf->filelength = psf_get_filelen(psf);
  }
#line 200
  if (psf->dataend) {
#line 200
    tmp = psf->dataend - psf->dataoffset;
  } else {
#line 200
    tmp = psf->filelength - psf->dataoffset;
  }
#line 200
  psf->datalength = tmp;
#line 203
  if (pima->blocksize <= 0) {
    {
#line 204
    psf_log_printf(psf, "*** Error : pima->blocksize should be > 0.\n");
    }
#line 205
    return (30);
  }
#line 208
  if (pima->samplesperblock <= 0) {
    {
#line 209
    psf_log_printf(psf, "*** Error : pima->samplesperblock should be > 0.\n");
    }
#line 210
    return (30);
  }
#line 213
  if (psf->datalength % (long )pima->blocksize) {
#line 214
    pima->blocks = (int )(psf->datalength / (long )pima->blocksize + 1L);
  } else {
#line 216
    pima->blocks = (int )(psf->datalength / (long )pima->blocksize);
  }
#line 220
  if ((psf->sf.format & 268369920) == 720896) {
#line 220
    goto case_720896;
  }
#line 220
  if ((psf->sf.format & 268369920) == 65536) {
#line 220
    goto case_720896;
  }
#line 233
  if ((psf->sf.format & 268369920) == 131072) {
#line 233
    goto case_131072;
  }
#line 239
  goto switch_default;
  case_720896: 
#line 221
  count = (2 * (pima->blocksize - 4 * pima->channels)) / pima->channels + 1;
#line 223
  if (pima->samplesperblock != count) {
    {
#line 224
    psf_log_printf(psf, "*** Error : samplesperblock should be %d.\n", count);
    }
#line 225
    return (30);
  }
#line 228
  pima->decode_block = & wav_w64_ima_decode_block;
#line 230
  psf->sf.frames = (sf_count_t )(pima->samplesperblock * pima->blocks);
#line 231
  goto switch_break;
  case_131072: 
  {
#line 234
  psf_log_printf(psf, "still need to check block count\n\220");
#line 235
  pima->decode_block = & aiff_ima_decode_block;
#line 236
  psf->sf.frames = (sf_count_t )((pima->samplesperblock * pima->blocks) / pima->channels);
  }
#line 237
  goto switch_break;
  switch_default: 
  {
#line 240
  psf_log_printf(psf, "ima_reader_init: bad psf->sf.format\n\204U");
  }
#line 241
  return (30);
  switch_break: 
  {
#line 244
  (*(pima->decode_block))(psf, pima);
#line 246
  psf->read_short = & ima_read_s;
#line 247
  psf->read_int = & ima_read_i;
#line 248
  psf->read_float = & ima_read_f;
#line 249
  psf->read_double = & ima_read_d;
  }
#line 251
  return (0);
}
}
#line 266 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int count  ;
#line 255 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int aiff_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  unsigned char *blockdata ;
  int chan ;
  int k ;
  int diff ;
  int bytecode ;
  int predictor ;
  short step ;
  short stepindx ;
  short *sampledata ;
  sf_count_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp17 ;

  {
#line 260
  count = 0;
#line 261
  count ++;
#line 263
  pima->blockcount += pima->channels;
#line 264
  pima->samplecount = 0;
#line 266
  if (pima->blockcount > pima->blocks) {
    {
#line 267
    memset((void *)pima->samples, 0, (unsigned long )(pima->samplesperblock * pima->channels) * sizeof(short ));
    }
#line 268
    return (1);
  }
  {
#line 271
  __cil_tmp14 = psf_fread((void *)pima->block, (sf_count_t )1, (sf_count_t )(pima->blocksize * pima->channels),
                          psf);
#line 271
  k = (int )__cil_tmp14;
  }
#line 271
  if (k != pima->blocksize * pima->channels) {
    {
#line 272
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, pima->blocksize);
    }
  }
#line 275
  chan = 0;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;

#line 275
    if (! (chan < pima->channels)) {
#line 275
      goto while_break;
    }
    {
#line 276
    blockdata = pima->block + chan * 34;
#line 277
    sampledata = pima->samples + chan;
#line 280
    predictor = (int )((short )(((int )*(blockdata + 0) << 8) | ((int )*(blockdata + 1) & 128)));
#line 282
    stepindx = (short )((int )*(blockdata + 1) & 127);
#line 283
    __cil_tmp15 = clamp_ima_step_index((int )stepindx);
#line 283
    stepindx = (short )__cil_tmp15;
#line 289
    k = 0;
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 289
      if (! (k < pima->blocksize - 2)) {
#line 289
        goto while_break___0;
      }
#line 290
      bytecode = (int )*(blockdata + (k + 2));
#line 291
      *(sampledata + pima->channels * (2 * k)) = (short )(bytecode & 15);
#line 292
      *(sampledata + pima->channels * (2 * k + 1)) = (short )((bytecode >> 4) & 15);
#line 289
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 296
    k = 0;
    {
#line 296
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 296
      if (! (k < pima->samplesperblock)) {
#line 296
        goto while_break___1;
      }
      {
#line 297
      step = (short )ima_step_size[stepindx];
#line 299
      bytecode = (int )*(pima->samples + (pima->channels * k + chan));
#line 301
      stepindx = (short )((int )stepindx + ima_indx_adjust[bytecode]);
#line 302
      __cil_tmp17 = clamp_ima_step_index((int )stepindx);
#line 302
      stepindx = (short )__cil_tmp17;
#line 304
      diff = (int )step >> 3;
      }
#line 305
      if (bytecode & 1) {
#line 305
        diff += (int )step >> 2;
      }
#line 306
      if (bytecode & 2) {
#line 306
        diff += (int )step >> 1;
      }
#line 307
      if (bytecode & 4) {
#line 307
        diff += (int )step;
      }
#line 308
      if (bytecode & 8) {
#line 308
        diff = - diff;
      }
#line 310
      predictor += diff;
#line 311
      if (predictor < -32768) {
#line 312
        predictor = -32768;
      } else
#line 313
      if (predictor > 32767) {
#line 314
        predictor = 32767;
      }
#line 316
      *(pima->samples + (pima->channels * k + chan)) = (short )predictor;
#line 296
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 275
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 320
  return (1);
}
}
#line 324 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int aiff_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  int chan ;
  int k ;
  int step ;
  int diff ;
  int vpdiff ;
  int blockindx ;
  int indx ;
  short bytecode ;
  short mask ;
  int tmp ;
  sf_count_t __cil_tmp17 ;

  {
#line 329
  chan = 0;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;

#line 329
    if (! (chan < pima->channels)) {
#line 329
      goto while_break;
    }
#line 330
    blockindx = chan * pima->blocksize;
#line 332
    *(pima->block + blockindx) = (unsigned char )(((int )*(pima->samples + chan) >> 8) & 255);
#line 333
    *(pima->block + (blockindx + 1)) = (unsigned char )(((int )*(pima->samples + chan) & 128) + (pima->stepindx[chan] & 127));
#line 335
    pima->previous[chan] = (int )*(pima->samples + chan);
#line 329
    chan ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 339
  k = pima->channels;
  {
#line 339
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 339
    if (! (k < pima->samplesperblock * pima->channels)) {
#line 339
      goto while_break___0;
    }
#line 340
    if (pima->channels > 1) {
#line 340
      tmp = k % 2;
    } else {
#line 340
      tmp = 0;
    }
#line 340
    chan = tmp;
#line 342
    diff = (int )*(pima->samples + k) - pima->previous[chan];
#line 344
    bytecode = (short)0;
#line 345
    step = ima_step_size[pima->stepindx[chan]];
#line 346
    vpdiff = step >> 3;
#line 347
    if (diff < 0) {
#line 348
      bytecode = (short)8;
#line 349
      diff = - diff;
    }
#line 351
    mask = (short)4;
    {
#line 352
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 352
      if (! mask) {
#line 352
        goto while_break___1;
      }
#line 353
      if (diff >= step) {
#line 354
        bytecode = (short )((int )bytecode | (int )mask);
#line 355
        diff -= step;
#line 356
        vpdiff += step;
      }
#line 358
      step >>= 1;
#line 359
      mask = (short )((int )mask >> 1);
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: ;
#line 362
    if ((int )bytecode & 8) {
#line 363
      pima->previous[chan] -= vpdiff;
    } else {
#line 365
      pima->previous[chan] += vpdiff;
    }
#line 367
    if (pima->previous[chan] > 32767) {
#line 368
      pima->previous[chan] = 32767;
    } else
#line 369
    if (pima->previous[chan] < -32768) {
#line 370
      pima->previous[chan] = -32768;
    }
    {
#line 372
    pima->stepindx[chan] += ima_indx_adjust[bytecode];
#line 374
    pima->stepindx[chan] = clamp_ima_step_index(pima->stepindx[chan]);
#line 375
    *(pima->samples + k) = bytecode;
#line 339
    k ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
#line 380
  chan = 0;
  {
#line 380
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 380
    if (! (chan < pima->channels)) {
#line 380
      goto while_break___2;
    }
#line 381
    indx = pima->channels;
    {
#line 381
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 381
      if (! (indx < pima->channels * pima->samplesperblock)) {
#line 381
        goto while_break___3;
      }
#line 382
      blockindx = (chan * pima->blocksize + 2) + indx / 2;
#line 384
      *(pima->block + blockindx) = (unsigned char )((int )*(pima->samples + indx) & 15);
#line 385
      *(pima->block + blockindx) = (unsigned char )((int )*(pima->block + blockindx) | (((int )*(pima->samples + (indx + chan)) << 4) & 240));
#line 381
      indx += 2 * pima->channels;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
#line 380
    chan ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 391
  __cil_tmp17 = psf_fwrite((void const   *)pima->block, (sf_count_t )1, (sf_count_t )(pima->channels * pima->blocksize),
                           psf);
#line 391
  k = (int )__cil_tmp17;
  }
#line 391
  if (k != pima->channels * pima->blocksize) {
    {
#line 392
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pima->channels * pima->blocksize);
    }
  }
  {
#line 394
  memset((void *)pima->samples, 0, (unsigned long )(pima->channels * pima->samplesperblock) * sizeof(short ));
#line 395
  pima->samplecount = 0;
#line 396
  (pima->blockcount) ++;
  }
#line 398
  return (1);
}
}
#line 402 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int wav_w64_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  int chan ;
  int k ;
  int predictor ;
  int blockindx ;
  int indx ;
  int indxstart ;
  int diff ;
  short step ;
  short bytecode ;
  short stepindx[2] ;
  sf_count_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp17 ;
  int tmp ;
  int __cil_tmp21 ;

  {
#line 406
  (pima->blockcount) ++;
#line 407
  pima->samplecount = 0;
#line 409
  if (pima->blockcount > pima->blocks) {
    {
#line 410
    memset((void *)pima->samples, 0, (unsigned long )(pima->samplesperblock * pima->channels) * sizeof(short ));
    }
#line 411
    return (1);
  }
  {
#line 414
  __cil_tmp14 = psf_fread((void *)pima->block, (sf_count_t )1, (sf_count_t )pima->blocksize,
                          psf);
#line 414
  k = (int )__cil_tmp14;
  }
#line 414
  if (k != pima->blocksize) {
    {
#line 415
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, pima->blocksize);
    }
  }
#line 419
  chan = 0;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;

#line 419
    if (! (chan < pima->channels)) {
#line 419
      goto while_break;
    }
#line 420
    predictor = (int )*(pima->block + chan * 4) | ((int )*(pima->block + (chan * 4 + 1)) << 8);
#line 421
    if (predictor & 32768) {
#line 422
      predictor -= 65536;
    }
    {
#line 424
    stepindx[chan] = (short )*(pima->block + (chan * 4 + 2));
#line 425
    __cil_tmp15 = clamp_ima_step_index((int )stepindx[chan]);
#line 425
    stepindx[chan] = (short )__cil_tmp15;
    }
#line 428
    if ((int )*(pima->block + (chan * 4 + 3)) != 0) {
      {
#line 429
      psf_log_printf(psf, "IMA ADPCM synchronisation error.\n");
      }
    }
#line 431
    *(pima->samples + chan) = (short )predictor;
#line 419
    chan ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 439
  blockindx = 4 * pima->channels;
#line 441
  indxstart = pima->channels;
  {
#line 442
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 442
    if (! (blockindx < pima->blocksize)) {
#line 442
      goto while_break___0;
    }
#line 443
    chan = 0;
    {
#line 443
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 443
      if (! (chan < pima->channels)) {
#line 443
        goto while_break___1;
      }
#line 444
      indx = indxstart + chan;
#line 445
      k = 0;
      {
#line 445
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 445
        if (! (k < 4)) {
#line 445
          goto while_break___2;
        }
#line 446
        __cil_tmp17 = blockindx;
#line 446
        blockindx ++;
#line 446
        bytecode = (short )*(pima->block + __cil_tmp17);
#line 447
        *(pima->samples + indx) = (short )((int )bytecode & 15);
#line 448
        indx += pima->channels;
#line 449
        *(pima->samples + indx) = (short )(((int )bytecode >> 4) & 15);
#line 450
        indx += pima->channels;
#line 445
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: 
#line 443
      chan ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
#line 453
    indxstart += 8 * pima->channels;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
#line 458
  k = pima->channels;
  {
#line 458
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 458
    if (! (k < pima->samplesperblock * pima->channels)) {
#line 458
      goto while_break___3;
    }
#line 459
    if (pima->channels > 1) {
#line 459
      tmp = k % 2;
    } else {
#line 459
      tmp = 0;
    }
#line 459
    chan = tmp;
#line 461
    bytecode = (short )((int )*(pima->samples + k) & 15);
#line 463
    step = (short )ima_step_size[stepindx[chan]];
#line 464
    predictor = (int )*(pima->samples + (k - pima->channels));
#line 466
    diff = (int )step >> 3;
#line 467
    if ((int )bytecode & 1) {
#line 468
      diff += (int )step >> 2;
    }
#line 469
    if ((int )bytecode & 2) {
#line 470
      diff += (int )step >> 1;
    }
#line 471
    if ((int )bytecode & 4) {
#line 472
      diff += (int )step;
    }
#line 473
    if ((int )bytecode & 8) {
#line 474
      diff = - diff;
    }
#line 476
    predictor += diff;
#line 478
    if (predictor > 32767) {
#line 479
      predictor = 32767;
    } else
#line 480
    if (predictor < -32768) {
#line 481
      predictor = -32768;
    }
    {
#line 483
    stepindx[chan] = (short )((int )stepindx[chan] + ima_indx_adjust[bytecode]);
#line 484
    __cil_tmp21 = clamp_ima_step_index((int )stepindx[chan]);
#line 484
    stepindx[chan] = (short )__cil_tmp21;
#line 486
    *(pima->samples + k) = (short )predictor;
#line 458
    k ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: ;
#line 489
  return (1);
}
}
#line 493 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int wav_w64_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  int chan ;
  int k ;
  int step ;
  int diff ;
  int vpdiff ;
  int blockindx ;
  int indx ;
  int indxstart ;
  short bytecode ;
  short mask ;
  int tmp ;
  sf_count_t __cil_tmp20 ;

  {
#line 498
  chan = 0;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;

#line 498
    if (! (chan < pima->channels)) {
#line 498
      goto while_break;
    }
#line 499
    *(pima->block + chan * 4) = (unsigned char )((int )*(pima->samples + chan) & 255);
#line 500
    *(pima->block + (chan * 4 + 1)) = (unsigned char )(((int )*(pima->samples + chan) >> 8) & 255);
#line 502
    *(pima->block + (chan * 4 + 2)) = (unsigned char )pima->stepindx[chan];
#line 503
    *(pima->block + (chan * 4 + 3)) = (unsigned char)0;
#line 505
    pima->previous[chan] = (int )*(pima->samples + chan);
#line 498
    chan ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 510
  k = pima->channels;
  {
#line 510
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 510
    if (! (k < pima->samplesperblock * pima->channels)) {
#line 510
      goto while_break___0;
    }
#line 511
    if (pima->channels > 1) {
#line 511
      tmp = k % 2;
    } else {
#line 511
      tmp = 0;
    }
#line 511
    chan = tmp;
#line 513
    diff = (int )*(pima->samples + k) - pima->previous[chan];
#line 515
    bytecode = (short)0;
#line 516
    step = ima_step_size[pima->stepindx[chan]];
#line 517
    vpdiff = step >> 3;
#line 518
    if (diff < 0) {
#line 519
      bytecode = (short)8;
#line 520
      diff = - diff;
    }
#line 522
    mask = (short)4;
    {
#line 523
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 523
      if (! mask) {
#line 523
        goto while_break___1;
      }
#line 524
      if (diff >= step) {
#line 525
        bytecode = (short )((int )bytecode | (int )mask);
#line 526
        diff -= step;
#line 527
        vpdiff += step;
      }
#line 529
      step >>= 1;
#line 530
      mask = (short )((int )mask >> 1);
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: ;
#line 533
    if ((int )bytecode & 8) {
#line 534
      pima->previous[chan] -= vpdiff;
    } else {
#line 536
      pima->previous[chan] += vpdiff;
    }
#line 538
    if (pima->previous[chan] > 32767) {
#line 539
      pima->previous[chan] = 32767;
    } else
#line 540
    if (pima->previous[chan] < -32768) {
#line 541
      pima->previous[chan] = -32768;
    }
    {
#line 543
    pima->stepindx[chan] += ima_indx_adjust[bytecode];
#line 544
    pima->stepindx[chan] = clamp_ima_step_index(pima->stepindx[chan]);
#line 546
    *(pima->samples + k) = bytecode;
#line 510
    k ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 551
  blockindx = 4 * pima->channels;
#line 553
  indxstart = pima->channels;
  {
#line 554
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 554
    if (! (blockindx < pima->blocksize)) {
#line 554
      goto while_break___2;
    }
#line 555
    chan = 0;
    {
#line 555
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 555
      if (! (chan < pima->channels)) {
#line 555
        goto while_break___3;
      }
#line 556
      indx = indxstart + chan;
#line 557
      k = 0;
      {
#line 557
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 557
        if (! (k < 4)) {
#line 557
          goto while_break___4;
        }
#line 558
        *(pima->block + blockindx) = (unsigned char )((int )*(pima->samples + indx) & 15);
#line 559
        indx += pima->channels;
#line 560
        *(pima->block + blockindx) = (unsigned char )((int )*(pima->block + blockindx) | (((int )*(pima->samples + indx) << 4) & 240));
#line 561
        indx += pima->channels;
#line 562
        blockindx ++;
#line 557
        k ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 555
      chan ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 565
    indxstart += 8 * pima->channels;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 570
  __cil_tmp20 = psf_fwrite((void const   *)pima->block, (sf_count_t )1, (sf_count_t )pima->blocksize,
                           psf);
#line 570
  k = (int )__cil_tmp20;
  }
#line 570
  if (k != pima->blocksize) {
    {
#line 571
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pima->blocksize);
    }
  }
  {
#line 573
  memset((void *)pima->samples, 0, (unsigned long )pima->samplesperblock * sizeof(short ));
#line 574
  pima->samplecount = 0;
#line 575
  (pima->blockcount) ++;
  }
#line 577
  return (1);
}
}
#line 581 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int ima_read_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short *ptr ,
                          int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;
  int tmp ;

  {
#line 582
  total = 0;
#line 582
  indx = 0;
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;

#line 584
    if (! (indx < len)) {
#line 584
      goto while_break;
    }
#line 585
    if (pima->blockcount >= pima->blocks) {
#line 585
      if (pima->samplecount >= pima->samplesperblock) {
        {
#line 586
        memset((void *)(ptr + indx), 0, (unsigned long )(len - indx) * sizeof(short ));
        }
#line 587
        return (total);
      }
    }
#line 590
    if (pima->samplecount >= pima->samplesperblock) {
      {
#line 591
      (*(pima->decode_block))(psf, pima);
      }
    }
#line 593
    count___0 = (pima->samplesperblock - pima->samplecount) * pima->channels;
#line 594
    if (len - indx > count___0) {
#line 594
      tmp = count___0;
    } else {
#line 594
      tmp = len - indx;
    }
    {
#line 594
    count___0 = tmp;
#line 596
    memcpy((void *)(ptr + indx), (void const   *)(pima->samples + pima->samplecount * pima->channels),
           (unsigned long )count___0 * sizeof(short ));
#line 597
    indx += count___0;
#line 598
    pima->samplecount += count___0 / pima->channels;
#line 599
    total = indx;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 602
  return (total);
}
}
#line 606 "/root/patchweave_donee/23/src/ima_adpcm.c"
static sf_count_t ima_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 609
  total = (sf_count_t )0;
#line 611
  if (! psf->codec_data) {
#line 612
    return ((sf_count_t )0);
  }
#line 613
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;

#line 615
    if (! (len > 0L)) {
#line 615
      goto while_break;
    }
#line 616
    if (len > 268435456L) {
#line 616
      tmp = 268435456;
    } else {
#line 616
      tmp = (int )len;
    }
    {
#line 616
    readcount = tmp;
#line 618
    count___0 = ima_read_block(psf, pima, ptr, readcount);
#line 620
    total += (long )count___0;
#line 621
    len -= (long )count___0;
    }
#line 622
    if (count___0 != readcount) {
#line 623
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 626
  return (total);
}
}
#line 630 "/root/patchweave_donee/23/src/ima_adpcm.c"
static sf_count_t ima_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 635
  total = (sf_count_t )0;
#line 637
  if (! psf->codec_data) {
#line 638
    return ((sf_count_t )0);
  }
#line 639
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 641
  sptr = ubuf.sbuf;
#line 642
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;

#line 643
    if (! (len > 0L)) {
#line 643
      goto while_break;
    }
#line 644
    if (len >= (long )bufferlen) {
#line 644
      tmp = bufferlen;
    } else {
#line 644
      tmp = (int )len;
    }
    {
#line 644
    readcount = tmp;
#line 645
    count___0 = ima_read_block(psf, pima, sptr, readcount);
#line 646
    k = 0;
    }
    {
#line 646
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 646
      if (! (k < readcount)) {
#line 646
        goto while_break___0;
      }
      {
#line 647
      *(ptr + (total + (long )k)) = arith_shift_left((int32_t )*(sptr + k), 16);
#line 646
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 648
    total += (long )count___0;
#line 649
    len -= (long )readcount;
#line 650
    if (count___0 != readcount) {
#line 651
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 654
  return (total);
}
}
#line 658 "/root/patchweave_donee/23/src/ima_adpcm.c"
static sf_count_t ima_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;

  {
#line 663
  total = (sf_count_t )0;
#line 666
  if (! psf->codec_data) {
#line 667
    return ((sf_count_t )0);
  }
#line 668
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 670
  if (psf->norm_float == 1) {
#line 670
    tmp = 1. / (double )((float )32768);
  } else {
#line 670
    tmp = 1.;
  }
#line 670
  normfact = (float )tmp;
#line 672
  sptr = ubuf.sbuf;
#line 673
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;

#line 674
    if (! (len > 0L)) {
#line 674
      goto while_break;
    }
#line 675
    if (len >= (long )bufferlen) {
#line 675
      tmp___0 = bufferlen;
    } else {
#line 675
      tmp___0 = (int )len;
    }
    {
#line 675
    readcount = tmp___0;
#line 676
    count___0 = ima_read_block(psf, pima, sptr, readcount);
#line 677
    k = 0;
    }
    {
#line 677
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 677
      if (! (k < readcount)) {
#line 677
        goto while_break___0;
      }
#line 678
      *(ptr + (total + (long )k)) = normfact * (float )*(sptr + k);
#line 677
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 679
    total += (long )count___0;
#line 680
    len -= (long )readcount;
#line 681
    if (count___0 != readcount) {
#line 682
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 685
  return (total);
}
}
#line 689 "/root/patchweave_donee/23/src/ima_adpcm.c"
static sf_count_t ima_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;

  {
#line 694
  total = (sf_count_t )0;
#line 697
  if (! psf->codec_data) {
#line 698
    return ((sf_count_t )0);
  }
#line 699
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 701
  if (psf->norm_double == 1) {
#line 701
    tmp = 1. / (double )32768;
  } else {
#line 701
    tmp = 1.;
  }
#line 701
  normfact = tmp;
#line 703
  sptr = ubuf.sbuf;
#line 704
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 705
  while (1) {
    while_continue: /* CIL Label */ ;

#line 705
    if (! (len > 0L)) {
#line 705
      goto while_break;
    }
#line 706
    if (len >= (long )bufferlen) {
#line 706
      tmp___0 = bufferlen;
    } else {
#line 706
      tmp___0 = (int )len;
    }
    {
#line 706
    readcount = tmp___0;
#line 707
    count___0 = ima_read_block(psf, pima, sptr, readcount);
#line 708
    k = 0;
    }
    {
#line 708
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 708
      if (! (k < readcount)) {
#line 708
        goto while_break___0;
      }
#line 709
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 708
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 710
    total += (long )count___0;
#line 711
    len -= (long )readcount;
#line 712
    if (count___0 != readcount) {
#line 713
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 716
  return (total);
}
}
#line 720 "/root/patchweave_donee/23/src/ima_adpcm.c"
static sf_count_t aiff_ima_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int newblock ;
  int newsample ;
  int newblockaiff ;

  {
#line 724
  if (! psf->codec_data) {
#line 725
    return ((sf_count_t )0);
  }
#line 726
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 728
  if (psf->datalength < 0L) {
#line 729
    psf->error = 39;
#line 730
    return ((sf_count_t )-1);
  } else
#line 728
  if (psf->dataoffset < 0L) {
#line 729
    psf->error = 39;
#line 730
    return ((sf_count_t )-1);
  }
#line 733
  if (offset == 0L) {
    {
#line 734
    psf_fseek(psf, psf->dataoffset, 0);
#line 735
    pima->blockcount = 0;
#line 736
    (*(pima->decode_block))(psf, pima);
#line 737
    pima->samplecount = 0;
    }
#line 738
    return ((sf_count_t )0);
  }
#line 741
  if (offset < 0L) {
#line 742
    psf->error = 39;
#line 743
    return ((sf_count_t )-1);
  } else
#line 741
  if (offset > (long )(pima->blocks * pima->samplesperblock)) {
#line 742
    psf->error = 39;
#line 743
    return ((sf_count_t )-1);
  }
#line 746
  newblock = (int )(offset / (long )pima->samplesperblock);
#line 747
  newsample = (int )(offset % (long )pima->samplesperblock);
#line 748
  newblockaiff = newblock * psf->sf.channels;
#line 750
  if (mode == 16) {
    {
#line 751
    psf_fseek(psf, psf->dataoffset + (long )(newblockaiff * pima->blocksize), 0);
#line 752
    pima->blockcount = newblockaiff;
#line 753
    (*(pima->decode_block))(psf, pima);
#line 754
    pima->samplecount = newsample;
    }
  } else {
#line 758
    psf->error = 39;
#line 759
    return ((sf_count_t )-1);
  }
#line 762
  return ((sf_count_t )(newblock * pima->samplesperblock + newsample));
}
}
#line 766 "/root/patchweave_donee/23/src/ima_adpcm.c"
static sf_count_t wav_w64_ima_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int newblock ;
  int newsample ;

  {
#line 770
  if (! psf->codec_data) {
#line 771
    return ((sf_count_t )0);
  }
#line 772
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 774
  if (psf->datalength < 0L) {
#line 775
    psf->error = 39;
#line 776
    return ((sf_count_t )-1);
  } else
#line 774
  if (psf->dataoffset < 0L) {
#line 775
    psf->error = 39;
#line 776
    return ((sf_count_t )-1);
  }
#line 779
  if (offset == 0L) {
    {
#line 780
    psf_fseek(psf, psf->dataoffset, 0);
#line 781
    pima->blockcount = 0;
#line 782
    (*(pima->decode_block))(psf, pima);
#line 783
    pima->samplecount = 0;
    }
#line 784
    return ((sf_count_t )0);
  }
#line 787
  if (offset < 0L) {
#line 788
    psf->error = 39;
#line 789
    return ((sf_count_t )-1);
  } else
#line 787
  if (offset > (long )(pima->blocks * pima->samplesperblock)) {
#line 788
    psf->error = 39;
#line 789
    return ((sf_count_t )-1);
  }
#line 792
  newblock = (int )(offset / (long )pima->samplesperblock);
#line 793
  newsample = (int )(offset % (long )pima->samplesperblock);
#line 795
  if (mode == 16) {
    {
#line 796
    psf_fseek(psf, psf->dataoffset + (long )(newblock * pima->blocksize), 0);
#line 797
    pima->blockcount = newblock;
#line 798
    (*(pima->decode_block))(psf, pima);
#line 799
    pima->samplecount = newsample;
    }
  } else {
#line 803
    psf->error = 39;
#line 804
    return ((sf_count_t )-1);
  }
#line 807
  return ((sf_count_t )(newblock * pima->samplesperblock + newsample));
}
}
#line 815 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int ima_writer_init(SF_PRIVATE *psf , int blockalign ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int samplesperblock ;
  unsigned int pimasize ;
  void *tmp ;

  {
#line 820
  if (psf->file.mode != 32) {
#line 821
    return (24);
  }
  {
#line 823
  samplesperblock = (2 * (blockalign - 4 * psf->sf.channels)) / psf->sf.channels + 1;
#line 825
  pimasize = (unsigned int )((sizeof(IMA_ADPCM_PRIVATE ) + (unsigned long )blockalign) + (unsigned long )((3 * psf->sf.channels) * samplesperblock));
#line 827
  tmp = calloc(1UL, (unsigned long )pimasize);
#line 827
  pima = (IMA_ADPCM_PRIVATE *)tmp;
  }
#line 827
  if ((unsigned long )pima == (unsigned long )((void *)0)) {
#line 828
    return (17);
  }
#line 830
  psf->codec_data = (void *)pima;
#line 832
  pima->channels = psf->sf.channels;
#line 833
  pima->blocksize = blockalign;
#line 834
  pima->samplesperblock = samplesperblock;
#line 836
  pima->block = (unsigned char *)(pima->data);
#line 837
  pima->samples = pima->data + blockalign;
#line 839
  pima->samplecount = 0;
#line 843
  if ((psf->sf.format & 268369920) == 720896) {
#line 843
    goto case_720896;
  }
#line 843
  if ((psf->sf.format & 268369920) == 65536) {
#line 843
    goto case_720896;
  }
#line 847
  if ((psf->sf.format & 268369920) == 131072) {
#line 847
    goto case_131072;
  }
#line 851
  goto switch_default;
  case_720896: 
#line 844
  pima->encode_block = & wav_w64_ima_encode_block;
#line 845
  goto switch_break;
  case_131072: 
#line 848
  pima->encode_block = & aiff_ima_encode_block;
#line 849
  goto switch_break;
  switch_default: 
  {
#line 852
  psf_log_printf(psf, "ima_reader_init: bad psf->sf.format\n");
  }
#line 853
  return (30);
  switch_break: 
#line 856
  psf->write_short = & ima_write_s;
#line 857
  psf->write_int = & ima_write_i;
#line 858
  psf->write_float = & ima_write_f;
#line 859
  psf->write_double = & ima_write_d;
#line 861
  return (0);
}
}
#line 868 "/root/patchweave_donee/23/src/ima_adpcm.c"
static int ima_write_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short const   *ptr ,
                           int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;

  {
#line 869
  total = 0;
#line 869
  indx = 0;
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;

#line 871
    if (! (indx < len)) {
#line 871
      goto while_break;
    }
#line 872
    count___0 = (pima->samplesperblock - pima->samplecount) * pima->channels;
#line 874
    if (count___0 > len - indx) {
#line 875
      count___0 = len - indx;
    }
    {
#line 877
    memcpy((void *)(pima->samples + pima->samplecount * pima->channels), (void const   *)(ptr + total),
           (unsigned long )count___0 * sizeof(short ));
#line 878
    indx += count___0;
#line 879
    pima->samplecount += count___0 / pima->channels;
#line 880
    total = indx;
    }
#line 882
    if (pima->samplecount >= pima->samplesperblock) {
      {
#line 883
      (*(pima->encode_block))(psf, pima);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 886
  return (total);
}
}
#line 890 "/root/patchweave_donee/23/src/ima_adpcm.c"
static sf_count_t ima_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 893
  total = (sf_count_t )0;
#line 895
  if (! psf->codec_data) {
#line 896
    return ((sf_count_t )0);
  }
#line 897
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;

#line 899
    if (! len) {
#line 899
      goto while_break;
    }
#line 900
    if (len > 268435456L) {
#line 900
      tmp = 268435456;
    } else {
#line 900
      tmp = (int )len;
    }
    {
#line 900
    writecount = tmp;
#line 902
    count___0 = ima_write_block(psf, pima, ptr, writecount);
#line 904
    total += (long )count___0;
#line 905
    len -= (long )count___0;
    }
#line 906
    if (count___0 != writecount) {
#line 907
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 910
  return (total);
}
}
#line 914 "/root/patchweave_donee/23/src/ima_adpcm.c"
static sf_count_t ima_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 919
  total = (sf_count_t )0;
#line 921
  if (! psf->codec_data) {
#line 922
    return ((sf_count_t )0);
  }
#line 923
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 925
  sptr = ubuf.sbuf;
#line 926
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 927
  while (1) {
    while_continue: /* CIL Label */ ;

#line 927
    if (! (len > 0L)) {
#line 927
      goto while_break;
    }
#line 928
    if (len >= (long )bufferlen) {
#line 928
      tmp = bufferlen;
    } else {
#line 928
      tmp = (int )len;
    }
#line 928
    writecount = tmp;
#line 929
    k = 0;
    {
#line 929
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 929
      if (! (k < writecount)) {
#line 929
        goto while_break___0;
      }
#line 930
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 929
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 931
    count___0 = ima_write_block(psf, pima, (short const   *)sptr, writecount);
#line 932
    total += (long )count___0;
#line 933
    len -= (long )writecount;
    }
#line 934
    if (count___0 != writecount) {
#line 935
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 938
  return (total);
}
}
#line 942 "/root/patchweave_donee/23/src/ima_adpcm.c"
static sf_count_t ima_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp15 ;

  {
#line 947
  total = (sf_count_t )0;
#line 950
  if (! psf->codec_data) {
#line 951
    return ((sf_count_t )0);
  }
#line 952
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 954
  if (psf->norm_float == 1) {
#line 954
    tmp = 1. * (double )32767;
  } else {
#line 954
    tmp = 1.;
  }
#line 954
  normfact = (float )tmp;
#line 956
  sptr = ubuf.sbuf;
#line 957
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;

#line 958
    if (! (len > 0L)) {
#line 958
      goto while_break;
    }
#line 959
    if (len >= (long )bufferlen) {
#line 959
      tmp___0 = bufferlen;
    } else {
#line 959
      tmp___0 = (int )len;
    }
#line 959
    writecount = tmp___0;
#line 960
    k = 0;
    {
#line 960
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 960
      if (! (k < writecount)) {
#line 960
        goto while_break___0;
      }
      {
#line 961
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 961
      *(sptr + k) = (short )__cil_tmp15;
#line 960
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 962
    count___0 = ima_write_block(psf, pima, (short const   *)sptr, writecount);
#line 963
    total += (long )count___0;
#line 964
    len -= (long )writecount;
    }
#line 965
    if (count___0 != writecount) {
#line 966
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 969
  return (total);
}
}
#line 973 "/root/patchweave_donee/23/src/ima_adpcm.c"
static sf_count_t ima_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp15 ;

  {
#line 978
  total = (sf_count_t )0;
#line 981
  if (! psf->codec_data) {
#line 982
    return ((sf_count_t )0);
  }
#line 983
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 985
  if (psf->norm_double == 1) {
#line 985
    tmp = 1. * (double )32767;
  } else {
#line 985
    tmp = 1.;
  }
#line 985
  normfact = tmp;
#line 987
  sptr = ubuf.sbuf;
#line 988
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 989
  while (1) {
    while_continue: /* CIL Label */ ;

#line 989
    if (! (len > 0L)) {
#line 989
      goto while_break;
    }
#line 990
    if (len >= (long )bufferlen) {
#line 990
      tmp___0 = bufferlen;
    } else {
#line 990
      tmp___0 = (int )len;
    }
#line 990
    writecount = tmp___0;
#line 991
    k = 0;
    {
#line 991
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 991
      if (! (k < writecount)) {
#line 991
        goto while_break___0;
      }
      {
#line 992
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 992
      *(sptr + k) = (short )__cil_tmp15;
#line 991
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 993
    count___0 = ima_write_block(psf, pima, (short const   *)sptr, writecount);
#line 994
    total += (long )count___0;
#line 995
    len -= (long )writecount;
    }
#line 996
    if (count___0 != writecount) {
#line 997
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1000
  return (total);
}
}
#line 31 "/root/patchweave_donee/23/src/id3.c"
int id3_skip(SF_PRIVATE *psf ) 
{ 
  unsigned char buf[10] ;
  int offset ;

  {
  {
#line 34
  memset((void *)(buf), 0, sizeof(buf));
#line 35
  psf_binheader_readf(psf, "pb\274\322\204U", 0, buf, 10);
  }
#line 37
  if ((int )buf[0] == 73) {
#line 37
    if ((int )buf[1] == 68) {
#line 37
      if ((int )buf[2] == 51) {
        {
#line 38
        offset = (int )buf[6] & 127;
#line 39
        offset = (offset << 7) | ((int )buf[7] & 127);
#line 40
        offset = (offset << 7) | ((int )buf[8] & 127);
#line 41
        offset = (offset << 7) | ((int )buf[9] & 127);
#line 43
        psf_log_printf(psf, "ID3 length : %d\n--------------------\nU", offset);
        }
#line 46
        if (offset < 0) {
#line 47
          return (0);
        }
        {
#line 50
        psf->fileoffset += (long )(offset + 10);
#line 51
        psf_binheader_readf(psf, "pi\001", psf->fileoffset);
        }
#line 53
        return (1);
      }
    }
  }
#line 56
  return (0);
}
}
#line 34 "/root/patchweave_donee/23/src/GSM610/gsm.h"
gsm gsm_create(void) ;
#line 37
void gsm_init(gsm state ) ;
#line 39
void gsm_destroy(gsm S ) ;
#line 42
int gsm_option(gsm r , int opt , int *val ) ;
#line 44
void gsm_encode(gsm s , gsm_signal *source , gsm_byte *c ) ;
#line 45
int gsm_decode(gsm s , gsm_byte *c , gsm_signal *target ) ;
#line 50 "/root/patchweave_donee/23/src/gsm610.c"
static sf_count_t gsm610_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 51
static sf_count_t gsm610_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 52
static sf_count_t gsm610_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 53
static sf_count_t gsm610_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 55
static sf_count_t gsm610_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 56
static sf_count_t gsm610_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 57
static sf_count_t gsm610_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 58
static sf_count_t gsm610_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 60
static int gsm610_read_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short *ptr ,
                             int len ) ;
#line 61
static int gsm610_write_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short const   *ptr ,
                              int len ) ;
#line 63
static int gsm610_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 64
static int gsm610_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 66
static int gsm610_wav_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 67
static int gsm610_wav_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 69
static sf_count_t gsm610_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 71
static int gsm610_close(SF_PRIVATE *psf ) ;
#line 78 "/root/patchweave_donee/23/src/gsm610.c"
int gsm610_init(SF_PRIVATE *psf ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int true_flag ;
  void *tmp ;

  {
#line 80
  true_flag = 1;
#line 82
  if ((unsigned long )psf->codec_data != (unsigned long )((void *)0)) {
    {
#line 83
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n");
    }
#line 84
    return (30);
  }
#line 87
  if (psf->file.mode == 48) {
#line 88
    return (24);
  }
  {
#line 90
  psf->sf.seekable = 0;
#line 92
  tmp = calloc(1UL, sizeof(GSM610_PRIVATE ));
#line 92
  pgsm610 = (GSM610_PRIVATE *)tmp;
  }
#line 92
  if ((unsigned long )pgsm610 == (unsigned long )((void *)0)) {
#line 93
    return (17);
  }
  {
#line 95
  psf->codec_data = (void *)pgsm610;
#line 97
  memset((void *)pgsm610, 0, sizeof(GSM610_PRIVATE ));
#line 105
  pgsm610->gsm_data = gsm_create();
  }
#line 105
  if ((unsigned long )pgsm610->gsm_data == (unsigned long )((void *)0)) {
#line 106
    return (17);
  }
#line 111
  if ((psf->sf.format & 268369920) == 720896) {
#line 111
    goto case_720896;
  }
#line 111
  if ((psf->sf.format & 268369920) == 1245184) {
#line 111
    goto case_720896;
  }
#line 111
  if ((psf->sf.format & 268369920) == 65536) {
#line 111
    goto case_720896;
  }
#line 122
  if ((psf->sf.format & 268369920) == 262144) {
#line 122
    goto case_262144;
  }
#line 122
  if ((psf->sf.format & 268369920) == 131072) {
#line 122
    goto case_262144;
  }
#line 130
  goto switch_default;
  case_720896: 
  {
#line 112
  gsm_option(pgsm610->gsm_data, 4, & true_flag);
#line 114
  pgsm610->encode_block = & gsm610_wav_encode_block;
#line 115
  pgsm610->decode_block = & gsm610_wav_decode_block;
#line 117
  pgsm610->samplesperblock = 320;
#line 118
  pgsm610->blocksize = 65;
  }
#line 119
  goto switch_break;
  case_262144: 
#line 123
  pgsm610->encode_block = & gsm610_encode_block;
#line 124
  pgsm610->decode_block = & gsm610_decode_block;
#line 126
  pgsm610->samplesperblock = 160;
#line 127
  pgsm610->blocksize = 33;
#line 128
  goto switch_break;
  switch_default: 
#line 131
  return (30);
#line 132
  goto switch_break;
  switch_break: ;
#line 135
  if (psf->file.mode == 16) {
#line 136
    if (psf->datalength % (long )pgsm610->blocksize == 0L) {
#line 137
      pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize);
    } else
#line 138
    if (psf->datalength % (long )pgsm610->blocksize == 1L) {
#line 138
      if (pgsm610->blocksize == 33) {
#line 146
        pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize);
      } else {
        {
#line 149
        psf_log_printf(psf, "*** Warning : data chunk seems to be truncated.\n\220");
#line 150
        pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize + 1L);
        }
      }
    } else {
      {
#line 149
      psf_log_printf(psf, "*** Warning : data chunk seems to be truncated.\n\220");
#line 150
      pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize + 1L);
      }
    }
    {
#line 153
    psf->sf.frames = (sf_count_t )(pgsm610->samplesperblock * pgsm610->blocks);
#line 155
    psf_fseek(psf, psf->dataoffset, 0);
#line 157
    (*(pgsm610->decode_block))(psf, pgsm610);
#line 159
    psf->read_short = & gsm610_read_s;
#line 160
    psf->read_int = & gsm610_read_i;
#line 161
    psf->read_float = & gsm610_read_f;
#line 162
    psf->read_double = & gsm610_read_d;
    }
  }
#line 165
  if (psf->file.mode == 32) {
#line 166
    pgsm610->blockcount = 0;
#line 167
    pgsm610->samplecount = 0;
#line 169
    psf->write_short = & gsm610_write_s;
#line 170
    psf->write_int = & gsm610_write_i;
#line 171
    psf->write_float = & gsm610_write_f;
#line 172
    psf->write_double = & gsm610_write_d;
  }
  {
#line 175
  psf->codec_close = & gsm610_close;
#line 177
  psf->seek = & gsm610_seek;
#line 179
  psf->filelength = psf_get_filelen(psf);
#line 180
  psf->datalength = psf->filelength - psf->dataoffset;
  }
#line 182
  return (0);
}
}
#line 190 "/root/patchweave_donee/23/src/gsm610.c"
static int gsm610_wav_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  sf_count_t __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 193
  (pgsm610->blockcount) ++;
#line 194
  pgsm610->samplecount = 0;
#line 196
  if (pgsm610->blockcount > pgsm610->blocks) {
    {
#line 197
    memset((void *)(pgsm610->samples), 0, sizeof(pgsm610->samples));
    }
#line 198
    return (1);
  }
  {
#line 201
  __cil_tmp5 = psf_fread((void *)(pgsm610->block), (sf_count_t )1, (sf_count_t )65,
                         psf);
#line 201
  k = (int )__cil_tmp5;
  }
#line 201
  if (k != 65) {
    {
#line 202
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, 65);
    }
  }
  {
#line 204
  __cil_tmp6 = gsm_decode(pgsm610->gsm_data, pgsm610->block, pgsm610->samples);
  }
#line 204
  if (__cil_tmp6 < 0) {
    {
#line 205
    psf_log_printf(psf, "Error from WAV gsm_decode() on frame : %d\n", pgsm610->blockcount);
    }
#line 206
    return (0);
  }
  {
#line 209
  __cil_tmp7 = gsm_decode(pgsm610->gsm_data, pgsm610->block + 33, pgsm610->samples + 160);
  }
#line 209
  if (__cil_tmp7 < 0) {
    {
#line 210
    psf_log_printf(psf, "Error from WAV gsm_decode() on frame : %d.5\n", pgsm610->blockcount);
    }
#line 211
    return (0);
  }
#line 214
  return (1);
}
}
#line 218 "/root/patchweave_donee/23/src/gsm610.c"
static int gsm610_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  sf_count_t __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 221
  (pgsm610->blockcount) ++;
#line 222
  pgsm610->samplecount = 0;
#line 224
  if (pgsm610->blockcount > pgsm610->blocks) {
    {
#line 225
    memset((void *)(pgsm610->samples), 0, sizeof(pgsm610->samples));
    }
#line 226
    return (1);
  }
  {
#line 229
  __cil_tmp5 = psf_fread((void *)(pgsm610->block), (sf_count_t )1, (sf_count_t )33,
                         psf);
#line 229
  k = (int )__cil_tmp5;
  }
#line 229
  if (k != 33) {
    {
#line 230
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nU", k, 33);
    }
  }
  {
#line 232
  __cil_tmp6 = gsm_decode(pgsm610->gsm_data, pgsm610->block, pgsm610->samples);
  }
#line 232
  if (__cil_tmp6 < 0) {
    {
#line 233
    psf_log_printf(psf, "Error from standard gsm_decode() on frame : %d\n", pgsm610->blockcount);
    }
#line 234
    return (0);
  }
#line 237
  return (1);
}
}
#line 241 "/root/patchweave_donee/23/src/gsm610.c"
static int gsm610_read_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short *ptr ,
                             int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;
  int tmp ;

  {
#line 242
  total = 0;
#line 242
  indx = 0;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;

#line 244
    if (! (indx < len)) {
#line 244
      goto while_break;
    }
#line 245
    if (pgsm610->blockcount >= pgsm610->blocks) {
#line 245
      if (pgsm610->samplecount >= pgsm610->samplesperblock) {
        {
#line 246
        memset((void *)(ptr + indx), 0, (unsigned long )(len - indx) * sizeof(short ));
        }
#line 247
        return (total);
      }
    }
#line 250
    if (pgsm610->samplecount >= pgsm610->samplesperblock) {
      {
#line 251
      (*(pgsm610->decode_block))(psf, pgsm610);
      }
    }
#line 253
    count___0 = pgsm610->samplesperblock - pgsm610->samplecount;
#line 254
    if (len - indx > count___0) {
#line 254
      tmp = count___0;
    } else {
#line 254
      tmp = len - indx;
    }
    {
#line 254
    count___0 = tmp;
#line 256
    memcpy((void *)(ptr + indx), (void const   *)(& pgsm610->samples[pgsm610->samplecount]),
           (unsigned long )count___0 * sizeof(short ));
#line 257
    indx += count___0;
#line 258
    pgsm610->samplecount += count___0;
#line 259
    total = indx;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 262
  return (total);
}
}
#line 266 "/root/patchweave_donee/23/src/gsm610.c"
static sf_count_t gsm610_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 269
  total = (sf_count_t )0;
#line 271
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 272
    return ((sf_count_t )0);
  }
#line 273
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;

#line 275
    if (! (len > 0L)) {
#line 275
      goto while_break;
    }
#line 276
    if (len > 268435456L) {
#line 276
      tmp = 16777216;
    } else {
#line 276
      tmp = (int )len;
    }
    {
#line 276
    readcount = tmp;
#line 278
    count___0 = gsm610_read_block(psf, pgsm610, ptr, readcount);
#line 280
    total += (long )count___0;
#line 281
    len -= (long )count___0;
    }
#line 283
    if (count___0 != readcount) {
#line 284
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 287
  return (total);
}
}
#line 291 "/root/patchweave_donee/23/src/gsm610.c"
static sf_count_t gsm610_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 295
  readcount = 0;
#line 296
  total = (sf_count_t )0;
#line 298
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 299
    return ((sf_count_t )0);
  }
#line 300
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 302
  sptr = ubuf.sbuf;
#line 303
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;

#line 304
    if (! (len > 0L)) {
#line 304
      goto while_break;
    }
#line 305
    if (len >= (long )bufferlen) {
#line 305
      tmp = (long )bufferlen;
    } else {
#line 305
      tmp = len;
    }
    {
#line 305
    readcount = (int )tmp;
#line 306
    count___0 = gsm610_read_block(psf, pgsm610, sptr, readcount);
#line 307
    k = 0;
    }
    {
#line 307
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 307
      if (! (k < readcount)) {
#line 307
        goto while_break___0;
      }
      {
#line 308
      *(ptr + (total + (long )k)) = arith_shift_left((int32_t )*(sptr + k), 16);
#line 307
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 310
    total += (long )count___0;
#line 311
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 313
  return (total);
}
}
#line 317 "/root/patchweave_donee/23/src/gsm610.c"
static sf_count_t gsm610_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 321
  readcount = 0;
#line 322
  total = (sf_count_t )0;
#line 325
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 326
    return ((sf_count_t )0);
  }
#line 327
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 329
  if (psf->norm_float == 1) {
#line 329
    tmp = 1. / (double )((float )32768);
  } else {
#line 329
    tmp = 1.;
  }
#line 329
  normfact = (float )tmp;
#line 331
  sptr = ubuf.sbuf;
#line 332
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;

#line 333
    if (! (len > 0L)) {
#line 333
      goto while_break;
    }
#line 334
    if (len >= (long )bufferlen) {
#line 334
      tmp___0 = (long )bufferlen;
    } else {
#line 334
      tmp___0 = len;
    }
    {
#line 334
    readcount = (int )tmp___0;
#line 335
    count___0 = gsm610_read_block(psf, pgsm610, sptr, readcount);
#line 336
    k = 0;
    }
    {
#line 336
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 336
      if (! (k < readcount)) {
#line 336
        goto while_break___0;
      }
#line 337
      *(ptr + (total + (long )k)) = normfact * (float )((int )*(sptr + k));
#line 336
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 339
    total += (long )count___0;
#line 340
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 342
  return (total);
}
}
#line 346 "/root/patchweave_donee/23/src/gsm610.c"
static sf_count_t gsm610_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 350
  readcount = 0;
#line 351
  total = (sf_count_t )0;
#line 354
  if (psf->norm_double == 1) {
#line 354
    tmp = 1. / (double )32768;
  } else {
#line 354
    tmp = 1.;
  }
#line 354
  normfact = tmp;
#line 356
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 357
    return ((sf_count_t )0);
  }
#line 358
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 360
  sptr = ubuf.sbuf;
#line 361
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;

#line 362
    if (! (len > 0L)) {
#line 362
      goto while_break;
    }
#line 363
    if (len >= (long )bufferlen) {
#line 363
      tmp___0 = (long )bufferlen;
    } else {
#line 363
      tmp___0 = len;
    }
    {
#line 363
    readcount = (int )tmp___0;
#line 364
    count___0 = gsm610_read_block(psf, pgsm610, sptr, readcount);
#line 365
    k = 0;
    }
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 365
      if (! (k < readcount)) {
#line 365
        goto while_break___0;
      }
#line 366
      *(ptr + (total + (long )k)) = normfact * (double )((int )*(sptr + k));
#line 365
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 368
    total += (long )count___0;
#line 369
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 371
  return (total);
}
}
#line 375 "/root/patchweave_donee/23/src/gsm610.c"
static sf_count_t gsm610_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int newblock ;
  int newsample ;
  int true_flag ;

  {
#line 379
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 380
    return ((sf_count_t )0);
  }
#line 381
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 383
  if (psf->dataoffset < 0L) {
#line 384
    psf->error = 39;
#line 385
    return ((sf_count_t )-1);
  }
#line 388
  if (offset == 0L) {
    {
#line 389
    true_flag = 1;
#line 391
    psf_fseek(psf, psf->dataoffset, 0);
#line 392
    pgsm610->blockcount = 0;
#line 394
    gsm_init(pgsm610->gsm_data);
    }
#line 395
    if ((psf->sf.format & 268369920) == 65536) {
      {
#line 397
      gsm_option(pgsm610->gsm_data, 4, & true_flag);
      }
    } else
#line 395
    if ((psf->sf.format & 268369920) == 720896) {
      {
#line 397
      gsm_option(pgsm610->gsm_data, 4, & true_flag);
      }
    }
    {
#line 399
    (*(pgsm610->decode_block))(psf, pgsm610);
#line 400
    pgsm610->samplecount = 0;
    }
#line 401
    return ((sf_count_t )0);
  }
#line 404
  if (offset < 0L) {
#line 405
    psf->error = 39;
#line 406
    return ((sf_count_t )-1);
  } else
#line 404
  if (offset > (long )(pgsm610->blocks * pgsm610->samplesperblock)) {
#line 405
    psf->error = 39;
#line 406
    return ((sf_count_t )-1);
  }
#line 409
  newblock = (int )(offset / (long )pgsm610->samplesperblock);
#line 410
  newsample = (int )(offset % (long )pgsm610->samplesperblock);
#line 412
  if (psf->file.mode == 16) {
#line 413
    if (psf->read_current != (long )(newblock * pgsm610->samplesperblock + newsample)) {
      {
#line 414
      psf_fseek(psf, psf->dataoffset + (long )(newblock * pgsm610->samplesperblock),
                0);
#line 415
      pgsm610->blockcount = newblock;
#line 416
      (*(pgsm610->decode_block))(psf, pgsm610);
#line 417
      pgsm610->samplecount = newsample;
      }
    }
#line 420
    return ((sf_count_t )(newblock * pgsm610->samplesperblock + newsample));
  }
#line 424
  psf->error = 39;
#line 425
  return ((sf_count_t )-1);
}
}
#line 433 "/root/patchweave_donee/23/src/gsm610.c"
static int gsm610_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 437
  gsm_encode(pgsm610->gsm_data, pgsm610->samples, pgsm610->block);
#line 440
  __cil_tmp4 = psf_fwrite((void const   *)(pgsm610->block), (sf_count_t )1, (sf_count_t )33,
                          psf);
#line 440
  k = (int )__cil_tmp4;
  }
#line 440
  if (k != 33) {
    {
#line 441
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, 33);
    }
  }
  {
#line 443
  pgsm610->samplecount = 0;
#line 444
  (pgsm610->blockcount) ++;
#line 447
  memset((void *)(pgsm610->samples), 0, sizeof(pgsm610->samples));
  }
#line 449
  return (1);
}
}
#line 453 "/root/patchweave_donee/23/src/gsm610.c"
static int gsm610_wav_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 457
  gsm_encode(pgsm610->gsm_data, pgsm610->samples, pgsm610->block);
#line 458
  gsm_encode(pgsm610->gsm_data, pgsm610->samples + 160, pgsm610->block + 32);
#line 461
  __cil_tmp4 = psf_fwrite((void const   *)(pgsm610->block), (sf_count_t )1, (sf_count_t )65,
                          psf);
#line 461
  k = (int )__cil_tmp4;
  }
#line 461
  if (k != 65) {
    {
#line 462
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, 65);
    }
  }
  {
#line 464
  pgsm610->samplecount = 0;
#line 465
  (pgsm610->blockcount) ++;
#line 468
  memset((void *)(pgsm610->samples), 0, sizeof(pgsm610->samples));
  }
#line 470
  return (1);
}
}
#line 474 "/root/patchweave_donee/23/src/gsm610.c"
static int gsm610_write_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short const   *ptr ,
                              int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;

  {
#line 475
  total = 0;
#line 475
  indx = 0;
  {
#line 477
  while (1) {
    while_continue: /* CIL Label */ ;

#line 477
    if (! (indx < len)) {
#line 477
      goto while_break;
    }
#line 478
    count___0 = pgsm610->samplesperblock - pgsm610->samplecount;
#line 480
    if (count___0 > len - indx) {
#line 481
      count___0 = len - indx;
    }
    {
#line 483
    memcpy((void *)(& pgsm610->samples[pgsm610->samplecount]), (void const   *)(ptr + indx),
           (unsigned long )count___0 * sizeof(short ));
#line 484
    indx += count___0;
#line 485
    pgsm610->samplecount += count___0;
#line 486
    total = indx;
    }
#line 488
    if (pgsm610->samplecount >= pgsm610->samplesperblock) {
      {
#line 489
      (*(pgsm610->encode_block))(psf, pgsm610);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 492
  return (total);
}
}
#line 496 "/root/patchweave_donee/23/src/gsm610.c"
static sf_count_t gsm610_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 499
  total = (sf_count_t )0;
#line 501
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 502
    return ((sf_count_t )0);
  }
#line 503
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;

#line 505
    if (! (len > 0L)) {
#line 505
      goto while_break;
    }
#line 506
    if (len > 268435456L) {
#line 506
      tmp = 268435456;
    } else {
#line 506
      tmp = (int )len;
    }
    {
#line 506
    writecount = tmp;
#line 508
    count___0 = gsm610_write_block(psf, pgsm610, ptr, writecount);
#line 510
    total += (long )count___0;
#line 511
    len -= (long )count___0;
    }
#line 513
    if (count___0 != writecount) {
#line 514
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 517
  return (total);
}
}
#line 521 "/root/patchweave_donee/23/src/gsm610.c"
static sf_count_t gsm610_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 525
  writecount = 0;
#line 526
  total = (sf_count_t )0;
#line 528
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 529
    return ((sf_count_t )0);
  }
#line 530
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 532
  sptr = ubuf.sbuf;
#line 533
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;

#line 534
    if (! (len > 0L)) {
#line 534
      goto while_break;
    }
#line 535
    if (len >= (long )bufferlen) {
#line 535
      tmp = (long )bufferlen;
    } else {
#line 535
      tmp = len;
    }
#line 535
    writecount = (int )tmp;
#line 536
    k = 0;
    {
#line 536
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 536
      if (! (k < writecount)) {
#line 536
        goto while_break___0;
      }
#line 537
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 536
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 538
    count___0 = gsm610_write_block(psf, pgsm610, (short const   *)sptr, writecount);
#line 540
    total += (long )count___0;
#line 541
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 543
  return (total);
}
}
#line 547 "/root/patchweave_donee/23/src/gsm610.c"
static sf_count_t gsm610_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 551
  writecount = 0;
#line 552
  total = (sf_count_t )0;
#line 555
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 556
    return ((sf_count_t )0);
  }
#line 557
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 559
  if (psf->norm_float == 1) {
#line 559
    tmp = 1. * (double )32767;
  } else {
#line 559
    tmp = 1.;
  }
#line 559
  normfact = (float )tmp;
#line 561
  sptr = ubuf.sbuf;
#line 562
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;

#line 563
    if (! (len > 0L)) {
#line 563
      goto while_break;
    }
#line 564
    if (len >= (long )bufferlen) {
#line 564
      tmp___0 = (long )bufferlen;
    } else {
#line 564
      tmp___0 = len;
    }
#line 564
    writecount = (int )tmp___0;
#line 565
    k = 0;
    {
#line 565
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 565
      if (! (k < writecount)) {
#line 565
        goto while_break___0;
      }
      {
#line 566
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 566
      *(sptr + k) = (short )__cil_tmp15;
#line 565
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 567
    count___0 = gsm610_write_block(psf, pgsm610, (short const   *)sptr, writecount);
#line 569
    total += (long )count___0;
#line 570
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 572
  return (total);
}
}
#line 576 "/root/patchweave_donee/23/src/gsm610.c"
static sf_count_t gsm610_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  BUF_UNION ubuf ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 580
  writecount = 0;
#line 581
  total = (sf_count_t )0;
#line 584
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 585
    return ((sf_count_t )0);
  }
#line 586
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 588
  if (psf->norm_double == 1) {
#line 588
    tmp = 1. * (double )32767;
  } else {
#line 588
    tmp = 1.;
  }
#line 588
  normfact = tmp;
#line 590
  sptr = ubuf.sbuf;
#line 591
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;

#line 592
    if (! (len > 0L)) {
#line 592
      goto while_break;
    }
#line 593
    if (len >= (long )bufferlen) {
#line 593
      tmp___0 = (long )bufferlen;
    } else {
#line 593
      tmp___0 = len;
    }
#line 593
    writecount = (int )tmp___0;
#line 594
    k = 0;
    {
#line 594
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 594
      if (! (k < writecount)) {
#line 594
        goto while_break___0;
      }
      {
#line 595
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 595
      *(sptr + k) = (short )__cil_tmp15;
#line 594
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 596
    count___0 = gsm610_write_block(psf, pgsm610, (short const   *)sptr, writecount);
#line 598
    total += (long )count___0;
#line 599
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 601
  return (total);
}
}
#line 605 "/root/patchweave_donee/23/src/gsm610.c"
static int gsm610_close(SF_PRIVATE *psf ) 
{ 
  GSM610_PRIVATE *pgsm610 ;

  {
#line 608
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 609
    return (0);
  }
#line 611
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 613
  if (psf->file.mode == 32) {
#line 618
    if (pgsm610->samplecount) {
#line 618
      if (pgsm610->samplecount < pgsm610->samplesperblock) {
        {
#line 619
        (*(pgsm610->encode_block))(psf, pgsm610);
        }
      }
    }
  }
#line 622
  if (pgsm610->gsm_data) {
    {
#line 623
    gsm_destroy(pgsm610->gsm_data);
    }
  }
#line 625
  return (0);
}
}
#line 56 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t host_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 57
static sf_count_t host_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 58
static sf_count_t host_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 59
static sf_count_t host_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 61
static sf_count_t host_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 62
static sf_count_t host_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 63
static sf_count_t host_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 64
static sf_count_t host_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 66
static void float32_peak_update(SF_PRIVATE *psf , float const   *buffer , int count___0 ,
                                sf_count_t indx ) ;
#line 68
static sf_count_t replace_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 69
static sf_count_t replace_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 70
static sf_count_t replace_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 71
static sf_count_t replace_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 73
static sf_count_t replace_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 74
static sf_count_t replace_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 75
static sf_count_t replace_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 76
static sf_count_t replace_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 78
static void bf2f_array(float *buffer , int count___0 ) ;
#line 79
static void f2bf_array(float *buffer , int count___0 ) ;
#line 81
static int float32_get_capability(SF_PRIVATE *psf ) ;
#line 90 "/root/patchweave_donee/23/src/float32.c"
static int float_caps  ;
#line 88 "/root/patchweave_donee/23/src/float32.c"
int float32_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;
  sf_count_t tmp___0 ;

  {
#line 91
  if (psf->sf.channels < 1) {
    {
#line 92
    psf_log_printf(psf, "float32_init : internal error : channels = %d\n", psf->sf.channels);
    }
#line 93
    return (30);
  }
  {
#line 96
  float_caps = float32_get_capability(psf);
#line 98
  psf->blockwidth = (int )(sizeof(float ) * (unsigned long )psf->sf.channels);
  }
#line 100
  if (psf->file.mode == 16) {
    _L: 
#line 102
    if (psf->endian + float_caps == 536870947) {
#line 102
      goto case_536870947;
    }
#line 110
    if (psf->endian + float_caps == 268435474) {
#line 110
      goto case_268435474;
    }
#line 118
    if (psf->endian + float_caps == 536870930) {
#line 118
      goto case_536870930;
    }
#line 126
    if (psf->endian + float_caps == 268435491) {
#line 126
      goto case_268435491;
    }
#line 135
    if (psf->endian + float_caps == 536870964) {
#line 135
      goto case_536870964;
    }
#line 143
    if (psf->endian + float_caps == 268435508) {
#line 143
      goto case_268435508;
    }
#line 151
    if (psf->endian + float_caps == 536870981) {
#line 151
      goto case_536870981;
    }
#line 159
    if (psf->endian + float_caps == 268435525) {
#line 159
      goto case_268435525;
    }
#line 167
    goto switch_default;
    case_536870947: 
#line 103
    psf->data_endswap = 0;
#line 104
    psf->read_short = & host_read_f2s;
#line 105
    psf->read_int = & host_read_f2i;
#line 106
    psf->read_float = & host_read_f;
#line 107
    psf->read_double = & host_read_f2d;
#line 108
    goto switch_break;
    case_268435474: 
#line 111
    psf->data_endswap = 0;
#line 112
    psf->read_short = & host_read_f2s;
#line 113
    psf->read_int = & host_read_f2i;
#line 114
    psf->read_float = & host_read_f;
#line 115
    psf->read_double = & host_read_f2d;
#line 116
    goto switch_break;
    case_536870930: 
#line 119
    psf->data_endswap = 1;
#line 120
    psf->read_short = & host_read_f2s;
#line 121
    psf->read_int = & host_read_f2i;
#line 122
    psf->read_float = & host_read_f;
#line 123
    psf->read_double = & host_read_f2d;
#line 124
    goto switch_break;
    case_268435491: 
#line 127
    psf->data_endswap = 1;
#line 128
    psf->read_short = & host_read_f2s;
#line 129
    psf->read_int = & host_read_f2i;
#line 130
    psf->read_float = & host_read_f;
#line 131
    psf->read_double = & host_read_f2d;
#line 132
    goto switch_break;
    case_536870964: 
#line 136
    psf->data_endswap = 1;
#line 137
    psf->read_short = & replace_read_f2s;
#line 138
    psf->read_int = & replace_read_f2i;
#line 139
    psf->read_float = & replace_read_f;
#line 140
    psf->read_double = & replace_read_f2d;
#line 141
    goto switch_break;
    case_268435508: 
#line 144
    psf->data_endswap = 0;
#line 145
    psf->read_short = & replace_read_f2s;
#line 146
    psf->read_int = & replace_read_f2i;
#line 147
    psf->read_float = & replace_read_f;
#line 148
    psf->read_double = & replace_read_f2d;
#line 149
    goto switch_break;
    case_536870981: 
#line 152
    psf->data_endswap = 0;
#line 153
    psf->read_short = & replace_read_f2s;
#line 154
    psf->read_int = & replace_read_f2i;
#line 155
    psf->read_float = & replace_read_f;
#line 156
    psf->read_double = & replace_read_f2d;
#line 157
    goto switch_break;
    case_268435525: 
#line 160
    psf->data_endswap = 1;
#line 161
    psf->read_short = & replace_read_f2s;
#line 162
    psf->read_int = & replace_read_f2i;
#line 163
    psf->read_float = & replace_read_f;
#line 164
    psf->read_double = & replace_read_f2d;
#line 165
    goto switch_break;
    switch_default: 
#line 167
    goto switch_break;
    switch_break: ;
  } else
#line 100
  if (psf->file.mode == 48) {
#line 100
    goto _L;
  }
#line 171
  if (psf->file.mode == 32) {
    _L___3: 
#line 173
    if (psf->endian + float_caps == 268435474) {
#line 173
      goto case_268435474___0;
    }
#line 181
    if (psf->endian + float_caps == 536870947) {
#line 181
      goto case_536870947___0;
    }
#line 189
    if (psf->endian + float_caps == 536870930) {
#line 189
      goto case_536870930___0;
    }
#line 197
    if (psf->endian + float_caps == 268435491) {
#line 197
      goto case_268435491___0;
    }
#line 206
    if (psf->endian + float_caps == 536870964) {
#line 206
      goto case_536870964___0;
    }
#line 214
    if (psf->endian + float_caps == 268435508) {
#line 214
      goto case_268435508___0;
    }
#line 222
    if (psf->endian + float_caps == 536870981) {
#line 222
      goto case_536870981___0;
    }
#line 230
    if (psf->endian + float_caps == 268435525) {
#line 230
      goto case_268435525___0;
    }
#line 238
    goto switch_default___0;
    case_268435474___0: 
#line 174
    psf->data_endswap = 0;
#line 175
    psf->write_short = & host_write_s2f;
#line 176
    psf->write_int = & host_write_i2f;
#line 177
    psf->write_float = & host_write_f;
#line 178
    psf->write_double = & host_write_d2f;
#line 179
    goto switch_break___0;
    case_536870947___0: 
#line 182
    psf->data_endswap = 0;
#line 183
    psf->write_short = & host_write_s2f;
#line 184
    psf->write_int = & host_write_i2f;
#line 185
    psf->write_float = & host_write_f;
#line 186
    psf->write_double = & host_write_d2f;
#line 187
    goto switch_break___0;
    case_536870930___0: 
#line 190
    psf->data_endswap = 1;
#line 191
    psf->write_short = & host_write_s2f;
#line 192
    psf->write_int = & host_write_i2f;
#line 193
    psf->write_float = & host_write_f;
#line 194
    psf->write_double = & host_write_d2f;
#line 195
    goto switch_break___0;
    case_268435491___0: 
#line 198
    psf->data_endswap = 1;
#line 199
    psf->write_short = & host_write_s2f;
#line 200
    psf->write_int = & host_write_i2f;
#line 201
    psf->write_float = & host_write_f;
#line 202
    psf->write_double = & host_write_d2f;
#line 203
    goto switch_break___0;
    case_536870964___0: 
#line 207
    psf->data_endswap = 1;
#line 208
    psf->write_short = & replace_write_s2f;
#line 209
    psf->write_int = & replace_write_i2f;
#line 210
    psf->write_float = & replace_write_f;
#line 211
    psf->write_double = & replace_write_d2f;
#line 212
    goto switch_break___0;
    case_268435508___0: 
#line 215
    psf->data_endswap = 0;
#line 216
    psf->write_short = & replace_write_s2f;
#line 217
    psf->write_int = & replace_write_i2f;
#line 218
    psf->write_float = & replace_write_f;
#line 219
    psf->write_double = & replace_write_d2f;
#line 220
    goto switch_break___0;
    case_536870981___0: 
#line 223
    psf->data_endswap = 0;
#line 224
    psf->write_short = & replace_write_s2f;
#line 225
    psf->write_int = & replace_write_i2f;
#line 226
    psf->write_float = & replace_write_f;
#line 227
    psf->write_double = & replace_write_d2f;
#line 228
    goto switch_break___0;
    case_268435525___0: 
#line 231
    psf->data_endswap = 1;
#line 232
    psf->write_short = & replace_write_s2f;
#line 233
    psf->write_int = & replace_write_i2f;
#line 234
    psf->write_float = & replace_write_f;
#line 235
    psf->write_double = & replace_write_d2f;
#line 236
    goto switch_break___0;
    switch_default___0: 
#line 238
    goto switch_break___0;
    switch_break___0: ;
  } else
#line 171
  if (psf->file.mode == 48) {
#line 171
    goto _L___3;
  }
#line 242
  if (psf->filelength > psf->dataoffset) {
#line 243
    if (psf->dataend > 0L) {
#line 243
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 243
      tmp = psf->filelength - psf->dataoffset;
    }
#line 243
    psf->datalength = tmp;
  } else {
#line 247
    psf->datalength = (sf_count_t )0;
  }
#line 249
  if (psf->blockwidth > 0) {
#line 249
    tmp___0 = psf->datalength / (long )psf->blockwidth;
  } else {
#line 249
    tmp___0 = 0L;
  }
#line 249
  psf->sf.frames = tmp___0;
#line 251
  return (0);
}
}
#line 255 "/root/patchweave_donee/23/src/float32.c"
float float32_be_read(unsigned char const   *cptr ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  float fvalue ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double __cil_tmp9 ;
  int __cil_tmp10 ;
  double __cil_tmp11 ;

  {
#line 259
  negative = (int )*(cptr + 0) & 128;
#line 260
  if ((int )*(cptr + 1) & 128) {
#line 260
    tmp = 1;
  } else {
#line 260
    tmp = 0;
  }
#line 260
  exponent = (((int )*(cptr + 0) & 127) << 1) | tmp;
#line 261
  mantissa = ((((int )*(cptr + 1) & 127) << 16) | ((int )*(cptr + 2) << 8)) | (int )*(cptr + 3);
#line 263
  if (! exponent) {
#line 263
    if (! mantissa) {
#line 264
      return ((float )0.);
    }
  }
#line 266
  mantissa |= 8388608;
#line 267
  if (exponent) {
#line 267
    tmp___0 = exponent - 127;
  } else {
#line 267
    tmp___0 = 0;
  }
#line 267
  exponent = tmp___0;
#line 269
  if (mantissa) {
#line 269
    tmp___1 = (double )((float )mantissa / (float )8388608);
  } else {
#line 269
    tmp___1 = 0.;
  }
#line 269
  fvalue = (float )tmp___1;
#line 271
  if (negative) {
#line 272
    fvalue *= (float )-1;
  }
#line 274
  if (exponent > 0) {
    {
#line 275
    __cil_tmp9 = pow(2., (double )exponent);
#line 275
    fvalue = (float )((double )fvalue * __cil_tmp9);
    }
  } else
#line 276
  if (exponent < 0) {
    {
#line 277
    __cil_tmp10 = abs(exponent);
#line 277
    __cil_tmp11 = pow(2., (double )__cil_tmp10);
#line 277
    fvalue = (float )((double )fvalue / __cil_tmp11);
    }
  }
#line 279
  return (fvalue);
}
}
#line 283 "/root/patchweave_donee/23/src/float32.c"
float float32_le_read(unsigned char const   *cptr ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  float fvalue ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double __cil_tmp9 ;
  int __cil_tmp10 ;
  double __cil_tmp11 ;

  {
#line 287
  negative = (int )*(cptr + 3) & 128;
#line 288
  if ((int )*(cptr + 2) & 128) {
#line 288
    tmp = 1;
  } else {
#line 288
    tmp = 0;
  }
#line 288
  exponent = (((int )*(cptr + 3) & 127) << 1) | tmp;
#line 289
  mantissa = ((((int )*(cptr + 2) & 127) << 16) | ((int )*(cptr + 1) << 8)) | (int )*(cptr + 0);
#line 291
  if (! exponent) {
#line 291
    if (! mantissa) {
#line 292
      return ((float )0.);
    }
  }
#line 294
  mantissa |= 8388608;
#line 295
  if (exponent) {
#line 295
    tmp___0 = exponent - 127;
  } else {
#line 295
    tmp___0 = 0;
  }
#line 295
  exponent = tmp___0;
#line 297
  if (mantissa) {
#line 297
    tmp___1 = (double )((float )mantissa / (float )8388608);
  } else {
#line 297
    tmp___1 = 0.;
  }
#line 297
  fvalue = (float )tmp___1;
#line 299
  if (negative) {
#line 300
    fvalue *= (float )-1;
  }
#line 302
  if (exponent > 0) {
    {
#line 303
    __cil_tmp9 = pow(2., (double )exponent);
#line 303
    fvalue = (float )((double )fvalue * __cil_tmp9);
    }
  } else
#line 304
  if (exponent < 0) {
    {
#line 305
    __cil_tmp10 = abs(exponent);
#line 305
    __cil_tmp11 = pow(2., (double )__cil_tmp10);
#line 305
    fvalue = (float )((double )fvalue / __cil_tmp11);
    }
  }
#line 307
  return (fvalue);
}
}
#line 311 "/root/patchweave_donee/23/src/float32.c"
void float32_le_write(float in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;

  {
  {
#line 312
  negative = 0;
#line 314
  memset((void *)out, 0, sizeof(int ));
#line 316
  __cil_tmp6 = fabs((double )in);
  }
#line 316
  if (__cil_tmp6 < 1.00000000001e-30) {
#line 317
    return;
  }
#line 319
  if ((double )in < 0.) {
#line 320
    in = (float )((double )in * - 1.);
#line 321
    negative = 1;
  }
  {
#line 324
  __cil_tmp7 = frexp((double )in, & exponent);
#line 324
  in = (float )__cil_tmp7;
#line 326
  exponent += 126;
#line 328
  in *= (float )16777216;
#line 329
  mantissa = (int )in & 8388607;
  }
#line 331
  if (negative) {
#line 332
    *(out + 3) = (unsigned char )((int )*(out + 3) | 128);
  }
#line 334
  if (exponent & 1) {
#line 335
    *(out + 2) = (unsigned char )((int )*(out + 2) | 128);
  }
#line 337
  *(out + 0) = (unsigned char )(mantissa & 255);
#line 338
  *(out + 1) = (unsigned char )((mantissa >> 8) & 255);
#line 339
  *(out + 2) = (unsigned char )((int )*(out + 2) | ((mantissa >> 16) & 127));
#line 340
  *(out + 3) = (unsigned char )((int )*(out + 3) | ((exponent >> 1) & 127));
#line 342
  return;
}
}
#line 346 "/root/patchweave_donee/23/src/float32.c"
void float32_be_write(float in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;

  {
  {
#line 347
  negative = 0;
#line 349
  memset((void *)out, 0, sizeof(int ));
#line 351
  __cil_tmp6 = fabs((double )in);
  }
#line 351
  if (__cil_tmp6 < 1.00000000001e-30) {
#line 352
    return;
  }
#line 354
  if ((double )in < 0.) {
#line 355
    in = (float )((double )in * - 1.);
#line 356
    negative = 1;
  }
  {
#line 359
  __cil_tmp7 = frexp((double )in, & exponent);
#line 359
  in = (float )__cil_tmp7;
#line 361
  exponent += 126;
#line 363
  in *= (float )16777216;
#line 364
  mantissa = (int )in & 8388607;
  }
#line 366
  if (negative) {
#line 367
    *(out + 0) = (unsigned char )((int )*(out + 0) | 128);
  }
#line 369
  if (exponent & 1) {
#line 370
    *(out + 1) = (unsigned char )((int )*(out + 1) | 128);
  }
#line 372
  *(out + 3) = (unsigned char )(mantissa & 255);
#line 373
  *(out + 2) = (unsigned char )((mantissa >> 8) & 255);
#line 374
  *(out + 1) = (unsigned char )((int )*(out + 1) | ((mantissa >> 16) & 127));
#line 375
  *(out + 0) = (unsigned char )((int )*(out + 0) | ((exponent >> 1) & 127));
#line 377
  return;
}
}
#line 385 "/root/patchweave_donee/23/src/float32.c"
static void float32_peak_update(SF_PRIVATE *psf , float const   *buffer , int count___0 ,
                                sf_count_t indx ) 
{ 
  int chan ;
  int k ;
  int position ;
  float fmaxval ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;

  {
#line 390
  chan = 0;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;

#line 390
    if (! (chan < psf->sf.channels)) {
#line 390
      goto while_break;
    }
    {
#line 391
    __cil_tmp9 = fabs((double )*(buffer + chan));
#line 391
    fmaxval = (float )__cil_tmp9;
#line 392
    position = 0;
#line 393
    k = chan;
    }
    {
#line 393
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 393
      if (! (k < count___0)) {
#line 393
        goto while_break___0;
      }
      {
#line 394
      __cil_tmp10 = fabs((double )*(buffer + k));
      }
#line 394
      if ((double )fmaxval < __cil_tmp10) {
        {
#line 395
        __cil_tmp11 = fabs((double )*(buffer + k));
#line 395
        fmaxval = (float )__cil_tmp11;
#line 396
        position = k;
        }
      }
#line 393
      k += psf->sf.channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 399
    if ((double )fmaxval > (psf->peak_info)->peaks[chan].value) {
#line 400
      (psf->peak_info)->peaks[chan].value = (double )fmaxval;
#line 401
      (psf->peak_info)->peaks[chan].position = (psf->write_current + indx) + (long )(position / psf->sf.channels);
    }
#line 390
    chan ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 405
  return;
}
}
#line 409 "/root/patchweave_donee/23/src/float32.c"
static int float32_get_capability(SF_PRIVATE *psf ) 
{ 
  union __anonunion_484 data ;
  int tmp ;

  {
#line 416
  data.f = (float )1.23456789;
#line 418
  if (! psf->ieee_replace) {
#line 420
    if ((int )data.c[0] == 82) {
#line 420
      if ((int )data.c[1] == 6) {
#line 420
        if ((int )data.c[2] == 158) {
#line 420
          if ((int )data.c[3] == 63) {
#line 421
            return (18);
          }
        }
      }
    }
#line 424
    if ((int )data.c[3] == 82) {
#line 424
      if ((int )data.c[2] == 6) {
#line 424
        if ((int )data.c[1] == 158) {
#line 424
          if ((int )data.c[0] == 63) {
#line 425
            return (35);
          }
        }
      }
    }
  }
  {
#line 429
  psf_log_printf(psf, "Using IEEE replacement code for float.\n");
#line 431
  tmp = 52;
  }
#line 431
  return (tmp);
}
}
#line 438 "/root/patchweave_donee/23/src/float32.c"
static void f2s_array(float const   *src , int count___0 , short *dest , float scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    count___0 --;
#line 440
    if (! (count___0 >= 0)) {
#line 440
      goto while_break;
    }
    {
#line 441
    __cil_tmp5 = lrintf(scale * (float )*(src + count___0));
#line 441
    *(dest + count___0) = (short )__cil_tmp5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 447
  return;
}
}
#line 446 "/root/patchweave_donee/23/src/float32.c"
static void f2s_clip_array(float const   *src , int count___0 , short *dest , float scale ) 
{ 
  float tmp ;
  long __cil_tmp6 ;

  {
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    count___0 --;
#line 447
    if (! (count___0 >= 0)) {
#line 447
      goto while_break;
    }
#line 448
    tmp = scale * (float )*(src + count___0);
#line 450
    if ((double )tmp > 32767.) {
#line 451
      *(dest + count___0) = (short)32767;
    } else
#line 452
    if ((double )tmp < - 32768.) {
#line 453
      *(dest + count___0) = (short)-32768;
    } else {
      {
#line 455
      __cil_tmp6 = lrintf(tmp);
#line 455
      *(dest + count___0) = (short )__cil_tmp6;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 462
  return;
}
}
#line 460 "/root/patchweave_donee/23/src/float32.c"
__inline static void f2i_array(float const   *src , int count___0 , int *dest , float scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    count___0 --;
#line 461
    if (! (count___0 >= 0)) {
#line 461
      goto while_break;
    }
    {
#line 462
    __cil_tmp5 = lrintf(scale * (float )*(src + count___0));
#line 462
    *(dest + count___0) = (int )__cil_tmp5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 468
  return;
}
}
#line 467 "/root/patchweave_donee/23/src/float32.c"
__inline static void f2i_clip_array(float const   *src , int count___0 , int *dest ,
                                    float scale ) 
{ 
  float tmp ;
  long __cil_tmp6 ;

  {
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    count___0 --;
#line 468
    if (! (count___0 >= 0)) {
#line 468
      goto while_break;
    }
#line 469
    tmp = scale * (float )*(src + count___0);
#line 471
    if ((double )tmp > 1. * (double )2147483647) {
#line 472
      *(dest + count___0) = 2147483647;
    } else
#line 473
    if ((double )tmp < - 1. * (double )2147483647) {
#line 474
      *(dest + count___0) = (-0x7FFFFFFF-1);
    } else {
      {
#line 476
      __cil_tmp6 = lrintf(tmp);
#line 476
      *(dest + count___0) = (int )__cil_tmp6;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 483
  return;
}
}
#line 481 "/root/patchweave_donee/23/src/float32.c"
__inline static void f2d_array(float const   *src , int count___0 , double *dest ) 
{ 


  {
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    count___0 --;
#line 482
    if (! (count___0 >= 0)) {
#line 482
      goto while_break;
    }
#line 483
    *(dest + count___0) = (double )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 488
  return;
}
}
#line 488 "/root/patchweave_donee/23/src/float32.c"
__inline static void s2f_array(short const   *src , float *dest , int count___0 ,
                               float scale ) 
{ 


  {
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    count___0 --;
#line 489
    if (! (count___0 >= 0)) {
#line 489
      goto while_break;
    }
#line 490
    *(dest + count___0) = scale * (float )((int )*(src + count___0));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 495
  return;
}
}
#line 495 "/root/patchweave_donee/23/src/float32.c"
__inline static void i2f_array(int const   *src , float *dest , int count___0 , float scale ) 
{ 


  {
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    count___0 --;
#line 496
    if (! (count___0 >= 0)) {
#line 496
      goto while_break;
    }
#line 497
    *(dest + count___0) = scale * (float )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 502
  return;
}
}
#line 502 "/root/patchweave_donee/23/src/float32.c"
__inline static void d2f_array(double const   *src , float *dest , int count___0 ) 
{ 


  {
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    count___0 --;
#line 503
    if (! (count___0 >= 0)) {
#line 503
      goto while_break;
    }
#line 504
    *(dest + count___0) = (float )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 509
  return;
}
}
#line 512 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t host_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , int  , short * , float  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  void (*tmp)(float const   *src , int count , short *dest , float scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 516
  total = (sf_count_t )0;
#line 519
  if (psf->add_clipping) {
#line 519
    tmp = & f2s_clip_array;
  } else {
#line 519
    tmp = & f2s_array;
  }
#line 519
  convert = tmp;
#line 520
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
#line 521
  if (psf->float_int_mult == 0) {
#line 521
    tmp___0 = 1.;
  } else {
#line 521
    tmp___0 = (double )((float )32767 / psf->float_max);
  }
#line 521
  scale = (float )tmp___0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;

#line 523
    if (! (len > 0L)) {
#line 523
      goto while_break;
    }
#line 524
    if (len < (long )bufferlen) {
#line 525
      bufferlen = (int )len;
    }
    {
#line 526
    __cil_tmp12 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 526
    readcount = (int )__cil_tmp12;
    }
#line 529
    if (psf->data_endswap == 1) {
      {
#line 530
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 532
    (*convert)((float const   *)(ubuf.fbuf), readcount, ptr + total, scale);
#line 533
    total += (long )readcount;
    }
#line 534
    if (readcount < bufferlen) {
#line 535
      goto while_break;
    }
#line 536
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 539
  return (total);
}
}
#line 543 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t host_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(float const   * , int  , int * , float  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  void (*tmp)(float const   *src , int count , int *dest , float scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 547
  total = (sf_count_t )0;
#line 550
  if (psf->add_clipping) {
#line 550
    tmp = & f2i_clip_array;
  } else {
#line 550
    tmp = & f2i_array;
  }
#line 550
  convert = tmp;
#line 551
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
#line 552
  if (psf->float_int_mult == 0) {
#line 552
    tmp___0 = 1.;
  } else {
#line 552
    tmp___0 = (double )((float )2147483647 / psf->float_max);
  }
#line 552
  scale = (float )tmp___0;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;

#line 554
    if (! (len > 0L)) {
#line 554
      goto while_break;
    }
#line 555
    if (len < (long )bufferlen) {
#line 556
      bufferlen = (int )len;
    }
    {
#line 557
    __cil_tmp12 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 557
    readcount = (int )__cil_tmp12;
    }
#line 559
    if (psf->data_endswap == 1) {
      {
#line 560
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 562
    (*convert)((float const   *)(ubuf.fbuf), readcount, ptr + total, scale);
#line 563
    total += (long )readcount;
    }
#line 564
    if (readcount < bufferlen) {
#line 565
      goto while_break;
    }
#line 566
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 569
  return (total);
}
}
#line 573 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t host_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 576
  total = (sf_count_t )0;
#line 578
  if (psf->data_endswap != 1) {
    {
#line 579
    __cil_tmp8 = psf_fread((void *)ptr, (sf_count_t )sizeof(float ), len, psf);
    }
#line 579
    return (__cil_tmp8);
  }
#line 581
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;

#line 583
    if (! (len > 0L)) {
#line 583
      goto while_break;
    }
#line 584
    if (len < (long )bufferlen) {
#line 585
      bufferlen = (int )len;
    }
    {
#line 586
    __cil_tmp9 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 586
    readcount = (int )__cil_tmp9;
#line 588
    endswap_int_copy((int *)(ptr + total), (int const   *)(ubuf.ibuf), readcount);
#line 590
    total += (long )readcount;
    }
#line 591
    if (readcount < bufferlen) {
#line 592
      goto while_break;
    }
#line 593
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 596
  return (total);
}
}
#line 600 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t host_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 603
  total = (sf_count_t )0;
#line 605
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;

#line 607
    if (! (len > 0L)) {
#line 607
      goto while_break;
    }
#line 608
    if (len < (long )bufferlen) {
#line 609
      bufferlen = (int )len;
    }
    {
#line 610
    __cil_tmp8 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 610
    readcount = (int )__cil_tmp8;
    }
#line 612
    if (psf->data_endswap == 1) {
      {
#line 613
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 616
    f2d_array((float const   *)(ubuf.fbuf), readcount, ptr + total);
#line 617
    total += (long )readcount;
    }
#line 618
    if (readcount < bufferlen) {
#line 619
      goto while_break;
    }
#line 620
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 623
  return (total);
}
}
#line 627 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t host_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 630
  total = (sf_count_t )0;
#line 634
  if (psf->scale_int_float == 0) {
#line 634
    tmp = 1.;
  } else {
#line 634
    tmp = 1. / (double )32768;
  }
#line 634
  scale = (float )tmp;
#line 635
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;

#line 637
    if (! (len > 0L)) {
#line 637
      goto while_break;
    }
#line 638
    if (len < (long )bufferlen) {
#line 639
      bufferlen = (int )len;
    }
    {
#line 640
    s2f_array(ptr + total, ubuf.fbuf, bufferlen, scale);
    }
#line 642
    if (psf->peak_info) {
      {
#line 643
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 645
    if (psf->data_endswap == 1) {
      {
#line 646
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 648
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                             (sf_count_t )bufferlen, psf);
#line 648
    writecount = (int )__cil_tmp10;
#line 649
    total += (long )writecount;
    }
#line 650
    if (writecount < bufferlen) {
#line 651
      goto while_break;
    }
#line 652
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 655
  return (total);
}
}
#line 659 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t host_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 662
  total = (sf_count_t )0;
#line 665
  if (psf->scale_int_float == 0) {
#line 665
    tmp = 1.;
  } else {
#line 665
    tmp = 1. / (8. * (double )268435456);
  }
#line 665
  scale = (float )tmp;
#line 666
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;

#line 668
    if (! (len > 0L)) {
#line 668
      goto while_break;
    }
#line 669
    if (len < (long )bufferlen) {
#line 670
      bufferlen = (int )len;
    }
    {
#line 671
    i2f_array(ptr + total, ubuf.fbuf, bufferlen, scale);
    }
#line 673
    if (psf->peak_info) {
      {
#line 674
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 676
    if (psf->data_endswap == 1) {
      {
#line 677
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 679
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                             (sf_count_t )bufferlen, psf);
#line 679
    writecount = (int )__cil_tmp10;
#line 680
    total += (long )writecount;
    }
#line 681
    if (writecount < bufferlen) {
#line 682
      goto while_break;
    }
#line 683
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 686
  return (total);
}
}
#line 690 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t host_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 693
  total = (sf_count_t )0;
#line 695
  if (psf->peak_info) {
    {
#line 696
    float32_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 698
  if (psf->data_endswap != 1) {
    {
#line 699
    __cil_tmp8 = psf_fwrite((void const   *)ptr, (sf_count_t )sizeof(float ), len,
                            psf);
    }
#line 699
    return (__cil_tmp8);
  }
#line 701
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;

#line 703
    if (! (len > 0L)) {
#line 703
      goto while_break;
    }
#line 704
    if (len < (long )bufferlen) {
#line 705
      bufferlen = (int )len;
    }
    {
#line 707
    endswap_int_copy(ubuf.ibuf, (int const   *)(ptr + total), bufferlen);
#line 709
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                            (sf_count_t )bufferlen, psf);
#line 709
    writecount = (int )__cil_tmp9;
#line 710
    total += (long )writecount;
    }
#line 711
    if (writecount < bufferlen) {
#line 712
      goto while_break;
    }
#line 713
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 716
  return (total);
}
}
#line 720 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t host_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 723
  total = (sf_count_t )0;
#line 725
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;

#line 727
    if (! (len > 0L)) {
#line 727
      goto while_break;
    }
#line 728
    if (len < (long )bufferlen) {
#line 729
      bufferlen = (int )len;
    }
    {
#line 731
    d2f_array(ptr + total, ubuf.fbuf, bufferlen);
    }
#line 733
    if (psf->peak_info) {
      {
#line 734
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 736
    if (psf->data_endswap == 1) {
      {
#line 737
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 739
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                            (sf_count_t )bufferlen, psf);
#line 739
    writecount = (int )__cil_tmp8;
#line 740
    total += (long )writecount;
    }
#line 741
    if (writecount < bufferlen) {
#line 742
      goto while_break;
    }
#line 743
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 746
  return (total);
}
}
#line 753 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t replace_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 756
  total = (sf_count_t )0;
#line 759
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
#line 760
  if (psf->float_int_mult == 0) {
#line 760
    tmp = 1.;
  } else {
#line 760
    tmp = (double )((float )32767 / psf->float_max);
  }
#line 760
  scale = (float )tmp;
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;

#line 762
    if (! (len > 0L)) {
#line 762
      goto while_break;
    }
#line 763
    if (len < (long )bufferlen) {
#line 764
      bufferlen = (int )len;
    }
    {
#line 765
    __cil_tmp10 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 765
    readcount = (int )__cil_tmp10;
    }
#line 767
    if (psf->data_endswap == 1) {
      {
#line 768
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 770
    bf2f_array(ubuf.fbuf, bufferlen);
#line 772
    f2s_array((float const   *)(ubuf.fbuf), readcount, ptr + total, scale);
#line 773
    total += (long )readcount;
    }
#line 774
    if (readcount < bufferlen) {
#line 775
      goto while_break;
    }
#line 776
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 779
  return (total);
}
}
#line 783 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t replace_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 786
  total = (sf_count_t )0;
#line 789
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
#line 790
  if (psf->float_int_mult == 0) {
#line 790
    tmp = 1.;
  } else {
#line 790
    tmp = (double )((float )32767 / psf->float_max);
  }
#line 790
  scale = (float )tmp;
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;

#line 792
    if (! (len > 0L)) {
#line 792
      goto while_break;
    }
#line 793
    if (len < (long )bufferlen) {
#line 794
      bufferlen = (int )len;
    }
    {
#line 795
    __cil_tmp10 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 795
    readcount = (int )__cil_tmp10;
    }
#line 797
    if (psf->data_endswap == 1) {
      {
#line 798
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 800
    bf2f_array(ubuf.fbuf, bufferlen);
#line 802
    f2i_array((float const   *)(ubuf.fbuf), readcount, ptr + total, scale);
#line 803
    total += (long )readcount;
    }
#line 804
    if (readcount < bufferlen) {
#line 805
      goto while_break;
    }
#line 806
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 809
  return (total);
}
}
#line 813 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t replace_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 816
  total = (sf_count_t )0;
#line 820
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 822
  while (1) {
    while_continue: /* CIL Label */ ;

#line 822
    if (! (len > 0L)) {
#line 822
      goto while_break;
    }
#line 823
    if (len < (long )bufferlen) {
#line 824
      bufferlen = (int )len;
    }
    {
#line 825
    __cil_tmp8 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 825
    readcount = (int )__cil_tmp8;
    }
#line 827
    if (psf->data_endswap == 1) {
      {
#line 828
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 830
    bf2f_array(ubuf.fbuf, bufferlen);
#line 832
    memcpy((void *)(ptr + total), (void const   *)(ubuf.fbuf), (unsigned long )bufferlen * sizeof(float ));
#line 834
    total += (long )readcount;
    }
#line 835
    if (readcount < bufferlen) {
#line 836
      goto while_break;
    }
#line 837
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 840
  return (total);
}
}
#line 844 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t replace_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 847
  total = (sf_count_t )0;
#line 849
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;

#line 851
    if (! (len > 0L)) {
#line 851
      goto while_break;
    }
#line 852
    if (len < (long )bufferlen) {
#line 853
      bufferlen = (int )len;
    }
    {
#line 854
    __cil_tmp8 = psf_fread((void *)(ubuf.fbuf), (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 854
    readcount = (int )__cil_tmp8;
    }
#line 856
    if (psf->data_endswap == 1) {
      {
#line 857
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 859
    bf2f_array(ubuf.fbuf, bufferlen);
#line 861
    f2d_array((float const   *)(ubuf.fbuf), readcount, ptr + total);
#line 862
    total += (long )readcount;
    }
#line 863
    if (readcount < bufferlen) {
#line 864
      goto while_break;
    }
#line 865
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 868
  return (total);
}
}
#line 872 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t replace_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 875
  total = (sf_count_t )0;
#line 878
  if (psf->scale_int_float == 0) {
#line 878
    tmp = 1.;
  } else {
#line 878
    tmp = 1. / (double )32768;
  }
#line 878
  scale = (float )tmp;
#line 879
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;

#line 881
    if (! (len > 0L)) {
#line 881
      goto while_break;
    }
#line 882
    if (len < (long )bufferlen) {
#line 883
      bufferlen = (int )len;
    }
    {
#line 884
    s2f_array(ptr + total, ubuf.fbuf, bufferlen, scale);
    }
#line 886
    if (psf->peak_info) {
      {
#line 887
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
    {
#line 889
    f2bf_array(ubuf.fbuf, bufferlen);
    }
#line 891
    if (psf->data_endswap == 1) {
      {
#line 892
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 894
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                             (sf_count_t )bufferlen, psf);
#line 894
    writecount = (int )__cil_tmp10;
#line 895
    total += (long )writecount;
    }
#line 896
    if (writecount < bufferlen) {
#line 897
      goto while_break;
    }
#line 898
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 901
  return (total);
}
}
#line 905 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t replace_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 908
  total = (sf_count_t )0;
#line 911
  if (psf->scale_int_float == 0) {
#line 911
    tmp = 1.;
  } else {
#line 911
    tmp = 1. / (8. * (double )268435456);
  }
#line 911
  scale = (float )tmp;
#line 912
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 914
  while (1) {
    while_continue: /* CIL Label */ ;

#line 914
    if (! (len > 0L)) {
#line 914
      goto while_break;
    }
#line 915
    if (len < (long )bufferlen) {
#line 916
      bufferlen = (int )len;
    }
    {
#line 917
    i2f_array(ptr + total, ubuf.fbuf, bufferlen, scale);
    }
#line 919
    if (psf->peak_info) {
      {
#line 920
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
    {
#line 922
    f2bf_array(ubuf.fbuf, bufferlen);
    }
#line 924
    if (psf->data_endswap == 1) {
      {
#line 925
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 927
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                             (sf_count_t )bufferlen, psf);
#line 927
    writecount = (int )__cil_tmp10;
#line 928
    total += (long )writecount;
    }
#line 929
    if (writecount < bufferlen) {
#line 930
      goto while_break;
    }
#line 931
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 934
  return (total);
}
}
#line 938 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t replace_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 941
  total = (sf_count_t )0;
#line 944
  if (psf->peak_info) {
    {
#line 945
    float32_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 947
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 949
  while (1) {
    while_continue: /* CIL Label */ ;

#line 949
    if (! (len > 0L)) {
#line 949
      goto while_break;
    }
#line 950
    if (len < (long )bufferlen) {
#line 951
      bufferlen = (int )len;
    }
    {
#line 953
    memcpy((void *)(ubuf.fbuf), (void const   *)(ptr + total), (unsigned long )bufferlen * sizeof(float ));
#line 955
    f2bf_array(ubuf.fbuf, bufferlen);
    }
#line 957
    if (psf->data_endswap == 1) {
      {
#line 958
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 960
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                            (sf_count_t )bufferlen, psf);
#line 960
    writecount = (int )__cil_tmp8;
#line 961
    total += (long )writecount;
    }
#line 962
    if (writecount < bufferlen) {
#line 963
      goto while_break;
    }
#line 964
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 967
  return (total);
}
}
#line 971 "/root/patchweave_donee/23/src/float32.c"
static sf_count_t replace_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 974
  total = (sf_count_t )0;
#line 976
  bufferlen = (int )(sizeof(ubuf.fbuf) / sizeof(ubuf.fbuf[0]));
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;

#line 978
    if (! (len > 0L)) {
#line 978
      goto while_break;
    }
#line 979
    if (len < (long )bufferlen) {
#line 980
      bufferlen = (int )len;
    }
    {
#line 981
    d2f_array(ptr + total, ubuf.fbuf, bufferlen);
    }
#line 983
    if (psf->peak_info) {
      {
#line 984
      float32_peak_update(psf, (float const   *)(ubuf.fbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
    {
#line 986
    f2bf_array(ubuf.fbuf, bufferlen);
    }
#line 988
    if (psf->data_endswap == 1) {
      {
#line 989
      endswap_int_array(ubuf.ibuf, bufferlen);
      }
    }
    {
#line 991
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.fbuf), (sf_count_t )sizeof(float ),
                            (sf_count_t )bufferlen, psf);
#line 991
    writecount = (int )__cil_tmp8;
#line 992
    total += (long )writecount;
    }
#line 993
    if (writecount < bufferlen) {
#line 994
      goto while_break;
    }
#line 995
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 998
  return (total);
}
}
#line 1005 "/root/patchweave_donee/23/src/float32.c"
static void bf2f_array(float *buffer , int count___0 ) 
{ 


  {
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1006
    count___0 --;
#line 1006
    if (! (count___0 >= 0)) {
#line 1006
      goto while_break;
    }
    {
#line 1007
    *(buffer + count___0) = float32_le_read((unsigned char const   *)((unsigned char *)(buffer + count___0)));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1013
  return;
}
}
#line 1012 "/root/patchweave_donee/23/src/float32.c"
static void f2bf_array(float *buffer , int count___0 ) 
{ 


  {
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1013
    count___0 --;
#line 1013
    if (! (count___0 >= 0)) {
#line 1013
      goto while_break;
    }
    {
#line 1014
    float32_le_write(*(buffer + count___0), (unsigned char *)(buffer + count___0));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1020
  return;
}
}
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                                                          struct stat *__statbuf ) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 224
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat64)(char const   *__path ,
                                                                                            struct stat64 *__statbuf ) ;
#line 226
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat64)(int __fd ,
                                                                                             struct stat64 *__statbuf ) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat)(int __fd ,
                                                                                             char const   *__filename ,
                                                                                             struct stat *__statbuf ,
                                                                                             int __flag ) ;
#line 249
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat64)(int __fd ,
                                                                                               char const   *__filename ,
                                                                                               struct stat64 *__statbuf ,
                                                                                               int __flag ) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                                                           struct stat *__statbuf ) ;
#line 272
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat64)(char const   *__path ,
                                                                                             struct stat64 *__statbuf ) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknodat)(int __fd ,
                                                                                             char const   *__path ,
                                                                                             __mode_t __mode ,
                                                                                             __dev_t __dev ) ;
#line 395
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag ) ;
#line 428
extern  __attribute__((__nothrow__)) int __fxstat64(int __ver , int __fildes , struct stat64 *__stat_buf ) ;
#line 430
extern  __attribute__((__nothrow__)) int __xstat64(int __ver , char const   *__filename ,
                                                   struct stat64 *__stat_buf ) ;
#line 432
extern  __attribute__((__nothrow__)) int __lxstat64(int __ver , char const   *__filename ,
                                                    struct stat64 *__stat_buf ) ;
#line 434
extern  __attribute__((__nothrow__)) int __fxstatat64(int __ver , int __fildes , char const   *__filename ,
                                                      struct stat64 *__stat_buf ,
                                                      int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev ) ;
#line 453
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                                                          struct stat *__statbuf ) ;
#line 453 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) stat)(char const   *__path ,
                                                            struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = __xstat(1, __path, __statbuf);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 460
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                                                           struct stat *__statbuf ) ;
#line 460 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) lstat)(char const   *__path ,
                                                             struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 462
  __cil_tmp3 = __lxstat(1, __path, __statbuf);
  }
#line 462
  return (__cil_tmp3);
}
}
#line 467
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
#line 467 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 469
  __cil_tmp3 = __fxstat(1, __fd, __statbuf);
  }
#line 469
  return (__cil_tmp3);
}
}
#line 474
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat)(int __fd ,
                                                                                             char const   *__filename ,
                                                                                             struct stat *__statbuf ,
                                                                                             int __flag ) ;
#line 474 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstatat)(int __fd , char const   *__filename ,
                                                               struct stat *__statbuf ,
                                                               int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 477
  __cil_tmp5 = __fxstatat(1, __fd, __filename, __statbuf, __flag);
  }
#line 477
  return (__cil_tmp5);
}
}
#line 483
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
#line 483 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) mknod)(char const   *__path ,
                                                             __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 485
  __cil_tmp4 = __xmknod(0, __path, __mode, & __dev);
  }
#line 485
  return (__cil_tmp4);
}
}
#line 491
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknodat)(int __fd ,
                                                                                             char const   *__path ,
                                                                                             __mode_t __mode ,
                                                                                             __dev_t __dev ) ;
#line 491 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) mknodat)(int __fd , char const   *__path ,
                                                               __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 494
  __cil_tmp5 = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 494
  return (__cil_tmp5);
}
}
#line 502
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) stat64)(char const   *__path ,
                                                                                            struct stat64 *__statbuf ) ;
#line 502 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) stat64)(char const   *__path ,
                                                              struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 504
  __cil_tmp3 = __xstat64(1, __path, __statbuf);
  }
#line 504
  return (__cil_tmp3);
}
}
#line 509
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) lstat64)(char const   *__path ,
                                                                                             struct stat64 *__statbuf ) ;
#line 509 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) lstat64)(char const   *__path ,
                                                               struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 511
  __cil_tmp3 = __lxstat64(1, __path, __statbuf);
  }
#line 511
  return (__cil_tmp3);
}
}
#line 516
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstat64)(int __fd ,
                                                                                             struct stat64 *__statbuf ) ;
#line 516 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 518
  __cil_tmp3 = __fxstat64(1, __fd, __statbuf);
  }
#line 518
  return (__cil_tmp3);
}
}
#line 523
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) fstatat64)(int __fd ,
                                                                                               char const   *__filename ,
                                                                                               struct stat64 *__statbuf ,
                                                                                               int __flag ) ;
#line 523 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__gnu_inline__)) fstatat64)(int __fd , char const   *__filename ,
                                                                 struct stat64 *__statbuf ,
                                                                 int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 526
  __cil_tmp5 = __fxstatat64(1, __fd, __filename, __statbuf, __flag);
  }
#line 526
  return (__cil_tmp5);
}
}
#line 67 "/root/patchweave_donee/23/src/file_io.c"
static void psf_log_syserr(SF_PRIVATE *psf , int error ) ;
#line 75
static int psf_close_fd(int fd ) ;
#line 76
static int psf_open_fd(PSF_FILE *pfile ) ;
#line 77
static sf_count_t psf_get_filelen_fd(int fd ) ;
#line 80 "/root/patchweave_donee/23/src/file_io.c"
int psf_fopen(SF_PRIVATE *psf ) 
{ 
  int *__cil_tmp3 ;

  {
  {
#line 82
  psf->error = 0;
#line 83
  psf->file.filedes = psf_open_fd(& psf->file);
  }
#line 85
  if (psf->file.filedes == -44) {
#line 86
    psf->error = 44;
#line 87
    psf->file.filedes = -1;
#line 88
    return (psf->error);
  }
#line 91
  if (psf->file.filedes == -1) {
    {
#line 92
    __cil_tmp3 = __errno_location();
#line 92
    psf_log_syserr(psf, *__cil_tmp3);
    }
  }
#line 94
  return (psf->error);
}
}
#line 98 "/root/patchweave_donee/23/src/file_io.c"
int psf_fclose(SF_PRIVATE *psf ) 
{ 
  int retval ;
  int *__cil_tmp4 ;

  {
#line 101
  if (psf->virtual_io) {
#line 102
    return (0);
  }
#line 104
  if (psf->file.do_not_close_descriptor) {
#line 105
    psf->file.filedes = -1;
#line 106
    return (0);
  }
  {
#line 109
  retval = psf_close_fd(psf->file.filedes);
  }
#line 109
  if (retval == -1) {
    {
#line 110
    __cil_tmp4 = __errno_location();
#line 110
    psf_log_syserr(psf, *__cil_tmp4);
    }
  }
#line 112
  psf->file.filedes = -1;
#line 114
  return (retval);
}
}
#line 118 "/root/patchweave_donee/23/src/file_io.c"
int psf_open_rsrc(SF_PRIVATE *psf ) 
{ 
  int *__cil_tmp8 ;

  {
#line 120
  if (psf->rsrc.filedes > 0) {
#line 121
    return (0);
  }
  {
#line 124
  snprintf(psf->rsrc.path.c, sizeof(psf->rsrc.path.c), "%s/..namedfork/rsrc", psf->file.path.c);
#line 125
  psf->error = 0;
#line 126
  psf->rsrc.filedes = psf_open_fd(& psf->rsrc);
  }
#line 126
  if (psf->rsrc.filedes >= 0) {
    {
#line 127
    psf->rsrclength = psf_get_filelen_fd(psf->rsrc.filedes);
    }
#line 128
    if (psf->rsrclength > 0L) {
#line 129
      return (0);
    } else
#line 128
    if (psf->rsrc.mode & 32) {
#line 129
      return (0);
    }
    {
#line 130
    psf_close_fd(psf->rsrc.filedes);
#line 131
    psf->rsrc.filedes = -1;
    }
  }
#line 134
  if (psf->rsrc.filedes == -44) {
#line 135
    psf->error = 44;
#line 136
    return (psf->error);
  }
  {
#line 143
  snprintf(psf->rsrc.path.c, sizeof(psf->rsrc.path.c), "%s._%s", psf->file.dir.c,
           psf->file.name.c);
#line 144
  psf->error = 0;
#line 145
  psf->rsrc.filedes = psf_open_fd(& psf->rsrc);
  }
#line 145
  if (psf->rsrc.filedes >= 0) {
    {
#line 146
    psf->rsrclength = psf_get_filelen_fd(psf->rsrc.filedes);
    }
#line 147
    return (0);
  }
  {
#line 154
  snprintf(psf->rsrc.path.c, sizeof(psf->rsrc.path.c), "%s.AppleDouble/%s", psf->file.dir.c,
           psf->file.name.c);
#line 155
  psf->error = 0;
#line 156
  psf->rsrc.filedes = psf_open_fd(& psf->rsrc);
  }
#line 156
  if (psf->rsrc.filedes >= 0) {
    {
#line 157
    psf->rsrclength = psf_get_filelen_fd(psf->rsrc.filedes);
    }
#line 158
    return (0);
  }
#line 162
  if (psf->rsrc.filedes == -1) {
    {
#line 163
    __cil_tmp8 = __errno_location();
#line 163
    psf_log_syserr(psf, *__cil_tmp8);
    }
  }
#line 165
  psf->rsrc.filedes = -1;
#line 167
  return (psf->error);
}
}
#line 171 "/root/patchweave_donee/23/src/file_io.c"
sf_count_t psf_get_filelen(SF_PRIVATE *psf ) 
{ 
  sf_count_t filelen ;
  sf_count_t __cil_tmp3 ;
  int *__cil_tmp5 ;

  {
#line 174
  if (psf->virtual_io) {
    {
#line 175
    __cil_tmp3 = (*(psf->vio.get_filelen))(psf->vio_user_data);
    }
#line 175
    return (__cil_tmp3);
  }
  {
#line 177
  filelen = psf_get_filelen_fd(psf->file.filedes);
  }
#line 179
  if (filelen == -1L) {
    {
#line 180
    __cil_tmp5 = __errno_location();
#line 180
    psf_log_syserr(psf, *__cil_tmp5);
    }
#line 181
    return ((sf_count_t )-1);
  }
#line 184
  if (filelen == -15L) {
#line 185
    psf->error = 15;
#line 186
    return ((sf_count_t )-1);
  }
#line 190
  if (psf->file.mode == 32) {
#line 190
    goto case_32;
  }
#line 194
  if (psf->file.mode == 16) {
#line 194
    goto case_16;
  }
#line 199
  if (psf->file.mode == 48) {
#line 199
    goto case_48;
  }
#line 207
  goto switch_default;
  case_32: 
#line 191
  filelen -= psf->fileoffset;
#line 192
  goto switch_break;
  case_16: 
#line 195
  if (psf->fileoffset > 0L) {
#line 195
    if (psf->filelength > 0L) {
#line 196
      filelen = psf->filelength;
    }
  }
#line 197
  goto switch_break;
  case_48: 
#line 205
  goto switch_break;
  switch_default: 
#line 209
  filelen = (sf_count_t )-1;
  switch_break: ;
#line 212
  return (filelen);
}
}
#line 216 "/root/patchweave_donee/23/src/file_io.c"
int psf_close_rsrc(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 217
  psf_close_fd(psf->rsrc.filedes);
#line 218
  psf->rsrc.filedes = -1;
  }
#line 219
  return (0);
}
}
#line 223 "/root/patchweave_donee/23/src/file_io.c"
int psf_set_stdio(SF_PRIVATE *psf ) 
{ 
  int error ;

  {
#line 224
  error = 0;
#line 227
  if (psf->file.mode == 48) {
#line 227
    goto case_48;
  }
#line 231
  if (psf->file.mode == 16) {
#line 231
    goto case_16;
  }
#line 235
  if (psf->file.mode == 32) {
#line 235
    goto case_32;
  }
#line 239
  goto switch_default;
  case_48: 
#line 228
  error = 45;
#line 229
  goto switch_break;
  case_16: 
#line 232
  psf->file.filedes = 0;
#line 233
  goto switch_break;
  case_32: 
#line 236
  psf->file.filedes = 1;
#line 237
  goto switch_break;
  switch_default: 
#line 240
  error = 44;
#line 241
  goto switch_break;
  switch_break: 
#line 243
  psf->filelength = (sf_count_t )0;
#line 245
  return (error);
}
}
#line 249 "/root/patchweave_donee/23/src/file_io.c"
void psf_set_file(SF_PRIVATE *psf , int fd ) 
{ 


  {
#line 250
  psf->file.filedes = fd;
#line 251
  return;
}
}
#line 254 "/root/patchweave_donee/23/src/file_io.c"
int psf_file_valid(SF_PRIVATE *psf ) 
{ 
  int tmp ;

  {
#line 255
  if (psf->file.filedes >= 0) {
#line 255
    tmp = 1;
  } else {
#line 255
    tmp = 0;
  }
#line 255
  return (tmp);
}
}
#line 259 "/root/patchweave_donee/23/src/file_io.c"
sf_count_t psf_fseek(SF_PRIVATE *psf , sf_count_t offset , int whence ) 
{ 
  sf_count_t current_pos ;
  sf_count_t new_position ;
  sf_count_t __cil_tmp6 ;
  int *__cil_tmp9 ;
  __off_t __cil_tmp10 ;
  int *__cil_tmp12 ;

  {
#line 262
  if (psf->virtual_io) {
    {
#line 263
    __cil_tmp6 = (*(psf->vio.seek))(offset, whence, psf->vio_user_data);
    }
#line 263
    return (__cil_tmp6);
  }
  {
#line 265
  current_pos = psf_ftell(psf);
  }
#line 268
  if (whence == 0) {
#line 268
    goto case_0;
  }
#line 272
  if (whence == 2) {
#line 272
    goto case_2;
  }
#line 290
  if (whence == 1) {
#line 290
    goto case_1;
  }
#line 296
  goto switch_default;
  case_0: 
#line 269
  offset += psf->fileoffset;
#line 270
  goto switch_break;
  case_2: 
#line 273
  if (psf->file.mode == 32) {
    {
#line 274
    new_position = lseek(psf->file.filedes, offset, whence);
    }
#line 276
    if (new_position < 0L) {
      {
#line 277
      __cil_tmp9 = __errno_location();
#line 277
      psf_log_syserr(psf, *__cil_tmp9);
      }
    }
#line 279
    return (new_position - psf->fileoffset);
  }
  {
#line 286
  whence = 0;
#line 287
  __cil_tmp10 = lseek(psf->file.filedes, (__off_t )0, 2);
#line 287
  offset = __cil_tmp10 + offset;
  }
#line 288
  goto switch_break;
  case_1: 
#line 292
  offset += current_pos;
#line 293
  whence = 0;
#line 294
  goto switch_break;
  switch_default: 
  {
#line 298
  psf_log_printf(psf, "psf_fseek : whence is %d *****.\n\230\001", whence);
  }
#line 299
  return ((sf_count_t )0);
  switch_break: ;
#line 302
  if (current_pos != offset) {
    {
#line 303
    new_position = lseek(psf->file.filedes, offset, whence);
    }
  } else {
#line 305
    new_position = offset;
  }
#line 307
  if (new_position < 0L) {
    {
#line 308
    __cil_tmp12 = __errno_location();
#line 308
    psf_log_syserr(psf, *__cil_tmp12);
    }
  }
#line 310
  new_position -= psf->fileoffset;
#line 312
  return (new_position);
}
}
#line 316 "/root/patchweave_donee/23/src/file_io.c"
sf_count_t psf_fread(void *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) 
{ 
  sf_count_t total ;
  ssize_t count___0 ;
  sf_count_t __cil_tmp7 ;
  long tmp ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
#line 317
  total = (sf_count_t )0;
#line 320
  if (psf->virtual_io) {
    {
#line 321
    __cil_tmp7 = (*(psf->vio.read))(ptr, bytes * items, psf->vio_user_data);
    }
#line 321
    return (__cil_tmp7 / bytes);
  }
#line 323
  items *= bytes;
#line 326
  if (items <= 0L) {
#line 327
    return ((sf_count_t )0);
  }
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 329
    if (! (items > 0L)) {
#line 329
      goto while_break;
    }
#line 331
    if (items > 1073741824L) {
#line 331
      tmp = 1073741824L;
    } else {
#line 331
      tmp = items;
    }
    {
#line 331
    count___0 = tmp;
#line 333
    count___0 = read(psf->file.filedes, (void *)((char *)ptr + total), (size_t )count___0);
    }
#line 335
    if (count___0 == -1L) {
      {
#line 336
      __cil_tmp10 = __errno_location();
      }
#line 336
      if (*__cil_tmp10 == 4) {
#line 337
        goto while_continue;
      }
      {
#line 339
      __cil_tmp11 = __errno_location();
#line 339
      psf_log_syserr(psf, *__cil_tmp11);
      }
#line 340
      goto while_break;
    }
#line 343
    if (count___0 == 0L) {
#line 344
      goto while_break;
    }
#line 346
    total += count___0;
#line 347
    items -= count___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 350
  if (psf->is_pipe) {
#line 351
    psf->pipeoffset += total;
  }
#line 353
  return (total / bytes);
}
}
#line 357 "/root/patchweave_donee/23/src/file_io.c"
sf_count_t psf_fwrite(void const   *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) 
{ 
  sf_count_t total ;
  ssize_t count___0 ;
  sf_count_t __cil_tmp7 ;
  long tmp ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
#line 358
  total = (sf_count_t )0;
#line 361
  if (bytes == 0L) {
#line 362
    return ((sf_count_t )0);
  } else
#line 361
  if (items == 0L) {
#line 362
    return ((sf_count_t )0);
  }
#line 364
  if (psf->virtual_io) {
    {
#line 365
    __cil_tmp7 = (*(psf->vio.write))(ptr, bytes * items, psf->vio_user_data);
    }
#line 365
    return (__cil_tmp7 / bytes);
  }
#line 367
  items *= bytes;
#line 370
  if (items <= 0L) {
#line 371
    return ((sf_count_t )0);
  }
  {
#line 373
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 373
    if (! (items > 0L)) {
#line 373
      goto while_break;
    }
#line 375
    if (items > 1073741824L) {
#line 375
      tmp = 1073741824L;
    } else {
#line 375
      tmp = items;
    }
    {
#line 375
    count___0 = tmp;
#line 377
    count___0 = write(psf->file.filedes, (void const   *)((char const   *)ptr + total),
                      (size_t )count___0);
    }
#line 379
    if (count___0 == -1L) {
      {
#line 380
      __cil_tmp10 = __errno_location();
      }
#line 380
      if (*__cil_tmp10 == 4) {
#line 381
        goto while_continue;
      }
      {
#line 383
      __cil_tmp11 = __errno_location();
#line 383
      psf_log_syserr(psf, *__cil_tmp11);
      }
#line 384
      goto while_break;
    }
#line 387
    if (count___0 == 0L) {
#line 388
      goto while_break;
    }
#line 390
    total += count___0;
#line 391
    items -= count___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 394
  if (psf->is_pipe) {
#line 395
    psf->pipeoffset += total;
  }
#line 397
  return (total / bytes);
}
}
#line 401 "/root/patchweave_donee/23/src/file_io.c"
sf_count_t psf_ftell(SF_PRIVATE *psf ) 
{ 
  sf_count_t pos ;
  sf_count_t __cil_tmp3 ;
  int *__cil_tmp5 ;

  {
#line 404
  if (psf->virtual_io) {
    {
#line 405
    __cil_tmp3 = (*(psf->vio.tell))(psf->vio_user_data);
    }
#line 405
    return (__cil_tmp3);
  }
#line 407
  if (psf->is_pipe) {
#line 408
    return (psf->pipeoffset);
  }
  {
#line 410
  pos = lseek(psf->file.filedes, (__off_t )0, 1);
  }
#line 412
  if (pos == -1L) {
    {
#line 413
    __cil_tmp5 = __errno_location();
#line 413
    psf_log_syserr(psf, *__cil_tmp5);
    }
#line 414
    return ((sf_count_t )-1);
  }
#line 417
  return (pos - psf->fileoffset);
}
}
#line 421 "/root/patchweave_donee/23/src/file_io.c"
static int psf_close_fd(int fd ) 
{ 
  int retval ;
  int *__cil_tmp4 ;

  {
#line 424
  if (fd < 0) {
#line 425
    return (0);
  }
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 427
    __cil_tmp4 = __errno_location();
#line 427
    retval = close(fd);
    }
#line 427
    if (retval == -1) {
#line 427
      if (! (*__cil_tmp4 == 4)) {
#line 427
        goto while_break;
      }
    } else {
#line 427
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 430
  return (retval);
}
}
#line 434 "/root/patchweave_donee/23/src/file_io.c"
sf_count_t psf_fgets(char *buffer , sf_count_t bufsize , SF_PRIVATE *psf ) 
{ 
  sf_count_t k ;
  sf_count_t count___0 ;
  int *__cil_tmp7 ;
  int *__cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 435
  k = (sf_count_t )0;
  {
#line 438
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 438
    if (! (k < bufsize - 1L)) {
#line 438
      goto while_break;
    }
    {
#line 439
    count___0 = read(psf->file.filedes, (void *)(buffer + k), (size_t )1);
    }
#line 441
    if (count___0 == -1L) {
      {
#line 442
      __cil_tmp7 = __errno_location();
      }
#line 442
      if (*__cil_tmp7 == 4) {
#line 443
        goto while_continue;
      }
      {
#line 445
      __cil_tmp8 = __errno_location();
#line 445
      psf_log_syserr(psf, *__cil_tmp8);
      }
#line 446
      goto while_break;
    }
#line 449
    __cil_tmp9 = k;
#line 449
    k ++;
#line 449
    if (count___0 == 0L) {
#line 450
      goto while_break;
    } else
#line 449
    if ((int )*(buffer + __cil_tmp9) == 10) {
#line 450
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 453
  *(buffer + k) = (char)0;
#line 455
  return (k);
}
}
#line 459 "/root/patchweave_donee/23/src/file_io.c"
int psf_is_pipe(SF_PRIVATE *psf ) 
{ 
  struct stat statbuf ;
  int __cil_tmp3 ;
  int *__cil_tmp4 ;

  {
#line 462
  if (psf->virtual_io) {
#line 463
    return (0);
  }
  {
#line 465
  __cil_tmp3 = fstat(psf->file.filedes, & statbuf);
  }
#line 465
  if (__cil_tmp3 == -1) {
    {
#line 466
    __cil_tmp4 = __errno_location();
#line 466
    psf_log_syserr(psf, *__cil_tmp4);
    }
#line 468
    return (1);
  }
#line 471
  if ((statbuf.st_mode & 61440U) == 4096U) {
#line 472
    return (1);
  } else
#line 471
  if ((statbuf.st_mode & 61440U) == 49152U) {
#line 472
    return (1);
  }
#line 474
  return (0);
}
}
#line 478 "/root/patchweave_donee/23/src/file_io.c"
static sf_count_t psf_get_filelen_fd(int fd ) 
{ 
  struct stat statbuf ;
  int __cil_tmp3 ;

  {
  {
#line 490
  __cil_tmp3 = fstat(fd, & statbuf);
  }
#line 490
  if (__cil_tmp3 == -1) {
#line 491
    return ((sf_count_t )-1);
  }
#line 493
  return (statbuf.st_size);
}
}
#line 498 "/root/patchweave_donee/23/src/file_io.c"
int psf_ftruncate(SF_PRIVATE *psf , sf_count_t len ) 
{ 
  int retval ;
  int *__cil_tmp5 ;

  {
#line 502
  if (len < 0L) {
#line 503
    return (-1);
  }
#line 505
  if (sizeof(__off_t ) < sizeof(sf_count_t )) {
#line 505
    if (len > 2147483647L) {
#line 506
      return (-1);
    }
  }
  {
#line 508
  retval = ftruncate(psf->file.filedes, len);
  }
#line 510
  if (retval == -1) {
    {
#line 511
    __cil_tmp5 = __errno_location();
#line 511
    psf_log_syserr(psf, *__cil_tmp5);
    }
  }
#line 513
  return (retval);
}
}
#line 517 "/root/patchweave_donee/23/src/file_io.c"
void psf_init_files(SF_PRIVATE *psf ) 
{ 


  {
#line 518
  psf->file.filedes = -1;
#line 519
  psf->rsrc.filedes = -1;
#line 520
  psf->file.savedes = -1;
#line 521
  return;
}
}
#line 524 "/root/patchweave_donee/23/src/file_io.c"
void psf_use_rsrc(SF_PRIVATE *psf , int on_off ) 
{ 


  {
#line 526
  if (on_off) {
#line 527
    if (psf->file.filedes != psf->rsrc.filedes) {
#line 528
      psf->file.savedes = psf->file.filedes;
#line 529
      psf->file.filedes = psf->rsrc.filedes;
    }
  } else
#line 532
  if (psf->file.filedes == psf->rsrc.filedes) {
#line 533
    psf->file.filedes = psf->file.savedes;
  }
#line 535
  return;
}
}
#line 539 "/root/patchweave_donee/23/src/file_io.c"
static int psf_open_fd(PSF_FILE *pfile ) 
{ 
  int fd ;
  int oflag ;
  int mode ;

  {
#line 547
  if (sizeof(sf_count_t ) != 8UL) {
    {
#line 548
    puts("\n\n*** Fatal error : sizeof (sf_count_t) != 8\204U");
#line 549
    puts("*** This means that libsndfile was not configured correctly.\n");
#line 550
    exit(1);
    }
  }
#line 554
  if (pfile->mode == 16) {
#line 554
    goto case_16;
  }
#line 559
  if (pfile->mode == 32) {
#line 559
    goto case_32;
  }
#line 564
  if (pfile->mode == 48) {
#line 564
    goto case_48;
  }
#line 569
  goto switch_default;
  case_16: 
#line 555
  oflag = 0;
#line 556
  mode = 0;
#line 557
  goto switch_break;
  case_32: 
#line 560
  oflag = 577;
#line 561
  mode = (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3);
#line 562
  goto switch_break;
  case_48: 
#line 565
  oflag = 66;
#line 566
  mode = (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3);
#line 567
  goto switch_break;
  switch_default: 
#line 570
  return (-44);
#line 571
  goto switch_break;
  switch_break: ;
#line 574
  if (mode == 0) {
    {
#line 575
    fd = open((char const   *)(pfile->path.c), oflag);
    }
  } else {
    {
#line 577
    fd = open((char const   *)(pfile->path.c), oflag, mode);
    }
  }
#line 579
  return (fd);
}
}
#line 583 "/root/patchweave_donee/23/src/file_io.c"
static void psf_log_syserr(SF_PRIVATE *psf , int error ) 
{ 
  char *__cil_tmp3 ;

  {
#line 586
  if (psf->error == 0) {
    {
#line 587
    psf->error = 2;
#line 588
    __cil_tmp3 = strerror(error);
#line 588
    snprintf(psf->syserr, sizeof(psf->syserr), "System error : %s.", __cil_tmp3);
    }
  }
#line 591
  return;
}
}
#line 595 "/root/patchweave_donee/23/src/file_io.c"
void psf_fsync(SF_PRIVATE *psf ) 
{ 


  {
#line 598
  if (psf->file.mode == 32) {
    {
#line 599
    fsync(psf->file.filedes);
    }
  } else
#line 598
  if (psf->file.mode == 48) {
    {
#line 599
    fsync(psf->file.filedes);
    }
  }
#line 603
  return;
}
}
#line 53 "/root/patchweave_donee/23/src/dwvw.c"
static sf_count_t dwvw_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 54
static sf_count_t dwvw_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 55
static sf_count_t dwvw_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 56
static sf_count_t dwvw_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 58
static sf_count_t dwvw_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 59
static sf_count_t dwvw_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 60
static sf_count_t dwvw_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 61
static sf_count_t dwvw_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 63
static sf_count_t dwvw_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 64
static int dwvw_close(SF_PRIVATE *psf ) ;
#line 65
static int dwvw_byterate(SF_PRIVATE *psf ) ;
#line 67
static int dwvw_decode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int *ptr , int len ) ;
#line 68
static int dwvw_decode_load_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int bit_count ) ;
#line 70
static int dwvw_encode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int const   *ptr ,
                            int len ) ;
#line 71
static void dwvw_encode_store_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int data ,
                                   int new_bits ) ;
#line 72
static void dwvw_read_reset(DWVW_PRIVATE *pdwvw ) ;
#line 79 "/root/patchweave_donee/23/src/dwvw.c"
int dwvw_init(SF_PRIVATE *psf , int bitwidth ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  void *tmp ;

  {
#line 82
  if ((unsigned long )psf->codec_data != (unsigned long )((void *)0)) {
    {
#line 83
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n");
    }
#line 84
    return (30);
  }
#line 87
  if (bitwidth > 24) {
#line 88
    return (138);
  }
#line 90
  if (psf->file.mode == 48) {
#line 91
    return (24);
  }
  {
#line 93
  tmp = calloc(1UL, sizeof(DWVW_PRIVATE ));
#line 93
  pdwvw = (DWVW_PRIVATE *)tmp;
  }
#line 93
  if ((unsigned long )pdwvw == (unsigned long )((void *)0)) {
#line 94
    return (17);
  }
  {
#line 96
  psf->codec_data = (void *)pdwvw;
#line 97
  pdwvw->bit_width = bitwidth;
#line 98
  dwvw_read_reset(pdwvw);
  }
#line 100
  if (psf->file.mode == 16) {
#line 101
    psf->read_short = & dwvw_read_s;
#line 102
    psf->read_int = & dwvw_read_i;
#line 103
    psf->read_float = & dwvw_read_f;
#line 104
    psf->read_double = & dwvw_read_d;
  }
#line 107
  if (psf->file.mode == 32) {
#line 108
    psf->write_short = & dwvw_write_s;
#line 109
    psf->write_int = & dwvw_write_i;
#line 110
    psf->write_float = & dwvw_write_f;
#line 111
    psf->write_double = & dwvw_write_d;
  }
#line 114
  psf->codec_close = & dwvw_close;
#line 115
  psf->seek = & dwvw_seek;
#line 116
  psf->byterate = & dwvw_byterate;
#line 118
  if (psf->file.mode == 16) {
    {
#line 119
    psf->sf.frames = psf_decode_frame_count(psf);
#line 120
    dwvw_read_reset(pdwvw);
    }
  }
#line 123
  return (0);
}
}
#line 133 "/root/patchweave_donee/23/src/dwvw.c"
static int last_values[12]  ;
#line 130 "/root/patchweave_donee/23/src/dwvw.c"
static int dwvw_close(SF_PRIVATE *psf ) 
{ 
  DWVW_PRIVATE *pdwvw ;

  {
#line 133
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 134
    return (0);
  }
#line 135
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 137
  if (psf->file.mode == 32) {
    {
#line 138
    last_values[0] = 0;
#line 138
    last_values[1] = 0;
#line 138
    last_values[2] = 0;
#line 138
    last_values[3] = 0;
#line 138
    last_values[4] = 0;
#line 138
    last_values[5] = 0;
#line 138
    last_values[6] = 0;
#line 138
    last_values[7] = 0;
#line 138
    last_values[8] = 0;
#line 138
    last_values[9] = 0;
#line 138
    last_values[10] = 0;
#line 138
    last_values[11] = 0;
#line 141
    dwvw_encode_data(psf, pdwvw, (int const   *)(last_values), 12);
#line 144
    psf_fwrite((void const   *)(pdwvw->b.buffer), (sf_count_t )1, (sf_count_t )pdwvw->b.index,
               psf);
    }
#line 146
    if (psf->write_header) {
      {
#line 147
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 150
  return (0);
}
}
#line 154 "/root/patchweave_donee/23/src/dwvw.c"
static sf_count_t dwvw_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  DWVW_PRIVATE *pdwvw ;

  {
#line 157
  if (! psf->codec_data) {
#line 158
    psf->error = 30;
#line 159
    return ((sf_count_t )-1);
  }
#line 162
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 164
  if (offset == 0L) {
    {
#line 165
    psf_fseek(psf, psf->dataoffset, 0);
#line 166
    dwvw_read_reset(pdwvw);
    }
#line 167
    return ((sf_count_t )0);
  }
#line 170
  psf->error = 39;
#line 171
  return ((sf_count_t )-1);
}
}
#line 175 "/root/patchweave_donee/23/src/dwvw.c"
static int dwvw_byterate(SF_PRIVATE *psf ) 
{ 


  {
#line 177
  if (psf->file.mode == 16) {
#line 178
    return ((int )((psf->datalength * (long )psf->sf.samplerate) / psf->sf.frames));
  }
#line 180
  return (-1);
}
}
#line 187 "/root/patchweave_donee/23/src/dwvw.c"
static sf_count_t dwvw_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 191
  readcount = 0;
#line 192
  total = (sf_count_t )0;
#line 194
  if (! psf->codec_data) {
#line 195
    return ((sf_count_t )0);
  }
#line 196
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 198
  iptr = ubuf.ibuf;
#line 199
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;

#line 200
    if (! (len > 0L)) {
#line 200
      goto while_break;
    }
#line 201
    if (len >= (long )bufferlen) {
#line 201
      tmp = (long )bufferlen;
    } else {
#line 201
      tmp = len;
    }
    {
#line 201
    readcount = (int )tmp;
#line 202
    count___0 = dwvw_decode_data(psf, pdwvw, iptr, readcount);
#line 203
    k = 0;
    }
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 203
      if (! (k < readcount)) {
#line 203
        goto while_break___0;
      }
#line 204
      *(ptr + (total + (long )k)) = (short )(*(iptr + k) >> 16);
#line 203
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 206
    total += (long )count___0;
#line 207
    len -= (long )readcount;
#line 208
    if (count___0 != readcount) {
#line 209
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 212
  return (total);
}
}
#line 216 "/root/patchweave_donee/23/src/dwvw.c"
static sf_count_t dwvw_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 219
  total = (sf_count_t )0;
#line 221
  if (! psf->codec_data) {
#line 222
    return ((sf_count_t )0);
  }
#line 223
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;

#line 225
    if (! (len > 0L)) {
#line 225
      goto while_break;
    }
#line 226
    if (len > 268435456L) {
#line 226
      tmp = 268435456;
    } else {
#line 226
      tmp = (int )len;
    }
    {
#line 226
    readcount = tmp;
#line 228
    count___0 = dwvw_decode_data(psf, pdwvw, ptr, readcount);
#line 230
    total += (long )count___0;
#line 231
    len -= (long )count___0;
    }
#line 233
    if (count___0 != readcount) {
#line 234
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 237
  return (total);
}
}
#line 241 "/root/patchweave_donee/23/src/dwvw.c"
static sf_count_t dwvw_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 245
  readcount = 0;
#line 246
  total = (sf_count_t )0;
#line 249
  if (! psf->codec_data) {
#line 250
    return ((sf_count_t )0);
  }
#line 251
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 253
  if (psf->norm_float == 1) {
#line 253
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 253
    tmp = 1.;
  }
#line 253
  normfact = (float )tmp;
#line 255
  iptr = ubuf.ibuf;
#line 256
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;

#line 257
    if (! (len > 0L)) {
#line 257
      goto while_break;
    }
#line 258
    if (len >= (long )bufferlen) {
#line 258
      tmp___0 = (long )bufferlen;
    } else {
#line 258
      tmp___0 = len;
    }
    {
#line 258
    readcount = (int )tmp___0;
#line 259
    count___0 = dwvw_decode_data(psf, pdwvw, iptr, readcount);
#line 260
    k = 0;
    }
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 260
      if (! (k < readcount)) {
#line 260
        goto while_break___0;
      }
#line 261
      *(ptr + (total + (long )k)) = normfact * (float )*(iptr + k);
#line 260
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 263
    total += (long )count___0;
#line 264
    len -= (long )readcount;
#line 265
    if (count___0 != readcount) {
#line 266
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 269
  return (total);
}
}
#line 273 "/root/patchweave_donee/23/src/dwvw.c"
static sf_count_t dwvw_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 277
  readcount = 0;
#line 278
  total = (sf_count_t )0;
#line 281
  if (! psf->codec_data) {
#line 282
    return ((sf_count_t )0);
  }
#line 283
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 285
  if (psf->norm_double == 1) {
#line 285
    tmp = 1. / (double )2147483648U;
  } else {
#line 285
    tmp = 1.;
  }
#line 285
  normfact = tmp;
#line 287
  iptr = ubuf.ibuf;
#line 288
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;

#line 289
    if (! (len > 0L)) {
#line 289
      goto while_break;
    }
#line 290
    if (len >= (long )bufferlen) {
#line 290
      tmp___0 = (long )bufferlen;
    } else {
#line 290
      tmp___0 = len;
    }
    {
#line 290
    readcount = (int )tmp___0;
#line 291
    count___0 = dwvw_decode_data(psf, pdwvw, iptr, readcount);
#line 292
    k = 0;
    }
    {
#line 292
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 292
      if (! (k < readcount)) {
#line 292
        goto while_break___0;
      }
#line 293
      *(ptr + (total + (long )k)) = normfact * (double )*(iptr + k);
#line 292
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 295
    total += (long )count___0;
#line 296
    len -= (long )readcount;
#line 297
    if (count___0 != readcount) {
#line 298
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 301
  return (total);
}
}
#line 305 "/root/patchweave_donee/23/src/dwvw.c"
static int dwvw_decode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int *ptr , int len ) 
{ 
  int count___0 ;
  int delta_width_modifier ;
  int delta_width ;
  int delta_negative ;
  int delta ;
  int sample ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;

  {
#line 310
  delta_width = pdwvw->last_delta_width;
#line 311
  sample = pdwvw->last_sample;
#line 313
  count___0 = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;

#line 313
    if (! (count___0 < len)) {
#line 313
      goto while_break;
    }
    {
#line 315
    delta_width_modifier = dwvw_decode_load_bits(psf, pdwvw, -1);
    }
#line 318
    if (delta_width_modifier < 0) {
#line 319
      goto while_break;
    } else
#line 318
    if (pdwvw->b.end == 0) {
#line 318
      if (count___0 == 0) {
#line 319
        goto while_break;
      }
    }
    {
#line 321
    __cil_tmp12 = dwvw_decode_load_bits(psf, pdwvw, 1);
    }
#line 321
    if (delta_width_modifier) {
#line 321
      if (__cil_tmp12) {
#line 322
        delta_width_modifier = - delta_width_modifier;
      }
    }
#line 325
    delta_width = ((delta_width + delta_width_modifier) + pdwvw->bit_width) % pdwvw->bit_width;
#line 328
    delta = 0;
#line 329
    if (delta_width) {
      {
#line 330
      __cil_tmp13 = dwvw_decode_load_bits(psf, pdwvw, delta_width - 1);
#line 330
      delta = __cil_tmp13 | (1 << (delta_width - 1));
#line 331
      delta_negative = dwvw_decode_load_bits(psf, pdwvw, 1);
      }
#line 332
      if (delta == pdwvw->max_delta - 1) {
        {
#line 333
        __cil_tmp15 = dwvw_decode_load_bits(psf, pdwvw, 1);
#line 333
        delta += __cil_tmp15;
        }
      }
#line 334
      if (delta_negative) {
#line 335
        delta = - delta;
      }
    }
#line 339
    sample += delta;
#line 341
    if (sample >= pdwvw->max_delta) {
#line 342
      sample -= pdwvw->span;
    } else
#line 343
    if (sample < - pdwvw->max_delta) {
#line 344
      sample += pdwvw->span;
    }
    {
#line 347
    *(ptr + count___0) = arith_shift_left(sample, 32 - pdwvw->bit_width);
    }
#line 349
    if (pdwvw->b.end == 0) {
#line 349
      if (pdwvw->bit_count == 0) {
#line 350
        goto while_break;
      }
    }
#line 313
    count___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 353
  pdwvw->last_delta_width = delta_width;
#line 354
  pdwvw->last_sample = sample;
#line 356
  pdwvw->samplecount += count___0;
#line 358
  return (count___0);
}
}
#line 362 "/root/patchweave_donee/23/src/dwvw.c"
static int dwvw_decode_load_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int bit_count ) 
{ 
  int output ;
  int get_dwm ;
  sf_count_t __cil_tmp6 ;

  {
#line 363
  output = 0;
#line 363
  get_dwm = 0;
#line 371
  if (bit_count < 0) {
#line 372
    get_dwm = 1;
#line 374
    bit_count = pdwvw->dwm_maxsize;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;

#line 378
    if (! (pdwvw->bit_count < bit_count)) {
#line 378
      goto while_break;
    }
#line 379
    if (pdwvw->b.index >= pdwvw->b.end) {
      {
#line 380
      __cil_tmp6 = psf_fread((void *)(pdwvw->b.buffer), (sf_count_t )1, (sf_count_t )sizeof(pdwvw->b.buffer),
                             psf);
#line 380
      pdwvw->b.end = (int )__cil_tmp6;
#line 381
      pdwvw->b.index = 0;
      }
    }
#line 385
    if (bit_count < 8) {
#line 385
      if (pdwvw->b.end == 0) {
#line 386
        return (-1);
      }
    }
    {
#line 388
    pdwvw->bits = arith_shift_left(pdwvw->bits, 8);
    }
#line 390
    if (pdwvw->b.index < pdwvw->b.end) {
#line 391
      pdwvw->bits |= (int )pdwvw->b.buffer[pdwvw->b.index];
#line 392
      (pdwvw->b.index) ++;
    }
#line 394
    pdwvw->bit_count += 8;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 398
  if (! get_dwm) {
#line 399
    output = (pdwvw->bits >> (pdwvw->bit_count - bit_count)) & ((1 << bit_count) - 1);
#line 400
    pdwvw->bit_count -= bit_count;
#line 401
    return (output);
  }
  {
#line 405
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 405
    if (! (output < pdwvw->dwm_maxsize)) {
#line 405
      goto while_break___0;
    }
#line 406
    (pdwvw->bit_count) --;
#line 407
    if (pdwvw->bits & (1 << pdwvw->bit_count)) {
#line 408
      goto while_break___0;
    }
#line 409
    output ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 412
  return (output);
}
}
#line 416 "/root/patchweave_donee/23/src/dwvw.c"
static void dwvw_read_reset(DWVW_PRIVATE *pdwvw ) 
{ 
  int bitwidth ;

  {
  {
#line 417
  bitwidth = pdwvw->bit_width;
#line 419
  memset((void *)pdwvw, 0, sizeof(DWVW_PRIVATE ));
#line 421
  pdwvw->bit_width = bitwidth;
#line 422
  pdwvw->dwm_maxsize = bitwidth / 2;
#line 423
  pdwvw->max_delta = 1 << (bitwidth - 1);
#line 424
  pdwvw->span = 1 << bitwidth;
  }
#line 426
  return;
}
}
#line 428 "/root/patchweave_donee/23/src/dwvw.c"
static void dwvw_encode_store_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int data ,
                                   int new_bits ) 
{ 
  int byte ;
  int32_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;

  {
  {
#line 432
  __cil_tmp7 = arith_shift_left(1, new_bits);
#line 432
  __cil_tmp6 = arith_shift_left(pdwvw->bits, new_bits);
#line 432
  pdwvw->bits = __cil_tmp6 | (data & (__cil_tmp7 - 1));
#line 433
  pdwvw->bit_count += new_bits;
  }
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;

#line 436
    if (! (pdwvw->bit_count >= 8)) {
#line 436
      goto while_break;
    }
#line 437
    byte = pdwvw->bits >> (pdwvw->bit_count - 8);
#line 438
    pdwvw->bit_count -= 8;
#line 439
    pdwvw->b.buffer[pdwvw->b.index] = (unsigned char )(byte & 255);
#line 440
    (pdwvw->b.index) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 443
  if (pdwvw->b.index > (int )sizeof(pdwvw->b.buffer) - 4) {
    {
#line 444
    psf_fwrite((void const   *)(pdwvw->b.buffer), (sf_count_t )1, (sf_count_t )pdwvw->b.index,
               psf);
#line 445
    pdwvw->b.index = 0;
    }
  }
#line 448
  return;
}
}
#line 483 "/root/patchweave_donee/23/src/dwvw.c"
static int dwvw_encode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int const   *ptr ,
                            int len ) 
{ 
  int count___0 ;
  int delta_width_modifier ;
  int delta ;
  int delta_negative ;
  int delta_width ;
  int extra_bit ;
  int y ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;

  {
#line 487
  count___0 = 0;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;

#line 487
    if (! (count___0 < len)) {
#line 487
      goto while_break;
    }
#line 488
    delta = (int )((*(ptr + count___0) >> (32 - pdwvw->bit_width)) - (int const   )pdwvw->last_sample);
#line 491
    extra_bit = -1;
#line 492
    delta_negative = 0;
#line 493
    if (delta < - pdwvw->max_delta) {
#line 494
      delta = pdwvw->max_delta + delta % pdwvw->max_delta;
    } else
#line 495
    if (delta == - pdwvw->max_delta) {
#line 496
      extra_bit = 1;
#line 497
      delta_negative = 1;
#line 498
      delta = pdwvw->max_delta - 1;
    } else
#line 500
    if (delta > pdwvw->max_delta) {
      {
#line 501
      delta_negative = 1;
#line 502
      delta = pdwvw->span - delta;
#line 503
      delta = abs(delta);
      }
    } else
#line 505
    if (delta == pdwvw->max_delta) {
#line 506
      extra_bit = 1;
#line 507
      delta = pdwvw->max_delta - 1;
    } else
#line 509
    if (delta < 0) {
      {
#line 510
      delta_negative = 1;
#line 511
      delta = abs(delta);
      }
    }
#line 514
    if (delta == pdwvw->max_delta - 1) {
#line 514
      if (extra_bit == -1) {
#line 515
        extra_bit = 0;
      }
    }
#line 518
    y = delta;
#line 518
    delta_width = 0;
    {
#line 518
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 518
      if (! y) {
#line 518
        goto while_break___0;
      }
#line 518
      delta_width ++;
#line 518
      y >>= 1;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 521
    delta_width_modifier = (delta_width - pdwvw->last_delta_width) % pdwvw->bit_width;
#line 522
    if (delta_width_modifier > pdwvw->dwm_maxsize) {
#line 523
      delta_width_modifier -= pdwvw->bit_width;
    }
#line 524
    if (delta_width_modifier < - pdwvw->dwm_maxsize) {
#line 525
      delta_width_modifier += pdwvw->bit_width;
    }
    {
#line 528
    __cil_tmp15 = abs(delta_width_modifier);
#line 528
    dwvw_encode_store_bits(psf, pdwvw, 0, __cil_tmp15);
#line 529
    __cil_tmp16 = abs(delta_width_modifier);
    }
#line 529
    if (__cil_tmp16 != pdwvw->dwm_maxsize) {
      {
#line 530
      dwvw_encode_store_bits(psf, pdwvw, 1, 1);
      }
    }
#line 533
    if (delta_width_modifier < 0) {
      {
#line 534
      dwvw_encode_store_bits(psf, pdwvw, 1, 1);
      }
    }
#line 535
    if (delta_width_modifier > 0) {
      {
#line 536
      dwvw_encode_store_bits(psf, pdwvw, 0, 1);
      }
    }
#line 539
    if (delta_width) {
      {
#line 540
      __cil_tmp17 = abs(delta_width);
#line 540
      dwvw_encode_store_bits(psf, pdwvw, delta, __cil_tmp17 - 1);
      }
#line 541
      if (delta_negative) {
#line 541
        tmp = 1;
      } else {
#line 541
        tmp = 0;
      }
      {
#line 541
      dwvw_encode_store_bits(psf, pdwvw, tmp, 1);
      }
    }
#line 545
    if (extra_bit >= 0) {
      {
#line 546
      dwvw_encode_store_bits(psf, pdwvw, extra_bit, 1);
      }
    }
#line 548
    pdwvw->last_sample = (int )(*(ptr + count___0) >> (32 - pdwvw->bit_width));
#line 549
    pdwvw->last_delta_width = delta_width;
#line 487
    count___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 552
  pdwvw->samplecount += count___0;
#line 554
  return (count___0);
}
}
#line 558 "/root/patchweave_donee/23/src/dwvw.c"
static sf_count_t dwvw_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 562
  writecount = 0;
#line 563
  total = (sf_count_t )0;
#line 565
  if (! psf->codec_data) {
#line 566
    return ((sf_count_t )0);
  }
#line 567
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 569
  iptr = ubuf.ibuf;
#line 570
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;

#line 571
    if (! (len > 0L)) {
#line 571
      goto while_break;
    }
#line 572
    if (len >= (long )bufferlen) {
#line 572
      tmp = (long )bufferlen;
    } else {
#line 572
      tmp = len;
    }
#line 572
    writecount = (int )tmp;
#line 573
    k = 0;
    {
#line 573
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 573
      if (! (k < writecount)) {
#line 573
        goto while_break___0;
      }
      {
#line 574
      *(iptr + k) = arith_shift_left((int32_t )*(ptr + (total + (long )k)), 16);
#line 573
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 575
    count___0 = dwvw_encode_data(psf, pdwvw, (int const   *)iptr, writecount);
#line 577
    total += (long )count___0;
#line 578
    len -= (long )writecount;
    }
#line 579
    if (count___0 != writecount) {
#line 580
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 583
  return (total);
}
}
#line 587 "/root/patchweave_donee/23/src/dwvw.c"
static sf_count_t dwvw_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 590
  total = (sf_count_t )0;
#line 592
  if (! psf->codec_data) {
#line 593
    return ((sf_count_t )0);
  }
#line 594
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;

#line 596
    if (! (len > 0L)) {
#line 596
      goto while_break;
    }
#line 597
    if (len > 268435456L) {
#line 597
      tmp = 268435456;
    } else {
#line 597
      tmp = (int )len;
    }
    {
#line 597
    writecount = tmp;
#line 599
    count___0 = dwvw_encode_data(psf, pdwvw, ptr, writecount);
#line 601
    total += (long )count___0;
#line 602
    len -= (long )count___0;
    }
#line 604
    if (count___0 != writecount) {
#line 605
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 608
  return (total);
}
}
#line 612 "/root/patchweave_donee/23/src/dwvw.c"
static sf_count_t dwvw_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 616
  writecount = 0;
#line 617
  total = (sf_count_t )0;
#line 620
  if (! psf->codec_data) {
#line 621
    return ((sf_count_t )0);
  }
#line 622
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 624
  if (psf->norm_float == 1) {
#line 624
    tmp = 1. * (double )2147483647;
  } else {
#line 624
    tmp = 1.;
  }
#line 624
  normfact = (float )tmp;
#line 626
  iptr = ubuf.ibuf;
#line 627
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;

#line 628
    if (! (len > 0L)) {
#line 628
      goto while_break;
    }
#line 629
    if (len >= (long )bufferlen) {
#line 629
      tmp___0 = (long )bufferlen;
    } else {
#line 629
      tmp___0 = len;
    }
#line 629
    writecount = (int )tmp___0;
#line 630
    k = 0;
    {
#line 630
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 630
      if (! (k < writecount)) {
#line 630
        goto while_break___0;
      }
      {
#line 631
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 631
      *(iptr + k) = (int )__cil_tmp15;
#line 630
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 632
    count___0 = dwvw_encode_data(psf, pdwvw, (int const   *)iptr, writecount);
#line 634
    total += (long )count___0;
#line 635
    len -= (long )writecount;
    }
#line 636
    if (count___0 != writecount) {
#line 637
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 640
  return (total);
}
}
#line 644 "/root/patchweave_donee/23/src/dwvw.c"
static sf_count_t dwvw_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  BUF_UNION ubuf ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 648
  writecount = 0;
#line 649
  total = (sf_count_t )0;
#line 652
  if (! psf->codec_data) {
#line 653
    return ((sf_count_t )0);
  }
#line 654
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 656
  if (psf->norm_double == 1) {
#line 656
    tmp = 1. * (double )2147483647;
  } else {
#line 656
    tmp = 1.;
  }
#line 656
  normfact = tmp;
#line 658
  iptr = ubuf.ibuf;
#line 659
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;

#line 660
    if (! (len > 0L)) {
#line 660
      goto while_break;
    }
#line 661
    if (len >= (long )bufferlen) {
#line 661
      tmp___0 = (long )bufferlen;
    } else {
#line 661
      tmp___0 = len;
    }
#line 661
    writecount = (int )tmp___0;
#line 662
    k = 0;
    {
#line 662
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 662
      if (! (k < writecount)) {
#line 662
        goto while_break___0;
      }
      {
#line 663
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 663
      *(iptr + k) = (int )__cil_tmp15;
#line 662
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 664
    count___0 = dwvw_encode_data(psf, pdwvw, (int const   *)iptr, writecount);
#line 666
    total += (long )count___0;
#line 667
    len -= (long )writecount;
    }
#line 668
    if (count___0 != writecount) {
#line 669
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 672
  return (total);
}
}
#line 59 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t host_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 60
static sf_count_t host_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 61
static sf_count_t host_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 62
static sf_count_t host_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 64
static sf_count_t host_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 65
static sf_count_t host_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 66
static sf_count_t host_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 67
static sf_count_t host_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 69
static void double64_peak_update(SF_PRIVATE *psf , double const   *buffer , int count___0 ,
                                 sf_count_t indx ) ;
#line 71
static int double64_get_capability(SF_PRIVATE *psf ) ;
#line 73
static sf_count_t replace_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 74
static sf_count_t replace_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 75
static sf_count_t replace_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 76
static sf_count_t replace_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 78
static sf_count_t replace_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 79
static sf_count_t replace_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 80
static sf_count_t replace_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 81
static sf_count_t replace_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 83
static void d2bd_read(double *buffer , int count___0 ) ;
#line 84
static void bd2d_write(double *buffer , int count___0 ) ;
#line 93 "/root/patchweave_donee/23/src/double64.c"
static int double64_caps  ;
#line 91 "/root/patchweave_donee/23/src/double64.c"
int double64_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;

  {
#line 94
  if (psf->sf.channels < 1) {
    {
#line 95
    psf_log_printf(psf, "double64_init : internal error : channels = %d\n", psf->sf.channels);
    }
#line 96
    return (30);
  }
  {
#line 99
  double64_caps = double64_get_capability(psf);
#line 101
  psf->blockwidth = (int )(sizeof(double ) * (unsigned long )psf->sf.channels);
  }
#line 103
  if (psf->file.mode == 16) {
    _L: 
#line 105
    if (psf->endian + double64_caps == 536870964) {
#line 105
      goto case_536870964;
    }
#line 113
    if (psf->endian + double64_caps == 268435491) {
#line 113
      goto case_268435491;
    }
#line 121
    if (psf->endian + double64_caps == 536870947) {
#line 121
      goto case_536870947;
    }
#line 129
    if (psf->endian + double64_caps == 268435508) {
#line 129
      goto case_268435508;
    }
#line 138
    if (psf->endian + double64_caps == 536870998) {
#line 138
      goto case_536870998;
    }
#line 146
    if (psf->endian + double64_caps == 268435525) {
#line 146
      goto case_268435525;
    }
#line 154
    if (psf->endian + double64_caps == 536870981) {
#line 154
      goto case_536870981;
    }
#line 162
    if (psf->endian + double64_caps == 268435542) {
#line 162
      goto case_268435542;
    }
#line 170
    goto switch_default;
    case_536870964: 
#line 106
    psf->data_endswap = 0;
#line 107
    psf->read_short = & host_read_d2s;
#line 108
    psf->read_int = & host_read_d2i;
#line 109
    psf->read_float = & host_read_d2f;
#line 110
    psf->read_double = & host_read_d;
#line 111
    goto switch_break;
    case_268435491: 
#line 114
    psf->data_endswap = 0;
#line 115
    psf->read_short = & host_read_d2s;
#line 116
    psf->read_int = & host_read_d2i;
#line 117
    psf->read_float = & host_read_d2f;
#line 118
    psf->read_double = & host_read_d;
#line 119
    goto switch_break;
    case_536870947: 
#line 122
    psf->data_endswap = 1;
#line 123
    psf->read_short = & host_read_d2s;
#line 124
    psf->read_int = & host_read_d2i;
#line 125
    psf->read_float = & host_read_d2f;
#line 126
    psf->read_double = & host_read_d;
#line 127
    goto switch_break;
    case_268435508: 
#line 130
    psf->data_endswap = 1;
#line 131
    psf->read_short = & host_read_d2s;
#line 132
    psf->read_int = & host_read_d2i;
#line 133
    psf->read_float = & host_read_d2f;
#line 134
    psf->read_double = & host_read_d;
#line 135
    goto switch_break;
    case_536870998: 
#line 139
    psf->data_endswap = 0;
#line 140
    psf->read_short = & replace_read_d2s;
#line 141
    psf->read_int = & replace_read_d2i;
#line 142
    psf->read_float = & replace_read_d2f;
#line 143
    psf->read_double = & replace_read_d;
#line 144
    goto switch_break;
    case_268435525: 
#line 147
    psf->data_endswap = 0;
#line 148
    psf->read_short = & replace_read_d2s;
#line 149
    psf->read_int = & replace_read_d2i;
#line 150
    psf->read_float = & replace_read_d2f;
#line 151
    psf->read_double = & replace_read_d;
#line 152
    goto switch_break;
    case_536870981: 
#line 155
    psf->data_endswap = 1;
#line 156
    psf->read_short = & replace_read_d2s;
#line 157
    psf->read_int = & replace_read_d2i;
#line 158
    psf->read_float = & replace_read_d2f;
#line 159
    psf->read_double = & replace_read_d;
#line 160
    goto switch_break;
    case_268435542: 
#line 163
    psf->data_endswap = 1;
#line 164
    psf->read_short = & replace_read_d2s;
#line 165
    psf->read_int = & replace_read_d2i;
#line 166
    psf->read_float = & replace_read_d2f;
#line 167
    psf->read_double = & replace_read_d;
#line 168
    goto switch_break;
    switch_default: 
#line 170
    goto switch_break;
    switch_break: ;
  } else
#line 103
  if (psf->file.mode == 48) {
#line 103
    goto _L;
  }
#line 174
  if (psf->file.mode == 32) {
    _L___4: 
#line 176
    if (psf->endian + double64_caps == 268435491) {
#line 176
      goto case_268435491___0;
    }
#line 184
    if (psf->endian + double64_caps == 536870964) {
#line 184
      goto case_536870964___0;
    }
#line 192
    if (psf->endian + double64_caps == 536870947) {
#line 192
      goto case_536870947___0;
    }
#line 200
    if (psf->endian + double64_caps == 268435508) {
#line 200
      goto case_268435508___0;
    }
#line 209
    if (psf->endian + double64_caps == 268435525) {
#line 209
      goto case_268435525___0;
    }
#line 217
    if (psf->endian + double64_caps == 536870998) {
#line 217
      goto case_536870998___0;
    }
#line 225
    if (psf->endian + double64_caps == 536870981) {
#line 225
      goto case_536870981___0;
    }
#line 233
    if (psf->endian + double64_caps == 268435542) {
#line 233
      goto case_268435542___0;
    }
#line 241
    goto switch_default___0;
    case_268435491___0: 
#line 177
    psf->data_endswap = 0;
#line 178
    psf->write_short = & host_write_s2d;
#line 179
    psf->write_int = & host_write_i2d;
#line 180
    psf->write_float = & host_write_f2d;
#line 181
    psf->write_double = & host_write_d;
#line 182
    goto switch_break___0;
    case_536870964___0: 
#line 185
    psf->data_endswap = 0;
#line 186
    psf->write_short = & host_write_s2d;
#line 187
    psf->write_int = & host_write_i2d;
#line 188
    psf->write_float = & host_write_f2d;
#line 189
    psf->write_double = & host_write_d;
#line 190
    goto switch_break___0;
    case_536870947___0: 
#line 193
    psf->data_endswap = 1;
#line 194
    psf->write_short = & host_write_s2d;
#line 195
    psf->write_int = & host_write_i2d;
#line 196
    psf->write_float = & host_write_f2d;
#line 197
    psf->write_double = & host_write_d;
#line 198
    goto switch_break___0;
    case_268435508___0: 
#line 201
    psf->data_endswap = 1;
#line 202
    psf->write_short = & host_write_s2d;
#line 203
    psf->write_int = & host_write_i2d;
#line 204
    psf->write_float = & host_write_f2d;
#line 205
    psf->write_double = & host_write_d;
#line 206
    goto switch_break___0;
    case_268435525___0: 
#line 210
    psf->data_endswap = 0;
#line 211
    psf->write_short = & replace_write_s2d;
#line 212
    psf->write_int = & replace_write_i2d;
#line 213
    psf->write_float = & replace_write_f2d;
#line 214
    psf->write_double = & replace_write_d;
#line 215
    goto switch_break___0;
    case_536870998___0: 
#line 218
    psf->data_endswap = 0;
#line 219
    psf->write_short = & replace_write_s2d;
#line 220
    psf->write_int = & replace_write_i2d;
#line 221
    psf->write_float = & replace_write_f2d;
#line 222
    psf->write_double = & replace_write_d;
#line 223
    goto switch_break___0;
    case_536870981___0: 
#line 226
    psf->data_endswap = 1;
#line 227
    psf->write_short = & replace_write_s2d;
#line 228
    psf->write_int = & replace_write_i2d;
#line 229
    psf->write_float = & replace_write_f2d;
#line 230
    psf->write_double = & replace_write_d;
#line 231
    goto switch_break___0;
    case_268435542___0: 
#line 234
    psf->data_endswap = 1;
#line 235
    psf->write_short = & replace_write_s2d;
#line 236
    psf->write_int = & replace_write_i2d;
#line 237
    psf->write_float = & replace_write_f2d;
#line 238
    psf->write_double = & replace_write_d;
#line 239
    goto switch_break___0;
    switch_default___0: 
#line 241
    goto switch_break___0;
    switch_break___0: ;
  } else
#line 174
  if (psf->file.mode == 48) {
#line 174
    goto _L___4;
  }
#line 245
  if (psf->filelength > psf->dataoffset) {
#line 246
    if (psf->dataend > 0L) {
#line 246
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 246
      tmp = psf->filelength - psf->dataoffset;
    }
#line 246
    psf->datalength = tmp;
  } else {
#line 250
    psf->datalength = (sf_count_t )0;
  }
#line 252
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 254
  return (0);
}
}
#line 284 "/root/patchweave_donee/23/src/double64.c"
double double64_be_read(unsigned char const   *cptr ) 
{ 
  int exponent ;
  int negative ;
  int upper ;
  int lower ;
  double dvalue ;
  int tmp ;
  double __cil_tmp8 ;
  int __cil_tmp9 ;
  double __cil_tmp10 ;

  {
#line 288
  if ((int )*(cptr + 0) & 128) {
#line 288
    tmp = 1;
  } else {
#line 288
    tmp = 0;
  }
#line 288
  negative = tmp;
#line 289
  exponent = (((int )*(cptr + 0) & 127) << 4) | (((int )*(cptr + 1) >> 4) & 15);
#line 292
  upper = (((((int )*(cptr + 1) & 15) << 24) | ((int )*(cptr + 2) << 16)) | ((int )*(cptr + 3) << 8)) | (int )*(cptr + 4);
#line 293
  lower = (((int )*(cptr + 5) << 16) | ((int )*(cptr + 6) << 8)) | (int )*(cptr + 7);
#line 295
  if (exponent == 0) {
#line 295
    if (upper == 0) {
#line 295
      if (lower == 0) {
#line 296
        return (0.);
      }
    }
  }
#line 298
  dvalue = (double )upper + (double )lower / (double )16777216;
#line 299
  dvalue += (double )268435456;
#line 301
  exponent -= 1023;
#line 303
  dvalue /= (double )268435456;
#line 305
  if (negative) {
#line 306
    dvalue *= (double )-1;
  }
#line 308
  if (exponent > 0) {
    {
#line 309
    __cil_tmp8 = pow(2., (double )exponent);
#line 309
    dvalue *= __cil_tmp8;
    }
  } else
#line 310
  if (exponent < 0) {
    {
#line 311
    __cil_tmp9 = abs(exponent);
#line 311
    __cil_tmp10 = pow(2., (double )__cil_tmp9);
#line 311
    dvalue /= __cil_tmp10;
    }
  }
#line 313
  return (dvalue);
}
}
#line 317 "/root/patchweave_donee/23/src/double64.c"
double double64_le_read(unsigned char const   *cptr ) 
{ 
  int exponent ;
  int negative ;
  int upper ;
  int lower ;
  double dvalue ;
  int tmp ;
  double __cil_tmp8 ;
  int __cil_tmp9 ;
  double __cil_tmp10 ;

  {
#line 321
  if ((int )*(cptr + 7) & 128) {
#line 321
    tmp = 1;
  } else {
#line 321
    tmp = 0;
  }
#line 321
  negative = tmp;
#line 322
  exponent = (((int )*(cptr + 7) & 127) << 4) | (((int )*(cptr + 6) >> 4) & 15);
#line 325
  upper = (((((int )*(cptr + 6) & 15) << 24) | ((int )*(cptr + 5) << 16)) | ((int )*(cptr + 4) << 8)) | (int )*(cptr + 3);
#line 326
  lower = (((int )*(cptr + 2) << 16) | ((int )*(cptr + 1) << 8)) | (int )*(cptr + 0);
#line 328
  if (exponent == 0) {
#line 328
    if (upper == 0) {
#line 328
      if (lower == 0) {
#line 329
        return (0.);
      }
    }
  }
#line 331
  dvalue = (double )upper + (double )lower / (double )16777216;
#line 332
  dvalue += (double )268435456;
#line 334
  exponent -= 1023;
#line 336
  dvalue /= (double )268435456;
#line 338
  if (negative) {
#line 339
    dvalue *= (double )-1;
  }
#line 341
  if (exponent > 0) {
    {
#line 342
    __cil_tmp8 = pow(2., (double )exponent);
#line 342
    dvalue *= __cil_tmp8;
    }
  } else
#line 343
  if (exponent < 0) {
    {
#line 344
    __cil_tmp9 = abs(exponent);
#line 344
    __cil_tmp10 = pow(2., (double )__cil_tmp9);
#line 344
    dvalue /= __cil_tmp10;
    }
  }
#line 346
  return (dvalue);
}
}
#line 350 "/root/patchweave_donee/23/src/double64.c"
void double64_be_write(double in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  double __cil_tmp5 ;
  double __cil_tmp7 ;
  long __cil_tmp8 ;
  double __cil_tmp10 ;
  long __cil_tmp11 ;

  {
  {
#line 353
  memset((void *)out, 0, sizeof(double ));
#line 355
  __cil_tmp5 = fabs(in);
  }
#line 355
  if (__cil_tmp5 < 1.00000000001e-30) {
#line 356
    return;
  }
#line 358
  if (in < 0.) {
#line 359
    in *= - 1.;
#line 360
    *(out + 0) = (unsigned char )((int )*(out + 0) | 128);
  }
  {
#line 363
  in = frexp(in, & exponent);
#line 365
  exponent += 1022;
#line 367
  *(out + 0) = (unsigned char )((int )*(out + 0) | ((exponent >> 4) & 127));
#line 368
  *(out + 1) = (unsigned char )((int )*(out + 1) | ((exponent << 4) & 240));
#line 370
  in *= (double )536870912;
#line 371
  __cil_tmp7 = floor(in);
#line 371
  __cil_tmp8 = lrint(__cil_tmp7);
#line 371
  mantissa = (int )__cil_tmp8;
#line 373
  *(out + 1) = (unsigned char )((int )*(out + 1) | ((mantissa >> 24) & 15));
#line 374
  *(out + 2) = (unsigned char )((mantissa >> 16) & 255);
#line 375
  *(out + 3) = (unsigned char )((mantissa >> 8) & 255);
#line 376
  *(out + 4) = (unsigned char )(mantissa & 255);
#line 378
  in = fmod(in, 1.);
#line 379
  in *= (double )16777216;
#line 380
  __cil_tmp10 = floor(in);
#line 380
  __cil_tmp11 = lrint(__cil_tmp10);
#line 380
  mantissa = (int )__cil_tmp11;
#line 382
  *(out + 5) = (unsigned char )((mantissa >> 16) & 255);
#line 383
  *(out + 6) = (unsigned char )((mantissa >> 8) & 255);
#line 384
  *(out + 7) = (unsigned char )(mantissa & 255);
  }
#line 386
  return;
}
}
#line 390 "/root/patchweave_donee/23/src/double64.c"
void double64_le_write(double in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  double __cil_tmp5 ;
  double __cil_tmp7 ;
  long __cil_tmp8 ;
  double __cil_tmp10 ;
  long __cil_tmp11 ;

  {
  {
#line 393
  memset((void *)out, 0, sizeof(double ));
#line 395
  __cil_tmp5 = fabs(in);
  }
#line 395
  if (__cil_tmp5 < 1.00000000001e-30) {
#line 396
    return;
  }
#line 398
  if (in < 0.) {
#line 399
    in *= - 1.;
#line 400
    *(out + 7) = (unsigned char )((int )*(out + 7) | 128);
  }
  {
#line 403
  in = frexp(in, & exponent);
#line 405
  exponent += 1022;
#line 407
  *(out + 7) = (unsigned char )((int )*(out + 7) | ((exponent >> 4) & 127));
#line 408
  *(out + 6) = (unsigned char )((int )*(out + 6) | ((exponent << 4) & 240));
#line 410
  in *= (double )536870912;
#line 411
  __cil_tmp7 = floor(in);
#line 411
  __cil_tmp8 = lrint(__cil_tmp7);
#line 411
  mantissa = (int )__cil_tmp8;
#line 413
  *(out + 6) = (unsigned char )((int )*(out + 6) | ((mantissa >> 24) & 15));
#line 414
  *(out + 5) = (unsigned char )((mantissa >> 16) & 255);
#line 415
  *(out + 4) = (unsigned char )((mantissa >> 8) & 255);
#line 416
  *(out + 3) = (unsigned char )(mantissa & 255);
#line 418
  in = fmod(in, 1.);
#line 419
  in *= (double )16777216;
#line 420
  __cil_tmp10 = floor(in);
#line 420
  __cil_tmp11 = lrint(__cil_tmp10);
#line 420
  mantissa = (int )__cil_tmp11;
#line 422
  *(out + 2) = (unsigned char )((mantissa >> 16) & 255);
#line 423
  *(out + 1) = (unsigned char )((mantissa >> 8) & 255);
#line 424
  *(out + 0) = (unsigned char )(mantissa & 255);
  }
#line 426
  return;
}
}
#line 434 "/root/patchweave_donee/23/src/double64.c"
static void double64_peak_update(SF_PRIVATE *psf , double const   *buffer , int count___0 ,
                                 sf_count_t indx ) 
{ 
  int chan ;
  int k ;
  int position ;
  float fmaxval ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;

  {
#line 439
  chan = 0;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;

#line 439
    if (! (chan < psf->sf.channels)) {
#line 439
      goto while_break;
    }
    {
#line 440
    __cil_tmp9 = fabs((double )*(buffer + chan));
#line 440
    fmaxval = (float )__cil_tmp9;
#line 441
    position = 0;
#line 442
    k = chan;
    }
    {
#line 442
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 442
      if (! (k < count___0)) {
#line 442
        goto while_break___0;
      }
      {
#line 443
      __cil_tmp10 = fabs((double )*(buffer + k));
      }
#line 443
      if ((double )fmaxval < __cil_tmp10) {
        {
#line 444
        __cil_tmp11 = fabs((double )*(buffer + k));
#line 444
        fmaxval = (float )__cil_tmp11;
#line 445
        position = k;
        }
      }
#line 442
      k += psf->sf.channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 448
    if ((double )fmaxval > (psf->peak_info)->peaks[chan].value) {
#line 449
      (psf->peak_info)->peaks[chan].value = (double )fmaxval;
#line 450
      (psf->peak_info)->peaks[chan].position = (psf->write_current + indx) + (long )(position / psf->sf.channels);
    }
#line 439
    chan ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 454
  return;
}
}
#line 458 "/root/patchweave_donee/23/src/double64.c"
static int double64_get_capability(SF_PRIVATE *psf ) 
{ 
  union __anonunion_531 data ;
  int tmp ;

  {
#line 464
  data.d = 1.23456789013;
#line 466
  if (! psf->ieee_replace) {
#line 468
    if ((int )data.c[0] == 251) {
#line 468
      if ((int )data.c[1] == 89) {
#line 468
        if ((int )data.c[2] == 140) {
#line 468
          if ((int )data.c[3] == 66) {
#line 468
            if ((int )data.c[4] == 202) {
#line 468
              if ((int )data.c[5] == 192) {
#line 468
                if ((int )data.c[6] == 243) {
#line 468
                  if ((int )data.c[7] == 63) {
#line 470
                    return (35);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 473
    if ((int )data.c[0] == 63) {
#line 473
      if ((int )data.c[1] == 243) {
#line 473
        if ((int )data.c[2] == 192) {
#line 473
          if ((int )data.c[3] == 202) {
#line 473
            if ((int )data.c[4] == 66) {
#line 473
              if ((int )data.c[5] == 140) {
#line 473
                if ((int )data.c[6] == 89) {
#line 473
                  if ((int )data.c[7] == 251) {
#line 475
                    return (52);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 479
  psf_log_printf(psf, "Using IEEE replacement code for double.\n\220");
#line 481
  tmp = 69;
  }
#line 481
  return (tmp);
}
}
#line 488 "/root/patchweave_donee/23/src/double64.c"
static void d2s_array(double const   *src , int count___0 , short *dest , double scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    count___0 --;
#line 489
    if (! (count___0 >= 0)) {
#line 489
      goto while_break;
    }
    {
#line 490
    __cil_tmp5 = lrint(scale * (double )*(src + count___0));
#line 490
    *(dest + count___0) = (short )__cil_tmp5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 496
  return;
}
}
#line 495 "/root/patchweave_donee/23/src/double64.c"
static void d2s_clip_array(double const   *src , int count___0 , short *dest , double scale ) 
{ 
  double tmp ;
  long __cil_tmp6 ;

  {
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    count___0 --;
#line 496
    if (! (count___0 >= 0)) {
#line 496
      goto while_break;
    }
#line 497
    tmp = scale * (double )*(src + count___0);
#line 499
    if (tmp > 32767.) {
#line 500
      *(dest + count___0) = (short)32767;
    } else
#line 501
    if (tmp < - 32768.) {
#line 502
      *(dest + count___0) = (short)-32768;
    } else {
      {
#line 504
      __cil_tmp6 = lrint(tmp);
#line 504
      *(dest + count___0) = (short )__cil_tmp6;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 511
  return;
}
}
#line 509 "/root/patchweave_donee/23/src/double64.c"
static void d2i_array(double const   *src , int count___0 , int *dest , double scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    count___0 --;
#line 510
    if (! (count___0 >= 0)) {
#line 510
      goto while_break;
    }
    {
#line 511
    __cil_tmp5 = lrint(scale * (double )*(src + count___0));
#line 511
    *(dest + count___0) = (int )__cil_tmp5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 517
  return;
}
}
#line 516 "/root/patchweave_donee/23/src/double64.c"
static void d2i_clip_array(double const   *src , int count___0 , int *dest , double scale ) 
{ 
  float tmp ;
  long __cil_tmp6 ;

  {
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    count___0 --;
#line 517
    if (! (count___0 >= 0)) {
#line 517
      goto while_break;
    }
#line 518
    tmp = (float )(scale * (double )*(src + count___0));
#line 520
    if ((double )tmp > 1. * (double )2147483647) {
#line 521
      *(dest + count___0) = 2147483647;
    } else
#line 522
    if ((double )tmp < - 1. * (double )2147483647) {
#line 523
      *(dest + count___0) = (-0x7FFFFFFF-1);
    } else {
      {
#line 525
      __cil_tmp6 = lrint((double )tmp);
#line 525
      *(dest + count___0) = (int )__cil_tmp6;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 532
  return;
}
}
#line 530 "/root/patchweave_donee/23/src/double64.c"
__inline static void d2f_array___0(double const   *src , int count___0 , float *dest ) 
{ 


  {
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    count___0 --;
#line 531
    if (! (count___0 >= 0)) {
#line 531
      goto while_break;
    }
#line 532
    *(dest + count___0) = (float )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 537
  return;
}
}
#line 537 "/root/patchweave_donee/23/src/double64.c"
__inline static void s2d_array(short const   *src , double *dest , int count___0 ,
                               double scale ) 
{ 


  {
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    count___0 --;
#line 538
    if (! (count___0 >= 0)) {
#line 538
      goto while_break;
    }
#line 539
    *(dest + count___0) = scale * (double )((int )*(src + count___0));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 544
  return;
}
}
#line 544 "/root/patchweave_donee/23/src/double64.c"
__inline static void i2d_array(int const   *src , double *dest , int count___0 , double scale ) 
{ 


  {
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    count___0 --;
#line 545
    if (! (count___0 >= 0)) {
#line 545
      goto while_break;
    }
#line 546
    *(dest + count___0) = scale * (double )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 551
  return;
}
}
#line 551 "/root/patchweave_donee/23/src/double64.c"
__inline static void f2d_array___0(float const   *src , double *dest , int count___0 ) 
{ 


  {
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    count___0 --;
#line 552
    if (! (count___0 >= 0)) {
#line 552
      goto while_break;
    }
#line 553
    *(dest + count___0) = (double )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 558
  return;
}
}
#line 561 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t host_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , int  , short * , double  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  void (*tmp)(double const   *src , int count , short *dest , double scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 565
  total = (sf_count_t )0;
#line 568
  if (psf->add_clipping) {
#line 568
    tmp = & d2s_clip_array;
  } else {
#line 568
    tmp = & d2s_array;
  }
#line 568
  convert = tmp;
#line 569
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
#line 570
  if (psf->float_int_mult == 0) {
#line 570
    tmp___0 = 1.;
  } else {
#line 570
    tmp___0 = (double )((float )32767 / psf->float_max);
  }
#line 570
  scale = tmp___0;
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;

#line 572
    if (! (len > 0L)) {
#line 572
      goto while_break;
    }
#line 573
    if (len < (long )bufferlen) {
#line 574
      bufferlen = (int )len;
    }
    {
#line 575
    __cil_tmp12 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 575
    readcount = (int )__cil_tmp12;
    }
#line 577
    if (psf->data_endswap == 1) {
      {
#line 578
      endswap_double_array(ubuf.dbuf, readcount);
      }
    }
    {
#line 580
    (*convert)((double const   *)(ubuf.dbuf), readcount, ptr + total, scale);
#line 581
    total += (long )readcount;
#line 582
    len -= (long )readcount;
    }
#line 583
    if (readcount < bufferlen) {
#line 584
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 587
  return (total);
}
}
#line 591 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t host_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  void (*convert)(double const   * , int  , int * , double  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  void (*tmp)(double const   *src , int count , int *dest , double scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 595
  total = (sf_count_t )0;
#line 598
  if (psf->add_clipping) {
#line 598
    tmp = & d2i_clip_array;
  } else {
#line 598
    tmp = & d2i_array;
  }
#line 598
  convert = tmp;
#line 599
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
#line 600
  if (psf->float_int_mult == 0) {
#line 600
    tmp___0 = 1.;
  } else {
#line 600
    tmp___0 = (double )((float )2147483647 / psf->float_max);
  }
#line 600
  scale = tmp___0;
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;

#line 602
    if (! (len > 0L)) {
#line 602
      goto while_break;
    }
#line 603
    if (len < (long )bufferlen) {
#line 604
      bufferlen = (int )len;
    }
    {
#line 605
    __cil_tmp12 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 605
    readcount = (int )__cil_tmp12;
    }
#line 607
    if (psf->data_endswap == 1) {
      {
#line 608
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 610
    (*convert)((double const   *)(ubuf.dbuf), readcount, ptr + total, scale);
#line 611
    total += (long )readcount;
#line 612
    len -= (long )readcount;
    }
#line 613
    if (readcount < bufferlen) {
#line 614
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 617
  return (total);
}
}
#line 621 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t host_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 624
  total = (sf_count_t )0;
#line 626
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;

#line 628
    if (! (len > 0L)) {
#line 628
      goto while_break;
    }
#line 629
    if (len < (long )bufferlen) {
#line 630
      bufferlen = (int )len;
    }
    {
#line 631
    __cil_tmp8 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                           psf);
#line 631
    readcount = (int )__cil_tmp8;
    }
#line 633
    if (psf->data_endswap == 1) {
      {
#line 634
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 636
    d2f_array___0((double const   *)(ubuf.dbuf), readcount, ptr + total);
#line 637
    total += (long )readcount;
#line 638
    len -= (long )readcount;
    }
#line 639
    if (readcount < bufferlen) {
#line 640
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 643
  return (total);
}
}
#line 647 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t host_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  sf_count_t readcount ;
  sf_count_t total ;

  {
  {
#line 649
  total = (sf_count_t )0;
#line 651
  readcount = psf_fread((void *)ptr, (sf_count_t )sizeof(double ), len, psf);
  }
#line 653
  if (psf->data_endswap != 1) {
#line 654
    return (readcount);
  }
#line 657
  if (readcount < 134217728L) {
    {
#line 658
    endswap_double_array(ptr, (int )readcount);
    }
#line 659
    return (readcount);
  }
#line 662
  bufferlen = 134217728;
  {
#line 663
  while (1) {
    while_continue: /* CIL Label */ ;

#line 663
    if (! (len > 0L)) {
#line 663
      goto while_break;
    }
#line 664
    if (len < (long )bufferlen) {
#line 665
      bufferlen = (int )len;
    }
    {
#line 667
    endswap_double_array(ptr + total, bufferlen);
#line 669
    total += (long )bufferlen;
#line 670
    len -= (long )bufferlen;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 673
  return (total);
}
}
#line 677 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t host_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 680
  total = (sf_count_t )0;
#line 683
  if (psf->scale_int_float == 0) {
#line 683
    tmp = 1.;
  } else {
#line 683
    tmp = 1. / (double )32768;
  }
#line 683
  scale = tmp;
#line 684
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;

#line 686
    if (! (len > 0L)) {
#line 686
      goto while_break;
    }
#line 687
    if (len < (long )bufferlen) {
#line 688
      bufferlen = (int )len;
    }
    {
#line 690
    s2d_array(ptr + total, ubuf.dbuf, bufferlen, scale);
    }
#line 692
    if (psf->peak_info) {
      {
#line 693
      double64_peak_update(psf, (double const   *)(ubuf.dbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 695
    if (psf->data_endswap == 1) {
      {
#line 696
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 698
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                             (sf_count_t )bufferlen, psf);
#line 698
    writecount = (int )__cil_tmp10;
#line 699
    total += (long )writecount;
    }
#line 700
    if (writecount < bufferlen) {
#line 701
      goto while_break;
    }
#line 702
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 705
  return (total);
}
}
#line 709 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t host_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 712
  total = (sf_count_t )0;
#line 715
  if (psf->scale_int_float == 0) {
#line 715
    tmp = 1.;
  } else {
#line 715
    tmp = 1. / (8. * (double )268435456);
  }
#line 715
  scale = tmp;
#line 716
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;

#line 718
    if (! (len > 0L)) {
#line 718
      goto while_break;
    }
#line 719
    if (len < (long )bufferlen) {
#line 720
      bufferlen = (int )len;
    }
    {
#line 721
    i2d_array(ptr + total, ubuf.dbuf, bufferlen, scale);
    }
#line 723
    if (psf->peak_info) {
      {
#line 724
      double64_peak_update(psf, (double const   *)(ubuf.dbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 726
    if (psf->data_endswap == 1) {
      {
#line 727
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 729
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                             (sf_count_t )bufferlen, psf);
#line 729
    writecount = (int )__cil_tmp10;
#line 730
    total += (long )writecount;
    }
#line 731
    if (writecount < bufferlen) {
#line 732
      goto while_break;
    }
#line 733
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 736
  return (total);
}
}
#line 740 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t host_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 743
  total = (sf_count_t )0;
#line 745
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;

#line 747
    if (! (len > 0L)) {
#line 747
      goto while_break;
    }
#line 748
    if (len < (long )bufferlen) {
#line 749
      bufferlen = (int )len;
    }
    {
#line 750
    f2d_array___0(ptr + total, ubuf.dbuf, bufferlen);
    }
#line 752
    if (psf->peak_info) {
      {
#line 753
      double64_peak_update(psf, (double const   *)(ubuf.dbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
#line 755
    if (psf->data_endswap == 1) {
      {
#line 756
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 758
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                            (sf_count_t )bufferlen, psf);
#line 758
    writecount = (int )__cil_tmp8;
#line 759
    total += (long )writecount;
    }
#line 760
    if (writecount < bufferlen) {
#line 761
      goto while_break;
    }
#line 762
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 765
  return (total);
}
}
#line 769 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t host_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 772
  total = (sf_count_t )0;
#line 774
  if (psf->peak_info) {
    {
#line 775
    double64_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 777
  if (psf->data_endswap != 1) {
    {
#line 778
    __cil_tmp8 = psf_fwrite((void const   *)ptr, (sf_count_t )sizeof(double ), len,
                            psf);
    }
#line 778
    return (__cil_tmp8);
  }
#line 780
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;

#line 782
    if (! (len > 0L)) {
#line 782
      goto while_break;
    }
#line 783
    if (len < (long )bufferlen) {
#line 784
      bufferlen = (int )len;
    }
    {
#line 786
    endswap_double_copy(ubuf.dbuf, ptr + total, bufferlen);
#line 788
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                            (sf_count_t )bufferlen, psf);
#line 788
    writecount = (int )__cil_tmp9;
#line 789
    total += (long )writecount;
    }
#line 790
    if (writecount < bufferlen) {
#line 791
      goto while_break;
    }
#line 792
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 795
  return (total);
}
}
#line 802 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t replace_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 805
  total = (sf_count_t )0;
#line 808
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
#line 809
  if (psf->float_int_mult == 0) {
#line 809
    tmp = 1.;
  } else {
#line 809
    tmp = (double )((float )32767 / psf->float_max);
  }
#line 809
  scale = tmp;
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;

#line 811
    if (! (len > 0L)) {
#line 811
      goto while_break;
    }
#line 812
    if (len < (long )bufferlen) {
#line 813
      bufferlen = (int )len;
    }
    {
#line 814
    __cil_tmp10 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 814
    readcount = (int )__cil_tmp10;
    }
#line 816
    if (psf->data_endswap == 1) {
      {
#line 817
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 819
    d2bd_read(ubuf.dbuf, bufferlen);
#line 821
    d2s_array((double const   *)(ubuf.dbuf), readcount, ptr + total, scale);
#line 822
    total += (long )readcount;
    }
#line 823
    if (readcount < bufferlen) {
#line 824
      goto while_break;
    }
#line 825
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 828
  return (total);
}
}
#line 832 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t replace_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 835
  total = (sf_count_t )0;
#line 838
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
#line 839
  if (psf->float_int_mult == 0) {
#line 839
    tmp = 1.;
  } else {
#line 839
    tmp = (double )((float )2147483647 / psf->float_max);
  }
#line 839
  scale = tmp;
  {
#line 841
  while (1) {
    while_continue: /* CIL Label */ ;

#line 841
    if (! (len > 0L)) {
#line 841
      goto while_break;
    }
#line 842
    if (len < (long )bufferlen) {
#line 843
      bufferlen = (int )len;
    }
    {
#line 844
    __cil_tmp10 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 844
    readcount = (int )__cil_tmp10;
    }
#line 846
    if (psf->data_endswap == 1) {
      {
#line 847
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 849
    d2bd_read(ubuf.dbuf, bufferlen);
#line 851
    d2i_array((double const   *)(ubuf.dbuf), readcount, ptr + total, scale);
#line 852
    total += (long )readcount;
    }
#line 853
    if (readcount < bufferlen) {
#line 854
      goto while_break;
    }
#line 855
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 858
  return (total);
}
}
#line 862 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t replace_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 865
  total = (sf_count_t )0;
#line 867
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;

#line 869
    if (! (len > 0L)) {
#line 869
      goto while_break;
    }
#line 870
    if (len < (long )bufferlen) {
#line 871
      bufferlen = (int )len;
    }
    {
#line 872
    __cil_tmp8 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                           psf);
#line 872
    readcount = (int )__cil_tmp8;
    }
#line 874
    if (psf->data_endswap == 1) {
      {
#line 875
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 877
    d2bd_read(ubuf.dbuf, bufferlen);
#line 879
    memcpy((void *)(ptr + total), (void const   *)(ubuf.dbuf), (unsigned long )bufferlen * sizeof(double ));
#line 881
    total += (long )readcount;
    }
#line 882
    if (readcount < bufferlen) {
#line 883
      goto while_break;
    }
#line 884
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 887
  return (total);
}
}
#line 891 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t replace_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 894
  total = (sf_count_t )0;
#line 897
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;

#line 899
    if (! (len > 0L)) {
#line 899
      goto while_break;
    }
#line 900
    if (len < (long )bufferlen) {
#line 901
      bufferlen = (int )len;
    }
    {
#line 902
    __cil_tmp8 = psf_fread((void *)(ubuf.dbuf), (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                           psf);
#line 902
    readcount = (int )__cil_tmp8;
    }
#line 904
    if (psf->data_endswap == 1) {
      {
#line 905
      endswap_double_array(ubuf.dbuf, readcount);
      }
    }
    {
#line 907
    d2bd_read(ubuf.dbuf, readcount);
#line 909
    memcpy((void *)(ptr + total), (void const   *)(ubuf.dbuf), (unsigned long )readcount * sizeof(double ));
#line 911
    total += (long )readcount;
    }
#line 912
    if (readcount < bufferlen) {
#line 913
      goto while_break;
    }
#line 914
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 917
  return (total);
}
}
#line 921 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t replace_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 924
  total = (sf_count_t )0;
#line 927
  if (psf->scale_int_float == 0) {
#line 927
    tmp = 1.;
  } else {
#line 927
    tmp = 1. / (double )32768;
  }
#line 927
  scale = tmp;
#line 928
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;

#line 930
    if (! (len > 0L)) {
#line 930
      goto while_break;
    }
#line 931
    if (len < (long )bufferlen) {
#line 932
      bufferlen = (int )len;
    }
    {
#line 933
    s2d_array(ptr + total, ubuf.dbuf, bufferlen, scale);
    }
#line 935
    if (psf->peak_info) {
      {
#line 936
      double64_peak_update(psf, (double const   *)(ubuf.dbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
    {
#line 938
    bd2d_write(ubuf.dbuf, bufferlen);
    }
#line 940
    if (psf->data_endswap == 1) {
      {
#line 941
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 943
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                             (sf_count_t )bufferlen, psf);
#line 943
    writecount = (int )__cil_tmp10;
#line 944
    total += (long )writecount;
    }
#line 945
    if (writecount < bufferlen) {
#line 946
      goto while_break;
    }
#line 947
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 950
  return (total);
}
}
#line 954 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t replace_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 957
  total = (sf_count_t )0;
#line 960
  if (psf->scale_int_float == 0) {
#line 960
    tmp = 1.;
  } else {
#line 960
    tmp = 1. / (8. * (double )268435456);
  }
#line 960
  scale = tmp;
#line 961
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 963
  while (1) {
    while_continue: /* CIL Label */ ;

#line 963
    if (! (len > 0L)) {
#line 963
      goto while_break;
    }
#line 964
    if (len < (long )bufferlen) {
#line 965
      bufferlen = (int )len;
    }
    {
#line 966
    i2d_array(ptr + total, ubuf.dbuf, bufferlen, scale);
    }
#line 968
    if (psf->peak_info) {
      {
#line 969
      double64_peak_update(psf, (double const   *)(ubuf.dbuf), bufferlen, total / (long )psf->sf.channels);
      }
    }
    {
#line 971
    bd2d_write(ubuf.dbuf, bufferlen);
    }
#line 973
    if (psf->data_endswap == 1) {
      {
#line 974
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 976
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                             (sf_count_t )bufferlen, psf);
#line 976
    writecount = (int )__cil_tmp10;
#line 977
    total += (long )writecount;
    }
#line 978
    if (writecount < bufferlen) {
#line 979
      goto while_break;
    }
#line 980
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 983
  return (total);
}
}
#line 987 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t replace_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 990
  total = (sf_count_t )0;
#line 992
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;

#line 994
    if (! (len > 0L)) {
#line 994
      goto while_break;
    }
#line 995
    if (len < (long )bufferlen) {
#line 996
      bufferlen = (int )len;
    }
    {
#line 997
    f2d_array___0(ptr + total, ubuf.dbuf, bufferlen);
#line 999
    bd2d_write(ubuf.dbuf, bufferlen);
    }
#line 1001
    if (psf->data_endswap == 1) {
      {
#line 1002
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 1004
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                            (sf_count_t )bufferlen, psf);
#line 1004
    writecount = (int )__cil_tmp8;
#line 1005
    total += (long )writecount;
    }
#line 1006
    if (writecount < bufferlen) {
#line 1007
      goto while_break;
    }
#line 1008
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1011
  return (total);
}
}
#line 1015 "/root/patchweave_donee/23/src/double64.c"
static sf_count_t replace_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 1018
  total = (sf_count_t )0;
#line 1021
  if (psf->peak_info) {
    {
#line 1022
    double64_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 1024
  bufferlen = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0]));
  {
#line 1026
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1026
    if (! (len > 0L)) {
#line 1026
      goto while_break;
    }
#line 1027
    if (len < (long )bufferlen) {
#line 1028
      bufferlen = (int )len;
    }
    {
#line 1030
    memcpy((void *)(ubuf.dbuf), (void const   *)(ptr + total), (unsigned long )bufferlen * sizeof(double ));
#line 1032
    bd2d_write(ubuf.dbuf, bufferlen);
    }
#line 1034
    if (psf->data_endswap == 1) {
      {
#line 1035
      endswap_double_array(ubuf.dbuf, bufferlen);
      }
    }
    {
#line 1037
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.dbuf), (sf_count_t )sizeof(double ),
                            (sf_count_t )bufferlen, psf);
#line 1037
    writecount = (int )__cil_tmp8;
#line 1038
    total += (long )writecount;
    }
#line 1039
    if (writecount < bufferlen) {
#line 1040
      goto while_break;
    }
#line 1041
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1044
  return (total);
}
}
#line 1051 "/root/patchweave_donee/23/src/double64.c"
static void d2bd_read(double *buffer , int count___0 ) 
{ 


  {
  {
#line 1052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1052
    count___0 --;
#line 1052
    if (! (count___0 >= 0)) {
#line 1052
      goto while_break;
    }
    {
#line 1053
    *(buffer + count___0) = double64_le_read((unsigned char const   *)((unsigned char *)(buffer + count___0)));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1059
  return;
}
}
#line 1058 "/root/patchweave_donee/23/src/double64.c"
static void bd2d_write(double *buffer , int count___0 ) 
{ 


  {
  {
#line 1059
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1059
    count___0 --;
#line 1059
    if (! (count___0 >= 0)) {
#line 1059
      goto while_break;
    }
    {
#line 1060
    double64_le_write(*(buffer + count___0), (unsigned char *)(buffer + count___0));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1066
  return;
}
}
#line 78 "/root/patchweave_donee/23/src/dither.c"
static sf_count_t dither_read_short(SF_PRIVATE *UNUSED_psf , short *UNUSED_ptr , sf_count_t len ) ;
#line 79
static sf_count_t dither_read_int(SF_PRIVATE *UNUSED_psf , int *UNUSED_ptr , sf_count_t len ) ;
#line 81
static sf_count_t dither_write_short(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 82
static sf_count_t dither_write_int(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 83
static sf_count_t dither_write_float(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 84
static sf_count_t dither_write_double(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 87 "/root/patchweave_donee/23/src/dither.c"
int dither_init(SF_PRIVATE *psf , int mode ) 
{ 
  DITHER_DATA *pdither ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 90
  pdither = (DITHER_DATA *)psf->dither;
#line 93
  if (mode == 16) {
#line 93
    if (psf->read_dither.type == 500) {
#line 94
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 95
        return (0);
      }
#line 97
      if (pdither->read_short) {
#line 98
        psf->read_short = pdither->read_short;
      }
#line 99
      if (pdither->read_int) {
#line 100
        psf->read_int = pdither->read_int;
      }
#line 101
      if (pdither->read_float) {
#line 102
        psf->read_float = pdither->read_float;
      }
#line 103
      if (pdither->read_double) {
#line 104
        psf->read_double = pdither->read_double;
      }
#line 105
      return (0);
    }
  }
#line 109
  if (mode == 32) {
#line 109
    if (psf->write_dither.type == 500) {
#line 110
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 111
        return (0);
      }
#line 113
      if (pdither->write_short) {
#line 114
        psf->write_short = pdither->write_short;
      }
#line 115
      if (pdither->write_int) {
#line 116
        psf->write_int = pdither->write_int;
      }
#line 117
      if (pdither->write_float) {
#line 118
        psf->write_float = pdither->write_float;
      }
#line 119
      if (pdither->write_double) {
#line 120
        psf->write_double = pdither->write_double;
      }
#line 121
      return (0);
    }
  }
#line 125
  if (mode == 16) {
#line 125
    if (psf->read_dither.type != 0) {
#line 126
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
        {
#line 127
        tmp = calloc(1UL, sizeof(DITHER_DATA ));
#line 127
        pdither = (DITHER_DATA *)tmp;
        }
      }
#line 128
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 129
        return (17);
      }
#line 133
      if ((psf->sf.format & 65535) == 6) {
#line 133
        goto case_6;
      }
#line 133
      if ((psf->sf.format & 65535) == 7) {
#line 133
        goto case_6;
      }
#line 142
      if ((psf->sf.format & 65535) == 5) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 1) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 2) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 3) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 4) {
#line 142
        goto case_5;
      }
#line 147
      goto switch_default;
      case_6: 
#line 134
      pdither->read_int = psf->read_int;
#line 135
      psf->read_int = & dither_read_int;
#line 136
      goto switch_break;
      case_5: 
#line 143
      pdither->read_short = psf->read_short;
#line 144
      psf->read_short = & dither_read_short;
#line 145
      goto switch_break;
      switch_default: 
#line 147
      goto switch_break;
      switch_break: ;
    }
  }
#line 152
  if (mode == 32) {
#line 152
    if (psf->write_dither.type != 0) {
#line 153
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
        {
#line 154
        tmp___0 = calloc(1UL, sizeof(DITHER_DATA ));
#line 154
        pdither = (DITHER_DATA *)tmp___0;
        }
      }
#line 155
      if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 156
        return (17);
      }
#line 160
      if ((psf->sf.format & 65535) == 6) {
#line 160
        goto case_6___0;
      }
#line 160
      if ((psf->sf.format & 65535) == 7) {
#line 160
        goto case_6___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 5) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 1) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 2) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 3) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 4) {
#line 169
        goto case_5___0;
      }
#line 172
      goto switch_default___0;
      case_6___0: 
#line 161
      pdither->write_int = psf->write_int;
#line 162
      psf->write_int = & dither_write_int;
#line 163
      goto switch_break___0;
      case_5___0: 
#line 170
      goto switch_break___0;
      switch_default___0: 
#line 172
      goto switch_break___0;
      switch_break___0: 
#line 175
      pdither->write_short = psf->write_short;
#line 176
      psf->write_short = & dither_write_short;
#line 178
      pdither->write_int = psf->write_int;
#line 179
      psf->write_int = & dither_write_int;
#line 181
      pdither->write_float = psf->write_float;
#line 182
      psf->write_float = & dither_write_float;
#line 184
      pdither->write_double = psf->write_double;
#line 185
      psf->write_double = & dither_write_double;
    }
  }
#line 188
  return (0);
}
}
#line 194
static void dither_short(short const   *in , short *out , int frames , int channels ) ;
#line 195
static void dither_int(int const   *in , int *out , int frames , int channels ) ;
#line 197
static void dither_float(float const   *in , float *out , int frames , int channels ) ;
#line 198
static void dither_double(double const   *in , double *out , int frames , int channels ) ;
#line 201 "/root/patchweave_donee/23/src/dither.c"
static sf_count_t dither_read_short(SF_PRIVATE *UNUSED_psf , short *UNUSED_ptr , sf_count_t len ) 
{ 


  {
#line 203
  return (len);
}
}
#line 207 "/root/patchweave_donee/23/src/dither.c"
static sf_count_t dither_read_int(SF_PRIVATE *UNUSED_psf , int *UNUSED_ptr , sf_count_t len ) 
{ 


  {
#line 209
  return (len);
}
}
#line 216 "/root/patchweave_donee/23/src/dither.c"
static sf_count_t dither_write_short(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  int tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 219
  total = (sf_count_t )0;
#line 221
  pdither = (DITHER_DATA *)psf->dither;
#line 221
  if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 222
    psf->error = 666;
#line 223
    return ((sf_count_t )0);
  }
#line 229
  if ((psf->sf.format & 65535) == 80) {
#line 229
    goto case_80;
  }
#line 229
  if ((psf->sf.format & 65535) == 5) {
#line 229
    goto case_80;
  }
#line 229
  if ((psf->sf.format & 65535) == 1) {
#line 229
    goto case_80;
  }
#line 232
  goto switch_default;
  case_80: 
#line 230
  goto switch_break;
  switch_default: 
  {
#line 233
  __cil_tmp9 = (*(pdither->write_short))(psf, ptr, len);
  }
#line 233
  return (__cil_tmp9);
  switch_break: 
#line 236
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(short ));
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;

#line 238
    if (! (len > 0L)) {
#line 238
      goto while_break;
    }
#line 239
    if (len >= (long )bufferlen) {
#line 239
      tmp = bufferlen;
    } else {
#line 239
      tmp = (int )len;
    }
    {
#line 239
    writecount = tmp;
#line 240
    writecount /= psf->sf.channels;
#line 241
    writecount *= psf->sf.channels;
#line 243
    dither_short(ptr, (short *)(pdither->buffer), writecount / psf->sf.channels, psf->sf.channels);
#line 245
    __cil_tmp11 = (*(pdither->write_short))(psf, (short const   *)((short *)(pdither->buffer)),
                                            (sf_count_t )writecount);
#line 245
    thiswrite = (int )__cil_tmp11;
#line 246
    total += (long )thiswrite;
#line 247
    len -= (long )thiswrite;
    }
#line 248
    if (thiswrite < writecount) {
#line 249
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 252
  return (total);
}
}
#line 256 "/root/patchweave_donee/23/src/dither.c"
static sf_count_t dither_write_int(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  int tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 259
  total = (sf_count_t )0;
#line 261
  pdither = (DITHER_DATA *)psf->dither;
#line 261
  if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 262
    psf->error = 666;
#line 263
    return ((sf_count_t )0);
  }
#line 270
  if ((psf->sf.format & 65535) == 3) {
#line 270
    goto case_3;
  }
#line 270
  if ((psf->sf.format & 65535) == 2) {
#line 270
    goto case_3;
  }
#line 270
  if ((psf->sf.format & 65535) == 5) {
#line 270
    goto case_3;
  }
#line 270
  if ((psf->sf.format & 65535) == 1) {
#line 270
    goto case_3;
  }
#line 274
  if ((psf->sf.format & 65535) == 81) {
#line 274
    goto case_81;
  }
#line 274
  if ((psf->sf.format & 65535) == 80) {
#line 274
    goto case_81;
  }
#line 277
  goto switch_default;
  case_3: 
#line 271
  goto switch_break;
  case_81: 
#line 275
  goto switch_break;
  switch_default: 
  {
#line 278
  __cil_tmp9 = (*(pdither->write_int))(psf, ptr, len);
  }
#line 278
  return (__cil_tmp9);
  switch_break: 
#line 282
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(int ));
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;

#line 284
    if (! (len > 0L)) {
#line 284
      goto while_break;
    }
#line 285
    if (len >= (long )bufferlen) {
#line 285
      tmp = bufferlen;
    } else {
#line 285
      tmp = (int )len;
    }
    {
#line 285
    writecount = tmp;
#line 286
    writecount /= psf->sf.channels;
#line 287
    writecount *= psf->sf.channels;
#line 289
    dither_int(ptr, (int *)(pdither->buffer), writecount / psf->sf.channels, psf->sf.channels);
#line 291
    __cil_tmp11 = (*(pdither->write_int))(psf, (int const   *)((int *)(pdither->buffer)),
                                          (sf_count_t )writecount);
#line 291
    thiswrite = (int )__cil_tmp11;
#line 292
    total += (long )thiswrite;
#line 293
    len -= (long )thiswrite;
    }
#line 294
    if (thiswrite < writecount) {
#line 295
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 298
  return (total);
}
}
#line 302 "/root/patchweave_donee/23/src/dither.c"
static sf_count_t dither_write_float(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  float tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 305
  total = (sf_count_t )0;
#line 307
  pdither = (DITHER_DATA *)psf->dither;
#line 307
  if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 308
    psf->error = 666;
#line 309
    return ((sf_count_t )0);
  }
#line 316
  if ((psf->sf.format & 65535) == 3) {
#line 316
    goto case_3;
  }
#line 316
  if ((psf->sf.format & 65535) == 2) {
#line 316
    goto case_3;
  }
#line 316
  if ((psf->sf.format & 65535) == 5) {
#line 316
    goto case_3;
  }
#line 316
  if ((psf->sf.format & 65535) == 1) {
#line 316
    goto case_3;
  }
#line 320
  if ((psf->sf.format & 65535) == 81) {
#line 320
    goto case_81;
  }
#line 320
  if ((psf->sf.format & 65535) == 80) {
#line 320
    goto case_81;
  }
#line 323
  goto switch_default;
  case_3: 
#line 317
  goto switch_break;
  case_81: 
#line 321
  goto switch_break;
  switch_default: 
  {
#line 324
  __cil_tmp9 = (*(pdither->write_float))(psf, ptr, len);
  }
#line 324
  return (__cil_tmp9);
  switch_break: 
#line 327
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(float ));
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;

#line 329
    if (! (len > 0L)) {
#line 329
      goto while_break;
    }
#line 330
    if (len >= (long )bufferlen) {
#line 330
      tmp = (float )bufferlen;
    } else {
#line 330
      tmp = (float )len;
    }
    {
#line 330
    writecount = (int )tmp;
#line 331
    writecount /= psf->sf.channels;
#line 332
    writecount *= psf->sf.channels;
#line 334
    dither_float(ptr, (float *)(pdither->buffer), writecount / psf->sf.channels, psf->sf.channels);
#line 336
    __cil_tmp11 = (*(pdither->write_float))(psf, (float const   *)((float *)(pdither->buffer)),
                                            (sf_count_t )writecount);
#line 336
    thiswrite = (int )__cil_tmp11;
#line 337
    total += (long )thiswrite;
#line 338
    len -= (long )thiswrite;
    }
#line 339
    if (thiswrite < writecount) {
#line 340
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 343
  return (total);
}
}
#line 347 "/root/patchweave_donee/23/src/dither.c"
static sf_count_t dither_write_double(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 350
  total = (sf_count_t )0;
#line 352
  pdither = (DITHER_DATA *)psf->dither;
#line 352
  if ((unsigned long )pdither == (unsigned long )((void *)0)) {
#line 353
    psf->error = 666;
#line 354
    return ((sf_count_t )0);
  }
#line 361
  if ((psf->sf.format & 65535) == 3) {
#line 361
    goto case_3;
  }
#line 361
  if ((psf->sf.format & 65535) == 2) {
#line 361
    goto case_3;
  }
#line 361
  if ((psf->sf.format & 65535) == 5) {
#line 361
    goto case_3;
  }
#line 361
  if ((psf->sf.format & 65535) == 1) {
#line 361
    goto case_3;
  }
#line 365
  if ((psf->sf.format & 65535) == 81) {
#line 365
    goto case_81;
  }
#line 365
  if ((psf->sf.format & 65535) == 80) {
#line 365
    goto case_81;
  }
#line 368
  goto switch_default;
  case_3: 
#line 362
  goto switch_break;
  case_81: 
#line 366
  goto switch_break;
  switch_default: 
  {
#line 369
  __cil_tmp9 = (*(pdither->write_double))(psf, ptr, len);
  }
#line 369
  return (__cil_tmp9);
  switch_break: 
#line 373
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(double ));
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;

#line 375
    if (! (len > 0L)) {
#line 375
      goto while_break;
    }
#line 376
    if (len >= (long )bufferlen) {
#line 376
      tmp = (double )bufferlen;
    } else {
#line 376
      tmp = (double )len;
    }
    {
#line 376
    writecount = (int )tmp;
#line 377
    writecount /= psf->sf.channels;
#line 378
    writecount *= psf->sf.channels;
#line 380
    dither_double(ptr, pdither->buffer, writecount / psf->sf.channels, psf->sf.channels);
#line 382
    __cil_tmp11 = (*(pdither->write_double))(psf, (double const   *)(pdither->buffer),
                                             (sf_count_t )writecount);
#line 382
    thiswrite = (int )__cil_tmp11;
#line 383
    total += (long )thiswrite;
#line 384
    len -= (long )thiswrite;
    }
#line 385
    if (thiswrite < writecount) {
#line 386
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 389
  return (total);
}
}
#line 396 "/root/patchweave_donee/23/src/dither.c"
static void dither_short(short const   *in , short *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;

  {
#line 399
  ch = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;

#line 399
    if (! (ch < channels)) {
#line 399
      goto while_break;
    }
#line 400
    k = ch;
    {
#line 400
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 400
      if (! (k < channels * frames)) {
#line 400
        goto while_break___0;
      }
#line 401
      *(out + k) = (short )*(in + k);
#line 400
      k += channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 399
    ch ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 403
  return;
}
}
#line 406 "/root/patchweave_donee/23/src/dither.c"
static void dither_int(int const   *in , int *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;

  {
#line 409
  ch = 0;
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;

#line 409
    if (! (ch < channels)) {
#line 409
      goto while_break;
    }
#line 410
    k = ch;
    {
#line 410
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 410
      if (! (k < channels * frames)) {
#line 410
        goto while_break___0;
      }
#line 411
      *(out + k) = (int )*(in + k);
#line 410
      k += channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 409
    ch ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 413
  return;
}
}
#line 416 "/root/patchweave_donee/23/src/dither.c"
static void dither_float(float const   *in , float *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;

  {
#line 419
  ch = 0;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;

#line 419
    if (! (ch < channels)) {
#line 419
      goto while_break;
    }
#line 420
    k = ch;
    {
#line 420
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 420
      if (! (k < channels * frames)) {
#line 420
        goto while_break___0;
      }
#line 421
      *(out + k) = (float )*(in + k);
#line 420
      k += channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 419
    ch ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 423
  return;
}
}
#line 426 "/root/patchweave_donee/23/src/dither.c"
static void dither_double(double const   *in , double *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;

  {
#line 429
  ch = 0;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;

#line 429
    if (! (ch < channels)) {
#line 429
      goto while_break;
    }
#line 430
    k = ch;
    {
#line 430
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 430
      if (! (k < channels * frames)) {
#line 430
        goto while_break___0;
      }
#line 431
      *(out + k) = (double )*(in + k);
#line 430
      k += channels;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 429
    ch ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 433
  return;
}
}
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 46 "/root/patchweave_donee/23/src/common.c"
__inline static void log_putchar(SF_PRIVATE *psf , char ch ) 
{ 
  int __cil_tmp3 ;

  {
#line 47
  if (psf->parselog.indx < (int )sizeof(psf->parselog.buf) - 1) {
#line 48
    __cil_tmp3 = psf->parselog.indx;
#line 48
    (psf->parselog.indx) ++;
#line 48
    psf->parselog.buf[__cil_tmp3] = ch;
#line 49
    psf->parselog.buf[psf->parselog.indx] = (char)0;
  }
#line 51
  return;
}
}
#line 55 "/root/patchweave_donee/23/src/common.c"
void psf_log_printf(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list ap ;
  uint32_t u ;
  int d ;
  int tens ;
  int shift ;
  int width ;
  int width_specifier ;
  int left_align ;
  int slen ;
  char c ;
  char *strptr ;
  char istr[5] ;
  char lead_char ;
  char sign_char ;
  char const   *__cil_tmp17 ;
  char const   *__cil_tmp21 ;
  unsigned short const   **__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int tmp ;
  int __cil_tmp25 ;
  char *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  sf_count_t D ;
  sf_count_t Tens ;
  int __cil_tmp39 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int tmp___0 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int tmp___1 ;
  char *__cil_tmp51 ;

  {
  {
#line 61
  __builtin_va_start((__builtin_va_list )((void *)ap), format);
  }
  {
#line 63
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: 
#line 63
    __cil_tmp17 = format;
#line 63
    format ++;
#line 63
    c = (char )*__cil_tmp17;
#line 63
    if (! c) {
#line 63
      goto while_break;
    }
#line 64
    if ((int )c != 37) {
      {
#line 65
      log_putchar(psf, c);
      }
#line 66
      goto while_continue;
    }
#line 69
    if ((int )*(format + 0) == 37) {
      {
#line 70
      log_putchar(psf, (char )'%');
#line 71
      format ++;
      }
#line 72
      goto while_continue;
    }
#line 75
    sign_char = (char)0;
#line 76
    left_align = 0;
    {
#line 77
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: ;
#line 80
      if ((int )*(format + 0) == 43) {
#line 80
        goto case_43;
      }
#line 80
      if ((int )*(format + 0) == 32) {
#line 80
        goto case_43;
      }
#line 85
      if ((int )*(format + 0) == 45) {
#line 85
        goto case_45;
      }
#line 90
      goto switch_default;
      case_43: 
#line 81
      sign_char = (char )*(format + 0);
#line 82
      format ++;
#line 83
      goto while_continue___0;
      case_45: 
#line 86
      left_align = 1;
#line 87
      format ++;
#line 88
      goto while_continue___0;
      switch_default: 
#line 90
      goto switch_break;
      switch_break: ;
#line 93
      goto while_break___0;
    }
    while_break___25: /* CIL Label */ ;
    }
    while_break___0: ;
#line 96
    if ((int )*(format + 0) == 0) {
#line 97
      goto while_break;
    }
#line 99
    lead_char = (char )' ';
#line 100
    if ((int )*(format + 0) == 48) {
#line 101
      lead_char = (char )'0';
    }
#line 103
    width_specifier = 0;
    {
#line 104
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 104
      __cil_tmp22 = __ctype_b_loc();
#line 104
      __cil_tmp21 = format;
#line 104
      format ++;
#line 104
      c = (char )*__cil_tmp21;
      }
#line 104
      if ((int )c) {
#line 104
        if (! ((int )*(*__cil_tmp22 + (int )c) & 2048)) {
#line 104
          goto while_break___1;
        }
      } else {
#line 104
        goto while_break___1;
      }
#line 105
      width_specifier = width_specifier * 10 + ((int )c - 48);
    }
    while_break___26: /* CIL Label */ ;
    }
    while_break___1: ;
#line 108
    if ((int )c == 0) {
#line 108
      goto case_0;
    }
#line 112
    if ((int )c == 115) {
#line 112
      goto case_115;
    }
#line 127
    if ((int )c == 100) {
#line 127
      goto case_100;
    }
#line 178
    if ((int )c == 68) {
#line 178
      goto case_68;
    }
#line 213
    if ((int )c == 117) {
#line 213
      goto case_117;
    }
#line 257
    if ((int )c == 99) {
#line 257
      goto case_99;
    }
#line 263
    if ((int )c == 88) {
#line 263
      goto case_88;
    }
#line 263
    if ((int )c == 120) {
#line 263
      goto case_88;
    }
#line 291
    if ((int )c == 77) {
#line 291
      goto case_77;
    }
#line 313
    goto switch_default___0;
    case_0: 
    {
#line 109
    __builtin_va_end((__builtin_va_list )((void *)ap));
    }
#line 110
    return;
    case_115: 
#line 113
    strptr = (char *)0;
#line 114
    if ((unsigned long )strptr == (unsigned long )((void *)0)) {
#line 115
      goto switch_break___0;
    }
    {
#line 116
    __cil_tmp23 = strlen((char const   *)strptr);
#line 116
    slen = (int )__cil_tmp23;
    }
#line 117
    if (width_specifier >= slen) {
#line 117
      tmp = width_specifier - slen;
    } else {
#line 117
      tmp = 0;
    }
#line 117
    width_specifier = tmp;
#line 118
    if (left_align == 0) {
      {
#line 119
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 119
        __cil_tmp25 = width_specifier;
#line 119
        width_specifier --;
#line 119
        if (! (__cil_tmp25 > 0)) {
#line 119
          goto while_break___2;
        }
        {
#line 120
        log_putchar(psf, (char )' ');
        }
      }
      while_break___27: /* CIL Label */ ;
      }
      while_break___2: ;
    }
    {
#line 121
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 121
      if (! *strptr) {
#line 121
        goto while_break___3;
      }
      {
#line 122
      __cil_tmp26 = strptr;
#line 122
      strptr ++;
#line 122
      log_putchar(psf, *__cil_tmp26);
      }
    }
    while_break___28: /* CIL Label */ ;
    }
    while_break___3: ;
    {
#line 123
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 123
      __cil_tmp27 = width_specifier;
#line 123
      width_specifier --;
#line 123
      if (! (__cil_tmp27 > 0)) {
#line 123
        goto while_break___4;
      }
      {
#line 124
      log_putchar(psf, (char )' ');
      }
    }
    while_break___29: /* CIL Label */ ;
    }
    while_break___4: ;
#line 125
    goto switch_break___0;
    case_100: 
#line 128
    d = 0;
#line 130
    if (d < 0) {
#line 131
      d = - d;
#line 132
      sign_char = (char )'-';
#line 133
      if ((int )lead_char != 48) {
#line 133
        if (left_align == 0) {
#line 134
          __cil_tmp28 = width_specifier;
#line 134
          width_specifier --;
        }
      }
    }
#line 137
    tens = 1;
#line 138
    width = 1;
    {
#line 139
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 139
      if (! (d / tens >= 10)) {
#line 139
        goto while_break___5;
      }
#line 140
      tens *= 10;
#line 141
      width ++;
    }
    while_break___30: /* CIL Label */ ;
    }
    while_break___5: 
#line 144
    width_specifier -= width;
#line 146
    if ((int )sign_char == 32) {
      {
#line 147
      log_putchar(psf, (char )' ');
#line 148
      __cil_tmp30 = width_specifier;
#line 148
      width_specifier --;
      }
    }
#line 151
    if (left_align == 0) {
#line 151
      if ((int )lead_char != 48) {
#line 152
        if ((int )sign_char == 43) {
#line 153
          __cil_tmp31 = width_specifier;
#line 153
          width_specifier --;
        }
        {
#line 155
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 155
          __cil_tmp32 = width_specifier;
#line 155
          width_specifier --;
#line 155
          if (! (__cil_tmp32 > 0)) {
#line 155
            goto while_break___6;
          }
          {
#line 156
          log_putchar(psf, lead_char);
          }
        }
        while_break___31: /* CIL Label */ ;
        }
        while_break___6: ;
      }
    }
#line 159
    if ((int )sign_char == 43) {
      {
#line 160
      log_putchar(psf, sign_char);
#line 161
      __cil_tmp33 = width_specifier;
#line 161
      width_specifier --;
      }
    } else
#line 159
    if ((int )sign_char == 45) {
      {
#line 160
      log_putchar(psf, sign_char);
#line 161
      __cil_tmp33 = width_specifier;
#line 161
      width_specifier --;
      }
    }
#line 164
    if (left_align == 0) {
      {
#line 165
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 165
        __cil_tmp34 = width_specifier;
#line 165
        width_specifier --;
#line 165
        if (! (__cil_tmp34 > 0)) {
#line 165
          goto while_break___7;
        }
        {
#line 166
        log_putchar(psf, lead_char);
        }
      }
      while_break___32: /* CIL Label */ ;
      }
      while_break___7: ;
    }
    {
#line 168
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 168
      if (! (tens > 0)) {
#line 168
        goto while_break___8;
      }
      {
#line 169
      log_putchar(psf, (char )(48 + d / tens));
#line 170
      d %= tens;
#line 171
      tens /= 10;
      }
    }
    while_break___33: /* CIL Label */ ;
    }
    while_break___8: ;
    {
#line 174
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 174
      __cil_tmp35 = width_specifier;
#line 174
      width_specifier --;
#line 174
      if (! (__cil_tmp35 > 0)) {
#line 174
        goto while_break___9;
      }
      {
#line 175
      log_putchar(psf, lead_char);
      }
    }
    while_break___34: /* CIL Label */ ;
    }
    while_break___9: ;
#line 176
    goto switch_break___0;
    case_68: 
#line 181
    D = (sf_count_t )0;
#line 183
    if (D == 0L) {
      {
#line 184
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 184
        width_specifier --;
#line 184
        if (! (width_specifier > 0)) {
#line 184
          goto while_break___10;
        }
        {
#line 185
        log_putchar(psf, lead_char);
        }
      }
      while_break___35: /* CIL Label */ ;
      }
      while_break___10: 
      {
#line 186
      log_putchar(psf, (char )'0');
      }
#line 187
      goto switch_break___0;
    }
#line 189
    if (D < 0L) {
      {
#line 190
      log_putchar(psf, (char )'-');
#line 191
      D = - D;
      }
    }
#line 193
    Tens = (sf_count_t )1;
#line 194
    width = 1;
    {
#line 195
    while (1) {
      while_continue___13: /* CIL Label */ ;

#line 195
      if (! (D / Tens >= 10L)) {
#line 195
        goto while_break___11;
      }
#line 196
      Tens *= 10L;
#line 197
      width ++;
    }
    while_break___36: /* CIL Label */ ;
    }
    while_break___11: ;
    {
#line 200
    while (1) {
      while_continue___14: /* CIL Label */ ;

#line 200
      if (! (width_specifier > width)) {
#line 200
        goto while_break___12;
      }
      {
#line 201
      log_putchar(psf, lead_char);
#line 202
      __cil_tmp39 = width_specifier;
#line 202
      width_specifier --;
      }
    }
    while_break___37: /* CIL Label */ ;
    }
    while_break___12: ;
    {
#line 205
    while (1) {
      while_continue___15: /* CIL Label */ ;

#line 205
      if (! (Tens > 0L)) {
#line 205
        goto while_break___13;
      }
      {
#line 206
      log_putchar(psf, (char )(48L + D / Tens));
#line 207
      D %= Tens;
#line 208
      Tens /= 10L;
      }
    }
    while_break___38: /* CIL Label */ ;
    }
    while_break___13: ;
#line 211
    goto switch_break___0;
    case_117: 
#line 214
    u = (uint32_t )0;
#line 216
    tens = 1;
#line 217
    width = 1;
    {
#line 218
    while (1) {
      while_continue___16: /* CIL Label */ ;

#line 218
      if (! (u / (unsigned int )tens >= 10U)) {
#line 218
        goto while_break___14;
      }
#line 219
      tens *= 10;
#line 220
      width ++;
    }
    while_break___39: /* CIL Label */ ;
    }
    while_break___14: 
#line 223
    width_specifier -= width;
#line 225
    if ((int )sign_char == 32) {
      {
#line 226
      log_putchar(psf, (char )' ');
#line 227
      __cil_tmp41 = width_specifier;
#line 227
      width_specifier --;
      }
    }
#line 230
    if (left_align == 0) {
#line 230
      if ((int )lead_char != 48) {
#line 231
        if ((int )sign_char == 43) {
#line 232
          __cil_tmp42 = width_specifier;
#line 232
          width_specifier --;
        }
        {
#line 234
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 234
          __cil_tmp43 = width_specifier;
#line 234
          width_specifier --;
#line 234
          if (! (__cil_tmp43 > 0)) {
#line 234
            goto while_break___15;
          }
          {
#line 235
          log_putchar(psf, lead_char);
          }
        }
        while_break___40: /* CIL Label */ ;
        }
        while_break___15: ;
      }
    }
#line 238
    if ((int )sign_char == 43) {
      {
#line 239
      log_putchar(psf, sign_char);
#line 240
      __cil_tmp44 = width_specifier;
#line 240
      width_specifier --;
      }
    } else
#line 238
    if ((int )sign_char == 45) {
      {
#line 239
      log_putchar(psf, sign_char);
#line 240
      __cil_tmp44 = width_specifier;
#line 240
      width_specifier --;
      }
    }
#line 243
    if (left_align == 0) {
      {
#line 244
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 244
        __cil_tmp45 = width_specifier;
#line 244
        width_specifier --;
#line 244
        if (! (__cil_tmp45 > 0)) {
#line 244
          goto while_break___16;
        }
        {
#line 245
        log_putchar(psf, lead_char);
        }
      }
      while_break___41: /* CIL Label */ ;
      }
      while_break___16: ;
    }
    {
#line 247
    while (1) {
      while_continue___19: /* CIL Label */ ;

#line 247
      if (! (tens > 0)) {
#line 247
        goto while_break___17;
      }
      {
#line 248
      log_putchar(psf, (char )(48U + u / (unsigned int )tens));
#line 249
      u %= (unsigned int )tens;
#line 250
      tens /= 10;
      }
    }
    while_break___42: /* CIL Label */ ;
    }
    while_break___17: ;
    {
#line 253
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 253
      __cil_tmp46 = width_specifier;
#line 253
      width_specifier --;
#line 253
      if (! (__cil_tmp46 > 0)) {
#line 253
        goto while_break___18;
      }
      {
#line 254
      log_putchar(psf, lead_char);
      }
    }
    while_break___43: /* CIL Label */ ;
    }
    while_break___18: ;
#line 255
    goto switch_break___0;
    case_99: 
    {
#line 258
    c = (char)0;
#line 259
    log_putchar(psf, c);
    }
#line 260
    goto switch_break___0;
    case_88: 
#line 264
    d = 0;
#line 266
    if (d == 0) {
      {
#line 267
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 267
        width_specifier --;
#line 267
        if (! (width_specifier > 0)) {
#line 267
          goto while_break___19;
        }
        {
#line 268
        log_putchar(psf, lead_char);
        }
      }
      while_break___44: /* CIL Label */ ;
      }
      while_break___19: 
      {
#line 269
      log_putchar(psf, (char )'0');
      }
#line 270
      goto switch_break___0;
    }
#line 272
    shift = 28;
#line 273
    if (width_specifier < 8) {
#line 273
      tmp___0 = 8;
    } else {
#line 273
      tmp___0 = width_specifier;
    }
#line 273
    width = tmp___0;
    {
#line 274
    while (1) {
      while_continue___22: /* CIL Label */ ;

#line 274
      if (! (! ((15U << shift) & (unsigned int )d))) {
#line 274
        goto while_break___20;
      }
#line 275
      shift -= 4;
#line 276
      __cil_tmp48 = width;
#line 276
      width --;
    }
    while_break___45: /* CIL Label */ ;
    }
    while_break___20: ;
    {
#line 279
    while (1) {
      while_continue___23: /* CIL Label */ ;

#line 279
      if (width > 0) {
#line 279
        if (! (width_specifier > width)) {
#line 279
          goto while_break___21;
        }
      } else {
#line 279
        goto while_break___21;
      }
      {
#line 280
      log_putchar(psf, lead_char);
#line 281
      __cil_tmp49 = width_specifier;
#line 281
      width_specifier --;
      }
    }
    while_break___46: /* CIL Label */ ;
    }
    while_break___21: ;
    {
#line 284
    while (1) {
      while_continue___24: /* CIL Label */ ;

#line 284
      if (! (shift >= 0)) {
#line 284
        goto while_break___22;
      }
#line 285
      c = (char )((d >> shift) & 15);
#line 286
      if ((int )c > 9) {
#line 286
        tmp___1 = ((int )c + 65) - 10;
      } else {
#line 286
        tmp___1 = (int )c + 48;
      }
      {
#line 286
      log_putchar(psf, (char )tmp___1);
#line 287
      shift -= 4;
      }
    }
    while_break___47: /* CIL Label */ ;
    }
    while_break___22: ;
#line 289
    goto switch_break___0;
    case_77: 
#line 292
    d = 0;
#line 294
    istr[0] = (char )(d & 255);
#line 295
    istr[1] = (char )((d >> 8) & 255);
#line 296
    istr[2] = (char )((d >> 16) & 255);
#line 297
    istr[3] = (char )((d >> 24) & 255);
#line 305
    istr[4] = (char)0;
#line 306
    strptr = istr;
    {
#line 307
    while (1) {
      while_continue___25: /* CIL Label */ ;

#line 307
      if (! *strptr) {
#line 307
        goto while_break___23;
      }
      {
#line 308
      __cil_tmp51 = strptr;
#line 308
      strptr ++;
#line 308
      c = *__cil_tmp51;
#line 309
      log_putchar(psf, c);
      }
    }
    while_break___48: /* CIL Label */ ;
    }
    while_break___23: ;
#line 311
    goto switch_break___0;
    switch_default___0: 
    {
#line 314
    log_putchar(psf, (char )'*');
#line 315
    log_putchar(psf, c);
#line 316
    log_putchar(psf, (char )'*');
    }
#line 317
    goto switch_break___0;
    switch_break___0: ;
  }
  while_break___24: /* CIL Label */ ;
  }
  while_break: 
  {
#line 321
  __builtin_va_end((__builtin_va_list )((void *)ap));
  }
#line 322
  return;
}
}
#line 334 "/root/patchweave_donee/23/src/common.c"
void psf_asciiheader_printf(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list argptr ;
  int maxlen ;
  char *start ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  {
#line 339
  __cil_tmp6 = strlen((char const   *)((char *)(psf->header)));
#line 339
  maxlen = (int )__cil_tmp6;
#line 340
  start = (char *)(psf->header) + maxlen;
#line 341
  maxlen = (int )(sizeof(psf->header) - (unsigned long )maxlen);
#line 343
  __builtin_va_start((__builtin_va_list )((void *)argptr), format);
#line 344
  vsnprintf(start, (unsigned long )maxlen, format, (__gnuc_va_list )((void *)argptr));
#line 345
  __builtin_va_end((__builtin_va_list )((void *)argptr));
#line 348
  *(start + (maxlen - 1)) = (char)0;
#line 350
  __cil_tmp7 = strlen((char const   *)((char *)(psf->header)));
#line 350
  psf->headindex = (int )__cil_tmp7;
  }
#line 352
  return;
}
}
#line 400 "/root/patchweave_donee/23/src/common.c"
__inline static void header_put_byte(SF_PRIVATE *psf , char x ) 
{ 
  int __cil_tmp3 ;

  {
#line 401
  if (psf->headindex < (int )sizeof(psf->header) - 1) {
#line 402
    __cil_tmp3 = psf->headindex;
#line 402
    (psf->headindex) ++;
#line 402
    psf->header[__cil_tmp3] = (unsigned char )x;
  }
#line 404
  return;
}
}
#line 418 "/root/patchweave_donee/23/src/common.c"
__inline static void header_put_marker(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 419
  if (psf->headindex < (int )sizeof(psf->header) - 4) {
#line 420
    __cil_tmp3 = psf->headindex;
#line 420
    (psf->headindex) ++;
#line 420
    psf->header[__cil_tmp3] = (unsigned char )x;
#line 421
    __cil_tmp4 = psf->headindex;
#line 421
    (psf->headindex) ++;
#line 421
    psf->header[__cil_tmp4] = (unsigned char )(x >> 8);
#line 422
    __cil_tmp5 = psf->headindex;
#line 422
    (psf->headindex) ++;
#line 422
    psf->header[__cil_tmp5] = (unsigned char )(x >> 16);
#line 423
    __cil_tmp6 = psf->headindex;
#line 423
    (psf->headindex) ++;
#line 423
    psf->header[__cil_tmp6] = (unsigned char )(x >> 24);
  }
#line 426
  return;
}
}
#line 433 "/root/patchweave_donee/23/src/common.c"
__inline static void header_put_be_short(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 434
  if (psf->headindex < (int )sizeof(psf->header) - 2) {
#line 435
    __cil_tmp3 = psf->headindex;
#line 435
    (psf->headindex) ++;
#line 435
    psf->header[__cil_tmp3] = (unsigned char )(x >> 8);
#line 436
    __cil_tmp4 = psf->headindex;
#line 436
    (psf->headindex) ++;
#line 436
    psf->header[__cil_tmp4] = (unsigned char )x;
  }
#line 439
  return;
}
}
#line 441 "/root/patchweave_donee/23/src/common.c"
__inline static void header_put_le_short(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 442
  if (psf->headindex < (int )sizeof(psf->header) - 2) {
#line 443
    __cil_tmp3 = psf->headindex;
#line 443
    (psf->headindex) ++;
#line 443
    psf->header[__cil_tmp3] = (unsigned char )x;
#line 444
    __cil_tmp4 = psf->headindex;
#line 444
    (psf->headindex) ++;
#line 444
    psf->header[__cil_tmp4] = (unsigned char )(x >> 8);
  }
#line 447
  return;
}
}
#line 449 "/root/patchweave_donee/23/src/common.c"
__inline static void header_put_be_3byte(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 450
  if (psf->headindex < (int )sizeof(psf->header) - 3) {
#line 451
    __cil_tmp3 = psf->headindex;
#line 451
    (psf->headindex) ++;
#line 451
    psf->header[__cil_tmp3] = (unsigned char )(x >> 16);
#line 452
    __cil_tmp4 = psf->headindex;
#line 452
    (psf->headindex) ++;
#line 452
    psf->header[__cil_tmp4] = (unsigned char )(x >> 8);
#line 453
    __cil_tmp5 = psf->headindex;
#line 453
    (psf->headindex) ++;
#line 453
    psf->header[__cil_tmp5] = (unsigned char )x;
  }
#line 456
  return;
}
}
#line 458 "/root/patchweave_donee/23/src/common.c"
__inline static void header_put_le_3byte(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 459
  if (psf->headindex < (int )sizeof(psf->header) - 3) {
#line 460
    __cil_tmp3 = psf->headindex;
#line 460
    (psf->headindex) ++;
#line 460
    psf->header[__cil_tmp3] = (unsigned char )x;
#line 461
    __cil_tmp4 = psf->headindex;
#line 461
    (psf->headindex) ++;
#line 461
    psf->header[__cil_tmp4] = (unsigned char )(x >> 8);
#line 462
    __cil_tmp5 = psf->headindex;
#line 462
    (psf->headindex) ++;
#line 462
    psf->header[__cil_tmp5] = (unsigned char )(x >> 16);
  }
#line 465
  return;
}
}
#line 467 "/root/patchweave_donee/23/src/common.c"
__inline static void header_put_be_int(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 468
  if (psf->headindex < (int )sizeof(psf->header) - 4) {
#line 469
    __cil_tmp3 = psf->headindex;
#line 469
    (psf->headindex) ++;
#line 469
    psf->header[__cil_tmp3] = (unsigned char )(x >> 24);
#line 470
    __cil_tmp4 = psf->headindex;
#line 470
    (psf->headindex) ++;
#line 470
    psf->header[__cil_tmp4] = (unsigned char )(x >> 16);
#line 471
    __cil_tmp5 = psf->headindex;
#line 471
    (psf->headindex) ++;
#line 471
    psf->header[__cil_tmp5] = (unsigned char )(x >> 8);
#line 472
    __cil_tmp6 = psf->headindex;
#line 472
    (psf->headindex) ++;
#line 472
    psf->header[__cil_tmp6] = (unsigned char )x;
  }
#line 475
  return;
}
}
#line 519 "/root/patchweave_donee/23/src/common.c"
__inline static void header_put_be_8byte(SF_PRIVATE *psf , sf_count_t x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 520
  if (psf->headindex < (int )sizeof(psf->header) - 8) {
#line 521
    __cil_tmp3 = psf->headindex;
#line 521
    (psf->headindex) ++;
#line 521
    psf->header[__cil_tmp3] = (unsigned char )(x >> 56);
#line 522
    __cil_tmp4 = psf->headindex;
#line 522
    (psf->headindex) ++;
#line 522
    psf->header[__cil_tmp4] = (unsigned char )(x >> 48);
#line 523
    __cil_tmp5 = psf->headindex;
#line 523
    (psf->headindex) ++;
#line 523
    psf->header[__cil_tmp5] = (unsigned char )(x >> 40);
#line 524
    __cil_tmp6 = psf->headindex;
#line 524
    (psf->headindex) ++;
#line 524
    psf->header[__cil_tmp6] = (unsigned char )(x >> 32);
#line 525
    __cil_tmp7 = psf->headindex;
#line 525
    (psf->headindex) ++;
#line 525
    psf->header[__cil_tmp7] = (unsigned char )(x >> 24);
#line 526
    __cil_tmp8 = psf->headindex;
#line 526
    (psf->headindex) ++;
#line 526
    psf->header[__cil_tmp8] = (unsigned char )(x >> 16);
#line 527
    __cil_tmp9 = psf->headindex;
#line 527
    (psf->headindex) ++;
#line 527
    psf->header[__cil_tmp9] = (unsigned char )(x >> 8);
#line 528
    __cil_tmp10 = psf->headindex;
#line 528
    (psf->headindex) ++;
#line 528
    psf->header[__cil_tmp10] = (unsigned char )x;
  }
#line 531
  return;
}
}
#line 533 "/root/patchweave_donee/23/src/common.c"
__inline static void header_put_le_8byte(SF_PRIVATE *psf , sf_count_t x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 534
  if (psf->headindex < (int )sizeof(psf->header) - 8) {
#line 535
    __cil_tmp3 = psf->headindex;
#line 535
    (psf->headindex) ++;
#line 535
    psf->header[__cil_tmp3] = (unsigned char )x;
#line 536
    __cil_tmp4 = psf->headindex;
#line 536
    (psf->headindex) ++;
#line 536
    psf->header[__cil_tmp4] = (unsigned char )(x >> 8);
#line 537
    __cil_tmp5 = psf->headindex;
#line 537
    (psf->headindex) ++;
#line 537
    psf->header[__cil_tmp5] = (unsigned char )(x >> 16);
#line 538
    __cil_tmp6 = psf->headindex;
#line 538
    (psf->headindex) ++;
#line 538
    psf->header[__cil_tmp6] = (unsigned char )(x >> 24);
#line 539
    __cil_tmp7 = psf->headindex;
#line 539
    (psf->headindex) ++;
#line 539
    psf->header[__cil_tmp7] = (unsigned char )(x >> 32);
#line 540
    __cil_tmp8 = psf->headindex;
#line 540
    (psf->headindex) ++;
#line 540
    psf->header[__cil_tmp8] = (unsigned char )(x >> 40);
#line 541
    __cil_tmp9 = psf->headindex;
#line 541
    (psf->headindex) ++;
#line 541
    psf->header[__cil_tmp9] = (unsigned char )(x >> 48);
#line 542
    __cil_tmp10 = psf->headindex;
#line 542
    (psf->headindex) ++;
#line 542
    psf->header[__cil_tmp10] = (unsigned char )(x >> 56);
  }
#line 545
  return;
}
}
#line 551 "/root/patchweave_donee/23/src/common.c"
int psf_binheader_writef(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list argptr ;
  sf_count_t countdata ;
  unsigned long longdata ;
  unsigned int data ;
  float floatdata ;
  double doubledata ;
  void *bindata ;
  size_t size ;
  char c ;
  char *strptr ;
  int count___0 ;
  int trunc_8to4 ;
  char const   *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  size_t __cil_tmp19 ;

  {
  {
#line 561
  count___0 = 0;
#line 563
  trunc_8to4 = 0;
#line 565
  __builtin_va_start((__builtin_va_list )((void *)argptr), format);
  }
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    __cil_tmp15 = format;
#line 567
    format ++;
#line 567
    c = (char )*__cil_tmp15;
#line 567
    if (! c) {
#line 567
      goto while_break;
    }
#line 569
    if ((int )c == 32) {
#line 569
      goto case_32;
    }
#line 572
    if ((int )c == 101) {
#line 572
      goto case_101;
    }
#line 576
    if ((int )c == 69) {
#line 576
      goto case_69;
    }
#line 580
    if ((int )c == 116) {
#line 580
      goto case_116;
    }
#line 584
    if ((int )c == 84) {
#line 584
      goto case_84;
    }
#line 588
    if ((int )c == 109) {
#line 588
      goto case_109;
    }
#line 594
    if ((int )c == 49) {
#line 594
      goto case_49;
    }
#line 600
    if ((int )c == 50) {
#line 600
      goto case_50;
    }
#line 611
    if ((int )c == 51) {
#line 611
      goto case_51;
    }
#line 622
    if ((int )c == 52) {
#line 622
      goto case_52;
    }
#line 633
    if ((int )c == 56) {
#line 633
      goto case_56;
    }
#line 655
    if ((int )c == 102) {
#line 655
      goto case_102;
    }
#line 666
    if ((int )c == 100) {
#line 666
      goto case_100;
    }
#line 676
    if ((int )c == 115) {
#line 676
      goto case_115;
    }
#line 691
    if ((int )c == 83) {
#line 691
      goto case_83;
    }
#line 709
    if ((int )c == 98) {
#line 709
      goto case_98;
    }
#line 717
    if ((int )c == 122) {
#line 717
      goto case_122;
    }
#line 727
    if ((int )c == 104) {
#line 727
      goto case_104;
    }
#line 734
    if ((int )c == 106) {
#line 734
      goto case_106;
    }
#line 740
    goto switch_default;
    case_32: 
#line 570
    goto switch_break;
    case_101: 
#line 573
    psf->rwf_endian = 268435456;
#line 574
    goto switch_break;
    case_69: 
#line 577
    psf->rwf_endian = 536870912;
#line 578
    goto switch_break;
    case_116: 
#line 581
    trunc_8to4 = 1;
#line 582
    goto switch_break;
    case_84: 
#line 585
    trunc_8to4 = 0;
#line 586
    goto switch_break;
    case_109: 
    {
#line 589
    data = 0U;
#line 590
    header_put_marker(psf, (int )data);
#line 591
    count___0 += 4;
    }
#line 592
    goto switch_break;
    case_49: 
    {
#line 595
    data = 0U;
#line 596
    header_put_byte(psf, (char )data);
#line 597
    count___0 ++;
    }
#line 598
    goto switch_break;
    case_50: 
#line 601
    data = 0U;
#line 602
    if (psf->rwf_endian == 536870912) {
      {
#line 603
      header_put_be_short(psf, (int )data);
      }
    } else {
      {
#line 606
      header_put_le_short(psf, (int )data);
      }
    }
#line 608
    count___0 += 2;
#line 609
    goto switch_break;
    case_51: 
#line 612
    data = 0U;
#line 613
    if (psf->rwf_endian == 536870912) {
      {
#line 614
      header_put_be_3byte(psf, (int )data);
      }
    } else {
      {
#line 617
      header_put_le_3byte(psf, (int )data);
      }
    }
#line 619
    count___0 += 3;
#line 620
    goto switch_break;
    case_52: 
#line 623
    data = 0U;
#line 624
    if (psf->rwf_endian == 536870912) {
      {
#line 625
      header_put_be_int(psf, (int )data);
      }
    } else {
      {
#line 628
      header_put_marker(psf, (int )data);
      }
    }
#line 630
    count___0 += 4;
#line 631
    goto switch_break;
    case_56: 
#line 634
    countdata = (sf_count_t )0;
#line 635
    if (psf->rwf_endian == 536870912) {
#line 635
      if (trunc_8to4 == 0) {
        {
#line 636
        header_put_be_8byte(psf, countdata);
#line 637
        count___0 += 8;
        }
      } else {
#line 635
        goto _L___6;
      }
    } else
    _L___6: 
#line 639
    if (psf->rwf_endian == 268435456) {
#line 639
      if (trunc_8to4 == 0) {
        {
#line 640
        header_put_le_8byte(psf, countdata);
#line 641
        count___0 += 8;
        }
      } else {
#line 639
        goto _L___5;
      }
    } else
    _L___5: 
#line 643
    if (psf->rwf_endian == 536870912) {
#line 643
      if (trunc_8to4 == 1) {
        {
#line 644
        longdata = (unsigned long )(countdata & 4294967295L);
#line 645
        header_put_be_int(psf, (int )longdata);
#line 646
        count___0 += 4;
        }
      } else {
#line 643
        goto _L;
      }
    } else
    _L: 
#line 648
    if (psf->rwf_endian == 268435456) {
#line 648
      if (trunc_8to4 == 1) {
        {
#line 649
        longdata = (unsigned long )(countdata & 4294967295L);
#line 650
        header_put_marker(psf, (int )longdata);
#line 651
        count___0 += 4;
        }
      }
    }
#line 653
    goto switch_break;
    case_102: 
#line 657
    floatdata = (float )0;
#line 658
    if (psf->rwf_endian == 536870912) {
      {
#line 659
      float32_be_write(floatdata, psf->header + psf->headindex);
      }
    } else {
      {
#line 661
      float32_le_write(floatdata, psf->header + psf->headindex);
      }
    }
#line 662
    psf->headindex += 4;
#line 663
    count___0 += 4;
#line 664
    goto switch_break;
    case_100: 
#line 667
    doubledata = (double )0;
#line 668
    if (psf->rwf_endian == 536870912) {
      {
#line 669
      double64_be_write(doubledata, psf->header + psf->headindex);
      }
    } else {
      {
#line 671
      double64_le_write(doubledata, psf->header + psf->headindex);
      }
    }
#line 672
    psf->headindex += 8;
#line 673
    count___0 += 8;
#line 674
    goto switch_break;
    case_115: 
    {
#line 678
    strptr = (char *)0;
#line 679
    __cil_tmp16 = strlen((char const   *)strptr);
#line 679
    size = __cil_tmp16 + 1UL;
#line 680
    size += size & 1UL;
    }
#line 681
    if (psf->rwf_endian == 536870912) {
      {
#line 682
      header_put_be_int(psf, (int )size);
      }
    } else {
      {
#line 684
      header_put_marker(psf, (int )size);
      }
    }
    {
#line 685
    memcpy((void *)(& psf->header[psf->headindex]), (void const   *)strptr, size);
#line 686
    psf->headindex = (int )((size_t )psf->headindex + size);
#line 687
    psf->header[psf->headindex - 1] = (unsigned char)0;
#line 688
    count___0 = (int )((unsigned long )count___0 + (4UL + size));
    }
#line 689
    goto switch_break;
    case_83: 
    {
#line 696
    strptr = (char *)0;
#line 697
    size = strlen((char const   *)strptr);
    }
#line 698
    if (psf->rwf_endian == 536870912) {
      {
#line 699
      header_put_be_int(psf, (int )size);
      }
    } else {
      {
#line 701
      header_put_marker(psf, (int )size);
      }
    }
    {
#line 702
    memcpy((void *)(& psf->header[psf->headindex]), (void const   *)strptr, size + 1UL);
#line 703
    size += size & 1UL;
#line 704
    psf->headindex = (int )((size_t )psf->headindex + size);
#line 705
    psf->header[psf->headindex] = (unsigned char)0;
#line 706
    count___0 = (int )((unsigned long )count___0 + (4UL + size));
    }
#line 707
    goto switch_break;
    case_98: 
    {
#line 710
    bindata = (void *)0;
#line 711
    size = (size_t )0;
#line 712
    memcpy((void *)(& psf->header[psf->headindex]), (void const   *)bindata, size);
#line 713
    psf->headindex = (int )((size_t )psf->headindex + size);
#line 714
    count___0 = (int )((size_t )count___0 + size);
    }
#line 715
    goto switch_break;
    case_122: 
#line 718
    size = (size_t )0;
#line 719
    count___0 = (int )((size_t )count___0 + size);
    {
#line 720
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 720
      if (! size) {
#line 720
        goto while_break___0;
      }
#line 721
      psf->header[psf->headindex] = (unsigned char)0;
#line 722
      (psf->headindex) ++;
#line 723
      __cil_tmp19 = size;
#line 723
      size --;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 725
    goto switch_break;
    case_104: 
    {
#line 728
    bindata = (void *)0;
#line 729
    memcpy((void *)(& psf->header[psf->headindex]), (void const   *)bindata, 16UL);
#line 730
    psf->headindex += 16;
#line 731
    count___0 += 16;
    }
#line 732
    goto switch_break;
    case_106: 
#line 735
    size = (size_t )0;
#line 736
    psf->headindex = (int )((size_t )psf->headindex + size);
#line 737
    count___0 = (int )size;
#line 738
    goto switch_break;
    switch_default: 
    {
#line 741
    psf_log_printf(psf, "*** Invalid format specifier `%c\'\n\325\323\204U", (int )c);
#line 742
    psf->error = 30;
    }
#line 743
    goto switch_break;
    switch_break: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 747
  __builtin_va_end((__builtin_va_list )((void *)argptr));
  }
#line 748
  return (count___0);
}
}
#line 799 "/root/patchweave_donee/23/src/common.c"
static int header_read(SF_PRIVATE *psf , void *ptr , int bytes ) 
{ 
  int count___0 ;
  sf_count_t __cil_tmp5 ;
  int most ;
  sf_count_t __cil_tmp7 ;

  {
#line 800
  count___0 = 0;
#line 802
  if (psf->headindex >= (int )sizeof(psf->header)) {
    {
#line 803
    __cil_tmp5 = psf_fread(ptr, (sf_count_t )1, (sf_count_t )bytes, psf);
    }
#line 803
    return ((int )__cil_tmp5);
  }
#line 805
  if (psf->headindex + bytes > (int )sizeof(psf->header)) {
    {
#line 808
    most = (int )sizeof(psf->header) - psf->headend;
#line 809
    psf_fread((void *)(psf->header + psf->headend), (sf_count_t )1, (sf_count_t )most,
              psf);
#line 810
    memcpy(ptr, (void const   *)(psf->header + psf->headend), (unsigned long )most);
#line 811
    psf->headindex += most;
#line 811
    psf->headend = psf->headindex;
#line 812
    psf_fread((void *)((char *)ptr + most), (sf_count_t )(bytes - most), (sf_count_t )1,
              psf);
    }
#line 813
    return (bytes);
  }
#line 816
  if (psf->headindex + bytes > psf->headend) {
    {
#line 817
    __cil_tmp7 = psf_fread((void *)(psf->header + psf->headend), (sf_count_t )1, (sf_count_t )(bytes - (psf->headend - psf->headindex)),
                           psf);
#line 817
    count___0 = (int )__cil_tmp7;
    }
#line 818
    if (count___0 != bytes - (psf->headend - psf->headindex)) {
      {
#line 819
      psf_log_printf(psf, "Error : psf_fread returned short count.\n\220");
      }
#line 820
      return (count___0);
    }
#line 822
    psf->headend += count___0;
  }
  {
#line 825
  memcpy(ptr, (void const   *)(psf->header + psf->headindex), (unsigned long )bytes);
#line 826
  psf->headindex += bytes;
  }
#line 828
  return (bytes);
}
}
#line 832 "/root/patchweave_donee/23/src/common.c"
static void header_seek(SF_PRIVATE *psf , sf_count_t position , int whence ) 
{ 
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;

  {
#line 835
  if (whence == 0) {
#line 835
    goto case_0;
  }
#line 846
  if (whence == 1) {
#line 846
    goto case_1;
  }
#line 872
  goto switch_default;
  case_0: 
#line 836
  if (position > (long )((int )sizeof(psf->header))) {
    {
#line 838
    psf_fseek(psf, position, whence);
    }
#line 839
    return;
  }
#line 841
  if (position > (long )psf->headend) {
    {
#line 842
    __cil_tmp4 = psf_fread((void *)(psf->header + psf->headend), (sf_count_t )1, position - (long )psf->headend,
                           psf);
#line 842
    psf->headend = (int )((sf_count_t )psf->headend + __cil_tmp4);
    }
  }
#line 843
  psf->headindex = (int )position;
#line 844
  goto switch_break;
  case_1: 
#line 847
  if ((long )psf->headindex + position < 0L) {
#line 848
    goto switch_break;
  }
#line 850
  if (psf->headindex >= (int )sizeof(psf->header)) {
    {
#line 851
    psf_fseek(psf, position, whence);
    }
#line 852
    return;
  }
#line 855
  if ((long )psf->headindex + position <= (long )psf->headend) {
#line 856
    psf->headindex = (int )((sf_count_t )psf->headindex + position);
#line 857
    goto switch_break;
  }
#line 860
  if ((long )psf->headindex + position > (long )((int )sizeof(psf->header))) {
    {
#line 862
    psf->headindex = psf->headend;
#line 863
    psf_fseek(psf, position, 1);
    }
#line 864
    goto switch_break;
  }
  {
#line 867
  __cil_tmp5 = psf_fread((void *)(psf->header + psf->headend), (sf_count_t )1, position - (long )(psf->headend - psf->headindex),
                         psf);
#line 867
  psf->headend = (int )((sf_count_t )psf->headend + __cil_tmp5);
#line 868
  psf->headindex = psf->headend;
  }
#line 869
  goto switch_break;
  switch_default: 
  {
#line 873
  psf_log_printf(psf, "Bad whence param in header_seek().\n\323\204U");
  }
#line 874
  goto switch_break;
  switch_break: ;
#line 877
  return;
}
}
#line 881 "/root/patchweave_donee/23/src/common.c"
static int header_gets(SF_PRIVATE *psf , char *ptr , int bufsize ) 
{ 
  int k ;
  sf_count_t __cil_tmp6 ;

  {
#line 884
  k = 0;
  {
#line 884
  while (1) {
    while_continue: /* CIL Label */ ;

#line 884
    if (! (k < bufsize - 1)) {
#line 884
      goto while_break;
    }
#line 885
    if (psf->headindex < psf->headend) {
#line 886
      *(ptr + k) = (char )psf->header[psf->headindex];
#line 887
      (psf->headindex) ++;
    } else {
      {
#line 890
      __cil_tmp6 = psf_fread((void *)(psf->header + psf->headend), (sf_count_t )1,
                             (sf_count_t )1, psf);
#line 890
      psf->headend = (int )((sf_count_t )psf->headend + __cil_tmp6);
#line 891
      *(ptr + k) = (char )psf->header[psf->headindex];
#line 892
      psf->headindex = psf->headend;
      }
    }
#line 895
    if ((int )*(ptr + k) == 10) {
#line 896
      goto while_break;
    }
#line 884
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 899
  *(ptr + k) = (char)0;
#line 901
  return (k);
}
}
#line 905 "/root/patchweave_donee/23/src/common.c"
int psf_binheader_readf(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list argptr ;
  sf_count_t *countptr ;
  sf_count_t countdata ;
  unsigned char *ucptr ;
  unsigned char sixteen_bytes[16] ;
  unsigned int *intptr ;
  unsigned int intdata ;
  unsigned short *shortptr ;
  char *charptr ;
  float *floatptr ;
  double *doubleptr ;
  char c ;
  int byte_count ;
  int count___0 ;
  sf_count_t __cil_tmp17 ;
  char const   *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int k ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int32_t __cil_tmp27 ;
  int32_t __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp32 ;
  int __cil_tmp35 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
#line 915
  byte_count = 0;
#line 917
  if (! format) {
    {
#line 918
    __cil_tmp17 = psf_ftell(psf);
    }
#line 918
    return ((int )__cil_tmp17);
  }
  {
#line 920
  __builtin_va_start((__builtin_va_list )((void *)argptr), format);
  }
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    __cil_tmp18 = format;
#line 922
    format ++;
#line 922
    c = (char )*__cil_tmp18;
#line 922
    if (! c) {
#line 922
      goto while_break;
    }
#line 924
    if ((int )c == 101) {
#line 924
      goto case_101;
    }
#line 928
    if ((int )c == 69) {
#line 928
      goto case_69;
    }
#line 932
    if ((int )c == 109) {
#line 932
      goto case_109;
    }
#line 939
    if ((int )c == 104) {
#line 939
      goto case_104;
    }
#line 951
    if ((int )c == 49) {
#line 951
      goto case_49;
    }
#line 957
    if ((int )c == 50) {
#line 957
      goto case_50;
    }
#line 968
    if ((int )c == 51) {
#line 968
      goto case_51;
    }
#line 978
    if ((int )c == 52) {
#line 978
      goto case_52;
    }
#line 989
    if ((int )c == 56) {
#line 989
      goto case_56;
    }
#line 1000
    if ((int )c == 102) {
#line 1000
      goto case_102;
    }
#line 1010
    if ((int )c == 100) {
#line 1010
      goto case_100;
    }
#line 1020
    if ((int )c == 115) {
#line 1020
      goto case_115;
    }
#line 1033
    if ((int )c == 98) {
#line 1033
      goto case_98;
    }
#line 1040
    if ((int )c == 71) {
#line 1040
      goto case_71;
    }
#line 1047
    if ((int )c == 122) {
#line 1047
      goto case_122;
    }
#line 1059
    if ((int )c == 112) {
#line 1059
      goto case_112;
    }
#line 1066
    if ((int )c == 106) {
#line 1066
      goto case_106;
    }
#line 1075
    goto switch_default;
    case_101: 
#line 925
    psf->rwf_endian = 268435456;
#line 926
    goto switch_break;
    case_69: 
#line 929
    psf->rwf_endian = 536870912;
#line 930
    goto switch_break;
    case_109: 
    {
#line 933
    intptr = (unsigned int *)0;
#line 934
    ucptr = (unsigned char *)intptr;
#line 935
    __cil_tmp19 = header_read(psf, (void *)ucptr, (int )sizeof(int ));
#line 935
    byte_count += __cil_tmp19;
#line 936
    *intptr = (unsigned int )(((int )*(ucptr + 0) | ((int )*(ucptr + 1) << 8)) | ((int )*(ucptr + 2) << 16)) | ((uint32_t )*(ucptr + 3) << 24);
    }
#line 937
    goto switch_break;
    case_104: 
    {
#line 940
    intptr = (unsigned int *)0;
#line 941
    ucptr = (unsigned char *)intptr;
#line 942
    __cil_tmp20 = header_read(psf, (void *)(sixteen_bytes), (int )sizeof(sixteen_bytes));
#line 942
    byte_count += __cil_tmp20;
#line 944
    intdata = 0U;
#line 945
    k = 0;
    }
    {
#line 945
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 945
      if (! (k < 16)) {
#line 945
        goto while_break___0;
      }
#line 946
      intdata ^= (unsigned int )((int )sixteen_bytes[k] << k);
#line 945
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 948
    *intptr = intdata;
#line 949
    goto switch_break;
    case_49: 
    {
#line 952
    charptr = (char *)0;
#line 953
    *charptr = (char)0;
#line 954
    __cil_tmp23 = header_read(psf, (void *)charptr, (int )sizeof(char ));
#line 954
    byte_count += __cil_tmp23;
    }
#line 955
    goto switch_break;
    case_50: 
    {
#line 958
    shortptr = (unsigned short *)0;
#line 959
    *shortptr = (unsigned short)0;
#line 960
    ucptr = (unsigned char *)shortptr;
#line 961
    __cil_tmp24 = header_read(psf, (void *)ucptr, (int )sizeof(short ));
#line 961
    byte_count += __cil_tmp24;
    }
#line 962
    if (psf->rwf_endian == 536870912) {
#line 963
      *shortptr = (unsigned short )(((int )*(ucptr + 0) << 8) | (int )*(ucptr + 1));
    } else {
#line 965
      *shortptr = (unsigned short )(((int )*(ucptr + 1) << 8) | (int )*(ucptr + 0));
    }
#line 966
    goto switch_break;
    case_51: 
    {
#line 969
    intptr = (unsigned int *)0;
#line 970
    *intptr = 0U;
#line 971
    __cil_tmp25 = header_read(psf, (void *)(sixteen_bytes), 3);
#line 971
    byte_count += __cil_tmp25;
    }
#line 972
    if (psf->rwf_endian == 536870912) {
#line 973
      *intptr = (unsigned int )((((int )sixteen_bytes[0] << 16) | ((int )sixteen_bytes[1] << 8)) | (int )sixteen_bytes[2]);
    } else {
#line 975
      *intptr = (unsigned int )((((int )sixteen_bytes[2] << 16) | ((int )sixteen_bytes[1] << 8)) | (int )sixteen_bytes[0]);
    }
#line 976
    goto switch_break;
    case_52: 
    {
#line 979
    intptr = (unsigned int *)0;
#line 980
    *intptr = 0U;
#line 981
    ucptr = (unsigned char *)intptr;
#line 982
    __cil_tmp26 = header_read(psf, (void *)ucptr, (int )sizeof(int ));
#line 982
    byte_count += __cil_tmp26;
    }
#line 983
    if (psf->rwf_endian == 536870912) {
      {
#line 984
      __cil_tmp27 = psf_get_be32(ucptr, 0);
#line 984
      *intptr = (unsigned int )__cil_tmp27;
      }
    } else {
      {
#line 986
      __cil_tmp28 = psf_get_le32(ucptr, 0);
#line 986
      *intptr = (unsigned int )__cil_tmp28;
      }
    }
#line 987
    goto switch_break;
    case_56: 
    {
#line 990
    countptr = (sf_count_t *)0;
#line 991
    *countptr = (sf_count_t )0;
#line 992
    __cil_tmp29 = header_read(psf, (void *)(sixteen_bytes), 8);
#line 992
    byte_count += __cil_tmp29;
    }
#line 993
    if (psf->rwf_endian == 536870912) {
      {
#line 994
      countdata = psf_get_be64(sixteen_bytes, 0);
      }
    } else {
      {
#line 996
      countdata = psf_get_le64(sixteen_bytes, 0);
      }
    }
#line 997
    *countptr = countdata;
#line 998
    goto switch_break;
    case_102: 
    {
#line 1001
    floatptr = (float *)0;
#line 1002
    *floatptr = (float )0.;
#line 1003
    __cil_tmp32 = header_read(psf, (void *)floatptr, (int )sizeof(float ));
#line 1003
    byte_count += __cil_tmp32;
    }
#line 1004
    if (psf->rwf_endian == 536870912) {
      {
#line 1005
      *floatptr = float32_be_read((unsigned char const   *)((unsigned char *)floatptr));
      }
    } else {
      {
#line 1007
      *floatptr = float32_le_read((unsigned char const   *)((unsigned char *)floatptr));
      }
    }
#line 1008
    goto switch_break;
    case_100: 
    {
#line 1011
    doubleptr = (double *)0;
#line 1012
    *doubleptr = 0.;
#line 1013
    __cil_tmp35 = header_read(psf, (void *)doubleptr, (int )sizeof(double ));
#line 1013
    byte_count += __cil_tmp35;
    }
#line 1014
    if (psf->rwf_endian == 536870912) {
      {
#line 1015
      *doubleptr = double64_be_read((unsigned char const   *)((unsigned char *)doubleptr));
      }
    } else {
      {
#line 1017
      *doubleptr = double64_le_read((unsigned char const   *)((unsigned char *)doubleptr));
      }
    }
#line 1018
    goto switch_break;
    case_115: 
    {
#line 1021
    psf_log_printf(psf, "Format conversion \'s\' not implemented yet.\n");
    }
#line 1031
    goto switch_break;
    case_98: 
#line 1034
    charptr = (char *)0;
#line 1035
    count___0 = 0;
#line 1036
    if (count___0 > 0) {
      {
#line 1037
      __cil_tmp38 = header_read(psf, (void *)charptr, count___0);
#line 1037
      byte_count += __cil_tmp38;
      }
    }
#line 1038
    goto switch_break;
    case_71: 
#line 1041
    charptr = (char *)0;
#line 1042
    count___0 = 0;
#line 1043
    if (count___0 > 0) {
      {
#line 1044
      __cil_tmp39 = header_gets(psf, charptr, count___0);
#line 1044
      byte_count += __cil_tmp39;
      }
    }
#line 1045
    goto switch_break;
    case_122: 
    {
#line 1048
    psf_log_printf(psf, "Format conversion \'z\' not implemented yet.\n");
    }
#line 1057
    goto switch_break;
    case_112: 
    {
#line 1061
    count___0 = 0;
#line 1062
    header_seek(psf, (sf_count_t )count___0, 0);
#line 1063
    byte_count = count___0;
    }
#line 1064
    goto switch_break;
    case_106: 
#line 1068
    count___0 = 0;
#line 1069
    if (count___0) {
      {
#line 1070
      header_seek(psf, (sf_count_t )count___0, 1);
#line 1071
      byte_count += count___0;
      }
    }
#line 1073
    goto switch_break;
    switch_default: 
    {
#line 1076
    psf_log_printf(psf, "*** Invalid format specifier `%c\'\n", (int )c);
#line 1077
    psf->error = 30;
    }
#line 1078
    goto switch_break;
    switch_break: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1082
  __builtin_va_end((__builtin_va_list )((void *)argptr));
  }
#line 1084
  return (byte_count);
}
}
#line 1091 "/root/patchweave_donee/23/src/common.c"
sf_count_t psf_default_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t samples_from_start ) 
{ 
  sf_count_t position ;
  sf_count_t retval ;

  {
#line 1094
  if (psf->blockwidth) {
#line 1094
    if (! (psf->dataoffset >= 0L)) {
#line 1095
      psf->error = 39;
#line 1096
      return ((sf_count_t )-1);
    }
  } else {
#line 1095
    psf->error = 39;
#line 1096
    return ((sf_count_t )-1);
  }
#line 1099
  if (! psf->sf.seekable) {
#line 1100
    psf->error = 40;
#line 1101
    return ((sf_count_t )-1);
  }
  {
#line 1104
  position = psf->dataoffset + (long )psf->blockwidth * samples_from_start;
#line 1106
  retval = psf_fseek(psf, position, 0);
  }
#line 1106
  if (retval != position) {
#line 1107
    psf->error = 43;
#line 1108
    return ((sf_count_t )-1);
  }
#line 1111
  return (samples_from_start);
}
}
#line 1118 "/root/patchweave_donee/23/src/common.c"
void psf_hexdump(void const   *ptr , int len ) 
{ 
  char const   *data ;
  char ascii[17] ;
  int k ;
  int m ;
  char const   *tmp ;
  int __cil_tmp8 ;
  int tmp___0 ;

  {
#line 1123
  data = (char const   *)ptr;
#line 1123
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1124
    return;
  }
#line 1125
  if (len <= 0) {
#line 1126
    return;
  }
  {
#line 1128
  puts("\021");
#line 1129
  k = 0;
  }
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1129
    if (! (k < len)) {
#line 1129
      goto while_break;
    }
    {
#line 1130
    memset((void *)(ascii), ' ', sizeof(ascii));
#line 1132
    printf("%08X: ", k);
#line 1133
    m = 0;
    }
    {
#line 1133
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1133
      if (m < 16) {
#line 1133
        if (! (k + m < len)) {
#line 1133
          goto while_break___0;
        }
      } else {
#line 1133
        goto while_break___0;
      }
#line 1134
      if (m == 8) {
#line 1134
        tmp = " %02X ";
      } else {
#line 1134
        tmp = "%02X ";
      }
      {
#line 1134
      printf(tmp, (int )*(data + (k + m)) & 255);
#line 1135
      __cil_tmp8 = psf_isprint((int )*(data + (k + m)));
      }
#line 1135
      if (__cil_tmp8) {
#line 1135
        tmp___0 = (int )*(data + (k + m));
      } else {
#line 1135
        tmp___0 = '.';
      }
#line 1135
      ascii[m] = (char )tmp___0;
#line 1133
      m ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 1138
    if (m <= 8) {
      {
#line 1138
      printf(" \226\327\323\204U");
      }
    }
    {
#line 1139
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1139
      if (! (m < 16)) {
#line 1139
        goto while_break___1;
      }
      {
#line 1139
      printf("   ");
#line 1139
      m ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 1141
    ascii[16] = (char)0;
#line 1142
    printf(" %s\n", ascii);
#line 1129
    k += 16;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1145
  puts("\220");
  }
#line 1147
  return;
}
}
#line 1149 "/root/patchweave_donee/23/src/common.c"
void psf_log_SF_INFO(SF_PRIVATE *psf ) 
{ 
  char const   *tmp ;

  {
  {
#line 1150
  psf_log_printf(psf, "---------------------------------\n");
#line 1152
  psf_log_printf(psf, " Sample rate :   %d\n", psf->sf.samplerate);
  }
#line 1153
  if ((long long )psf->sf.frames == -1LL) {
    {
#line 1154
    psf_log_printf(psf, " Frames      :   unknown\n");
    }
  } else {
    {
#line 1156
    psf_log_printf(psf, " Frames      :   %D\n\204U", psf->sf.frames);
    }
  }
  {
#line 1157
  psf_log_printf(psf, " Channels    :   %d\n\204U", psf->sf.channels);
#line 1159
  psf_log_printf(psf, " Format      :   0x%X\n", psf->sf.format);
#line 1160
  psf_log_printf(psf, " Sections    :   %d\n\204U", psf->sf.sections);
  }
#line 1161
  if (psf->sf.seekable) {
#line 1161
    tmp = "TRUE";
  } else {
#line 1161
    tmp = "FALSE";
  }
  {
#line 1161
  psf_log_printf(psf, " Seekable    :   %s\n\204U", tmp);
#line 1163
  psf_log_printf(psf, "---------------------------------\n\327\323\204U");
  }
#line 1165
  return;
}
}
#line 1170 "/root/patchweave_donee/23/src/common.c"
void *psf_memset(void *s , int c , sf_count_t len ) 
{ 
  char *ptr ;
  int setcount ;
  int tmp ;

  {
#line 1174
  ptr = (char *)s;
  {
#line 1176
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1176
    if (! (len > 0L)) {
#line 1176
      goto while_break;
    }
#line 1177
    if (len > 268435456L) {
#line 1177
      tmp = 268435456;
    } else {
#line 1177
      tmp = (int )len;
    }
    {
#line 1177
    setcount = tmp;
#line 1179
    memset((void *)ptr, c, (unsigned long )setcount);
#line 1181
    ptr += setcount;
#line 1182
    len -= (long )setcount;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1185
  return (s);
}
}
#line 1189 "/root/patchweave_donee/23/src/common.c"
SF_INSTRUMENT *psf_instrument_alloc(void) 
{ 
  SF_INSTRUMENT *instr ;
  void *tmp ;

  {
  {
#line 1192
  tmp = calloc(1UL, sizeof(SF_INSTRUMENT ));
#line 1192
  instr = (SF_INSTRUMENT *)tmp;
  }
#line 1194
  if ((unsigned long )instr == (unsigned long )((void *)0)) {
#line 1195
    return ((SF_INSTRUMENT *)((void *)0));
  }
#line 1198
  instr->basenote = (char)-1;
#line 1199
  instr->velocity_lo = (char)-1;
#line 1200
  instr->velocity_hi = (char)-1;
#line 1201
  instr->key_lo = (char)-1;
#line 1202
  instr->key_hi = (char)-1;
#line 1204
  return (instr);
}
}
#line 1208 "/root/patchweave_donee/23/src/common.c"
void psf_sanitize_string(char *cptr , int len ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int tmp ;

  {
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1212
    __cil_tmp3 = len;
#line 1212
    len --;
#line 1213
    __cil_tmp4 = psf_isprint((int )*(cptr + len));
    }
#line 1213
    if (__cil_tmp4) {
#line 1213
      tmp = (int )*(cptr + len);
    } else {
#line 1213
      tmp = '.';
    }
#line 1213
    *(cptr + len) = (char )tmp;
#line 1210
    if (! (len > 0)) {
#line 1210
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1215
  return;
}
}
#line 1219 "/root/patchweave_donee/23/src/common.c"
void psf_get_date_str(char *str , int maxlen ) 
{ 
  time_t current ;
  struct tm timedata ;
  struct tm *tmptr ;

  {
  {
#line 1223
  time(& current);
#line 1227
  tmptr = gmtime_r(& current, & timedata);
  }
#line 1236
  if (tmptr) {
    {
#line 1237
    snprintf(str, (unsigned long )maxlen, "%4d-%02d-%02d %02d:%02d:%02d UTC\251",
             1900 + timedata.tm_year, timedata.tm_mon, timedata.tm_mday, timedata.tm_hour,
             timedata.tm_min, timedata.tm_sec);
    }
  } else {
    {
#line 1241
    snprintf(str, (unsigned long )maxlen, "Unknown date\204U");
    }
  }
#line 1243
  return;
}
}
#line 1247 "/root/patchweave_donee/23/src/common.c"
int subformat_to_bytewidth(int format ) 
{ 


  {
#line 1251
  if (format == 1) {
#line 1251
    goto case_1;
  }
#line 1251
  if (format == 5) {
#line 1251
    goto case_1;
  }
#line 1253
  if (format == 2) {
#line 1253
    goto case_2;
  }
#line 1255
  if (format == 3) {
#line 1255
    goto case_3;
  }
#line 1258
  if (format == 6) {
#line 1258
    goto case_6;
  }
#line 1258
  if (format == 4) {
#line 1258
    goto case_6;
  }
#line 1260
  if (format == 7) {
#line 1260
    goto case_7;
  }
#line 1249
  goto switch_break;
  case_1: 
#line 1252
  return (1);
  case_2: 
#line 1254
  return (2);
  case_3: 
#line 1256
  return (3);
  case_6: 
#line 1259
  return (4);
  case_7: 
#line 1261
  return (8);
  switch_break: ;
#line 1264
  return (0);
}
}
#line 1270 "/root/patchweave_donee/23/src/common.c"
static int array[4]  ;
#line 1268 "/root/patchweave_donee/23/src/common.c"
int s_bitwidth_to_subformat(int bits ) 
{ 


  {
#line 1269
  array[0] = 1;
#line 1269
  array[1] = 2;
#line 1269
  array[2] = 3;
#line 1269
  array[3] = 4;
#line 1273
  if (bits < 8) {
#line 1274
    return (0);
  } else
#line 1273
  if (bits > 32) {
#line 1274
    return (0);
  }
#line 1276
  return (array[(bits + 7) / 8 - 1]);
}
}
#line 1282 "/root/patchweave_donee/23/src/common.c"
static int array___0[4]  ;
#line 1280 "/root/patchweave_donee/23/src/common.c"
int u_bitwidth_to_subformat(int bits ) 
{ 


  {
#line 1281
  array___0[0] = 5;
#line 1281
  array___0[1] = 2;
#line 1281
  array___0[2] = 3;
#line 1281
  array___0[3] = 4;
#line 1285
  if (bits < 8) {
#line 1286
    return (0);
  } else
#line 1285
  if (bits > 32) {
#line 1286
    return (0);
  }
#line 1288
  return (array___0[(bits + 7) / 8 - 1]);
}
}
#line 1300 "/root/patchweave_donee/23/src/common.c"
static uint64_t value  ;
#line 1298 "/root/patchweave_donee/23/src/common.c"
int32_t psf_rand_int32(void) 
{ 
  int k ;
  int count___0 ;
  struct timeval tv ;

  {
#line 1299
  value = (uint64_t )0;
#line 1302
  if (value == 0UL) {
    {
#line 1306
    gettimeofday(& tv, (void *)0);
#line 1307
    value = (uint64_t )(tv.tv_sec + tv.tv_usec);
    }
  }
#line 1313
  count___0 = (int )(4UL + (value & 7UL));
#line 1314
  k = 0;
  {
#line 1314
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1314
    if (! (k < count___0)) {
#line 1314
      goto while_break;
    }
#line 1315
    value = (11117UL * value + 211231UL) & 2147483647UL;
#line 1314
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1317
  return ((int32_t )value);
}
}
#line 1321 "/root/patchweave_donee/23/src/common.c"
void append_snprintf(char *dest , size_t maxlen , char const   *fmt  , ...) 
{ 
  size_t len ;
  unsigned long __cil_tmp5 ;
  va_list ap ;

  {
  {
#line 1322
  __cil_tmp5 = strlen((char const   *)dest);
#line 1322
  len = __cil_tmp5;
  }
#line 1324
  if (len < maxlen) {
    {
#line 1327
    __builtin_va_start((__builtin_va_list )((void *)ap), fmt);
#line 1328
    vsnprintf(dest + len, maxlen - len, fmt, (__gnuc_va_list )((void *)ap));
#line 1329
    __builtin_va_end((__builtin_va_list )((void *)ap));
    }
  }
#line 1332
  return;
}
}
#line 1337 "/root/patchweave_donee/23/src/common.c"
void psf_strlcpy_crlf(char *dest , char const   *src , size_t destmax , size_t srcmax ) 
{ 
  char *destend ;
  char const   *srcend ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char const   *__cil_tmp14 ;

  {
#line 1339
  destend = (dest + destmax) - 2;
#line 1340
  srcend = src + srcmax;
  {
#line 1342
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1342
    if ((unsigned long )dest < (unsigned long )destend) {
#line 1342
      if (! ((unsigned long )src < (unsigned long )srcend)) {
#line 1342
        goto while_break;
      }
    } else {
#line 1342
      goto while_break;
    }
#line 1343
    if ((int )*(src + 0) == 13) {
#line 1343
      if ((int )*(src + 1) == 10) {
        _L: 
#line 1344
        __cil_tmp7 = dest;
#line 1344
        dest ++;
#line 1344
        *__cil_tmp7 = (char )'\r';
#line 1345
        __cil_tmp8 = dest;
#line 1345
        dest ++;
#line 1345
        *__cil_tmp8 = (char )'\n';
#line 1346
        src += 2;
#line 1347
        goto while_continue;
      } else {
#line 1343
        goto _L___7;
      }
    } else
    _L___7: 
#line 1343
    if ((int )*(src + 0) == 10) {
#line 1343
      if ((int )*(src + 1) == 13) {
#line 1343
        goto _L;
      }
    }
#line 1350
    if ((int )*(src + 0) == 13) {
#line 1351
      __cil_tmp9 = dest;
#line 1351
      dest ++;
#line 1351
      *__cil_tmp9 = (char )'\r';
#line 1352
      __cil_tmp10 = dest;
#line 1352
      dest ++;
#line 1352
      *__cil_tmp10 = (char )'\n';
#line 1353
      src ++;
#line 1354
      goto while_continue;
    }
#line 1357
    if ((int )*(src + 0) == 10) {
#line 1358
      __cil_tmp11 = dest;
#line 1358
      dest ++;
#line 1358
      *__cil_tmp11 = (char )'\r';
#line 1359
      __cil_tmp12 = dest;
#line 1359
      dest ++;
#line 1359
      *__cil_tmp12 = (char )'\n';
#line 1360
      src ++;
#line 1361
      goto while_continue;
    }
#line 1364
    __cil_tmp14 = src;
#line 1364
    src ++;
#line 1364
    __cil_tmp13 = dest;
#line 1364
    dest ++;
#line 1364
    *__cil_tmp13 = (char )*__cil_tmp14;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1368
  *dest = (char)0;
#line 1369
  return;
}
}
#line 1372 "/root/patchweave_donee/23/src/common.c"
sf_count_t psf_decode_frame_count(SF_PRIVATE *psf ) 
{ 
  sf_count_t count___0 ;
  sf_count_t readlen ;
  sf_count_t total ;
  BUF_UNION ubuf ;
  int __cil_tmp6 ;

  {
  {
#line 1373
  total = (sf_count_t )0;
#line 1377
  __cil_tmp6 = psf_is_pipe(psf);
  }
#line 1377
  if (__cil_tmp6) {
#line 1378
    return ((sf_count_t )-1LL);
  } else
#line 1377
  if (psf->datalength > 16777216L) {
#line 1378
    return ((sf_count_t )-1LL);
  }
  {
#line 1380
  psf_fseek(psf, psf->dataoffset, 0);
#line 1382
  readlen = (sf_count_t )((int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0])) / psf->sf.channels);
#line 1383
  readlen *= (long )psf->sf.channels;
  }
  {
#line 1385
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1385
    count___0 = (*(psf->read_int))(psf, ubuf.ibuf, readlen);
    }
#line 1385
    if (! (count___0 > 0L)) {
#line 1385
      goto while_break;
    }
#line 1386
    total += count___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1388
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 1390
  return (total / (long )psf->sf.channels);
}
}
#line 1399 "/root/patchweave_donee/23/src/common.c"
char const   *str_of_major_format(int format ) 
{ 


  {
#line 1401
  if ((format & 268369920) == 65536) {
#line 1401
    goto case_65536;
  }
#line 1402
  if ((format & 268369920) == 131072) {
#line 1402
    goto case_131072;
  }
#line 1403
  if ((format & 268369920) == 196608) {
#line 1403
    goto case_196608;
  }
#line 1404
  if ((format & 268369920) == 262144) {
#line 1404
    goto case_262144;
  }
#line 1405
  if ((format & 268369920) == 327680) {
#line 1405
    goto case_327680;
  }
#line 1406
  if ((format & 268369920) == 393216) {
#line 1406
    goto case_393216;
  }
#line 1407
  if ((format & 268369920) == 458752) {
#line 1407
    goto case_458752;
  }
#line 1408
  if ((format & 268369920) == 524288) {
#line 1408
    goto case_524288;
  }
#line 1409
  if ((format & 268369920) == 655360) {
#line 1409
    goto case_655360;
  }
#line 1410
  if ((format & 268369920) == 720896) {
#line 1410
    goto case_720896;
  }
#line 1411
  if ((format & 268369920) == 786432) {
#line 1411
    goto case_786432;
  }
#line 1412
  if ((format & 268369920) == 851968) {
#line 1412
    goto case_851968;
  }
#line 1413
  if ((format & 268369920) == 917504) {
#line 1413
    goto case_917504;
  }
#line 1414
  if ((format & 268369920) == 983040) {
#line 1414
    goto case_983040;
  }
#line 1415
  if ((format & 268369920) == 1048576) {
#line 1415
    goto case_1048576;
  }
#line 1416
  if ((format & 268369920) == 1114112) {
#line 1416
    goto case_1114112;
  }
#line 1417
  if ((format & 268369920) == 1179648) {
#line 1417
    goto case_1179648;
  }
#line 1418
  if ((format & 268369920) == 1245184) {
#line 1418
    goto case_1245184;
  }
#line 1419
  if ((format & 268369920) == 1441792) {
#line 1419
    goto case_1441792;
  }
#line 1420
  if ((format & 268369920) == 1507328) {
#line 1420
    goto case_1507328;
  }
#line 1421
  if ((format & 268369920) == 1572864) {
#line 1421
    goto case_1572864;
  }
#line 1422
  if ((format & 268369920) == 1638400) {
#line 1422
    goto case_1638400;
  }
#line 1423
  if ((format & 268369920) == 2097152) {
#line 1423
    goto case_2097152;
  }
#line 1424
  goto switch_default;
  case_65536: 
#line 1401
  return ("SF_FORMAT_WAV");
#line 1401
  goto switch_break;
  case_131072: 
#line 1402
  return ("SF_FORMAT_AIFF");
#line 1402
  goto switch_break;
  case_196608: 
#line 1403
  return ("SF_FORMAT_AU");
#line 1403
  goto switch_break;
  case_262144: 
#line 1404
  return ("SF_FORMAT_RAW");
#line 1404
  goto switch_break;
  case_327680: 
#line 1405
  return ("SF_FORMAT_PAF");
#line 1405
  goto switch_break;
  case_393216: 
#line 1406
  return ("SF_FORMAT_SVX");
#line 1406
  goto switch_break;
  case_458752: 
#line 1407
  return ("SF_FORMAT_NIST");
#line 1407
  goto switch_break;
  case_524288: 
#line 1408
  return ("SF_FORMAT_VOC");
#line 1408
  goto switch_break;
  case_655360: 
#line 1409
  return ("SF_FORMAT_IRCAM");
#line 1409
  goto switch_break;
  case_720896: 
#line 1410
  return ("SF_FORMAT_W64");
#line 1410
  goto switch_break;
  case_786432: 
#line 1411
  return ("SF_FORMAT_MAT4");
#line 1411
  goto switch_break;
  case_851968: 
#line 1412
  return ("SF_FORMAT_MAT5");
#line 1412
  goto switch_break;
  case_917504: 
#line 1413
  return ("SF_FORMAT_PVF");
#line 1413
  goto switch_break;
  case_983040: 
#line 1414
  return ("SF_FORMAT_XI");
#line 1414
  goto switch_break;
  case_1048576: 
#line 1415
  return ("SF_FORMAT_HTKU");
#line 1415
  goto switch_break;
  case_1114112: 
#line 1416
  return ("SF_FORMAT_SDS");
#line 1416
  goto switch_break;
  case_1179648: 
#line 1417
  return ("SF_FORMAT_AVR");
#line 1417
  goto switch_break;
  case_1245184: 
#line 1418
  return ("SF_FORMAT_WAVEX");
#line 1418
  goto switch_break;
  case_1441792: 
#line 1419
  return ("SF_FORMAT_SD2");
#line 1419
  goto switch_break;
  case_1507328: 
#line 1420
  return ("SF_FORMAT_FLAC");
#line 1420
  goto switch_break;
  case_1572864: 
#line 1421
  return ("SF_FORMAT_CAF");
#line 1421
  goto switch_break;
  case_1638400: 
#line 1422
  return ("SF_FORMAT_WVE");
#line 1422
  goto switch_break;
  case_2097152: 
#line 1423
  return ("SF_FORMAT_OGG");
#line 1423
  goto switch_break;
  switch_default: 
#line 1425
  goto switch_break;
  switch_break: ;
#line 1428
  return ("BAD_MAJOR_FORMAT\220");
}
}
#line 1432 "/root/patchweave_donee/23/src/common.c"
char const   *str_of_minor_format(int format ) 
{ 


  {
#line 1434
  if ((format & 65535) == 1) {
#line 1434
    goto case_1;
  }
#line 1435
  if ((format & 65535) == 2) {
#line 1435
    goto case_2;
  }
#line 1436
  if ((format & 65535) == 3) {
#line 1436
    goto case_3;
  }
#line 1437
  if ((format & 65535) == 4) {
#line 1437
    goto case_4;
  }
#line 1438
  if ((format & 65535) == 5) {
#line 1438
    goto case_5;
  }
#line 1439
  if ((format & 65535) == 6) {
#line 1439
    goto case_6;
  }
#line 1440
  if ((format & 65535) == 7) {
#line 1440
    goto case_7;
  }
#line 1441
  if ((format & 65535) == 16) {
#line 1441
    goto case_16;
  }
#line 1442
  if ((format & 65535) == 17) {
#line 1442
    goto case_17;
  }
#line 1443
  if ((format & 65535) == 18) {
#line 1443
    goto case_18;
  }
#line 1444
  if ((format & 65535) == 19) {
#line 1444
    goto case_19;
  }
#line 1445
  if ((format & 65535) == 32) {
#line 1445
    goto case_32;
  }
#line 1446
  if ((format & 65535) == 33) {
#line 1446
    goto case_33;
  }
#line 1447
  if ((format & 65535) == 48) {
#line 1447
    goto case_48;
  }
#line 1448
  if ((format & 65535) == 49) {
#line 1448
    goto case_49;
  }
#line 1449
  if ((format & 65535) == 50) {
#line 1449
    goto case_50;
  }
#line 1450
  if ((format & 65535) == 64) {
#line 1450
    goto case_64;
  }
#line 1451
  if ((format & 65535) == 65) {
#line 1451
    goto case_65;
  }
#line 1452
  if ((format & 65535) == 66) {
#line 1452
    goto case_66;
  }
#line 1453
  if ((format & 65535) == 67) {
#line 1453
    goto case_67;
  }
#line 1454
  if ((format & 65535) == 80) {
#line 1454
    goto case_80;
  }
#line 1455
  if ((format & 65535) == 81) {
#line 1455
    goto case_81;
  }
#line 1456
  if ((format & 65535) == 96) {
#line 1456
    goto case_96;
  }
#line 1457
  goto switch_default;
  case_1: 
#line 1434
  return ("SF_FORMAT_PCM_S8\220");
#line 1434
  goto switch_break;
  case_2: 
#line 1435
  return ("SF_FORMAT_PCM_16\220");
#line 1435
  goto switch_break;
  case_3: 
#line 1436
  return ("SF_FORMAT_PCM_24\220");
#line 1436
  goto switch_break;
  case_4: 
#line 1437
  return ("SF_FORMAT_PCM_32\220");
#line 1437
  goto switch_break;
  case_5: 
#line 1438
  return ("SF_FORMAT_PCM_U8\220");
#line 1438
  goto switch_break;
  case_6: 
#line 1439
  return ("SF_FORMAT_FLOAT");
#line 1439
  goto switch_break;
  case_7: 
#line 1440
  return ("SF_FORMAT_DOUBLE\220");
#line 1440
  goto switch_break;
  case_16: 
#line 1441
  return ("SF_FORMAT_ULAW");
#line 1441
  goto switch_break;
  case_17: 
#line 1442
  return ("SF_FORMAT_ALAW");
#line 1442
  goto switch_break;
  case_18: 
#line 1443
  return ("SF_FORMAT_IMA_ADPCM");
#line 1443
  goto switch_break;
  case_19: 
#line 1444
  return ("SF_FORMAT_MS_ADPCM");
#line 1444
  goto switch_break;
  case_32: 
#line 1445
  return ("SF_FORMAT_GSM610\220");
#line 1445
  goto switch_break;
  case_33: 
#line 1446
  return ("SF_FORMAT_VOX_ADPCM");
#line 1446
  goto switch_break;
  case_48: 
#line 1447
  return ("SF_FORMAT_G721_32");
#line 1447
  goto switch_break;
  case_49: 
#line 1448
  return ("SF_FORMAT_G723_24");
#line 1448
  goto switch_break;
  case_50: 
#line 1449
  return ("SF_FORMAT_G723_40");
#line 1449
  goto switch_break;
  case_64: 
#line 1450
  return ("SF_FORMAT_DWVW_12");
#line 1450
  goto switch_break;
  case_65: 
#line 1451
  return ("SF_FORMAT_DWVW_16");
#line 1451
  goto switch_break;
  case_66: 
#line 1452
  return ("SF_FORMAT_DWVW_24");
#line 1452
  goto switch_break;
  case_67: 
#line 1453
  return ("SF_FORMAT_DWVW_N\220");
#line 1453
  goto switch_break;
  case_80: 
#line 1454
  return ("SF_FORMAT_DPCM_8\220");
#line 1454
  goto switch_break;
  case_81: 
#line 1455
  return ("SF_FORMAT_DPCM_16");
#line 1455
  goto switch_break;
  case_96: 
#line 1456
  return ("SF_FORMAT_VORBIS\220");
#line 1456
  goto switch_break;
  switch_default: 
#line 1458
  goto switch_break;
  switch_break: ;
#line 1461
  return ("BAD_MINOR_FORMAT\220");
}
}
#line 1465 "/root/patchweave_donee/23/src/common.c"
char const   *str_of_open_mode(int mode ) 
{ 


  {
#line 1467
  if (mode == 16) {
#line 1467
    goto case_16;
  }
#line 1468
  if (mode == 32) {
#line 1468
    goto case_32;
  }
#line 1469
  if (mode == 48) {
#line 1469
    goto case_48;
  }
#line 1471
  goto switch_default;
  case_16: 
#line 1467
  return ("SFM_READ\220");
#line 1467
  goto switch_break;
  case_32: 
#line 1468
  return ("SFM_WRITE");
#line 1468
  goto switch_break;
  case_48: 
#line 1469
  return ("SFM_RDWR\220");
#line 1469
  goto switch_break;
  switch_default: 
#line 1472
  goto switch_break;
  switch_break: ;
#line 1475
  return ("BAD_MODE\220");
}
}
#line 1479 "/root/patchweave_donee/23/src/common.c"
char const   *str_of_endianness(int end ) 
{ 


  {
#line 1481
  if (end == 536870912) {
#line 1481
    goto case_536870912;
  }
#line 1482
  if (end == 268435456) {
#line 1482
    goto case_268435456;
  }
#line 1483
  if (end == 805306368) {
#line 1483
    goto case_805306368;
  }
#line 1484
  goto switch_default;
  case_536870912: 
#line 1481
  return ("SF_ENDIAN_BIG");
#line 1481
  goto switch_break;
  case_268435456: 
#line 1482
  return ("SF_ENDIAN_LITTLE\220");
#line 1482
  goto switch_break;
  case_805306368: 
#line 1483
  return ("SF_ENDIAN_CPU");
#line 1483
  goto switch_break;
  switch_default: 
#line 1485
  goto switch_break;
  switch_break: ;
#line 1489
  return ("\220");
}
}
#line 1496 "/root/patchweave_donee/23/src/common.c"
void psf_f2s_array(float const   *src , short *dest , int count___0 , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1499
  if (normalize) {
#line 1499
    tmp = 1. * (double )32767;
  } else {
#line 1499
    tmp = 1.;
  }
#line 1499
  normfact = (float )tmp;
  {
#line 1500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1500
    count___0 --;
#line 1500
    if (! (count___0 >= 0)) {
#line 1500
      goto while_break;
    }
    {
#line 1501
    __cil_tmp7 = lrintf((float )(*(src + count___0) * (float const   )normfact));
#line 1501
    *(dest + count___0) = (short )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1503
  return;
}
}
#line 1507 "/root/patchweave_donee/23/src/common.c"
void psf_f2s_clip_array(float const   *src , short *dest , int count___0 , int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1510
  if (normalize) {
#line 1510
    tmp = 1. * (double )32768;
  } else {
#line 1510
    tmp = 1.;
  }
#line 1510
  normfact = (float )tmp;
  {
#line 1512
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1512
    count___0 --;
#line 1512
    if (! (count___0 >= 0)) {
#line 1512
      goto while_break;
    }
#line 1513
    scaled_value = (float )(*(src + count___0) * (float const   )normfact);
#line 1514
    if ((double )scaled_value >= 1. * (double )32767) {
#line 1515
      *(dest + count___0) = (short)32767;
#line 1516
      goto while_continue;
    }
#line 1518
    if ((double )scaled_value <= - 8. * (double )4096) {
#line 1519
      *(dest + count___0) = (short)-32768;
#line 1520
      goto while_continue;
    }
    {
#line 1523
    __cil_tmp8 = lrintf(scaled_value);
#line 1523
    *(dest + count___0) = (short )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1526
  return;
}
}
#line 1530 "/root/patchweave_donee/23/src/common.c"
void psf_d2s_array(double const   *src , short *dest , int count___0 , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1533
  if (normalize) {
#line 1533
    tmp = 1. * (double )32767;
  } else {
#line 1533
    tmp = 1.;
  }
#line 1533
  normfact = tmp;
  {
#line 1534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1534
    count___0 --;
#line 1534
    if (! (count___0 >= 0)) {
#line 1534
      goto while_break;
    }
    {
#line 1535
    __cil_tmp7 = lrint((double )(*(src + count___0) * (double const   )normfact));
#line 1535
    *(dest + count___0) = (short )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1537
  return;
}
}
#line 1541 "/root/patchweave_donee/23/src/common.c"
void psf_d2s_clip_array(double const   *src , short *dest , int count___0 , int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1544
  if (normalize) {
#line 1544
    tmp = 1. * (double )32768;
  } else {
#line 1544
    tmp = 1.;
  }
#line 1544
  normfact = tmp;
  {
#line 1546
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1546
    count___0 --;
#line 1546
    if (! (count___0 >= 0)) {
#line 1546
      goto while_break;
    }
#line 1547
    scaled_value = (double )(*(src + count___0) * (double const   )normfact);
#line 1548
    if (scaled_value >= 1. * (double )32767) {
#line 1549
      *(dest + count___0) = (short)32767;
#line 1550
      goto while_continue;
    }
#line 1552
    if (scaled_value <= - 8. * (double )4096) {
#line 1553
      *(dest + count___0) = (short)-32768;
#line 1554
      goto while_continue;
    }
    {
#line 1557
    __cil_tmp8 = lrint(scaled_value);
#line 1557
    *(dest + count___0) = (short )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1560
  return;
}
}
#line 1565 "/root/patchweave_donee/23/src/common.c"
void psf_f2i_array(float const   *src , int *dest , int count___0 , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1568
  if (normalize) {
#line 1568
    tmp = 1. * (double )2147483647;
  } else {
#line 1568
    tmp = 1.;
  }
#line 1568
  normfact = (float )tmp;
  {
#line 1569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1569
    count___0 --;
#line 1569
    if (! (count___0 >= 0)) {
#line 1569
      goto while_break;
    }
    {
#line 1570
    __cil_tmp7 = lrintf((float )(*(src + count___0) * (float const   )normfact));
#line 1570
    *(dest + count___0) = (int )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1572
  return;
}
}
#line 1576 "/root/patchweave_donee/23/src/common.c"
void psf_f2i_clip_array(float const   *src , int *dest , int count___0 , int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1579
  if (normalize) {
#line 1579
    tmp = 8. * (double )268435456;
  } else {
#line 1579
    tmp = 1.;
  }
#line 1579
  normfact = (float )tmp;
  {
#line 1581
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1581
    count___0 --;
#line 1581
    if (! (count___0 >= 0)) {
#line 1581
      goto while_break;
    }
#line 1582
    scaled_value = (float )(*(src + count___0) * (float const   )normfact);
#line 1583
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1584
      *(dest + count___0) = 2147483647;
#line 1585
      goto while_continue;
    }
#line 1587
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1588
      *(dest + count___0) = (-0x7FFFFFFF-1);
#line 1589
      goto while_continue;
    }
    {
#line 1592
    __cil_tmp8 = lrintf(scaled_value);
#line 1592
    *(dest + count___0) = (int )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1595
  return;
}
}
#line 1599 "/root/patchweave_donee/23/src/common.c"
void psf_d2i_array(double const   *src , int *dest , int count___0 , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1602
  if (normalize) {
#line 1602
    tmp = 1. * (double )2147483647;
  } else {
#line 1602
    tmp = 1.;
  }
#line 1602
  normfact = tmp;
  {
#line 1603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1603
    count___0 --;
#line 1603
    if (! (count___0 >= 0)) {
#line 1603
      goto while_break;
    }
    {
#line 1604
    __cil_tmp7 = lrint((double )(*(src + count___0) * (double const   )normfact));
#line 1604
    *(dest + count___0) = (int )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1606
  return;
}
}
#line 1610 "/root/patchweave_donee/23/src/common.c"
void psf_d2i_clip_array(double const   *src , int *dest , int count___0 , int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1613
  if (normalize) {
#line 1613
    tmp = 8. * (double )268435456;
  } else {
#line 1613
    tmp = 1.;
  }
#line 1613
  normfact = tmp;
  {
#line 1615
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1615
    count___0 --;
#line 1615
    if (! (count___0 >= 0)) {
#line 1615
      goto while_break;
    }
#line 1616
    scaled_value = (double )(*(src + count___0) * (double const   )normfact);
#line 1617
    if (scaled_value >= 1. * (double )2147483647) {
#line 1618
      *(dest + count___0) = 2147483647;
#line 1619
      goto while_continue;
    }
#line 1621
    if (scaled_value <= - 8. * (double )268435456) {
#line 1622
      *(dest + count___0) = (-0x7FFFFFFF-1);
#line 1623
      goto while_continue;
    }
    {
#line 1626
    __cil_tmp8 = lrint(scaled_value);
#line 1626
    *(dest + count___0) = (int )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1629
  return;
}
}
#line 1633 "/root/patchweave_donee/23/src/common.c"
FILE *psf_open_tmpfile(char *fname , size_t fnamelen ) 
{ 
  char const   *tmpdir ;
  FILE *file ;
  char *__cil_tmp6 ;
  char const   *tmp ;
  int __cil_tmp8 ;
  int32_t __cil_tmp9 ;
  int32_t __cil_tmp10 ;
  int32_t __cil_tmp12 ;
  int32_t __cil_tmp13 ;

  {
  {
#line 1640
  __cil_tmp6 = getenv("TMPDIR");
#line 1640
  tmpdir = (char const   *)__cil_tmp6;
  }
#line 1641
  if ((unsigned long )tmpdir == (unsigned long )((void *)0)) {
#line 1641
    tmp = "/tmp";
  } else {
#line 1641
    tmp = tmpdir;
  }
  {
#line 1641
  tmpdir = tmp;
#line 1644
  __cil_tmp8 = access(tmpdir, 7);
  }
#line 1644
  if (tmpdir) {
#line 1644
    if (__cil_tmp8 == 0) {
      {
#line 1645
      __cil_tmp9 = psf_rand_int32();
#line 1645
      __cil_tmp10 = psf_rand_int32();
#line 1645
      snprintf(fname, fnamelen, "%s/%x%x-alac.tmp\230\001", tmpdir, __cil_tmp9, __cil_tmp10);
#line 1646
      file = fopen((char const   *)fname, "wb+");
      }
#line 1646
      if ((unsigned long )file != (unsigned long )((void *)0)) {
#line 1647
        return (file);
      }
    }
  }
  {
#line 1650
  __cil_tmp12 = psf_rand_int32();
#line 1650
  __cil_tmp13 = psf_rand_int32();
#line 1650
  snprintf(fname, fnamelen, "%x%x-alac.tmp", __cil_tmp12, __cil_tmp13);
#line 1651
  file = fopen((char const   *)fname, "wb+\377");
  }
#line 1651
  if ((unsigned long )file != (unsigned long )((void *)0)) {
#line 1652
    return (file);
  }
  {
#line 1654
  memset((void *)fname, 0, fnamelen);
  }
#line 1655
  return ((FILE *)((void *)0));
}
}
#line 28 "/root/patchweave_donee/23/src/command.c"
static SF_FORMAT_INFO simple_formats[15]  = 
#line 28 "/root/patchweave_donee/23/src/command.c"
  {      {131074, "AIFF (Apple/SGI 16 bit PCM)", "aiff"}, 
        {131078, "AIFF (Apple/SGI 32 bit float)", "aifc"}, 
        {131073, "AIFF (Apple/SGI 8 bit PCM)", "aiff"}, 
        {196610, "AU (Sun/Next 16 bit PCM)", "au"}, 
        {196624, "AU (Sun/Next 8-bit u-law)", "au"}, 
        {1572976, "CAF (Apple 16 bit ALAC)", "caf"}, 
        {1572866, "CAF (Apple 16 bit PCM)", "caf"}, 
        {1507330, "FLAC 16 bit\323\204U", "flac"}, 
        {262177, "OKI Dialogic VOX ADPCM", "vox"}, 
        {2097248, "Ogg Vorbis (Xiph Foundation)", "oga"}, 
        {65538, "WAV (Microsoft 16 bit PCM)", "wav"}, 
        {65542, "WAV (Microsoft 32 bit float)", "wav"}, 
        {65554, "WAV (Microsoft 4 bit IMA ADPCM)", "wav"}, 
        {65555, "WAV (Microsoft 4 bit MS ADPCM)", "wav"}, 
        {65541, "WAV (Microsoft 8 bit PCM)", "wav"}};
#line 97 "/root/patchweave_donee/23/src/command.c"
int psf_get_format_simple_count(void) 
{ 


  {
#line 98
  return ((int )(sizeof(simple_formats) / sizeof(SF_FORMAT_INFO )));
}
}
#line 102 "/root/patchweave_donee/23/src/command.c"
int psf_get_format_simple(SF_FORMAT_INFO *data ) 
{ 
  int indx ;

  {
#line 105
  if (data->format < 0) {
#line 106
    return (31);
  } else
#line 105
  if (data->format >= (int )sizeof(simple_formats) / (int )sizeof(SF_FORMAT_INFO )) {
#line 106
    return (31);
  }
  {
#line 108
  indx = data->format;
#line 109
  memcpy((void *)data, (void const   *)(& simple_formats[indx]), (unsigned long )((int )sizeof(SF_FORMAT_INFO )));
  }
#line 111
  return (0);
}
}
#line 118 "/root/patchweave_donee/23/src/command.c"
static SF_FORMAT_INFO major_formats[25]  = 
#line 118
  {      {131072, "AIFF (Apple/SGI)\323\001 ", "aiff"}, 
        {196608, "AU (Sun/NeXT)", "au"}, 
        {1179648, "AVR (Audio Visual Research)", "avr"}, 
        {1572864, "CAF (Apple Core Audio File)", "caf"}, 
        {1507328, "FLAC (Free Lossless Audio Codec)\323\001 ", "flac"}, 
        {1048576, "HTK (HMM Tool Kit)", "htk"}, 
        {393216, "IFF (Amiga IFF/SVX8/SV16)T^`\375\177", "iff\323\204U"}, 
        {786432, "MAT4 (GNU Octave 2.0 / Matlab 4.2)", "mat"}, 
        {851968, "MAT5 (GNU Octave 2.1 / Matlab 5.0)", "mat"}, 
        {2162688, "MPC (Akai MPC 2k)\340\334\323\204U", "mpc"}, 
        {2097152, "OGG (OGG Container format)", "oga"}, 
        {327680, "PAF (Ensoniq PARIS)", "paf"}, 
        {917504, "PVF (Portable Voice Format)", "pvf"}, 
        {262144, "RAW (header-less)", "raw"}, 
        {2228224, "RF64 (RIFF 64)", "rf64"}, 
        {1441792, "SD2 (Sound Designer II)", "sd2"}, 
        {1114112, "SDS (Midi Sample Dump Standard)", "sds"}, 
        {655360, "SF (Berkeley/IRCAM/CARL)\323\001 ", "sf"}, 
        {524288, "VOC (Creative Labs)", "voc"}, 
        {720896, "W64 (SoundFoundry WAVE 64)", "w64"}, 
        {65536, "WAV (Microsoft)", "wav"}, 
        {458752, "WAV (NIST Sphere)", "wav"}, 
        {1245184, "WAVEX (Microsoft)", "wav"}, 
        {1638400, "WVE (Psion Series 3)", "wve"}, 
        {983040, "XI (FastTracker 2)", "xi"}};
#line 153 "/root/patchweave_donee/23/src/command.c"
int psf_get_format_major_count(void) 
{ 


  {
#line 154
  return ((int )(sizeof(major_formats) / sizeof(SF_FORMAT_INFO )));
}
}
#line 158 "/root/patchweave_donee/23/src/command.c"
int psf_get_format_major(SF_FORMAT_INFO *data ) 
{ 
  int indx ;

  {
#line 161
  if (data->format < 0) {
#line 162
    return (31);
  } else
#line 161
  if (data->format >= (int )sizeof(major_formats) / (int )sizeof(SF_FORMAT_INFO )) {
#line 162
    return (31);
  }
  {
#line 164
  indx = data->format;
#line 165
  memcpy((void *)data, (void const   *)(& major_formats[indx]), (unsigned long )((int )sizeof(SF_FORMAT_INFO )));
  }
#line 167
  return (0);
}
}
#line 174 "/root/patchweave_donee/23/src/command.c"
static SF_FORMAT_INFO subtype_formats[25]  = 
#line 174
  {      {1, "Signed 8 bit PCM\251", (char const   *)((void *)0)}, 
        {2, "Signed 16 bit PCM", (char const   *)((void *)0)}, 
        {3, "Signed 24 bit PCM", (char const   *)((void *)0)}, 
        {4, "Signed 32 bit PCM", (char const   *)((void *)0)}, 
        {5, "Unsigned 8 bit PCM", (char const   *)((void *)0)}, 
        {6, "32 bit float", (char const   *)((void *)0)}, 
        {7, "64 bit float", (char const   *)((void *)0)}, 
        {16, "U-Law", (char const   *)((void *)0)}, 
        {17, "A-Law", (char const   *)((void *)0)}, 
        {18, "IMA ADPCM", (char const   *)((void *)0)}, 
        {19, "Microsoft ADPCM", (char const   *)((void *)0)}, 
        {32, "GSM 6.10\251", (char const   *)((void *)0)}, 
        {48, "32kbs G721 ADPCM\251", (char const   *)((void *)0)}, 
        {49, "24kbs G723 ADPCM\251", (char const   *)((void *)0)}, 
        {64, "12 bit DWVW", (char const   *)((void *)0)}, 
        {65, "16 bit DWVW", (char const   *)((void *)0)}, 
        {66, "24 bit DWVW", (char const   *)((void *)0)}, 
        {33, "VOX ADPCM", "vox"}, 
        {81, "16 bit DPCM", (char const   *)((void *)0)}, 
        {80, "8 bit DPCM", (char const   *)((void *)0)}, 
        {96, "Vorbis", (char const   *)((void *)0)}, 
        {112, "16 bit ALAC", (char const   *)((void *)0)}, 
        {113, "20 bit ALAC", (char const   *)((void *)0)}, 
        {114, "24 bit ALAC", (char const   *)((void *)0)}, 
        {115, "32 bit ALAC", (char const   *)((void *)0)}};
#line 215 "/root/patchweave_donee/23/src/command.c"
int psf_get_format_subtype_count(void) 
{ 


  {
#line 216
  return ((int )(sizeof(subtype_formats) / sizeof(SF_FORMAT_INFO )));
}
}
#line 220 "/root/patchweave_donee/23/src/command.c"
int psf_get_format_subtype(SF_FORMAT_INFO *data ) 
{ 
  int indx ;

  {
#line 223
  if (data->format < 0) {
#line 224
    data->format = 0;
#line 225
    return (31);
  } else
#line 223
  if (data->format >= (int )sizeof(subtype_formats) / (int )sizeof(SF_FORMAT_INFO )) {
#line 224
    data->format = 0;
#line 225
    return (31);
  }
  {
#line 228
  indx = data->format;
#line 229
  memcpy((void *)data, (void const   *)(& subtype_formats[indx]), sizeof(SF_FORMAT_INFO ));
  }
#line 231
  return (0);
}
}
#line 238 "/root/patchweave_donee/23/src/command.c"
int psf_get_format_info(SF_FORMAT_INFO *data ) 
{ 
  int k ;
  int format ;

  {
#line 241
  if (data->format & 268369920) {
#line 242
    format = data->format & 268369920;
#line 244
    k = 0;
    {
#line 244
    while (1) {
      while_continue: /* CIL Label */ ;

#line 244
      if (! (k < (int )sizeof(major_formats) / (int )sizeof(SF_FORMAT_INFO ))) {
#line 244
        goto while_break;
      }
#line 245
      if (format == major_formats[k].format) {
        {
#line 246
        memcpy((void *)data, (void const   *)(& major_formats[k]), sizeof(SF_FORMAT_INFO ));
        }
#line 247
        return (0);
      }
#line 244
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 251
  if (data->format & 65535) {
#line 252
    format = data->format & 65535;
#line 254
    k = 0;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 254
      if (! (k < (int )sizeof(subtype_formats) / (int )sizeof(SF_FORMAT_INFO ))) {
#line 254
        goto while_break___0;
      }
#line 255
      if (format == subtype_formats[k].format) {
        {
#line 256
        memcpy((void *)data, (void const   *)(& subtype_formats[k]), sizeof(SF_FORMAT_INFO ));
        }
#line 257
        return (0);
      }
#line 254
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  {
#line 262
  memset((void *)data, 0, sizeof(SF_FORMAT_INFO ));
  }
#line 264
  return (31);
}
}
#line 271 "/root/patchweave_donee/23/src/command.c"
double psf_calc_signal_max(SF_PRIVATE *psf , int normalize ) 
{ 
  BUF_UNION ubuf ;
  sf_count_t position ;
  double max_val ;
  double temp ;
  double *data ;
  int k ;
  int len ;
  int readcount ;
  int save_state ;
  sf_count_t __cil_tmp14 ;
  double tmp ;

  {
#line 278
  if (! psf->sf.seekable) {
#line 279
    psf->error = 40;
#line 280
    return (0.);
  }
#line 283
  if (! psf->read_double) {
#line 284
    psf->error = 18;
#line 285
    return (0.);
  }
  {
#line 288
  save_state = sf_command((SNDFILE *)psf, 4112, (void *)0, 0);
#line 289
  sf_command((SNDFILE *)psf, 4114, (void *)0, normalize);
#line 293
  position = sf_seek((SNDFILE *)psf, (sf_count_t )0, 1);
#line 295
  sf_seek((SNDFILE *)psf, (sf_count_t )0, 0);
#line 297
  data = ubuf.dbuf;
#line 299
  len = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0])) - (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0])) % psf->sf.channels;
#line 301
  max_val = 0.;
#line 301
  readcount = 1;
  }
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;

#line 301
    if (! (readcount > 0)) {
#line 301
      goto while_break;
    }
    {
#line 302
    __cil_tmp14 = sf_read_double((SNDFILE *)psf, data, (sf_count_t )len);
#line 302
    readcount = (int )__cil_tmp14;
#line 303
    k = 0;
    }
    {
#line 303
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 303
      if (! (k < readcount)) {
#line 303
        goto while_break___0;
      }
      {
#line 304
      temp = fabs(*(data + k));
      }
#line 305
      if (temp > max_val) {
#line 305
        tmp = temp;
      } else {
#line 305
        tmp = max_val;
      }
#line 305
      max_val = tmp;
#line 303
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 310
  sf_seek((SNDFILE *)psf, position, 0);
#line 311
  sf_command((SNDFILE *)psf, 4114, (void *)0, save_state);
  }
#line 313
  return (max_val);
}
}
#line 317 "/root/patchweave_donee/23/src/command.c"
int psf_calc_max_all_channels(SF_PRIVATE *psf , double *peaks , int normalize ) 
{ 
  BUF_UNION ubuf ;
  sf_count_t position ;
  double temp ;
  double *data ;
  int k ;
  int len ;
  int readcount ;
  int save_state ;
  int chan ;
  sf_count_t __cil_tmp15 ;
  double tmp ;

  {
#line 325
  if (! psf->sf.seekable) {
#line 326
    psf->error = 40;
#line 326
    return (psf->error);
  }
#line 328
  if (! psf->read_double) {
#line 329
    psf->error = 18;
#line 329
    return (psf->error);
  }
  {
#line 331
  save_state = sf_command((SNDFILE *)psf, 4112, (void *)0, 0);
#line 332
  sf_command((SNDFILE *)psf, 4114, (void *)0, normalize);
#line 334
  memset((void *)peaks, 0, sizeof(double ) * (unsigned long )psf->sf.channels);
#line 337
  position = sf_seek((SNDFILE *)psf, (sf_count_t )0, 1);
#line 338
  sf_seek((SNDFILE *)psf, (sf_count_t )0, 0);
#line 340
  len = (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0])) - (int )(sizeof(ubuf.dbuf) / sizeof(ubuf.dbuf[0])) % psf->sf.channels;
#line 342
  data = ubuf.dbuf;
#line 344
  chan = 0;
#line 345
  readcount = len;
  }
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;

#line 346
    if (! (readcount > 0)) {
#line 346
      goto while_break;
    }
    {
#line 347
    __cil_tmp15 = sf_read_double((SNDFILE *)psf, data, (sf_count_t )len);
#line 347
    readcount = (int )__cil_tmp15;
#line 348
    k = 0;
    }
    {
#line 348
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 348
      if (! (k < readcount)) {
#line 348
        goto while_break___0;
      }
      {
#line 349
      temp = fabs(*(data + k));
      }
#line 350
      if (temp > *(peaks + chan)) {
#line 350
        tmp = temp;
      } else {
#line 350
        tmp = *(peaks + chan);
      }
#line 350
      *(peaks + chan) = tmp;
#line 351
      chan = (chan + 1) % psf->sf.channels;
#line 348
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 355
  sf_seek((SNDFILE *)psf, position, 0);
#line 357
  sf_command((SNDFILE *)psf, 4114, (void *)0, save_state);
  }
#line 359
  return (0);
}
}
#line 363 "/root/patchweave_donee/23/src/command.c"
int psf_get_signal_max(SF_PRIVATE *psf , double *peak ) 
{ 
  int k ;

  {
#line 366
  if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 367
    return (0);
  }
#line 369
  *(peak + 0) = (psf->peak_info)->peaks[0].value;
#line 371
  k = 1;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;

#line 371
    if (! (k < psf->sf.channels)) {
#line 371
      goto while_break;
    }
#line 372
    *(peak + 0) = (double )0;
#line 371
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 374
  return (1);
}
}
#line 378 "/root/patchweave_donee/23/src/command.c"
int psf_get_max_all_channels(SF_PRIVATE *psf , double *peaks ) 
{ 
  int k ;

  {
#line 381
  if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 382
    return (0);
  }
#line 384
  k = 0;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;

#line 384
    if (! (k < psf->sf.channels)) {
#line 384
      goto while_break;
    }
#line 385
    *(peaks + k) = (psf->peak_info)->peaks[k].value;
#line 384
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 387
  return (1);
}
}
#line 30 "/root/patchweave_donee/23/src/chunk.c"
static int64_t hash_of_str(char const   *str ) 
{ 
  int64_t marker ;
  int k ;

  {
#line 31
  marker = (int64_t )0;
#line 34
  k = 0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;

#line 34
    if (! *(str + k)) {
#line 34
      goto while_break;
    }
#line 35
    marker = marker * 127L + (long )*((uint8_t *)str + k);
#line 34
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 37
  return (marker);
}
}
#line 41 "/root/patchweave_donee/23/src/chunk.c"
SF_CHUNK_ITERATOR *psf_get_chunk_iterator(SF_PRIVATE *psf , char const   *marker_str ) 
{ 
  READ_CHUNKS *pchk ;
  int idx ;
  int tmp ;
  int64_t hash ;
  size_t marker_len ;
  int64_t __cil_tmp12 ;
  int64_t tmp___0 ;
  void *tmp___1 ;

  {
#line 42
  pchk = & psf->rchunks;
#line 45
  if (marker_str) {
    {
#line 46
    idx = psf_find_read_chunk_str(pchk, marker_str);
    }
  } else {
#line 48
    if (pchk->used > 0U) {
#line 48
      tmp = 0;
    } else {
#line 48
      tmp = -1;
    }
#line 48
    idx = tmp;
  }
#line 50
  if (idx < 0) {
#line 51
    return ((SF_CHUNK_ITERATOR *)((void *)0));
  }
#line 53
  if ((unsigned long )psf->iterator == (unsigned long )((void *)0)) {
    {
#line 54
    tmp___1 = calloc(1UL, sizeof(SF_CHUNK_ITERATOR ));
#line 54
    psf->iterator = (SF_CHUNK_ITERATOR *)tmp___1;
    }
#line 55
    if ((unsigned long )psf->iterator == (unsigned long )((void *)0)) {
#line 56
      return ((SF_CHUNK_ITERATOR *)((void *)0));
    }
  }
#line 59
  (psf->iterator)->sndfile = (SNDFILE *)psf;
#line 61
  if (marker_str) {
    {
#line 71
    marker_len = strlen(marker_str);
    }
#line 72
    if (marker_len > 64UL) {
#line 73
      marker_len = (size_t )64;
    }
#line 75
    if (marker_len > 4UL) {
      {
#line 75
      __cil_tmp12 = hash_of_str(marker_str);
#line 75
      tmp___0 = __cil_tmp12;
      }
    }
    {
#line 75
    hash = tmp___0;
#line 77
    memcpy((void *)((psf->iterator)->id), (void const   *)marker_str, marker_len);
#line 78
    (psf->iterator)->id_size = (unsigned int )marker_len;
#line 79
    (psf->iterator)->hash = hash;
    }
  }
#line 82
  (psf->iterator)->current = (uint32_t )idx;
#line 84
  return (psf->iterator);
}
}
#line 88 "/root/patchweave_donee/23/src/chunk.c"
SF_CHUNK_ITERATOR *psf_next_chunk_iterator(READ_CHUNKS *pchk , SF_CHUNK_ITERATOR *iterator ) 
{ 
  int64_t hash ;
  uint32_t k ;

  {
#line 89
  hash = iterator->hash;
#line 92
  (iterator->current) ++;
#line 94
  if (hash) {
#line 95
    k = iterator->current;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;

#line 95
      if (! (k < pchk->used)) {
#line 95
        goto while_break;
      }
#line 96
      if ((pchk->chunks + k)->hash == hash) {
#line 97
        iterator->current = k;
#line 98
        return (iterator);
      }
#line 95
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 101
  if (iterator->current < pchk->used) {
#line 102
    return (iterator);
  }
  {
#line 105
  memset((void *)iterator, 0, sizeof(*iterator));
  }
#line 106
  return ((SF_CHUNK_ITERATOR *)((void *)0));
}
}
#line 110 "/root/patchweave_donee/23/src/chunk.c"
static int psf_store_read_chunk(READ_CHUNKS *pchk , READ_CHUNK *rchunk ) 
{ 
  READ_CHUNK *old_ptr ;
  int new_count ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 111
  if (pchk->count == 0U) {
    {
#line 112
    pchk->used = (uint32_t )0;
#line 113
    pchk->count = (uint32_t )20;
#line 114
    tmp = calloc((unsigned long )pchk->count, sizeof(READ_CHUNK ));
#line 114
    pchk->chunks = (READ_CHUNK *)tmp;
    }
  } else
#line 116
  if (pchk->used > pchk->count) {
#line 117
    return (30);
  } else
#line 118
  if (pchk->used == pchk->count) {
    {
#line 119
    old_ptr = pchk->chunks;
#line 120
    new_count = (int )((3U * (pchk->count + 1U)) / 2U);
#line 122
    tmp___0 = realloc((void *)old_ptr, (unsigned long )new_count * sizeof(READ_CHUNK ));
#line 122
    pchk->chunks = (READ_CHUNK *)tmp___0;
    }
#line 123
    if ((unsigned long )pchk->chunks == (unsigned long )((void *)0)) {
#line 124
      pchk->chunks = old_ptr;
#line 125
      return (17);
    }
#line 127
    pchk->count = (uint32_t )new_count;
  }
#line 130
  *(pchk->chunks + pchk->used) = *rchunk;
#line 132
  (pchk->used) ++;
#line 134
  return (0);
}
}
#line 138 "/root/patchweave_donee/23/src/chunk.c"
int psf_store_read_chunk_u32(READ_CHUNKS *pchk , uint32_t marker , sf_count_t offset ,
                             uint32_t len ) 
{ 
  READ_CHUNK rchunk ;
  int __cil_tmp6 ;

  {
  {
#line 141
  memset((void *)(& rchunk), 0, sizeof(rchunk));
#line 143
  rchunk.hash = (int64_t )marker;
#line 144
  rchunk.mark32 = marker;
#line 145
  rchunk.offset = offset;
#line 146
  rchunk.len = len;
#line 148
  rchunk.id_size = 4U;
#line 149
  memcpy((void *)(rchunk.id), (void const   *)(& marker), (unsigned long )rchunk.id_size);
#line 151
  __cil_tmp6 = psf_store_read_chunk(pchk, & rchunk);
  }
#line 151
  return (__cil_tmp6);
}
}
#line 155 "/root/patchweave_donee/23/src/chunk.c"
int psf_find_read_chunk_str(READ_CHUNKS *pchk , char const   *marker_str ) 
{ 
  int64_t hash ;
  uint32_t k ;
  union __anonunion_704 u ;
  unsigned long __cil_tmp6 ;
  int64_t __cil_tmp7 ;
  int64_t tmp ;

  {
  {
#line 163
  snprintf(u.str, sizeof(u.str), "%s\031\324\204U", marker_str);
#line 165
  __cil_tmp6 = strlen(marker_str);
  }
#line 165
  if (__cil_tmp6 > 4UL) {
    {
#line 165
    __cil_tmp7 = hash_of_str(marker_str);
#line 165
    tmp = __cil_tmp7;
    }
  } else {
#line 165
    tmp = (long )u.marker;
  }
#line 165
  hash = tmp;
#line 167
  k = (uint32_t )0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;

#line 167
    if (! (k < pchk->used)) {
#line 167
      goto while_break;
    }
#line 168
    if ((pchk->chunks + k)->hash == hash) {
#line 169
      return ((int )k);
    }
#line 167
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 171
  return (-1);
}
}
#line 175 "/root/patchweave_donee/23/src/chunk.c"
int psf_find_read_chunk_m32(READ_CHUNKS *pchk , uint32_t marker ) 
{ 
  uint32_t k ;

  {
#line 178
  k = (uint32_t )0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;

#line 178
    if (! (k < pchk->used)) {
#line 178
      goto while_break;
    }
#line 179
    if ((pchk->chunks + k)->mark32 == marker) {
#line 180
      return ((int )k);
    }
#line 178
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 182
  return (-1);
}
}
#line 185 "/root/patchweave_donee/23/src/chunk.c"
int psf_find_read_chunk_iterator(READ_CHUNKS *pchk , SF_CHUNK_ITERATOR *marker ) 
{ 


  {
#line 186
  if (marker->current < pchk->used) {
#line 187
    return ((int )marker->current);
  }
#line 189
  return (-1);
}
}
#line 193 "/root/patchweave_donee/23/src/chunk.c"
int psf_store_read_chunk_str(READ_CHUNKS *pchk , char const   *marker_str , sf_count_t offset ,
                             uint32_t len ) 
{ 
  READ_CHUNK rchunk ;
  union __anonunion_705 u ;
  size_t marker_len ;
  int64_t __cil_tmp9 ;
  int64_t tmp ;
  unsigned long tmp___0 ;
  int __cil_tmp12 ;

  {
  {
#line 201
  memset((void *)(& rchunk), 0, sizeof(rchunk));
#line 202
  snprintf(u.str, sizeof(u.str), "%s", marker_str);
#line 204
  marker_len = strlen(marker_str);
  }
#line 206
  if (marker_len > 4UL) {
    {
#line 206
    __cil_tmp9 = hash_of_str(marker_str);
#line 206
    tmp = __cil_tmp9;
    }
  } else {
#line 206
    tmp = (long )u.marker;
  }
#line 206
  rchunk.hash = tmp;
#line 207
  rchunk.mark32 = u.marker;
#line 208
  rchunk.offset = offset;
#line 209
  rchunk.len = len;
#line 211
  if (marker_len > 64UL) {
#line 211
    tmp___0 = 64UL;
  } else {
#line 211
    tmp___0 = marker_len;
  }
  {
#line 211
  rchunk.id_size = (unsigned int )tmp___0;
#line 212
  memcpy((void *)(rchunk.id), (void const   *)marker_str, (unsigned long )rchunk.id_size);
#line 214
  __cil_tmp12 = psf_store_read_chunk(pchk, & rchunk);
  }
#line 214
  return (__cil_tmp12);
}
}
#line 218 "/root/patchweave_donee/23/src/chunk.c"
int psf_save_write_chunk(WRITE_CHUNKS *pchk , SF_CHUNK_INFO *chunk_info ) 
{ 
  union __anonunion_706 u ;
  uint32_t len ;
  WRITE_CHUNK *old_ptr ;
  int new_count ;
  unsigned long __cil_tmp10 ;
  int64_t __cil_tmp11 ;
  int64_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 225
  if (pchk->count == 0U) {
    {
#line 226
    pchk->used = (uint32_t )0;
#line 227
    pchk->count = (uint32_t )20;
#line 228
    tmp___0 = calloc((unsigned long )pchk->count, sizeof(WRITE_CHUNK ));
#line 228
    pchk->chunks = (WRITE_CHUNK *)tmp___0;
    }
  } else
#line 230
  if (pchk->used >= pchk->count) {
    {
#line 231
    old_ptr = pchk->chunks;
#line 232
    new_count = (int )((3U * (pchk->count + 1U)) / 2U);
#line 234
    tmp___1 = realloc((void *)old_ptr, (unsigned long )new_count * sizeof(WRITE_CHUNK ));
#line 234
    pchk->chunks = (WRITE_CHUNK *)tmp___1;
    }
#line 235
    if ((unsigned long )pchk->chunks == (unsigned long )((void *)0)) {
#line 236
      pchk->chunks = old_ptr;
#line 237
      return (17);
    }
  }
#line 241
  len = chunk_info->datalen;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;

#line 242
    if (! (len & 3U)) {
#line 242
      goto while_break;
    }
#line 242
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 244
  snprintf(u.str, sizeof(u.str), "%s", (char const   *)(chunk_info->id));
#line 246
  __cil_tmp10 = strlen((char const   *)(chunk_info->id));
  }
#line 246
  if (__cil_tmp10 > 4UL) {
    {
#line 246
    __cil_tmp11 = hash_of_str((char const   *)(chunk_info->id));
#line 246
    tmp = __cil_tmp11;
    }
  } else {
#line 246
    tmp = (long )u.marker;
  }
  {
#line 246
  (pchk->chunks + pchk->used)->hash = tmp;
#line 247
  (pchk->chunks + pchk->used)->mark32 = u.marker;
#line 248
  (pchk->chunks + pchk->used)->len = len;
#line 249
  (pchk->chunks + pchk->used)->data = psf_memdup((void const   *)chunk_info->data,
                                                 (size_t )chunk_info->datalen);
#line 251
  (pchk->used) ++;
  }
#line 253
  return (0);
}
}
#line 30 "/root/patchweave_donee/23/src/chanmap.h"
int aiff_caf_find_channel_layout_tag(int const   *chan_map , int channels ) ;
#line 32
AIFF_CAF_CHANNEL_MAP *aiff_caf_of_channel_layout_tag(int tag ) ;
#line 36 "/root/patchweave_donee/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP zero_chan[2]  = {      {0, (int const   *)((void *)0), "Use channel descriptions."}, 
        {1 << 16, (int const   *)((void *)0), "Use channel bitmap."}};
#line 42 "/root/patchweave_donee/23/src/chanmap.c"
static int const   one_chan_mono[1]  = {      (int const   )1};
#line 44 "/root/patchweave_donee/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP one_chan[1]  = {      {(100 << 16) | 1, one_chan_mono, "mono\204U"}};
#line 49 "/root/patchweave_donee/23/src/chanmap.c"
static int const   two_channel_stereo[2]  = {      (int const   )2,      (int const   )3};
#line 51 "/root/patchweave_donee/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP two_chan[2]  = {      {(101 << 16) | 2, two_channel_stereo, "stereo (L, R)"}, 
        {(102 << 16) | 2, two_channel_stereo, "stereo headphones (L, R)\250"}};
#line 64 "/root/patchweave_donee/23/src/chanmap.c"
static int const   three_channel_mpeg_30a[3]  = {      (int const   )2,      (int const   )3,      (int const   )4};
#line 66 "/root/patchweave_donee/23/src/chanmap.c"
static int const   three_channel_mpeg_30b[3]  = {      (int const   )4,      (int const   )2,      (int const   )3};
#line 68 "/root/patchweave_donee/23/src/chanmap.c"
static int const   three_channel_itu_21[3]  = {      (int const   )2,      (int const   )3,      (int const   )8};
#line 70 "/root/patchweave_donee/23/src/chanmap.c"
static int const   three_channel_dvd_4[3]  = {      (int const   )2,      (int const   )3,      (int const   )11};
#line 73 "/root/patchweave_donee/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP three_chan[4]  = {      {(113 << 16) | 3, three_channel_mpeg_30a, "MPEG 3 0 A (L, R, C)"}, 
        {(114 << 16) | 3, three_channel_mpeg_30b, "MPEG 3 0 B (C, L, R)"}, 
        {(131 << 16) | 3, three_channel_itu_21, "ITU 2.1 (L, R, Cs)"}, 
        {(133 << 16) | 3, three_channel_dvd_4, "DVD 4 (L, R, LFE)"}};
#line 81 "/root/patchweave_donee/23/src/chanmap.c"
static int const   four_channel_ambisonc_b[4]  = {      (int const   )23,      (int const   )24,      (int const   )25,      (int const   )26};
#line 83 "/root/patchweave_donee/23/src/chanmap.c"
static int const   four_channel_quad[4]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10};
#line 85 "/root/patchweave_donee/23/src/chanmap.c"
static int const   four_channel_mpeg_40a[4]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )8};
#line 87 "/root/patchweave_donee/23/src/chanmap.c"
static int const   four_channel_mpeg_40b[4]  = {      (int const   )4,      (int const   )2,      (int const   )3,      (int const   )8};
#line 89 "/root/patchweave_donee/23/src/chanmap.c"
static int const   four_channel_itu_23[4]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10};
#line 91 "/root/patchweave_donee/23/src/chanmap.c"
static int const   four_channel_dvd_5[4]  = {      (int const   )2,      (int const   )3,      (int const   )11,      (int const   )8};
#line 93 "/root/patchweave_donee/23/src/chanmap.c"
static int const   four_channel_dvd_10[4]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )11};
#line 96 "/root/patchweave_donee/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP four_chan[7]  = {      {(107 << 16) | 4, four_channel_ambisonc_b, "ambisonic B (W,  X, Y, Z)"}, 
        {(108 << 16) | 4, four_channel_quad, "quad (Lfront, Rfront, Lrear, Rrear)"}, 
        {(115 << 16) | 4, four_channel_mpeg_40a, "MPEG 4.0 A (L, R, C, Cs)\250"}, 
        {(116 << 16) | 4, four_channel_mpeg_40b, "MPEG 4.0 B (C, L, R, Cs)\250"}, 
        {(132 << 16) | 4, four_channel_itu_23, "ITU 2.3 (L, R, Ls, Rs)"}, 
        {(134 << 16) | 4, four_channel_dvd_5, "DVD 5 (L, R, LFE, Cs)"}, 
        {(136 << 16) | 4, four_channel_dvd_10, "DVD 10 (L, R, C, LFE)"}};
#line 107 "/root/patchweave_donee/23/src/chanmap.c"
static int const   five_channel_pentagonal[5]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10, 
        (int const   )4};
#line 109 "/root/patchweave_donee/23/src/chanmap.c"
static int const   five_channel_mpeg_50_a[5]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )9, 
        (int const   )10};
#line 111 "/root/patchweave_donee/23/src/chanmap.c"
static int const   five_channel_mpeg_50_b[5]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10, 
        (int const   )4};
#line 113 "/root/patchweave_donee/23/src/chanmap.c"
static int const   five_channel_mpeg_50_c[5]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )9, 
        (int const   )10};
#line 115 "/root/patchweave_donee/23/src/chanmap.c"
static int const   five_channel_mpeg_50_d[5]  = {      (int const   )4,      (int const   )2,      (int const   )3,      (int const   )9, 
        (int const   )10};
#line 117 "/root/patchweave_donee/23/src/chanmap.c"
static int const   five_channel_dvd_6[5]  = {      (int const   )2,      (int const   )3,      (int const   )11,      (int const   )9, 
        (int const   )10};
#line 119 "/root/patchweave_donee/23/src/chanmap.c"
static int const   five_channel_dvd_11[5]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )11, 
        (int const   )8};
#line 121 "/root/patchweave_donee/23/src/chanmap.c"
static int const   five_channel_dvd_18[5]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10, 
        (int const   )11};
#line 124 "/root/patchweave_donee/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP five_chan[8]  = 
#line 124
  {      {(109 << 16) | 5, five_channel_pentagonal, "pentagonal (L,  R, Lrear, Rrear, C)"}, 
        {(117 << 16) | 5,
      five_channel_mpeg_50_a, "MPEG 5.0 A (L, R, C, Ls, Rs)"}, 
        {(118 << 16) | 5, five_channel_mpeg_50_b, "MPEG 5.0 B (L, R, Ls, Rs, C)"}, 
        {(119 << 16) | 5, five_channel_mpeg_50_c, "MPEG 5.0 C (L, C, R, Ls, Rs,)"}, 
        {(120 << 16) | 5, five_channel_mpeg_50_d, "MPEG 5.0 D (C, L, R, Ls, Rs)"}, 
        {(135 << 16) | 5, five_channel_dvd_6, "DVD 6 (L, R, LFE, Ls, Rs)"}, 
        {(137 << 16) | 5, five_channel_dvd_11, "DVD 11 (L, R, C, LFE, Cs)"}, 
        {(138 << 16) | 5, five_channel_dvd_18, "DVD 18 (L, R, Ls, Rs, LFE)"}};
#line 136 "/root/patchweave_donee/23/src/chanmap.c"
static int const   six_channel_mpeg_51_a[6]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )11, 
        (int const   )9,      (int const   )10};
#line 138 "/root/patchweave_donee/23/src/chanmap.c"
static int const   six_channel_mpeg_51_b[6]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10, 
        (int const   )4,      (int const   )11};
#line 140 "/root/patchweave_donee/23/src/chanmap.c"
static int const   six_channel_mpeg_51_c[6]  = {      (int const   )2,      (int const   )4,      (int const   )3,      (int const   )9, 
        (int const   )10,      (int const   )11};
#line 142 "/root/patchweave_donee/23/src/chanmap.c"
static int const   six_channel_mpeg_51_d[6]  = {      (int const   )4,      (int const   )2,      (int const   )3,      (int const   )9, 
        (int const   )10,      (int const   )11};
#line 144 "/root/patchweave_donee/23/src/chanmap.c"
static int const   six_channel_audio_unit_60[6]  = {      (int const   )2,      (int const   )3,      (int const   )9,      (int const   )10, 
        (int const   )4,      (int const   )8};
#line 146 "/root/patchweave_donee/23/src/chanmap.c"
static int const   six_channel_aac_60[6]  = {      (int const   )4,      (int const   )2,      (int const   )3,      (int const   )9, 
        (int const   )10,      (int const   )8};
#line 149 "/root/patchweave_donee/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP six_chan[7]  = {      {(110 << 16) | 6, (int const   *)((void *)0), "hexagonal (L, R, Lr, Rr, C, Rear)"}, 
        {(121 << 16) | 6,
      six_channel_mpeg_51_a, "MPEG 5.1 A (L, R, C, LFE, Ls, Rs)"}, 
        {(122 << 16) | 6, six_channel_mpeg_51_b, "MPEG 5.1 B (L, R, Ls, Rs, C, LFE)"}, 
        {(123 << 16) | 6,
      six_channel_mpeg_51_c, "MPEG 5.1 C (L, C, R, Ls, Rs, LFE)"}, 
        {(124 << 16) | 6, six_channel_mpeg_51_d, "MPEG 5.1 D (C, L, R, Ls, Rs, LFE)"}, 
        {(139 << 16) | 6,
      six_channel_audio_unit_60, "AudioUnit 6.0 (L, R, Ls, Rs, C, Cs)"}, 
        {(141 << 16) | 6, six_channel_aac_60, "AAC 6.0 (C, L, R, Ls, Rs, Cs)"}};
#line 160 "/root/patchweave_donee/23/src/chanmap.c"
static int const   six_channel_mpeg_61a[7]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )11, 
        (int const   )9,      (int const   )10,      (int const   )8};
#line 162 "/root/patchweave_donee/23/src/chanmap.c"
static int const   six_channel_aac_61[7]  = {      (int const   )4,      (int const   )2,      (int const   )3,      (int const   )9, 
        (int const   )10,      (int const   )8,      (int const   )11};
#line 165 "/root/patchweave_donee/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP seven_chan[4]  = {      {(125 << 16) | 7, six_channel_mpeg_61a, "MPEG 6.1 A (L, R, C, LFE, Ls, Rs, Cs)"}, 
        {(140 << 16) | 7,
      (int const   *)((void *)0), "AudioUnit 7.0 (L, R, Ls, Rs, C, Rls, Rrs)"}, 
        {(142 << 16) | 7, six_channel_aac_61, "AAC 6.1 (C, L, R, Ls, Rs, Cs, Lfe)"}, 
        {(143 << 16) | 7, (int const   *)((void *)0), "AAC 7.0 (C, L, R, Ls, Rs, Rls, Rrs,)"}};
#line 173 "/root/patchweave_donee/23/src/chanmap.c"
static AIFF_CAF_CHANNEL_MAP eight_chan[8]  = 
#line 173
  {      {(111 << 16) | 8, (int const   *)((void *)0), "octagonal (Lf, Rf, Lr, Rr, Cf, Cr, Ls, Rs)"}, 
        {(112 << 16) | 8,
      (int const   *)((void *)0), "cube (L, R, Lrear, Rrear, Ltop, Rtop, Ltoprear, Rtoprear)"}, 
        {(126 << 16) | 8,
      (int const   *)((void *)0), "MPEG 7.1 A (L, R, C, LFE, Ls, Rs, Lc, Rc)"}, 
        {(127 << 16) | 8, (int const   *)((void *)0), "MPEG 7.1 B (C, Lc, Rc, L, R, Ls, Rs, LFE)"}, 
        {(128 << 16) | 8,
      (int const   *)((void *)0), "MPEG 7.1 C (L, R, C, LFE, Ls, R, Rls, Rrs)"}, 
        {(129 << 16) | 8, (int const   *)((void *)0), "Emagic Default 7.1 (L, R, Ls, Rs, C, LFE, Lc, Rc)"}, 
        {(130 << 16) | 8,
      (int const   *)((void *)0), "SMPTE DTV (L, R, C, LFE, Ls, Rs, Lt, Rt)\250"}, 
        {(144 << 16) | 8,
      (int const   *)((void *)0), "AAC octagonal (C, L, R, Ls, Rs, Rls, Rrs, Cs)"}};
#line 213 "/root/patchweave_donee/23/src/chanmap.c"
static MAP_MAP map[9]  = 
#line 213
  {      {zero_chan, (int )(sizeof(zero_chan) / sizeof(zero_chan[0]))}, 
        {one_chan, (int )(sizeof(one_chan) / sizeof(one_chan[0]))}, 
        {two_chan, (int )(sizeof(two_chan) / sizeof(two_chan[0]))}, 
        {three_chan, (int )(sizeof(three_chan) / sizeof(three_chan[0]))}, 
        {four_chan, (int )(sizeof(four_chan) / sizeof(four_chan[0]))}, 
        {five_chan, (int )(sizeof(five_chan) / sizeof(five_chan[0]))}, 
        {six_chan, (int )(sizeof(six_chan) / sizeof(six_chan[0]))}, 
        {seven_chan, (int )(sizeof(seven_chan) / sizeof(seven_chan[0]))}, 
        {eight_chan, (int )(sizeof(eight_chan) / sizeof(eight_chan[0]))}};
#line 227 "/root/patchweave_donee/23/src/chanmap.c"
int aiff_caf_find_channel_layout_tag(int const   *chan_map , int channels ) 
{ 
  AIFF_CAF_CHANNEL_MAP *curr_map ;
  unsigned int k ;
  unsigned int len ;
  int __cil_tmp6 ;

  {
#line 231
  if (channels < 1) {
#line 232
    return (0);
  } else
#line 231
  if (channels >= (int )(sizeof(map) / sizeof(map[0]))) {
#line 232
    return (0);
  }
#line 234
  curr_map = map[channels].map;
#line 235
  len = (unsigned int )map[channels].len;
#line 237
  k = 0U;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;

#line 237
    if (! (k < len)) {
#line 237
      goto while_break;
    }
#line 238
    if ((unsigned long )(curr_map + k)->channel_map != (unsigned long )((void *)0)) {
      {
#line 239
      __cil_tmp6 = memcmp((void const   *)chan_map, (void const   *)(curr_map + k)->channel_map,
                          (unsigned long )channels * sizeof(*(chan_map + 0)));
      }
#line 239
      if (__cil_tmp6 == 0) {
#line 240
        return ((curr_map + k)->channel_layout_tag);
      }
    }
#line 237
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 242
  return (0);
}
}
#line 246 "/root/patchweave_donee/23/src/chanmap.c"
AIFF_CAF_CHANNEL_MAP *aiff_caf_of_channel_layout_tag(int tag ) 
{ 
  AIFF_CAF_CHANNEL_MAP *curr_map ;
  unsigned int k ;
  unsigned int len ;
  int channels ;

  {
#line 249
  channels = tag & 65535;
#line 251
  if (channels < 0) {
#line 252
    return ((AIFF_CAF_CHANNEL_MAP *)((void *)0));
  } else
#line 251
  if (channels >= (int )(sizeof(map) / sizeof(map[0]))) {
#line 252
    return ((AIFF_CAF_CHANNEL_MAP *)((void *)0));
  }
#line 254
  curr_map = map[channels].map;
#line 255
  len = (unsigned int )map[channels].len;
#line 257
  k = 0U;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;

#line 257
    if (! (k < len)) {
#line 257
      goto while_break;
    }
#line 258
    if ((curr_map + k)->channel_layout_tag == tag) {
#line 259
      return (curr_map + k);
    }
#line 257
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 261
  return ((AIFF_CAF_CHANNEL_MAP *)((void *)0));
}
}
#line 32 "/root/patchweave_donee/23/src/cart.c"
__inline static size_t cart_min_size(SF_CART_INFO *info ) 
{ 


  {
#line 33
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 34
    return ((size_t )0);
  }
#line 36
  return ((unsigned long )info->tag_text_size);
}
}
#line 40 "/root/patchweave_donee/23/src/cart.c"
SF_CART_INFO_16K *cart_var_alloc(void) 
{ 
  SF_CART_INFO_16K *thing ;
  void *tmp ;

  {
  {
#line 42
  tmp = malloc(sizeof(SF_CART_INFO_16K ));
#line 42
  thing = (SF_CART_INFO_16K *)tmp;
  }
#line 43
  return (thing);
}
}
#line 47 "/root/patchweave_donee/23/src/cart.c"
int cart_var_set(SF_PRIVATE *psf , SF_CART_INFO *info , size_t datasize ) 
{ 
  size_t len ;
  size_t __cil_tmp5 ;
  int tmp ;

  {
#line 50
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 51
    return (0);
  }
  {
#line 53
  __cil_tmp5 = cart_min_size(info);
  }
#line 53
  if (__cil_tmp5 > datasize) {
#line 54
    psf->error = 51;
#line 55
    return (0);
  }
#line 58
  if (datasize >= sizeof(SF_CART_INFO_16K )) {
#line 59
    psf->error = 52;
#line 60
    return (0);
  }
#line 63
  if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
    {
#line 64
    psf->cart_16k = cart_var_alloc();
    }
#line 64
    if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
#line 65
      psf->error = 17;
#line 66
      return (0);
    }
  }
  {
#line 70
  memcpy((void *)psf->cart_16k, (void const   *)info, (size_t )0);
#line 71
  psf_strlcpy_crlf((psf->cart_16k)->tag_text, (char const   *)(info->tag_text), sizeof((psf->cart_16k)->tag_text),
                   datasize);
#line 73
  len = strlen((char const   *)((psf->cart_16k)->tag_text));
  }
#line 75
  if (len > 0UL) {
#line 75
    if ((int )(psf->cart_16k)->tag_text[len - 1UL] != 10) {
      {
#line 76
      psf_strlcat((psf->cart_16k)->tag_text, sizeof((psf->cart_16k)->tag_text), "\r\n");
      }
    }
  }
  {
#line 79
  len = strlen((char const   *)((psf->cart_16k)->tag_text));
  }
#line 80
  if (len & 1UL) {
#line 80
    tmp = 1;
  } else {
#line 80
    tmp = 2;
  }
#line 80
  len += (unsigned long )tmp;
#line 82
  (psf->cart_16k)->tag_text_size = (uint32_t )len;
#line 84
  return (1);
}
}
#line 89 "/root/patchweave_donee/23/src/cart.c"
int cart_var_get(SF_PRIVATE *psf , SF_CART_INFO *data , size_t datasize ) 
{ 
  size_t size ;

  {
#line 91
  if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
#line 92
    return (0);
  }
  {
#line 94
  size = (size_t )0;
#line 96
  memcpy((void *)data, (void const   *)psf->cart_16k, size);
  }
#line 98
  return (1);
}
}
#line 29 "/root/patchweave_donee/23/src/broadcast.c"
static int gen_coding_history(char *added_history , int added_history_max , SF_INFO *psfinfo ) ;
#line 32 "/root/patchweave_donee/23/src/broadcast.c"
__inline static size_t bc_min_size(SF_BROADCAST_INFO *info ) 
{ 


  {
#line 33
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 34
    return ((size_t )0);
  }
#line 36
  return ((unsigned long )info->coding_history_size);
}
}
#line 40 "/root/patchweave_donee/23/src/broadcast.c"
SF_BROADCAST_INFO_16K *broadcast_var_alloc(void) 
{ 
  void *__cil_tmp1 ;

  {
  {
#line 41
  __cil_tmp1 = calloc(1UL, sizeof(SF_BROADCAST_INFO_16K ));
  }
#line 41
  return ((SF_BROADCAST_INFO_16K *)__cil_tmp1);
}
}
#line 45 "/root/patchweave_donee/23/src/broadcast.c"
int broadcast_var_set(SF_PRIVATE *psf , SF_BROADCAST_INFO *info , size_t datasize ) 
{ 
  size_t len ;
  size_t __cil_tmp5 ;
  char added_history[256] ;
  int tmp ;

  {
#line 48
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 49
    return (0);
  }
  {
#line 51
  __cil_tmp5 = bc_min_size(info);
  }
#line 51
  if (__cil_tmp5 > datasize) {
#line 52
    psf->error = 49;
#line 53
    return (0);
  }
#line 56
  if (datasize >= sizeof(SF_BROADCAST_INFO_16K )) {
#line 57
    psf->error = 50;
#line 58
    return (0);
  }
#line 61
  if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
    {
#line 62
    psf->broadcast_16k = broadcast_var_alloc();
    }
#line 62
    if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
#line 63
      psf->error = 17;
#line 64
      return (0);
    }
  }
  {
#line 69
  memcpy((void *)psf->broadcast_16k, (void const   *)info, (size_t )0);
#line 71
  psf_strlcpy_crlf((psf->broadcast_16k)->coding_history, (char const   *)(info->coding_history),
                   sizeof((psf->broadcast_16k)->coding_history), datasize);
#line 72
  len = strlen((char const   *)((psf->broadcast_16k)->coding_history));
  }
#line 74
  if (len > 0UL) {
#line 74
    if ((int )(psf->broadcast_16k)->coding_history[len - 1UL] != 10) {
      {
#line 75
      psf_strlcat((psf->broadcast_16k)->coding_history, sizeof((psf->broadcast_16k)->coding_history),
                  "\r\n");
      }
    }
  }
#line 77
  if (psf->file.mode == 32) {
    {
#line 80
    gen_coding_history(added_history, (int )sizeof(added_history), & psf->sf);
#line 81
    psf_strlcat((psf->broadcast_16k)->coding_history, sizeof((psf->broadcast_16k)->coding_history),
                (char const   *)(added_history));
    }
  }
  {
#line 85
  len = strlen((char const   *)((psf->broadcast_16k)->coding_history));
  }
#line 86
  if (len & 1UL) {
#line 86
    tmp = 1;
  } else {
#line 86
    tmp = 0;
  }
#line 86
  len += (unsigned long )tmp;
#line 87
  (psf->broadcast_16k)->coding_history_size = (uint32_t )len;
#line 90
  (psf->broadcast_16k)->version = (short)1;
#line 92
  return (1);
}
}
#line 97 "/root/patchweave_donee/23/src/broadcast.c"
int broadcast_var_get(SF_PRIVATE *psf , SF_BROADCAST_INFO *data , size_t datasize ) 
{ 
  size_t size ;

  {
#line 100
  if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
#line 101
    return (0);
  }
  {
#line 103
  size = (size_t )0;
#line 105
  memcpy((void *)data, (void const   *)psf->broadcast_16k, size);
  }
#line 107
  return (1);
}
}
#line 114 "/root/patchweave_donee/23/src/broadcast.c"
static int gen_coding_history(char *added_history , int added_history_max , SF_INFO *psfinfo ) 
{ 
  char chnstr[16] ;
  int count___0 ;
  int width ;

  {
#line 137
  if (psfinfo->channels == 0) {
#line 137
    goto case_0;
  }
#line 140
  if (psfinfo->channels == 1) {
#line 140
    goto case_1;
  }
#line 144
  if (psfinfo->channels == 2) {
#line 144
    goto case_2;
  }
#line 148
  goto switch_default;
  case_0: 
#line 138
  return (0);
  case_1: 
  {
#line 141
  psf_strlcpy(chnstr, sizeof(chnstr), "mono");
  }
#line 142
  goto switch_break;
  case_2: 
  {
#line 145
  psf_strlcpy(chnstr, sizeof(chnstr), "stereo");
  }
#line 146
  goto switch_break;
  switch_default: 
  {
#line 149
  snprintf(chnstr, sizeof(chnstr), "%uchn", psfinfo->channels);
  }
#line 150
  goto switch_break;
  switch_break: ;
#line 155
  if ((psfinfo->format & 65535) == 1) {
#line 155
    goto case_1___0;
  }
#line 155
  if ((psfinfo->format & 65535) == 5) {
#line 155
    goto case_1___0;
  }
#line 158
  if ((psfinfo->format & 65535) == 2) {
#line 158
    goto case_2___0;
  }
#line 161
  if ((psfinfo->format & 65535) == 3) {
#line 161
    goto case_3;
  }
#line 164
  if ((psfinfo->format & 65535) == 4) {
#line 164
    goto case_4;
  }
#line 167
  if ((psfinfo->format & 65535) == 6) {
#line 167
    goto case_6;
  }
#line 170
  if ((psfinfo->format & 65535) == 7) {
#line 170
    goto case_7;
  }
#line 174
  if ((psfinfo->format & 65535) == 17) {
#line 174
    goto case_17;
  }
#line 174
  if ((psfinfo->format & 65535) == 16) {
#line 174
    goto case_17;
  }
#line 177
  goto switch_default___0;
  case_1___0: 
#line 156
  width = 8;
#line 157
  goto switch_break___0;
  case_2___0: 
#line 159
  width = 16;
#line 160
  goto switch_break___0;
  case_3: 
#line 162
  width = 24;
#line 163
  goto switch_break___0;
  case_4: 
#line 165
  width = 32;
#line 166
  goto switch_break___0;
  case_6: 
#line 168
  width = 24;
#line 169
  goto switch_break___0;
  case_7: 
#line 171
  width = 53;
#line 172
  goto switch_break___0;
  case_17: 
#line 175
  width = 12;
#line 176
  goto switch_break___0;
  switch_default___0: 
#line 178
  width = 42;
#line 179
  goto switch_break___0;
  switch_break___0: 
  {
#line 182
  count___0 = snprintf(added_history, (unsigned long )added_history_max, "A=PCM,F=%u,W=%d,M=%s,T=%s-%s\r\n",
                       psfinfo->samplerate, width, chnstr, "libsndfilef\324\204U",
                       "1.0.26");
  }
#line 186
  if (count___0 >= added_history_max) {
#line 187
    return (0);
  }
#line 189
  return (count___0);
}
}
#line 42 "/root/patchweave_donee/23/src/audio_detect.c"
static void vote_for_format(VOTE *vote , unsigned char const   *data , int datalen ) ;
#line 45 "/root/patchweave_donee/23/src/audio_detect.c"
int audio_detect(SF_PRIVATE *psf , AUDIO_DETECT *ad , unsigned char const   *data ,
                 int datalen ) 
{ 
  VOTE vote ;

  {
#line 48
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 49
    return (0);
  }
#line 51
  if ((unsigned long )ad == (unsigned long )((void *)0)) {
#line 52
    return (0);
  } else
#line 51
  if (datalen < 256) {
#line 52
    return (0);
  }
  {
#line 54
  vote_for_format(& vote, data, datalen);
#line 56
  psf_log_printf(psf, "audio_detect :\n    le_float     : %d\n    be_float     : %d\n    le_int_24_32 : %d\n    be_int_24_32 : %d\n",
                 vote.le_float, vote.be_float, vote.le_int_24_32, vote.be_int_24_32);
  }
#line 65
  if (ad->endianness == 268435456) {
#line 65
    if (vote.le_float > (3 * datalen) / 4) {
#line 67
      return (6);
    }
  }
#line 70
  if (ad->endianness == 268435456) {
#line 70
    if (vote.le_int_24_32 > (3 * datalen) / 4) {
#line 72
      return (4);
    }
  }
#line 75
  return (0);
}
}
#line 79 "/root/patchweave_donee/23/src/audio_detect.c"
static void vote_for_format(VOTE *vote , unsigned char const   *data , int datalen ) 
{ 
  int k ;

  {
  {
#line 83
  memset((void *)vote, 0, sizeof(VOTE ));
#line 85
  datalen -= datalen % 4;
#line 87
  k = 0;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;

#line 87
    if (! (k < datalen)) {
#line 87
      goto while_break;
    }
#line 88
    if (k % 4 == 0) {
#line 89
      if ((int )*(data + k) == 0) {
#line 89
        if ((int )*(data + (k + 1)) != 0) {
#line 90
          vote->le_int_24_32 += 4;
        }
      }
#line 92
      if ((int )*(data + 2) != 0) {
#line 92
        if ((int )*(data + 3) == 0) {
#line 93
          vote->le_int_24_32 += 4;
        }
      }
#line 95
      if ((int )*(data + 0) != 0) {
#line 95
        if ((int )*(data + 3) > 67) {
#line 95
          if ((int )*(data + 3) < 75) {
#line 96
            vote->le_float += 4;
          }
        }
      }
#line 98
      if ((int )*(data + 3) != 0) {
#line 98
        if ((int )*(data + 0) > 67) {
#line 98
          if ((int )*(data + 0) < 75) {
#line 99
            vote->be_float += 4;
          }
        }
      }
    }
#line 87
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 103
  return;
}
}
#line 26 "/root/patchweave_donee/23/src/alaw.c"
static sf_count_t alaw_read_alaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 27
static sf_count_t alaw_read_alaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 28
static sf_count_t alaw_read_alaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 29
static sf_count_t alaw_read_alaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 31
static sf_count_t alaw_write_s2alaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 32
static sf_count_t alaw_write_i2alaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 33
static sf_count_t alaw_write_f2alaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 34
static sf_count_t alaw_write_d2alaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 36
__inline static void alaw2s_array(unsigned char *buffer , int count___0 , short *ptr ) ;
#line 37
__inline static void alaw2i_array(unsigned char *buffer , int count___0 , int *ptr ) ;
#line 38
__inline static void alaw2f_array(unsigned char *buffer , int count___0 , float *ptr ,
                                  float normfact ) ;
#line 39
__inline static void alaw2d_array(unsigned char *buffer , int count___0 , double *ptr ,
                                  double normfact ) ;
#line 41
__inline static void s2alaw_array(short const   *ptr , int count___0 , unsigned char *buffer ) ;
#line 42
__inline static void i2alaw_array(int const   *ptr , int count___0 , unsigned char *buffer ) ;
#line 43
__inline static void f2alaw_array(float const   *ptr , int count___0 , unsigned char *buffer ,
                                  float normfact ) ;
#line 44
__inline static void d2alaw_array(double const   *ptr , int count___0 , unsigned char *buffer ,
                                  double normfact ) ;
#line 48 "/root/patchweave_donee/23/src/alaw.c"
int alaw_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;
  sf_count_t tmp___0 ;

  {
#line 50
  if (psf->file.mode == 16) {
#line 51
    psf->read_short = & alaw_read_alaw2s;
#line 52
    psf->read_int = & alaw_read_alaw2i;
#line 53
    psf->read_float = & alaw_read_alaw2f;
#line 54
    psf->read_double = & alaw_read_alaw2d;
  } else
#line 50
  if (psf->file.mode == 48) {
#line 51
    psf->read_short = & alaw_read_alaw2s;
#line 52
    psf->read_int = & alaw_read_alaw2i;
#line 53
    psf->read_float = & alaw_read_alaw2f;
#line 54
    psf->read_double = & alaw_read_alaw2d;
  }
#line 57
  if (psf->file.mode == 32) {
#line 58
    psf->write_short = & alaw_write_s2alaw;
#line 59
    psf->write_int = & alaw_write_i2alaw;
#line 60
    psf->write_float = & alaw_write_f2alaw;
#line 61
    psf->write_double = & alaw_write_d2alaw;
  } else
#line 57
  if (psf->file.mode == 48) {
#line 58
    psf->write_short = & alaw_write_s2alaw;
#line 59
    psf->write_int = & alaw_write_i2alaw;
#line 60
    psf->write_float = & alaw_write_f2alaw;
#line 61
    psf->write_double = & alaw_write_d2alaw;
  }
#line 64
  psf->bytewidth = 1;
#line 65
  psf->blockwidth = psf->sf.channels;
#line 67
  if (psf->filelength > psf->dataoffset) {
#line 68
    if (psf->dataend) {
#line 68
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 68
      tmp = psf->filelength - psf->dataoffset;
    }
#line 68
    psf->datalength = tmp;
  } else {
#line 70
    psf->datalength = (sf_count_t )0;
  }
#line 72
  if (psf->blockwidth > 0) {
#line 72
    tmp___0 = psf->datalength / (long )psf->blockwidth;
  } else {
#line 72
    tmp___0 = 0L;
  }
#line 72
  psf->sf.frames = tmp___0;
#line 74
  return (0);
}
}
#line 82 "/root/patchweave_donee/23/src/alaw.c"
static short alaw_decode[256]  = 
#line 82
  {      (short)-5504,      (short)-5248,      (short)-6016,      (short)-5760, 
        (short)-4480,      (short)-4224,      (short)-4992,      (short)-4736, 
        (short)-7552,      (short)-7296,      (short)-8064,      (short)-7808, 
        (short)-6528,      (short)-6272,      (short)-7040,      (short)-6784, 
        (short)-2752,      (short)-2624,      (short)-3008,      (short)-2880, 
        (short)-2240,      (short)-2112,      (short)-2496,      (short)-2368, 
        (short)-3776,      (short)-3648,      (short)-4032,      (short)-3904, 
        (short)-3264,      (short)-3136,      (short)-3520,      (short)-3392, 
        (short)-22016,      (short)-20992,      (short)-24064,      (short)-23040, 
        (short)-17920,      (short)-16896,      (short)-19968,      (short)-18944, 
        (short)-30208,      (short)-29184,      (short)-32256,      (short)-31232, 
        (short)-26112,      (short)-25088,      (short)-28160,      (short)-27136, 
        (short)-11008,      (short)-10496,      (short)-12032,      (short)-11520, 
        (short)-8960,      (short)-8448,      (short)-9984,      (short)-9472, 
        (short)-15104,      (short)-14592,      (short)-16128,      (short)-15616, 
        (short)-13056,      (short)-12544,      (short)-14080,      (short)-13568, 
        (short)-344,      (short)-328,      (short)-376,      (short)-360, 
        (short)-280,      (short)-264,      (short)-312,      (short)-296, 
        (short)-472,      (short)-456,      (short)-504,      (short)-488, 
        (short)-408,      (short)-392,      (short)-440,      (short)-424, 
        (short)-88,      (short)-72,      (short)-120,      (short)-104, 
        (short)-24,      (short)-8,      (short)-56,      (short)-40, 
        (short)-216,      (short)-200,      (short)-248,      (short)-232, 
        (short)-152,      (short)-136,      (short)-184,      (short)-168, 
        (short)-1376,      (short)-1312,      (short)-1504,      (short)-1440, 
        (short)-1120,      (short)-1056,      (short)-1248,      (short)-1184, 
        (short)-1888,      (short)-1824,      (short)-2016,      (short)-1952, 
        (short)-1632,      (short)-1568,      (short)-1760,      (short)-1696, 
        (short)-688,      (short)-656,      (short)-752,      (short)-720, 
        (short)-560,      (short)-528,      (short)-624,      (short)-592, 
        (short)-944,      (short)-912,      (short)-1008,      (short)-976, 
        (short)-816,      (short)-784,      (short)-880,      (short)-848, 
        (short)5504,      (short)5248,      (short)6016,      (short)5760, 
        (short)4480,      (short)4224,      (short)4992,      (short)4736, 
        (short)7552,      (short)7296,      (short)8064,      (short)7808, 
        (short)6528,      (short)6272,      (short)7040,      (short)6784, 
        (short)2752,      (short)2624,      (short)3008,      (short)2880, 
        (short)2240,      (short)2112,      (short)2496,      (short)2368, 
        (short)3776,      (short)3648,      (short)4032,      (short)3904, 
        (short)3264,      (short)3136,      (short)3520,      (short)3392, 
        (short)22016,      (short)20992,      (short)24064,      (short)23040, 
        (short)17920,      (short)16896,      (short)19968,      (short)18944, 
        (short)30208,      (short)29184,      (short)32256,      (short)31232, 
        (short)26112,      (short)25088,      (short)28160,      (short)27136, 
        (short)11008,      (short)10496,      (short)12032,      (short)11520, 
        (short)8960,      (short)8448,      (short)9984,      (short)9472, 
        (short)15104,      (short)14592,      (short)16128,      (short)15616, 
        (short)13056,      (short)12544,      (short)14080,      (short)13568, 
        (short)344,      (short)328,      (short)376,      (short)360, 
        (short)280,      (short)264,      (short)312,      (short)296, 
        (short)472,      (short)456,      (short)504,      (short)488, 
        (short)408,      (short)392,      (short)440,      (short)424, 
        (short)88,      (short)72,      (short)120,      (short)104, 
        (short)24,      (short)8,      (short)56,      (short)40, 
        (short)216,      (short)200,      (short)248,      (short)232, 
        (short)152,      (short)136,      (short)184,      (short)168, 
        (short)1376,      (short)1312,      (short)1504,      (short)1440, 
        (short)1120,      (short)1056,      (short)1248,      (short)1184, 
        (short)1888,      (short)1824,      (short)2016,      (short)1952, 
        (short)1632,      (short)1568,      (short)1760,      (short)1696, 
        (short)688,      (short)656,      (short)752,      (short)720, 
        (short)560,      (short)528,      (short)624,      (short)592, 
        (short)944,      (short)912,      (short)1008,      (short)976, 
        (short)816,      (short)784,      (short)880,      (short)848};
#line 118 "/root/patchweave_donee/23/src/alaw.c"
static unsigned char alaw_encode[2049]  = 
#line 118
  {      (unsigned char)213,      (unsigned char)212,      (unsigned char)215,      (unsigned char)214, 
        (unsigned char)209,      (unsigned char)208,      (unsigned char)211,      (unsigned char)210, 
        (unsigned char)221,      (unsigned char)220,      (unsigned char)223,      (unsigned char)222, 
        (unsigned char)217,      (unsigned char)216,      (unsigned char)219,      (unsigned char)218, 
        (unsigned char)197,      (unsigned char)196,      (unsigned char)199,      (unsigned char)198, 
        (unsigned char)193,      (unsigned char)192,      (unsigned char)195,      (unsigned char)194, 
        (unsigned char)205,      (unsigned char)204,      (unsigned char)207,      (unsigned char)206, 
        (unsigned char)201,      (unsigned char)200,      (unsigned char)203,      (unsigned char)202, 
        (unsigned char)245,      (unsigned char)245,      (unsigned char)244,      (unsigned char)244, 
        (unsigned char)247,      (unsigned char)247,      (unsigned char)246,      (unsigned char)246, 
        (unsigned char)241,      (unsigned char)241,      (unsigned char)240,      (unsigned char)240, 
        (unsigned char)243,      (unsigned char)243,      (unsigned char)242,      (unsigned char)242, 
        (unsigned char)253,      (unsigned char)253,      (unsigned char)252,      (unsigned char)252, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)254,      (unsigned char)254, 
        (unsigned char)249,      (unsigned char)249,      (unsigned char)248,      (unsigned char)248, 
        (unsigned char)251,      (unsigned char)251,      (unsigned char)250,      (unsigned char)250, 
        (unsigned char)229,      (unsigned char)229,      (unsigned char)229,      (unsigned char)229, 
        (unsigned char)228,      (unsigned char)228,      (unsigned char)228,      (unsigned char)228, 
        (unsigned char)231,      (unsigned char)231,      (unsigned char)231,      (unsigned char)231, 
        (unsigned char)230,      (unsigned char)230,      (unsigned char)230,      (unsigned char)230, 
        (unsigned char)225,      (unsigned char)225,      (unsigned char)225,      (unsigned char)225, 
        (unsigned char)224,      (unsigned char)224,      (unsigned char)224,      (unsigned char)224, 
        (unsigned char)227,      (unsigned char)227,      (unsigned char)227,      (unsigned char)227, 
        (unsigned char)226,      (unsigned char)226,      (unsigned char)226,      (unsigned char)226, 
        (unsigned char)237,      (unsigned char)237,      (unsigned char)237,      (unsigned char)237, 
        (unsigned char)236,      (unsigned char)236,      (unsigned char)236,      (unsigned char)236, 
        (unsigned char)239,      (unsigned char)239,      (unsigned char)239,      (unsigned char)239, 
        (unsigned char)238,      (unsigned char)238,      (unsigned char)238,      (unsigned char)238, 
        (unsigned char)233,      (unsigned char)233,      (unsigned char)233,      (unsigned char)233, 
        (unsigned char)232,      (unsigned char)232,      (unsigned char)232,      (unsigned char)232, 
        (unsigned char)235,      (unsigned char)235,      (unsigned char)235,      (unsigned char)235, 
        (unsigned char)234,      (unsigned char)234,      (unsigned char)234,      (unsigned char)234, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)149,      (unsigned char)149,      (unsigned char)149,      (unsigned char)149, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)148,      (unsigned char)148,      (unsigned char)148,      (unsigned char)148, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)151,      (unsigned char)151,      (unsigned char)151,      (unsigned char)151, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)150,      (unsigned char)150,      (unsigned char)150,      (unsigned char)150, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)145,      (unsigned char)145,      (unsigned char)145,      (unsigned char)145, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)144,      (unsigned char)144,      (unsigned char)144,      (unsigned char)144, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)147,      (unsigned char)147,      (unsigned char)147,      (unsigned char)147, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)146,      (unsigned char)146,      (unsigned char)146,      (unsigned char)146, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)157,      (unsigned char)157,      (unsigned char)157,      (unsigned char)157, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)156,      (unsigned char)156,      (unsigned char)156,      (unsigned char)156, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)159,      (unsigned char)159,      (unsigned char)159,      (unsigned char)159, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)158,      (unsigned char)158,      (unsigned char)158,      (unsigned char)158, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)153,      (unsigned char)153,      (unsigned char)153,      (unsigned char)153, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)152,      (unsigned char)152,      (unsigned char)152,      (unsigned char)152, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)155,      (unsigned char)155,      (unsigned char)155,      (unsigned char)155, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)154,      (unsigned char)154,      (unsigned char)154,      (unsigned char)154, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)133,      (unsigned char)133,      (unsigned char)133,      (unsigned char)133, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)132,      (unsigned char)132,      (unsigned char)132,      (unsigned char)132, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)135,      (unsigned char)135,      (unsigned char)135,      (unsigned char)135, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)134,      (unsigned char)134,      (unsigned char)134,      (unsigned char)134, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)129,      (unsigned char)129,      (unsigned char)129,      (unsigned char)129, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)131,      (unsigned char)131,      (unsigned char)131,      (unsigned char)131, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)130,      (unsigned char)130,      (unsigned char)130,      (unsigned char)130, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)141,      (unsigned char)141,      (unsigned char)141,      (unsigned char)141, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)140,      (unsigned char)140,      (unsigned char)140,      (unsigned char)140, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)143,      (unsigned char)143,      (unsigned char)143,      (unsigned char)143, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)142,      (unsigned char)142,      (unsigned char)142,      (unsigned char)142, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)137,      (unsigned char)137,      (unsigned char)137,      (unsigned char)137, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)136,      (unsigned char)136,      (unsigned char)136,      (unsigned char)136, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)139,      (unsigned char)139,      (unsigned char)139,      (unsigned char)139, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)138,      (unsigned char)138,      (unsigned char)138,      (unsigned char)138, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)181,      (unsigned char)181,      (unsigned char)181,      (unsigned char)181, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)180,      (unsigned char)180,      (unsigned char)180,      (unsigned char)180, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)183,      (unsigned char)183,      (unsigned char)183,      (unsigned char)183, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)182,      (unsigned char)182,      (unsigned char)182,      (unsigned char)182, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)177,      (unsigned char)177,      (unsigned char)177,      (unsigned char)177, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)176,      (unsigned char)176,      (unsigned char)176,      (unsigned char)176, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)179,      (unsigned char)179,      (unsigned char)179,      (unsigned char)179, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)178,      (unsigned char)178,      (unsigned char)178,      (unsigned char)178, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)189,      (unsigned char)189,      (unsigned char)189,      (unsigned char)189, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)188,      (unsigned char)188,      (unsigned char)188,      (unsigned char)188, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)191,      (unsigned char)191,      (unsigned char)191,      (unsigned char)191, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)190,      (unsigned char)190,      (unsigned char)190,      (unsigned char)190, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)185,      (unsigned char)185,      (unsigned char)185,      (unsigned char)185, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)184,      (unsigned char)184,      (unsigned char)184,      (unsigned char)184, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)187,      (unsigned char)187,      (unsigned char)187,      (unsigned char)187, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)186,      (unsigned char)186,      (unsigned char)186,      (unsigned char)186, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)165,      (unsigned char)165,      (unsigned char)165,      (unsigned char)165, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)164,      (unsigned char)164,      (unsigned char)164,      (unsigned char)164, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)167,      (unsigned char)167,      (unsigned char)167,      (unsigned char)167, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)166,      (unsigned char)166,      (unsigned char)166,      (unsigned char)166, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)161,      (unsigned char)161,      (unsigned char)161,      (unsigned char)161, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)160,      (unsigned char)160,      (unsigned char)160,      (unsigned char)160, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)163,      (unsigned char)163,      (unsigned char)163,      (unsigned char)163, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)162,      (unsigned char)162,      (unsigned char)162,      (unsigned char)162, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)173,      (unsigned char)173,      (unsigned char)173,      (unsigned char)173, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)172,      (unsigned char)172,      (unsigned char)172,      (unsigned char)172, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)175,      (unsigned char)175,      (unsigned char)175,      (unsigned char)175, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)174,      (unsigned char)174,      (unsigned char)174,      (unsigned char)174, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)169,      (unsigned char)169,      (unsigned char)169,      (unsigned char)169, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)168,      (unsigned char)168,      (unsigned char)168,      (unsigned char)168, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)171,      (unsigned char)171,      (unsigned char)171,      (unsigned char)171, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170,      (unsigned char)170,      (unsigned char)170,      (unsigned char)170, 
        (unsigned char)170};
#line 293 "/root/patchweave_donee/23/src/alaw.c"
__inline static void alaw2s_array(unsigned char *buffer , int count___0 , short *ptr ) 
{ 


  {
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    count___0 --;
#line 294
    if (! (count___0 >= 0)) {
#line 294
      goto while_break;
    }
#line 295
    *(ptr + count___0) = alaw_decode[(int )*(buffer + count___0)];
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 299
  return;
}
}
#line 299 "/root/patchweave_donee/23/src/alaw.c"
__inline static void alaw2i_array(unsigned char *buffer , int count___0 , int *ptr ) 
{ 


  {
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    count___0 --;
#line 300
    if (! (count___0 >= 0)) {
#line 300
      goto while_break;
    }
#line 301
    *(ptr + count___0) = (int )((uint32_t )alaw_decode[(int )*(buffer + count___0)] << 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 305
  return;
}
}
#line 305 "/root/patchweave_donee/23/src/alaw.c"
__inline static void alaw2f_array(unsigned char *buffer , int count___0 , float *ptr ,
                                  float normfact ) 
{ 


  {
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    count___0 --;
#line 306
    if (! (count___0 >= 0)) {
#line 306
      goto while_break;
    }
#line 307
    *(ptr + count___0) = normfact * (float )((int )alaw_decode[(int )*(buffer + count___0)]);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 311
  return;
}
}
#line 311 "/root/patchweave_donee/23/src/alaw.c"
__inline static void alaw2d_array(unsigned char *buffer , int count___0 , double *ptr ,
                                  double normfact ) 
{ 


  {
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    count___0 --;
#line 312
    if (! (count___0 >= 0)) {
#line 312
      goto while_break;
    }
#line 313
    *(ptr + count___0) = normfact * (double )((int )alaw_decode[(int )*(buffer + count___0)]);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 317
  return;
}
}
#line 317 "/root/patchweave_donee/23/src/alaw.c"
__inline static void s2alaw_array(short const   *ptr , int count___0 , unsigned char *buffer ) 
{ 


  {
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    count___0 --;
#line 318
    if (! (count___0 >= 0)) {
#line 318
      goto while_break;
    }
#line 319
    if ((int )*(ptr + count___0) >= 0) {
#line 320
      *(buffer + count___0) = alaw_encode[(int )*(ptr + count___0) / 16];
    } else {
#line 322
      *(buffer + count___0) = (unsigned char )(127 & (int )alaw_encode[(int )*(ptr + count___0) / -16]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 328
  return;
}
}
#line 327 "/root/patchweave_donee/23/src/alaw.c"
__inline static void i2alaw_array(int const   *ptr , int count___0 , unsigned char *buffer ) 
{ 


  {
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    count___0 --;
#line 328
    if (! (count___0 >= 0)) {
#line 328
      goto while_break;
    }
#line 329
    if (*(ptr + count___0) >= 0) {
#line 330
      *(buffer + count___0) = alaw_encode[*(ptr + count___0) >> 20];
    } else {
#line 332
      *(buffer + count___0) = (unsigned char )(127 & (int )alaw_encode[- *(ptr + count___0) >> 20]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 338
  return;
}
}
#line 337 "/root/patchweave_donee/23/src/alaw.c"
__inline static void f2alaw_array(float const   *ptr , int count___0 , unsigned char *buffer ,
                                  float normfact ) 
{ 
  long __cil_tmp6 ;
  long tmp ;

  {
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    count___0 --;
#line 338
    if (! (count___0 >= 0)) {
#line 338
      goto while_break;
    }
#line 339
    if (*(ptr + count___0) >= (float const   )((float )0)) {
      {
#line 340
      tmp = lrintf(normfact * (float )*(ptr + count___0));
#line 340
      *(buffer + count___0) = (unsigned char )tmp;
      }
    } else {
      {
#line 342
      __cil_tmp6 = lrintf(normfact * (float )*(ptr + count___0));
#line 342
      *(buffer + count___0) = (unsigned char )(127 & (int )alaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 349
  return;
}
}
#line 347 "/root/patchweave_donee/23/src/alaw.c"
__inline static void d2alaw_array(double const   *ptr , int count___0 , unsigned char *buffer ,
                                  double normfact ) 
{ 
  long __cil_tmp6 ;
  long tmp ;

  {
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    count___0 --;
#line 348
    if (! (count___0 >= 0)) {
#line 348
      goto while_break;
    }
#line 349
    if (*(ptr + count___0) >= (double const   )((double )0)) {
      {
#line 350
      tmp = lrint(normfact * (double )*(ptr + count___0));
#line 350
      *(buffer + count___0) = (unsigned char )tmp;
      }
    } else {
      {
#line 352
      __cil_tmp6 = lrint(normfact * (double )*(ptr + count___0));
#line 352
      *(buffer + count___0) = (unsigned char )(127 & (int )alaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 359
  return;
}
}
#line 360 "/root/patchweave_donee/23/src/alaw.c"
static sf_count_t alaw_read_alaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 363
  total = (sf_count_t )0;
#line 365
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;

#line 367
    if (! (len > 0L)) {
#line 367
      goto while_break;
    }
#line 368
    if (len < (long )bufferlen) {
#line 369
      bufferlen = (int )len;
    }
    {
#line 370
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 370
    readcount = (int )__cil_tmp8;
#line 371
    alaw2s_array(ubuf.ucbuf, readcount, ptr + total);
#line 372
    total += (long )readcount;
    }
#line 373
    if (readcount < bufferlen) {
#line 374
      goto while_break;
    }
#line 375
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 378
  return (total);
}
}
#line 382 "/root/patchweave_donee/23/src/alaw.c"
static sf_count_t alaw_read_alaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 385
  total = (sf_count_t )0;
#line 387
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;

#line 389
    if (! (len > 0L)) {
#line 389
      goto while_break;
    }
#line 390
    if (len < (long )bufferlen) {
#line 391
      bufferlen = (int )len;
    }
    {
#line 392
    __cil_tmp8 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 392
    readcount = (int )__cil_tmp8;
#line 393
    alaw2i_array(ubuf.ucbuf, readcount, ptr + total);
#line 394
    total += (long )readcount;
    }
#line 395
    if (readcount < bufferlen) {
#line 396
      goto while_break;
    }
#line 397
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 400
  return (total);
}
}
#line 404 "/root/patchweave_donee/23/src/alaw.c"
static sf_count_t alaw_read_alaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 407
  total = (sf_count_t )0;
#line 410
  if (psf->norm_float == 1) {
#line 410
    tmp = 1. / (double )((float )32768);
  } else {
#line 410
    tmp = 1.;
  }
#line 410
  normfact = (float )tmp;
#line 412
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;

#line 414
    if (! (len > 0L)) {
#line 414
      goto while_break;
    }
#line 415
    if (len < (long )bufferlen) {
#line 416
      bufferlen = (int )len;
    }
    {
#line 417
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 417
    readcount = (int )__cil_tmp10;
#line 418
    alaw2f_array(ubuf.ucbuf, readcount, ptr + total, normfact);
#line 419
    total += (long )readcount;
    }
#line 420
    if (readcount < bufferlen) {
#line 421
      goto while_break;
    }
#line 422
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 425
  return (total);
}
}
#line 429 "/root/patchweave_donee/23/src/alaw.c"
static sf_count_t alaw_read_alaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 432
  total = (sf_count_t )0;
#line 435
  if (psf->norm_double) {
#line 435
    tmp = 1. / (double )32768;
  } else {
#line 435
    tmp = 1.;
  }
#line 435
  normfact = tmp;
#line 436
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;

#line 438
    if (! (len > 0L)) {
#line 438
      goto while_break;
    }
#line 439
    if (len < (long )bufferlen) {
#line 440
      bufferlen = (int )len;
    }
    {
#line 441
    __cil_tmp10 = psf_fread((void *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 441
    readcount = (int )__cil_tmp10;
#line 442
    alaw2d_array(ubuf.ucbuf, readcount, ptr + total, normfact);
#line 443
    total += (long )readcount;
    }
#line 444
    if (readcount < bufferlen) {
#line 445
      goto while_break;
    }
#line 446
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 449
  return (total);
}
}
#line 456 "/root/patchweave_donee/23/src/alaw.c"
static sf_count_t alaw_write_s2alaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 459
  total = (sf_count_t )0;
#line 461
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;

#line 463
    if (! (len > 0L)) {
#line 463
      goto while_break;
    }
#line 464
    if (len < (long )bufferlen) {
#line 465
      bufferlen = (int )len;
    }
    {
#line 466
    s2alaw_array(ptr + total, bufferlen, ubuf.ucbuf);
#line 467
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 467
    writecount = (int )__cil_tmp8;
#line 468
    total += (long )writecount;
    }
#line 469
    if (writecount < bufferlen) {
#line 470
      goto while_break;
    }
#line 471
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 474
  return (total);
}
}
#line 478 "/root/patchweave_donee/23/src/alaw.c"
static sf_count_t alaw_write_i2alaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 481
  total = (sf_count_t )0;
#line 483
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;

#line 485
    if (! (len > 0L)) {
#line 485
      goto while_break;
    }
#line 486
    if (len < (long )bufferlen) {
#line 487
      bufferlen = (int )len;
    }
    {
#line 488
    i2alaw_array(ptr + total, bufferlen, ubuf.ucbuf);
#line 489
    __cil_tmp8 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 489
    writecount = (int )__cil_tmp8;
#line 490
    total += (long )writecount;
    }
#line 491
    if (writecount < bufferlen) {
#line 492
      goto while_break;
    }
#line 493
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 496
  return (total);
}
}
#line 500 "/root/patchweave_donee/23/src/alaw.c"
static sf_count_t alaw_write_f2alaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 503
  total = (sf_count_t )0;
#line 506
  if (psf->norm_float == 1) {
#line 506
    tmp = (1. * (double )32767) / 16.;
  } else {
#line 506
    tmp = 1. / (double )16;
  }
#line 506
  normfact = (float )tmp;
#line 508
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;

#line 510
    if (! (len > 0L)) {
#line 510
      goto while_break;
    }
#line 511
    if (len < (long )bufferlen) {
#line 512
      bufferlen = (int )len;
    }
    {
#line 513
    f2alaw_array(ptr + total, bufferlen, ubuf.ucbuf, normfact);
#line 514
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                             psf);
#line 514
    writecount = (int )__cil_tmp10;
#line 515
    total += (long )writecount;
    }
#line 516
    if (writecount < bufferlen) {
#line 517
      goto while_break;
    }
#line 518
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 521
  return (total);
}
}
#line 525 "/root/patchweave_donee/23/src/alaw.c"
static sf_count_t alaw_write_d2alaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 528
  total = (sf_count_t )0;
#line 531
  if (psf->norm_double) {
#line 531
    tmp = (1. * (double )32767) / 16.;
  } else {
#line 531
    tmp = 1. / 16.;
  }
#line 531
  normfact = tmp;
#line 533
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;

#line 535
    if (! (len > 0L)) {
#line 535
      goto while_break;
    }
#line 536
    if (len < (long )bufferlen) {
#line 537
      bufferlen = (int )len;
    }
    {
#line 538
    d2alaw_array(ptr + total, bufferlen, ubuf.ucbuf, normfact);
#line 539
    __cil_tmp10 = psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, (sf_count_t )bufferlen,
                             psf);
#line 539
    writecount = (int )__cil_tmp10;
#line 540
    total += (long )writecount;
    }
#line 541
    if (writecount < bufferlen) {
#line 542
      goto while_break;
    }
#line 543
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 546
  return (total);
}
}
#line 88 "/root/patchweave_donee/23/src/ALAC/alac_codec.h"
int32_t alac_decoder_init(ALAC_DECODER *p , void *inMagicCookie , uint32_t inMagicCookieSize ) ;
#line 89
int32_t alac_encoder_init(ALAC_ENCODER *p , uint32_t samplerate , uint32_t channels ,
                          uint32_t format_flags , uint32_t frameSize ) ;
#line 91
int32_t alac_decode(ALAC_DECODER *p , struct BitBuffer *bits , int32_t *sampleBuffer ,
                    uint32_t numSamples , uint32_t *outNumSamples ) ;
#line 94
int32_t alac_encode(ALAC_ENCODER *p , uint32_t numSamples , int32_t *theReadBuffer ,
                    unsigned char *theWriteBuffer , uint32_t *ioNumBytes ) ;
#line 98
void alac_set_fastmode(ALAC_ENCODER *p , int32_t fast ) ;
#line 100
uint32_t alac_get_magic_cookie_size(uint32_t inNumChannels ) ;
#line 101
void alac_get_magic_cookie(ALAC_ENCODER *p , void *outCookie , uint32_t *ioSize ) ;
#line 102
void alac_get_source_format(ALAC_ENCODER *p , AudioFormatDescription *source , AudioFormatDescription *output ) ;
#line 75 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.h"
void BitBufferInit(BitBuffer *bits , uint8_t *buffer , uint32_t byteSize ) ;
#line 76
uint32_t BitBufferRead(BitBuffer *bits , uint8_t numBits ) ;
#line 77
uint8_t BitBufferReadSmall(BitBuffer *bits , uint8_t numBits ) ;
#line 78
uint8_t BitBufferReadOne(BitBuffer *bits ) ;
#line 79
uint32_t BitBufferPeek(BitBuffer *bits , uint8_t numBits ) ;
#line 80
uint32_t BitBufferPeekOne(BitBuffer *bits ) ;
#line 81
uint32_t BitBufferUnpackBERSize(BitBuffer *bits ) ;
#line 82
uint32_t BitBufferGetPosition(BitBuffer *bits ) ;
#line 83
void BitBufferByteAlign(BitBuffer *bits , int32_t addZeros ) ;
#line 84
void BitBufferAdvance(BitBuffer *bits , uint32_t numBits ) ;
#line 85
void BitBufferRewind(BitBuffer *bits , uint32_t numBits ) ;
#line 86
void BitBufferWrite(BitBuffer *bits , uint32_t bitValues , uint32_t numBits ) ;
#line 87
void BitBufferReset(BitBuffer *bits ) ;
#line 71 "/root/patchweave_donee/23/src/alac.c"
static int alac_reader_init(SF_PRIVATE *psf , ALAC_DECODER_INFO *info ) ;
#line 72
static int alac_writer_init(SF_PRIVATE *psf ) ;
#line 74
static sf_count_t alac_reader_calc_frames(SF_PRIVATE *psf , ALAC_PRIVATE *plac ) ;
#line 76
static sf_count_t alac_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 77
static sf_count_t alac_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 78
static sf_count_t alac_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 79
static sf_count_t alac_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 81
static sf_count_t alac_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 82
static sf_count_t alac_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 83
static sf_count_t alac_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 84
static sf_count_t alac_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 86
static sf_count_t alac_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 88
static int alac_close(SF_PRIVATE *psf ) ;
#line 89
static int alac_byterate(SF_PRIVATE *psf ) ;
#line 91
static int alac_decode_block(SF_PRIVATE *psf , ALAC_PRIVATE *plac ) ;
#line 92
static int alac_encode_block(SF_PRIVATE *psf , ALAC_PRIVATE *plac ) ;
#line 94
static uint32_t alac_kuki_read(SF_PRIVATE *psf , uint32_t kuki_offset , uint8_t *kuki ,
                               size_t kuki_maxlen ) ;
#line 96
static PAKT_INFO *alac_pakt_alloc(uint32_t initial_count ) ;
#line 97
static PAKT_INFO *alac_pakt_read_decode(SF_PRIVATE *psf , uint32_t UNUSED_pakt_offset ) ;
#line 98
static PAKT_INFO *alac_pakt_append(PAKT_INFO *info , uint32_t value___0 ) ;
#line 99
static uint8_t *alac_pakt_encode(SF_PRIVATE *psf , uint32_t *pakt_size_out ) ;
#line 100
static sf_count_t alac_pakt_block_offset(PAKT_INFO *info , uint32_t block ) ;
#line 102
static char const   *alac_error_string(int error ) ;
#line 109 "/root/patchweave_donee/23/src/alac.c"
int alac_init(SF_PRIVATE *psf , ALAC_DECODER_INFO *info ) 
{ 
  int error ;

  {
  {
#line 112
  psf->codec_data = calloc(1UL, sizeof(ALAC_PRIVATE ) + ((unsigned long )psf->sf.channels * sizeof(int )) * 8192UL);
  }
#line 112
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 113
    return (17);
  }
#line 115
  psf->codec_close = & alac_close;
#line 118
  if (psf->file.mode == 48) {
#line 118
    goto case_48;
  }
#line 121
  if (psf->file.mode == 16) {
#line 121
    goto case_16;
  }
#line 126
  if (psf->file.mode == 32) {
#line 126
    goto case_32;
  }
#line 131
  goto switch_default;
  case_48: 
#line 119
  return (24);
  case_16: 
  {
#line 122
  error = alac_reader_init(psf, info);
  }
#line 122
  if (error) {
#line 123
    return (error);
  }
#line 124
  goto switch_break;
  case_32: 
  {
#line 127
  error = alac_writer_init(psf);
  }
#line 127
  if (error) {
#line 128
    return (error);
  }
#line 129
  goto switch_break;
  switch_default: 
  {
#line 132
  psf_log_printf(psf, "%s : Bad psf->file.mode.\n", "alac_init");
  }
#line 133
  return (30);
  switch_break: 
#line 136
  psf->byterate = & alac_byterate;
#line 138
  return (0);
}
}
#line 142 "/root/patchweave_donee/23/src/alac.c"
void alac_get_desc_chunk_items(int subformat , uint32_t *fmt_flags , uint32_t *frames_per_packet ) 
{ 


  {
#line 144
  if (subformat == 112) {
#line 144
    goto case_112;
  }
#line 147
  if (subformat == 113) {
#line 147
    goto case_113;
  }
#line 150
  if (subformat == 114) {
#line 150
    goto case_114;
  }
#line 153
  if (subformat == 115) {
#line 153
    goto case_115;
  }
#line 156
  goto switch_default;
  case_112: 
#line 145
  *fmt_flags = (uint32_t )1;
#line 146
  goto switch_break;
  case_113: 
#line 148
  *fmt_flags = (uint32_t )2;
#line 149
  goto switch_break;
  case_114: 
#line 151
  *fmt_flags = (uint32_t )3;
#line 152
  goto switch_break;
  case_115: 
#line 154
  *fmt_flags = (uint32_t )4;
#line 155
  goto switch_break;
  switch_default: 
#line 157
  goto switch_break;
  switch_break: 
#line 159
  *frames_per_packet = (uint32_t )4096;
#line 160
  return;
}
}
#line 163 "/root/patchweave_donee/23/src/alac.c"
static int alac_close(SF_PRIVATE *psf ) 
{ 
  ALAC_PRIVATE *plac ;
  BUF_UNION ubuf ;
  ALAC_ENCODER *penc ;
  SF_CHUNK_INFO chunk_info ;
  sf_count_t readcount ;
  uint8_t **kuki_data ;
  unsigned long __lengthofkuki_data ;
  void *tmp ;
  uint32_t pakt_size ;
  uint32_t saved_partial_block_frames ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp13 ;
  uint8_t *tmp___0 ;

  {
  {
#line 170
  __lengthofkuki_data = (unsigned long )plac->kuki_size;
#line 170
  tmp = __builtin_alloca(sizeof(*kuki_data) * __lengthofkuki_data);
#line 170
  kuki_data = (uint8_t **)tmp;
#line 167
  plac = (ALAC_PRIVATE *)psf->codec_data;
  }
#line 169
  if (psf->file.mode == 32) {
#line 170
    penc = & plac->__annonCompField4.encoder;
#line 174
    pakt_size = (uint32_t )0;
#line 176
    plac->final_write_block = 1;
#line 177
    saved_partial_block_frames = plac->partial_block_frames;
#line 180
    if (plac->partial_block_frames) {
#line 180
      if (plac->partial_block_frames < plac->frames_per_block) {
        {
#line 181
        alac_encode_block(psf, plac);
        }
      }
    }
    {
#line 183
    plac->partial_block_frames = saved_partial_block_frames;
#line 185
    alac_get_magic_cookie(penc, (void *)kuki_data, & plac->kuki_size);
#line 187
    memset((void *)(& chunk_info), 0, sizeof(chunk_info));
#line 188
    __cil_tmp10 = snprintf(chunk_info.id, sizeof(chunk_info.id), "kuki");
#line 188
    chunk_info.id_size = (unsigned int )__cil_tmp10;
#line 189
    chunk_info.data = (void *)kuki_data;
#line 190
    chunk_info.datalen = plac->kuki_size;
#line 191
    psf_save_write_chunk(& psf->wchunks, & chunk_info);
#line 193
    memset((void *)(& chunk_info), 0, sizeof(chunk_info));
#line 194
    __cil_tmp11 = snprintf(chunk_info.id, sizeof(chunk_info.id), "pakt");
#line 194
    chunk_info.id_size = (unsigned int )__cil_tmp11;
#line 195
    tmp___0 = alac_pakt_encode(psf, & pakt_size);
#line 195
    chunk_info.data = (void *)tmp___0;
#line 196
    chunk_info.datalen = pakt_size;
#line 197
    psf_save_write_chunk(& psf->wchunks, & chunk_info);
#line 199
    free(chunk_info.data);
#line 200
    chunk_info.data = (void *)0;
#line 202
    (*(psf->write_header))(psf, 1);
    }
#line 204
    if ((unsigned long )plac->enctmp != (unsigned long )((void *)0)) {
      {
#line 205
      fseek(plac->enctmp, 0L, 0);
      }
      {
#line 207
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 207
        __cil_tmp13 = fread((void *)(ubuf.ucbuf), 1UL, sizeof(ubuf.ucbuf), plac->enctmp);
#line 207
        readcount = (sf_count_t )__cil_tmp13;
        }
#line 207
        if (! (readcount > 0L)) {
#line 207
          goto while_break;
        }
        {
#line 208
        psf_fwrite((void const   *)(ubuf.ucbuf), (sf_count_t )1, readcount, psf);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 209
      fclose(plac->enctmp);
#line 210
      remove((char const   *)(plac->enctmpname));
      }
    }
  }
#line 214
  if (plac->pakt_info) {
    {
#line 215
    free((void *)plac->pakt_info);
    }
  }
#line 216
  plac->pakt_info = (PAKT_INFO *)((void *)0);
#line 218
  return (0);
}
}
#line 222 "/root/patchweave_donee/23/src/alac.c"
static int alac_byterate(SF_PRIVATE *psf ) 
{ 


  {
#line 224
  if (psf->file.mode == 16) {
#line 225
    return ((int )((psf->datalength * (long )psf->sf.samplerate) / psf->sf.frames));
  }
#line 227
  return (-1);
}
}
#line 235 "/root/patchweave_donee/23/src/alac.c"
static int alac_reader_init(SF_PRIVATE *psf , ALAC_DECODER_INFO *info ) 
{ 
  ALAC_PRIVATE *plac ;
  uint32_t kuki_size ;
  int error ;
  union __anonunion_861 u ;
  char const   *__cil_tmp10 ;

  {
#line 241
  if ((unsigned long )info == (unsigned long )((void *)0)) {
    {
#line 242
    psf_log_printf(psf, "%s : ALAC_DECODER_INFO is NULL.\n\320c\340\324\204U", "alac_reader_init\312\001@");
    }
#line 243
    return (30);
  }
#line 246
  if (info->frames_per_packet > 8192U) {
    {
#line 247
    psf_log_printf(psf, "*** Error : frames_per_packet (%u) is too big. ***\n", info->frames_per_packet);
    }
#line 248
    return (30);
  }
#line 251
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 253
  plac->channels = psf->sf.channels;
#line 254
  plac->frames_per_block = info->frames_per_packet;
#line 255
  plac->bits_per_sample = info->bits_per_sample;
#line 257
  if ((unsigned long )plac->pakt_info != (unsigned long )((void *)0)) {
    {
#line 258
    free((void *)plac->pakt_info);
    }
  }
  {
#line 259
  plac->pakt_info = alac_pakt_read_decode(psf, info->pakt_offset);
  }
#line 262
  if ((unsigned long )plac->pakt_info == (unsigned long )((void *)0)) {
    {
#line 263
    psf_log_printf(psf, "%s : alac_pkt_read() returns NULL.\n", "alac_reader_init\312\001@");
    }
#line 264
    return (17);
  }
  {
#line 268
  kuki_size = alac_kuki_read(psf, info->kuki_offset, u.kuki, sizeof(u.kuki));
#line 270
  error = alac_decoder_init(& plac->__annonCompField4.decoder, (void *)(u.kuki), kuki_size);
  }
#line 270
  if (error != 0) {
    {
#line 271
    __cil_tmp10 = alac_error_string(error);
#line 271
    psf_log_printf(psf, "*** alac_decoder_init() returned %s. ***\n", __cil_tmp10);
    }
#line 272
    return (30);
  }
#line 276
  if (plac->__annonCompField4.decoder.mNumChannels != (unsigned int )psf->sf.channels) {
    {
#line 277
    psf_log_printf(psf, "*** Initialized decoder has %u channels, but it should be %d. ***\n",
                   plac->__annonCompField4.decoder.mNumChannels, psf->sf.channels);
    }
#line 278
    return (30);
  }
#line 285
  if (info->bits_per_sample == 32U) {
#line 285
    goto case_32;
  }
#line 285
  if (info->bits_per_sample == 24U) {
#line 285
    goto case_32;
  }
#line 285
  if (info->bits_per_sample == 20U) {
#line 285
    goto case_32;
  }
#line 285
  if (info->bits_per_sample == 16U) {
#line 285
    goto case_32;
  }
#line 292
  goto switch_default;
  case_32: 
#line 286
  psf->read_short = & alac_read_s;
#line 287
  psf->read_int = & alac_read_i;
#line 288
  psf->read_float = & alac_read_f;
#line 289
  psf->read_double = & alac_read_d;
#line 290
  goto switch_break;
  switch_default: 
  {
#line 293
  printf("%s : info->bits_per_sample %u\n", "alac_reader_init\312\001@", info->bits_per_sample);
  }
#line 294
  return (4);
  switch_break: 
  {
#line 297
  psf->codec_close = & alac_close;
#line 298
  psf->seek = & alac_seek;
#line 300
  psf->sf.frames = alac_reader_calc_frames(psf, plac);
#line 301
  alac_seek(psf, 16, (sf_count_t )0);
  }
#line 303
  return (0);
}
}
#line 307 "/root/patchweave_donee/23/src/alac.c"
static int alac_writer_init(SF_PRIVATE *psf ) 
{ 
  ALAC_PRIVATE *plac ;
  uint32_t alac_format_flags ;
  int *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 309
  alac_format_flags = (uint32_t )0;
#line 311
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 313
  if (psf->file.mode != 32) {
#line 314
    return (24);
  }
  {
#line 316
  plac->channels = psf->sf.channels;
#line 317
  plac->kuki_size = alac_get_magic_cookie_size((uint32_t )psf->sf.channels);
#line 319
  psf->write_short = & alac_write_s;
#line 320
  psf->write_int = & alac_write_i;
#line 321
  psf->write_float = & alac_write_f;
#line 322
  psf->write_double = & alac_write_d;
  }
#line 325
  if ((psf->sf.format & 65535) == 112) {
#line 325
    goto case_112;
  }
#line 330
  if ((psf->sf.format & 65535) == 113) {
#line 330
    goto case_113;
  }
#line 335
  if ((psf->sf.format & 65535) == 114) {
#line 335
    goto case_114;
  }
#line 340
  if ((psf->sf.format & 65535) == 115) {
#line 340
    goto case_115;
  }
#line 345
  goto switch_default;
  case_112: 
#line 326
  alac_format_flags = (uint32_t )1;
#line 327
  plac->bits_per_sample = (uint32_t )16;
#line 328
  goto switch_break;
  case_113: 
#line 331
  alac_format_flags = (uint32_t )2;
#line 332
  plac->bits_per_sample = (uint32_t )20;
#line 333
  goto switch_break;
  case_114: 
#line 336
  alac_format_flags = (uint32_t )3;
#line 337
  plac->bits_per_sample = (uint32_t )24;
#line 338
  goto switch_break;
  case_115: 
#line 341
  alac_format_flags = (uint32_t )4;
#line 342
  plac->bits_per_sample = (uint32_t )32;
#line 343
  goto switch_break;
  switch_default: 
  {
#line 346
  psf_log_printf(psf, "%s : Can\'t figure out bits per sample.\n", "alac_writer_init\312\001\300\324\025\215\004");
  }
#line 347
  return (18);
  switch_break: 
  {
#line 350
  plac->frames_per_block = (uint32_t )4096;
#line 352
  plac->pakt_info = alac_pakt_alloc((uint32_t )2000);
#line 354
  plac->enctmp = psf_open_tmpfile(plac->enctmpname, sizeof(plac->enctmpname));
  }
#line 354
  if ((unsigned long )plac->enctmp == (unsigned long )((void *)0)) {
    {
#line 355
    __cil_tmp7 = __errno_location();
#line 355
    __cil_tmp8 = strerror(*__cil_tmp7);
#line 355
    psf_log_printf(psf, "Error : Failed to open temp file \'%s\' : \n\256\340\324\204U",
                   plac->enctmpname, __cil_tmp8);
    }
#line 356
    return (168);
  }
  {
#line 359
  alac_encoder_init(& plac->__annonCompField4.encoder, (uint32_t )psf->sf.samplerate,
                    (uint32_t )psf->sf.channels, alac_format_flags, (uint32_t )4096);
  }
#line 361
  return (0);
}
}
#line 369 "/root/patchweave_donee/23/src/alac.c"
__inline static uint32_t alac_reader_next_packet_size(PAKT_INFO *info ) 
{ 
  uint32_t __cil_tmp2 ;

  {
#line 370
  if (info->current >= info->count) {
#line 371
    return ((uint32_t )0);
  }
#line 372
  __cil_tmp2 = info->current;
#line 372
  (info->current) ++;
#line 372
  return (info->packet_size[__cil_tmp2]);
}
}
#line 376 "/root/patchweave_donee/23/src/alac.c"
static sf_count_t alac_reader_calc_frames(SF_PRIVATE *psf , ALAC_PRIVATE *plac ) 
{ 
  sf_count_t frames ;
  uint32_t current_pos ;
  uint32_t blocks ;
  uint32_t tmp ;

  {
#line 377
  frames = (sf_count_t )0;
#line 378
  current_pos = (uint32_t )1;
#line 378
  blocks = (uint32_t )0;
#line 380
  (plac->pakt_info)->current = (uint32_t )0;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;

#line 382
    if ((long )current_pos < psf->filelength) {
#line 382
      if (! (current_pos > 0U)) {
#line 382
        goto while_break;
      }
    } else {
#line 382
      goto while_break;
    }
    {
#line 383
    current_pos = alac_reader_next_packet_size(plac->pakt_info);
    }
#line 384
    if (current_pos > 0U) {
#line 384
      tmp = blocks + 1U;
    } else {
#line 384
      tmp = blocks;
    }
#line 384
    blocks = tmp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 387
  if (blocks == 0U) {
#line 388
    return ((sf_count_t )0);
  }
  {
#line 391
  frames = (sf_count_t )(plac->frames_per_block * (blocks - 1U));
#line 393
  alac_seek(psf, 16, frames);
#line 394
  alac_decode_block(psf, plac);
#line 395
  frames += (long )plac->frames_this_block;
#line 397
  (plac->pakt_info)->current = (uint32_t )0;
  }
#line 399
  return (frames);
}
}
#line 403 "/root/patchweave_donee/23/src/alac.c"
static int alac_decode_block(SF_PRIVATE *psf , ALAC_PRIVATE *plac ) 
{ 
  ALAC_DECODER *pdec ;
  uint8_t *byte_buffer ;
  unsigned long __lengthofbyte_buffer ;
  void *tmp ;
  uint32_t packet_size ;
  BitBuffer bit_buffer ;
  sf_count_t __cil_tmp8 ;

  {
  {
#line 406
  __lengthofbyte_buffer = (unsigned long )(psf->sf.channels * 131072);
#line 406
  tmp = __builtin_alloca(sizeof(*byte_buffer) * __lengthofbyte_buffer);
#line 406
  byte_buffer = (uint8_t *)tmp;
#line 404
  pdec = & plac->__annonCompField4.decoder;
#line 409
  packet_size = alac_reader_next_packet_size(plac->pakt_info);
  }
#line 410
  if (packet_size == 0U) {
#line 411
    if ((plac->pakt_info)->current < (plac->pakt_info)->count) {
      {
#line 412
      psf_log_printf(psf, "packet_size is 0 (%d of %d)\n", (plac->pakt_info)->current,
                     (plac->pakt_info)->count);
      }
    }
#line 413
    return (0);
  }
  {
#line 416
  psf_fseek(psf, plac->input_data_pos, 0);
  }
#line 418
  if ((unsigned long )packet_size > sizeof(*byte_buffer) * __lengthofbyte_buffer) {
    {
#line 419
    psf_log_printf(psf, "%s : bad packet_size (%u)\n\340\324\204U", "alac_decode_block",
                   packet_size);
    }
#line 420
    return (0);
  }
  {
#line 423
  __cil_tmp8 = psf_fread((void *)byte_buffer, (sf_count_t )1, (sf_count_t )packet_size,
                         psf);
  }
#line 423
  if ((long )packet_size != __cil_tmp8) {
#line 424
    return (0);
  }
  {
#line 426
  BitBufferInit(& bit_buffer, byte_buffer, packet_size);
#line 428
  plac->input_data_pos += (long )packet_size;
#line 429
  plac->frames_this_block = (uint32_t )0;
#line 430
  alac_decode(pdec, & bit_buffer, plac->buffer, plac->frames_per_block, & plac->frames_this_block);
#line 432
  plac->partial_block_frames = (uint32_t )0;
  }
#line 434
  return (1);
}
}
#line 439 "/root/patchweave_donee/23/src/alac.c"
static int alac_encode_block(SF_PRIVATE *psf , ALAC_PRIVATE *plac ) 
{ 
  ALAC_ENCODER *penc ;
  uint8_t *byte_buffer ;
  unsigned long __lengthofbyte_buffer ;
  void *tmp ;
  uint32_t num_bytes ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 442
  __lengthofbyte_buffer = (unsigned long )(psf->sf.channels * 131072);
#line 442
  tmp = __builtin_alloca(sizeof(*byte_buffer) * __lengthofbyte_buffer);
#line 442
  byte_buffer = (uint8_t *)tmp;
#line 440
  penc = & plac->__annonCompField4.encoder;
#line 442
  num_bytes = (uint32_t )0;
#line 444
  alac_encode(penc, plac->partial_block_frames, plac->buffer, byte_buffer, & num_bytes);
#line 446
  __cil_tmp6 = fwrite((void const   *)byte_buffer, 1UL, (unsigned long )num_bytes,
                      plac->enctmp);
  }
#line 446
  if (__cil_tmp6 != (unsigned long )num_bytes) {
#line 447
    return (0);
  }
  {
#line 448
  plac->pakt_info = alac_pakt_append(plac->pakt_info, num_bytes);
  }
#line 448
  if ((unsigned long )plac->pakt_info == (unsigned long )((void *)0)) {
#line 449
    return (0);
  }
#line 451
  plac->partial_block_frames = (uint32_t )0;
#line 453
  return (1);
}
}
#line 461 "/root/patchweave_donee/23/src/alac.c"
static sf_count_t alac_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int readcount ;
  sf_count_t total ;
  int __cil_tmp9 ;
  sf_count_t tmp ;

  {
#line 465
  total = (sf_count_t )0;
#line 467
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 467
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 468
    return ((sf_count_t )0);
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;

#line 470
    if (! (len > 0L)) {
#line 470
      goto while_break;
    }
    {
#line 471
    __cil_tmp9 = alac_decode_block(psf, plac);
    }
#line 471
    if (plac->partial_block_frames >= plac->frames_this_block) {
#line 471
      if (__cil_tmp9 == 0) {
#line 472
        goto while_break;
      }
    }
#line 474
    readcount = (int )((plac->frames_this_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 475
    if ((long )readcount > len) {
#line 475
      tmp = len;
    } else {
#line 475
      tmp = (long )readcount;
    }
#line 475
    readcount = (int )tmp;
#line 477
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 479
    k = 0;
    {
#line 479
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 479
      if (! (k < readcount)) {
#line 479
        goto while_break___0;
      }
#line 480
      *(ptr + (total + (long )k)) = (short )(*(iptr + k) >> 16);
#line 479
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 482
    plac->partial_block_frames += (unsigned int )(readcount / plac->channels);
#line 483
    total += (long )readcount;
#line 484
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 487
  return (total);
}
}
#line 491 "/root/patchweave_donee/23/src/alac.c"
static sf_count_t alac_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int readcount ;
  sf_count_t total ;
  int __cil_tmp9 ;
  sf_count_t tmp ;

  {
#line 495
  total = (sf_count_t )0;
#line 497
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 497
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 498
    return ((sf_count_t )0);
  }
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;

#line 500
    if (! (len > 0L)) {
#line 500
      goto while_break;
    }
    {
#line 501
    __cil_tmp9 = alac_decode_block(psf, plac);
    }
#line 501
    if (plac->partial_block_frames >= plac->frames_this_block) {
#line 501
      if (__cil_tmp9 == 0) {
#line 502
        goto while_break;
      }
    }
#line 504
    readcount = (int )((plac->frames_this_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 505
    if ((long )readcount > len) {
#line 505
      tmp = len;
    } else {
#line 505
      tmp = (long )readcount;
    }
#line 505
    readcount = (int )tmp;
#line 507
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 509
    k = 0;
    {
#line 509
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 509
      if (! (k < readcount)) {
#line 509
        goto while_break___0;
      }
#line 510
      *(ptr + (total + (long )k)) = *(iptr + k);
#line 509
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 512
    plac->partial_block_frames += (unsigned int )(readcount / plac->channels);
#line 513
    total += (long )readcount;
#line 514
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 517
  return (total);
}
}
#line 521 "/root/patchweave_donee/23/src/alac.c"
static sf_count_t alac_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int __cil_tmp11 ;
  sf_count_t tmp___0 ;

  {
#line 525
  total = (sf_count_t )0;
#line 528
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 528
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 529
    return ((sf_count_t )0);
  }
#line 531
  if (psf->norm_float == 1) {
#line 531
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 531
    tmp = 1.;
  }
#line 531
  normfact = (float )tmp;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;

#line 533
    if (! (len > 0L)) {
#line 533
      goto while_break;
    }
    {
#line 534
    __cil_tmp11 = alac_decode_block(psf, plac);
    }
#line 534
    if (plac->partial_block_frames >= plac->frames_this_block) {
#line 534
      if (__cil_tmp11 == 0) {
#line 535
        goto while_break;
      }
    }
#line 537
    readcount = (int )((plac->frames_this_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 538
    if ((long )readcount > len) {
#line 538
      tmp___0 = len;
    } else {
#line 538
      tmp___0 = (long )readcount;
    }
#line 538
    readcount = (int )tmp___0;
#line 540
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 542
    k = 0;
    {
#line 542
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 542
      if (! (k < readcount)) {
#line 542
        goto while_break___0;
      }
#line 543
      *(ptr + (total + (long )k)) = normfact * (float )*(iptr + k);
#line 542
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 545
    plac->partial_block_frames += (unsigned int )(readcount / plac->channels);
#line 546
    total += (long )readcount;
#line 547
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 550
  return (total);
}
}
#line 554 "/root/patchweave_donee/23/src/alac.c"
static sf_count_t alac_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int __cil_tmp11 ;
  sf_count_t tmp___0 ;

  {
#line 558
  total = (sf_count_t )0;
#line 561
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 561
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 562
    return ((sf_count_t )0);
  }
#line 564
  if (psf->norm_double == 1) {
#line 564
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 564
    tmp = 1.;
  }
#line 564
  normfact = tmp;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;

#line 566
    if (! (len > 0L)) {
#line 566
      goto while_break;
    }
    {
#line 567
    __cil_tmp11 = alac_decode_block(psf, plac);
    }
#line 567
    if (plac->partial_block_frames >= plac->frames_this_block) {
#line 567
      if (__cil_tmp11 == 0) {
#line 568
        goto while_break;
      }
    }
#line 570
    readcount = (int )((plac->frames_this_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 571
    if ((long )readcount > len) {
#line 571
      tmp___0 = len;
    } else {
#line 571
      tmp___0 = (long )readcount;
    }
#line 571
    readcount = (int )tmp___0;
#line 573
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 575
    k = 0;
    {
#line 575
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 575
      if (! (k < readcount)) {
#line 575
        goto while_break___0;
      }
#line 576
      *(ptr + (total + (long )k)) = normfact * (double )*(iptr + k);
#line 575
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 578
    plac->partial_block_frames += (unsigned int )(readcount / plac->channels);
#line 579
    total += (long )readcount;
#line 580
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 583
  return (total);
}
}
#line 590 "/root/patchweave_donee/23/src/alac.c"
static sf_count_t alac_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  ALAC_PRIVATE *plac ;
  int newblock ;
  int newsample ;
  sf_count_t __cil_tmp7 ;

  {
#line 594
  if (! psf->codec_data) {
#line 595
    return ((sf_count_t )0);
  }
#line 596
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 598
  if (psf->datalength < 0L) {
#line 599
    psf->error = 39;
#line 600
    return ((sf_count_t )-1);
  } else
#line 598
  if (psf->dataoffset < 0L) {
#line 599
    psf->error = 39;
#line 600
    return ((sf_count_t )-1);
  }
#line 603
  if (offset == 0L) {
    {
#line 604
    psf_fseek(psf, psf->dataoffset, 0);
#line 606
    plac->frames_this_block = (uint32_t )0;
#line 607
    plac->input_data_pos = psf->dataoffset;
#line 608
    (plac->pakt_info)->current = (uint32_t )0;
    }
#line 609
    return ((sf_count_t )0);
  }
#line 612
  if (offset < 0L) {
#line 613
    psf->error = 39;
#line 614
    return ((sf_count_t )-1);
  } else
#line 612
  if (offset > (long )((plac->pakt_info)->count * plac->frames_per_block)) {
#line 613
    psf->error = 39;
#line 614
    return ((sf_count_t )-1);
  }
#line 617
  newblock = (int )(offset / (long )plac->frames_per_block);
#line 618
  newsample = (int )(offset % (long )plac->frames_per_block);
#line 620
  if (mode == 16) {
    {
#line 621
    __cil_tmp7 = alac_pakt_block_offset(plac->pakt_info, (uint32_t )newblock);
#line 621
    plac->input_data_pos = psf->dataoffset + __cil_tmp7;
#line 623
    (plac->pakt_info)->current = (uint32_t )newblock;
#line 624
    alac_decode_block(psf, plac);
#line 625
    plac->partial_block_frames = (uint32_t )newsample;
    }
  } else {
#line 629
    psf->error = 39;
#line 630
    return ((sf_count_t )-1);
  }
#line 633
  return ((sf_count_t )((unsigned int )newblock * plac->frames_per_block + (unsigned int )newsample));
}
}
#line 641 "/root/patchweave_donee/23/src/alac.c"
static sf_count_t alac_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int writecount ;
  sf_count_t total ;
  sf_count_t tmp ;

  {
#line 645
  total = (sf_count_t )0;
#line 647
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 647
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 648
    return ((sf_count_t )0);
  }
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;

#line 650
    if (! (len > 0L)) {
#line 650
      goto while_break;
    }
#line 651
    writecount = (int )((plac->frames_per_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 652
    if (writecount == 0) {
#line 652
      tmp = len;
    } else
#line 652
    if ((long )writecount > len) {
#line 652
      tmp = len;
    } else {
#line 652
      tmp = (long )writecount;
    }
#line 652
    writecount = (int )tmp;
#line 654
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 656
    k = 0;
    {
#line 656
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 656
      if (! (k < writecount)) {
#line 656
        goto while_break___0;
      }
      {
#line 657
      *(iptr + k) = arith_shift_left((int32_t )*(ptr + k), 16);
#line 656
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 659
    plac->partial_block_frames += (unsigned int )(writecount / plac->channels);
#line 660
    total += (long )writecount;
#line 661
    len -= (long )writecount;
#line 662
    ptr += writecount;
#line 664
    if (plac->partial_block_frames >= plac->frames_per_block) {
      {
#line 665
      alac_encode_block(psf, plac);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 668
  return (total);
}
}
#line 672 "/root/patchweave_donee/23/src/alac.c"
static sf_count_t alac_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  int *iptr ;
  int k ;
  int writecount ;
  sf_count_t total ;
  sf_count_t tmp ;

  {
#line 676
  total = (sf_count_t )0;
#line 678
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 678
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 679
    return ((sf_count_t )0);
  }
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;

#line 681
    if (! (len > 0L)) {
#line 681
      goto while_break;
    }
#line 682
    writecount = (int )((plac->frames_per_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 683
    if (writecount == 0) {
#line 683
      tmp = len;
    } else
#line 683
    if ((long )writecount > len) {
#line 683
      tmp = len;
    } else {
#line 683
      tmp = (long )writecount;
    }
#line 683
    writecount = (int )tmp;
#line 685
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 687
    k = 0;
    {
#line 687
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 687
      if (! (k < writecount)) {
#line 687
        goto while_break___0;
      }
#line 688
      *(iptr + k) = (int )*(ptr + k);
#line 687
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 690
    plac->partial_block_frames += (unsigned int )(writecount / plac->channels);
#line 691
    total += (long )writecount;
#line 692
    len -= (long )writecount;
#line 693
    ptr += writecount;
#line 695
    if (plac->partial_block_frames >= plac->frames_per_block) {
      {
#line 696
      alac_encode_block(psf, plac);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 699
  return (total);
}
}
#line 703 "/root/patchweave_donee/23/src/alac.c"
static sf_count_t alac_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  void (*convert)(float const   * , int * , int  , int  ) ;
  int *iptr ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , int *dest , int count , int normalize ) ;
  sf_count_t tmp___0 ;

  {
#line 708
  total = (sf_count_t )0;
#line 710
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 710
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 711
    return ((sf_count_t )0);
  }
#line 713
  if (psf->add_clipping) {
#line 713
    tmp = & psf_f2i_clip_array;
  } else {
#line 713
    tmp = & psf_f2i_array;
  }
#line 713
  convert = tmp;
  {
#line 715
  while (1) {
    while_continue: /* CIL Label */ ;

#line 715
    if (! (len > 0L)) {
#line 715
      goto while_break;
    }
#line 716
    writecount = (int )((plac->frames_per_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 717
    if (writecount == 0) {
#line 717
      tmp___0 = len;
    } else
#line 717
    if ((long )writecount > len) {
#line 717
      tmp___0 = len;
    } else {
#line 717
      tmp___0 = (long )writecount;
    }
    {
#line 717
    writecount = (int )tmp___0;
#line 719
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 721
    (*convert)(ptr, iptr, writecount, psf->norm_float);
#line 723
    plac->partial_block_frames += (unsigned int )(writecount / plac->channels);
#line 724
    total += (long )writecount;
#line 725
    len -= (long )writecount;
#line 726
    ptr += writecount;
    }
#line 728
    if (plac->partial_block_frames >= plac->frames_per_block) {
      {
#line 729
      alac_encode_block(psf, plac);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 732
  return (total);
}
}
#line 736 "/root/patchweave_donee/23/src/alac.c"
static sf_count_t alac_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  ALAC_PRIVATE *plac ;
  void (*convert)(double const   * , int * , int  , int  ) ;
  int *iptr ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , int *dest , int count , int normalize ) ;
  sf_count_t tmp___0 ;

  {
#line 741
  total = (sf_count_t )0;
#line 743
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 743
  if ((unsigned long )plac == (unsigned long )((void *)0)) {
#line 744
    return ((sf_count_t )0);
  }
#line 746
  if (psf->add_clipping) {
#line 746
    tmp = & psf_d2i_clip_array;
  } else {
#line 746
    tmp = & psf_d2i_array;
  }
#line 746
  convert = tmp;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;

#line 748
    if (! (len > 0L)) {
#line 748
      goto while_break;
    }
#line 749
    writecount = (int )((plac->frames_per_block - plac->partial_block_frames) * (unsigned int )plac->channels);
#line 750
    if (writecount == 0) {
#line 750
      tmp___0 = len;
    } else
#line 750
    if ((long )writecount > len) {
#line 750
      tmp___0 = len;
    } else {
#line 750
      tmp___0 = (long )writecount;
    }
    {
#line 750
    writecount = (int )tmp___0;
#line 752
    iptr = plac->buffer + plac->partial_block_frames * (unsigned int )plac->channels;
#line 754
    (*convert)(ptr, iptr, writecount, psf->norm_float);
#line 756
    plac->partial_block_frames += (unsigned int )(writecount / plac->channels);
#line 757
    total += (long )writecount;
#line 758
    len -= (long )writecount;
#line 759
    ptr += writecount;
    }
#line 761
    if (plac->partial_block_frames >= plac->frames_per_block) {
      {
#line 762
      alac_encode_block(psf, plac);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 765
  return (total);
}
}
#line 773 "/root/patchweave_donee/23/src/alac.c"
static PAKT_INFO *alac_pakt_alloc(uint32_t initial_count ) 
{ 
  PAKT_INFO *info ;
  void *tmp ;

  {
  {
#line 776
  tmp = calloc(1UL, sizeof(PAKT_INFO ) + (unsigned long )initial_count * sizeof(info->packet_size[0]));
#line 776
  info = (PAKT_INFO *)tmp;
  }
#line 776
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 777
    return ((PAKT_INFO *)((void *)0));
  }
#line 779
  info->allocated = initial_count;
#line 780
  info->current = (uint32_t )0;
#line 781
  info->count = (uint32_t )0;
#line 783
  return (info);
}
}
#line 787 "/root/patchweave_donee/23/src/alac.c"
static PAKT_INFO *alac_pakt_append(PAKT_INFO *info , uint32_t value___0 ) 
{ 
  PAKT_INFO *temp ;
  uint32_t newcount ;
  uint32_t __cil_tmp6 ;
  void *tmp ;

  {
#line 789
  if (info->count >= info->allocated) {
    {
#line 791
    newcount = info->allocated + info->allocated / 2U;
#line 793
    tmp = realloc((void *)info, sizeof(PAKT_INFO ) + (unsigned long )newcount * sizeof(info->packet_size[0]));
#line 793
    temp = (PAKT_INFO *)tmp;
    }
#line 793
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 794
      return ((PAKT_INFO *)((void *)0));
    }
#line 796
    info = temp;
#line 797
    info->allocated = newcount;
  }
#line 800
  __cil_tmp6 = info->count;
#line 800
  (info->count) ++;
#line 800
  info->packet_size[__cil_tmp6] = value___0;
#line 801
  return (info);
}
}
#line 805 "/root/patchweave_donee/23/src/alac.c"
static PAKT_INFO *alac_pakt_read_decode(SF_PRIVATE *psf , uint32_t UNUSED_pakt_offset ) 
{ 
  SF_CHUNK_INFO chunk_info ;
  PAKT_INFO *info ;
  uint8_t *pakt_data ;
  uint32_t bcount ;
  uint32_t value___0 ;
  uint32_t pakt_size ;
  SF_CHUNK_ITERATOR *chunk_iterator ;
  int __cil_tmp12 ;
  char const   *__cil_tmp13 ;
  uint8_t byte ;
  int32_t count___0 ;

  {
  {
#line 807
  info = (PAKT_INFO *)((void *)0);
#line 808
  pakt_data = (uint8_t *)((void *)0);
#line 809
  value___0 = (uint32_t )1;
#line 813
  memset((void *)(& chunk_info), 0, sizeof(chunk_info));
#line 814
  snprintf(chunk_info.id, sizeof(chunk_info.id), "pakt\204U");
#line 815
  chunk_info.id_size = 4U;
#line 817
  chunk_iterator = psf_get_chunk_iterator(psf, (char const   *)(chunk_info.id));
  }
#line 817
  if ((unsigned long )chunk_iterator == (unsigned long )((void *)0)) {
    {
#line 818
    printf("%s %d : no chunk iterator found\n\n", "alac_pakt_read_decodeU", 818);
#line 819
    free(chunk_info.data);
#line 820
    chunk_info.data = (void *)0;
    }
#line 821
    return ((PAKT_INFO *)((void *)0));
  }
  {
#line 824
  (*(psf->get_chunk_size))(psf, chunk_iterator, & chunk_info);
#line 826
  pakt_size = chunk_info.datalen;
#line 827
  chunk_info.data = malloc((unsigned long )(pakt_size + 5U));
#line 829
  __cil_tmp12 = (*(psf->get_chunk_data))(psf, chunk_iterator, & chunk_info);
#line 829
  bcount = (uint32_t )__cil_tmp12;
  }
#line 829
  if (bcount != 0U) {
    {
#line 830
    __cil_tmp13 = sf_error_number((int )bcount);
#line 830
    printf("%s %d : %s\n\n", "alac_pakt_read_decode", 830, __cil_tmp13);
    }
    {
#line 831
    while (1) {
      while_continue: /* CIL Label */ ;

#line 831
      if (! chunk_iterator) {
#line 831
        goto while_break;
      }
      {
#line 832
      chunk_iterator = (*(psf->next_chunk_iterator))(psf, chunk_iterator);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: 
    {
#line 833
    free(chunk_info.data);
#line 834
    chunk_info.data = (void *)0;
    }
#line 835
    return ((PAKT_INFO *)((void *)0));
  }
  {
#line 838
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 838
    if (! chunk_iterator) {
#line 838
      goto while_break___0;
    }
    {
#line 839
    chunk_iterator = (*(psf->next_chunk_iterator))(psf, chunk_iterator);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 841
  info = alac_pakt_alloc(pakt_size / 4U);
#line 844
  bcount = (uint32_t )24;
  }
  {
#line 844
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 844
    if (bcount < pakt_size) {
#line 844
      if (! (value___0 != 0U)) {
#line 844
        goto while_break___1;
      }
    } else {
#line 844
      goto while_break___1;
    }
#line 846
    count___0 = 0;
#line 848
    value___0 = (uint32_t )0;
    {
#line 849
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 850
      byte = *(pakt_data + (bcount + (unsigned int )count___0));
#line 851
      value___0 = (value___0 << 7) + (unsigned int )((int )byte & 127);
#line 853
      count___0 ++;
#line 854
      if (count___0 > 5) {
        {
#line 855
        printf("%s %d : Ooops! count %d    bcount %d\n", "alac_pakt_read_decode",
               855, count___0, bcount);
#line 856
        value___0 = (uint32_t )0;
        }
#line 857
        goto while_break___2;
      } else
#line 854
      if (bcount + (unsigned int )count___0 > pakt_size) {
        {
#line 855
        printf("%s %d : Ooops! count %d    bcount %d\n", "alac_pakt_read_decode",
               855, count___0, bcount);
#line 856
        value___0 = (uint32_t )0;
        }
#line 857
        goto while_break___2;
      }
#line 849
      if (! ((int )byte & 128)) {
#line 849
        goto while_break___2;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 862
    bcount += (unsigned int )count___0;
#line 864
    info = alac_pakt_append(info, value___0);
    }
#line 864
    if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 865
      goto FreeExit;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 868
  free((void *)pakt_data);
  }
#line 870
  return (info);
  FreeExit: 
  {
#line 873
  free((void *)pakt_data);
#line 874
  free((void *)info);
  }
#line 875
  return ((PAKT_INFO *)((void *)0));
}
}
#line 879 "/root/patchweave_donee/23/src/alac.c"
static uint8_t *alac_pakt_encode(SF_PRIVATE *psf , uint32_t *pakt_size_out ) 
{ 
  ALAC_PRIVATE *plac ;
  PAKT_INFO *info ;
  uint8_t *data ;
  uint32_t k ;
  uint32_t allocated ;
  uint32_t pakt_size ;
  int32_t value___0 ;
  uint32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  void *tmp ;

  {
  {
#line 885
  plac = (ALAC_PRIVATE *)psf->codec_data;
#line 886
  info = plac->pakt_info;
#line 888
  allocated = 100U + 2U * info->count;
#line 889
  tmp = calloc(1UL, (unsigned long )allocated);
#line 889
  data = (uint8_t *)tmp;
  }
#line 889
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 890
    return ((uint8_t *)((void *)0));
  }
  {
#line 892
  psf_put_be64(data, 0, (int64_t )info->count);
#line 893
  psf_put_be64(data, 8, psf->sf.frames);
#line 894
  psf_put_be32(data, 20, (int32_t )(4096U - plac->partial_block_frames));
#line 897
  pakt_size = (uint32_t )24;
#line 899
  k = (uint32_t )0;
  }
  {
#line 899
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 899
    if (! (k < info->count)) {
#line 899
      goto while_break;
    }
#line 900
    value___0 = (int32_t )info->packet_size[k];
#line 902
    if ((value___0 & 127) == value___0) {
#line 903
      __cil_tmp11 = pakt_size;
#line 903
      pakt_size ++;
#line 903
      *(data + __cil_tmp11) = (uint8_t )value___0;
#line 904
      goto while_continue;
    }
#line 907
    if ((value___0 & 16383) == value___0) {
#line 908
      __cil_tmp12 = pakt_size;
#line 908
      pakt_size ++;
#line 908
      *(data + __cil_tmp12) = (uint8_t )((value___0 >> 7) | 128);
#line 909
      __cil_tmp13 = pakt_size;
#line 909
      pakt_size ++;
#line 909
      *(data + __cil_tmp13) = (uint8_t )(value___0 & 127);
#line 910
      goto while_continue;
    }
#line 913
    if ((value___0 & 2097151) == value___0) {
#line 914
      __cil_tmp14 = pakt_size;
#line 914
      pakt_size ++;
#line 914
      *(data + __cil_tmp14) = (uint8_t )((value___0 >> 14) | 128);
#line 915
      __cil_tmp15 = pakt_size;
#line 915
      pakt_size ++;
#line 915
      *(data + __cil_tmp15) = (uint8_t )(((value___0 >> 7) & 127) | 128);
#line 916
      __cil_tmp16 = pakt_size;
#line 916
      pakt_size ++;
#line 916
      *(data + __cil_tmp16) = (uint8_t )(value___0 & 127);
#line 917
      goto while_continue;
    }
#line 920
    if ((value___0 & 268435455) == value___0) {
#line 921
      __cil_tmp17 = pakt_size;
#line 921
      pakt_size ++;
#line 921
      *(data + __cil_tmp17) = (uint8_t )((value___0 >> 21) | 128);
#line 922
      __cil_tmp18 = pakt_size;
#line 922
      pakt_size ++;
#line 922
      *(data + __cil_tmp18) = (uint8_t )(((value___0 >> 14) & 127) | 128);
#line 923
      __cil_tmp19 = pakt_size;
#line 923
      pakt_size ++;
#line 923
      *(data + __cil_tmp19) = (uint8_t )(((value___0 >> 7) & 127) | 128);
#line 924
      __cil_tmp20 = pakt_size;
#line 924
      pakt_size ++;
#line 924
      *(data + __cil_tmp20) = (uint8_t )(value___0 & 127);
#line 925
      goto while_continue;
    }
    {
#line 928
    *pakt_size_out = (uint32_t )0;
#line 929
    free((void *)data);
    }
#line 930
    return ((uint8_t *)((void *)0));
#line 899
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 933
  *pakt_size_out = pakt_size;
#line 934
  return (data);
}
}
#line 938 "/root/patchweave_donee/23/src/alac.c"
static sf_count_t alac_pakt_block_offset(PAKT_INFO *info , uint32_t block ) 
{ 
  sf_count_t offset ;
  uint32_t k ;

  {
#line 939
  offset = (sf_count_t )0;
#line 942
  k = (uint32_t )0;
  {
#line 942
  while (1) {
    while_continue: /* CIL Label */ ;

#line 942
    if (! (k < block)) {
#line 942
      goto while_break;
    }
#line 943
    offset += (long )info->packet_size[k];
#line 942
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 945
  return (offset);
}
}
#line 949 "/root/patchweave_donee/23/src/alac.c"
static uint32_t alac_kuki_read(SF_PRIVATE *psf , uint32_t kuki_offset , uint8_t *kuki ,
                               size_t kuki_maxlen ) 
{ 
  uint32_t marker ;
  uint64_t kuki_size ;
  sf_count_t __cil_tmp7 ;
  int64_t __cil_tmp8 ;

  {
  {
#line 953
  __cil_tmp7 = psf_fseek(psf, (sf_count_t )kuki_offset, 0);
  }
#line 953
  if (__cil_tmp7 != (long )kuki_offset) {
#line 954
    return ((uint32_t )0);
  }
  {
#line 956
  psf_fread((void *)(& marker), (sf_count_t )1, (sf_count_t )sizeof(marker), psf);
  }
#line 957
  if (marker != ((unsigned int )((107 | (117 << 8)) | (107 << 16)) | (105U << 24))) {
#line 958
    return ((uint32_t )0);
  }
  {
#line 960
  psf_fread((void *)(& kuki_size), (sf_count_t )1, (sf_count_t )sizeof(kuki_size),
            psf);
#line 961
  __cil_tmp8 = ENDSWAP_64X((int64_t )kuki_size);
#line 961
  kuki_size = (uint64_t )__cil_tmp8;
  }
#line 963
  if (kuki_size == 0UL) {
    {
#line 964
    psf_log_printf(psf, "%s : Bad size (%D) of \'kuki\' chunk.\n\204U", "alac_kuki_read",
                   kuki_size);
    }
#line 965
    return ((uint32_t )0);
  } else
#line 963
  if (kuki_size > kuki_maxlen) {
    {
#line 964
    psf_log_printf(psf, "%s : Bad size (%D) of \'kuki\' chunk.\n\204U", "alac_kuki_read",
                   kuki_size);
    }
#line 965
    return ((uint32_t )0);
  }
  {
#line 968
  psf_fread((void *)kuki, (sf_count_t )1, (sf_count_t )kuki_size, psf);
  }
#line 970
  return ((uint32_t )kuki_size);
}
}
#line 978 "/root/patchweave_donee/23/src/alac.c"
static char errstr[128]  ;
#line 976 "/root/patchweave_donee/23/src/alac.c"
static char const   *alac_error_string(int error ) 
{ 


  {
#line 979
  if (error == -4) {
#line 979
    goto case_neg_4;
  }
#line 980
  if (error == -43) {
#line 980
    goto case_neg_43;
  }
#line 981
  if (error == -50) {
#line 981
    goto case_neg_50;
  }
#line 982
  if (error == -108) {
#line 982
    goto case_neg_108;
  }
#line 983
  if (error == -666) {
#line 983
    goto case_neg_666;
  }
#line 986
  if (error == -1048576) {
#line 986
    goto case_neg_1048576;
  }
#line 987
  if (error == -1048577) {
#line 987
    goto case_neg_1048577;
  }
#line 988
  if (error == -1048578) {
#line 988
    goto case_neg_1048578;
  }
#line 989
  if (error == -1048579) {
#line 989
    goto case_neg_1048579;
  }
#line 990
  if (error == -1048580) {
#line 990
    goto case_neg_1048580;
  }
#line 991
  if (error == -1048581) {
#line 991
    goto case_neg_1048581;
  }
#line 992
  goto switch_default;
  case_neg_4: 
#line 979
  return ("kALAC_UnimplementedError\220");
#line 979
  goto switch_break;
  case_neg_43: 
#line 980
  return ("kALAC_FileNotFoundError");
#line 980
  goto switch_break;
  case_neg_50: 
#line 981
  return ("kALAC_ParamError\220");
#line 981
  goto switch_break;
  case_neg_108: 
#line 982
  return ("kALAC_MemFullError");
#line 982
  goto switch_break;
  case_neg_666: 
#line 983
  return ("fALAC_FrameLengthError");
#line 983
  goto switch_break;
  case_neg_1048576: 
#line 986
  return ("kALAC_BadBitWidth\235\342\324\204U");
#line 986
  goto switch_break;
  case_neg_1048577: 
#line 987
  return ("kALAC_IncompatibleVersion\234\342\324\204U");
#line 987
  goto switch_break;
  case_neg_1048578: 
#line 988
  return ("kALAC_BadSpecificConfigSize\324\204U");
#line 988
  goto switch_break;
  case_neg_1048579: 
#line 989
  return ("kALAC_ZeroChannelCount");
#line 989
  goto switch_break;
  case_neg_1048580: 
#line 990
  return ("kALAC_NumSamplesTooBig");
#line 990
  goto switch_break;
  case_neg_1048581: 
#line 991
  return ("kALAC_UnsupportedElement\220");
#line 991
  goto switch_break;
  switch_default: 
#line 993
  goto switch_break;
  switch_break: 
  {
#line 996
  snprintf(errstr, sizeof(errstr), "Unknown error %d\230\001", error);
  }
#line 997
  return ((char const   *)(errstr));
}
}
#line 42 "/root/patchweave_donee/23/src/ALAC/matrixlib.h"
void mix16(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres ) ;
#line 43
void unmix16(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres ) ;
#line 46
void mix20(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres ) ;
#line 47
void unmix20(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres ) ;
#line 52
void mix24(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) ;
#line 54
void unmix24(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) ;
#line 61
void mix32(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) ;
#line 63
void unmix32(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) ;
#line 70
void copyPredictorTo24(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) ;
#line 71
void copyPredictorTo24Shift(int32_t *in , uint16_t *shift , int32_t *out , uint32_t stride ,
                            int32_t numSamples , int32_t bytesShifted ) ;
#line 72
void copyPredictorTo20(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) ;
#line 74
void copyPredictorTo32(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) ;
#line 75
void copyPredictorTo32Shift(int32_t *in , uint16_t *shift , int32_t *out , uint32_t stride ,
                            int32_t numSamples , int32_t bytesShifted ) ;
#line 51 "/root/patchweave_donee/23/src/ALAC/matrix_enc.c"
void mix16(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres ) 
{ 
  int32_t j ;
  int32_t mod ;
  int32_t m2 ;
  int32_t l ;
  int32_t r ;

  {
#line 55
  if (mixres != 0) {
#line 57
    mod = 1 << mixbits;
#line 61
    m2 = mod - mixres;
#line 62
    j = 0;
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;

#line 62
      if (! (j < numSamples)) {
#line 62
        goto while_break;
      }
#line 66
      l = *(in + 0) >> 16;
#line 67
      r = *(in + 1) >> 16;
#line 68
      in += stride;
#line 69
      *(u + j) = (mixres * l + m2 * r) >> mixbits;
#line 70
      *(v + j) = l - r;
#line 62
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 76
    j = 0;
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 76
      if (! (j < numSamples)) {
#line 76
        goto while_break___0;
      }
#line 78
      *(u + j) = *(in + 0) >> 16;
#line 79
      *(v + j) = *(in + 1) >> 16;
#line 80
      in += stride;
#line 76
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 81
  return;
}
}
#line 89 "/root/patchweave_donee/23/src/ALAC/matrix_enc.c"
void mix20(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres ) 
{ 
  int32_t l ;
  int32_t r ;
  int32_t j ;
  int32_t mod ;
  int32_t m2 ;

  {
#line 94
  if (mixres != 0) {
#line 97
    mod = 1 << mixbits;
#line 98
    m2 = mod - mixres;
#line 100
    j = 0;
    {
#line 100
    while (1) {
      while_continue: /* CIL Label */ ;

#line 100
      if (! (j < numSamples)) {
#line 100
        goto while_break;
      }
#line 102
      l = *(in + 0) >> 12;
#line 103
      r = *(in + 1) >> 12;
#line 104
      in += stride;
#line 106
      *(u + j) = (mixres * l + m2 * r) >> mixbits;
#line 107
      *(v + j) = l - r;
#line 100
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 113
    j = 0;
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 113
      if (! (j < numSamples)) {
#line 113
        goto while_break___0;
      }
#line 115
      *(u + j) = *(in + 0) >> 12;
#line 116
      *(v + j) = *(in + 1) >> 12;
#line 117
      in += stride;
#line 113
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 118
  return;
}
}
#line 126 "/root/patchweave_donee/23/src/ALAC/matrix_enc.c"
void mix24(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) 
{ 
  int32_t l ;
  int32_t r ;
  int32_t shift ;
  uint32_t mask ;
  int32_t j ;
  int32_t k ;
  int32_t mod ;
  int32_t m2 ;
  int32_t __cil_tmp18 ;
  int32_t __cil_tmp20 ;

  {
#line 130
  shift = bytesShifted * 8;
#line 131
  mask = (uint32_t )((1UL << shift) - 1UL);
#line 134
  if (mixres != 0) {
#line 137
    mod = 1 << mixbits;
#line 138
    m2 = mod - mixres;
#line 140
    if (bytesShifted != 0) {
#line 142
      k = 0;
#line 142
      j = 0;
      {
#line 142
      while (1) {
        while_continue: /* CIL Label */ ;

#line 142
        if (! (j < numSamples)) {
#line 142
          goto while_break;
        }
#line 144
        l = *(in + 0) >> 8;
#line 145
        r = *(in + 1) >> 8;
#line 146
        in += stride;
#line 148
        *(shiftUV + k) = (uint16_t )((unsigned int )l & mask);
#line 149
        *(shiftUV + (k + 1)) = (uint16_t )((unsigned int )r & mask);
#line 151
        l >>= shift;
#line 152
        r >>= shift;
#line 154
        *(u + j) = (mixres * l + m2 * r) >> mixbits;
#line 155
        *(v + j) = l - r;
#line 142
        k += 2;
#line 142
        __cil_tmp18 = j;
#line 142
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 160
      j = 0;
      {
#line 160
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 160
        if (! (j < numSamples)) {
#line 160
          goto while_break___0;
        }
#line 162
        l = *(in + 0) >> 8;
#line 163
        r = *(in + 1) >> 8;
#line 164
        in += stride;
#line 166
        *(u + j) = (mixres * l + m2 * r) >> mixbits;
#line 167
        *(v + j) = l - r;
#line 160
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
    }
  } else
#line 174
  if (bytesShifted != 0) {
#line 176
    k = 0;
#line 176
    j = 0;
    {
#line 176
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 176
      if (! (j < numSamples)) {
#line 176
        goto while_break___1;
      }
#line 178
      l = *(in + 0) >> 8;
#line 179
      r = *(in + 1) >> 8;
#line 180
      in += stride;
#line 182
      *(shiftUV + k) = (uint16_t )((unsigned int )l & mask);
#line 183
      *(shiftUV + (k + 1)) = (uint16_t )((unsigned int )r & mask);
#line 185
      l >>= shift;
#line 186
      r >>= shift;
#line 188
      *(u + j) = l;
#line 189
      *(v + j) = r;
#line 176
      k += 2;
#line 176
      __cil_tmp20 = j;
#line 176
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  } else {
#line 194
    j = 0;
    {
#line 194
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 194
      if (! (j < numSamples)) {
#line 194
        goto while_break___2;
      }
#line 196
      l = *(in + 0) >> 8;
#line 197
      r = *(in + 1) >> 8;
#line 198
      in += stride;
#line 194
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 199
  return;
}
}
#line 210 "/root/patchweave_donee/23/src/ALAC/matrix_enc.c"
void mix32(int32_t *in , uint32_t stride , int32_t *u , int32_t *v , int32_t numSamples ,
           int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) 
{ 
  int32_t shift ;
  uint32_t mask ;
  int32_t l ;
  int32_t r ;
  int32_t j ;
  int32_t k ;
  int32_t mod ;
  int32_t m2 ;
  int32_t __cil_tmp18 ;
  int32_t __cil_tmp20 ;

  {
#line 213
  shift = bytesShifted * 8;
#line 214
  mask = (uint32_t )((1UL << shift) - 1UL);
#line 218
  if (mixres != 0) {
#line 220
    mod = 1 << mixbits;
#line 226
    m2 = mod - mixres;
#line 227
    k = 0;
#line 227
    j = 0;
    {
#line 227
    while (1) {
      while_continue: /* CIL Label */ ;

#line 227
      if (! (j < numSamples)) {
#line 227
        goto while_break;
      }
#line 229
      l = *(in + 0);
#line 230
      r = *(in + 1);
#line 231
      in += stride;
#line 233
      *(shiftUV + k) = (uint16_t )((unsigned int )l & mask);
#line 234
      *(shiftUV + (k + 1)) = (uint16_t )((unsigned int )r & mask);
#line 236
      l >>= shift;
#line 237
      r >>= shift;
#line 239
      *(u + j) = (mixres * l + m2 * r) >> mixbits;
#line 240
      *(v + j) = l - r;
#line 227
      k += 2;
#line 227
      __cil_tmp18 = j;
#line 227
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 245
  if (bytesShifted == 0) {
#line 248
    j = 0;
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 248
      if (! (j < numSamples)) {
#line 248
        goto while_break___0;
      }
#line 250
      *(u + j) = *(in + 0);
#line 251
      *(v + j) = *(in + 1);
#line 252
      in += stride;
#line 248
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 258
    k = 0;
#line 258
    j = 0;
    {
#line 258
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 258
      if (! (j < numSamples)) {
#line 258
        goto while_break___1;
      }
#line 260
      l = *(in + 0);
#line 261
      r = *(in + 1);
#line 262
      in += stride;
#line 264
      *(shiftUV + k) = (uint16_t )((unsigned int )l & mask);
#line 265
      *(shiftUV + (k + 1)) = (uint16_t )((unsigned int )r & mask);
#line 267
      l >>= shift;
#line 268
      r >>= shift;
#line 270
      *(u + j) = l;
#line 271
      *(v + j) = r;
#line 258
      k += 2;
#line 258
      __cil_tmp20 = j;
#line 258
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 263
  return;
}
}
#line 63 "/root/patchweave_donee/23/src/ALAC/matrix_dec.c"
void unmix16(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres ) 
{ 
  int32_t j ;
  int32_t l ;
  int32_t r ;

  {
#line 67
  if (mixres != 0) {
#line 70
    j = 0;
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;

#line 70
      if (! (j < numSamples)) {
#line 70
        goto while_break;
      }
      {
#line 74
      l = (*(u + j) + *(v + j)) - (mixres * *(v + j) >> mixbits);
#line 75
      r = l - *(v + j);
#line 77
      *(out + 0) = arith_shift_left(l, 16);
#line 78
      *(out + 1) = arith_shift_left(r, 16);
#line 79
      out += stride;
#line 70
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 85
    j = 0;
    {
#line 85
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 85
      if (! (j < numSamples)) {
#line 85
        goto while_break___0;
      }
#line 87
      *(out + 0) = *(u + j) << 16;
#line 88
      *(out + 1) = *(v + j) << 16;
#line 89
      out += stride;
#line 85
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 90
  return;
}
}
#line 98 "/root/patchweave_donee/23/src/ALAC/matrix_dec.c"
void unmix20(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres ) 
{ 
  int32_t j ;
  int32_t l ;
  int32_t r ;

  {
#line 102
  if (mixres != 0) {
#line 105
    j = 0;
    {
#line 105
    while (1) {
      while_continue: /* CIL Label */ ;

#line 105
      if (! (j < numSamples)) {
#line 105
        goto while_break;
      }
      {
#line 109
      l = (*(u + j) + *(v + j)) - (mixres * *(v + j) >> mixbits);
#line 110
      r = l - *(v + j);
#line 112
      *(out + 0) = arith_shift_left(l, 12);
#line 113
      *(out + 1) = arith_shift_left(r, 12);
#line 114
      out += stride;
#line 105
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 120
    j = 0;
    {
#line 120
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 120
      if (! (j < numSamples)) {
#line 120
        goto while_break___0;
      }
      {
#line 122
      *(out + 0) = arith_shift_left(*(u + j), 12);
#line 123
      *(out + 1) = arith_shift_left(*(v + j), 12);
#line 124
      out += stride;
#line 120
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 125
  return;
}
}
#line 133 "/root/patchweave_donee/23/src/ALAC/matrix_dec.c"
void unmix24(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) 
{ 
  int32_t shift ;
  int32_t l ;
  int32_t r ;
  int32_t j ;
  int32_t k ;
  int32_t __cil_tmp15 ;
  int32_t __cil_tmp16 ;
  int32_t __cil_tmp19 ;
  int32_t __cil_tmp21 ;

  {
#line 136
  shift = bytesShifted * 8;
#line 140
  if (mixres != 0) {
#line 143
    if (bytesShifted != 0) {
#line 145
      k = 0;
#line 145
      j = 0;
      {
#line 145
      while (1) {
        while_continue: /* CIL Label */ ;

#line 145
        if (! (j < numSamples)) {
#line 145
          goto while_break;
        }
        {
#line 147
        l = (*(u + j) + *(v + j)) - (mixres * *(v + j) >> mixbits);
#line 148
        r = l - *(v + j);
#line 150
        __cil_tmp15 = arith_shift_left(l, shift);
#line 150
        l = (int32_t )((unsigned int )__cil_tmp15 | (uint32_t )*(shiftUV + k));
#line 151
        __cil_tmp16 = arith_shift_left(r, shift);
#line 151
        r = (int32_t )((unsigned int )__cil_tmp16 | (uint32_t )*(shiftUV + (k + 1)));
#line 153
        *(out + 0) = arith_shift_left(l, 8);
#line 154
        *(out + 1) = arith_shift_left(r, 8);
#line 155
        out += stride;
#line 145
        k += 2;
#line 145
        __cil_tmp19 = j;
#line 145
        j ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 160
      j = 0;
      {
#line 160
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 160
        if (! (j < numSamples)) {
#line 160
          goto while_break___0;
        }
#line 162
        l = (*(u + j) + *(v + j)) - (mixres * *(v + j) >> mixbits);
#line 163
        r = l - *(v + j);
#line 165
        *(out + 0) = l << 8;
#line 166
        *(out + 1) = r << 8;
#line 167
        out += stride;
#line 160
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: ;
    }
  } else
#line 174
  if (bytesShifted != 0) {
#line 176
    k = 0;
#line 176
    j = 0;
    {
#line 176
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 176
      if (! (j < numSamples)) {
#line 176
        goto while_break___1;
      }
#line 178
      l = *(u + j);
#line 179
      r = *(v + j);
#line 181
      l = (int32_t )((unsigned int )(l << shift) | (uint32_t )*(shiftUV + k));
#line 182
      r = (int32_t )((unsigned int )(r << shift) | (uint32_t )*(shiftUV + (k + 1)));
#line 184
      *(out + 0) = l << 8;
#line 185
      *(out + 1) = r << 8;
#line 186
      out += stride;
#line 176
      k += 2;
#line 176
      __cil_tmp21 = j;
#line 176
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  } else {
#line 191
    j = 0;
    {
#line 191
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 191
      if (! (j < numSamples)) {
#line 191
        goto while_break___2;
      }
#line 193
      *(out + 0) = *(u + j) << 8;
#line 194
      *(out + 1) = *(v + j) << 8;
#line 195
      out += stride;
#line 191
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 196
  return;
}
}
#line 207 "/root/patchweave_donee/23/src/ALAC/matrix_dec.c"
void unmix32(int32_t *u , int32_t *v , int32_t *out , uint32_t stride , int32_t numSamples ,
             int32_t mixbits , int32_t mixres , uint16_t *shiftUV , int32_t bytesShifted ) 
{ 
  int32_t shift ;
  int32_t l ;
  int32_t r ;
  int32_t j ;
  int32_t k ;
  int32_t lt ;
  int32_t rt ;
  int32_t __cil_tmp17 ;
  int32_t __cil_tmp18 ;
  int32_t __cil_tmp19 ;
  int32_t __cil_tmp21 ;

  {
#line 210
  shift = bytesShifted * 8;
#line 214
  if (mixres != 0) {
#line 219
    k = 0;
#line 219
    j = 0;
    {
#line 219
    while (1) {
      while_continue: /* CIL Label */ ;

#line 219
      if (! (j < numSamples)) {
#line 219
        goto while_break;
      }
      {
#line 223
      lt = *(u + j);
#line 224
      rt = *(v + j);
#line 226
      l = (lt + rt) - (mixres * rt >> mixbits);
#line 227
      r = l - rt;
#line 229
      __cil_tmp17 = arith_shift_left(l, shift);
#line 229
      *(out + 0) = (int32_t )((unsigned int )__cil_tmp17 | (uint32_t )*(shiftUV + k));
#line 230
      __cil_tmp18 = arith_shift_left(r, shift);
#line 230
      *(out + 1) = (int32_t )((unsigned int )__cil_tmp18 | (uint32_t )*(shiftUV + (k + 1)));
#line 231
      out += stride;
#line 219
      k += 2;
#line 219
      __cil_tmp19 = j;
#line 219
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 236
  if (bytesShifted == 0) {
#line 239
    j = 0;
    {
#line 239
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 239
      if (! (j < numSamples)) {
#line 239
        goto while_break___0;
      }
#line 241
      *(out + 0) = *(u + j);
#line 242
      *(out + 1) = *(v + j);
#line 243
      out += stride;
#line 239
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 249
    k = 0;
#line 249
    j = 0;
    {
#line 249
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 249
      if (! (j < numSamples)) {
#line 249
        goto while_break___1;
      }
#line 251
      *(out + 0) = (int32_t )((unsigned int )(*(u + j) << shift) | (uint32_t )*(shiftUV + k));
#line 252
      *(out + 1) = (int32_t )((unsigned int )(*(v + j) << shift) | (uint32_t )*(shiftUV + (k + 1)));
#line 253
      out += stride;
#line 249
      k += 2;
#line 249
      __cil_tmp21 = j;
#line 249
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 254
  return;
}
}
#line 262 "/root/patchweave_donee/23/src/ALAC/matrix_dec.c"
void copyPredictorTo24(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) 
{ 
  int32_t j ;

  {
#line 266
  j = 0;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;

#line 266
    if (! (j < numSamples)) {
#line 266
      goto while_break;
    }
#line 268
    *(out + 0) = *(in + j) << 8;
#line 269
    out += stride;
#line 266
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 270
  return;
}
}
#line 274 "/root/patchweave_donee/23/src/ALAC/matrix_dec.c"
void copyPredictorTo24Shift(int32_t *in , uint16_t *shift , int32_t *out , uint32_t stride ,
                            int32_t numSamples , int32_t bytesShifted ) 
{ 
  int32_t shiftVal ;
  int32_t j ;
  int32_t val ;
  int32_t __cil_tmp10 ;

  {
#line 276
  shiftVal = bytesShifted * 8;
#line 281
  j = 0;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;

#line 281
    if (! (j < numSamples)) {
#line 281
      goto while_break;
    }
    {
#line 283
    val = *(in + j);
#line 285
    __cil_tmp10 = arith_shift_left(val, shiftVal);
#line 285
    val = (int32_t )((unsigned int )__cil_tmp10 | (uint32_t )*(shift + j));
#line 286
    *(out + 0) = arith_shift_left(val, 8);
#line 287
    out += stride;
#line 281
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 285
  return;
}
}
#line 292 "/root/patchweave_donee/23/src/ALAC/matrix_dec.c"
void copyPredictorTo20(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) 
{ 
  int32_t j ;

  {
#line 298
  j = 0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;

#line 298
    if (! (j < numSamples)) {
#line 298
      goto while_break;
    }
    {
#line 300
    *(out + 0) = arith_shift_left(*(in + j), 12);
#line 301
    out += stride;
#line 298
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 302
  return;
}
}
#line 306 "/root/patchweave_donee/23/src/ALAC/matrix_dec.c"
void copyPredictorTo32(int32_t *in , int32_t *out , uint32_t stride , int32_t numSamples ) 
{ 
  int32_t i ;
  int32_t j ;
  int32_t __cil_tmp8 ;

  {
#line 311
  j = 0;
#line 311
  i = 0;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;

#line 311
    if (! (i < numSamples)) {
#line 311
      goto while_break;
    }
    {
#line 312
    *(out + j) = arith_shift_left(*(in + i), 8);
#line 311
    j = (int32_t )((uint32_t )j + stride);
#line 311
    __cil_tmp8 = i;
#line 311
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 315
  return;
}
}
#line 316 "/root/patchweave_donee/23/src/ALAC/matrix_dec.c"
void copyPredictorTo32Shift(int32_t *in , uint16_t *shift , int32_t *out , uint32_t stride ,
                            int32_t numSamples , int32_t bytesShifted ) 
{ 
  int32_t *op ;
  uint32_t shiftVal ;
  int32_t j ;
  int32_t __cil_tmp10 ;

  {
#line 318
  op = out;
#line 319
  shiftVal = (uint32_t )(bytesShifted * 8);
#line 325
  j = 0;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;

#line 325
    if (! (j < numSamples)) {
#line 325
      goto while_break;
    }
    {
#line 327
    __cil_tmp10 = arith_shift_left(*(in + j), (int )shiftVal);
#line 327
    *(op + 0) = (int32_t )((unsigned int )__cil_tmp10 | (uint32_t )*(shift + j));
#line 328
    op += stride;
#line 325
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 329
  return;
}
}
#line 49 "/root/patchweave_donee/23/src/ALAC/dplib.h"
void init_coefs(int16_t *coefs , uint32_t denshift , int32_t numPairs ) ;
#line 50
void copy_coefs(int16_t *srcCoefs , int16_t *dstCoefs , int32_t numPairs ) ;
#line 54
void pc_block(int32_t *in , int32_t *pc1 , int32_t num , int16_t *coefs , int32_t numactive ,
              uint32_t chanbits , uint32_t denshift ) ;
#line 55
void unpc_block(int32_t *pc1 , int32_t *out , int32_t num , int16_t *coefs , int32_t numactive ,
                uint32_t chanbits , uint32_t denshift ) ;
#line 43 "/root/patchweave_donee/23/src/ALAC/dp_enc.c"
void init_coefs(int16_t *coefs , uint32_t denshift , int32_t numPairs ) 
{ 
  int32_t k ;
  int32_t den ;

  {
#line 46
  den = 1 << denshift;
#line 48
  *(coefs + 0) = (int16_t )(38 * den >> 4);
#line 49
  *(coefs + 1) = (int16_t )(-29 * den >> 4);
#line 50
  *(coefs + 2) = (int16_t )(-2 * den >> 4);
#line 51
  k = 3;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;

#line 51
    if (! (k < numPairs)) {
#line 51
      goto while_break;
    }
#line 52
    *(coefs + k) = (int16_t )0;
#line 51
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 55
  return;
}
}
#line 56 "/root/patchweave_donee/23/src/ALAC/dp_enc.c"
void copy_coefs(int16_t *srcCoefs , int16_t *dstCoefs , int32_t numPairs ) 
{ 
  int32_t k ;

  {
#line 60
  k = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;

#line 60
    if (! (k < numPairs)) {
#line 60
      goto while_break;
    }
#line 61
    *(dstCoefs + k) = *(srcCoefs + k);
#line 60
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 64
  return;
}
}
#line 64 "/root/patchweave_donee/23/src/ALAC/dp_enc.c"
__inline static int32_t sign_of_int(int32_t i ) 
{ 
  int32_t negishift ;

  {
#line 68
  negishift = (int32_t )((uint32_t )(- i) >> 31);
#line 69
  return (negishift | (i >> 31));
}
}
#line 73 "/root/patchweave_donee/23/src/ALAC/dp_enc.c"
void pc_block(int32_t *in , int32_t *pc1 , int32_t num , int16_t *coefs , int32_t numactive ,
              uint32_t chanbits , uint32_t denshift ) 
{ 
  register int16_t a0 ;
  register int16_t a1 ;
  register int16_t a2 ;
  register int16_t a3 ;
  register int32_t b0 ;
  register int32_t b1 ;
  register int32_t b2 ;
  register int32_t b3 ;
  int32_t j ;
  int32_t k ;
  int32_t lim ;
  int32_t *pin ;
  int32_t sum1 ;
  int32_t dd ;
  int32_t sg ;
  int32_t sgn ;
  int32_t top ;
  int32_t del ;
  int32_t del0 ;
  uint32_t chanshift ;
  int32_t denhalf ;
  int32_t __cil_tmp30 ;
  int32_t __cil_tmp32 ;
  int32_t __cil_tmp37 ;
  int32_t __cil_tmp38 ;
  int32_t __cil_tmp39 ;
  int32_t __cil_tmp40 ;
  int32_t __cil_tmp41 ;
  register int16_t a4 ;
  register int16_t a5 ;
  register int16_t a6 ;
  register int16_t a7 ;
  register int32_t b4 ;
  register int32_t b5 ;
  register int32_t b6 ;
  register int32_t b7 ;
  int32_t *__cil_tmp51 ;
  int32_t *__cil_tmp52 ;
  int32_t *__cil_tmp53 ;
  int32_t *__cil_tmp54 ;
  int32_t *__cil_tmp55 ;
  int32_t *__cil_tmp56 ;
  int32_t *__cil_tmp57 ;
  int32_t __cil_tmp58 ;
  int32_t __cil_tmp67 ;
  int32_t __cil_tmp68 ;
  int32_t __cil_tmp69 ;
  int32_t __cil_tmp70 ;
  int32_t __cil_tmp71 ;
  int32_t __cil_tmp72 ;
  int32_t __cil_tmp73 ;
  int32_t __cil_tmp74 ;
  int32_t __cil_tmp75 ;
  int32_t __cil_tmp80 ;
  int32_t __cil_tmp82 ;

  {
#line 83
  chanshift = 32U - chanbits;
#line 84
  denhalf = 1 << (denshift - 1U);
#line 86
  *(pc1 + 0) = *(in + 0);
#line 87
  if (numactive == 0) {
#line 90
    if ((unsigned long )in != (unsigned long )pc1) {
#line 90
      if (num > 1) {
        {
#line 91
        memcpy((void *)(pc1 + 1), (void const   *)(in + 1), (unsigned long )(num - 1) * sizeof(int32_t ));
        }
      }
    }
#line 92
    return;
  }
#line 94
  if (numactive == 31) {
#line 97
    j = 1;
    {
#line 97
    while (1) {
      while_continue: /* CIL Label */ ;

#line 97
      if (! (j < num)) {
#line 97
        goto while_break;
      }
#line 99
      del = *(in + j) - *(in + (j - 1));
#line 100
      *(pc1 + j) = (del << chanshift) >> chanshift;
#line 97
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: ;
#line 102
    return;
  }
#line 105
  j = 1;
  {
#line 105
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 105
    if (! (j <= numactive)) {
#line 105
      goto while_break___0;
    }
    {
#line 107
    del = *(in + j) - *(in + (j - 1));
#line 108
    __cil_tmp30 = arith_shift_left(del, (int )chanshift);
#line 108
    *(pc1 + j) = __cil_tmp30 >> chanshift;
#line 105
    j ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___0: 
#line 111
  lim = numactive + 1;
#line 113
  if (numactive == 4) {
#line 116
    a0 = *(coefs + 0);
#line 117
    a1 = *(coefs + 1);
#line 118
    a2 = *(coefs + 2);
#line 119
    a3 = *(coefs + 3);
#line 121
    j = lim;
    {
#line 121
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: ;
#line 121
      if (! (j < num)) {
#line 121
        goto while_break___1;
      }
      {
#line 125
      top = *(in + (j - lim));
#line 126
      pin = (in + j) - 1;
#line 128
      b0 = top - *(pin + 0);
#line 129
      b1 = top - *(pin + -1);
#line 130
      b2 = top - *(pin + -2);
#line 131
      b3 = top - *(pin + -3);
#line 133
      sum1 = ((((denhalf - (int )a0 * b0) - (int )a1 * b1) - (int )a2 * b2) - (int )a3 * b3) >> denshift;
#line 135
      del = (*(in + j) - top) - sum1;
#line 136
      __cil_tmp32 = arith_shift_left(del, (int )chanshift);
#line 136
      del = __cil_tmp32 >> chanshift;
#line 137
      *(pc1 + j) = del;
#line 138
      del0 = del;
#line 140
      sg = sign_of_int(del);
      }
#line 141
      if (sg > 0) {
        {
#line 143
        sgn = sign_of_int(b3);
#line 144
        a3 = (int16_t )((int )a3 - sgn);
#line 145
        del0 -= sgn * b3 >> denshift;
        }
#line 146
        if (del0 <= 0) {
#line 147
          goto while_continue___1;
        }
        {
#line 149
        sgn = sign_of_int(b2);
#line 150
        a2 = (int16_t )((int )a2 - sgn);
#line 151
        del0 -= 2 * (sgn * b2 >> denshift);
        }
#line 152
        if (del0 <= 0) {
#line 153
          goto while_continue___1;
        }
        {
#line 155
        sgn = sign_of_int(b1);
#line 156
        a1 = (int16_t )((int )a1 - sgn);
#line 157
        del0 -= 3 * (sgn * b1 >> denshift);
        }
#line 158
        if (del0 <= 0) {
#line 159
          goto while_continue___1;
        }
        {
#line 161
        __cil_tmp37 = sign_of_int(b0);
#line 161
        a0 = (int16_t )((int )a0 - __cil_tmp37);
        }
      } else
#line 163
      if (sg < 0) {
        {
#line 166
        __cil_tmp38 = sign_of_int(b3);
#line 166
        sgn = - __cil_tmp38;
#line 167
        a3 = (int16_t )((int )a3 - sgn);
#line 168
        del0 -= sgn * b3 >> denshift;
        }
#line 169
        if (del0 >= 0) {
#line 170
          goto while_continue___1;
        }
        {
#line 172
        __cil_tmp39 = sign_of_int(b2);
#line 172
        sgn = - __cil_tmp39;
#line 173
        a2 = (int16_t )((int )a2 - sgn);
#line 174
        del0 -= 2 * (sgn * b2 >> denshift);
        }
#line 175
        if (del0 >= 0) {
#line 176
          goto while_continue___1;
        }
        {
#line 178
        __cil_tmp40 = sign_of_int(b1);
#line 178
        sgn = - __cil_tmp40;
#line 179
        a1 = (int16_t )((int )a1 - sgn);
#line 180
        del0 -= 3 * (sgn * b1 >> denshift);
        }
#line 181
        if (del0 >= 0) {
#line 182
          goto while_continue___1;
        }
        {
#line 184
        __cil_tmp41 = sign_of_int(b0);
#line 184
        a0 = (int16_t )((int )a0 + __cil_tmp41);
        }
      }
#line 121
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___1: 
#line 188
    *(coefs + 0) = a0;
#line 189
    *(coefs + 1) = a1;
#line 190
    *(coefs + 2) = a2;
#line 191
    *(coefs + 3) = a3;
  } else
#line 193
  if (numactive == 8) {
#line 199
    a0 = *(coefs + 0);
#line 200
    a1 = *(coefs + 1);
#line 201
    a2 = *(coefs + 2);
#line 202
    a3 = *(coefs + 3);
#line 203
    a4 = *(coefs + 4);
#line 204
    a5 = *(coefs + 5);
#line 205
    a6 = *(coefs + 6);
#line 206
    a7 = *(coefs + 7);
#line 208
    j = lim;
    {
#line 208
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___2: ;
#line 208
      if (! (j < num)) {
#line 208
        goto while_break___2;
      }
      {
#line 212
      top = *(in + (j - lim));
#line 213
      pin = (in + j) - 1;
#line 215
      __cil_tmp51 = pin;
#line 215
      pin --;
#line 215
      b0 = top - *__cil_tmp51;
#line 216
      __cil_tmp52 = pin;
#line 216
      pin --;
#line 216
      b1 = top - *__cil_tmp52;
#line 217
      __cil_tmp53 = pin;
#line 217
      pin --;
#line 217
      b2 = top - *__cil_tmp53;
#line 218
      __cil_tmp54 = pin;
#line 218
      pin --;
#line 218
      b3 = top - *__cil_tmp54;
#line 219
      __cil_tmp55 = pin;
#line 219
      pin --;
#line 219
      b4 = top - *__cil_tmp55;
#line 220
      __cil_tmp56 = pin;
#line 220
      pin --;
#line 220
      b5 = top - *__cil_tmp56;
#line 221
      __cil_tmp57 = pin;
#line 221
      pin --;
#line 221
      b6 = top - *__cil_tmp57;
#line 222
      b7 = top - *pin;
#line 223
      pin += 8;
#line 225
      sum1 = ((((((((denhalf - (int )a0 * b0) - (int )a1 * b1) - (int )a2 * b2) - (int )a3 * b3) - (int )a4 * b4) - (int )a5 * b5) - (int )a6 * b6) - (int )a7 * b7) >> denshift;
#line 228
      del = (*(in + j) - top) - sum1;
#line 229
      __cil_tmp58 = arith_shift_left(del, (int )chanshift);
#line 229
      del = __cil_tmp58 >> chanshift;
#line 230
      *(pc1 + j) = del;
#line 231
      del0 = del;
#line 233
      sg = sign_of_int(del);
      }
#line 234
      if (sg > 0) {
        {
#line 236
        sgn = sign_of_int(b7);
#line 237
        a7 = (int16_t )((int )a7 - sgn);
#line 238
        del0 -= sgn * b7 >> denshift;
        }
#line 239
        if (del0 <= 0) {
#line 240
          goto while_continue___2;
        }
        {
#line 242
        sgn = sign_of_int(b6);
#line 243
        a6 = (int16_t )((int )a6 - sgn);
#line 244
        del0 -= 2 * (sgn * b6 >> denshift);
        }
#line 245
        if (del0 <= 0) {
#line 246
          goto while_continue___2;
        }
        {
#line 248
        sgn = sign_of_int(b5);
#line 249
        a5 = (int16_t )((int )a5 - sgn);
#line 250
        del0 -= 3 * (sgn * b5 >> denshift);
        }
#line 251
        if (del0 <= 0) {
#line 252
          goto while_continue___2;
        }
        {
#line 254
        sgn = sign_of_int(b4);
#line 255
        a4 = (int16_t )((int )a4 - sgn);
#line 256
        del0 -= 4 * (sgn * b4 >> denshift);
        }
#line 257
        if (del0 <= 0) {
#line 258
          goto while_continue___2;
        }
        {
#line 260
        sgn = sign_of_int(b3);
#line 261
        a3 = (int16_t )((int )a3 - sgn);
#line 262
        del0 -= 5 * (sgn * b3 >> denshift);
        }
#line 263
        if (del0 <= 0) {
#line 264
          goto while_continue___2;
        }
        {
#line 266
        sgn = sign_of_int(b2);
#line 267
        a2 = (int16_t )((int )a2 - sgn);
#line 268
        del0 -= 6 * (sgn * b2 >> denshift);
        }
#line 269
        if (del0 <= 0) {
#line 270
          goto while_continue___2;
        }
        {
#line 272
        sgn = sign_of_int(b1);
#line 273
        a1 = (int16_t )((int )a1 - sgn);
#line 274
        del0 -= 7 * (sgn * b1 >> denshift);
        }
#line 275
        if (del0 <= 0) {
#line 276
          goto while_continue___2;
        }
        {
#line 278
        __cil_tmp67 = sign_of_int(b0);
#line 278
        a0 = (int16_t )((int )a0 - __cil_tmp67);
        }
      } else
#line 280
      if (sg < 0) {
        {
#line 283
        __cil_tmp68 = sign_of_int(b7);
#line 283
        sgn = - __cil_tmp68;
#line 284
        a7 = (int16_t )((int )a7 - sgn);
#line 285
        del0 -= sgn * b7 >> denshift;
        }
#line 286
        if (del0 >= 0) {
#line 287
          goto while_continue___2;
        }
        {
#line 289
        __cil_tmp69 = sign_of_int(b6);
#line 289
        sgn = - __cil_tmp69;
#line 290
        a6 = (int16_t )((int )a6 - sgn);
#line 291
        del0 -= 2 * (sgn * b6 >> denshift);
        }
#line 292
        if (del0 >= 0) {
#line 293
          goto while_continue___2;
        }
        {
#line 295
        __cil_tmp70 = sign_of_int(b5);
#line 295
        sgn = - __cil_tmp70;
#line 296
        a5 = (int16_t )((int )a5 - sgn);
#line 297
        del0 -= 3 * (sgn * b5 >> denshift);
        }
#line 298
        if (del0 >= 0) {
#line 299
          goto while_continue___2;
        }
        {
#line 301
        __cil_tmp71 = sign_of_int(b4);
#line 301
        sgn = - __cil_tmp71;
#line 302
        a4 = (int16_t )((int )a4 - sgn);
#line 303
        del0 -= 4 * (sgn * b4 >> denshift);
        }
#line 304
        if (del0 >= 0) {
#line 305
          goto while_continue___2;
        }
        {
#line 307
        __cil_tmp72 = sign_of_int(b3);
#line 307
        sgn = - __cil_tmp72;
#line 308
        a3 = (int16_t )((int )a3 - sgn);
#line 309
        del0 -= 5 * (sgn * b3 >> denshift);
        }
#line 310
        if (del0 >= 0) {
#line 311
          goto while_continue___2;
        }
        {
#line 313
        __cil_tmp73 = sign_of_int(b2);
#line 313
        sgn = - __cil_tmp73;
#line 314
        a2 = (int16_t )((int )a2 - sgn);
#line 315
        del0 -= 6 * (sgn * b2 >> denshift);
        }
#line 316
        if (del0 >= 0) {
#line 317
          goto while_continue___2;
        }
        {
#line 319
        __cil_tmp74 = sign_of_int(b1);
#line 319
        sgn = - __cil_tmp74;
#line 320
        a1 = (int16_t )((int )a1 - sgn);
#line 321
        del0 -= 7 * (sgn * b1 >> denshift);
        }
#line 322
        if (del0 >= 0) {
#line 323
          goto while_continue___2;
        }
        {
#line 325
        __cil_tmp75 = sign_of_int(b0);
#line 325
        a0 = (int16_t )((int )a0 + __cil_tmp75);
        }
      }
#line 208
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: 
#line 329
    *(coefs + 0) = a0;
#line 330
    *(coefs + 1) = a1;
#line 331
    *(coefs + 2) = a2;
#line 332
    *(coefs + 3) = a3;
#line 333
    *(coefs + 4) = a4;
#line 334
    *(coefs + 5) = a5;
#line 335
    *(coefs + 6) = a6;
#line 336
    *(coefs + 7) = a7;
  } else {
#line 342
    j = lim;
    {
#line 342
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 342
      if (! (j < num)) {
#line 342
        goto while_break___3;
      }
#line 346
      top = *(in + (j - lim));
#line 347
      pin = (in + j) - 1;
#line 349
      sum1 = 0;
#line 350
      k = 0;
      {
#line 350
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 350
        if (! (k < numactive)) {
#line 350
          goto while_break___4;
        }
#line 351
        sum1 -= (int )*(coefs + k) * (top - *(pin + - k));
#line 350
        k ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: 
      {
#line 353
      del = (*(in + j) - top) - ((sum1 + denhalf) >> denshift);
#line 354
      del = (del << chanshift) >> chanshift;
#line 355
      *(pc1 + j) = del;
#line 356
      del0 = del;
#line 358
      sg = sign_of_int(del);
      }
#line 359
      if (sg > 0) {
#line 361
        k = numactive - 1;
        {
#line 361
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 361
          if (! (k >= 0)) {
#line 361
            goto while_break___5;
          }
          {
#line 363
          dd = top - *(pin + - k);
#line 364
          sgn = sign_of_int(dd);
#line 365
          *(coefs + k) = (int16_t )((int )*(coefs + k) - sgn);
#line 366
          del0 -= (numactive - k) * (sgn * dd >> denshift);
          }
#line 367
          if (del0 <= 0) {
#line 368
            goto while_break___5;
          }
#line 361
          __cil_tmp80 = k;
#line 361
          k --;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: ;
      } else
#line 371
      if (sg < 0) {
#line 373
        k = numactive - 1;
        {
#line 373
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 373
          if (! (k >= 0)) {
#line 373
            goto while_break___6;
          }
          {
#line 375
          dd = top - *(pin + - k);
#line 376
          sgn = sign_of_int(dd);
#line 377
          *(coefs + k) = (int16_t )((int )*(coefs + k) + sgn);
#line 378
          del0 -= (numactive - k) * (- sgn * dd >> denshift);
          }
#line 379
          if (del0 >= 0) {
#line 380
            goto while_break___6;
          }
#line 373
          __cil_tmp82 = k;
#line 373
          k --;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: ;
      }
#line 342
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: ;
  }
#line 347
  return;
}
}
#line 53 "/root/patchweave_donee/23/src/ALAC/dp_dec.c"
void unpc_block(int32_t *pc1 , int32_t *out , int32_t num , int16_t *coefs , int32_t numactive ,
                uint32_t chanbits , uint32_t denshift ) 
{ 
  register int16_t a0 ;
  register int16_t a1 ;
  register int16_t a2 ;
  register int16_t a3 ;
  register int32_t b0 ;
  register int32_t b1 ;
  register int32_t b2 ;
  register int32_t b3 ;
  int32_t j ;
  int32_t k ;
  int32_t lim ;
  int32_t sum1 ;
  int32_t sg ;
  int32_t sgn ;
  int32_t top ;
  int32_t dd ;
  int32_t *pout ;
  int32_t del ;
  int32_t del0 ;
  uint32_t chanshift ;
  int32_t denhalf ;
  int32_t prev ;
  int32_t __cil_tmp31 ;
  register int16_t ia0 ;
  register int16_t ia1 ;
  register int16_t ia2 ;
  register int16_t ia3 ;
  register int32_t ib0 ;
  register int32_t ib1 ;
  register int32_t ib2 ;
  register int32_t ib3 ;
  int32_t __cil_tmp42 ;
  int32_t __cil_tmp46 ;
  int32_t __cil_tmp47 ;
  int32_t __cil_tmp48 ;
  int32_t __cil_tmp49 ;
  int32_t __cil_tmp50 ;
  register int16_t a4 ;
  register int16_t a5 ;
  register int16_t a6 ;
  register int16_t a7 ;
  register int32_t b4 ;
  register int32_t b5 ;
  register int32_t b6 ;
  register int32_t b7 ;
  int32_t *__cil_tmp60 ;
  int32_t *__cil_tmp61 ;
  int32_t *__cil_tmp62 ;
  int32_t *__cil_tmp63 ;
  int32_t *__cil_tmp64 ;
  int32_t *__cil_tmp65 ;
  int32_t *__cil_tmp66 ;
  int32_t __cil_tmp68 ;
  int32_t __cil_tmp76 ;
  int32_t __cil_tmp77 ;
  int32_t __cil_tmp78 ;
  int32_t __cil_tmp79 ;
  int32_t __cil_tmp80 ;
  int32_t __cil_tmp81 ;
  int32_t __cil_tmp82 ;
  int32_t __cil_tmp83 ;
  int32_t __cil_tmp84 ;
  int32_t __cil_tmp89 ;
  int32_t __cil_tmp91 ;

  {
#line 61
  chanshift = 32U - chanbits;
#line 62
  denhalf = 1 << (denshift - 1U);
#line 64
  *(out + 0) = *(pc1 + 0);
#line 65
  if (numactive == 0) {
#line 68
    if ((unsigned long )pc1 != (unsigned long )out) {
#line 68
      if (num > 1) {
        {
#line 69
        memcpy((void *)(out + 1), (void const   *)(pc1 + 1), (unsigned long )(num - 1) * sizeof(int32_t ));
        }
      }
    }
#line 70
    return;
  }
#line 72
  if (numactive == 31) {
#line 85
    prev = *(out + 0);
#line 86
    j = 1;
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;

#line 86
      if (! (j < num)) {
#line 86
        goto while_break;
      }
#line 88
      del = *(pc1 + j) + prev;
#line 89
      prev = (del << chanshift) >> chanshift;
#line 90
      *(out + j) = prev;
#line 86
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: ;
#line 92
    return;
  }
#line 95
  j = 1;
  {
#line 95
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 95
    if (! (j <= numactive)) {
#line 95
      goto while_break___0;
    }
    {
#line 97
    del = *(pc1 + j) + *(out + (j - 1));
#line 98
    __cil_tmp31 = arith_shift_left(del, (int )chanshift);
#line 98
    *(out + j) = __cil_tmp31 >> chanshift;
#line 95
    j ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___0: 
#line 101
  lim = numactive + 1;
#line 103
  if (numactive == 4) {
#line 109
    ia0 = *(coefs + 0);
#line 110
    ia1 = *(coefs + 1);
#line 111
    ia2 = *(coefs + 2);
#line 112
    ia3 = *(coefs + 3);
#line 114
    j = lim;
    {
#line 114
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: ;
#line 114
      if (! (j < num)) {
#line 114
        goto while_break___1;
      }
      {
#line 118
      top = *(out + (j - lim));
#line 119
      pout = (out + j) - 1;
#line 121
      ib0 = top - *(pout + 0);
#line 122
      ib1 = top - *(pout + -1);
#line 123
      ib2 = top - *(pout + -2);
#line 124
      ib3 = top - *(pout + -3);
#line 126
      sum1 = ((((denhalf - (int )ia0 * ib0) - (int )ia1 * ib1) - (int )ia2 * ib2) - (int )ia3 * ib3) >> denshift;
#line 128
      del = *(pc1 + j);
#line 129
      del0 = del;
#line 130
      sg = sign_of_int(del);
#line 131
      del += top + sum1;
#line 133
      __cil_tmp42 = arith_shift_left(del, (int )chanshift);
#line 133
      *(out + j) = __cil_tmp42 >> chanshift;
      }
#line 135
      if (sg > 0) {
        {
#line 137
        sgn = sign_of_int(ib3);
#line 138
        ia3 = (int16_t )((int )ia3 - sgn);
#line 139
        del0 -= sgn * ib3 >> denshift;
        }
#line 140
        if (del0 <= 0) {
#line 141
          goto while_continue___1;
        }
        {
#line 143
        sgn = sign_of_int(ib2);
#line 144
        ia2 = (int16_t )((int )ia2 - sgn);
#line 145
        del0 -= 2 * (sgn * ib2 >> denshift);
        }
#line 146
        if (del0 <= 0) {
#line 147
          goto while_continue___1;
        }
        {
#line 149
        sgn = sign_of_int(ib1);
#line 150
        ia1 = (int16_t )((int )ia1 - sgn);
#line 151
        del0 -= 3 * (sgn * ib1 >> denshift);
        }
#line 152
        if (del0 <= 0) {
#line 153
          goto while_continue___1;
        }
        {
#line 155
        __cil_tmp46 = sign_of_int(ib0);
#line 155
        ia0 = (int16_t )((int )ia0 - __cil_tmp46);
        }
      } else
#line 157
      if (sg < 0) {
        {
#line 160
        __cil_tmp47 = sign_of_int(ib3);
#line 160
        sgn = - __cil_tmp47;
#line 161
        ia3 = (int16_t )((int )ia3 - sgn);
#line 162
        del0 -= sgn * ib3 >> denshift;
        }
#line 163
        if (del0 >= 0) {
#line 164
          goto while_continue___1;
        }
        {
#line 166
        __cil_tmp48 = sign_of_int(ib2);
#line 166
        sgn = - __cil_tmp48;
#line 167
        ia2 = (int16_t )((int )ia2 - sgn);
#line 168
        del0 -= 2 * (sgn * ib2 >> denshift);
        }
#line 169
        if (del0 >= 0) {
#line 170
          goto while_continue___1;
        }
        {
#line 172
        __cil_tmp49 = sign_of_int(ib1);
#line 172
        sgn = - __cil_tmp49;
#line 173
        ia1 = (int16_t )((int )ia1 - sgn);
#line 174
        del0 -= 3 * (sgn * ib1 >> denshift);
        }
#line 175
        if (del0 >= 0) {
#line 176
          goto while_continue___1;
        }
        {
#line 178
        __cil_tmp50 = sign_of_int(ib0);
#line 178
        ia0 = (int16_t )((int )ia0 + __cil_tmp50);
        }
      }
#line 114
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___1: 
#line 182
    *(coefs + 0) = ia0;
#line 183
    *(coefs + 1) = ia1;
#line 184
    *(coefs + 2) = ia2;
#line 185
    *(coefs + 3) = ia3;
  } else
#line 187
  if (numactive == 8) {
#line 193
    a0 = *(coefs + 0);
#line 194
    a1 = *(coefs + 1);
#line 195
    a2 = *(coefs + 2);
#line 196
    a3 = *(coefs + 3);
#line 197
    a4 = *(coefs + 4);
#line 198
    a5 = *(coefs + 5);
#line 199
    a6 = *(coefs + 6);
#line 200
    a7 = *(coefs + 7);
#line 202
    j = lim;
    {
#line 202
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___2: ;
#line 202
      if (! (j < num)) {
#line 202
        goto while_break___2;
      }
      {
#line 206
      top = *(out + (j - lim));
#line 207
      pout = (out + j) - 1;
#line 209
      __cil_tmp60 = pout;
#line 209
      pout --;
#line 209
      b0 = top - *__cil_tmp60;
#line 210
      __cil_tmp61 = pout;
#line 210
      pout --;
#line 210
      b1 = top - *__cil_tmp61;
#line 211
      __cil_tmp62 = pout;
#line 211
      pout --;
#line 211
      b2 = top - *__cil_tmp62;
#line 212
      __cil_tmp63 = pout;
#line 212
      pout --;
#line 212
      b3 = top - *__cil_tmp63;
#line 213
      __cil_tmp64 = pout;
#line 213
      pout --;
#line 213
      b4 = top - *__cil_tmp64;
#line 214
      __cil_tmp65 = pout;
#line 214
      pout --;
#line 214
      b5 = top - *__cil_tmp65;
#line 215
      __cil_tmp66 = pout;
#line 215
      pout --;
#line 215
      b6 = top - *__cil_tmp66;
#line 216
      b7 = top - *pout;
#line 217
      pout += 8;
#line 219
      sum1 = ((((((((denhalf - (int )a0 * b0) - (int )a1 * b1) - (int )a2 * b2) - (int )a3 * b3) - (int )a4 * b4) - (int )a5 * b5) - (int )a6 * b6) - (int )a7 * b7) >> denshift;
#line 222
      del = *(pc1 + j);
#line 223
      del0 = del;
#line 224
      sg = sign_of_int(del);
#line 225
      del += top + sum1;
#line 227
      __cil_tmp68 = arith_shift_left(del, (int )chanshift);
#line 227
      *(out + j) = __cil_tmp68 >> chanshift;
      }
#line 229
      if (sg > 0) {
        {
#line 231
        sgn = sign_of_int(b7);
#line 232
        a7 = (int16_t )((int )a7 - sgn);
#line 233
        del0 -= sgn * b7 >> denshift;
        }
#line 234
        if (del0 <= 0) {
#line 235
          goto while_continue___2;
        }
        {
#line 237
        sgn = sign_of_int(b6);
#line 238
        a6 = (int16_t )((int )a6 - sgn);
#line 239
        del0 -= 2 * (sgn * b6 >> denshift);
        }
#line 240
        if (del0 <= 0) {
#line 241
          goto while_continue___2;
        }
        {
#line 243
        sgn = sign_of_int(b5);
#line 244
        a5 = (int16_t )((int )a5 - sgn);
#line 245
        del0 -= 3 * (sgn * b5 >> denshift);
        }
#line 246
        if (del0 <= 0) {
#line 247
          goto while_continue___2;
        }
        {
#line 249
        sgn = sign_of_int(b4);
#line 250
        a4 = (int16_t )((int )a4 - sgn);
#line 251
        del0 -= 4 * (sgn * b4 >> denshift);
        }
#line 252
        if (del0 <= 0) {
#line 253
          goto while_continue___2;
        }
        {
#line 255
        sgn = sign_of_int(b3);
#line 256
        a3 = (int16_t )((int )a3 - sgn);
#line 257
        del0 -= 5 * (sgn * b3 >> denshift);
        }
#line 258
        if (del0 <= 0) {
#line 259
          goto while_continue___2;
        }
        {
#line 261
        sgn = sign_of_int(b2);
#line 262
        a2 = (int16_t )((int )a2 - sgn);
#line 263
        del0 -= 6 * (sgn * b2 >> denshift);
        }
#line 264
        if (del0 <= 0) {
#line 265
          goto while_continue___2;
        }
        {
#line 267
        sgn = sign_of_int(b1);
#line 268
        a1 = (int16_t )((int )a1 - sgn);
#line 269
        del0 -= 7 * (sgn * b1 >> denshift);
        }
#line 270
        if (del0 <= 0) {
#line 271
          goto while_continue___2;
        }
        {
#line 273
        __cil_tmp76 = sign_of_int(b0);
#line 273
        a0 = (int16_t )((int )a0 - __cil_tmp76);
        }
      } else
#line 275
      if (sg < 0) {
        {
#line 278
        __cil_tmp77 = sign_of_int(b7);
#line 278
        sgn = - __cil_tmp77;
#line 279
        a7 = (int16_t )((int )a7 - sgn);
#line 280
        del0 -= sgn * b7 >> denshift;
        }
#line 281
        if (del0 >= 0) {
#line 282
          goto while_continue___2;
        }
        {
#line 284
        __cil_tmp78 = sign_of_int(b6);
#line 284
        sgn = - __cil_tmp78;
#line 285
        a6 = (int16_t )((int )a6 - sgn);
#line 286
        del0 -= 2 * (sgn * b6 >> denshift);
        }
#line 287
        if (del0 >= 0) {
#line 288
          goto while_continue___2;
        }
        {
#line 290
        __cil_tmp79 = sign_of_int(b5);
#line 290
        sgn = - __cil_tmp79;
#line 291
        a5 = (int16_t )((int )a5 - sgn);
#line 292
        del0 -= 3 * (sgn * b5 >> denshift);
        }
#line 293
        if (del0 >= 0) {
#line 294
          goto while_continue___2;
        }
        {
#line 296
        __cil_tmp80 = sign_of_int(b4);
#line 296
        sgn = - __cil_tmp80;
#line 297
        a4 = (int16_t )((int )a4 - sgn);
#line 298
        del0 -= 4 * (sgn * b4 >> denshift);
        }
#line 299
        if (del0 >= 0) {
#line 300
          goto while_continue___2;
        }
        {
#line 302
        __cil_tmp81 = sign_of_int(b3);
#line 302
        sgn = - __cil_tmp81;
#line 303
        a3 = (int16_t )((int )a3 - sgn);
#line 304
        del0 -= 5 * (sgn * b3 >> denshift);
        }
#line 305
        if (del0 >= 0) {
#line 306
          goto while_continue___2;
        }
        {
#line 308
        __cil_tmp82 = sign_of_int(b2);
#line 308
        sgn = - __cil_tmp82;
#line 309
        a2 = (int16_t )((int )a2 - sgn);
#line 310
        del0 -= 6 * (sgn * b2 >> denshift);
        }
#line 311
        if (del0 >= 0) {
#line 312
          goto while_continue___2;
        }
        {
#line 314
        __cil_tmp83 = sign_of_int(b1);
#line 314
        sgn = - __cil_tmp83;
#line 315
        a1 = (int16_t )((int )a1 - sgn);
#line 316
        del0 -= 7 * (sgn * b1 >> denshift);
        }
#line 317
        if (del0 >= 0) {
#line 318
          goto while_continue___2;
        }
        {
#line 320
        __cil_tmp84 = sign_of_int(b0);
#line 320
        a0 = (int16_t )((int )a0 + __cil_tmp84);
        }
      }
#line 202
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: 
#line 324
    *(coefs + 0) = a0;
#line 325
    *(coefs + 1) = a1;
#line 326
    *(coefs + 2) = a2;
#line 327
    *(coefs + 3) = a3;
#line 328
    *(coefs + 4) = a4;
#line 329
    *(coefs + 5) = a5;
#line 330
    *(coefs + 6) = a6;
#line 331
    *(coefs + 7) = a7;
  } else {
#line 336
    j = lim;
    {
#line 336
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 336
      if (! (j < num)) {
#line 336
        goto while_break___3;
      }
#line 340
      sum1 = 0;
#line 341
      pout = (out + j) - 1;
#line 342
      top = *(out + (j - lim));
#line 344
      k = 0;
      {
#line 344
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 344
        if (! (k < numactive)) {
#line 344
          goto while_break___4;
        }
#line 345
        sum1 += (int )*(coefs + k) * (*(pout + - k) - top);
#line 344
        k ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: 
      {
#line 347
      del = *(pc1 + j);
#line 348
      del0 = del;
#line 349
      sg = sign_of_int(del);
#line 350
      del += top + ((sum1 + denhalf) >> denshift);
#line 351
      *(out + j) = (del << chanshift) >> chanshift;
      }
#line 353
      if (sg > 0) {
#line 355
        k = numactive - 1;
        {
#line 355
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 355
          if (! (k >= 0)) {
#line 355
            goto while_break___5;
          }
          {
#line 357
          dd = top - *(pout + - k);
#line 358
          sgn = sign_of_int(dd);
#line 359
          *(coefs + k) = (int16_t )((int )*(coefs + k) - sgn);
#line 360
          del0 -= (numactive - k) * (sgn * dd >> denshift);
          }
#line 361
          if (del0 <= 0) {
#line 362
            goto while_break___5;
          }
#line 355
          __cil_tmp89 = k;
#line 355
          k --;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: ;
      } else
#line 365
      if (sg < 0) {
#line 367
        k = numactive - 1;
        {
#line 367
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 367
          if (! (k >= 0)) {
#line 367
            goto while_break___6;
          }
          {
#line 369
          dd = top - *(pout + - k);
#line 370
          sgn = sign_of_int(dd);
#line 371
          *(coefs + k) = (int16_t )((int )*(coefs + k) + sgn);
#line 372
          del0 -= (numactive - k) * (- sgn * dd >> denshift);
          }
#line 373
          if (del0 >= 0) {
#line 374
            goto while_break___6;
          }
#line 367
          __cil_tmp91 = k;
#line 367
          k --;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: ;
      }
#line 336
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: ;
  }
#line 341
  return;
}
}
#line 577 "/usr/include/stdio.h"
__inline extern char *( __attribute__((__gnu_inline__)) gets)(char *__str ) ;
#line 229 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern char *__gets_chk(char *__str , size_t  ) ;
#line 230
extern char *__gets_warn(char *__str ) ;
#line 235 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__gnu_inline__)) gets)(char *__str ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 237
  __cil_tmp2 = __builtin_object_size((void *)__str, 1);
  }
#line 237
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 238
    __cil_tmp3 = __builtin_object_size((void *)__str, 1);
#line 238
    __cil_tmp4 = __gets_chk(__str, __cil_tmp3);
    }
#line 238
    return (__cil_tmp4);
  }
  {
#line 239
  __cil_tmp5 = __gets_warn(__str);
  }
#line 239
  return (__cil_tmp5);
}
}
#line 125 "/root/patchweave_donee/23/src/ALAC/ALACAudioTypes.h"
static ALACChannelLayoutTag ALACChannelLayoutTags___2[8]  = 
#line 125 "/root/patchweave_donee/23/src/ALAC/ALACAudioTypes.h"
  {      (ALACChannelLayoutTag )6553601,      (ALACChannelLayoutTag )6619138,      (ALACChannelLayoutTag )7405571,      (ALACChannelLayoutTag )7602180, 
        (ALACChannelLayoutTag )7864325,      (ALACChannelLayoutTag )8126470,      (ALACChannelLayoutTag )9306119,      (ALACChannelLayoutTag )8323080};
#line 70 "/root/patchweave_donee/23/src/ALAC/aglib.h"
void set_standard_ag_params(AGParamRecPtr params , uint32_t fullwidth , uint32_t sectorwidth ) ;
#line 71
void set_ag_params(AGParamRecPtr params , uint32_t m , uint32_t p , uint32_t k , uint32_t f ,
                   uint32_t s , uint32_t maxrun ) ;
#line 73
int32_t dyn_comp(AGParamRecPtr params , int32_t *pc , BitBuffer *bitstream , int32_t numSamples ,
                 int32_t bitSize , uint32_t *outNumBits ) ;
#line 74
int32_t dyn_decomp(AGParamRecPtr params , BitBuffer *bitstream , int32_t *pc , int32_t numSamples ,
                   int32_t maxSize , uint32_t *outNumBits ) ;
#line 53 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
void GetConfig(ALAC_ENCODER *p , ALACSpecificConfig *config ) ;
#line 55
static int32_t EncodeStereo(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                            uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) ;
#line 56
static int32_t EncodeStereoFast(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                                uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) ;
#line 57
static int32_t EncodeStereoEscape(ALAC_ENCODER *p , struct BitBuffer *bitstream ,
                                  int32_t *inputBuffer , uint32_t stride , uint32_t numSamples ) ;
#line 58
static int32_t EncodeMono(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                          uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) ;
#line 67 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
uint32_t kALACEncoderMagic  =    (unsigned int )((100 | (112 << 8)) | (103 << 16)) | (101U << 24);
#line 68 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
uint32_t kMaxSampleSize  =    (uint32_t )32;
#line 69 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
uint32_t kDefaultMixBits  =    (uint32_t )2;
#line 70 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
uint32_t kDefaultMixRes  =    (uint32_t )0;
#line 71 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
uint32_t kMaxRes  =    (uint32_t )4;
#line 72 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
uint32_t kDefaultNumUV  =    (uint32_t )8;
#line 73 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
uint32_t kMinUV  =    (uint32_t )4;
#line 74 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
uint32_t kMaxUV  =    (uint32_t )8;
#line 101 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
static uint32_t sChannelMaps[8]  = 
#line 101
  {      (uint32_t )0,      (uint32_t )1,      (uint32_t )(1 << 3),      (uint32_t )(1 << 3), 
        (uint32_t )((1 << 9) | (1 << 3)),      (uint32_t )((1 << 9) | (1 << 3)),      (uint32_t )((1 << 9) | (1 << 3)),      (uint32_t )(((1 << 15) | (1 << 9)) | (1 << 3))};
#line 124 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
void alac_set_fastmode(ALAC_ENCODER *p , int32_t fast ) 
{ 


  {
#line 126
  p->mFastMode = fast;
#line 127
  return;
}
}
#line 228 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
static int32_t EncodeStereo(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                            uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) 
{ 
  BitBuffer workBits ;
  BitBuffer startBits ;
  AGParamRec agParams ;
  uint32_t bits1 ;
  uint32_t bits2 ;
  uint32_t dilate ;
  int32_t mixBits ;
  int32_t mixRes ;
  int32_t maxRes ;
  uint32_t minBits ;
  uint32_t minBits1 ;
  uint32_t minBits2 ;
  uint32_t numU ;
  uint32_t numV ;
  uint32_t mode ;
  uint32_t pbFactor ;
  uint32_t chanBits ;
  uint8_t bytesShifted ;
  SearchCoefs coefsU ;
  SearchCoefs coefsV ;
  uint32_t indx ;
  uint8_t partialFrame ;
  uint32_t escapeBits ;
  bool doEscape ;
  int32_t status ;
  int32_t bestRes ;
  int tmp ;
  uint32_t numUV ;
  uint32_t converge ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t bitShift ;
  uint32_t shiftedVal ;
  uint32_t __cil_tmp51 ;
  uint32_t __cil_tmp52 ;

  {
#line 231
  startBits = *bitstream;
#line 248
  status = 0;
#line 252
  if (! ((int )p->mBitDepth == 16)) {
#line 252
    if (! ((int )p->mBitDepth == 20)) {
#line 252
      if (! ((int )p->mBitDepth == 24)) {
#line 252
        if (! ((int )p->mBitDepth == 32)) {
#line 252
          return (-50);
        }
      }
    }
  }
#line 259
  coefsU = p->mCoefsU[channelIndex];
#line 260
  coefsV = p->mCoefsV[channelIndex];
#line 265
  if ((int )p->mBitDepth == 32) {
#line 266
    bytesShifted = (uint8_t )2;
  } else
#line 267
  if ((int )p->mBitDepth >= 24) {
#line 268
    bytesShifted = (uint8_t )1;
  } else {
#line 270
    bytesShifted = (uint8_t )0;
  }
#line 272
  chanBits = (uint32_t )(((int )p->mBitDepth - (int )bytesShifted * 8) + 1);
#line 275
  if (numSamples == p->mFrameSize) {
#line 275
    tmp = 0;
  } else {
#line 275
    tmp = 1;
  }
#line 275
  partialFrame = (uint8_t )tmp;
#line 279
  mixBits = (int32_t )kDefaultMixBits;
#line 280
  maxRes = (int32_t )kMaxRes;
#line 281
  numV = kDefaultNumUV;
#line 281
  numU = numV;
#line 282
  mode = (uint32_t )0;
#line 283
  pbFactor = (uint32_t )4;
#line 284
  dilate = (uint32_t )8;
#line 286
  minBits2 = (uint32_t )(1UL << 31);
#line 286
  minBits1 = minBits2;
#line 286
  minBits = minBits1;
#line 288
  bestRes = (int32_t )p->mLastMixRes[channelIndex];
#line 290
  mixRes = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;

#line 290
    if (! (mixRes <= maxRes)) {
#line 290
      goto while_break;
    }
#line 295
    if ((int )p->mBitDepth == 16) {
#line 295
      goto case_16;
    }
#line 298
    if ((int )p->mBitDepth == 20) {
#line 298
      goto case_20;
    }
#line 301
    if ((int )p->mBitDepth == 24) {
#line 301
      goto case_24;
    }
#line 306
    if ((int )p->mBitDepth == 32) {
#line 306
      goto case_32;
    }
#line 293
    goto switch_break;
    case_16: 
    {
#line 296
    mix16(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )(numSamples / dilate),
          mixBits, mixRes);
    }
#line 297
    goto switch_break;
    case_20: 
    {
#line 299
    mix20(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )(numSamples / dilate),
          mixBits, mixRes);
    }
#line 300
    goto switch_break;
    case_24: 
    {
#line 303
    mix24(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )(numSamples / dilate),
          mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
    }
#line 305
    goto switch_break;
    case_32: 
    {
#line 308
    mix32(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )(numSamples / dilate),
          mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
    }
#line 310
    goto switch_break;
    switch_break: 
    {
#line 313
    BitBufferInit(& workBits, p->mWorkBuffer, p->mMaxOutputBytes);
#line 316
    pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )(numSamples / dilate), *(coefsU + (numU - 1U)),
             (int32_t )numU, chanBits, (uint32_t )9);
#line 317
    pc_block(p->mMixBufferV, p->mPredictorV, (int32_t )(numSamples / dilate), *(coefsV + (numV - 1U)),
             (int32_t )numV, chanBits, (uint32_t )9);
#line 320
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples / dilate, numSamples / dilate, (uint32_t )255);
#line 321
    status = dyn_comp(& agParams, p->mPredictorU, & workBits, (int32_t )(numSamples / dilate),
                      (int32_t )chanBits, & bits1);
    }
#line 322
    if (status) {
#line 322
      goto Exit;
    }
    {
#line 324
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples / dilate, numSamples / dilate, (uint32_t )255);
#line 325
    status = dyn_comp(& agParams, p->mPredictorV, & workBits, (int32_t )(numSamples / dilate),
                      (int32_t )chanBits, & bits2);
    }
#line 326
    if (status) {
#line 326
      goto Exit;
    }
#line 329
    if (bits1 + bits2 < minBits1) {
#line 331
      minBits1 = bits1 + bits2;
#line 332
      bestRes = mixRes;
    }
#line 290
    mixRes ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 336
  p->mLastMixRes[channelIndex] = (int16_t )bestRes;
#line 339
  mixRes = (int32_t )p->mLastMixRes[channelIndex];
#line 342
  if ((int )p->mBitDepth == 16) {
#line 342
    goto case_16___0;
  }
#line 345
  if ((int )p->mBitDepth == 20) {
#line 345
    goto case_20___0;
  }
#line 348
  if ((int )p->mBitDepth == 24) {
#line 348
    goto case_24___0;
  }
#line 353
  if ((int )p->mBitDepth == 32) {
#line 353
    goto case_32___0;
  }
#line 340
  goto switch_break___0;
  case_16___0: 
  {
#line 343
  mix16(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes);
  }
#line 344
  goto switch_break___0;
  case_20___0: 
  {
#line 346
  mix20(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes);
  }
#line 347
  goto switch_break___0;
  case_24___0: 
  {
#line 350
  mix24(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
  }
#line 352
  goto switch_break___0;
  case_32___0: 
  {
#line 355
  mix32(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
  }
#line 357
  goto switch_break___0;
  switch_break___0: 
#line 361
  numV = kMinUV;
#line 361
  numU = numV;
#line 362
  minBits2 = (uint32_t )(1UL << 31);
#line 362
  minBits1 = minBits2;
#line 364
  numUV = kMinUV;
  {
#line 364
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 364
    if (! (numUV <= kMaxUV)) {
#line 364
      goto while_break___0;
    }
    {
#line 366
    BitBufferInit(& workBits, p->mWorkBuffer, p->mMaxOutputBytes);
#line 368
    dilate = (uint32_t )32;
#line 371
    converge = (uint32_t )0;
    }
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 371
      if (! (converge < 8U)) {
#line 371
        goto while_break___1;
      }
      {
#line 373
      pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )(numSamples / dilate), *(coefsU + (numUV - 1U)),
               (int32_t )numUV, chanBits, (uint32_t )9);
#line 374
      pc_block(p->mMixBufferV, p->mPredictorV, (int32_t )(numSamples / dilate), *(coefsV + (numUV - 1U)),
               (int32_t )numUV, chanBits, (uint32_t )9);
#line 371
      converge ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 377
    dilate = (uint32_t )8;
#line 379
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples / dilate, numSamples / dilate, (uint32_t )255);
#line 380
    status = dyn_comp(& agParams, p->mPredictorU, & workBits, (int32_t )(numSamples / dilate),
                      (int32_t )chanBits, & bits1);
    }
#line 382
    if (bits1 * dilate + 16U * numUV < minBits1) {
#line 384
      minBits1 = bits1 * dilate + 16U * numUV;
#line 385
      numU = numUV;
    }
    {
#line 388
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples / dilate, numSamples / dilate, (uint32_t )255);
#line 389
    status = dyn_comp(& agParams, p->mPredictorV, & workBits, (int32_t )(numSamples / dilate),
                      (int32_t )chanBits, & bits2);
    }
#line 391
    if (bits2 * dilate + 16U * numUV < minBits2) {
#line 393
      minBits2 = bits2 * dilate + 16U * numUV;
#line 394
      numV = numUV;
    }
#line 364
    numUV += 4U;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: ;
#line 399
  if ((int )partialFrame == 1) {
#line 399
    tmp___0 = 32;
  } else {
#line 399
    tmp___0 = 0;
  }
#line 399
  minBits = ((minBits1 + minBits2) + 64U) + (unsigned int )tmp___0;
#line 400
  if ((int )bytesShifted != 0) {
#line 401
    minBits += (numSamples * (unsigned int )((int )bytesShifted * 8)) * 2U;
  }
#line 403
  if ((int )partialFrame == 1) {
#line 403
    tmp___1 = 32;
  } else {
#line 403
    tmp___1 = 0;
  }
#line 403
  escapeBits = ((numSamples * (unsigned int )p->mBitDepth) * 2U + (unsigned int )tmp___1) + 16U;
#line 405
  if (minBits >= escapeBits) {
#line 405
    tmp___2 = 1;
  } else {
#line 405
    tmp___2 = 0;
  }
#line 405
  doEscape = (bool )tmp___2;
#line 407
  if ((unsigned int )doEscape == 0U) {
    {
#line 410
    BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )12);
#line 411
    BitBufferWrite(bitstream, (uint32_t )(((int )partialFrame << 3) | ((int )bytesShifted << 1)),
                   (uint32_t )4);
    }
#line 412
    if (partialFrame) {
      {
#line 413
      BitBufferWrite(bitstream, numSamples, (uint32_t )32);
      }
    }
    {
#line 414
    BitBufferWrite(bitstream, (uint32_t )mixBits, (uint32_t )8);
#line 415
    BitBufferWrite(bitstream, (uint32_t )mixRes, (uint32_t )8);
#line 421
    BitBufferWrite(bitstream, (mode << 4) | 9U, (uint32_t )8);
#line 422
    BitBufferWrite(bitstream, (pbFactor << 5) | numU, (uint32_t )8);
#line 423
    indx = (uint32_t )0;
    }
    {
#line 423
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 423
      if (! (indx < numU)) {
#line 423
        goto while_break___2;
      }
      {
#line 424
      BitBufferWrite(bitstream, (uint32_t )(*(coefsU + (numU - 1U)))[indx], (uint32_t )16);
#line 423
      indx ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 426
    BitBufferWrite(bitstream, (mode << 4) | 9U, (uint32_t )8);
#line 427
    BitBufferWrite(bitstream, (pbFactor << 5) | numV, (uint32_t )8);
#line 428
    indx = (uint32_t )0;
    }
    {
#line 428
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 428
      if (! (indx < numV)) {
#line 428
        goto while_break___3;
      }
      {
#line 429
      BitBufferWrite(bitstream, (uint32_t )(*(coefsV + (numV - 1U)))[indx], (uint32_t )16);
#line 428
      indx ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: ;
#line 432
    if ((int )bytesShifted != 0) {
#line 434
      bitShift = (uint32_t )((int )bytesShifted * 8);
#line 438
      indx = (uint32_t )0;
      {
#line 438
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 438
        if (! (indx < numSamples * 2U)) {
#line 438
          goto while_break___4;
        }
        {
#line 442
        shiftedVal = ((uint32_t )p->mShiftBufferUV[indx] << bitShift) | (uint32_t )p->mShiftBufferUV[indx + 1U];
#line 443
        BitBufferWrite(bitstream, shiftedVal, bitShift * 2U);
#line 438
        indx += 2U;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: ;
    }
#line 450
    if (mode == 0U) {
      {
#line 452
      pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )numSamples, *(coefsU + (numU - 1U)),
               (int32_t )numU, chanBits, (uint32_t )9);
      }
    } else {
      {
#line 456
      pc_block(p->mMixBufferU, p->mPredictorV, (int32_t )numSamples, *(coefsU + (numU - 1U)),
               (int32_t )numU, chanBits, (uint32_t )9);
#line 457
      pc_block(p->mPredictorV, p->mPredictorU, (int32_t )numSamples, (int16_t *)((void *)0),
               31, chanBits, (uint32_t )0);
      }
    }
    {
#line 460
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples, numSamples, (uint32_t )255);
#line 461
    status = dyn_comp(& agParams, p->mPredictorU, bitstream, (int32_t )numSamples,
                      (int32_t )chanBits, & bits1);
    }
#line 462
    if (status) {
#line 462
      goto Exit;
    }
#line 465
    if (mode == 0U) {
      {
#line 467
      pc_block(p->mMixBufferV, p->mPredictorV, (int32_t )numSamples, *(coefsV + (numV - 1U)),
               (int32_t )numV, chanBits, (uint32_t )9);
      }
    } else {
      {
#line 471
      pc_block(p->mMixBufferV, p->mPredictorU, (int32_t )numSamples, *(coefsV + (numV - 1U)),
               (int32_t )numV, chanBits, (uint32_t )9);
#line 472
      pc_block(p->mPredictorU, p->mPredictorV, (int32_t )numSamples, (int16_t *)((void *)0),
               31, chanBits, (uint32_t )0);
      }
    }
    {
#line 475
    set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14,
                  numSamples, numSamples, (uint32_t )255);
#line 476
    status = dyn_comp(& agParams, p->mPredictorV, bitstream, (int32_t )numSamples,
                      (int32_t )chanBits, & bits2);
    }
#line 477
    if (status) {
#line 477
      goto Exit;
    }
    {
#line 482
    __cil_tmp52 = BitBufferGetPosition(& startBits);
#line 482
    __cil_tmp51 = BitBufferGetPosition(bitstream);
#line 482
    minBits = __cil_tmp51 - __cil_tmp52;
    }
#line 483
    if (minBits >= escapeBits) {
      {
#line 485
      *bitstream = startBits;
#line 486
      doEscape = (bool )1;
#line 487
      printf("compressed frame too big: %u vs. %u \n", minBits, escapeBits);
      }
    }
  }
#line 491
  if ((unsigned int )doEscape == 1U) {
    {
#line 494
    status = EncodeStereoEscape(p, bitstream, inputBuffer, stride, numSamples);
    }
  }
  Exit: 
#line 502
  return (status);
}
}
#line 510 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
static int32_t EncodeStereoFast(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                                uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) 
{ 
  BitBuffer startBits ;
  AGParamRec agParams ;
  uint32_t bits1 ;
  uint32_t bits2 ;
  int32_t mixBits ;
  int32_t mixRes ;
  uint32_t minBits ;
  uint32_t minBits1 ;
  uint32_t minBits2 ;
  uint32_t numU ;
  uint32_t numV ;
  uint32_t mode ;
  uint32_t pbFactor ;
  uint32_t chanBits ;
  uint8_t bytesShifted ;
  SearchCoefs coefsU ;
  SearchCoefs coefsV ;
  uint32_t indx ;
  uint8_t partialFrame ;
  uint32_t escapeBits ;
  bool doEscape ;
  int32_t status ;
  int tmp ;
  uint32_t bitShift ;
  uint32_t shiftedVal ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t __cil_tmp39 ;
  uint32_t __cil_tmp40 ;

  {
#line 512
  startBits = *bitstream;
#line 531
  if (! ((int )p->mBitDepth == 16)) {
#line 531
    if (! ((int )p->mBitDepth == 20)) {
#line 531
      if (! ((int )p->mBitDepth == 24)) {
#line 531
        if (! ((int )p->mBitDepth == 32)) {
#line 531
          return (-50);
        }
      }
    }
  }
#line 538
  coefsU = p->mCoefsU[channelIndex];
#line 539
  coefsV = p->mCoefsV[channelIndex];
#line 544
  if ((int )p->mBitDepth == 32) {
#line 545
    bytesShifted = (uint8_t )2;
  } else
#line 546
  if ((int )p->mBitDepth >= 24) {
#line 547
    bytesShifted = (uint8_t )1;
  } else {
#line 549
    bytesShifted = (uint8_t )0;
  }
#line 551
  chanBits = (uint32_t )(((int )p->mBitDepth - (int )bytesShifted * 8) + 1);
#line 554
  if (numSamples == p->mFrameSize) {
#line 554
    tmp = 0;
  } else {
#line 554
    tmp = 1;
  }
#line 554
  partialFrame = (uint8_t )tmp;
#line 557
  mixBits = (int32_t )kDefaultMixBits;
#line 558
  mixRes = (int32_t )kDefaultMixRes;
#line 559
  numV = kDefaultNumUV;
#line 559
  numU = numV;
#line 560
  mode = (uint32_t )0;
#line 561
  pbFactor = (uint32_t )4;
#line 563
  minBits2 = (uint32_t )(1UL << 31);
#line 563
  minBits1 = minBits2;
#line 563
  minBits = minBits1;
#line 568
  if ((int )p->mBitDepth == 16) {
#line 568
    goto case_16;
  }
#line 571
  if ((int )p->mBitDepth == 20) {
#line 571
    goto case_20;
  }
#line 574
  if ((int )p->mBitDepth == 24) {
#line 574
    goto case_24;
  }
#line 579
  if ((int )p->mBitDepth == 32) {
#line 579
    goto case_32;
  }
#line 566
  goto switch_break;
  case_16: 
  {
#line 569
  mix16(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes);
  }
#line 570
  goto switch_break;
  case_20: 
  {
#line 572
  mix20(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes);
  }
#line 573
  goto switch_break;
  case_24: 
  {
#line 576
  mix24(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
  }
#line 578
  goto switch_break;
  case_32: 
  {
#line 581
  mix32(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        mixBits, mixRes, p->mShiftBufferUV, (int32_t )bytesShifted);
  }
#line 583
  goto switch_break;
  switch_break: 
  {
#line 589
  BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )12);
#line 590
  BitBufferWrite(bitstream, (uint32_t )(((int )partialFrame << 3) | ((int )bytesShifted << 1)),
                 (uint32_t )4);
  }
#line 591
  if (partialFrame) {
    {
#line 592
    BitBufferWrite(bitstream, numSamples, (uint32_t )32);
    }
  }
  {
#line 593
  BitBufferWrite(bitstream, (uint32_t )mixBits, (uint32_t )8);
#line 594
  BitBufferWrite(bitstream, (uint32_t )mixRes, (uint32_t )8);
#line 600
  BitBufferWrite(bitstream, (mode << 4) | 9U, (uint32_t )8);
#line 601
  BitBufferWrite(bitstream, (pbFactor << 5) | numU, (uint32_t )8);
#line 602
  indx = (uint32_t )0;
  }
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;

#line 602
    if (! (indx < numU)) {
#line 602
      goto while_break;
    }
    {
#line 603
    BitBufferWrite(bitstream, (uint32_t )(*(coefsU + (numU - 1U)))[indx], (uint32_t )16);
#line 602
    indx ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 605
  BitBufferWrite(bitstream, (mode << 4) | 9U, (uint32_t )8);
#line 606
  BitBufferWrite(bitstream, (pbFactor << 5) | numV, (uint32_t )8);
#line 607
  indx = (uint32_t )0;
  }
  {
#line 607
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 607
    if (! (indx < numV)) {
#line 607
      goto while_break___0;
    }
    {
#line 608
    BitBufferWrite(bitstream, (uint32_t )(*(coefsV + (numV - 1U)))[indx], (uint32_t )16);
#line 607
    indx ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 611
  if ((int )bytesShifted != 0) {
#line 613
    bitShift = (uint32_t )((int )bytesShifted * 8);
#line 617
    indx = (uint32_t )0;
    {
#line 617
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 617
      if (! (indx < numSamples * 2U)) {
#line 617
        goto while_break___1;
      }
      {
#line 621
      shiftedVal = ((uint32_t )p->mShiftBufferUV[indx] << bitShift) | (uint32_t )p->mShiftBufferUV[indx + 1U];
#line 622
      BitBufferWrite(bitstream, shiftedVal, bitShift * 2U);
#line 617
      indx += 2U;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
  {
#line 628
  pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )numSamples, *(coefsU + (numU - 1U)),
           (int32_t )numU, chanBits, (uint32_t )9);
#line 630
  set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14, numSamples,
                numSamples, (uint32_t )255);
#line 631
  status = dyn_comp(& agParams, p->mPredictorU, bitstream, (int32_t )numSamples, (int32_t )chanBits,
                    & bits1);
  }
#line 632
  if (status) {
#line 632
    goto Exit;
  }
  {
#line 635
  pc_block(p->mMixBufferV, p->mPredictorV, (int32_t )numSamples, *(coefsV + (numV - 1U)),
           (int32_t )numV, chanBits, (uint32_t )9);
#line 637
  set_ag_params(& agParams, (uint32_t )10, (pbFactor * 40U) / 4U, (uint32_t )14, numSamples,
                numSamples, (uint32_t )255);
#line 638
  status = dyn_comp(& agParams, p->mPredictorV, bitstream, (int32_t )numSamples, (int32_t )chanBits,
                    & bits2);
  }
#line 639
  if (status) {
#line 639
    goto Exit;
  }
#line 642
  minBits1 = (uint32_t )((unsigned long )bits1 + ((unsigned long )numU * sizeof(int16_t )) * 8UL);
#line 643
  minBits2 = (uint32_t )((unsigned long )bits2 + ((unsigned long )numV * sizeof(int16_t )) * 8UL);
#line 646
  if ((int )partialFrame == 1) {
#line 646
    tmp___0 = 32;
  } else {
#line 646
    tmp___0 = 0;
  }
#line 646
  minBits = ((minBits1 + minBits2) + 64U) + (unsigned int )tmp___0;
#line 647
  if ((int )bytesShifted != 0) {
#line 648
    minBits += (numSamples * (unsigned int )((int )bytesShifted * 8)) * 2U;
  }
#line 650
  if ((int )partialFrame == 1) {
#line 650
    tmp___1 = 32;
  } else {
#line 650
    tmp___1 = 0;
  }
#line 650
  escapeBits = ((numSamples * (unsigned int )p->mBitDepth) * 2U + (unsigned int )tmp___1) + 16U;
#line 652
  if (minBits >= escapeBits) {
#line 652
    tmp___2 = 1;
  } else {
#line 652
    tmp___2 = 0;
  }
#line 652
  doEscape = (bool )tmp___2;
#line 654
  if ((unsigned int )doEscape == 0U) {
    {
#line 659
    __cil_tmp40 = BitBufferGetPosition(& startBits);
#line 659
    __cil_tmp39 = BitBufferGetPosition(bitstream);
#line 659
    minBits = __cil_tmp39 - __cil_tmp40;
    }
#line 660
    if (minBits >= escapeBits) {
      {
#line 662
      doEscape = (bool )1;
#line 663
      printf("compressed frame too big: %u vs. %u\n\204U", minBits, escapeBits);
      }
    }
  }
#line 668
  if ((unsigned int )doEscape == 1U) {
    {
#line 673
    *bitstream = startBits;
#line 676
    status = EncodeStereoEscape(p, bitstream, inputBuffer, stride, numSamples);
    }
  }
  Exit: 
#line 684
  return (status);
}
}
#line 692 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
static int32_t EncodeStereoEscape(ALAC_ENCODER *p , struct BitBuffer *bitstream ,
                                  int32_t *inputBuffer , uint32_t stride , uint32_t numSamples ) 
{ 
  uint8_t partialFrame ;
  uint32_t indx ;
  int tmp ;

  {
#line 698
  if (numSamples == p->mFrameSize) {
#line 698
    tmp = 0;
  } else {
#line 698
    tmp = 1;
  }
  {
#line 698
  partialFrame = (uint8_t )tmp;
#line 701
  BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )12);
#line 702
  BitBufferWrite(bitstream, (uint32_t )(((int )partialFrame << 3) | 1), (uint32_t )4);
  }
#line 703
  if (partialFrame) {
    {
#line 704
    BitBufferWrite(bitstream, numSamples, (uint32_t )32);
    }
  }
#line 709
  if ((int )p->mBitDepth == 16) {
#line 709
    goto case_16;
  }
#line 716
  if ((int )p->mBitDepth == 20) {
#line 716
    goto case_20;
  }
#line 723
  if ((int )p->mBitDepth == 24) {
#line 723
    goto case_24;
  }
#line 732
  if ((int )p->mBitDepth == 32) {
#line 732
    goto case_32;
  }
#line 707
  goto switch_break;
  case_16: 
#line 710
  indx = (uint32_t )0;
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;

#line 710
    if (! (indx < numSamples * stride)) {
#line 710
      goto while_break;
    }
    {
#line 712
    BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + indx) >> 16), (uint32_t )16);
#line 713
    BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + (indx + 1U)) >> 16), (uint32_t )16);
#line 710
    indx += stride;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 715
  goto switch_break;
  case_20: 
#line 717
  indx = (uint32_t )0;
  {
#line 717
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 717
    if (! (indx < numSamples * stride)) {
#line 717
      goto while_break___0;
    }
    {
#line 719
    BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + indx) >> 12), (uint32_t )16);
#line 720
    BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + (indx + 1U)) >> 12), (uint32_t )16);
#line 717
    indx += stride;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
#line 722
  goto switch_break;
  case_24: 
  {
#line 725
  mix24(inputBuffer, stride, p->mMixBufferU, p->mMixBufferV, (int32_t )numSamples,
        0, 0, p->mShiftBufferUV, 0);
#line 726
  indx = (uint32_t )0;
  }
  {
#line 726
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 726
    if (! (indx < numSamples)) {
#line 726
      goto while_break___1;
    }
    {
#line 728
    BitBufferWrite(bitstream, (uint32_t )(p->mMixBufferU[indx] >> 8), (uint32_t )24);
#line 729
    BitBufferWrite(bitstream, (uint32_t )(p->mMixBufferV[indx] >> 8), (uint32_t )24);
#line 726
    indx ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 731
  goto switch_break;
  case_32: 
#line 733
  indx = (uint32_t )0;
  {
#line 733
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 733
    if (! (indx < numSamples * stride)) {
#line 733
      goto while_break___2;
    }
    {
#line 735
    BitBufferWrite(bitstream, (uint32_t )*(inputBuffer + indx), (uint32_t )32);
#line 736
    BitBufferWrite(bitstream, (uint32_t )*(inputBuffer + (indx + 1U)), (uint32_t )32);
#line 733
    indx += stride;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 738
  goto switch_break;
  switch_break: ;
#line 741
  return (0);
}
}
#line 749 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
static int32_t EncodeMono(ALAC_ENCODER *p , struct BitBuffer *bitstream , int32_t *inputBuffer ,
                          uint32_t stride , uint32_t channelIndex , uint32_t numSamples ) 
{ 
  BitBuffer startBits ;
  AGParamRec agParams ;
  uint32_t bits1 ;
  uint32_t numU ;
  SearchCoefs coefsU ;
  uint32_t dilate ;
  uint32_t minBits ;
  uint32_t bestU ;
  uint32_t minU ;
  uint32_t maxU ;
  uint32_t indx ;
  uint32_t indx2 ;
  uint8_t bytesShifted ;
  uint32_t shift ;
  uint32_t mask ;
  uint32_t chanBits ;
  uint8_t pbFactor ;
  uint8_t partialFrame ;
  uint32_t escapeBits ;
  bool doEscape ;
  int32_t status ;
  int tmp ;
  uint32_t __cil_tmp29 ;
  uint32_t __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  BitBuffer workBits ;
  uint32_t numBits ;
  uint32_t converge ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t __cil_tmp44 ;
  uint32_t __cil_tmp45 ;
  uint32_t __cil_tmp46 ;

  {
#line 751
  startBits = *bitstream;
#line 768
  status = 0;
#line 772
  if (! ((int )p->mBitDepth == 16)) {
#line 772
    if (! ((int )p->mBitDepth == 20)) {
#line 772
      if (! ((int )p->mBitDepth == 24)) {
#line 772
        if (! ((int )p->mBitDepth == 32)) {
#line 772
          return (-50);
        }
      }
    }
  }
#line 775
  coefsU = p->mCoefsU[channelIndex];
#line 779
  if ((int )p->mBitDepth == 32) {
#line 780
    bytesShifted = (uint8_t )2;
  } else
#line 781
  if ((int )p->mBitDepth >= 24) {
#line 782
    bytesShifted = (uint8_t )1;
  } else {
#line 784
    bytesShifted = (uint8_t )0;
  }
#line 786
  shift = (uint32_t )((int )bytesShifted * 8);
#line 787
  mask = (uint32_t )((1UL << shift) - 1UL);
#line 788
  chanBits = (uint32_t )((int )p->mBitDepth - (int )bytesShifted * 8);
#line 791
  if (numSamples == p->mFrameSize) {
#line 791
    tmp = 0;
  } else {
#line 791
    tmp = 1;
  }
#line 791
  partialFrame = (uint8_t )tmp;
#line 796
  if ((int )p->mBitDepth == 16) {
#line 796
    goto case_16;
  }
#line 802
  if ((int )p->mBitDepth == 20) {
#line 802
    goto case_20;
  }
#line 807
  if ((int )p->mBitDepth == 24) {
#line 807
    goto case_24;
  }
#line 817
  if ((int )p->mBitDepth == 32) {
#line 817
    goto case_32;
  }
#line 794
  goto switch_break;
  case_16: 
#line 798
  indx2 = (uint32_t )0;
#line 798
  indx = (uint32_t )0;
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;

#line 798
    if (! (indx < numSamples)) {
#line 798
      goto while_break;
    }
#line 799
    p->mMixBufferU[indx] = *(inputBuffer + indx2) >> 16;
#line 798
    indx2 += stride;
#line 798
    __cil_tmp29 = indx;
#line 798
    indx ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break: ;
#line 800
  goto switch_break;
  case_20: 
#line 804
  indx2 = (uint32_t )0;
#line 804
  indx = (uint32_t )0;
  {
#line 804
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 804
    if (! (indx < numSamples)) {
#line 804
      goto while_break___0;
    }
#line 805
    p->mMixBufferU[indx] = *(inputBuffer + indx2) >> 12;
#line 804
    indx2 += stride;
#line 804
    __cil_tmp30 = indx;
#line 804
    indx ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___0: ;
#line 806
  goto switch_break;
  case_24: 
#line 809
  indx2 = (uint32_t )0;
#line 809
  indx = (uint32_t )0;
  {
#line 809
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 809
    if (! (indx < numSamples)) {
#line 809
      goto while_break___1;
    }
#line 811
    p->mMixBufferU[indx] = *(inputBuffer + indx2) >> 8;
#line 812
    p->mShiftBufferUV[indx] = (uint16_t )((unsigned int )p->mMixBufferU[indx] & mask);
#line 813
    p->mMixBufferU[indx] >>= shift;
#line 809
    indx2 += stride;
#line 809
    __cil_tmp31 = indx;
#line 809
    indx ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___1: ;
#line 816
  goto switch_break;
  case_32: 
#line 819
  indx2 = (uint32_t )0;
#line 819
  indx = (uint32_t )0;
  {
#line 819
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 819
    if (! (indx < numSamples)) {
#line 819
      goto while_break___2;
    }
#line 821
    p->mShiftBufferUV[indx] = (uint16_t )((unsigned int )*(inputBuffer + indx2) & mask);
#line 822
    p->mMixBufferU[indx] = *(inputBuffer + indx2) >> shift;
#line 819
    indx2 += stride;
#line 819
    __cil_tmp32 = indx;
#line 819
    indx ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___2: ;
#line 824
  goto switch_break;
  switch_break: 
#line 829
  minU = (uint32_t )4;
#line 830
  maxU = (uint32_t )8;
#line 831
  minBits = (uint32_t )(1UL << 31);
#line 832
  pbFactor = (uint8_t )4;
#line 834
  bestU = minU;
#line 836
  numU = minU;
  {
#line 836
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 836
    if (! (numU <= maxU)) {
#line 836
      goto while_break___3;
    }
    {
#line 841
    BitBufferInit(& workBits, p->mWorkBuffer, p->mMaxOutputBytes);
#line 843
    dilate = (uint32_t )32;
#line 844
    converge = (uint32_t )0;
    }
    {
#line 844
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 844
      if (! (converge < 7U)) {
#line 844
        goto while_break___4;
      }
      {
#line 845
      pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )(numSamples / dilate), *(coefsU + (numU - 1U)),
               (int32_t )numU, chanBits, (uint32_t )9);
#line 844
      converge ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___4: 
    {
#line 847
    dilate = (uint32_t )8;
#line 848
    pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )(numSamples / dilate), *(coefsU + (numU - 1U)),
             (int32_t )numU, chanBits, (uint32_t )9);
#line 850
    set_ag_params(& agParams, (uint32_t )10, (uint32_t )(((int )pbFactor * 40) / 4),
                  (uint32_t )14, numSamples / dilate, numSamples / dilate, (uint32_t )255);
#line 851
    status = dyn_comp(& agParams, p->mPredictorU, & workBits, (int32_t )(numSamples / dilate),
                      (int32_t )chanBits, & bits1);
    }
#line 852
    if (status) {
#line 852
      goto Exit;
    }
#line 854
    numBits = dilate * bits1 + 16U * numU;
#line 855
    if (numBits < minBits) {
#line 857
      bestU = numU;
#line 858
      minBits = numBits;
    }
#line 836
    numU += 4U;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___3: ;
#line 864
  if ((int )partialFrame == 1) {
#line 864
    tmp___0 = 32;
  } else {
#line 864
    tmp___0 = 0;
  }
#line 864
  minBits += (unsigned int )(32 + tmp___0);
#line 865
  if ((int )bytesShifted != 0) {
#line 866
    minBits += numSamples * (unsigned int )((int )bytesShifted * 8);
  }
#line 868
  if ((int )partialFrame == 1) {
#line 868
    tmp___1 = 32;
  } else {
#line 868
    tmp___1 = 0;
  }
#line 868
  escapeBits = (numSamples * (unsigned int )p->mBitDepth + (unsigned int )tmp___1) + 16U;
#line 870
  if (minBits >= escapeBits) {
#line 870
    tmp___2 = 1;
  } else {
#line 870
    tmp___2 = 0;
  }
#line 870
  doEscape = (bool )tmp___2;
#line 872
  if ((unsigned int )doEscape == 0U) {
    {
#line 875
    BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )12);
#line 876
    BitBufferWrite(bitstream, (uint32_t )(((int )partialFrame << 3) | ((int )bytesShifted << 1)),
                   (uint32_t )4);
    }
#line 877
    if (partialFrame) {
      {
#line 878
      BitBufferWrite(bitstream, numSamples, (uint32_t )32);
      }
    }
    {
#line 879
    BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )16);
#line 882
    numU = bestU;
#line 883
    BitBufferWrite(bitstream, (uint32_t )9, (uint32_t )8);
#line 884
    BitBufferWrite(bitstream, (unsigned int )((int )pbFactor << 5) | numU, (uint32_t )8);
#line 885
    indx = (uint32_t )0;
    }
    {
#line 885
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 885
      if (! (indx < numU)) {
#line 885
        goto while_break___5;
      }
      {
#line 886
      BitBufferWrite(bitstream, (uint32_t )(*(coefsU + (numU - 1U)))[indx], (uint32_t )16);
#line 885
      indx ++;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___5: ;
#line 889
    if ((int )bytesShifted != 0) {
#line 891
      indx = (uint32_t )0;
      {
#line 891
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 891
        if (! (indx < numSamples)) {
#line 891
          goto while_break___6;
        }
        {
#line 892
        BitBufferWrite(bitstream, (uint32_t )p->mShiftBufferUV[indx], shift);
#line 891
        indx ++;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___6: ;
    }
    {
#line 896
    pc_block(p->mMixBufferU, p->mPredictorU, (int32_t )numSamples, *(coefsU + (numU - 1U)),
             (int32_t )numU, chanBits, (uint32_t )9);
#line 899
    set_standard_ag_params(& agParams, numSamples, numSamples);
#line 900
    status = dyn_comp(& agParams, p->mPredictorU, bitstream, (int32_t )numSamples,
                      (int32_t )chanBits, & bits1);
#line 907
    __cil_tmp45 = BitBufferGetPosition(& startBits);
#line 907
    __cil_tmp44 = BitBufferGetPosition(bitstream);
#line 907
    minBits = __cil_tmp44 - __cil_tmp45;
    }
#line 908
    if (minBits >= escapeBits) {
      {
#line 910
      *bitstream = startBits;
#line 911
      doEscape = (bool )1;
#line 912
      printf("compressed frame too big: %u vs. %u\n\204U", minBits, escapeBits);
      }
    }
  }
#line 916
  if ((unsigned int )doEscape == 1U) {
    {
#line 919
    BitBufferWrite(bitstream, (uint32_t )0, (uint32_t )12);
#line 920
    BitBufferWrite(bitstream, (uint32_t )(((int )partialFrame << 3) | 1), (uint32_t )4);
    }
#line 921
    if (partialFrame) {
      {
#line 922
      BitBufferWrite(bitstream, numSamples, (uint32_t )32);
      }
    }
#line 927
    if ((int )p->mBitDepth == 16) {
#line 927
      goto case_16___0;
    }
#line 931
    if ((int )p->mBitDepth == 20) {
#line 931
      goto case_20___0;
    }
#line 936
    if ((int )p->mBitDepth == 24) {
#line 936
      goto case_24___0;
    }
#line 944
    if ((int )p->mBitDepth == 32) {
#line 944
      goto case_32___0;
    }
#line 925
    goto switch_break___0;
    case_16___0: 
#line 928
    indx = (uint32_t )0;
    {
#line 928
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 928
      if (! (indx < numSamples * stride)) {
#line 928
        goto while_break___7;
      }
      {
#line 929
      BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + indx) >> 16), (uint32_t )16);
#line 928
      indx += stride;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___7: ;
#line 930
    goto switch_break___0;
    case_20___0: 
#line 933
    indx = (uint32_t )0;
    {
#line 933
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 933
      if (! (indx < numSamples * stride)) {
#line 933
        goto while_break___8;
      }
      {
#line 934
      BitBufferWrite(bitstream, (uint32_t )(*(inputBuffer + indx) >> 12), (uint32_t )20);
#line 933
      indx += stride;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___8: ;
#line 935
    goto switch_break___0;
    case_24___0: 
#line 938
    indx2 = (uint32_t )0;
#line 938
    indx = (uint32_t )0;
    {
#line 938
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 938
      if (! (indx < numSamples)) {
#line 938
        goto while_break___9;
      }
      {
#line 940
      p->mMixBufferU[indx] = *(inputBuffer + indx2) >> 8;
#line 941
      BitBufferWrite(bitstream, (uint32_t )p->mMixBufferU[indx], (uint32_t )24);
#line 938
      indx2 += stride;
#line 938
      __cil_tmp46 = indx;
#line 938
      indx ++;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___9: ;
#line 943
    goto switch_break___0;
    case_32___0: 
#line 945
    indx = (uint32_t )0;
    {
#line 945
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 945
      if (! (indx < numSamples * stride)) {
#line 945
        goto while_break___10;
      }
      {
#line 946
      BitBufferWrite(bitstream, (uint32_t )*(inputBuffer + indx), (uint32_t )32);
#line 945
      indx += stride;
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___10: ;
#line 947
    goto switch_break___0;
    switch_break___0: ;
  }
  Exit: 
#line 955
  return (status);
}
}
#line 967 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
int32_t alac_encode(ALAC_ENCODER *p , uint32_t numSamples , int32_t *theReadBuffer ,
                    unsigned char *theWriteBuffer , uint32_t *ioNumBytes ) 
{ 
  uint32_t outputSize ;
  BitBuffer bitstream ;
  int32_t status ;
  uint32_t numChannels ;
  int32_t *inputBuffer ;
  uint32_t tag ;
  uint32_t channelIndex ;
  uint8_t stereoElementTag ;
  uint8_t monoElementTag ;
  uint8_t lfeElementTag ;
  uint32_t __cil_tmp27 ;
  uint32_t tmp ;

  {
#line 973
  numChannels = p->mNumChannels;
#line 976
  if (! ((int )p->mBitDepth == 16)) {
#line 976
    if (! ((int )p->mBitDepth == 20)) {
#line 976
      if (! ((int )p->mBitDepth == 24)) {
#line 976
        if (! ((int )p->mBitDepth == 32)) {
#line 976
          return (-50);
        }
      }
    }
  }
  {
#line 979
  BitBufferInit(& bitstream, theWriteBuffer, p->mMaxOutputBytes);
  }
#line 981
  if (numChannels == 2U) {
    {
#line 984
    BitBufferWrite(& bitstream, (uint32_t )1, (uint32_t )3);
#line 985
    BitBufferWrite(& bitstream, (uint32_t )0, (uint32_t )4);
    }
#line 988
    if (p->mFastMode == 0) {
      {
#line 989
      status = EncodeStereo(p, & bitstream, theReadBuffer, (uint32_t )2, (uint32_t )0,
                            numSamples);
      }
    } else {
      {
#line 991
      status = EncodeStereoFast(p, & bitstream, theReadBuffer, (uint32_t )2, (uint32_t )0,
                                numSamples);
      }
    }
#line 992
    if (status) {
#line 992
      goto Exit;
    }
  } else
#line 994
  if (numChannels == 1U) {
    {
#line 997
    BitBufferWrite(& bitstream, (uint32_t )0, (uint32_t )3);
#line 998
    BitBufferWrite(& bitstream, (uint32_t )0, (uint32_t )4);
#line 1001
    status = EncodeMono(p, & bitstream, theReadBuffer, (uint32_t )1, (uint32_t )0,
                        numSamples);
    }
#line 1002
    if (status) {
#line 1002
      goto Exit;
    }
  } else {
#line 1013
    inputBuffer = theReadBuffer;
#line 1015
    stereoElementTag = (uint8_t )0;
#line 1016
    monoElementTag = (uint8_t )0;
#line 1017
    lfeElementTag = (uint8_t )0;
#line 1019
    channelIndex = (uint32_t )0;
    {
#line 1019
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1019
      if (! (channelIndex < numChannels)) {
#line 1019
        goto while_break;
      }
      {
#line 1021
      tag = (uint32_t )(((unsigned long )sChannelMaps[numChannels - 1U] & (7UL << channelIndex * 3U)) >> channelIndex * 3U);
#line 1023
      BitBufferWrite(& bitstream, tag, (uint32_t )3);
      }
#line 1026
      if (tag == 0U) {
#line 1026
        goto case_0;
      }
#line 1037
      if (tag == 1U) {
#line 1037
        goto case_1;
      }
#line 1048
      if (tag == 3U) {
#line 1048
        goto case_3;
      }
#line 1059
      goto switch_default;
      case_0: 
      {
#line 1028
      BitBufferWrite(& bitstream, (uint32_t )monoElementTag, (uint32_t )4);
#line 1030
      status = EncodeMono(p, & bitstream, inputBuffer, numChannels, channelIndex,
                          numSamples);
#line 1032
      inputBuffer ++;
#line 1033
      channelIndex ++;
#line 1034
      monoElementTag = (uint8_t )((int )monoElementTag + 1);
      }
#line 1035
      goto switch_break;
      case_1: 
      {
#line 1039
      BitBufferWrite(& bitstream, (uint32_t )stereoElementTag, (uint32_t )4);
#line 1041
      status = EncodeStereo(p, & bitstream, inputBuffer, numChannels, channelIndex,
                            numSamples);
#line 1043
      inputBuffer += 2;
#line 1044
      channelIndex += 2U;
#line 1045
      stereoElementTag = (uint8_t )((int )stereoElementTag + 1);
      }
#line 1046
      goto switch_break;
      case_3: 
      {
#line 1050
      BitBufferWrite(& bitstream, (uint32_t )lfeElementTag, (uint32_t )4);
#line 1052
      status = EncodeMono(p, & bitstream, inputBuffer, numChannels, channelIndex,
                          numSamples);
#line 1054
      inputBuffer ++;
#line 1055
      channelIndex ++;
#line 1056
      lfeElementTag = (uint8_t )((int )lfeElementTag + 1);
      }
#line 1057
      goto switch_break;
      switch_default: 
      {
#line 1060
      printf("That ain\'t right! (%u)\n", tag);
#line 1061
      status = -50;
      }
#line 1062
      goto Exit;
      switch_break: ;
#line 1065
      if (status) {
#line 1065
        goto Exit;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 1084
  BitBufferWrite(& bitstream, (uint32_t )7, (uint32_t )3);
#line 1087
  BitBufferByteAlign(& bitstream, 1);
#line 1089
  __cil_tmp27 = BitBufferGetPosition(& bitstream);
#line 1089
  outputSize = __cil_tmp27 / 8U;
#line 1094
  *ioNumBytes = outputSize;
#line 1098
  p->mTotalBytesGenerated += outputSize;
  }
#line 1099
  if (p->mMaxFrameBytes > outputSize) {
#line 1099
    tmp = p->mMaxFrameBytes;
  } else {
#line 1099
    tmp = outputSize;
  }
#line 1099
  p->mMaxFrameBytes = tmp;
#line 1101
  status = 0;
  Exit: 
#line 1104
  return (status);
}
}
#line 1116 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
void GetConfig(ALAC_ENCODER *p , ALACSpecificConfig *config ) 
{ 
  int32_t __cil_tmp3 ;
  int16_t __cil_tmp4 ;
  int32_t __cil_tmp5 ;
  int32_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;

  {
  {
#line 1118
  __cil_tmp3 = ENDSWAP_32((int32_t )p->mFrameSize);
#line 1118
  config->frameLength = (uint32_t )__cil_tmp3;
#line 1119
  config->compatibleVersion = (uint8_t )0;
#line 1120
  config->bitDepth = (uint8_t )p->mBitDepth;
#line 1121
  config->pb = (uint8_t )40;
#line 1122
  config->kb = (uint8_t )14;
#line 1123
  config->mb = (uint8_t )10;
#line 1124
  config->numChannels = (uint8_t )p->mNumChannels;
#line 1125
  __cil_tmp4 = ENDSWAP_16((int16_t )((uint16_t )255));
#line 1125
  config->maxRun = (uint16_t )__cil_tmp4;
#line 1126
  __cil_tmp5 = ENDSWAP_32((int32_t )p->mMaxFrameBytes);
#line 1126
  config->maxFrameBytes = (uint32_t )__cil_tmp5;
#line 1127
  __cil_tmp6 = ENDSWAP_32((int32_t )p->mAvgBitRate);
#line 1127
  config->avgBitRate = (uint32_t )__cil_tmp6;
#line 1128
  __cil_tmp7 = ENDSWAP_32((int32_t )p->mOutputSampleRate);
#line 1128
  config->sampleRate = (uint32_t )__cil_tmp7;
  }
#line 1130
  return;
}
}
#line 1132 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
uint32_t alac_get_magic_cookie_size(uint32_t inNumChannels ) 
{ 


  {
#line 1134
  if (inNumChannels > 2U) {
#line 1136
    return ((uint32_t )((sizeof(ALACSpecificConfig ) + 12UL) + sizeof(ALACAudioChannelLayout )));
  } else {
#line 1140
    return ((uint32_t )sizeof(ALACSpecificConfig ));
  }
}
}
#line 1145 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
void alac_get_magic_cookie(ALAC_ENCODER *p , void *outCookie , uint32_t *ioSize ) 
{ 
  ALACSpecificConfig theConfig ;
  ALACAudioChannelLayout theChannelLayout ;
  uint8_t theChannelAtom[12] ;
  uint32_t theCookieSize ;
  uint8_t *theCookiePointer ;
  int32_t __cil_tmp9 ;

  {
  {
#line 1147
  theConfig.frameLength = (uint32_t )0;
#line 1147
  theConfig.compatibleVersion = (uint8_t )0;
#line 1147
  theConfig.bitDepth = (uint8_t )0;
#line 1147
  theConfig.pb = (uint8_t )0;
#line 1147
  theConfig.mb = (uint8_t )0;
#line 1147
  theConfig.kb = (uint8_t )0;
#line 1147
  theConfig.numChannels = (uint8_t )0;
#line 1147
  theConfig.maxRun = (uint16_t )0;
#line 1147
  theConfig.maxFrameBytes = (uint32_t )0;
#line 1147
  theConfig.avgBitRate = (uint32_t )0;
#line 1147
  theConfig.sampleRate = (uint32_t )0;
#line 1148
  theChannelLayout.mChannelLayoutTag = (ALACChannelLayoutTag )0;
#line 1148
  theChannelLayout.mChannelBitmap = (uint32_t )0;
#line 1148
  theChannelLayout.mNumberChannelDescriptions = (uint32_t )0;
#line 1149
  theChannelAtom[0] = (uint8_t )0;
#line 1149
  theChannelAtom[1] = (uint8_t )0;
#line 1149
  theChannelAtom[2] = (uint8_t )0;
#line 1149
  theChannelAtom[3] = (uint8_t )0;
#line 1149
  theChannelAtom[4] = (uint8_t )'c';
#line 1149
  theChannelAtom[5] = (uint8_t )'h';
#line 1149
  theChannelAtom[6] = (uint8_t )'a';
#line 1149
  theChannelAtom[7] = (uint8_t )'n';
#line 1149
  theChannelAtom[8] = (uint8_t )0;
#line 1149
  theChannelAtom[9] = (uint8_t )0;
#line 1149
  theChannelAtom[10] = (uint8_t )0;
#line 1149
  theChannelAtom[11] = (uint8_t )0;
#line 1150
  theCookieSize = (uint32_t )sizeof(ALACSpecificConfig );
#line 1151
  theCookiePointer = (uint8_t *)outCookie;
#line 1153
  GetConfig(p, & theConfig);
  }
#line 1154
  if ((int )theConfig.numChannels > 2) {
    {
#line 1156
    __cil_tmp9 = ENDSWAP_32((int32_t )ALACChannelLayoutTags___2[(int )theConfig.numChannels - 1]);
#line 1156
    theChannelLayout.mChannelLayoutTag = (ALACChannelLayoutTag )__cil_tmp9;
#line 1157
    theCookieSize = (uint32_t )((unsigned long )theCookieSize + (sizeof(ALACAudioChannelLayout ) + 12UL));
    }
  }
#line 1159
  if (*ioSize >= theCookieSize) {
    {
#line 1161
    memcpy((void *)theCookiePointer, (void const   *)(& theConfig), sizeof(ALACSpecificConfig ));
#line 1162
    theChannelAtom[3] = (uint8_t )(sizeof(ALACAudioChannelLayout ) + 12UL);
    }
#line 1163
    if ((int )theConfig.numChannels > 2) {
      {
#line 1165
      theCookiePointer += sizeof(ALACSpecificConfig );
#line 1166
      memcpy((void *)theCookiePointer, (void const   *)(theChannelAtom), 12UL);
#line 1167
      theCookiePointer += 12;
#line 1168
      memcpy((void *)theCookiePointer, (void const   *)(& theChannelLayout), sizeof(ALACAudioChannelLayout ));
      }
    }
#line 1170
    *ioSize = theCookieSize;
  } else {
#line 1174
    *ioSize = (uint32_t )0;
  }
#line 1176
  return;
}
}
#line 1183 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
int32_t alac_encoder_init(ALAC_ENCODER *p , uint32_t samplerate , uint32_t channels ,
                          uint32_t format_flags , uint32_t frameSize ) 
{ 
  int32_t status ;
  uint32_t tmp ;
  uint32_t indx ;
  int32_t channel ;
  int32_t search ;

  {
#line 1187
  if (frameSize > 0U) {
#line 1187
    if (frameSize <= 4096U) {
#line 1187
      tmp = frameSize;
    } else {
#line 1187
      tmp = 4096U;
    }
  } else {
#line 1187
    tmp = 4096U;
  }
#line 1187
  p->mFrameSize = tmp;
#line 1189
  p->mOutputSampleRate = samplerate;
#line 1190
  p->mNumChannels = channels;
#line 1193
  if (format_flags == 1U) {
#line 1193
    goto case_1;
  }
#line 1196
  if (format_flags == 2U) {
#line 1196
    goto case_2;
  }
#line 1199
  if (format_flags == 3U) {
#line 1199
    goto case_3;
  }
#line 1202
  if (format_flags == 4U) {
#line 1202
    goto case_4;
  }
#line 1205
  goto switch_default;
  case_1: 
#line 1194
  p->mBitDepth = (int16_t )16;
#line 1195
  goto switch_break;
  case_2: 
#line 1197
  p->mBitDepth = (int16_t )20;
#line 1198
  goto switch_break;
  case_3: 
#line 1200
  p->mBitDepth = (int16_t )24;
#line 1201
  goto switch_break;
  case_4: 
#line 1203
  p->mBitDepth = (int16_t )32;
#line 1204
  goto switch_break;
  switch_default: 
#line 1206
  goto switch_break;
  switch_break: 
#line 1211
  indx = (uint32_t )0;
  {
#line 1211
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1211
    if (! (indx < 8U)) {
#line 1211
      goto while_break;
    }
#line 1212
    p->mLastMixRes[indx] = (int16_t )kDefaultMixRes;
#line 1211
    indx ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 1217
  p->mMaxOutputBytes = (p->mFrameSize * p->mNumChannels) * ((10U + kMaxSampleSize) / 8U) + 1U;
#line 1219
  status = 0;
#line 1222
  channel = 0;
  {
#line 1222
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1222
    if (! (channel < (int32_t )p->mNumChannels)) {
#line 1222
      goto while_break___0;
    }
#line 1224
    search = 0;
    {
#line 1224
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1224
      if (! (search < 16)) {
#line 1224
        goto while_break___1;
      }
      {
#line 1226
      init_coefs(p->mCoefsU[channel][search], (uint32_t )9, 16);
#line 1227
      init_coefs(p->mCoefsV[channel][search], (uint32_t )9, 16);
#line 1224
      search ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 1222
    channel ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1231
  return (status);
}
}
#line 1239 "/root/patchweave_donee/23/src/ALAC/alac_encoder.c"
void alac_get_source_format(ALAC_ENCODER *p , AudioFormatDescription *source , AudioFormatDescription *output ) 
{ 


  {
#line 1246
  if (source->mFormatID != 1835233388U) {
#line 1247
    p->mBitDepth = (int16_t )16;
  } else
#line 1246
  if ((source->mFormatFlags & 1U) != 0U) {
#line 1247
    p->mBitDepth = (int16_t )16;
  } else
#line 1246
  if (source->mBitsPerChannel <= 16U) {
#line 1247
    p->mBitDepth = (int16_t )16;
  } else
#line 1248
  if (source->mBitsPerChannel <= 20U) {
#line 1249
    p->mBitDepth = (int16_t )20;
  } else
#line 1250
  if (source->mBitsPerChannel <= 24U) {
#line 1251
    p->mBitDepth = (int16_t )24;
  } else {
#line 1253
    p->mBitDepth = (int16_t )32;
  }
#line 1255
  return;
}
}
#line 47 "/root/patchweave_donee/23/src/ALAC/alac_decoder.c"
uint32_t kMaxBitDepth  =    (uint32_t )32;
#line 51
static int32_t alac_fill_element(struct BitBuffer *bits ) ;
#line 52
static int32_t alac_data_stream_element(struct BitBuffer *bits ) ;
#line 54
static void Zero32(int32_t *buffer , uint32_t numItems , uint32_t stride ) ;
#line 62 "/root/patchweave_donee/23/src/ALAC/alac_decoder.c"
int32_t alac_decoder_init(ALAC_DECODER *p , void *inMagicCookie , uint32_t inMagicCookieSize ) 
{ 
  int32_t status ;
  ALACSpecificConfig theConfig ;
  uint8_t *theActualCookie ;
  uint32_t theCookieBytesRemaining ;
  int32_t __cil_tmp8 ;
  int16_t __cil_tmp9 ;
  int32_t __cil_tmp10 ;
  int32_t __cil_tmp11 ;
  int32_t __cil_tmp12 ;

  {
#line 64
  status = 0;
#line 66
  theActualCookie = (uint8_t *)inMagicCookie;
#line 67
  theCookieBytesRemaining = inMagicCookieSize;
#line 76
  if ((int )*(theActualCookie + 4) == 102) {
#line 76
    if ((int )*(theActualCookie + 5) == 114) {
#line 76
      if ((int )*(theActualCookie + 6) == 109) {
#line 76
        if ((int )*(theActualCookie + 7) == 97) {
#line 78
          theActualCookie += 12;
#line 79
          theCookieBytesRemaining -= 12U;
        }
      }
    }
  }
#line 83
  if ((int )*(theActualCookie + 4) == 97) {
#line 83
    if ((int )*(theActualCookie + 5) == 108) {
#line 83
      if ((int )*(theActualCookie + 6) == 97) {
#line 83
        if ((int )*(theActualCookie + 7) == 99) {
#line 85
          theActualCookie += 12;
#line 86
          theCookieBytesRemaining -= 12U;
        }
      }
    }
  }
#line 90
  if ((unsigned long )theCookieBytesRemaining >= sizeof(ALACSpecificConfig )) {
    {
#line 92
    __cil_tmp8 = psf_get_be32(theActualCookie, 0);
#line 92
    theConfig.frameLength = (uint32_t )__cil_tmp8;
    }
#line 94
    if (theConfig.frameLength > 4096U) {
#line 95
      return (-666);
    }
    {
#line 97
    theConfig.compatibleVersion = *(theActualCookie + 0);
#line 98
    theConfig.bitDepth = *(theActualCookie + 0);
#line 99
    theConfig.pb = *(theActualCookie + 0);
#line 100
    theConfig.mb = *(theActualCookie + 0);
#line 101
    theConfig.kb = *(theActualCookie + 0);
#line 102
    theConfig.numChannels = *(theActualCookie + 0);
#line 103
    __cil_tmp9 = psf_get_be16(theActualCookie, 0);
#line 103
    theConfig.maxRun = (uint16_t )__cil_tmp9;
#line 104
    __cil_tmp10 = psf_get_be32(theActualCookie, 0);
#line 104
    theConfig.maxFrameBytes = (uint32_t )__cil_tmp10;
#line 105
    __cil_tmp11 = psf_get_be32(theActualCookie, 0);
#line 105
    theConfig.avgBitRate = (uint32_t )__cil_tmp11;
#line 106
    __cil_tmp12 = psf_get_be32(theActualCookie, 0);
#line 106
    theConfig.sampleRate = (uint32_t )__cil_tmp12;
#line 108
    p->mConfig = theConfig;
#line 109
    p->mNumChannels = (uint32_t )theConfig.numChannels;
    }
#line 111
    if (! ((int )p->mConfig.compatibleVersion <= 0)) {
#line 111
      return (-1048577);
    }
#line 112
    if ((int )p->mConfig.bitDepth >= 8) {
#line 112
      if (! ((int )p->mConfig.bitDepth <= 32)) {
#line 112
        return (-1048576);
      }
    } else {
#line 112
      return (-1048576);
    }
#line 113
    if ((unsigned long )(p->mMixBufferU) != (unsigned long )((void *)0)) {
#line 113
      if ((unsigned long )(p->mMixBufferV) != (unsigned long )((void *)0)) {
#line 113
        if (! ((unsigned long )(p->__annonCompField3.mPredictor) != (unsigned long )((void *)0))) {
#line 113
          status = -108;
#line 113
          goto Exit;
        }
      } else {
#line 113
        status = -108;
#line 113
        goto Exit;
      }
    } else {
#line 113
      status = -108;
#line 113
      goto Exit;
    }
  } else {
#line 118
    status = -1048578;
  }
  Exit: 
#line 128
  return (status);
}
}
#line 137 "/root/patchweave_donee/23/src/ALAC/alac_decoder.c"
int32_t alac_decode(ALAC_DECODER *p , struct BitBuffer *bits , int32_t *sampleBuffer ,
                    uint32_t numSamples , uint32_t *outNumSamples ) 
{ 
  BitBuffer shiftBits ;
  uint32_t bits1 ;
  uint32_t bits2 ;
  uint8_t tag ;
  uint8_t elementInstanceTag ;
  AGParamRec agParams ;
  uint32_t channelIndex ;
  int16_t coefsU[32] ;
  int16_t coefsV[32] ;
  uint8_t numU ;
  uint8_t numV ;
  uint8_t mixBits ;
  int8_t mixRes ;
  uint16_t unusedHeader ;
  uint8_t escapeFlag ;
  uint32_t chanBits ;
  uint8_t bytesShifted ;
  uint32_t shift ;
  uint8_t modeU ;
  uint8_t modeV ;
  uint32_t denShiftU ;
  uint32_t denShiftV ;
  uint16_t pbFactorU ;
  uint16_t pbFactorV ;
  uint16_t pb ;
  int32_t *out32 ;
  uint8_t headerByte ;
  uint8_t partialFrame ;
  uint32_t extraBits ;
  int32_t val ;
  uint32_t i ;
  uint32_t j ;
  int32_t status ;
  uint32_t numChannels ;
  uint32_t __cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  uint32_t __cil_tmp45 ;
  uint32_t __cil_tmp46 ;
  uint32_t __cil_tmp47 ;
  uint32_t __cil_tmp48 ;
  uint32_t __cil_tmp49 ;
  uint32_t __cil_tmp50 ;
  uint32_t __cil_tmp53 ;
  uint32_t __cil_tmp55 ;
  int32_t __cil_tmp56 ;
  uint32_t __cil_tmp57 ;
  uint32_t __cil_tmp59 ;
  uint32_t __cil_tmp62 ;
  uint32_t __cil_tmp64 ;
  uint32_t __cil_tmp65 ;
  uint32_t __cil_tmp66 ;
  uint32_t __cil_tmp67 ;
  uint32_t __cil_tmp68 ;
  uint32_t __cil_tmp69 ;
  uint32_t __cil_tmp70 ;
  uint32_t __cil_tmp71 ;
  uint32_t __cil_tmp72 ;
  uint32_t __cil_tmp74 ;
  uint32_t __cil_tmp75 ;
  uint32_t __cil_tmp76 ;
  uint32_t __cil_tmp80 ;
  uint32_t __cil_tmp81 ;
  uint32_t __cil_tmp83 ;
  uint32_t __cil_tmp84 ;
  uint32_t __cil_tmp85 ;
  uint32_t __cil_tmp86 ;
  uint32_t __cil_tmp88 ;
  uint32_t __cil_tmp89 ;
  int32_t *fill32 ;

  {
#line 166
  numChannels = p->mNumChannels;
#line 168
  if ((unsigned long )bits != (unsigned long )((void *)0)) {
#line 168
    if ((unsigned long )sampleBuffer != (unsigned long )((void *)0)) {
#line 168
      if (! ((unsigned long )outNumSamples != (unsigned long )((void *)0))) {
#line 168
        return (-50);
      }
    } else {
#line 168
      return (-50);
    }
  } else {
#line 168
    return (-50);
  }
#line 169
  if (! (p->mNumChannels > 0U)) {
#line 169
    return (-1048579);
  }
#line 171
  p->mActiveElements = (uint16_t )0;
#line 172
  channelIndex = (uint32_t )0;
#line 174
  status = 0;
#line 175
  *outNumSamples = numSamples;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;

#line 177
    if (! (status == 0)) {
#line 177
      goto while_break;
    }
#line 180
    if (! ((unsigned long )bits->cur < (unsigned long )bits->end)) {
#line 180
      status = -50;
#line 180
      goto Exit;
    }
    {
#line 183
    pb = (uint16_t )p->mConfig.pb;
#line 186
    tag = BitBufferReadSmall(bits, (uint8_t )3);
    }
#line 190
    if ((int )tag == 3) {
#line 190
      goto case_3;
    }
#line 190
    if ((int )tag == 0) {
#line 190
      goto case_3;
    }
#line 309
    if ((int )tag == 16) {
#line 309
      goto case_16;
    }
#line 314
    if ((int )tag == 20) {
#line 314
      goto case_20;
    }
#line 318
    if ((int )tag == 24) {
#line 318
      goto case_24;
    }
#line 325
    if ((int )tag == 32) {
#line 325
      goto case_32;
    }
#line 339
    if ((int )tag == 1) {
#line 339
      goto case_1;
    }
#line 500
    if ((int )tag == 16) {
#line 500
      goto case_16___0;
    }
#line 504
    if ((int )tag == 20) {
#line 504
      goto case_20___0;
    }
#line 508
    if ((int )tag == 24) {
#line 508
      goto case_24___0;
    }
#line 513
    if ((int )tag == 32) {
#line 513
      goto case_32___0;
    }
#line 526
    if ((int )tag == 5) {
#line 526
      goto case_5;
    }
#line 526
    if ((int )tag == 2) {
#line 526
      goto case_5;
    }
#line 534
    if ((int )tag == 4) {
#line 534
      goto case_4;
    }
#line 541
    if ((int )tag == 6) {
#line 541
      goto case_6;
    }
#line 548
    if ((int )tag == 7) {
#line 548
      goto case_7;
    }
#line 187
    goto switch_break;
    case_3: 
    {
#line 193
    elementInstanceTag = BitBufferReadSmall(bits, (uint8_t )4);
#line 194
    p->mActiveElements = (uint16_t )((unsigned int )p->mActiveElements | (1U << (int )elementInstanceTag));
#line 197
    __cil_tmp42 = BitBufferRead(bits, (uint8_t )12);
#line 197
    unusedHeader = (uint16_t )__cil_tmp42;
    }
#line 198
    if (! ((int )unusedHeader == 0)) {
#line 198
      status = -50;
#line 198
      goto Exit;
    }
    {
#line 201
    __cil_tmp43 = BitBufferRead(bits, (uint8_t )4);
#line 201
    headerByte = (uint8_t )__cil_tmp43;
#line 203
    partialFrame = (uint8_t )((int )headerByte >> 3);
#line 205
    bytesShifted = (uint8_t )((unsigned int )((int )headerByte >> 1) & 3U);
    }
#line 206
    if (! ((int )bytesShifted != 3)) {
#line 206
      status = -50;
#line 206
      goto Exit;
    }
#line 208
    shift = (uint32_t )((int )bytesShifted * 8);
#line 210
    escapeFlag = (uint8_t )((int )headerByte & 1);
#line 212
    chanBits = (uint32_t )((int )p->mConfig.bitDepth - (int )bytesShifted * 8);
#line 215
    if ((int )partialFrame != 0) {
      {
#line 217
      __cil_tmp44 = BitBufferRead(bits, (uint8_t )16);
#line 217
      numSamples = __cil_tmp44 << 16;
#line 218
      __cil_tmp45 = BitBufferRead(bits, (uint8_t )16);
#line 218
      numSamples |= __cil_tmp45;
      }
#line 220
      if (! (numSamples < 4096U)) {
#line 220
        return (-1048580);
      }
    }
#line 223
    if ((int )escapeFlag == 0) {
      {
#line 226
      __cil_tmp46 = BitBufferRead(bits, (uint8_t )8);
#line 226
      mixBits = (uint8_t )__cil_tmp46;
#line 227
      __cil_tmp47 = BitBufferRead(bits, (uint8_t )8);
#line 227
      mixRes = (int8_t )__cil_tmp47;
#line 230
      __cil_tmp48 = BitBufferRead(bits, (uint8_t )8);
#line 230
      headerByte = (uint8_t )__cil_tmp48;
#line 231
      modeU = (uint8_t )((int )headerByte >> 4);
#line 232
      denShiftU = (unsigned int )headerByte & 15U;
#line 234
      __cil_tmp49 = BitBufferRead(bits, (uint8_t )8);
#line 234
      headerByte = (uint8_t )__cil_tmp49;
#line 235
      pbFactorU = (uint16_t )((int )headerByte >> 5);
#line 236
      numU = (uint8_t )((unsigned int )headerByte & 31U);
#line 238
      i = (uint32_t )0;
      }
      {
#line 238
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 238
        if (! (i < (unsigned int )numU)) {
#line 238
          goto while_break___0;
        }
        {
#line 239
        __cil_tmp50 = BitBufferRead(bits, (uint8_t )16);
#line 239
        coefsU[i] = (int16_t )__cil_tmp50;
#line 238
        i ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___0: ;
#line 242
      if ((int )bytesShifted != 0) {
        {
#line 244
        shiftBits = *bits;
#line 245
        BitBufferAdvance(bits, (unsigned int )((int )bytesShifted * 8) * numSamples);
        }
      }
      {
#line 249
      set_ag_params(& agParams, (uint32_t )p->mConfig.mb, (uint32_t )(((int )pb * (int )pbFactorU) / 4),
                    (uint32_t )p->mConfig.kb, numSamples, numSamples, (uint32_t )p->mConfig.maxRun);
#line 250
      status = dyn_decomp(& agParams, bits, p->__annonCompField3.mPredictor, (int32_t )numSamples,
                          (int32_t )chanBits, & bits1);
      }
#line 251
      if (status) {
#line 251
        goto Exit;
      }
#line 253
      if ((int )modeU == 0) {
        {
#line 255
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferU, (int32_t )numSamples,
                   & coefsU[0], (int32_t )numU, chanBits, denShiftU);
        }
      } else {
        {
#line 260
        unpc_block(p->__annonCompField3.mPredictor, p->__annonCompField3.mPredictor,
                   (int32_t )numSamples, (int16_t *)((void *)0), 31, chanBits, (uint32_t )0);
#line 261
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferU, (int32_t )numSamples,
                   & coefsU[0], (int32_t )numU, chanBits, denShiftU);
        }
      }
    } else {
#line 269
      shift = 32U - chanBits;
#line 270
      if (chanBits <= 16U) {
#line 272
        i = (uint32_t )0;
        {
#line 272
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 272
          if (! (i < numSamples)) {
#line 272
            goto while_break___1;
          }
          {
#line 274
          __cil_tmp53 = BitBufferRead(bits, (uint8_t )chanBits);
#line 274
          val = (int32_t )__cil_tmp53;
#line 275
          val = (val << shift) >> shift;
#line 276
          p->mMixBufferU[i] = val;
#line 272
          i ++;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___1: ;
      } else {
#line 282
        extraBits = chanBits - 16U;
#line 283
        i = (uint32_t )0;
        {
#line 283
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 283
          if (! (i < numSamples)) {
#line 283
            goto while_break___2;
          }
          {
#line 285
          __cil_tmp55 = BitBufferRead(bits, (uint8_t )16);
#line 285
          val = (int32_t )__cil_tmp55;
#line 286
          __cil_tmp56 = arith_shift_left(val, 16);
#line 286
          val = __cil_tmp56 >> shift;
#line 287
          __cil_tmp57 = BitBufferRead(bits, (uint8_t )extraBits);
#line 287
          p->mMixBufferU[i] = (int32_t )((unsigned int )val | __cil_tmp57);
#line 283
          i ++;
          }
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___2: ;
      }
#line 291
      mixRes = (int8_t )0;
#line 291
      mixBits = (uint8_t )mixRes;
#line 292
      bits1 = chanBits * numSamples;
#line 293
      bytesShifted = (uint8_t )0;
    }
#line 297
    if ((int )bytesShifted != 0) {
#line 299
      shift = (uint32_t )((int )bytesShifted * 8);
#line 302
      i = (uint32_t )0;
      {
#line 302
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 302
        if (! (i < numSamples)) {
#line 302
          goto while_break___3;
        }
        {
#line 303
        __cil_tmp59 = BitBufferRead(& shiftBits, (uint8_t )shift);
#line 303
        p->__annonCompField3.mShiftBuffer[i] = (uint16_t )__cil_tmp59;
#line 302
        i ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___3: ;
    }
#line 309
    if ((int )p->mConfig.bitDepth == 16) {
#line 309
      goto case_16;
    }
#line 314
    if ((int )p->mConfig.bitDepth == 20) {
#line 314
      goto case_20;
    }
#line 318
    if ((int )p->mConfig.bitDepth == 24) {
#line 318
      goto case_24;
    }
#line 325
    if ((int )p->mConfig.bitDepth == 32) {
#line 325
      goto case_32;
    }
#line 307
    goto switch_break___0;
    case_16: 
#line 310
    out32 = sampleBuffer + channelIndex;
#line 311
    j = (uint32_t )0;
#line 311
    i = (uint32_t )0;
    {
#line 311
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 311
      if (! (i < numSamples)) {
#line 311
        goto while_break___4;
      }
      {
#line 312
      *(out32 + j) = arith_shift_left(p->mMixBufferU[i], 16);
#line 311
      j += numChannels;
#line 311
      __cil_tmp62 = i;
#line 311
      i ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___4: ;
#line 313
    goto switch_break___0;
    case_20: 
    {
#line 315
    out32 = sampleBuffer + channelIndex;
#line 316
    copyPredictorTo20(p->mMixBufferU, out32, numChannels, (int32_t )numSamples);
    }
#line 317
    goto switch_break___0;
    case_24: 
#line 319
    out32 = sampleBuffer + channelIndex;
#line 320
    if ((int )bytesShifted != 0) {
      {
#line 321
      copyPredictorTo24Shift(p->mMixBufferU, p->__annonCompField3.mShiftBuffer, out32,
                             numChannels, (int32_t )numSamples, (int32_t )bytesShifted);
      }
    } else {
      {
#line 323
      copyPredictorTo24(p->mMixBufferU, out32, numChannels, (int32_t )numSamples);
      }
    }
#line 324
    goto switch_break___0;
    case_32: 
#line 326
    out32 = sampleBuffer + channelIndex;
#line 327
    if ((int )bytesShifted != 0) {
      {
#line 328
      copyPredictorTo32Shift(p->mMixBufferU, p->__annonCompField3.mShiftBuffer, out32,
                             numChannels, (int32_t )numSamples, (int32_t )bytesShifted);
      }
    } else {
      {
#line 330
      copyPredictorTo32(p->mMixBufferU, out32, numChannels, (int32_t )numSamples);
      }
    }
#line 331
    goto switch_break___0;
    switch_break___0: 
#line 334
    channelIndex ++;
#line 335
    *outNumSamples = numSamples;
#line 336
    goto switch_break;
    case_1: 
#line 342
    if (channelIndex + 2U > numChannels) {
#line 343
      goto NoMoreChannels;
    }
    {
#line 346
    elementInstanceTag = BitBufferReadSmall(bits, (uint8_t )4);
#line 347
    p->mActiveElements = (uint16_t )((unsigned int )p->mActiveElements | (1U << (int )elementInstanceTag));
#line 350
    __cil_tmp64 = BitBufferRead(bits, (uint8_t )12);
#line 350
    unusedHeader = (uint16_t )__cil_tmp64;
    }
#line 351
    if (! ((int )unusedHeader == 0)) {
#line 351
      status = -50;
#line 351
      goto Exit;
    }
    {
#line 354
    __cil_tmp65 = BitBufferRead(bits, (uint8_t )4);
#line 354
    headerByte = (uint8_t )__cil_tmp65;
#line 356
    partialFrame = (uint8_t )((int )headerByte >> 3);
#line 358
    bytesShifted = (uint8_t )((unsigned int )((int )headerByte >> 1) & 3U);
    }
#line 359
    if (! ((int )bytesShifted != 3)) {
#line 359
      status = -50;
#line 359
      goto Exit;
    }
#line 361
    shift = (uint32_t )((int )bytesShifted * 8);
#line 363
    escapeFlag = (uint8_t )((int )headerByte & 1);
#line 365
    chanBits = (uint32_t )(((int )p->mConfig.bitDepth - (int )bytesShifted * 8) + 1);
#line 368
    if ((int )partialFrame != 0) {
      {
#line 370
      __cil_tmp66 = BitBufferRead(bits, (uint8_t )16);
#line 370
      numSamples = __cil_tmp66 << 16;
#line 371
      __cil_tmp67 = BitBufferRead(bits, (uint8_t )16);
#line 371
      numSamples |= __cil_tmp67;
      }
#line 373
      if (! (numSamples < 4096U)) {
#line 373
        return (-1048580);
      }
    }
#line 376
    if ((int )escapeFlag == 0) {
      {
#line 379
      __cil_tmp68 = BitBufferRead(bits, (uint8_t )8);
#line 379
      mixBits = (uint8_t )__cil_tmp68;
#line 380
      __cil_tmp69 = BitBufferRead(bits, (uint8_t )8);
#line 380
      mixRes = (int8_t )__cil_tmp69;
#line 382
      __cil_tmp70 = BitBufferRead(bits, (uint8_t )8);
#line 382
      headerByte = (uint8_t )__cil_tmp70;
#line 383
      modeU = (uint8_t )((int )headerByte >> 4);
#line 384
      denShiftU = (unsigned int )headerByte & 15U;
#line 386
      __cil_tmp71 = BitBufferRead(bits, (uint8_t )8);
#line 386
      headerByte = (uint8_t )__cil_tmp71;
#line 387
      pbFactorU = (uint16_t )((int )headerByte >> 5);
#line 388
      numU = (uint8_t )((unsigned int )headerByte & 31U);
#line 389
      i = (uint32_t )0;
      }
      {
#line 389
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 389
        if (! (i < (unsigned int )numU)) {
#line 389
          goto while_break___5;
        }
        {
#line 390
        __cil_tmp72 = BitBufferRead(bits, (uint8_t )16);
#line 390
        coefsU[i] = (int16_t )__cil_tmp72;
#line 389
        i ++;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___5: 
      {
#line 392
      __cil_tmp74 = BitBufferRead(bits, (uint8_t )8);
#line 392
      headerByte = (uint8_t )__cil_tmp74;
#line 393
      modeV = (uint8_t )((int )headerByte >> 4);
#line 394
      denShiftV = (unsigned int )headerByte & 15U;
#line 396
      __cil_tmp75 = BitBufferRead(bits, (uint8_t )8);
#line 396
      headerByte = (uint8_t )__cil_tmp75;
#line 397
      pbFactorV = (uint16_t )((int )headerByte >> 5);
#line 398
      numV = (uint8_t )((unsigned int )headerByte & 31U);
#line 399
      i = (uint32_t )0;
      }
      {
#line 399
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 399
        if (! (i < (unsigned int )numV)) {
#line 399
          goto while_break___6;
        }
        {
#line 400
        __cil_tmp76 = BitBufferRead(bits, (uint8_t )16);
#line 400
        coefsV[i] = (int16_t )__cil_tmp76;
#line 399
        i ++;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___6: ;
#line 403
      if ((int )bytesShifted != 0) {
        {
#line 405
        shiftBits = *bits;
#line 406
        BitBufferAdvance(bits, (unsigned int )(((int )bytesShifted * 8) * 2) * numSamples);
        }
      }
      {
#line 410
      set_ag_params(& agParams, (uint32_t )p->mConfig.mb, (uint32_t )(((int )pb * (int )pbFactorU) / 4),
                    (uint32_t )p->mConfig.kb, numSamples, numSamples, (uint32_t )p->mConfig.maxRun);
#line 411
      status = dyn_decomp(& agParams, bits, p->__annonCompField3.mPredictor, (int32_t )numSamples,
                          (int32_t )chanBits, & bits1);
      }
#line 412
      if (status) {
#line 412
        goto Exit;
      }
#line 414
      if ((int )modeU == 0) {
        {
#line 416
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferU, (int32_t )numSamples,
                   & coefsU[0], (int32_t )numU, chanBits, denShiftU);
        }
      } else {
        {
#line 421
        unpc_block(p->__annonCompField3.mPredictor, p->__annonCompField3.mPredictor,
                   (int32_t )numSamples, (int16_t *)((void *)0), 31, chanBits, (uint32_t )0);
#line 422
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferU, (int32_t )numSamples,
                   & coefsU[0], (int32_t )numU, chanBits, denShiftU);
        }
      }
      {
#line 426
      set_ag_params(& agParams, (uint32_t )p->mConfig.mb, (uint32_t )(((int )pb * (int )pbFactorV) / 4),
                    (uint32_t )p->mConfig.kb, numSamples, numSamples, (uint32_t )p->mConfig.maxRun);
#line 427
      status = dyn_decomp(& agParams, bits, p->__annonCompField3.mPredictor, (int32_t )numSamples,
                          (int32_t )chanBits, & bits2);
      }
#line 428
      if (status) {
#line 428
        goto Exit;
      }
#line 430
      if ((int )modeV == 0) {
        {
#line 432
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferV, (int32_t )numSamples,
                   & coefsV[0], (int32_t )numV, chanBits, denShiftV);
        }
      } else {
        {
#line 437
        unpc_block(p->__annonCompField3.mPredictor, p->__annonCompField3.mPredictor,
                   (int32_t )numSamples, (int16_t *)((void *)0), 31, chanBits, (uint32_t )0);
#line 438
        unpc_block(p->__annonCompField3.mPredictor, p->mMixBufferV, (int32_t )numSamples,
                   & coefsV[0], (int32_t )numV, chanBits, denShiftV);
        }
      }
    } else {
#line 446
      chanBits = (uint32_t )p->mConfig.bitDepth;
#line 447
      shift = 32U - chanBits;
#line 448
      if (chanBits <= 16U) {
#line 450
        i = (uint32_t )0;
        {
#line 450
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 450
          if (! (i < numSamples)) {
#line 450
            goto while_break___7;
          }
          {
#line 452
          __cil_tmp80 = BitBufferRead(bits, (uint8_t )chanBits);
#line 452
          val = (int32_t )__cil_tmp80;
#line 453
          val = (val << shift) >> shift;
#line 454
          p->mMixBufferU[i] = val;
#line 456
          __cil_tmp81 = BitBufferRead(bits, (uint8_t )chanBits);
#line 456
          val = (int32_t )__cil_tmp81;
#line 457
          val = (val << shift) >> shift;
#line 458
          p->mMixBufferV[i] = val;
#line 450
          i ++;
          }
        }
        while_break___19: /* CIL Label */ ;
        }
        while_break___7: ;
      } else {
#line 464
        extraBits = chanBits - 16U;
#line 465
        i = (uint32_t )0;
        {
#line 465
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 465
          if (! (i < numSamples)) {
#line 465
            goto while_break___8;
          }
          {
#line 467
          __cil_tmp83 = BitBufferRead(bits, (uint8_t )16);
#line 467
          val = (int32_t )__cil_tmp83;
#line 468
          val = (int32_t )(((uint32_t )val << 16) >> shift);
#line 469
          __cil_tmp84 = BitBufferRead(bits, (uint8_t )extraBits);
#line 469
          p->mMixBufferU[i] = (int32_t )((unsigned int )val | __cil_tmp84);
#line 471
          __cil_tmp85 = BitBufferRead(bits, (uint8_t )16);
#line 471
          val = (int32_t )__cil_tmp85;
#line 472
          val = (int32_t )((uint32_t )val >> shift);
#line 473
          __cil_tmp86 = BitBufferRead(bits, (uint8_t )extraBits);
#line 473
          p->mMixBufferV[i] = (int32_t )((unsigned int )val | __cil_tmp86);
#line 465
          i ++;
          }
        }
        while_break___20: /* CIL Label */ ;
        }
        while_break___8: ;
      }
#line 477
      bits1 = chanBits * numSamples;
#line 478
      bits2 = chanBits * numSamples;
#line 479
      mixRes = (int8_t )0;
#line 479
      mixBits = (uint8_t )mixRes;
#line 480
      bytesShifted = (uint8_t )0;
    }
#line 484
    if ((int )bytesShifted != 0) {
#line 486
      shift = (uint32_t )((int )bytesShifted * 8);
#line 489
      i = (uint32_t )0;
      {
#line 489
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 489
        if (! (i < numSamples * 2U)) {
#line 489
          goto while_break___9;
        }
        {
#line 491
        __cil_tmp88 = BitBufferRead(& shiftBits, (uint8_t )shift);
#line 491
        p->__annonCompField3.mShiftBuffer[i] = (uint16_t )__cil_tmp88;
#line 492
        __cil_tmp89 = BitBufferRead(& shiftBits, (uint8_t )shift);
#line 492
        p->__annonCompField3.mShiftBuffer[i + 1U] = (uint16_t )__cil_tmp89;
#line 489
        i += 2U;
        }
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___9: ;
    }
#line 500
    if ((int )p->mConfig.bitDepth == 16) {
#line 500
      goto case_16___0;
    }
#line 504
    if ((int )p->mConfig.bitDepth == 20) {
#line 504
      goto case_20___0;
    }
#line 508
    if ((int )p->mConfig.bitDepth == 24) {
#line 508
      goto case_24___0;
    }
#line 513
    if ((int )p->mConfig.bitDepth == 32) {
#line 513
      goto case_32___0;
    }
#line 498
    goto switch_break___1;
    case_16___0: 
    {
#line 501
    out32 = sampleBuffer + channelIndex;
#line 502
    unmix16(p->mMixBufferU, p->mMixBufferV, out32, numChannels, (int32_t )numSamples,
            (int32_t )mixBits, (int32_t )mixRes);
    }
#line 503
    goto switch_break___1;
    case_20___0: 
    {
#line 505
    out32 = sampleBuffer + channelIndex;
#line 506
    unmix20(p->mMixBufferU, p->mMixBufferV, out32, numChannels, (int32_t )numSamples,
            (int32_t )mixBits, (int32_t )mixRes);
    }
#line 507
    goto switch_break___1;
    case_24___0: 
    {
#line 509
    out32 = sampleBuffer + channelIndex;
#line 510
    unmix24(p->mMixBufferU, p->mMixBufferV, out32, numChannels, (int32_t )numSamples,
            (int32_t )mixBits, (int32_t )mixRes, p->__annonCompField3.mShiftBuffer,
            (int32_t )bytesShifted);
    }
#line 512
    goto switch_break___1;
    case_32___0: 
    {
#line 514
    out32 = sampleBuffer + channelIndex;
#line 515
    unmix32(p->mMixBufferU, p->mMixBufferV, out32, numChannels, (int32_t )numSamples,
            (int32_t )mixBits, (int32_t )mixRes, p->__annonCompField3.mShiftBuffer,
            (int32_t )bytesShifted);
    }
#line 517
    goto switch_break___1;
    switch_break___1: 
#line 520
    channelIndex += 2U;
#line 521
    *outNumSamples = numSamples;
#line 522
    goto switch_break;
    case_5: 
#line 530
    status = -1048581;
#line 531
    goto switch_break;
    case_4: 
    {
#line 537
    status = alac_data_stream_element(bits);
    }
#line 538
    goto switch_break;
    case_6: 
    {
#line 544
    status = alac_fill_element(bits);
    }
#line 545
    goto switch_break;
    case_7: 
    {
#line 551
    BitBufferByteAlign(bits, 0);
    }
#line 553
    goto Exit;
    switch_break: ;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break: ;
  NoMoreChannels: 
  {
#line 568
  while (1) {
    while_continue___10: /* CIL Label */ ;

#line 568
    if (! (channelIndex < numChannels)) {
#line 568
      goto while_break___10;
    }
    {
#line 570
    fill32 = sampleBuffer + channelIndex;
#line 571
    Zero32(fill32, numSamples, numChannels);
#line 568
    channelIndex ++;
    }
  }
  while_break___22: /* CIL Label */ ;
  }
  while_break___10: ;
  Exit: 
#line 575
  return (status);
}
}
#line 587 "/root/patchweave_donee/23/src/ALAC/alac_decoder.c"
static int32_t alac_fill_element(struct BitBuffer *bits ) 
{ 
  int16_t count___0 ;
  uint8_t __cil_tmp3 ;
  uint8_t __cil_tmp4 ;

  {
  {
#line 593
  __cil_tmp3 = BitBufferReadSmall(bits, (uint8_t )4);
#line 593
  count___0 = (int16_t )__cil_tmp3;
  }
#line 594
  if ((int )count___0 == 15) {
    {
#line 595
    __cil_tmp4 = BitBufferReadSmall(bits, (uint8_t )8);
#line 595
    count___0 = (int16_t )((int )count___0 + ((int )((int16_t )__cil_tmp4) - 1));
    }
  }
  {
#line 597
  BitBufferAdvance(bits, (uint32_t )((int )count___0 * 8));
  }
#line 599
  if (! ((unsigned long )bits->cur <= (unsigned long )bits->end)) {
#line 599
    return (-50);
  }
#line 601
  return (0);
}
}
#line 609 "/root/patchweave_donee/23/src/ALAC/alac_decoder.c"
static int32_t alac_data_stream_element(struct BitBuffer *bits ) 
{ 
  int32_t data_byte_align_flag ;
  uint16_t count___0 ;
  uint8_t __cil_tmp4 ;
  uint8_t __cil_tmp5 ;
  uint8_t __cil_tmp6 ;

  {
  {
#line 616
  BitBufferReadSmall(bits, (uint8_t )4);
#line 618
  __cil_tmp4 = BitBufferReadOne(bits);
#line 618
  data_byte_align_flag = (int32_t )__cil_tmp4;
#line 621
  __cil_tmp5 = BitBufferReadSmall(bits, (uint8_t )8);
#line 621
  count___0 = (uint16_t )__cil_tmp5;
  }
#line 622
  if ((int )count___0 == 255) {
    {
#line 623
    __cil_tmp6 = BitBufferReadSmall(bits, (uint8_t )8);
#line 623
    count___0 = (uint16_t )((int )count___0 + (int )__cil_tmp6);
    }
  }
#line 626
  if (data_byte_align_flag) {
    {
#line 627
    BitBufferByteAlign(bits, 0);
    }
  }
  {
#line 630
  BitBufferAdvance(bits, (uint32_t )((int )count___0 * 8));
  }
#line 632
  if (! ((unsigned long )bits->cur <= (unsigned long )bits->end)) {
#line 632
    return (-50);
  }
#line 634
  return (0);
}
}
#line 641 "/root/patchweave_donee/23/src/ALAC/alac_decoder.c"
static void Zero32(int32_t *buffer , uint32_t numItems , uint32_t stride ) 
{ 
  uint32_t indx ;

  {
#line 643
  if (stride == 1U) {
    {
#line 645
    memset((void *)buffer, 0, (unsigned long )numItems * sizeof(int32_t ));
    }
  } else {
#line 649
    indx = (uint32_t )0;
    {
#line 649
    while (1) {
      while_continue: /* CIL Label */ ;

#line 649
      if (! (indx < numItems * stride)) {
#line 649
        goto while_break;
      }
#line 650
      *(buffer + indx) = 0;
#line 649
      indx += stride;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 654
  return;
}
}
#line 59 "/root/patchweave_donee/23/src/ALAC/ag_enc.c"
__inline static int32_t lead(int32_t m ) 
{ 
  long j ;
  unsigned long c ;

  {
#line 62
  c = 1UL << 31;
#line 64
  j = 0L;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;

#line 64
    if (! (j < 32L)) {
#line 64
      goto while_break;
    }
#line 66
    if ((c & (unsigned long )m) != 0UL) {
#line 67
      goto while_break;
    }
#line 68
    c >>= 1;
#line 64
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 70
  return ((int32_t )j);
}
}
#line 75 "/root/patchweave_donee/23/src/ALAC/ag_enc.c"
__inline static int32_t lg3a(int32_t x ) 
{ 
  int32_t result ;

  {
  {
#line 79
  x += 3;
#line 80
  result = lead(x);
  }
#line 82
  return (31 - result);
}
}
#line 85 "/root/patchweave_donee/23/src/ALAC/ag_enc.c"
__inline static int32_t abs_func(int32_t a ) 
{ 
  int32_t isneg ;
  int32_t xorval ;
  int32_t result ;

  {
#line 88
  isneg = a >> 31;
#line 89
  xorval = a ^ isneg;
#line 90
  result = xorval - isneg;
#line 92
  return (result);
}
}
#line 95 "/root/patchweave_donee/23/src/ALAC/ag_enc.c"
__inline static uint32_t read32bit(uint8_t *buffer ) 
{ 
  uint32_t value___0 ;

  {
#line 100
  value___0 = ((((uint32_t )*(buffer + 0) << 24) | ((uint32_t )*(buffer + 1) << 16)) | ((uint32_t )*(buffer + 2) << 8)) | (uint32_t )*(buffer + 3);
#line 102
  return (value___0);
}
}
#line 109 "/root/patchweave_donee/23/src/ALAC/ag_enc.c"
__inline static int32_t dyn_code(int32_t m , int32_t k , int32_t n , uint32_t *outNumBits ) 
{ 
  uint32_t divx ;
  uint32_t mod ;
  uint32_t de ;
  uint32_t numBits ;
  uint32_t value___0 ;

  {
#line 117
  divx = (uint32_t )(n / m);
#line 119
  if (divx >= 9U) {
#line 121
    numBits = (uint32_t )25;
#line 122
    value___0 = (uint32_t )((((1 << 9) - 1) << 16) + n);
  } else {
#line 126
    mod = (uint32_t )(n % m);
#line 127
    de = (uint32_t )(mod == 0U);
#line 128
    numBits = ((divx + (unsigned int )k) + 1U) - de;
#line 129
    value___0 = (((unsigned int )(((1 << divx) - 1) << (numBits - divx)) + mod) + 1U) - de;
#line 132
    if (numBits > 25U) {
#line 134
      numBits = (uint32_t )25;
#line 135
      value___0 = (uint32_t )((((1 << 9) - 1) << 16) + n);
    }
  }
#line 139
  *outNumBits = numBits;
#line 141
  return ((int32_t )value___0);
}
}
#line 145 "/root/patchweave_donee/23/src/ALAC/ag_enc.c"
__inline static int32_t dyn_code_32bit(int32_t maxbits , uint32_t m , uint32_t k ,
                                       uint32_t n , uint32_t *outNumBits , uint32_t *outValue ,
                                       uint32_t *overflow , uint32_t *overflowbits ) 
{ 
  uint32_t divx ;
  uint32_t mod ;
  uint32_t de ;
  uint32_t numBits ;
  uint32_t value___0 ;
  int32_t didOverflow ;

  {
#line 150
  didOverflow = 0;
#line 152
  divx = n / m;
#line 154
  if (divx < 9U) {
#line 156
    mod = n - m * divx;
#line 158
    de = (uint32_t )(mod == 0U);
#line 159
    numBits = ((divx + k) + 1U) - de;
#line 160
    value___0 = (((unsigned int )(((1 << divx) - 1) << (numBits - divx)) + mod) + 1U) - de;
#line 161
    if (numBits > 25U) {
#line 162
      goto codeasescape;
    }
  } else {
    codeasescape: 
#line 167
    numBits = (uint32_t )9;
#line 168
    value___0 = (uint32_t )((1 << 9) - 1);
#line 169
    *overflow = n;
#line 170
    *overflowbits = (uint32_t )maxbits;
#line 171
    didOverflow = 1;
  }
#line 174
  *outNumBits = numBits;
#line 175
  *outValue = value___0;
#line 177
  return (didOverflow);
}
}
#line 181 "/root/patchweave_donee/23/src/ALAC/ag_enc.c"
__inline static void dyn_jam_noDeref(unsigned char *out , uint32_t bitPos , uint32_t numBits ,
                                     uint32_t value___0 ) 
{ 
  uint32_t mask ;
  uint32_t curr ;
  uint32_t shift ;
  int32_t __cil_tmp8 ;

  {
  {
#line 189
  __cil_tmp8 = psf_get_be32(out, (int )(bitPos >> 3));
#line 189
  curr = (uint32_t )__cil_tmp8;
#line 191
  shift = (32U - (bitPos & 7U)) - numBits;
#line 193
  mask = 4294967295U >> (32U - numBits);
#line 194
  mask <<= shift;
#line 196
  value___0 = (value___0 << shift) & mask;
#line 197
  value___0 |= curr & ~ mask;
#line 199
  psf_put_be32(out, (int )(bitPos >> 3), (int32_t )value___0);
  }
#line 201
  return;
}
}
#line 203 "/root/patchweave_donee/23/src/ALAC/ag_enc.c"
__inline static void dyn_jam_noDeref_large(unsigned char *out , uint32_t bitPos ,
                                           uint32_t numBits , uint32_t value___0 ) 
{ 
  uint32_t w ;
  uint32_t curr ;
  uint32_t mask ;
  int32_t shiftvalue ;
  int32_t __cil_tmp9 ;
  uint8_t tailbyte ;
  uint8_t *tailptr ;

  {
  {
#line 208
  shiftvalue = (int32_t )((32U - (bitPos & 7U)) - numBits);
#line 212
  __cil_tmp9 = psf_get_be32(out, (int )(bitPos >> 3));
#line 212
  curr = (uint32_t )__cil_tmp9;
  }
#line 214
  if (shiftvalue < 0) {
#line 219
    w = value___0 >> - shiftvalue;
#line 220
    mask = 4294967295U >> - shiftvalue;
#line 221
    w |= curr & ~ mask;
#line 223
    tailptr = (out + (bitPos >> 3)) + 4;
#line 224
    tailbyte = (uint8_t )((value___0 << (8 + shiftvalue)) & 255U);
#line 225
    *tailptr = tailbyte;
  } else {
#line 229
    mask = 4294967295U >> (32U - numBits);
#line 230
    mask <<= shiftvalue;
#line 232
    w = (value___0 << shiftvalue) & mask;
#line 233
    w |= curr & ~ mask;
  }
  {
#line 236
  psf_put_be32(out, (int )(bitPos >> 3), (int32_t )w);
  }
#line 238
  return;
}
}
#line 240 "/root/patchweave_donee/23/src/ALAC/ag_enc.c"
int32_t dyn_comp(AGParamRecPtr params , int32_t *pc , BitBuffer *bitstream , int32_t numSamples ,
                 int32_t bitSize , uint32_t *outNumBits ) 
{ 
  unsigned char *out ;
  uint32_t bitPos ;
  uint32_t startPos ;
  uint32_t m ;
  uint32_t k ;
  uint32_t n ;
  uint32_t c ;
  uint32_t mz ;
  uint32_t nz ;
  uint32_t numBits ;
  uint32_t value___0 ;
  int32_t del ;
  int32_t zmode ;
  uint32_t overflow ;
  uint32_t overflowbits ;
  int32_t status ;
  uint32_t mb ;
  uint32_t pb ;
  uint32_t kb ;
  uint32_t wb ;
  int32_t rowPos ;
  int32_t rowSize ;
  int32_t rowJump ;
  int32_t *inPtr ;
  int32_t __cil_tmp31 ;
  int32_t *__cil_tmp32 ;
  int32_t __cil_tmp34 ;
  int32_t __cil_tmp35 ;
  int32_t __cil_tmp37 ;
  int32_t __cil_tmp38 ;

  {
#line 253
  rowPos = 0;
#line 254
  rowSize = (int32_t )params->sw;
#line 255
  rowJump = (int32_t )(params->fw - (unsigned int )rowSize);
#line 256
  inPtr = pc;
#line 258
  *outNumBits = (uint32_t )0;
#line 259
  if (bitSize >= 1) {
#line 259
    if (! (bitSize <= 32)) {
#line 259
      return (-50);
    }
  } else {
#line 259
    return (-50);
  }
#line 261
  out = bitstream->cur;
#line 262
  startPos = bitstream->bitIndex;
#line 263
  bitPos = startPos;
#line 265
  params->mb = params->mb0;
#line 265
  mb = params->mb;
#line 266
  pb = params->pb;
#line 267
  kb = params->kb;
#line 268
  wb = params->wb;
#line 269
  zmode = 0;
#line 271
  c = (uint32_t )0;
#line 272
  status = 0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;

#line 274
    if (! (c < (uint32_t )numSamples)) {
#line 274
      goto while_break;
    }
    {
#line 276
    m = mb >> 9;
#line 277
    __cil_tmp31 = lg3a((int32_t )m);
#line 277
    k = (uint32_t )__cil_tmp31;
    }
#line 278
    if (k > kb) {
#line 280
      k = kb;
    }
    {
#line 282
    m = (uint32_t )((1 << k) - 1);
#line 284
    __cil_tmp32 = inPtr;
#line 284
    inPtr ++;
#line 284
    del = *__cil_tmp32;
#line 285
    rowPos ++;
#line 287
    __cil_tmp34 = abs_func(del);
#line 287
    n = (uint32_t )(((__cil_tmp34 << 1) - ((del >> 31) & 1)) - zmode);
#line 290
    __cil_tmp35 = dyn_code_32bit(bitSize, m, k, n, & numBits, & value___0, & overflow,
                                 & overflowbits);
    }
#line 290
    if (__cil_tmp35) {
      {
#line 292
      dyn_jam_noDeref(out, bitPos, numBits, value___0);
#line 293
      bitPos += numBits;
#line 294
      dyn_jam_noDeref_large(out, bitPos, overflowbits, overflow);
#line 295
      bitPos += overflowbits;
      }
    } else {
      {
#line 299
      dyn_jam_noDeref(out, bitPos, numBits, value___0);
#line 300
      bitPos += numBits;
      }
    }
#line 303
    c ++;
#line 304
    if (rowPos >= rowSize) {
#line 306
      rowPos = 0;
#line 307
      inPtr += rowJump;
    }
#line 310
    mb = (pb * (n + (unsigned int )zmode) + mb) - (pb * mb >> 9);
#line 313
    if (n > 65535U) {
#line 314
      mb = (uint32_t )65535;
    }
#line 316
    zmode = 0;
#line 318
    if (! (c <= (uint32_t )numSamples)) {
#line 318
      status = -50;
#line 318
      goto Exit;
    }
#line 320
    if (mb << 2 < (unsigned int )(1 << 9)) {
#line 320
      if (c < (uint32_t )numSamples) {
#line 322
        zmode = 1;
#line 323
        nz = (uint32_t )0;
        {
#line 325
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 325
          if (c < (uint32_t )numSamples) {
#line 325
            if (! (*inPtr == 0)) {
#line 325
              goto while_break___0;
            }
          } else {
#line 325
            goto while_break___0;
          }
#line 328
          inPtr ++;
#line 329
          nz ++;
#line 330
          c ++;
#line 331
          rowPos ++;
#line 331
          if (rowPos >= rowSize) {
#line 333
            rowPos = 0;
#line 334
            inPtr += rowJump;
          }
#line 337
          if (nz >= 65535U) {
#line 339
            zmode = 0;
#line 340
            goto while_break___0;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: 
        {
#line 344
        __cil_tmp37 = lead((int32_t )mb);
#line 344
        k = (unsigned int )(__cil_tmp37 - 24) + ((mb + (unsigned int )(1 << 4)) >> 6);
#line 345
        mz = (unsigned int )((1 << k) - 1) & wb;
#line 347
        __cil_tmp38 = dyn_code((int32_t )mz, (int32_t )k, (int32_t )nz, & numBits);
#line 347
        value___0 = (uint32_t )__cil_tmp38;
#line 348
        dyn_jam_noDeref(out, bitPos, numBits, value___0);
#line 349
        bitPos += numBits;
#line 351
        mb = (uint32_t )0;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 355
  *outNumBits = bitPos - startPos;
#line 356
  BitBufferAdvance(bitstream, *outNumBits);
  }
  Exit: 
#line 359
  return (status);
}
}
#line 56 "/root/patchweave_donee/23/src/ALAC/ag_dec.c"
void set_standard_ag_params(AGParamRecPtr params , uint32_t fullwidth , uint32_t sectorwidth ) 
{ 


  {
  {
#line 64
  set_ag_params(params, (uint32_t )10, (uint32_t )40, (uint32_t )14, fullwidth, sectorwidth,
                (uint32_t )255);
  }
#line 67
  return;
}
}
#line 67 "/root/patchweave_donee/23/src/ALAC/ag_dec.c"
void set_ag_params(AGParamRecPtr params , uint32_t m , uint32_t p , uint32_t k , uint32_t f ,
                   uint32_t s , uint32_t maxrun ) 
{ 


  {
#line 69
  params->mb0 = m;
#line 69
  params->mb = params->mb0;
#line 70
  params->pb = p;
#line 71
  params->kb = k;
#line 72
  params->wb = (1U << params->kb) - 1U;
#line 73
  params->qb = (unsigned int )(1 << 9) - params->pb;
#line 74
  params->fw = f;
#line 75
  params->sw = s;
#line 76
  params->maxrun = maxrun;
#line 77
  return;
}
}
#line 130 "/root/patchweave_donee/23/src/ALAC/ag_dec.c"
__inline static uint32_t getstreambits(uint8_t *in , int32_t bitoffset , int32_t numbits ) 
{ 
  uint32_t load1 ;
  uint32_t load2 ;
  uint32_t byteoffset ;
  uint32_t result ;
  int32_t load2shift ;

  {
  {
#line 133
  byteoffset = (uint32_t )(bitoffset / 8);
#line 138
  load1 = read32bit(in + byteoffset);
  }
#line 140
  if (numbits + (bitoffset & 7) > 32) {
#line 144
    result = load1 << (bitoffset & 7);
#line 145
    load2 = (uint32_t )*(in + (byteoffset + 4U));
#line 146
    load2shift = 8 - ((numbits + (bitoffset & 7)) - 32);
#line 147
    load2 >>= load2shift;
#line 148
    result >>= 32 - numbits;
#line 149
    result |= load2;
  } else {
#line 153
    result = load1 >> ((32 - numbits) - (bitoffset & 7));
  }
#line 158
  if ((unsigned long )numbits != sizeof(result) * 8UL) {
#line 159
    result = (uint32_t )((unsigned long )result & ~ (4294967295UL << numbits));
  }
#line 161
  return (result);
}
}
#line 165 "/root/patchweave_donee/23/src/ALAC/ag_dec.c"
__inline static int32_t dyn_get(unsigned char *in , uint32_t *bitPos , uint32_t m ,
                                uint32_t k ) 
{ 
  uint32_t tempbits ;
  uint32_t result ;
  uint32_t pre ;
  uint32_t v ;
  uint32_t streamlong ;
  uint32_t notI ;
  int32_t __cil_tmp12 ;

  {
  {
#line 167
  tempbits = *bitPos;
#line 169
  pre = (uint32_t )0;
#line 172
  streamlong = read32bit(in + (tempbits >> 3));
#line 173
  streamlong <<= tempbits & 7U;
#line 177
  notI = ~ streamlong;
#line 178
  __cil_tmp12 = lead((int32_t )notI);
#line 178
  pre = (uint32_t )__cil_tmp12;
  }
#line 181
  if (pre >= 9U) {
#line 183
    pre = (uint32_t )9;
#line 184
    tempbits += pre;
#line 185
    streamlong <<= pre;
#line 186
    result = streamlong >> 16;
#line 187
    tempbits += 16U;
  } else {
#line 195
    tempbits += pre;
#line 196
    tempbits ++;
#line 197
    streamlong <<= pre + 1U;
#line 198
    v = streamlong >> (32U - k);
#line 199
    tempbits += k;
#line 201
    result = (pre * m + v) - 1U;
#line 203
    if (v < 2U) {
#line 205
      result -= v - 1U;
#line 206
      tempbits --;
    }
  }
#line 210
  *bitPos = tempbits;
#line 211
  return ((int32_t )result);
}
}
#line 215 "/root/patchweave_donee/23/src/ALAC/ag_dec.c"
__inline static int32_t dyn_get_32bit(uint8_t *in , uint32_t *bitPos , int32_t m ,
                                      int32_t k , int32_t maxbits ) 
{ 
  uint32_t tempbits ;
  uint32_t v ;
  uint32_t streamlong ;
  uint32_t result ;
  uint32_t notI ;
  int32_t __cil_tmp12 ;

  {
  {
#line 217
  tempbits = *bitPos;
#line 222
  streamlong = read32bit(in + (tempbits >> 3));
#line 223
  streamlong <<= tempbits & 7U;
#line 227
  notI = ~ streamlong;
#line 228
  __cil_tmp12 = lead((int32_t )notI);
#line 228
  result = (uint32_t )__cil_tmp12;
  }
#line 231
  if (result >= 9U) {
    {
#line 233
    result = getstreambits(in, (int32_t )(tempbits + 9U), maxbits);
#line 234
    tempbits += (unsigned int )(9 + maxbits);
    }
  } else {
#line 243
    tempbits += result;
#line 244
    tempbits ++;
#line 246
    if (k != 1) {
#line 248
      streamlong <<= result + 1U;
#line 249
      v = streamlong >> (32 - k);
#line 250
      tempbits += (unsigned int )k;
#line 251
      tempbits --;
#line 252
      result *= (unsigned int )m;
#line 254
      if (v >= 2U) {
#line 256
        result += v - 1U;
#line 257
        tempbits ++;
      }
    }
  }
#line 262
  *bitPos = tempbits;
#line 264
  return ((int32_t )result);
}
}
#line 267 "/root/patchweave_donee/23/src/ALAC/ag_dec.c"
int32_t dyn_decomp(AGParamRecPtr params , BitBuffer *bitstream , int32_t *pc , int32_t numSamples ,
                   int32_t maxSize , uint32_t *outNumBits ) 
{ 
  uint8_t *in ;
  int32_t *outPtr ;
  uint32_t bitPos ;
  uint32_t startPos ;
  uint32_t maxPos ;
  uint32_t j ;
  uint32_t m ;
  uint32_t k ;
  uint32_t n ;
  uint32_t c ;
  uint32_t mz ;
  int32_t del ;
  int32_t zmode ;
  uint32_t mb ;
  uint32_t pb_local ;
  uint32_t kb_local ;
  uint32_t wb_local ;
  int32_t status ;
  int32_t __cil_tmp25 ;
  uint32_t tmp ;
  int32_t __cil_tmp27 ;
  uint32_t ndecode ;
  int32_t multiplier ;
  int32_t *__cil_tmp30 ;
  int32_t __cil_tmp32 ;
  int32_t __cil_tmp33 ;
  int32_t *__cil_tmp34 ;

  {
#line 270
  outPtr = pc;
#line 275
  pb_local = params->pb;
#line 276
  kb_local = params->kb;
#line 277
  wb_local = params->wb;
#line 280
  if ((unsigned long )bitstream != (unsigned long )((void *)0)) {
#line 280
    if ((unsigned long )pc != (unsigned long )((void *)0)) {
#line 280
      if (! ((unsigned long )outNumBits != (unsigned long )((void *)0))) {
#line 280
        return (-50);
      }
    } else {
#line 280
      return (-50);
    }
  } else {
#line 280
    return (-50);
  }
#line 281
  *outNumBits = (uint32_t )0;
#line 283
  in = bitstream->cur;
#line 284
  startPos = bitstream->bitIndex;
#line 285
  maxPos = bitstream->byteSize * 8U;
#line 286
  bitPos = startPos;
#line 288
  mb = params->mb0;
#line 289
  zmode = 0;
#line 291
  c = (uint32_t )0;
#line 292
  status = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;

#line 294
    if (! (c < (uint32_t )numSamples)) {
#line 294
      goto while_break;
    }
#line 297
    if (! (bitPos < maxPos)) {
#line 297
      status = -50;
#line 297
      goto Exit;
    }
    {
#line 299
    m = mb >> 9;
#line 300
    __cil_tmp25 = lg3a((int32_t )m);
#line 300
    k = (uint32_t )__cil_tmp25;
    }
#line 302
    if (k < kb_local) {
#line 302
      tmp = k;
    } else {
#line 302
      tmp = kb_local;
    }
    {
#line 302
    k = tmp;
#line 303
    m = (uint32_t )((1 << k) - 1);
#line 305
    __cil_tmp27 = dyn_get_32bit(in, & bitPos, (int32_t )m, (int32_t )k, maxSize);
#line 305
    n = (uint32_t )__cil_tmp27;
#line 309
    ndecode = n + (unsigned int )zmode;
#line 310
    multiplier = - ((int )(ndecode & 1U));
#line 312
    multiplier |= 1;
#line 313
    del = (int32_t )(((ndecode + 1U) >> 1) * (unsigned int )multiplier);
#line 316
    __cil_tmp30 = outPtr;
#line 316
    outPtr ++;
#line 316
    *__cil_tmp30 = del;
#line 318
    c ++;
#line 320
    mb = (pb_local * (n + (unsigned int )zmode) + mb) - (pb_local * mb >> 9);
    }
#line 323
    if (n > 65535U) {
#line 324
      mb = (uint32_t )65535;
    }
#line 326
    zmode = 0;
#line 328
    if (mb << 2 < (unsigned int )(1 << 9)) {
#line 328
      if (c < (uint32_t )numSamples) {
        {
#line 330
        zmode = 1;
#line 331
        __cil_tmp32 = lead((int32_t )mb);
#line 331
        k = (unsigned int )(__cil_tmp32 - 24) + ((mb + (unsigned int )(1 << 4)) >> 6);
#line 332
        mz = (unsigned int )((1 << k) - 1) & wb_local;
#line 334
        __cil_tmp33 = dyn_get(in, & bitPos, mz, k);
#line 334
        n = (uint32_t )__cil_tmp33;
        }
#line 336
        if (! (c + n <= (uint32_t )numSamples)) {
#line 336
          status = -50;
#line 336
          goto Exit;
        }
#line 338
        j = (uint32_t )0;
        {
#line 338
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 338
          if (! (j < n)) {
#line 338
            goto while_break___0;
          }
#line 340
          __cil_tmp34 = outPtr;
#line 340
          outPtr ++;
#line 340
          *__cil_tmp34 = 0;
#line 341
          c ++;
#line 338
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
#line 344
        if (n >= 65535U) {
#line 345
          zmode = 0;
        }
#line 347
        mb = (uint32_t )0;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  Exit: 
  {
#line 352
  *outNumBits = bitPos - startPos;
#line 353
  BitBufferAdvance(bitstream, *outNumBits);
  }
#line 354
  if (! ((unsigned long )bitstream->cur <= (unsigned long )bitstream->end)) {
#line 354
    status = -50;
  }
#line 356
  return (status);
}
}
#line 34 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
void BitBufferInit(BitBuffer *bits , uint8_t *buffer , uint32_t byteSize ) 
{ 


  {
#line 36
  bits->cur = buffer;
#line 37
  bits->end = bits->cur + byteSize;
#line 38
  bits->bitIndex = (uint32_t )0;
#line 39
  bits->byteSize = byteSize;
#line 40
  return;
}
}
#line 44 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
uint32_t BitBufferRead(BitBuffer *bits , uint8_t numBits ) 
{ 
  uint32_t returnBits ;

  {
#line 50
  returnBits = (((uint32_t )*(bits->cur + 0) << 16) | ((uint32_t )*(bits->cur + 1) << 8)) | (uint32_t )*(bits->cur + 2);
#line 51
  returnBits <<= bits->bitIndex;
#line 52
  returnBits &= 16777215U;
#line 54
  bits->bitIndex += (unsigned int )numBits;
#line 56
  returnBits >>= 24 - (int )numBits;
#line 58
  bits->cur += bits->bitIndex >> 3;
#line 59
  bits->bitIndex &= 7U;
#line 63
  return (returnBits);
}
}
#line 69 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
uint8_t BitBufferReadSmall(BitBuffer *bits , uint8_t numBits ) 
{ 
  uint16_t returnBits ;

  {
#line 75
  returnBits = (uint16_t )(((int )*(bits->cur + 0) << 8) | (int )*(bits->cur + 1));
#line 76
  returnBits = (uint16_t )((int )returnBits << bits->bitIndex);
#line 78
  bits->bitIndex += (unsigned int )numBits;
#line 80
  returnBits = (uint16_t )((int )returnBits >> (16 - (int )numBits));
#line 82
  bits->cur += bits->bitIndex >> 3;
#line 83
  bits->bitIndex &= 7U;
#line 87
  return ((uint8_t )returnBits);
}
}
#line 93 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
uint8_t BitBufferReadOne(BitBuffer *bits ) 
{ 
  uint8_t returnBits ;

  {
#line 97
  returnBits = (uint8_t )(((int )*(bits->cur + 0) >> (7U - bits->bitIndex)) & 1);
#line 99
  (bits->bitIndex) ++;
#line 101
  bits->cur += bits->bitIndex >> 3;
#line 102
  bits->bitIndex &= 7U;
#line 106
  return (returnBits);
}
}
#line 111 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
uint32_t BitBufferPeek(BitBuffer *bits , uint8_t numBits ) 
{ 


  {
#line 113
  return (((((((uint32_t )*(bits->cur + 0) << 16) | ((uint32_t )*(bits->cur + 1) << 8)) | (uint32_t )*(bits->cur + 2)) << bits->bitIndex) & 16777215U) >> (24 - (int )numBits));
}
}
#line 119 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
uint32_t BitBufferPeekOne(BitBuffer *bits ) 
{ 


  {
#line 121
  return ((uint32_t )(((int )*(bits->cur + 0) >> (7U - bits->bitIndex)) & 1));
}
}
#line 126 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
uint32_t BitBufferUnpackBERSize(BitBuffer *bits ) 
{ 
  uint32_t size ;
  uint8_t tmp ;
  uint8_t __cil_tmp4 ;

  {
#line 131
  tmp = (uint8_t )128U;
#line 131
  size = (uint32_t )0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;

#line 131
    if (! tmp) {
#line 131
      goto while_break;
    }
    {
#line 132
    __cil_tmp4 = BitBufferReadSmall(bits, (uint8_t )8);
#line 132
    tmp = __cil_tmp4;
#line 131
    size = (size << 7U) | ((unsigned int )tmp & 127U);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 134
  return (size);
}
}
#line 139 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
uint32_t BitBufferGetPosition(BitBuffer *bits ) 
{ 
  uint8_t *begin ;

  {
#line 143
  begin = bits->end - bits->byteSize;
#line 145
  return ((uint32_t )(bits->cur - begin) * 8U + bits->bitIndex);
}
}
#line 150 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
void BitBufferByteAlign(BitBuffer *bits , int32_t addZeros ) 
{ 


  {
#line 153
  if (bits->bitIndex == 0U) {
#line 154
    return;
  }
#line 156
  if (addZeros) {
    {
#line 157
    BitBufferWrite(bits, (uint32_t )0, 8U - bits->bitIndex);
    }
  } else {
    {
#line 159
    BitBufferAdvance(bits, 8U - bits->bitIndex);
    }
  }
#line 162
  return;
}
}
#line 164 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
void BitBufferAdvance(BitBuffer *bits , uint32_t numBits ) 
{ 


  {
#line 166
  if (numBits) {
#line 168
    bits->bitIndex += numBits;
#line 169
    bits->cur += bits->bitIndex >> 3;
#line 170
    bits->bitIndex &= 7U;
  }
#line 172
  return;
}
}
#line 176 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
void BitBufferRewind(BitBuffer *bits , uint32_t numBits ) 
{ 
  uint32_t numBytes ;
  uint8_t *__cil_tmp4 ;

  {
#line 180
  if (numBits == 0U) {
#line 181
    return;
  }
#line 183
  if (bits->bitIndex >= numBits) {
#line 185
    bits->bitIndex -= numBits;
#line 186
    return;
  }
#line 189
  numBits -= bits->bitIndex;
#line 190
  bits->bitIndex = (uint32_t )0;
#line 192
  numBytes = numBits / 8U;
#line 193
  numBits %= 8U;
#line 195
  bits->cur -= numBytes;
#line 197
  if (numBits > 0U) {
#line 199
    bits->bitIndex = 8U - numBits;
#line 200
    __cil_tmp4 = bits->cur;
#line 200
    (bits->cur) --;
  }
#line 203
  if ((unsigned long )bits->cur < (unsigned long )(bits->end - bits->byteSize)) {
#line 207
    bits->cur = bits->end - bits->byteSize;
#line 208
    bits->bitIndex = (uint32_t )0;
  }
#line 210
  return;
}
}
#line 214 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
void BitBufferWrite(BitBuffer *bits , uint32_t bitValues , uint32_t numBits ) 
{ 
  uint32_t invBitIndex ;
  uint32_t tmp ;
  uint8_t shift ;
  uint8_t mask ;
  uint32_t curNum ;
  uint32_t tmp___8 ;

  {
#line 218
  if (! ((unsigned long )bits != (unsigned long )((void *)0))) {
#line 218
    return;
  }
#line 219
  if (! (numBits > 0U)) {
#line 219
    return;
  }
#line 221
  invBitIndex = 8U - bits->bitIndex;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;

#line 223
    if (! (numBits > 0U)) {
#line 223
      goto while_break;
    }
#line 230
    if (invBitIndex < numBits) {
#line 230
      tmp___8 = invBitIndex;
    } else {
#line 230
      tmp___8 = numBits;
    }
#line 230
    curNum = tmp___8;
#line 232
    tmp = bitValues >> (numBits - curNum);
#line 234
    shift = (uint8_t )(invBitIndex - curNum);
#line 235
    mask = (uint8_t )(255U >> (8U - curNum));
#line 236
    mask = (uint8_t )((int )mask << (int )shift);
#line 238
    *(bits->cur + 0) = (uint8_t )(((int )*(bits->cur + 0) & ~ ((int )mask)) | (((int )((uint8_t )tmp) << (int )shift) & (int )mask));
#line 239
    numBits -= curNum;
#line 242
    invBitIndex -= curNum;
#line 243
    if (invBitIndex == 0U) {
#line 245
      invBitIndex = (uint32_t )8;
#line 246
      (bits->cur) ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 250
  bits->bitIndex = 8U - invBitIndex;
#line 251
  return;
}
}
#line 253 "/root/patchweave_donee/23/src/ALAC/ALACBitUtilities.c"
void BitBufferReset(BitBuffer *bits ) 
{ 


  {
#line 256
  bits->cur = bits->end - bits->byteSize;
#line 257
  bits->bitIndex = (uint32_t )0;
#line 258
  return;
}
}
#line 68 "/root/patchweave_donee/23/src/G72x/g72x.h"
struct g72x_state *g72x_reader_init(int codec , int *blocksize , int *samplesperblock ) ;
#line 69
struct g72x_state *g72x_writer_init(int codec , int *blocksize , int *samplesperblock ) ;
#line 75
int g72x_decode_block(G72x_STATE *pstate , unsigned char const   *block , short *samples ) ;
#line 83
int g72x_encode_block(G72x_STATE *pstate , short *samples , unsigned char *block ) ;
#line 83 "/root/patchweave_donee/23/src/G72x/g72x_priv.h"
int predictor_zero(G72x_STATE *state_ptr ) ;
#line 85
int predictor_pole(G72x_STATE *state_ptr ) ;
#line 87
int step_size(G72x_STATE *state_ptr ) ;
#line 89
int quantize(int d , int y , short *table , int size ) ;
#line 91
int reconstruct(int sign , int dqln , int y ) ;
#line 93
void update(int code_size , int y , int wi , int fi , int dq , int sr , int dqsez ,
            G72x_STATE *state_ptr ) ;
#line 95
int g721_encoder(int sl , G72x_STATE *state_ptr ) ;
#line 96
int g721_decoder(int i , G72x_STATE *state_ptr ) ;
#line 98
int g723_16_encoder(int sl , G72x_STATE *state_ptr ) ;
#line 99
int g723_16_decoder(int i , G72x_STATE *state_ptr ) ;
#line 101
int g723_24_encoder(int sl , G72x_STATE *state_ptr ) ;
#line 102
int g723_24_decoder(int i , G72x_STATE *state_ptr ) ;
#line 104
int g723_40_encoder(int sl , G72x_STATE *state_ptr ) ;
#line 105
int g723_40_decoder(int i , G72x_STATE *state_ptr ) ;
#line 107
void private_init_state(G72x_STATE *state_ptr ) ;
#line 116 "/root/patchweave_donee/23/src/G72x/g72x_priv.h"
__inline static int arith_shift_left___29(int x , int shift ) 
{ 


  {
#line 117
  return ((int )((unsigned int )x << shift));
}
}
#line 40 "/root/patchweave_donee/23/src/G72x/g72x.c"
static G72x_STATE *g72x_state_new(void) ;
#line 41
static int unpack_bytes(int bits , int blocksize , unsigned char const   *block ,
                        short *samples ) ;
#line 42
static int pack_bytes(int bits , short const   *samples , unsigned char *block ) ;
#line 45 "/root/patchweave_donee/23/src/G72x/g72x.c"
static short power2[15]  = 
#line 45
  {      (short)1,      (short)2,      (short)4,      (short)8, 
        (short)16,      (short)32,      (short)64,      (short)128, 
        (short)256,      (short)512,      (short)1024,      (short)2048, 
        (short)4096,      (short)8192,      (short)16384};
#line 59 "/root/patchweave_donee/23/src/G72x/g72x.c"
static int quan(int val , short *table , int size ) 
{ 
  int i ;
  short *__cil_tmp5 ;

  {
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;

#line 63
    if (! (i < size)) {
#line 63
      goto while_break;
    }
#line 64
    __cil_tmp5 = table;
#line 64
    table ++;
#line 64
    if (val < (int )*__cil_tmp5) {
#line 65
      goto while_break;
    }
#line 63
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 66
  return (i);
}
}
#line 76 "/root/patchweave_donee/23/src/G72x/g72x.c"
static int fmult(int an , int srn ) 
{ 
  short anmag ;
  short anexp ;
  short anmant ;
  short wanexp ;
  short wanmant ;
  short retval ;
  int tmp ;
  int __cil_tmp10 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 82
  if (an > 0) {
#line 82
    tmp = an;
  } else {
#line 82
    tmp = - an & 8191;
  }
  {
#line 82
  anmag = (short )tmp;
#line 83
  __cil_tmp10 = quan((int )anmag, power2, 15);
#line 83
  anexp = (short )(__cil_tmp10 - 6);
  }
#line 84
  if ((int )anmag == 0) {
#line 84
    tmp___1 = 32;
  } else {
#line 84
    if ((int )anexp >= 0) {
#line 84
      tmp___0 = (int )anmag >> (int )anexp;
    } else {
#line 84
      tmp___0 = (int )anmag << - ((int )anexp);
    }
#line 84
    tmp___1 = tmp___0;
  }
#line 84
  anmant = (short )tmp___1;
#line 86
  wanexp = (short )(((int )anexp + ((srn >> 6) & 15)) - 13);
#line 95
  wanmant = (short )((int )anmant * (srn & 63) >> 4);
#line 97
  if ((int )wanexp >= 0) {
#line 97
    tmp___2 = ((int )wanmant << (int )wanexp) & 32767;
  } else {
#line 97
    tmp___2 = (int )wanmant >> - ((int )wanexp);
  }
#line 97
  retval = (short )tmp___2;
#line 99
  if ((an ^ srn) < 0) {
#line 99
    tmp___3 = - ((int )retval);
  } else {
#line 99
    tmp___3 = (int )retval;
  }
#line 99
  return (tmp___3);
}
}
#line 102 "/root/patchweave_donee/23/src/G72x/g72x.c"
static G72x_STATE *g72x_state_new(void) 
{ 
  void *__cil_tmp1 ;

  {
  {
#line 103
  __cil_tmp1 = calloc(1UL, sizeof(G72x_STATE ));
  }
#line 103
  return ((G72x_STATE *)__cil_tmp1);
}
}
#line 113 "/root/patchweave_donee/23/src/G72x/g72x.c"
void private_init_state(G72x_STATE *state_ptr ) 
{ 
  int cnta ;

  {
#line 117
  state_ptr->yl = 34816L;
#line 118
  state_ptr->yu = (short)544;
#line 119
  state_ptr->dms = (short)0;
#line 120
  state_ptr->dml = (short)0;
#line 121
  state_ptr->ap = (short)0;
#line 122
  cnta = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;

#line 122
    if (! (cnta < 2)) {
#line 122
      goto while_break;
    }
#line 123
    state_ptr->a[cnta] = (short)0;
#line 124
    state_ptr->pk[cnta] = (short)0;
#line 125
    state_ptr->sr[cnta] = (short)32;
#line 122
    cnta ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 127
  cnta = 0;
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 127
    if (! (cnta < 6)) {
#line 127
      goto while_break___0;
    }
#line 128
    state_ptr->b[cnta] = (short)0;
#line 129
    state_ptr->dq[cnta] = (short)32;
#line 127
    cnta ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 131
  state_ptr->td = (char)0;
#line 132
  return;
}
}
#line 134 "/root/patchweave_donee/23/src/G72x/g72x.c"
struct g72x_state *g72x_reader_init(int codec , int *blocksize , int *samplesperblock ) 
{ 
  G72x_STATE *pstate ;

  {
  {
#line 137
  pstate = g72x_state_new();
  }
#line 137
  if ((unsigned long )pstate == (unsigned long )((void *)0)) {
#line 138
    return ((struct g72x_state *)((void *)0));
  }
  {
#line 140
  private_init_state(pstate);
#line 142
  pstate->encoder = (int (*)(int  , struct g72x_state * ))((void *)0);
  }
#line 145
  if (codec == 2) {
#line 145
    goto case_2;
  }
#line 154
  if (codec == 3) {
#line 154
    goto case_3;
  }
#line 163
  if (codec == 4) {
#line 163
    goto case_4;
  }
#line 172
  if (codec == 5) {
#line 172
    goto case_5;
  }
#line 181
  goto switch_default;
  case_2: 
#line 146
  pstate->decoder = & g723_16_decoder;
#line 147
  *blocksize = 30;
#line 148
  *samplesperblock = 120;
#line 149
  pstate->codec_bits = 2;
#line 150
  pstate->blocksize = 30;
#line 151
  pstate->samplesperblock = 120;
#line 152
  goto switch_break;
  case_3: 
#line 155
  pstate->decoder = & g723_24_decoder;
#line 156
  *blocksize = 45;
#line 157
  *samplesperblock = 120;
#line 158
  pstate->codec_bits = 3;
#line 159
  pstate->blocksize = 45;
#line 160
  pstate->samplesperblock = 120;
#line 161
  goto switch_break;
  case_4: 
#line 164
  pstate->decoder = & g721_decoder;
#line 165
  *blocksize = 60;
#line 166
  *samplesperblock = 120;
#line 167
  pstate->codec_bits = 4;
#line 168
  pstate->blocksize = 60;
#line 169
  pstate->samplesperblock = 120;
#line 170
  goto switch_break;
  case_5: 
#line 173
  pstate->decoder = & g723_40_decoder;
#line 174
  *blocksize = 75;
#line 175
  *samplesperblock = 120;
#line 176
  pstate->codec_bits = 5;
#line 177
  pstate->blocksize = 75;
#line 178
  pstate->samplesperblock = 120;
#line 179
  goto switch_break;
  switch_default: 
  {
#line 182
  free((void *)pstate);
  }
#line 183
  return ((struct g72x_state *)((void *)0));
  switch_break: ;
#line 186
  return (pstate);
}
}
#line 189 "/root/patchweave_donee/23/src/G72x/g72x.c"
struct g72x_state *g72x_writer_init(int codec , int *blocksize , int *samplesperblock ) 
{ 
  G72x_STATE *pstate ;

  {
  {
#line 192
  pstate = g72x_state_new();
  }
#line 192
  if ((unsigned long )pstate == (unsigned long )((void *)0)) {
#line 193
    return ((struct g72x_state *)((void *)0));
  }
  {
#line 195
  private_init_state(pstate);
#line 196
  pstate->decoder = (int (*)(int  , struct g72x_state * ))((void *)0);
  }
#line 199
  if (codec == 2) {
#line 199
    goto case_2;
  }
#line 208
  if (codec == 3) {
#line 208
    goto case_3;
  }
#line 217
  if (codec == 4) {
#line 217
    goto case_4;
  }
#line 226
  if (codec == 5) {
#line 226
    goto case_5;
  }
#line 235
  goto switch_default;
  case_2: 
#line 200
  pstate->encoder = & g723_16_encoder;
#line 201
  *blocksize = 30;
#line 202
  *samplesperblock = 120;
#line 203
  pstate->codec_bits = 2;
#line 204
  pstate->blocksize = 30;
#line 205
  pstate->samplesperblock = 120;
#line 206
  goto switch_break;
  case_3: 
#line 209
  pstate->encoder = & g723_24_encoder;
#line 210
  *blocksize = 45;
#line 211
  *samplesperblock = 120;
#line 212
  pstate->codec_bits = 3;
#line 213
  pstate->blocksize = 45;
#line 214
  pstate->samplesperblock = 120;
#line 215
  goto switch_break;
  case_4: 
#line 218
  pstate->encoder = & g721_encoder;
#line 219
  *blocksize = 60;
#line 220
  *samplesperblock = 120;
#line 221
  pstate->codec_bits = 4;
#line 222
  pstate->blocksize = 60;
#line 223
  pstate->samplesperblock = 120;
#line 224
  goto switch_break;
  case_5: 
#line 227
  pstate->encoder = & g723_40_encoder;
#line 228
  *blocksize = 75;
#line 229
  *samplesperblock = 120;
#line 230
  pstate->codec_bits = 5;
#line 231
  pstate->blocksize = 75;
#line 232
  pstate->samplesperblock = 120;
#line 233
  goto switch_break;
  switch_default: 
  {
#line 236
  free((void *)pstate);
  }
#line 237
  return ((struct g72x_state *)((void *)0));
  switch_break: ;
#line 240
  return (pstate);
}
}
#line 243 "/root/patchweave_donee/23/src/G72x/g72x.c"
int g72x_decode_block(G72x_STATE *pstate , unsigned char const   *block , short *samples ) 
{ 
  int k ;
  int count___0 ;
  int __cil_tmp7 ;

  {
  {
#line 246
  count___0 = unpack_bytes(pstate->codec_bits, pstate->blocksize, block, samples);
#line 248
  k = 0;
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;

#line 248
    if (! (k < count___0)) {
#line 248
      goto while_break;
    }
    {
#line 249
    __cil_tmp7 = (*(pstate->decoder))((int )*(samples + k), pstate);
#line 249
    *(samples + k) = (short )__cil_tmp7;
#line 248
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 251
  return (0);
}
}
#line 254 "/root/patchweave_donee/23/src/G72x/g72x.c"
int g72x_encode_block(G72x_STATE *pstate , short *samples , unsigned char *block ) 
{ 
  int k ;
  int count___0 ;
  int __cil_tmp6 ;

  {
#line 257
  k = 0;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;

#line 257
    if (! (k < pstate->samplesperblock)) {
#line 257
      goto while_break;
    }
    {
#line 258
    __cil_tmp6 = (*(pstate->encoder))((int )*(samples + k), pstate);
#line 258
    *(samples + k) = (short )__cil_tmp6;
#line 257
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 260
  count___0 = pack_bytes(pstate->codec_bits, (short const   *)samples, block);
  }
#line 262
  return (count___0);
}
}
#line 271 "/root/patchweave_donee/23/src/G72x/g72x.c"
int predictor_zero(G72x_STATE *state_ptr ) 
{ 
  int i ;
  int sezi ;
  int __cil_tmp5 ;

  {
  {
#line 276
  sezi = fmult((int )state_ptr->b[0] >> 2, (int )state_ptr->dq[0]);
#line 277
  i = 1;
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;

#line 277
    if (! (i < 6)) {
#line 277
      goto while_break;
    }
    {
#line 278
    __cil_tmp5 = fmult((int )state_ptr->b[i] >> 2, (int )state_ptr->dq[i]);
#line 278
    sezi += __cil_tmp5;
#line 277
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 279
  return (sezi);
}
}
#line 287 "/root/patchweave_donee/23/src/G72x/g72x.c"
int predictor_pole(G72x_STATE *state_ptr ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 289
  __cil_tmp3 = fmult((int )state_ptr->a[0] >> 2, (int )state_ptr->sr[0]);
#line 289
  __cil_tmp2 = fmult((int )state_ptr->a[1] >> 2, (int )state_ptr->sr[1]);
  }
#line 289
  return (__cil_tmp2 + __cil_tmp3);
}
}
#line 298 "/root/patchweave_donee/23/src/G72x/g72x.c"
int step_size(G72x_STATE *state_ptr ) 
{ 
  int y ;
  int dif ;
  int al ;

  {
#line 304
  if ((int )state_ptr->ap >= 256) {
#line 305
    return ((int )state_ptr->yu);
  } else {
#line 307
    y = (int )(state_ptr->yl >> 6);
#line 308
    dif = (int )state_ptr->yu - y;
#line 309
    al = (int )state_ptr->ap >> 2;
#line 310
    if (dif > 0) {
#line 311
      y += dif * al >> 6;
    } else
#line 312
    if (dif < 0) {
#line 313
      y += (dif * al + 63) >> 6;
    }
#line 314
    return (y);
  }
}
}
#line 327 "/root/patchweave_donee/23/src/G72x/g72x.c"
int quantize(int d , int y , short *table , int size ) 
{ 
  short dqm ;
  short expon ;
  short mant ;
  short dl ;
  short dln ;
  int i ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 345
  __cil_tmp11 = abs(d);
#line 345
  dqm = (short )__cil_tmp11;
#line 346
  __cil_tmp12 = quan((int )dqm >> 1, power2, 15);
#line 346
  expon = (short )__cil_tmp12;
#line 347
  mant = (short )((((int )dqm << 7) >> (int )expon) & 127);
#line 348
  dl = (short )(((int )expon << 7) + (int )mant);
#line 355
  dln = (short )((int )dl - (y >> 2));
#line 362
  i = quan((int )dln, table, size);
  }
#line 363
  if (d < 0) {
#line 364
    return (((size << 1) + 1) - i);
  } else
#line 365
  if (i == 0) {
#line 366
    return ((size << 1) + 1);
  }
#line 368
  return (i);
}
}
#line 378 "/root/patchweave_donee/23/src/G72x/g72x.c"
int reconstruct(int sign , int dqln , int y ) 
{ 
  short dql ;
  short dex ;
  short dqt ;
  short dq ;
  int tmp ;
  int tmp___0 ;

  {
#line 388
  dql = (short )(dqln + (y >> 2));
#line 390
  if ((int )dql < 0) {
#line 391
    if (sign) {
#line 391
      tmp = -32768;
    } else {
#line 391
      tmp = 0;
    }
#line 391
    return (tmp);
  } else {
#line 393
    dex = (short )(((int )dql >> 7) & 15);
#line 394
    dqt = (short )(128 + ((int )dql & 127));
#line 395
    dq = (short )(((int )dqt << 7) >> (14 - (int )dex));
#line 396
    if (sign) {
#line 396
      tmp___0 = (int )dq - 32768;
    } else {
#line 396
      tmp___0 = (int )dq;
    }
#line 396
    return (tmp___0);
  }
}
}
#line 407 "/root/patchweave_donee/23/src/G72x/g72x.c"
void update(int code_size , int y , int wi , int fi , int dq , int sr , int dqsez ,
            G72x_STATE *state_ptr ) 
{ 
  int cnt ;
  short mag ;
  short expon ;
  short a2p ;
  short a1ul ;
  short pks1 ;
  short fa1 ;
  char tr ;
  short ylint ;
  short thr2 ;
  short dqthr ;
  short ylfrac ;
  short thr1 ;
  short pk0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp27 ;
  int tmp___2 ;
  int __cil_tmp29 ;
  int tmp___3 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;

  {
#line 419
  a2p = (short)0;
#line 428
  if (dqsez < 0) {
#line 428
    tmp = 1;
  } else {
#line 428
    tmp = 0;
  }
#line 428
  pk0 = (short )tmp;
#line 430
  mag = (short )(dq & 32767);
#line 432
  ylint = (short )(state_ptr->yl >> 15);
#line 433
  ylfrac = (short )((state_ptr->yl >> 10) & 31L);
#line 434
  thr1 = (short )((32 + (int )ylfrac) << (int )ylint);
#line 435
  if ((int )ylint > 9) {
#line 435
    tmp___0 = 31 << 10;
  } else {
#line 435
    tmp___0 = (int )thr1;
  }
#line 435
  thr2 = (short )tmp___0;
#line 436
  dqthr = (short )(((int )thr2 + ((int )thr2 >> 1)) >> 1);
#line 437
  if ((int )state_ptr->td == 0) {
#line 438
    tr = (char)0;
  } else
#line 439
  if ((int )mag <= (int )dqthr) {
#line 440
    tr = (char)0;
  } else {
#line 442
    tr = (char)1;
  }
#line 450
  state_ptr->yu = (short )(y + ((wi - y) >> 5));
#line 453
  if ((int )state_ptr->yu < 544) {
#line 454
    state_ptr->yu = (short)544;
  } else
#line 455
  if ((int )state_ptr->yu > 5120) {
#line 456
    state_ptr->yu = (short)5120;
  }
#line 460
  state_ptr->yl += (long )state_ptr->yu + (- state_ptr->yl >> 6);
#line 465
  if ((int )tr == 1) {
#line 466
    state_ptr->a[0] = (short)0;
#line 467
    state_ptr->a[1] = (short)0;
#line 468
    state_ptr->b[0] = (short)0;
#line 469
    state_ptr->b[1] = (short)0;
#line 470
    state_ptr->b[2] = (short)0;
#line 471
    state_ptr->b[3] = (short)0;
#line 472
    state_ptr->b[4] = (short)0;
#line 473
    state_ptr->b[5] = (short)0;
  } else {
#line 476
    pks1 = (short )((int )pk0 ^ (int )state_ptr->pk[0]);
#line 479
    a2p = (short )((int )state_ptr->a[1] - ((int )state_ptr->a[1] >> 7));
#line 480
    if (dqsez != 0) {
#line 481
      if ((int )pks1) {
#line 481
        tmp___1 = (int )state_ptr->a[0];
      } else {
#line 481
        tmp___1 = - ((int )state_ptr->a[0]);
      }
#line 481
      fa1 = (short )tmp___1;
#line 482
      if ((int )fa1 < -8191) {
#line 483
        a2p = (short )((int )a2p - 256);
      } else
#line 484
      if ((int )fa1 > 8191) {
#line 485
        a2p = (short )((int )a2p + 255);
      } else {
#line 487
        a2p = (short )((int )a2p + ((int )fa1 >> 5));
      }
#line 489
      if ((int )pk0 ^ (int )state_ptr->pk[1]) {
#line 491
        if ((int )a2p <= -12160) {
#line 492
          a2p = (short)-12288;
        } else
#line 493
        if ((int )a2p >= 12416) {
#line 494
          a2p = (short)12288;
        } else {
#line 496
          a2p = (short )((int )a2p - 128);
        }
      } else
#line 498
      if ((int )a2p <= -12416) {
#line 499
        a2p = (short)-12288;
      } else
#line 500
      if ((int )a2p >= 12160) {
#line 501
        a2p = (short)12288;
      } else {
#line 503
        a2p = (short )((int )a2p + 128);
      }
    }
#line 507
    state_ptr->a[1] = a2p;
#line 511
    state_ptr->a[0] = (short )((int )state_ptr->a[0] - ((int )state_ptr->a[0] >> 8));
#line 512
    if (dqsez != 0) {
#line 513
      if ((int )pks1 == 0) {
#line 514
        state_ptr->a[0] = (short )((int )state_ptr->a[0] + 192);
      } else {
#line 516
        state_ptr->a[0] = (short )((int )state_ptr->a[0] - 192);
      }
    }
#line 520
    a1ul = (short )(15360 - (int )a2p);
#line 521
    if ((int )state_ptr->a[0] < - ((int )a1ul)) {
#line 522
      state_ptr->a[0] = (short )(- ((int )a1ul));
    } else
#line 523
    if ((int )state_ptr->a[0] > (int )a1ul) {
#line 524
      state_ptr->a[0] = a1ul;
    }
#line 527
    cnt = 0;
    {
#line 527
    while (1) {
      while_continue: /* CIL Label */ ;

#line 527
      if (! (cnt < 6)) {
#line 527
        goto while_break;
      }
#line 528
      if (code_size == 5) {
#line 529
        state_ptr->b[cnt] = (short )((int )state_ptr->b[cnt] - ((int )state_ptr->b[cnt] >> 9));
      } else {
#line 531
        state_ptr->b[cnt] = (short )((int )state_ptr->b[cnt] - ((int )state_ptr->b[cnt] >> 8));
      }
#line 532
      if (dq & 32767) {
#line 533
        if ((dq ^ (int )state_ptr->dq[cnt]) >= 0) {
#line 534
          state_ptr->b[cnt] = (short )((int )state_ptr->b[cnt] + 128);
        } else {
#line 536
          state_ptr->b[cnt] = (short )((int )state_ptr->b[cnt] - 128);
        }
      }
#line 527
      cnt ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 541
  cnt = 5;
  {
#line 541
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 541
    if (! (cnt > 0)) {
#line 541
      goto while_break___0;
    }
#line 542
    state_ptr->dq[cnt] = state_ptr->dq[cnt - 1];
#line 541
    __cil_tmp27 = cnt;
#line 541
    cnt --;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 544
  if ((int )mag == 0) {
#line 545
    if (dq >= 0) {
#line 545
      tmp___2 = 32;
    } else {
#line 545
      tmp___2 = 64544;
    }
#line 545
    state_ptr->dq[0] = (short )tmp___2;
  } else {
    {
#line 547
    __cil_tmp29 = quan((int )mag, power2, 15);
#line 547
    expon = (short )__cil_tmp29;
    }
#line 548
    if (dq >= 0) {
#line 548
      tmp___3 = ((int )expon << 6) + (((int )mag << 6) >> (int )expon);
    } else {
#line 548
      tmp___3 = (((int )expon << 6) + (((int )mag << 6) >> (int )expon)) - 1024;
    }
#line 548
    state_ptr->dq[0] = (short )tmp___3;
  }
#line 553
  state_ptr->sr[1] = state_ptr->sr[0];
#line 555
  if (sr == 0) {
#line 556
    state_ptr->sr[0] = (short)32;
  } else
#line 557
  if (sr > 0) {
    {
#line 558
    __cil_tmp31 = quan(sr, power2, 15);
#line 558
    expon = (short )__cil_tmp31;
#line 559
    state_ptr->sr[0] = (short )(((int )expon << 6) + ((sr << 6) >> (int )expon));
    }
  } else
#line 561
  if (sr > -32768) {
    {
#line 562
    mag = (short )(- sr);
#line 563
    __cil_tmp32 = quan((int )mag, power2, 15);
#line 563
    expon = (short )__cil_tmp32;
#line 564
    state_ptr->sr[0] = (short )((((int )expon << 6) + (((int )mag << 6) >> (int )expon)) - 1024);
    }
  } else {
#line 567
    state_ptr->sr[0] = (short)-992;
  }
#line 570
  state_ptr->pk[1] = state_ptr->pk[0];
#line 571
  state_ptr->pk[0] = pk0;
#line 574
  if ((int )tr == 1) {
#line 575
    state_ptr->td = (char)0;
  } else
#line 576
  if ((int )a2p < -11776) {
#line 577
    state_ptr->td = (char)1;
  } else {
#line 579
    state_ptr->td = (char)0;
  }
#line 584
  state_ptr->dms = (short )((int )state_ptr->dms + ((fi - (int )state_ptr->dms) >> 5));
#line 585
  state_ptr->dml = (short )((int )state_ptr->dml + (((fi << 2) - (int )state_ptr->dml) >> 7));
#line 587
  if ((int )tr == 1) {
#line 588
    state_ptr->ap = (short)256;
  } else
#line 589
  if (y < 1536) {
#line 590
    state_ptr->ap = (short )((int )state_ptr->ap + ((512 - (int )state_ptr->ap) >> 4));
  } else
#line 591
  if ((int )state_ptr->td == 1) {
#line 592
    state_ptr->ap = (short )((int )state_ptr->ap + ((512 - (int )state_ptr->ap) >> 4));
  } else {
    {
#line 593
    __cil_tmp33 = abs(((int )state_ptr->dms << 2) - (int )state_ptr->dml);
    }
#line 593
    if (__cil_tmp33 >= (int )state_ptr->dml >> 3) {
#line 594
      state_ptr->ap = (short )((int )state_ptr->ap + ((512 - (int )state_ptr->ap) >> 4));
    } else {
#line 596
      state_ptr->ap = (short )((int )state_ptr->ap + (- ((int )state_ptr->ap) >> 4));
    }
  }
#line 598
  return;
}
}
#line 605 "/root/patchweave_donee/23/src/G72x/g72x.c"
static int unpack_bytes(int bits , int blocksize , unsigned char const   *block ,
                        short *samples ) 
{ 
  unsigned int in_buffer ;
  unsigned char in_byte ;
  int k ;
  int in_bits ;
  int bindex ;
  int __cil_tmp10 ;

  {
#line 606
  in_buffer = 0U;
#line 608
  in_bits = 0;
#line 608
  bindex = 0;
#line 610
  k = 0;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;

#line 610
    if (bindex <= blocksize) {
#line 610
      if (! (k < 120)) {
#line 610
        goto while_break;
      }
    } else {
#line 610
      goto while_break;
    }
#line 611
    if (in_bits < bits) {
#line 612
      __cil_tmp10 = bindex;
#line 612
      bindex ++;
#line 612
      in_byte = (unsigned char )*(block + __cil_tmp10);
#line 614
      in_buffer |= (unsigned int )((int )in_byte << in_bits);
#line 615
      in_bits += 8;
    }
#line 617
    *(samples + k) = (short )(in_buffer & (unsigned int )((1 << bits) - 1));
#line 618
    in_buffer >>= bits;
#line 619
    in_bits -= bits;
#line 610
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 622
  return (k);
}
}
#line 626 "/root/patchweave_donee/23/src/G72x/g72x.c"
static int pack_bytes(int bits , short const   *samples , unsigned char *block ) 
{ 
  unsigned int out_buffer ;
  int k ;
  int bindex ;
  int out_bits ;
  unsigned char out_byte ;
  int __cil_tmp9 ;

  {
#line 628
  out_buffer = 0U;
#line 629
  bindex = 0;
#line 629
  out_bits = 0;
#line 632
  k = 0;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;

#line 632
    if (! (k < 120)) {
#line 632
      goto while_break;
    }
#line 633
    out_buffer |= (unsigned int )((int )*(samples + k) << out_bits);
#line 634
    out_bits += bits;
#line 635
    if (out_bits >= 8) {
#line 636
      out_byte = (unsigned char )(out_buffer & 255U);
#line 637
      out_bits -= 8;
#line 638
      out_buffer >>= 8;
#line 639
      __cil_tmp9 = bindex;
#line 639
      bindex ++;
#line 639
      *(block + __cil_tmp9) = out_byte;
    }
#line 632
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 643
  return (bindex);
}
}
#line 56 "/root/patchweave_donee/23/src/G72x/g723_40.c"
static short _dqlntab[32]  = 
#line 56 "/root/patchweave_donee/23/src/G72x/g723_40.c"
  {      (short)-2048,      (short)-66,      (short)28,      (short)104, 
        (short)169,      (short)224,      (short)274,      (short)318, 
        (short)358,      (short)395,      (short)429,      (short)459, 
        (short)488,      (short)514,      (short)539,      (short)566, 
        (short)566,      (short)539,      (short)514,      (short)488, 
        (short)459,      (short)429,      (short)395,      (short)358, 
        (short)318,      (short)274,      (short)224,      (short)169, 
        (short)104,      (short)28,      (short)-66,      (short)-2048};
#line 62 "/root/patchweave_donee/23/src/G72x/g723_40.c"
static short _witab[32]  = 
#line 62
  {      (short)448,      (short)448,      (short)768,      (short)1248, 
        (short)1280,      (short)1312,      (short)1856,      (short)3200, 
        (short)4512,      (short)5728,      (short)7008,      (short)8960, 
        (short)11456,      (short)14080,      (short)16928,      (short)22272, 
        (short)22272,      (short)16928,      (short)14080,      (short)11456, 
        (short)8960,      (short)7008,      (short)5728,      (short)4512, 
        (short)3200,      (short)1856,      (short)1312,      (short)1280, 
        (short)1248,      (short)768,      (short)448,      (short)448};
#line 72 "/root/patchweave_donee/23/src/G72x/g723_40.c"
static short _fitab[32]  = 
#line 72
  {      (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)512,      (short)512,      (short)512, 
        (short)512,      (short)512,      (short)1024,      (short)1536, 
        (short)2048,      (short)2560,      (short)3072,      (short)3072, 
        (short)3072,      (short)3072,      (short)2560,      (short)2048, 
        (short)1536,      (short)1024,      (short)512,      (short)512, 
        (short)512,      (short)512,      (short)512,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0};
#line 77 "/root/patchweave_donee/23/src/G72x/g723_40.c"
static short qtab_723_40[15]  = 
#line 77
  {      (short)-122,      (short)-16,      (short)68,      (short)139, 
        (short)198,      (short)250,      (short)298,      (short)339, 
        (short)378,      (short)413,      (short)445,      (short)475, 
        (short)502,      (short)528,      (short)553};
#line 87 "/root/patchweave_donee/23/src/G72x/g723_40.c"
int g723_40_encoder(int sl , G72x_STATE *state_ptr ) 
{ 
  short sei ;
  short sezi ;
  short se ;
  short sez ;
  short d ;
  short y ;
  short sr ;
  short dqsez ;
  short dq ;
  short i ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;

  {
  {
#line 97
  sl >>= 2;
#line 99
  __cil_tmp13 = predictor_zero(state_ptr);
#line 99
  sezi = (short )__cil_tmp13;
#line 100
  sez = (short )((int )sezi >> 1);
#line 101
  __cil_tmp14 = predictor_pole(state_ptr);
#line 101
  sei = (short )((int )sezi + __cil_tmp14);
#line 102
  se = (short )((int )sei >> 1);
#line 104
  d = (short )(sl - (int )se);
#line 107
  __cil_tmp15 = step_size(state_ptr);
#line 107
  y = (short )__cil_tmp15;
#line 108
  __cil_tmp16 = quantize((int )d, (int )y, qtab_723_40, 15);
#line 108
  i = (short )__cil_tmp16;
#line 110
  __cil_tmp17 = reconstruct((int )i & 16, (int )_dqlntab[i], (int )y);
#line 110
  dq = (short )__cil_tmp17;
  }
#line 112
  if ((int )dq < 0) {
#line 112
    tmp = (int )se - ((int )dq & 32767);
  } else {
#line 112
    tmp = (int )se + (int )dq;
  }
  {
#line 112
  sr = (short )tmp;
#line 114
  dqsez = (short )(((int )sr + (int )sez) - (int )se);
#line 116
  update(5, (int )y, (int )_witab[i], (int )_fitab[i], (int )dq, (int )sr, (int )dqsez,
         state_ptr);
  }
#line 118
  return ((int )i);
}
}
#line 128 "/root/patchweave_donee/23/src/G72x/g723_40.c"
int g723_40_decoder(int i , G72x_STATE *state_ptr ) 
{ 
  short sezi ;
  short sei ;
  short sez ;
  short se ;
  short y ;
  short sr ;
  short dq ;
  short dqsez ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;

  {
  {
#line 136
  i &= 31;
#line 137
  __cil_tmp11 = predictor_zero(state_ptr);
#line 137
  sezi = (short )__cil_tmp11;
#line 138
  sez = (short )((int )sezi >> 1);
#line 139
  __cil_tmp12 = predictor_pole(state_ptr);
#line 139
  sei = (short )((int )sezi + __cil_tmp12);
#line 140
  se = (short )((int )sei >> 1);
#line 142
  __cil_tmp13 = step_size(state_ptr);
#line 142
  y = (short )__cil_tmp13;
#line 143
  __cil_tmp14 = reconstruct(i & 16, (int )_dqlntab[i], (int )y);
#line 143
  dq = (short )__cil_tmp14;
  }
#line 145
  if ((int )dq < 0) {
#line 145
    tmp = (int )se - ((int )dq & 32767);
  } else {
#line 145
    tmp = (int )se + (int )dq;
  }
  {
#line 145
  sr = (short )tmp;
#line 147
  dqsez = (short )(((int )sr - (int )se) + (int )sez);
#line 149
  update(5, (int )y, (int )_witab[i], (int )_fitab[i], (int )dq, (int )sr, (int )dqsez,
         state_ptr);
#line 151
  __cil_tmp16 = arith_shift_left___29((int )sr, 2);
  }
#line 151
  return (__cil_tmp16);
}
}
#line 48 "/root/patchweave_donee/23/src/G72x/g723_24.c"
static short _dqlntab___0[8]  = 
#line 48 "/root/patchweave_donee/23/src/G72x/g723_24.c"
  {      (short)-2048,      (short)135,      (short)273,      (short)373, 
        (short)373,      (short)273,      (short)135,      (short)-2048};
#line 51 "/root/patchweave_donee/23/src/G72x/g723_24.c"
static short _witab___0[8]  = 
#line 51
  {      (short)-128,      (short)960,      (short)4384,      (short)18624, 
        (short)18624,      (short)4384,      (short)960,      (short)-128};
#line 58 "/root/patchweave_donee/23/src/G72x/g723_24.c"
static short _fitab___0[8]  = 
#line 58
  {      (short)0,      (short)512,      (short)1024,      (short)3584, 
        (short)3584,      (short)1024,      (short)512,      (short)0};
#line 60 "/root/patchweave_donee/23/src/G72x/g723_24.c"
static short qtab_723_24[3]  = {      (short)8,      (short)218,      (short)331};
#line 69 "/root/patchweave_donee/23/src/G72x/g723_24.c"
int g723_24_encoder(int sl , G72x_STATE *state_ptr ) 
{ 
  short sei ;
  short sezi ;
  short se ;
  short sez ;
  short d ;
  short y ;
  short sr ;
  short dqsez ;
  short dq ;
  short i ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;

  {
  {
#line 81
  sl >>= 2;
#line 83
  __cil_tmp13 = predictor_zero(state_ptr);
#line 83
  sezi = (short )__cil_tmp13;
#line 84
  sez = (short )((int )sezi >> 1);
#line 85
  __cil_tmp14 = predictor_pole(state_ptr);
#line 85
  sei = (short )((int )sezi + __cil_tmp14);
#line 86
  se = (short )((int )sei >> 1);
#line 88
  d = (short )(sl - (int )se);
#line 91
  __cil_tmp15 = step_size(state_ptr);
#line 91
  y = (short )__cil_tmp15;
#line 92
  __cil_tmp16 = quantize((int )d, (int )y, qtab_723_24, 3);
#line 92
  i = (short )__cil_tmp16;
#line 93
  __cil_tmp17 = reconstruct((int )i & 4, (int )_dqlntab___0[i], (int )y);
#line 93
  dq = (short )__cil_tmp17;
  }
#line 95
  if ((int )dq < 0) {
#line 95
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 95
    tmp = (int )se + (int )dq;
  }
  {
#line 95
  sr = (short )tmp;
#line 97
  dqsez = (short )(((int )sr + (int )sez) - (int )se);
#line 99
  update(3, (int )y, (int )_witab___0[i], (int )_fitab___0[i], (int )dq, (int )sr,
         (int )dqsez, state_ptr);
  }
#line 101
  return ((int )i);
}
}
#line 112 "/root/patchweave_donee/23/src/G72x/g723_24.c"
int g723_24_decoder(int i , G72x_STATE *state_ptr ) 
{ 
  short sezi ;
  short sei ;
  short sez ;
  short se ;
  short y ;
  short sr ;
  short dq ;
  short dqsez ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;

  {
  {
#line 122
  i &= 7;
#line 123
  __cil_tmp11 = predictor_zero(state_ptr);
#line 123
  sezi = (short )__cil_tmp11;
#line 124
  sez = (short )((int )sezi >> 1);
#line 125
  __cil_tmp12 = predictor_pole(state_ptr);
#line 125
  sei = (short )((int )sezi + __cil_tmp12);
#line 126
  se = (short )((int )sei >> 1);
#line 128
  __cil_tmp13 = step_size(state_ptr);
#line 128
  y = (short )__cil_tmp13;
#line 129
  __cil_tmp14 = reconstruct(i & 4, (int )_dqlntab___0[i], (int )y);
#line 129
  dq = (short )__cil_tmp14;
  }
#line 131
  if ((int )dq < 0) {
#line 131
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 131
    tmp = (int )se + (int )dq;
  }
  {
#line 131
  sr = (short )tmp;
#line 133
  dqsez = (short )(((int )sr - (int )se) + (int )sez);
#line 135
  update(3, (int )y, (int )_witab___0[i], (int )_fitab___0[i], (int )dq, (int )sr,
         (int )dqsez, state_ptr);
#line 137
  __cil_tmp16 = arith_shift_left___29((int )sr, 2);
  }
#line 137
  return (__cil_tmp16);
}
}
#line 53 "/root/patchweave_donee/23/src/G72x/g723_16.c"
static short _dqlntab___1[4]  = {      (short)116,      (short)365,      (short)365,      (short)116};
#line 60 "/root/patchweave_donee/23/src/G72x/g723_16.c"
static short _witab___1[4]  = {      (short)-704,      (short)14048,      (short)14048,      (short)-704};
#line 69 "/root/patchweave_donee/23/src/G72x/g723_16.c"
static short _fitab___1[4]  = {      (short)0,      (short)3584,      (short)3584,      (short)0};
#line 73 "/root/patchweave_donee/23/src/G72x/g723_16.c"
static short qtab_723_16[1]  = {      (short)261};
#line 83 "/root/patchweave_donee/23/src/G72x/g723_16.c"
int g723_16_encoder(int sl , G72x_STATE *state_ptr ) 
{ 
  short sei ;
  short sezi ;
  short se ;
  short sez ;
  short d ;
  short y ;
  short sr ;
  short dqsez ;
  short dq ;
  short i ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;

  {
  {
#line 95
  sl >>= 2;
#line 97
  __cil_tmp13 = predictor_zero(state_ptr);
#line 97
  sezi = (short )__cil_tmp13;
#line 98
  sez = (short )((int )sezi >> 1);
#line 99
  __cil_tmp14 = predictor_pole(state_ptr);
#line 99
  sei = (short )((int )sezi + __cil_tmp14);
#line 100
  se = (short )((int )sei >> 1);
#line 102
  d = (short )(sl - (int )se);
#line 105
  __cil_tmp15 = step_size(state_ptr);
#line 105
  y = (short )__cil_tmp15;
#line 106
  __cil_tmp16 = quantize((int )d, (int )y, qtab_723_16, 1);
#line 106
  i = (short )__cil_tmp16;
  }
#line 111
  if ((int )i == 3) {
#line 112
    if (((int )d & 32768) == 0) {
#line 113
      i = (short)0;
    }
  }
  {
#line 115
  __cil_tmp17 = reconstruct((int )i & 2, (int )_dqlntab___1[i], (int )y);
#line 115
  dq = (short )__cil_tmp17;
  }
#line 117
  if ((int )dq < 0) {
#line 117
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 117
    tmp = (int )se + (int )dq;
  }
  {
#line 117
  sr = (short )tmp;
#line 119
  dqsez = (short )(((int )sr + (int )sez) - (int )se);
#line 121
  update(2, (int )y, (int )_witab___1[i], (int )_fitab___1[i], (int )dq, (int )sr,
         (int )dqsez, state_ptr);
  }
#line 123
  return ((int )i);
}
}
#line 134 "/root/patchweave_donee/23/src/G72x/g723_16.c"
int g723_16_decoder(int i , G72x_STATE *state_ptr ) 
{ 
  short sezi ;
  short sei ;
  short sez ;
  short se ;
  short y ;
  short sr ;
  short dq ;
  short dqsez ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;

  {
  {
#line 144
  i &= 3;
#line 145
  __cil_tmp11 = predictor_zero(state_ptr);
#line 145
  sezi = (short )__cil_tmp11;
#line 146
  sez = (short )((int )sezi >> 1);
#line 147
  __cil_tmp12 = predictor_pole(state_ptr);
#line 147
  sei = (short )((int )sezi + __cil_tmp12);
#line 148
  se = (short )((int )sei >> 1);
#line 150
  __cil_tmp13 = step_size(state_ptr);
#line 150
  y = (short )__cil_tmp13;
#line 151
  __cil_tmp14 = reconstruct(i & 2, (int )_dqlntab___1[i], (int )y);
#line 151
  dq = (short )__cil_tmp14;
  }
#line 153
  if ((int )dq < 0) {
#line 153
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 153
    tmp = (int )se + (int )dq;
  }
  {
#line 153
  sr = (short )tmp;
#line 155
  dqsez = (short )(((int )sr - (int )se) + (int )sez);
#line 157
  update(2, (int )y, (int )_witab___1[i], (int )_fitab___1[i], (int )dq, (int )sr,
         (int )dqsez, state_ptr);
  }
#line 160
  return ((int )sr << 2);
}
}
#line 55 "/root/patchweave_donee/23/src/G72x/g721.c"
static short qtab_721[7]  = {      (short)-124,      (short)80,      (short)178,      (short)246, 
        (short)300,      (short)349,      (short)400};
#line 60 "/root/patchweave_donee/23/src/G72x/g721.c"
static short _dqlntab___2[16]  = 
#line 60
  {      (short)-2048,      (short)4,      (short)135,      (short)213, 
        (short)273,      (short)323,      (short)373,      (short)425, 
        (short)425,      (short)373,      (short)323,      (short)273, 
        (short)213,      (short)135,      (short)4,      (short)-2048};
#line 64 "/root/patchweave_donee/23/src/G72x/g721.c"
static short _witab___2[16]  = 
#line 64
  {      (short)-12,      (short)18,      (short)41,      (short)64, 
        (short)112,      (short)198,      (short)355,      (short)1122, 
        (short)1122,      (short)355,      (short)198,      (short)112, 
        (short)64,      (short)41,      (short)18,      (short)-12};
#line 71 "/root/patchweave_donee/23/src/G72x/g721.c"
static short _fitab___2[16]  = 
#line 71
  {      (short)0,      (short)0,      (short)0,      (short)512, 
        (short)512,      (short)512,      (short)1536,      (short)3584, 
        (short)3584,      (short)1536,      (short)512,      (short)512, 
        (short)512,      (short)0,      (short)0,      (short)0};
#line 81 "/root/patchweave_donee/23/src/G72x/g721.c"
int g721_encoder(int sl , G72x_STATE *state_ptr ) 
{ 
  short sezi ;
  short se ;
  short sez ;
  short d ;
  short sr ;
  short y ;
  short dqsez ;
  short dq ;
  short i ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int __cil_tmp18 ;

  {
  {
#line 93
  sl >>= 2;
#line 95
  __cil_tmp12 = predictor_zero(state_ptr);
#line 95
  sezi = (short )__cil_tmp12;
#line 96
  sez = (short )((int )sezi >> 1);
#line 97
  __cil_tmp13 = predictor_pole(state_ptr);
#line 97
  se = (short )(((int )sezi + __cil_tmp13) >> 1);
#line 99
  d = (short )(sl - (int )se);
#line 102
  __cil_tmp14 = step_size(state_ptr);
#line 102
  y = (short )__cil_tmp14;
#line 103
  __cil_tmp15 = quantize((int )d, (int )y, qtab_721, 7);
#line 103
  i = (short )__cil_tmp15;
#line 105
  __cil_tmp16 = reconstruct((int )i & 8, (int )_dqlntab___2[i], (int )y);
#line 105
  dq = (short )__cil_tmp16;
  }
#line 107
  if ((int )dq < 0) {
#line 107
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 107
    tmp = (int )se + (int )dq;
  }
  {
#line 107
  sr = (short )tmp;
#line 109
  dqsez = (short )(((int )sr + (int )sez) - (int )se);
#line 111
  __cil_tmp18 = arith_shift_left___29((int )_witab___2[i], 5);
#line 111
  update(4, (int )y, __cil_tmp18, (int )_fitab___2[i], (int )dq, (int )sr, (int )dqsez,
         state_ptr);
  }
#line 113
  return ((int )i);
}
}
#line 126 "/root/patchweave_donee/23/src/G72x/g721.c"
int g721_decoder(int i , G72x_STATE *state_ptr ) 
{ 
  short sezi ;
  short sei ;
  short sez ;
  short se ;
  short y ;
  short sr ;
  short dq ;
  short dqsez ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 136
  i &= 15;
#line 137
  __cil_tmp11 = predictor_zero(state_ptr);
#line 137
  sezi = (short )__cil_tmp11;
#line 138
  sez = (short )((int )sezi >> 1);
#line 139
  __cil_tmp12 = predictor_pole(state_ptr);
#line 139
  sei = (short )((int )sezi + __cil_tmp12);
#line 140
  se = (short )((int )sei >> 1);
#line 142
  __cil_tmp13 = step_size(state_ptr);
#line 142
  y = (short )__cil_tmp13;
#line 144
  __cil_tmp14 = reconstruct(i & 8, (int )_dqlntab___2[i], (int )y);
#line 144
  dq = (short )__cil_tmp14;
  }
#line 146
  if ((int )dq < 0) {
#line 146
    tmp = (int )se - ((int )dq & 16383);
  } else {
#line 146
    tmp = (int )se + (int )dq;
  }
  {
#line 146
  sr = (short )tmp;
#line 148
  dqsez = (short )(((int )sr - (int )se) + (int )sez);
#line 150
  __cil_tmp16 = arith_shift_left___29((int )_witab___2[i], 5);
#line 150
  update(4, (int )y, __cil_tmp16, (int )_fitab___2[i], (int )dq, (int )sr, (int )dqsez,
         state_ptr);
#line 153
  __cil_tmp17 = arith_shift_left___29((int )sr, 2);
  }
#line 153
  return (__cil_tmp17);
}
}
#line 65 "/root/patchweave_donee/23/src/GSM610/gsm610_priv.h"
__inline static int16_t SASR_W(int16_t x , int16_t by ) 
{ 


  {
#line 66
  if ((int )x >= 0) {
#line 67
    return ((int16_t )((int )x >> (int )by));
  }
#line 68
  return ((int16_t )(~ (~ ((int )x) >> (int )by)));
}
}
#line 72 "/root/patchweave_donee/23/src/GSM610/gsm610_priv.h"
__inline static int32_t SASR_L(int32_t x , int16_t by ) 
{ 


  {
#line 73
  if (x >= 0) {
#line 74
    return (x >> (int )by);
  }
#line 75
  return (~ (~ x >> (int )by));
}
}
#line 80 "/root/patchweave_donee/23/src/GSM610/gsm610_priv.h"
__inline static int16_t SASL_W(int16_t x , int16_t by ) 
{ 


  {
#line 81
  if ((int )x >= 0) {
#line 82
    return ((int16_t )((int )x << (int )by));
  }
#line 83
  return ((int16_t )(- (- ((int )x) << (int )by)));
}
}
#line 87 "/root/patchweave_donee/23/src/GSM610/gsm610_priv.h"
__inline static int32_t SASL_L(int32_t x , int16_t by ) 
{ 


  {
#line 88
  if (x >= 0) {
#line 89
    return (x << (int )by);
  }
#line 90
  return (- (- x << (int )by));
}
}
#line 96
int16_t gsm_mult(int16_t a , int16_t b ) ;
#line 97
int32_t gsm_L_mult(int16_t a , int16_t b ) ;
#line 98
int16_t gsm_mult_r(int16_t a , int16_t b ) ;
#line 100
int16_t gsm_div(int16_t num , int16_t denum ) ;
#line 102
int16_t gsm_add(int16_t a , int16_t b ) ;
#line 103
int32_t gsm_L_add(int32_t a , int32_t b ) ;
#line 105
int16_t gsm_sub(int16_t a , int16_t b ) ;
#line 106
int32_t gsm_L_sub(int32_t a , int32_t b ) ;
#line 108
int16_t gsm_abs(int16_t a ) ;
#line 110
int16_t gsm_norm(int32_t a ) ;
#line 112
int32_t gsm_L_asl(int32_t a , int n ) ;
#line 113
int16_t gsm_asl(int16_t a , int n ) ;
#line 115
int32_t gsm_L_asr(int32_t a , int n ) ;
#line 116
int16_t gsm_asr(int16_t a , int n ) ;
#line 123 "/root/patchweave_donee/23/src/GSM610/gsm610_priv.h"
__inline static int32_t GSM_MULT_R(int16_t a , int16_t b ) 
{ 


  {
#line 124
  return (((int32_t )a * (int32_t )b + 16384) >> 15);
}
}
#line 128 "/root/patchweave_donee/23/src/GSM610/gsm610_priv.h"
__inline static int32_t GSM_MULT(int16_t a , int16_t b ) 
{ 


  {
#line 129
  return ((int32_t )a * (int32_t )b >> 15);
}
}
#line 138 "/root/patchweave_donee/23/src/GSM610/gsm610_priv.h"
__inline static int32_t GSM_L_ADD(int32_t a , int32_t b ) 
{ 
  uint32_t utmp ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 141
  if (a < 0) {
#line 141
    if (b < 0) {
#line 142
      utmp = (uint32_t )(- (a + 1)) + (uint32_t )(- (b + 1));
#line 143
      if (utmp >= 2147483647U) {
#line 143
        tmp = (-0x7FFFFFFF-1);
      } else {
#line 143
        tmp = - ((int32_t )utmp) - 2;
      }
#line 143
      return (tmp);
    }
  }
#line 146
  if (a > 0) {
#line 146
    if (b > 0) {
#line 147
      utmp = (uint32_t )a + (uint32_t )b;
#line 148
      if (utmp >= 2147483647U) {
#line 148
        tmp___0 = 2147483647U;
      } else {
#line 148
        tmp___0 = utmp;
      }
#line 148
      return ((int32_t )tmp___0);
    }
  }
#line 151
  return (a + b);
}
}
#line 155 "/root/patchweave_donee/23/src/GSM610/gsm610_priv.h"
__inline static int32_t GSM_ADD(int16_t a , int16_t b ) 
{ 
  int32_t ltmp ;

  {
#line 158
  ltmp = (int32_t )a + (int32_t )b;
#line 160
  if (ltmp >= 32767) {
#line 161
    return (32767);
  }
#line 162
  if (ltmp <= -32768) {
#line 163
    return (-32768);
  }
#line 165
  return (ltmp);
}
}
#line 169 "/root/patchweave_donee/23/src/GSM610/gsm610_priv.h"
__inline static int32_t GSM_SUB(int16_t a , int16_t b ) 
{ 
  int32_t ltmp ;

  {
#line 172
  ltmp = (int32_t )a - (int32_t )b;
#line 174
  if (ltmp >= 32767) {
#line 175
    ltmp = 32767;
  } else
#line 176
  if (ltmp <= -32768) {
#line 177
    ltmp = -32768;
  }
#line 179
  return (ltmp);
}
}
#line 183 "/root/patchweave_donee/23/src/GSM610/gsm610_priv.h"
__inline static int16_t GSM_ABS(int16_t a ) 
{ 


  {
#line 185
  if ((int )a > 0) {
#line 186
    return (a);
  }
#line 187
  if ((int )a == -32768) {
#line 188
    return ((int16_t )32767);
  }
#line 189
  return ((int16_t )(- ((int )a)));
}
}
#line 196
void Gsm_Coder(struct gsm_state *State , int16_t *s , int16_t *LARc , int16_t *Nc ,
               int16_t *bc , int16_t *Mc , int16_t *xmaxc , int16_t *xMc ) ;
#line 206
void Gsm_Long_Term_Predictor(struct gsm_state *S , int16_t *d , int16_t *dp , int16_t *e ,
                             int16_t *dpp , int16_t *Nc , int16_t *bc ) ;
#line 215
void Gsm_LPC_Analysis(struct gsm_state *S , int16_t *s , int16_t *LARc ) ;
#line 220
void Gsm_Preprocess(struct gsm_state *S , int16_t *s , int16_t *so ) ;
#line 232
void Gsm_Short_Term_Analysis_Filter(struct gsm_state *S , int16_t *LARc , int16_t *s ) ;
#line 237
void Gsm_Decoder(struct gsm_state *S , int16_t *LARcr , int16_t *Ncr , int16_t *bcr ,
                 int16_t *Mcr , int16_t *xmaxcr , int16_t *xMcr , int16_t *s ) ;
#line 254
void Gsm_Long_Term_Synthesis_Filtering(struct gsm_state *S , int16_t Ncr , int16_t bcr ,
                                       int16_t *erp , int16_t *drp ) ;
#line 261
void Gsm_RPE_Decoding(int16_t xmaxcr , int16_t Mcr , int16_t *xMcr , int16_t *erp ) ;
#line 268
void Gsm_RPE_Encoding(int16_t *e , int16_t *xmaxc , int16_t *Mc , int16_t *xMc ) ;
#line 275
void Gsm_Short_Term_Synthesis_Filter(struct gsm_state *S , int16_t *LARcr , int16_t *wt ,
                                     int16_t *s ) ;
#line 22 "/root/patchweave_donee/23/src/GSM610/table.c"
int16_t gsm_A[8]  = 
#line 22 "/root/patchweave_donee/23/src/GSM610/table.c"
  {      (int16_t )20480,      (int16_t )20480,      (int16_t )20480,      (int16_t )20480, 
        (int16_t )13964,      (int16_t )15360,      (int16_t )8534,      (int16_t )9036};
#line 23 "/root/patchweave_donee/23/src/GSM610/table.c"
int16_t gsm_B[8]  = 
#line 23
  {      (int16_t )0,      (int16_t )0,      (int16_t )2048,      (int16_t )-2560, 
        (int16_t )94,      (int16_t )-1792,      (int16_t )-341,      (int16_t )-1144};
#line 24 "/root/patchweave_donee/23/src/GSM610/table.c"
int16_t gsm_MIC[8]  = 
#line 24
  {      (int16_t )-32,      (int16_t )-32,      (int16_t )-16,      (int16_t )-16, 
        (int16_t )-8,      (int16_t )-8,      (int16_t )-4,      (int16_t )-4};
#line 25 "/root/patchweave_donee/23/src/GSM610/table.c"
int16_t gsm_MAC[8]  = 
#line 25
  {      (int16_t )31,      (int16_t )31,      (int16_t )15,      (int16_t )15, 
        (int16_t )7,      (int16_t )7,      (int16_t )3,      (int16_t )3};
#line 30 "/root/patchweave_donee/23/src/GSM610/table.c"
int16_t gsm_INVA[8]  = 
#line 30
  {      (int16_t )13107,      (int16_t )13107,      (int16_t )13107,      (int16_t )13107, 
        (int16_t )19223,      (int16_t )17476,      (int16_t )31454,      (int16_t )29708};
#line 36 "/root/patchweave_donee/23/src/GSM610/table.c"
int16_t gsm_DLB[4]  = {      (int16_t )6554,      (int16_t )16384,      (int16_t )26214,      (int16_t )32767};
#line 42 "/root/patchweave_donee/23/src/GSM610/table.c"
int16_t gsm_QLB[4]  = {      (int16_t )3277,      (int16_t )11469,      (int16_t )21299,      (int16_t )32767};
#line 48 "/root/patchweave_donee/23/src/GSM610/table.c"
int16_t gsm_H[11]  = 
#line 48
  {      (int16_t )-134,      (int16_t )-374,      (int16_t )0,      (int16_t )2054, 
        (int16_t )5741,      (int16_t )8192,      (int16_t )5741,      (int16_t )2054, 
        (int16_t )0,      (int16_t )-374,      (int16_t )-134};
#line 54 "/root/patchweave_donee/23/src/GSM610/table.c"
int16_t gsm_NRFAC[8]  = 
#line 54
  {      (int16_t )29128,      (int16_t )26215,      (int16_t )23832,      (int16_t )21846, 
        (int16_t )20165,      (int16_t )18725,      (int16_t )17476,      (int16_t )16384};
#line 60 "/root/patchweave_donee/23/src/GSM610/table.c"
int16_t gsm_FAC[8]  = 
#line 60
  {      (int16_t )18431,      (int16_t )20479,      (int16_t )22527,      (int16_t )24575, 
        (int16_t )26623,      (int16_t )28671,      (int16_t )30719,      (int16_t )32767};
#line 18 "/root/patchweave_donee/23/src/GSM610/short_term.c"
static void Decoding_of_the_coded_Log_Area_Ratios(int16_t *LARc , int16_t *LARpp ) 
{ 
  register int16_t temp1 ;
  int16_t *__cil_tmp4 ;
  int32_t __cil_tmp5 ;
  int32_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int32_t __cil_tmp8 ;
  int16_t *__cil_tmp9 ;
  int32_t __cil_tmp10 ;
  int16_t *__cil_tmp11 ;
  int32_t __cil_tmp12 ;
  int32_t __cil_tmp13 ;
  int32_t __cil_tmp14 ;
  int32_t __cil_tmp15 ;
  int16_t *__cil_tmp16 ;
  int32_t __cil_tmp17 ;
  int16_t *__cil_tmp18 ;
  int32_t __cil_tmp19 ;
  int32_t __cil_tmp20 ;
  int32_t __cil_tmp21 ;
  int32_t __cil_tmp22 ;
  int16_t *__cil_tmp23 ;
  int32_t __cil_tmp24 ;
  int16_t *__cil_tmp25 ;
  int32_t __cil_tmp26 ;
  int32_t __cil_tmp27 ;
  int32_t __cil_tmp28 ;
  int32_t __cil_tmp29 ;
  int16_t *__cil_tmp30 ;
  int32_t __cil_tmp31 ;
  int16_t *__cil_tmp32 ;
  int32_t __cil_tmp33 ;
  int32_t __cil_tmp34 ;
  int32_t __cil_tmp35 ;
  int32_t __cil_tmp36 ;
  int16_t *__cil_tmp37 ;
  int32_t __cil_tmp38 ;
  int16_t *__cil_tmp39 ;
  int32_t __cil_tmp40 ;
  int32_t __cil_tmp41 ;
  int32_t __cil_tmp42 ;
  int32_t __cil_tmp43 ;
  int16_t *__cil_tmp44 ;
  int32_t __cil_tmp45 ;
  int16_t *__cil_tmp46 ;
  int32_t __cil_tmp47 ;
  int32_t __cil_tmp48 ;
  int32_t __cil_tmp49 ;
  int32_t __cil_tmp50 ;
  int16_t *__cil_tmp51 ;
  int32_t __cil_tmp52 ;
  int16_t *__cil_tmp53 ;
  int32_t __cil_tmp54 ;
  int32_t __cil_tmp55 ;
  int32_t __cil_tmp56 ;
  int32_t __cil_tmp57 ;
  int16_t *__cil_tmp58 ;
  int32_t __cil_tmp59 ;

  {
  {
#line 54
  __cil_tmp4 = LARc;
#line 54
  LARc ++;
#line 54
  __cil_tmp5 = GSM_ADD(*__cil_tmp4, (int16_t )-32);
#line 54
  __cil_tmp6 = arith_shift_left(__cil_tmp5, 10);
#line 54
  temp1 = (int16_t )__cil_tmp6;
#line 54
  __cil_tmp7 = GSM_SUB(temp1, (int16_t )0);
#line 54
  temp1 = (int16_t )__cil_tmp7;
#line 54
  __cil_tmp8 = GSM_MULT_R((int16_t )13107, temp1);
#line 54
  temp1 = (int16_t )__cil_tmp8;
#line 54
  __cil_tmp10 = GSM_ADD(temp1, temp1);
#line 54
  __cil_tmp9 = LARpp;
#line 54
  LARpp ++;
#line 54
  *__cil_tmp9 = (int16_t )__cil_tmp10;
#line 55
  __cil_tmp11 = LARc;
#line 55
  LARc ++;
#line 55
  __cil_tmp12 = GSM_ADD(*__cil_tmp11, (int16_t )-32);
#line 55
  __cil_tmp13 = arith_shift_left(__cil_tmp12, 10);
#line 55
  temp1 = (int16_t )__cil_tmp13;
#line 55
  __cil_tmp14 = GSM_SUB(temp1, (int16_t )0);
#line 55
  temp1 = (int16_t )__cil_tmp14;
#line 55
  __cil_tmp15 = GSM_MULT_R((int16_t )13107, temp1);
#line 55
  temp1 = (int16_t )__cil_tmp15;
#line 55
  __cil_tmp17 = GSM_ADD(temp1, temp1);
#line 55
  __cil_tmp16 = LARpp;
#line 55
  LARpp ++;
#line 55
  *__cil_tmp16 = (int16_t )__cil_tmp17;
#line 56
  __cil_tmp18 = LARc;
#line 56
  LARc ++;
#line 56
  __cil_tmp19 = GSM_ADD(*__cil_tmp18, (int16_t )-16);
#line 56
  __cil_tmp20 = arith_shift_left(__cil_tmp19, 10);
#line 56
  temp1 = (int16_t )__cil_tmp20;
#line 56
  __cil_tmp21 = GSM_SUB(temp1, (int16_t )4096);
#line 56
  temp1 = (int16_t )__cil_tmp21;
#line 56
  __cil_tmp22 = GSM_MULT_R((int16_t )13107, temp1);
#line 56
  temp1 = (int16_t )__cil_tmp22;
#line 56
  __cil_tmp24 = GSM_ADD(temp1, temp1);
#line 56
  __cil_tmp23 = LARpp;
#line 56
  LARpp ++;
#line 56
  *__cil_tmp23 = (int16_t )__cil_tmp24;
#line 57
  __cil_tmp25 = LARc;
#line 57
  LARc ++;
#line 57
  __cil_tmp26 = GSM_ADD(*__cil_tmp25, (int16_t )-16);
#line 57
  __cil_tmp27 = arith_shift_left(__cil_tmp26, 10);
#line 57
  temp1 = (int16_t )__cil_tmp27;
#line 57
  __cil_tmp28 = GSM_SUB(temp1, (int16_t )-5120);
#line 57
  temp1 = (int16_t )__cil_tmp28;
#line 57
  __cil_tmp29 = GSM_MULT_R((int16_t )13107, temp1);
#line 57
  temp1 = (int16_t )__cil_tmp29;
#line 57
  __cil_tmp31 = GSM_ADD(temp1, temp1);
#line 57
  __cil_tmp30 = LARpp;
#line 57
  LARpp ++;
#line 57
  *__cil_tmp30 = (int16_t )__cil_tmp31;
#line 59
  __cil_tmp32 = LARc;
#line 59
  LARc ++;
#line 59
  __cil_tmp33 = GSM_ADD(*__cil_tmp32, (int16_t )-8);
#line 59
  __cil_tmp34 = arith_shift_left(__cil_tmp33, 10);
#line 59
  temp1 = (int16_t )__cil_tmp34;
#line 59
  __cil_tmp35 = GSM_SUB(temp1, (int16_t )188);
#line 59
  temp1 = (int16_t )__cil_tmp35;
#line 59
  __cil_tmp36 = GSM_MULT_R((int16_t )19223, temp1);
#line 59
  temp1 = (int16_t )__cil_tmp36;
#line 59
  __cil_tmp38 = GSM_ADD(temp1, temp1);
#line 59
  __cil_tmp37 = LARpp;
#line 59
  LARpp ++;
#line 59
  *__cil_tmp37 = (int16_t )__cil_tmp38;
#line 60
  __cil_tmp39 = LARc;
#line 60
  LARc ++;
#line 60
  __cil_tmp40 = GSM_ADD(*__cil_tmp39, (int16_t )-8);
#line 60
  __cil_tmp41 = arith_shift_left(__cil_tmp40, 10);
#line 60
  temp1 = (int16_t )__cil_tmp41;
#line 60
  __cil_tmp42 = GSM_SUB(temp1, (int16_t )-3584);
#line 60
  temp1 = (int16_t )__cil_tmp42;
#line 60
  __cil_tmp43 = GSM_MULT_R((int16_t )17476, temp1);
#line 60
  temp1 = (int16_t )__cil_tmp43;
#line 60
  __cil_tmp45 = GSM_ADD(temp1, temp1);
#line 60
  __cil_tmp44 = LARpp;
#line 60
  LARpp ++;
#line 60
  *__cil_tmp44 = (int16_t )__cil_tmp45;
#line 61
  __cil_tmp46 = LARc;
#line 61
  LARc ++;
#line 61
  __cil_tmp47 = GSM_ADD(*__cil_tmp46, (int16_t )-4);
#line 61
  __cil_tmp48 = arith_shift_left(__cil_tmp47, 10);
#line 61
  temp1 = (int16_t )__cil_tmp48;
#line 61
  __cil_tmp49 = GSM_SUB(temp1, (int16_t )-682);
#line 61
  temp1 = (int16_t )__cil_tmp49;
#line 61
  __cil_tmp50 = GSM_MULT_R((int16_t )31454, temp1);
#line 61
  temp1 = (int16_t )__cil_tmp50;
#line 61
  __cil_tmp52 = GSM_ADD(temp1, temp1);
#line 61
  __cil_tmp51 = LARpp;
#line 61
  LARpp ++;
#line 61
  *__cil_tmp51 = (int16_t )__cil_tmp52;
#line 62
  __cil_tmp53 = LARc;
#line 62
  LARc ++;
#line 62
  __cil_tmp54 = GSM_ADD(*__cil_tmp53, (int16_t )-4);
#line 62
  __cil_tmp55 = arith_shift_left(__cil_tmp54, 10);
#line 62
  temp1 = (int16_t )__cil_tmp55;
#line 62
  __cil_tmp56 = GSM_SUB(temp1, (int16_t )-2288);
#line 62
  temp1 = (int16_t )__cil_tmp56;
#line 62
  __cil_tmp57 = GSM_MULT_R((int16_t )29708, temp1);
#line 62
  temp1 = (int16_t )__cil_tmp57;
#line 62
  __cil_tmp59 = GSM_ADD(temp1, temp1);
#line 62
  __cil_tmp58 = LARpp;
#line 62
  LARpp ++;
#line 62
  *__cil_tmp58 = (int16_t )__cil_tmp59;
  }
#line 63
  return;
}
}
#line 85 "/root/patchweave_donee/23/src/GSM610/short_term.c"
static void Coefficients_0_12(int16_t *LARpp_j_1 , int16_t *LARpp_j , int16_t *LARp ) 
{ 
  register int i ;
  int16_t __cil_tmp5 ;
  int16_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int16_t __cil_tmp8 ;
  int32_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int16_t *__cil_tmp11 ;
  int16_t *__cil_tmp12 ;
  int16_t *__cil_tmp13 ;

  {
#line 92
  i = 1;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;

#line 92
    if (! (i <= 8)) {
#line 92
      goto while_break;
    }
    {
#line 93
    __cil_tmp5 = SASR_W(*LARpp_j_1, (int16_t )2);
#line 93
    __cil_tmp6 = SASR_W(*LARpp_j, (int16_t )2);
#line 93
    __cil_tmp7 = GSM_ADD(__cil_tmp5, __cil_tmp6);
#line 93
    *LARp = (int16_t )__cil_tmp7;
#line 94
    __cil_tmp8 = SASR_W(*LARpp_j_1, (int16_t )1);
#line 94
    __cil_tmp9 = GSM_ADD(*LARp, __cil_tmp8);
#line 94
    *LARp = (int16_t )__cil_tmp9;
#line 92
    __cil_tmp13 = LARpp_j;
#line 92
    LARpp_j ++;
#line 92
    __cil_tmp12 = LARpp_j_1;
#line 92
    LARpp_j_1 ++;
#line 92
    __cil_tmp11 = LARp;
#line 92
    LARp ++;
#line 92
    __cil_tmp10 = i;
#line 92
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 96
  return;
}
}
#line 98 "/root/patchweave_donee/23/src/GSM610/short_term.c"
static void Coefficients_13_26(int16_t *LARpp_j_1 , int16_t *LARpp_j , int16_t *LARp ) 
{ 
  register int i ;
  int16_t __cil_tmp5 ;
  int16_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int __cil_tmp8 ;
  int16_t *__cil_tmp9 ;
  int16_t *__cil_tmp10 ;
  int16_t *__cil_tmp11 ;

  {
#line 104
  i = 1;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;

#line 104
    if (! (i <= 8)) {
#line 104
      goto while_break;
    }
    {
#line 105
    __cil_tmp5 = SASR_W(*LARpp_j_1, (int16_t )1);
#line 105
    __cil_tmp6 = SASR_W(*LARpp_j, (int16_t )1);
#line 105
    __cil_tmp7 = GSM_ADD(__cil_tmp5, __cil_tmp6);
#line 105
    *LARp = (int16_t )__cil_tmp7;
#line 104
    __cil_tmp11 = LARp;
#line 104
    LARp ++;
#line 104
    __cil_tmp10 = LARpp_j;
#line 104
    LARpp_j ++;
#line 104
    __cil_tmp9 = LARpp_j_1;
#line 104
    LARpp_j_1 ++;
#line 104
    __cil_tmp8 = i;
#line 104
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 108
  return;
}
}
#line 108 "/root/patchweave_donee/23/src/GSM610/short_term.c"
static void Coefficients_27_39(int16_t *LARpp_j_1 , int16_t *LARpp_j , int16_t *LARp ) 
{ 
  register int i ;
  int16_t __cil_tmp5 ;
  int16_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int16_t __cil_tmp8 ;
  int32_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int16_t *__cil_tmp11 ;
  int16_t *__cil_tmp12 ;
  int16_t *__cil_tmp13 ;

  {
#line 115
  i = 1;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;

#line 115
    if (! (i <= 8)) {
#line 115
      goto while_break;
    }
    {
#line 116
    __cil_tmp5 = SASR_W(*LARpp_j_1, (int16_t )2);
#line 116
    __cil_tmp6 = SASR_W(*LARpp_j, (int16_t )2);
#line 116
    __cil_tmp7 = GSM_ADD(__cil_tmp5, __cil_tmp6);
#line 116
    *LARp = (int16_t )__cil_tmp7;
#line 117
    __cil_tmp8 = SASR_W(*LARpp_j, (int16_t )1);
#line 117
    __cil_tmp9 = GSM_ADD(*LARp, __cil_tmp8);
#line 117
    *LARp = (int16_t )__cil_tmp9;
#line 115
    __cil_tmp13 = LARp;
#line 115
    LARp ++;
#line 115
    __cil_tmp12 = LARpp_j;
#line 115
    LARpp_j ++;
#line 115
    __cil_tmp11 = LARpp_j_1;
#line 115
    LARpp_j_1 ++;
#line 115
    __cil_tmp10 = i;
#line 115
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 119
  return;
}
}
#line 122 "/root/patchweave_donee/23/src/GSM610/short_term.c"
static void Coefficients_40_159(int16_t *LARpp_j , int16_t *LARp ) 
{ 
  register int i ;
  int __cil_tmp4 ;
  int16_t *__cil_tmp5 ;
  int16_t *__cil_tmp6 ;

  {
#line 128
  i = 1;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;

#line 128
    if (! (i <= 8)) {
#line 128
      goto while_break;
    }
#line 129
    *LARp = *LARpp_j;
#line 128
    __cil_tmp6 = LARpp_j;
#line 128
    LARpp_j ++;
#line 128
    __cil_tmp5 = LARp;
#line 128
    LARp ++;
#line 128
    __cil_tmp4 = i;
#line 128
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 132
  return;
}
}
#line 134 "/root/patchweave_donee/23/src/GSM610/short_term.c"
static void LARp_to_rp(int16_t *LARp ) 
{ 
  register int i ;
  register int16_t temp ;
  int tmp ;
  int32_t __cil_tmp5 ;
  int tmp___0 ;
  int tmp___1 ;
  int32_t __cil_tmp8 ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp11 ;
  int16_t *__cil_tmp12 ;

  {
#line 145
  i = 1;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;

#line 145
    if (! (i <= 8)) {
#line 145
      goto while_break;
    }
#line 155
    if ((int )*LARp < 0) {
#line 156
      if ((int )*LARp == -32768) {
#line 156
        tmp = 32767;
      } else {
#line 156
        tmp = - ((int )*LARp);
      }
#line 156
      temp = (int16_t )tmp;
#line 157
      if ((int )temp < 11059) {
#line 157
        tmp___1 = (int )temp << 1;
      } else {
#line 157
        if ((int )temp < 20070) {
#line 157
          tmp___0 = (int )temp + 11059;
        } else {
          {
#line 157
          __cil_tmp5 = GSM_ADD((int16_t )((int )temp >> 2), (int16_t )26112);
#line 157
          tmp___0 = __cil_tmp5;
          }
        }
#line 157
        tmp___1 = tmp___0;
      }
#line 157
      *LARp = (int16_t )(- tmp___1);
    } else {
#line 162
      temp = *LARp;
#line 163
      if ((int )temp < 11059) {
#line 163
        tmp___3 = (int )temp << 1;
      } else {
#line 163
        if ((int )temp < 20070) {
#line 163
          tmp___2 = (int )temp + 11059;
        } else {
          {
#line 163
          __cil_tmp8 = GSM_ADD((int16_t )((int )temp >> 2), (int16_t )26112);
#line 163
          tmp___2 = __cil_tmp8;
          }
        }
#line 163
        tmp___3 = tmp___2;
      }
#line 163
      *LARp = (int16_t )tmp___3;
    }
#line 145
    __cil_tmp12 = LARp;
#line 145
    LARp ++;
#line 145
    __cil_tmp11 = i;
#line 145
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 149
  return;
}
}
#line 172 "/root/patchweave_donee/23/src/GSM610/short_term.c"
static void Short_term_analysis_filtering(struct gsm_state *S , int16_t *rp , int k_n ,
                                          int16_t *s ) 
{ 
  register int16_t *u ;
  register int i ;
  register int16_t di ;
  register int16_t zzz ;
  register int16_t ui ;
  register int16_t sav ;
  register int16_t rpi ;
  int __cil_tmp12 ;
  int32_t __cil_tmp13 ;
  int32_t __cil_tmp14 ;
  int32_t __cil_tmp15 ;
  int32_t __cil_tmp16 ;

  {
#line 189
  u = S->u;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;

#line 193
    if (! __cil_tmp12) {
#line 193
      goto while_break;
    }
#line 194
    sav = *s;
#line 194
    di = sav;
#line 196
    i = 0;
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 196
      if (! (i < 8)) {
#line 196
        goto while_break___0;
      }
      {
#line 198
      ui = *(u + i);
#line 199
      rpi = *(rp + i);
#line 200
      *(u + i) = sav;
#line 202
      __cil_tmp13 = GSM_MULT_R(rpi, di);
#line 202
      zzz = (int16_t )__cil_tmp13;
#line 203
      __cil_tmp14 = GSM_ADD(ui, zzz);
#line 203
      sav = (int16_t )__cil_tmp14;
#line 205
      __cil_tmp15 = GSM_MULT_R(rpi, ui);
#line 205
      zzz = (int16_t )__cil_tmp15;
#line 206
      __cil_tmp16 = GSM_ADD(di, zzz);
#line 206
      di = (int16_t )__cil_tmp16;
#line 196
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 209
    *s = di;
#line 193
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 197
  return;
}
}
#line 215 "/root/patchweave_donee/23/src/GSM610/short_term.c"
static void Fast_Short_term_analysis_filtering(struct gsm_state *S , int16_t *rp ,
                                               int k_n , int16_t *s ) 
{ 
  register int16_t *u ;
  register int i ;
  float uf[8] ;
  float rpf[8] ;
  register float scalef ;
  register float sav ;
  register float di ;
  register float temp ;
  int __cil_tmp13 ;
  register float rpfi ;
  register float ufi ;

  {
#line 222
  u = S->u;
#line 227
  scalef = (float )3.0517578125e-05;
#line 230
  i = 0;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;

#line 230
    if (! (i < 8)) {
#line 230
      goto while_break;
    }
#line 231
    uf[i] = (float )*(u + i);
#line 232
    rpf[i] = (float )((int )*(rp + i)) * scalef;
#line 230
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 234
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 234
    if (! __cil_tmp13) {
#line 234
      goto while_break___0;
    }
#line 235
    di = (float )*s;
#line 235
    sav = di;
#line 236
    i = 0;
    {
#line 236
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 236
      if (! (i < 8)) {
#line 236
        goto while_break___1;
      }
#line 237
      rpfi = rpf[i];
#line 238
      ufi = uf[i];
#line 240
      uf[i] = sav;
#line 241
      temp = rpfi * di + ufi;
#line 242
      di += rpfi * ufi;
#line 243
      sav = temp;
#line 236
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 245
    *s = (int16_t )di;
#line 234
    s ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 247
  i = 0;
  {
#line 247
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 247
    if (! (i < 8)) {
#line 247
      goto while_break___2;
    }
#line 247
    *(u + i) = (int16_t )uf[i];
#line 247
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 251
  return;
}
}
#line 251 "/root/patchweave_donee/23/src/GSM610/short_term.c"
static void Short_term_synthesis_filtering(struct gsm_state *S , int16_t *rrp , int k ,
                                           int16_t *wt , int16_t *sr ) 
{ 
  register int16_t *v ;
  register int i ;
  register int16_t sri ;
  register int16_t tmp1 ;
  register int16_t tmp2 ;
  int __cil_tmp11 ;
  int16_t *__cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp ;
  int32_t __cil_tmp15 ;
  int tmp___0 ;
  int32_t __cil_tmp17 ;
  int16_t *__cil_tmp18 ;

  {
#line 259
  v = S->v;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    __cil_tmp11 = k;
#line 263
    k --;
#line 263
    if (! __cil_tmp11) {
#line 263
      goto while_break;
    }
#line 264
    __cil_tmp12 = wt;
#line 264
    wt ++;
#line 264
    sri = *__cil_tmp12;
#line 265
    i = 8;
    {
#line 265
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 265
      if (! __cil_tmp13) {
#line 265
        goto while_break___0;
      }
#line 268
      tmp1 = *(rrp + i);
#line 269
      tmp2 = *(v + i);
#line 270
      if ((int )tmp1 == -32768) {
#line 270
        if ((int )tmp2 == -32768) {
#line 270
          tmp = 32767;
        } else {
#line 270
          tmp = 65535 & (((int32_t )tmp1 * (int32_t )tmp2 + 16384) >> 15);
        }
      } else {
#line 270
        tmp = 65535 & (((int32_t )tmp1 * (int32_t )tmp2 + 16384) >> 15);
      }
      {
#line 270
      tmp2 = (int16_t )tmp;
#line 275
      __cil_tmp15 = GSM_SUB(sri, tmp2);
#line 275
      sri = (int16_t )__cil_tmp15;
      }
#line 279
      if ((int )tmp1 == -32768) {
#line 279
        if ((int )sri == -32768) {
#line 279
          tmp___0 = 32767;
        } else {
#line 279
          tmp___0 = 65535 & (((int32_t )tmp1 * (int32_t )sri + 16384) >> 15);
        }
      } else {
#line 279
        tmp___0 = 65535 & (((int32_t )tmp1 * (int32_t )sri + 16384) >> 15);
      }
      {
#line 279
      tmp1 = (int16_t )tmp___0;
#line 284
      __cil_tmp17 = GSM_ADD(*(v + i), tmp1);
#line 284
      *(v + (i + 1)) = (int16_t )__cil_tmp17;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 286
    *(v + 0) = sri;
#line 286
    __cil_tmp18 = sr;
#line 286
    sr ++;
#line 286
    *__cil_tmp18 = *(v + 0);
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 290
  return;
}
}
#line 293 "/root/patchweave_donee/23/src/GSM610/short_term.c"
static void Fast_Short_term_synthesis_filtering(struct gsm_state *S , int16_t *rrp ,
                                                int k , int16_t *wt , int16_t *sr ) 
{ 
  register int16_t *v ;
  register int i ;
  float va[9] ;
  float rrpa[8] ;
  register float scalef ;
  register float temp ;
  int __cil_tmp12 ;
  register float sri ;
  int16_t *__cil_tmp14 ;
  int __cil_tmp15 ;
  int16_t *__cil_tmp16 ;

  {
#line 301
  v = S->v;
#line 305
  scalef = (float )3.0517578125e-05;
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;

#line 307
    if (! (i < 8)) {
#line 307
      goto while_break;
    }
#line 308
    va[i] = (float )*(v + i);
#line 309
    rrpa[i] = (float )*(rrp + i) * scalef;
#line 307
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 311
    __cil_tmp12 = k;
#line 311
    k --;
#line 311
    if (! __cil_tmp12) {
#line 311
      goto while_break___0;
    }
#line 312
    __cil_tmp14 = wt;
#line 312
    wt ++;
#line 312
    sri = (float )*__cil_tmp14;
#line 313
    i = 8;
    {
#line 313
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 313
      if (! __cil_tmp15) {
#line 313
        goto while_break___1;
      }
#line 314
      sri -= rrpa[i] * va[i];
#line 315
      if ((double )sri < - 32768.) {
#line 315
        sri = (float )(- 32768.);
      } else
#line 316
      if ((double )sri > 32767.) {
#line 316
        sri = (float )32767.;
      }
#line 318
      temp = va[i] + rrpa[i] * sri;
#line 319
      if ((double )temp < - 32768.) {
#line 319
        temp = (float )(- 32768.);
      } else
#line 320
      if ((double )temp > 32767.) {
#line 320
        temp = (float )32767.;
      }
#line 321
      va[i + 1] = temp;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 323
    va[0] = sri;
#line 323
    __cil_tmp16 = sr;
#line 323
    sr ++;
#line 323
    *__cil_tmp16 = (int16_t )va[0];
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 325
    if (! (i < 9)) {
#line 325
      goto while_break___2;
    }
#line 325
    *(v + i) = (int16_t )va[i];
#line 325
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 329
  return;
}
}
#line 330 "/root/patchweave_donee/23/src/GSM610/short_term.c"
void Gsm_Short_Term_Analysis_Filter(struct gsm_state *S , int16_t *LARc , int16_t *s ) 
{ 
  int16_t *LARpp_j ;
  int16_t *LARpp_j_1 ;
  int16_t LARp[8] ;
  void (*tmp)(struct gsm_state *S , int16_t *rp , int k_n , int16_t *s ) ;
  void (*tmp___0)(struct gsm_state *S , int16_t *rp , int k_n , int16_t *s ) ;
  void (*tmp___1)(struct gsm_state *S , int16_t *rp , int k_n , int16_t *s ) ;
  void (*tmp___2)(struct gsm_state *S , int16_t *rp , int k_n , int16_t *s ) ;

  {
  {
#line 337
  LARpp_j = S->LARpp[S->j];
#line 338
  S->j = (int16_t )((int )S->j ^ 1);
#line 338
  LARpp_j_1 = S->LARpp[S->j];
#line 352
  Decoding_of_the_coded_Log_Area_Ratios(LARc, LARpp_j);
#line 354
  Coefficients_0_12(LARpp_j_1, LARpp_j, LARp);
#line 355
  LARp_to_rp(LARp);
  }
#line 356
  if ((int )S->fast) {
#line 356
    tmp = & Fast_Short_term_analysis_filtering;
  } else {
#line 356
    tmp = & Short_term_analysis_filtering;
  }
  {
#line 356
  (*tmp)(S, LARp, 13, s);
#line 358
  Coefficients_13_26(LARpp_j_1, LARpp_j, LARp);
#line 359
  LARp_to_rp(LARp);
  }
#line 360
  if ((int )S->fast) {
#line 360
    tmp___0 = & Fast_Short_term_analysis_filtering;
  } else {
#line 360
    tmp___0 = & Short_term_analysis_filtering;
  }
  {
#line 360
  (*tmp___0)(S, LARp, 14, s + 13);
#line 362
  Coefficients_27_39(LARpp_j_1, LARpp_j, LARp);
#line 363
  LARp_to_rp(LARp);
  }
#line 364
  if ((int )S->fast) {
#line 364
    tmp___1 = & Fast_Short_term_analysis_filtering;
  } else {
#line 364
    tmp___1 = & Short_term_analysis_filtering;
  }
  {
#line 364
  (*tmp___1)(S, LARp, 13, s + 27);
#line 366
  Coefficients_40_159(LARpp_j, LARp);
#line 367
  LARp_to_rp(LARp);
  }
#line 368
  if ((int )S->fast) {
#line 368
    tmp___2 = & Fast_Short_term_analysis_filtering;
  } else {
#line 368
    tmp___2 = & Short_term_analysis_filtering;
  }
  {
#line 368
  (*tmp___2)(S, LARp, 120, s + 40);
  }
#line 370
  return;
}
}
#line 371 "/root/patchweave_donee/23/src/GSM610/short_term.c"
void Gsm_Short_Term_Synthesis_Filter(struct gsm_state *S , int16_t *LARcr , int16_t *wt ,
                                     int16_t *s ) 
{ 
  int16_t *LARpp_j ;
  int16_t *LARpp_j_1 ;
  int16_t LARp[8] ;
  void (*tmp)(struct gsm_state *S , int16_t *rrp , int k , int16_t *wt , int16_t *sr ) ;
  void (*tmp___0)(struct gsm_state *S , int16_t *rrp , int k , int16_t *wt , int16_t *sr ) ;
  void (*tmp___1)(struct gsm_state *S , int16_t *rrp , int k , int16_t *wt , int16_t *sr ) ;
  void (*tmp___2)(struct gsm_state *S , int16_t *rrp , int k , int16_t *wt , int16_t *sr ) ;

  {
  {
#line 380
  LARpp_j = S->LARpp[S->j];
#line 381
  S->j = (int16_t )((int )S->j ^ 1);
#line 381
  LARpp_j_1 = S->LARpp[S->j];
#line 395
  Decoding_of_the_coded_Log_Area_Ratios(LARcr, LARpp_j);
#line 397
  Coefficients_0_12(LARpp_j_1, LARpp_j, LARp);
#line 398
  LARp_to_rp(LARp);
  }
#line 399
  if ((int )S->fast) {
#line 399
    tmp = & Fast_Short_term_synthesis_filtering;
  } else {
#line 399
    tmp = & Short_term_synthesis_filtering;
  }
  {
#line 399
  (*tmp)(S, LARp, 13, wt, s);
#line 401
  Coefficients_13_26(LARpp_j_1, LARpp_j, LARp);
#line 402
  LARp_to_rp(LARp);
  }
#line 403
  if ((int )S->fast) {
#line 403
    tmp___0 = & Fast_Short_term_synthesis_filtering;
  } else {
#line 403
    tmp___0 = & Short_term_synthesis_filtering;
  }
  {
#line 403
  (*tmp___0)(S, LARp, 14, wt + 13, s + 13);
#line 405
  Coefficients_27_39(LARpp_j_1, LARpp_j, LARp);
#line 406
  LARp_to_rp(LARp);
  }
#line 407
  if ((int )S->fast) {
#line 407
    tmp___1 = & Fast_Short_term_synthesis_filtering;
  } else {
#line 407
    tmp___1 = & Short_term_synthesis_filtering;
  }
  {
#line 407
  (*tmp___1)(S, LARp, 13, wt + 27, s + 27);
#line 409
  Coefficients_40_159(LARpp_j, LARp);
#line 410
  LARp_to_rp(LARp);
  }
#line 411
  if ((int )S->fast) {
#line 411
    tmp___2 = & Fast_Short_term_synthesis_filtering;
  } else {
#line 411
    tmp___2 = & Short_term_synthesis_filtering;
  }
  {
#line 411
  (*tmp___2)(S, LARp, 120, wt + 40, s + 40);
  }
#line 413
  return;
}
}
#line 17 "/root/patchweave_donee/23/src/GSM610/rpe.c"
static void Weighting_filter(int16_t *e , int16_t *x ) 
{ 
  register int32_t L_result ;
  register int k ;
  int tmp ;
  int tmp___0 ;

  {
#line 43
  e -= 5;
#line 47
  k = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;

#line 47
    if (! (k <= 39)) {
#line 47
      goto while_break;
    }
    {
#line 48
    L_result = 8192 >> 1;
#line 77
    L_result += ((((((((int )*(e + k) * -134 + (int )*(e + (k + 1)) * -374) + (int )*(e + (k + 3)) * 2054) + (int )*(e + (k + 4)) * 5741) + (int )*(e + (k + 5)) * 8192) + (int )*(e + (k + 6)) * 5741) + (int )*(e + (k + 7)) * 2054) + (int )*(e + (k + 9)) * -374) + (int )*(e + (k + 10)) * -134;
#line 100
    L_result = SASR_L(L_result, (int16_t )13);
    }
#line 101
    if (L_result < -32768) {
#line 101
      tmp___0 = -32768;
    } else {
#line 101
      if (L_result > 32767) {
#line 101
        tmp = 32767;
      } else {
#line 101
        tmp = L_result;
      }
#line 101
      tmp___0 = tmp;
    }
#line 101
    *(x + k) = (int16_t )tmp___0;
#line 47
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 51
  return;
}
}
#line 108 "/root/patchweave_donee/23/src/GSM610/rpe.c"
static void RPE_grid_selection(int16_t *x , int16_t *xM , int16_t *Mc_out ) 
{ 
  register int i ;
  register int32_t L_result ;
  register int32_t L_temp ;
  int32_t EM ;
  int16_t Mc ;
  int32_t L_common_0_3 ;
  int16_t __cil_tmp10 ;
  int16_t __cil_tmp11 ;
  int16_t __cil_tmp12 ;
  int16_t __cil_tmp13 ;
  int16_t __cil_tmp14 ;
  int16_t __cil_tmp15 ;
  int16_t __cil_tmp16 ;
  int16_t __cil_tmp17 ;
  int16_t __cil_tmp18 ;
  int16_t __cil_tmp19 ;
  int16_t __cil_tmp20 ;
  int16_t __cil_tmp21 ;
  int16_t __cil_tmp22 ;
  int16_t __cil_tmp23 ;
  int16_t __cil_tmp24 ;
  int16_t __cil_tmp25 ;
  int16_t __cil_tmp26 ;
  int16_t __cil_tmp27 ;
  int16_t __cil_tmp28 ;
  int16_t __cil_tmp29 ;
  int16_t __cil_tmp30 ;
  int16_t __cil_tmp31 ;
  int16_t __cil_tmp32 ;
  int16_t __cil_tmp33 ;
  int16_t __cil_tmp34 ;
  int16_t __cil_tmp35 ;
  int16_t __cil_tmp36 ;
  int16_t __cil_tmp37 ;
  int16_t __cil_tmp38 ;
  int16_t __cil_tmp39 ;
  int16_t __cil_tmp40 ;
  int16_t __cil_tmp41 ;
  int16_t __cil_tmp42 ;
  int16_t __cil_tmp43 ;
  int16_t __cil_tmp44 ;
  int16_t __cil_tmp45 ;
  int16_t __cil_tmp46 ;
  int16_t __cil_tmp47 ;
  int16_t __cil_tmp48 ;
  int16_t __cil_tmp49 ;

  {
  {
#line 125
  EM = 0;
#line 126
  Mc = (int16_t )0;
#line 155
  L_result = 0;
#line 156
  __cil_tmp10 = SASR_W(*(x + 3), (int16_t )2);
#line 156
  L_temp = (int32_t )__cil_tmp10;
#line 156
  L_result += L_temp * L_temp;
#line 156
  __cil_tmp11 = SASR_W(*(x + 6), (int16_t )2);
#line 156
  L_temp = (int32_t )__cil_tmp11;
#line 156
  L_result += L_temp * L_temp;
#line 156
  __cil_tmp12 = SASR_W(*(x + 9), (int16_t )2);
#line 156
  L_temp = (int32_t )__cil_tmp12;
#line 156
  L_result += L_temp * L_temp;
#line 156
  __cil_tmp13 = SASR_W(*(x + 12), (int16_t )2);
#line 156
  L_temp = (int32_t )__cil_tmp13;
#line 156
  L_result += L_temp * L_temp;
#line 157
  __cil_tmp14 = SASR_W(*(x + 15), (int16_t )2);
#line 157
  L_temp = (int32_t )__cil_tmp14;
#line 157
  L_result += L_temp * L_temp;
#line 157
  __cil_tmp15 = SASR_W(*(x + 18), (int16_t )2);
#line 157
  L_temp = (int32_t )__cil_tmp15;
#line 157
  L_result += L_temp * L_temp;
#line 157
  __cil_tmp16 = SASR_W(*(x + 21), (int16_t )2);
#line 157
  L_temp = (int32_t )__cil_tmp16;
#line 157
  L_result += L_temp * L_temp;
#line 157
  __cil_tmp17 = SASR_W(*(x + 24), (int16_t )2);
#line 157
  L_temp = (int32_t )__cil_tmp17;
#line 157
  L_result += L_temp * L_temp;
#line 158
  __cil_tmp18 = SASR_W(*(x + 27), (int16_t )2);
#line 158
  L_temp = (int32_t )__cil_tmp18;
#line 158
  L_result += L_temp * L_temp;
#line 158
  __cil_tmp19 = SASR_W(*(x + 30), (int16_t )2);
#line 158
  L_temp = (int32_t )__cil_tmp19;
#line 158
  L_result += L_temp * L_temp;
#line 158
  __cil_tmp20 = SASR_W(*(x + 33), (int16_t )2);
#line 158
  L_temp = (int32_t )__cil_tmp20;
#line 158
  L_result += L_temp * L_temp;
#line 158
  __cil_tmp21 = SASR_W(*(x + 36), (int16_t )2);
#line 158
  L_temp = (int32_t )__cil_tmp21;
#line 158
  L_result += L_temp * L_temp;
#line 159
  L_common_0_3 = L_result;
#line 163
  __cil_tmp22 = SASR_W(*(x + 0), (int16_t )2);
#line 163
  L_temp = (int32_t )__cil_tmp22;
#line 163
  L_result += L_temp * L_temp;
#line 164
  L_result <<= 1;
#line 165
  EM = L_result;
#line 169
  L_result = 0;
#line 170
  __cil_tmp23 = SASR_W(*(x + 1), (int16_t )2);
#line 170
  L_temp = (int32_t )__cil_tmp23;
#line 170
  L_result += L_temp * L_temp;
#line 171
  __cil_tmp24 = SASR_W(*(x + 4), (int16_t )2);
#line 171
  L_temp = (int32_t )__cil_tmp24;
#line 171
  L_result += L_temp * L_temp;
#line 171
  __cil_tmp25 = SASR_W(*(x + 7), (int16_t )2);
#line 171
  L_temp = (int32_t )__cil_tmp25;
#line 171
  L_result += L_temp * L_temp;
#line 171
  __cil_tmp26 = SASR_W(*(x + 10), (int16_t )2);
#line 171
  L_temp = (int32_t )__cil_tmp26;
#line 171
  L_result += L_temp * L_temp;
#line 171
  __cil_tmp27 = SASR_W(*(x + 13), (int16_t )2);
#line 171
  L_temp = (int32_t )__cil_tmp27;
#line 171
  L_result += L_temp * L_temp;
#line 172
  __cil_tmp28 = SASR_W(*(x + 16), (int16_t )2);
#line 172
  L_temp = (int32_t )__cil_tmp28;
#line 172
  L_result += L_temp * L_temp;
#line 172
  __cil_tmp29 = SASR_W(*(x + 19), (int16_t )2);
#line 172
  L_temp = (int32_t )__cil_tmp29;
#line 172
  L_result += L_temp * L_temp;
#line 172
  __cil_tmp30 = SASR_W(*(x + 22), (int16_t )2);
#line 172
  L_temp = (int32_t )__cil_tmp30;
#line 172
  L_result += L_temp * L_temp;
#line 172
  __cil_tmp31 = SASR_W(*(x + 25), (int16_t )2);
#line 172
  L_temp = (int32_t )__cil_tmp31;
#line 172
  L_result += L_temp * L_temp;
#line 173
  __cil_tmp32 = SASR_W(*(x + 28), (int16_t )2);
#line 173
  L_temp = (int32_t )__cil_tmp32;
#line 173
  L_result += L_temp * L_temp;
#line 173
  __cil_tmp33 = SASR_W(*(x + 31), (int16_t )2);
#line 173
  L_temp = (int32_t )__cil_tmp33;
#line 173
  L_result += L_temp * L_temp;
#line 173
  __cil_tmp34 = SASR_W(*(x + 34), (int16_t )2);
#line 173
  L_temp = (int32_t )__cil_tmp34;
#line 173
  L_result += L_temp * L_temp;
#line 173
  __cil_tmp35 = SASR_W(*(x + 37), (int16_t )2);
#line 173
  L_temp = (int32_t )__cil_tmp35;
#line 173
  L_result += L_temp * L_temp;
#line 174
  L_result <<= 1;
  }
#line 175
  if (L_result > EM) {
#line 176
    Mc = (int16_t )1;
#line 177
    EM = L_result;
  }
  {
#line 182
  L_result = 0;
#line 183
  __cil_tmp36 = SASR_W(*(x + 2), (int16_t )2);
#line 183
  L_temp = (int32_t )__cil_tmp36;
#line 183
  L_result += L_temp * L_temp;
#line 184
  __cil_tmp37 = SASR_W(*(x + 5), (int16_t )2);
#line 184
  L_temp = (int32_t )__cil_tmp37;
#line 184
  L_result += L_temp * L_temp;
#line 184
  __cil_tmp38 = SASR_W(*(x + 8), (int16_t )2);
#line 184
  L_temp = (int32_t )__cil_tmp38;
#line 184
  L_result += L_temp * L_temp;
#line 184
  __cil_tmp39 = SASR_W(*(x + 11), (int16_t )2);
#line 184
  L_temp = (int32_t )__cil_tmp39;
#line 184
  L_result += L_temp * L_temp;
#line 184
  __cil_tmp40 = SASR_W(*(x + 14), (int16_t )2);
#line 184
  L_temp = (int32_t )__cil_tmp40;
#line 184
  L_result += L_temp * L_temp;
#line 185
  __cil_tmp41 = SASR_W(*(x + 17), (int16_t )2);
#line 185
  L_temp = (int32_t )__cil_tmp41;
#line 185
  L_result += L_temp * L_temp;
#line 185
  __cil_tmp42 = SASR_W(*(x + 20), (int16_t )2);
#line 185
  L_temp = (int32_t )__cil_tmp42;
#line 185
  L_result += L_temp * L_temp;
#line 185
  __cil_tmp43 = SASR_W(*(x + 23), (int16_t )2);
#line 185
  L_temp = (int32_t )__cil_tmp43;
#line 185
  L_result += L_temp * L_temp;
#line 185
  __cil_tmp44 = SASR_W(*(x + 26), (int16_t )2);
#line 185
  L_temp = (int32_t )__cil_tmp44;
#line 185
  L_result += L_temp * L_temp;
#line 186
  __cil_tmp45 = SASR_W(*(x + 29), (int16_t )2);
#line 186
  L_temp = (int32_t )__cil_tmp45;
#line 186
  L_result += L_temp * L_temp;
#line 186
  __cil_tmp46 = SASR_W(*(x + 32), (int16_t )2);
#line 186
  L_temp = (int32_t )__cil_tmp46;
#line 186
  L_result += L_temp * L_temp;
#line 186
  __cil_tmp47 = SASR_W(*(x + 35), (int16_t )2);
#line 186
  L_temp = (int32_t )__cil_tmp47;
#line 186
  L_result += L_temp * L_temp;
#line 186
  __cil_tmp48 = SASR_W(*(x + 38), (int16_t )2);
#line 186
  L_temp = (int32_t )__cil_tmp48;
#line 186
  L_result += L_temp * L_temp;
#line 187
  L_result <<= 1;
  }
#line 188
  if (L_result > EM) {
#line 189
    Mc = (int16_t )2;
#line 190
    EM = L_result;
  }
  {
#line 195
  L_result = L_common_0_3;
#line 196
  __cil_tmp49 = SASR_W(*(x + 39), (int16_t )2);
#line 196
  L_temp = (int32_t )__cil_tmp49;
#line 196
  L_result += L_temp * L_temp;
#line 197
  L_result <<= 1;
  }
#line 198
  if (L_result > EM) {
#line 199
    Mc = (int16_t )3;
#line 200
    EM = L_result;
  }
#line 206
  i = 0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;

#line 206
    if (! (i <= 12)) {
#line 206
      goto while_break;
    }
#line 206
    *(xM + i) = *(x + ((int )Mc + 3 * i));
#line 206
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 207
  *Mc_out = Mc;
#line 208
  return;
}
}
#line 212 "/root/patchweave_donee/23/src/GSM610/rpe.c"
static void APCM_quantization_xmaxc_to_exp_mant(int16_t xmaxc , int16_t *expon_out ,
                                                int16_t *mant_out ) 
{ 
  int16_t expon ;
  int16_t mant ;
  int16_t __cil_tmp6 ;
  int16_t __cil_tmp7 ;

  {
#line 222
  expon = (int16_t )0;
#line 223
  if ((int )xmaxc > 15) {
    {
#line 223
    __cil_tmp6 = SASR_W(xmaxc, (int16_t )3);
#line 223
    expon = (int16_t )((int )__cil_tmp6 - 1);
    }
  }
#line 224
  mant = (int16_t )((int )xmaxc - ((int )expon << 3));
#line 226
  if ((int )mant == 0) {
#line 227
    expon = (int16_t )-4;
#line 228
    mant = (int16_t )7;
  } else {
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;

#line 231
      if (! ((int )mant <= 7)) {
#line 231
        goto while_break;
      }
#line 232
      mant = (int16_t )(((int )mant << 1) | 1);
#line 233
      __cil_tmp7 = expon;
#line 233
      expon = (int16_t )((int )expon - 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 235
    mant = (int16_t )((int )mant - 8);
  }
#line 241
  *expon_out = expon;
#line 242
  *mant_out = mant;
#line 243
  return;
}
}
#line 245 "/root/patchweave_donee/23/src/GSM610/rpe.c"
static void APCM_quantization(int16_t *xM , int16_t *xMc , int16_t *mant_out , int16_t *expon_out ,
                              int16_t *xmaxc_out ) 
{ 
  int i ;
  int itest ;
  int16_t xmax ;
  int16_t xmaxc ;
  int16_t temp ;
  int16_t temp1 ;
  int16_t temp2 ;
  int16_t expon ;
  int16_t mant ;
  int16_t __cil_tmp24 ;
  int16_t __cil_tmp25 ;
  int32_t __cil_tmp29 ;
  int32_t __cil_tmp30 ;

  {
#line 262
  xmax = (int16_t )0;
#line 263
  i = 0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;

#line 263
    if (! (i <= 12)) {
#line 263
      goto while_break;
    }
    {
#line 264
    temp = *(xM + i);
#line 265
    temp = GSM_ABS(temp);
    }
#line 266
    if ((int )temp > (int )xmax) {
#line 266
      xmax = temp;
    }
#line 263
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 272
  expon = (int16_t )0;
#line 273
  temp = SASR_W(xmax, (int16_t )9);
#line 274
  itest = 0;
#line 276
  i = 0;
  }
  {
#line 276
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 276
    if (! (i <= 5)) {
#line 276
      goto while_break___0;
    }
    {
#line 277
    itest |= (int )temp <= 0;
#line 278
    temp = SASR_W(temp, (int16_t )1);
    }
#line 281
    if (itest == 0) {
#line 281
      expon = (int16_t )((int )expon + 1);
    }
#line 276
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 285
  temp = (int16_t )((int )expon + 5);
#line 288
  __cil_tmp24 = SASR_W(xmax, temp);
#line 288
  __cil_tmp25 = gsm_add(__cil_tmp24, (int16_t )((int )expon << 3));
#line 288
  xmaxc = __cil_tmp25;
#line 294
  APCM_quantization_xmaxc_to_exp_mant(xmaxc, & expon, & mant);
#line 313
  temp1 = (int16_t )(6 - (int )expon);
#line 314
  temp2 = gsm_NRFAC[mant];
#line 316
  i = 0;
  }
  {
#line 316
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 316
    if (! (i <= 12)) {
#line 316
      goto while_break___1;
    }
    {
#line 319
    __cil_tmp29 = arith_shift_left((int32_t )*(xM + i), (int )temp1);
#line 319
    temp = (int16_t )__cil_tmp29;
#line 320
    __cil_tmp30 = GSM_MULT(temp, temp2);
#line 320
    temp = (int16_t )__cil_tmp30;
#line 321
    temp = SASR_W(temp, (int16_t )12);
#line 322
    *(xMc + i) = (int16_t )((int )temp + 4);
#line 316
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
#line 328
  *mant_out = mant;
#line 329
  *expon_out = expon;
#line 330
  *xmaxc_out = xmaxc;
#line 331
  return;
}
}
#line 335 "/root/patchweave_donee/23/src/GSM610/rpe.c"
static void APCM_inverse_quantization(int16_t *xMc , int16_t mant , int16_t expon ,
                                      int16_t *xMp ) 
{ 
  int i ;
  int16_t temp ;
  int16_t temp1 ;
  int16_t temp2 ;
  int16_t temp3 ;
  int16_t __cil_tmp12 ;
  int16_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int16_t *__cil_tmp16 ;
  int32_t __cil_tmp18 ;
  int32_t __cil_tmp19 ;
  int32_t __cil_tmp20 ;
  int16_t *__cil_tmp21 ;

  {
  {
#line 351
  temp1 = gsm_FAC[mant];
#line 352
  temp2 = gsm_sub((int16_t )6, expon);
#line 353
  __cil_tmp12 = gsm_sub(temp2, (int16_t )1);
#line 353
  __cil_tmp13 = gsm_asl((int16_t )1, (int )__cil_tmp12);
#line 353
  temp3 = __cil_tmp13;
#line 355
  i = 13;
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;

#line 355
    if (! __cil_tmp14) {
#line 355
      goto while_break;
    }
    {
#line 359
    __cil_tmp16 = xMc;
#line 359
    xMc ++;
#line 359
    temp = (int16_t )(((int )*__cil_tmp16 << 1) - 7);
#line 362
    __cil_tmp18 = arith_shift_left((int32_t )temp, 12);
#line 362
    temp = (int16_t )__cil_tmp18;
#line 363
    __cil_tmp19 = GSM_MULT_R(temp1, temp);
#line 363
    temp = (int16_t )__cil_tmp19;
#line 364
    __cil_tmp20 = GSM_ADD(temp, temp3);
#line 364
    temp = (int16_t )__cil_tmp20;
#line 365
    __cil_tmp21 = xMp;
#line 365
    xMp ++;
#line 365
    *__cil_tmp21 = gsm_asr(temp, (int )temp2);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 370
  return;
}
}
#line 371 "/root/patchweave_donee/23/src/GSM610/rpe.c"
static void RPE_grid_positioning(int16_t Mc , int16_t *xMp , int16_t *ep ) 
{ 
  int i ;
  int16_t *__cil_tmp6 ;
  int16_t *__cil_tmp7 ;
  int16_t *__cil_tmp8 ;
  int16_t *__cil_tmp9 ;
  int16_t *__cil_tmp10 ;
  int16_t *__cil_tmp11 ;

  {
#line 384
  i = 13;
#line 389
  if ((int )Mc == 3) {
#line 389
    goto case_3;
  }
#line 390
  if ((int )Mc == 2) {
#line 390
    goto case_2;
  }
#line 392
  if ((int )Mc == 1) {
#line 392
    goto case_1;
  }
#line 393
  if ((int )Mc == 0) {
#line 393
    goto case_0;
  }
#line 388
  goto switch_break;
  case_3: 
#line 389
  __cil_tmp6 = ep;
#line 389
  ep ++;
#line 389
  *__cil_tmp6 = (int16_t )0;
  case_2: 
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    __cil_tmp7 = ep;
#line 391
    ep ++;
#line 391
    *__cil_tmp7 = (int16_t )0;
    case_1: 
#line 392
    __cil_tmp8 = ep;
#line 392
    ep ++;
#line 392
    *__cil_tmp8 = (int16_t )0;
    case_0: 
#line 393
    __cil_tmp10 = xMp;
#line 393
    xMp ++;
#line 393
    __cil_tmp9 = ep;
#line 393
    ep ++;
#line 393
    *__cil_tmp9 = *__cil_tmp10;
#line 390
    if (! i) {
#line 390
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
  switch_break: ;
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    Mc = (int16_t )((int )Mc + 1);
#line 396
    if (! ((int )Mc < 4)) {
#line 396
      goto while_break___0;
    }
#line 396
    __cil_tmp11 = ep;
#line 396
    ep ++;
#line 396
    *__cil_tmp11 = (int16_t )0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 400
  return;
}
}
#line 424 "/root/patchweave_donee/23/src/GSM610/rpe.c"
void Gsm_RPE_Encoding(int16_t *e , int16_t *xmaxc , int16_t *Mc , int16_t *xMc ) 
{ 
  int16_t x[40] ;
  int16_t xM[13] ;
  int16_t xMp[13] ;
  int16_t mant ;
  int16_t expon ;

  {
  {
#line 434
  Weighting_filter(e, x);
#line 435
  RPE_grid_selection(x, xM, Mc);
#line 437
  APCM_quantization(xM, xMc, & mant, & expon, xmaxc);
#line 438
  APCM_inverse_quantization(xMc, mant, expon, xMp);
#line 440
  RPE_grid_positioning(*Mc, xMp, e);
  }
#line 442
  return;
}
}
#line 444 "/root/patchweave_donee/23/src/GSM610/rpe.c"
void Gsm_RPE_Decoding(int16_t xmaxcr , int16_t Mcr , int16_t *xMcr , int16_t *erp ) 
{ 
  int16_t expon ;
  int16_t mant ;
  int16_t xMp[13] ;

  {
  {
#line 454
  APCM_quantization_xmaxc_to_exp_mant(xmaxcr, & expon, & mant);
#line 455
  APCM_inverse_quantization(xMcr, mant, expon, xMp);
#line 456
  RPE_grid_positioning(Mcr, xMp, erp);
  }
#line 458
  return;
}
}
#line 29 "/root/patchweave_donee/23/src/GSM610/preprocess.c"
void Gsm_Preprocess(struct gsm_state *S , int16_t *s , int16_t *so ) 
{ 
  int16_t z1 ;
  int32_t L_z2 ;
  int16_t mp ;
  int16_t s1 ;
  int32_t L_s2 ;
  int32_t L_temp ;
  int16_t msp ;
  int16_t lsp ;
  int16_t SO ;
  register int k ;
  int __cil_tmp14 ;
  int16_t __cil_tmp15 ;
  int32_t __cil_tmp16 ;
  int32_t __cil_tmp22 ;
  int32_t __cil_tmp23 ;
  int32_t __cil_tmp24 ;
  int32_t __cil_tmp27 ;
  int32_t __cil_tmp28 ;
  int16_t *__cil_tmp29 ;
  int32_t __cil_tmp30 ;

  {
#line 35
  z1 = S->z1;
#line 36
  L_z2 = S->L_z2;
#line 37
  mp = (int16_t )S->mp;
#line 47
  k = 160;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    __cil_tmp14 = k;
#line 49
    k --;
#line 49
    if (! __cil_tmp14) {
#line 49
      goto while_break;
    }
    {
#line 53
    __cil_tmp15 = SASR_W(*s, (int16_t )3);
#line 53
    __cil_tmp16 = arith_shift_left((int32_t )__cil_tmp15, 2);
#line 53
    SO = (int16_t )__cil_tmp16;
#line 54
    s ++;
#line 70
    s1 = (int16_t )((int )SO - (int )z1);
#line 71
    z1 = SO;
#line 76
    L_s2 = (int32_t )s1;
#line 77
    L_s2 = arith_shift_left(L_s2, 15);
#line 81
    __cil_tmp22 = SASR_L(L_z2, (int16_t )15);
#line 81
    msp = (int16_t )__cil_tmp22;
#line 82
    __cil_tmp23 = arith_shift_left((int32_t )msp, 15);
#line 82
    lsp = (int16_t )(L_z2 - __cil_tmp23);
#line 84
    __cil_tmp24 = GSM_MULT_R(lsp, (int16_t )32735);
#line 84
    L_s2 += __cil_tmp24;
#line 85
    L_temp = (int32_t )msp * 32735;
#line 86
    L_z2 = GSM_L_ADD(L_temp, L_s2);
#line 89
    L_temp = GSM_L_ADD(L_z2, 16384);
#line 93
    __cil_tmp27 = GSM_MULT_R(mp, (int16_t )-28180);
#line 93
    msp = (int16_t )__cil_tmp27;
#line 94
    __cil_tmp28 = SASR_L(L_temp, (int16_t )15);
#line 94
    mp = (int16_t )__cil_tmp28;
#line 95
    __cil_tmp30 = GSM_ADD(mp, msp);
#line 95
    __cil_tmp29 = so;
#line 95
    so ++;
#line 95
    *__cil_tmp29 = (int16_t )__cil_tmp30;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 98
  S->z1 = z1;
#line 99
  S->L_z2 = L_z2;
#line 100
  S->mp = (int )mp;
#line 101
  return;
}
}
#line 19 "/root/patchweave_donee/23/src/GSM610/lpc.c"
static void Autocorrelation(int16_t *s , int32_t *L_ACF ) 
{ 
  register int k ;
  register int i ;
  int16_t temp ;
  int16_t smax ;
  int16_t scalauto ;
  float float_s[160] ;
  int16_t __cil_tmp12 ;
  int32_t __cil_tmp13 ;
  int32_t __cil_tmp15 ;
  int32_t __cil_tmp17 ;
  int32_t __cil_tmp19 ;
  register float *sp ;
  register float sl ;
  int __cil_tmp24 ;
  int __cil_tmp26 ;
  int __cil_tmp29 ;

  {
#line 38
  smax = (int16_t )0;
#line 39
  k = 0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;

#line 39
    if (! (k <= 159)) {
#line 39
      goto while_break;
    }
    {
#line 40
    temp = GSM_ABS(*(s + k));
    }
#line 41
    if ((int )temp > (int )smax) {
#line 41
      smax = temp;
    }
#line 39
    k ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: ;
#line 46
  if ((int )smax == 0) {
#line 47
    scalauto = (int16_t )0;
  } else {
    {
#line 50
    __cil_tmp12 = gsm_norm((int32_t )smax << 16);
#line 50
    scalauto = (int16_t )(4 - (int )__cil_tmp12);
    }
  }
#line 56
  if ((int )scalauto > 0) {
#line 73
    if ((int )scalauto == 1) {
#line 73
      goto case_1;
    }
#line 74
    if ((int )scalauto == 2) {
#line 74
      goto case_2;
    }
#line 75
    if ((int )scalauto == 3) {
#line 75
      goto case_3;
    }
#line 76
    if ((int )scalauto == 4) {
#line 76
      goto case_4;
    }
#line 72
    goto switch_break;
    case_1: 
#line 73
    k = 0;
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 73
      if (! (k <= 159)) {
#line 73
        goto while_break___0;
      }
      {
#line 73
      __cil_tmp13 = GSM_MULT_R(*(s + k), (int16_t )16384);
#line 73
      *(s + k) = (int16_t )__cil_tmp13;
#line 73
      float_s[k] = (float )*(s + k);
#line 73
      k ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___0: ;
#line 73
    goto switch_break;
    case_2: 
#line 74
    k = 0;
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 74
      if (! (k <= 159)) {
#line 74
        goto while_break___1;
      }
      {
#line 74
      __cil_tmp15 = GSM_MULT_R(*(s + k), (int16_t )(16384 >> 1));
#line 74
      *(s + k) = (int16_t )__cil_tmp15;
#line 74
      float_s[k] = (float )*(s + k);
#line 74
      k ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___1: ;
#line 74
    goto switch_break;
    case_3: 
#line 75
    k = 0;
    {
#line 75
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 75
      if (! (k <= 159)) {
#line 75
        goto while_break___2;
      }
      {
#line 75
      __cil_tmp17 = GSM_MULT_R(*(s + k), (int16_t )(16384 >> 2));
#line 75
      *(s + k) = (int16_t )__cil_tmp17;
#line 75
      float_s[k] = (float )*(s + k);
#line 75
      k ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___2: ;
#line 75
    goto switch_break;
    case_4: 
#line 76
    k = 0;
    {
#line 76
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 76
      if (! (k <= 159)) {
#line 76
        goto while_break___3;
      }
      {
#line 76
      __cil_tmp19 = GSM_MULT_R(*(s + k), (int16_t )(16384 >> 3));
#line 76
      *(s + k) = (int16_t )__cil_tmp19;
#line 76
      float_s[k] = (float )*(s + k);
#line 76
      k ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___3: ;
#line 76
    goto switch_break;
    switch_break: ;
  } else {
#line 81
    k = 0;
    {
#line 81
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 81
      if (! (k <= 159)) {
#line 81
        goto while_break___4;
      }
#line 81
      float_s[k] = (float )*(s + k);
#line 81
      k ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___4: ;
  }
#line 88
  sp = float_s;
#line 89
  sl = *sp;
#line 102
  k = 9;
  {
#line 102
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 102
    if (! __cil_tmp24) {
#line 102
      goto while_break___5;
    }
#line 102
    *(L_ACF + k) = 0;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___5: 
#line 104
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 105
  sp ++;
#line 105
  sl = *sp;
#line 106
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 106
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 107
  sp ++;
#line 107
  sl = *sp;
#line 108
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 108
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 108
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 109
  sp ++;
#line 109
  sl = *sp;
#line 110
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 110
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 110
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 110
  *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 111
  sp ++;
#line 111
  sl = *sp;
#line 112
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 112
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 112
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 112
  *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 112
  *(L_ACF + 4) += (int32_t )(sl * *(sp + -4));
#line 113
  sp ++;
#line 113
  sl = *sp;
#line 114
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 114
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 114
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 114
  *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 114
  *(L_ACF + 4) += (int32_t )(sl * *(sp + -4));
#line 114
  *(L_ACF + 5) += (int32_t )(sl * *(sp + -5));
#line 115
  sp ++;
#line 115
  sl = *sp;
#line 116
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 116
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 116
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 116
  *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 116
  *(L_ACF + 4) += (int32_t )(sl * *(sp + -4));
#line 116
  *(L_ACF + 5) += (int32_t )(sl * *(sp + -5));
#line 116
  *(L_ACF + 6) += (int32_t )(sl * *(sp + -6));
#line 117
  sp ++;
#line 117
  sl = *sp;
#line 118
  *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 118
  *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 118
  *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 118
  *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 118
  *(L_ACF + 4) += (int32_t )(sl * *(sp + -4));
#line 118
  *(L_ACF + 5) += (int32_t )(sl * *(sp + -5));
#line 118
  *(L_ACF + 6) += (int32_t )(sl * *(sp + -6));
#line 118
  *(L_ACF + 7) += (int32_t )(sl * *(sp + -7));
#line 120
  i = 8;
  {
#line 120
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 120
    if (! (i <= 159)) {
#line 120
      goto while_break___6;
    }
#line 121
    sp ++;
#line 121
    sl = *sp;
#line 123
    *(L_ACF + 0) += (int32_t )(sl * *(sp + 0));
#line 124
    *(L_ACF + 1) += (int32_t )(sl * *(sp + -1));
#line 124
    *(L_ACF + 2) += (int32_t )(sl * *(sp + -2));
#line 124
    *(L_ACF + 3) += (int32_t )(sl * *(sp + -3));
#line 124
    *(L_ACF + 4) += (int32_t )(sl * *(sp + -4));
#line 125
    *(L_ACF + 5) += (int32_t )(sl * *(sp + -5));
#line 125
    *(L_ACF + 6) += (int32_t )(sl * *(sp + -6));
#line 125
    *(L_ACF + 7) += (int32_t )(sl * *(sp + -7));
#line 125
    *(L_ACF + 8) += (int32_t )(sl * *(sp + -8));
#line 120
    i ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___6: 
#line 128
  k = 9;
  {
#line 128
  while (1) {
    while_continue___7: /* CIL Label */ ;

#line 128
    if (! __cil_tmp26) {
#line 128
      goto while_break___7;
    }
    {
#line 129
    *(L_ACF + k) = SASL_L(*(L_ACF + k), (int16_t )1);
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___7: ;
#line 134
  if ((int )scalauto > 0) {
#line 136
    k = 160;
    {
#line 136
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 136
      if (! __cil_tmp29) {
#line 136
        goto while_break___8;
      }
      {
#line 137
      *s = SASL_W(*s, scalauto);
#line 136
      s ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___8: ;
  }
#line 141
  return;
}
}
#line 143 "/root/patchweave_donee/23/src/GSM610/lpc.c"
static void Fast_Autocorrelation(int16_t *s , int32_t *L_ACF ) 
{ 
  register int k ;
  register int i ;
  float f_L_ACF[9] ;
  float scale ;
  float s_f[160] ;
  register float *sf ;
  register float L_temp2 ;
  register float *sfl ;

  {
#line 152
  sf = s_f;
#line 154
  i = 0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;

#line 154
    if (! (i < 160)) {
#line 154
      goto while_break;
    }
#line 154
    *(sf + i) = (float )*(s + i);
#line 154
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 155
  k = 0;
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 155
    if (! (k <= 8)) {
#line 155
      goto while_break___0;
    }
#line 156
    L_temp2 = (float )0;
#line 157
    sfl = sf - k;
#line 158
    i = k;
    {
#line 158
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 158
      if (! (i < 160)) {
#line 158
        goto while_break___1;
      }
#line 158
      L_temp2 += *(sf + i) * *(sfl + i);
#line 158
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 159
    f_L_ACF[k] = L_temp2;
#line 155
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 161
  scale = (float )2147483647 / f_L_ACF[0];
#line 163
  k = 0;
  {
#line 163
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 163
    if (! (k <= 8)) {
#line 163
      goto while_break___2;
    }
#line 164
    *(L_ACF + k) = (int32_t )(f_L_ACF[k] * scale);
#line 163
    k ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 167
  return;
}
}
#line 170 "/root/patchweave_donee/23/src/GSM610/lpc.c"
static void Reflection_coefficients(int32_t *L_ACF , int16_t *r ) 
{ 
  register int i ;
  register int m ;
  register int n ;
  register int16_t temp ;
  int16_t ACF[9] ;
  int16_t P[9] ;
  int16_t K[9] ;
  int __cil_tmp10 ;
  int16_t *__cil_tmp11 ;
  int32_t __cil_tmp15 ;
  int32_t __cil_tmp16 ;
  int16_t *__cil_tmp21 ;
  int32_t __cil_tmp26 ;
  int32_t __cil_tmp27 ;
  int32_t __cil_tmp28 ;
  int32_t __cil_tmp29 ;
  int32_t __cil_tmp30 ;
  int32_t __cil_tmp31 ;
  int __cil_tmp33 ;
  int16_t *__cil_tmp34 ;

  {
#line 184
  if (*(L_ACF + 0) == 0) {
#line 185
    i = 8;
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;

#line 185
      if (! __cil_tmp10) {
#line 185
        goto while_break;
      }
#line 185
      __cil_tmp11 = r;
#line 185
      r ++;
#line 185
      *__cil_tmp11 = (int16_t )0;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: ;
#line 186
    return;
  }
  {
#line 190
  temp = gsm_norm(*(L_ACF + 0));
#line 195
  i = 0;
  }
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 195
    if (! (i <= 8)) {
#line 195
      goto while_break___0;
    }
    {
#line 195
    __cil_tmp15 = SASL_L(*(L_ACF + i), temp);
#line 195
    __cil_tmp16 = SASR_L(__cil_tmp15, (int16_t )16);
#line 195
    ACF[i] = (int16_t )__cil_tmp16;
#line 195
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___0: 
#line 200
  i = 1;
  {
#line 200
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 200
    if (! (i <= 7)) {
#line 200
      goto while_break___1;
    }
#line 200
    K[i] = ACF[i];
#line 200
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: 
#line 201
  i = 0;
  {
#line 201
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 201
    if (! (i <= 8)) {
#line 201
      goto while_break___2;
    }
#line 201
    P[i] = ACF[i];
#line 201
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___2: 
#line 205
  n = 1;
  {
#line 205
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 205
    if (! (n <= 8)) {
#line 205
      goto while_break___3;
    }
    {
#line 206
    temp = P[1];
#line 207
    temp = GSM_ABS(temp);
    }
#line 208
    if ((int )P[0] < (int )temp) {
#line 209
      i = n;
      {
#line 209
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 209
        if (! (i <= 8)) {
#line 209
          goto while_break___4;
        }
#line 209
        __cil_tmp21 = r;
#line 209
        r ++;
#line 209
        *__cil_tmp21 = (int16_t )0;
#line 209
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: ;
#line 210
      return;
    }
    {
#line 213
    *r = gsm_div(temp, P[0]);
    }
#line 216
    if ((int )P[1] > 0) {
#line 216
      *r = (int16_t )(- ((int )*r));
    }
#line 218
    if (n == 8) {
#line 218
      return;
    }
    {
#line 222
    __cil_tmp26 = GSM_MULT_R(P[1], *r);
#line 222
    temp = (int16_t )__cil_tmp26;
#line 223
    __cil_tmp27 = GSM_ADD(P[0], temp);
#line 223
    P[0] = (int16_t )__cil_tmp27;
#line 225
    m = 1;
    }
    {
#line 225
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 225
      if (! (m <= 8 - n)) {
#line 225
        goto while_break___5;
      }
      {
#line 226
      __cil_tmp28 = GSM_MULT_R(K[m], *r);
#line 226
      temp = (int16_t )__cil_tmp28;
#line 227
      __cil_tmp29 = GSM_ADD(P[m + 1], temp);
#line 227
      P[m] = (int16_t )__cil_tmp29;
#line 229
      __cil_tmp30 = GSM_MULT_R(P[m + 1], *r);
#line 229
      temp = (int16_t )__cil_tmp30;
#line 230
      __cil_tmp31 = GSM_ADD(K[m], temp);
#line 230
      K[m] = (int16_t )__cil_tmp31;
#line 225
      m ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___5: 
#line 205
    __cil_tmp34 = r;
#line 205
    r ++;
#line 205
    __cil_tmp33 = n;
#line 205
    n ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___3: ;
#line 209
  return;
}
}
#line 237 "/root/patchweave_donee/23/src/GSM610/lpc.c"
static void Transformation_to_Log_Area_Ratios(int16_t *r ) 
{ 
  register int16_t temp ;
  register int i ;
  int tmp___2 ;
  int __cil_tmp10 ;
  int16_t *__cil_tmp11 ;

  {
#line 254
  i = 1;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;

#line 254
    if (! (i <= 8)) {
#line 254
      goto while_break;
    }
    {
#line 255
    temp = *r;
#line 256
    temp = GSM_ABS(temp);
    }
#line 259
    if ((int )temp < 22118) {
#line 260
      temp = (int16_t )((int )temp >> 1);
    } else
#line 262
    if ((int )temp < 31130) {
#line 264
      temp = (int16_t )((int )temp - 11059);
    } else {
#line 268
      temp = (int16_t )((int )temp - 26112);
#line 269
      temp = (int16_t )((int )temp << 2);
    }
#line 272
    if ((int )*r < 0) {
#line 272
      tmp___2 = - ((int )temp);
    } else {
#line 272
      tmp___2 = (int )temp;
    }
#line 272
    *r = (int16_t )tmp___2;
#line 254
    __cil_tmp11 = r;
#line 254
    r ++;
#line 254
    __cil_tmp10 = i;
#line 254
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 258
  return;
}
}
#line 279 "/root/patchweave_donee/23/src/GSM610/lpc.c"
static void Quantization_and_coding(int16_t *LAR ) 
{ 
  register int16_t temp ;
  int32_t __cil_tmp3 ;
  int32_t __cil_tmp4 ;
  int32_t __cil_tmp5 ;
  int tmp ;
  int tmp___0 ;
  int32_t __cil_tmp10 ;
  int32_t __cil_tmp11 ;
  int32_t __cil_tmp12 ;
  int tmp___1 ;
  int tmp___2 ;
  int32_t __cil_tmp17 ;
  int32_t __cil_tmp18 ;
  int32_t __cil_tmp19 ;
  int tmp___3 ;
  int tmp___4 ;
  int32_t __cil_tmp24 ;
  int32_t __cil_tmp25 ;
  int32_t __cil_tmp26 ;
  int tmp___5 ;
  int tmp___6 ;
  int32_t __cil_tmp31 ;
  int32_t __cil_tmp32 ;
  int32_t __cil_tmp33 ;
  int tmp___7 ;
  int tmp___8 ;
  int32_t __cil_tmp38 ;
  int32_t __cil_tmp39 ;
  int32_t __cil_tmp40 ;
  int tmp___9 ;
  int tmp___10 ;
  int32_t __cil_tmp45 ;
  int32_t __cil_tmp46 ;
  int32_t __cil_tmp47 ;
  int tmp___11 ;
  int tmp___12 ;
  int32_t __cil_tmp52 ;
  int32_t __cil_tmp53 ;
  int32_t __cil_tmp54 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 303
  __cil_tmp3 = GSM_MULT((int16_t )20480, *LAR);
#line 303
  temp = (int16_t )__cil_tmp3;
#line 303
  __cil_tmp4 = GSM_ADD(temp, (int16_t )0);
#line 303
  temp = (int16_t )__cil_tmp4;
#line 303
  __cil_tmp5 = GSM_ADD(temp, (int16_t )256);
#line 303
  temp = (int16_t )__cil_tmp5;
#line 303
  temp = SASR_W(temp, (int16_t )9);
  }
#line 303
  if ((int )temp > 31) {
#line 303
    tmp___0 = 63;
  } else {
#line 303
    if ((int )temp < -32) {
#line 303
      tmp = 0;
    } else {
#line 303
      tmp = (int )temp - -32;
    }
#line 303
    tmp___0 = tmp;
  }
  {
#line 303
  *LAR = (int16_t )tmp___0;
#line 303
  LAR ++;
#line 304
  __cil_tmp10 = GSM_MULT((int16_t )20480, *LAR);
#line 304
  temp = (int16_t )__cil_tmp10;
#line 304
  __cil_tmp11 = GSM_ADD(temp, (int16_t )0);
#line 304
  temp = (int16_t )__cil_tmp11;
#line 304
  __cil_tmp12 = GSM_ADD(temp, (int16_t )256);
#line 304
  temp = (int16_t )__cil_tmp12;
#line 304
  temp = SASR_W(temp, (int16_t )9);
  }
#line 304
  if ((int )temp > 31) {
#line 304
    tmp___2 = 63;
  } else {
#line 304
    if ((int )temp < -32) {
#line 304
      tmp___1 = 0;
    } else {
#line 304
      tmp___1 = (int )temp - -32;
    }
#line 304
    tmp___2 = tmp___1;
  }
  {
#line 304
  *LAR = (int16_t )tmp___2;
#line 304
  LAR ++;
#line 305
  __cil_tmp17 = GSM_MULT((int16_t )20480, *LAR);
#line 305
  temp = (int16_t )__cil_tmp17;
#line 305
  __cil_tmp18 = GSM_ADD(temp, (int16_t )2048);
#line 305
  temp = (int16_t )__cil_tmp18;
#line 305
  __cil_tmp19 = GSM_ADD(temp, (int16_t )256);
#line 305
  temp = (int16_t )__cil_tmp19;
#line 305
  temp = SASR_W(temp, (int16_t )9);
  }
#line 305
  if ((int )temp > 15) {
#line 305
    tmp___4 = 31;
  } else {
#line 305
    if ((int )temp < -16) {
#line 305
      tmp___3 = 0;
    } else {
#line 305
      tmp___3 = (int )temp - -16;
    }
#line 305
    tmp___4 = tmp___3;
  }
  {
#line 305
  *LAR = (int16_t )tmp___4;
#line 305
  LAR ++;
#line 306
  __cil_tmp24 = GSM_MULT((int16_t )20480, *LAR);
#line 306
  temp = (int16_t )__cil_tmp24;
#line 306
  __cil_tmp25 = GSM_ADD(temp, (int16_t )-2560);
#line 306
  temp = (int16_t )__cil_tmp25;
#line 306
  __cil_tmp26 = GSM_ADD(temp, (int16_t )256);
#line 306
  temp = (int16_t )__cil_tmp26;
#line 306
  temp = SASR_W(temp, (int16_t )9);
  }
#line 306
  if ((int )temp > 15) {
#line 306
    tmp___6 = 31;
  } else {
#line 306
    if ((int )temp < -16) {
#line 306
      tmp___5 = 0;
    } else {
#line 306
      tmp___5 = (int )temp - -16;
    }
#line 306
    tmp___6 = tmp___5;
  }
  {
#line 306
  *LAR = (int16_t )tmp___6;
#line 306
  LAR ++;
#line 308
  __cil_tmp31 = GSM_MULT((int16_t )13964, *LAR);
#line 308
  temp = (int16_t )__cil_tmp31;
#line 308
  __cil_tmp32 = GSM_ADD(temp, (int16_t )94);
#line 308
  temp = (int16_t )__cil_tmp32;
#line 308
  __cil_tmp33 = GSM_ADD(temp, (int16_t )256);
#line 308
  temp = (int16_t )__cil_tmp33;
#line 308
  temp = SASR_W(temp, (int16_t )9);
  }
#line 308
  if ((int )temp > 7) {
#line 308
    tmp___8 = 15;
  } else {
#line 308
    if ((int )temp < -8) {
#line 308
      tmp___7 = 0;
    } else {
#line 308
      tmp___7 = (int )temp - -8;
    }
#line 308
    tmp___8 = tmp___7;
  }
  {
#line 308
  *LAR = (int16_t )tmp___8;
#line 308
  LAR ++;
#line 309
  __cil_tmp38 = GSM_MULT((int16_t )15360, *LAR);
#line 309
  temp = (int16_t )__cil_tmp38;
#line 309
  __cil_tmp39 = GSM_ADD(temp, (int16_t )-1792);
#line 309
  temp = (int16_t )__cil_tmp39;
#line 309
  __cil_tmp40 = GSM_ADD(temp, (int16_t )256);
#line 309
  temp = (int16_t )__cil_tmp40;
#line 309
  temp = SASR_W(temp, (int16_t )9);
  }
#line 309
  if ((int )temp > 7) {
#line 309
    tmp___10 = 15;
  } else {
#line 309
    if ((int )temp < -8) {
#line 309
      tmp___9 = 0;
    } else {
#line 309
      tmp___9 = (int )temp - -8;
    }
#line 309
    tmp___10 = tmp___9;
  }
  {
#line 309
  *LAR = (int16_t )tmp___10;
#line 309
  LAR ++;
#line 310
  __cil_tmp45 = GSM_MULT((int16_t )8534, *LAR);
#line 310
  temp = (int16_t )__cil_tmp45;
#line 310
  __cil_tmp46 = GSM_ADD(temp, (int16_t )-341);
#line 310
  temp = (int16_t )__cil_tmp46;
#line 310
  __cil_tmp47 = GSM_ADD(temp, (int16_t )256);
#line 310
  temp = (int16_t )__cil_tmp47;
#line 310
  temp = SASR_W(temp, (int16_t )9);
  }
#line 310
  if ((int )temp > 3) {
#line 310
    tmp___12 = 7;
  } else {
#line 310
    if ((int )temp < -4) {
#line 310
      tmp___11 = 0;
    } else {
#line 310
      tmp___11 = (int )temp - -4;
    }
#line 310
    tmp___12 = tmp___11;
  }
  {
#line 310
  *LAR = (int16_t )tmp___12;
#line 310
  LAR ++;
#line 311
  __cil_tmp52 = GSM_MULT((int16_t )9036, *LAR);
#line 311
  temp = (int16_t )__cil_tmp52;
#line 311
  __cil_tmp53 = GSM_ADD(temp, (int16_t )-1144);
#line 311
  temp = (int16_t )__cil_tmp53;
#line 311
  __cil_tmp54 = GSM_ADD(temp, (int16_t )256);
#line 311
  temp = (int16_t )__cil_tmp54;
#line 311
  temp = SASR_W(temp, (int16_t )9);
  }
#line 311
  if ((int )temp > 3) {
#line 311
    tmp___14 = 7;
  } else {
#line 311
    if ((int )temp < -4) {
#line 311
      tmp___13 = 0;
    } else {
#line 311
      tmp___13 = (int )temp - -4;
    }
#line 311
    tmp___14 = tmp___13;
  }
#line 311
  *LAR = (int16_t )tmp___14;
#line 311
  LAR ++;
#line 312
  return;
}
}
#line 316 "/root/patchweave_donee/23/src/GSM610/lpc.c"
void Gsm_LPC_Analysis(struct gsm_state *S , int16_t *s , int16_t *LARc ) 
{ 
  int32_t L_ACF[9] ;

  {
#line 324
  if (S->fast) {
    {
#line 325
    Fast_Autocorrelation(s, L_ACF);
    }
  } else {
    {
#line 328
    Autocorrelation(s, L_ACF);
    }
  }
  {
#line 329
  Reflection_coefficients(L_ACF, LARc);
#line 330
  Transformation_to_Log_Area_Ratios(LARc);
#line 331
  Quantization_and_coding(LARc);
  }
#line 333
  return;
}
}
#line 462 "/root/patchweave_donee/23/src/GSM610/long_term.c"
static void Calculation_of_the_LTP_parameters(int16_t *din , int16_t *dp , int16_t *bc_out ,
                                              int16_t *Nc_out ) 
{ 
  register int k ;
  register int lambda ;
  int16_t Nc ;
  int16_t bc ;
  float wt_float[40] ;
  float dp_float_base[120] ;
  float *dp_float ;
  int32_t L_max ;
  int32_t L_power ;
  int16_t R ;
  int16_t S ;
  int16_t dmax ;
  int16_t scal ;
  register int16_t temp ;
  int16_t __cil_tmp24 ;
  register float *lp ;
  register float W ;
  register float a ;
  register float b ;
  register float c ;
  register float d ;
  register float e ;
  register float f ;
  register float g ;
  register float h ;
  register float E ;
  register float S0 ;
  register float S1 ;
  register float S2 ;
  register float S3 ;
  register float S4 ;
  register float S5 ;
  register float S6 ;
  register float S7 ;
  register float S8 ;
  register int32_t L_temp ;
  int16_t __cil_tmp50 ;
  int32_t __cil_tmp53 ;
  int32_t __cil_tmp54 ;
  int16_t __cil_tmp55 ;

  {
#line 472
  dp_float = dp_float_base + 120;
#line 480
  dmax = (int16_t )0;
#line 482
  k = 0;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;

#line 482
    if (! (k <= 39)) {
#line 482
      goto while_break;
    }
    {
#line 483
    temp = *(din + k);
#line 484
    temp = GSM_ABS(temp);
    }
#line 485
    if ((int )temp > (int )dmax) {
#line 485
      dmax = temp;
    }
#line 482
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 488
  temp = (int16_t )0;
#line 489
  if ((int )dmax == 0) {
#line 489
    scal = (int16_t )0;
  } else {
    {
#line 492
    temp = gsm_norm((int32_t )dmax << 16);
    }
  }
#line 495
  if ((int )temp > 6) {
#line 495
    scal = (int16_t )0;
  } else {
#line 496
    scal = (int16_t )(6 - (int )temp);
  }
#line 502
  k = 0;
  {
#line 502
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 502
    if (! (k < 40)) {
#line 502
      goto while_break___0;
    }
    {
#line 502
    __cil_tmp24 = SASR_W(*(din + k), scal);
#line 502
    wt_float[k] = (float )__cil_tmp24;
#line 502
    k ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 503
  k = -120;
  {
#line 503
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 503
    if (! (k < 0)) {
#line 503
      goto while_break___1;
    }
#line 503
    *(dp_float + k) = (float )*(dp + k);
#line 503
    k ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: 
#line 507
  L_max = 0;
#line 508
  Nc = (int16_t )40;
#line 510
  lambda = 40;
  {
#line 510
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 510
    if (! (lambda <= 120)) {
#line 510
      goto while_break___2;
    }
#line 512
    lp = dp_float - lambda;
#line 515
    a = *(lp + -8);
#line 515
    b = *(lp + -7);
#line 515
    c = *(lp + -6);
#line 515
    d = *(lp + -5);
#line 515
    e = *(lp + -4);
#line 515
    f = *(lp + -3);
#line 515
    g = *(lp + -2);
#line 515
    h = *(lp + -1);
#line 519
    S0 = (float )0;
#line 519
    S1 = (float )0;
#line 519
    S2 = (float )0;
#line 519
    S3 = (float )0;
#line 519
    S4 = (float )0;
#line 519
    S5 = (float )0;
#line 519
    S6 = (float )0;
#line 519
    S7 = (float )0;
#line 519
    S8 = (float )0;
#line 545
    W = wt_float[0];
#line 545
    E = W * a;
#line 545
    S8 += E;
#line 545
    E = W * b;
#line 545
    S7 += E;
#line 545
    E = W * c;
#line 545
    S6 += E;
#line 545
    E = W * d;
#line 545
    S5 += E;
#line 545
    E = W * e;
#line 545
    S4 += E;
#line 545
    E = W * f;
#line 545
    S3 += E;
#line 545
    E = W * g;
#line 545
    S2 += E;
#line 545
    E = W * h;
#line 545
    S1 += E;
#line 545
    a = *(lp + 0);
#line 545
    E = W * a;
#line 545
    S0 += E;
#line 545
    W = wt_float[1];
#line 545
    E = W * b;
#line 545
    S8 += E;
#line 545
    E = W * c;
#line 545
    S7 += E;
#line 545
    E = W * d;
#line 545
    S6 += E;
#line 545
    E = W * e;
#line 545
    S5 += E;
#line 545
    E = W * f;
#line 545
    S4 += E;
#line 545
    E = W * g;
#line 545
    S3 += E;
#line 545
    E = W * h;
#line 545
    S2 += E;
#line 545
    E = W * a;
#line 545
    S1 += E;
#line 545
    b = *(lp + 1);
#line 545
    E = W * b;
#line 545
    S0 += E;
#line 545
    W = wt_float[2];
#line 545
    E = W * c;
#line 545
    S8 += E;
#line 545
    E = W * d;
#line 545
    S7 += E;
#line 545
    E = W * e;
#line 545
    S6 += E;
#line 545
    E = W * f;
#line 545
    S5 += E;
#line 545
    E = W * g;
#line 545
    S4 += E;
#line 545
    E = W * h;
#line 545
    S3 += E;
#line 545
    E = W * a;
#line 545
    S2 += E;
#line 545
    E = W * b;
#line 545
    S1 += E;
#line 545
    c = *(lp + 2);
#line 545
    E = W * c;
#line 545
    S0 += E;
#line 545
    W = wt_float[3];
#line 545
    E = W * d;
#line 545
    S8 += E;
#line 545
    E = W * e;
#line 545
    S7 += E;
#line 545
    E = W * f;
#line 545
    S6 += E;
#line 545
    E = W * g;
#line 545
    S5 += E;
#line 545
    E = W * h;
#line 545
    S4 += E;
#line 545
    E = W * a;
#line 545
    S3 += E;
#line 545
    E = W * b;
#line 545
    S2 += E;
#line 545
    E = W * c;
#line 545
    S1 += E;
#line 545
    d = *(lp + 3);
#line 545
    E = W * d;
#line 545
    S0 += E;
#line 546
    W = wt_float[4];
#line 546
    E = W * e;
#line 546
    S8 += E;
#line 546
    E = W * f;
#line 546
    S7 += E;
#line 546
    E = W * g;
#line 546
    S6 += E;
#line 546
    E = W * h;
#line 546
    S5 += E;
#line 546
    E = W * a;
#line 546
    S4 += E;
#line 546
    E = W * b;
#line 546
    S3 += E;
#line 546
    E = W * c;
#line 546
    S2 += E;
#line 546
    E = W * d;
#line 546
    S1 += E;
#line 546
    e = *(lp + 4);
#line 546
    E = W * e;
#line 546
    S0 += E;
#line 546
    W = wt_float[5];
#line 546
    E = W * f;
#line 546
    S8 += E;
#line 546
    E = W * g;
#line 546
    S7 += E;
#line 546
    E = W * h;
#line 546
    S6 += E;
#line 546
    E = W * a;
#line 546
    S5 += E;
#line 546
    E = W * b;
#line 546
    S4 += E;
#line 546
    E = W * c;
#line 546
    S3 += E;
#line 546
    E = W * d;
#line 546
    S2 += E;
#line 546
    E = W * e;
#line 546
    S1 += E;
#line 546
    f = *(lp + 5);
#line 546
    E = W * f;
#line 546
    S0 += E;
#line 546
    W = wt_float[6];
#line 546
    E = W * g;
#line 546
    S8 += E;
#line 546
    E = W * h;
#line 546
    S7 += E;
#line 546
    E = W * a;
#line 546
    S6 += E;
#line 546
    E = W * b;
#line 546
    S5 += E;
#line 546
    E = W * c;
#line 546
    S4 += E;
#line 546
    E = W * d;
#line 546
    S3 += E;
#line 546
    E = W * e;
#line 546
    S2 += E;
#line 546
    E = W * f;
#line 546
    S1 += E;
#line 546
    g = *(lp + 6);
#line 546
    E = W * g;
#line 546
    S0 += E;
#line 546
    W = wt_float[7];
#line 546
    E = W * h;
#line 546
    S8 += E;
#line 546
    E = W * a;
#line 546
    S7 += E;
#line 546
    E = W * b;
#line 546
    S6 += E;
#line 546
    E = W * c;
#line 546
    S5 += E;
#line 546
    E = W * d;
#line 546
    S4 += E;
#line 546
    E = W * e;
#line 546
    S3 += E;
#line 546
    E = W * f;
#line 546
    S2 += E;
#line 546
    E = W * g;
#line 546
    S1 += E;
#line 546
    h = *(lp + 7);
#line 546
    E = W * h;
#line 546
    S0 += E;
#line 548
    W = wt_float[8];
#line 548
    E = W * a;
#line 548
    S8 += E;
#line 548
    E = W * b;
#line 548
    S7 += E;
#line 548
    E = W * c;
#line 548
    S6 += E;
#line 548
    E = W * d;
#line 548
    S5 += E;
#line 548
    E = W * e;
#line 548
    S4 += E;
#line 548
    E = W * f;
#line 548
    S3 += E;
#line 548
    E = W * g;
#line 548
    S2 += E;
#line 548
    E = W * h;
#line 548
    S1 += E;
#line 548
    a = *(lp + 8);
#line 548
    E = W * a;
#line 548
    S0 += E;
#line 548
    W = wt_float[9];
#line 548
    E = W * b;
#line 548
    S8 += E;
#line 548
    E = W * c;
#line 548
    S7 += E;
#line 548
    E = W * d;
#line 548
    S6 += E;
#line 548
    E = W * e;
#line 548
    S5 += E;
#line 548
    E = W * f;
#line 548
    S4 += E;
#line 548
    E = W * g;
#line 548
    S3 += E;
#line 548
    E = W * h;
#line 548
    S2 += E;
#line 548
    E = W * a;
#line 548
    S1 += E;
#line 548
    b = *(lp + 9);
#line 548
    E = W * b;
#line 548
    S0 += E;
#line 548
    W = wt_float[10];
#line 548
    E = W * c;
#line 548
    S8 += E;
#line 548
    E = W * d;
#line 548
    S7 += E;
#line 548
    E = W * e;
#line 548
    S6 += E;
#line 548
    E = W * f;
#line 548
    S5 += E;
#line 548
    E = W * g;
#line 548
    S4 += E;
#line 548
    E = W * h;
#line 548
    S3 += E;
#line 548
    E = W * a;
#line 548
    S2 += E;
#line 548
    E = W * b;
#line 548
    S1 += E;
#line 548
    c = *(lp + 10);
#line 548
    E = W * c;
#line 548
    S0 += E;
#line 548
    W = wt_float[11];
#line 548
    E = W * d;
#line 548
    S8 += E;
#line 548
    E = W * e;
#line 548
    S7 += E;
#line 548
    E = W * f;
#line 548
    S6 += E;
#line 548
    E = W * g;
#line 548
    S5 += E;
#line 548
    E = W * h;
#line 548
    S4 += E;
#line 548
    E = W * a;
#line 548
    S3 += E;
#line 548
    E = W * b;
#line 548
    S2 += E;
#line 548
    E = W * c;
#line 548
    S1 += E;
#line 548
    d = *(lp + 11);
#line 548
    E = W * d;
#line 548
    S0 += E;
#line 549
    W = wt_float[12];
#line 549
    E = W * e;
#line 549
    S8 += E;
#line 549
    E = W * f;
#line 549
    S7 += E;
#line 549
    E = W * g;
#line 549
    S6 += E;
#line 549
    E = W * h;
#line 549
    S5 += E;
#line 549
    E = W * a;
#line 549
    S4 += E;
#line 549
    E = W * b;
#line 549
    S3 += E;
#line 549
    E = W * c;
#line 549
    S2 += E;
#line 549
    E = W * d;
#line 549
    S1 += E;
#line 549
    e = *(lp + 12);
#line 549
    E = W * e;
#line 549
    S0 += E;
#line 549
    W = wt_float[13];
#line 549
    E = W * f;
#line 549
    S8 += E;
#line 549
    E = W * g;
#line 549
    S7 += E;
#line 549
    E = W * h;
#line 549
    S6 += E;
#line 549
    E = W * a;
#line 549
    S5 += E;
#line 549
    E = W * b;
#line 549
    S4 += E;
#line 549
    E = W * c;
#line 549
    S3 += E;
#line 549
    E = W * d;
#line 549
    S2 += E;
#line 549
    E = W * e;
#line 549
    S1 += E;
#line 549
    f = *(lp + 13);
#line 549
    E = W * f;
#line 549
    S0 += E;
#line 549
    W = wt_float[14];
#line 549
    E = W * g;
#line 549
    S8 += E;
#line 549
    E = W * h;
#line 549
    S7 += E;
#line 549
    E = W * a;
#line 549
    S6 += E;
#line 549
    E = W * b;
#line 549
    S5 += E;
#line 549
    E = W * c;
#line 549
    S4 += E;
#line 549
    E = W * d;
#line 549
    S3 += E;
#line 549
    E = W * e;
#line 549
    S2 += E;
#line 549
    E = W * f;
#line 549
    S1 += E;
#line 549
    g = *(lp + 14);
#line 549
    E = W * g;
#line 549
    S0 += E;
#line 549
    W = wt_float[15];
#line 549
    E = W * h;
#line 549
    S8 += E;
#line 549
    E = W * a;
#line 549
    S7 += E;
#line 549
    E = W * b;
#line 549
    S6 += E;
#line 549
    E = W * c;
#line 549
    S5 += E;
#line 549
    E = W * d;
#line 549
    S4 += E;
#line 549
    E = W * e;
#line 549
    S3 += E;
#line 549
    E = W * f;
#line 549
    S2 += E;
#line 549
    E = W * g;
#line 549
    S1 += E;
#line 549
    h = *(lp + 15);
#line 549
    E = W * h;
#line 549
    S0 += E;
#line 551
    W = wt_float[16];
#line 551
    E = W * a;
#line 551
    S8 += E;
#line 551
    E = W * b;
#line 551
    S7 += E;
#line 551
    E = W * c;
#line 551
    S6 += E;
#line 551
    E = W * d;
#line 551
    S5 += E;
#line 551
    E = W * e;
#line 551
    S4 += E;
#line 551
    E = W * f;
#line 551
    S3 += E;
#line 551
    E = W * g;
#line 551
    S2 += E;
#line 551
    E = W * h;
#line 551
    S1 += E;
#line 551
    a = *(lp + 16);
#line 551
    E = W * a;
#line 551
    S0 += E;
#line 551
    W = wt_float[17];
#line 551
    E = W * b;
#line 551
    S8 += E;
#line 551
    E = W * c;
#line 551
    S7 += E;
#line 551
    E = W * d;
#line 551
    S6 += E;
#line 551
    E = W * e;
#line 551
    S5 += E;
#line 551
    E = W * f;
#line 551
    S4 += E;
#line 551
    E = W * g;
#line 551
    S3 += E;
#line 551
    E = W * h;
#line 551
    S2 += E;
#line 551
    E = W * a;
#line 551
    S1 += E;
#line 551
    b = *(lp + 17);
#line 551
    E = W * b;
#line 551
    S0 += E;
#line 551
    W = wt_float[18];
#line 551
    E = W * c;
#line 551
    S8 += E;
#line 551
    E = W * d;
#line 551
    S7 += E;
#line 551
    E = W * e;
#line 551
    S6 += E;
#line 551
    E = W * f;
#line 551
    S5 += E;
#line 551
    E = W * g;
#line 551
    S4 += E;
#line 551
    E = W * h;
#line 551
    S3 += E;
#line 551
    E = W * a;
#line 551
    S2 += E;
#line 551
    E = W * b;
#line 551
    S1 += E;
#line 551
    c = *(lp + 18);
#line 551
    E = W * c;
#line 551
    S0 += E;
#line 551
    W = wt_float[19];
#line 551
    E = W * d;
#line 551
    S8 += E;
#line 551
    E = W * e;
#line 551
    S7 += E;
#line 551
    E = W * f;
#line 551
    S6 += E;
#line 551
    E = W * g;
#line 551
    S5 += E;
#line 551
    E = W * h;
#line 551
    S4 += E;
#line 551
    E = W * a;
#line 551
    S3 += E;
#line 551
    E = W * b;
#line 551
    S2 += E;
#line 551
    E = W * c;
#line 551
    S1 += E;
#line 551
    d = *(lp + 19);
#line 551
    E = W * d;
#line 551
    S0 += E;
#line 552
    W = wt_float[20];
#line 552
    E = W * e;
#line 552
    S8 += E;
#line 552
    E = W * f;
#line 552
    S7 += E;
#line 552
    E = W * g;
#line 552
    S6 += E;
#line 552
    E = W * h;
#line 552
    S5 += E;
#line 552
    E = W * a;
#line 552
    S4 += E;
#line 552
    E = W * b;
#line 552
    S3 += E;
#line 552
    E = W * c;
#line 552
    S2 += E;
#line 552
    E = W * d;
#line 552
    S1 += E;
#line 552
    e = *(lp + 20);
#line 552
    E = W * e;
#line 552
    S0 += E;
#line 552
    W = wt_float[21];
#line 552
    E = W * f;
#line 552
    S8 += E;
#line 552
    E = W * g;
#line 552
    S7 += E;
#line 552
    E = W * h;
#line 552
    S6 += E;
#line 552
    E = W * a;
#line 552
    S5 += E;
#line 552
    E = W * b;
#line 552
    S4 += E;
#line 552
    E = W * c;
#line 552
    S3 += E;
#line 552
    E = W * d;
#line 552
    S2 += E;
#line 552
    E = W * e;
#line 552
    S1 += E;
#line 552
    f = *(lp + 21);
#line 552
    E = W * f;
#line 552
    S0 += E;
#line 552
    W = wt_float[22];
#line 552
    E = W * g;
#line 552
    S8 += E;
#line 552
    E = W * h;
#line 552
    S7 += E;
#line 552
    E = W * a;
#line 552
    S6 += E;
#line 552
    E = W * b;
#line 552
    S5 += E;
#line 552
    E = W * c;
#line 552
    S4 += E;
#line 552
    E = W * d;
#line 552
    S3 += E;
#line 552
    E = W * e;
#line 552
    S2 += E;
#line 552
    E = W * f;
#line 552
    S1 += E;
#line 552
    g = *(lp + 22);
#line 552
    E = W * g;
#line 552
    S0 += E;
#line 552
    W = wt_float[23];
#line 552
    E = W * h;
#line 552
    S8 += E;
#line 552
    E = W * a;
#line 552
    S7 += E;
#line 552
    E = W * b;
#line 552
    S6 += E;
#line 552
    E = W * c;
#line 552
    S5 += E;
#line 552
    E = W * d;
#line 552
    S4 += E;
#line 552
    E = W * e;
#line 552
    S3 += E;
#line 552
    E = W * f;
#line 552
    S2 += E;
#line 552
    E = W * g;
#line 552
    S1 += E;
#line 552
    h = *(lp + 23);
#line 552
    E = W * h;
#line 552
    S0 += E;
#line 554
    W = wt_float[24];
#line 554
    E = W * a;
#line 554
    S8 += E;
#line 554
    E = W * b;
#line 554
    S7 += E;
#line 554
    E = W * c;
#line 554
    S6 += E;
#line 554
    E = W * d;
#line 554
    S5 += E;
#line 554
    E = W * e;
#line 554
    S4 += E;
#line 554
    E = W * f;
#line 554
    S3 += E;
#line 554
    E = W * g;
#line 554
    S2 += E;
#line 554
    E = W * h;
#line 554
    S1 += E;
#line 554
    a = *(lp + 24);
#line 554
    E = W * a;
#line 554
    S0 += E;
#line 554
    W = wt_float[25];
#line 554
    E = W * b;
#line 554
    S8 += E;
#line 554
    E = W * c;
#line 554
    S7 += E;
#line 554
    E = W * d;
#line 554
    S6 += E;
#line 554
    E = W * e;
#line 554
    S5 += E;
#line 554
    E = W * f;
#line 554
    S4 += E;
#line 554
    E = W * g;
#line 554
    S3 += E;
#line 554
    E = W * h;
#line 554
    S2 += E;
#line 554
    E = W * a;
#line 554
    S1 += E;
#line 554
    b = *(lp + 25);
#line 554
    E = W * b;
#line 554
    S0 += E;
#line 554
    W = wt_float[26];
#line 554
    E = W * c;
#line 554
    S8 += E;
#line 554
    E = W * d;
#line 554
    S7 += E;
#line 554
    E = W * e;
#line 554
    S6 += E;
#line 554
    E = W * f;
#line 554
    S5 += E;
#line 554
    E = W * g;
#line 554
    S4 += E;
#line 554
    E = W * h;
#line 554
    S3 += E;
#line 554
    E = W * a;
#line 554
    S2 += E;
#line 554
    E = W * b;
#line 554
    S1 += E;
#line 554
    c = *(lp + 26);
#line 554
    E = W * c;
#line 554
    S0 += E;
#line 554
    W = wt_float[27];
#line 554
    E = W * d;
#line 554
    S8 += E;
#line 554
    E = W * e;
#line 554
    S7 += E;
#line 554
    E = W * f;
#line 554
    S6 += E;
#line 554
    E = W * g;
#line 554
    S5 += E;
#line 554
    E = W * h;
#line 554
    S4 += E;
#line 554
    E = W * a;
#line 554
    S3 += E;
#line 554
    E = W * b;
#line 554
    S2 += E;
#line 554
    E = W * c;
#line 554
    S1 += E;
#line 554
    d = *(lp + 27);
#line 554
    E = W * d;
#line 554
    S0 += E;
#line 555
    W = wt_float[28];
#line 555
    E = W * e;
#line 555
    S8 += E;
#line 555
    E = W * f;
#line 555
    S7 += E;
#line 555
    E = W * g;
#line 555
    S6 += E;
#line 555
    E = W * h;
#line 555
    S5 += E;
#line 555
    E = W * a;
#line 555
    S4 += E;
#line 555
    E = W * b;
#line 555
    S3 += E;
#line 555
    E = W * c;
#line 555
    S2 += E;
#line 555
    E = W * d;
#line 555
    S1 += E;
#line 555
    e = *(lp + 28);
#line 555
    E = W * e;
#line 555
    S0 += E;
#line 555
    W = wt_float[29];
#line 555
    E = W * f;
#line 555
    S8 += E;
#line 555
    E = W * g;
#line 555
    S7 += E;
#line 555
    E = W * h;
#line 555
    S6 += E;
#line 555
    E = W * a;
#line 555
    S5 += E;
#line 555
    E = W * b;
#line 555
    S4 += E;
#line 555
    E = W * c;
#line 555
    S3 += E;
#line 555
    E = W * d;
#line 555
    S2 += E;
#line 555
    E = W * e;
#line 555
    S1 += E;
#line 555
    f = *(lp + 29);
#line 555
    E = W * f;
#line 555
    S0 += E;
#line 555
    W = wt_float[30];
#line 555
    E = W * g;
#line 555
    S8 += E;
#line 555
    E = W * h;
#line 555
    S7 += E;
#line 555
    E = W * a;
#line 555
    S6 += E;
#line 555
    E = W * b;
#line 555
    S5 += E;
#line 555
    E = W * c;
#line 555
    S4 += E;
#line 555
    E = W * d;
#line 555
    S3 += E;
#line 555
    E = W * e;
#line 555
    S2 += E;
#line 555
    E = W * f;
#line 555
    S1 += E;
#line 555
    g = *(lp + 30);
#line 555
    E = W * g;
#line 555
    S0 += E;
#line 555
    W = wt_float[31];
#line 555
    E = W * h;
#line 555
    S8 += E;
#line 555
    E = W * a;
#line 555
    S7 += E;
#line 555
    E = W * b;
#line 555
    S6 += E;
#line 555
    E = W * c;
#line 555
    S5 += E;
#line 555
    E = W * d;
#line 555
    S4 += E;
#line 555
    E = W * e;
#line 555
    S3 += E;
#line 555
    E = W * f;
#line 555
    S2 += E;
#line 555
    E = W * g;
#line 555
    S1 += E;
#line 555
    h = *(lp + 31);
#line 555
    E = W * h;
#line 555
    S0 += E;
#line 557
    W = wt_float[32];
#line 557
    E = W * a;
#line 557
    S8 += E;
#line 557
    E = W * b;
#line 557
    S7 += E;
#line 557
    E = W * c;
#line 557
    S6 += E;
#line 557
    E = W * d;
#line 557
    S5 += E;
#line 557
    E = W * e;
#line 557
    S4 += E;
#line 557
    E = W * f;
#line 557
    S3 += E;
#line 557
    E = W * g;
#line 557
    S2 += E;
#line 557
    E = W * h;
#line 557
    S1 += E;
#line 557
    a = *(lp + 32);
#line 557
    E = W * a;
#line 557
    S0 += E;
#line 557
    W = wt_float[33];
#line 557
    E = W * b;
#line 557
    S8 += E;
#line 557
    E = W * c;
#line 557
    S7 += E;
#line 557
    E = W * d;
#line 557
    S6 += E;
#line 557
    E = W * e;
#line 557
    S5 += E;
#line 557
    E = W * f;
#line 557
    S4 += E;
#line 557
    E = W * g;
#line 557
    S3 += E;
#line 557
    E = W * h;
#line 557
    S2 += E;
#line 557
    E = W * a;
#line 557
    S1 += E;
#line 557
    b = *(lp + 33);
#line 557
    E = W * b;
#line 557
    S0 += E;
#line 557
    W = wt_float[34];
#line 557
    E = W * c;
#line 557
    S8 += E;
#line 557
    E = W * d;
#line 557
    S7 += E;
#line 557
    E = W * e;
#line 557
    S6 += E;
#line 557
    E = W * f;
#line 557
    S5 += E;
#line 557
    E = W * g;
#line 557
    S4 += E;
#line 557
    E = W * h;
#line 557
    S3 += E;
#line 557
    E = W * a;
#line 557
    S2 += E;
#line 557
    E = W * b;
#line 557
    S1 += E;
#line 557
    c = *(lp + 34);
#line 557
    E = W * c;
#line 557
    S0 += E;
#line 557
    W = wt_float[35];
#line 557
    E = W * d;
#line 557
    S8 += E;
#line 557
    E = W * e;
#line 557
    S7 += E;
#line 557
    E = W * f;
#line 557
    S6 += E;
#line 557
    E = W * g;
#line 557
    S5 += E;
#line 557
    E = W * h;
#line 557
    S4 += E;
#line 557
    E = W * a;
#line 557
    S3 += E;
#line 557
    E = W * b;
#line 557
    S2 += E;
#line 557
    E = W * c;
#line 557
    S1 += E;
#line 557
    d = *(lp + 35);
#line 557
    E = W * d;
#line 557
    S0 += E;
#line 558
    W = wt_float[36];
#line 558
    E = W * e;
#line 558
    S8 += E;
#line 558
    E = W * f;
#line 558
    S7 += E;
#line 558
    E = W * g;
#line 558
    S6 += E;
#line 558
    E = W * h;
#line 558
    S5 += E;
#line 558
    E = W * a;
#line 558
    S4 += E;
#line 558
    E = W * b;
#line 558
    S3 += E;
#line 558
    E = W * c;
#line 558
    S2 += E;
#line 558
    E = W * d;
#line 558
    S1 += E;
#line 558
    e = *(lp + 36);
#line 558
    E = W * e;
#line 558
    S0 += E;
#line 558
    W = wt_float[37];
#line 558
    E = W * f;
#line 558
    S8 += E;
#line 558
    E = W * g;
#line 558
    S7 += E;
#line 558
    E = W * h;
#line 558
    S6 += E;
#line 558
    E = W * a;
#line 558
    S5 += E;
#line 558
    E = W * b;
#line 558
    S4 += E;
#line 558
    E = W * c;
#line 558
    S3 += E;
#line 558
    E = W * d;
#line 558
    S2 += E;
#line 558
    E = W * e;
#line 558
    S1 += E;
#line 558
    f = *(lp + 37);
#line 558
    E = W * f;
#line 558
    S0 += E;
#line 558
    W = wt_float[38];
#line 558
    E = W * g;
#line 558
    S8 += E;
#line 558
    E = W * h;
#line 558
    S7 += E;
#line 558
    E = W * a;
#line 558
    S6 += E;
#line 558
    E = W * b;
#line 558
    S5 += E;
#line 558
    E = W * c;
#line 558
    S4 += E;
#line 558
    E = W * d;
#line 558
    S3 += E;
#line 558
    E = W * e;
#line 558
    S2 += E;
#line 558
    E = W * f;
#line 558
    S1 += E;
#line 558
    g = *(lp + 38);
#line 558
    E = W * g;
#line 558
    S0 += E;
#line 558
    W = wt_float[39];
#line 558
    E = W * h;
#line 558
    S8 += E;
#line 558
    E = W * a;
#line 558
    S7 += E;
#line 558
    E = W * b;
#line 558
    S6 += E;
#line 558
    E = W * c;
#line 558
    S5 += E;
#line 558
    E = W * d;
#line 558
    S4 += E;
#line 558
    E = W * e;
#line 558
    S3 += E;
#line 558
    E = W * f;
#line 558
    S2 += E;
#line 558
    E = W * g;
#line 558
    S1 += E;
#line 558
    h = *(lp + 39);
#line 558
    E = W * h;
#line 558
    S0 += E;
#line 569
    if (S0 > (float )L_max) {
#line 569
      L_max = (int32_t )S0;
#line 569
      Nc = (int16_t )lambda;
    }
#line 570
    if (S1 > (float )L_max) {
#line 570
      L_max = (int32_t )S1;
#line 570
      Nc = (int16_t )(lambda + 1);
    }
#line 571
    if (S2 > (float )L_max) {
#line 571
      L_max = (int32_t )S2;
#line 571
      Nc = (int16_t )(lambda + 2);
    }
#line 572
    if (S3 > (float )L_max) {
#line 572
      L_max = (int32_t )S3;
#line 572
      Nc = (int16_t )(lambda + 3);
    }
#line 573
    if (S4 > (float )L_max) {
#line 573
      L_max = (int32_t )S4;
#line 573
      Nc = (int16_t )(lambda + 4);
    }
#line 574
    if (S5 > (float )L_max) {
#line 574
      L_max = (int32_t )S5;
#line 574
      Nc = (int16_t )(lambda + 5);
    }
#line 575
    if (S6 > (float )L_max) {
#line 575
      L_max = (int32_t )S6;
#line 575
      Nc = (int16_t )(lambda + 6);
    }
#line 576
    if (S7 > (float )L_max) {
#line 576
      L_max = (int32_t )S7;
#line 576
      Nc = (int16_t )(lambda + 7);
    }
#line 577
    if (S8 > (float )L_max) {
#line 577
      L_max = (int32_t )S8;
#line 577
      Nc = (int16_t )(lambda + 8);
    }
#line 510
    lambda += 9;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
#line 579
  *Nc_out = Nc;
#line 581
  L_max <<= 1;
#line 586
  L_max >>= 6 - (int )scal;
#line 593
  L_power = 0;
#line 594
  k = 0;
  {
#line 594
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 594
    if (! (k <= 39)) {
#line 594
      goto while_break___3;
    }
    {
#line 597
    __cil_tmp50 = SASR_W(*(dp + (k - (int )Nc)), (int16_t )3);
#line 597
    L_temp = (int32_t )__cil_tmp50;
#line 598
    L_power += L_temp * L_temp;
#line 594
    k ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___3: 
#line 600
  L_power <<= 1;
#line 605
  if (L_max <= 0) {
#line 606
    *bc_out = (int16_t )0;
#line 607
    return;
  }
#line 609
  if (L_max >= L_power) {
#line 610
    *bc_out = (int16_t )3;
#line 611
    return;
  }
  {
#line 614
  temp = gsm_norm(L_power);
#line 616
  __cil_tmp53 = SASR_L(L_max << (int )temp, (int16_t )16);
#line 616
  R = (int16_t )__cil_tmp53;
#line 617
  __cil_tmp54 = SASR_L(L_power << (int )temp, (int16_t )16);
#line 617
  S = (int16_t )__cil_tmp54;
#line 625
  bc = (int16_t )0;
  }
  {
#line 625
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 625
    if (! ((int )bc <= 2)) {
#line 625
      goto while_break___4;
    }
    {
#line 625
    __cil_tmp55 = gsm_mult(S, gsm_DLB[bc]);
    }
#line 625
    if ((int )R <= (int )__cil_tmp55) {
#line 625
      goto while_break___4;
    }
#line 625
    bc = (int16_t )((int )bc + 1);
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: 
#line 626
  *bc_out = bc;
#line 627
  return;
}
}
#line 704 "/root/patchweave_donee/23/src/GSM610/long_term.c"
static void Fast_Calculation_of_the_LTP_parameters(int16_t *din , int16_t *dp , int16_t *bc_out ,
                                                   int16_t *Nc_out ) 
{ 
  register int k ;
  register int lambda ;
  int16_t Nc ;
  int16_t bc ;
  float wt_float[40] ;
  float dp_float_base[120] ;
  float *dp_float ;
  register float L_max ;
  register float L_power ;
  register float *lp ;
  register float W ;
  register float a ;
  register float b ;
  register float c ;
  register float d ;
  register float e ;
  register float f ;
  register float g ;
  register float h ;
  register float E ;
  register float S0 ;
  register float S1 ;
  register float S2 ;
  register float S3 ;
  register float S4 ;
  register float S5 ;
  register float S6 ;
  register float S7 ;
  register float S8 ;
  register float f___0 ;

  {
#line 714
  dp_float = dp_float_base + 120;
#line 718
  k = 0;
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;

#line 718
    if (! (k < 40)) {
#line 718
      goto while_break;
    }
#line 718
    wt_float[k] = (float )*(din + k);
#line 718
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 719
  k = -120;
  {
#line 719
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 719
    if (! (k < 0)) {
#line 719
      goto while_break___0;
    }
#line 719
    *(dp_float + k) = (float )*(dp + k);
#line 719
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
#line 722
  L_max = (float )0;
#line 723
  Nc = (int16_t )40;
#line 725
  lambda = 40;
  {
#line 725
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 725
    if (! (lambda <= 120)) {
#line 725
      goto while_break___1;
    }
#line 727
    lp = dp_float - lambda;
#line 730
    a = *(lp + -8);
#line 730
    b = *(lp + -7);
#line 730
    c = *(lp + -6);
#line 730
    d = *(lp + -5);
#line 730
    e = *(lp + -4);
#line 730
    f = *(lp + -3);
#line 730
    g = *(lp + -2);
#line 730
    h = *(lp + -1);
#line 734
    S0 = (float )0;
#line 734
    S1 = (float )0;
#line 734
    S2 = (float )0;
#line 734
    S3 = (float )0;
#line 734
    S4 = (float )0;
#line 734
    S5 = (float )0;
#line 734
    S6 = (float )0;
#line 734
    S7 = (float )0;
#line 734
    S8 = (float )0;
#line 760
    W = wt_float[0];
#line 760
    E = W * a;
#line 760
    S8 += E;
#line 760
    E = W * b;
#line 760
    S7 += E;
#line 760
    E = W * c;
#line 760
    S6 += E;
#line 760
    E = W * d;
#line 760
    S5 += E;
#line 760
    E = W * e;
#line 760
    S4 += E;
#line 760
    E = W * f;
#line 760
    S3 += E;
#line 760
    E = W * g;
#line 760
    S2 += E;
#line 760
    E = W * h;
#line 760
    S1 += E;
#line 760
    a = *(lp + 0);
#line 760
    E = W * a;
#line 760
    S0 += E;
#line 760
    W = wt_float[1];
#line 760
    E = W * b;
#line 760
    S8 += E;
#line 760
    E = W * c;
#line 760
    S7 += E;
#line 760
    E = W * d;
#line 760
    S6 += E;
#line 760
    E = W * e;
#line 760
    S5 += E;
#line 760
    E = W * f;
#line 760
    S4 += E;
#line 760
    E = W * g;
#line 760
    S3 += E;
#line 760
    E = W * h;
#line 760
    S2 += E;
#line 760
    E = W * a;
#line 760
    S1 += E;
#line 760
    b = *(lp + 1);
#line 760
    E = W * b;
#line 760
    S0 += E;
#line 760
    W = wt_float[2];
#line 760
    E = W * c;
#line 760
    S8 += E;
#line 760
    E = W * d;
#line 760
    S7 += E;
#line 760
    E = W * e;
#line 760
    S6 += E;
#line 760
    E = W * f;
#line 760
    S5 += E;
#line 760
    E = W * g;
#line 760
    S4 += E;
#line 760
    E = W * h;
#line 760
    S3 += E;
#line 760
    E = W * a;
#line 760
    S2 += E;
#line 760
    E = W * b;
#line 760
    S1 += E;
#line 760
    c = *(lp + 2);
#line 760
    E = W * c;
#line 760
    S0 += E;
#line 760
    W = wt_float[3];
#line 760
    E = W * d;
#line 760
    S8 += E;
#line 760
    E = W * e;
#line 760
    S7 += E;
#line 760
    E = W * f;
#line 760
    S6 += E;
#line 760
    E = W * g;
#line 760
    S5 += E;
#line 760
    E = W * h;
#line 760
    S4 += E;
#line 760
    E = W * a;
#line 760
    S3 += E;
#line 760
    E = W * b;
#line 760
    S2 += E;
#line 760
    E = W * c;
#line 760
    S1 += E;
#line 760
    d = *(lp + 3);
#line 760
    E = W * d;
#line 760
    S0 += E;
#line 761
    W = wt_float[4];
#line 761
    E = W * e;
#line 761
    S8 += E;
#line 761
    E = W * f;
#line 761
    S7 += E;
#line 761
    E = W * g;
#line 761
    S6 += E;
#line 761
    E = W * h;
#line 761
    S5 += E;
#line 761
    E = W * a;
#line 761
    S4 += E;
#line 761
    E = W * b;
#line 761
    S3 += E;
#line 761
    E = W * c;
#line 761
    S2 += E;
#line 761
    E = W * d;
#line 761
    S1 += E;
#line 761
    e = *(lp + 4);
#line 761
    E = W * e;
#line 761
    S0 += E;
#line 761
    W = wt_float[5];
#line 761
    E = W * f;
#line 761
    S8 += E;
#line 761
    E = W * g;
#line 761
    S7 += E;
#line 761
    E = W * h;
#line 761
    S6 += E;
#line 761
    E = W * a;
#line 761
    S5 += E;
#line 761
    E = W * b;
#line 761
    S4 += E;
#line 761
    E = W * c;
#line 761
    S3 += E;
#line 761
    E = W * d;
#line 761
    S2 += E;
#line 761
    E = W * e;
#line 761
    S1 += E;
#line 761
    f = *(lp + 5);
#line 761
    E = W * f;
#line 761
    S0 += E;
#line 761
    W = wt_float[6];
#line 761
    E = W * g;
#line 761
    S8 += E;
#line 761
    E = W * h;
#line 761
    S7 += E;
#line 761
    E = W * a;
#line 761
    S6 += E;
#line 761
    E = W * b;
#line 761
    S5 += E;
#line 761
    E = W * c;
#line 761
    S4 += E;
#line 761
    E = W * d;
#line 761
    S3 += E;
#line 761
    E = W * e;
#line 761
    S2 += E;
#line 761
    E = W * f;
#line 761
    S1 += E;
#line 761
    g = *(lp + 6);
#line 761
    E = W * g;
#line 761
    S0 += E;
#line 761
    W = wt_float[7];
#line 761
    E = W * h;
#line 761
    S8 += E;
#line 761
    E = W * a;
#line 761
    S7 += E;
#line 761
    E = W * b;
#line 761
    S6 += E;
#line 761
    E = W * c;
#line 761
    S5 += E;
#line 761
    E = W * d;
#line 761
    S4 += E;
#line 761
    E = W * e;
#line 761
    S3 += E;
#line 761
    E = W * f;
#line 761
    S2 += E;
#line 761
    E = W * g;
#line 761
    S1 += E;
#line 761
    h = *(lp + 7);
#line 761
    E = W * h;
#line 761
    S0 += E;
#line 763
    W = wt_float[8];
#line 763
    E = W * a;
#line 763
    S8 += E;
#line 763
    E = W * b;
#line 763
    S7 += E;
#line 763
    E = W * c;
#line 763
    S6 += E;
#line 763
    E = W * d;
#line 763
    S5 += E;
#line 763
    E = W * e;
#line 763
    S4 += E;
#line 763
    E = W * f;
#line 763
    S3 += E;
#line 763
    E = W * g;
#line 763
    S2 += E;
#line 763
    E = W * h;
#line 763
    S1 += E;
#line 763
    a = *(lp + 8);
#line 763
    E = W * a;
#line 763
    S0 += E;
#line 763
    W = wt_float[9];
#line 763
    E = W * b;
#line 763
    S8 += E;
#line 763
    E = W * c;
#line 763
    S7 += E;
#line 763
    E = W * d;
#line 763
    S6 += E;
#line 763
    E = W * e;
#line 763
    S5 += E;
#line 763
    E = W * f;
#line 763
    S4 += E;
#line 763
    E = W * g;
#line 763
    S3 += E;
#line 763
    E = W * h;
#line 763
    S2 += E;
#line 763
    E = W * a;
#line 763
    S1 += E;
#line 763
    b = *(lp + 9);
#line 763
    E = W * b;
#line 763
    S0 += E;
#line 763
    W = wt_float[10];
#line 763
    E = W * c;
#line 763
    S8 += E;
#line 763
    E = W * d;
#line 763
    S7 += E;
#line 763
    E = W * e;
#line 763
    S6 += E;
#line 763
    E = W * f;
#line 763
    S5 += E;
#line 763
    E = W * g;
#line 763
    S4 += E;
#line 763
    E = W * h;
#line 763
    S3 += E;
#line 763
    E = W * a;
#line 763
    S2 += E;
#line 763
    E = W * b;
#line 763
    S1 += E;
#line 763
    c = *(lp + 10);
#line 763
    E = W * c;
#line 763
    S0 += E;
#line 763
    W = wt_float[11];
#line 763
    E = W * d;
#line 763
    S8 += E;
#line 763
    E = W * e;
#line 763
    S7 += E;
#line 763
    E = W * f;
#line 763
    S6 += E;
#line 763
    E = W * g;
#line 763
    S5 += E;
#line 763
    E = W * h;
#line 763
    S4 += E;
#line 763
    E = W * a;
#line 763
    S3 += E;
#line 763
    E = W * b;
#line 763
    S2 += E;
#line 763
    E = W * c;
#line 763
    S1 += E;
#line 763
    d = *(lp + 11);
#line 763
    E = W * d;
#line 763
    S0 += E;
#line 764
    W = wt_float[12];
#line 764
    E = W * e;
#line 764
    S8 += E;
#line 764
    E = W * f;
#line 764
    S7 += E;
#line 764
    E = W * g;
#line 764
    S6 += E;
#line 764
    E = W * h;
#line 764
    S5 += E;
#line 764
    E = W * a;
#line 764
    S4 += E;
#line 764
    E = W * b;
#line 764
    S3 += E;
#line 764
    E = W * c;
#line 764
    S2 += E;
#line 764
    E = W * d;
#line 764
    S1 += E;
#line 764
    e = *(lp + 12);
#line 764
    E = W * e;
#line 764
    S0 += E;
#line 764
    W = wt_float[13];
#line 764
    E = W * f;
#line 764
    S8 += E;
#line 764
    E = W * g;
#line 764
    S7 += E;
#line 764
    E = W * h;
#line 764
    S6 += E;
#line 764
    E = W * a;
#line 764
    S5 += E;
#line 764
    E = W * b;
#line 764
    S4 += E;
#line 764
    E = W * c;
#line 764
    S3 += E;
#line 764
    E = W * d;
#line 764
    S2 += E;
#line 764
    E = W * e;
#line 764
    S1 += E;
#line 764
    f = *(lp + 13);
#line 764
    E = W * f;
#line 764
    S0 += E;
#line 764
    W = wt_float[14];
#line 764
    E = W * g;
#line 764
    S8 += E;
#line 764
    E = W * h;
#line 764
    S7 += E;
#line 764
    E = W * a;
#line 764
    S6 += E;
#line 764
    E = W * b;
#line 764
    S5 += E;
#line 764
    E = W * c;
#line 764
    S4 += E;
#line 764
    E = W * d;
#line 764
    S3 += E;
#line 764
    E = W * e;
#line 764
    S2 += E;
#line 764
    E = W * f;
#line 764
    S1 += E;
#line 764
    g = *(lp + 14);
#line 764
    E = W * g;
#line 764
    S0 += E;
#line 764
    W = wt_float[15];
#line 764
    E = W * h;
#line 764
    S8 += E;
#line 764
    E = W * a;
#line 764
    S7 += E;
#line 764
    E = W * b;
#line 764
    S6 += E;
#line 764
    E = W * c;
#line 764
    S5 += E;
#line 764
    E = W * d;
#line 764
    S4 += E;
#line 764
    E = W * e;
#line 764
    S3 += E;
#line 764
    E = W * f;
#line 764
    S2 += E;
#line 764
    E = W * g;
#line 764
    S1 += E;
#line 764
    h = *(lp + 15);
#line 764
    E = W * h;
#line 764
    S0 += E;
#line 766
    W = wt_float[16];
#line 766
    E = W * a;
#line 766
    S8 += E;
#line 766
    E = W * b;
#line 766
    S7 += E;
#line 766
    E = W * c;
#line 766
    S6 += E;
#line 766
    E = W * d;
#line 766
    S5 += E;
#line 766
    E = W * e;
#line 766
    S4 += E;
#line 766
    E = W * f;
#line 766
    S3 += E;
#line 766
    E = W * g;
#line 766
    S2 += E;
#line 766
    E = W * h;
#line 766
    S1 += E;
#line 766
    a = *(lp + 16);
#line 766
    E = W * a;
#line 766
    S0 += E;
#line 766
    W = wt_float[17];
#line 766
    E = W * b;
#line 766
    S8 += E;
#line 766
    E = W * c;
#line 766
    S7 += E;
#line 766
    E = W * d;
#line 766
    S6 += E;
#line 766
    E = W * e;
#line 766
    S5 += E;
#line 766
    E = W * f;
#line 766
    S4 += E;
#line 766
    E = W * g;
#line 766
    S3 += E;
#line 766
    E = W * h;
#line 766
    S2 += E;
#line 766
    E = W * a;
#line 766
    S1 += E;
#line 766
    b = *(lp + 17);
#line 766
    E = W * b;
#line 766
    S0 += E;
#line 766
    W = wt_float[18];
#line 766
    E = W * c;
#line 766
    S8 += E;
#line 766
    E = W * d;
#line 766
    S7 += E;
#line 766
    E = W * e;
#line 766
    S6 += E;
#line 766
    E = W * f;
#line 766
    S5 += E;
#line 766
    E = W * g;
#line 766
    S4 += E;
#line 766
    E = W * h;
#line 766
    S3 += E;
#line 766
    E = W * a;
#line 766
    S2 += E;
#line 766
    E = W * b;
#line 766
    S1 += E;
#line 766
    c = *(lp + 18);
#line 766
    E = W * c;
#line 766
    S0 += E;
#line 766
    W = wt_float[19];
#line 766
    E = W * d;
#line 766
    S8 += E;
#line 766
    E = W * e;
#line 766
    S7 += E;
#line 766
    E = W * f;
#line 766
    S6 += E;
#line 766
    E = W * g;
#line 766
    S5 += E;
#line 766
    E = W * h;
#line 766
    S4 += E;
#line 766
    E = W * a;
#line 766
    S3 += E;
#line 766
    E = W * b;
#line 766
    S2 += E;
#line 766
    E = W * c;
#line 766
    S1 += E;
#line 766
    d = *(lp + 19);
#line 766
    E = W * d;
#line 766
    S0 += E;
#line 767
    W = wt_float[20];
#line 767
    E = W * e;
#line 767
    S8 += E;
#line 767
    E = W * f;
#line 767
    S7 += E;
#line 767
    E = W * g;
#line 767
    S6 += E;
#line 767
    E = W * h;
#line 767
    S5 += E;
#line 767
    E = W * a;
#line 767
    S4 += E;
#line 767
    E = W * b;
#line 767
    S3 += E;
#line 767
    E = W * c;
#line 767
    S2 += E;
#line 767
    E = W * d;
#line 767
    S1 += E;
#line 767
    e = *(lp + 20);
#line 767
    E = W * e;
#line 767
    S0 += E;
#line 767
    W = wt_float[21];
#line 767
    E = W * f;
#line 767
    S8 += E;
#line 767
    E = W * g;
#line 767
    S7 += E;
#line 767
    E = W * h;
#line 767
    S6 += E;
#line 767
    E = W * a;
#line 767
    S5 += E;
#line 767
    E = W * b;
#line 767
    S4 += E;
#line 767
    E = W * c;
#line 767
    S3 += E;
#line 767
    E = W * d;
#line 767
    S2 += E;
#line 767
    E = W * e;
#line 767
    S1 += E;
#line 767
    f = *(lp + 21);
#line 767
    E = W * f;
#line 767
    S0 += E;
#line 767
    W = wt_float[22];
#line 767
    E = W * g;
#line 767
    S8 += E;
#line 767
    E = W * h;
#line 767
    S7 += E;
#line 767
    E = W * a;
#line 767
    S6 += E;
#line 767
    E = W * b;
#line 767
    S5 += E;
#line 767
    E = W * c;
#line 767
    S4 += E;
#line 767
    E = W * d;
#line 767
    S3 += E;
#line 767
    E = W * e;
#line 767
    S2 += E;
#line 767
    E = W * f;
#line 767
    S1 += E;
#line 767
    g = *(lp + 22);
#line 767
    E = W * g;
#line 767
    S0 += E;
#line 767
    W = wt_float[23];
#line 767
    E = W * h;
#line 767
    S8 += E;
#line 767
    E = W * a;
#line 767
    S7 += E;
#line 767
    E = W * b;
#line 767
    S6 += E;
#line 767
    E = W * c;
#line 767
    S5 += E;
#line 767
    E = W * d;
#line 767
    S4 += E;
#line 767
    E = W * e;
#line 767
    S3 += E;
#line 767
    E = W * f;
#line 767
    S2 += E;
#line 767
    E = W * g;
#line 767
    S1 += E;
#line 767
    h = *(lp + 23);
#line 767
    E = W * h;
#line 767
    S0 += E;
#line 769
    W = wt_float[24];
#line 769
    E = W * a;
#line 769
    S8 += E;
#line 769
    E = W * b;
#line 769
    S7 += E;
#line 769
    E = W * c;
#line 769
    S6 += E;
#line 769
    E = W * d;
#line 769
    S5 += E;
#line 769
    E = W * e;
#line 769
    S4 += E;
#line 769
    E = W * f;
#line 769
    S3 += E;
#line 769
    E = W * g;
#line 769
    S2 += E;
#line 769
    E = W * h;
#line 769
    S1 += E;
#line 769
    a = *(lp + 24);
#line 769
    E = W * a;
#line 769
    S0 += E;
#line 769
    W = wt_float[25];
#line 769
    E = W * b;
#line 769
    S8 += E;
#line 769
    E = W * c;
#line 769
    S7 += E;
#line 769
    E = W * d;
#line 769
    S6 += E;
#line 769
    E = W * e;
#line 769
    S5 += E;
#line 769
    E = W * f;
#line 769
    S4 += E;
#line 769
    E = W * g;
#line 769
    S3 += E;
#line 769
    E = W * h;
#line 769
    S2 += E;
#line 769
    E = W * a;
#line 769
    S1 += E;
#line 769
    b = *(lp + 25);
#line 769
    E = W * b;
#line 769
    S0 += E;
#line 769
    W = wt_float[26];
#line 769
    E = W * c;
#line 769
    S8 += E;
#line 769
    E = W * d;
#line 769
    S7 += E;
#line 769
    E = W * e;
#line 769
    S6 += E;
#line 769
    E = W * f;
#line 769
    S5 += E;
#line 769
    E = W * g;
#line 769
    S4 += E;
#line 769
    E = W * h;
#line 769
    S3 += E;
#line 769
    E = W * a;
#line 769
    S2 += E;
#line 769
    E = W * b;
#line 769
    S1 += E;
#line 769
    c = *(lp + 26);
#line 769
    E = W * c;
#line 769
    S0 += E;
#line 769
    W = wt_float[27];
#line 769
    E = W * d;
#line 769
    S8 += E;
#line 769
    E = W * e;
#line 769
    S7 += E;
#line 769
    E = W * f;
#line 769
    S6 += E;
#line 769
    E = W * g;
#line 769
    S5 += E;
#line 769
    E = W * h;
#line 769
    S4 += E;
#line 769
    E = W * a;
#line 769
    S3 += E;
#line 769
    E = W * b;
#line 769
    S2 += E;
#line 769
    E = W * c;
#line 769
    S1 += E;
#line 769
    d = *(lp + 27);
#line 769
    E = W * d;
#line 769
    S0 += E;
#line 770
    W = wt_float[28];
#line 770
    E = W * e;
#line 770
    S8 += E;
#line 770
    E = W * f;
#line 770
    S7 += E;
#line 770
    E = W * g;
#line 770
    S6 += E;
#line 770
    E = W * h;
#line 770
    S5 += E;
#line 770
    E = W * a;
#line 770
    S4 += E;
#line 770
    E = W * b;
#line 770
    S3 += E;
#line 770
    E = W * c;
#line 770
    S2 += E;
#line 770
    E = W * d;
#line 770
    S1 += E;
#line 770
    e = *(lp + 28);
#line 770
    E = W * e;
#line 770
    S0 += E;
#line 770
    W = wt_float[29];
#line 770
    E = W * f;
#line 770
    S8 += E;
#line 770
    E = W * g;
#line 770
    S7 += E;
#line 770
    E = W * h;
#line 770
    S6 += E;
#line 770
    E = W * a;
#line 770
    S5 += E;
#line 770
    E = W * b;
#line 770
    S4 += E;
#line 770
    E = W * c;
#line 770
    S3 += E;
#line 770
    E = W * d;
#line 770
    S2 += E;
#line 770
    E = W * e;
#line 770
    S1 += E;
#line 770
    f = *(lp + 29);
#line 770
    E = W * f;
#line 770
    S0 += E;
#line 770
    W = wt_float[30];
#line 770
    E = W * g;
#line 770
    S8 += E;
#line 770
    E = W * h;
#line 770
    S7 += E;
#line 770
    E = W * a;
#line 770
    S6 += E;
#line 770
    E = W * b;
#line 770
    S5 += E;
#line 770
    E = W * c;
#line 770
    S4 += E;
#line 770
    E = W * d;
#line 770
    S3 += E;
#line 770
    E = W * e;
#line 770
    S2 += E;
#line 770
    E = W * f;
#line 770
    S1 += E;
#line 770
    g = *(lp + 30);
#line 770
    E = W * g;
#line 770
    S0 += E;
#line 770
    W = wt_float[31];
#line 770
    E = W * h;
#line 770
    S8 += E;
#line 770
    E = W * a;
#line 770
    S7 += E;
#line 770
    E = W * b;
#line 770
    S6 += E;
#line 770
    E = W * c;
#line 770
    S5 += E;
#line 770
    E = W * d;
#line 770
    S4 += E;
#line 770
    E = W * e;
#line 770
    S3 += E;
#line 770
    E = W * f;
#line 770
    S2 += E;
#line 770
    E = W * g;
#line 770
    S1 += E;
#line 770
    h = *(lp + 31);
#line 770
    E = W * h;
#line 770
    S0 += E;
#line 772
    W = wt_float[32];
#line 772
    E = W * a;
#line 772
    S8 += E;
#line 772
    E = W * b;
#line 772
    S7 += E;
#line 772
    E = W * c;
#line 772
    S6 += E;
#line 772
    E = W * d;
#line 772
    S5 += E;
#line 772
    E = W * e;
#line 772
    S4 += E;
#line 772
    E = W * f;
#line 772
    S3 += E;
#line 772
    E = W * g;
#line 772
    S2 += E;
#line 772
    E = W * h;
#line 772
    S1 += E;
#line 772
    a = *(lp + 32);
#line 772
    E = W * a;
#line 772
    S0 += E;
#line 772
    W = wt_float[33];
#line 772
    E = W * b;
#line 772
    S8 += E;
#line 772
    E = W * c;
#line 772
    S7 += E;
#line 772
    E = W * d;
#line 772
    S6 += E;
#line 772
    E = W * e;
#line 772
    S5 += E;
#line 772
    E = W * f;
#line 772
    S4 += E;
#line 772
    E = W * g;
#line 772
    S3 += E;
#line 772
    E = W * h;
#line 772
    S2 += E;
#line 772
    E = W * a;
#line 772
    S1 += E;
#line 772
    b = *(lp + 33);
#line 772
    E = W * b;
#line 772
    S0 += E;
#line 772
    W = wt_float[34];
#line 772
    E = W * c;
#line 772
    S8 += E;
#line 772
    E = W * d;
#line 772
    S7 += E;
#line 772
    E = W * e;
#line 772
    S6 += E;
#line 772
    E = W * f;
#line 772
    S5 += E;
#line 772
    E = W * g;
#line 772
    S4 += E;
#line 772
    E = W * h;
#line 772
    S3 += E;
#line 772
    E = W * a;
#line 772
    S2 += E;
#line 772
    E = W * b;
#line 772
    S1 += E;
#line 772
    c = *(lp + 34);
#line 772
    E = W * c;
#line 772
    S0 += E;
#line 772
    W = wt_float[35];
#line 772
    E = W * d;
#line 772
    S8 += E;
#line 772
    E = W * e;
#line 772
    S7 += E;
#line 772
    E = W * f;
#line 772
    S6 += E;
#line 772
    E = W * g;
#line 772
    S5 += E;
#line 772
    E = W * h;
#line 772
    S4 += E;
#line 772
    E = W * a;
#line 772
    S3 += E;
#line 772
    E = W * b;
#line 772
    S2 += E;
#line 772
    E = W * c;
#line 772
    S1 += E;
#line 772
    d = *(lp + 35);
#line 772
    E = W * d;
#line 772
    S0 += E;
#line 773
    W = wt_float[36];
#line 773
    E = W * e;
#line 773
    S8 += E;
#line 773
    E = W * f;
#line 773
    S7 += E;
#line 773
    E = W * g;
#line 773
    S6 += E;
#line 773
    E = W * h;
#line 773
    S5 += E;
#line 773
    E = W * a;
#line 773
    S4 += E;
#line 773
    E = W * b;
#line 773
    S3 += E;
#line 773
    E = W * c;
#line 773
    S2 += E;
#line 773
    E = W * d;
#line 773
    S1 += E;
#line 773
    e = *(lp + 36);
#line 773
    E = W * e;
#line 773
    S0 += E;
#line 773
    W = wt_float[37];
#line 773
    E = W * f;
#line 773
    S8 += E;
#line 773
    E = W * g;
#line 773
    S7 += E;
#line 773
    E = W * h;
#line 773
    S6 += E;
#line 773
    E = W * a;
#line 773
    S5 += E;
#line 773
    E = W * b;
#line 773
    S4 += E;
#line 773
    E = W * c;
#line 773
    S3 += E;
#line 773
    E = W * d;
#line 773
    S2 += E;
#line 773
    E = W * e;
#line 773
    S1 += E;
#line 773
    f = *(lp + 37);
#line 773
    E = W * f;
#line 773
    S0 += E;
#line 773
    W = wt_float[38];
#line 773
    E = W * g;
#line 773
    S8 += E;
#line 773
    E = W * h;
#line 773
    S7 += E;
#line 773
    E = W * a;
#line 773
    S6 += E;
#line 773
    E = W * b;
#line 773
    S5 += E;
#line 773
    E = W * c;
#line 773
    S4 += E;
#line 773
    E = W * d;
#line 773
    S3 += E;
#line 773
    E = W * e;
#line 773
    S2 += E;
#line 773
    E = W * f;
#line 773
    S1 += E;
#line 773
    g = *(lp + 38);
#line 773
    E = W * g;
#line 773
    S0 += E;
#line 773
    W = wt_float[39];
#line 773
    E = W * h;
#line 773
    S8 += E;
#line 773
    E = W * a;
#line 773
    S7 += E;
#line 773
    E = W * b;
#line 773
    S6 += E;
#line 773
    E = W * c;
#line 773
    S5 += E;
#line 773
    E = W * d;
#line 773
    S4 += E;
#line 773
    E = W * e;
#line 773
    S3 += E;
#line 773
    E = W * f;
#line 773
    S2 += E;
#line 773
    E = W * g;
#line 773
    S1 += E;
#line 773
    h = *(lp + 39);
#line 773
    E = W * h;
#line 773
    S0 += E;
#line 775
    if (S0 > L_max) {
#line 775
      L_max = S0;
#line 775
      Nc = (int16_t )lambda;
    }
#line 776
    if (S1 > L_max) {
#line 776
      L_max = S1;
#line 776
      Nc = (int16_t )(lambda + 1);
    }
#line 777
    if (S2 > L_max) {
#line 777
      L_max = S2;
#line 777
      Nc = (int16_t )(lambda + 2);
    }
#line 778
    if (S3 > L_max) {
#line 778
      L_max = S3;
#line 778
      Nc = (int16_t )(lambda + 3);
    }
#line 779
    if (S4 > L_max) {
#line 779
      L_max = S4;
#line 779
      Nc = (int16_t )(lambda + 4);
    }
#line 780
    if (S5 > L_max) {
#line 780
      L_max = S5;
#line 780
      Nc = (int16_t )(lambda + 5);
    }
#line 781
    if (S6 > L_max) {
#line 781
      L_max = S6;
#line 781
      Nc = (int16_t )(lambda + 6);
    }
#line 782
    if (S7 > L_max) {
#line 782
      L_max = S7;
#line 782
      Nc = (int16_t )(lambda + 7);
    }
#line 783
    if (S8 > L_max) {
#line 783
      L_max = S8;
#line 783
      Nc = (int16_t )(lambda + 8);
    }
#line 725
    lambda += 9;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
#line 785
  *Nc_out = Nc;
#line 787
  if ((double )L_max <= 0.) {
#line 788
    *bc_out = (int16_t )0;
#line 789
    return;
  }
#line 795
  dp_float -= (int )Nc;
#line 796
  L_power = (float )0;
#line 797
  k = 0;
  {
#line 797
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 797
    if (! (k < 40)) {
#line 797
      goto while_break___2;
    }
#line 798
    f___0 = *(dp_float + k);
#line 799
    L_power += f___0 * f___0;
#line 797
    k ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: ;
#line 802
  if (L_max >= L_power) {
#line 803
    *bc_out = (int16_t )3;
#line 804
    return;
  }
#line 811
  lambda = (int )((double )(L_max / L_power) * 32768.);
#line 812
  bc = (int16_t )0;
  {
#line 812
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 812
    if (! ((int )bc <= 2)) {
#line 812
      goto while_break___3;
    }
#line 812
    if (lambda <= (int )gsm_DLB[bc]) {
#line 812
      goto while_break___3;
    }
#line 812
    bc = (int16_t )((int )bc + 1);
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: 
#line 813
  *bc_out = bc;
#line 814
  return;
}
}
#line 822 "/root/patchweave_donee/23/src/GSM610/long_term.c"
static void Long_term_analysis_filtering(int16_t bc , int16_t Nc , int16_t *dp , int16_t *d ,
                                         int16_t *dpp , int16_t *e ) 
{ 
  register int k ;
  int32_t __cil_tmp8 ;
  int32_t __cil_tmp9 ;
  int32_t __cil_tmp11 ;
  int32_t __cil_tmp12 ;
  int32_t __cil_tmp14 ;
  int32_t __cil_tmp15 ;
  int32_t __cil_tmp17 ;
  int32_t __cil_tmp18 ;

  {
#line 846
  if ((int )bc == 0) {
#line 846
    goto case_0;
  }
#line 847
  if ((int )bc == 1) {
#line 847
    goto case_1;
  }
#line 848
  if ((int )bc == 2) {
#line 848
    goto case_2;
  }
#line 849
  if ((int )bc == 3) {
#line 849
    goto case_3;
  }
#line 845
  goto switch_break;
  case_0: 
#line 846
  k = 0;
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;

#line 846
    if (! (k <= 39)) {
#line 846
      goto while_break;
    }
    {
#line 846
    __cil_tmp8 = GSM_MULT_R((int16_t )3277, *(dp + (k - (int )Nc)));
#line 846
    *(dpp + k) = (int16_t )__cil_tmp8;
#line 846
    __cil_tmp9 = GSM_SUB(*(d + k), *(dpp + k));
#line 846
    *(e + k) = (int16_t )__cil_tmp9;
#line 846
    k ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 846
  goto switch_break;
  case_1: 
#line 847
  k = 0;
  {
#line 847
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 847
    if (! (k <= 39)) {
#line 847
      goto while_break___0;
    }
    {
#line 847
    __cil_tmp11 = GSM_MULT_R((int16_t )11469, *(dp + (k - (int )Nc)));
#line 847
    *(dpp + k) = (int16_t )__cil_tmp11;
#line 847
    __cil_tmp12 = GSM_SUB(*(d + k), *(dpp + k));
#line 847
    *(e + k) = (int16_t )__cil_tmp12;
#line 847
    k ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
#line 847
  goto switch_break;
  case_2: 
#line 848
  k = 0;
  {
#line 848
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 848
    if (! (k <= 39)) {
#line 848
      goto while_break___1;
    }
    {
#line 848
    __cil_tmp14 = GSM_MULT_R((int16_t )21299, *(dp + (k - (int )Nc)));
#line 848
    *(dpp + k) = (int16_t )__cil_tmp14;
#line 848
    __cil_tmp15 = GSM_SUB(*(d + k), *(dpp + k));
#line 848
    *(e + k) = (int16_t )__cil_tmp15;
#line 848
    k ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 848
  goto switch_break;
  case_3: 
#line 849
  k = 0;
  {
#line 849
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 849
    if (! (k <= 39)) {
#line 849
      goto while_break___2;
    }
    {
#line 849
    __cil_tmp17 = GSM_MULT_R((int16_t )32767, *(dp + (k - (int )Nc)));
#line 849
    *(dpp + k) = (int16_t )__cil_tmp17;
#line 849
    __cil_tmp18 = GSM_SUB(*(d + k), *(dpp + k));
#line 849
    *(e + k) = (int16_t )__cil_tmp18;
#line 849
    k ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 849
  goto switch_break;
  switch_break: ;
#line 852
  return;
}
}
#line 853 "/root/patchweave_donee/23/src/GSM610/long_term.c"
void Gsm_Long_Term_Predictor(struct gsm_state *S , int16_t *d , int16_t *dp , int16_t *e ,
                             int16_t *dpp , int16_t *Nc , int16_t *bc ) 
{ 


  {
#line 869
  if (S->fast) {
    {
#line 876
    Fast_Calculation_of_the_LTP_parameters(d, dp, bc, Nc);
    }
  } else {
    {
#line 884
    Calculation_of_the_LTP_parameters(d, dp, bc, Nc);
    }
  }
  {
#line 886
  Long_term_analysis_filtering(*bc, *Nc, dp, d, dpp, e);
  }
#line 888
  return;
}
}
#line 890 "/root/patchweave_donee/23/src/GSM610/long_term.c"
void Gsm_Long_Term_Synthesis_Filtering(struct gsm_state *S , int16_t Ncr , int16_t bcr ,
                                       int16_t *erp , int16_t *drp ) 
{ 
  register int k ;
  int16_t brp ;
  int16_t drpp ;
  int16_t Nr ;
  int tmp ;
  int32_t __cil_tmp13 ;
  int32_t __cil_tmp14 ;

  {
#line 908
  if ((int )Ncr < 40) {
#line 908
    tmp = (int )S->nrp;
  } else
#line 908
  if ((int )Ncr > 120) {
#line 908
    tmp = (int )S->nrp;
  } else {
#line 908
    tmp = (int )Ncr;
  }
#line 908
  Nr = (int16_t )tmp;
#line 909
  S->nrp = Nr;
#line 914
  brp = gsm_QLB[bcr];
#line 921
  k = 0;
  {
#line 921
  while (1) {
    while_continue: /* CIL Label */ ;

#line 921
    if (! (k <= 39)) {
#line 921
      goto while_break;
    }
    {
#line 922
    __cil_tmp13 = GSM_MULT_R(brp, *(drp + (k - (int )Nr)));
#line 922
    drpp = (int16_t )__cil_tmp13;
#line 923
    __cil_tmp14 = GSM_ADD(*(erp + k), drpp);
#line 923
    *(drp + k) = (int16_t )__cil_tmp14;
#line 921
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 931
  k = 0;
  {
#line 931
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 931
    if (! (k <= 119)) {
#line 931
      goto while_break___0;
    }
#line 931
    *(drp + (-120 + k)) = *(drp + (-80 + k));
#line 931
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 935
  return;
}
}
#line 11 "/root/patchweave_donee/23/src/GSM610/gsm_option.c"
int gsm_option(gsm r , int opt , int *val ) 
{ 
  int result ;

  {
#line 13
  result = -1;
#line 16
  if (opt == 3) {
#line 16
    goto case_3;
  }
#line 23
  if (opt == 1) {
#line 23
    goto case_1;
  }
#line 30
  if (opt == 2) {
#line 30
    goto case_2;
  }
#line 38
  if (opt == 6) {
#line 38
    goto case_6;
  }
#line 46
  if (opt == 5) {
#line 46
    goto case_5;
  }
#line 54
  if (opt == 4) {
#line 54
    goto case_4;
  }
#line 62
  goto switch_default;
  case_3: 
#line 21
  goto switch_break;
  case_1: 
#line 25
  result = (int )r->verbose;
#line 26
  if (val) {
#line 26
    r->verbose = (char )*val;
  }
#line 28
  goto switch_break;
  case_2: 
#line 33
  result = (int )r->fast;
#line 34
  if (val) {
#line 34
    r->fast = (char )(! (! *val));
  }
#line 36
  goto switch_break;
  case_6: 
#line 41
  result = (int )r->frame_chain;
#line 42
  if (val) {
#line 42
    r->frame_chain = (unsigned char )*val;
  }
#line 44
  goto switch_break;
  case_5: 
#line 49
  result = (int )r->frame_index;
#line 50
  if (val) {
#line 50
    r->frame_index = (unsigned char )*val;
  }
#line 52
  goto switch_break;
  case_4: 
#line 57
  result = (int )r->wav_fmt;
#line 58
  if (val) {
#line 58
    r->wav_fmt = (char )(! (! *val));
  }
#line 60
  goto switch_break;
  switch_default: 
#line 63
  goto switch_break;
  switch_break: ;
#line 65
  return (result);
}
}
#line 10 "/root/patchweave_donee/23/src/GSM610/gsm_encode.c"
void gsm_encode(gsm s , gsm_signal *source , gsm_byte *c ) 
{ 
  int16_t LARc[8] ;
  int16_t Nc[4] ;
  int16_t Mc[4] ;
  int16_t bc[4] ;
  int16_t xmaxc[4] ;
  int16_t xmc[52] ;
  uint16_t sr ;
  gsm_byte *__cil_tmp11 ;
  gsm_byte *__cil_tmp12 ;
  gsm_byte *__cil_tmp13 ;
  gsm_byte *__cil_tmp14 ;
  gsm_byte *__cil_tmp15 ;
  gsm_byte *__cil_tmp16 ;
  gsm_byte *__cil_tmp17 ;
  gsm_byte *__cil_tmp18 ;
  gsm_byte *__cil_tmp19 ;
  gsm_byte *__cil_tmp20 ;
  gsm_byte *__cil_tmp21 ;
  gsm_byte *__cil_tmp22 ;
  gsm_byte *__cil_tmp23 ;
  gsm_byte *__cil_tmp24 ;
  gsm_byte *__cil_tmp25 ;
  gsm_byte *__cil_tmp26 ;
  gsm_byte *__cil_tmp27 ;
  gsm_byte *__cil_tmp28 ;
  gsm_byte *__cil_tmp29 ;
  gsm_byte *__cil_tmp30 ;
  gsm_byte *__cil_tmp31 ;
  gsm_byte *__cil_tmp32 ;
  gsm_byte *__cil_tmp33 ;
  gsm_byte *__cil_tmp34 ;
  gsm_byte *__cil_tmp35 ;
  gsm_byte *__cil_tmp36 ;
  gsm_byte *__cil_tmp37 ;
  gsm_byte *__cil_tmp38 ;
  gsm_byte *__cil_tmp39 ;
  gsm_byte *__cil_tmp40 ;
  gsm_byte *__cil_tmp41 ;
  gsm_byte *__cil_tmp42 ;
  uint16_t sr___0 ;
  gsm_byte *__cil_tmp44 ;
  gsm_byte *__cil_tmp45 ;
  gsm_byte *__cil_tmp46 ;
  gsm_byte *__cil_tmp47 ;
  gsm_byte *__cil_tmp48 ;
  gsm_byte *__cil_tmp49 ;
  gsm_byte *__cil_tmp50 ;
  gsm_byte *__cil_tmp51 ;
  gsm_byte *__cil_tmp52 ;
  gsm_byte *__cil_tmp53 ;
  gsm_byte *__cil_tmp54 ;
  gsm_byte *__cil_tmp55 ;
  gsm_byte *__cil_tmp56 ;
  gsm_byte *__cil_tmp57 ;
  gsm_byte *__cil_tmp58 ;
  gsm_byte *__cil_tmp59 ;
  gsm_byte *__cil_tmp60 ;
  gsm_byte *__cil_tmp61 ;
  gsm_byte *__cil_tmp62 ;
  gsm_byte *__cil_tmp63 ;
  gsm_byte *__cil_tmp64 ;
  gsm_byte *__cil_tmp65 ;
  gsm_byte *__cil_tmp66 ;
  gsm_byte *__cil_tmp67 ;
  gsm_byte *__cil_tmp68 ;
  gsm_byte *__cil_tmp69 ;
  gsm_byte *__cil_tmp70 ;
  gsm_byte *__cil_tmp71 ;
  gsm_byte *__cil_tmp72 ;
  gsm_byte *__cil_tmp73 ;
  gsm_byte *__cil_tmp74 ;
  gsm_byte *__cil_tmp75 ;
  gsm_byte *__cil_tmp76 ;
  gsm_byte *__cil_tmp77 ;
  gsm_byte *__cil_tmp78 ;
  gsm_byte *__cil_tmp79 ;
  gsm_byte *__cil_tmp80 ;
  gsm_byte *__cil_tmp81 ;
  gsm_byte *__cil_tmp82 ;
  gsm_byte *__cil_tmp83 ;
  gsm_byte *__cil_tmp84 ;
  gsm_byte *__cil_tmp85 ;
  gsm_byte *__cil_tmp86 ;
  gsm_byte *__cil_tmp87 ;
  gsm_byte *__cil_tmp88 ;
  gsm_byte *__cil_tmp89 ;
  gsm_byte *__cil_tmp90 ;
  gsm_byte *__cil_tmp91 ;
  gsm_byte *__cil_tmp92 ;
  gsm_byte *__cil_tmp93 ;
  gsm_byte *__cil_tmp94 ;
  gsm_byte *__cil_tmp95 ;
  gsm_byte *__cil_tmp96 ;
  gsm_byte *__cil_tmp97 ;
  gsm_byte *__cil_tmp98 ;
  gsm_byte *__cil_tmp99 ;
  gsm_byte *__cil_tmp100 ;
  gsm_byte *__cil_tmp101 ;
  gsm_byte *__cil_tmp102 ;
  gsm_byte *__cil_tmp103 ;
  gsm_byte *__cil_tmp104 ;
  gsm_byte *__cil_tmp105 ;
  gsm_byte *__cil_tmp106 ;
  gsm_byte *__cil_tmp107 ;
  gsm_byte *__cil_tmp108 ;
  gsm_byte *__cil_tmp109 ;

  {
  {
#line 14
  Gsm_Coder(s, source, LARc, Nc, bc, Mc, xmaxc, xmc);
  }
#line 105
  if (s->wav_fmt) {
#line 106
    s->frame_index = (unsigned char )(! s->frame_index);
#line 107
    if (s->frame_index) {
#line 110
      sr = (uint16_t )0;
#line 111
      sr = (uint16_t )(((int )sr >> 6) | ((int )LARc[0] << 10));
#line 112
      sr = (uint16_t )(((int )sr >> 6) | ((int )LARc[1] << 10));
#line 113
      __cil_tmp11 = c;
#line 113
      c ++;
#line 113
      *__cil_tmp11 = (gsm_byte )((int )sr >> 4);
#line 114
      sr = (uint16_t )(((int )sr >> 5) | ((int )LARc[2] << 11));
#line 115
      __cil_tmp12 = c;
#line 115
      c ++;
#line 115
      *__cil_tmp12 = (gsm_byte )((int )sr >> 7);
#line 116
      sr = (uint16_t )(((int )sr >> 5) | ((int )LARc[3] << 11));
#line 117
      sr = (uint16_t )(((int )sr >> 4) | ((int )LARc[4] << 12));
#line 118
      __cil_tmp13 = c;
#line 118
      c ++;
#line 118
      *__cil_tmp13 = (gsm_byte )((int )sr >> 6);
#line 119
      sr = (uint16_t )(((int )sr >> 4) | ((int )LARc[5] << 12));
#line 120
      sr = (uint16_t )(((int )sr >> 3) | ((int )LARc[6] << 13));
#line 121
      __cil_tmp14 = c;
#line 121
      c ++;
#line 121
      *__cil_tmp14 = (gsm_byte )((int )sr >> 7);
#line 122
      sr = (uint16_t )(((int )sr >> 3) | ((int )LARc[7] << 13));
#line 123
      sr = (uint16_t )(((int )sr >> 7) | ((int )Nc[0] << 9));
#line 124
      __cil_tmp15 = c;
#line 124
      c ++;
#line 124
      *__cil_tmp15 = (gsm_byte )((int )sr >> 5);
#line 125
      sr = (uint16_t )(((int )sr >> 2) | ((int )bc[0] << 14));
#line 126
      sr = (uint16_t )(((int )sr >> 2) | ((int )Mc[0] << 14));
#line 127
      sr = (uint16_t )(((int )sr >> 6) | ((int )xmaxc[0] << 10));
#line 128
      __cil_tmp16 = c;
#line 128
      c ++;
#line 128
      *__cil_tmp16 = (gsm_byte )((int )sr >> 3);
#line 129
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[0] << 13));
#line 130
      __cil_tmp17 = c;
#line 130
      c ++;
#line 130
      *__cil_tmp17 = (gsm_byte )((int )sr >> 8);
#line 131
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[1] << 13));
#line 132
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[2] << 13));
#line 133
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[3] << 13));
#line 134
      __cil_tmp18 = c;
#line 134
      c ++;
#line 134
      *__cil_tmp18 = (gsm_byte )((int )sr >> 7);
#line 135
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[4] << 13));
#line 136
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[5] << 13));
#line 137
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[6] << 13));
#line 138
      __cil_tmp19 = c;
#line 138
      c ++;
#line 138
      *__cil_tmp19 = (gsm_byte )((int )sr >> 6);
#line 139
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[7] << 13));
#line 140
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[8] << 13));
#line 141
      __cil_tmp20 = c;
#line 141
      c ++;
#line 141
      *__cil_tmp20 = (gsm_byte )((int )sr >> 8);
#line 142
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[9] << 13));
#line 143
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[10] << 13));
#line 144
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[11] << 13));
#line 145
      __cil_tmp21 = c;
#line 145
      c ++;
#line 145
      *__cil_tmp21 = (gsm_byte )((int )sr >> 7);
#line 146
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[12] << 13));
#line 147
      sr = (uint16_t )(((int )sr >> 7) | ((int )Nc[1] << 9));
#line 148
      __cil_tmp22 = c;
#line 148
      c ++;
#line 148
      *__cil_tmp22 = (gsm_byte )((int )sr >> 5);
#line 149
      sr = (uint16_t )(((int )sr >> 2) | ((int )bc[1] << 14));
#line 150
      sr = (uint16_t )(((int )sr >> 2) | ((int )Mc[1] << 14));
#line 151
      sr = (uint16_t )(((int )sr >> 6) | ((int )xmaxc[1] << 10));
#line 152
      __cil_tmp23 = c;
#line 152
      c ++;
#line 152
      *__cil_tmp23 = (gsm_byte )((int )sr >> 3);
#line 153
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[13] << 13));
#line 154
      __cil_tmp24 = c;
#line 154
      c ++;
#line 154
      *__cil_tmp24 = (gsm_byte )((int )sr >> 8);
#line 155
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[14] << 13));
#line 156
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[15] << 13));
#line 157
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[16] << 13));
#line 158
      __cil_tmp25 = c;
#line 158
      c ++;
#line 158
      *__cil_tmp25 = (gsm_byte )((int )sr >> 7);
#line 159
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[17] << 13));
#line 160
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[18] << 13));
#line 161
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[19] << 13));
#line 162
      __cil_tmp26 = c;
#line 162
      c ++;
#line 162
      *__cil_tmp26 = (gsm_byte )((int )sr >> 6);
#line 163
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[20] << 13));
#line 164
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[21] << 13));
#line 165
      __cil_tmp27 = c;
#line 165
      c ++;
#line 165
      *__cil_tmp27 = (gsm_byte )((int )sr >> 8);
#line 166
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[22] << 13));
#line 167
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[23] << 13));
#line 168
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[24] << 13));
#line 169
      __cil_tmp28 = c;
#line 169
      c ++;
#line 169
      *__cil_tmp28 = (gsm_byte )((int )sr >> 7);
#line 170
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[25] << 13));
#line 171
      sr = (uint16_t )(((int )sr >> 7) | ((int )Nc[2] << 9));
#line 172
      __cil_tmp29 = c;
#line 172
      c ++;
#line 172
      *__cil_tmp29 = (gsm_byte )((int )sr >> 5);
#line 173
      sr = (uint16_t )(((int )sr >> 2) | ((int )bc[2] << 14));
#line 174
      sr = (uint16_t )(((int )sr >> 2) | ((int )Mc[2] << 14));
#line 175
      sr = (uint16_t )(((int )sr >> 6) | ((int )xmaxc[2] << 10));
#line 176
      __cil_tmp30 = c;
#line 176
      c ++;
#line 176
      *__cil_tmp30 = (gsm_byte )((int )sr >> 3);
#line 177
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[26] << 13));
#line 178
      __cil_tmp31 = c;
#line 178
      c ++;
#line 178
      *__cil_tmp31 = (gsm_byte )((int )sr >> 8);
#line 179
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[27] << 13));
#line 180
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[28] << 13));
#line 181
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[29] << 13));
#line 182
      __cil_tmp32 = c;
#line 182
      c ++;
#line 182
      *__cil_tmp32 = (gsm_byte )((int )sr >> 7);
#line 183
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[30] << 13));
#line 184
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[31] << 13));
#line 185
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[32] << 13));
#line 186
      __cil_tmp33 = c;
#line 186
      c ++;
#line 186
      *__cil_tmp33 = (gsm_byte )((int )sr >> 6);
#line 187
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[33] << 13));
#line 188
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[34] << 13));
#line 189
      __cil_tmp34 = c;
#line 189
      c ++;
#line 189
      *__cil_tmp34 = (gsm_byte )((int )sr >> 8);
#line 190
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[35] << 13));
#line 191
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[36] << 13));
#line 192
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[37] << 13));
#line 193
      __cil_tmp35 = c;
#line 193
      c ++;
#line 193
      *__cil_tmp35 = (gsm_byte )((int )sr >> 7);
#line 194
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[38] << 13));
#line 195
      sr = (uint16_t )(((int )sr >> 7) | ((int )Nc[3] << 9));
#line 196
      __cil_tmp36 = c;
#line 196
      c ++;
#line 196
      *__cil_tmp36 = (gsm_byte )((int )sr >> 5);
#line 197
      sr = (uint16_t )(((int )sr >> 2) | ((int )bc[3] << 14));
#line 198
      sr = (uint16_t )(((int )sr >> 2) | ((int )Mc[3] << 14));
#line 199
      sr = (uint16_t )(((int )sr >> 6) | ((int )xmaxc[3] << 10));
#line 200
      __cil_tmp37 = c;
#line 200
      c ++;
#line 200
      *__cil_tmp37 = (gsm_byte )((int )sr >> 3);
#line 201
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[39] << 13));
#line 202
      __cil_tmp38 = c;
#line 202
      c ++;
#line 202
      *__cil_tmp38 = (gsm_byte )((int )sr >> 8);
#line 203
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[40] << 13));
#line 204
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[41] << 13));
#line 205
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[42] << 13));
#line 206
      __cil_tmp39 = c;
#line 206
      c ++;
#line 206
      *__cil_tmp39 = (gsm_byte )((int )sr >> 7);
#line 207
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[43] << 13));
#line 208
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[44] << 13));
#line 209
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[45] << 13));
#line 210
      __cil_tmp40 = c;
#line 210
      c ++;
#line 210
      *__cil_tmp40 = (gsm_byte )((int )sr >> 6);
#line 211
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[46] << 13));
#line 212
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[47] << 13));
#line 213
      __cil_tmp41 = c;
#line 213
      c ++;
#line 213
      *__cil_tmp41 = (gsm_byte )((int )sr >> 8);
#line 214
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[48] << 13));
#line 215
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[49] << 13));
#line 216
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[50] << 13));
#line 217
      __cil_tmp42 = c;
#line 217
      c ++;
#line 217
      *__cil_tmp42 = (gsm_byte )((int )sr >> 7);
#line 218
      sr = (uint16_t )(((int )sr >> 3) | ((int )xmc[51] << 13));
#line 219
      sr = (uint16_t )((int )sr >> 4);
#line 220
      *c = (gsm_byte )((int )sr >> 8);
#line 221
      s->frame_chain = *c;
    } else {
#line 226
      sr___0 = (uint16_t )0;
#line 227
      sr___0 = (uint16_t )(((int )sr___0 >> 4) | ((int )s->frame_chain << 12));
#line 228
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )LARc[0] << 10));
#line 229
      __cil_tmp44 = c;
#line 229
      c ++;
#line 229
      *__cil_tmp44 = (gsm_byte )((int )sr___0 >> 6);
#line 230
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )LARc[1] << 10));
#line 231
      __cil_tmp45 = c;
#line 231
      c ++;
#line 231
      *__cil_tmp45 = (gsm_byte )((int )sr___0 >> 8);
#line 232
      sr___0 = (uint16_t )(((int )sr___0 >> 5) | ((int )LARc[2] << 11));
#line 233
      sr___0 = (uint16_t )(((int )sr___0 >> 5) | ((int )LARc[3] << 11));
#line 234
      __cil_tmp46 = c;
#line 234
      c ++;
#line 234
      *__cil_tmp46 = (gsm_byte )((int )sr___0 >> 6);
#line 235
      sr___0 = (uint16_t )(((int )sr___0 >> 4) | ((int )LARc[4] << 12));
#line 236
      sr___0 = (uint16_t )(((int )sr___0 >> 4) | ((int )LARc[5] << 12));
#line 237
      __cil_tmp47 = c;
#line 237
      c ++;
#line 237
      *__cil_tmp47 = (gsm_byte )((int )sr___0 >> 6);
#line 238
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )LARc[6] << 13));
#line 239
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )LARc[7] << 13));
#line 240
      __cil_tmp48 = c;
#line 240
      c ++;
#line 240
      *__cil_tmp48 = (gsm_byte )((int )sr___0 >> 8);
#line 241
      sr___0 = (uint16_t )(((int )sr___0 >> 7) | ((int )Nc[0] << 9));
#line 242
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )bc[0] << 14));
#line 243
      __cil_tmp49 = c;
#line 243
      c ++;
#line 243
      *__cil_tmp49 = (gsm_byte )((int )sr___0 >> 7);
#line 244
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )Mc[0] << 14));
#line 245
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )xmaxc[0] << 10));
#line 246
      __cil_tmp50 = c;
#line 246
      c ++;
#line 246
      *__cil_tmp50 = (gsm_byte )((int )sr___0 >> 7);
#line 247
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[0] << 13));
#line 248
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[1] << 13));
#line 249
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[2] << 13));
#line 250
      __cil_tmp51 = c;
#line 250
      c ++;
#line 250
      *__cil_tmp51 = (gsm_byte )((int )sr___0 >> 6);
#line 251
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[3] << 13));
#line 252
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[4] << 13));
#line 253
      __cil_tmp52 = c;
#line 253
      c ++;
#line 253
      *__cil_tmp52 = (gsm_byte )((int )sr___0 >> 8);
#line 254
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[5] << 13));
#line 255
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[6] << 13));
#line 256
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[7] << 13));
#line 257
      __cil_tmp53 = c;
#line 257
      c ++;
#line 257
      *__cil_tmp53 = (gsm_byte )((int )sr___0 >> 7);
#line 258
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[8] << 13));
#line 259
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[9] << 13));
#line 260
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[10] << 13));
#line 261
      __cil_tmp54 = c;
#line 261
      c ++;
#line 261
      *__cil_tmp54 = (gsm_byte )((int )sr___0 >> 6);
#line 262
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[11] << 13));
#line 263
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[12] << 13));
#line 264
      __cil_tmp55 = c;
#line 264
      c ++;
#line 264
      *__cil_tmp55 = (gsm_byte )((int )sr___0 >> 8);
#line 265
      sr___0 = (uint16_t )(((int )sr___0 >> 7) | ((int )Nc[1] << 9));
#line 266
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )bc[1] << 14));
#line 267
      __cil_tmp56 = c;
#line 267
      c ++;
#line 267
      *__cil_tmp56 = (gsm_byte )((int )sr___0 >> 7);
#line 268
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )Mc[1] << 14));
#line 269
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )xmaxc[1] << 10));
#line 270
      __cil_tmp57 = c;
#line 270
      c ++;
#line 270
      *__cil_tmp57 = (gsm_byte )((int )sr___0 >> 7);
#line 271
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[13] << 13));
#line 272
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[14] << 13));
#line 273
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[15] << 13));
#line 274
      __cil_tmp58 = c;
#line 274
      c ++;
#line 274
      *__cil_tmp58 = (gsm_byte )((int )sr___0 >> 6);
#line 275
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[16] << 13));
#line 276
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[17] << 13));
#line 277
      __cil_tmp59 = c;
#line 277
      c ++;
#line 277
      *__cil_tmp59 = (gsm_byte )((int )sr___0 >> 8);
#line 278
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[18] << 13));
#line 279
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[19] << 13));
#line 280
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[20] << 13));
#line 281
      __cil_tmp60 = c;
#line 281
      c ++;
#line 281
      *__cil_tmp60 = (gsm_byte )((int )sr___0 >> 7);
#line 282
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[21] << 13));
#line 283
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[22] << 13));
#line 284
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[23] << 13));
#line 285
      __cil_tmp61 = c;
#line 285
      c ++;
#line 285
      *__cil_tmp61 = (gsm_byte )((int )sr___0 >> 6);
#line 286
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[24] << 13));
#line 287
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[25] << 13));
#line 288
      __cil_tmp62 = c;
#line 288
      c ++;
#line 288
      *__cil_tmp62 = (gsm_byte )((int )sr___0 >> 8);
#line 289
      sr___0 = (uint16_t )(((int )sr___0 >> 7) | ((int )Nc[2] << 9));
#line 290
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )bc[2] << 14));
#line 291
      __cil_tmp63 = c;
#line 291
      c ++;
#line 291
      *__cil_tmp63 = (gsm_byte )((int )sr___0 >> 7);
#line 292
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )Mc[2] << 14));
#line 293
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )xmaxc[2] << 10));
#line 294
      __cil_tmp64 = c;
#line 294
      c ++;
#line 294
      *__cil_tmp64 = (gsm_byte )((int )sr___0 >> 7);
#line 295
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[26] << 13));
#line 296
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[27] << 13));
#line 297
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[28] << 13));
#line 298
      __cil_tmp65 = c;
#line 298
      c ++;
#line 298
      *__cil_tmp65 = (gsm_byte )((int )sr___0 >> 6);
#line 299
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[29] << 13));
#line 300
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[30] << 13));
#line 301
      __cil_tmp66 = c;
#line 301
      c ++;
#line 301
      *__cil_tmp66 = (gsm_byte )((int )sr___0 >> 8);
#line 302
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[31] << 13));
#line 303
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[32] << 13));
#line 304
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[33] << 13));
#line 305
      __cil_tmp67 = c;
#line 305
      c ++;
#line 305
      *__cil_tmp67 = (gsm_byte )((int )sr___0 >> 7);
#line 306
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[34] << 13));
#line 307
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[35] << 13));
#line 308
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[36] << 13));
#line 309
      __cil_tmp68 = c;
#line 309
      c ++;
#line 309
      *__cil_tmp68 = (gsm_byte )((int )sr___0 >> 6);
#line 310
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[37] << 13));
#line 311
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[38] << 13));
#line 312
      __cil_tmp69 = c;
#line 312
      c ++;
#line 312
      *__cil_tmp69 = (gsm_byte )((int )sr___0 >> 8);
#line 313
      sr___0 = (uint16_t )(((int )sr___0 >> 7) | ((int )Nc[3] << 9));
#line 314
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )bc[3] << 14));
#line 315
      __cil_tmp70 = c;
#line 315
      c ++;
#line 315
      *__cil_tmp70 = (gsm_byte )((int )sr___0 >> 7);
#line 316
      sr___0 = (uint16_t )(((int )sr___0 >> 2) | ((int )Mc[3] << 14));
#line 317
      sr___0 = (uint16_t )(((int )sr___0 >> 6) | ((int )xmaxc[3] << 10));
#line 318
      __cil_tmp71 = c;
#line 318
      c ++;
#line 318
      *__cil_tmp71 = (gsm_byte )((int )sr___0 >> 7);
#line 319
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[39] << 13));
#line 320
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[40] << 13));
#line 321
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[41] << 13));
#line 322
      __cil_tmp72 = c;
#line 322
      c ++;
#line 322
      *__cil_tmp72 = (gsm_byte )((int )sr___0 >> 6);
#line 323
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[42] << 13));
#line 324
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[43] << 13));
#line 325
      __cil_tmp73 = c;
#line 325
      c ++;
#line 325
      *__cil_tmp73 = (gsm_byte )((int )sr___0 >> 8);
#line 326
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[44] << 13));
#line 327
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[45] << 13));
#line 328
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[46] << 13));
#line 329
      __cil_tmp74 = c;
#line 329
      c ++;
#line 329
      *__cil_tmp74 = (gsm_byte )((int )sr___0 >> 7);
#line 330
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[47] << 13));
#line 331
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[48] << 13));
#line 332
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[49] << 13));
#line 333
      __cil_tmp75 = c;
#line 333
      c ++;
#line 333
      *__cil_tmp75 = (gsm_byte )((int )sr___0 >> 6);
#line 334
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[50] << 13));
#line 335
      sr___0 = (uint16_t )(((int )sr___0 >> 3) | ((int )xmc[51] << 13));
#line 336
      __cil_tmp76 = c;
#line 336
      c ++;
#line 336
      *__cil_tmp76 = (gsm_byte )((int )sr___0 >> 8);
    }
  } else {
#line 345
    __cil_tmp77 = c;
#line 345
    c ++;
#line 345
    *__cil_tmp77 = (gsm_byte )((13 << 4) | (((int )LARc[0] >> 2) & 15));
#line 347
    __cil_tmp78 = c;
#line 347
    c ++;
#line 347
    *__cil_tmp78 = (gsm_byte )((((int )LARc[0] & 3) << 6) | ((int )LARc[1] & 63));
#line 349
    __cil_tmp79 = c;
#line 349
    c ++;
#line 349
    *__cil_tmp79 = (gsm_byte )((((int )LARc[2] & 31) << 3) | (((int )LARc[3] >> 2) & 7));
#line 351
    __cil_tmp80 = c;
#line 351
    c ++;
#line 351
    *__cil_tmp80 = (gsm_byte )(((((int )LARc[3] & 3) << 6) | (((int )LARc[4] & 15) << 2)) | (((int )LARc[5] >> 2) & 3));
#line 354
    __cil_tmp81 = c;
#line 354
    c ++;
#line 354
    *__cil_tmp81 = (gsm_byte )(((((int )LARc[5] & 3) << 6) | (((int )LARc[6] & 7) << 3)) | ((int )LARc[7] & 7));
#line 357
    __cil_tmp82 = c;
#line 357
    c ++;
#line 357
    *__cil_tmp82 = (gsm_byte )((((int )Nc[0] & 127) << 1) | (((int )bc[0] >> 1) & 1));
#line 359
    __cil_tmp83 = c;
#line 359
    c ++;
#line 359
    *__cil_tmp83 = (gsm_byte )(((((int )bc[0] & 1) << 7) | (((int )Mc[0] & 3) << 5)) | (((int )xmaxc[0] >> 1) & 31));
#line 362
    __cil_tmp84 = c;
#line 362
    c ++;
#line 362
    *__cil_tmp84 = (gsm_byte )((((((int )xmaxc[0] & 1) << 7) | (((int )xmc[0] & 7) << 4)) | (((int )xmc[1] & 7) << 1)) | (((int )xmc[2] >> 2) & 1));
#line 366
    __cil_tmp85 = c;
#line 366
    c ++;
#line 366
    *__cil_tmp85 = (gsm_byte )(((((int )xmc[2] & 3) << 6) | (((int )xmc[3] & 7) << 3)) | ((int )xmc[4] & 7));
#line 369
    __cil_tmp86 = c;
#line 369
    c ++;
#line 369
    *__cil_tmp86 = (gsm_byte )(((((int )xmc[5] & 7) << 5) | (((int )xmc[6] & 7) << 2)) | (((int )xmc[7] >> 1) & 3));
#line 372
    __cil_tmp87 = c;
#line 372
    c ++;
#line 372
    *__cil_tmp87 = (gsm_byte )((((((int )xmc[7] & 1) << 7) | (((int )xmc[8] & 7) << 4)) | (((int )xmc[9] & 7) << 1)) | (((int )xmc[10] >> 2) & 1));
#line 376
    __cil_tmp88 = c;
#line 376
    c ++;
#line 376
    *__cil_tmp88 = (gsm_byte )(((((int )xmc[10] & 3) << 6) | (((int )xmc[11] & 7) << 3)) | ((int )xmc[12] & 7));
#line 379
    __cil_tmp89 = c;
#line 379
    c ++;
#line 379
    *__cil_tmp89 = (gsm_byte )((((int )Nc[1] & 127) << 1) | (((int )bc[1] >> 1) & 1));
#line 381
    __cil_tmp90 = c;
#line 381
    c ++;
#line 381
    *__cil_tmp90 = (gsm_byte )(((((int )bc[1] & 1) << 7) | (((int )Mc[1] & 3) << 5)) | (((int )xmaxc[1] >> 1) & 31));
#line 384
    __cil_tmp91 = c;
#line 384
    c ++;
#line 384
    *__cil_tmp91 = (gsm_byte )((((((int )xmaxc[1] & 1) << 7) | (((int )xmc[13] & 7) << 4)) | (((int )xmc[14] & 7) << 1)) | (((int )xmc[15] >> 2) & 1));
#line 388
    __cil_tmp92 = c;
#line 388
    c ++;
#line 388
    *__cil_tmp92 = (gsm_byte )(((((int )xmc[15] & 3) << 6) | (((int )xmc[16] & 7) << 3)) | ((int )xmc[17] & 7));
#line 391
    __cil_tmp93 = c;
#line 391
    c ++;
#line 391
    *__cil_tmp93 = (gsm_byte )(((((int )xmc[18] & 7) << 5) | (((int )xmc[19] & 7) << 2)) | (((int )xmc[20] >> 1) & 3));
#line 394
    __cil_tmp94 = c;
#line 394
    c ++;
#line 394
    *__cil_tmp94 = (gsm_byte )((((((int )xmc[20] & 1) << 7) | (((int )xmc[21] & 7) << 4)) | (((int )xmc[22] & 7) << 1)) | (((int )xmc[23] >> 2) & 1));
#line 398
    __cil_tmp95 = c;
#line 398
    c ++;
#line 398
    *__cil_tmp95 = (gsm_byte )(((((int )xmc[23] & 3) << 6) | (((int )xmc[24] & 7) << 3)) | ((int )xmc[25] & 7));
#line 401
    __cil_tmp96 = c;
#line 401
    c ++;
#line 401
    *__cil_tmp96 = (gsm_byte )((((int )Nc[2] & 127) << 1) | (((int )bc[2] >> 1) & 1));
#line 403
    __cil_tmp97 = c;
#line 403
    c ++;
#line 403
    *__cil_tmp97 = (gsm_byte )(((((int )bc[2] & 1) << 7) | (((int )Mc[2] & 3) << 5)) | (((int )xmaxc[2] >> 1) & 31));
#line 406
    __cil_tmp98 = c;
#line 406
    c ++;
#line 406
    *__cil_tmp98 = (gsm_byte )((((((int )xmaxc[2] & 1) << 7) | (((int )xmc[26] & 7) << 4)) | (((int )xmc[27] & 7) << 1)) | (((int )xmc[28] >> 2) & 1));
#line 410
    __cil_tmp99 = c;
#line 410
    c ++;
#line 410
    *__cil_tmp99 = (gsm_byte )(((((int )xmc[28] & 3) << 6) | (((int )xmc[29] & 7) << 3)) | ((int )xmc[30] & 7));
#line 413
    __cil_tmp100 = c;
#line 413
    c ++;
#line 413
    *__cil_tmp100 = (gsm_byte )(((((int )xmc[31] & 7) << 5) | (((int )xmc[32] & 7) << 2)) | (((int )xmc[33] >> 1) & 3));
#line 416
    __cil_tmp101 = c;
#line 416
    c ++;
#line 416
    *__cil_tmp101 = (gsm_byte )((((((int )xmc[33] & 1) << 7) | (((int )xmc[34] & 7) << 4)) | (((int )xmc[35] & 7) << 1)) | (((int )xmc[36] >> 2) & 1));
#line 420
    __cil_tmp102 = c;
#line 420
    c ++;
#line 420
    *__cil_tmp102 = (gsm_byte )(((((int )xmc[36] & 3) << 6) | (((int )xmc[37] & 7) << 3)) | ((int )xmc[38] & 7));
#line 423
    __cil_tmp103 = c;
#line 423
    c ++;
#line 423
    *__cil_tmp103 = (gsm_byte )((((int )Nc[3] & 127) << 1) | (((int )bc[3] >> 1) & 1));
#line 425
    __cil_tmp104 = c;
#line 425
    c ++;
#line 425
    *__cil_tmp104 = (gsm_byte )(((((int )bc[3] & 1) << 7) | (((int )Mc[3] & 3) << 5)) | (((int )xmaxc[3] >> 1) & 31));
#line 428
    __cil_tmp105 = c;
#line 428
    c ++;
#line 428
    *__cil_tmp105 = (gsm_byte )((((((int )xmaxc[3] & 1) << 7) | (((int )xmc[39] & 7) << 4)) | (((int )xmc[40] & 7) << 1)) | (((int )xmc[41] >> 2) & 1));
#line 432
    __cil_tmp106 = c;
#line 432
    c ++;
#line 432
    *__cil_tmp106 = (gsm_byte )(((((int )xmc[41] & 3) << 6) | (((int )xmc[42] & 7) << 3)) | ((int )xmc[43] & 7));
#line 435
    __cil_tmp107 = c;
#line 435
    c ++;
#line 435
    *__cil_tmp107 = (gsm_byte )(((((int )xmc[44] & 7) << 5) | (((int )xmc[45] & 7) << 2)) | (((int )xmc[46] >> 1) & 3));
#line 438
    __cil_tmp108 = c;
#line 438
    c ++;
#line 438
    *__cil_tmp108 = (gsm_byte )((((((int )xmc[46] & 1) << 7) | (((int )xmc[47] & 7) << 4)) | (((int )xmc[48] & 7) << 1)) | (((int )xmc[49] >> 2) & 1));
#line 442
    __cil_tmp109 = c;
#line 442
    c ++;
#line 442
    *__cil_tmp109 = (gsm_byte )(((((int )xmc[49] & 3) << 6) | (((int )xmc[50] & 7) << 3)) | ((int )xmc[51] & 7));
  }
#line 444
  return;
}
}
#line 20 "/root/patchweave_donee/23/src/GSM610/gsm_destroy.c"
void gsm_destroy(gsm S ) 
{ 


  {
#line 22
  if (S) {
    {
#line 23
    free((void *)((char *)S));
    }
  }
#line 26
  return;
}
}
#line 11 "/root/patchweave_donee/23/src/GSM610/gsm_decode.c"
int gsm_decode(gsm s , gsm_byte *c , gsm_signal *target ) 
{ 
  int16_t LARc[8] ;
  int16_t Nc[4] ;
  int16_t Mc[4] ;
  int16_t bc[4] ;
  int16_t xmaxc[4] ;
  int16_t xmc[52] ;
  uint16_t sr ;
  gsm_byte *__cil_tmp11 ;
  gsm_byte *__cil_tmp12 ;
  gsm_byte *__cil_tmp13 ;
  gsm_byte *__cil_tmp14 ;
  gsm_byte *__cil_tmp15 ;
  gsm_byte *__cil_tmp16 ;
  gsm_byte *__cil_tmp17 ;
  gsm_byte *__cil_tmp18 ;
  gsm_byte *__cil_tmp19 ;
  gsm_byte *__cil_tmp20 ;
  gsm_byte *__cil_tmp21 ;
  gsm_byte *__cil_tmp22 ;
  gsm_byte *__cil_tmp23 ;
  gsm_byte *__cil_tmp24 ;
  gsm_byte *__cil_tmp25 ;
  gsm_byte *__cil_tmp26 ;
  gsm_byte *__cil_tmp27 ;
  gsm_byte *__cil_tmp28 ;
  gsm_byte *__cil_tmp29 ;
  gsm_byte *__cil_tmp30 ;
  gsm_byte *__cil_tmp31 ;
  gsm_byte *__cil_tmp32 ;
  gsm_byte *__cil_tmp33 ;
  gsm_byte *__cil_tmp34 ;
  gsm_byte *__cil_tmp35 ;
  gsm_byte *__cil_tmp36 ;
  gsm_byte *__cil_tmp37 ;
  gsm_byte *__cil_tmp38 ;
  gsm_byte *__cil_tmp39 ;
  gsm_byte *__cil_tmp40 ;
  gsm_byte *__cil_tmp41 ;
  gsm_byte *__cil_tmp42 ;
  gsm_byte *__cil_tmp43 ;
  gsm_byte *__cil_tmp44 ;
  gsm_byte *__cil_tmp45 ;
  gsm_byte *__cil_tmp46 ;
  gsm_byte *__cil_tmp47 ;
  gsm_byte *__cil_tmp48 ;
  gsm_byte *__cil_tmp49 ;
  gsm_byte *__cil_tmp50 ;
  gsm_byte *__cil_tmp51 ;
  gsm_byte *__cil_tmp52 ;
  gsm_byte *__cil_tmp53 ;
  gsm_byte *__cil_tmp54 ;
  gsm_byte *__cil_tmp55 ;
  gsm_byte *__cil_tmp56 ;
  gsm_byte *__cil_tmp57 ;
  gsm_byte *__cil_tmp58 ;
  gsm_byte *__cil_tmp59 ;
  gsm_byte *__cil_tmp60 ;
  gsm_byte *__cil_tmp61 ;
  gsm_byte *__cil_tmp62 ;
  gsm_byte *__cil_tmp63 ;
  gsm_byte *__cil_tmp64 ;
  gsm_byte *__cil_tmp65 ;
  gsm_byte *__cil_tmp66 ;
  gsm_byte *__cil_tmp67 ;
  gsm_byte *__cil_tmp68 ;
  gsm_byte *__cil_tmp69 ;
  gsm_byte *__cil_tmp70 ;
  gsm_byte *__cil_tmp71 ;
  gsm_byte *__cil_tmp72 ;
  gsm_byte *__cil_tmp73 ;
  gsm_byte *__cil_tmp74 ;
  gsm_byte *__cil_tmp75 ;
  gsm_byte *__cil_tmp76 ;
  gsm_byte *__cil_tmp77 ;
  gsm_byte *__cil_tmp78 ;
  gsm_byte *__cil_tmp79 ;
  gsm_byte *__cil_tmp80 ;
  gsm_byte *__cil_tmp81 ;
  gsm_byte *__cil_tmp82 ;
  gsm_byte *__cil_tmp83 ;
  gsm_byte *__cil_tmp84 ;
  gsm_byte *__cil_tmp85 ;
  gsm_byte *__cil_tmp86 ;
  gsm_byte *__cil_tmp87 ;
  gsm_byte *__cil_tmp88 ;
  gsm_byte *__cil_tmp89 ;
  gsm_byte *__cil_tmp90 ;
  gsm_byte *__cil_tmp91 ;
  gsm_byte *__cil_tmp92 ;
  gsm_byte *__cil_tmp93 ;
  gsm_byte *__cil_tmp94 ;
  gsm_byte *__cil_tmp95 ;
  gsm_byte *__cil_tmp96 ;
  gsm_byte *__cil_tmp97 ;
  gsm_byte *__cil_tmp98 ;
  gsm_byte *__cil_tmp99 ;
  gsm_byte *__cil_tmp100 ;
  gsm_byte *__cil_tmp101 ;
  gsm_byte *__cil_tmp102 ;
  gsm_byte *__cil_tmp103 ;
  gsm_byte *__cil_tmp104 ;
  gsm_byte *__cil_tmp105 ;
  gsm_byte *__cil_tmp106 ;
  gsm_byte *__cil_tmp107 ;

  {
#line 16
  if (s->wav_fmt) {
#line 17
    sr = (uint16_t )0;
#line 19
    s->frame_index = (unsigned char )(! s->frame_index);
#line 20
    if (s->frame_index) {
#line 21
      __cil_tmp11 = c;
#line 21
      c ++;
#line 21
      sr = (uint16_t )*__cil_tmp11;
#line 22
      LARc[0] = (int16_t )((int )sr & 63);
#line 22
      sr = (uint16_t )((int )sr >> 6);
#line 23
      __cil_tmp12 = c;
#line 23
      c ++;
#line 23
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp12) << 2));
#line 24
      LARc[1] = (int16_t )((int )sr & 63);
#line 24
      sr = (uint16_t )((int )sr >> 6);
#line 25
      __cil_tmp13 = c;
#line 25
      c ++;
#line 25
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp13) << 4));
#line 26
      LARc[2] = (int16_t )((int )sr & 31);
#line 26
      sr = (uint16_t )((int )sr >> 5);
#line 27
      LARc[3] = (int16_t )((int )sr & 31);
#line 27
      sr = (uint16_t )((int )sr >> 5);
#line 28
      __cil_tmp14 = c;
#line 28
      c ++;
#line 28
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp14) << 2));
#line 29
      LARc[4] = (int16_t )((int )sr & 15);
#line 29
      sr = (uint16_t )((int )sr >> 4);
#line 30
      LARc[5] = (int16_t )((int )sr & 15);
#line 30
      sr = (uint16_t )((int )sr >> 4);
#line 31
      __cil_tmp15 = c;
#line 31
      c ++;
#line 31
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp15) << 2));
#line 32
      LARc[6] = (int16_t )((int )sr & 7);
#line 32
      sr = (uint16_t )((int )sr >> 3);
#line 33
      LARc[7] = (int16_t )((int )sr & 7);
#line 33
      sr = (uint16_t )((int )sr >> 3);
#line 34
      __cil_tmp16 = c;
#line 34
      c ++;
#line 34
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp16) << 4));
#line 35
      Nc[0] = (int16_t )((int )sr & 127);
#line 35
      sr = (uint16_t )((int )sr >> 7);
#line 36
      bc[0] = (int16_t )((int )sr & 3);
#line 36
      sr = (uint16_t )((int )sr >> 2);
#line 37
      Mc[0] = (int16_t )((int )sr & 3);
#line 37
      sr = (uint16_t )((int )sr >> 2);
#line 38
      __cil_tmp17 = c;
#line 38
      c ++;
#line 38
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp17) << 1));
#line 39
      xmaxc[0] = (int16_t )((int )sr & 63);
#line 39
      sr = (uint16_t )((int )sr >> 6);
#line 40
      xmc[0] = (int16_t )((int )sr & 7);
#line 40
      sr = (uint16_t )((int )sr >> 3);
#line 41
      __cil_tmp18 = c;
#line 41
      c ++;
#line 41
      sr = (uint16_t )*__cil_tmp18;
#line 42
      xmc[1] = (int16_t )((int )sr & 7);
#line 42
      sr = (uint16_t )((int )sr >> 3);
#line 43
      xmc[2] = (int16_t )((int )sr & 7);
#line 43
      sr = (uint16_t )((int )sr >> 3);
#line 44
      __cil_tmp19 = c;
#line 44
      c ++;
#line 44
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp19) << 2));
#line 45
      xmc[3] = (int16_t )((int )sr & 7);
#line 45
      sr = (uint16_t )((int )sr >> 3);
#line 46
      xmc[4] = (int16_t )((int )sr & 7);
#line 46
      sr = (uint16_t )((int )sr >> 3);
#line 47
      xmc[5] = (int16_t )((int )sr & 7);
#line 47
      sr = (uint16_t )((int )sr >> 3);
#line 48
      __cil_tmp20 = c;
#line 48
      c ++;
#line 48
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp20) << 1));
#line 49
      xmc[6] = (int16_t )((int )sr & 7);
#line 49
      sr = (uint16_t )((int )sr >> 3);
#line 50
      xmc[7] = (int16_t )((int )sr & 7);
#line 50
      sr = (uint16_t )((int )sr >> 3);
#line 51
      xmc[8] = (int16_t )((int )sr & 7);
#line 51
      sr = (uint16_t )((int )sr >> 3);
#line 52
      __cil_tmp21 = c;
#line 52
      c ++;
#line 52
      sr = (uint16_t )*__cil_tmp21;
#line 53
      xmc[9] = (int16_t )((int )sr & 7);
#line 53
      sr = (uint16_t )((int )sr >> 3);
#line 54
      xmc[10] = (int16_t )((int )sr & 7);
#line 54
      sr = (uint16_t )((int )sr >> 3);
#line 55
      __cil_tmp22 = c;
#line 55
      c ++;
#line 55
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp22) << 2));
#line 56
      xmc[11] = (int16_t )((int )sr & 7);
#line 56
      sr = (uint16_t )((int )sr >> 3);
#line 57
      xmc[12] = (int16_t )((int )sr & 7);
#line 57
      sr = (uint16_t )((int )sr >> 3);
#line 58
      __cil_tmp23 = c;
#line 58
      c ++;
#line 58
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp23) << 4));
#line 59
      Nc[1] = (int16_t )((int )sr & 127);
#line 59
      sr = (uint16_t )((int )sr >> 7);
#line 60
      bc[1] = (int16_t )((int )sr & 3);
#line 60
      sr = (uint16_t )((int )sr >> 2);
#line 61
      Mc[1] = (int16_t )((int )sr & 3);
#line 61
      sr = (uint16_t )((int )sr >> 2);
#line 62
      __cil_tmp24 = c;
#line 62
      c ++;
#line 62
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp24) << 1));
#line 63
      xmaxc[1] = (int16_t )((int )sr & 63);
#line 63
      sr = (uint16_t )((int )sr >> 6);
#line 64
      xmc[13] = (int16_t )((int )sr & 7);
#line 64
      sr = (uint16_t )((int )sr >> 3);
#line 65
      __cil_tmp25 = c;
#line 65
      c ++;
#line 65
      sr = (uint16_t )*__cil_tmp25;
#line 66
      xmc[14] = (int16_t )((int )sr & 7);
#line 66
      sr = (uint16_t )((int )sr >> 3);
#line 67
      xmc[15] = (int16_t )((int )sr & 7);
#line 67
      sr = (uint16_t )((int )sr >> 3);
#line 68
      __cil_tmp26 = c;
#line 68
      c ++;
#line 68
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp26) << 2));
#line 69
      xmc[16] = (int16_t )((int )sr & 7);
#line 69
      sr = (uint16_t )((int )sr >> 3);
#line 70
      xmc[17] = (int16_t )((int )sr & 7);
#line 70
      sr = (uint16_t )((int )sr >> 3);
#line 71
      xmc[18] = (int16_t )((int )sr & 7);
#line 71
      sr = (uint16_t )((int )sr >> 3);
#line 72
      __cil_tmp27 = c;
#line 72
      c ++;
#line 72
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp27) << 1));
#line 73
      xmc[19] = (int16_t )((int )sr & 7);
#line 73
      sr = (uint16_t )((int )sr >> 3);
#line 74
      xmc[20] = (int16_t )((int )sr & 7);
#line 74
      sr = (uint16_t )((int )sr >> 3);
#line 75
      xmc[21] = (int16_t )((int )sr & 7);
#line 75
      sr = (uint16_t )((int )sr >> 3);
#line 76
      __cil_tmp28 = c;
#line 76
      c ++;
#line 76
      sr = (uint16_t )*__cil_tmp28;
#line 77
      xmc[22] = (int16_t )((int )sr & 7);
#line 77
      sr = (uint16_t )((int )sr >> 3);
#line 78
      xmc[23] = (int16_t )((int )sr & 7);
#line 78
      sr = (uint16_t )((int )sr >> 3);
#line 79
      __cil_tmp29 = c;
#line 79
      c ++;
#line 79
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp29) << 2));
#line 80
      xmc[24] = (int16_t )((int )sr & 7);
#line 80
      sr = (uint16_t )((int )sr >> 3);
#line 81
      xmc[25] = (int16_t )((int )sr & 7);
#line 81
      sr = (uint16_t )((int )sr >> 3);
#line 82
      __cil_tmp30 = c;
#line 82
      c ++;
#line 82
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp30) << 4));
#line 83
      Nc[2] = (int16_t )((int )sr & 127);
#line 83
      sr = (uint16_t )((int )sr >> 7);
#line 84
      bc[2] = (int16_t )((int )sr & 3);
#line 84
      sr = (uint16_t )((int )sr >> 2);
#line 85
      Mc[2] = (int16_t )((int )sr & 3);
#line 85
      sr = (uint16_t )((int )sr >> 2);
#line 86
      __cil_tmp31 = c;
#line 86
      c ++;
#line 86
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp31) << 1));
#line 87
      xmaxc[2] = (int16_t )((int )sr & 63);
#line 87
      sr = (uint16_t )((int )sr >> 6);
#line 88
      xmc[26] = (int16_t )((int )sr & 7);
#line 88
      sr = (uint16_t )((int )sr >> 3);
#line 89
      __cil_tmp32 = c;
#line 89
      c ++;
#line 89
      sr = (uint16_t )*__cil_tmp32;
#line 90
      xmc[27] = (int16_t )((int )sr & 7);
#line 90
      sr = (uint16_t )((int )sr >> 3);
#line 91
      xmc[28] = (int16_t )((int )sr & 7);
#line 91
      sr = (uint16_t )((int )sr >> 3);
#line 92
      __cil_tmp33 = c;
#line 92
      c ++;
#line 92
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp33) << 2));
#line 93
      xmc[29] = (int16_t )((int )sr & 7);
#line 93
      sr = (uint16_t )((int )sr >> 3);
#line 94
      xmc[30] = (int16_t )((int )sr & 7);
#line 94
      sr = (uint16_t )((int )sr >> 3);
#line 95
      xmc[31] = (int16_t )((int )sr & 7);
#line 95
      sr = (uint16_t )((int )sr >> 3);
#line 96
      __cil_tmp34 = c;
#line 96
      c ++;
#line 96
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp34) << 1));
#line 97
      xmc[32] = (int16_t )((int )sr & 7);
#line 97
      sr = (uint16_t )((int )sr >> 3);
#line 98
      xmc[33] = (int16_t )((int )sr & 7);
#line 98
      sr = (uint16_t )((int )sr >> 3);
#line 99
      xmc[34] = (int16_t )((int )sr & 7);
#line 99
      sr = (uint16_t )((int )sr >> 3);
#line 100
      __cil_tmp35 = c;
#line 100
      c ++;
#line 100
      sr = (uint16_t )*__cil_tmp35;
#line 101
      xmc[35] = (int16_t )((int )sr & 7);
#line 101
      sr = (uint16_t )((int )sr >> 3);
#line 102
      xmc[36] = (int16_t )((int )sr & 7);
#line 102
      sr = (uint16_t )((int )sr >> 3);
#line 103
      __cil_tmp36 = c;
#line 103
      c ++;
#line 103
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp36) << 2));
#line 104
      xmc[37] = (int16_t )((int )sr & 7);
#line 104
      sr = (uint16_t )((int )sr >> 3);
#line 105
      xmc[38] = (int16_t )((int )sr & 7);
#line 105
      sr = (uint16_t )((int )sr >> 3);
#line 106
      __cil_tmp37 = c;
#line 106
      c ++;
#line 106
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp37) << 4));
#line 107
      Nc[3] = (int16_t )((int )sr & 127);
#line 107
      sr = (uint16_t )((int )sr >> 7);
#line 108
      bc[3] = (int16_t )((int )sr & 3);
#line 108
      sr = (uint16_t )((int )sr >> 2);
#line 109
      Mc[3] = (int16_t )((int )sr & 3);
#line 109
      sr = (uint16_t )((int )sr >> 2);
#line 110
      __cil_tmp38 = c;
#line 110
      c ++;
#line 110
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp38) << 1));
#line 111
      xmaxc[3] = (int16_t )((int )sr & 63);
#line 111
      sr = (uint16_t )((int )sr >> 6);
#line 112
      xmc[39] = (int16_t )((int )sr & 7);
#line 112
      sr = (uint16_t )((int )sr >> 3);
#line 113
      __cil_tmp39 = c;
#line 113
      c ++;
#line 113
      sr = (uint16_t )*__cil_tmp39;
#line 114
      xmc[40] = (int16_t )((int )sr & 7);
#line 114
      sr = (uint16_t )((int )sr >> 3);
#line 115
      xmc[41] = (int16_t )((int )sr & 7);
#line 115
      sr = (uint16_t )((int )sr >> 3);
#line 116
      __cil_tmp40 = c;
#line 116
      c ++;
#line 116
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp40) << 2));
#line 117
      xmc[42] = (int16_t )((int )sr & 7);
#line 117
      sr = (uint16_t )((int )sr >> 3);
#line 118
      xmc[43] = (int16_t )((int )sr & 7);
#line 118
      sr = (uint16_t )((int )sr >> 3);
#line 119
      xmc[44] = (int16_t )((int )sr & 7);
#line 119
      sr = (uint16_t )((int )sr >> 3);
#line 120
      __cil_tmp41 = c;
#line 120
      c ++;
#line 120
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp41) << 1));
#line 121
      xmc[45] = (int16_t )((int )sr & 7);
#line 121
      sr = (uint16_t )((int )sr >> 3);
#line 122
      xmc[46] = (int16_t )((int )sr & 7);
#line 122
      sr = (uint16_t )((int )sr >> 3);
#line 123
      xmc[47] = (int16_t )((int )sr & 7);
#line 123
      sr = (uint16_t )((int )sr >> 3);
#line 124
      __cil_tmp42 = c;
#line 124
      c ++;
#line 124
      sr = (uint16_t )*__cil_tmp42;
#line 125
      xmc[48] = (int16_t )((int )sr & 7);
#line 125
      sr = (uint16_t )((int )sr >> 3);
#line 126
      xmc[49] = (int16_t )((int )sr & 7);
#line 126
      sr = (uint16_t )((int )sr >> 3);
#line 127
      __cil_tmp43 = c;
#line 127
      c ++;
#line 127
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp43) << 2));
#line 128
      xmc[50] = (int16_t )((int )sr & 7);
#line 128
      sr = (uint16_t )((int )sr >> 3);
#line 129
      xmc[51] = (int16_t )((int )sr & 7);
#line 129
      sr = (uint16_t )((int )sr >> 3);
#line 131
      s->frame_chain = (unsigned char )((int )sr & 15);
    } else {
#line 134
      sr = (uint16_t )s->frame_chain;
#line 135
      __cil_tmp44 = c;
#line 135
      c ++;
#line 135
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp44) << 4));
#line 136
      LARc[0] = (int16_t )((int )sr & 63);
#line 136
      sr = (uint16_t )((int )sr >> 6);
#line 137
      LARc[1] = (int16_t )((int )sr & 63);
#line 137
      sr = (uint16_t )((int )sr >> 6);
#line 138
      __cil_tmp45 = c;
#line 138
      c ++;
#line 138
      sr = (uint16_t )*__cil_tmp45;
#line 139
      LARc[2] = (int16_t )((int )sr & 31);
#line 139
      sr = (uint16_t )((int )sr >> 5);
#line 140
      __cil_tmp46 = c;
#line 140
      c ++;
#line 140
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp46) << 3));
#line 141
      LARc[3] = (int16_t )((int )sr & 31);
#line 141
      sr = (uint16_t )((int )sr >> 5);
#line 142
      LARc[4] = (int16_t )((int )sr & 15);
#line 142
      sr = (uint16_t )((int )sr >> 4);
#line 143
      __cil_tmp47 = c;
#line 143
      c ++;
#line 143
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp47) << 2));
#line 144
      LARc[5] = (int16_t )((int )sr & 15);
#line 144
      sr = (uint16_t )((int )sr >> 4);
#line 145
      LARc[6] = (int16_t )((int )sr & 7);
#line 145
      sr = (uint16_t )((int )sr >> 3);
#line 146
      LARc[7] = (int16_t )((int )sr & 7);
#line 146
      sr = (uint16_t )((int )sr >> 3);
#line 147
      __cil_tmp48 = c;
#line 147
      c ++;
#line 147
      sr = (uint16_t )*__cil_tmp48;
#line 148
      Nc[0] = (int16_t )((int )sr & 127);
#line 148
      sr = (uint16_t )((int )sr >> 7);
#line 149
      __cil_tmp49 = c;
#line 149
      c ++;
#line 149
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp49) << 1));
#line 150
      bc[0] = (int16_t )((int )sr & 3);
#line 150
      sr = (uint16_t )((int )sr >> 2);
#line 151
      Mc[0] = (int16_t )((int )sr & 3);
#line 151
      sr = (uint16_t )((int )sr >> 2);
#line 152
      __cil_tmp50 = c;
#line 152
      c ++;
#line 152
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp50) << 5));
#line 153
      xmaxc[0] = (int16_t )((int )sr & 63);
#line 153
      sr = (uint16_t )((int )sr >> 6);
#line 154
      xmc[0] = (int16_t )((int )sr & 7);
#line 154
      sr = (uint16_t )((int )sr >> 3);
#line 155
      xmc[1] = (int16_t )((int )sr & 7);
#line 155
      sr = (uint16_t )((int )sr >> 3);
#line 156
      __cil_tmp51 = c;
#line 156
      c ++;
#line 156
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp51) << 1));
#line 157
      xmc[2] = (int16_t )((int )sr & 7);
#line 157
      sr = (uint16_t )((int )sr >> 3);
#line 158
      xmc[3] = (int16_t )((int )sr & 7);
#line 158
      sr = (uint16_t )((int )sr >> 3);
#line 159
      xmc[4] = (int16_t )((int )sr & 7);
#line 159
      sr = (uint16_t )((int )sr >> 3);
#line 160
      __cil_tmp52 = c;
#line 160
      c ++;
#line 160
      sr = (uint16_t )*__cil_tmp52;
#line 161
      xmc[5] = (int16_t )((int )sr & 7);
#line 161
      sr = (uint16_t )((int )sr >> 3);
#line 162
      xmc[6] = (int16_t )((int )sr & 7);
#line 162
      sr = (uint16_t )((int )sr >> 3);
#line 163
      __cil_tmp53 = c;
#line 163
      c ++;
#line 163
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp53) << 2));
#line 164
      xmc[7] = (int16_t )((int )sr & 7);
#line 164
      sr = (uint16_t )((int )sr >> 3);
#line 165
      xmc[8] = (int16_t )((int )sr & 7);
#line 165
      sr = (uint16_t )((int )sr >> 3);
#line 166
      xmc[9] = (int16_t )((int )sr & 7);
#line 166
      sr = (uint16_t )((int )sr >> 3);
#line 167
      __cil_tmp54 = c;
#line 167
      c ++;
#line 167
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp54) << 1));
#line 168
      xmc[10] = (int16_t )((int )sr & 7);
#line 168
      sr = (uint16_t )((int )sr >> 3);
#line 169
      xmc[11] = (int16_t )((int )sr & 7);
#line 169
      sr = (uint16_t )((int )sr >> 3);
#line 170
      xmc[12] = (int16_t )((int )sr & 7);
#line 170
      sr = (uint16_t )((int )sr >> 3);
#line 171
      __cil_tmp55 = c;
#line 171
      c ++;
#line 171
      sr = (uint16_t )*__cil_tmp55;
#line 172
      Nc[1] = (int16_t )((int )sr & 127);
#line 172
      sr = (uint16_t )((int )sr >> 7);
#line 173
      __cil_tmp56 = c;
#line 173
      c ++;
#line 173
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp56) << 1));
#line 174
      bc[1] = (int16_t )((int )sr & 3);
#line 174
      sr = (uint16_t )((int )sr >> 2);
#line 175
      Mc[1] = (int16_t )((int )sr & 3);
#line 175
      sr = (uint16_t )((int )sr >> 2);
#line 176
      __cil_tmp57 = c;
#line 176
      c ++;
#line 176
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp57) << 5));
#line 177
      xmaxc[1] = (int16_t )((int )sr & 63);
#line 177
      sr = (uint16_t )((int )sr >> 6);
#line 178
      xmc[13] = (int16_t )((int )sr & 7);
#line 178
      sr = (uint16_t )((int )sr >> 3);
#line 179
      xmc[14] = (int16_t )((int )sr & 7);
#line 179
      sr = (uint16_t )((int )sr >> 3);
#line 180
      __cil_tmp58 = c;
#line 180
      c ++;
#line 180
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp58) << 1));
#line 181
      xmc[15] = (int16_t )((int )sr & 7);
#line 181
      sr = (uint16_t )((int )sr >> 3);
#line 182
      xmc[16] = (int16_t )((int )sr & 7);
#line 182
      sr = (uint16_t )((int )sr >> 3);
#line 183
      xmc[17] = (int16_t )((int )sr & 7);
#line 183
      sr = (uint16_t )((int )sr >> 3);
#line 184
      __cil_tmp59 = c;
#line 184
      c ++;
#line 184
      sr = (uint16_t )*__cil_tmp59;
#line 185
      xmc[18] = (int16_t )((int )sr & 7);
#line 185
      sr = (uint16_t )((int )sr >> 3);
#line 186
      xmc[19] = (int16_t )((int )sr & 7);
#line 186
      sr = (uint16_t )((int )sr >> 3);
#line 187
      __cil_tmp60 = c;
#line 187
      c ++;
#line 187
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp60) << 2));
#line 188
      xmc[20] = (int16_t )((int )sr & 7);
#line 188
      sr = (uint16_t )((int )sr >> 3);
#line 189
      xmc[21] = (int16_t )((int )sr & 7);
#line 189
      sr = (uint16_t )((int )sr >> 3);
#line 190
      xmc[22] = (int16_t )((int )sr & 7);
#line 190
      sr = (uint16_t )((int )sr >> 3);
#line 191
      __cil_tmp61 = c;
#line 191
      c ++;
#line 191
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp61) << 1));
#line 192
      xmc[23] = (int16_t )((int )sr & 7);
#line 192
      sr = (uint16_t )((int )sr >> 3);
#line 193
      xmc[24] = (int16_t )((int )sr & 7);
#line 193
      sr = (uint16_t )((int )sr >> 3);
#line 194
      xmc[25] = (int16_t )((int )sr & 7);
#line 194
      sr = (uint16_t )((int )sr >> 3);
#line 195
      __cil_tmp62 = c;
#line 195
      c ++;
#line 195
      sr = (uint16_t )*__cil_tmp62;
#line 196
      Nc[2] = (int16_t )((int )sr & 127);
#line 196
      sr = (uint16_t )((int )sr >> 7);
#line 197
      __cil_tmp63 = c;
#line 197
      c ++;
#line 197
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp63) << 1));
#line 198
      bc[2] = (int16_t )((int )sr & 3);
#line 198
      sr = (uint16_t )((int )sr >> 2);
#line 199
      Mc[2] = (int16_t )((int )sr & 3);
#line 199
      sr = (uint16_t )((int )sr >> 2);
#line 200
      __cil_tmp64 = c;
#line 200
      c ++;
#line 200
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp64) << 5));
#line 201
      xmaxc[2] = (int16_t )((int )sr & 63);
#line 201
      sr = (uint16_t )((int )sr >> 6);
#line 202
      xmc[26] = (int16_t )((int )sr & 7);
#line 202
      sr = (uint16_t )((int )sr >> 3);
#line 203
      xmc[27] = (int16_t )((int )sr & 7);
#line 203
      sr = (uint16_t )((int )sr >> 3);
#line 204
      __cil_tmp65 = c;
#line 204
      c ++;
#line 204
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp65) << 1));
#line 205
      xmc[28] = (int16_t )((int )sr & 7);
#line 205
      sr = (uint16_t )((int )sr >> 3);
#line 206
      xmc[29] = (int16_t )((int )sr & 7);
#line 206
      sr = (uint16_t )((int )sr >> 3);
#line 207
      xmc[30] = (int16_t )((int )sr & 7);
#line 207
      sr = (uint16_t )((int )sr >> 3);
#line 208
      __cil_tmp66 = c;
#line 208
      c ++;
#line 208
      sr = (uint16_t )*__cil_tmp66;
#line 209
      xmc[31] = (int16_t )((int )sr & 7);
#line 209
      sr = (uint16_t )((int )sr >> 3);
#line 210
      xmc[32] = (int16_t )((int )sr & 7);
#line 210
      sr = (uint16_t )((int )sr >> 3);
#line 211
      __cil_tmp67 = c;
#line 211
      c ++;
#line 211
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp67) << 2));
#line 212
      xmc[33] = (int16_t )((int )sr & 7);
#line 212
      sr = (uint16_t )((int )sr >> 3);
#line 213
      xmc[34] = (int16_t )((int )sr & 7);
#line 213
      sr = (uint16_t )((int )sr >> 3);
#line 214
      xmc[35] = (int16_t )((int )sr & 7);
#line 214
      sr = (uint16_t )((int )sr >> 3);
#line 215
      __cil_tmp68 = c;
#line 215
      c ++;
#line 215
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp68) << 1));
#line 216
      xmc[36] = (int16_t )((int )sr & 7);
#line 216
      sr = (uint16_t )((int )sr >> 3);
#line 217
      xmc[37] = (int16_t )((int )sr & 7);
#line 217
      sr = (uint16_t )((int )sr >> 3);
#line 218
      xmc[38] = (int16_t )((int )sr & 7);
#line 218
      sr = (uint16_t )((int )sr >> 3);
#line 219
      __cil_tmp69 = c;
#line 219
      c ++;
#line 219
      sr = (uint16_t )*__cil_tmp69;
#line 220
      Nc[3] = (int16_t )((int )sr & 127);
#line 220
      sr = (uint16_t )((int )sr >> 7);
#line 221
      __cil_tmp70 = c;
#line 221
      c ++;
#line 221
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp70) << 1));
#line 222
      bc[3] = (int16_t )((int )sr & 3);
#line 222
      sr = (uint16_t )((int )sr >> 2);
#line 223
      Mc[3] = (int16_t )((int )sr & 3);
#line 223
      sr = (uint16_t )((int )sr >> 2);
#line 224
      __cil_tmp71 = c;
#line 224
      c ++;
#line 224
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp71) << 5));
#line 225
      xmaxc[3] = (int16_t )((int )sr & 63);
#line 225
      sr = (uint16_t )((int )sr >> 6);
#line 226
      xmc[39] = (int16_t )((int )sr & 7);
#line 226
      sr = (uint16_t )((int )sr >> 3);
#line 227
      xmc[40] = (int16_t )((int )sr & 7);
#line 227
      sr = (uint16_t )((int )sr >> 3);
#line 228
      __cil_tmp72 = c;
#line 228
      c ++;
#line 228
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp72) << 1));
#line 229
      xmc[41] = (int16_t )((int )sr & 7);
#line 229
      sr = (uint16_t )((int )sr >> 3);
#line 230
      xmc[42] = (int16_t )((int )sr & 7);
#line 230
      sr = (uint16_t )((int )sr >> 3);
#line 231
      xmc[43] = (int16_t )((int )sr & 7);
#line 231
      sr = (uint16_t )((int )sr >> 3);
#line 232
      __cil_tmp73 = c;
#line 232
      c ++;
#line 232
      sr = (uint16_t )*__cil_tmp73;
#line 233
      xmc[44] = (int16_t )((int )sr & 7);
#line 233
      sr = (uint16_t )((int )sr >> 3);
#line 234
      xmc[45] = (int16_t )((int )sr & 7);
#line 234
      sr = (uint16_t )((int )sr >> 3);
#line 235
      __cil_tmp74 = c;
#line 235
      c ++;
#line 235
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp74) << 2));
#line 236
      xmc[46] = (int16_t )((int )sr & 7);
#line 236
      sr = (uint16_t )((int )sr >> 3);
#line 237
      xmc[47] = (int16_t )((int )sr & 7);
#line 237
      sr = (uint16_t )((int )sr >> 3);
#line 238
      xmc[48] = (int16_t )((int )sr & 7);
#line 238
      sr = (uint16_t )((int )sr >> 3);
#line 239
      __cil_tmp75 = c;
#line 239
      c ++;
#line 239
      sr = (uint16_t )((int )sr | ((int )((uint16_t )*__cil_tmp75) << 1));
#line 240
      xmc[49] = (int16_t )((int )sr & 7);
#line 240
      sr = (uint16_t )((int )sr >> 3);
#line 241
      xmc[50] = (int16_t )((int )sr & 7);
#line 241
      sr = (uint16_t )((int )sr >> 3);
#line 242
      xmc[51] = (int16_t )((int )sr & 7);
#line 242
      sr = (uint16_t )((int )sr >> 3);
    }
  } else {
#line 250
    if ((((int )*c >> 4) & 15) != 13) {
#line 250
      return (-1);
    }
#line 252
    __cil_tmp76 = c;
#line 252
    c ++;
#line 252
    LARc[0] = (int16_t )(((int )*__cil_tmp76 & 15) << 2);
#line 253
    LARc[0] = (int16_t )((int )LARc[0] | (((int )*c >> 6) & 3));
#line 254
    __cil_tmp77 = c;
#line 254
    c ++;
#line 254
    LARc[1] = (int16_t )((int )*__cil_tmp77 & 63);
#line 255
    LARc[2] = (int16_t )(((int )*c >> 3) & 31);
#line 256
    __cil_tmp78 = c;
#line 256
    c ++;
#line 256
    LARc[3] = (int16_t )(((int )*__cil_tmp78 & 7) << 2);
#line 257
    LARc[3] = (int16_t )((int )LARc[3] | (((int )*c >> 6) & 3));
#line 258
    LARc[4] = (int16_t )(((int )*c >> 2) & 15);
#line 259
    __cil_tmp79 = c;
#line 259
    c ++;
#line 259
    LARc[5] = (int16_t )(((int )*__cil_tmp79 & 3) << 2);
#line 260
    LARc[5] = (int16_t )((int )LARc[5] | (((int )*c >> 6) & 3));
#line 261
    LARc[6] = (int16_t )(((int )*c >> 3) & 7);
#line 262
    __cil_tmp80 = c;
#line 262
    c ++;
#line 262
    LARc[7] = (int16_t )((int )*__cil_tmp80 & 7);
#line 263
    Nc[0] = (int16_t )(((int )*c >> 1) & 127);
#line 264
    __cil_tmp81 = c;
#line 264
    c ++;
#line 264
    bc[0] = (int16_t )(((int )*__cil_tmp81 & 1) << 1);
#line 265
    bc[0] = (int16_t )((int )bc[0] | (((int )*c >> 7) & 1));
#line 266
    Mc[0] = (int16_t )(((int )*c >> 5) & 3);
#line 267
    __cil_tmp82 = c;
#line 267
    c ++;
#line 267
    xmaxc[0] = (int16_t )(((int )*__cil_tmp82 & 31) << 1);
#line 268
    xmaxc[0] = (int16_t )((int )xmaxc[0] | (((int )*c >> 7) & 1));
#line 269
    xmc[0] = (int16_t )(((int )*c >> 4) & 7);
#line 270
    xmc[1] = (int16_t )(((int )*c >> 1) & 7);
#line 271
    __cil_tmp83 = c;
#line 271
    c ++;
#line 271
    xmc[2] = (int16_t )(((int )*__cil_tmp83 & 1) << 2);
#line 272
    xmc[2] = (int16_t )((int )xmc[2] | (((int )*c >> 6) & 3));
#line 273
    xmc[3] = (int16_t )(((int )*c >> 3) & 7);
#line 274
    __cil_tmp84 = c;
#line 274
    c ++;
#line 274
    xmc[4] = (int16_t )((int )*__cil_tmp84 & 7);
#line 275
    xmc[5] = (int16_t )(((int )*c >> 5) & 7);
#line 276
    xmc[6] = (int16_t )(((int )*c >> 2) & 7);
#line 277
    __cil_tmp85 = c;
#line 277
    c ++;
#line 277
    xmc[7] = (int16_t )(((int )*__cil_tmp85 & 3) << 1);
#line 278
    xmc[7] = (int16_t )((int )xmc[7] | (((int )*c >> 7) & 1));
#line 279
    xmc[8] = (int16_t )(((int )*c >> 4) & 7);
#line 280
    xmc[9] = (int16_t )(((int )*c >> 1) & 7);
#line 281
    __cil_tmp86 = c;
#line 281
    c ++;
#line 281
    xmc[10] = (int16_t )(((int )*__cil_tmp86 & 1) << 2);
#line 282
    xmc[10] = (int16_t )((int )xmc[10] | (((int )*c >> 6) & 3));
#line 283
    xmc[11] = (int16_t )(((int )*c >> 3) & 7);
#line 284
    __cil_tmp87 = c;
#line 284
    c ++;
#line 284
    xmc[12] = (int16_t )((int )*__cil_tmp87 & 7);
#line 285
    Nc[1] = (int16_t )(((int )*c >> 1) & 127);
#line 286
    __cil_tmp88 = c;
#line 286
    c ++;
#line 286
    bc[1] = (int16_t )(((int )*__cil_tmp88 & 1) << 1);
#line 287
    bc[1] = (int16_t )((int )bc[1] | (((int )*c >> 7) & 1));
#line 288
    Mc[1] = (int16_t )(((int )*c >> 5) & 3);
#line 289
    __cil_tmp89 = c;
#line 289
    c ++;
#line 289
    xmaxc[1] = (int16_t )(((int )*__cil_tmp89 & 31) << 1);
#line 290
    xmaxc[1] = (int16_t )((int )xmaxc[1] | (((int )*c >> 7) & 1));
#line 291
    xmc[13] = (int16_t )(((int )*c >> 4) & 7);
#line 292
    xmc[14] = (int16_t )(((int )*c >> 1) & 7);
#line 293
    __cil_tmp90 = c;
#line 293
    c ++;
#line 293
    xmc[15] = (int16_t )(((int )*__cil_tmp90 & 1) << 2);
#line 294
    xmc[15] = (int16_t )((int )xmc[15] | (((int )*c >> 6) & 3));
#line 295
    xmc[16] = (int16_t )(((int )*c >> 3) & 7);
#line 296
    __cil_tmp91 = c;
#line 296
    c ++;
#line 296
    xmc[17] = (int16_t )((int )*__cil_tmp91 & 7);
#line 297
    xmc[18] = (int16_t )(((int )*c >> 5) & 7);
#line 298
    xmc[19] = (int16_t )(((int )*c >> 2) & 7);
#line 299
    __cil_tmp92 = c;
#line 299
    c ++;
#line 299
    xmc[20] = (int16_t )(((int )*__cil_tmp92 & 3) << 1);
#line 300
    xmc[20] = (int16_t )((int )xmc[20] | (((int )*c >> 7) & 1));
#line 301
    xmc[21] = (int16_t )(((int )*c >> 4) & 7);
#line 302
    xmc[22] = (int16_t )(((int )*c >> 1) & 7);
#line 303
    __cil_tmp93 = c;
#line 303
    c ++;
#line 303
    xmc[23] = (int16_t )(((int )*__cil_tmp93 & 1) << 2);
#line 304
    xmc[23] = (int16_t )((int )xmc[23] | (((int )*c >> 6) & 3));
#line 305
    xmc[24] = (int16_t )(((int )*c >> 3) & 7);
#line 306
    __cil_tmp94 = c;
#line 306
    c ++;
#line 306
    xmc[25] = (int16_t )((int )*__cil_tmp94 & 7);
#line 307
    Nc[2] = (int16_t )(((int )*c >> 1) & 127);
#line 308
    __cil_tmp95 = c;
#line 308
    c ++;
#line 308
    bc[2] = (int16_t )(((int )*__cil_tmp95 & 1) << 1);
#line 309
    bc[2] = (int16_t )((int )bc[2] | (((int )*c >> 7) & 1));
#line 310
    Mc[2] = (int16_t )(((int )*c >> 5) & 3);
#line 311
    __cil_tmp96 = c;
#line 311
    c ++;
#line 311
    xmaxc[2] = (int16_t )(((int )*__cil_tmp96 & 31) << 1);
#line 312
    xmaxc[2] = (int16_t )((int )xmaxc[2] | (((int )*c >> 7) & 1));
#line 313
    xmc[26] = (int16_t )(((int )*c >> 4) & 7);
#line 314
    xmc[27] = (int16_t )(((int )*c >> 1) & 7);
#line 315
    __cil_tmp97 = c;
#line 315
    c ++;
#line 315
    xmc[28] = (int16_t )(((int )*__cil_tmp97 & 1) << 2);
#line 316
    xmc[28] = (int16_t )((int )xmc[28] | (((int )*c >> 6) & 3));
#line 317
    xmc[29] = (int16_t )(((int )*c >> 3) & 7);
#line 318
    __cil_tmp98 = c;
#line 318
    c ++;
#line 318
    xmc[30] = (int16_t )((int )*__cil_tmp98 & 7);
#line 319
    xmc[31] = (int16_t )(((int )*c >> 5) & 7);
#line 320
    xmc[32] = (int16_t )(((int )*c >> 2) & 7);
#line 321
    __cil_tmp99 = c;
#line 321
    c ++;
#line 321
    xmc[33] = (int16_t )(((int )*__cil_tmp99 & 3) << 1);
#line 322
    xmc[33] = (int16_t )((int )xmc[33] | (((int )*c >> 7) & 1));
#line 323
    xmc[34] = (int16_t )(((int )*c >> 4) & 7);
#line 324
    xmc[35] = (int16_t )(((int )*c >> 1) & 7);
#line 325
    __cil_tmp100 = c;
#line 325
    c ++;
#line 325
    xmc[36] = (int16_t )(((int )*__cil_tmp100 & 1) << 2);
#line 326
    xmc[36] = (int16_t )((int )xmc[36] | (((int )*c >> 6) & 3));
#line 327
    xmc[37] = (int16_t )(((int )*c >> 3) & 7);
#line 328
    __cil_tmp101 = c;
#line 328
    c ++;
#line 328
    xmc[38] = (int16_t )((int )*__cil_tmp101 & 7);
#line 329
    Nc[3] = (int16_t )(((int )*c >> 1) & 127);
#line 330
    __cil_tmp102 = c;
#line 330
    c ++;
#line 330
    bc[3] = (int16_t )(((int )*__cil_tmp102 & 1) << 1);
#line 331
    bc[3] = (int16_t )((int )bc[3] | (((int )*c >> 7) & 1));
#line 332
    Mc[3] = (int16_t )(((int )*c >> 5) & 3);
#line 333
    __cil_tmp103 = c;
#line 333
    c ++;
#line 333
    xmaxc[3] = (int16_t )(((int )*__cil_tmp103 & 31) << 1);
#line 334
    xmaxc[3] = (int16_t )((int )xmaxc[3] | (((int )*c >> 7) & 1));
#line 335
    xmc[39] = (int16_t )(((int )*c >> 4) & 7);
#line 336
    xmc[40] = (int16_t )(((int )*c >> 1) & 7);
#line 337
    __cil_tmp104 = c;
#line 337
    c ++;
#line 337
    xmc[41] = (int16_t )(((int )*__cil_tmp104 & 1) << 2);
#line 338
    xmc[41] = (int16_t )((int )xmc[41] | (((int )*c >> 6) & 3));
#line 339
    xmc[42] = (int16_t )(((int )*c >> 3) & 7);
#line 340
    __cil_tmp105 = c;
#line 340
    c ++;
#line 340
    xmc[43] = (int16_t )((int )*__cil_tmp105 & 7);
#line 341
    xmc[44] = (int16_t )(((int )*c >> 5) & 7);
#line 342
    xmc[45] = (int16_t )(((int )*c >> 2) & 7);
#line 343
    __cil_tmp106 = c;
#line 343
    c ++;
#line 343
    xmc[46] = (int16_t )(((int )*__cil_tmp106 & 3) << 1);
#line 344
    xmc[46] = (int16_t )((int )xmc[46] | (((int )*c >> 7) & 1));
#line 345
    xmc[47] = (int16_t )(((int )*c >> 4) & 7);
#line 346
    xmc[48] = (int16_t )(((int )*c >> 1) & 7);
#line 347
    __cil_tmp107 = c;
#line 347
    c ++;
#line 347
    xmc[49] = (int16_t )(((int )*__cil_tmp107 & 1) << 2);
#line 348
    xmc[49] = (int16_t )((int )xmc[49] | (((int )*c >> 6) & 3));
#line 349
    xmc[50] = (int16_t )(((int )*c >> 3) & 7);
#line 350
    xmc[51] = (int16_t )((int )*c & 7);
  }
  {
#line 353
  Gsm_Decoder(s, LARc, Nc, bc, Mc, xmaxc, xmc, target);
  }
#line 355
  return (0);
}
}
#line 18 "/root/patchweave_donee/23/src/GSM610/gsm_create.c"
gsm gsm_create(void) 
{ 
  gsm r ;
  void *tmp ;

  {
  {
#line 22
  tmp = malloc(sizeof(struct gsm_state ));
#line 22
  r = (gsm )tmp;
  }
#line 23
  if (! r) {
#line 23
    return (r);
  }
  {
#line 25
  memset((void *)((char *)r), 0, sizeof(struct gsm_state ));
#line 26
  r->nrp = (int16_t )40;
  }
#line 28
  return (r);
}
}
#line 32 "/root/patchweave_donee/23/src/GSM610/gsm_create.c"
void gsm_init(gsm state ) 
{ 


  {
  {
#line 34
  memset((void *)state, 0, sizeof(struct gsm_state ));
#line 35
  state->nrp = (int16_t )40;
  }
#line 37
  return;
}
}
#line 15 "/root/patchweave_donee/23/src/GSM610/decode.c"
static void Postprocessing(struct gsm_state *S , int16_t *s ) 
{ 
  register int k ;
  register int16_t msr ;
  register int16_t tmp ;
  int __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int32_t __cil_tmp8 ;
  int32_t __cil_tmp9 ;

  {
#line 20
  msr = S->msr;
#line 23
  k = 160;
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;

#line 23
    if (! __cil_tmp6) {
#line 23
      goto while_break;
    }
    {
#line 24
    __cil_tmp7 = GSM_MULT_R(msr, (int16_t )28180);
#line 24
    tmp = (int16_t )__cil_tmp7;
#line 25
    __cil_tmp8 = GSM_ADD(*s, tmp);
#line 25
    msr = (int16_t )__cil_tmp8;
#line 26
    __cil_tmp9 = GSM_ADD(msr, msr);
#line 26
    *s = (int16_t )(__cil_tmp9 & 65528);
#line 23
    s ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 28
  S->msr = msr;
#line 29
  return;
}
}
#line 31 "/root/patchweave_donee/23/src/GSM610/decode.c"
void Gsm_Decoder(struct gsm_state *S , int16_t *LARcr , int16_t *Ncr , int16_t *bcr ,
                 int16_t *Mcr , int16_t *xmaxcr , int16_t *xMcr , int16_t *s ) 
{ 
  int j ;
  int k ;
  int16_t erp[40] ;
  int16_t wt[160] ;
  int16_t *drp ;
  int __cil_tmp15 ;
  int16_t *__cil_tmp16 ;
  int16_t *__cil_tmp17 ;
  int16_t *__cil_tmp18 ;
  int16_t *__cil_tmp19 ;

  {
#line 46
  drp = S->dp0 + 120;
#line 48
  j = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;

#line 48
    if (! (j <= 3)) {
#line 48
      goto while_break;
    }
    {
#line 49
    Gsm_RPE_Decoding(*xmaxcr, *Mcr, xMcr, erp);
#line 50
    Gsm_Long_Term_Synthesis_Filtering(S, *Ncr, *bcr, erp, drp);
#line 52
    k = 0;
    }
    {
#line 52
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 52
      if (! (k <= 39)) {
#line 52
        goto while_break___0;
      }
#line 52
      wt[j * 40 + k] = *(drp + k);
#line 52
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 48
    xMcr += 13;
#line 48
    __cil_tmp19 = Mcr;
#line 48
    Mcr ++;
#line 48
    __cil_tmp18 = Ncr;
#line 48
    Ncr ++;
#line 48
    __cil_tmp17 = bcr;
#line 48
    bcr ++;
#line 48
    __cil_tmp16 = xmaxcr;
#line 48
    xmaxcr ++;
#line 48
    __cil_tmp15 = j;
#line 48
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 55
  Gsm_Short_Term_Synthesis_Filter(S, LARcr, wt, s);
#line 56
  Postprocessing(S, s);
  }
#line 58
  return;
}
}
#line 17 "/root/patchweave_donee/23/src/GSM610/code.c"
void Gsm_Coder(struct gsm_state *State , int16_t *s , int16_t *LARc , int16_t *Nc ,
               int16_t *bc , int16_t *Mc , int16_t *xmaxc , int16_t *xMc ) 
{ 
  int k ;
  int16_t *dp ;
  int16_t *dpp ;
  int16_t so[160] ;
  int16_t *__cil_tmp13 ;
  int16_t *__cil_tmp14 ;
  int16_t *__cil_tmp15 ;
  int16_t *__cil_tmp16 ;
  register int i ;
  int32_t __cil_tmp18 ;
  int __cil_tmp20 ;

  {
  {
#line 49
  dp = State->dp0 + 120;
#line 50
  dpp = dp;
#line 54
  Gsm_Preprocess(State, s, so);
#line 55
  Gsm_LPC_Analysis(State, so, LARc);
#line 56
  Gsm_Short_Term_Analysis_Filter(State, LARc, so);
#line 58
  k = 0;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;

#line 58
    if (! (k <= 3)) {
#line 58
      goto while_break;
    }
    {
#line 59
    __cil_tmp13 = Nc;
#line 59
    Nc ++;
#line 59
    __cil_tmp14 = bc;
#line 59
    bc ++;
#line 59
    Gsm_Long_Term_Predictor(State, so + k * 40, dp, State->e + 5, dpp, __cil_tmp13,
                            __cil_tmp14);
#line 67
    __cil_tmp15 = xmaxc;
#line 67
    xmaxc ++;
#line 67
    __cil_tmp16 = Mc;
#line 67
    Mc ++;
#line 67
    Gsm_RPE_Encoding(State->e + 5, __cil_tmp15, __cil_tmp16, xMc);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 77
      if (! (i <= 39)) {
#line 77
        goto while_break___0;
      }
      {
#line 78
      __cil_tmp18 = GSM_ADD(State->e[5 + i], *(dpp + i));
#line 78
      *(dp + i) = (int16_t )__cil_tmp18;
#line 77
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 80
    dp += 40;
#line 81
    dpp += 40;
#line 58
    xMc += 13;
#line 58
    __cil_tmp20 = k;
#line 58
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 84
  memcpy((void *)((char *)(State->dp0)), (void const   *)((char *)(State->dp0 + 160)),
         120UL * sizeof(State->dp0[0]));
  }
#line 86
  return;
}
}
#line 19 "/root/patchweave_donee/23/src/GSM610/add.c"
int16_t gsm_add(int16_t a , int16_t b ) 
{ 
  int32_t sum ;
  int tmp ;
  int tmp___0 ;

  {
#line 21
  sum = (int32_t )a + (int32_t )b;
#line 22
  if (sum < -32768) {
#line 22
    tmp___0 = -32768;
  } else {
#line 22
    if (sum > 32767) {
#line 22
      tmp = 32767;
    } else {
#line 22
      tmp = sum;
    }
#line 22
    tmp___0 = tmp;
  }
#line 22
  return ((int16_t )tmp___0);
}
}
#line 25 "/root/patchweave_donee/23/src/GSM610/add.c"
int16_t gsm_sub(int16_t a , int16_t b ) 
{ 
  int32_t diff ;
  int tmp ;
  int tmp___0 ;

  {
#line 27
  diff = (int32_t )a - (int32_t )b;
#line 28
  if (diff < -32768) {
#line 28
    tmp___0 = -32768;
  } else {
#line 28
    if (diff > 32767) {
#line 28
      tmp = 32767;
    } else {
#line 28
      tmp = diff;
    }
#line 28
    tmp___0 = tmp;
  }
#line 28
  return ((int16_t )tmp___0);
}
}
#line 31 "/root/patchweave_donee/23/src/GSM610/add.c"
int16_t gsm_mult(int16_t a , int16_t b ) 
{ 
  int32_t __cil_tmp3 ;

  {
#line 33
  if ((int )a == -32768) {
#line 33
    if ((int )b == -32768) {
#line 34
      return ((int16_t )32767);
    }
  }
  {
#line 36
  __cil_tmp3 = SASR_L((int32_t )a * (int32_t )b, (int16_t )15);
  }
#line 36
  return ((int16_t )__cil_tmp3);
}
}
#line 39 "/root/patchweave_donee/23/src/GSM610/add.c"
int16_t gsm_mult_r(int16_t a , int16_t b ) 
{ 
  int32_t prod ;

  {
#line 41
  if ((int )b == -32768) {
#line 41
    if ((int )a == -32768) {
#line 42
      return ((int16_t )32767);
    } else {
#line 44
      prod = (int32_t )a * (int32_t )b + 16384;
#line 45
      prod >>= 15;
#line 46
      return ((int16_t )(prod & 65535));
    }
  } else {
#line 44
    prod = (int32_t )a * (int32_t )b + 16384;
#line 45
    prod >>= 15;
#line 46
    return ((int16_t )(prod & 65535));
  }
}
}
#line 50 "/root/patchweave_donee/23/src/GSM610/add.c"
int16_t gsm_abs(int16_t a ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 52
  if ((int )a < 0) {
#line 52
    if ((int )a == -32768) {
#line 52
      tmp = 32767;
    } else {
#line 52
      tmp = - ((int )a);
    }
#line 52
    tmp___0 = tmp;
  } else {
#line 52
    tmp___0 = (int )a;
  }
#line 52
  return ((int16_t )tmp___0);
}
}
#line 55 "/root/patchweave_donee/23/src/GSM610/add.c"
int32_t gsm_L_mult(int16_t a , int16_t b ) 
{ 


  {
#line 58
  return ((int32_t )a * (int32_t )b << 1);
}
}
#line 61 "/root/patchweave_donee/23/src/GSM610/add.c"
int32_t gsm_L_add(int32_t a , int32_t b ) 
{ 
  uint32_t A ;
  int tmp ;
  uint32_t A___0 ;
  unsigned int tmp___0 ;

  {
#line 63
  if (a < 0) {
#line 64
    if (b >= 0) {
#line 65
      return (a + b);
    } else {
#line 67
      A = (uint32_t )(- (a + 1)) + (uint32_t )(- (b + 1));
#line 68
      if (A >= 2147483647U) {
#line 68
        tmp = (-0x7FFFFFFF-1);
      } else {
#line 68
        tmp = - ((int32_t )A) - 2;
      }
#line 68
      return (tmp);
    }
  } else
#line 71
  if (b <= 0) {
#line 72
    return (a + b);
  } else {
#line 74
    A___0 = (uint32_t )a + (uint32_t )b;
#line 75
    if (A___0 > 2147483647U) {
#line 75
      tmp___0 = 2147483647U;
    } else {
#line 75
      tmp___0 = A___0;
    }
#line 75
    return ((int32_t )tmp___0);
  }
}
}
#line 79 "/root/patchweave_donee/23/src/GSM610/add.c"
int32_t gsm_L_sub(int32_t a , int32_t b ) 
{ 
  uint32_t A ;
  unsigned int tmp ;
  uint32_t A___0 ;
  int tmp___0 ;

  {
#line 81
  if (a >= 0) {
#line 82
    if (b >= 0) {
#line 83
      return (a - b);
    } else {
#line 86
      A = (uint32_t )a + (unsigned int )(- (b + 1));
#line 87
      if (A >= 2147483647U) {
#line 87
        tmp = 2147483647U;
      } else {
#line 87
        tmp = A + 1U;
      }
#line 87
      return ((int32_t )tmp);
    }
  } else
#line 90
  if (b <= 0) {
#line 91
    return (a - b);
  } else {
#line 94
    A___0 = (uint32_t )(- (a + 1)) + (unsigned int )b;
#line 95
    if (A___0 >= 2147483647U) {
#line 95
      tmp___0 = (-0x7FFFFFFF-1);
    } else {
#line 95
      tmp___0 = - ((int32_t )A___0) - 1;
    }
#line 95
    return (tmp___0);
  }
}
}
#line 99 "/root/patchweave_donee/23/src/GSM610/add.c"
static unsigned char const   bitoff[256]  = 
#line 99
  {      (unsigned char const   )(unsigned char)8,      (unsigned char const   )(unsigned char)7,      (unsigned char const   )(unsigned char)6,      (unsigned char const   )(unsigned char)6, 
        (unsigned char const   )(unsigned char)5,      (unsigned char const   )(unsigned char)5,      (unsigned char const   )(unsigned char)5,      (unsigned char const   )(unsigned char)5, 
        (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4, 
        (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4,      (unsigned char const   )(unsigned char)4, 
        (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3, 
        (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3, 
        (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3, 
        (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3,      (unsigned char const   )(unsigned char)3, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2,      (unsigned char const   )(unsigned char)2, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1,      (unsigned char const   )(unsigned char)1, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0, 
        (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0,      (unsigned char const   )(unsigned char)0};
#line 118 "/root/patchweave_donee/23/src/GSM610/add.c"
int16_t gsm_norm(int32_t a ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 140
  if (a < 0) {
#line 141
    if (a <= -1073741824) {
#line 141
      return ((int16_t )0);
    }
#line 142
    a = ~ a;
  }
#line 145
  if ((unsigned int )a & 4294901760U) {
#line 145
    if ((unsigned int )a & 4278190080U) {
#line 145
      tmp___0 = -1 + (int )bitoff[255 & (a >> 24)];
    } else {
#line 145
      tmp___0 = 7 + (int )bitoff[255 & (a >> 16)];
    }
#line 145
    tmp___2 = tmp___0;
  } else {
#line 145
    if (a & 65280) {
#line 145
      tmp___1 = 15 + (int )bitoff[255 & (a >> 8)];
    } else {
#line 145
      tmp___1 = 23 + (int )bitoff[255 & a];
    }
#line 145
    tmp___2 = tmp___1;
  }
#line 145
  return ((int16_t )tmp___2);
}
}
#line 154 "/root/patchweave_donee/23/src/GSM610/add.c"
int32_t gsm_L_asl(int32_t a , int n ) 
{ 
  int32_t __cil_tmp3 ;

  {
#line 156
  if (n >= 32) {
#line 156
    return (0);
  }
#line 157
  if (n <= -32) {
#line 157
    return (- (a < 0));
  }
#line 158
  if (n < 0) {
    {
#line 158
    __cil_tmp3 = gsm_L_asr(a, - n);
    }
#line 158
    return (__cil_tmp3);
  }
#line 159
  return (a << n);
}
}
#line 162 "/root/patchweave_donee/23/src/GSM610/add.c"
int16_t gsm_asr(int16_t a , int n ) 
{ 
  int16_t __cil_tmp3 ;

  {
#line 164
  if (n >= 16) {
#line 164
    return ((int16_t )(- ((int )a < 0)));
  }
#line 165
  if (n <= -16) {
#line 165
    return ((int16_t )0);
  }
#line 166
  if (n < 0) {
#line 166
    return ((int16_t )((int )a << - n));
  }
  {
#line 168
  __cil_tmp3 = SASR_W(a, (int16_t )n);
  }
#line 168
  return (__cil_tmp3);
}
}
#line 171 "/root/patchweave_donee/23/src/GSM610/add.c"
int16_t gsm_asl(int16_t a , int n ) 
{ 
  int16_t __cil_tmp3 ;

  {
#line 173
  if (n >= 16) {
#line 173
    return ((int16_t )0);
  }
#line 174
  if (n <= -16) {
#line 174
    return ((int16_t )(- ((int )a < 0)));
  }
#line 175
  if (n < 0) {
    {
#line 175
    __cil_tmp3 = gsm_asr(a, - n);
    }
#line 175
    return (__cil_tmp3);
  }
#line 176
  return ((int16_t )((int )a << n));
}
}
#line 179 "/root/patchweave_donee/23/src/GSM610/add.c"
int32_t gsm_L_asr(int32_t a , int n ) 
{ 
  int32_t __cil_tmp3 ;

  {
#line 181
  if (n >= 32) {
#line 181
    return (- (a < 0));
  }
#line 182
  if (n <= -32) {
#line 182
    return (0);
  }
#line 183
  if (n < 0) {
#line 183
    return (a << - n);
  }
  {
#line 185
  __cil_tmp3 = SASR_L(a, (int16_t )n);
  }
#line 185
  return (__cil_tmp3);
}
}
#line 213 "/root/patchweave_donee/23/src/GSM610/add.c"
int16_t gsm_div(int16_t num , int16_t denum ) 
{ 
  int32_t L_num ;
  int32_t L_denum ;
  int16_t div___0 ;
  int k ;
  int __cil_tmp8 ;

  {
#line 215
  L_num = (int32_t )num;
#line 216
  L_denum = (int32_t )denum;
#line 217
  div___0 = (int16_t )0;
#line 218
  k = 15;
#line 228
  if ((int )num == 0) {
#line 229
    return ((int16_t )0);
  }
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    __cil_tmp8 = k;
#line 231
    k --;
#line 231
    if (! __cil_tmp8) {
#line 231
      goto while_break;
    }
#line 232
    div___0 = (int16_t )((int )div___0 << 1);
#line 233
    L_num <<= 1;
#line 235
    if (L_num >= L_denum) {
#line 236
      L_num -= L_denum;
#line 237
      div___0 = (int16_t )((int )div___0 + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 241
  return (div___0);
}
}
#line 143 "/root/patchweave_donee/23/src/ogg_opus.c"
int ogg_opus_open(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 145
  psf_log_printf(psf, "This version of libsndfile was compiled without Ogg/Opus support.\n");
  }
#line 146
  return (18);
}
}
#line 158 "/root/patchweave_donee/23/src/ogg_pcm.c"
int ogg_pcm_open(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 160
  psf_log_printf(psf, "This version of libsndfile was compiled without Ogg/Speex support.\n");
  }
#line 161
  return (18);
}
}
#line 419 "/root/patchweave_donee/23/src/ogg_speex.c"
int ogg_speex_open(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 421
  psf_log_printf(psf, "This version of libsndfile was compiled without Ogg/Speex support.\n");
  }
#line 422
  return (18);
}
}
#line 164 "/usr/include/vorbis/codec.h"
extern void vorbis_info_init(vorbis_info *vi ) ;
#line 165
extern void vorbis_info_clear(vorbis_info *vi ) ;
#line 167
extern void vorbis_comment_init(vorbis_comment *vc ) ;
#line 169
extern void vorbis_comment_add_tag(vorbis_comment *vc , char const   *tag , char const   *contents ) ;
#line 171
extern char *vorbis_comment_query(vorbis_comment *vc , char const   *tag , int count ) ;
#line 173
extern void vorbis_comment_clear(vorbis_comment *vc ) ;
#line 175
extern int vorbis_block_init(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 176
extern int vorbis_block_clear(vorbis_block *vb ) ;
#line 177
extern void vorbis_dsp_clear(vorbis_dsp_state *v ) ;
#line 181
extern char const   *vorbis_version_string(void) ;
#line 185
extern int vorbis_analysis_init(vorbis_dsp_state *v , vorbis_info *vi ) ;
#line 187
extern int vorbis_analysis_headerout(vorbis_dsp_state *v , vorbis_comment *vc , ogg_packet *op ,
                                     ogg_packet *op_comm , ogg_packet *op_code ) ;
#line 192
extern float **vorbis_analysis_buffer(vorbis_dsp_state *v , int vals ) ;
#line 193
extern int vorbis_analysis_wrote(vorbis_dsp_state *v , int vals ) ;
#line 194
extern int vorbis_analysis_blockout(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 195
extern int vorbis_analysis(vorbis_block *vb , ogg_packet *op ) ;
#line 197
extern int vorbis_bitrate_addblock(vorbis_block *vb ) ;
#line 198
extern int vorbis_bitrate_flushpacket(vorbis_dsp_state *vd , ogg_packet *op ) ;
#line 203
extern int vorbis_synthesis_headerin(vorbis_info *vi , vorbis_comment *vc , ogg_packet *op ) ;
#line 206
extern int vorbis_synthesis_init(vorbis_dsp_state *v , vorbis_info *vi ) ;
#line 208
extern int vorbis_synthesis(vorbis_block *vb , ogg_packet *op ) ;
#line 210
extern int vorbis_synthesis_blockin(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 211
extern int vorbis_synthesis_pcmout(vorbis_dsp_state *v , float ***pcm ) ;
#line 213
extern int vorbis_synthesis_read(vorbis_dsp_state *v , int samples ) ;
#line 157 "/usr/include/vorbis/vorbisenc.h"
extern int vorbis_encode_init_vbr(vorbis_info *vi , long channels , long rate , float base_quality ) ;
#line 81 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_read_header(SF_PRIVATE *psf , int log_data ) ;
#line 82
static int vorbis_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 83
static int vorbis_close(SF_PRIVATE *psf ) ;
#line 84
static int vorbis_command(SF_PRIVATE *psf , int command , void *data , int datasize ) ;
#line 85
static int vorbis_byterate(SF_PRIVATE *psf ) ;
#line 86
static sf_count_t vorbis_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 87
static sf_count_t vorbis_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t lens ) ;
#line 88
static sf_count_t vorbis_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t lens ) ;
#line 89
static sf_count_t vorbis_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t lens ) ;
#line 90
static sf_count_t vorbis_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t lens ) ;
#line 91
static sf_count_t vorbis_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t lens ) ;
#line 92
static sf_count_t vorbis_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t lens ) ;
#line 93
static sf_count_t vorbis_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t lens ) ;
#line 94
static sf_count_t vorbis_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t lens ) ;
#line 95
static sf_count_t vorbis_read_sample(SF_PRIVATE *psf , void *ptr , sf_count_t lens ,
                                     convert_func *transfn ) ;
#line 96
static sf_count_t vorbis_length(SF_PRIVATE *psf ) ;
#line 103 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static STR_PAIRS vorbis_metatypes[10]  = 
#line 103
  {      {1, "Title"}, 
        {2, "Copyright"}, 
        {3, "Software\250"}, 
        {4, "Artist"}, 
        {5, "Comment"}, 
        {6, "Date"}, 
        {7, "Album"}, 
        {8, "License"}, 
        {9, "Tracknumber"}, 
        {16, "Genre"}};
#line 133 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_read_header(SF_PRIVATE *psf , int log_data ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  char *buffer ;
  int bytes ;
  int i ;
  int nn ;
  sf_count_t __cil_tmp10 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int k ;
  char *dd ;
  int result ;
  int __cil_tmp21 ;
  sf_count_t __cil_tmp23 ;
  int printed_metadata_msg ;
  int k___0 ;
  char *dd___0 ;

  {
  {
#line 135
  odata = (OGG_PRIVATE *)psf->container_data;
#line 136
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 141
  odata->eos = 0;
#line 144
  ogg_stream_reset(& odata->ostream);
#line 145
  ogg_sync_reset(& odata->osync);
#line 155
  buffer = ogg_sync_buffer(& odata->osync, 4096L);
#line 158
  memcpy((void *)buffer, (void const   *)(psf->header), (unsigned long )psf->headindex);
#line 159
  bytes = psf->headindex;
#line 162
  __cil_tmp10 = psf_fread((void *)(buffer + psf->headindex), (sf_count_t )1, (sf_count_t )(4096 - psf->headindex),
                          psf);
#line 162
  bytes = (int )((sf_count_t )bytes + __cil_tmp10);
#line 163
  ogg_sync_wrote(& odata->osync, (long )bytes);
#line 166
  nn = ogg_sync_pageout(& odata->osync, & odata->opage);
  }
#line 166
  if (nn != 1) {
#line 169
    if (bytes < 4096) {
#line 170
      return (0);
    }
    {
#line 173
    psf_log_printf(psf, "Input does not appear to be an Ogg bitstream.\n");
    }
#line 174
    return (3);
  }
  {
#line 181
  ogg_stream_clear(& odata->ostream);
#line 182
  __cil_tmp12 = ogg_page_serialno(& odata->opage);
#line 182
  ogg_stream_init(& odata->ostream, __cil_tmp12);
#line 184
  __cil_tmp13 = ogg_stream_pagein(& odata->ostream, & odata->opage);
  }
#line 184
  if (__cil_tmp13 < 0) {
    {
#line 186
    psf_log_printf(psf, "Error reading first page of Ogg bitstream data\n");
    }
#line 187
    return (3);
  }
  {
#line 190
  __cil_tmp14 = ogg_stream_packetout(& odata->ostream, & odata->opacket);
  }
#line 190
  if (__cil_tmp14 != 1) {
    {
#line 192
    psf_log_printf(psf, "Error reading initial header packet.\n");
    }
#line 193
    return (3);
  }
  {
#line 201
  vorbis_block_clear(& vdata->vblock);
#line 202
  vorbis_dsp_clear(& vdata->vdsp);
#line 203
  vorbis_comment_clear(& vdata->vcomment);
#line 204
  vorbis_info_clear(& vdata->vinfo);
#line 215
  vorbis_info_init(& vdata->vinfo);
#line 216
  vorbis_comment_init(& vdata->vcomment);
#line 218
  __cil_tmp15 = vorbis_synthesis_headerin(& vdata->vinfo, & vdata->vcomment, & odata->opacket);
  }
#line 218
  if (__cil_tmp15 < 0) {
    {
#line 220
    psf_log_printf(psf, "Found Vorbis in stream header, but vorbis_synthesis_headerin failed.\n");
    }
#line 221
    return (3);
  }
#line 230
  if (log_data) {
#line 233
    k = 0;
    {
#line 233
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: ;
#line 233
      if (! (k < (int )(sizeof(vorbis_metatypes) / sizeof(vorbis_metatypes[0])))) {
#line 233
        goto while_break;
      }
      {
#line 236
      dd = vorbis_comment_query(& vdata->vcomment, vorbis_metatypes[k].name, 0);
      }
#line 237
      if ((unsigned long )dd == (unsigned long )((void *)0)) {
#line 238
        goto while_continue;
      }
      {
#line 239
      psf_store_string(psf, vorbis_metatypes[k].id, (char const   *)dd);
#line 233
      k ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 255
  i = 0;
  {
#line 256
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 256
    if (! (i < 2)) {
#line 256
      goto while_break___0;
    }
    {
#line 257
    __cil_tmp21 = ogg_sync_pageout(& odata->osync, & odata->opage);
#line 257
    result = __cil_tmp21;
    }
#line 258
    if (result == 0) {
      {
#line 260
      buffer = ogg_sync_buffer(& odata->osync, 4096L);
#line 261
      __cil_tmp23 = psf_fread((void *)buffer, (sf_count_t )1, (sf_count_t )4096, psf);
#line 261
      bytes = (int )__cil_tmp23;
      }
#line 263
      if (bytes == 0) {
#line 263
        if (i < 2) {
          {
#line 264
          psf_log_printf(psf, "End of file before finding all Vorbis headers!\n");
          }
#line 265
          return (3);
        }
      }
      {
#line 267
      nn = ogg_sync_wrote(& odata->osync, (long )bytes);
      }
    } else
#line 269
    if (result == 1) {
      {
#line 277
      nn = ogg_stream_pagein(& odata->ostream, & odata->opage);
      }
      {
#line 278
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 278
        if (! (i < 2)) {
#line 278
          goto while_break___1;
        }
        {
#line 279
        result = ogg_stream_packetout(& odata->ostream, & odata->opacket);
        }
#line 280
        if (result == 0) {
#line 281
          goto while_break___1;
        }
#line 282
        if (result < 0) {
          {
#line 285
          psf_log_printf(psf, "Corrupt secondary header.\tExiting.\n");
          }
#line 286
          return (3);
        }
        {
#line 289
        vorbis_synthesis_headerin(& vdata->vinfo, & vdata->vcomment, & odata->opacket);
#line 290
        i ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: ;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
#line 295
  if (log_data) {
    {
#line 296
    printed_metadata_msg = 0;
#line 299
    psf_log_printf(psf, "Bitstream is %d channel, %D Hz\n", vdata->vinfo.channels,
                   vdata->vinfo.rate);
#line 300
    psf_log_printf(psf, "Encoded by : %s\n\230\001", vdata->vcomment.vendor);
#line 303
    k___0 = 0;
    }
    {
#line 303
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: ;
#line 303
      if (! (k___0 < (int )(sizeof(vorbis_metatypes) / sizeof(vorbis_metatypes[0])))) {
#line 303
        goto while_break___2;
      }
      {
#line 306
      dd___0 = vorbis_comment_query(& vdata->vcomment, vorbis_metatypes[k___0].name,
                                    0);
      }
#line 307
      if ((unsigned long )dd___0 == (unsigned long )((void *)0)) {
#line 308
        goto while_continue___2;
      }
#line 310
      if (printed_metadata_msg == 0) {
        {
#line 311
        psf_log_printf(psf, "Metadata :\n");
#line 312
        printed_metadata_msg = 1;
        }
      }
      {
#line 315
      psf_store_string(psf, vorbis_metatypes[k___0].id, (char const   *)dd___0);
#line 316
      psf_log_printf(psf, "  %-10s : %s\n", vorbis_metatypes[k___0].name, dd___0);
#line 303
      k___0 ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 319
    psf_log_printf(psf, "End\n");
    }
  }
  {
#line 322
  psf->sf.samplerate = (int )vdata->vinfo.rate;
#line 323
  psf->sf.channels = vdata->vinfo.channels;
#line 324
  psf->sf.format = 2097248;
#line 329
  vorbis_synthesis_init(& vdata->vdsp, & vdata->vinfo);
#line 334
  vorbis_block_init(& vdata->vdsp, & vdata->vblock);
#line 336
  vdata->loc = (sf_count_t )0;
  }
#line 338
  return (0);
}
}
#line 342 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int k ;
  int ret ;
  char const   *name ;
  int32_t __cil_tmp10 ;
  ogg_packet header ;
  ogg_packet header_comm ;
  ogg_packet header_code ;
  int result ;

  {
  {
#line 344
  odata = (OGG_PRIVATE *)psf->container_data;
#line 345
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 348
  vorbis_info_init(& vdata->vinfo);
#line 351
  ret = vorbis_encode_init_vbr(& vdata->vinfo, (long )psf->sf.channels, (long )psf->sf.samplerate,
                               (float )vdata->quality);
  }
#line 360
  if (ret) {
#line 361
    return (1);
  }
  {
#line 363
  vdata->loc = (sf_count_t )0;
#line 366
  vorbis_comment_init(& vdata->vcomment);
#line 368
  vorbis_comment_add_tag(& vdata->vcomment, "ENCODER", "libsndfile");
#line 369
  k = 0;
  }
  {
#line 369
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 369
    if (! (k < 32)) {
#line 369
      goto while_break;
    }
#line 372
    if (psf->strings.data[k].type == 0) {
#line 373
      goto while_break;
    }
#line 376
    if (psf->strings.data[k].type == 1) {
#line 376
      goto case_1;
    }
#line 377
    if (psf->strings.data[k].type == 2) {
#line 377
      goto case_2;
    }
#line 378
    if (psf->strings.data[k].type == 3) {
#line 378
      goto case_3;
    }
#line 379
    if (psf->strings.data[k].type == 4) {
#line 379
      goto case_4;
    }
#line 380
    if (psf->strings.data[k].type == 5) {
#line 380
      goto case_5;
    }
#line 381
    if (psf->strings.data[k].type == 6) {
#line 381
      goto case_6;
    }
#line 382
    if (psf->strings.data[k].type == 7) {
#line 382
      goto case_7;
    }
#line 383
    if (psf->strings.data[k].type == 8) {
#line 383
      goto case_8;
    }
#line 384
    if (psf->strings.data[k].type == 9) {
#line 384
      goto case_9;
    }
#line 385
    if (psf->strings.data[k].type == 16) {
#line 385
      goto case_16;
    }
#line 387
    goto switch_default;
    case_1: 
#line 376
    name = "TITLE";
#line 376
    goto switch_break;
    case_2: 
#line 377
    name = "COPYRIGHT";
#line 377
    goto switch_break;
    case_3: 
#line 378
    name = "SOFTWARE\220";
#line 378
    goto switch_break;
    case_4: 
#line 379
    name = "ARTIST";
#line 379
    goto switch_break;
    case_5: 
#line 380
    name = "COMMENT";
#line 380
    goto switch_break;
    case_6: 
#line 381
    name = "DATE";
#line 381
    goto switch_break;
    case_7: 
#line 382
    name = "ALBUMU";
#line 382
    goto switch_break;
    case_8: 
#line 383
    name = "LICENSE";
#line 383
    goto switch_break;
    case_9: 
#line 384
    name = "Tracknumber\327\204U";
#line 384
    goto switch_break;
    case_16: 
#line 385
    name = "Genre";
#line 385
    goto switch_break;
    switch_default: 
#line 387
    goto while_continue;
    switch_break: 
    {
#line 390
    vorbis_comment_add_tag(& vdata->vcomment, name, (char const   *)(psf->strings.storage + psf->strings.data[k].offset));
#line 369
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 394
  vorbis_analysis_init(& vdata->vdsp, & vdata->vinfo);
#line 395
  vorbis_block_init(& vdata->vdsp, & vdata->vblock);
#line 403
  __cil_tmp10 = psf_rand_int32();
#line 403
  ogg_stream_init(& odata->ostream, __cil_tmp10);
#line 417
  vorbis_analysis_headerout(& vdata->vdsp, & vdata->vcomment, & header, & header_comm,
                            & header_code);
#line 418
  ogg_stream_packetin(& odata->ostream, & header);
#line 419
  ogg_stream_packetin(& odata->ostream, & header_comm);
#line 420
  ogg_stream_packetin(& odata->ostream, & header_code);
  }
  {
#line 425
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 425
    result = ogg_stream_flush(& odata->ostream, & odata->opage);
    }
#line 425
    if (! (result != 0)) {
#line 425
      goto while_break___0;
    }
    {
#line 426
    psf_fwrite((void const   *)odata->opage.header, (sf_count_t )1, odata->opage.header_len,
               psf);
#line 427
    psf_fwrite((void const   *)odata->opage.body, (sf_count_t )1, odata->opage.body_len,
               psf);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 431
  return (0);
}
}
#line 435 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_close(SF_PRIVATE *psf ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int result ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 436
  odata = (OGG_PRIVATE *)psf->container_data;
#line 437
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 439
  if ((unsigned long )odata == (unsigned long )((void *)0)) {
#line 440
    return (0);
  } else
#line 439
  if ((unsigned long )vdata == (unsigned long )((void *)0)) {
#line 440
    return (0);
  }
#line 445
  if (psf->file.mode == 32) {
#line 447
    if (psf->write_current <= 0L) {
      {
#line 448
      vorbis_write_header(psf, 0);
      }
    }
    {
#line 450
    vorbis_analysis_wrote(& vdata->vdsp, 0);
    }
    {
#line 451
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 451
      __cil_tmp4 = vorbis_analysis_blockout(& vdata->vdsp, & vdata->vblock);
      }
#line 451
      if (! (__cil_tmp4 == 1)) {
#line 451
        goto while_break;
      }
      {
#line 455
      vorbis_analysis(& vdata->vblock, (ogg_packet *)((void *)0));
#line 456
      vorbis_bitrate_addblock(& vdata->vblock);
      }
      {
#line 458
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 458
        __cil_tmp5 = vorbis_bitrate_flushpacket(& vdata->vdsp, & odata->opacket);
        }
#line 458
        if (! __cil_tmp5) {
#line 458
          goto while_break___0;
        }
        {
#line 460
        ogg_stream_packetin(& odata->ostream, & odata->opacket);
        }
        {
#line 463
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 463
          if (! (! odata->eos)) {
#line 463
            goto while_break___1;
          }
          {
#line 464
          __cil_tmp7 = ogg_stream_pageout(& odata->ostream, & odata->opage);
#line 464
          result = __cil_tmp7;
          }
#line 465
          if (result == 0) {
#line 465
            goto while_break___1;
          }
          {
#line 466
          psf_fwrite((void const   *)odata->opage.header, (sf_count_t )1, odata->opage.header_len,
                     psf);
#line 467
          psf_fwrite((void const   *)odata->opage.body, (sf_count_t )1, odata->opage.body_len,
                     psf);
#line 472
          __cil_tmp8 = ogg_page_eos(& odata->opage);
          }
#line 472
          if (__cil_tmp8) {
#line 472
            odata->eos = 1;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: ;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 481
  vorbis_block_clear(& vdata->vblock);
#line 482
  vorbis_dsp_clear(& vdata->vdsp);
#line 483
  vorbis_comment_clear(& vdata->vcomment);
#line 484
  vorbis_info_clear(& vdata->vinfo);
  }
#line 486
  return (0);
}
}
#line 490 "/root/patchweave_donee/23/src/ogg_vorbis.c"
int ogg_vorbis_open(SF_PRIVATE *psf ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  void *__cil_tmp4 ;
  int error ;
  char const   *__cil_tmp6 ;

  {
  {
#line 491
  odata = (OGG_PRIVATE *)psf->container_data;
#line 492
  __cil_tmp4 = calloc(1UL, sizeof(VORBIS_PRIVATE ));
#line 492
  vdata = (VORBIS_PRIVATE *)__cil_tmp4;
#line 493
  error = 0;
  }
#line 495
  if ((unsigned long )odata == (unsigned long )((void *)0)) {
    {
#line 496
    psf_log_printf(psf, "%s : odata is NULL???\n", "ogg_vorbis_open");
    }
#line 497
    return (30);
  }
#line 500
  psf->codec_data = (void *)vdata;
#line 502
  if (psf->file.mode == 48) {
#line 503
    return (24);
  }
  {
#line 505
  __cil_tmp6 = vorbis_version_string();
#line 505
  psf_log_printf(psf, "Vorbis library version : %s\n", __cil_tmp6);
  }
#line 507
  if (psf->file.mode == 16) {
    {
#line 509
    ogg_sync_init(& odata->osync);
#line 511
    error = vorbis_read_header(psf, 1);
    }
#line 511
    if (error) {
#line 512
      return (error);
    }
    {
#line 514
    psf->read_short = & vorbis_read_s;
#line 515
    psf->read_int = & vorbis_read_i;
#line 516
    psf->read_float = & vorbis_read_f;
#line 517
    psf->read_double = & vorbis_read_d;
#line 518
    psf->sf.frames = vorbis_length(psf);
    }
  }
#line 521
  psf->codec_close = & vorbis_close;
#line 522
  if (psf->file.mode == 32) {
#line 525
    vdata->quality = 0.400000000001;
#line 527
    psf->write_header = & vorbis_write_header;
#line 528
    psf->write_short = & vorbis_write_s;
#line 529
    psf->write_int = & vorbis_write_i;
#line 530
    psf->write_float = & vorbis_write_f;
#line 531
    psf->write_double = & vorbis_write_d;
#line 533
    psf->sf.frames = (sf_count_t )-1LL;
#line 534
    psf->strings.flags = (uint32_t )256;
  }
#line 537
  psf->seek = & vorbis_seek;
#line 538
  psf->command = & vorbis_command;
#line 539
  psf->byterate = & vorbis_byterate;
#line 542
  psf->sf.format = 2097248;
#line 543
  psf->sf.sections = 1;
#line 545
  psf->datalength = (sf_count_t )1;
#line 546
  psf->dataoffset = (sf_count_t )0;
#line 549
  return (error);
}
}
#line 553 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_command(SF_PRIVATE *psf , int command , void *data , int datasize ) 
{ 
  VORBIS_PRIVATE *vdata ;

  {
#line 554
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 557
  if (command == 4865) {
#line 557
    goto case_4865;
  }
#line 572
  goto switch_default;
  case_4865: 
#line 558
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 559
    return (0);
  } else
#line 558
  if ((unsigned long )datasize != sizeof(double )) {
#line 559
    return (0);
  }
#line 561
  if (psf->have_written) {
#line 562
    return (0);
  }
  {
#line 564
  vdata->quality = 1. - *((double *)data);
#line 567
  vdata->quality = (double )0;
#line 569
  psf_log_printf(psf, "%s : Setting SFC_SET_VBR_ENCODING_QUALITY to %f.\n", "vorbis_command",
                 vdata->quality);
  }
#line 570
  return (1);
  switch_default: 
#line 573
  return (0);

#line 576
  return (0);
}
}
#line 580 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_rnull(SF_PRIVATE *UNUSED_psf , int samples , void *UNUSED_vptr ,
                        int UNUSED_off , int channels , float **UNUSED_pcm ) 
{ 


  {
#line 582
  return (samples * channels);
}
}
#line 586 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_rshort(SF_PRIVATE *psf , int samples , void *vptr , int off , int channels ,
                         float **pcm ) 
{ 
  short *ptr ;
  int i ;
  int j ;
  int n ;
  float inverse ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;

  {
#line 588
  ptr = (short *)vptr + off;
#line 589
  i = 0;
#line 590
  if (psf->float_int_mult) {
#line 592
    inverse = (float )(1. / (double )psf->float_max);
#line 593
    j = 0;
    {
#line 593
    while (1) {
      while_continue: /* CIL Label */ ;

#line 593
      if (! (j < samples)) {
#line 593
        goto while_break;
      }
#line 594
      n = 0;
      {
#line 594
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 594
        if (! (n < channels)) {
#line 594
          goto while_break___0;
        }
        {
#line 595
        __cil_tmp13 = lrintf((*(*(pcm + n) + j) * inverse) * 32767.f);
#line 595
        __cil_tmp12 = i;
#line 595
        i ++;
#line 595
        *(ptr + __cil_tmp12) = (short )__cil_tmp13;
#line 594
        n ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
#line 593
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 599
    j = 0;
    {
#line 599
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 599
      if (! (j < samples)) {
#line 599
        goto while_break___1;
      }
#line 600
      n = 0;
      {
#line 600
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 600
        if (! (n < channels)) {
#line 600
          goto while_break___2;
        }
        {
#line 601
        __cil_tmp17 = lrintf(*(*(pcm + n) + j) * 32767.f);
#line 601
        __cil_tmp16 = i;
#line 601
        i ++;
#line 601
        *(ptr + __cil_tmp16) = (short )__cil_tmp17;
#line 600
        n ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 599
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 603
  return (i);
}
}
#line 607 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_rint(SF_PRIVATE *psf , int samples , void *vptr , int off , int channels ,
                       float **pcm ) 
{ 
  int *ptr ;
  int i ;
  int j ;
  int n ;
  float inverse ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  int __cil_tmp16 ;
  long __cil_tmp17 ;

  {
#line 609
  ptr = (int *)vptr + off;
#line 610
  i = 0;
#line 612
  if (psf->float_int_mult) {
#line 614
    inverse = (float )(1. / (double )psf->float_max);
#line 615
    j = 0;
    {
#line 615
    while (1) {
      while_continue: /* CIL Label */ ;

#line 615
      if (! (j < samples)) {
#line 615
        goto while_break;
      }
#line 616
      n = 0;
      {
#line 616
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 616
        if (! (n < channels)) {
#line 616
          goto while_break___0;
        }
        {
#line 617
        __cil_tmp13 = lrintf((*(*(pcm + n) + j) * inverse) * 2147483648.f);
#line 617
        __cil_tmp12 = i;
#line 617
        i ++;
#line 617
        *(ptr + __cil_tmp12) = (int )__cil_tmp13;
#line 616
        n ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
#line 615
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 621
    j = 0;
    {
#line 621
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 621
      if (! (j < samples)) {
#line 621
        goto while_break___1;
      }
#line 622
      n = 0;
      {
#line 622
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 622
        if (! (n < channels)) {
#line 622
          goto while_break___2;
        }
        {
#line 623
        __cil_tmp17 = lrintf(*(*(pcm + n) + j) * 2147483648.f);
#line 623
        __cil_tmp16 = i;
#line 623
        i ++;
#line 623
        *(ptr + __cil_tmp16) = (int )__cil_tmp17;
#line 622
        n ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 621
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 625
  return (i);
}
}
#line 629 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_rfloat(SF_PRIVATE *UNUSED_psf , int samples , void *vptr , int off ,
                         int channels , float **pcm ) 
{ 
  float *ptr ;
  int i ;
  int j ;
  int n ;
  int __cil_tmp11 ;

  {
#line 631
  ptr = (float *)vptr + off;
#line 632
  i = 0;
#line 633
  j = 0;
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;

#line 633
    if (! (j < samples)) {
#line 633
      goto while_break;
    }
#line 634
    n = 0;
    {
#line 634
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 634
      if (! (n < channels)) {
#line 634
        goto while_break___0;
      }
#line 635
      __cil_tmp11 = i;
#line 635
      i ++;
#line 635
      *(ptr + __cil_tmp11) = *(*(pcm + n) + j);
#line 634
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 633
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 636
  return (i);
}
}
#line 640 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_rdouble(SF_PRIVATE *UNUSED_psf , int samples , void *vptr , int off ,
                          int channels , float **pcm ) 
{ 
  double *ptr ;
  int i ;
  int j ;
  int n ;
  int __cil_tmp11 ;

  {
#line 642
  ptr = (double *)vptr + off;
#line 643
  i = 0;
#line 644
  j = 0;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;

#line 644
    if (! (j < samples)) {
#line 644
      goto while_break;
    }
#line 645
    n = 0;
    {
#line 645
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 645
      if (! (n < channels)) {
#line 645
        goto while_break___0;
      }
#line 646
      __cil_tmp11 = i;
#line 646
      i ++;
#line 646
      *(ptr + __cil_tmp11) = (double )*(*(pcm + n) + j);
#line 645
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 644
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 647
  return (i);
}
}
#line 652 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_read_sample(SF_PRIVATE *psf , void *ptr , sf_count_t lens ,
                                     convert_func *transfn ) 
{ 
  VORBIS_PRIVATE *vdata ;
  OGG_PRIVATE *odata ;
  int len ;
  int samples ;
  int i ;
  float **pcm ;
  int __cil_tmp12 ;
  int result ;
  int __cil_tmp14 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  char *buffer ;
  int bytes ;
  sf_count_t __cil_tmp23 ;

  {
#line 654
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 655
  odata = (OGG_PRIVATE *)psf->container_data;
#line 656
  i = 0;
#line 659
  len = (int )(lens / (long )psf->sf.channels);
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 661
    samples = vorbis_synthesis_pcmout(& vdata->vdsp, & pcm);
    }
#line 661
    if (! (samples > 0)) {
#line 661
      goto while_break;
    }
#line 662
    if (samples > len) {
#line 662
      samples = len;
    }
    {
#line 663
    __cil_tmp12 = (*transfn)(psf, samples, ptr, i, psf->sf.channels, pcm);
#line 663
    i += __cil_tmp12;
#line 664
    len -= samples;
#line 666
    vorbis_synthesis_read(& vdata->vdsp, samples);
#line 667
    vdata->loc += (long )samples;
    }
#line 668
    if (len == 0) {
#line 669
      return ((sf_count_t )i);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 671
  goto start0;
  {
#line 672
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 672
    if (len > 0) {
#line 672
      if (! (! odata->eos)) {
#line 672
        goto while_break___0;
      }
    } else {
#line 672
      goto while_break___0;
    }
    {
#line 674
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 674
      if (len > 0) {
#line 674
        if (! (! odata->eos)) {
#line 674
          goto while_break___1;
        }
      } else {
#line 674
        goto while_break___1;
      }
      {
#line 675
      __cil_tmp14 = ogg_sync_pageout(& odata->osync, & odata->opage);
#line 675
      result = __cil_tmp14;
      }
#line 676
      if (result == 0) {
#line 676
        goto while_break___1;
      }
#line 677
      if (result < 0) {
        {
#line 679
        psf_log_printf(psf, "Corrupt or missing data in bitstream ; continuing...\n");
        }
      } else {
        {
#line 683
        ogg_stream_pagein(& odata->ostream, & odata->opage);
        }
        start0: 
        {
#line 685
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 686
          result = ogg_stream_packetout(& odata->ostream, & odata->opacket);
          }
#line 687
          if (result == 0) {
#line 688
            goto while_break___2;
          }
#line 689
          if (! (result < 0)) {
            {
#line 695
            __cil_tmp16 = vorbis_synthesis(& vdata->vblock, & odata->opacket);
            }
#line 695
            if (__cil_tmp16 == 0) {
              {
#line 696
              vorbis_synthesis_blockin(& vdata->vdsp, & vdata->vblock);
              }
            }
            {
#line 704
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 704
              samples = vorbis_synthesis_pcmout(& vdata->vdsp, & pcm);
              }
#line 704
              if (! (samples > 0)) {
#line 704
                goto while_break___3;
              }
#line 705
              if (samples > len) {
#line 705
                samples = len;
              }
              {
#line 706
              __cil_tmp18 = (*transfn)(psf, samples, ptr, i, psf->sf.channels, pcm);
#line 706
              i += __cil_tmp18;
#line 707
              len -= samples;
#line 709
              vorbis_synthesis_read(& vdata->vdsp, samples);
#line 710
              vdata->loc += (long )samples;
              }
#line 711
              if (len == 0) {
#line 712
                return ((sf_count_t )i);
              }
            }
            while_break___8: /* CIL Label */ ;
            }
            while_break___3: ;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: 
        {
#line 716
        __cil_tmp19 = ogg_page_eos(& odata->opage);
        }
#line 716
        if (__cil_tmp19) {
#line 716
          odata->eos = 1;
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: ;
#line 719
    if (! odata->eos) {
      {
#line 722
      buffer = ogg_sync_buffer(& odata->osync, 4096L);
#line 723
      __cil_tmp23 = psf_fread((void *)buffer, (sf_count_t )1, (sf_count_t )4096, psf);
#line 723
      bytes = (int )__cil_tmp23;
#line 724
      ogg_sync_wrote(& odata->osync, (long )bytes);
      }
#line 725
      if (bytes == 0) {
#line 725
        odata->eos = 1;
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 728
  return ((sf_count_t )i);
}
}
#line 732 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 733
  __cil_tmp4 = vorbis_read_sample(psf, (void *)ptr, lens, & vorbis_rshort);
  }
#line 733
  return (__cil_tmp4);
}
}
#line 737 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 738
  __cil_tmp4 = vorbis_read_sample(psf, (void *)ptr, lens, & vorbis_rint);
  }
#line 738
  return (__cil_tmp4);
}
}
#line 742 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 743
  __cil_tmp4 = vorbis_read_sample(psf, (void *)ptr, lens, & vorbis_rfloat);
  }
#line 743
  return (__cil_tmp4);
}
}
#line 747 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 748
  __cil_tmp4 = vorbis_read_sample(psf, (void *)ptr, lens, & vorbis_rdouble);
  }
#line 748
  return (__cil_tmp4);
}
}
#line 755 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static void vorbis_write_samples(SF_PRIVATE *psf , OGG_PRIVATE *odata , VORBIS_PRIVATE *vdata ,
                                 int in_frames ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int result ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 757
  vorbis_analysis_wrote(& vdata->vdsp, in_frames);
  }
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 764
    __cil_tmp5 = vorbis_analysis_blockout(& vdata->vdsp, & vdata->vblock);
    }
#line 764
    if (! (__cil_tmp5 == 1)) {
#line 764
      goto while_break;
    }
    {
#line 767
    vorbis_analysis(& vdata->vblock, (ogg_packet *)((void *)0));
#line 768
    vorbis_bitrate_addblock(& vdata->vblock);
    }
    {
#line 770
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 770
      __cil_tmp6 = vorbis_bitrate_flushpacket(& vdata->vdsp, & odata->opacket);
      }
#line 770
      if (! __cil_tmp6) {
#line 770
        goto while_break___0;
      }
      {
#line 773
      ogg_stream_packetin(& odata->ostream, & odata->opacket);
      }
      {
#line 776
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 776
        if (! (! odata->eos)) {
#line 776
          goto while_break___1;
        }
        {
#line 777
        __cil_tmp8 = ogg_stream_pageout(& odata->ostream, & odata->opage);
#line 777
        result = __cil_tmp8;
        }
#line 778
        if (result == 0) {
#line 779
          goto while_break___1;
        }
        {
#line 780
        psf_fwrite((void const   *)odata->opage.header, (sf_count_t )1, odata->opage.header_len,
                   psf);
#line 781
        psf_fwrite((void const   *)odata->opage.body, (sf_count_t )1, odata->opage.body_len,
                   psf);
#line 785
        __cil_tmp9 = ogg_page_eos(& odata->opage);
        }
#line 785
        if (__cil_tmp9) {
#line 786
          odata->eos = 1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 791
  vdata->loc += (long )in_frames;
#line 792
  return;
}
}
#line 796 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 798
  j = 0;
#line 799
  odata = (OGG_PRIVATE *)psf->container_data;
#line 800
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 801
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 802
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vdsp, in_frames);
#line 802
  buffer = __cil_tmp11;
#line 803
  i = 0;
  }
  {
#line 803
  while (1) {
    while_continue: /* CIL Label */ ;

#line 803
    if (! (i < in_frames)) {
#line 803
      goto while_break;
    }
#line 804
    m = 0;
    {
#line 804
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 804
      if (! (m < psf->sf.channels)) {
#line 804
        goto while_break___0;
      }
#line 805
      __cil_tmp12 = j;
#line 805
      j ++;
#line 805
      *(*(buffer + m) + i) = (float )*(ptr + __cil_tmp12) / 32767.f;
#line 804
      m ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 803
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 807
  vorbis_write_samples(psf, odata, vdata, in_frames);
  }
#line 809
  return (lens);
}
}
#line 813 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 814
  j = 0;
#line 815
  odata = (OGG_PRIVATE *)psf->container_data;
#line 816
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 817
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 818
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vdsp, in_frames);
#line 818
  buffer = __cil_tmp11;
#line 819
  i = 0;
  }
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;

#line 819
    if (! (i < in_frames)) {
#line 819
      goto while_break;
    }
#line 820
    m = 0;
    {
#line 820
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 820
      if (! (m < psf->sf.channels)) {
#line 820
        goto while_break___0;
      }
#line 821
      __cil_tmp12 = j;
#line 821
      j ++;
#line 821
      *(*(buffer + m) + i) = (float )*(ptr + __cil_tmp12) / 2147483648.f;
#line 820
      m ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 819
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 823
  vorbis_write_samples(psf, odata, vdata, in_frames);
  }
#line 825
  return (lens);
}
}
#line 829 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 830
  j = 0;
#line 831
  odata = (OGG_PRIVATE *)psf->container_data;
#line 832
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 833
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 834
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vdsp, in_frames);
#line 834
  buffer = __cil_tmp11;
#line 835
  i = 0;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;

#line 835
    if (! (i < in_frames)) {
#line 835
      goto while_break;
    }
#line 836
    m = 0;
    {
#line 836
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 836
      if (! (m < psf->sf.channels)) {
#line 836
        goto while_break___0;
      }
#line 837
      __cil_tmp12 = j;
#line 837
      j ++;
#line 837
      *(*(buffer + m) + i) = (float )*(ptr + __cil_tmp12);
#line 836
      m ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 835
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 839
  vorbis_write_samples(psf, odata, vdata, in_frames);
  }
#line 841
  return (lens);
}
}
#line 845 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 846
  j = 0;
#line 847
  odata = (OGG_PRIVATE *)psf->container_data;
#line 848
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 849
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 850
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vdsp, in_frames);
#line 850
  buffer = __cil_tmp11;
#line 851
  i = 0;
  }
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;

#line 851
    if (! (i < in_frames)) {
#line 851
      goto while_break;
    }
#line 852
    m = 0;
    {
#line 852
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 852
      if (! (m < psf->sf.channels)) {
#line 852
        goto while_break___0;
      }
#line 853
      __cil_tmp12 = j;
#line 853
      j ++;
#line 853
      *(*(buffer + m) + i) = (float )*(ptr + __cil_tmp12);
#line 852
      m ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 851
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 855
  vorbis_write_samples(psf, odata, vdata, in_frames);
  }
#line 857
  return (lens);
}
}
#line 861 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  sf_count_t target ;
  sf_count_t m ;
  long tmp ;

  {
#line 863
  odata = (OGG_PRIVATE *)psf->container_data;
#line 864
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 866
  if ((unsigned long )odata == (unsigned long )((void *)0)) {
#line 867
    return ((sf_count_t )0);
  } else
#line 866
  if ((unsigned long )vdata == (unsigned long )((void *)0)) {
#line 867
    return ((sf_count_t )0);
  }
#line 869
  if (offset < 0L) {
#line 870
    psf->error = 39;
#line 871
    return ((sf_count_t )-1);
  }
#line 874
  if (psf->file.mode == 16) {
#line 875
    target = offset - vdata->loc;
#line 877
    if (target < 0L) {
      {
#line 879
      psf_fseek(psf, (sf_count_t )12, 0);
#line 880
      vorbis_read_header(psf, 0);
#line 881
      target = offset;
      }
    }
    {
#line 884
    while (1) {
      while_continue: /* CIL Label */ ;

#line 884
      if (! (target > 0L)) {
#line 884
        goto while_break;
      }
#line 885
      if (target > 4096L) {
#line 885
        tmp = 4096L;
      } else {
#line 885
        tmp = target;
      }
      {
#line 885
      m = tmp;
#line 892
      vorbis_read_sample(psf, (void *)0, m * (long )psf->sf.channels, & vorbis_rnull);
#line 894
      target -= m;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 897
    return (vdata->loc);
  }
#line 900
  return ((sf_count_t )0);
}
}
#line 905 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_byterate(SF_PRIVATE *psf ) 
{ 


  {
#line 907
  if (psf->file.mode == 16) {
#line 908
    return ((int )((psf->datalength * (long )psf->sf.samplerate) / psf->sf.frames));
  }
#line 910
  return (-1);
}
}
#line 945 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static stream_set *create_stream_set(void) 
{ 
  stream_set *set ;
  void *__cil_tmp2 ;
  void *tmp ;

  {
  {
#line 946
  __cil_tmp2 = calloc(1UL, sizeof(stream_set ));
#line 946
  set = (stream_set *)__cil_tmp2;
#line 948
  tmp = calloc(5UL, sizeof(stream_processor ));
#line 948
  set->streams = (stream_processor *)tmp;
#line 949
  set->allocated = 5;
#line 950
  set->used = 0;
  }
#line 952
  return (set);
}
}
#line 956 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static void vorbis_end(stream_processor *stream , sf_count_t *len ) 
{ 


  {
  {
#line 957
  *len += stream->lastgranulepos;
#line 958
  vorbis_comment_clear(& stream->vcomment);
#line 959
  vorbis_info_clear(& stream->vinfo);
  }
#line 961
  return;
}
}
#line 963 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static void free_stream_set(stream_set *set , sf_count_t *len ) 
{ 
  int i ;

  {
#line 966
  i = 0;
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;

#line 966
    if (! (i < set->used)) {
#line 966
      goto while_break;
    }
#line 967
    if (! (set->streams + i)->end) {
      {
#line 968
      vorbis_end(set->streams + i, len);
      }
    }
    {
#line 969
    ogg_stream_clear(& (set->streams + i)->ostream);
#line 966
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 972
  free((void *)set->streams);
#line 973
  free((void *)set);
  }
#line 975
  return;
}
}
#line 977 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int streams_open(stream_set *set ) 
{ 
  int i ;
  int res ;

  {
#line 978
  res = 0;
#line 980
  i = 0;
  {
#line 980
  while (1) {
    while_continue: /* CIL Label */ ;

#line 980
    if (! (i < set->used)) {
#line 980
      goto while_break;
    }
#line 981
    if (! (set->streams + i)->end) {
#line 982
      res ++;
    }
#line 980
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 983
  return (res);
}
}
#line 987 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static stream_processor *find_stream_processor(stream_set *set , ogg_page *page ) 
{ 
  uint32_t serial ;
  int __cil_tmp4 ;
  int i ;
  int invalid ;
  stream_processor *stream ;
  int __cil_tmp10 ;
  int res ;
  ogg_packet packet ;
  int __cil_tmp16 ;
  void *tmp ;

  {
  {
#line 988
  __cil_tmp4 = ogg_page_serialno(page);
#line 988
  serial = (uint32_t )__cil_tmp4;
#line 989
  invalid = 0;
#line 993
  i = 0;
  }
  {
#line 993
  while (1) {
    while_continue: /* CIL Label */ ;

#line 993
    if (! (i < set->used)) {
#line 993
      goto while_break;
    }
#line 995
    if (serial == (set->streams + i)->serial) {
#line 997
      stream = set->streams + i;
#line 999
      set->in_headers = 0;
#line 1001
      if (stream->end) {
#line 1002
        stream->isillegal = 1;
#line 1003
        return (stream);
      }
      {
#line 1006
      stream->isnew = 0;
#line 1007
      stream->end = ogg_page_eos(page);
#line 1008
      stream->serial = serial;
      }
#line 1009
      return (stream);
    }
#line 993
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1018
  __cil_tmp10 = streams_open(set);
  }
#line 1018
  if (__cil_tmp10) {
#line 1018
    if (! set->in_headers) {
#line 1019
      invalid = 1;
    }
  }
#line 1021
  set->in_headers = 1;
#line 1023
  if (set->allocated < set->used) {
#line 1024
    stream = set->streams + set->used;
  } else {
    {
#line 1026
    set->allocated += 5;
#line 1027
    tmp = realloc((void *)set->streams, sizeof(stream_processor ) * (unsigned long )set->allocated);
#line 1027
    set->streams = (stream_processor *)tmp;
#line 1028
    stream = set->streams + set->used;
    }
  }
  {
#line 1031
  (set->used) ++;
#line 1033
  stream->isnew = 1;
#line 1034
  stream->isillegal = invalid;
#line 1041
  ogg_stream_init(& stream->ostream, (int )serial);
#line 1042
  ogg_stream_pagein(& stream->ostream, page);
#line 1043
  res = ogg_stream_packetout(& stream->ostream, & packet);
  }
#line 1044
  if (res <= 0) {
#line 1045
    return ((stream_processor *)((void *)0));
  } else {
    {
#line 1046
    __cil_tmp16 = memcmp((void const   *)packet.packet, (void const   *)"\001vorbis",
                         7UL);
    }
#line 1046
    if (packet.bytes >= 7L) {
#line 1046
      if (__cil_tmp16 == 0) {
        {
#line 1048
        stream->lastgranulepos = (sf_count_t )0;
#line 1049
        vorbis_comment_init(& stream->vcomment);
#line 1050
        vorbis_info_init(& stream->vinfo);
        }
      }
    }
  }
  {
#line 1053
  res = ogg_stream_packetout(& stream->ostream, & packet);
#line 1056
  ogg_stream_clear(& stream->ostream);
#line 1057
  ogg_stream_init(& stream->ostream, (int )serial);
#line 1060
  stream->end = ogg_page_eos(page);
#line 1061
  stream->serial = serial;
  }
#line 1063
  return (stream);
}
}
#line 1069 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int CHUNK_SIZE  ;
#line 1067 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static int vorbis_length_get_next_page(SF_PRIVATE *psf , ogg_sync_state *osync , ogg_page *page ) 
{ 
  int __cil_tmp5 ;
  char *buffer ;
  char *__cil_tmp7 ;
  int bytes ;
  sf_count_t __cil_tmp9 ;

  {
#line 1068
  CHUNK_SIZE = 4500;
  {
#line 1070
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1070
    __cil_tmp5 = ogg_sync_pageout(osync, page);
    }
#line 1070
    if (! (__cil_tmp5 <= 0)) {
#line 1070
      goto while_break;
    }
    {
#line 1071
    __cil_tmp7 = ogg_sync_buffer(osync, (long )CHUNK_SIZE);
#line 1071
    buffer = __cil_tmp7;
#line 1072
    __cil_tmp9 = psf_fread((void *)buffer, (sf_count_t )1, (sf_count_t )4096, psf);
#line 1072
    bytes = (int )__cil_tmp9;
    }
#line 1074
    if (bytes <= 0) {
      {
#line 1075
      ogg_sync_wrote(osync, 0L);
      }
#line 1076
      return (0);
    }
    {
#line 1079
    ogg_sync_wrote(osync, (long )bytes);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1082
  return (1);
}
}
#line 1086 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_length_aux(SF_PRIVATE *psf ) 
{ 
  ogg_sync_state osync ;
  ogg_page page ;
  sf_count_t len ;
  stream_set *processors ;
  int __cil_tmp7 ;
  stream_processor *p ;
  stream_processor *__cil_tmp9 ;
  ogg_packet packet ;
  int header ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  sf_count_t gp ;
  ogg_int64_t __cil_tmp16 ;

  {
  {
#line 1090
  len = (sf_count_t )0;
#line 1093
  processors = create_stream_set();
  }
#line 1094
  if ((unsigned long )processors == (unsigned long )((void *)0)) {
#line 1095
    return ((sf_count_t )0);
  }
  {
#line 1097
  ogg_sync_init(& osync);
  }
  {
#line 1099
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: 
    {
#line 1099
    __cil_tmp7 = vorbis_length_get_next_page(psf, & osync, & page);
    }
#line 1099
    if (! __cil_tmp7) {
#line 1099
      goto while_break;
    }
    {
#line 1101
    __cil_tmp9 = find_stream_processor(processors, & page);
#line 1101
    p = __cil_tmp9;
    }
#line 1103
    if (! p) {
#line 1104
      len = (sf_count_t )0;
#line 1105
      goto while_break;
    }
#line 1108
    if (p->isillegal) {
#line 1108
      if (! p->shownillegal) {
#line 1110
        p->shownillegal = 1;
#line 1114
        if (! p->isnew) {
#line 1114
          goto while_continue;
        }
      }
    }
#line 1117
    if (! p->isillegal) {
      {
#line 1119
      header = 0;
#line 1121
      ogg_stream_pagein(& p->ostream, & page);
      }
#line 1122
      if (p->doneheaders < 3) {
#line 1123
        header = 1;
      }
      {
#line 1125
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: 
        {
#line 1125
        __cil_tmp12 = ogg_stream_packetout(& p->ostream, & packet);
        }
#line 1125
        if (! (__cil_tmp12 > 0)) {
#line 1125
          goto while_break___0;
        }
#line 1127
        if (p->doneheaders < 3) {
          {
#line 1128
          __cil_tmp13 = vorbis_synthesis_headerin(& p->vinfo, & p->vcomment, & packet);
          }
#line 1128
          if (__cil_tmp13 < 0) {
#line 1129
            goto while_continue___0;
          }
#line 1130
          (p->doneheaders) ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
#line 1133
      if (! header) {
        {
#line 1134
        __cil_tmp16 = ogg_page_granulepos(& page);
#line 1134
        gp = __cil_tmp16;
        }
#line 1135
        if (gp > 0L) {
#line 1135
          p->lastgranulepos = gp;
        }
      }
#line 1137
      if (p->end) {
        {
#line 1138
        vorbis_end(p, & len);
#line 1139
        p->isillegal = 1;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1144
  ogg_sync_clear(& osync);
#line 1145
  free_stream_set(processors, & len);
  }
#line 1147
  return (len);
}
}
#line 1151 "/root/patchweave_donee/23/src/ogg_vorbis.c"
static sf_count_t vorbis_length(SF_PRIVATE *psf ) 
{ 
  sf_count_t length ;
  int error ;

  {
#line 1155
  if (psf->sf.seekable == 0) {
#line 1156
    return ((sf_count_t )-1LL);
  }
  {
#line 1158
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1159
  length = vorbis_length_aux(psf);
#line 1161
  psf_fseek(psf, (sf_count_t )12, 0);
#line 1162
  error = vorbis_read_header(psf, 0);
  }
#line 1162
  if (error != 0) {
#line 1163
    psf->error = error;
  }
#line 1165
  return (length);
}
}
#line 73 "/root/patchweave_donee/23/src/rf64.c"
static int rf64_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) ;
#line 74
static int rf64_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 75
static int rf64_close(SF_PRIVATE *psf ) ;
#line 76
static int rf64_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int datasize ) ;
#line 83 "/root/patchweave_donee/23/src/rf64.c"
int rf64_open(SF_PRIVATE *psf ) 
{ 
  WAV_PRIVATE *wpriv ;
  int subformat ;
  int error ;
  int blockalign ;
  int framesperblock ;
  void *tmp ;

  {
  {
#line 85
  error = 0;
#line 88
  tmp = calloc(1UL, sizeof(WAV_PRIVATE ));
#line 88
  wpriv = (WAV_PRIVATE *)tmp;
  }
#line 88
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 89
    return (17);
  }
#line 90
  psf->container_data = (void *)wpriv;
#line 91
  wpriv->wavex_ambisonic = 64;
#line 94
  psf->endian = 268435456;
#line 97
  if (psf->file.mode == 16) {
    _L: 
    {
#line 98
    error = rf64_read_header(psf, & blockalign, & framesperblock);
    }
#line 98
    if (error != 0) {
#line 99
      return (error);
    }
  } else
#line 97
  if (psf->file.mode == 48) {
#line 97
    if (psf->filelength > 0L) {
#line 97
      goto _L;
    }
  }
#line 102
  if ((psf->sf.format & 268369920) != 2228224) {
#line 103
    return (1);
  }
#line 105
  subformat = psf->sf.format & 65535;
#line 107
  if (psf->file.mode == 32) {
    _L___9: 
#line 108
    if (psf->is_pipe) {
#line 109
      return (29);
    }
    {
#line 111
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 113
    error = rf64_write_header(psf, 0);
    }
#line 113
    if (error) {
#line 114
      return (error);
    }
#line 116
    psf->write_header = & rf64_write_header;
  } else
#line 107
  if (psf->file.mode == 48) {
#line 107
    goto _L___9;
  }
#line 119
  psf->container_close = & rf64_close;
#line 120
  psf->command = & rf64_command;
#line 126
  if (subformat == 4) {
#line 126
    goto case_4;
  }
#line 126
  if (subformat == 3) {
#line 126
    goto case_4;
  }
#line 126
  if (subformat == 2) {
#line 126
    goto case_4;
  }
#line 126
  if (subformat == 5) {
#line 126
    goto case_4;
  }
#line 130
  if (subformat == 16) {
#line 130
    goto case_16;
  }
#line 134
  if (subformat == 17) {
#line 134
    goto case_17;
  }
#line 139
  if (subformat == 6) {
#line 139
    goto case_6;
  }
#line 143
  if (subformat == 7) {
#line 143
    goto case_7;
  }
#line 149
  goto switch_default;
  case_4: 
  {
#line 127
  error = pcm_init(psf);
  }
#line 128
  goto switch_break;
  case_16: 
  {
#line 131
  error = ulaw_init(psf);
  }
#line 132
  goto switch_break;
  case_17: 
  {
#line 135
  error = alaw_init(psf);
  }
#line 136
  goto switch_break;
  case_6: 
  {
#line 140
  error = float32_init(psf);
  }
#line 141
  goto switch_break;
  case_7: 
  {
#line 144
  error = double64_init(psf);
  }
#line 145
  goto switch_break;
  switch_default: 
#line 149
  return (18);
  switch_break: ;
#line 152
  return (error);
}
}
#line 168 "/root/patchweave_donee/23/src/rf64.c"
static int rf64_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) 
{ 
  WAV_PRIVATE *wpriv ;
  WAV_FMT *wav_fmt ;
  sf_count_t riff_size ;
  sf_count_t frame_count ;
  sf_count_t ds64_datalength ;
  uint32_t marks[2] ;
  uint32_t chunk_size ;
  uint32_t parsestage ;
  int marker ;
  int error ;
  int done ;
  int format ;
  sf_count_t pos ;
  sf_count_t __cil_tmp17 ;
  unsigned int table_len ;
  unsigned int bytesread ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned int next ;
  sf_count_t __cil_tmp28 ;
  sf_count_t __cil_tmp29 ;
  unsigned short const   **__cil_tmp30 ;
  unsigned short const   **__cil_tmp31 ;
  unsigned short const   **__cil_tmp32 ;
  unsigned short const   **__cil_tmp33 ;
  sf_count_t __cil_tmp34 ;
  sf_count_t __cil_tmp35 ;
  sf_count_t __cil_tmp36 ;
  int __cil_tmp37 ;
  int tmp ;

  {
#line 171
  riff_size = (sf_count_t )0;
#line 171
  frame_count = (sf_count_t )0;
#line 171
  ds64_datalength = (sf_count_t )0;
#line 172
  parsestage = (uint32_t )0;
#line 173
  done = 0;
#line 173
  format = 0;
#line 175
  wpriv = (WAV_PRIVATE *)psf->container_data;
#line 175
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 176
    return (30);
  }
  {
#line 177
  wav_fmt = & wpriv->wav_fmt;
#line 180
  psf_binheader_readf(psf, "pmmm", 0, & marker, marks, marks + 1);
  }
#line 181
  if ((unsigned int )marker != ((unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24))) {
#line 182
    return (162);
  } else
#line 181
  if (marks[1] != ((unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24))) {
#line 182
    return (162);
  }
#line 184
  if (marks[0] == ((unsigned int )((255 | (255 << 8)) | (255 << 16)) | (255U << 24))) {
    {
#line 185
    psf_log_printf(psf, "%M\n  %M\n\221", (unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24),
                   (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24));
    }
  } else {
    {
#line 187
    psf_log_printf(psf, "%M : 0x%x (should be 0xFFFFFFFF)\n  %M\n", (unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24),
                   (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24));
    }
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;

#line 189
    if (! (! done)) {
#line 189
      goto while_break;
    }
    {
#line 191
    chunk_size = (uint32_t )0;
#line 191
    marker = (int )chunk_size;
#line 192
    psf_binheader_readf(psf, "em4", & marker, & chunk_size);
    }
#line 194
    if (marker == 0) {
      {
#line 195
      __cil_tmp17 = psf_ftell(psf);
#line 195
      pos = __cil_tmp17;
#line 196
      psf_log_printf(psf, "Have 0 marker at position %D (0x%x).\nU", pos, pos);
      }
#line 197
      goto while_break;
    }
#line 201
    if (marker == (int )((unsigned int )((100 | (115 << 8)) | (54 << 16)) | (52U << 24))) {
#line 201
      goto case_exp;
    }
#line 246
    if (marker == (int )((unsigned int )((102 | (109 << 8)) | (116 << 16)) | (32U << 24))) {
#line 246
      goto case_exp___0;
    }
#line 254
    if (marker == (int )((unsigned int )((98 | (101 << 8)) | (120 << 16)) | (116U << 24))) {
#line 254
      goto case_exp___1;
    }
#line 260
    if (marker == (int )((unsigned int )((99 | (97 << 8)) | (114 << 16)) | (116U << 24))) {
#line 260
      goto case_exp___2;
    }
#line 266
    if (marker == (int )((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 266
      goto case_exp___3;
    }
#line 311
    goto switch_default;
    case_exp: 
#line 202
    if (parsestage & 1U) {
      {
#line 203
      psf_log_printf(psf, "*** Second \'ds64\' chunk?\n\343\263\327\204U");
      }
#line 204
      goto switch_break;
    }
    {
#line 210
    __cil_tmp20 = psf_binheader_readf(psf, "888\327\204U", & riff_size, & ds64_datalength,
                                      & frame_count);
#line 210
    bytesread = (unsigned int )__cil_tmp20;
#line 213
    __cil_tmp21 = psf_binheader_readf(psf, "4\350\263\327\204U", & table_len);
#line 213
    bytesread += (unsigned int )__cil_tmp21;
#line 215
    __cil_tmp22 = psf_binheader_readf(psf, "j\343\263\327\204U", table_len);
#line 215
    bytesread += (unsigned int )__cil_tmp22;
    }
#line 217
    if (chunk_size == bytesread) {
      {
#line 218
      psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
      }
    } else
#line 219
    if (chunk_size >= bytesread + 4U) {
      {
#line 221
      psf_binheader_readf(psf, "m", & next);
      }
#line 222
      if (next == ((unsigned int )((102 | (109 << 8)) | (116 << 16)) | (32U << 24))) {
        {
#line 223
        psf_log_printf(psf, "%M : %u (should be %u)\n", marker, chunk_size, bytesread);
#line 224
        psf_binheader_readf(psf, "j", -4);
        }
      } else {
        {
#line 227
        psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
#line 228
        psf_binheader_readf(psf, "j", (chunk_size - bytesread) - 4U);
        }
      }
    }
#line 232
    if (psf->filelength != riff_size + 8L) {
      {
#line 233
      psf_log_printf(psf, "  Riff size : %D (should be %D)\n\230\001", riff_size,
                     psf->filelength - 8L);
      }
    } else {
      {
#line 235
      psf_log_printf(psf, "  Riff size : %D\n", riff_size);
      }
    }
    {
#line 237
    psf_log_printf(psf, "  Data size : %D\n", ds64_datalength);
#line 239
    psf_log_printf(psf, "  Frames    : %D\n", frame_count);
#line 240
    psf_log_printf(psf, "  Table length : %u\n", table_len);
#line 243
    parsestage |= 1U;
    }
#line 244
    goto switch_break;
    case_exp___0: 
    {
#line 247
    psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
#line 248
    error = wav_w64_read_fmt_chunk(psf, (int )chunk_size);
    }
#line 248
    if (error != 0) {
#line 249
      return (error);
    }
#line 250
    format = (int )wav_fmt->format;
#line 251
    parsestage |= 2U;
#line 252
    goto switch_break;
    case_exp___1: 
    {
#line 255
    error = wav_read_bext_chunk(psf, chunk_size);
    }
#line 255
    if (error != 0) {
#line 256
      return (error);
    }
#line 257
    parsestage |= 4U;
#line 258
    goto switch_break;
    case_exp___2: 
    {
#line 261
    error = wav_read_cart_chunk(psf, chunk_size);
    }
#line 261
    if (error != 0) {
#line 262
      return (error);
    }
#line 263
    parsestage |= 16U;
#line 264
    goto switch_break;
    case_exp___3: 
#line 269
    if ((parsestage & 1U) != 0U) {
#line 270
      if (chunk_size == 4294967295U) {
        {
#line 271
        psf_log_printf(psf, "%M : 0x%x\n", marker, chunk_size);
        }
      } else {
        {
#line 273
        psf_log_printf(psf, "%M : 0x%x (should be 0xffffffff\n\230\001", marker, chunk_size);
        }
      }
#line 274
      psf->datalength = ds64_datalength;
    } else
#line 277
    if (chunk_size == 4294967295U) {
      {
#line 278
      psf_log_printf(psf, "%M : 0x%x\n", marker, chunk_size);
#line 279
      psf_log_printf(psf, "  *** Data length not specified no \'ds64\' chunk.\n");
      }
    } else {
      {
#line 282
      psf_log_printf(psf, "%M : 0x%x\n**** Weird, RF64 file without a \'ds64\' chunk and no valid \'data\' size.\n",
                     marker, chunk_size);
#line 283
      psf->datalength = (sf_count_t )chunk_size;
      }
    }
    {
#line 287
    psf->dataoffset = psf_ftell(psf);
    }
#line 289
    if (psf->dataoffset > 0L) {
#line 290
      if (chunk_size == 0U) {
#line 290
        if (riff_size == 8L) {
#line 290
          if (psf->filelength > 44L) {
            {
#line 291
            psf_log_printf(psf, "  *** Looks like a WAV file which wasn\'t closed properly. Fixing it.\n");
#line 292
            psf->datalength = psf->filelength - psf->dataoffset;
            }
          }
        }
      }
#line 296
      if (psf->datalength + psf->dataoffset < psf->filelength) {
#line 297
        psf->dataend = psf->datalength + psf->dataoffset;
      }
#line 299
      if (! psf->sf.seekable) {
#line 300
        goto switch_break;
      } else
#line 299
      if (psf->dataoffset < 0L) {
#line 300
        goto switch_break;
      }
      {
#line 303
      psf_fseek(psf, psf->datalength, 1);
#line 305
      __cil_tmp28 = psf_ftell(psf);
      }
#line 305
      if (__cil_tmp28 != psf->datalength + psf->dataoffset) {
        {
#line 306
        psf_log_printf(psf, "  *** psf_fseek past end error ***\n");
        }
      }
#line 307
      goto switch_break;
    }
#line 309
    goto switch_break;
    switch_default: 
#line 312
    if (chunk_size >= 4294901760U) {
      {
#line 313
      __cil_tmp29 = psf_ftell(psf);
#line 313
      psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\n",
                     marker, __cil_tmp29 - 8L, chunk_size);
#line 314
      done = 1;
      }
#line 315
      goto switch_break;
    }
    {
#line 318
    __cil_tmp33 = __ctype_b_loc();
#line 318
    __cil_tmp32 = __ctype_b_loc();
#line 318
    __cil_tmp31 = __ctype_b_loc();
#line 318
    __cil_tmp30 = __ctype_b_loc();
    }
#line 318
    if ((int )*(*__cil_tmp30 + ((marker >> 24) & 255)) & 16384) {
#line 318
      if ((int )*(*__cil_tmp31 + ((marker >> 16) & 255)) & 16384) {
#line 318
        if ((int )*(*__cil_tmp32 + ((marker >> 8) & 255)) & 16384) {
#line 318
          if ((int )*(*__cil_tmp33 + (marker & 255)) & 16384) {
            {
#line 320
            psf_log_printf(psf, "*** %M : %d (unknown marker)\n", marker, chunk_size);
            }
#line 321
            if (chunk_size < 8U) {
#line 322
              done = 1;
            }
            {
#line 323
            psf_binheader_readf(psf, "j", chunk_size);
            }
#line 324
            goto switch_break;
          }
        }
      }
    }
    {
#line 326
    __cil_tmp34 = psf_ftell(psf);
    }
#line 326
    if (__cil_tmp34 & 3L) {
      {
#line 327
      psf_log_printf(psf, "  Unknown chunk marker at position 0x%x. Resynching.\n",
                     chunk_size - 4U);
#line 328
      psf_binheader_readf(psf, "j", -3);
      }
#line 329
      goto switch_break;
    }
    {
#line 331
    __cil_tmp35 = psf_ftell(psf);
#line 331
    psf_log_printf(psf, "*** Unknown chunk marker (0x%X) at position 0x%X. Exiting parser.\n",
                   marker, __cil_tmp35 - 4L);
#line 332
    done = 1;
    }
#line 333
    goto switch_break;
    switch_break: ;
#line 339
    if ((unsigned int )marker != ((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 339
      if ((long )chunk_size >= psf->filelength) {
        {
#line 340
        psf_log_printf(psf, "*** Chunk size %u > file length %D. Exiting parser.\n",
                       chunk_size, psf->filelength);
        }
#line 341
        goto while_break;
      }
    }
    {
#line 344
    __cil_tmp36 = psf_ftell(psf);
    }
#line 344
    if (__cil_tmp36 >= psf->filelength - (long )((int )sizeof(marker))) {
      {
#line 345
      psf_log_printf(psf, "End\n");
      }
#line 346
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 350
  if (psf->dataoffset <= 0L) {
#line 351
    return (71);
  }
#line 353
  if (psf->sf.channels < 1) {
#line 354
    return (33);
  }
#line 356
  if (psf->sf.channels >= 1024) {
#line 357
    return (34);
  }
  {
#line 360
  psf->endian = psf->rwf_endian;
#line 362
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 364
  if (psf->is_pipe == 0) {
    {
#line 369
    psf_binheader_readf(psf, "4", & marker);
    }
#line 370
    if ((unsigned int )marker == ((unsigned int )((119 | (118 << 8)) | (112 << 16)) | (107U << 24))) {
#line 371
      return (78);
    } else
#line 370
    if ((unsigned int )marker == ((unsigned int )((79 | (103 << 8)) | (103 << 16)) | (83U << 24))) {
#line 371
      return (78);
    }
  }
  {
#line 375
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 377
  if (psf->blockwidth) {
#line 378
    if (psf->filelength - psf->dataoffset < psf->datalength) {
#line 379
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    } else {
#line 381
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
  }
#line 384
  if (frame_count != psf->sf.frames) {
    {
#line 385
    psf_log_printf(psf, "*** Calculated frame count %d does not match value from \'ds64\' chunk of %d.\n",
                   psf->sf.frames, frame_count);
    }
  }
#line 389
  if (format == 65534) {
#line 389
    goto case_65534;
  }
#line 400
  if (format == 1) {
#line 400
    goto case_1;
  }
#line 405
  if (format == 257) {
#line 405
    goto case_257;
  }
#line 405
  if (format == 7) {
#line 405
    goto case_257;
  }
#line 410
  if (format == 258) {
#line 410
    goto case_258;
  }
#line 410
  if (format == 6) {
#line 410
    goto case_258;
  }
#line 414
  if (format == 2) {
#line 414
    goto case_2;
  }
#line 420
  if (format == 17) {
#line 420
    goto case_17;
  }
#line 426
  if (format == 49) {
#line 426
    goto case_49;
  }
#line 430
  if (format == 3) {
#line 430
    goto case_3;
  }
#line 435
  if (format == 64) {
#line 435
    goto case_64;
  }
#line 439
  goto switch_default___0;
  case_65534: 
#line 392
  psf->sf.format = (psf->sf.format & -268369921) | 2228224;
#line 394
  if (psf->sf.format == 1245203) {
#line 395
    *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 396
    *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
  }
#line 398
  goto switch_break___0;
  case_1: 
  {
#line 401
  __cil_tmp37 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 401
  psf->sf.format = 2228224 | __cil_tmp37;
  }
#line 402
  goto switch_break___0;
  case_257: 
#line 406
  psf->sf.format = 2228240;
#line 407
  goto switch_break___0;
  case_258: 
#line 411
  psf->sf.format = 2228241;
#line 412
  goto switch_break___0;
  case_2: 
#line 415
  psf->sf.format = 2228243;
#line 416
  *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 417
  *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
#line 418
  goto switch_break___0;
  case_17: 
#line 421
  psf->sf.format = 2228242;
#line 422
  *blockalign = (int )wav_fmt->ima.blockalign;
#line 423
  *framesperblock = (int )wav_fmt->ima.samplesperblock;
#line 424
  goto switch_break___0;
  case_49: 
#line 427
  psf->sf.format = 2228256;
#line 428
  goto switch_break___0;
  case_3: 
#line 431
  psf->sf.format = 2228224;
#line 432
  if (psf->bytewidth == 8) {
#line 432
    tmp = 7;
  } else {
#line 432
    tmp = 6;
  }
#line 432
  psf->sf.format |= tmp;
#line 433
  goto switch_break___0;
  case_64: 
#line 436
  psf->sf.format = 2228272;
#line 437
  goto switch_break___0;
  switch_default___0: 
#line 439
  return (18);
  switch_break___0: ;
#line 442
  if (wpriv->fmt_is_broken) {
    {
#line 443
    wav_w64_analyze(psf);
    }
  }
#line 446
  if (psf->endian == 536870912) {
#line 447
    psf->sf.format |= 536870912;
  }
#line 449
  return (0);
}
}
#line 453 "/root/patchweave_donee/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_PCM  =    {1U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 461 "/root/patchweave_donee/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_IEEE_FLOAT  =    {3U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 465 "/root/patchweave_donee/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_ALAW  =    {6U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 469 "/root/patchweave_donee/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MULAW  =    {7U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 477 "/root/patchweave_donee/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM  =    {1U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 481 "/root/patchweave_donee/23/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT  =    {3U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 487 "/root/patchweave_donee/23/src/rf64.c"
static int rf64_write_fmt_chunk(SF_PRIVATE *psf ) 
{ 
  WAV_PRIVATE *wpriv ;
  int subformat ;
  int fmt_size ;
  EXT_SUBFORMAT *tmp ;
  EXT_SUBFORMAT *tmp___0 ;

  {
#line 491
  wpriv = (WAV_PRIVATE *)psf->container_data;
#line 491
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 492
    return (30);
  }
#line 494
  subformat = psf->sf.format & 65535;
#line 505
  if (subformat == 17) {
#line 505
    goto case_17;
  }
#line 505
  if (subformat == 16) {
#line 505
    goto case_17;
  }
#line 505
  if (subformat == 7) {
#line 505
    goto case_17;
  }
#line 505
  if (subformat == 6) {
#line 505
    goto case_17;
  }
#line 505
  if (subformat == 4) {
#line 505
    goto case_17;
  }
#line 505
  if (subformat == 3) {
#line 505
    goto case_17;
  }
#line 505
  if (subformat == 2) {
#line 505
    goto case_17;
  }
#line 505
  if (subformat == 5) {
#line 505
    goto case_17;
  }
#line 535
  if (subformat == 1) {
#line 535
    goto case_1;
  }
#line 539
  if (subformat == 2) {
#line 539
    goto case_2___0;
  }
#line 543
  if (subformat == 4) {
#line 543
    goto case_4___0;
  }
#line 547
  if (subformat == 6) {
#line 547
    goto case_6___0;
  }
#line 551
  if (subformat == 8) {
#line 551
    goto case_8;
  }
#line 563
  goto switch_default___0;
  case_17: 
  {
#line 506
  fmt_size = 40;
#line 509
  psf_binheader_writef(psf, "4224", fmt_size, 65534, psf->sf.channels, psf->sf.samplerate);
#line 511
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 513
  psf_binheader_writef(psf, "22\264\327\204U", psf->bytewidth * psf->sf.channels,
                       psf->bytewidth * 8);
#line 516
  psf_binheader_writef(psf, "2", 22);
#line 519
  psf_binheader_writef(psf, "2|\264\327\204U", psf->bytewidth * 8);
  }
#line 524
  if (wpriv->wavex_ambisonic != 64) {
    {
#line 525
    psf_binheader_writef(psf, "4", 0);
    }
  } else
#line 526
  if (wpriv->wavex_channelmask != 0U) {
    {
#line 527
    psf_binheader_writef(psf, "4", wpriv->wavex_channelmask);
    }
  } else {
#line 535
    if (psf->sf.channels == 1) {
#line 535
      goto case_1;
    }
#line 539
    if (psf->sf.channels == 2) {
#line 539
      goto case_2___0;
    }
#line 543
    if (psf->sf.channels == 4) {
#line 543
      goto case_4___0;
    }
#line 547
    if (psf->sf.channels == 6) {
#line 547
      goto case_6___0;
    }
#line 551
    if (psf->sf.channels == 8) {
#line 551
      goto case_8;
    }
#line 555
    goto switch_default;
    case_1: 
    {
#line 536
    psf_binheader_writef(psf, "4v\264\327\204U", 4);
    }
#line 537
    goto switch_break___0;
    case_2___0: 
    {
#line 540
    psf_binheader_writef(psf, "4u\264\327\204U", 3);
    }
#line 541
    goto switch_break___0;
    case_4___0: 
    {
#line 544
    psf_binheader_writef(psf, "4", 51);
    }
#line 545
    goto switch_break___0;
    case_6___0: 
    {
#line 548
    psf_binheader_writef(psf, "4", 63);
    }
#line 549
    goto switch_break___0;
    case_8: 
    {
#line 552
    psf_binheader_writef(psf, "4m\264\327\204U", 255);
    }
#line 553
    goto switch_break___0;
    switch_default: 
    {
#line 556
    psf_binheader_writef(psf, "4", 0);
    }
#line 557
    goto switch_break___0;
    switch_break___0: ;
  }
#line 560
  goto switch_break;
  switch_default___0: 
#line 564
  return (18);
  switch_break: ;
#line 573
  if (subformat == 4) {
#line 573
    goto case_4___1;
  }
#line 573
  if (subformat == 3) {
#line 573
    goto case_4___1;
  }
#line 573
  if (subformat == 2) {
#line 573
    goto case_4___1;
  }
#line 573
  if (subformat == 5) {
#line 573
    goto case_4___1;
  }
#line 579
  if (subformat == 7) {
#line 579
    goto case_7___0;
  }
#line 579
  if (subformat == 6) {
#line 579
    goto case_7___0;
  }
#line 584
  if (subformat == 16) {
#line 584
    goto case_16___0;
  }
#line 588
  if (subformat == 17) {
#line 588
    goto case_17___0;
  }
#line 592
  goto switch_default___1;
  case_4___1: 
#line 574
  if (wpriv->wavex_ambisonic == 64) {
#line 574
    tmp = & MSGUID_SUBTYPE_PCM;
  } else {
#line 574
    tmp = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM;
  }
  {
#line 574
  wavex_write_guid(psf, tmp);
  }
#line 576
  goto switch_break___1;
  case_7___0: 
#line 580
  if (wpriv->wavex_ambisonic == 64) {
#line 580
    tmp___0 = & MSGUID_SUBTYPE_IEEE_FLOAT;
  } else {
#line 580
    tmp___0 = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT;
  }
  {
#line 580
  wavex_write_guid(psf, tmp___0);
  }
#line 582
  goto switch_break___1;
  case_16___0: 
  {
#line 585
  wavex_write_guid(psf, & MSGUID_SUBTYPE_MULAW);
  }
#line 586
  goto switch_break___1;
  case_17___0: 
  {
#line 589
  wavex_write_guid(psf, & MSGUID_SUBTYPE_ALAW);
  }
#line 590
  goto switch_break___1;
  switch_default___1: 
#line 592
  return (18);
  switch_break___1: ;
#line 595
  return (0);
}
}
#line 600 "/root/patchweave_donee/23/src/rf64.c"
static int rf64_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int error ;
  int has_data ;
  int add_fact_chunk ;
  WAV_PRIVATE *wpriv ;
  long tmp ;

  {
#line 602
  error = 0;
#line 602
  has_data = 0;
#line 602
  add_fact_chunk = 0;
#line 605
  wpriv = (WAV_PRIVATE *)psf->container_data;
#line 605
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 606
    return (30);
  }
  {
#line 608
  current = psf_ftell(psf);
  }
#line 610
  if (psf->dataoffset > 0L) {
#line 610
    if (current > psf->dataoffset) {
#line 611
      has_data = 1;
    }
  }
#line 613
  if (calc_length) {
    {
#line 614
    psf->filelength = psf_get_filelen(psf);
#line 615
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 617
    if (psf->dataend) {
#line 618
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 620
    if (psf->bytewidth > 0) {
#line 621
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
  {
#line 625
  psf->header[0] = (unsigned char)0;
#line 626
  psf->headindex = 0;
#line 627
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 629
  if (wpriv->rf64_downgrade) {
#line 629
    if (psf->filelength < 4294967295L) {
#line 630
      if (psf->filelength < 8L) {
#line 630
        tmp = 8L;
      } else {
#line 630
        tmp = psf->filelength - 8L;
      }
      {
#line 630
      psf_binheader_writef(psf, "etm8mU", (unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24),
                           tmp, (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24));
#line 631
      psf_binheader_writef(psf, "m4884U", (unsigned int )((74 | (85 << 8)) | (78 << 16)) | (75U << 24),
                           20, 0, 0, 0, 0);
#line 632
      add_fact_chunk = 1;
      }
    } else {
      {
#line 635
      psf_binheader_writef(psf, "em4m\204U", (unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24),
                           4294967295U, (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24));
#line 637
      psf_binheader_writef(psf, "m48884", (unsigned int )((100 | (115 << 8)) | (54 << 16)) | (52U << 24),
                           28, psf->filelength - 8L, psf->datalength, psf->sf.frames,
                           0);
      }
    }
  } else {
    {
#line 635
    psf_binheader_writef(psf, "em4m\204U", (unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24),
                         4294967295U, (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24));
#line 637
    psf_binheader_writef(psf, "m48884", (unsigned int )((100 | (115 << 8)) | (54 << 16)) | (52U << 24),
                         28, psf->filelength - 8L, psf->datalength, psf->sf.frames,
                         0);
    }
  }
  {
#line 641
  psf_binheader_writef(psf, "m\366\264\327\204U", (unsigned int )((102 | (109 << 8)) | (116 << 16)) | (32U << 24));
  }
#line 645
  if ((psf->sf.format & 268369920) == 65536) {
#line 645
    goto case_65536;
  }
#line 651
  if ((psf->sf.format & 268369920) == 2228224) {
#line 651
    goto case_2228224;
  }
#line 651
  if ((psf->sf.format & 268369920) == 1245184) {
#line 651
    goto case_2228224;
  }
#line 658
  goto switch_default;
  case_65536: 
  {
#line 646
  psf_log_printf(psf, "ooops SF_FORMAT_WAV\n");
  }
#line 647
  return (18);
#line 648
  goto switch_break;
  case_2228224: 
  {
#line 652
  error = rf64_write_fmt_chunk(psf);
  }
#line 652
  if (error != 0) {
#line 653
    return (error);
  }
#line 654
  if (add_fact_chunk) {
    {
#line 655
    psf_binheader_writef(psf, "tm48", (unsigned int )((102 | (97 << 8)) | (99 << 16)) | (116U << 24),
                         4, psf->sf.frames);
    }
  }
#line 656
  goto switch_break;
  switch_default: 
#line 659
  return (18);
  switch_break: ;
#line 662
  if ((unsigned long )psf->broadcast_16k != (unsigned long )((void *)0)) {
    {
#line 663
    wav_write_bext_chunk(psf);
    }
  }
#line 665
  if ((unsigned long )psf->cart_16k != (unsigned long )((void *)0)) {
    {
#line 666
    wav_write_cart_chunk(psf);
    }
  }
#line 715
  if (wpriv->rf64_downgrade) {
#line 715
    if (psf->filelength < 4294967295L) {
      {
#line 716
      psf_binheader_writef(psf, "tm8", (unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24),
                           psf->datalength);
      }
    } else {
      {
#line 718
      psf_binheader_writef(psf, "m4", (unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24),
                           4294967295U);
      }
    }
  } else {
    {
#line 718
    psf_binheader_writef(psf, "m4", (unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24),
                         4294967295U);
    }
  }
  {
#line 720
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 721
  if (psf->error) {
#line 722
    return (psf->error);
  }
#line 724
  if (has_data) {
#line 724
    if (psf->dataoffset != (long )psf->headindex) {
      {
#line 725
      printf("Oooops : has_data && psf->dataoffset != psf->headindex\n");
#line 726
      psf->error = 30;
      }
#line 726
      return (psf->error);
    }
  }
#line 729
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 731
  if (! has_data) {
    {
#line 732
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 733
  if (current > 0L) {
    {
#line 734
    psf_fseek(psf, current, 0);
    }
  }
#line 736
  return (psf->error);
}
}
#line 740 "/root/patchweave_donee/23/src/rf64.c"
static int rf64_close(SF_PRIVATE *psf ) 
{ 


  {
#line 742
  if (psf->file.mode == 32) {
    {
#line 745
    (*(psf->write_header))(psf, 1);
    }
  } else
#line 742
  if (psf->file.mode == 48) {
    {
#line 745
    (*(psf->write_header))(psf, 1);
    }
  }
#line 748
  return (0);
}
}
#line 752 "/root/patchweave_donee/23/src/rf64.c"
static int rf64_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int datasize ) 
{ 
  WAV_PRIVATE *wpriv ;
  int __cil_tmp6 ;
  int tmp ;

  {
#line 755
  wpriv = (WAV_PRIVATE *)psf->container_data;
#line 755
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 756
    return (30);
  }
#line 759
  if (command == 4608) {
#line 759
    goto case_4608;
  }
#line 770
  if (command == 4609) {
#line 770
    goto case_4609;
  }
#line 773
  if (command == 4353) {
#line 773
    goto case_4353;
  }
#line 777
  if (command == 4624) {
#line 777
    goto case_4624;
  }
#line 782
  goto switch_default;
  case_4608: 
#line 760
  if ((psf->sf.format & 268369920) == 1245184) {
#line 761
    if (datasize == 64) {
#line 762
      wpriv->wavex_ambisonic = 64;
    } else
#line 763
    if (datasize == 65) {
#line 764
      wpriv->wavex_ambisonic = 65;
    } else {
#line 766
      return (0);
    }
  }
#line 768
  return (wpriv->wavex_ambisonic);
  case_4609: 
#line 771
  return (wpriv->wavex_ambisonic);
  case_4353: 
  {
#line 774
  __cil_tmp6 = wavex_gen_channel_mask((int const   *)psf->channel_map, psf->sf.channels);
#line 774
  wpriv->wavex_channelmask = (unsigned int )__cil_tmp6;
  }
#line 775
  return (wpriv->wavex_channelmask != 0U);
  case_4624: 
#line 778
  if (psf->have_written == 0) {
#line 779
    if (datasize) {
#line 779
      tmp = 1;
    } else {
#line 779
      tmp = 0;
    }
#line 779
    wpriv->rf64_downgrade = tmp;
  }
#line 780
  return (wpriv->rf64_downgrade);
  switch_default: 
#line 783
  goto switch_break;
  switch_break: ;
#line 786
  return (0);
}
}
#line 55 "/root/patchweave_donee/23/src/mpc2k.c"
static int mpc2k_close(SF_PRIVATE *psf ) ;
#line 57
static int mpc2k_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 58
static int mpc2k_read_header(SF_PRIVATE *psf ) ;
#line 65 "/root/patchweave_donee/23/src/mpc2k.c"
int mpc2k_open(SF_PRIVATE *psf ) 
{ 
  int error ;
  int __cil_tmp4 ;

  {
#line 66
  error = 0;
#line 68
  if (psf->file.mode == 16) {
    _L: 
    {
#line 69
    error = mpc2k_read_header(psf);
    }
#line 69
    if (error) {
#line 70
      return (error);
    }
  } else
#line 68
  if (psf->file.mode == 48) {
#line 68
    if (psf->filelength > 0L) {
#line 68
      goto _L;
    }
  }
#line 73
  if ((psf->sf.format & 268369920) != 2162688) {
#line 74
    return (1);
  }
#line 76
  if (psf->file.mode == 32) {
    _L___10: 
    {
#line 77
    __cil_tmp4 = mpc2k_write_header(psf, 0);
    }
#line 77
    if (__cil_tmp4) {
#line 78
      return (psf->error);
    }
#line 80
    psf->write_header = & mpc2k_write_header;
  } else
#line 76
  if (psf->file.mode == 48) {
#line 76
    goto _L___10;
  }
  {
#line 83
  psf->container_close = & mpc2k_close;
#line 85
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 87
  error = pcm_init(psf);
  }
#line 89
  return (error);
}
}
#line 96 "/root/patchweave_donee/23/src/mpc2k.c"
static int mpc2k_close(SF_PRIVATE *psf ) 
{ 


  {
#line 98
  if (psf->file.mode == 32) {
    {
#line 99
    mpc2k_write_header(psf, 1);
    }
  } else
#line 98
  if (psf->file.mode == 48) {
    {
#line 99
    mpc2k_write_header(psf, 1);
    }
  }
#line 101
  return (0);
}
}
#line 105 "/root/patchweave_donee/23/src/mpc2k.c"
static int mpc2k_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  char sample_name[18] ;
  sf_count_t current ;
  size_t __cil_tmp7 ;

  {
#line 109
  if (psf->pipeoffset > 0L) {
#line 110
    return (0);
  }
  {
#line 112
  current = psf_ftell(psf);
  }
#line 114
  if (calc_length) {
    {
#line 115
    psf->filelength = psf_get_filelen(psf);
#line 117
    psf->dataoffset = (sf_count_t )42;
#line 118
    psf->datalength = psf->filelength - psf->dataoffset;
#line 120
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
#line 124
  psf->header[0] = (unsigned char)0;
#line 125
  psf->headindex = 0;
#line 131
  if (psf->is_pipe == 0) {
    {
#line 132
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 134
  snprintf(sample_name, sizeof(sample_name), "%s                    ", psf->file.name.c);
#line 136
  __cil_tmp7 = make_size_t(17);
#line 136
  psf_binheader_writef(psf, "e11b\204U", 1, 4, sample_name, __cil_tmp7);
#line 137
  psf_binheader_writef(psf, "e111\204U", 100, 0, (psf->sf.channels - 1) & 1);
#line 138
  psf_binheader_writef(psf, "et4888", 0, psf->sf.frames, psf->sf.frames, psf->sf.frames);
#line 139
  psf_binheader_writef(psf, "e112\204U", 0, 1, (int )((uint16_t )psf->sf.samplerate));
#line 142
  psf->bytewidth = 2;
#line 143
  psf->endian = 268435456;
#line 145
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 147
  if (psf->error) {
#line 148
    return (psf->error);
  }
#line 150
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 152
  if (current > 0L) {
    {
#line 153
    psf_fseek(psf, current, 0);
    }
  }
#line 155
  return (psf->error);
}
}
#line 159 "/root/patchweave_donee/23/src/mpc2k.c"
static int mpc2k_read_header(SF_PRIVATE *psf ) 
{ 
  char sample_name[18] ;
  unsigned char bytes[4] ;
  uint32_t sample_start ;
  uint32_t loop_end ;
  uint32_t sample_frames ;
  uint32_t loop_length ;
  uint16_t sample_rate ;
  size_t __cil_tmp9 ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 165
  __cil_tmp9 = make_size_t(17);
#line 165
  psf_binheader_readf(psf, "pebb", 0, bytes, 2, sample_name, __cil_tmp9);
  }
#line 167
  if ((int )bytes[0] != 1) {
#line 168
    return (666);
  } else
#line 167
  if ((int )bytes[1] != 4) {
#line 168
    return (666);
  }
  {
#line 170
  sample_name[17] = (char)0;
#line 172
  psf_log_printf(psf, "MPC2000\n  Name         : %s\n", sample_name);
#line 174
  psf_binheader_readf(psf, "eb4444", bytes, 3, & sample_start, & loop_end, & sample_frames,
                      & loop_length);
  }
#line 176
  if ((int )bytes[2]) {
#line 176
    tmp = 2;
  } else {
#line 176
    tmp = 1;
  }
#line 176
  psf->sf.channels = tmp;
#line 178
  if ((int )bytes[2]) {
#line 178
    tmp___0 = "Yes\327\204U";
  } else {
#line 178
    tmp___0 = "No\323\327\204U";
  }
  {
#line 178
  psf_log_printf(psf, "  Level        : %d\n  Tune         : %d\n  Stereo       : %s\n",
                 (int )bytes[0], (int )bytes[1], tmp___0);
#line 180
  psf_log_printf(psf, "  Sample start : %d\n  Loop end     : %d\n  Frames       : %d\n  Length       : %d\n\230\001",
                 sample_start, loop_end, sample_frames, loop_length);
#line 182
  psf_binheader_readf(psf, "eb2", bytes, 2, & sample_rate);
  }
#line 184
  if ((int )bytes[0]) {
#line 184
    tmp___1 = "None";
  } else {
#line 184
    tmp___1 = "Fwd";
  }
  {
#line 184
  psf_log_printf(psf, "  Loop mode    : %s\n  Beats        : %d\n  Sample rate  : %d\nEnd\n\230\001",
                 tmp___1, (int )bytes[1], (int )sample_rate);
#line 186
  psf->sf.samplerate = (int )sample_rate;
#line 188
  psf->sf.format = 2162690;
#line 190
  psf->dataoffset = psf_ftell(psf);
#line 193
  psf->bytewidth = 2;
#line 194
  psf->endian = 268435456;
#line 196
  psf->datalength = psf->filelength - psf->dataoffset;
#line 197
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 198
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 200
  psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
  }
#line 202
  return (0);
}
}
#line 51 "/root/patchweave_donee/23/src/xi.c"
static int xi_close(SF_PRIVATE *UNUSED_psf ) ;
#line 52
static int xi_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 53
static int xi_read_header(SF_PRIVATE *psf ) ;
#line 54
static int dpcm_init(SF_PRIVATE *psf ) ;
#line 57
static sf_count_t dpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 64 "/root/patchweave_donee/23/src/xi.c"
int xi_open(SF_PRIVATE *psf ) 
{ 
  XI_PRIVATE *pxi ;
  int subformat ;
  int error ;
  int tmp ;
  int __cil_tmp8 ;
  void *tmp___0 ;

  {
#line 66
  error = 0;
#line 68
  if (psf->is_pipe) {
#line 69
    return (142);
  }
#line 71
  if (psf->codec_data) {
#line 72
    pxi = (XI_PRIVATE *)psf->codec_data;
  } else {
    {
#line 73
    tmp___0 = calloc(1UL, sizeof(XI_PRIVATE ));
#line 73
    pxi = (XI_PRIVATE *)tmp___0;
    }
#line 73
    if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 74
      return (17);
    }
  }
#line 76
  psf->codec_data = (void *)pxi;
#line 78
  if (psf->file.mode == 16) {
    _L: 
    {
#line 79
    error = xi_read_header(psf);
    }
#line 79
    if (error) {
#line 80
      return (error);
    }
  } else
#line 78
  if (psf->file.mode == 48) {
#line 78
    if (psf->filelength > 0L) {
#line 78
      goto _L;
    }
  }
#line 83
  subformat = psf->sf.format & 65535;
#line 85
  if (psf->file.mode == 32) {
    _L___11: 
#line 86
    if ((psf->sf.format & 268369920) != 983040) {
#line 87
      return (1);
    }
    {
#line 89
    psf->endian = 268435456;
#line 90
    psf->sf.channels = 1;
#line 91
    psf->sf.samplerate = 44100;
#line 94
    memcpy((void *)(pxi->filename), (void const   *)"Default Name            \230\001\200",
           sizeof(pxi->filename));
#line 95
    memcpy((void *)(pxi->software), (void const   *)"libsndfile-1.0.26               ",
           sizeof(pxi->software));
#line 97
    memset((void *)(pxi->sample_name), 0, sizeof(pxi->sample_name));
#line 98
    snprintf(pxi->sample_name, sizeof(pxi->sample_name), "%s", "Sample #1");
    }
#line 100
    if (subformat == 81) {
#line 100
      tmp = 16;
    } else {
#line 100
      tmp = 0;
    }
    {
#line 100
    pxi->sample_flags = tmp;
#line 102
    __cil_tmp8 = xi_write_header(psf, 0);
    }
#line 102
    if (__cil_tmp8) {
#line 103
      return (psf->error);
    }
#line 105
    psf->write_header = & xi_write_header;
  } else
#line 85
  if (psf->file.mode == 48) {
#line 85
    goto _L___11;
  }
#line 108
  psf->container_close = & xi_close;
#line 109
  psf->seek = & dpcm_seek;
#line 111
  psf->sf.seekable = 0;
#line 113
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 117
  if (subformat == 81) {
#line 117
    goto case_81;
  }
#line 117
  if (subformat == 80) {
#line 117
    goto case_81;
  }
#line 121
  goto switch_default;
  case_81: 
  {
#line 118
  error = dpcm_init(psf);
  }
#line 119
  goto switch_break;
  switch_default: 
#line 121
  goto switch_break;
  switch_break: ;
#line 124
  return (error);
}
}
#line 131 "/root/patchweave_donee/23/src/xi.c"
static int xi_close(SF_PRIVATE *UNUSED_psf ) 
{ 


  {
#line 133
  return (0);
}
}
#line 139
static sf_count_t dpcm_read_dsc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 140
static sf_count_t dpcm_read_dsc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 141
static sf_count_t dpcm_read_dsc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 142
static sf_count_t dpcm_read_dsc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 144
static sf_count_t dpcm_write_s2dsc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 145
static sf_count_t dpcm_write_i2dsc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 146
static sf_count_t dpcm_write_f2dsc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 147
static sf_count_t dpcm_write_d2dsc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 149
static sf_count_t dpcm_read_dles2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 150
static sf_count_t dpcm_read_dles2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 151
static sf_count_t dpcm_read_dles2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 152
static sf_count_t dpcm_read_dles2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 154
static sf_count_t dpcm_write_s2dles(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 155
static sf_count_t dpcm_write_i2dles(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 156
static sf_count_t dpcm_write_f2dles(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 157
static sf_count_t dpcm_write_d2dles(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 160 "/root/patchweave_donee/23/src/xi.c"
static int dpcm_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;

  {
#line 161
  if (psf->bytewidth == 0) {
#line 162
    return (30);
  } else
#line 161
  if (psf->sf.channels == 0) {
#line 162
    return (30);
  }
#line 164
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 166
  if (psf->file.mode == 16) {
    _L: 
#line 168
    if (psf->bytewidth == 1) {
#line 168
      goto case_1;
    }
#line 174
    if (psf->bytewidth == 2) {
#line 174
      goto case_2;
    }
#line 180
    goto switch_default;
    case_1: 
#line 169
    psf->read_short = & dpcm_read_dsc2s;
#line 170
    psf->read_int = & dpcm_read_dsc2i;
#line 171
    psf->read_float = & dpcm_read_dsc2f;
#line 172
    psf->read_double = & dpcm_read_dsc2d;
#line 173
    goto switch_break;
    case_2: 
#line 175
    psf->read_short = & dpcm_read_dles2s;
#line 176
    psf->read_int = & dpcm_read_dles2i;
#line 177
    psf->read_float = & dpcm_read_dles2f;
#line 178
    psf->read_double = & dpcm_read_dles2d;
#line 179
    goto switch_break;
    switch_default: 
    {
#line 181
    psf_log_printf(psf, "dpcm_init() returning SFE_UNIMPLEMENTED\n");
    }
#line 182
    return (18);
    switch_break: ;
  } else
#line 166
  if (psf->file.mode == 48) {
#line 166
    goto _L;
  }
#line 186
  if (psf->file.mode == 32) {
    _L___12: 
#line 188
    if (psf->bytewidth == 1) {
#line 188
      goto case_1___0;
    }
#line 194
    if (psf->bytewidth == 2) {
#line 194
      goto case_2___0;
    }
#line 200
    goto switch_default___0;
    case_1___0: 
#line 189
    psf->write_short = & dpcm_write_s2dsc;
#line 190
    psf->write_int = & dpcm_write_i2dsc;
#line 191
    psf->write_float = & dpcm_write_f2dsc;
#line 192
    psf->write_double = & dpcm_write_d2dsc;
#line 193
    goto switch_break___0;
    case_2___0: 
#line 195
    psf->write_short = & dpcm_write_s2dles;
#line 196
    psf->write_int = & dpcm_write_i2dles;
#line 197
    psf->write_float = & dpcm_write_f2dles;
#line 198
    psf->write_double = & dpcm_write_d2dles;
#line 199
    goto switch_break___0;
    switch_default___0: 
    {
#line 201
    psf_log_printf(psf, "dpcm_init() returning SFE_UNIMPLEMENTED\n\220");
    }
#line 202
    return (18);
    switch_break___0: ;
  } else
#line 186
  if (psf->file.mode == 48) {
#line 186
    goto _L___12;
  }
  {
#line 206
  psf->filelength = psf_get_filelen(psf);
  }
#line 207
  if (psf->dataend) {
#line 207
    tmp = psf->dataend - psf->dataoffset;
  } else {
#line 207
    tmp = psf->filelength - psf->dataoffset;
  }
#line 207
  psf->datalength = tmp;
#line 209
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 211
  return (0);
}
}
#line 218 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int total ;
  int bufferlen ;
  int len ;
  int tmp ;
  sf_count_t __cil_tmp10 ;
  int tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 223
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 223
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 224
    return ((sf_count_t )30);
  }
#line 226
  if (psf->datalength < 0L) {
#line 227
    psf->error = 39;
#line 228
    return ((sf_count_t )-1);
  } else
#line 226
  if (psf->dataoffset < 0L) {
#line 227
    psf->error = 39;
#line 228
    return ((sf_count_t )-1);
  }
#line 231
  if (offset == 0L) {
    {
#line 232
    psf_fseek(psf, psf->dataoffset, 0);
#line 233
    pxi->last_16 = (short)0;
    }
#line 234
    return ((sf_count_t )0);
  }
#line 237
  if (offset < 0L) {
#line 238
    psf->error = 39;
#line 239
    return ((sf_count_t )-1);
  } else
#line 237
  if (offset > psf->sf.frames) {
#line 238
    psf->error = 39;
#line 239
    return ((sf_count_t )-1);
  }
#line 242
  if (mode != 16) {
#line 244
    psf->error = 39;
#line 245
    return ((sf_count_t )-1);
  }
  {
#line 248
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 250
  if ((psf->sf.format & 65535) == 81) {
#line 251
    total = (int )offset;
#line 252
    bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;

#line 253
      if (! (total > 0)) {
#line 253
        goto while_break;
      }
#line 254
      if (total > bufferlen) {
#line 254
        tmp = bufferlen;
      } else {
#line 254
        tmp = total;
      }
      {
#line 254
      len = tmp;
#line 255
      __cil_tmp10 = dpcm_read_dles2s(psf, ubuf.sbuf, (sf_count_t )len);
#line 255
      total = (int )((sf_count_t )total - __cil_tmp10);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 259
    total = (int )offset;
#line 260
    bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 261
      if (! (total > 0)) {
#line 261
        goto while_break___0;
      }
#line 262
      if (total > bufferlen) {
#line 262
        tmp___0 = bufferlen;
      } else {
#line 262
        tmp___0 = total;
      }
      {
#line 262
      len = tmp___0;
#line 263
      __cil_tmp12 = dpcm_read_dsc2s(psf, ubuf.sbuf, (sf_count_t )len);
#line 263
      total = (int )((sf_count_t )total - __cil_tmp12);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 267
  return (offset);
}
}
#line 272 "/root/patchweave_donee/23/src/xi.c"
static int xi_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  XI_PRIVATE *pxi ;
  sf_count_t current ;
  char const   *string ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;

  {
#line 277
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 277
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 278
    return (30);
  }
  {
#line 280
  current = psf_ftell(psf);
#line 283
  psf->header[0] = (unsigned char)0;
#line 284
  psf->headindex = 0;
#line 285
  psf_fseek(psf, (sf_count_t )0, 0);
#line 287
  string = "Extended Instrument: ";
#line 288
  __cil_tmp7 = strlen(string);
#line 288
  psf_binheader_writef(psf, "b", string, __cil_tmp7);
#line 289
  psf_binheader_writef(psf, "b1", pxi->filename, sizeof(pxi->filename), 26);
#line 292
  psf_binheader_writef(psf, "eb2", pxi->software, sizeof(pxi->software), (1 << 8) + 2);
#line 298
  psf_binheader_writef(psf, "z", (size_t )194);
#line 303
  __cil_tmp8 = make_size_t(22);
#line 303
  psf_binheader_writef(psf, "ez2z2", (size_t )12, 4660, __cil_tmp8, 1);
#line 305
  pxi->loop_begin = 0;
#line 306
  pxi->loop_end = 0;
#line 308
  psf_binheader_writef(psf, "et844U", psf->sf.frames, pxi->loop_begin, pxi->loop_end);
#line 311
  __cil_tmp9 = strlen((char const   *)(pxi->sample_name));
#line 311
  psf_binheader_writef(psf, "111111", 128, 0, pxi->sample_flags, 128, 0, __cil_tmp9);
#line 313
  psf_binheader_writef(psf, "b", pxi->sample_name, sizeof(pxi->sample_name));
#line 320
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 322
  if (psf->error) {
#line 323
    return (psf->error);
  }
#line 325
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 327
  if (current > 0L) {
    {
#line 328
    psf_fseek(psf, current, 0);
    }
  }
#line 330
  return (psf->error);
}
}
#line 334 "/root/patchweave_donee/23/src/xi.c"
static int xi_read_header(SF_PRIVATE *psf ) 
{ 
  char buffer[64] ;
  char name[32] ;
  short version ;
  short fade_out ;
  short sample_count ;
  int k ;
  int loop_begin ;
  int loop_end ;
  int sample_sizes[16] ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char const   *tmp ;
  int tmp___0 ;
  short __cil_tmp18 ;
  sf_count_t __cil_tmp20 ;

  {
  {
#line 340
  psf_binheader_readf(psf, "pb\002\330\204U", 0, buffer, 21);
#line 342
  memset((void *)(sample_sizes), 0, sizeof(sample_sizes));
#line 344
  buffer[20] = (char)0;
#line 345
  __cil_tmp11 = strcmp((char const   *)(buffer), "Extended Instrument:\204U");
  }
#line 345
  if (__cil_tmp11 != 0) {
#line 346
    return (140);
  }
  {
#line 348
  memset((void *)(buffer), 0, sizeof(buffer));
#line 349
  psf_binheader_readf(psf, "b", buffer, 23);
  }
#line 351
  if ((int )buffer[22] != 26) {
#line 352
    return (140);
  }
#line 354
  buffer[22] = (char)0;
#line 355
  k = 21;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;

#line 355
    if (k >= 0) {
#line 355
      if (! ((int )buffer[k] == 32)) {
#line 355
        goto while_break;
      }
    } else {
#line 355
      goto while_break;
    }
#line 356
    buffer[k] = (char)0;
#line 355
    __cil_tmp12 = k;
#line 355
    k --;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 358
  psf_log_printf(psf, "Extended Instrument : %s\n\023\002\330\204U", buffer);
#line 359
  psf_store_string(psf, 1, (char const   *)(buffer));
#line 361
  psf_binheader_readf(psf, "be2", buffer, 20, & version);
#line 362
  buffer[19] = (char)0;
#line 363
  k = 18;
  }
  {
#line 363
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 363
    if (k >= 0) {
#line 363
      if (! ((int )buffer[k] == 32)) {
#line 363
        goto while_break___0;
      }
    } else {
#line 363
      goto while_break___0;
    }
#line 364
    buffer[k] = (char)0;
#line 363
    __cil_tmp13 = k;
#line 363
    k --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 366
  psf_log_printf(psf, "Software : %s\nVersion  : %d.%02d\n\377\377\377", buffer, (int )version / 256,
                 (int )version % 256);
#line 367
  psf_store_string(psf, 3, (char const   *)(buffer));
#line 372
  psf_binheader_readf(psf, "j", 194);
#line 374
  psf_binheader_readf(psf, "b", buffer, 12);
#line 375
  psf_log_printf(psf, "Volume Loop\n  sustain : %u\n  begin   : %u\n  end     : %u\n",
                 (int )buffer[0], (int )buffer[1], (int )buffer[2]);
#line 377
  psf_log_printf(psf, "Pan Loop\n  sustain : %u\n  begin   : %u\n  end     : %u\n",
                 (int )buffer[3], (int )buffer[4], (int )buffer[5]);
#line 379
  psf_log_printf(psf, "Envelope Flags\n  volume  : 0x%X\n  pan     : 0x%X\n", (int )buffer[6] & 255,
                 (int )buffer[7] & 255);
#line 382
  psf_log_printf(psf, "Vibrato\n  type    : %u\n  sweep   : %u\n  depth   : %u\n  rate    : %u\n\204U",
                 (int )buffer[8], (int )buffer[9], (int )buffer[10], (int )buffer[11]);
#line 389
  psf_binheader_readf(psf, "e2j2\204U", & fade_out, 22, & sample_count);
#line 390
  psf_log_printf(psf, "Fade out  : %d\n", (int )fade_out);
  }
#line 393
  if ((int )sample_count > 16) {
#line 394
    return (141);
  }
  {
#line 396
  psf->instrument = psf_instrument_alloc();
  }
#line 396
  if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 396
    if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 397
      return (17);
    }
  }
#line 399
  (psf->instrument)->basenote = (char)0;
#line 401
  k = 0;
  {
#line 401
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___1: ;
#line 401
    if (! (k < (int )sample_count)) {
#line 401
      goto while_break___1;
    }
    {
#line 402
    psf_binheader_readf(psf, "e444", & sample_sizes[k], & loop_begin, & loop_end);
#line 405
    psf_binheader_readf(psf, "bb", buffer, 6, name, 22);
#line 406
    name[21] = (char)0;
#line 408
    psf_log_printf(psf, "Sample #%d\n  name    : %s\n", k + 1, name);
#line 410
    psf_log_printf(psf, "  size    : %d\n", sample_sizes[k]);
#line 414
    psf_log_printf(psf, "  loop\n    begin : %d\n    end   : %d\n", loop_begin, loop_end);
#line 416
    psf_log_printf(psf, "  volume  : %u\n  f. tune : %d\n  flags   : 0x%02X \364\001\330\204U",
                   (int )buffer[0] & 255, (int )buffer[1] & 255, (int )buffer[2] & 255);
#line 419
    psf_log_printf(psf, " (\001\330\204U");
    }
#line 420
    if ((int )buffer[2] & 1) {
      {
#line 421
      psf_log_printf(psf, " Loop");
      }
    }
#line 422
    if ((int )buffer[2] & 2) {
      {
#line 423
      psf_log_printf(psf, " PingPong");
      }
    }
#line 424
    if ((int )buffer[2] & 16) {
#line 424
      tmp = " 16bit";
    } else {
#line 424
      tmp = " 8bit";
    }
    {
#line 424
    psf_log_printf(psf, tmp);
#line 425
    psf_log_printf(psf, " )\n");
#line 427
    psf_log_printf(psf, "  pan     : %u\n  note    : %d\n  namelen : %d\n", (int )buffer[3] & 255,
                   (int )buffer[4], (int )buffer[5]);
#line 430
    (psf->instrument)->basenote = buffer[4];
    }
#line 431
    if ((int )buffer[2] & 1) {
#line 432
      (psf->instrument)->loop_count = 1;
#line 433
      if ((int )buffer[2] & 2) {
#line 433
        tmp___0 = 803;
      } else {
#line 433
        tmp___0 = 801;
      }
#line 433
      (psf->instrument)->loops[0].mode = tmp___0;
#line 434
      (psf->instrument)->loops[0].start = (uint32_t )loop_begin;
#line 435
      (psf->instrument)->loops[0].end = (uint32_t )loop_end;
    }
#line 438
    if (k != 0) {
#line 439
      goto while_continue___1;
    }
#line 441
    if ((int )buffer[2] & 16) {
#line 442
      psf->sf.format = 983121;
#line 443
      psf->bytewidth = 2;
    } else {
#line 446
      psf->sf.format = 983120;
#line 447
      psf->bytewidth = 1;
    }
#line 401
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
  {
#line 451
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 451
    if ((int )sample_count > 1) {
#line 451
      if (! (sample_sizes[(int )sample_count - 1] == 0)) {
#line 451
        goto while_break___2;
      }
    } else {
#line 451
      goto while_break___2;
    }
#line 452
    __cil_tmp18 = sample_count;
#line 452
    sample_count = (short )((int )sample_count - 1);
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 456
  if ((int )sample_count > 2) {
    {
#line 457
    psf_log_printf(psf, "*** Sample count is less than 16 but more than 1.\n");
#line 458
    psf_log_printf(psf, "  sample count : %d    sample_sizes [%d] : %d\n", (int )sample_count,
                   (int )sample_count - 1, sample_sizes[(int )sample_count - 1]);
    }
#line 460
    return (141);
  }
  {
#line 463
  psf->datalength = (sf_count_t )sample_sizes[0];
#line 465
  psf->dataoffset = psf_ftell(psf);
  }
#line 466
  if (psf->dataoffset < 0L) {
    {
#line 467
    psf_log_printf(psf, "*** Bad Data Offset : %D\n", psf->dataoffset);
    }
#line 468
    return (26);
  }
  {
#line 470
  psf_log_printf(psf, "Data Offset : %D\n", psf->dataoffset);
  }
#line 472
  if (psf->dataoffset + psf->datalength > psf->filelength) {
    {
#line 473
    psf_log_printf(psf, "*** File seems to be truncated. Should be at least %D bytes long.\n",
                   psf->dataoffset + (long )sample_sizes[0]);
#line 475
    psf->datalength = psf->filelength - psf->dataoffset;
    }
  }
  {
#line 478
  __cil_tmp20 = psf_fseek(psf, psf->dataoffset, 0);
  }
#line 478
  if (__cil_tmp20 != psf->dataoffset) {
#line 479
    return (39);
  }
#line 481
  psf->endian = 268435456;
#line 482
  psf->sf.channels = 1;
#line 483
  psf->sf.samplerate = 44100;
#line 485
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 487
  if (! psf->sf.frames) {
#line 487
    if (psf->blockwidth) {
#line 488
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 490
  (psf->instrument)->gain = 1;
#line 491
  (psf->instrument)->key_lo = (char)0;
#line 491
  (psf->instrument)->velocity_lo = (psf->instrument)->key_lo;
#line 492
  (psf->instrument)->key_hi = (char)127;
#line 492
  (psf->instrument)->velocity_hi = (psf->instrument)->key_hi;
#line 494
  return (0);
}
}
#line 500
static void dsc2s_array(XI_PRIVATE *pxi , signed char *src , int count___0 , short *dest ) ;
#line 501
static void dsc2i_array(XI_PRIVATE *pxi , signed char *src , int count___0 , int *dest ) ;
#line 502
static void dsc2f_array(XI_PRIVATE *pxi , signed char *src , int count___0 , float *dest ,
                        float normfact ) ;
#line 503
static void dsc2d_array(XI_PRIVATE *pxi , signed char *src , int count___0 , double *dest ,
                        double normfact ) ;
#line 505
static void dles2s_array(XI_PRIVATE *pxi , short *src , int count___0 , short *dest ) ;
#line 506
static void dles2i_array(XI_PRIVATE *pxi , short *src , int count___0 , int *dest ) ;
#line 507
static void dles2f_array(XI_PRIVATE *pxi , short *src , int count___0 , float *dest ,
                         float normfact ) ;
#line 508
static void dles2d_array(XI_PRIVATE *pxi , short *src , int count___0 , double *dest ,
                         double normfact ) ;
#line 511 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_read_dsc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 515
  total = (sf_count_t )0;
#line 517
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 517
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 518
    return ((sf_count_t )0);
  }
#line 520
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;

#line 522
    if (! (len > 0L)) {
#line 522
      goto while_break;
    }
#line 523
    if (len < (long )bufferlen) {
#line 524
      bufferlen = (int )len;
    }
    {
#line 525
    __cil_tmp9 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 525
    readcount = (int )__cil_tmp9;
#line 526
    dsc2s_array(pxi, ubuf.scbuf, readcount, ptr + total);
#line 527
    total += (long )readcount;
    }
#line 528
    if (readcount < bufferlen) {
#line 529
      goto while_break;
    }
#line 530
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 533
  return (total);
}
}
#line 537 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_read_dsc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 541
  total = (sf_count_t )0;
#line 543
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 543
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 544
    return ((sf_count_t )0);
  }
#line 546
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;

#line 548
    if (! (len > 0L)) {
#line 548
      goto while_break;
    }
#line 549
    if (len < (long )bufferlen) {
#line 550
      bufferlen = (int )len;
    }
    {
#line 551
    __cil_tmp9 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 551
    readcount = (int )__cil_tmp9;
#line 552
    dsc2i_array(pxi, ubuf.scbuf, readcount, ptr + total);
#line 553
    total += (long )readcount;
    }
#line 554
    if (readcount < bufferlen) {
#line 555
      goto while_break;
    }
#line 556
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 559
  return (total);
}
}
#line 563 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_read_dsc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 567
  total = (sf_count_t )0;
#line 570
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 570
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 571
    return ((sf_count_t )0);
  }
#line 573
  if (psf->norm_float == 1) {
#line 573
    tmp = 1. / (double )((float )128);
  } else {
#line 573
    tmp = 1.;
  }
#line 573
  normfact = (float )tmp;
#line 575
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;

#line 577
    if (! (len > 0L)) {
#line 577
      goto while_break;
    }
#line 578
    if (len < (long )bufferlen) {
#line 579
      bufferlen = (int )len;
    }
    {
#line 580
    __cil_tmp11 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 580
    readcount = (int )__cil_tmp11;
#line 581
    dsc2f_array(pxi, ubuf.scbuf, readcount, ptr + total, normfact);
#line 582
    total += (long )readcount;
    }
#line 583
    if (readcount < bufferlen) {
#line 584
      goto while_break;
    }
#line 585
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 588
  return (total);
}
}
#line 592 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_read_dsc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 596
  total = (sf_count_t )0;
#line 599
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 599
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 600
    return ((sf_count_t )0);
  }
#line 602
  if (psf->norm_double == 1) {
#line 602
    tmp = 1. / (double )128;
  } else {
#line 602
    tmp = 1.;
  }
#line 602
  normfact = tmp;
#line 604
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;

#line 606
    if (! (len > 0L)) {
#line 606
      goto while_break;
    }
#line 607
    if (len < (long )bufferlen) {
#line 608
      bufferlen = (int )len;
    }
    {
#line 609
    __cil_tmp11 = psf_fread((void *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 609
    readcount = (int )__cil_tmp11;
#line 610
    dsc2d_array(pxi, ubuf.scbuf, readcount, ptr + total, normfact);
#line 611
    total += (long )readcount;
    }
#line 612
    if (readcount < bufferlen) {
#line 613
      goto while_break;
    }
#line 614
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 617
  return (total);
}
}
#line 624 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_read_dles2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 628
  total = (sf_count_t )0;
#line 630
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 630
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 631
    return ((sf_count_t )0);
  }
#line 633
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;

#line 635
    if (! (len > 0L)) {
#line 635
      goto while_break;
    }
#line 636
    if (len < (long )bufferlen) {
#line 637
      bufferlen = (int )len;
    }
    {
#line 638
    __cil_tmp9 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 638
    readcount = (int )__cil_tmp9;
#line 639
    dles2s_array(pxi, ubuf.sbuf, readcount, ptr + total);
#line 640
    total += (long )readcount;
    }
#line 641
    if (readcount < bufferlen) {
#line 642
      goto while_break;
    }
#line 643
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 646
  return (total);
}
}
#line 650 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_read_dles2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 654
  total = (sf_count_t )0;
#line 656
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 656
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 657
    return ((sf_count_t )0);
  }
#line 659
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;

#line 661
    if (! (len > 0L)) {
#line 661
      goto while_break;
    }
#line 662
    if (len < (long )bufferlen) {
#line 663
      bufferlen = (int )len;
    }
    {
#line 664
    __cil_tmp9 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 664
    readcount = (int )__cil_tmp9;
#line 665
    dles2i_array(pxi, ubuf.sbuf, readcount, ptr + total);
#line 666
    total += (long )readcount;
    }
#line 667
    if (readcount < bufferlen) {
#line 668
      goto while_break;
    }
#line 669
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 672
  return (total);
}
}
#line 676 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_read_dles2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 680
  total = (sf_count_t )0;
#line 683
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 683
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 684
    return ((sf_count_t )0);
  }
#line 686
  if (psf->norm_float == 1) {
#line 686
    tmp = 1. / (double )((float )32768);
  } else {
#line 686
    tmp = 1.;
  }
#line 686
  normfact = (float )tmp;
#line 688
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;

#line 690
    if (! (len > 0L)) {
#line 690
      goto while_break;
    }
#line 691
    if (len < (long )bufferlen) {
#line 692
      bufferlen = (int )len;
    }
    {
#line 693
    __cil_tmp11 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 693
    readcount = (int )__cil_tmp11;
#line 694
    dles2f_array(pxi, ubuf.sbuf, readcount, ptr + total, normfact);
#line 695
    total += (long )readcount;
    }
#line 696
    if (readcount < bufferlen) {
#line 697
      goto while_break;
    }
#line 698
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 701
  return (total);
}
}
#line 705 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_read_dles2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 709
  total = (sf_count_t )0;
#line 712
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 712
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 713
    return ((sf_count_t )0);
  }
#line 715
  if (psf->norm_double == 1) {
#line 715
    tmp = 1. / (double )32768;
  } else {
#line 715
    tmp = 1.;
  }
#line 715
  normfact = tmp;
#line 717
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;

#line 719
    if (! (len > 0L)) {
#line 719
      goto while_break;
    }
#line 720
    if (len < (long )bufferlen) {
#line 721
      bufferlen = (int )len;
    }
    {
#line 722
    __cil_tmp11 = psf_fread((void *)(ubuf.sbuf), (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 722
    readcount = (int )__cil_tmp11;
#line 723
    dles2d_array(pxi, ubuf.sbuf, readcount, ptr + total, normfact);
#line 724
    total += (long )readcount;
    }
#line 725
    if (readcount < bufferlen) {
#line 726
      goto while_break;
    }
#line 727
    len -= (long )readcount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 730
  return (total);
}
}
#line 736
static void s2dsc_array(XI_PRIVATE *pxi , short const   *src , signed char *dest ,
                        int count___0 ) ;
#line 737
static void i2dsc_array(XI_PRIVATE *pxi , int const   *src , signed char *dest , int count___0 ) ;
#line 738
static void f2dsc_array(XI_PRIVATE *pxi , float const   *src , signed char *dest ,
                        int count___0 , float normfact ) ;
#line 739
static void d2dsc_array(XI_PRIVATE *pxi , double const   *src , signed char *dest ,
                        int count___0 , double normfact ) ;
#line 741
static void s2dles_array(XI_PRIVATE *pxi , short const   *src , short *dest , int count___0 ) ;
#line 742
static void i2dles_array(XI_PRIVATE *pxi , int const   *src , short *dest , int count___0 ) ;
#line 743
static void f2dles_array(XI_PRIVATE *pxi , float const   *src , short *dest , int count___0 ,
                         float normfact ) ;
#line 744
static void d2dles_array(XI_PRIVATE *pxi , double const   *src , short *dest , int count___0 ,
                         double normfact ) ;
#line 748 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_write_s2dsc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 752
  total = (sf_count_t )0;
#line 754
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 754
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 755
    return ((sf_count_t )0);
  }
#line 757
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 759
  while (1) {
    while_continue: /* CIL Label */ ;

#line 759
    if (! (len > 0L)) {
#line 759
      goto while_break;
    }
#line 760
    if (len < (long )bufferlen) {
#line 761
      bufferlen = (int )len;
    }
    {
#line 762
    s2dsc_array(pxi, ptr + total, ubuf.scbuf, bufferlen);
#line 763
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 763
    writecount = (int )__cil_tmp9;
#line 764
    total += (long )writecount;
    }
#line 765
    if (writecount < bufferlen) {
#line 766
      goto while_break;
    }
#line 767
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 770
  return (total);
}
}
#line 774 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_write_i2dsc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 778
  total = (sf_count_t )0;
#line 780
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 780
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 781
    return ((sf_count_t )0);
  }
#line 783
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;

#line 785
    if (! (len > 0L)) {
#line 785
      goto while_break;
    }
#line 786
    if (len < (long )bufferlen) {
#line 787
      bufferlen = (int )len;
    }
    {
#line 788
    i2dsc_array(pxi, ptr + total, ubuf.scbuf, bufferlen);
#line 789
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 789
    writecount = (int )__cil_tmp9;
#line 790
    total += (long )writecount;
    }
#line 791
    if (writecount < bufferlen) {
#line 792
      goto while_break;
    }
#line 793
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 796
  return (total);
}
}
#line 800 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_write_f2dsc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 804
  total = (sf_count_t )0;
#line 807
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 807
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 808
    return ((sf_count_t )0);
  }
#line 810
  if (psf->norm_float == 1) {
#line 810
    tmp = 1. * (double )127;
  } else {
#line 810
    tmp = 1.;
  }
#line 810
  normfact = (float )tmp;
#line 812
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;

#line 814
    if (! (len > 0L)) {
#line 814
      goto while_break;
    }
#line 815
    if (len < (long )bufferlen) {
#line 816
      bufferlen = (int )len;
    }
    {
#line 817
    f2dsc_array(pxi, ptr + total, ubuf.scbuf, bufferlen, normfact);
#line 818
    __cil_tmp11 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                             (sf_count_t )bufferlen, psf);
#line 818
    writecount = (int )__cil_tmp11;
#line 819
    total += (long )writecount;
    }
#line 820
    if (writecount < bufferlen) {
#line 821
      goto while_break;
    }
#line 822
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 825
  return (total);
}
}
#line 829 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_write_d2dsc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 833
  total = (sf_count_t )0;
#line 836
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 836
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 837
    return ((sf_count_t )0);
  }
#line 839
  if (psf->norm_double == 1) {
#line 839
    tmp = 1. * (double )127;
  } else {
#line 839
    tmp = 1.;
  }
#line 839
  normfact = tmp;
#line 841
  bufferlen = (int )(sizeof(ubuf.ucbuf) / sizeof(ubuf.ucbuf[0]));
  {
#line 843
  while (1) {
    while_continue: /* CIL Label */ ;

#line 843
    if (! (len > 0L)) {
#line 843
      goto while_break;
    }
#line 844
    if (len < (long )bufferlen) {
#line 845
      bufferlen = (int )len;
    }
    {
#line 846
    d2dsc_array(pxi, ptr + total, ubuf.scbuf, bufferlen, normfact);
#line 847
    __cil_tmp11 = psf_fwrite((void const   *)(ubuf.scbuf), (sf_count_t )sizeof(signed char ),
                             (sf_count_t )bufferlen, psf);
#line 847
    writecount = (int )__cil_tmp11;
#line 848
    total += (long )writecount;
    }
#line 849
    if (writecount < bufferlen) {
#line 850
      goto while_break;
    }
#line 851
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 854
  return (total);
}
}
#line 859 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_write_s2dles(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 863
  total = (sf_count_t )0;
#line 865
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 865
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 866
    return ((sf_count_t )0);
  }
#line 868
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;

#line 870
    if (! (len > 0L)) {
#line 870
      goto while_break;
    }
#line 871
    if (len < (long )bufferlen) {
#line 872
      bufferlen = (int )len;
    }
    {
#line 873
    s2dles_array(pxi, ptr + total, ubuf.sbuf, bufferlen);
#line 874
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 874
    writecount = (int )__cil_tmp9;
#line 875
    total += (long )writecount;
    }
#line 876
    if (writecount < bufferlen) {
#line 877
      goto while_break;
    }
#line 878
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 881
  return (total);
}
}
#line 885 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_write_i2dles(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;

  {
#line 889
  total = (sf_count_t )0;
#line 891
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 891
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 892
    return ((sf_count_t )0);
  }
#line 894
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;

#line 896
    if (! (len > 0L)) {
#line 896
      goto while_break;
    }
#line 897
    if (len < (long )bufferlen) {
#line 898
      bufferlen = (int )len;
    }
    {
#line 899
    i2dles_array(pxi, ptr + total, ubuf.sbuf, bufferlen);
#line 900
    __cil_tmp9 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                            (sf_count_t )bufferlen, psf);
#line 900
    writecount = (int )__cil_tmp9;
#line 901
    total += (long )writecount;
    }
#line 902
    if (writecount < bufferlen) {
#line 903
      goto while_break;
    }
#line 904
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 907
  return (total);
}
}
#line 911 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_write_f2dles(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 915
  total = (sf_count_t )0;
#line 918
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 918
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 919
    return ((sf_count_t )0);
  }
#line 921
  if (psf->norm_float == 1) {
#line 921
    tmp = 1. * (double )32767;
  } else {
#line 921
    tmp = 1.;
  }
#line 921
  normfact = (float )tmp;
#line 923
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;

#line 925
    if (! (len > 0L)) {
#line 925
      goto while_break;
    }
#line 926
    if (len < (long )bufferlen) {
#line 927
      bufferlen = (int )len;
    }
    {
#line 928
    f2dles_array(pxi, ptr + total, ubuf.sbuf, bufferlen, normfact);
#line 929
    __cil_tmp11 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 929
    writecount = (int )__cil_tmp11;
#line 930
    total += (long )writecount;
    }
#line 931
    if (writecount < bufferlen) {
#line 932
      goto while_break;
    }
#line 933
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 936
  return (total);
}
}
#line 940 "/root/patchweave_donee/23/src/xi.c"
static sf_count_t dpcm_write_d2dles(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 944
  total = (sf_count_t )0;
#line 947
  pxi = (XI_PRIVATE *)psf->codec_data;
#line 947
  if ((unsigned long )pxi == (unsigned long )((void *)0)) {
#line 948
    return ((sf_count_t )0);
  }
#line 950
  if (psf->norm_double == 1) {
#line 950
    tmp = 1. * (double )32767;
  } else {
#line 950
    tmp = 1.;
  }
#line 950
  normfact = tmp;
#line 952
  bufferlen = (int )(sizeof(ubuf.sbuf) / sizeof(ubuf.sbuf[0]));
  {
#line 954
  while (1) {
    while_continue: /* CIL Label */ ;

#line 954
    if (! (len > 0L)) {
#line 954
      goto while_break;
    }
#line 955
    if (len < (long )bufferlen) {
#line 956
      bufferlen = (int )len;
    }
    {
#line 957
    d2dles_array(pxi, ptr + total, ubuf.sbuf, bufferlen, normfact);
#line 958
    __cil_tmp11 = psf_fwrite((void const   *)(ubuf.sbuf), (sf_count_t )sizeof(short ),
                             (sf_count_t )bufferlen, psf);
#line 958
    writecount = (int )__cil_tmp11;
#line 959
    total += (long )writecount;
    }
#line 960
    if (writecount < bufferlen) {
#line 961
      goto while_break;
    }
#line 962
    len -= (long )writecount;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 965
  return (total);
}
}
#line 973 "/root/patchweave_donee/23/src/xi.c"
static void dsc2s_array(XI_PRIVATE *pxi , signed char *src , int count___0 , short *dest ) 
{ 
  signed char last_val ;
  int k ;
  int32_t __cil_tmp7 ;
  int32_t __cil_tmp9 ;

  {
#line 977
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 979
  k = 0;
  {
#line 979
  while (1) {
    while_continue: /* CIL Label */ ;

#line 979
    if (! (k < count___0)) {
#line 979
      goto while_break;
    }
    {
#line 980
    last_val = (signed char )((int )last_val + (int )*(src + k));
#line 981
    __cil_tmp7 = arith_shift_left((int32_t )last_val, 8);
#line 981
    *(dest + k) = (short )__cil_tmp7;
#line 979
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 984
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 984
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 986
  return;
}
}
#line 988 "/root/patchweave_donee/23/src/xi.c"
static void dsc2i_array(XI_PRIVATE *pxi , signed char *src , int count___0 , int *dest ) 
{ 
  signed char last_val ;
  int k ;
  int32_t __cil_tmp9 ;

  {
#line 992
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 994
  k = 0;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;

#line 994
    if (! (k < count___0)) {
#line 994
      goto while_break;
    }
    {
#line 995
    last_val = (signed char )((int )last_val + (int )*(src + k));
#line 996
    *(dest + k) = arith_shift_left((int32_t )last_val, 24);
#line 994
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 999
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 999
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 1001
  return;
}
}
#line 1003 "/root/patchweave_donee/23/src/xi.c"
static void dsc2f_array(XI_PRIVATE *pxi , signed char *src , int count___0 , float *dest ,
                        float normfact ) 
{ 
  signed char last_val ;
  int k ;
  int32_t __cil_tmp9 ;

  {
#line 1007
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1009
  k = 0;
  {
#line 1009
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1009
    if (! (k < count___0)) {
#line 1009
      goto while_break;
    }
#line 1010
    last_val = (signed char )((int )last_val + (int )*(src + k));
#line 1011
    *(dest + k) = (float )((int )last_val) * normfact;
#line 1009
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1014
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 1014
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 1016
  return;
}
}
#line 1018 "/root/patchweave_donee/23/src/xi.c"
static void dsc2d_array(XI_PRIVATE *pxi , signed char *src , int count___0 , double *dest ,
                        double normfact ) 
{ 
  signed char last_val ;
  int k ;
  int32_t __cil_tmp9 ;

  {
#line 1022
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1024
  k = 0;
  {
#line 1024
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1024
    if (! (k < count___0)) {
#line 1024
      goto while_break;
    }
#line 1025
    last_val = (signed char )((int )last_val + (int )*(src + k));
#line 1026
    *(dest + k) = (double )((int )last_val) * normfact;
#line 1024
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1029
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 1029
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 1031
  return;
}
}
#line 1036 "/root/patchweave_donee/23/src/xi.c"
static void s2dsc_array(XI_PRIVATE *pxi , short const   *src , signed char *dest ,
                        int count___0 ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  int32_t __cil_tmp9 ;

  {
#line 1040
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1042
  k = 0;
  {
#line 1042
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1042
    if (! (k < count___0)) {
#line 1042
      goto while_break;
    }
#line 1043
    current = (signed char )((int )*(src + k) >> 8);
#line 1044
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1045
    last_val = current;
#line 1042
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1048
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 1048
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 1050
  return;
}
}
#line 1052 "/root/patchweave_donee/23/src/xi.c"
static void i2dsc_array(XI_PRIVATE *pxi , int const   *src , signed char *dest , int count___0 ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  int32_t __cil_tmp9 ;

  {
#line 1056
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1058
  k = 0;
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1058
    if (! (k < count___0)) {
#line 1058
      goto while_break;
    }
#line 1059
    current = (signed char )(*(src + k) >> 24);
#line 1060
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1061
    last_val = current;
#line 1058
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1064
  __cil_tmp9 = arith_shift_left((int32_t )last_val, 8);
#line 1064
  pxi->last_16 = (short )__cil_tmp9;
  }
#line 1066
  return;
}
}
#line 1068 "/root/patchweave_donee/23/src/xi.c"
static void f2dsc_array(XI_PRIVATE *pxi , float const   *src , signed char *dest ,
                        int count___0 , float normfact ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  long __cil_tmp9 ;
  int32_t __cil_tmp11 ;

  {
#line 1072
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1074
  k = 0;
  {
#line 1074
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1074
    if (! (k < count___0)) {
#line 1074
      goto while_break;
    }
    {
#line 1075
    __cil_tmp9 = lrintf((float )(*(src + k) * (float const   )normfact));
#line 1075
    current = (signed char )__cil_tmp9;
#line 1076
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1077
    last_val = current;
#line 1074
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1080
  __cil_tmp11 = arith_shift_left((int32_t )last_val, 8);
#line 1080
  pxi->last_16 = (short )__cil_tmp11;
  }
#line 1082
  return;
}
}
#line 1084 "/root/patchweave_donee/23/src/xi.c"
static void d2dsc_array(XI_PRIVATE *pxi , double const   *src , signed char *dest ,
                        int count___0 , double normfact ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  long __cil_tmp9 ;
  int32_t __cil_tmp11 ;

  {
#line 1088
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1090
  k = 0;
  {
#line 1090
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1090
    if (! (k < count___0)) {
#line 1090
      goto while_break;
    }
    {
#line 1091
    __cil_tmp9 = lrint((double )(*(src + k) * (double const   )normfact));
#line 1091
    current = (signed char )__cil_tmp9;
#line 1092
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1093
    last_val = current;
#line 1090
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1096
  __cil_tmp11 = arith_shift_left((int32_t )last_val, 8);
#line 1096
  pxi->last_16 = (short )__cil_tmp11;
  }
#line 1098
  return;
}
}
#line 1103 "/root/patchweave_donee/23/src/xi.c"
static void dles2s_array(XI_PRIVATE *pxi , short *src , int count___0 , short *dest ) 
{ 
  short last_val ;
  int k ;

  {
#line 1107
  last_val = pxi->last_16;
#line 1109
  k = 0;
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1109
    if (! (k < count___0)) {
#line 1109
      goto while_break;
    }
#line 1110
    last_val = (short )((int )last_val + (int )*(src + k));
#line 1111
    *(dest + k) = last_val;
#line 1109
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1114
  pxi->last_16 = last_val;
#line 1115
  return;
}
}
#line 1118 "/root/patchweave_donee/23/src/xi.c"
static void dles2i_array(XI_PRIVATE *pxi , short *src , int count___0 , int *dest ) 
{ 
  short last_val ;
  int k ;

  {
#line 1122
  last_val = pxi->last_16;
#line 1124
  k = 0;
  {
#line 1124
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1124
    if (! (k < count___0)) {
#line 1124
      goto while_break;
    }
    {
#line 1125
    last_val = (short )((int )last_val + (int )*(src + k));
#line 1126
    *(dest + k) = arith_shift_left((int32_t )last_val, 16);
#line 1124
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1129
  pxi->last_16 = last_val;
#line 1130
  return;
}
}
#line 1133 "/root/patchweave_donee/23/src/xi.c"
static void dles2f_array(XI_PRIVATE *pxi , short *src , int count___0 , float *dest ,
                         float normfact ) 
{ 
  short last_val ;
  int k ;

  {
#line 1137
  last_val = pxi->last_16;
#line 1139
  k = 0;
  {
#line 1139
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1139
    if (! (k < count___0)) {
#line 1139
      goto while_break;
    }
#line 1140
    last_val = (short )((int )last_val + (int )*(src + k));
#line 1141
    *(dest + k) = (float )((int )last_val) * normfact;
#line 1139
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1144
  pxi->last_16 = last_val;
#line 1145
  return;
}
}
#line 1148 "/root/patchweave_donee/23/src/xi.c"
static void dles2d_array(XI_PRIVATE *pxi , short *src , int count___0 , double *dest ,
                         double normfact ) 
{ 
  short last_val ;
  int k ;

  {
#line 1152
  last_val = pxi->last_16;
#line 1154
  k = 0;
  {
#line 1154
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1154
    if (! (k < count___0)) {
#line 1154
      goto while_break;
    }
#line 1155
    last_val = (short )((int )last_val + (int )*(src + k));
#line 1156
    *(dest + k) = (double )((int )last_val) * normfact;
#line 1154
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1159
  pxi->last_16 = last_val;
#line 1160
  return;
}
}
#line 1166 "/root/patchweave_donee/23/src/xi.c"
static void s2dles_array(XI_PRIVATE *pxi , short const   *src , short *dest , int count___0 ) 
{ 
  short diff ;
  short last_val ;
  int k ;

  {
#line 1170
  last_val = pxi->last_16;
#line 1172
  k = 0;
  {
#line 1172
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1172
    if (! (k < count___0)) {
#line 1172
      goto while_break;
    }
#line 1173
    diff = (short )((int )*(src + k) - (int )last_val);
#line 1174
    *(dest + k) = diff;
#line 1175
    last_val = (short )*(src + k);
#line 1172
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1178
  pxi->last_16 = last_val;
#line 1179
  return;
}
}
#line 1182 "/root/patchweave_donee/23/src/xi.c"
static void i2dles_array(XI_PRIVATE *pxi , int const   *src , short *dest , int count___0 ) 
{ 
  short diff ;
  short last_val ;
  int k ;

  {
#line 1186
  last_val = pxi->last_16;
#line 1188
  k = 0;
  {
#line 1188
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1188
    if (! (k < count___0)) {
#line 1188
      goto while_break;
    }
#line 1189
    diff = (short )((*(src + k) >> 16) - (int const   )((int )last_val));
#line 1190
    *(dest + k) = diff;
#line 1191
    last_val = (short )(*(src + k) >> 16);
#line 1188
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1194
  pxi->last_16 = last_val;
#line 1195
  return;
}
}
#line 1198 "/root/patchweave_donee/23/src/xi.c"
static void f2dles_array(XI_PRIVATE *pxi , float const   *src , short *dest , int count___0 ,
                         float normfact ) 
{ 
  short diff ;
  short last_val ;
  short current ;
  int k ;
  long __cil_tmp10 ;

  {
#line 1202
  last_val = pxi->last_16;
#line 1204
  k = 0;
  {
#line 1204
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1204
    if (! (k < count___0)) {
#line 1204
      goto while_break;
    }
    {
#line 1205
    __cil_tmp10 = lrintf((float )(*(src + k) * (float const   )normfact));
#line 1205
    current = (short )__cil_tmp10;
#line 1206
    diff = (short )((int )current - (int )last_val);
#line 1207
    *(dest + k) = diff;
#line 1208
    last_val = current;
#line 1204
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1211
  pxi->last_16 = last_val;
#line 1212
  return;
}
}
#line 1215 "/root/patchweave_donee/23/src/xi.c"
static void d2dles_array(XI_PRIVATE *pxi , double const   *src , short *dest , int count___0 ,
                         double normfact ) 
{ 
  short diff ;
  short last_val ;
  short current ;
  int k ;
  long __cil_tmp10 ;

  {
#line 1219
  last_val = pxi->last_16;
#line 1221
  k = 0;
  {
#line 1221
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1221
    if (! (k < count___0)) {
#line 1221
      goto while_break;
    }
    {
#line 1222
    __cil_tmp10 = lrint((double )(*(src + k) * (double const   )normfact));
#line 1222
    current = (short )__cil_tmp10;
#line 1223
    diff = (short )((int )current - (int )last_val);
#line 1224
    *(dest + k) = diff;
#line 1225
    last_val = current;
#line 1221
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1228
  pxi->last_16 = last_val;
#line 1229
  return;
}
}
#line 134 "/root/patchweave_donee/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_PCM___0  =    {1U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 142 "/root/patchweave_donee/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_IEEE_FLOAT___0  =    {3U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 146 "/root/patchweave_donee/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_ALAW___0  =    {6U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 150 "/root/patchweave_donee/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MULAW___0  =    {7U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 158 "/root/patchweave_donee/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___0  =    {1U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 162 "/root/patchweave_donee/23/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___0  =    {3U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 179
static int wav_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) ;
#line 180
static int wav_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 182
static int wav_write_tailer(SF_PRIVATE *psf ) ;
#line 183
static void wav_write_strings(SF_PRIVATE *psf , int location ) ;
#line 184
static int wav_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int datasize ) ;
#line 185
static int wav_close(SF_PRIVATE *psf ) ;
#line 187
static int wav_subchunk_parse(SF_PRIVATE *psf , int chunk , uint32_t chunk_length ) ;
#line 188
static int exif_subchunk_parse(SF_PRIVATE *psf , uint32_t length ) ;
#line 189
static int wav_read_smpl_chunk(SF_PRIVATE *psf , uint32_t chunklen ) ;
#line 190
static int wav_read_acid_chunk(SF_PRIVATE *psf , uint32_t chunklen ) ;
#line 192
static int wav_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) ;
#line 193
static SF_CHUNK_ITERATOR *wav_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) ;
#line 194
static int wav_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 195
static int wav_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 202 "/root/patchweave_donee/23/src/wav.c"
int wav_open(SF_PRIVATE *psf ) 
{ 
  WAV_PRIVATE *wpriv ;
  int format ;
  int subformat ;
  int error ;
  int blockalign ;
  int framesperblock ;
  int __cil_tmp21 ;
  void *tmp ;

  {
  {
#line 204
  blockalign = 0;
#line 204
  framesperblock = 0;
#line 206
  tmp = calloc(1UL, sizeof(WAV_PRIVATE ));
#line 206
  wpriv = (WAV_PRIVATE *)tmp;
  }
#line 206
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 207
    return (17);
  }
#line 208
  psf->container_data = (void *)wpriv;
#line 210
  wpriv->wavex_ambisonic = 64;
#line 211
  psf->strings.flags = (uint32_t )768;
#line 213
  if (psf->file.mode == 16) {
    _L: 
    {
#line 214
    error = wav_read_header(psf, & blockalign, & framesperblock);
    }
#line 214
    if (error) {
#line 215
      return (error);
    }
#line 217
    psf->next_chunk_iterator = & wav_next_chunk_iterator;
#line 218
    psf->get_chunk_size = & wav_get_chunk_size;
#line 219
    psf->get_chunk_data = & wav_get_chunk_data;
  } else
#line 213
  if (psf->file.mode == 48) {
#line 213
    if (psf->filelength > 0L) {
#line 213
      goto _L;
    }
  }
#line 222
  subformat = psf->sf.format & 65535;
#line 224
  if (psf->file.mode == 32) {
    _L___14: 
#line 225
    if (psf->is_pipe) {
#line 226
      return (29);
    }
#line 228
    wpriv->wavex_ambisonic = 64;
#line 230
    format = psf->sf.format & 268369920;
#line 231
    if (format != 65536) {
#line 231
      if (format != 1245184) {
#line 232
        return (1);
      }
    }
#line 234
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 237
    psf->endian = psf->sf.format & 805306368;
#line 240
    if (psf->endian != 536870912) {
#line 241
      psf->endian = 268435456;
    }
#line 243
    if (psf->file.mode != 48) {
#line 244
      psf->filelength = (sf_count_t )0;
#line 245
      psf->datalength = (sf_count_t )0;
#line 246
      psf->dataoffset = (sf_count_t )0;
#line 247
      psf->sf.frames = (sf_count_t )0;
    } else
#line 243
    if (psf->filelength < 44L) {
#line 244
      psf->filelength = (sf_count_t )0;
#line 245
      psf->datalength = (sf_count_t )0;
#line 246
      psf->dataoffset = (sf_count_t )0;
#line 247
      psf->sf.frames = (sf_count_t )0;
    }
#line 250
    if (subformat == 18) {
      {
#line 251
      blockalign = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 252
      framesperblock = -1;
      }
    } else
#line 250
    if (subformat == 19) {
      {
#line 251
      blockalign = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 252
      framesperblock = -1;
      }
    }
#line 258
    if (psf->file.mode == 32) {
#line 258
      if (subformat == 6) {
        _L___13: 
        {
#line 259
        psf->peak_info = peak_info_calloc(psf->sf.channels);
        }
#line 259
        if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 260
          return (17);
        }
#line 261
        (psf->peak_info)->peak_loc = 42;
      } else
#line 258
      if (subformat == 7) {
#line 258
        goto _L___13;
      }
    }
#line 264
    psf->write_header = & wav_write_header;
#line 265
    psf->set_chunk = & wav_set_chunk;
  } else
#line 224
  if (psf->file.mode == 48) {
#line 224
    goto _L___14;
  }
#line 268
  psf->container_close = & wav_close;
#line 269
  psf->command = & wav_command;
#line 275
  if (subformat == 4) {
#line 275
    goto case_4;
  }
#line 275
  if (subformat == 3) {
#line 275
    goto case_4;
  }
#line 275
  if (subformat == 2) {
#line 275
    goto case_4;
  }
#line 275
  if (subformat == 5) {
#line 275
    goto case_4;
  }
#line 279
  if (subformat == 16) {
#line 279
    goto case_16;
  }
#line 283
  if (subformat == 17) {
#line 283
    goto case_17;
  }
#line 288
  if (subformat == 6) {
#line 288
    goto case_6;
  }
#line 292
  if (subformat == 7) {
#line 292
    goto case_7;
  }
#line 296
  if (subformat == 18) {
#line 296
    goto case_18;
  }
#line 300
  if (subformat == 19) {
#line 300
    goto case_19;
  }
#line 304
  if (subformat == 48) {
#line 304
    goto case_48;
  }
#line 309
  if (subformat == 32) {
#line 309
    goto case_32;
  }
#line 313
  goto switch_default;
  case_4: 
  {
#line 276
  error = pcm_init(psf);
  }
#line 277
  goto switch_break;
  case_16: 
  {
#line 280
  error = ulaw_init(psf);
  }
#line 281
  goto switch_break;
  case_17: 
  {
#line 284
  error = alaw_init(psf);
  }
#line 285
  goto switch_break;
  case_6: 
  {
#line 289
  error = float32_init(psf);
  }
#line 290
  goto switch_break;
  case_7: 
  {
#line 293
  error = double64_init(psf);
  }
#line 294
  goto switch_break;
  case_18: 
  {
#line 297
  error = wav_w64_ima_init(psf, blockalign, framesperblock);
  }
#line 298
  goto switch_break;
  case_19: 
  {
#line 301
  error = wav_w64_msadpcm_init(psf, blockalign, framesperblock);
  }
#line 302
  goto switch_break;
  case_48: 
  {
#line 305
  error = g72x_init(psf);
  }
#line 306
  goto switch_break;
  case_32: 
  {
#line 310
  error = gsm610_init(psf);
  }
#line 311
  goto switch_break;
  switch_default: 
#line 313
  return (18);
  switch_break: ;
#line 316
  if (psf->file.mode == 32) {
    {
#line 317
    __cil_tmp21 = (*(psf->write_header))(psf, 0);
    }
#line 317
    return (__cil_tmp21);
  } else
#line 316
  if (psf->file.mode == 48) {
#line 316
    if (psf->filelength == 0L) {
      {
#line 317
      __cil_tmp21 = (*(psf->write_header))(psf, 0);
      }
#line 317
      return (__cil_tmp21);
    }
  }
#line 319
  return (error);
}
}
#line 327 "/root/patchweave_donee/23/src/wav.c"
static int wav_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) 
{ 
  WAV_PRIVATE *wpriv ;
  WAV_FMT *wav_fmt ;
  FACT_CHUNK fact_chunk ;
  uint32_t marker ;
  uint32_t chunk_size ;
  uint32_t RIFFsize ;
  uint32_t done ;
  uint32_t uk ;
  int parsestage ;
  int error ;
  int format ;
  char buffer[256] ;
  int tmp ;
  size_t jump ;
  sf_count_t pos ;
  sf_count_t __cil_tmp19 ;
  sf_count_t __cil_tmp20 ;
  sf_count_t __cil_tmp23 ;
  float value___0 ;
  uint32_t position ;
  int tmp___0 ;
  uint32_t thisread ;
  uint32_t bytesread ;
  uint32_t cue_count ;
  int id ;
  int position___0 ;
  int chunk_id ;
  int chunk_start ;
  int block_start ;
  int offset ;
  int __cil_tmp38 ;
  unsigned int tmp___1 ;
  int __cil_tmp40 ;
  uint32_t __cil_tmp41 ;
  sf_count_t __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  sf_count_t __cil_tmp52 ;
  sf_count_t __cil_tmp53 ;
  sf_count_t __cil_tmp54 ;
  sf_count_t __cil_tmp55 ;
  int __cil_tmp56 ;
  int tmp___2 ;

  {
#line 331
  chunk_size = (uint32_t )0;
#line 331
  RIFFsize = (uint32_t )0;
#line 331
  done = (uint32_t )0;
#line 332
  parsestage = 0;
#line 332
  format = 0;
#line 335
  if (psf->is_pipe == 0) {
#line 335
    if (psf->filelength > 4294967295L) {
      {
#line 336
      psf_log_printf(psf, "Warning : filelength > 0xffffffff. This is bad!!!!\n");
      }
    }
  }
#line 338
  wpriv = (WAV_PRIVATE *)psf->container_data;
#line 338
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 339
    return (30);
  }
  {
#line 340
  wav_fmt = & wpriv->wav_fmt;
#line 343
  psf_binheader_readf(psf, "pmj", 0, & marker, -4);
#line 344
  psf->headindex = 0;
  }
#line 350
  if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
#line 350
    tmp = 268435456;
  } else {
#line 350
    tmp = 536870912;
  }
#line 350
  psf->rwf_endian = tmp;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;

#line 352
    if (! (! done)) {
#line 352
      goto while_break;
    }
    {
#line 353
    jump = (size_t )(chunk_size & 1U);
#line 355
    chunk_size = (uint32_t )0;
#line 355
    marker = chunk_size;
#line 356
    psf_binheader_readf(psf, "jm4", jump, & marker, & chunk_size);
    }
#line 357
    if (marker == 0U) {
      {
#line 358
      __cil_tmp19 = psf_ftell(psf);
#line 358
      pos = __cil_tmp19;
#line 359
      psf_log_printf(psf, "Have 0 marker at position %D (0x%x).\n", pos, pos);
      }
#line 360
      goto while_break;
    }
    {
#line 363
    __cil_tmp20 = psf_ftell(psf);
#line 363
    psf_store_read_chunk_u32(& psf->rchunks, marker, __cil_tmp20, chunk_size);
    }
#line 367
    if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (88U << 24))) {
#line 367
      goto case_exp;
    }
#line 367
    if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
#line 367
      goto case_exp;
    }
#line 406
    if (marker == ((unsigned int )((102 | (109 << 8)) | (116 << 16)) | (32U << 24))) {
#line 406
      goto case_exp___1;
    }
#line 424
    if (marker == ((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 424
      goto case_exp___2;
    }
#line 470
    if (marker == ((unsigned int )((102 | (97 << 8)) | (99 << 16)) | (116U << 24))) {
#line 470
      goto case_exp___3;
    }
#line 492
    if (marker == ((unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24))) {
#line 492
      goto case_exp___4;
    }
#line 536
    if (marker == ((unsigned int )((99 | (117 << 8)) | (101 << 16)) | (32U << 24))) {
#line 536
      goto case_exp___5;
    }
#line 574
    if (marker == ((unsigned int )((115 | (109 << 8)) | (112 << 16)) | (108U << 24))) {
#line 574
      goto case_exp___6;
    }
#line 583
    if (marker == ((unsigned int )((97 | (99 << 8)) | (105 << 16)) | (100U << 24))) {
#line 583
      goto case_exp___7;
    }
#line 593
    if (marker == ((unsigned int )((76 | (73 << 8)) | (83 << 16)) | (84U << 24))) {
#line 593
      goto case_exp___8;
    }
#line 593
    if (marker == ((unsigned int )((73 | (78 << 8)) | (70 << 16)) | (79U << 24))) {
#line 593
      goto case_exp___8;
    }
#line 600
    if (marker == ((unsigned int )((98 | (101 << 8)) | (120 << 16)) | (116U << 24))) {
#line 600
      goto case_exp___10;
    }
#line 609
    if (marker == ((unsigned int )((80 | (65 << 8)) | (68 << 16)) | (32U << 24))) {
#line 609
      goto case_exp___11;
    }
#line 618
    if (marker == ((unsigned int )((99 | (97 << 8)) | (114 << 16)) | (116U << 24))) {
#line 618
      goto case_exp___12;
    }
#line 643
    if (marker == ((unsigned int )((70 | (76 << 8)) | (76 << 16)) | (82U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((77 | (69 << 8)) | (88 << 16)) | (84U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((68 | (73 << 8)) | (83 << 16)) | (80U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((95 | (80 << 8)) | (77 << 16)) | (88U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((74 | (85 << 8)) | (78 << 16)) | (75U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((67 | (114 << 8)) | (56 << 16)) | (114U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((83 | (121 << 8)) | (76 << 16)) | (112U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((117 | (109 << 8)) | (105 << 16)) | (100U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((65 | (70 << 8)) | (65 << 16)) | (110U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((105 | (110 << 8)) | (115 << 16)) | (116U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((111 | (118 << 8)) | (119 << 16)) | (102U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((114 | (101 << 8)) | (103 << 16)) | (110U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((101 | (108 << 8)) | (109 << 16)) | (49U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((109 | (105 << 8)) | (110 << 16)) | (102U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((112 | (108 << 8)) | (115 << 16)) | (116U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((108 | (101 << 8)) | (118 << 16)) | (108U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((101 | (108 << 8)) | (109 << 16)) | (111U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((99 | (108 << 8)) | (109 << 16)) | (32U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((97 | (102 << 8)) | (115 << 16)) | (112U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((115 | (116 << 8)) | (114 << 16)) | (99U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 643
    if (marker == ((unsigned int )((105 | (88 << 8)) | (77 << 16)) | (76U << 24))) {
#line 643
      goto case_exp___13;
    }
#line 648
    goto switch_default;
    case_exp: 
#line 368
    if (parsestage) {
#line 369
      return (61);
    }
#line 371
    parsestage |= 1;
#line 373
    RIFFsize = chunk_size;
#line 375
    if (psf->fileoffset > 0L) {
#line 375
      if (psf->filelength > (long )(RIFFsize + 8U)) {
#line 377
        psf->filelength = (sf_count_t )(RIFFsize + 8U);
#line 378
        if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
          {
#line 379
          psf_log_printf(psf, "RIFF : %u\n#\330\204U", RIFFsize);
          }
        } else {
          {
#line 381
          psf_log_printf(psf, "RIFX : %u\n#\330\204U", RIFFsize);
          }
        }
      } else {
#line 375
        goto _L;
      }
    } else
    _L: 
#line 383
    if (psf->filelength < (long )(RIFFsize + (unsigned int )(2 * (int )sizeof(marker)))) {
#line 384
      if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
        {
#line 385
        psf_log_printf(psf, "RIFF : %u (should be %D)\nM#\330\204U", RIFFsize, psf->filelength - (long )(2 * (int )sizeof(marker)));
        }
      } else {
        {
#line 387
        psf_log_printf(psf, "RIFX : %u (should be %D)\n\t#\330\204U", RIFFsize, psf->filelength - (long )(2 * (int )sizeof(marker)));
        }
      }
#line 389
      RIFFsize = (uint32_t )(psf->filelength - (long )(2 * (int )sizeof(RIFFsize)));
    } else
#line 392
    if (marker == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
      {
#line 393
      psf_log_printf(psf, "RIFF : %u\n", RIFFsize);
      }
    } else {
      {
#line 395
      psf_log_printf(psf, "RIFX : %u\n", RIFFsize);
      }
    }
    {
#line 398
    psf_binheader_readf(psf, "me#\330\204U", & marker);
    }
#line 399
    if (marker != ((unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24))) {
#line 400
      return (62);
    }
    {
#line 401
    parsestage |= 2;
#line 402
    psf_log_printf(psf, "WAVE\n");
#line 403
    chunk_size = (uint32_t )0;
    }
#line 404
    goto switch_break;
    case_exp___1: 
#line 407
    if ((parsestage & 3) != 3) {
#line 408
      return (63);
    }
#line 411
    if (parsestage & 4) {
#line 412
      goto switch_break;
    }
    {
#line 414
    parsestage |= 4;
#line 416
    psf_log_printf(psf, "fmt  : %d\n", chunk_size);
#line 418
    error = wav_w64_read_fmt_chunk(psf, (int )chunk_size);
    }
#line 418
    if (error) {
#line 419
      return (error);
    }
#line 421
    format = (int )wav_fmt->format;
#line 422
    goto switch_break;
    case_exp___2: 
#line 425
    if ((parsestage & 7) != 7) {
#line 426
      return (71);
    }
#line 428
    if (psf->file.mode == 48) {
#line 428
      if (((unsigned int )parsestage & 2147483648U) != 0U) {
#line 429
        return (47);
      }
    }
#line 431
    parsestage |= 32;
#line 433
    psf->datalength = (sf_count_t )chunk_size;
#line 434
    if (psf->datalength & 1L) {
      {
#line 435
      psf_log_printf(psf, "*** \'data\' chunk should be an even number of bytes in length.\n");
      }
    }
    {
#line 437
    psf->dataoffset = psf_ftell(psf);
    }
#line 439
    if (psf->dataoffset > 0L) {
#line 440
      if (chunk_size == 0U) {
#line 440
        if (RIFFsize == 8U) {
#line 440
          if (psf->filelength > 44L) {
            {
#line 441
            psf_log_printf(psf, "*** Looks like a WAV file which wasn\'t closed properly. Fixing it.\n\330\204U");
#line 442
            psf->datalength = psf->filelength - psf->dataoffset;
            }
          }
        }
      }
#line 445
      if (psf->datalength > psf->filelength - psf->dataoffset) {
        {
#line 446
        psf_log_printf(psf, "data : %D (should be %D)\n", psf->datalength, psf->filelength - psf->dataoffset);
#line 447
        psf->datalength = psf->filelength - psf->dataoffset;
        }
      } else {
        {
#line 450
        psf_log_printf(psf, "data : %D\n", psf->datalength);
        }
      }
#line 453
      if (psf->datalength + psf->dataoffset < psf->filelength) {
#line 454
        psf->dataend = psf->datalength + psf->dataoffset;
      }
#line 456
      psf->datalength += (long )(chunk_size & 1U);
#line 457
      chunk_size = (uint32_t )0;
    }
#line 460
    if (! psf->sf.seekable) {
#line 461
      goto switch_break;
    } else
#line 460
    if (psf->dataoffset < 0L) {
#line 461
      goto switch_break;
    }
    {
#line 464
    psf_fseek(psf, psf->datalength, 1);
#line 466
    __cil_tmp23 = psf_ftell(psf);
    }
#line 466
    if (__cil_tmp23 != psf->datalength + psf->dataoffset) {
      {
#line 467
      psf_log_printf(psf, "*** psf_fseek past end error ***\n");
      }
    }
#line 468
    goto switch_break;
    case_exp___3: 
#line 471
    if ((parsestage & 3) != 3) {
#line 472
      return (66);
    }
#line 474
    parsestage |= 8;
#line 476
    if ((parsestage & 4) != 4) {
      {
#line 477
      psf_log_printf(psf, "*** Should have \'fmt \' chunk before \'fact\'\n");
      }
    }
    {
#line 479
    psf_binheader_readf(psf, "4", & fact_chunk.frames);
    }
#line 481
    if (chunk_size > (unsigned int )((int )sizeof(fact_chunk))) {
      {
#line 482
      psf_binheader_readf(psf, "j", (int )(chunk_size - (unsigned int )((int )sizeof(fact_chunk))));
      }
    }
#line 484
    if (chunk_size) {
      {
#line 485
      psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
      }
    } else {
      {
#line 487
      psf_log_printf(psf, "%M : %u (should not be zero)\n", marker, chunk_size);
      }
    }
    {
#line 489
    psf_log_printf(psf, "  frames  : %d\n", fact_chunk.frames);
    }
#line 490
    goto switch_break;
    case_exp___4: 
#line 493
    if ((parsestage & 7) != 7) {
#line 494
      return (68);
    }
    {
#line 496
    parsestage |= 16;
#line 498
    psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
    }
#line 499
    if ((unsigned long )chunk_size != 2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int ))) {
      {
#line 500
      psf_binheader_readf(psf, "j", chunk_size);
#line 501
      psf_log_printf(psf, "*** File PEAK chunk size doesn\'t fit with number of channels (%d).\n",
                     psf->sf.channels);
      }
#line 502
      return (67);
    }
    {
#line 505
    psf->peak_info = peak_info_calloc(psf->sf.channels);
    }
#line 505
    if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 506
      return (17);
    }
    {
#line 509
    psf_binheader_readf(psf, "44", & (psf->peak_info)->version, & (psf->peak_info)->timestamp);
    }
#line 511
    if ((psf->peak_info)->version != 1U) {
      {
#line 512
      psf_log_printf(psf, "  version    : %d *** (should be version 1)\n", (psf->peak_info)->version);
      }
    } else {
      {
#line 514
      psf_log_printf(psf, "  version    : %d\n", (psf->peak_info)->version);
      }
    }
    {
#line 516
    psf_log_printf(psf, "  time stamp : %d\n", (psf->peak_info)->timestamp);
#line 517
    psf_log_printf(psf, "    Ch   Position       Value\n");
#line 519
    uk = (uint32_t )0;
    }
    {
#line 519
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 519
      if (! (uk < (uint32_t )psf->sf.channels)) {
#line 519
        goto while_break___0;
      }
      {
#line 523
      psf_binheader_readf(psf, "f4", & value___0, & position);
#line 524
      (psf->peak_info)->peaks[uk].value = (double )value___0;
#line 525
      (psf->peak_info)->peaks[uk].position = (sf_count_t )position;
#line 527
      snprintf(buffer, sizeof(buffer), "    %2d   %-12ld   %g\n", uk, (psf->peak_info)->peaks[uk].position,
               (psf->peak_info)->peaks[uk].value);
#line 529
      buffer[sizeof(buffer) - 1UL] = (char)0;
#line 530
      psf_log_printf(psf, "%s", buffer);
#line 519
      uk ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 533
    if ((parsestage & 32) == 0) {
#line 533
      tmp___0 = 42;
    } else {
#line 533
      tmp___0 = 43;
    }
#line 533
    (psf->peak_info)->peak_loc = tmp___0;
#line 534
    goto switch_break;
    case_exp___5: 
    {
#line 537
    parsestage |= (-0x7FFFFFFF-1);
#line 542
    __cil_tmp38 = psf_binheader_readf(psf, "4", & cue_count);
#line 542
    bytesread = (uint32_t )__cil_tmp38;
#line 543
    psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
    }
#line 545
    if (cue_count > 10U) {
      {
#line 546
      psf_log_printf(psf, "  Count : %u (skipping)\n\230\001", cue_count);
      }
#line 547
      if (cue_count > 20U) {
#line 547
        tmp___1 = 20U;
      } else {
#line 547
        tmp___1 = cue_count;
      }
      {
#line 547
      psf_binheader_readf(psf, "j", tmp___1 * 24U);
      }
#line 548
      goto switch_break;
    }
    {
#line 551
    psf_log_printf(psf, "  Count : %d\n", cue_count);
    }
    {
#line 553
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 553
      if (! cue_count) {
#line 553
        goto while_break___1;
      }
      {
#line 555
      __cil_tmp40 = psf_binheader_readf(psf, "444444", & id, & position___0, & chunk_id,
                                        & chunk_start, & block_start, & offset);
#line 555
      thisread = (uint32_t )__cil_tmp40;
      }
#line 555
      if (thisread == 0U) {
#line 556
        goto while_break___1;
      }
      {
#line 557
      bytesread += thisread;
#line 559
      psf_log_printf(psf, "   Cue ID : %2d  Pos : %5u  Chunk : %M  Chk Start : %d  Blk Start : %d  Offset : %5d\n",
                     id, position___0, chunk_id, chunk_start, block_start, offset);
#line 564
      __cil_tmp41 = cue_count;
#line 564
      cue_count --;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
#line 567
    if (bytesread != chunk_size) {
      {
#line 568
      psf_log_printf(psf, "**** Chunk size weirdness (%d != %d)\n", chunk_size, bytesread);
#line 569
      psf_binheader_readf(psf, "j", chunk_size - bytesread);
      }
    }
#line 572
    goto switch_break;
    case_exp___6: 
    {
#line 575
    parsestage |= (-0x7FFFFFFF-1);
#line 577
    psf_log_printf(psf, "smpl : %u\n", chunk_size);
#line 579
    error = wav_read_smpl_chunk(psf, chunk_size);
    }
#line 579
    if (error) {
#line 580
      return (error);
    }
#line 581
    goto switch_break;
    case_exp___7: 
    {
#line 584
    parsestage |= (-0x7FFFFFFF-1);
#line 586
    psf_log_printf(psf, "acid : %u\n", chunk_size);
#line 588
    error = wav_read_acid_chunk(psf, chunk_size);
    }
#line 588
    if (error) {
#line 589
      return (error);
    }
#line 590
    goto switch_break;
    case_exp___8: 
    {
#line 594
    parsestage |= (-0x7FFFFFFF-1);
#line 596
    error = wav_subchunk_parse(psf, (int )marker, chunk_size);
    }
#line 596
    if (error != 0) {
#line 597
      return (error);
    }
#line 598
    goto switch_break;
    case_exp___10: 
    {
#line 605
    error = wav_read_bext_chunk(psf, chunk_size);
    }
#line 605
    if (error) {
#line 606
      return (error);
    }
#line 607
    goto switch_break;
    case_exp___11: 
    {
#line 614
    psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
#line 615
    psf_binheader_readf(psf, "j", chunk_size);
    }
#line 616
    goto switch_break;
    case_exp___12: 
    {
#line 619
    error = wav_read_cart_chunk(psf, chunk_size);
    }
#line 619
    if (error) {
#line 620
      return (error);
    }
#line 621
    goto switch_break;
    case_exp___13: 
    {
#line 644
    psf_log_printf(psf, "%M : %u\n\230\001", marker, chunk_size);
#line 645
    psf_binheader_readf(psf, "j", chunk_size);
    }
#line 646
    goto switch_break;
    switch_default: 
#line 649
    if (chunk_size >= 4294901760U) {
      {
#line 650
      done = (uint32_t )1;
#line 651
      __cil_tmp47 = psf_ftell(psf);
#line 651
      psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\n",
                     marker, __cil_tmp47 - 8L, chunk_size);
      }
#line 652
      goto switch_break;
    }
    {
#line 655
    __cil_tmp51 = psf_isprint((int )(marker & 255U));
#line 655
    __cil_tmp50 = psf_isprint((int )((marker >> 8) & 255U));
#line 655
    __cil_tmp49 = psf_isprint((int )((marker >> 16) & 255U));
#line 655
    __cil_tmp48 = psf_isprint((int )((marker >> 24) & 255U));
    }
#line 655
    if (__cil_tmp48) {
#line 655
      if (__cil_tmp49) {
#line 655
        if (__cil_tmp50) {
#line 655
          if (__cil_tmp51) {
            {
#line 657
            psf_log_printf(psf, "*** %M : %u (unknown marker)\n", marker, chunk_size);
#line 658
            psf_binheader_readf(psf, "j", chunk_size);
            }
#line 659
            goto switch_break;
          }
        }
      }
    }
    {
#line 661
    __cil_tmp52 = psf_ftell(psf);
    }
#line 661
    if (__cil_tmp52 & 3L) {
      {
#line 662
      __cil_tmp53 = psf_ftell(psf);
#line 662
      psf_log_printf(psf, "  Unknown chunk marker at position %D. Resynching.\n",
                     __cil_tmp53 - 8L);
#line 663
      psf_binheader_readf(psf, "j", -3);
#line 665
      parsestage |= (-0x7FFFFFFF-1);
      }
#line 666
      goto switch_break;
    }
    {
#line 668
    __cil_tmp54 = psf_ftell(psf);
#line 668
    psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D. Exiting parser.\n",
                   marker, __cil_tmp54 - 8L);
#line 669
    done = (uint32_t )1;
    }
#line 670
    goto switch_break;
    switch_break: ;
#line 673
    if ((long )chunk_size >= psf->filelength) {
      {
#line 674
      psf_log_printf(psf, "*** Chunk size %u > file length %D. Exiting parser.\n",
                     chunk_size, psf->filelength);
      }
#line 675
      goto while_break;
    }
#line 678
    if (! psf->sf.seekable) {
#line 678
      if (parsestage & 32) {
#line 679
        goto while_break;
      }
    }
    {
#line 681
    __cil_tmp55 = psf_ftell(psf);
    }
#line 681
    if (__cil_tmp55 >= psf->filelength - (long )((int )sizeof(chunk_size))) {
      {
#line 682
      psf_log_printf(psf, "End\n");
      }
#line 683
      goto while_break;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 687
  if (psf->dataoffset <= 0L) {
#line 688
    return (71);
  }
#line 690
  if (psf->sf.channels < 1) {
#line 691
    return (33);
  }
#line 693
  if (psf->sf.channels >= 1024) {
#line 694
    return (34);
  }
#line 696
  if (format != 1) {
#line 696
    if ((parsestage & 8) == 0) {
      {
#line 697
      psf_log_printf(psf, "**** All non-PCM format files should have a \'fact\' chunk.\n");
      }
    }
  }
  {
#line 700
  psf->endian = psf->rwf_endian;
#line 702
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 704
  if (psf->is_pipe == 0) {
    {
#line 709
    psf_binheader_readf(psf, "4", & marker);
    }
#line 710
    if (marker == ((unsigned int )((119 | (118 << 8)) | (112 << 16)) | (107U << 24))) {
#line 711
      return (78);
    } else
#line 710
    if (marker == ((unsigned int )((79 | (103 << 8)) | (103 << 16)) | (83U << 24))) {
#line 711
      return (78);
    }
  }
  {
#line 715
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 717
  if (psf->blockwidth) {
#line 718
    if (psf->filelength - psf->dataoffset < psf->datalength) {
#line 719
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    } else {
#line 721
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
  }
#line 725
  if (format == 65534) {
#line 725
    goto case_65534;
  }
#line 732
  if (format == 1) {
#line 732
    goto case_1;
  }
#line 737
  if (format == 257) {
#line 737
    goto case_257;
  }
#line 737
  if (format == 7) {
#line 737
    goto case_257;
  }
#line 742
  if (format == 258) {
#line 742
    goto case_258;
  }
#line 742
  if (format == 6) {
#line 742
    goto case_258;
  }
#line 746
  if (format == 2) {
#line 746
    goto case_2;
  }
#line 752
  if (format == 17) {
#line 752
    goto case_17;
  }
#line 758
  if (format == 49) {
#line 758
    goto case_49;
  }
#line 762
  if (format == 3) {
#line 762
    goto case_3;
  }
#line 767
  if (format == 64) {
#line 767
    goto case_64;
  }
#line 771
  goto switch_default___0;
  case_65534: 
#line 726
  if (psf->sf.format == 1245203) {
#line 727
    *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 728
    *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
  }
#line 730
  goto switch_break___0;
  case_1: 
  {
#line 733
  __cil_tmp56 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 733
  psf->sf.format = 65536 | __cil_tmp56;
  }
#line 734
  goto switch_break___0;
  case_257: 
#line 738
  psf->sf.format = 65552;
#line 739
  goto switch_break___0;
  case_258: 
#line 743
  psf->sf.format = 65553;
#line 744
  goto switch_break___0;
  case_2: 
#line 747
  psf->sf.format = 65555;
#line 748
  *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 749
  *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
#line 750
  goto switch_break___0;
  case_17: 
#line 753
  psf->sf.format = 65554;
#line 754
  *blockalign = (int )wav_fmt->ima.blockalign;
#line 755
  *framesperblock = (int )wav_fmt->ima.samplesperblock;
#line 756
  goto switch_break___0;
  case_49: 
#line 759
  psf->sf.format = 65568;
#line 760
  goto switch_break___0;
  case_3: 
#line 763
  psf->sf.format = 65536;
#line 764
  if (psf->bytewidth == 8) {
#line 764
    tmp___2 = 7;
  } else {
#line 764
    tmp___2 = 6;
  }
#line 764
  psf->sf.format |= tmp___2;
#line 765
  goto switch_break___0;
  case_64: 
#line 768
  psf->sf.format = 65584;
#line 769
  goto switch_break___0;
  switch_default___0: 
#line 771
  return (18);
  switch_break___0: ;
#line 774
  if (wpriv->fmt_is_broken) {
    {
#line 775
    wav_w64_analyze(psf);
    }
  }
#line 778
  if (psf->endian == 536870912) {
#line 779
    psf->sf.format |= 536870912;
  }
#line 781
  return (0);
}
}
#line 785 "/root/patchweave_donee/23/src/wav.c"
static int wav_write_fmt_chunk(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int fmt_size ;
  int add_fact_chunk ;
  int blockalign ;
  int framesperblock ;
  int bytespersec ;
  int blockalign___0 ;
  int framesperblock___0 ;
  int bytespersec___0 ;
  int extrabytes ;
  int blockalign___1 ;
  int framesperblock___1 ;
  int bytespersec___1 ;

  {
#line 786
  add_fact_chunk = 0;
#line 788
  subformat = psf->sf.format & 65535;
#line 794
  if (subformat == 4) {
#line 794
    goto case_4;
  }
#line 794
  if (subformat == 3) {
#line 794
    goto case_4;
  }
#line 794
  if (subformat == 2) {
#line 794
    goto case_4;
  }
#line 794
  if (subformat == 5) {
#line 794
    goto case_4;
  }
#line 806
  if (subformat == 7) {
#line 806
    goto case_7;
  }
#line 806
  if (subformat == 6) {
#line 806
    goto case_7;
  }
#line 819
  if (subformat == 16) {
#line 819
    goto case_16;
  }
#line 832
  if (subformat == 17) {
#line 832
    goto case_17;
  }
#line 846
  if (subformat == 18) {
#line 846
    goto case_18;
  }
#line 867
  if (subformat == 19) {
#line 867
    goto case_19;
  }
#line 894
  if (subformat == 48) {
#line 894
    goto case_48;
  }
#line 910
  if (subformat == 32) {
#line 910
    goto case_32;
  }
#line 933
  goto switch_default;
  case_4: 
  {
#line 795
  fmt_size = 16;
#line 798
  psf_binheader_writef(psf, "4224", fmt_size, 1, psf->sf.channels, psf->sf.samplerate);
#line 800
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 802
  psf_binheader_writef(psf, "22", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
  }
#line 803
  goto switch_break;
  case_7: 
  {
#line 807
  fmt_size = 16;
#line 810
  psf_binheader_writef(psf, "4224", fmt_size, 3, psf->sf.channels, psf->sf.samplerate);
#line 812
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 814
  psf_binheader_writef(psf, "22%\330\204U", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
#line 816
  add_fact_chunk = 1;
  }
#line 817
  goto switch_break;
  case_16: 
  {
#line 820
  fmt_size = 18;
#line 823
  psf_binheader_writef(psf, "4224", fmt_size, 7, psf->sf.channels, psf->sf.samplerate);
#line 825
  psf_binheader_writef(psf, "4)%\330\204U", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 827
  psf_binheader_writef(psf, "222\330\204U", psf->bytewidth * psf->sf.channels, 8,
                       0);
#line 829
  add_fact_chunk = 1;
  }
#line 830
  goto switch_break;
  case_17: 
  {
#line 833
  fmt_size = 18;
#line 836
  psf_binheader_writef(psf, "4224", fmt_size, 6, psf->sf.channels, psf->sf.samplerate);
#line 838
  psf_binheader_writef(psf, "4\365$\330\204U", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 840
  psf_binheader_writef(psf, "222\330\204U", psf->bytewidth * psf->sf.channels, 8,
                       0);
#line 842
  add_fact_chunk = 1;
  }
#line 843
  goto switch_break;
  case_18: 
  {
#line 849
  blockalign = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 850
  framesperblock = (2 * (blockalign - 4 * psf->sf.channels)) / psf->sf.channels + 1;
#line 851
  bytespersec = (psf->sf.samplerate * blockalign) / framesperblock;
#line 854
  fmt_size = 20;
#line 857
  psf_binheader_writef(psf, "42244", fmt_size, 17, psf->sf.channels, psf->sf.samplerate,
                       bytespersec);
#line 861
  psf_binheader_writef(psf, "2222\204U", blockalign, 4, 2, framesperblock);
#line 864
  add_fact_chunk = 1;
  }
#line 865
  goto switch_break;
  case_19: 
  {
#line 870
  blockalign___0 = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 871
  framesperblock___0 = 2 + (2 * (blockalign___0 - 7 * psf->sf.channels)) / psf->sf.channels;
#line 872
  bytespersec___0 = (psf->sf.samplerate * blockalign___0) / framesperblock___0;
#line 875
  extrabytes = 32;
#line 876
  fmt_size = 18 + extrabytes;
#line 879
  psf_binheader_writef(psf, "422\330\204U", fmt_size, 2, psf->sf.channels);
#line 882
  psf_binheader_writef(psf, "44$\330\204U", psf->sf.samplerate, bytespersec___0);
#line 885
  psf_binheader_writef(psf, "22222", blockalign___0, 4, extrabytes, framesperblock___0,
                       7);
#line 887
  msadpcm_write_adapt_coeffs(psf);
#line 890
  add_fact_chunk = 1;
  }
#line 891
  goto switch_break;
  case_48: 
  {
#line 896
  fmt_size = 20;
#line 899
  psf_binheader_writef(psf, "42244", fmt_size, 64, psf->sf.channels, psf->sf.samplerate,
                       (psf->sf.samplerate * psf->sf.channels) / 2);
#line 903
  psf_binheader_writef(psf, "2222\204U", 64, 4, 2, 0);
#line 905
  add_fact_chunk = 1;
  }
#line 906
  goto switch_break;
  case_32: 
  {
#line 913
  blockalign___1 = 65;
#line 914
  framesperblock___1 = 320;
#line 915
  bytespersec___1 = (psf->sf.samplerate * blockalign___1) / framesperblock___1;
#line 918
  fmt_size = 20;
#line 921
  psf_binheader_writef(psf, "422\330\204U", fmt_size, 49, psf->sf.channels);
#line 924
  psf_binheader_writef(psf, "44\b\330\204U", psf->sf.samplerate, bytespersec___1);
#line 927
  psf_binheader_writef(psf, "2222", blockalign___1, 0, 2, framesperblock___1);
#line 930
  add_fact_chunk = 1;
  }
#line 931
  goto switch_break;
  switch_default: 
#line 933
  return (18);
  switch_break: ;
#line 936
  if (add_fact_chunk) {
    {
#line 937
    psf_binheader_writef(psf, "tm48", (unsigned int )((102 | (97 << 8)) | (99 << 16)) | (116U << 24),
                         4, psf->sf.frames);
    }
  }
#line 939
  return (0);
}
}
#line 943 "/root/patchweave_donee/23/src/wav.c"
static int wavex_write_fmt_chunk(SF_PRIVATE *psf ) 
{ 
  WAV_PRIVATE *wpriv ;
  int subformat ;
  int fmt_size ;
  EXT_SUBFORMAT *tmp ;
  EXT_SUBFORMAT *tmp___0 ;

  {
#line 947
  wpriv = (WAV_PRIVATE *)psf->container_data;
#line 947
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 948
    return (30);
  }
#line 950
  subformat = psf->sf.format & 65535;
#line 961
  if (subformat == 17) {
#line 961
    goto case_17;
  }
#line 961
  if (subformat == 16) {
#line 961
    goto case_17;
  }
#line 961
  if (subformat == 7) {
#line 961
    goto case_17;
  }
#line 961
  if (subformat == 6) {
#line 961
    goto case_17;
  }
#line 961
  if (subformat == 4) {
#line 961
    goto case_17;
  }
#line 961
  if (subformat == 3) {
#line 961
    goto case_17;
  }
#line 961
  if (subformat == 2) {
#line 961
    goto case_17;
  }
#line 961
  if (subformat == 5) {
#line 961
    goto case_17;
  }
#line 991
  if (subformat == 1) {
#line 991
    goto case_1;
  }
#line 995
  if (subformat == 2) {
#line 995
    goto case_2___0;
  }
#line 999
  if (subformat == 4) {
#line 999
    goto case_4___0;
  }
#line 1003
  if (subformat == 6) {
#line 1003
    goto case_6___0;
  }
#line 1007
  if (subformat == 8) {
#line 1007
    goto case_8;
  }
#line 1019
  goto switch_default___0;
  case_17: 
  {
#line 962
  fmt_size = 40;
#line 965
  psf_binheader_writef(psf, "4224\204U", fmt_size, 65534, psf->sf.channels, psf->sf.samplerate);
#line 967
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 969
  psf_binheader_writef(psf, "22", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
#line 972
  psf_binheader_writef(psf, "2", 22);
#line 975
  psf_binheader_writef(psf, "2%%\330\204U", psf->bytewidth * 8);
  }
#line 980
  if (wpriv->wavex_ambisonic != 64) {
    {
#line 981
    psf_binheader_writef(psf, "4\307%\330\204U", 0);
    }
  } else
#line 982
  if (wpriv->wavex_channelmask != 0U) {
    {
#line 983
    psf_binheader_writef(psf, "4f&\330\204U", wpriv->wavex_channelmask);
    }
  } else {
#line 991
    if (psf->sf.channels == 1) {
#line 991
      goto case_1;
    }
#line 995
    if (psf->sf.channels == 2) {
#line 995
      goto case_2___0;
    }
#line 999
    if (psf->sf.channels == 4) {
#line 999
      goto case_4___0;
    }
#line 1003
    if (psf->sf.channels == 6) {
#line 1003
      goto case_6___0;
    }
#line 1007
    if (psf->sf.channels == 8) {
#line 1007
      goto case_8;
    }
#line 1011
    goto switch_default;
    case_1: 
    {
#line 992
    psf_binheader_writef(psf, "4\276%\330\204U", 4);
    }
#line 993
    goto switch_break___0;
    case_2___0: 
    {
#line 996
    psf_binheader_writef(psf, "4", 3);
    }
#line 997
    goto switch_break___0;
    case_4___0: 
    {
#line 1000
    psf_binheader_writef(psf, "4|%\330\204U", 51);
    }
#line 1001
    goto switch_break___0;
    case_6___0: 
    {
#line 1004
    psf_binheader_writef(psf, "4|%\330\204U", 63);
    }
#line 1005
    goto switch_break___0;
    case_8: 
    {
#line 1008
    psf_binheader_writef(psf, "4\v%\330\204U", 255);
    }
#line 1009
    goto switch_break___0;
    switch_default: 
    {
#line 1012
    psf_binheader_writef(psf, "4", 0);
    }
#line 1013
    goto switch_break___0;
    switch_break___0: ;
  }
#line 1016
  goto switch_break;
  switch_default___0: 
#line 1020
  return (18);
  switch_break: ;
#line 1029
  if (subformat == 4) {
#line 1029
    goto case_4___1;
  }
#line 1029
  if (subformat == 3) {
#line 1029
    goto case_4___1;
  }
#line 1029
  if (subformat == 2) {
#line 1029
    goto case_4___1;
  }
#line 1029
  if (subformat == 5) {
#line 1029
    goto case_4___1;
  }
#line 1035
  if (subformat == 7) {
#line 1035
    goto case_7___0;
  }
#line 1035
  if (subformat == 6) {
#line 1035
    goto case_7___0;
  }
#line 1040
  if (subformat == 16) {
#line 1040
    goto case_16___0;
  }
#line 1044
  if (subformat == 17) {
#line 1044
    goto case_17___0;
  }
#line 1056
  goto switch_default___1;
  case_4___1: 
#line 1030
  if (wpriv->wavex_ambisonic == 64) {
#line 1030
    tmp = & MSGUID_SUBTYPE_PCM___0;
  } else {
#line 1030
    tmp = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___0;
  }
  {
#line 1030
  wavex_write_guid(psf, tmp);
  }
#line 1032
  goto switch_break___1;
  case_7___0: 
#line 1036
  if (wpriv->wavex_ambisonic == 64) {
#line 1036
    tmp___0 = & MSGUID_SUBTYPE_IEEE_FLOAT___0;
  } else {
#line 1036
    tmp___0 = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___0;
  }
  {
#line 1036
  wavex_write_guid(psf, tmp___0);
  }
#line 1038
  goto switch_break___1;
  case_16___0: 
  {
#line 1041
  wavex_write_guid(psf, & MSGUID_SUBTYPE_MULAW___0);
  }
#line 1042
  goto switch_break___1;
  case_17___0: 
  {
#line 1045
  wavex_write_guid(psf, & MSGUID_SUBTYPE_ALAW___0);
  }
#line 1046
  goto switch_break___1;
  switch_default___1: 
#line 1056
  return (18);
  switch_break___1: 
  {
#line 1059
  psf_binheader_writef(psf, "tm48\204U", (unsigned int )((102 | (97 << 8)) | (99 << 16)) | (116U << 24),
                       4, psf->sf.frames);
  }
#line 1061
  return (0);
}
}
#line 1066 "/root/patchweave_donee/23/src/wav.c"
static int wav_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  uint32_t uk ;
  int k ;
  int error ;
  int has_data ;
  long tmp ;
  long tmp___0 ;
  time_t __cil_tmp14 ;
  int tmp___1 ;
  double dtune ;
  int type ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t __cil_tmp23 ;
  size_t __cil_tmp25 ;

  {
  {
#line 1069
  has_data = 0;
#line 1071
  current = psf_ftell(psf);
  }
#line 1073
  if (current > psf->dataoffset) {
#line 1074
    has_data = 1;
  }
#line 1076
  if (calc_length) {
    {
#line 1077
    psf->filelength = psf_get_filelen(psf);
#line 1079
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 1081
    if (psf->dataend) {
#line 1082
      psf->datalength -= psf->filelength - psf->dataend;
    } else
#line 1083
    if (psf->bytewidth > 0) {
#line 1083
      if (psf->sf.seekable == 1) {
#line 1084
        psf->datalength = (psf->sf.frames * (long )psf->bytewidth) * (long )psf->sf.channels;
      }
    }
  }
  {
#line 1088
  psf->header[0] = (unsigned char)0;
#line 1089
  psf->headindex = 0;
#line 1090
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 1100
  if (psf->endian == 268435456) {
#line 1101
    if (psf->filelength < 8L) {
#line 1101
      tmp = 8L;
    } else {
#line 1101
      tmp = psf->filelength - 8L;
    }
    {
#line 1101
    psf_binheader_writef(psf, "etm8\204U", (unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24),
                         tmp);
    }
  } else {
#line 1103
    if (psf->filelength < 8L) {
#line 1103
      tmp___0 = 8L;
    } else {
#line 1103
      tmp___0 = psf->filelength - 8L;
    }
    {
#line 1103
    psf_binheader_writef(psf, "Etm8\204U", (unsigned int )((82 | (73 << 8)) | (70 << 16)) | (88U << 24),
                         tmp___0);
    }
  }
  {
#line 1106
  psf_binheader_writef(psf, "mm", (unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24),
                       (unsigned int )((102 | (109 << 8)) | (116 << 16)) | (32U << 24));
  }
#line 1110
  if ((psf->sf.format & 268369920) == 65536) {
#line 1110
    goto case_65536;
  }
#line 1115
  if ((psf->sf.format & 268369920) == 1245184) {
#line 1115
    goto case_1245184;
  }
#line 1120
  goto switch_default;
  case_65536: 
  {
#line 1111
  error = wav_write_fmt_chunk(psf);
  }
#line 1111
  if (error != 0) {
#line 1112
    return (error);
  }
#line 1113
  goto switch_break;
  case_1245184: 
  {
#line 1116
  error = wavex_write_fmt_chunk(psf);
  }
#line 1116
  if (error != 0) {
#line 1117
    return (error);
  }
#line 1118
  goto switch_break;
  switch_default: 
#line 1121
  return (18);
  switch_break: ;
#line 1125
  if (psf->strings.flags & 1024U) {
    {
#line 1126
    wav_write_strings(psf, 1024);
    }
  }
#line 1128
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1128
    if ((psf->peak_info)->peak_loc == 42) {
      {
#line 1129
      psf_binheader_writef(psf, "m4", (unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24),
                           2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1130
      __cil_tmp14 = time((time_t *)((void *)0));
#line 1130
      psf_binheader_writef(psf, "44", 1, __cil_tmp14);
#line 1131
      k = 0;
      }
      {
#line 1131
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1131
        if (! (k < psf->sf.channels)) {
#line 1131
          goto while_break;
        }
        {
#line 1132
        psf_binheader_writef(psf, "ft8", (double )((float )(psf->peak_info)->peaks[k].value),
                             (psf->peak_info)->peaks[k].position);
#line 1131
        k ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 1135
  if ((unsigned long )psf->broadcast_16k != (unsigned long )((void *)0)) {
    {
#line 1136
    wav_write_bext_chunk(psf);
    }
  }
#line 1138
  if ((unsigned long )psf->cart_16k != (unsigned long )((void *)0)) {
    {
#line 1139
    wav_write_cart_chunk(psf);
    }
  }
#line 1141
  if ((unsigned long )psf->instrument != (unsigned long )((void *)0)) {
    {
#line 1143
    dtune = (double )1073741824 / 25.;
#line 1145
    psf_binheader_writef(psf, "m4\b\330\204U", (unsigned int )((115 | (109 << 8)) | (112 << 16)) | (108U << 24),
                         36 + ((psf->instrument)->loop_count * 6) * 4);
#line 1146
    psf_binheader_writef(psf, "44%\330\204U", 0, 0);
#line 1147
    tmp___1 = (int )(1000000000. / (double )psf->sf.samplerate);
#line 1148
    psf_binheader_writef(psf, "44&\330\204U", tmp___1, (int )(psf->instrument)->basenote);
#line 1149
    tmp___1 = (int )((uint32_t )((double )((int )(psf->instrument)->detune) * dtune + 0.5));
#line 1150
    psf_binheader_writef(psf, "4", tmp___1);
#line 1151
    psf_binheader_writef(psf, "44", 0, 0);
#line 1152
    psf_binheader_writef(psf, "44", (psf->instrument)->loop_count, 0);
#line 1154
    tmp___1 = 0;
    }
    {
#line 1154
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1154
      if (! (tmp___1 < (psf->instrument)->loop_count)) {
#line 1154
        goto while_break___0;
      }
#line 1157
      type = (psf->instrument)->loops[tmp___1].mode;
#line 1158
      if (type == 801) {
#line 1158
        tmp___17 = 0;
      } else {
#line 1158
        if (type == 802) {
#line 1158
          tmp___16 = 2;
        } else {
#line 1158
          if (type == 803) {
#line 1158
            tmp___15 = 1;
          } else {
#line 1158
            tmp___15 = 32;
          }
#line 1158
          tmp___16 = tmp___15;
        }
#line 1158
        tmp___17 = tmp___16;
      }
      {
#line 1158
      type = tmp___17;
#line 1160
      psf_binheader_writef(psf, "44#\330\204U", tmp___1, type);
#line 1161
      psf_binheader_writef(psf, "44", (psf->instrument)->loops[tmp___1].start, (psf->instrument)->loops[tmp___1].end - 1U);
#line 1162
      psf_binheader_writef(psf, "44", 0, (psf->instrument)->loops[tmp___1].count);
#line 1154
      tmp___1 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 1167
  uk = (uint32_t )0;
  {
#line 1167
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1167
    if (! (uk < psf->wchunks.used)) {
#line 1167
      goto while_break___1;
    }
    {
#line 1168
    __cil_tmp23 = make_size_t((int )(psf->wchunks.chunks + uk)->len);
#line 1168
    psf_binheader_writef(psf, "m4b", (int )(psf->wchunks.chunks + uk)->mark32, (psf->wchunks.chunks + uk)->len,
                         (psf->wchunks.chunks + uk)->data, __cil_tmp23);
#line 1167
    uk ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 1170
  if ((long )(psf->headindex + 16) < psf->dataoffset) {
    {
#line 1172
    k = (int )(psf->dataoffset - (long )(psf->headindex + 16));
#line 1173
    __cil_tmp25 = make_size_t(k);
#line 1173
    psf_binheader_writef(psf, "m4z\330\204U", (unsigned int )((80 | (65 << 8)) | (68 << 16)) | (32U << 24),
                         k, __cil_tmp25);
    }
  }
  {
#line 1176
  psf_binheader_writef(psf, "tm8", (unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24),
                       psf->datalength);
#line 1177
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 1178
  if (psf->error) {
#line 1179
    return (psf->error);
  }
#line 1181
  if (has_data) {
#line 1181
    if (psf->dataoffset != (long )psf->headindex) {
      {
#line 1182
      psf_log_printf(psf, "Oooops : has_data && psf->dataoffset != psf->headindex\n");
#line 1183
      psf->error = 30;
      }
#line 1183
      return (psf->error);
    }
  }
#line 1186
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 1188
  if (! has_data) {
    {
#line 1189
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 1190
  if (current > 0L) {
    {
#line 1191
    psf_fseek(psf, current, 0);
    }
  }
#line 1193
  return (psf->error);
}
}
#line 1198 "/root/patchweave_donee/23/src/wav.c"
static int wav_write_tailer(SF_PRIVATE *psf ) 
{ 
  int k ;
  time_t __cil_tmp4 ;

  {
#line 1202
  psf->header[0] = (unsigned char)0;
#line 1203
  psf->headindex = 0;
#line 1205
  if (psf->bytewidth > 0) {
#line 1205
    if (psf->sf.seekable == 1) {
#line 1206
      psf->datalength = (psf->sf.frames * (long )psf->bytewidth) * (long )psf->sf.channels;
#line 1207
      psf->dataend = psf->dataoffset + psf->datalength;
    }
  }
#line 1210
  if (psf->dataend > 0L) {
    {
#line 1211
    psf_fseek(psf, psf->dataend, 0);
    }
  } else {
    {
#line 1213
    psf->dataend = psf_fseek(psf, (sf_count_t )0, 2);
    }
  }
#line 1215
  if (psf->dataend & 1L) {
    {
#line 1216
    psf_binheader_writef(psf, "zP&\330\204U", 1);
    }
  }
#line 1219
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1219
    if ((psf->peak_info)->peak_loc == 43) {
      {
#line 1220
      psf_binheader_writef(psf, "m4&\330\204U", (unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24),
                           2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1221
      __cil_tmp4 = time((time_t *)((void *)0));
#line 1221
      psf_binheader_writef(psf, "44", 1, __cil_tmp4);
#line 1222
      k = 0;
      }
      {
#line 1222
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1222
        if (! (k < psf->sf.channels)) {
#line 1222
          goto while_break;
        }
        {
#line 1223
        psf_binheader_writef(psf, "f4", (psf->peak_info)->peaks[k].value, (psf->peak_info)->peaks[k].position);
#line 1222
        k ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 1226
  if (psf->strings.flags & 2048U) {
    {
#line 1227
    wav_write_strings(psf, 2048);
    }
  }
#line 1230
  if (psf->headindex > 0) {
    {
#line 1231
    psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
               psf);
    }
  }
#line 1233
  return (0);
}
}
#line 1237 "/root/patchweave_donee/23/src/wav.c"
static void wav_write_strings(SF_PRIVATE *psf , int location ) 
{ 
  int k ;
  int prev_head_index ;
  int saved_head_index ;
  int __cil_tmp6 ;

  {
  {
#line 1240
  __cil_tmp6 = psf_location_string_count(psf, location);
  }
#line 1240
  if (__cil_tmp6 == 0) {
#line 1241
    return;
  }
  {
#line 1243
  prev_head_index = psf->headindex + 4;
#line 1245
  psf_binheader_writef(psf, "m4m\330\204U", (unsigned int )((76 | (73 << 8)) | (83 << 16)) | (84U << 24),
                       12245933, (unsigned int )((73 | (78 << 8)) | (70 << 16)) | (79U << 24));
#line 1247
  k = 0;
  }
  {
#line 1247
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1247
    if (! (k < 32)) {
#line 1247
      goto while_break;
    }
#line 1248
    if (psf->strings.data[k].type == 0) {
#line 1249
      goto while_break;
    }
#line 1250
    if (psf->strings.data[k].type < 0) {
#line 1251
      goto while_continue;
    } else
#line 1250
    if (psf->strings.data[k].flags != location) {
#line 1251
      goto while_continue;
    }
#line 1254
    if (psf->strings.data[k].type == 3) {
#line 1254
      goto case_3;
    }
#line 1258
    if (psf->strings.data[k].type == 1) {
#line 1258
      goto case_1;
    }
#line 1262
    if (psf->strings.data[k].type == 2) {
#line 1262
      goto case_2;
    }
#line 1266
    if (psf->strings.data[k].type == 4) {
#line 1266
      goto case_4;
    }
#line 1270
    if (psf->strings.data[k].type == 5) {
#line 1270
      goto case_5;
    }
#line 1274
    if (psf->strings.data[k].type == 6) {
#line 1274
      goto case_6;
    }
#line 1278
    if (psf->strings.data[k].type == 16) {
#line 1278
      goto case_16;
    }
#line 1282
    if (psf->strings.data[k].type == 7) {
#line 1282
      goto case_7;
    }
#line 1286
    if (psf->strings.data[k].type == 9) {
#line 1286
      goto case_9;
    }
#line 1290
    goto switch_default;
    case_3: 
    {
#line 1255
    psf_binheader_writef(psf, "ms&\330\204U", (unsigned int )((73 | (83 << 8)) | (70 << 16)) | (84U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1256
    goto switch_break;
    case_1: 
    {
#line 1259
    psf_binheader_writef(psf, "ms&\330\204U", (unsigned int )((73 | (78 << 8)) | (65 << 16)) | (77U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1260
    goto switch_break;
    case_2: 
    {
#line 1263
    psf_binheader_writef(psf, "ms&\330\204U", (unsigned int )((73 | (67 << 8)) | (79 << 16)) | (80U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1264
    goto switch_break;
    case_4: 
    {
#line 1267
    psf_binheader_writef(psf, "ms&\330\204U", (unsigned int )((73 | (65 << 8)) | (82 << 16)) | (84U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1268
    goto switch_break;
    case_5: 
    {
#line 1271
    psf_binheader_writef(psf, "ms", (unsigned int )((73 | (67 << 8)) | (77 << 16)) | (84U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1272
    goto switch_break;
    case_6: 
    {
#line 1275
    psf_binheader_writef(psf, "ms&\330\204U", (unsigned int )((73 | (67 << 8)) | (82 << 16)) | (68U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1276
    goto switch_break;
    case_16: 
    {
#line 1279
    psf_binheader_writef(psf, "ms", (unsigned int )((73 | (71 << 8)) | (78 << 16)) | (82U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1280
    goto switch_break;
    case_7: 
    {
#line 1283
    psf_binheader_writef(psf, "ms&\330\204U", (unsigned int )((73 | (80 << 8)) | (82 << 16)) | (68U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1284
    goto switch_break;
    case_9: 
    {
#line 1287
    psf_binheader_writef(psf, "ms", (unsigned int )((73 | (84 << 8)) | (82 << 16)) | (75U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1288
    goto switch_break;
    switch_default: 
#line 1291
    goto switch_break;
    switch_break: 
#line 1247
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1295
  saved_head_index = psf->headindex;
#line 1296
  psf->headindex = prev_head_index;
#line 1297
  psf_binheader_writef(psf, "4\347%\330\204U", (saved_head_index - prev_head_index) - 4);
#line 1298
  psf->headindex = saved_head_index;
  }
#line 1300
  return;
}
}
#line 1303 "/root/patchweave_donee/23/src/wav.c"
static int wav_close(SF_PRIVATE *psf ) 
{ 
  sf_count_t current ;
  sf_count_t __cil_tmp3 ;

  {
#line 1305
  if (psf->file.mode == 32) {
    _L: 
    {
#line 1306
    wav_write_tailer(psf);
    }
#line 1308
    if (psf->file.mode == 48) {
      {
#line 1309
      __cil_tmp3 = psf_ftell(psf);
#line 1309
      current = __cil_tmp3;
      }
#line 1316
      if (current < psf->filelength) {
        {
#line 1317
        psf_ftruncate(psf, current);
#line 1318
        psf->filelength = current;
        }
      }
    }
    {
#line 1322
    (*(psf->write_header))(psf, 1);
    }
  } else
#line 1305
  if (psf->file.mode == 48) {
#line 1305
    goto _L;
  }
#line 1325
  return (0);
}
}
#line 1329 "/root/patchweave_donee/23/src/wav.c"
static int wav_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int datasize ) 
{ 
  WAV_PRIVATE *wpriv ;
  int __cil_tmp6 ;

  {
#line 1332
  wpriv = (WAV_PRIVATE *)psf->container_data;
#line 1332
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 1333
    return (30);
  }
#line 1336
  if (command == 4608) {
#line 1336
    goto case_4608;
  }
#line 1347
  if (command == 4609) {
#line 1347
    goto case_4609;
  }
#line 1350
  if (command == 4353) {
#line 1350
    goto case_4353;
  }
#line 1354
  goto switch_default;
  case_4608: 
#line 1337
  if ((psf->sf.format & 268369920) == 1245184) {
#line 1338
    if (datasize == 64) {
#line 1339
      wpriv->wavex_ambisonic = 64;
    } else
#line 1340
    if (datasize == 65) {
#line 1341
      wpriv->wavex_ambisonic = 65;
    } else {
#line 1343
      return (0);
    }
  }
#line 1345
  return (wpriv->wavex_ambisonic);
  case_4609: 
#line 1348
  return (wpriv->wavex_ambisonic);
  case_4353: 
  {
#line 1351
  __cil_tmp6 = wavex_gen_channel_mask((int const   *)psf->channel_map, psf->sf.channels);
#line 1351
  wpriv->wavex_channelmask = (unsigned int )__cil_tmp6;
  }
#line 1352
  return (wpriv->wavex_channelmask != 0U);
  switch_default: 
#line 1355
  goto switch_break;
  switch_break: ;
#line 1358
  return (0);
}
}
#line 1362 "/root/patchweave_donee/23/src/wav.c"
static int wav_subchunk_parse(SF_PRIVATE *psf , int chunk , uint32_t chunk_length ) 
{ 
  sf_count_t current_pos ;
  char buffer[512] ;
  uint32_t chunk_size ;
  uint32_t bytesread ;
  sf_count_t __cil_tmp8 ;
  uint32_t thisread ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int mark_id ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  sf_count_t __cil_tmp24 ;

  {
  {
#line 1367
  __cil_tmp8 = psf_fseek(psf, (sf_count_t )0, 1);
#line 1367
  current_pos = __cil_tmp8 - 4L;
#line 1369
  bytesread = (uint32_t )sizeof(chunk_length);
  }
#line 1371
  if (chunk_length <= 8U) {
    {
#line 1373
    psf_log_printf(psf, "%M : %u (weird length)\n", chunk, chunk_length);
#line 1374
    psf_binheader_readf(psf, "mj\'\330\204U", & chunk, chunk_length - 4U);
#line 1375
    psf_log_printf(psf, "  %M\nU", chunk);
    }
#line 1376
    return (0);
  }
#line 1379
  if ((unsigned int )psf->headindex + chunk_length > (unsigned int )((int )sizeof(psf->header))) {
    {
#line 1380
    psf_log_printf(psf, "%M : %u (too long)\n", chunk, chunk_length);
#line 1381
    psf_binheader_readf(psf, "j", chunk_length);
    }
#line 1382
    return (0);
  }
#line 1385
  if (current_pos + (long )chunk_length > psf->filelength) {
    {
#line 1386
    psf_log_printf(psf, "%M : %u (should be %d)\n", chunk, chunk_length, (int )(psf->filelength - current_pos));
#line 1387
    chunk_length = (uint32_t )(psf->filelength - current_pos);
    }
  } else {
    {
#line 1390
    psf_log_printf(psf, "%M : %u\n\230\001", chunk, chunk_length);
    }
  }
  {
#line 1392
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1392
    if (! (bytesread < chunk_length)) {
#line 1392
      goto while_break;
    }
    {
#line 1395
    __cil_tmp10 = psf_binheader_readf(psf, "m", & chunk);
#line 1395
    thisread = (uint32_t )__cil_tmp10;
    }
#line 1395
    if (thisread == 0U) {
#line 1396
      goto while_break;
    }
#line 1397
    bytesread += thisread;
#line 1401
    if (chunk == (int )((unsigned int )((73 | (78 << 8)) | (70 << 16)) | (79U << 24))) {
#line 1401
      goto case_exp;
    }
#line 1401
    if (chunk == (int )((unsigned int )((97 | (100 << 8)) | (116 << 16)) | (108U << 24))) {
#line 1401
      goto case_exp;
    }
#line 1406
    if (chunk == (int )((unsigned int )((101 | (120 << 8)) | (105 << 16)) | (102U << 24))) {
#line 1406
      goto case_exp___1;
    }
#line 1411
    if (chunk == (int )((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 1411
      goto case_exp___2;
    }
#line 1417
    if (chunk == 0) {
#line 1417
      goto case_0;
    }
#line 1428
    goto switch_default;
    case_exp: 
    {
#line 1403
    psf_log_printf(psf, "  %M\n", chunk);
    }
#line 1404
    goto while_continue;
    case_exp___1: 
    {
#line 1407
    psf_log_printf(psf, "  %M\n", chunk);
#line 1408
    __cil_tmp11 = exif_subchunk_parse(psf, chunk_length - bytesread);
#line 1408
    bytesread += (unsigned int )__cil_tmp11;
    }
#line 1409
    goto while_continue;
    case_exp___2: 
    {
#line 1412
    psf_log_printf(psf, "  %M inside a LIST block??? Backing out.\n", chunk);
#line 1414
    psf_binheader_readf(psf, "j", -4);
    }
#line 1415
    return (0);
    case_0: 
    {
#line 1422
    psf_log_printf(psf, "    *** Found weird-ass zero marker. Jumping to end of chunk.\n");
    }
#line 1423
    if (bytesread < chunk_length) {
      {
#line 1424
      __cil_tmp12 = psf_binheader_readf(psf, "j", (chunk_length - bytesread) + 4U);
#line 1424
      bytesread += (unsigned int )__cil_tmp12;
      }
    }
    {
#line 1425
    __cil_tmp13 = psf_fseek(psf, (sf_count_t )0, 1);
#line 1425
    psf_log_printf(psf, "    *** Offset is now : 0x%X\n", __cil_tmp13);
    }
#line 1426
    return (0);
    switch_default: 
#line 1429
    goto switch_break;
    switch_break: ;
#line 1446
    if (chunk == (int )((unsigned int )((73 | (84 << 8)) | (82 << 16)) | (75U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (65 << 8)) | (85 << 16)) | (84U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (83 << 8)) | (82 << 16)) | (67U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (83 << 8)) | (66 << 16)) | (74U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (80 << 8)) | (82 << 16)) | (68U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (78 << 8)) | (65 << 16)) | (77U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (71 << 8)) | (78 << 16)) | (82U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (69 << 8)) | (78 << 16)) | (71U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (82 << 16)) | (68U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (77 << 16)) | (84U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (65 << 8)) | (82 << 16)) | (84U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (65 << 8)) | (82 << 16)) | (76U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (79 << 16)) | (80U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1446
    if (chunk == (int )((unsigned int )((73 | (83 << 8)) | (70 << 16)) | (84U << 24))) {
#line 1446
      goto case_exp___3;
    }
#line 1460
    if (chunk == (int )((unsigned int )((108 | (97 << 8)) | (98 << 16)) | (108U << 24))) {
#line 1460
      goto case_exp___17;
    }
#line 1481
    if (chunk == (int )((unsigned int )((110 | (111 << 8)) | (116 << 16)) | (101U << 24))) {
#line 1481
      goto case_exp___18;
    }
#line 1481
    if (chunk == (int )((unsigned int )((108 | (116 << 8)) | (120 << 16)) | (116U << 24))) {
#line 1481
      goto case_exp___18;
    }
#line 1481
    if (chunk == (int )((unsigned int )((68 | (73 << 8)) | (83 << 16)) | (80U << 24))) {
#line 1481
      goto case_exp___18;
    }
#line 1494
    goto switch_default___0;
    case_exp___3: 
    {
#line 1447
    __cil_tmp14 = psf_binheader_readf(psf, "4", & chunk_size);
#line 1447
    bytesread += (unsigned int )__cil_tmp14;
#line 1448
    chunk_size += chunk_size & 1U;
    }
#line 1449
    if (chunk_size >= (unsigned int )((int )sizeof(buffer))) {
      {
#line 1450
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
#line 1451
      psf_binheader_readf(psf, "j", chunk_length);
      }
#line 1452
      return (0);
    } else
#line 1449
    if (chunk_size >= chunk_length) {
      {
#line 1450
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
#line 1451
      psf_binheader_readf(psf, "j", chunk_length);
      }
#line 1452
      return (0);
    }
    {
#line 1455
    __cil_tmp15 = psf_binheader_readf(psf, "b", buffer, chunk_size);
#line 1455
    bytesread += (unsigned int )__cil_tmp15;
#line 1456
    buffer[chunk_size] = (char)0;
#line 1457
    psf_log_printf(psf, "    %M : %s\n", chunk, buffer);
    }
#line 1458
    goto switch_break___0;
    case_exp___17: 
    {
#line 1463
    __cil_tmp17 = psf_binheader_readf(psf, "44", & chunk_size, & mark_id);
#line 1463
    bytesread += (unsigned int )__cil_tmp17;
#line 1464
    chunk_size -= 4U;
#line 1465
    chunk_size += chunk_size & 1U;
    }
#line 1466
    if (chunk_size < 1U) {
      {
#line 1467
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
#line 1468
      psf_binheader_readf(psf, "j", chunk_length);
      }
#line 1469
      goto switch_break___0;
    } else
#line 1466
    if (chunk_size >= (unsigned int )((int )sizeof(buffer))) {
      {
#line 1467
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
#line 1468
      psf_binheader_readf(psf, "j", chunk_length);
      }
#line 1469
      goto switch_break___0;
    } else
#line 1466
    if (chunk_size >= chunk_length) {
      {
#line 1467
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
#line 1468
      psf_binheader_readf(psf, "j", chunk_length);
      }
#line 1469
      goto switch_break___0;
    }
    {
#line 1472
    __cil_tmp18 = psf_binheader_readf(psf, "b", buffer, chunk_size);
#line 1472
    bytesread += (unsigned int )__cil_tmp18;
#line 1473
    buffer[chunk_size] = (char)0;
#line 1474
    psf_log_printf(psf, "    %M : %u : %s\n", chunk, mark_id, buffer);
    }
#line 1476
    goto switch_break___0;
    case_exp___18: 
    {
#line 1482
    __cil_tmp19 = psf_binheader_readf(psf, "4", & chunk_size);
#line 1482
    bytesread += (unsigned int )__cil_tmp19;
#line 1483
    chunk_size += chunk_size & 1U;
    }
#line 1484
    if (chunk_size >= (unsigned int )((int )sizeof(buffer))) {
      {
#line 1485
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
#line 1486
      psf_binheader_readf(psf, "j", chunk_length);
      }
#line 1487
      return (0);
    } else
#line 1484
    if (chunk_size >= chunk_length) {
      {
#line 1485
      psf_log_printf(psf, "  *** %M : %u (too big)\n\230\001", chunk, chunk_size);
#line 1486
      psf_binheader_readf(psf, "j", chunk_length);
      }
#line 1487
      return (0);
    }
    {
#line 1490
    __cil_tmp20 = psf_binheader_readf(psf, "j", chunk_size);
#line 1490
    bytesread += (unsigned int )__cil_tmp20;
#line 1491
    psf_log_printf(psf, "    %M : %u\n", chunk, chunk_size);
    }
#line 1492
    goto switch_break___0;
    switch_default___0: 
    {
#line 1495
    __cil_tmp21 = psf_binheader_readf(psf, "4", & chunk_size);
#line 1495
    bytesread += (unsigned int )__cil_tmp21;
#line 1496
    chunk_size += chunk_size & 1U;
#line 1497
    psf_log_printf(psf, "    *** %M : %u\n\230\001", chunk, chunk_size);
    }
#line 1498
    if (bytesread + chunk_size > chunk_length) {
      {
#line 1499
      __cil_tmp22 = psf_binheader_readf(psf, "j", (chunk_length - bytesread) + 4U);
#line 1499
      bytesread += (unsigned int )__cil_tmp22;
      }
#line 1500
      goto while_continue;
    } else {
      {
#line 1503
      __cil_tmp23 = psf_binheader_readf(psf, "j", chunk_size);
#line 1503
      bytesread += (unsigned int )__cil_tmp23;
      }
    }
#line 1505
    if (chunk_size >= chunk_length) {
#line 1506
      return (0);
    }
#line 1507
    goto switch_break___0;
    switch_break___0: ;
#line 1511
    if (chunk == (int )((unsigned int )((73 | (83 << 8)) | (70 << 16)) | (84U << 24))) {
#line 1511
      goto case_exp___21;
    }
#line 1514
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (79 << 16)) | (80U << 24))) {
#line 1514
      goto case_exp___22;
    }
#line 1517
    if (chunk == (int )((unsigned int )((73 | (78 << 8)) | (65 << 16)) | (77U << 24))) {
#line 1517
      goto case_exp___23;
    }
#line 1520
    if (chunk == (int )((unsigned int )((73 | (65 << 8)) | (82 << 16)) | (84U << 24))) {
#line 1520
      goto case_exp___24;
    }
#line 1523
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (77 << 16)) | (84U << 24))) {
#line 1523
      goto case_exp___25;
    }
#line 1526
    if (chunk == (int )((unsigned int )((73 | (67 << 8)) | (82 << 16)) | (68U << 24))) {
#line 1526
      goto case_exp___26;
    }
#line 1529
    if (chunk == (int )((unsigned int )((73 | (71 << 8)) | (78 << 16)) | (82U << 24))) {
#line 1529
      goto case_exp___27;
    }
#line 1532
    if (chunk == (int )((unsigned int )((73 | (80 << 8)) | (82 << 16)) | (68U << 24))) {
#line 1532
      goto case_exp___28;
    }
#line 1535
    if (chunk == (int )((unsigned int )((73 | (84 << 8)) | (82 << 16)) | (75U << 24))) {
#line 1535
      goto case_exp___29;
    }
#line 1510
    goto switch_break___1;
    case_exp___21: 
    {
#line 1512
    psf_store_string(psf, 3, (char const   *)(buffer));
    }
#line 1513
    goto switch_break___1;
    case_exp___22: 
    {
#line 1515
    psf_store_string(psf, 2, (char const   *)(buffer));
    }
#line 1516
    goto switch_break___1;
    case_exp___23: 
    {
#line 1518
    psf_store_string(psf, 1, (char const   *)(buffer));
    }
#line 1519
    goto switch_break___1;
    case_exp___24: 
    {
#line 1521
    psf_store_string(psf, 4, (char const   *)(buffer));
    }
#line 1522
    goto switch_break___1;
    case_exp___25: 
    {
#line 1524
    psf_store_string(psf, 5, (char const   *)(buffer));
    }
#line 1525
    goto switch_break___1;
    case_exp___26: 
    {
#line 1527
    psf_store_string(psf, 6, (char const   *)(buffer));
    }
#line 1528
    goto switch_break___1;
    case_exp___27: 
    {
#line 1530
    psf_store_string(psf, 16, (char const   *)(buffer));
    }
#line 1531
    goto switch_break___1;
    case_exp___28: 
    {
#line 1533
    psf_store_string(psf, 7, (char const   *)(buffer));
    }
#line 1534
    goto switch_break___1;
    case_exp___29: 
    {
#line 1536
    psf_store_string(psf, 9, (char const   *)(buffer));
    }
#line 1537
    goto switch_break___1;
    switch_break___1: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1541
  __cil_tmp24 = psf_fseek(psf, (sf_count_t )0, 1);
#line 1541
  current_pos = __cil_tmp24 - current_pos;
  }
#line 1543
  if (current_pos - 4L != (long )chunk_length) {
    {
#line 1544
    psf_log_printf(psf, "**** Bad chunk length %d sbould be %D\n", chunk_length, current_pos - 4L);
    }
  }
#line 1546
  return (0);
}
}
#line 1550 "/root/patchweave_donee/23/src/wav.c"
static int wav_read_smpl_chunk(SF_PRIVATE *psf , uint32_t chunklen ) 
{ 
  char buffer[512] ;
  uint32_t thisread ;
  uint32_t bytesread ;
  uint32_t dword ;
  uint32_t sampler_data ;
  uint32_t loop_count ;
  uint32_t note ;
  uint32_t start ;
  uint32_t end ;
  uint32_t type ;
  uint32_t count___0 ;
  int j ;
  int k ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  char ch ;
  int __cil_tmp35 ;

  {
  {
#line 1552
  bytesread = (uint32_t )0;
#line 1553
  type = (uint32_t )-1;
#line 1556
  chunklen += chunklen & 1U;
#line 1558
  __cil_tmp16 = psf_binheader_readf(psf, "4", & dword);
#line 1558
  bytesread += (unsigned int )__cil_tmp16;
#line 1559
  psf_log_printf(psf, "  Manufacturer : %X\n", dword);
#line 1561
  __cil_tmp17 = psf_binheader_readf(psf, "4", & dword);
#line 1561
  bytesread += (unsigned int )__cil_tmp17;
#line 1562
  psf_log_printf(psf, "  Product      : %u\n", dword);
#line 1564
  __cil_tmp18 = psf_binheader_readf(psf, "4", & dword);
#line 1564
  bytesread += (unsigned int )__cil_tmp18;
#line 1565
  psf_log_printf(psf, "  Period       : %u nsec\n", dword);
#line 1567
  __cil_tmp19 = psf_binheader_readf(psf, "4", & note);
#line 1567
  bytesread += (unsigned int )__cil_tmp19;
#line 1568
  psf_log_printf(psf, "  Midi Note    : %u\n", note);
#line 1570
  __cil_tmp20 = psf_binheader_readf(psf, "4", & dword);
#line 1570
  bytesread += (unsigned int )__cil_tmp20;
  }
#line 1571
  if (dword != 0U) {
    {
#line 1572
    snprintf(buffer, sizeof(buffer), "%f", (1. * (double )2147483648U) / (double )dword);
#line 1574
    psf_log_printf(psf, "  Pitch Fract. : %s\n", buffer);
    }
  } else {
    {
#line 1577
    psf_log_printf(psf, "  Pitch Fract. : 0\n");
    }
  }
  {
#line 1579
  __cil_tmp21 = psf_binheader_readf(psf, "4", & dword);
#line 1579
  bytesread += (unsigned int )__cil_tmp21;
#line 1580
  psf_log_printf(psf, "  SMPTE Format : %u\n\204U", dword);
#line 1582
  __cil_tmp22 = psf_binheader_readf(psf, "4((\330\204U", & dword);
#line 1582
  bytesread += (unsigned int )__cil_tmp22;
#line 1583
  snprintf(buffer, sizeof(buffer), "%02d:%02d:%02d %02d\330\204U", (dword >> 24) & 127U,
           (dword >> 16) & 127U, (dword >> 8) & 127U, dword & 127U);
#line 1585
  psf_log_printf(psf, "  SMPTE Offset : %s\n", buffer);
#line 1587
  __cil_tmp23 = psf_binheader_readf(psf, "41(\330\204U", & loop_count);
#line 1587
  bytesread += (unsigned int )__cil_tmp23;
#line 1588
  psf_log_printf(psf, "  Loop Count   : %u\n", loop_count);
  }
#line 1590
  if (loop_count == 0U) {
#line 1590
    if (chunklen == bytesread) {
#line 1591
      return (0);
    }
  }
  {
#line 1596
  __cil_tmp24 = psf_binheader_readf(psf, "4", & sampler_data);
#line 1596
  bytesread += (unsigned int )__cil_tmp24;
#line 1598
  psf->instrument = psf_instrument_alloc();
  }
#line 1598
  if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 1599
    return (17);
  }
#line 1601
  (psf->instrument)->loop_count = (int )loop_count;
#line 1603
  j = 0;
  {
#line 1603
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1603
    if (loop_count > 0U) {
#line 1603
      if (! (chunklen - bytesread >= 24U)) {
#line 1603
        goto while_break;
      }
    } else {
#line 1603
      goto while_break;
    }
    {
#line 1604
    __cil_tmp26 = psf_binheader_readf(psf, "4=(\330\204U", & dword);
#line 1604
    thisread = (uint32_t )__cil_tmp26;
    }
#line 1604
    if (thisread == 0U) {
#line 1605
      goto while_break;
    }
    {
#line 1606
    bytesread += thisread;
#line 1607
    psf_log_printf(psf, "    Cue ID : %2u\230\001", dword);
#line 1609
    __cil_tmp27 = psf_binheader_readf(psf, "4", & type);
#line 1609
    bytesread += (unsigned int )__cil_tmp27;
#line 1610
    psf_log_printf(psf, "  Type : %2u\204U", type);
#line 1612
    __cil_tmp28 = psf_binheader_readf(psf, "4\337\'\330\204U", & start);
#line 1612
    bytesread += (unsigned int )__cil_tmp28;
#line 1613
    psf_log_printf(psf, "  Start : %5u", start);
#line 1615
    __cil_tmp29 = psf_binheader_readf(psf, "4", & end);
#line 1615
    bytesread += (unsigned int )__cil_tmp29;
#line 1616
    psf_log_printf(psf, "  End : %5u", end);
#line 1618
    __cil_tmp30 = psf_binheader_readf(psf, "4", & dword);
#line 1618
    bytesread += (unsigned int )__cil_tmp30;
#line 1619
    psf_log_printf(psf, "  Fraction : %5u\230\001", dword);
#line 1621
    __cil_tmp31 = psf_binheader_readf(psf, "4", & count___0);
#line 1621
    bytesread += (unsigned int )__cil_tmp31;
#line 1622
    psf_log_printf(psf, "  Count : %5u\n", count___0);
    }
#line 1624
    if (j < (int )(sizeof((psf->instrument)->loops) / sizeof((psf->instrument)->loops[0]))) {
#line 1625
      (psf->instrument)->loops[j].start = start;
#line 1626
      (psf->instrument)->loops[j].end = end + 1U;
#line 1627
      (psf->instrument)->loops[j].count = count___0;
#line 1630
      if (type == 0U) {
#line 1630
        goto case_0;
      }
#line 1633
      if (type == 1U) {
#line 1633
        goto case_1;
      }
#line 1636
      if (type == 2U) {
#line 1636
        goto case_2;
      }
#line 1639
      goto switch_default;
      case_0: 
#line 1631
      (psf->instrument)->loops[j].mode = 801;
#line 1632
      goto switch_break;
      case_1: 
#line 1634
      (psf->instrument)->loops[j].mode = 803;
#line 1635
      goto switch_break;
      case_2: 
#line 1637
      (psf->instrument)->loops[j].mode = 802;
#line 1638
      goto switch_break;
      switch_default: 
#line 1640
      (psf->instrument)->loops[j].mode = 800;
#line 1641
      goto switch_break;
      switch_break: ;
    }
#line 1645
    __cil_tmp32 = loop_count;
#line 1645
    loop_count --;
#line 1603
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1648
  if (chunklen - bytesread == 0U) {
#line 1649
    if (sampler_data != 0U) {
      {
#line 1650
      psf_log_printf(psf, "  Sampler Data : %u (should be 0)\n\'\330\204U", sampler_data);
      }
    } else {
      {
#line 1652
      psf_log_printf(psf, "  Sampler Data : %u\n\204U", sampler_data);
      }
    }
  } else {
#line 1655
    if (sampler_data != chunklen - bytesread) {
      {
#line 1656
      psf_log_printf(psf, "  Sampler Data : %u (should have been %u)\n", sampler_data,
                     chunklen - bytesread);
#line 1657
      sampler_data = chunklen - bytesread;
      }
    } else {
      {
#line 1660
      psf_log_printf(psf, "  Sampler Data : %u\n", sampler_data);
      }
    }
    {
#line 1662
    psf_log_printf(psf, "      ");
#line 1663
    k = 0;
    }
    {
#line 1663
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1663
      if (! (k < (int )sampler_data)) {
#line 1663
        goto while_break___0;
      }
#line 1666
      if (k > 0) {
#line 1666
        if (k % 20 == 0) {
          {
#line 1667
          psf_log_printf(psf, "\n      ");
          }
        }
      }
      {
#line 1669
      __cil_tmp35 = psf_binheader_readf(psf, "1", & ch);
#line 1669
      thisread = (uint32_t )__cil_tmp35;
      }
#line 1669
      if (thisread == 0U) {
#line 1670
        goto while_break___0;
      }
      {
#line 1671
      bytesread += thisread;
#line 1672
      psf_log_printf(psf, "%02X U", (int )ch & 255);
#line 1663
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 1675
    psf_log_printf(psf, "\n");
    }
  }
#line 1678
  (psf->instrument)->basenote = (char )note;
#line 1679
  (psf->instrument)->gain = 1;
#line 1680
  (psf->instrument)->key_lo = (char)0;
#line 1680
  (psf->instrument)->velocity_lo = (psf->instrument)->key_lo;
#line 1681
  (psf->instrument)->key_hi = (char)127;
#line 1681
  (psf->instrument)->velocity_hi = (psf->instrument)->key_hi;
#line 1683
  return (0);
}
}
#line 1718 "/root/patchweave_donee/23/src/wav.c"
static int wav_read_acid_chunk(SF_PRIVATE *psf , uint32_t chunklen ) 
{ 
  char buffer[512] ;
  uint32_t bytesread ;
  int beats ;
  int flags ;
  short rootnote ;
  short q1 ;
  short meter_denom ;
  short meter_numer ;
  float q2 ;
  float tempo ;
  int __cil_tmp13 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int __cil_tmp19 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 1720
  bytesread = (uint32_t )0;
#line 1725
  chunklen += chunklen & 1U;
#line 1727
  __cil_tmp13 = psf_binheader_readf(psf, "422f", & flags, & rootnote, & q1, & q2);
#line 1727
  bytesread += (unsigned int )__cil_tmp13;
#line 1729
  snprintf(buffer, sizeof(buffer), "%f(\330\204U", (double )q2);
  }
#line 1731
  if (flags & 1) {
#line 1731
    tmp = "OneShot";
  } else {
#line 1731
    tmp = "Loop\204U";
  }
#line 1731
  if (flags & 2) {
#line 1731
    tmp___0 = "RootNoteValidU";
  } else {
#line 1731
    tmp___0 = "RootNoteInvalid";
  }
#line 1731
  if (flags & 4) {
#line 1731
    tmp___1 = "StretchOn";
  } else {
#line 1731
    tmp___1 = "StretchOff(\330\204U";
  }
#line 1731
  if (flags & 8) {
#line 1731
    tmp___2 = "DiskBased";
  } else {
#line 1731
    tmp___2 = "RAMBased\220";
  }
#line 1731
  if (flags & 16) {
#line 1731
    tmp___3 = "??On";
  } else {
#line 1731
    tmp___3 = "??Off";
  }
  {
#line 1731
  psf_log_printf(psf, "  Flags     : 0x%04x (%s,%s,%s,%s,%s)\n", flags, tmp, tmp___0,
                 tmp___1, tmp___2, tmp___3);
#line 1738
  psf_log_printf(psf, "  Root note : 0x%x\n  ????      : 0x%04x\n  ????      : %s\nn(\330\204U",
                 (int )rootnote, (int )q1, buffer);
#line 1741
  __cil_tmp19 = psf_binheader_readf(psf, "422f\204U", & beats, & meter_denom, & meter_numer,
                                    & tempo);
#line 1741
  bytesread += (unsigned int )__cil_tmp19;
#line 1742
  snprintf(buffer, sizeof(buffer), "%f", (double )tempo);
#line 1743
  psf_log_printf(psf, "  Beats     : %d\n  Meter     : %d/%d\n  Tempo     : %s\n",
                 beats, (int )meter_numer, (int )meter_denom, buffer);
#line 1746
  psf_binheader_readf(psf, "j", chunklen - bytesread);
#line 1748
  tmp___6 = calloc(1UL, sizeof(SF_LOOP_INFO ));
#line 1748
  psf->loop_info = (SF_LOOP_INFO *)tmp___6;
  }
#line 1748
  if ((unsigned long )psf->loop_info == (unsigned long )((void *)0)) {
#line 1749
    return (17);
  }
#line 1751
  (psf->loop_info)->time_sig_num = meter_numer;
#line 1752
  (psf->loop_info)->time_sig_den = meter_denom;
#line 1753
  if (flags & 1) {
#line 1753
    tmp___4 = 800;
  } else {
#line 1753
    tmp___4 = 801;
  }
#line 1753
  (psf->loop_info)->loop_mode = tmp___4;
#line 1754
  (psf->loop_info)->num_beats = beats;
#line 1755
  (psf->loop_info)->bpm = tempo;
#line 1756
  if (flags & 2) {
#line 1756
    tmp___5 = (int )rootnote;
  } else {
#line 1756
    tmp___5 = -1;
  }
#line 1756
  (psf->loop_info)->root_key = tmp___5;
#line 1758
  return (0);
}
}
#line 1762 "/root/patchweave_donee/23/src/wav.c"
int wav_read_bext_chunk(SF_PRIVATE *psf , uint32_t chunksize ) 
{ 
  SF_BROADCAST_INFO_16K *b ;
  uint32_t bytes ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 1765
  bytes = (uint32_t )0;
#line 1767
  if (chunksize < 602U) {
    {
#line 1768
    psf_log_printf(psf, "bext : %u (should be >= %d)\n\204U", chunksize, 602);
#line 1769
    psf_binheader_readf(psf, "j", chunksize);
    }
#line 1770
    return (0);
  }
#line 1773
  if (chunksize > 10240U) {
    {
#line 1774
    psf_log_printf(psf, "bext : %u (should be < %d)\n\330\204U", chunksize, 10240);
#line 1775
    psf_binheader_readf(psf, "jV(\330\204U", chunksize);
    }
#line 1776
    return (0);
  }
#line 1779
  if ((unsigned long )chunksize >= sizeof(SF_BROADCAST_INFO_16K )) {
    {
#line 1780
    psf_log_printf(psf, "bext : %u too big to be handled\n\230\001", chunksize);
#line 1781
    psf_binheader_readf(psf, "j", chunksize);
    }
#line 1782
    return (0);
  }
  {
#line 1785
  psf_log_printf(psf, "bext : %u\n", chunksize);
#line 1787
  psf->broadcast_16k = broadcast_var_alloc();
  }
#line 1787
  if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
#line 1788
    psf->error = 17;
#line 1789
    return (psf->error);
  }
  {
#line 1792
  b = psf->broadcast_16k;
#line 1794
  __cil_tmp6 = psf_binheader_readf(psf, "b", b->description, sizeof(b->description));
#line 1794
  bytes += (unsigned int )__cil_tmp6;
#line 1795
  __cil_tmp7 = psf_binheader_readf(psf, "b", b->originator, sizeof(b->originator));
#line 1795
  bytes += (unsigned int )__cil_tmp7;
#line 1796
  __cil_tmp8 = psf_binheader_readf(psf, "b\304(\330\204U", b->originator_reference,
                                   sizeof(b->originator_reference));
#line 1796
  bytes += (unsigned int )__cil_tmp8;
#line 1797
  __cil_tmp9 = psf_binheader_readf(psf, "b\310(\330\204U", b->origination_date, sizeof(b->origination_date));
#line 1797
  bytes += (unsigned int )__cil_tmp9;
#line 1798
  __cil_tmp10 = psf_binheader_readf(psf, "b", b->origination_time, sizeof(b->origination_time));
#line 1798
  bytes += (unsigned int )__cil_tmp10;
#line 1799
  __cil_tmp11 = psf_binheader_readf(psf, "442", & b->time_reference_low, & b->time_reference_high,
                                    & b->version);
#line 1799
  bytes += (unsigned int )__cil_tmp11;
#line 1800
  __cil_tmp12 = psf_binheader_readf(psf, "bj(\330\204U", & b->umid, sizeof(b->umid),
                                    190);
#line 1800
  bytes += (unsigned int )__cil_tmp12;
  }
#line 1802
  if (chunksize > 602U) {
    {
#line 1805
    b->coding_history_size = chunksize - 602U;
#line 1808
    __cil_tmp13 = psf_binheader_readf(psf, "b", b->coding_history, b->coding_history_size);
#line 1808
    bytes += (unsigned int )__cil_tmp13;
    }
  }
#line 1811
  if (bytes < chunksize) {
    {
#line 1812
    psf_binheader_readf(psf, "j", chunksize - bytes);
    }
  }
#line 1814
  return (0);
}
}
#line 1818 "/root/patchweave_donee/23/src/wav.c"
int wav_write_bext_chunk(SF_PRIVATE *psf ) 
{ 
  SF_BROADCAST_INFO_16K *b ;
  size_t __cil_tmp3 ;
  size_t __cil_tmp4 ;

  {
#line 1821
  if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
#line 1822
    return (-1);
  }
  {
#line 1824
  b = psf->broadcast_16k;
#line 1826
  psf_binheader_writef(psf, "m4", (unsigned int )((98 | (101 << 8)) | (120 << 16)) | (116U << 24),
                       602U + b->coding_history_size);
#line 1833
  psf_binheader_writef(psf, "b", b->description, sizeof(b->description));
#line 1834
  psf_binheader_writef(psf, "b", b->originator, sizeof(b->originator));
#line 1835
  psf_binheader_writef(psf, "b\311(\330\204U", b->originator_reference, sizeof(b->originator_reference));
#line 1836
  psf_binheader_writef(psf, "b", b->origination_date, sizeof(b->origination_date));
#line 1837
  psf_binheader_writef(psf, "b\310(\330\204U", b->origination_time, sizeof(b->origination_time));
#line 1838
  psf_binheader_writef(psf, "442", b->time_reference_low, b->time_reference_high,
                       (int )b->version);
#line 1839
  psf_binheader_writef(psf, "b\005)\330\204U", b->umid, sizeof(b->umid));
#line 1840
  __cil_tmp3 = make_size_t(190);
#line 1840
  psf_binheader_writef(psf, "z", __cil_tmp3);
  }
#line 1842
  if (b->coding_history_size > 0U) {
    {
#line 1843
    __cil_tmp4 = make_size_t((int )b->coding_history_size);
#line 1843
    psf_binheader_writef(psf, "b\272(\330\204U", b->coding_history, __cil_tmp4);
    }
  }
#line 1845
  return (0);
}
}
#line 1849 "/root/patchweave_donee/23/src/wav.c"
int wav_read_cart_chunk(SF_PRIVATE *psf , uint32_t chunksize ) 
{ 
  SF_CART_INFO_16K *c ;
  uint32_t bytes ;
  int k ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  size_t __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  size_t __cil_tmp28 ;
  int __cil_tmp29 ;

  {
#line 1851
  bytes = (uint32_t )0;
#line 1854
  if (chunksize < 2048U) {
    {
#line 1855
    psf_log_printf(psf, "cart : %u (should be >= %d)\n\204U", chunksize, 2048);
#line 1856
    psf_binheader_readf(psf, "j\005)\330\204U", chunksize);
    }
#line 1857
    return (0);
  }
#line 1859
  if (chunksize > 4294967295U) {
    {
#line 1860
    psf_log_printf(psf, "cart : %u (should be < %d)\n", chunksize, 4294967295U);
#line 1861
    psf_binheader_readf(psf, "j", chunksize);
    }
#line 1862
    return (0);
  }
#line 1865
  if ((unsigned long )chunksize >= sizeof(SF_CART_INFO_16K )) {
    {
#line 1866
    psf_log_printf(psf, "cart : %u too big to be handled\n\230\001", chunksize);
#line 1867
    psf_binheader_readf(psf, "j", chunksize);
    }
#line 1868
    return (0);
  }
  {
#line 1871
  psf_log_printf(psf, "cart : %u\n(\330\204U", chunksize);
#line 1873
  psf->cart_16k = cart_var_alloc();
  }
#line 1873
  if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
#line 1874
    psf->error = 17;
#line 1875
    return (psf->error);
  }
  {
#line 1878
  c = psf->cart_16k;
#line 1879
  __cil_tmp7 = psf_binheader_readf(psf, "b", c->version, sizeof(c->version));
#line 1879
  bytes += (unsigned int )__cil_tmp7;
#line 1880
  __cil_tmp8 = psf_binheader_readf(psf, "b", c->title, sizeof(c->title));
#line 1880
  bytes += (unsigned int )__cil_tmp8;
#line 1881
  __cil_tmp9 = psf_binheader_readf(psf, "b", c->artist, sizeof(c->artist));
#line 1881
  bytes += (unsigned int )__cil_tmp9;
#line 1882
  __cil_tmp10 = psf_binheader_readf(psf, "b", c->cut_id, sizeof(c->cut_id));
#line 1882
  bytes += (unsigned int )__cil_tmp10;
#line 1883
  __cil_tmp11 = psf_binheader_readf(psf, "b", c->client_id, sizeof(c->client_id));
#line 1883
  bytes += (unsigned int )__cil_tmp11;
#line 1884
  __cil_tmp12 = psf_binheader_readf(psf, "b", c->category, sizeof(c->category));
#line 1884
  bytes += (unsigned int )__cil_tmp12;
#line 1885
  __cil_tmp13 = psf_binheader_readf(psf, "b", c->classification, sizeof(c->classification));
#line 1885
  bytes += (unsigned int )__cil_tmp13;
#line 1886
  __cil_tmp14 = psf_binheader_readf(psf, "b", c->out_cue, sizeof(c->out_cue));
#line 1886
  bytes += (unsigned int )__cil_tmp14;
#line 1887
  __cil_tmp15 = psf_binheader_readf(psf, "b", c->start_date, sizeof(c->start_date));
#line 1887
  bytes += (unsigned int )__cil_tmp15;
#line 1888
  __cil_tmp16 = psf_binheader_readf(psf, "b", c->start_time, sizeof(c->start_time));
#line 1888
  bytes += (unsigned int )__cil_tmp16;
#line 1889
  __cil_tmp17 = psf_binheader_readf(psf, "b", c->end_date, sizeof(c->end_date));
#line 1889
  bytes += (unsigned int )__cil_tmp17;
#line 1890
  __cil_tmp18 = psf_binheader_readf(psf, "b", c->end_time, sizeof(c->end_time));
#line 1890
  bytes += (unsigned int )__cil_tmp18;
#line 1891
  __cil_tmp19 = psf_binheader_readf(psf, "b", c->producer_app_id, sizeof(c->producer_app_id));
#line 1891
  bytes += (unsigned int )__cil_tmp19;
#line 1892
  __cil_tmp20 = psf_binheader_readf(psf, "b", c->producer_app_version, sizeof(c->producer_app_version));
#line 1892
  bytes += (unsigned int )__cil_tmp20;
#line 1893
  __cil_tmp21 = psf_binheader_readf(psf, "b", c->user_def, sizeof(c->user_def));
#line 1893
  bytes += (unsigned int )__cil_tmp21;
#line 1894
  __cil_tmp22 = psf_binheader_readf(psf, "e4", & c->level_reference, sizeof(c->level_reference));
#line 1894
  bytes += (unsigned int )__cil_tmp22;
#line 1896
  k = 0;
  }
  {
#line 1896
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1896
    if (! (k < (int )(sizeof(c->post_timers) / sizeof(c->post_timers[0])))) {
#line 1896
      goto while_break;
    }
    {
#line 1897
    __cil_tmp23 = make_size_t(4);
#line 1897
    __cil_tmp24 = psf_binheader_readf(psf, "b4", & c->post_timers[k].usage, __cil_tmp23,
                                      & c->post_timers[k].value);
#line 1897
    bytes += (unsigned int )__cil_tmp24;
#line 1896
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1899
  __cil_tmp26 = psf_binheader_readf(psf, "b", c->reserved, sizeof(c->reserved));
#line 1899
  bytes += (unsigned int )__cil_tmp26;
#line 1900
  __cil_tmp27 = psf_binheader_readf(psf, "b", c->url, sizeof(c->url));
#line 1900
  bytes += (unsigned int )__cil_tmp27;
  }
#line 1902
  if (chunksize > 2048U) {
    {
#line 1904
    c->tag_text_size = chunksize - 2048U;
#line 1905
    __cil_tmp28 = make_size_t((int )c->tag_text_size);
#line 1905
    __cil_tmp29 = psf_binheader_readf(psf, "b", c->tag_text, __cil_tmp28);
#line 1905
    bytes += (unsigned int )__cil_tmp29;
    }
  }
#line 1908
  return (0);
}
}
#line 1912 "/root/patchweave_donee/23/src/wav.c"
int wav_write_cart_chunk(SF_PRIVATE *psf ) 
{ 
  SF_CART_INFO_16K *c ;
  int k ;
  size_t __cil_tmp4 ;
  size_t __cil_tmp6 ;

  {
#line 1916
  if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
#line 1917
    return (-1);
  }
  {
#line 1919
  c = psf->cart_16k;
#line 1920
  psf_binheader_writef(psf, "m4", (unsigned int )((99 | (97 << 8)) | (114 << 16)) | (116U << 24),
                       2048U + c->tag_text_size);
#line 1925
  psf_binheader_writef(psf, "b", c->version, sizeof(c->version));
#line 1926
  psf_binheader_writef(psf, "b", c->title, sizeof(c->title));
#line 1927
  psf_binheader_writef(psf, "b", c->artist, sizeof(c->artist));
#line 1928
  psf_binheader_writef(psf, "b", c->cut_id, sizeof(c->cut_id));
#line 1929
  psf_binheader_writef(psf, "b", c->client_id, sizeof(c->client_id));
#line 1930
  psf_binheader_writef(psf, "b", c->category, sizeof(c->category));
#line 1931
  psf_binheader_writef(psf, "b", c->classification, sizeof(c->classification));
#line 1932
  psf_binheader_writef(psf, "b", c->out_cue, sizeof(c->out_cue));
#line 1933
  psf_binheader_writef(psf, "b", c->start_date, sizeof(c->start_date));
#line 1934
  psf_binheader_writef(psf, "b", c->start_time, sizeof(c->start_time));
#line 1935
  psf_binheader_writef(psf, "b", c->end_date, sizeof(c->end_date));
#line 1936
  psf_binheader_writef(psf, "bX)\330\204U", c->end_time, sizeof(c->end_time));
#line 1937
  psf_binheader_writef(psf, "b", c->producer_app_id, sizeof(c->producer_app_id));
#line 1938
  psf_binheader_writef(psf, "bS)\330\204U", c->producer_app_version, sizeof(c->producer_app_version));
#line 1939
  psf_binheader_writef(psf, "b", c->user_def, sizeof(c->user_def));
#line 1940
  psf_binheader_writef(psf, "4", c->level_reference, sizeof(c->level_reference));
#line 1942
  k = 0;
  }
  {
#line 1942
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1942
    if (! (k < (int )(sizeof(c->post_timers) / sizeof(c->post_timers[0])))) {
#line 1942
      goto while_break;
    }
    {
#line 1943
    __cil_tmp4 = make_size_t(4);
#line 1943
    psf_binheader_writef(psf, "b4", c->post_timers[k].usage, __cil_tmp4, c->post_timers[k].value);
#line 1942
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1945
  psf_binheader_writef(psf, "z", sizeof(c->reserved));
#line 1946
  psf_binheader_writef(psf, "b", c->url, sizeof(c->url));
  }
#line 1948
  if (c->tag_text_size > 0U) {
    {
#line 1949
    __cil_tmp6 = make_size_t((int )c->tag_text_size);
#line 1949
    psf_binheader_writef(psf, "b", c->tag_text, __cil_tmp6);
    }
  }
#line 1951
  return (0);
}
}
#line 1955 "/root/patchweave_donee/23/src/wav.c"
static int exif_fill_and_sink(SF_PRIVATE *psf , char *buf , size_t bufsz , size_t toread ) 
{ 
  size_t bytesread ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 1957
  bytesread = (size_t )0;
#line 1959
  *(buf + 0) = (char)0;
#line 1960
  bufsz --;
#line 1961
  if (toread < bufsz) {
#line 1962
    bufsz = toread;
  }
  {
#line 1963
  __cil_tmp6 = psf_binheader_readf(psf, "b\337\234\327\204U", buf, bufsz);
#line 1963
  bytesread = (size_t )__cil_tmp6;
#line 1964
  *(buf + bufsz) = (char)0;
  }
#line 1966
  if (bytesread == bufsz) {
#line 1966
    if (toread > bufsz) {
      {
#line 1967
      __cil_tmp7 = psf_binheader_readf(psf, "j", toread - bufsz);
#line 1967
      bytesread += (unsigned long )__cil_tmp7;
      }
    }
  }
#line 1969
  return ((int )bytesread);
}
}
#line 1977 "/root/patchweave_donee/23/src/wav.c"
static int exif_subchunk_parse(SF_PRIVATE *psf , uint32_t length ) 
{ 
  uint32_t marker ;
  uint32_t dword ;
  uint32_t vmajor ;
  uint32_t vminor ;
  uint32_t bytesread ;
  char buf[4096] ;
  int thisread ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 1978
  vmajor = (uint32_t )-1;
#line 1978
  vminor = (uint32_t )-1;
#line 1978
  bytesread = (uint32_t )0;
  {
#line 1982
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1982
    if (! (bytesread < length)) {
#line 1982
      goto while_break;
    }
    {
#line 1984
    thisread = psf_binheader_readf(psf, "m", & marker);
    }
#line 1984
    if (thisread == 0) {
#line 1985
      goto while_break;
    }
#line 1986
    bytesread += (unsigned int )thisread;
#line 1990
    if (marker == 0U) {
#line 1990
      goto case_0;
    }
#line 1993
    if (marker == ((unsigned int )((101 | (118 << 8)) | (101 << 16)) | (114U << 24))) {
#line 1993
      goto case_exp;
    }
#line 2000
    if (marker == ((unsigned int )((111 | (108 << 8)) | (121 << 16)) | (109U << 24))) {
#line 2000
      goto case_exp___0;
    }
#line 2014
    if (marker == ((unsigned int )((101 | (117 << 8)) | (99 << 16)) | (109U << 24))) {
#line 2014
      goto case_exp___1;
    }
#line 2014
    if (marker == ((unsigned int )((101 | (114 << 8)) | (101 << 16)) | (108U << 24))) {
#line 2014
      goto case_exp___1;
    }
#line 2014
    if (marker == ((unsigned int )((101 | (116 << 8)) | (105 << 16)) | (109U << 24))) {
#line 2014
      goto case_exp___1;
    }
#line 2014
    if (marker == ((unsigned int )((101 | (99 << 8)) | (111 << 16)) | (114U << 24))) {
#line 2014
      goto case_exp___1;
    }
#line 2014
    if (marker == ((unsigned int )((101 | (109 << 8)) | (100 << 16)) | (108U << 24))) {
#line 2014
      goto case_exp___1;
    }
#line 2014
    if (marker == ((unsigned int )((101 | (109 << 8)) | (110 << 16)) | (116U << 24))) {
#line 2014
      goto case_exp___1;
    }
#line 2039
    goto switch_default;
    case_0: 
#line 1991
    goto switch_break;
    case_exp: 
    {
#line 1994
    __cil_tmp11 = psf_binheader_readf(psf, "j4", 4, & dword);
#line 1994
    bytesread += (unsigned int )__cil_tmp11;
#line 1995
    vmajor = 10U * (((dword >> 24) & 255U) - 48U) + (((dword >> 16) & 255U) - 48U);
#line 1996
    vminor = 10U * (((dword >> 8) & 255U) - 48U) + ((dword & 255U) - 48U);
#line 1997
    psf_log_printf(psf, "    EXIF Version : %u.%02u\n\330\204U", vmajor, vminor);
    }
#line 1998
    goto switch_break;
    case_exp___0: 
    {
#line 2001
    __cil_tmp12 = psf_binheader_readf(psf, "4\240)\330\204U", & dword);
#line 2001
    bytesread += (unsigned int )__cil_tmp12;
#line 2002
    psf_log_printf(psf, "%M : %u\n\230\001", marker, dword);
    }
#line 2003
    if (bytesread + dword > length) {
#line 2004
      goto switch_break;
    }
    {
#line 2005
    dword += dword & 1U;
#line 2006
    __cil_tmp13 = psf_binheader_readf(psf, "j\217)\330\204U", dword);
#line 2006
    bytesread += (unsigned int )__cil_tmp13;
    }
#line 2007
    goto switch_break;
    case_exp___1: 
    {
#line 2015
    __cil_tmp14 = psf_binheader_readf(psf, "4", & dword);
#line 2015
    bytesread += (unsigned int )__cil_tmp14;
#line 2016
    bytesread = (uint32_t )((unsigned long )bytesread + sizeof(dword));
#line 2017
    dword += dword & 1U;
    }
#line 2019
    if ((unsigned long )dword >= sizeof(buf)) {
      {
#line 2020
      psf_log_printf(psf, "*** Marker \'%M\' is too big %u\n\n", marker, dword);
      }
#line 2021
      return ((int )bytesread);
    }
    {
#line 2024
    __cil_tmp15 = exif_fill_and_sink(psf, buf, sizeof(buf), (size_t )dword);
#line 2024
    bytesread += (unsigned int )__cil_tmp15;
#line 2029
    __cil_tmp16 = strlen((char const   *)(buf));
    }
#line 2029
    if (marker == ((unsigned int )((101 | (109 << 8)) | (100 << 16)) | (108U << 24))) {
#line 2029
      if ((unsigned long )dword == __cil_tmp16) {
        {
#line 2030
        psf_log_printf(psf, "    *** field size too small for string (sinking 2 bytes)\n)\330\204U");
#line 2031
        __cil_tmp17 = psf_binheader_readf(psf, "ji)\330\204U", 2);
#line 2031
        bytesread += (unsigned int )__cil_tmp17;
        }
      }
    }
    {
#line 2034
    psf_log_printf(psf, "    %M : %u (%s)\n", marker, dword, buf);
    }
#line 2035
    if (dword > length) {
#line 2036
      return ((int )bytesread);
    }
#line 2037
    goto switch_break;
    switch_default: 
    {
#line 2040
    psf_log_printf(psf, "    *** %M (%u): -- ignored --\n", marker, marker);
    }
#line 2041
    goto switch_break;
    switch_break: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 2045
  return ((int )bytesread);
}
}
#line 2052 "/root/patchweave_donee/23/src/wav.c"
static int wav_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 2053
  __cil_tmp3 = psf_save_write_chunk(& psf->wchunks, chunk_info);
  }
#line 2053
  return (__cil_tmp3);
}
}
#line 2057 "/root/patchweave_donee/23/src/wav.c"
static SF_CHUNK_ITERATOR *wav_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) 
{ 
  SF_CHUNK_ITERATOR *__cil_tmp3 ;

  {
  {
#line 2058
  __cil_tmp3 = psf_next_chunk_iterator(& psf->rchunks, iterator);
  }
#line 2058
  return (__cil_tmp3);
}
}
#line 2062 "/root/patchweave_donee/23/src/wav.c"
static int wav_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;

  {
  {
#line 2065
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 2065
  if (indx < 0) {
#line 2066
    return (164);
  }
#line 2068
  chunk_info->datalen = (psf->rchunks.chunks + indx)->len;
#line 2070
  return (0);
}
}
#line 2074 "/root/patchweave_donee/23/src/wav.c"
static int wav_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;
  sf_count_t pos ;

  {
  {
#line 2078
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 2078
  if (indx < 0) {
#line 2079
    return (164);
  }
#line 2081
  if ((unsigned long )chunk_info->data == (unsigned long )((void *)0)) {
#line 2082
    return (167);
  }
  {
#line 2084
  chunk_info->id_size = (psf->rchunks.chunks + indx)->id_size;
#line 2085
  memcpy((void *)(chunk_info->id), (void const   *)((psf->rchunks.chunks + indx)->id),
         sizeof(chunk_info->id) / sizeof(chunk_info->id[0]));
#line 2087
  pos = psf_ftell(psf);
#line 2088
  psf_fseek(psf, (psf->rchunks.chunks + indx)->offset, 0);
#line 2089
  psf_fread(chunk_info->data, (sf_count_t )0, (sf_count_t )1, psf);
#line 2090
  psf_fseek(psf, pos, 0);
  }
#line 2092
  return (0);
}
}
#line 33 "/root/patchweave_donee/23/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_PCM___1  =    {1U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 37 "/root/patchweave_donee/23/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MS_ADPCM___1  =    {2U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 41 "/root/patchweave_donee/23/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_IEEE_FLOAT___1  =    {3U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 45 "/root/patchweave_donee/23/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_ALAW___1  =    {6U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 49 "/root/patchweave_donee/23/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MULAW___1  =    {7U, (unsigned short)0, (unsigned short)16, {(char)-128, (char)0, (char)0, (char)-86,
                                                (char)0, (char)56, (char)-101, (char)113}};
#line 58 "/root/patchweave_donee/23/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___1  =    {1U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 62 "/root/patchweave_donee/23/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___1  =    {3U, (unsigned short)1825, (unsigned short)4563, {(char)-122, (char)68, (char)-56,
                                                     (char)-63, (char)-54, (char)0,
                                                     (char)0, (char)0}};
#line 79 "/root/patchweave_donee/23/src/wav_w64.c"
static struct chanmap_s channel_mask_bits[18]  = 
#line 79
  {      {2, "L"}, 
        {3, "R"}, 
        {4, "C"}, 
        {11, "LFE"}, 
        {9, "Ls"}, 
        {10, "Rs"}, 
        {12, "Lc"}, 
        {13, "Rc"}, 
        {8, "Cs"}, 
        {14, "Sl"}, 
        {15, "Sr"}, 
        {16, "Tc"}, 
        {17, "Tfl"}, 
        {19, "Tfc"}, 
        {18, "Tfr"}, 
        {20, "Trl"}, 
        {22, "Trc"}, 
        {21, "Trr"}};
#line 106 "/root/patchweave_donee/23/src/wav_w64.c"
static int wavex_guid_equal(EXT_SUBFORMAT *first , EXT_SUBFORMAT *second ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp3 = memcmp((void const   *)first, (void const   *)second, sizeof(EXT_SUBFORMAT ));
  }
#line 107
  return (! __cil_tmp3);
}
}
#line 113 "/root/patchweave_donee/23/src/wav_w64.c"
int wav_w64_read_fmt_chunk(SF_PRIVATE *psf , int fmtsize ) 
{ 
  WAV_PRIVATE *wpriv ;
  WAV_FMT *wav_fmt ;
  int bytesread ;
  int k ;
  int bytespersec ;
  char const   *__cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char buffer[128] ;
  int __cil_tmp15 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  char buffer___0[512] ;
  unsigned int bit ;
  int __cil_tmp22 ;
  unsigned long __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int tmp___0 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int tmp___1 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  char const   *tmp___2 ;
  void *tmp___3 ;

  {
#line 116
  bytespersec = 0;
#line 118
  wpriv = (WAV_PRIVATE *)psf->container_data;
#line 118
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 119
    return (30);
  }
  {
#line 120
  wav_fmt = & wpriv->wav_fmt;
#line 122
  memset((void *)wav_fmt, 0, sizeof(WAV_FMT ));
  }
#line 124
  if (fmtsize < 16) {
#line 125
    return (65);
  }
  {
#line 130
  bytesread = psf_binheader_readf(psf, "224422", & wav_fmt->format, & wav_fmt->min.channels,
                                  & wav_fmt->min.samplerate, & wav_fmt->min.bytespersec,
                                  & wav_fmt->min.blockalign, & wav_fmt->min.bitwidth);
#line 135
  __cil_tmp9 = wav_w64_format_str((int )wav_fmt->format);
#line 135
  psf_log_printf(psf, "  Format        : 0x%X => %s\n", (int )wav_fmt->format, __cil_tmp9);
#line 136
  psf_log_printf(psf, "  Channels      : %d\n", (int )wav_fmt->min.channels);
#line 137
  psf_log_printf(psf, "  Sample Rate   : %d\n", wav_fmt->min.samplerate);
  }
#line 139
  if ((int )wav_fmt->format == 1) {
#line 139
    if ((int )wav_fmt->min.blockalign == 0) {
#line 139
      if ((int )wav_fmt->min.bitwidth > 0) {
#line 139
        if ((int )wav_fmt->min.channels > 0) {
#line 141
          if ((int )wav_fmt->min.bitwidth % 8 > 0) {
#line 141
            tmp = 1;
          } else {
#line 141
            tmp = 0;
          }
          {
#line 141
          wav_fmt->min.blockalign = (unsigned short )((int )wav_fmt->min.bitwidth / 8 + tmp);
#line 142
          wav_fmt->min.blockalign = (unsigned short )((int )wav_fmt->min.blockalign * (int )wav_fmt->min.channels);
#line 143
          psf_log_printf(psf, "  Block Align   : 0 (should be %d)\n", (int )wav_fmt->min.blockalign);
          }
        } else {
          {
#line 146
          psf_log_printf(psf, "  Block Align   : %d\n", (int )wav_fmt->min.blockalign);
          }
        }
      } else {
        {
#line 146
        psf_log_printf(psf, "  Block Align   : %d\n", (int )wav_fmt->min.blockalign);
        }
      }
    } else {
      {
#line 146
      psf_log_printf(psf, "  Block Align   : %d\n", (int )wav_fmt->min.blockalign);
      }
    }
  } else {
    {
#line 146
    psf_log_printf(psf, "  Block Align   : %d\n", (int )wav_fmt->min.blockalign);
    }
  }
#line 148
  if ((int )wav_fmt->format == 1) {
#line 148
    if ((int )wav_fmt->min.bitwidth == 24) {
#line 148
      if ((int )wav_fmt->min.blockalign == 4 * (int )wav_fmt->min.channels) {
        {
#line 150
        psf_log_printf(psf, "  Bit Width     : 24\n");
#line 152
        psf_log_printf(psf, "\n  Ambiguous information in \'fmt \' chunk. Possibile file types:\n    0) Invalid IEEE float file generated by Syntrillium\'s Cooledit!\n    1) File generated by ALSA\'s arecord containing 24 bit samples in 32 bit containers.\n    2) 24 bit file with incorrect Block Align value.\n\n");
#line 159
        wpriv->fmt_is_broken = 1;
        }
      } else {
#line 148
        goto _L;
      }
    } else {
#line 148
      goto _L;
    }
  } else
  _L: 
#line 161
  if ((int )wav_fmt->min.bitwidth == 0) {
#line 164
    if ((int )wav_fmt->format == 29232) {
#line 164
      goto case_29232;
    }
#line 164
    if ((int )wav_fmt->format == 49) {
#line 164
      goto case_29232;
    }
#line 167
    goto switch_default;
    case_29232: 
    {
#line 165
    psf_log_printf(psf, "  Bit Width     : %d\n", (int )wav_fmt->min.bitwidth);
    }
#line 166
    goto switch_break;
    switch_default: 
    {
#line 168
    psf_log_printf(psf, "  Bit Width     : %d (should not be 0)\n", (int )wav_fmt->min.bitwidth);
    }
    switch_break: ;
  } else {
#line 174
    if ((int )wav_fmt->format == 29232) {
#line 174
      goto case_29232___0;
    }
#line 174
    if ((int )wav_fmt->format == 49) {
#line 174
      goto case_29232___0;
    }
#line 177
    goto switch_default___0;
    case_29232___0: 
    {
#line 175
    psf_log_printf(psf, "  Bit Width     : %d (should be 0)\n", (int )wav_fmt->min.bitwidth);
    }
#line 176
    goto switch_break___0;
    switch_default___0: 
    {
#line 178
    psf_log_printf(psf, "  Bit Width     : %d\n", (int )wav_fmt->min.bitwidth);
    }
    switch_break___0: ;
  }
#line 182
  psf->sf.samplerate = (int )wav_fmt->min.samplerate;
#line 183
  psf->sf.frames = (sf_count_t )0;
#line 184
  psf->sf.channels = (int )wav_fmt->min.channels;
#line 188
  if ((int )wav_fmt->format == 3) {
#line 188
    goto case_3;
  }
#line 188
  if ((int )wav_fmt->format == 1) {
#line 188
    goto case_3;
  }
#line 199
  if ((int )wav_fmt->format == 7) {
#line 199
    goto case_7;
  }
#line 199
  if ((int )wav_fmt->format == 6) {
#line 199
    goto case_7;
  }
#line 212
  if ((int )wav_fmt->format == 17) {
#line 212
    goto case_17;
  }
#line 235
  if ((int )wav_fmt->format == 2) {
#line 235
    goto case_2;
  }
#line 278
  if ((int )wav_fmt->format == 49) {
#line 278
    goto case_49___1;
  }
#line 298
  if ((int )wav_fmt->format == 65534) {
#line 298
    goto case_65534;
  }
#line 406
  if ((int )wav_fmt->format == 64) {
#line 406
    goto case_64;
  }
#line 424
  goto switch_default___1;
  case_3: 
#line 189
  bytespersec = (int )(wav_fmt->min.samplerate * (unsigned int )wav_fmt->min.blockalign);
#line 190
  if (wav_fmt->min.bytespersec != (unsigned int )bytespersec) {
    {
#line 191
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 193
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec);
    }
  }
#line 195
  psf->bytewidth = ((int )wav_fmt->min.bitwidth + 7) / 8;
#line 196
  goto switch_break___1;
  case_7: 
#line 200
  if (wav_fmt->min.bytespersec != wav_fmt->min.samplerate * (unsigned int )wav_fmt->min.blockalign) {
    {
#line 201
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec,
                   wav_fmt->min.samplerate * (unsigned int )wav_fmt->min.blockalign);
    }
  } else {
    {
#line 203
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec);
    }
  }
#line 205
  psf->bytewidth = 1;
#line 206
  if (fmtsize >= 18) {
    {
#line 207
    __cil_tmp11 = psf_binheader_readf(psf, "2", & wav_fmt->size20.extrabytes);
#line 207
    bytesread += __cil_tmp11;
#line 208
    psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->size20.extrabytes);
    }
  }
#line 210
  goto switch_break___1;
  case_17: 
#line 213
  if ((int )wav_fmt->min.bitwidth != 4) {
#line 214
    return (73);
  }
#line 215
  if ((int )wav_fmt->min.channels < 1) {
#line 216
    return (74);
  } else
#line 215
  if ((int )wav_fmt->min.channels > 2) {
#line 216
    return (74);
  }
  {
#line 218
  __cil_tmp12 = psf_binheader_readf(psf, "22", & wav_fmt->ima.extrabytes, & wav_fmt->ima.samplesperblock);
#line 218
  bytesread += __cil_tmp12;
#line 219
  psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->ima.extrabytes);
  }
#line 220
  if ((int )wav_fmt->ima.samplesperblock < 1) {
    {
#line 221
    psf_log_printf(psf, "  Samples/Block : %d (should be > 0)\n", (int )wav_fmt->ima.samplesperblock);
    }
#line 222
    return (75);
  } else {
    {
#line 225
    psf_log_printf(psf, "  Samples/Block : %d\n", (int )wav_fmt->ima.samplesperblock);
    }
  }
#line 227
  bytespersec = (int )((wav_fmt->ima.samplerate * (unsigned int )wav_fmt->ima.blockalign) / (unsigned int )wav_fmt->ima.samplesperblock);
#line 228
  if (wav_fmt->ima.bytespersec != (unsigned int )bytespersec) {
    {
#line 229
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->ima.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 231
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->ima.bytespersec);
    }
  }
#line 233
  goto switch_break___1;
  case_2: 
#line 236
  if ((int )wav_fmt->msadpcm.bitwidth != 4) {
#line 237
    return (73);
  }
#line 238
  if ((int )wav_fmt->msadpcm.channels < 1) {
#line 239
    return (74);
  } else
#line 238
  if ((int )wav_fmt->msadpcm.channels > 2) {
#line 239
    return (74);
  }
  {
#line 241
  __cil_tmp13 = psf_binheader_readf(psf, "222", & wav_fmt->msadpcm.extrabytes, & wav_fmt->msadpcm.samplesperblock,
                                    & wav_fmt->msadpcm.numcoeffs);
#line 241
  bytesread += __cil_tmp13;
#line 244
  psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->msadpcm.extrabytes);
  }
#line 245
  if ((int )wav_fmt->ima.samplesperblock < 1) {
    {
#line 246
    psf_log_printf(psf, "  Samples/Block : %d (should be > 0)\n", (int )wav_fmt->ima.samplesperblock);
    }
#line 247
    return (75);
  } else {
    {
#line 250
    psf_log_printf(psf, "  Samples/Block : %d\n", (int )wav_fmt->ima.samplesperblock);
    }
  }
#line 252
  bytespersec = (int )((wav_fmt->min.samplerate * (unsigned int )wav_fmt->min.blockalign) / (unsigned int )wav_fmt->msadpcm.samplesperblock);
#line 253
  if (wav_fmt->min.bytespersec == (unsigned int )bytespersec) {
    {
#line 254
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec);
    }
  } else
#line 255
  if (wav_fmt->min.bytespersec == (wav_fmt->min.samplerate / (unsigned int )wav_fmt->msadpcm.samplesperblock) * (unsigned int )wav_fmt->min.blockalign) {
    {
#line 256
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d (MS BUG!))\n", wav_fmt->min.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 258
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec,
                   bytespersec);
    }
  }
#line 260
  if ((int )wav_fmt->msadpcm.numcoeffs > (int )(sizeof(wav_fmt->msadpcm.coeffs) / sizeof(wav_fmt->msadpcm.coeffs[0]))) {
    {
#line 261
    psf_log_printf(psf, "  No. of Coeffs : %d (should be <= %d)\n", (int )wav_fmt->msadpcm.numcoeffs,
                   (int )(sizeof(wav_fmt->msadpcm.coeffs) / sizeof(wav_fmt->msadpcm.coeffs[0])));
#line 262
    wav_fmt->msadpcm.numcoeffs = (unsigned short )((int )(sizeof(wav_fmt->msadpcm.coeffs) / sizeof(wav_fmt->msadpcm.coeffs[0])));
    }
  } else {
    {
#line 265
    psf_log_printf(psf, "  No. of Coeffs : %d\n", (int )wav_fmt->msadpcm.numcoeffs);
    }
  }
  {
#line 267
  psf_log_printf(psf, "    Index   Coeffs1   Coeffs2\n");
#line 268
  k = 0;
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;

#line 268
    if (! (k < (int )wav_fmt->msadpcm.numcoeffs)) {
#line 268
      goto while_break;
    }
    {
#line 271
    __cil_tmp15 = psf_binheader_readf(psf, "22", & wav_fmt->msadpcm.coeffs[k].coeff1,
                                      & wav_fmt->msadpcm.coeffs[k].coeff2);
#line 271
    bytesread += __cil_tmp15;
#line 273
    snprintf(buffer, sizeof(buffer), "     %2d     %7d   %7d\n", k, (int )wav_fmt->msadpcm.coeffs[k].coeff1,
             (int )wav_fmt->msadpcm.coeffs[k].coeff2);
#line 274
    psf_log_printf(psf, (char const   *)(buffer));
#line 268
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 276
  goto switch_break___1;
  case_49___1: 
#line 279
  if ((int )wav_fmt->gsm610.channels != 1) {
#line 280
    return (76);
  } else
#line 279
  if ((int )wav_fmt->gsm610.blockalign != 65) {
#line 280
    return (76);
  }
  {
#line 282
  __cil_tmp17 = psf_binheader_readf(psf, "22", & wav_fmt->gsm610.extrabytes, & wav_fmt->gsm610.samplesperblock);
#line 282
  bytesread += __cil_tmp17;
  }
#line 285
  if ((int )wav_fmt->gsm610.samplesperblock != 320) {
#line 286
    return (76);
  }
#line 288
  bytespersec = (int )((wav_fmt->gsm610.samplerate * (unsigned int )wav_fmt->gsm610.blockalign) / (unsigned int )wav_fmt->gsm610.samplesperblock);
#line 289
  if (wav_fmt->gsm610.bytespersec != (unsigned int )bytespersec) {
    {
#line 290
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->gsm610.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 292
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->gsm610.bytespersec);
    }
  }
  {
#line 294
  psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->gsm610.extrabytes);
#line 295
  psf_log_printf(psf, "  Samples/Block : %d\n", (int )wav_fmt->gsm610.samplesperblock);
  }
#line 296
  goto switch_break___1;
  case_65534: 
#line 299
  if (wav_fmt->ext.bytespersec != wav_fmt->ext.samplerate * (unsigned int )wav_fmt->ext.blockalign) {
    {
#line 300
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->ext.bytespersec,
                   wav_fmt->ext.samplerate * (unsigned int )wav_fmt->ext.blockalign);
    }
  } else {
    {
#line 302
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->ext.bytespersec);
    }
  }
  {
#line 304
  __cil_tmp18 = psf_binheader_readf(psf, "224", & wav_fmt->ext.extrabytes, & wav_fmt->ext.validbits,
                                    & wav_fmt->ext.channelmask);
#line 304
  bytesread += __cil_tmp18;
#line 308
  psf_log_printf(psf, "  Valid Bits    : %d\n", (int )wav_fmt->ext.validbits);
  }
#line 310
  if (wav_fmt->ext.channelmask == 0U) {
    {
#line 311
    psf_log_printf(psf, "  Channel Mask  : 0x0 (should not be zero)\n");
    }
  } else {
    {
#line 316
    wpriv->wavex_channelmask = wav_fmt->ext.channelmask;
#line 319
    free((void *)psf->channel_map);
#line 321
    tmp___3 = calloc((unsigned long )psf->sf.channels, sizeof(*(psf->channel_map + 0)));
#line 321
    psf->channel_map = (int *)tmp___3;
    }
#line 321
    if ((unsigned long )psf->channel_map == (unsigned long )((void *)0)) {
#line 322
      return (17);
    }
#line 325
    buffer___0[0] = (char)0;
#line 327
    k = 0;
#line 327
    bit = (unsigned int )k;
    {
#line 327
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 327
      if (bit < (unsigned int )((int )(sizeof(channel_mask_bits) / sizeof(channel_mask_bits[0])))) {
#line 327
        if (! (k < psf->sf.channels)) {
#line 327
          goto while_break___0;
        }
      } else {
#line 327
        goto while_break___0;
      }
#line 329
      if (wav_fmt->ext.channelmask & (unsigned int )(1 << bit)) {
#line 330
        if (k > psf->sf.channels) {
          {
#line 331
          psf_log_printf(psf, "*** More channel map bits than there are channels.\n");
          }
#line 332
          goto while_break___0;
        }
        {
#line 335
        __cil_tmp22 = k;
#line 335
        k ++;
#line 335
        *(psf->channel_map + __cil_tmp22) = channel_mask_bits[bit].id;
#line 336
        append_snprintf(buffer___0, sizeof(buffer___0), "%s, ", channel_mask_bits[bit].name);
        }
      }
#line 327
      bit ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 341
    __cil_tmp24 = strlen((char const   *)(buffer___0));
#line 341
    bit = (unsigned int )__cil_tmp24;
    }
#line 342
    if (bit >= 2U) {
#line 343
      bit --;
#line 343
      buffer___0[bit] = (char)0;
#line 344
      bit --;
#line 344
      buffer___0[bit] = (char)0;
    }
#line 347
    if (k != psf->sf.channels) {
      {
#line 348
      psf_log_printf(psf, "  Channel Mask  : 0x%X\n", wav_fmt->ext.channelmask);
#line 349
      psf_log_printf(psf, "*** Less channel map bits than there are channels.\n");
      }
    } else {
      {
#line 352
      psf_log_printf(psf, "  Channel Mask  : 0x%X (%s)\n", wav_fmt->ext.channelmask,
                     buffer___0);
      }
    }
  }
  {
#line 355
  __cil_tmp25 = psf_binheader_readf(psf, "422", & wav_fmt->ext.esf.esf_field1, & wav_fmt->ext.esf.esf_field2,
                                    & wav_fmt->ext.esf.esf_field3);
#line 355
  bytesread += __cil_tmp25;
#line 358
  psf_log_printf(psf, "  Subformat\n");
#line 359
  psf_log_printf(psf, "    esf_field1 : 0x%X\n", wav_fmt->ext.esf.esf_field1);
#line 360
  psf_log_printf(psf, "    esf_field2 : 0x%X\n", (int )wav_fmt->ext.esf.esf_field2);
#line 361
  psf_log_printf(psf, "    esf_field3 : 0x%X\n", (int )wav_fmt->ext.esf.esf_field3);
#line 362
  psf_log_printf(psf, "    esf_field4 : ");
#line 363
  k = 0;
  }
  {
#line 363
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 363
    if (! (k < 8)) {
#line 363
      goto while_break___1;
    }
    {
#line 364
    __cil_tmp26 = psf_binheader_readf(psf, "1", & wav_fmt->ext.esf.esf_field4[k]);
#line 364
    bytesread += __cil_tmp26;
#line 365
    psf_log_printf(psf, "0x%X ", (int )wav_fmt->ext.esf.esf_field4[k] & 255);
#line 363
    k ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 367
  psf_log_printf(psf, "\n");
#line 368
  psf->bytewidth = ((int )wav_fmt->ext.bitwidth + 7) / 8;
#line 371
  __cil_tmp28 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_PCM___1);
  }
#line 371
  if (__cil_tmp28) {
    {
#line 372
    __cil_tmp29 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 372
    psf->sf.format = 1245184 | __cil_tmp29;
#line 373
    psf_log_printf(psf, "    format : pcm\n");
    }
  } else {
    {
#line 375
    __cil_tmp30 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_MS_ADPCM___1);
    }
#line 375
    if (__cil_tmp30) {
      {
#line 376
      psf->sf.format = 1245203;
#line 377
      psf_log_printf(psf, "    format : ms adpcm\n");
      }
    } else {
      {
#line 379
      __cil_tmp31 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_IEEE_FLOAT___1);
      }
#line 379
      if (__cil_tmp31) {
#line 380
        if (psf->bytewidth == 8) {
#line 380
          tmp___0 = 7;
        } else {
#line 380
          tmp___0 = 6;
        }
        {
#line 380
        psf->sf.format = 1245184 | tmp___0;
#line 381
        psf_log_printf(psf, "    format : IEEE float\n\220");
        }
      } else {
        {
#line 383
        __cil_tmp33 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_ALAW___1);
        }
#line 383
        if (__cil_tmp33) {
          {
#line 384
          psf->sf.format = 1245201;
#line 385
          psf_log_printf(psf, "    format : A-law\n");
          }
        } else {
          {
#line 387
          __cil_tmp34 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_MULAW___1);
          }
#line 387
          if (__cil_tmp34) {
            {
#line 388
            psf->sf.format = 1245200;
#line 389
            psf_log_printf(psf, "    format : u-law\n");
            }
          } else {
            {
#line 391
            __cil_tmp35 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___1);
            }
#line 391
            if (__cil_tmp35) {
              {
#line 392
              __cil_tmp36 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 392
              psf->sf.format = 1245184 | __cil_tmp36;
#line 393
              psf_log_printf(psf, "    format : pcm (Ambisonic B)\n");
#line 394
              wpriv->wavex_ambisonic = 65;
              }
            } else {
              {
#line 396
              __cil_tmp37 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___1);
              }
#line 396
              if (__cil_tmp37) {
#line 397
                if (psf->bytewidth == 8) {
#line 397
                  tmp___1 = 7;
                } else {
#line 397
                  tmp___1 = 6;
                }
                {
#line 397
                psf->sf.format = 1245184 | tmp___1;
#line 398
                psf_log_printf(psf, "    format : IEEE float (Ambisonic B)\n");
#line 399
                wpriv->wavex_ambisonic = 65;
                }
              } else {
#line 402
                return (18);
              }
            }
          }
        }
      }
    }
  }
#line 404
  goto switch_break___1;
  case_64: 
  {
#line 407
  psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->g72x.bytespersec);
  }
#line 408
  if (fmtsize >= 20) {
    {
#line 409
    __cil_tmp39 = psf_binheader_readf(psf, "22", & wav_fmt->g72x.extrabytes, & wav_fmt->g72x.auxblocksize);
#line 409
    bytesread += __cil_tmp39;
    }
#line 410
    if ((int )wav_fmt->g72x.extrabytes == 0) {
      {
#line 411
      psf_log_printf(psf, "  Extra Bytes   : %d (should be 2)\n", (int )wav_fmt->g72x.extrabytes);
      }
    } else {
      {
#line 413
      psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->g72x.extrabytes);
      }
    }
    {
#line 414
    psf_log_printf(psf, "  Aux Blk Size  : %d\n", (int )wav_fmt->g72x.auxblocksize);
    }
  } else
#line 416
  if (fmtsize == 18) {
    {
#line 417
    __cil_tmp40 = psf_binheader_readf(psf, "2", & wav_fmt->g72x.extrabytes);
#line 417
    bytesread += __cil_tmp40;
    }
#line 418
    if ((int )wav_fmt->g72x.extrabytes != 0) {
#line 418
      tmp___2 = " (should be 0)";
    } else {
#line 418
      tmp___2 = "\220";
    }
    {
#line 418
    psf_log_printf(psf, "  Extra Bytes   : %d%s\n", (int )wav_fmt->g72x.extrabytes,
                   tmp___2);
    }
  } else {
    {
#line 421
    psf_log_printf(psf, "*** \'fmt \' chunk should be bigger than this!\n");
    }
  }
#line 422
  goto switch_break___1;
  switch_default___1: 
  {
#line 425
  psf_log_printf(psf, "*** No \'fmt \' chunk dumper for this format!\n");
  }
#line 426
  return (64);
  switch_break___1: ;
#line 429
  if (bytesread > fmtsize) {
    {
#line 430
    psf_log_printf(psf, "*** wav_w64_read_fmt_chunk (bytesread > fmtsize)\n");
    }
#line 431
    return (64);
  } else {
    {
#line 434
    psf_binheader_readf(psf, "j", fmtsize - bytesread);
    }
  }
#line 436
  psf->blockwidth = (int )wav_fmt->min.channels * psf->bytewidth;
#line 438
  return (0);
}
}
#line 442 "/root/patchweave_donee/23/src/wav_w64.c"
void wavex_write_guid(SF_PRIVATE *psf , EXT_SUBFORMAT *subformat ) 
{ 
  size_t __cil_tmp3 ;

  {
  {
#line 444
  __cil_tmp3 = make_size_t(8);
#line 444
  psf_binheader_writef(psf, "422b", subformat->esf_field1, (int )subformat->esf_field2,
                       (int )subformat->esf_field3, (char const   *)(subformat->esf_field4),
                       __cil_tmp3);
  }
#line 448
  return;
}
}
#line 451 "/root/patchweave_donee/23/src/wav_w64.c"
int wavex_gen_channel_mask(int const   *chan_map , int channels ) 
{ 
  int chan ;
  int mask ;
  int bit ;
  int last_bit ;
  int k ;

  {
#line 452
  mask = 0;
#line 452
  bit = -1;
#line 452
  last_bit = -1;
#line 454
  if ((unsigned long )chan_map == (unsigned long )((void *)0)) {
#line 455
    return (0);
  }
#line 457
  chan = 0;
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;

#line 457
    if (! (chan < channels)) {
#line 457
      goto while_break;
    }
#line 460
    k = bit + 1;
    {
#line 460
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 460
      if (! (k < (int )(sizeof(channel_mask_bits) / sizeof(channel_mask_bits[0])))) {
#line 460
        goto while_break___0;
      }
#line 461
      if (*(chan_map + chan) == (int const   )channel_mask_bits[k].id) {
#line 462
        bit = k;
#line 463
        goto while_break___0;
      }
#line 460
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 467
    if (bit <= last_bit) {
#line 468
      return (0);
    }
#line 470
    mask += 1 << bit;
#line 471
    last_bit = bit;
#line 457
    chan ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 474
  return (mask);
}
}
#line 478 "/root/patchweave_donee/23/src/wav_w64.c"
void wav_w64_analyze(SF_PRIVATE *psf ) 
{ 
  unsigned char buffer[4096] ;
  AUDIO_DETECT ad ;
  int format ;
  sf_count_t __cil_tmp5 ;

  {
#line 481
  format = 0;
#line 483
  if (psf->is_pipe) {
    {
#line 484
    psf_log_printf(psf, "*** Error : Reading from a pipe. Can\'t analyze data section to figure out real data format.\n\nU");
    }
#line 485
    return;
  }
  {
#line 488
  psf_log_printf(psf, "---------------------------------------------------\nFormat is known to be broken. Using detection code.\n");
#line 492
  ad.endianness = 268435456;
#line 493
  ad.channels = psf->sf.channels;
#line 495
  psf_fseek(psf, (sf_count_t )600, 0);
  }
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 497
    __cil_tmp5 = psf_fread((void *)(buffer), (sf_count_t )1, (sf_count_t )sizeof(buffer),
                           psf);
    }
#line 497
    if (! ((unsigned long )__cil_tmp5 == sizeof(buffer))) {
#line 497
      goto while_break;
    }
    {
#line 498
    format = audio_detect(psf, & ad, (unsigned char const   *)(buffer), (int )sizeof(buffer));
    }
#line 499
    if (format != 0) {
#line 500
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 504
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 506
  if (format == 0) {
    {
#line 507
    psf_log_printf(psf, "wav_w64_analyze : detection failed.\n");
    }
#line 508
    return;
  }
#line 513
  if (format == 6) {
#line 513
    goto case_6;
  }
#line 513
  if (format == 4) {
#line 513
    goto case_6;
  }
#line 520
  if (format == 3) {
#line 520
    goto case_3;
  }
#line 527
  goto switch_default;
  case_6: 
  {
#line 514
  psf_log_printf(psf, "wav_w64_analyze : found format : 0x%X\n", format);
#line 515
  psf->sf.format = (psf->sf.format & -65536) + format;
#line 516
  psf->bytewidth = 4;
#line 517
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
  }
#line 518
  goto switch_break;
  case_3: 
  {
#line 521
  psf_log_printf(psf, "wav_w64_analyze : found format : 0x%X\n", format);
#line 522
  psf->sf.format = (psf->sf.format & -65536) + format;
#line 523
  psf->bytewidth = 3;
#line 524
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
  }
#line 525
  goto switch_break;
  switch_default: 
  {
#line 528
  psf_log_printf(psf, "wav_w64_analyze : unhandled format : 0x%X\nJ\330\204U", format);
  }
#line 529
  goto switch_break;
  switch_break: ;
#line 532
  return;
}
}
#line 546 "/root/patchweave_donee/23/src/wav_w64.c"
static WAV_FORMAT_DESC wave_descs[106]  = 
#line 546
  {      {1, "WAVE_FORMAT_PCM"}, 
        {2, "WAVE_FORMAT_MS_ADPCM"}, 
        {3, "WAVE_FORMAT_IEEE_FLOAT"}, 
        {4, "WAVE_FORMAT_VSELP"}, 
        {5, "WAVE_FORMAT_IBM_CVSD\204U"}, 
        {6, "WAVE_FORMAT_ALAW\370 J\330\204U"}, 
        {7, "WAVE_FORMAT_MULAW"}, 
        {16, "WAVE_FORMAT_OKI_ADPCM"}, 
        {17, "WAVE_FORMAT_IMA_ADPCMU"}, 
        {18, "WAVE_FORMAT_MEDIASPACE_ADPCM"}, 
        {19, "WAVE_FORMAT_SIERRA_ADPCM\250"}, 
        {20, "WAVE_FORMAT_G723_ADPCM"}, 
        {21, "WAVE_FORMAT_DIGISTD"}, 
        {22, "WAVE_FORMAT_DIGIFIX"}, 
        {23, "WAVE_FORMAT_DIALOGIC_OKI_ADPCM"}, 
        {24, "WAVE_FORMAT_MEDIAVISION_ADPCMU"}, 
        {25, "WAVE_FORMAT_CU_CODEC\204U"}, 
        {32, "WAVE_FORMAT_YAMAHA_ADPCM\250"}, 
        {33, "WAVE_FORMAT_SONARCJ\330\204U"}, 
        {34, "WAVE_FORMAT_DSPGROUP_TRUESPEECH"}, 
        {35, "WAVE_FORMAT_ECHOSC1"}, 
        {36, "WAVE_FORMAT_AUDIOFILE_AF36"}, 
        {37, "WAVE_FORMAT_APTX\250"}, 
        {38, "WAVE_FORMAT_AUDIOFILE_AF10"}, 
        {39, "WAVE_FORMAT_PROSODY_1612\250"}, 
        {40, "WAVE_FORMAT_LRC"}, 
        {48, "WAVE_FORMAT_DOLBY_AC2"}, 
        {49, "WAVE_FORMAT_GSM610I\330\204U"}, 
        {50, "WAVE_FORMAT_MSNAUDIO\204U"}, 
        {51, "WAVE_FORMAT_ANTEX_ADPCME\250"}, 
        {52, "WAVE_FORMAT_CONTROL_RES_VQLPC"}, 
        {53, "WAVE_FORMAT_DIGIREAL"}, 
        {54, "WAVE_FORMAT_DIGIADPCM"}, 
        {55, "WAVE_FORMAT_CONTROL_RES_CR10"}, 
        {56, "WAVE_FORMAT_NMS_VBXADPCM\250"}, 
        {57, "WAVE_FORMAT_ROLAND_RDAC"}, 
        {58, "WAVE_FORMAT_ECHOSC3\330\204U"}, 
        {59, "WAVE_FORMAT_ROCKWELL_ADPCM"}, 
        {60, "WAVE_FORMAT_ROCKWELL_DIGITALKU"}, 
        {61, "WAVE_FORMAT_XEBEC\226I\330\204U"}, 
        {64, "WAVE_FORMAT_G721_ADPCM"}, 
        {65, "WAVE_FORMAT_G728_CELPU"}, 
        {66, "WAVE_FORMAT_MSG723I\330\204U"}, 
        {80, "WAVE_FORMAT_MPEG\250"}, 
        {82, "WAVE_FORMAT_RT24\250"}, 
        {83, "WAVE_FORMAT_PAC"}, 
        {85, "WAVE_FORMAT_MPEGLAYER3"}, 
        {89, "WAVE_FORMAT_LUCENT_G723"}, 
        {96, "WAVE_FORMAT_CIRRUS"}, 
        {97, "WAVE_FORMAT_ESPCM"}, 
        {98, "WAVE_FORMAT_VOXWARE"}, 
        {99, "WAVE_FORMAT_CANOPUS_ATRAC"}, 
        {100, "WAVE_FORMAT_G726_ADPCM"}, 
        {101, "WAVE_FORMAT_G722_ADPCM"}, 
        {102, "WAVE_FORMAT_DSAT\250"}, 
        {103, "WAVE_FORMAT_DSAT_DISPLAY\250"}, 
        {105, "WAVE_FORMAT_VOXWARE_BYTE_ALIGNED\250"}, 
        {112, "WAVE_FORMAT_VOXWARE_AC8"}, 
        {113, "WAVE_FORMAT_VOXWARE_AC10\250"}, 
        {114, "WAVE_FORMAT_VOXWARE_AC16\250"}, 
        {115, "WAVE_FORMAT_VOXWARE_AC20\250"}, 
        {116, "WAVE_FORMAT_VOXWARE_RT24\250"}, 
        {117, "WAVE_FORMAT_VOXWARE_RT29\250"}, 
        {118, "WAVE_FORMAT_VOXWARE_RT29HW"}, 
        {119, "WAVE_FORMAT_VOXWARE_VR12\250"}, 
        {120, "WAVE_FORMAT_VOXWARE_VR18\250"}, 
        {121, "WAVE_FORMAT_VOXWARE_TQ40\250"}, 
        {128, "WAVE_FORMAT_SOFTSOUND"}, 
        {129, "WAVE_FORMAT_VOXARE_TQ60"}, 
        {130, "WAVE_FORMAT_MSRT24"}, 
        {131, "WAVE_FORMAT_G729A"}, 
        {132, "WAVE_FORMAT_MVI_MV12"}, 
        {133, "WAVE_FORMAT_DF_G726\330\204U"}, 
        {134, "WAVE_FORMAT_DF_GSM610U"}, 
        {137, "WAVE_FORMAT_ONLIVEI\330\204U"}, 
        {145, "WAVE_FORMAT_SBC24\204I\330\204U"}, 
        {146, "WAVE_FORMAT_DOLBY_AC3_SPDIF"}, 
        {151, "WAVE_FORMAT_ZYXEL_ADPCM"}, 
        {152, "WAVE_FORMAT_PHILIPS_LPCBB\210I\330\204U"}, 
        {153, "WAVE_FORMAT_PACKED"}, 
        {256, "WAVE_FORMAT_RHETOREX_ADPCM"}, 
        {257, "IBM_FORMAT_MULAW\250"}, 
        {258, "IBM_FORMAT_ALAW"}, 
        {259, "IBM_FORMAT_ADPCM\250"}, 
        {273, "WAVE_FORMAT_VIVO_G723"}, 
        {274, "WAVE_FORMAT_VIVO_SIREN"}, 
        {291, "WAVE_FORMAT_DIGITAL_G723\250"}, 
        {512, "WAVE_FORMAT_CREATIVE_ADPCM"}, 
        {514, "WAVE_FORMAT_CREATIVE_FASTSPEECH8\250"}, 
        {515, "WAVE_FORMAT_CREATIVE_FASTSPEECH10"}, 
        {544, "WAVE_FORMAT_QUARTERDECK"}, 
        {768, "WAVE_FORMAT_FM_TOWNS_SND\250"}, 
        {1024, "WAVE_FORMAT_BZV_DIGITAL"}, 
        {1664, "WAVE_FORMAT_VME_VMPCMU"}, 
        {4096, "WAVE_FORMAT_OLIGSMI\330\204U"}, 
        {4097, "WAVE_FORMAT_OLIADPCM\204U"}, 
        {4098, "WAVE_FORMAT_OLICELP"}, 
        {4099, "WAVE_FORMAT_OLISBC\b\330\204U"}, 
        {4100, "WAVE_FORMAT_OLIOPR"}, 
        {4352, "WAVE_FORMAT_LH_CODEC\204U"}, 
        {5120, "WAVE_FORMAT_NORRISI\330\204U"}, 
        {5376, "WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS"}, 
        {8192, "WAVE_FORMAT_DVM"}, 
        {29008, "WAVE_FORMAT_INTERWAV_VSC112"}, 
        {29232, "WAVE_FORMAT_IPP_ITU_G_723_1"}, 
        {65534, "WAVE_FORMAT_EXTENSIBLE"}};
#line 656 "/root/patchweave_donee/23/src/wav_w64.c"
char const   *wav_w64_format_str(int k ) 
{ 
  int lower ;
  int upper ;
  int mid ;

  {
#line 659
  lower = -1;
#line 660
  upper = (int )(sizeof(wave_descs) / sizeof(WAV_FORMAT_DESC ));
#line 663
  if (wave_descs[0].ID <= k) {
#line 663
    if (k <= wave_descs[upper - 1].ID) {
      {
#line 665
      while (1) {
        while_continue: /* CIL Label */ ;

#line 665
        if (! (lower + 1 < upper)) {
#line 665
          goto while_break;
        }
#line 666
        mid = (upper + lower) / 2;
#line 668
        if (k == wave_descs[mid].ID) {
#line 669
          return (wave_descs[mid].name);
        }
#line 670
        if (k < wave_descs[mid].ID) {
#line 671
          upper = mid;
        } else {
#line 673
          lower = mid;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 677
  return ("Unknown format");
}
}
#line 681 "/root/patchweave_donee/23/src/wav_w64.c"
int wav_w64_srate2blocksize(int srate_chan_product ) 
{ 


  {
#line 682
  if (srate_chan_product < 12000) {
#line 683
    return (256);
  }
#line 684
  if (srate_chan_product < 23000) {
#line 685
    return (512);
  }
#line 686
  if (srate_chan_product < 44000) {
#line 687
    return (1024);
  }
#line 688
  return (2048);
}
}
#line 87 "/root/patchweave_donee/23/src/w64.c"
static unsigned char riff_MARKER16[16]  = 
#line 87 "/root/patchweave_donee/23/src/w64.c"
  {      (unsigned char )'r',      (unsigned char )'i',      (unsigned char )'f',      (unsigned char )'f', 
        (unsigned char)46,      (unsigned char)145,      (unsigned char)207,      (unsigned char)17, 
        (unsigned char)165,      (unsigned char)214,      (unsigned char)40,      (unsigned char)219, 
        (unsigned char)4,      (unsigned char)193,      (unsigned char)0,      (unsigned char)0};
#line 91 "/root/patchweave_donee/23/src/w64.c"
static unsigned char wave_MARKER16[16]  = 
#line 91
  {      (unsigned char )'w',      (unsigned char )'a',      (unsigned char )'v',      (unsigned char )'e', 
        (unsigned char)243,      (unsigned char)172,      (unsigned char)211,      (unsigned char)17, 
        (unsigned char)140,      (unsigned char)209,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)79,      (unsigned char)142,      (unsigned char)219,      (unsigned char)138};
#line 94 "/root/patchweave_donee/23/src/w64.c"
static unsigned char fmt_MARKER16[16]  = 
#line 94
  {      (unsigned char )'f',      (unsigned char )'m',      (unsigned char )'t',      (unsigned char )' ', 
        (unsigned char)243,      (unsigned char)172,      (unsigned char)211,      (unsigned char)17, 
        (unsigned char)140,      (unsigned char)209,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)79,      (unsigned char)142,      (unsigned char)219,      (unsigned char)138};
#line 97 "/root/patchweave_donee/23/src/w64.c"
static unsigned char fact_MARKER16[16]  = 
#line 97
  {      (unsigned char )'f',      (unsigned char )'a',      (unsigned char )'c',      (unsigned char )'t', 
        (unsigned char)243,      (unsigned char)172,      (unsigned char)211,      (unsigned char)17, 
        (unsigned char)140,      (unsigned char)209,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)79,      (unsigned char)142,      (unsigned char)219,      (unsigned char)138};
#line 100 "/root/patchweave_donee/23/src/w64.c"
static unsigned char data_MARKER16[16]  = 
#line 100
  {      (unsigned char )'d',      (unsigned char )'a',      (unsigned char )'t',      (unsigned char )'a', 
        (unsigned char)243,      (unsigned char)172,      (unsigned char)211,      (unsigned char)17, 
        (unsigned char)140,      (unsigned char)209,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)79,      (unsigned char)142,      (unsigned char)219,      (unsigned char)138};
#line 115
static int w64_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) ;
#line 116
static int w64_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 117
static int w64_close(SF_PRIVATE *psf ) ;
#line 124 "/root/patchweave_donee/23/src/w64.c"
int w64_open(SF_PRIVATE *psf ) 
{ 
  WAV_PRIVATE *wpriv ;
  int subformat ;
  int error ;
  int blockalign ;
  int framesperblock ;
  sf_count_t tmp ;
  void *tmp___0 ;

  {
  {
#line 126
  blockalign = 0;
#line 126
  framesperblock = 0;
#line 128
  tmp___0 = calloc(1UL, sizeof(WAV_PRIVATE ));
#line 128
  wpriv = (WAV_PRIVATE *)tmp___0;
  }
#line 128
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 129
    return (17);
  }
#line 130
  psf->container_data = (void *)wpriv;
#line 132
  if (psf->file.mode == 16) {
    _L: 
    {
#line 133
    error = w64_read_header(psf, & blockalign, & framesperblock);
    }
#line 133
    if (error) {
#line 134
      return (error);
    }
  } else
#line 132
  if (psf->file.mode == 48) {
#line 132
    if (psf->filelength > 0L) {
#line 132
      goto _L;
    }
  }
#line 137
  if ((psf->sf.format & 268369920) != 720896) {
#line 138
    return (1);
  }
#line 140
  subformat = psf->sf.format & 65535;
#line 142
  if (psf->file.mode == 32) {
    _L___20: 
#line 143
    if (psf->is_pipe) {
#line 144
      return (29);
    }
#line 146
    psf->endian = 268435456;
#line 148
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 150
    if (subformat == 18) {
      _L___19: 
      {
#line 151
      blockalign = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 152
      framesperblock = -1;
#line 158
      psf->filelength = (sf_count_t )-10001LL;
#line 159
      psf->datalength = psf->filelength;
      }
#line 160
      if (psf->sf.frames <= 0L) {
#line 161
        if (psf->blockwidth) {
#line 161
          tmp = psf->filelength / (long )psf->blockwidth;
        } else {
#line 161
          tmp = psf->filelength;
        }
#line 161
        psf->sf.frames = tmp;
      }
    } else
#line 150
    if (subformat == 19) {
#line 150
      goto _L___19;
    }
    {
#line 164
    error = w64_write_header(psf, 0);
    }
#line 164
    if (error) {
#line 165
      return (error);
    }
#line 167
    psf->write_header = & w64_write_header;
  } else
#line 142
  if (psf->file.mode == 48) {
#line 142
    goto _L___20;
  }
#line 170
  psf->container_close = & w64_close;
#line 173
  if (subformat == 5) {
#line 173
    goto case_5;
  }
#line 179
  if (subformat == 4) {
#line 179
    goto case_4;
  }
#line 179
  if (subformat == 3) {
#line 179
    goto case_4;
  }
#line 179
  if (subformat == 2) {
#line 179
    goto case_4;
  }
#line 183
  if (subformat == 16) {
#line 183
    goto case_16;
  }
#line 187
  if (subformat == 17) {
#line 187
    goto case_17;
  }
#line 192
  if (subformat == 6) {
#line 192
    goto case_6;
  }
#line 196
  if (subformat == 7) {
#line 196
    goto case_7;
  }
#line 200
  if (subformat == 18) {
#line 200
    goto case_18;
  }
#line 204
  if (subformat == 19) {
#line 204
    goto case_19;
  }
#line 209
  if (subformat == 32) {
#line 209
    goto case_32;
  }
#line 213
  goto switch_default;
  case_5: 
  {
#line 174
  error = pcm_init(psf);
  }
#line 175
  goto switch_break;
  case_4: 
  {
#line 180
  error = pcm_init(psf);
  }
#line 181
  goto switch_break;
  case_16: 
  {
#line 184
  error = ulaw_init(psf);
  }
#line 185
  goto switch_break;
  case_17: 
  {
#line 188
  error = alaw_init(psf);
  }
#line 189
  goto switch_break;
  case_6: 
  {
#line 193
  error = float32_init(psf);
  }
#line 194
  goto switch_break;
  case_7: 
  {
#line 197
  error = double64_init(psf);
  }
#line 198
  goto switch_break;
  case_18: 
  {
#line 201
  error = wav_w64_ima_init(psf, blockalign, framesperblock);
  }
#line 202
  goto switch_break;
  case_19: 
  {
#line 205
  error = wav_w64_msadpcm_init(psf, blockalign, framesperblock);
  }
#line 206
  goto switch_break;
  case_32: 
  {
#line 210
  error = gsm610_init(psf);
  }
#line 211
  goto switch_break;
  switch_default: 
#line 213
  return (18);
  switch_break: ;
#line 216
  return (error);
}
}
#line 224 "/root/patchweave_donee/23/src/w64.c"
static int w64_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) 
{ 
  WAV_PRIVATE *wpriv ;
  WAV_FMT *wav_fmt ;
  int dword ;
  int marker ;
  int format ;
  sf_count_t chunk_size ;
  sf_count_t bytesread ;
  int parsestage ;
  int error ;
  int done ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  sf_count_t frames ;
  sf_count_t __cil_tmp19 ;
  sf_count_t __cil_tmp20 ;
  sf_count_t __cil_tmp21 ;
  int __cil_tmp22 ;
  int tmp ;

  {
#line 227
  dword = 0;
#line 227
  format = 0;
#line 228
  bytesread = (sf_count_t )0;
#line 229
  parsestage = 0;
#line 229
  done = 0;
#line 231
  wpriv = (WAV_PRIVATE *)psf->container_data;
#line 231
  if ((unsigned long )wpriv == (unsigned long )((void *)0)) {
#line 232
    return (30);
  }
  {
#line 233
  wav_fmt = & wpriv->wav_fmt;
#line 236
  psf_binheader_readf(psf, "p(i\330\204U", 0);
  }
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;

#line 238
    if (! (! done)) {
#line 238
      goto while_break;
    }
#line 240
    if (psf->headindex & 7) {
      {
#line 241
      psf_binheader_readf(psf, "j", 8 - (psf->headindex & 7));
      }
    }
    {
#line 244
    chunk_size = (sf_count_t )0;
#line 244
    marker = (int )chunk_size;
#line 245
    __cil_tmp14 = psf_binheader_readf(psf, "eh8", & marker, & chunk_size);
#line 245
    bytesread = (sf_count_t )__cil_tmp14;
    }
#line 246
    if (bytesread == 0L) {
#line 247
      goto while_break;
    }
#line 249
    if (marker == (((((((((((((114 ^ (105 << 1)) ^ (102 << 2)) ^ (102 << 3)) ^ (46 << 4)) ^ (145 << 5)) ^ (207 << 6)) ^ (17 << 7)) ^ (165 << 8)) ^ (214 << 9)) ^ (40 << 10)) ^ (219 << 11)) ^ (4 << 12)) ^ (193 << 13))) {
#line 249
      goto case_exp;
    }
#line 270
    if (marker == (((((((((((((((109 ^ (7 << 1)) ^ (28 << 2)) ^ (234 << 3)) ^ (163 << 4)) ^ (239 << 5)) ^ (120 << 6)) ^ (76 << 7)) ^ (144 << 8)) ^ (87 << 9)) ^ (127 << 10)) ^ (121 << 11)) ^ (238 << 12)) ^ (37 << 13)) ^ (42 << 14)) ^ (174 << 15))) {
#line 270
      goto case_exp___0;
    }
#line 274
    if (marker == ((((((((((((((102 ^ (109 << 1)) ^ (116 << 2)) ^ (32 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 274
      goto case_exp___1;
    }
#line 294
    if (marker == ((((((((((((((102 ^ (97 << 1)) ^ (99 << 2)) ^ (116 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 294
      goto case_exp___2;
    }
#line 305
    if (marker == ((((((((((((((100 ^ (97 << 1)) ^ (116 << 2)) ^ (97 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 305
      goto case_exp___3;
    }
#line 327
    if (marker == ((((((((((((((108 ^ (101 << 1)) ^ (118 << 2)) ^ (108 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (209 << 8)) ^ (140 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 327
      goto case_exp___4;
    }
#line 332
    if (marker == (((((((((((((108 ^ (105 << 1)) ^ (115 << 2)) ^ (116 << 3)) ^ (47 << 4)) ^ (145 << 5)) ^ (207 << 6)) ^ (17 << 7)) ^ (165 << 8)) ^ (214 << 9)) ^ (40 << 10)) ^ (219 << 11)) ^ (4 << 12)) ^ (193 << 13))) {
#line 332
      goto case_exp___5;
    }
#line 337
    if (marker == ((((((((((((((106 ^ (117 << 1)) ^ (110 << 2)) ^ (107 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 337
      goto case_exp___6;
    }
#line 342
    if (marker == ((((((((((((((98 ^ (101 << 1)) ^ (120 << 2)) ^ (116 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (170 << 7)) ^ (209 << 8)) ^ (140 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 342
      goto case_exp___7;
    }
#line 347
    if (marker == ((((((((((((((86 ^ (98 << 1)) ^ (247 << 2)) ^ (171 << 3)) ^ (45 << 4)) ^ (57 << 5)) ^ (210 << 6)) ^ (17 << 7)) ^ (134 << 8)) ^ (199 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 347
      goto case_exp___8;
    }
#line 352
    if (marker == ((((((((((((((188 ^ (148 << 1)) ^ (95 << 2)) ^ (146 << 3)) ^ (90 << 4)) ^ (82 << 5)) ^ (210 << 6)) ^ (17 << 7)) ^ (134 << 8)) ^ (220 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 352
      goto case_exp___9;
    }
#line 357
    goto switch_default;
    case_exp: 
#line 250
    if (parsestage) {
#line 251
      return (124);
    }
#line 253
    if (psf->filelength != chunk_size) {
      {
#line 254
      psf_log_printf(psf, "riff : %D (should be %D)\n", chunk_size, psf->filelength);
      }
    } else {
      {
#line 256
      psf_log_printf(psf, "riff : %D\n", chunk_size);
      }
    }
    {
#line 258
    parsestage |= 1;
#line 260
    __cil_tmp15 = psf_binheader_readf(psf, "h\342h\330\204U", & marker);
#line 260
    bytesread += (long )__cil_tmp15;
    }
#line 261
    if (marker == ((((((((((((((119 ^ (97 << 1)) ^ (118 << 2)) ^ (101 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 262
      if ((parsestage & 1) != 1) {
#line 263
        return (125);
      }
      {
#line 264
      psf_log_printf(psf, "wave\n");
#line 265
      parsestage |= 2;
      }
    }
#line 267
    chunk_size = (sf_count_t )0;
#line 268
    goto switch_break;
    case_exp___0: 
    {
#line 271
    psf_log_printf(psf, "Looks like an ACID file. Exiting.\n");
    }
#line 272
    return (18);
    case_exp___1: 
#line 275
    if ((parsestage & 3) != 3) {
#line 276
      return (63);
    }
    {
#line 278
    psf_log_printf(psf, " fmt : %D\n", chunk_size);
#line 281
    chunk_size -= 24L;
#line 283
    error = wav_w64_read_fmt_chunk(psf, (int )chunk_size);
    }
#line 283
    if (error) {
#line 284
      return (error);
    }
#line 286
    if (chunk_size % 8L) {
      {
#line 287
      psf_binheader_readf(psf, "j", 8L - chunk_size % 8L);
      }
    }
#line 289
    format = (int )wav_fmt->format;
#line 290
    parsestage |= 4;
#line 291
    chunk_size = (sf_count_t )0;
#line 292
    goto switch_break;
    case_exp___2: 
    {
#line 297
    psf_binheader_readf(psf, "e8", & frames);
#line 298
    psf_log_printf(psf, "   fact : %D\n     frames : %D\n", chunk_size, frames);
#line 301
    chunk_size = (sf_count_t )0;
    }
#line 302
    goto switch_break;
    case_exp___3: 
#line 306
    if ((parsestage & 7) != 7) {
#line 307
      return (126);
    }
    {
#line 309
    psf->dataoffset = psf_ftell(psf);
#line 310
    psf->datalength = (sf_count_t )0;
    }
#line 312
    if (chunk_size % 8L) {
#line 313
      chunk_size += 8L - chunk_size % 8L;
    }
    {
#line 315
    psf_log_printf(psf, "data : %D\n", chunk_size);
#line 317
    parsestage |= 32;
    }
#line 319
    if (! psf->sf.seekable) {
#line 320
      goto switch_break;
    }
    {
#line 323
    psf_fseek(psf, chunk_size, 1);
#line 324
    chunk_size = (sf_count_t )0;
    }
#line 325
    goto switch_break;
    case_exp___4: 
    {
#line 328
    psf_log_printf(psf, "levl : %D\n", chunk_size);
#line 329
    chunk_size -= 24L;
    }
#line 330
    goto switch_break;
    case_exp___5: 
    {
#line 333
    psf_log_printf(psf, "list : %D\n", chunk_size);
#line 334
    chunk_size -= 24L;
    }
#line 335
    goto switch_break;
    case_exp___6: 
    {
#line 338
    psf_log_printf(psf, "junk : %D\n", chunk_size);
#line 339
    chunk_size -= 24L;
    }
#line 340
    goto switch_break;
    case_exp___7: 
    {
#line 343
    psf_log_printf(psf, "bext : %D\n", chunk_size);
#line 344
    chunk_size -= 24L;
    }
#line 345
    goto switch_break;
    case_exp___8: 
    {
#line 348
    psf_log_printf(psf, "marker : %D\n", chunk_size);
#line 349
    chunk_size -= 24L;
    }
#line 350
    goto switch_break;
    case_exp___9: 
    {
#line 353
    psf_log_printf(psf, "summary list : %D\n", chunk_size);
#line 354
    chunk_size -= 24L;
    }
#line 355
    goto switch_break;
    switch_default: 
    {
#line 358
    __cil_tmp19 = psf_ftell(psf);
#line 358
    psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D with length %D. Exiting parser.\n",
                   marker, __cil_tmp19 - 8L, chunk_size);
#line 359
    done = 1;
    }
#line 360
    goto switch_break;
    switch_break: ;
#line 363
    if (chunk_size >= psf->filelength) {
      {
#line 364
      psf_log_printf(psf, "*** Chunk size %u > file length %D. Exiting parser.\n",
                     chunk_size, psf->filelength);
      }
#line 365
      goto while_break;
    }
#line 368
    if (psf->sf.seekable == 0) {
#line 368
      if (parsestage & 32) {
#line 369
        goto while_break;
      }
    }
    {
#line 371
    __cil_tmp20 = psf_ftell(psf);
    }
#line 371
    if (__cil_tmp20 >= psf->filelength - (long )(2 * (int )sizeof(dword))) {
#line 372
      goto while_break;
    }
#line 374
    if (chunk_size > 0L) {
#line 374
      if (chunk_size < 4294901760L) {
        {
#line 375
        dword = (int )chunk_size;
#line 376
        psf_binheader_readf(psf, "j", dword - 24);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 380
  if (psf->dataoffset <= 0L) {
#line 381
    return (126);
  }
#line 383
  if (psf->sf.channels < 1) {
#line 384
    return (33);
  }
#line 386
  if (psf->sf.channels >= 1024) {
#line 387
    return (34);
  }
  {
#line 389
  psf->endian = 268435456;
#line 391
  __cil_tmp21 = psf_ftell(psf);
  }
#line 391
  if (__cil_tmp21 != psf->dataoffset) {
    {
#line 392
    psf_fseek(psf, psf->dataoffset, 0);
    }
  }
#line 394
  if (psf->blockwidth) {
#line 395
    if (psf->filelength - psf->dataoffset < psf->datalength) {
#line 396
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    } else {
#line 398
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
  }
#line 403
  if (format == 65534) {
#line 403
    goto case_65534;
  }
#line 403
  if (format == 1) {
#line 403
    goto case_65534;
  }
#line 408
  if (format == 7) {
#line 408
    goto case_7;
  }
#line 412
  if (format == 6) {
#line 412
    goto case_6;
  }
#line 416
  if (format == 2) {
#line 416
    goto case_2;
  }
#line 422
  if (format == 17) {
#line 422
    goto case_17;
  }
#line 428
  if (format == 49) {
#line 428
    goto case_49;
  }
#line 432
  if (format == 3) {
#line 432
    goto case_3;
  }
#line 437
  goto switch_default___0;
  case_65534: 
  {
#line 405
  __cil_tmp22 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 405
  psf->sf.format = 720896 | __cil_tmp22;
  }
#line 406
  goto switch_break___0;
  case_7: 
#line 409
  psf->sf.format = 720912;
#line 410
  goto switch_break___0;
  case_6: 
#line 413
  psf->sf.format = 720913;
#line 414
  goto switch_break___0;
  case_2: 
#line 417
  psf->sf.format = 720915;
#line 418
  *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 419
  *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
#line 420
  goto switch_break___0;
  case_17: 
#line 423
  psf->sf.format = 720914;
#line 424
  *blockalign = (int )wav_fmt->ima.blockalign;
#line 425
  *framesperblock = (int )wav_fmt->ima.samplesperblock;
#line 426
  goto switch_break___0;
  case_49: 
#line 429
  psf->sf.format = 720928;
#line 430
  goto switch_break___0;
  case_3: 
#line 433
  psf->sf.format = 720896;
#line 434
  if (psf->bytewidth == 8) {
#line 434
    tmp = 7;
  } else {
#line 434
    tmp = 6;
  }
#line 434
  psf->sf.format |= tmp;
#line 435
  goto switch_break___0;
  switch_default___0: 
#line 437
  return (18);
  switch_break___0: ;
#line 440
  return (0);
}
}
#line 444 "/root/patchweave_donee/23/src/w64.c"
static int w64_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t fmt_size ;
  sf_count_t current ;
  size_t fmt_pad ;
  int subformat ;
  int add_fact_chunk ;
  int blockalign ;
  int framesperblock ;
  int bytespersec ;
  int blockalign___0 ;
  int framesperblock___0 ;
  int bytespersec___0 ;
  int extrabytes ;
  int bytespersec___1 ;

  {
  {
#line 446
  fmt_pad = (size_t )0;
#line 447
  add_fact_chunk = 0;
#line 449
  current = psf_ftell(psf);
  }
#line 451
  if (calc_length) {
    {
#line 452
    psf->filelength = psf_get_filelen(psf);
#line 454
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 455
    if (psf->dataend) {
#line 456
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 458
    if (psf->bytewidth) {
#line 459
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
  {
#line 463
  psf->header[0] = (unsigned char)0;
#line 464
  psf->headindex = 0;
#line 465
  psf_fseek(psf, (sf_count_t )0, 0);
#line 468
  psf_binheader_writef(psf, "eh8hh", riff_MARKER16, psf->filelength, wave_MARKER16,
                       fmt_MARKER16);
#line 470
  subformat = psf->sf.format & 65535;
  }
#line 476
  if (subformat == 4) {
#line 476
    goto case_4;
  }
#line 476
  if (subformat == 3) {
#line 476
    goto case_4;
  }
#line 476
  if (subformat == 2) {
#line 476
    goto case_4;
  }
#line 476
  if (subformat == 5) {
#line 476
    goto case_4;
  }
#line 490
  if (subformat == 7) {
#line 490
    goto case_7;
  }
#line 490
  if (subformat == 6) {
#line 490
    goto case_7;
  }
#line 505
  if (subformat == 16) {
#line 505
    goto case_16;
  }
#line 520
  if (subformat == 17) {
#line 520
    goto case_17;
  }
#line 536
  if (subformat == 18) {
#line 536
    goto case_18;
  }
#line 561
  if (subformat == 19) {
#line 561
    goto case_19;
  }
#line 590
  if (subformat == 32) {
#line 590
    goto case_32;
  }
#line 613
  goto switch_default;
  case_4: 
  {
#line 477
  fmt_size = (sf_count_t )40;
#line 478
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 479
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 482
  psf_binheader_writef(psf, "e8224U", fmt_size, 1, psf->sf.channels, psf->sf.samplerate);
#line 484
  psf_binheader_writef(psf, "e4j\330\204U", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 486
  psf_binheader_writef(psf, "e22\330\204U", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
  }
#line 487
  goto switch_break;
  case_7: 
  {
#line 491
  fmt_size = (sf_count_t )40;
#line 492
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 493
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 496
  psf_binheader_writef(psf, "e8224U", fmt_size, 3, psf->sf.channels, psf->sf.samplerate);
#line 498
  psf_binheader_writef(psf, "e4j\330\204U", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 500
  psf_binheader_writef(psf, "e22\330\204U", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
#line 502
  add_fact_chunk = 1;
  }
#line 503
  goto switch_break;
  case_16: 
  {
#line 506
  fmt_size = (sf_count_t )40;
#line 507
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 508
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 511
  psf_binheader_writef(psf, "e8224U", fmt_size, 7, psf->sf.channels, psf->sf.samplerate);
#line 513
  psf_binheader_writef(psf, "e4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 515
  psf_binheader_writef(psf, "e22", psf->bytewidth * psf->sf.channels, 8);
#line 517
  add_fact_chunk = 1;
  }
#line 518
  goto switch_break;
  case_17: 
  {
#line 521
  fmt_size = (sf_count_t )40;
#line 522
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 523
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 526
  psf_binheader_writef(psf, "e8224", fmt_size, 6, psf->sf.channels, psf->sf.samplerate);
#line 528
  psf_binheader_writef(psf, "e4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 530
  psf_binheader_writef(psf, "e22\330\204U", psf->bytewidth * psf->sf.channels, 8);
#line 532
  add_fact_chunk = 1;
  }
#line 533
  goto switch_break;
  case_18: 
  {
#line 539
  blockalign = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 540
  framesperblock = (2 * (blockalign - 4 * psf->sf.channels)) / psf->sf.channels + 1;
#line 541
  bytespersec = (psf->sf.samplerate * blockalign) / framesperblock;
#line 544
  fmt_size = (sf_count_t )44;
#line 545
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 546
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 549
  psf_binheader_writef(psf, "e822", fmt_size, 17, psf->sf.channels);
#line 552
  psf_binheader_writef(psf, "e44\330\204U", psf->sf.samplerate, bytespersec);
#line 555
  psf_binheader_writef(psf, "e2222", blockalign, 4, 2, framesperblock);
#line 558
  add_fact_chunk = 1;
  }
#line 559
  goto switch_break;
  case_19: 
  {
#line 564
  blockalign___0 = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 565
  framesperblock___0 = 2 + (2 * (blockalign___0 - 7 * psf->sf.channels)) / psf->sf.channels;
#line 566
  bytespersec___0 = (psf->sf.samplerate * blockalign___0) / framesperblock___0;
#line 569
  extrabytes = 32;
#line 570
  fmt_size = (sf_count_t )(42 + extrabytes);
#line 571
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 572
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 575
  psf_binheader_writef(psf, "e822", fmt_size, 2, psf->sf.channels);
#line 578
  psf_binheader_writef(psf, "e44", psf->sf.samplerate, bytespersec___0);
#line 581
  psf_binheader_writef(psf, "e22222", blockalign___0, 4, extrabytes, framesperblock___0,
                       7);
#line 583
  msadpcm_write_adapt_coeffs(psf);
#line 586
  add_fact_chunk = 1;
  }
#line 587
  goto switch_break;
  case_32: 
  {
#line 593
  bytespersec___1 = (psf->sf.samplerate * 65) / 320;
#line 596
  fmt_size = (sf_count_t )44;
#line 597
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 598
  fmt_size = (sf_count_t )((size_t )fmt_size + fmt_pad);
#line 601
  psf_binheader_writef(psf, "e822\204U", fmt_size, 49, psf->sf.channels);
#line 604
  psf_binheader_writef(psf, "e44", psf->sf.samplerate, bytespersec___1);
#line 607
  psf_binheader_writef(psf, "e2222U", 65, 0, 2, 320);
#line 610
  add_fact_chunk = 1;
  }
#line 611
  goto switch_break;
  switch_default: 
#line 613
  return (18);
  switch_break: ;
#line 617
  if (fmt_pad > 0UL) {
    {
#line 618
    psf_binheader_writef(psf, "z}j\330\204U", fmt_pad);
    }
  }
#line 620
  if (add_fact_chunk) {
    {
#line 621
    psf_binheader_writef(psf, "eh88\204U", fact_MARKER16, (sf_count_t )32, psf->sf.frames);
    }
  }
  {
#line 623
  psf_binheader_writef(psf, "eh8\330\204U", data_MARKER16, psf->datalength + 24L);
#line 624
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 626
  if (psf->error) {
#line 627
    return (psf->error);
  }
#line 629
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 631
  if (current > 0L) {
    {
#line 632
    psf_fseek(psf, current, 0);
    }
  }
#line 634
  return (psf->error);
}
}
#line 638 "/root/patchweave_donee/23/src/w64.c"
static int w64_close(SF_PRIVATE *psf ) 
{ 


  {
#line 640
  if (psf->file.mode == 32) {
    {
#line 641
    w64_write_header(psf, 1);
    }
  } else
#line 640
  if (psf->file.mode == 48) {
    {
#line 641
    w64_write_header(psf, 1);
    }
  }
#line 643
  return (0);
}
}
#line 46 "/root/patchweave_donee/23/src/wve.c"
static int wve_read_header(SF_PRIVATE *psf ) ;
#line 47
static int wve_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 48
static int wve_close(SF_PRIVATE *psf ) ;
#line 55 "/root/patchweave_donee/23/src/wve.c"
int wve_open(SF_PRIVATE *psf ) 
{ 
  int error ;

  {
#line 56
  error = 0;
#line 58
  if (psf->is_pipe) {
#line 59
    return (160);
  }
#line 61
  if (psf->file.mode == 16) {
    _L: 
    {
#line 62
    error = wve_read_header(psf);
    }
#line 62
    if (error) {
#line 63
      return (error);
    }
  } else
#line 61
  if (psf->file.mode == 48) {
#line 61
    if (psf->filelength > 0L) {
#line 61
      goto _L;
    }
  }
#line 66
  if (psf->file.mode == 32) {
    _L___21: 
#line 67
    if ((psf->sf.format & 268369920) != 1638400) {
#line 68
      return (1);
    }
    {
#line 70
    psf->endian = 536870912;
#line 72
    error = wve_write_header(psf, 0);
    }
#line 72
    if (error) {
#line 73
      return (error);
    }
#line 75
    psf->write_header = & wve_write_header;
  } else
#line 66
  if (psf->file.mode == 48) {
#line 66
    goto _L___21;
  }
  {
#line 78
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 80
  psf->container_close = & wve_close;
#line 82
  error = alaw_init(psf);
  }
#line 84
  return (error);
}
}
#line 91 "/root/patchweave_donee/23/src/wve.c"
static int wve_read_header(SF_PRIVATE *psf ) 
{ 
  int marker ;
  unsigned short version ;
  unsigned short padding ;
  unsigned short repeats ;
  unsigned short trash ;
  unsigned int datalength ;

  {
  {
#line 97
  psf_binheader_readf(psf, "pm\202\330\204U", 0, & marker);
  }
#line 98
  if ((unsigned int )marker != ((unsigned int )((65 | (76 << 8)) | (97 << 16)) | (119U << 24))) {
    {
#line 99
    psf_log_printf(psf, "Could not find \'%M\'\n\204U", (unsigned int )((65 | (76 << 8)) | (97 << 16)) | (119U << 24));
    }
#line 100
    return (159);
  }
  {
#line 103
  psf_binheader_readf(psf, "m\023\210\330\204U", & marker);
  }
#line 104
  if ((unsigned int )marker != ((unsigned int )((83 | (111 << 8)) | (117 << 16)) | (110U << 24))) {
    {
#line 105
    psf_log_printf(psf, "Could not find \'%M\'\n", (unsigned int )((83 | (111 << 8)) | (117 << 16)) | (110U << 24));
    }
#line 106
    return (159);
  }
  {
#line 109
  psf_binheader_readf(psf, "m", & marker);
  }
#line 110
  if ((unsigned int )marker != ((unsigned int )((100 | (70 << 8)) | (105 << 16)) | (108U << 24))) {
    {
#line 111
    psf_log_printf(psf, "Could not find \'%M\'\n\204U", (unsigned int )((100 | (70 << 8)) | (105 << 16)) | (108U << 24));
    }
#line 112
    return (159);
  }
  {
#line 115
  psf_binheader_readf(psf, "m", & marker);
  }
#line 116
  if ((unsigned int )marker != (unsigned int )((101 | (42 << 8)) | (42 << 16))) {
    {
#line 117
    psf_log_printf(psf, "Could not find \'%M\'\n\204U", (unsigned int )((101 | (42 << 8)) | (42 << 16)));
    }
#line 118
    return (159);
  }
  {
#line 121
  psf_binheader_readf(psf, "E2", & version);
#line 123
  psf_log_printf(psf, "Psion Palmtop Alaw (.wve)\n  Sample Rate : 8000\n  Channels    : 1\n  Encoding    : A-law\n");
  }
#line 128
  if ((int )version != 3856) {
    {
#line 129
    psf_log_printf(psf, "Psion version %d should be %d\n", (int )version, 3856);
    }
  }
  {
#line 131
  psf_binheader_readf(psf, "E4", & datalength);
#line 132
  psf->dataoffset = (sf_count_t )32;
  }
#line 133
  if ((long )datalength != psf->filelength - psf->dataoffset) {
    {
#line 134
    psf->datalength = psf->filelength - psf->dataoffset;
#line 135
    psf_log_printf(psf, "Data length %d should be %D\n", datalength, psf->datalength);
    }
  } else {
#line 138
    psf->datalength = (sf_count_t )datalength;
  }
  {
#line 140
  psf_binheader_readf(psf, "E22222", & padding, & repeats, & trash, & trash, & trash);
#line 142
  psf->sf.format = 1638417;
#line 143
  psf->sf.samplerate = 8000;
#line 144
  psf->sf.frames = psf->datalength;
#line 145
  psf->sf.channels = 1;
  }
#line 147
  return (0);
}
}
#line 154 "/root/patchweave_donee/23/src/wve.c"
static int wve_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  unsigned int datalen ;

  {
  {
#line 158
  current = psf_ftell(psf);
  }
#line 160
  if (calc_length) {
    {
#line 161
    psf->filelength = psf_get_filelen(psf);
#line 163
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 164
    if (psf->dataend) {
#line 165
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 167
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 171
  psf->header[0] = (unsigned char)0;
#line 172
  psf->headindex = 0;
#line 173
  psf_fseek(psf, (sf_count_t )0, 0);
#line 176
  datalen = (unsigned int )psf->datalength;
#line 177
  psf_binheader_writef(psf, "EmmmmU", (unsigned int )((65 | (76 << 8)) | (97 << 16)) | (119U << 24),
                       (unsigned int )((83 | (111 << 8)) | (117 << 16)) | (110U << 24),
                       (unsigned int )((100 | (70 << 8)) | (105 << 16)) | (108U << 24),
                       (unsigned int )((101 | (42 << 8)) | (42 << 16)));
#line 178
  psf_binheader_writef(psf, "E2422222\251", 3856, datalen, 0, 0, 0, 0, 0);
#line 179
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 181
  if (psf->sf.channels != 1) {
#line 182
    return (34);
  }
#line 184
  if (psf->error) {
#line 185
    return (psf->error);
  }
#line 187
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 189
  if (current > 0L) {
    {
#line 190
    psf_fseek(psf, current, 0);
    }
  }
#line 192
  return (psf->error);
}
}
#line 199 "/root/patchweave_donee/23/src/wve.c"
static int wve_close(SF_PRIVATE *psf ) 
{ 


  {
#line 201
  if (psf->file.mode == 32) {
    {
#line 205
    wve_write_header(psf, 1);
    }
  } else
#line 201
  if (psf->file.mode == 48) {
    {
#line 205
    wve_write_header(psf, 1);
    }
  }
#line 208
  return (0);
}
}
#line 72 "/root/patchweave_donee/23/src/voc.c"
static int voc_close(SF_PRIVATE *psf ) ;
#line 73
static int voc_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 74
static int voc_read_header(SF_PRIVATE *psf ) ;
#line 76
static char const   *voc_encoding2str(int encoding ) ;
#line 104 "/root/patchweave_donee/23/src/voc.c"
int voc_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;

  {
#line 105
  error = 0;
#line 107
  if (psf->is_pipe) {
#line 108
    return (119);
  }
#line 110
  if (psf->file.mode == 16) {
    _L: 
    {
#line 111
    error = voc_read_header(psf);
    }
#line 111
    if (error) {
#line 112
      return (error);
    }
  } else
#line 110
  if (psf->file.mode == 48) {
#line 110
    if (psf->filelength > 0L) {
#line 110
      goto _L;
    }
  }
#line 115
  subformat = psf->sf.format & 65535;
#line 117
  if (psf->file.mode == 32) {
    _L___22: 
#line 118
    if ((psf->sf.format & 268369920) != 524288) {
#line 119
      return (1);
    }
    {
#line 121
    psf->endian = 268435456;
#line 123
    error = voc_write_header(psf, 0);
    }
#line 123
    if (error) {
#line 124
      return (error);
    }
#line 126
    psf->write_header = & voc_write_header;
  } else
#line 117
  if (psf->file.mode == 48) {
#line 117
    goto _L___22;
  }
#line 129
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 131
  psf->container_close = & voc_close;
#line 135
  if (subformat == 2) {
#line 135
    goto case_2;
  }
#line 135
  if (subformat == 5) {
#line 135
    goto case_2;
  }
#line 139
  if (subformat == 17) {
#line 139
    goto case_17;
  }
#line 143
  if (subformat == 16) {
#line 143
    goto case_16;
  }
#line 147
  goto switch_default;
  case_2: 
  {
#line 136
  error = pcm_init(psf);
  }
#line 137
  goto switch_break;
  case_17: 
  {
#line 140
  error = alaw_init(psf);
  }
#line 141
  goto switch_break;
  case_16: 
  {
#line 144
  error = ulaw_init(psf);
  }
#line 145
  goto switch_break;
  switch_default: 
#line 147
  return (18);
  switch_break: ;
#line 150
  return (error);
}
}
#line 157 "/root/patchweave_donee/23/src/voc.c"
static int voc_read_header(SF_PRIVATE *psf ) 
{ 
  VOC_DATA *pvoc ;
  char creative[20] ;
  unsigned char block_type ;
  unsigned char rate_byte ;
  short version ;
  short checksum ;
  short encoding ;
  short dataoffset ;
  int offset ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  char header[256] ;
  unsigned int size ;
  short count___0 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned char compression ;
  int size___0 ;
  int __cil_tmp25 ;
  unsigned char pack ;
  unsigned char stereo ;
  unsigned char compression___0 ;
  unsigned short rate_short ;
  int size___1 ;
  int __cil_tmp31 ;
  char const   *tmp ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned char bitwidth ;
  unsigned char channels ;
  int size___2 ;
  int fourbytes ;
  int __cil_tmp39 ;
  int temp_size ;
  char const   *__cil_tmp41 ;

  {
  {
#line 165
  offset = psf_binheader_readf(psf, "pb\244\330\204U", 0, creative, (int )sizeof(creative));
  }
#line 167
  if ((int )creative[sizeof(creative) - 1UL] != 26) {
#line 168
    return (110);
  }
  {
#line 171
  creative[sizeof(creative) - 1UL] = (char)0;
#line 173
  __cil_tmp12 = strcmp("Creative Voice File", (char const   *)(creative));
  }
#line 173
  if (__cil_tmp12) {
#line 174
    return (110);
  }
  {
#line 176
  psf_log_printf(psf, "%s\n\330\204U", creative);
#line 178
  __cil_tmp13 = psf_binheader_readf(psf, "e222\204U", & dataoffset, & version, & checksum);
#line 178
  offset += __cil_tmp13;
#line 180
  psf->dataoffset = (sf_count_t )dataoffset;
#line 182
  psf_log_printf(psf, "dataoffset : %d\nversion    : 0x%X\nchecksum   : 0x%X\n\204U",
                 psf->dataoffset, (int )version, (int )checksum);
  }
#line 186
  if ((int )version != 266) {
#line 186
    if ((int )version != 276) {
#line 187
      return (112);
    }
  }
  {
#line 189
  psf->codec_data = malloc(sizeof(VOC_DATA ));
  }
#line 189
  if (! psf->codec_data) {
#line 190
    return (17);
  }
  {
#line 192
  pvoc = (VOC_DATA *)psf->codec_data;
#line 194
  memset((void *)pvoc, 0, sizeof(VOC_DATA ));
#line 197
  psf->sf.format = 524288;
#line 198
  encoding = (short)5;
#line 199
  psf->endian = 268435456;
  }
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 206
    block_type = (unsigned char)0;
#line 207
    __cil_tmp18 = psf_binheader_readf(psf, "1", & block_type);
#line 207
    offset += __cil_tmp18;
    }
#line 210
    if ((int )block_type == 5) {
#line 210
      goto case_5;
    }
#line 225
    if ((int )block_type == 6) {
#line 225
      goto case_6;
    }
#line 232
    if ((int )block_type == 9) {
#line 232
      goto case_9;
    }
#line 232
    if ((int )block_type == 8) {
#line 232
      goto case_9;
    }
#line 232
    if ((int )block_type == 1) {
#line 232
      goto case_9;
    }
#line 235
    goto switch_default;
    case_5: 
    {
#line 211
    __cil_tmp19 = psf_binheader_readf(psf, "e3\244\330\204U", & size);
#line 211
    offset += __cil_tmp19;
#line 213
    psf_log_printf(psf, " ASCII : %d\n\204U", size);
    }
#line 215
    if ((unsigned long )size < sizeof(header) - 1UL) {
      {
#line 216
      __cil_tmp20 = psf_binheader_readf(psf, "b", header, size);
#line 216
      offset += __cil_tmp20;
#line 217
      header[size] = (char)0;
#line 218
      psf_log_printf(psf, "  text : %s\n", header);
      }
#line 219
      goto while_continue;
    }
    {
#line 222
    __cil_tmp21 = psf_binheader_readf(psf, "j", size);
#line 222
    offset += __cil_tmp21;
    }
#line 223
    goto while_continue;
    case_6: 
    {
#line 226
    __cil_tmp22 = psf_binheader_readf(psf, "e32", & size, & count___0);
#line 226
    offset += __cil_tmp22;
#line 227
    psf_log_printf(psf, " Repeat : %d\n", (int )count___0);
    }
#line 228
    goto while_continue;
    case_9: 
#line 233
    goto switch_break;
    switch_default: 
    {
#line 235
    psf_log_printf(psf, "*** Weird block marker (%d)\n", (int )block_type);
    }
    switch_break: ;
#line 238
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 241
  if ((int )block_type == 1) {
    {
#line 245
    __cil_tmp25 = psf_binheader_readf(psf, "e311", & size___0, & rate_byte, & compression);
#line 245
    offset += __cil_tmp25;
#line 247
    psf->sf.samplerate = 1000000 / (256 - ((int )rate_byte & 255));
#line 249
    psf_log_printf(psf, " Sound Data : %d\n  sr   : %d => %dHz\n  comp : %d\n", size___0,
                   (int )rate_byte, psf->sf.samplerate, (int )compression);
    }
#line 252
    if ((long )((offset + size___0) - 1) > psf->filelength) {
      {
#line 253
      psf_log_printf(psf, "Seems to be a truncated file.\n");
#line 254
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___0, offset + size___0, psf->filelength);
      }
#line 255
      return (114);
    } else
#line 257
    if ((psf->filelength - (long )offset) - (long )size___0 > 4L) {
      {
#line 258
      psf_log_printf(psf, "Seems to be a multi-segment file (#1).\n");
#line 259
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___0, offset + size___0, psf->filelength);
      }
#line 260
      return (114);
    }
#line 263
    psf->dataoffset = (sf_count_t )offset;
#line 264
    psf->dataend = psf->filelength - 1L;
#line 266
    psf->sf.channels = 1;
#line 267
    psf->bytewidth = 1;
#line 269
    psf->sf.format = 524293;
#line 271
    return (0);
  }
#line 274
  if ((int )block_type == 8) {
    {
#line 279
    __cil_tmp31 = psf_binheader_readf(psf, "e3211", & size___1, & rate_short, & pack,
                                      & stereo);
#line 279
    offset += __cil_tmp31;
#line 281
    psf_log_printf(psf, " Extended : %d\n", size___1);
    }
#line 282
    if (size___1 == 4) {
      {
#line 283
      psf_log_printf(psf, "  size   : 4\n");
      }
    } else {
      {
#line 285
      psf_log_printf(psf, "  size   : %d (should be 4)\n", size___1);
      }
    }
#line 287
    if ((int )stereo) {
#line 287
      tmp = "yes";
    } else {
#line 287
      tmp = "no";
    }
    {
#line 287
    psf_log_printf(psf, "  pack   : %d\n  stereo : %s\n\230\001", (int )pack, tmp);
    }
#line 290
    if (stereo) {
#line 291
      psf->sf.channels = 2;
#line 292
      psf->sf.samplerate = 128000000 / (65536 - (int )rate_short);
    } else {
#line 295
      psf->sf.channels = 1;
#line 296
      psf->sf.samplerate = 256000000 / (65536 - (int )rate_short);
    }
    {
#line 299
    psf_log_printf(psf, "  sr     : %d => %dHz\n", (int )rate_short & 65535, psf->sf.samplerate);
#line 301
    __cil_tmp33 = psf_binheader_readf(psf, "1", & block_type);
#line 301
    offset += __cil_tmp33;
    }
#line 303
    if ((int )block_type != 1) {
      {
#line 304
      psf_log_printf(psf, "*** Expecting VOC_SOUND_DATA section.\n");
      }
#line 305
      return (111);
    }
    {
#line 308
    __cil_tmp34 = psf_binheader_readf(psf, "e311", & size___1, & rate_byte, & compression___0);
#line 308
    offset += __cil_tmp34;
#line 310
    psf_log_printf(psf, " Sound Data : %d\n  sr     : %d\n  comp   : %d\n", size___1,
                   (int )rate_byte, (int )compression___0);
    }
#line 315
    if ((long )((offset + size___1) - 1) > psf->filelength) {
      {
#line 316
      psf_log_printf(psf, "Seems to be a truncated file.\n");
#line 317
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___1, offset + size___1, psf->filelength);
      }
#line 318
      return (114);
    } else
#line 320
    if ((long )((offset + size___1) - 1) < psf->filelength) {
      {
#line 321
      psf_log_printf(psf, "Seems to be a multi-segment file (#2).\n");
#line 322
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___1, offset + size___1, psf->filelength);
      }
#line 323
      return (114);
    }
#line 326
    psf->dataoffset = (sf_count_t )offset;
#line 327
    psf->dataend = psf->filelength - 1L;
#line 329
    psf->bytewidth = 1;
#line 331
    psf->sf.format = 524293;
#line 333
    return (0);
  }
#line 336
  if ((int )block_type == 9) {
    {
#line 340
    __cil_tmp39 = psf_binheader_readf(psf, "e341124", & size___2, & psf->sf.samplerate,
                                      & bitwidth, & channels, & encoding, & fourbytes);
#line 340
    offset += __cil_tmp39;
    }
#line 343
    if ((long )(size___2 * 2) == psf->filelength - 39L) {
      {
#line 344
      temp_size = (int )(psf->filelength - 31L);
#line 346
      psf_log_printf(psf, " Extended II : %d (SoX bug: should be %d)\n", size___2,
                     temp_size);
#line 347
      size___2 = temp_size;
      }
    } else {
      {
#line 350
      psf_log_printf(psf, " Extended II : %d\n", size___2);
      }
    }
    {
#line 352
    psf_log_printf(psf, "  sample rate : %d\n  bit width   : %d\n  channels    : %d\n",
                   psf->sf.samplerate, (int )bitwidth, (int )channels);
    }
#line 356
    if ((int )bitwidth == 16) {
#line 356
      if ((int )encoding == 0) {
        {
#line 357
        encoding = (short)4;
#line 358
        psf_log_printf(psf, "  encoding    : 0 (SoX bug: should be 4 for 16 bit signed PCM)\n");
        }
      } else {
        {
#line 361
        __cil_tmp41 = voc_encoding2str((int )encoding);
#line 361
        psf_log_printf(psf, "  encoding    : %d => %s\n", (int )encoding, __cil_tmp41);
        }
      }
    } else {
      {
#line 361
      __cil_tmp41 = voc_encoding2str((int )encoding);
#line 361
      psf_log_printf(psf, "  encoding    : %d => %s\n", (int )encoding, __cil_tmp41);
      }
    }
    {
#line 364
    psf_log_printf(psf, "  fourbytes   : %X\n", fourbytes);
#line 366
    psf->sf.channels = (int )channels;
#line 368
    psf->dataoffset = (sf_count_t )offset;
#line 369
    psf->dataend = psf->filelength - 1L;
    }
#line 371
    if ((long )(size___2 + 31) == psf->filelength + 1L) {
      {
#line 375
      psf_log_printf(psf, "Missing zero byte at end of file.\n");
#line 376
      size___2 = (int )(psf->filelength - 30L);
#line 377
      psf->dataend = (sf_count_t )0;
      }
    } else
#line 379
    if ((long )(size___2 + 31) > psf->filelength) {
      {
#line 380
      psf_log_printf(psf, "Seems to be a truncated file.\n");
#line 381
      size___2 = (int )(psf->filelength - 31L);
      }
    } else
#line 383
    if ((long )(size___2 + 31) < psf->filelength) {
      {
#line 384
      psf_log_printf(psf, "Seems to be a multi-segment file (#3).\n");
      }
    }
#line 387
    if ((int )encoding == 0) {
#line 387
      goto case_0;
    }
#line 392
    if ((int )encoding == 4) {
#line 392
      goto case_4;
    }
#line 397
    if ((int )encoding == 6) {
#line 397
      goto case_6___0;
    }
#line 402
    if ((int )encoding == 7) {
#line 402
      goto case_7;
    }
#line 407
    goto switch_default___0;
    case_0: 
#line 388
    psf->sf.format = 524293;
#line 389
    psf->bytewidth = 1;
#line 390
    goto switch_break___0;
    case_4: 
#line 393
    psf->sf.format = 524290;
#line 394
    psf->bytewidth = 2;
#line 395
    goto switch_break___0;
    case_6___0: 
#line 398
    psf->sf.format = 524305;
#line 399
    psf->bytewidth = 1;
#line 400
    goto switch_break___0;
    case_7: 
#line 403
    psf->sf.format = 524304;
#line 404
    psf->bytewidth = 1;
#line 405
    goto switch_break___0;
    switch_default___0: 
#line 408
    return (21);
#line 409
    goto switch_break___0;
    switch_break___0: ;
  }
#line 414
  return (0);
}
}
#line 421 "/root/patchweave_donee/23/src/voc.c"
static int voc_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int rate_const ;
  int subformat ;
  size_t __cil_tmp8 ;
  int length ;

  {
  {
#line 425
  current = psf_ftell(psf);
  }
#line 427
  if (calc_length) {
    {
#line 428
    psf->filelength = psf_get_filelen(psf);
#line 430
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 431
    if (psf->dataend) {
#line 432
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 434
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 437
  subformat = psf->sf.format & 65535;
#line 439
  psf->header[0] = (unsigned char)0;
#line 440
  psf->headindex = 0;
#line 441
  psf_fseek(psf, (sf_count_t )0, 0);
#line 444
  __cil_tmp8 = make_size_t(19);
#line 444
  psf_binheader_writef(psf, "eb1", "Creative Voice File", __cil_tmp8, 26);
#line 447
  psf_binheader_writef(psf, "e222", 26, 276, 4383);
  }
#line 455
  if (subformat == 5) {
#line 455
    if (psf->sf.channels == 1) {
      {
#line 457
      rate_const = 256 - 1000000 / psf->sf.samplerate;
#line 460
      psf_binheader_writef(psf, "e1311", 1, (int )(psf->datalength + 1L), rate_const,
                           0);
      }
    } else {
#line 455
      goto _L___23;
    }
  } else
  _L___23: 
#line 462
  if (subformat == 5) {
#line 462
    if (psf->sf.channels == 2) {
      {
#line 464
      rate_const = 65536 - 128000000 / psf->sf.samplerate;
#line 469
      psf_binheader_writef(psf, "e13211", 8, 4, rate_const, 0, 1);
#line 472
      rate_const = 256 - 1000000 / psf->sf.samplerate;
#line 477
      psf_binheader_writef(psf, "e1311U", 1, (int )(psf->datalength + 1L), rate_const,
                           0);
      }
    } else {
#line 462
      goto _L;
    }
  } else {
    _L: 
#line 482
    if (psf->sf.channels < 1) {
#line 483
      return (34);
    } else
#line 482
    if (psf->sf.channels > 2) {
#line 483
      return (34);
    }
#line 486
    if (subformat == 5) {
#line 486
      goto case_5;
    }
#line 493
    if (subformat == 2) {
#line 493
      goto case_2;
    }
#line 500
    if (subformat == 17) {
#line 500
      goto case_17;
    }
#line 506
    if (subformat == 16) {
#line 506
      goto case_16;
    }
#line 512
    goto switch_default;
    case_5: 
    {
#line 487
    psf->bytewidth = 1;
#line 488
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 490
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 16, psf->sf.channels,
                         4, 0);
    }
#line 491
    goto switch_break;
    case_2: 
    {
#line 494
    psf->bytewidth = 2;
#line 495
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 497
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 16, psf->sf.channels,
                         4, 0);
    }
#line 498
    goto switch_break;
    case_17: 
    {
#line 501
    psf->bytewidth = 1;
#line 502
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 503
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 8, psf->sf.channels,
                         6, 0);
    }
#line 504
    goto switch_break;
    case_16: 
    {
#line 507
    psf->bytewidth = 1;
#line 508
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 509
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 8, psf->sf.channels,
                         7, 0);
    }
#line 510
    goto switch_break;
    switch_default: 
#line 512
    return (18);
    switch_break: ;
  }
  {
#line 516
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 518
  if (psf->error) {
#line 519
    return (psf->error);
  }
#line 521
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 523
  if (current > 0L) {
    {
#line 524
    psf_fseek(psf, current, 0);
    }
  }
#line 526
  return (psf->error);
}
}
#line 530 "/root/patchweave_donee/23/src/voc.c"
static int voc_close(SF_PRIVATE *psf ) 
{ 
  unsigned char byte ;

  {
#line 532
  if (psf->file.mode == 32) {
    {
#line 536
    byte = (unsigned char)0;
#line 539
    psf_fseek(psf, (sf_count_t )0, 2);
#line 542
    psf_fwrite((void const   *)(& byte), (sf_count_t )1, (sf_count_t )1, psf);
#line 544
    voc_write_header(psf, 1);
    }
  } else
#line 532
  if (psf->file.mode == 48) {
    {
#line 536
    byte = (unsigned char)0;
#line 539
    psf_fseek(psf, (sf_count_t )0, 2);
#line 542
    psf_fwrite((void const   *)(& byte), (sf_count_t )1, (sf_count_t )1, psf);
#line 544
    voc_write_header(psf, 1);
    }
  }
#line 547
  return (0);
}
}
#line 551 "/root/patchweave_donee/23/src/voc.c"
static char const   *voc_encoding2str(int encoding ) 
{ 


  {
#line 554
  if (encoding == 0) {
#line 554
    goto case_0;
  }
#line 555
  if (encoding == 4) {
#line 555
    goto case_4;
  }
#line 556
  if (encoding == 6) {
#line 556
    goto case_6;
  }
#line 557
  if (encoding == 7) {
#line 557
    goto case_7;
  }
#line 558
  goto switch_default;
  case_0: 
#line 554
  return ("8 bit unsigned PCM\244\330\204U");
  case_4: 
#line 555
  return ("16 bit signed PCM");
  case_6: 
#line 556
  return ("A-lawU");
  case_7: 
#line 557
  return ("u-lawU");
  switch_default: 
#line 558
  goto switch_break;
  switch_break: ;
#line 560
  return ("*** Unknown ***");
}
}
#line 40 "/root/patchweave_donee/23/src/txw.c"
int txw_open(SF_PRIVATE *psf ) 
{ 


  {
#line 41
  if (psf) {
#line 42
    return (18);
  }
#line 43
  return (0);
}
}
#line 73 "/root/patchweave_donee/23/src/svx.c"
static int svx_close(SF_PRIVATE *psf ) ;
#line 74
static int svx_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 75
static int svx_read_header(SF_PRIVATE *psf ) ;
#line 82 "/root/patchweave_donee/23/src/svx.c"
int svx_open(SF_PRIVATE *psf ) 
{ 
  int error ;

  {
#line 85
  if (psf->file.mode == 16) {
    _L: 
    {
#line 86
    error = svx_read_header(psf);
    }
#line 86
    if (error) {
#line 87
      return (error);
    }
#line 89
    psf->endian = 536870912;
#line 91
    psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 92
    if (psf->blockwidth) {
#line 93
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
    {
#line 95
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 85
  if (psf->file.mode == 48) {
#line 85
    if (psf->filelength > 0L) {
#line 85
      goto _L;
    }
  }
#line 98
  if (psf->file.mode == 32) {
    _L___24: 
#line 99
    if (psf->is_pipe) {
#line 100
      return (29);
    }
#line 102
    if ((psf->sf.format & 268369920) != 393216) {
#line 103
      return (1);
    }
#line 105
    psf->endian = psf->sf.format & 805306368;
#line 107
    if (psf->endian == 268435456) {
#line 108
      return (32);
    } else
#line 107
    if (psf->endian == 805306368) {
#line 108
      return (32);
    }
    {
#line 110
    psf->endian = 536870912;
#line 112
    error = svx_write_header(psf, 0);
    }
#line 113
    if (error) {
#line 114
      return (error);
    }
#line 116
    psf->write_header = & svx_write_header;
  } else
#line 98
  if (psf->file.mode == 48) {
#line 98
    goto _L___24;
  }
  {
#line 119
  psf->container_close = & svx_close;
#line 121
  error = pcm_init(psf);
  }
#line 121
  if (error) {
#line 122
    return (error);
  }
#line 124
  return (0);
}
}
#line 131 "/root/patchweave_donee/23/src/svx.c"
static int svx_read_header(SF_PRIVATE *psf ) 
{ 
  VHDR_CHUNK vhdr ;
  uint32_t chunk_size ;
  uint32_t marker ;
  int filetype ;
  int parsestage ;
  int done ;
  int bytecount ;
  int channels ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  sf_count_t __cil_tmp18 ;
  sf_count_t __cil_tmp19 ;
  sf_count_t __cil_tmp20 ;

  {
#line 134
  filetype = 0;
#line 134
  parsestage = 0;
#line 134
  done = 0;
#line 135
  bytecount = 0;
#line 137
  if (psf->filelength > 4294967295L) {
    {
#line 138
    psf_log_printf(psf, "Warning : filelength > 0xffffffff. This is bad!!!!\n");
    }
  }
  {
#line 140
  memset((void *)(& vhdr), 0, sizeof(vhdr));
#line 141
  psf_binheader_readf(psf, "p", 0);
#line 144
  psf->sf.channels = 1;
#line 146
  psf->sf.format = 393216;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;

#line 148
    if (! (! done)) {
#line 148
      goto while_break;
    }
    {
#line 149
    psf_binheader_readf(psf, "Em4", & marker, & chunk_size);
    }
#line 152
    if (marker == ((unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24))) {
#line 152
      goto case_exp;
    }
#line 169
    if (marker == ((unsigned int )((86 | (72 << 8)) | (68 << 16)) | (82U << 24))) {
#line 169
      goto case_exp___0;
    }
#line 188
    if (marker == 0U) {
#line 188
      goto case_0;
    }
#line 190
    if (marker == 1U) {
#line 190
      goto case_1;
    }
#line 192
    if (marker == 2U) {
#line 192
      goto case_2;
    }
#line 212
    if (marker == ((unsigned int )((66 | (79 << 8)) | (68 << 16)) | (89U << 24))) {
#line 212
      goto case_exp___1;
    }
#line 237
    if (marker == ((unsigned int )((78 | (65 << 8)) | (77 << 16)) | (69U << 24))) {
#line 237
      goto case_exp___2;
    }
#line 254
    if (marker == ((unsigned int )((65 | (78 << 8)) | (78 << 16)) | (79U << 24))) {
#line 254
      goto case_exp___3;
    }
#line 263
    if (marker == ((unsigned int )((67 | (72 << 8)) | (65 << 16)) | (78U << 24))) {
#line 263
      goto case_exp___4;
    }
#line 285
    if (marker == ((unsigned int )((40 | (99 << 8)) | (41 << 16)) | (32U << 24))) {
#line 285
      goto case_exp___5;
    }
#line 285
    if (marker == ((unsigned int )((65 | (85 << 8)) | (84 << 16)) | (72U << 24))) {
#line 285
      goto case_exp___5;
    }
#line 294
    goto switch_default;
    case_exp: 
#line 153
    if (parsestage) {
#line 154
      return (102);
    }
#line 156
    if ((unsigned long )chunk_size != (unsigned long )psf->filelength - 2UL * sizeof(chunk_size)) {
      {
#line 157
      psf_log_printf(psf, "FORM : %u (should be %u)\n@\336\330\204U", chunk_size,
                     (unsigned long )((uint32_t )psf->filelength) - 2UL * sizeof(chunk_size));
      }
    } else {
      {
#line 159
      psf_log_printf(psf, "FORM : %u\n", chunk_size);
      }
    }
    {
#line 160
    parsestage |= 1;
#line 162
    psf_binheader_readf(psf, "m", & marker);
#line 164
    filetype = (int )marker;
#line 165
    psf_log_printf(psf, " %M\n", marker);
#line 166
    parsestage |= 2;
    }
#line 167
    goto switch_break;
    case_exp___0: 
#line 170
    if (! (parsestage & 3)) {
#line 171
      return (102);
    }
    {
#line 173
    psf_log_printf(psf, " VHDR : %d\n", chunk_size);
#line 175
    psf_binheader_readf(psf, "E4442114\230\001", & vhdr.oneShotHiSamples, & vhdr.repeatHiSamples,
                        & vhdr.samplesPerHiCycle, & vhdr.samplesPerSec, & vhdr.octave,
                        & vhdr.compression, & vhdr.volume);
#line 179
    psf_log_printf(psf, "  OneShotHiSamples  : %d\n", vhdr.oneShotHiSamples);
#line 180
    psf_log_printf(psf, "  RepeatHiSamples   : %d\n", vhdr.repeatHiSamples);
#line 181
    psf_log_printf(psf, "  samplesPerHiCycle : %d\n", vhdr.samplesPerHiCycle);
#line 182
    psf_log_printf(psf, "  Sample Rate       : %d\nB\336\330\204U", (int )vhdr.samplesPerSec);
#line 183
    psf_log_printf(psf, "  Octave            : %d\nk\336\330\204U", (int )vhdr.octave);
#line 185
    psf_log_printf(psf, "  Compression       : %d => ", (int )vhdr.compression);
    }
#line 188
    if ((int )vhdr.compression == 0) {
#line 188
      goto case_0;
    }
#line 190
    if ((int )vhdr.compression == 1) {
#line 190
      goto case_1;
    }
#line 192
    if ((int )vhdr.compression == 2) {
#line 192
      goto case_2;
    }
#line 187
    goto switch_break___0;
    case_0: 
    {
#line 188
    psf_log_printf(psf, "None.\n");
    }
#line 189
    goto switch_break___0;
    case_1: 
    {
#line 190
    psf_log_printf(psf, "Fibonacci delta\n\220");
    }
#line 191
    goto switch_break___0;
    case_2: 
    {
#line 192
    psf_log_printf(psf, "Exponential delta\n");
    }
#line 193
    goto switch_break___0;
    switch_break___0: 
    {
#line 196
    psf_log_printf(psf, "  Volume            : %d\n", vhdr.volume);
#line 198
    psf->sf.samplerate = (int )vhdr.samplesPerSec;
    }
#line 200
    if ((unsigned int )filetype == ((unsigned int )((56 | (83 << 8)) | (86 << 16)) | (88U << 24))) {
#line 201
      psf->sf.format |= 1;
#line 202
      psf->bytewidth = 1;
    } else
#line 204
    if ((unsigned int )filetype == ((unsigned int )((49 | (54 << 8)) | (83 << 16)) | (86U << 24))) {
#line 205
      psf->sf.format |= 2;
#line 206
      psf->bytewidth = 2;
    }
#line 209
    parsestage |= 4;
#line 210
    goto switch_break;
    case_exp___1: 
#line 213
    if (! (parsestage & 4)) {
#line 214
      return (103);
    }
    {
#line 216
    psf->datalength = (sf_count_t )chunk_size;
#line 218
    psf->dataoffset = psf_ftell(psf);
    }
#line 219
    if (psf->dataoffset < 0L) {
#line 220
      return (103);
    }
#line 222
    if (psf->datalength > psf->filelength - psf->dataoffset) {
      {
#line 223
      psf_log_printf(psf, " BODY : %D (should be %D)\n", psf->datalength, psf->filelength - psf->dataoffset);
#line 224
      psf->datalength = psf->filelength - psf->dataoffset;
      }
    } else {
      {
#line 227
      psf_log_printf(psf, " BODY : %D\n", psf->datalength);
      }
    }
#line 229
    parsestage |= 8;
#line 231
    if (! psf->sf.seekable) {
#line 232
      goto switch_break;
    }
    {
#line 234
    psf_fseek(psf, psf->datalength, 1);
    }
#line 235
    goto switch_break;
    case_exp___2: 
#line 238
    if (! (parsestage & 2)) {
#line 239
      return (102);
    }
    {
#line 241
    psf_log_printf(psf, " %M : %u\n", marker, chunk_size);
#line 243
    __cil_tmp11 = strlen((char const   *)(psf->file.name.c));
    }
#line 243
    if (__cil_tmp11 != (unsigned long )chunk_size) {
#line 244
      if ((unsigned long )chunk_size > sizeof(psf->file.name.c) - 1UL) {
#line 245
        return (106);
      }
      {
#line 247
      psf_binheader_readf(psf, "b", psf->file.name.c, chunk_size);
#line 248
      psf->file.name.c[chunk_size] = (char)0;
      }
    } else {
      {
#line 251
      psf_binheader_readf(psf, "j", chunk_size);
      }
    }
#line 252
    goto switch_break;
    case_exp___3: 
#line 255
    if (! (parsestage & 2)) {
#line 256
      return (102);
    }
    {
#line 258
    psf_log_printf(psf, " %M : %u\n", marker, chunk_size);
#line 260
    psf_binheader_readf(psf, "j", chunk_size);
    }
#line 261
    goto switch_break;
    case_exp___4: 
#line 264
    if (! (parsestage & 2)) {
#line 265
      return (102);
    }
    {
#line 267
    psf_log_printf(psf, " %M : %u\n", marker, chunk_size);
#line 269
    __cil_tmp12 = psf_binheader_readf(psf, "E4", & channels);
#line 269
    bytecount += __cil_tmp12;
    }
#line 271
    if (channels == 2) {
      {
#line 272
      psf_log_printf(psf, "  Channels : %d => mono\n\230\001", channels);
      }
    } else
#line 271
    if (channels == 4) {
      {
#line 272
      psf_log_printf(psf, "  Channels : %d => mono\n\230\001", channels);
      }
    } else
#line 273
    if (channels == 6) {
      {
#line 274
      psf->sf.channels = 2;
#line 275
      psf_log_printf(psf, "  Channels : %d => stereo\n", channels);
      }
    } else {
      {
#line 278
      psf_log_printf(psf, "  Channels : %d *** assuming mono\n", channels);
      }
    }
    {
#line 280
    psf_binheader_readf(psf, "j", chunk_size - (unsigned int )bytecount);
    }
#line 281
    goto switch_break;
    case_exp___5: 
#line 286
    if (! (parsestage & 2)) {
#line 287
      return (102);
    }
    {
#line 289
    psf_log_printf(psf, " %M : %u\n", marker, chunk_size);
#line 291
    psf_binheader_readf(psf, "j", chunk_size);
    }
#line 292
    goto switch_break;
    switch_default: 
#line 295
    if (chunk_size >= 4294901760U) {
      {
#line 296
      done = 1;
#line 297
      __cil_tmp13 = psf_ftell(psf);
#line 297
      psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\n",
                     marker, __cil_tmp13 - 8L, chunk_size);
      }
#line 298
      goto switch_break;
    }
    {
#line 301
    __cil_tmp17 = psf_isprint((int )(marker & 255U));
#line 301
    __cil_tmp16 = psf_isprint((int )((marker >> 8) & 255U));
#line 301
    __cil_tmp15 = psf_isprint((int )((marker >> 16) & 255U));
#line 301
    __cil_tmp14 = psf_isprint((int )((marker >> 24) & 255U));
    }
#line 301
    if (__cil_tmp14) {
#line 301
      if (__cil_tmp15) {
#line 301
        if (__cil_tmp16) {
#line 301
          if (__cil_tmp17) {
            {
#line 303
            psf_log_printf(psf, "%M : %u (unknown marker)\n", marker, chunk_size);
#line 304
            psf_binheader_readf(psf, "j", chunk_size);
            }
#line 305
            goto switch_break;
          }
        }
      }
    }
    {
#line 307
    __cil_tmp18 = psf_ftell(psf);
#line 307
    chunk_size = (uint32_t )__cil_tmp18;
    }
#line 307
    if (chunk_size & 3U) {
      {
#line 308
      psf_log_printf(psf, "  Unknown chunk marker at position %d. Resynching.\n",
                     chunk_size - 4U);
#line 310
      psf_binheader_readf(psf, "j", -3);
      }
#line 311
      goto switch_break;
    }
    {
#line 313
    __cil_tmp19 = psf_ftell(psf);
#line 313
    psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D. Exiting parser.\n",
                   marker, __cil_tmp19 - 8L);
#line 314
    done = 1;
    }
    switch_break: ;
#line 317
    if (! psf->sf.seekable) {
#line 317
      if (parsestage & 8) {
#line 318
        goto while_break;
      }
    }
    {
#line 320
    __cil_tmp20 = psf_ftell(psf);
    }
#line 320
    if (__cil_tmp20 >= psf->filelength - (long )((int )sizeof(chunk_size))) {
#line 321
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 324
  if (vhdr.compression) {
#line 325
    return (105);
  }
#line 327
  if (psf->dataoffset <= 0L) {
#line 328
    return (104);
  }
#line 330
  return (0);
}
}
#line 334 "/root/patchweave_donee/23/src/svx.c"
static int svx_close(SF_PRIVATE *psf ) 
{ 


  {
#line 336
  if (psf->file.mode == 32) {
    {
#line 337
    svx_write_header(psf, 1);
    }
  } else
#line 336
  if (psf->file.mode == 48) {
    {
#line 337
    svx_write_header(psf, 1);
    }
  }
#line 339
  return (0);
}
}
#line 345 "/root/patchweave_donee/23/src/svx.c"
static char annotation[37]  ;
#line 343 "/root/patchweave_donee/23/src/svx.c"
static int svx_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  long tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 344
  strcpy(annotation, "libsndfile by Erik de Castro Lopo");
#line 347
  current = psf_ftell(psf);
  }
#line 349
  if (calc_length) {
    {
#line 350
    psf->filelength = psf_get_filelen(psf);
#line 352
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 354
    if (psf->dataend) {
#line 355
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 357
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 360
  psf->header[0] = (unsigned char)0;
#line 361
  psf->headindex = 0;
#line 362
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 365
  if (psf->filelength < 8L) {
#line 365
    tmp = 0L;
  } else {
#line 365
    tmp = psf->filelength - 8L;
  }
  {
#line 365
  psf_binheader_writef(psf, "Etm8", (unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24),
                       tmp);
  }
#line 368
  if (psf->bytewidth == 1) {
#line 368
    tmp___0 = (unsigned int )((56 | (83 << 8)) | (86 << 16)) | (88U << 24);
  } else {
#line 368
    tmp___0 = (unsigned int )((49 | (54 << 8)) | (83 << 16)) | (86U << 24);
  }
  {
#line 368
  psf_binheader_writef(psf, "m", tmp___0);
#line 371
  psf_binheader_writef(psf, "Em4\330\204U", (unsigned int )((86 | (72 << 8)) | (68 << 16)) | (82U << 24),
                       sizeof(VHDR_CHUNK ));
#line 373
  psf_binheader_writef(psf, "E444\204U", psf->sf.frames, 0, 0);
#line 375
  psf_binheader_writef(psf, "E211\204U", psf->sf.samplerate, 1, 0);
  }
#line 377
  if (psf->bytewidth == 1) {
#line 377
    tmp___1 = 255;
  } else {
#line 377
    tmp___1 = 65535;
  }
  {
#line 377
  psf_binheader_writef(psf, "E4\336\330\204U", tmp___1);
  }
#line 379
  if (psf->sf.channels == 2) {
    {
#line 380
    psf_binheader_writef(psf, "Em44", (unsigned int )((67 | (72 << 8)) | (65 << 16)) | (78U << 24),
                         4, 6);
    }
  }
  {
#line 383
  psf_binheader_writef(psf, "EmsmsU", (unsigned int )((78 | (65 << 8)) | (77 << 16)) | (69U << 24),
                       psf->file.name.c, (unsigned int )((65 | (78 << 8)) | (78 << 16)) | (79U << 24),
                       annotation);
  }
#line 386
  if (psf->datalength < 0L) {
#line 386
    tmp___2 = 0L;
  } else {
#line 386
    tmp___2 = psf->datalength;
  }
  {
#line 386
  psf_binheader_writef(psf, "Etm8", (unsigned int )((66 | (79 << 8)) | (68 << 16)) | (89U << 24),
                       tmp___2);
#line 389
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 391
  if (psf->error) {
#line 392
    return (psf->error);
  }
#line 394
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 396
  if (current > 0L) {
    {
#line 397
    psf_fseek(psf, current, 0);
    }
  }
#line 399
  return (psf->error);
}
}
#line 68 "/root/patchweave_donee/23/src/sds.c"
static int sds_close(SF_PRIVATE *psf ) ;
#line 70
static int sds_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 71
static int sds_read_header(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 73
static int sds_init(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 75
static sf_count_t sds_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 76
static sf_count_t sds_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 77
static sf_count_t sds_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 78
static sf_count_t sds_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 80
static sf_count_t sds_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 81
static sf_count_t sds_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 82
static sf_count_t sds_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 83
static sf_count_t sds_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 85
static sf_count_t sds_seek(SF_PRIVATE *psf , int mode , sf_count_t seek_from_start ) ;
#line 86
static int sds_byterate(SF_PRIVATE *psf ) ;
#line 88
static int sds_2byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 89
static int sds_3byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 90
static int sds_4byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 92
static int sds_read(SF_PRIVATE *psf , SDS_PRIVATE *psds , int *ptr , int len ) ;
#line 94
static int sds_2byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 95
static int sds_3byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 96
static int sds_4byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 98
static int sds_write(SF_PRIVATE *psf , SDS_PRIVATE *psds , int const   *ptr , int len ) ;
#line 105 "/root/patchweave_donee/23/src/sds.c"
int sds_open(SF_PRIVATE *psf ) 
{ 
  SDS_PRIVATE *psds ;
  int error ;
  int __cil_tmp6 ;
  void *tmp ;

  {
  {
#line 107
  error = 0;
#line 110
  psf->sf.frames = (sf_count_t )0;
#line 112
  tmp = calloc(1UL, sizeof(SDS_PRIVATE ));
#line 112
  psds = (SDS_PRIVATE *)tmp;
  }
#line 112
  if (! psds) {
#line 113
    return (17);
  }
#line 114
  psf->codec_data = (void *)psds;
#line 116
  if (psf->file.mode == 16) {
    _L: 
    {
#line 117
    error = sds_read_header(psf, psds);
    }
#line 117
    if (error) {
#line 118
      return (error);
    }
  } else
#line 116
  if (psf->file.mode == 48) {
#line 116
    if (psf->filelength > 0L) {
#line 116
      goto _L;
    }
  }
#line 121
  if ((psf->sf.format & 268369920) != 1114112) {
#line 122
    return (1);
  }
#line 124
  if (psf->file.mode == 32) {
    _L___25: 
    {
#line 125
    __cil_tmp6 = sds_write_header(psf, 0);
    }
#line 125
    if (__cil_tmp6) {
#line 126
      return (psf->error);
    }
    {
#line 128
    psf->write_header = & sds_write_header;
#line 130
    psf_fseek(psf, (sf_count_t )21, 0);
    }
  } else
#line 124
  if (psf->file.mode == 48) {
#line 124
    goto _L___25;
  }
  {
#line 133
  error = sds_init(psf, psds);
  }
#line 133
  if (error != 0) {
#line 134
    return (error);
  }
#line 136
  psf->container_close = & sds_close;
#line 137
  psf->seek = & sds_seek;
#line 138
  psf->byterate = & sds_byterate;
#line 140
  psf->blockwidth = 0;
#line 142
  return (error);
}
}
#line 149 "/root/patchweave_donee/23/src/sds.c"
static int sds_close(SF_PRIVATE *psf ) 
{ 
  SDS_PRIVATE *psds ;

  {
#line 151
  if (psf->file.mode == 32) {
    _L: 
#line 154
    psds = (SDS_PRIVATE *)psf->codec_data;
#line 154
    if ((unsigned long )psds == (unsigned long )((void *)0)) {
      {
#line 155
      psf_log_printf(psf, "*** Bad psf->codec_data ptr.\n");
      }
#line 156
      return (30);
    }
#line 159
    if (psds->write_count > 0) {
      {
#line 160
      memset((void *)(& psds->write_data[psds->write_count]), 0, (unsigned long )(psds->samplesperblock - psds->write_count) * sizeof(int ));
#line 161
      (*(psds->writer))(psf, psds);
      }
    }
    {
#line 164
    sds_write_header(psf, 1);
    }
  } else
#line 151
  if (psf->file.mode == 48) {
#line 151
    goto _L;
  }
#line 167
  return (0);
}
}
#line 171 "/root/patchweave_donee/23/src/sds.c"
static int sds_init(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 


  {
#line 173
  if (psds->bitwidth < 8) {
#line 174
    psf->error = 145;
#line 174
    return (psf->error);
  } else
#line 173
  if (psds->bitwidth > 28) {
#line 174
    psf->error = 145;
#line 174
    return (psf->error);
  }
#line 176
  if (psds->bitwidth < 14) {
#line 177
    psds->reader = & sds_2byte_read;
#line 178
    psds->writer = & sds_2byte_write;
#line 179
    psds->samplesperblock = 60;
  } else
#line 181
  if (psds->bitwidth < 21) {
#line 182
    psds->reader = & sds_3byte_read;
#line 183
    psds->writer = & sds_3byte_write;
#line 184
    psds->samplesperblock = 40;
  } else {
#line 187
    psds->reader = & sds_4byte_read;
#line 188
    psds->writer = & sds_4byte_write;
#line 189
    psds->samplesperblock = 30;
  }
#line 192
  if (psf->file.mode == 16) {
    {
#line 193
    psf->read_short = & sds_read_s;
#line 194
    psf->read_int = & sds_read_i;
#line 195
    psf->read_float = & sds_read_f;
#line 196
    psf->read_double = & sds_read_d;
#line 199
    (*(psds->reader))(psf, psds);
    }
  } else
#line 192
  if (psf->file.mode == 48) {
    {
#line 193
    psf->read_short = & sds_read_s;
#line 194
    psf->read_int = & sds_read_i;
#line 195
    psf->read_float = & sds_read_f;
#line 196
    psf->read_double = & sds_read_d;
#line 199
    (*(psds->reader))(psf, psds);
    }
  }
#line 202
  if (psf->file.mode == 32) {
#line 203
    psf->write_short = & sds_write_s;
#line 204
    psf->write_int = & sds_write_i;
#line 205
    psf->write_float = & sds_write_f;
#line 206
    psf->write_double = & sds_write_d;
  } else
#line 202
  if (psf->file.mode == 48) {
#line 203
    psf->write_short = & sds_write_s;
#line 204
    psf->write_int = & sds_write_i;
#line 205
    psf->write_float = & sds_write_f;
#line 206
    psf->write_double = & sds_write_d;
  }
#line 209
  return (0);
}
}
#line 213 "/root/patchweave_donee/23/src/sds.c"
static int sds_read_header(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char channel ;
  unsigned char bitwidth ;
  unsigned char loop_type ;
  unsigned char byte ;
  unsigned short sample_no ;
  unsigned short marker ;
  unsigned int samp_period ;
  unsigned int data_length ;
  unsigned int sustain_loop_start ;
  unsigned int sustain_loop_end ;
  int bytesread ;
  int blockcount ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  sf_count_t __cil_tmp20 ;

  {
  {
#line 220
  bytesread = psf_binheader_readf(psf, "pE211U", 0, & marker, & channel, & byte);
  }
#line 222
  if ((int )marker != 61566) {
#line 223
    return (144);
  } else
#line 222
  if ((int )byte != 1) {
#line 223
    return (144);
  }
  {
#line 225
  __cil_tmp16 = psf_binheader_readf(psf, "e2", & sample_no);
#line 225
  bytesread += __cil_tmp16;
#line 226
  sample_no = (unsigned short )((((int )sample_no & 127) | (((int )sample_no & 32512) >> 1)) | (((int )sample_no & 8323072) >> 2));
#line 228
  psf_log_printf(psf, "Midi Sample Dump Standard (.sds)\nF07E\n Midi Channel  : %d\n Sample Number : %d\n",
                 (int )channel, (int )sample_no);
#line 232
  __cil_tmp17 = psf_binheader_readf(psf, "e13\331\204U", & bitwidth, & samp_period);
#line 232
  bytesread += __cil_tmp17;
#line 234
  samp_period = ((samp_period & 127U) | ((samp_period & 32512U) >> 1)) | ((samp_period & 8323072U) >> 2);
#line 236
  psds->bitwidth = (int )bitwidth;
  }
#line 238
  if (psds->bitwidth > 1) {
    {
#line 239
    psf_log_printf(psf, " Bit Width     : %d\n", psds->bitwidth);
    }
  } else {
    {
#line 241
    psf_log_printf(psf, " Bit Width     : %d (should be > 1)\n\204U", psds->bitwidth);
    }
#line 242
    return (145);
  }
#line 245
  if (samp_period > 0U) {
    {
#line 246
    psf->sf.samplerate = (int )(1000000000U / samp_period);
#line 248
    psf_log_printf(psf, " Sample Period : %d\n Sample Rate   : %d\n", samp_period,
                   psf->sf.samplerate);
    }
  } else {
    {
#line 253
    psf->sf.samplerate = 16000;
#line 255
    psf_log_printf(psf, " Sample Period : %d (should be > 0)\n Sample Rate   : %d (guessed)\n",
                   samp_period, psf->sf.samplerate);
    }
  }
  {
#line 260
  __cil_tmp18 = psf_binheader_readf(psf, "e3331", & data_length, & sustain_loop_start,
                                    & sustain_loop_end, & loop_type);
#line 260
  bytesread += __cil_tmp18;
#line 262
  data_length = ((data_length & 127U) | ((data_length & 32512U) >> 1)) | ((data_length & 8323072U) >> 2);
#line 264
  psds->frames = (int )data_length;
#line 264
  psf->sf.frames = (sf_count_t )psds->frames;
#line 266
  sustain_loop_start = ((sustain_loop_start & 127U) | ((sustain_loop_start & 32512U) >> 1)) | ((sustain_loop_start & 8323072U) >> 2);
#line 267
  sustain_loop_end = ((sustain_loop_end & 127U) | ((sustain_loop_end & 32512U) >> 1)) | ((sustain_loop_end & 8323072U) >> 2);
#line 269
  psf_log_printf(psf, " Sustain Loop\n     Start     : %d\n     End       : %d\n     Loop Type : %d\n",
                 sustain_loop_start, sustain_loop_end, (int )loop_type);
#line 275
  psf->dataoffset = (sf_count_t )21;
#line 276
  psf->datalength = psf->filelength - psf->dataoffset;
#line 278
  __cil_tmp19 = psf_binheader_readf(psf, "1", & byte);
#line 278
  bytesread += __cil_tmp19;
  }
#line 279
  if ((int )byte != 247) {
    {
#line 280
    psf_log_printf(psf, "bad end : %X\n", (int )byte & 255);
    }
  }
#line 282
  blockcount = 0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;

#line 282
    if (! ((long )bytesread < psf->filelength)) {
#line 282
      goto while_break;
    }
    {
#line 284
    __cil_tmp20 = psf_fread((void *)(& marker), (sf_count_t )1, (sf_count_t )2, psf);
#line 284
    bytesread = (int )((sf_count_t )bytesread + __cil_tmp20);
    }
#line 286
    if ((int )marker == 0) {
#line 287
      goto while_break;
    }
    {
#line 289
    psf_fseek(psf, (sf_count_t )125, 1);
#line 290
    bytesread += 125;
#line 282
    blockcount ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 293
  psf_log_printf(psf, "\nBlocks         : %d\n", blockcount);
#line 294
  psds->total_blocks = blockcount;
#line 296
  psds->samplesperblock = 120 / ((psds->bitwidth + 6) / 7);
#line 297
  psf_log_printf(psf, "Samples/Block  : %d\n", psds->samplesperblock);
#line 299
  psf_log_printf(psf, "Frames         : %d\n", blockcount * psds->samplesperblock);
#line 302
  psf->sf.channels = 1;
#line 303
  psf->sf.sections = 1;
  }
#line 310
  if ((psds->bitwidth + 7) / 8 == 1) {
#line 310
    goto case_1;
  }
#line 314
  if ((psds->bitwidth + 7) / 8 == 2) {
#line 314
    goto case_2;
  }
#line 318
  if ((psds->bitwidth + 7) / 8 == 3) {
#line 318
    goto case_3;
  }
#line 322
  if ((psds->bitwidth + 7) / 8 == 4) {
#line 322
    goto case_4;
  }
#line 326
  goto switch_default;
  case_1: 
#line 311
  psf->sf.format = 1114113;
#line 312
  goto switch_break;
  case_2: 
#line 315
  psf->sf.format = 1114114;
#line 316
  goto switch_break;
  case_3: 
#line 319
  psf->sf.format = 1114115;
#line 320
  goto switch_break;
  case_4: 
#line 323
  psf->sf.format = 1114116;
#line 324
  goto switch_break;
  switch_default: 
  {
#line 327
  psf_log_printf(psf, "*** Weird byte width (%d)\n", (psds->bitwidth + 7) / 8);
  }
#line 328
  return (145);
  switch_break: 
  {
#line 331
  psf_fseek(psf, (sf_count_t )21, 0);
  }
#line 333
  return (0);
}
}
#line 337 "/root/patchweave_donee/23/src/sds.c"
static int sds_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  SDS_PRIVATE *psds ;
  sf_count_t current ;
  int samp_period ;
  int data_length ;
  int sustain_loop_start ;
  int sustain_loop_end ;
  unsigned char loop_type ;
  int current_count ;
  int current_block ;

  {
#line 341
  loop_type = (unsigned char)0;
#line 343
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 343
  if ((unsigned long )psds == (unsigned long )((void *)0)) {
    {
#line 344
    psf_log_printf(psf, "*** Bad psf->codec_data ptr.\n");
    }
#line 345
    return (30);
  }
#line 348
  if (psf->pipeoffset > 0L) {
#line 349
    return (0);
  }
  {
#line 351
  current = psf_ftell(psf);
  }
#line 353
  if (calc_length) {
#line 354
    psf->sf.frames = (sf_count_t )psds->total_written;
  }
#line 356
  if (psds->write_count > 0) {
    {
#line 357
    current_count = psds->write_count;
#line 358
    current_block = psds->write_block;
#line 360
    (*(psds->writer))(psf, psds);
#line 362
    psf_fseek(psf, (sf_count_t )-127, 1);
#line 364
    psds->write_count = current_count;
#line 365
    psds->write_block = current_block;
    }
  }
#line 369
  psf->header[0] = (unsigned char)0;
#line 370
  psf->headindex = 0;
#line 372
  if (psf->is_pipe == 0) {
    {
#line 373
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 375
  psf_binheader_writef(psf, "E211", 61566, 0, 1);
  }
#line 378
  if ((psf->sf.format & 65535) == 1) {
#line 378
    goto case_1;
  }
#line 381
  if ((psf->sf.format & 65535) == 2) {
#line 381
    goto case_2;
  }
#line 384
  if ((psf->sf.format & 65535) == 3) {
#line 384
    goto case_3;
  }
#line 387
  goto switch_default;
  case_1: 
#line 379
  psds->bitwidth = 8;
#line 380
  goto switch_break;
  case_2: 
#line 382
  psds->bitwidth = 16;
#line 383
  goto switch_break;
  case_3: 
#line 385
  psds->bitwidth = 24;
#line 386
  goto switch_break;
  switch_default: 
#line 388
  return (145);
  switch_break: 
  {
#line 391
  samp_period = ((1000000000 / psf->sf.samplerate & 127) | ((1000000000 / psf->sf.samplerate << 1) & 32512)) | ((1000000000 / psf->sf.samplerate << 2) & 8323072);
#line 393
  psf_binheader_writef(psf, "e213", 0, psds->bitwidth, samp_period);
#line 395
  data_length = ((psds->total_written & 127) | ((psds->total_written << 1) & 32512)) | ((psds->total_written << 2) & 8323072);
#line 396
  sustain_loop_start = 0;
#line 397
  sustain_loop_end = 0;
#line 399
  psf_binheader_writef(psf, "e33311", data_length, sustain_loop_start, sustain_loop_end,
                       (int )loop_type, 247);
#line 402
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 404
  if (psf->error) {
#line 405
    return (psf->error);
  }
#line 407
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 408
  psf->datalength = (sf_count_t )(psds->write_block * 127);
#line 410
  if (current > 0L) {
    {
#line 411
    psf_fseek(psf, current, 0);
    }
  }
#line 413
  return (psf->error);
}
}
#line 421 "/root/patchweave_donee/23/src/sds.c"
static int sds_2byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  sf_count_t __cil_tmp8 ;
  int32_t __cil_tmp10 ;
  int32_t __cil_tmp11 ;

  {
#line 426
  (psds->read_block) ++;
#line 427
  psds->read_count = 0;
#line 429
  if (psds->read_block * psds->samplesperblock > psds->frames) {
    {
#line 430
    memset((void *)(psds->read_samples), 0, (unsigned long )psds->samplesperblock * sizeof(int ));
    }
#line 431
    return (1);
  }
  {
#line 434
  __cil_tmp8 = psf_fread((void *)(psds->read_data), (sf_count_t )1, (sf_count_t )127,
                         psf);
#line 434
  k = (int )__cil_tmp8;
  }
#line 434
  if (k != 127) {
    {
#line 435
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, 127);
    }
  }
#line 437
  if ((int )psds->read_data[0] != 240) {
    {
#line 438
    printf("Error A : %02X\n", (int )psds->read_data[0] & 255);
    }
  }
#line 441
  checksum = psds->read_data[1];
#line 442
  if ((int )checksum != 126) {
    {
#line 443
    printf("Error 1 : %02X\n", (int )checksum & 255);
    }
  }
#line 446
  k = 2;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;

#line 446
    if (! (k <= 124)) {
#line 446
      goto while_break;
    }
#line 447
    checksum = (unsigned char )((int )checksum ^ (int )psds->read_data[k]);
#line 446
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 449
  checksum = (unsigned char )((int )checksum & 127);
#line 451
  if ((int )checksum != (int )psds->read_data[125]) {
    {
#line 452
    psf_log_printf(psf, "Block %d : checksum is %02X should be %02X\n", (int )psds->read_data[4],
                   (int )checksum, (int )psds->read_data[125]);
    }
  }
#line 455
  ucptr = psds->read_data + 5;
#line 456
  k = 0;
  {
#line 456
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 456
    if (! (k < 120)) {
#line 456
      goto while_break___0;
    }
    {
#line 457
    __cil_tmp11 = arith_shift_left((int32_t )*(ucptr + (k + 1)), 18);
#line 457
    __cil_tmp10 = arith_shift_left((int32_t )*(ucptr + k), 25);
#line 457
    sample = (unsigned int )(__cil_tmp10 + __cil_tmp11);
#line 458
    psds->read_samples[k / 2] = (int )(sample - 2147483648U);
#line 456
    k += 2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 461
  return (1);
}
}
#line 465 "/root/patchweave_donee/23/src/sds.c"
static int sds_3byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  sf_count_t __cil_tmp8 ;

  {
#line 470
  (psds->read_block) ++;
#line 471
  psds->read_count = 0;
#line 473
  if (psds->read_block * psds->samplesperblock > psds->frames) {
    {
#line 474
    memset((void *)(psds->read_samples), 0, (unsigned long )psds->samplesperblock * sizeof(int ));
    }
#line 475
    return (1);
  }
  {
#line 478
  __cil_tmp8 = psf_fread((void *)(psds->read_data), (sf_count_t )1, (sf_count_t )127,
                         psf);
#line 478
  k = (int )__cil_tmp8;
  }
#line 478
  if (k != 127) {
    {
#line 479
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nU", k, 127);
    }
  }
#line 481
  if ((int )psds->read_data[0] != 240) {
    {
#line 482
    printf("Error A : %02X\n", (int )psds->read_data[0] & 255);
    }
  }
#line 485
  checksum = psds->read_data[1];
#line 486
  if ((int )checksum != 126) {
    {
#line 487
    printf("Error 1 : %02X\n", (int )checksum & 255);
    }
  }
#line 490
  k = 2;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;

#line 490
    if (! (k <= 124)) {
#line 490
      goto while_break;
    }
#line 491
    checksum = (unsigned char )((int )checksum ^ (int )psds->read_data[k]);
#line 490
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 493
  checksum = (unsigned char )((int )checksum & 127);
#line 495
  if ((int )checksum != (int )psds->read_data[125]) {
    {
#line 496
    psf_log_printf(psf, "Block %d : checksum is %02X should be %02X\n\331\204U", (int )psds->read_data[4],
                   (int )checksum, (int )psds->read_data[125]);
    }
  }
#line 499
  ucptr = psds->read_data + 5;
#line 500
  k = 0;
  {
#line 500
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 500
    if (! (k < 120)) {
#line 500
      goto while_break___0;
    }
#line 501
    sample = (((uint32_t )*(ucptr + k) << 25) + (unsigned int )((int )*(ucptr + (k + 1)) << 18)) + (unsigned int )((int )*(ucptr + (k + 2)) << 11);
#line 502
    psds->read_samples[k / 3] = (int )(sample - 2147483648U);
#line 500
    k += 3;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 505
  return (1);
}
}
#line 509 "/root/patchweave_donee/23/src/sds.c"
static int sds_4byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  uint32_t sample ;
  int k ;
  sf_count_t __cil_tmp8 ;

  {
#line 514
  (psds->read_block) ++;
#line 515
  psds->read_count = 0;
#line 517
  if (psds->read_block * psds->samplesperblock > psds->frames) {
    {
#line 518
    memset((void *)(psds->read_samples), 0, (unsigned long )psds->samplesperblock * sizeof(int ));
    }
#line 519
    return (1);
  }
  {
#line 522
  __cil_tmp8 = psf_fread((void *)(psds->read_data), (sf_count_t )1, (sf_count_t )127,
                         psf);
#line 522
  k = (int )__cil_tmp8;
  }
#line 522
  if (k != 127) {
    {
#line 523
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, 127);
    }
  }
#line 525
  if ((int )psds->read_data[0] != 240) {
    {
#line 526
    printf("Error A : %02X\n", (int )psds->read_data[0] & 255);
    }
  }
#line 529
  checksum = psds->read_data[1];
#line 530
  if ((int )checksum != 126) {
    {
#line 531
    printf("Error 1 : %02X\n", (int )checksum & 255);
    }
  }
#line 534
  k = 2;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;

#line 534
    if (! (k <= 124)) {
#line 534
      goto while_break;
    }
#line 535
    checksum = (unsigned char )((int )checksum ^ (int )psds->read_data[k]);
#line 534
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 537
  checksum = (unsigned char )((int )checksum & 127);
#line 539
  if ((int )checksum != (int )psds->read_data[125]) {
    {
#line 540
    psf_log_printf(psf, "Block %d : checksum is %02X should be %02X\n\331\204U", (int )psds->read_data[4],
                   (int )checksum, (int )psds->read_data[125]);
    }
  }
#line 543
  ucptr = psds->read_data + 5;
#line 544
  k = 0;
  {
#line 544
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 544
    if (! (k < 120)) {
#line 544
      goto while_break___0;
    }
#line 545
    sample = ((((uint32_t )*(ucptr + k) << 25) + (unsigned int )((int )*(ucptr + (k + 1)) << 18)) + (unsigned int )((int )*(ucptr + (k + 2)) << 11)) + (unsigned int )((int )*(ucptr + (k + 3)) << 4);
#line 546
    psds->read_samples[k / 4] = (int )(sample - 2147483648U);
#line 544
    k += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 549
  return (1);
}
}
#line 554 "/root/patchweave_donee/23/src/sds.c"
static sf_count_t sds_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 559
  total = (sf_count_t )0;
#line 561
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 562
    return ((sf_count_t )0);
  }
#line 563
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 565
  iptr = ubuf.ibuf;
#line 566
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;

#line 567
    if (! (len > 0L)) {
#line 567
      goto while_break;
    }
#line 568
    if (len >= (long )bufferlen) {
#line 568
      tmp = (long )bufferlen;
    } else {
#line 568
      tmp = len;
    }
    {
#line 568
    readcount = (int )tmp;
#line 569
    count___0 = sds_read(psf, psds, iptr, readcount);
#line 570
    k = 0;
    }
    {
#line 570
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 570
      if (! (k < readcount)) {
#line 570
        goto while_break___0;
      }
#line 571
      *(ptr + (total + (long )k)) = (short )(*(iptr + k) >> 16);
#line 570
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 572
    total += (long )count___0;
#line 573
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 576
  return (total);
}
}
#line 580 "/root/patchweave_donee/23/src/sds.c"
static sf_count_t sds_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int total ;

  {
#line 584
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 585
    return ((sf_count_t )0);
  }
  {
#line 586
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 588
  total = sds_read(psf, psds, ptr, (int )len);
  }
#line 590
  return ((sf_count_t )total);
}
}
#line 594 "/root/patchweave_donee/23/src/sds.c"
static sf_count_t sds_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  long tmp ;

  {
#line 599
  total = (sf_count_t )0;
#line 602
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 603
    return ((sf_count_t )0);
  }
#line 604
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 606
  if (psf->norm_float == 1) {
#line 607
    normfact = (float )(1. / (double )2147483648U);
  } else {
#line 609
    normfact = (float )(1. / (double )(1 << psds->bitwidth));
  }
#line 611
  iptr = ubuf.ibuf;
#line 612
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;

#line 613
    if (! (len > 0L)) {
#line 613
      goto while_break;
    }
#line 614
    if (len >= (long )bufferlen) {
#line 614
      tmp = (long )bufferlen;
    } else {
#line 614
      tmp = len;
    }
    {
#line 614
    readcount = (int )tmp;
#line 615
    count___0 = sds_read(psf, psds, iptr, readcount);
#line 616
    k = 0;
    }
    {
#line 616
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 616
      if (! (k < readcount)) {
#line 616
        goto while_break___0;
      }
#line 617
      *(ptr + (total + (long )k)) = normfact * (float )*(iptr + k);
#line 616
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 618
    total += (long )count___0;
#line 619
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 622
  return (total);
}
}
#line 626 "/root/patchweave_donee/23/src/sds.c"
static sf_count_t sds_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  long tmp ;

  {
#line 631
  total = (sf_count_t )0;
#line 634
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 635
    return ((sf_count_t )0);
  }
#line 636
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 638
  if (psf->norm_double == 1) {
#line 639
    normfact = 1. / (double )2147483648U;
  } else {
#line 641
    normfact = 1. / (double )(1 << psds->bitwidth);
  }
#line 643
  iptr = ubuf.ibuf;
#line 644
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;

#line 645
    if (! (len > 0L)) {
#line 645
      goto while_break;
    }
#line 646
    if (len >= (long )bufferlen) {
#line 646
      tmp = (long )bufferlen;
    } else {
#line 646
      tmp = len;
    }
    {
#line 646
    readcount = (int )tmp;
#line 647
    count___0 = sds_read(psf, psds, iptr, readcount);
#line 648
    k = 0;
    }
    {
#line 648
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 648
      if (! (k < readcount)) {
#line 648
        goto while_break___0;
      }
#line 649
      *(ptr + (total + (long )k)) = normfact * (double )*(iptr + k);
#line 648
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 650
    total += (long )count___0;
#line 651
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 654
  return (total);
}
}
#line 658 "/root/patchweave_donee/23/src/sds.c"
static int sds_read(SF_PRIVATE *psf , SDS_PRIVATE *psds , int *ptr , int len ) 
{ 
  int count___0 ;
  int total ;
  int tmp ;

  {
#line 659
  total = 0;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;

#line 661
    if (! (total < len)) {
#line 661
      goto while_break;
    }
#line 662
    if (psds->read_block * psds->samplesperblock >= psds->frames) {
      {
#line 663
      memset((void *)(ptr + total), 0, (unsigned long )(len - total) * sizeof(int ));
      }
#line 664
      return (total);
    }
#line 667
    if (psds->read_count >= psds->samplesperblock) {
      {
#line 668
      (*(psds->reader))(psf, psds);
      }
    }
#line 670
    count___0 = psds->samplesperblock - psds->read_count;
#line 671
    if (len - total > count___0) {
#line 671
      tmp = count___0;
    } else {
#line 671
      tmp = len - total;
    }
    {
#line 671
    count___0 = tmp;
#line 673
    memcpy((void *)(ptr + total), (void const   *)(& psds->read_samples[psds->read_count]),
           (unsigned long )count___0 * sizeof(int ));
#line 674
    total += count___0;
#line 675
    psds->read_count += count___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 678
  return (total);
}
}
#line 685 "/root/patchweave_donee/23/src/sds.c"
static sf_count_t sds_seek(SF_PRIVATE *psf , int mode , sf_count_t seek_from_start ) 
{ 
  SDS_PRIVATE *psds ;
  sf_count_t file_offset ;
  int newblock ;
  int newsample ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 690
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 690
  if ((unsigned long )psds == (unsigned long )((void *)0)) {
#line 691
    psf->error = 30;
#line 692
    return ((sf_count_t )-1);
  }
#line 695
  if (psf->datalength < 0L) {
#line 696
    psf->error = 39;
#line 697
    return ((sf_count_t )-1);
  } else
#line 695
  if (psf->dataoffset < 0L) {
#line 696
    psf->error = 39;
#line 697
    return ((sf_count_t )-1);
  }
#line 700
  if (seek_from_start < 0L) {
#line 701
    psf->error = 39;
#line 702
    return ((sf_count_t )-1);
  } else
#line 700
  if (seek_from_start > psf->sf.frames) {
#line 701
    psf->error = 39;
#line 702
    return ((sf_count_t )-1);
  }
#line 705
  if (mode == 16) {
#line 705
    if (psds->write_count > 0) {
      {
#line 706
      (*(psds->writer))(psf, psds);
      }
    }
  }
#line 708
  newblock = (int )(seek_from_start / (long )psds->samplesperblock);
#line 709
  newsample = (int )(seek_from_start % (long )psds->samplesperblock);
#line 712
  if (mode == 16) {
#line 712
    goto case_16;
  }
#line 730
  if (mode == 32) {
#line 730
    goto case_32;
  }
#line 748
  goto switch_default;
  case_16: 
#line 713
  if (newblock > psds->total_blocks) {
#line 714
    psf->error = 39;
#line 715
    return ((sf_count_t )-1);
  }
  {
#line 718
  file_offset = psf->dataoffset + (long )(newblock * 127);
#line 720
  __cil_tmp8 = psf_fseek(psf, file_offset, 0);
  }
#line 720
  if (__cil_tmp8 != file_offset) {
#line 721
    psf->error = 43;
#line 722
    return ((sf_count_t )-1);
  }
  {
#line 725
  psds->read_block = newblock;
#line 726
  (*(psds->reader))(psf, psds);
#line 727
  psds->read_count = newsample;
  }
#line 728
  goto switch_break;
  case_32: 
#line 731
  if (newblock > psds->total_blocks) {
#line 732
    psf->error = 39;
#line 733
    return ((sf_count_t )-1);
  }
  {
#line 736
  file_offset = psf->dataoffset + (long )(newblock * 127);
#line 738
  __cil_tmp9 = psf_fseek(psf, file_offset, 0);
  }
#line 738
  if (__cil_tmp9 != file_offset) {
#line 739
    psf->error = 43;
#line 740
    return ((sf_count_t )-1);
  }
  {
#line 743
  psds->write_block = newblock;
#line 744
  (*(psds->reader))(psf, psds);
#line 745
  psds->write_count = newsample;
  }
#line 746
  goto switch_break;
  switch_default: 
#line 749
  psf->error = 39;
#line 750
  return ((sf_count_t )-1);
#line 751
  goto switch_break;
  switch_break: ;
#line 754
  return (seek_from_start);
}
}
#line 758 "/root/patchweave_donee/23/src/sds.c"
static int sds_byterate(SF_PRIVATE *psf ) 
{ 


  {
#line 760
  if (psf->file.mode == 16) {
#line 761
    return ((int )((psf->datalength * (long )psf->sf.samplerate) / psf->sf.frames));
  }
#line 763
  return (-1);
}
}
#line 770 "/root/patchweave_donee/23/src/sds.c"
static int sds_2byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  sf_count_t __cil_tmp8 ;

  {
#line 775
  psds->write_data[0] = (unsigned char)240;
#line 776
  psds->write_data[1] = (unsigned char)126;
#line 777
  psds->write_data[2] = (unsigned char)0;
#line 778
  psds->write_data[3] = (unsigned char)2;
#line 779
  psds->write_data[4] = (unsigned char )(psds->write_block & 127);
#line 781
  ucptr = psds->write_data + 5;
#line 782
  k = 0;
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;

#line 782
    if (! (k < 120)) {
#line 782
      goto while_break;
    }
#line 783
    sample = (unsigned int )psds->write_samples[k / 2];
#line 784
    sample += 2147483648U;
#line 785
    *(ucptr + k) = (unsigned char )((sample >> 25) & 127U);
#line 786
    *(ucptr + (k + 1)) = (unsigned char )((sample >> 18) & 127U);
#line 782
    k += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 789
  checksum = psds->write_data[1];
#line 790
  k = 2;
  {
#line 790
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 790
    if (! (k <= 124)) {
#line 790
      goto while_break___0;
    }
#line 791
    checksum = (unsigned char )((int )checksum ^ (int )psds->write_data[k]);
#line 790
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 792
  checksum = (unsigned char )((int )checksum & 127);
#line 794
  psds->write_data[125] = checksum;
#line 795
  psds->write_data[126] = (unsigned char)247;
#line 797
  __cil_tmp8 = psf_fwrite((void const   *)(psds->write_data), (sf_count_t )1, (sf_count_t )127,
                          psf);
#line 797
  k = (int )__cil_tmp8;
  }
#line 797
  if (k != 127) {
    {
#line 798
    psf_log_printf(psf, "*** Warning : psf_fwrite (%d != %d).\nU", k, 127);
    }
  }
#line 800
  (psds->write_block) ++;
#line 801
  psds->write_count = 0;
#line 803
  if (psds->write_block > psds->total_blocks) {
#line 804
    psds->total_blocks = psds->write_block;
  }
#line 805
  psds->frames = psds->total_blocks * psds->samplesperblock;
#line 807
  return (1);
}
}
#line 811 "/root/patchweave_donee/23/src/sds.c"
static int sds_3byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  sf_count_t __cil_tmp8 ;

  {
#line 816
  psds->write_data[0] = (unsigned char)240;
#line 817
  psds->write_data[1] = (unsigned char)126;
#line 818
  psds->write_data[2] = (unsigned char)0;
#line 819
  psds->write_data[3] = (unsigned char)2;
#line 820
  psds->write_data[4] = (unsigned char )(psds->write_block & 127);
#line 822
  ucptr = psds->write_data + 5;
#line 823
  k = 0;
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;

#line 823
    if (! (k < 120)) {
#line 823
      goto while_break;
    }
#line 824
    sample = (unsigned int )psds->write_samples[k / 3];
#line 825
    sample += 2147483648U;
#line 826
    *(ucptr + k) = (unsigned char )((sample >> 25) & 127U);
#line 827
    *(ucptr + (k + 1)) = (unsigned char )((sample >> 18) & 127U);
#line 828
    *(ucptr + (k + 2)) = (unsigned char )((sample >> 11) & 127U);
#line 823
    k += 3;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 831
  checksum = psds->write_data[1];
#line 832
  k = 2;
  {
#line 832
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 832
    if (! (k <= 124)) {
#line 832
      goto while_break___0;
    }
#line 833
    checksum = (unsigned char )((int )checksum ^ (int )psds->write_data[k]);
#line 832
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 834
  checksum = (unsigned char )((int )checksum & 127);
#line 836
  psds->write_data[125] = checksum;
#line 837
  psds->write_data[126] = (unsigned char)247;
#line 839
  __cil_tmp8 = psf_fwrite((void const   *)(psds->write_data), (sf_count_t )1, (sf_count_t )127,
                          psf);
#line 839
  k = (int )__cil_tmp8;
  }
#line 839
  if (k != 127) {
    {
#line 840
    psf_log_printf(psf, "*** Warning : psf_fwrite (%d != %d).\n", k, 127);
    }
  }
#line 842
  (psds->write_block) ++;
#line 843
  psds->write_count = 0;
#line 845
  if (psds->write_block > psds->total_blocks) {
#line 846
    psds->total_blocks = psds->write_block;
  }
#line 847
  psds->frames = psds->total_blocks * psds->samplesperblock;
#line 849
  return (1);
}
}
#line 853 "/root/patchweave_donee/23/src/sds.c"
static int sds_4byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  sf_count_t __cil_tmp8 ;

  {
#line 858
  psds->write_data[0] = (unsigned char)240;
#line 859
  psds->write_data[1] = (unsigned char)126;
#line 860
  psds->write_data[2] = (unsigned char)0;
#line 861
  psds->write_data[3] = (unsigned char)2;
#line 862
  psds->write_data[4] = (unsigned char )(psds->write_block & 127);
#line 864
  ucptr = psds->write_data + 5;
#line 865
  k = 0;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;

#line 865
    if (! (k < 120)) {
#line 865
      goto while_break;
    }
#line 866
    sample = (unsigned int )psds->write_samples[k / 4];
#line 867
    sample += 2147483648U;
#line 868
    *(ucptr + k) = (unsigned char )((sample >> 25) & 127U);
#line 869
    *(ucptr + (k + 1)) = (unsigned char )((sample >> 18) & 127U);
#line 870
    *(ucptr + (k + 2)) = (unsigned char )((sample >> 11) & 127U);
#line 871
    *(ucptr + (k + 3)) = (unsigned char )((sample >> 4) & 127U);
#line 865
    k += 4;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 874
  checksum = psds->write_data[1];
#line 875
  k = 2;
  {
#line 875
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 875
    if (! (k <= 124)) {
#line 875
      goto while_break___0;
    }
#line 876
    checksum = (unsigned char )((int )checksum ^ (int )psds->write_data[k]);
#line 875
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 877
  checksum = (unsigned char )((int )checksum & 127);
#line 879
  psds->write_data[125] = checksum;
#line 880
  psds->write_data[126] = (unsigned char)247;
#line 882
  __cil_tmp8 = psf_fwrite((void const   *)(psds->write_data), (sf_count_t )1, (sf_count_t )127,
                          psf);
#line 882
  k = (int )__cil_tmp8;
  }
#line 882
  if (k != 127) {
    {
#line 883
    psf_log_printf(psf, "*** Warning : psf_fwrite (%d != %d).\n", k, 127);
    }
  }
#line 885
  (psds->write_block) ++;
#line 886
  psds->write_count = 0;
#line 888
  if (psds->write_block > psds->total_blocks) {
#line 889
    psds->total_blocks = psds->write_block;
  }
#line 890
  psds->frames = psds->total_blocks * psds->samplesperblock;
#line 892
  return (1);
}
}
#line 896 "/root/patchweave_donee/23/src/sds.c"
static sf_count_t sds_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 901
  total = (sf_count_t )0;
#line 903
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 904
    return ((sf_count_t )0);
  }
#line 905
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 906
  psds->total_written = (int )((sf_count_t )psds->total_written + len);
#line 908
  iptr = ubuf.ibuf;
#line 909
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 910
  while (1) {
    while_continue: /* CIL Label */ ;

#line 910
    if (! (len > 0L)) {
#line 910
      goto while_break;
    }
#line 911
    if (len >= (long )bufferlen) {
#line 911
      tmp = (long )bufferlen;
    } else {
#line 911
      tmp = len;
    }
#line 911
    writecount = (int )tmp;
#line 912
    k = 0;
    {
#line 912
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 912
      if (! (k < writecount)) {
#line 912
        goto while_break___0;
      }
      {
#line 913
      *(iptr + k) = arith_shift_left((int32_t )*(ptr + (total + (long )k)), 16);
#line 912
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 914
    count___0 = sds_write(psf, psds, (int const   *)iptr, writecount);
#line 915
    total += (long )count___0;
#line 916
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 919
  return (total);
}
}
#line 923 "/root/patchweave_donee/23/src/sds.c"
static sf_count_t sds_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int total ;

  {
#line 927
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 928
    return ((sf_count_t )0);
  }
  {
#line 929
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 930
  psds->total_written = (int )((sf_count_t )psds->total_written + len);
#line 932
  total = sds_write(psf, psds, ptr, (int )len);
  }
#line 934
  return ((sf_count_t )total);
}
}
#line 938 "/root/patchweave_donee/23/src/sds.c"
static sf_count_t sds_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  long tmp ;

  {
#line 943
  total = (sf_count_t )0;
#line 946
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 947
    return ((sf_count_t )0);
  }
#line 948
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 949
  psds->total_written = (int )((sf_count_t )psds->total_written + len);
#line 951
  if (psf->norm_float == 1) {
#line 952
    normfact = (float )(1. * (double )2147483648U);
  } else {
#line 954
    normfact = (float )(1. * (double )(1 << psds->bitwidth));
  }
#line 956
  iptr = ubuf.ibuf;
#line 957
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;

#line 958
    if (! (len > 0L)) {
#line 958
      goto while_break;
    }
#line 959
    if (len >= (long )bufferlen) {
#line 959
      tmp = (long )bufferlen;
    } else {
#line 959
      tmp = len;
    }
#line 959
    writecount = (int )tmp;
#line 960
    k = 0;
    {
#line 960
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 960
      if (! (k < writecount)) {
#line 960
        goto while_break___0;
      }
#line 961
      *(iptr + k) = (int )(normfact * (float )*(ptr + (total + (long )k)));
#line 960
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 962
    count___0 = sds_write(psf, psds, (int const   *)iptr, writecount);
#line 963
    total += (long )count___0;
#line 964
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 967
  return (total);
}
}
#line 971 "/root/patchweave_donee/23/src/sds.c"
static sf_count_t sds_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  long tmp ;

  {
#line 976
  total = (sf_count_t )0;
#line 979
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 980
    return ((sf_count_t )0);
  }
#line 981
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 982
  psds->total_written = (int )((sf_count_t )psds->total_written + len);
#line 984
  if (psf->norm_double == 1) {
#line 985
    normfact = 1. * (double )2147483648U;
  } else {
#line 987
    normfact = 1. * (double )(1 << psds->bitwidth);
  }
#line 989
  iptr = ubuf.ibuf;
#line 990
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;

#line 991
    if (! (len > 0L)) {
#line 991
      goto while_break;
    }
#line 992
    if (len >= (long )bufferlen) {
#line 992
      tmp = (long )bufferlen;
    } else {
#line 992
      tmp = len;
    }
#line 992
    writecount = (int )tmp;
#line 993
    k = 0;
    {
#line 993
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 993
      if (! (k < writecount)) {
#line 993
        goto while_break___0;
      }
#line 994
      *(iptr + k) = (int )(normfact * (double )*(ptr + (total + (long )k)));
#line 993
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 995
    count___0 = sds_write(psf, psds, (int const   *)iptr, writecount);
#line 996
    total += (long )count___0;
#line 997
    len -= (long )writecount;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1000
  return (total);
}
}
#line 1004 "/root/patchweave_donee/23/src/sds.c"
static int sds_write(SF_PRIVATE *psf , SDS_PRIVATE *psds , int const   *ptr , int len ) 
{ 
  int count___0 ;
  int total ;

  {
#line 1005
  total = 0;
  {
#line 1007
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1007
    if (! (total < len)) {
#line 1007
      goto while_break;
    }
#line 1008
    count___0 = psds->samplesperblock - psds->write_count;
#line 1009
    if (count___0 > len - total) {
#line 1010
      count___0 = len - total;
    }
    {
#line 1012
    memcpy((void *)(& psds->write_samples[psds->write_count]), (void const   *)(ptr + total),
           (unsigned long )count___0 * sizeof(int ));
#line 1013
    total += count___0;
#line 1014
    psds->write_count += count___0;
    }
#line 1016
    if (psds->write_count >= psds->samplesperblock) {
      {
#line 1017
      (*(psds->writer))(psf, psds);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1020
  return (total);
}
}
#line 89 "/root/patchweave_donee/23/src/sd2.c"
static int sd2_close(SF_PRIVATE *psf ) ;
#line 91
static int sd2_parse_rsrc_fork(SF_PRIVATE *psf ) ;
#line 92
static int parse_str_rsrc(SF_PRIVATE *psf , SD2_RSRC *rsrc ) ;
#line 94
static int sd2_write_rsrc_fork(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 101 "/root/patchweave_donee/23/src/sd2.c"
int sd2_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int valid ;

  {
#line 102
  error = 0;
#line 105
  psf->endian = 536870912;
#line 107
  if (psf->file.mode == 16) {
    _L: 
    {
#line 108
    psf_use_rsrc(psf, 1);
#line 109
    valid = psf_file_valid(psf);
#line 110
    psf_use_rsrc(psf, 0);
    }
#line 111
    if (! valid) {
      {
#line 112
      psf_log_printf(psf, "sd2_open : psf->rsrc.filedes < 0\n");
      }
#line 113
      return (151);
    }
    {
#line 116
    error = sd2_parse_rsrc_fork(psf);
    }
#line 118
    if (error) {
#line 119
      goto error_cleanup;
    }
  } else
#line 107
  if (psf->file.mode == 48) {
#line 107
    if (psf->rsrclength > 0L) {
#line 107
      goto _L;
    }
  }
#line 122
  if ((psf->sf.format & 268369920) != 1441792) {
#line 123
    error = 1;
#line 124
    goto error_cleanup;
  }
#line 127
  subformat = psf->sf.format & 65535;
#line 128
  psf->dataoffset = (sf_count_t )0;
#line 131
  if (psf->file.mode == 32) {
    _L___26: 
    {
#line 132
    psf->rsrc.mode = psf->file.mode;
#line 133
    psf_open_rsrc(psf);
#line 135
    error = sd2_write_rsrc_fork(psf, 0);
    }
#line 137
    if (error) {
#line 138
      goto error_cleanup;
    }
#line 141
    psf->write_header = (int (*)(struct sf_private_tag * , int  ))((void *)0);
  } else
#line 131
  if (psf->file.mode == 48) {
#line 131
    if (psf->rsrclength == 0L) {
#line 131
      goto _L___26;
    }
  }
#line 144
  psf->container_close = & sd2_close;
#line 146
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 152
  if (subformat == 4) {
#line 152
    goto case_4;
  }
#line 152
  if (subformat == 3) {
#line 152
    goto case_4;
  }
#line 152
  if (subformat == 2) {
#line 152
    goto case_4;
  }
#line 152
  if (subformat == 1) {
#line 152
    goto case_4;
  }
#line 156
  goto switch_default;
  case_4: 
  {
#line 153
  error = pcm_init(psf);
  }
#line 154
  goto switch_break;
  switch_default: 
#line 157
  error = 18;
#line 158
  goto switch_break;
  switch_break: 
  {
#line 161
  psf_fseek(psf, psf->dataoffset, 0);
  }
  error_cleanup: 
  {
#line 166
  psf_close_rsrc(psf);
  }
#line 168
  return (error);
}
}
#line 175 "/root/patchweave_donee/23/src/sd2.c"
static int sd2_close(SF_PRIVATE *psf ) 
{ 


  {
#line 184
  return (0);
}
}
#line 191 "/root/patchweave_donee/23/src/sd2.c"
__inline static void write_char(unsigned char *data , int offset , char value___0 ) 
{ 


  {
#line 192
  *(data + offset) = (unsigned char )value___0;
#line 193
  return;
}
}
#line 196 "/root/patchweave_donee/23/src/sd2.c"
__inline static void write_short(unsigned char *data , int offset , short value___0 ) 
{ 


  {
#line 197
  *(data + offset) = (unsigned char )((int )value___0 >> 8);
#line 198
  *(data + (offset + 1)) = (unsigned char )value___0;
#line 199
  return;
}
}
#line 202 "/root/patchweave_donee/23/src/sd2.c"
__inline static void write_int(unsigned char *data , int offset , int value___0 ) 
{ 


  {
#line 203
  *(data + offset) = (unsigned char )(value___0 >> 24);
#line 204
  *(data + (offset + 1)) = (unsigned char )(value___0 >> 16);
#line 205
  *(data + (offset + 2)) = (unsigned char )(value___0 >> 8);
#line 206
  *(data + (offset + 3)) = (unsigned char )value___0;
#line 207
  return;
}
}
#line 210 "/root/patchweave_donee/23/src/sd2.c"
__inline static void write_marker(unsigned char *data , int offset , int value___0 ) 
{ 


  {
#line 219
  *(data + offset) = (unsigned char )value___0;
#line 220
  *(data + (offset + 1)) = (unsigned char )(value___0 >> 8);
#line 221
  *(data + (offset + 2)) = (unsigned char )(value___0 >> 16);
#line 222
  *(data + (offset + 3)) = (unsigned char )(value___0 >> 24);
#line 225
  return;
}
}
#line 227 "/root/patchweave_donee/23/src/sd2.c"
static void write_str(unsigned char *data , int offset , char const   *buffer , int buffer_len ) 
{ 


  {
  {
#line 228
  memcpy((void *)(data + offset), (void const   *)buffer, (unsigned long )buffer_len);
  }
#line 230
  return;
}
}
#line 232 "/root/patchweave_donee/23/src/sd2.c"
static int sd2_write_rsrc_fork(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  SD2_RSRC rsrc ;
  STR_RSRC str_rsrc[4] ;
  unsigned int tmp ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  int k ;
  int str_offset ;
  int data_offset ;
  int next_str ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;

  {
#line 234
  str_rsrc[0].type = 111;
#line 234
  str_rsrc[0].id = 1000;
#line 234
  str_rsrc[0].name[0] = (char )"_sample-size\204U";
#line 234
  str_rsrc[0].name[1] = (char )"\251";
#line 234
  str_rsrc[0].name[2] = (char)0;
#line 234
  tmp = 3U;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;

#line 234
    if (tmp >= 32U) {
#line 234
      goto while_break;
    }
#line 234
    str_rsrc[0].name[tmp] = (char)0;
#line 234
    tmp ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: 
#line 234
  str_rsrc[0].value[0] = (char)0;
#line 234
  str_rsrc[0].value[1] = (char)0;
#line 234
  str_rsrc[0].value[2] = (char)0;
#line 234
  str_rsrc[0].value[3] = (char)0;
#line 234
  str_rsrc[0].value[4] = (char)0;
#line 234
  str_rsrc[0].value[5] = (char)0;
#line 234
  str_rsrc[0].value[6] = (char)0;
#line 234
  str_rsrc[0].value[7] = (char)0;
#line 234
  str_rsrc[0].value[8] = (char)0;
#line 234
  str_rsrc[0].value[9] = (char)0;
#line 234
  str_rsrc[0].value[10] = (char)0;
#line 234
  str_rsrc[0].value[11] = (char)0;
#line 234
  str_rsrc[0].value[12] = (char)0;
#line 234
  str_rsrc[0].value[13] = (char)0;
#line 234
  str_rsrc[0].value[14] = (char)0;
#line 234
  str_rsrc[0].value[15] = (char)0;
#line 234
  str_rsrc[0].value[16] = (char)0;
#line 234
  str_rsrc[0].value[17] = (char)0;
#line 234
  str_rsrc[0].value[18] = (char)0;
#line 234
  str_rsrc[0].value[19] = (char)0;
#line 234
  str_rsrc[0].value[20] = (char)0;
#line 234
  str_rsrc[0].value[21] = (char)0;
#line 234
  str_rsrc[0].value[22] = (char)0;
#line 234
  str_rsrc[0].value[23] = (char)0;
#line 234
  str_rsrc[0].value[24] = (char)0;
#line 234
  str_rsrc[0].value[25] = (char)0;
#line 234
  str_rsrc[0].value[26] = (char)0;
#line 234
  str_rsrc[0].value[27] = (char)0;
#line 234
  str_rsrc[0].value[28] = (char)0;
#line 234
  str_rsrc[0].value[29] = (char)0;
#line 234
  str_rsrc[0].value[30] = (char)0;
#line 234
  str_rsrc[0].value[31] = (char)0;
#line 234
  str_rsrc[0].value_len = 0;
#line 234
  str_rsrc[1].type = 111;
#line 234
  str_rsrc[1].id = 1001;
#line 234
  str_rsrc[1].name[0] = (char )"_sample-rate";
#line 234
  str_rsrc[1].name[1] = (char )"\251";
#line 234
  str_rsrc[1].name[2] = (char)0;
#line 234
  tmp___27 = 3U;
  {
#line 234
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 234
    if (tmp___27 >= 32U) {
#line 234
      goto while_break___0;
    }
#line 234
    str_rsrc[1].name[tmp___27] = (char)0;
#line 234
    tmp___27 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___0: 
#line 234
  str_rsrc[1].value[0] = (char)0;
#line 234
  str_rsrc[1].value[1] = (char)0;
#line 234
  str_rsrc[1].value[2] = (char)0;
#line 234
  str_rsrc[1].value[3] = (char)0;
#line 234
  str_rsrc[1].value[4] = (char)0;
#line 234
  str_rsrc[1].value[5] = (char)0;
#line 234
  str_rsrc[1].value[6] = (char)0;
#line 234
  str_rsrc[1].value[7] = (char)0;
#line 234
  str_rsrc[1].value[8] = (char)0;
#line 234
  str_rsrc[1].value[9] = (char)0;
#line 234
  str_rsrc[1].value[10] = (char)0;
#line 234
  str_rsrc[1].value[11] = (char)0;
#line 234
  str_rsrc[1].value[12] = (char)0;
#line 234
  str_rsrc[1].value[13] = (char)0;
#line 234
  str_rsrc[1].value[14] = (char)0;
#line 234
  str_rsrc[1].value[15] = (char)0;
#line 234
  str_rsrc[1].value[16] = (char)0;
#line 234
  str_rsrc[1].value[17] = (char)0;
#line 234
  str_rsrc[1].value[18] = (char)0;
#line 234
  str_rsrc[1].value[19] = (char)0;
#line 234
  str_rsrc[1].value[20] = (char)0;
#line 234
  str_rsrc[1].value[21] = (char)0;
#line 234
  str_rsrc[1].value[22] = (char)0;
#line 234
  str_rsrc[1].value[23] = (char)0;
#line 234
  str_rsrc[1].value[24] = (char)0;
#line 234
  str_rsrc[1].value[25] = (char)0;
#line 234
  str_rsrc[1].value[26] = (char)0;
#line 234
  str_rsrc[1].value[27] = (char)0;
#line 234
  str_rsrc[1].value[28] = (char)0;
#line 234
  str_rsrc[1].value[29] = (char)0;
#line 234
  str_rsrc[1].value[30] = (char)0;
#line 234
  str_rsrc[1].value[31] = (char)0;
#line 234
  str_rsrc[1].value_len = 0;
#line 234
  str_rsrc[2].type = 111;
#line 234
  str_rsrc[2].id = 1002;
#line 234
  str_rsrc[2].name[0] = (char )"_channels";
#line 234
  str_rsrc[2].name[1] = (char )"\251";
#line 234
  str_rsrc[2].name[2] = (char)0;
#line 234
  tmp___28 = 3U;
  {
#line 234
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 234
    if (tmp___28 >= 32U) {
#line 234
      goto while_break___1;
    }
#line 234
    str_rsrc[2].name[tmp___28] = (char)0;
#line 234
    tmp___28 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: 
#line 234
  str_rsrc[2].value[0] = (char)0;
#line 234
  str_rsrc[2].value[1] = (char)0;
#line 234
  str_rsrc[2].value[2] = (char)0;
#line 234
  str_rsrc[2].value[3] = (char)0;
#line 234
  str_rsrc[2].value[4] = (char)0;
#line 234
  str_rsrc[2].value[5] = (char)0;
#line 234
  str_rsrc[2].value[6] = (char)0;
#line 234
  str_rsrc[2].value[7] = (char)0;
#line 234
  str_rsrc[2].value[8] = (char)0;
#line 234
  str_rsrc[2].value[9] = (char)0;
#line 234
  str_rsrc[2].value[10] = (char)0;
#line 234
  str_rsrc[2].value[11] = (char)0;
#line 234
  str_rsrc[2].value[12] = (char)0;
#line 234
  str_rsrc[2].value[13] = (char)0;
#line 234
  str_rsrc[2].value[14] = (char)0;
#line 234
  str_rsrc[2].value[15] = (char)0;
#line 234
  str_rsrc[2].value[16] = (char)0;
#line 234
  str_rsrc[2].value[17] = (char)0;
#line 234
  str_rsrc[2].value[18] = (char)0;
#line 234
  str_rsrc[2].value[19] = (char)0;
#line 234
  str_rsrc[2].value[20] = (char)0;
#line 234
  str_rsrc[2].value[21] = (char)0;
#line 234
  str_rsrc[2].value[22] = (char)0;
#line 234
  str_rsrc[2].value[23] = (char)0;
#line 234
  str_rsrc[2].value[24] = (char)0;
#line 234
  str_rsrc[2].value[25] = (char)0;
#line 234
  str_rsrc[2].value[26] = (char)0;
#line 234
  str_rsrc[2].value[27] = (char)0;
#line 234
  str_rsrc[2].value[28] = (char)0;
#line 234
  str_rsrc[2].value[29] = (char)0;
#line 234
  str_rsrc[2].value[30] = (char)0;
#line 234
  str_rsrc[2].value[31] = (char)0;
#line 234
  str_rsrc[2].value_len = 0;
#line 234
  str_rsrc[3].type = 112;
#line 234
  str_rsrc[3].id = 1000;
#line 234
  str_rsrc[3].name[0] = (char )"_Markers\323";
#line 234
  str_rsrc[3].name[1] = (char )"\251";
#line 234
  str_rsrc[3].name[2] = (char)8;
#line 234
  tmp___29 = 3U;
  {
#line 234
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 234
    if (tmp___29 >= 32U) {
#line 234
      goto while_break___2;
    }
#line 234
    str_rsrc[3].name[tmp___29] = (char)0;
#line 234
    tmp___29 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 234
  str_rsrc[3].value[0] = (char)0;
#line 234
  str_rsrc[3].value[1] = (char)0;
#line 234
  str_rsrc[3].value[2] = (char)0;
#line 234
  str_rsrc[3].value[3] = (char)0;
#line 234
  str_rsrc[3].value[4] = (char)0;
#line 234
  str_rsrc[3].value[5] = (char)0;
#line 234
  str_rsrc[3].value[6] = (char)0;
#line 234
  str_rsrc[3].value[7] = (char)0;
#line 234
  str_rsrc[3].value[8] = (char)0;
#line 234
  str_rsrc[3].value[9] = (char)0;
#line 234
  str_rsrc[3].value[10] = (char)0;
#line 234
  str_rsrc[3].value[11] = (char)0;
#line 234
  str_rsrc[3].value[12] = (char)0;
#line 234
  str_rsrc[3].value[13] = (char)0;
#line 234
  str_rsrc[3].value[14] = (char)0;
#line 234
  str_rsrc[3].value[15] = (char)0;
#line 234
  str_rsrc[3].value[16] = (char)0;
#line 234
  str_rsrc[3].value[17] = (char)0;
#line 234
  str_rsrc[3].value[18] = (char)0;
#line 234
  str_rsrc[3].value[19] = (char)0;
#line 234
  str_rsrc[3].value[20] = (char)0;
#line 234
  str_rsrc[3].value[21] = (char)0;
#line 234
  str_rsrc[3].value[22] = (char)0;
#line 234
  str_rsrc[3].value[23] = (char)0;
#line 234
  str_rsrc[3].value[24] = (char)0;
#line 234
  str_rsrc[3].value[25] = (char)0;
#line 234
  str_rsrc[3].value[26] = (char)0;
#line 234
  str_rsrc[3].value[27] = (char)0;
#line 234
  str_rsrc[3].value[28] = (char)0;
#line 234
  str_rsrc[3].value[29] = (char)0;
#line 234
  str_rsrc[3].value[30] = (char)0;
#line 234
  str_rsrc[3].value[31] = (char)0;
#line 234
  str_rsrc[3].value_len = 0;
#line 243
  psf_use_rsrc(psf, 1);
#line 245
  memset((void *)(& rsrc), 0, sizeof(rsrc));
#line 247
  rsrc.sample_rate = psf->sf.samplerate;
#line 248
  rsrc.sample_size = psf->bytewidth;
#line 249
  rsrc.channels = psf->sf.channels;
#line 251
  rsrc.rsrc_data = psf->header;
#line 252
  rsrc.rsrc_len = (int )sizeof(psf->header);
#line 253
  memset((void *)rsrc.rsrc_data, 234, (unsigned long )rsrc.rsrc_len);
#line 255
  snprintf(str_rsrc[0].value, sizeof(str_rsrc[0].value), "_%d", rsrc.sample_size);
#line 256
  snprintf(str_rsrc[1].value, sizeof(str_rsrc[1].value), "_%d.000000", rsrc.sample_rate);
#line 257
  snprintf(str_rsrc[2].value, sizeof(str_rsrc[2].value), "_%d", rsrc.channels);
#line 259
  k = 0;
  }
  {
#line 259
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 259
    if (! (k < (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0])))) {
#line 259
      goto while_break___3;
    }
#line 260
    if (str_rsrc[k].value_len == 0) {
      {
#line 261
      __cil_tmp13 = strlen((char const   *)(str_rsrc[k].value));
#line 261
      str_rsrc[k].value_len = (int )__cil_tmp13;
#line 262
      str_rsrc[k].value[0] = (char )(str_rsrc[k].value_len - 1);
      }
    }
    {
#line 266
    __cil_tmp14 = strlen((char const   *)(str_rsrc[k].name));
#line 266
    str_rsrc[k].name[0] = (char )(__cil_tmp14 - 1UL);
#line 259
    k ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___3: 
#line 269
  rsrc.data_offset = 256;
#line 275
  rsrc.data_length = 0;
#line 276
  k = 0;
  {
#line 276
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 276
    if (! (k < (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0])))) {
#line 276
      goto while_break___4;
    }
#line 277
    rsrc.data_length += str_rsrc[k].value_len + 4;
#line 276
    k ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___4: 
  {
#line 279
  rsrc.map_offset = rsrc.data_offset + rsrc.data_length;
#line 282
  write_int(rsrc.rsrc_data, 0, rsrc.data_offset);
#line 283
  write_int(rsrc.rsrc_data, 4, rsrc.map_offset);
#line 284
  write_int(rsrc.rsrc_data, 8, rsrc.data_length);
#line 286
  __cil_tmp17 = strlen((char const   *)(psf->file.name.c));
#line 286
  write_char(rsrc.rsrc_data, 48, (char )__cil_tmp17);
#line 287
  __cil_tmp18 = strlen((char const   *)(psf->file.name.c));
#line 287
  write_str(rsrc.rsrc_data, 49, (char const   *)(psf->file.name.c), (int )__cil_tmp18);
#line 289
  write_short(rsrc.rsrc_data, 80, (short)0);
#line 290
  write_marker(rsrc.rsrc_data, 82, (int )((unsigned int )((83 | (100 << 8)) | (50 << 16)) | (102U << 24)));
#line 291
  write_marker(rsrc.rsrc_data, 86, (int )((unsigned int )((108 | (115 << 8)) | (102 << 16)) | (49U << 24)));
#line 294
  write_int(rsrc.rsrc_data, rsrc.map_offset, rsrc.data_offset);
#line 295
  write_int(rsrc.rsrc_data, rsrc.map_offset + 4, rsrc.map_offset);
#line 296
  write_int(rsrc.rsrc_data, rsrc.map_offset + 8, rsrc.data_length);
#line 300
  write_char(rsrc.rsrc_data, rsrc.map_offset + 16, (char)1);
#line 302
  write_int(rsrc.rsrc_data, rsrc.map_offset + 17, 305419896);
#line 304
  write_short(rsrc.rsrc_data, rsrc.map_offset + 21, (short)-21555);
#line 306
  write_short(rsrc.rsrc_data, rsrc.map_offset + 23, (short)0);
#line 310
  rsrc.type_offset = rsrc.map_offset + 30;
#line 311
  write_short(rsrc.rsrc_data, rsrc.map_offset + 24, (short )((rsrc.type_offset - rsrc.map_offset) - 2));
#line 314
  rsrc.type_count = 2;
#line 315
  write_short(rsrc.rsrc_data, rsrc.map_offset + 28, (short )(rsrc.type_count - 1));
#line 317
  rsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8;
#line 319
  rsrc.str_count = (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0]));
#line 320
  rsrc.string_offset = (rsrc.item_offset + (rsrc.str_count + 1) * 12) - rsrc.map_offset;
#line 321
  write_short(rsrc.rsrc_data, rsrc.map_offset + 26, (short )rsrc.string_offset);
#line 324
  rsrc.str_count = 3;
#line 325
  write_marker(rsrc.rsrc_data, rsrc.type_offset, (int )((unsigned int )((83 | (84 << 8)) | (82 << 16)) | (32U << 24)));
#line 326
  write_short(rsrc.rsrc_data, rsrc.type_offset + 4, (short )(rsrc.str_count - 1));
#line 327
  write_short(rsrc.rsrc_data, rsrc.type_offset + 6, (short)18);
#line 330
  write_marker(rsrc.rsrc_data, rsrc.type_offset + 8, (int )((unsigned int )((115 | (100 << 8)) | (77 << 16)) | (76U << 24)));
#line 331
  write_short(rsrc.rsrc_data, rsrc.type_offset + 12, (short)0);
#line 332
  write_short(rsrc.rsrc_data, rsrc.type_offset + 14, (short)54);
#line 334
  str_offset = rsrc.map_offset + rsrc.string_offset;
#line 335
  next_str = 0;
#line 336
  data_offset = rsrc.data_offset;
#line 337
  k = 0;
  }
  {
#line 337
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 337
    if (! (k < (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0])))) {
#line 337
      goto while_break___5;
    }
    {
#line 338
    __cil_tmp19 = strlen((char const   *)(str_rsrc[k].name));
#line 338
    write_str(rsrc.rsrc_data, str_offset, (char const   *)(str_rsrc[k].name), (int )__cil_tmp19);
#line 340
    write_short(rsrc.rsrc_data, rsrc.item_offset + k * 12, (short )str_rsrc[k].id);
#line 341
    write_short(rsrc.rsrc_data, (rsrc.item_offset + k * 12) + 2, (short )next_str);
#line 343
    __cil_tmp20 = strlen((char const   *)(str_rsrc[k].name));
#line 343
    str_offset = (int )((unsigned long )str_offset + __cil_tmp20);
#line 344
    __cil_tmp21 = strlen((char const   *)(str_rsrc[k].name));
#line 344
    next_str = (int )((unsigned long )next_str + __cil_tmp21);
#line 346
    write_int(rsrc.rsrc_data, (rsrc.item_offset + k * 12) + 4, data_offset - rsrc.data_offset);
#line 348
    write_int(rsrc.rsrc_data, data_offset, str_rsrc[k].value_len);
#line 349
    write_str(rsrc.rsrc_data, data_offset + 4, (char const   *)(str_rsrc[k].value),
              str_rsrc[k].value_len);
#line 350
    data_offset += 4 + str_rsrc[k].value_len;
#line 337
    k ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___5: 
  {
#line 354
  rsrc.map_length = str_offset - rsrc.map_offset;
#line 355
  write_int(rsrc.rsrc_data, 12, rsrc.map_length);
#line 356
  write_int(rsrc.rsrc_data, rsrc.map_offset + 12, rsrc.map_length);
#line 358
  rsrc.rsrc_len = rsrc.map_offset + rsrc.map_length;
#line 360
  psf_fwrite((void const   *)rsrc.rsrc_data, (sf_count_t )rsrc.rsrc_len, (sf_count_t )1,
             psf);
#line 362
  psf_use_rsrc(psf, 0);
  }
#line 364
  if (psf->error) {
#line 365
    return (psf->error);
  }
#line 367
  return (0);
}
}
#line 374 "/root/patchweave_donee/23/src/sd2.c"
__inline static int read_rsrc_char(SD2_RSRC *prsrc , int offset ) 
{ 
  unsigned char const   *data ;

  {
#line 375
  data = (unsigned char const   *)prsrc->rsrc_data;
#line 376
  if (offset < 0) {
#line 377
    return (0);
  } else
#line 376
  if (offset >= prsrc->rsrc_len) {
#line 377
    return (0);
  }
#line 378
  return ((int )*(data + offset));
}
}
#line 382 "/root/patchweave_donee/23/src/sd2.c"
__inline static int read_rsrc_short(SD2_RSRC *prsrc , int offset ) 
{ 
  unsigned char const   *data ;

  {
#line 383
  data = (unsigned char const   *)prsrc->rsrc_data;
#line 384
  if (offset < 0) {
#line 385
    return (0);
  } else
#line 384
  if (offset + 1 >= prsrc->rsrc_len) {
#line 385
    return (0);
  }
#line 386
  return (((int )*(data + offset) << 8) + (int )*(data + (offset + 1)));
}
}
#line 390 "/root/patchweave_donee/23/src/sd2.c"
__inline static int read_rsrc_int(SD2_RSRC *prsrc , int offset ) 
{ 
  unsigned char const   *data ;

  {
#line 391
  data = (unsigned char const   *)prsrc->rsrc_data;
#line 392
  if (offset < 0) {
#line 393
    return (0);
  } else
#line 392
  if (offset + 3 >= prsrc->rsrc_len) {
#line 393
    return (0);
  }
#line 394
  return ((int )(((((uint32_t )*(data + offset) << 24) + (unsigned int )((int )*(data + (offset + 1)) << 16)) + (unsigned int )((int )*(data + (offset + 2)) << 8)) + (unsigned int )*(data + (offset + 3))));
}
}
#line 398 "/root/patchweave_donee/23/src/sd2.c"
__inline static int read_rsrc_marker(SD2_RSRC *prsrc , int offset ) 
{ 
  unsigned char const   *data ;

  {
#line 399
  data = (unsigned char const   *)prsrc->rsrc_data;
#line 401
  if (offset < 0) {
#line 402
    return (0);
  } else
#line 401
  if (offset + 3 >= prsrc->rsrc_len) {
#line 402
    return (0);
  }
#line 407
  return ((int )((unsigned int )(((int )*(data + offset) + ((int )*(data + (offset + 1)) << 8)) + ((int )*(data + (offset + 2)) << 16)) + ((uint32_t )*(data + (offset + 3)) << 24)));
#line 409
  return (0);
}
}
#line 413 "/root/patchweave_donee/23/src/sd2.c"
static void read_rsrc_str(SD2_RSRC *prsrc , int offset , char *buffer , int buffer_len ) 
{ 
  unsigned char const   *data ;
  int k ;
  int __cil_tmp7 ;

  {
  {
#line 414
  data = (unsigned char const   *)prsrc->rsrc_data;
#line 417
  memset((void *)buffer, 0, (unsigned long )buffer_len);
  }
#line 419
  if (offset < 0) {
#line 420
    return;
  } else
#line 419
  if (offset + buffer_len >= prsrc->rsrc_len) {
#line 420
    return;
  }
#line 422
  k = 0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;

#line 422
    if (! (k < buffer_len - 1)) {
#line 422
      goto while_break;
    }
    {
#line 423
    __cil_tmp7 = psf_isprint((int )*(data + (offset + k)));
    }
#line 423
    if (__cil_tmp7 == 0) {
#line 424
      return;
    }
#line 425
    *(buffer + k) = (char )*(data + (offset + k));
#line 422
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 427
  return;
}
}
#line 431 "/root/patchweave_donee/23/src/sd2.c"
static int sd2_parse_rsrc_fork(SF_PRIVATE *psf ) 
{ 
  SD2_RSRC rsrc ;
  int k ;
  int marker ;
  int error ;
  sf_count_t __cil_tmp6 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp19 ;
  void *tmp ;

  {
  {
#line 433
  error = 0;
#line 435
  psf_use_rsrc(psf, 1);
#line 437
  memset((void *)(& rsrc), 0, sizeof(rsrc));
#line 439
  __cil_tmp6 = psf_get_filelen(psf);
#line 439
  rsrc.rsrc_len = (int )__cil_tmp6;
#line 440
  psf_log_printf(psf, "Resource length : %d (0x%04X)\n", rsrc.rsrc_len, rsrc.rsrc_len);
  }
#line 442
  if (rsrc.rsrc_len > (int )sizeof(psf->header)) {
    {
#line 443
    tmp = calloc(1UL, (unsigned long )rsrc.rsrc_len);
#line 443
    rsrc.rsrc_data = (unsigned char *)tmp;
#line 444
    rsrc.need_to_free_rsrc_data = 1;
    }
  } else {
#line 448
    rsrc.rsrc_data = psf->header;
#line 449
    rsrc.need_to_free_rsrc_data = 0;
  }
  {
#line 453
  psf_fread((void *)rsrc.rsrc_data, (sf_count_t )rsrc.rsrc_len, (sf_count_t )1, psf);
#line 456
  psf->headend = rsrc.rsrc_len;
#line 456
  psf->headindex = psf->headend;
#line 458
  rsrc.data_offset = read_rsrc_int(& rsrc, 0);
#line 459
  rsrc.map_offset = read_rsrc_int(& rsrc, 4);
#line 460
  rsrc.data_length = read_rsrc_int(& rsrc, 8);
#line 461
  rsrc.map_length = read_rsrc_int(& rsrc, 12);
  }
#line 463
  if (rsrc.data_offset == 333319) {
#line 463
    if (rsrc.map_offset == 131072) {
      {
#line 464
      psf_log_printf(psf, "Trying offset of 0x52 bytes.\n");
#line 465
      __cil_tmp12 = read_rsrc_int(& rsrc, 82);
#line 465
      rsrc.data_offset = __cil_tmp12 + 82;
#line 466
      __cil_tmp13 = read_rsrc_int(& rsrc, 86);
#line 466
      rsrc.map_offset = __cil_tmp13 + 82;
#line 467
      rsrc.data_length = read_rsrc_int(& rsrc, 90);
#line 468
      rsrc.map_length = read_rsrc_int(& rsrc, 94);
      }
    }
  }
  {
#line 471
  psf_log_printf(psf, "  data offset : 0x%04X\n  map  offset : 0x%04X\n  data length : 0x%04X\n  map  length : 0x%04X\n\230\001",
                 rsrc.data_offset, rsrc.map_offset, rsrc.data_length, rsrc.map_length);
  }
#line 475
  if (rsrc.data_offset > rsrc.rsrc_len) {
    {
#line 476
    psf_log_printf(psf, "Error : rsrc.data_offset (%d, 0x%x) > len\n", rsrc.data_offset,
                   rsrc.data_offset);
#line 477
    error = 147;
    }
#line 478
    goto parse_rsrc_fork_cleanup;
  }
#line 481
  if (rsrc.map_offset > rsrc.rsrc_len) {
    {
#line 482
    psf_log_printf(psf, "Error : rsrc.map_offset > len\n");
#line 483
    error = 148;
    }
#line 484
    goto parse_rsrc_fork_cleanup;
  }
#line 487
  if (rsrc.data_length > rsrc.rsrc_len) {
    {
#line 488
    psf_log_printf(psf, "Error : rsrc.data_length > len\n");
#line 489
    error = 149;
    }
#line 490
    goto parse_rsrc_fork_cleanup;
  }
#line 493
  if (rsrc.map_length > rsrc.rsrc_len) {
    {
#line 494
    psf_log_printf(psf, "Error : rsrc.map_length > len\n");
#line 495
    error = 150;
    }
#line 496
    goto parse_rsrc_fork_cleanup;
  }
#line 499
  if (rsrc.data_offset + rsrc.data_length != rsrc.map_offset) {
    {
#line 500
    psf_log_printf(psf, "Error : This does not look like a MacOSX resource fork.\n\220");
#line 501
    error = 151;
    }
#line 502
    goto parse_rsrc_fork_cleanup;
  } else
#line 499
  if (rsrc.map_offset + rsrc.map_length != rsrc.rsrc_len) {
    {
#line 500
    psf_log_printf(psf, "Error : This does not look like a MacOSX resource fork.\n\220");
#line 501
    error = 151;
    }
#line 502
    goto parse_rsrc_fork_cleanup;
  }
#line 505
  if (rsrc.map_offset + 28 >= rsrc.rsrc_len) {
    {
#line 506
    psf_log_printf(psf, "Bad map offset (%d + 28 > %d).\n", rsrc.map_offset, rsrc.rsrc_len);
#line 507
    error = 151;
    }
#line 508
    goto parse_rsrc_fork_cleanup;
  }
  {
#line 511
  __cil_tmp16 = read_rsrc_short(& rsrc, rsrc.map_offset + 26);
#line 511
  rsrc.string_offset = rsrc.map_offset + __cil_tmp16;
  }
#line 512
  if (rsrc.string_offset > rsrc.rsrc_len) {
    {
#line 513
    psf_log_printf(psf, "Bad string offset (%d).\n\230\001", rsrc.string_offset);
#line 514
    error = 151;
    }
#line 515
    goto parse_rsrc_fork_cleanup;
  }
#line 518
  rsrc.type_offset = rsrc.map_offset + 30;
#line 520
  if (rsrc.map_offset + 28 > rsrc.rsrc_len) {
    {
#line 521
    psf_log_printf(psf, "Bad map offset.\n\220");
    }
#line 522
    goto parse_rsrc_fork_cleanup;
  }
  {
#line 525
  __cil_tmp17 = read_rsrc_short(& rsrc, rsrc.map_offset + 28);
#line 525
  rsrc.type_count = __cil_tmp17 + 1;
  }
#line 526
  if (rsrc.type_count < 1) {
    {
#line 527
    psf_log_printf(psf, "Bad type count.\n\220");
#line 528
    error = 151;
    }
#line 529
    goto parse_rsrc_fork_cleanup;
  }
#line 532
  rsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8;
#line 533
  if (rsrc.item_offset < 0) {
    {
#line 534
    psf_log_printf(psf, "Bad item offset (%d).\n", rsrc.item_offset);
#line 535
    error = 151;
    }
#line 536
    goto parse_rsrc_fork_cleanup;
  } else
#line 533
  if (rsrc.item_offset > rsrc.rsrc_len) {
    {
#line 534
    psf_log_printf(psf, "Bad item offset (%d).\n", rsrc.item_offset);
#line 535
    error = 151;
    }
#line 536
    goto parse_rsrc_fork_cleanup;
  }
#line 539
  rsrc.str_index = -1;
#line 540
  k = 0;
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;

#line 540
    if (! (k < rsrc.type_count)) {
#line 540
      goto while_break;
    }
#line 541
    if (rsrc.type_offset + k * 8 > rsrc.rsrc_len) {
      {
#line 542
      psf_log_printf(psf, "Bad rsrc marker.\n8,\331\204U");
      }
#line 543
      goto parse_rsrc_fork_cleanup;
    }
    {
#line 546
    marker = read_rsrc_marker(& rsrc, rsrc.type_offset + k * 8);
    }
#line 548
    if ((unsigned int )marker == ((unsigned int )((83 | (84 << 8)) | (82 << 16)) | (32U << 24))) {
      {
#line 549
      rsrc.str_index = k;
#line 550
      __cil_tmp19 = read_rsrc_short(& rsrc, (rsrc.type_offset + k * 8) + 4);
#line 550
      rsrc.str_count = __cil_tmp19 + 1;
#line 551
      error = parse_str_rsrc(psf, & rsrc);
      }
#line 552
      goto parse_rsrc_fork_cleanup;
    }
#line 540
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 556
  psf_log_printf(psf, "No \'STR \' resource.\n");
#line 557
  error = 151;
  }
  parse_rsrc_fork_cleanup: 
  {
#line 561
  psf_use_rsrc(psf, 0);
  }
#line 563
  if (rsrc.need_to_free_rsrc_data) {
    {
#line 564
    free((void *)rsrc.rsrc_data);
    }
  }
#line 566
  return (error);
}
}
#line 570 "/root/patchweave_donee/23/src/sd2.c"
static int parse_str_rsrc(SF_PRIVATE *psf , SD2_RSRC *rsrc ) 
{ 
  char name[32] ;
  char value___0[32] ;
  int k ;
  int str_offset ;
  int rsrc_id ;
  int data_offset ;
  int data_len ;
  int slen ;
  int __cil_tmp13 ;
  long __cil_tmp16 ;
  long __cil_tmp17 ;
  long __cil_tmp18 ;
  int temp ;

  {
  {
#line 572
  data_offset = 0;
#line 572
  data_len = 0;
#line 574
  psf_log_printf(psf, "Finding parameters :\n");
#line 576
  str_offset = rsrc->string_offset;
#line 577
  psf_log_printf(psf, "  Offset    RsrcId    dlen    slen    Value\n");
#line 579
  k = 0;
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;

#line 579
    if (! (data_offset + data_len < rsrc->rsrc_len)) {
#line 579
      goto while_break;
    }
    {
#line 582
    slen = read_rsrc_char(rsrc, str_offset);
#line 583
    read_rsrc_str(rsrc, str_offset + 1, name, 0);
#line 584
    str_offset += slen + 1;
#line 586
    rsrc_id = read_rsrc_short(rsrc, rsrc->item_offset + k * 12);
#line 588
    __cil_tmp13 = read_rsrc_int(rsrc, (rsrc->item_offset + k * 12) + 4);
#line 588
    data_offset = rsrc->data_offset + __cil_tmp13;
    }
#line 589
    if (data_offset < 0) {
      {
#line 590
      psf_log_printf(psf, "Exiting parser on data offset of %d.\nU", data_offset);
      }
#line 591
      goto while_break;
    } else
#line 589
    if (data_offset > rsrc->rsrc_len) {
      {
#line 590
      psf_log_printf(psf, "Exiting parser on data offset of %d.\nU", data_offset);
      }
#line 591
      goto while_break;
    }
    {
#line 594
    data_len = read_rsrc_int(rsrc, data_offset);
    }
#line 595
    if (data_len < 0) {
      {
#line 596
      psf_log_printf(psf, "Exiting parser on data length of %d.\n", data_len);
      }
#line 597
      goto while_break;
    } else
#line 595
    if (data_len > rsrc->rsrc_len) {
      {
#line 596
      psf_log_printf(psf, "Exiting parser on data length of %d.\n", data_len);
      }
#line 597
      goto while_break;
    }
    {
#line 600
    slen = read_rsrc_char(rsrc, data_offset + 4);
#line 601
    read_rsrc_str(rsrc, data_offset + 5, value___0, 0);
#line 603
    psf_log_printf(psf, "  0x%04x     %4d     %4d     %3d    \'%s\'\n8-\331\204U",
                   data_offset, rsrc_id, data_len, slen, value___0);
    }
#line 605
    if (rsrc_id == 1000) {
#line 605
      if (rsrc->sample_size == 0) {
        {
#line 606
        __cil_tmp16 = strtol((char const   *)(value___0), (char **)((void *)0), 10);
#line 606
        rsrc->sample_size = (int )__cil_tmp16;
        }
      } else {
#line 605
        goto _L___30;
      }
    } else
    _L___30: 
#line 607
    if (rsrc_id == 1001) {
#line 607
      if (rsrc->sample_rate == 0) {
        {
#line 608
        __cil_tmp17 = strtol((char const   *)(value___0), (char **)((void *)0), 10);
#line 608
        rsrc->sample_rate = (int )__cil_tmp17;
        }
      } else {
#line 607
        goto _L;
      }
    } else
    _L: 
#line 609
    if (rsrc_id == 1002) {
#line 609
      if (rsrc->channels == 0) {
        {
#line 610
        __cil_tmp18 = strtol((char const   *)(value___0), (char **)((void *)0), 10);
#line 610
        rsrc->channels = (int )__cil_tmp18;
        }
      }
    }
#line 579
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 613
  psf_log_printf(psf, "Found Parameters :\n\331\204U");
#line 614
  psf_log_printf(psf, "  sample-size : %d\n\331\204U", rsrc->sample_size);
#line 615
  psf_log_printf(psf, "  sample-rate : %d\n\331\204U", rsrc->sample_rate);
#line 616
  psf_log_printf(psf, "  channels    : %d\n\331\204U", rsrc->channels);
  }
#line 618
  if (rsrc->sample_rate <= 4) {
#line 618
    if (rsrc->sample_size > 4) {
      {
#line 621
      psf_log_printf(psf, "Geez!! Looks like sample rate and sample size got switched.\nCorrecting this screw up.\n");
#line 622
      temp = rsrc->sample_rate;
#line 623
      rsrc->sample_rate = rsrc->sample_size;
#line 624
      rsrc->sample_size = temp;
      }
    }
  }
#line 627
  if (rsrc->sample_rate < 0) {
    {
#line 628
    psf_log_printf(psf, "Bad sample rate (%d)\nU", rsrc->sample_rate);
    }
#line 629
    return (151);
  }
#line 632
  if (rsrc->channels < 0) {
    {
#line 633
    psf_log_printf(psf, "Bad channel count (%d)\n", rsrc->channels);
    }
#line 634
    return (151);
  }
#line 637
  psf->sf.samplerate = rsrc->sample_rate;
#line 638
  psf->sf.channels = rsrc->channels;
#line 639
  psf->bytewidth = rsrc->sample_size;
#line 642
  if (rsrc->sample_size == 1) {
#line 642
    goto case_1;
  }
#line 646
  if (rsrc->sample_size == 2) {
#line 646
    goto case_2;
  }
#line 650
  if (rsrc->sample_size == 3) {
#line 650
    goto case_3;
  }
#line 654
  if (rsrc->sample_size == 4) {
#line 654
    goto case_4;
  }
#line 658
  goto switch_default;
  case_1: 
#line 643
  psf->sf.format = 1441793;
#line 644
  goto switch_break;
  case_2: 
#line 647
  psf->sf.format = 1441794;
#line 648
  goto switch_break;
  case_3: 
#line 651
  psf->sf.format = 1441795;
#line 652
  goto switch_break;
  case_4: 
#line 655
  psf->sf.format = 1441796;
#line 656
  goto switch_break;
  switch_default: 
  {
#line 659
  psf_log_printf(psf, "Bad sample size (%d)\n", rsrc->sample_size);
  }
#line 660
  return (152);
  switch_break: 
  {
#line 663
  psf_log_printf(psf, "ok\n\331\204U");
  }
#line 665
  return (0);
}
}
#line 33 "/root/patchweave_donee/23/src/rx2.c"
int rx2_open(SF_PRIVATE *psf ) 
{ 


  {
#line 34
  if (psf) {
#line 35
    return (18);
  }
#line 36
  return (0);
}
}
#line 31 "/root/patchweave_donee/23/src/raw.c"
int raw_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;

  {
#line 32
  error = 0;
#line 34
  subformat = psf->sf.format & 65535;
#line 36
  psf->endian = psf->sf.format & 805306368;
#line 40
  if (psf->endian == 0) {
#line 41
    psf->endian = 268435456;
  } else
#line 40
  if (psf->endian == 805306368) {
#line 41
    psf->endian = 268435456;
  }
#line 43
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 44
  psf->dataoffset = (sf_count_t )0;
#line 45
  psf->datalength = psf->filelength;
#line 48
  if (subformat == 1) {
#line 48
    goto case_1;
  }
#line 52
  if (subformat == 5) {
#line 52
    goto case_5;
  }
#line 58
  if (subformat == 4) {
#line 58
    goto case_4;
  }
#line 58
  if (subformat == 3) {
#line 58
    goto case_4;
  }
#line 58
  if (subformat == 2) {
#line 58
    goto case_4;
  }
#line 62
  if (subformat == 16) {
#line 62
    goto case_16;
  }
#line 66
  if (subformat == 17) {
#line 66
    goto case_17;
  }
#line 70
  if (subformat == 32) {
#line 70
    goto case_32;
  }
#line 75
  if (subformat == 6) {
#line 75
    goto case_6;
  }
#line 79
  if (subformat == 7) {
#line 79
    goto case_7;
  }
#line 83
  if (subformat == 64) {
#line 83
    goto case_64;
  }
#line 87
  if (subformat == 65) {
#line 87
    goto case_65;
  }
#line 91
  if (subformat == 66) {
#line 91
    goto case_66;
  }
#line 95
  if (subformat == 33) {
#line 95
    goto case_33;
  }
#line 100
  goto switch_default;
  case_1: 
  {
#line 49
  error = pcm_init(psf);
  }
#line 50
  goto switch_break;
  case_5: 
  {
#line 53
  error = pcm_init(psf);
  }
#line 54
  goto switch_break;
  case_4: 
  {
#line 59
  error = pcm_init(psf);
  }
#line 60
  goto switch_break;
  case_16: 
  {
#line 63
  error = ulaw_init(psf);
  }
#line 64
  goto switch_break;
  case_17: 
  {
#line 67
  error = alaw_init(psf);
  }
#line 68
  goto switch_break;
  case_32: 
  {
#line 71
  error = gsm610_init(psf);
  }
#line 72
  goto switch_break;
  case_6: 
  {
#line 76
  error = float32_init(psf);
  }
#line 77
  goto switch_break;
  case_7: 
  {
#line 80
  error = double64_init(psf);
  }
#line 81
  goto switch_break;
  case_64: 
  {
#line 84
  error = dwvw_init(psf, 12);
  }
#line 85
  goto switch_break;
  case_65: 
  {
#line 88
  error = dwvw_init(psf, 16);
  }
#line 89
  goto switch_break;
  case_66: 
  {
#line 92
  error = dwvw_init(psf, 24);
  }
#line 93
  goto switch_break;
  case_33: 
  {
#line 96
  error = vox_adpcm_init(psf);
  }
#line 97
  goto switch_break;
  switch_default: 
#line 100
  return (1);
  switch_break: ;
#line 103
  return (error);
}
}
#line 40 "/root/patchweave_donee/23/src/pvf.c"
static int pvf_close(SF_PRIVATE *UNUSED_psf ) ;
#line 42
static int pvf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 43
static int pvf_read_header(SF_PRIVATE *psf ) ;
#line 50 "/root/patchweave_donee/23/src/pvf.c"
int pvf_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp5 ;

  {
#line 52
  error = 0;
#line 54
  if (psf->file.mode == 16) {
    _L: 
    {
#line 55
    error = pvf_read_header(psf);
    }
#line 55
    if (error) {
#line 56
      return (error);
    }
  } else
#line 54
  if (psf->file.mode == 48) {
#line 54
    if (psf->filelength > 0L) {
#line 54
      goto _L;
    }
  }
#line 59
  subformat = psf->sf.format & 65535;
#line 61
  if (psf->file.mode == 32) {
    _L___31: 
#line 62
    if ((psf->sf.format & 268369920) != 917504) {
#line 63
      return (1);
    }
    {
#line 65
    psf->endian = 536870912;
#line 67
    __cil_tmp5 = pvf_write_header(psf, 0);
    }
#line 67
    if (__cil_tmp5) {
#line 68
      return (psf->error);
    }
#line 70
    psf->write_header = & pvf_write_header;
  } else
#line 61
  if (psf->file.mode == 48) {
#line 61
    goto _L___31;
  }
#line 73
  psf->container_close = & pvf_close;
#line 75
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 80
  if (subformat == 4) {
#line 80
    goto case_4;
  }
#line 80
  if (subformat == 2) {
#line 80
    goto case_4;
  }
#line 80
  if (subformat == 1) {
#line 80
    goto case_4;
  }
#line 84
  goto switch_default;
  case_4: 
  {
#line 81
  error = pcm_init(psf);
  }
#line 82
  goto switch_break;
  switch_default: 
#line 84
  goto switch_break;
  switch_break: ;
#line 87
  return (error);
}
}
#line 94 "/root/patchweave_donee/23/src/pvf.c"
static int pvf_close(SF_PRIVATE *UNUSED_psf ) 
{ 


  {
#line 96
  return (0);
}
}
#line 100 "/root/patchweave_donee/23/src/pvf.c"
static int pvf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  sf_count_t current ;
  unsigned long __cil_tmp5 ;

  {
#line 103
  if (psf->pipeoffset > 0L) {
#line 104
    return (0);
  }
  {
#line 106
  current = psf_ftell(psf);
#line 109
  psf->header[0] = (unsigned char)0;
#line 110
  psf->headindex = 0;
  }
#line 112
  if (psf->is_pipe == 0) {
    {
#line 113
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 115
  snprintf((char *)(psf->header), sizeof(psf->header), "PVF1\n%d %d %d\n", psf->sf.channels,
           psf->sf.samplerate, psf->bytewidth * 8);
#line 118
  __cil_tmp5 = strlen((char const   *)((char *)(psf->header)));
#line 118
  psf->headindex = (int )__cil_tmp5;
#line 121
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 123
  if (psf->error) {
#line 124
    return (psf->error);
  }
#line 126
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 128
  if (current > 0L) {
    {
#line 129
    psf_fseek(psf, current, 0);
    }
  }
#line 131
  return (psf->error);
}
}
#line 135 "/root/patchweave_donee/23/src/pvf.c"
static int pvf_read_header(SF_PRIVATE *psf ) 
{ 
  char buffer[32] ;
  int marker ;
  int channels ;
  int samplerate ;
  int bitwidth ;
  int __cil_tmp7 ;

  {
  {
#line 139
  psf_binheader_readf(psf, "pmj", 0, & marker, 1);
#line 140
  psf_log_printf(psf, "%M\n", marker);
  }
#line 142
  if ((unsigned int )marker != ((unsigned int )((80 | (86 << 8)) | (70 << 16)) | (49U << 24))) {
#line 143
    return (135);
  }
  {
#line 146
  psf_binheader_readf(psf, "G", buffer, sizeof(buffer));
#line 148
  __cil_tmp7 = sscanf((char const   *)(buffer), "%d %d %d\230\001", & channels, & samplerate,
                      & bitwidth);
  }
#line 148
  if (__cil_tmp7 != 3) {
#line 149
    return (136);
  }
  {
#line 151
  psf_log_printf(psf, " Channels    : %d\n Sample rate : %d\n Bit width   : %d\n",
                 channels, samplerate, bitwidth);
#line 154
  psf->sf.channels = channels;
#line 155
  psf->sf.samplerate = samplerate;
  }
#line 158
  if (bitwidth == 8) {
#line 158
    goto case_8;
  }
#line 163
  if (bitwidth == 16) {
#line 163
    goto case_16;
  }
#line 167
  if (bitwidth == 32) {
#line 167
    goto case_32;
  }
#line 172
  goto switch_default;
  case_8: 
#line 159
  psf->sf.format = 917505;
#line 160
  psf->bytewidth = 1;
#line 161
  goto switch_break;
  case_16: 
#line 164
  psf->sf.format = 917506;
#line 165
  psf->bytewidth = 2;
#line 166
  goto switch_break;
  case_32: 
#line 168
  psf->sf.format = 917508;
#line 169
  psf->bytewidth = 4;
#line 170
  goto switch_break;
  switch_default: 
#line 173
  return (137);
  switch_break: 
  {
#line 176
  psf->dataoffset = psf_ftell(psf);
#line 177
  psf_log_printf(psf, " Data Offset : %D\n\201\331\204U", psf->dataoffset);
#line 179
  psf->endian = 536870912;
#line 181
  psf->datalength = psf->filelength - psf->dataoffset;
#line 182
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
  }
#line 184
  if (! psf->sf.frames) {
#line 184
    if (psf->blockwidth) {
#line 185
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 187
  return (0);
}
}
#line 74 "/root/patchweave_donee/23/src/paf.c"
static int paf24_init(SF_PRIVATE *psf ) ;
#line 76
static int paf_read_header(SF_PRIVATE *psf ) ;
#line 77
static int paf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 79
static sf_count_t paf24_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 80
static sf_count_t paf24_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 81
static sf_count_t paf24_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 82
static sf_count_t paf24_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 84
static sf_count_t paf24_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 85
static sf_count_t paf24_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 86
static sf_count_t paf24_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 87
static sf_count_t paf24_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 89
static sf_count_t paf24_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 102 "/root/patchweave_donee/23/src/paf.c"
int paf_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int endian ;

  {
#line 105
  psf->dataoffset = (sf_count_t )2048;
#line 107
  if (psf->file.mode == 16) {
    _L: 
    {
#line 108
    error = paf_read_header(psf);
    }
#line 108
    if (error) {
#line 109
      return (error);
    }
  } else
#line 107
  if (psf->file.mode == 48) {
#line 107
    if (psf->filelength > 0L) {
#line 107
      goto _L;
    }
  }
#line 112
  subformat = psf->sf.format & 65535;
#line 114
  if (psf->file.mode == 32) {
    _L___32: 
#line 115
    if ((psf->sf.format & 268369920) != 327680) {
#line 116
      return (1);
    }
#line 118
    endian = psf->sf.format & 805306368;
#line 121
    psf->endian = 536870912;
#line 123
    if (endian == 268435456) {
#line 124
      psf->endian = 268435456;
    } else
#line 123
    if (endian == 805306368) {
#line 124
      psf->endian = 268435456;
    }
    {
#line 126
    error = paf_write_header(psf, 0);
    }
#line 126
    if (error) {
#line 127
      return (error);
    }
#line 129
    psf->write_header = & paf_write_header;
  } else
#line 114
  if (psf->file.mode == 48) {
#line 114
    goto _L___32;
  }
#line 133
  if (subformat == 1) {
#line 133
    goto case_1;
  }
#line 138
  if (subformat == 2) {
#line 138
    goto case_2;
  }
#line 143
  if (subformat == 3) {
#line 143
    goto case_3;
  }
#line 148
  goto switch_default;
  case_1: 
  {
#line 134
  psf->bytewidth = 1;
#line 135
  error = pcm_init(psf);
  }
#line 136
  goto switch_break;
  case_2: 
  {
#line 139
  psf->bytewidth = 2;
#line 140
  error = pcm_init(psf);
  }
#line 141
  goto switch_break;
  case_3: 
  {
#line 145
  error = paf24_init(psf);
  }
#line 146
  goto switch_break;
  switch_default: 
#line 148
  return (99);
  switch_break: ;
#line 151
  return (error);
}
}
#line 158 "/root/patchweave_donee/23/src/paf.c"
static int paf_read_header(SF_PRIVATE *psf ) 
{ 
  PAF_FMT paf_fmt ;
  int marker ;
  int tmp ;

  {
#line 162
  if (psf->filelength < 2048L) {
#line 163
    return (100);
  }
  {
#line 165
  memset((void *)(& paf_fmt), 0, sizeof(paf_fmt));
#line 166
  psf_binheader_readf(psf, "pm", 0, & marker);
#line 168
  psf_log_printf(psf, "Signature   : \'%M\'\n", marker);
  }
#line 170
  if ((unsigned int )marker == ((unsigned int )((32 | (112 << 8)) | (97 << 16)) | (102U << 24))) {
    {
#line 171
    psf_binheader_readf(psf, "E444444", & paf_fmt.version, & paf_fmt.endianness, & paf_fmt.samplerate,
                        & paf_fmt.format, & paf_fmt.channels, & paf_fmt.source);
    }
  } else
#line 174
  if ((unsigned int )marker == ((unsigned int )((102 | (97 << 8)) | (112 << 16)) | (32U << 24))) {
    {
#line 175
    psf_binheader_readf(psf, "e444444", & paf_fmt.version, & paf_fmt.endianness, & paf_fmt.samplerate,
                        & paf_fmt.format, & paf_fmt.channels, & paf_fmt.source);
    }
  } else {
#line 179
    return (97);
  }
  {
#line 181
  psf_log_printf(psf, "Version     : %d\n", paf_fmt.version);
  }
#line 183
  if (paf_fmt.version != 0) {
    {
#line 184
    psf_log_printf(psf, "*** Bad version number. should be zero.\n\220");
    }
#line 185
    return (98);
  }
  {
#line 188
  psf_log_printf(psf, "Sample Rate : %d\n", paf_fmt.samplerate);
#line 189
  psf_log_printf(psf, "Channels    : %d\n", paf_fmt.channels);
#line 191
  psf_log_printf(psf, "Endianness  : %d => ", paf_fmt.endianness);
  }
#line 192
  if (paf_fmt.endianness) {
    {
#line 193
    psf_log_printf(psf, "Little\n", paf_fmt.endianness);
#line 194
    psf->endian = 268435456;
    }
  } else {
    {
#line 197
    psf_log_printf(psf, "Big\n", paf_fmt.endianness);
#line 198
    psf->endian = 536870912;
    }
  }
#line 201
  if (paf_fmt.channels < 1) {
#line 202
    return (101);
  } else
#line 201
  if (paf_fmt.channels > 1024) {
#line 202
    return (101);
  }
  {
#line 204
  psf->datalength = psf->filelength - psf->dataoffset;
#line 206
  psf_binheader_readf(psf, "p", (int )psf->dataoffset);
#line 208
  psf->sf.samplerate = paf_fmt.samplerate;
#line 209
  psf->sf.channels = paf_fmt.channels;
#line 212
  psf->sf.format = 327680;
#line 214
  psf_log_printf(psf, "Format      : %d => ", paf_fmt.format);
  }
#line 217
  if (paf_fmt.endianness) {
#line 217
    tmp = 268435456;
  } else {
#line 217
    tmp = 536870912;
  }
#line 217
  psf->sf.format |= tmp;
#line 220
  if (paf_fmt.format == 2) {
#line 220
    goto case_2;
  }
#line 230
  if (paf_fmt.format == 0) {
#line 230
    goto case_0;
  }
#line 240
  if (paf_fmt.format == 1) {
#line 240
    goto case_1;
  }
#line 251
  goto switch_default;
  case_2: 
  {
#line 221
  psf_log_printf(psf, "8 bit linear PCM\n");
#line 222
  psf->bytewidth = 1;
#line 224
  psf->sf.format |= 1;
#line 226
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 227
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
  }
#line 228
  goto switch_break;
  case_0: 
  {
#line 231
  psf_log_printf(psf, "16 bit linear PCM\n\257\331\204U");
#line 232
  psf->bytewidth = 2;
#line 234
  psf->sf.format |= 2;
#line 236
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 237
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
  }
#line 238
  goto switch_break;
  case_1: 
  {
#line 241
  psf_log_printf(psf, "24 bit linear PCM\n\257\331\204U");
#line 242
  psf->bytewidth = 3;
#line 244
  psf->sf.format |= 3;
#line 246
  psf->blockwidth = 0;
#line 247
  psf->sf.frames = (10L * psf->datalength) / (long )(32 * psf->sf.channels);
  }
#line 249
  goto switch_break;
  switch_default: 
  {
#line 251
  psf_log_printf(psf, "Unknown\n\220");
  }
#line 252
  return (99);
#line 253
  goto switch_break;
  switch_break: 
  {
#line 256
  psf_log_printf(psf, "Source      : %d => \204U", paf_fmt.source);
  }
#line 259
  if (paf_fmt.source == 1) {
#line 259
    goto case_1___0;
  }
#line 261
  if (paf_fmt.source == 2) {
#line 261
    goto case_2___0;
  }
#line 263
  if (paf_fmt.source == 3) {
#line 263
    goto case_3;
  }
#line 265
  if (paf_fmt.source == 5) {
#line 265
    goto case_5;
  }
#line 267
  goto switch_default___0;
  case_1___0: 
  {
#line 259
  psf_log_printf(psf, "Analog Recording\n");
  }
#line 260
  goto switch_break___0;
  case_2___0: 
  {
#line 261
  psf_log_printf(psf, "Digital Transfer\nv\257\331\204U");
  }
#line 262
  goto switch_break___0;
  case_3: 
  {
#line 263
  psf_log_printf(psf, "Multi-track Mixdown\n");
  }
#line 264
  goto switch_break___0;
  case_5: 
  {
#line 265
  psf_log_printf(psf, "Audio Resulting From DSP Processing\n\204U");
  }
#line 266
  goto switch_break___0;
  switch_default___0: 
  {
#line 267
  psf_log_printf(psf, "Unknown\n\220");
  }
#line 268
  goto switch_break___0;
  switch_break___0: ;
#line 271
  return (0);
}
}
#line 275 "/root/patchweave_donee/23/src/paf.c"
static int paf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  int paf_format ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 279
  __cil_tmp4 = psf_ftell(psf);
  }
#line 279
  if (__cil_tmp4 >= 2048L) {
#line 280
    return (0);
  }
#line 282
  psf->dataoffset = (sf_count_t )2048;
#line 285
  if ((psf->sf.format & 65535) == 1) {
#line 285
    goto case_1;
  }
#line 289
  if ((psf->sf.format & 65535) == 2) {
#line 289
    goto case_2;
  }
#line 293
  if ((psf->sf.format & 65535) == 3) {
#line 293
    goto case_3;
  }
#line 297
  goto switch_default;
  case_1: 
#line 286
  paf_format = 2;
#line 287
  goto switch_break;
  case_2: 
#line 290
  paf_format = 0;
#line 291
  goto switch_break;
  case_3: 
#line 294
  paf_format = 1;
#line 295
  goto switch_break;
  switch_default: 
#line 297
  return (99);
  switch_break: 
#line 301
  psf->header[0] = (unsigned char)0;
#line 302
  psf->headindex = 0;
#line 304
  if (psf->endian == 536870912) {
    {
#line 306
    psf_binheader_writef(psf, "Em444U", (unsigned int )((32 | (112 << 8)) | (97 << 16)) | (102U << 24),
                         0, 0, psf->sf.samplerate);
#line 308
    psf_binheader_writef(psf, "E444", paf_format, psf->sf.channels, 0);
    }
  } else
#line 310
  if (psf->endian == 268435456) {
    {
#line 312
    psf_binheader_writef(psf, "em444", (unsigned int )((102 | (97 << 8)) | (112 << 16)) | (32U << 24),
                         0, 1, psf->sf.samplerate);
#line 314
    psf_binheader_writef(psf, "e444", paf_format, psf->sf.channels, 0);
    }
  }
  {
#line 318
  psf_binheader_writef(psf, "z", (size_t )(psf->dataoffset - (long )psf->headindex));
#line 320
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 322
  return (psf->error);
}
}
#line 339
static int paf24_read_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) ;
#line 340
static int paf24_write_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) ;
#line 341
static int paf24_close(SF_PRIVATE *psf ) ;
#line 345 "/root/patchweave_donee/23/src/paf.c"
static int paf24_init(SF_PRIVATE *psf ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int paf24size ;

  {
  {
#line 349
  paf24size = (int )(sizeof(PAF24_PRIVATE ) + (unsigned long )psf->sf.channels * (32UL + 10UL * sizeof(int )));
#line 356
  psf->last_op = 0;
#line 358
  psf->codec_data = calloc(1UL, (unsigned long )paf24size);
  }
#line 358
  if (! psf->codec_data) {
#line 359
    return (17);
  }
#line 361
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 363
  ppaf24->channels = psf->sf.channels;
#line 364
  ppaf24->samples = ppaf24->data;
#line 365
  ppaf24->block = (unsigned char *)(ppaf24->data + 10 * ppaf24->channels);
#line 367
  ppaf24->blocksize = 32 * ppaf24->channels;
#line 369
  if (psf->file.mode == 16) {
    {
#line 370
    paf24_read_block(psf, ppaf24);
#line 372
    psf->read_short = & paf24_read_s;
#line 373
    psf->read_int = & paf24_read_i;
#line 374
    psf->read_float = & paf24_read_f;
#line 375
    psf->read_double = & paf24_read_d;
    }
  } else
#line 369
  if (psf->file.mode == 48) {
    {
#line 370
    paf24_read_block(psf, ppaf24);
#line 372
    psf->read_short = & paf24_read_s;
#line 373
    psf->read_int = & paf24_read_i;
#line 374
    psf->read_float = & paf24_read_f;
#line 375
    psf->read_double = & paf24_read_d;
    }
  }
#line 378
  if (psf->file.mode == 32) {
#line 379
    psf->write_short = & paf24_write_s;
#line 380
    psf->write_int = & paf24_write_i;
#line 381
    psf->write_float = & paf24_write_f;
#line 382
    psf->write_double = & paf24_write_d;
  } else
#line 378
  if (psf->file.mode == 48) {
#line 379
    psf->write_short = & paf24_write_s;
#line 380
    psf->write_int = & paf24_write_i;
#line 381
    psf->write_float = & paf24_write_f;
#line 382
    psf->write_double = & paf24_write_d;
  }
  {
#line 385
  psf->seek = & paf24_seek;
#line 386
  psf->container_close = & paf24_close;
#line 388
  psf->filelength = psf_get_filelen(psf);
#line 389
  psf->datalength = psf->filelength - psf->dataoffset;
  }
#line 391
  if (psf->datalength % 32L) {
#line 392
    if (psf->file.mode == 16) {
      {
#line 393
      psf_log_printf(psf, "*** Warning : file seems to be truncated.\n");
      }
    }
#line 394
    ppaf24->max_blocks = (int )(psf->datalength / (long )ppaf24->blocksize + 1L);
  } else {
#line 397
    ppaf24->max_blocks = (int )(psf->datalength / (long )ppaf24->blocksize);
  }
#line 399
  ppaf24->read_block = 0;
#line 400
  if (psf->file.mode == 48) {
#line 401
    ppaf24->write_block = ppaf24->max_blocks;
  } else {
#line 403
    ppaf24->write_block = 0;
  }
#line 405
  psf->sf.frames = (sf_count_t )(10 * ppaf24->max_blocks);
#line 406
  ppaf24->sample_count = psf->sf.frames;
#line 408
  return (0);
}
}
#line 412 "/root/patchweave_donee/23/src/paf.c"
static sf_count_t paf24_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int newblock ;
  int newsample ;

  {
#line 416
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 417
    psf->error = 30;
#line 418
    return ((sf_count_t )-1);
  }
#line 421
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 423
  if (mode == 16) {
#line 423
    if (ppaf24->write_count > 0) {
      {
#line 424
      paf24_write_block(psf, ppaf24);
      }
    }
  }
#line 426
  newblock = (int )(offset / 10L);
#line 427
  newsample = (int )(offset % 10L);
#line 430
  if (mode == 16) {
#line 430
    goto case_16;
  }
#line 440
  if (mode == 32) {
#line 440
    goto case_32;
  }
#line 455
  goto switch_default;
  case_16: 
#line 431
  if (psf->last_op == 32) {
#line 431
    if (ppaf24->write_count) {
      {
#line 432
      paf24_write_block(psf, ppaf24);
      }
    }
  }
  {
#line 434
  psf_fseek(psf, psf->dataoffset + (long )(newblock * ppaf24->blocksize), 0);
#line 435
  ppaf24->read_block = newblock;
#line 436
  paf24_read_block(psf, ppaf24);
#line 437
  ppaf24->read_count = newsample;
  }
#line 438
  goto switch_break;
  case_32: 
#line 441
  if (offset > ppaf24->sample_count) {
#line 442
    psf->error = 39;
#line 443
    return ((sf_count_t )-1);
  }
#line 446
  if (psf->last_op == 32) {
#line 446
    if (ppaf24->write_count) {
      {
#line 447
      paf24_write_block(psf, ppaf24);
      }
    }
  }
  {
#line 449
  psf_fseek(psf, psf->dataoffset + (long )(newblock * ppaf24->blocksize), 0);
#line 450
  ppaf24->write_block = newblock;
#line 451
  paf24_read_block(psf, ppaf24);
#line 452
  ppaf24->write_count = newsample;
  }
#line 453
  goto switch_break;
  switch_default: 
#line 456
  psf->error = 39;
#line 457
  return ((sf_count_t )-1);
  switch_break: ;
#line 460
  return ((sf_count_t )(newblock * 10 + newsample));
}
}
#line 464 "/root/patchweave_donee/23/src/paf.c"
static int paf24_close(SF_PRIVATE *psf ) 
{ 
  PAF24_PRIVATE *ppaf24 ;

  {
#line 467
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 468
    return (0);
  }
#line 470
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 472
  if (psf->file.mode == 32) {
    _L: 
#line 473
    if (ppaf24->write_count > 0) {
      {
#line 474
      paf24_write_block(psf, ppaf24);
      }
    }
  } else
#line 472
  if (psf->file.mode == 48) {
#line 472
    goto _L;
  }
#line 477
  return (0);
}
}
#line 483 "/root/patchweave_donee/23/src/paf.c"
static int paf24_read_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) 
{ 
  int k ;
  int channel ;
  unsigned char *cptr ;
  sf_count_t __cil_tmp7 ;

  {
#line 487
  (ppaf24->read_block) ++;
#line 488
  ppaf24->read_count = 0;
#line 490
  if ((long )(ppaf24->read_block * 10) > ppaf24->sample_count) {
    {
#line 491
    memset((void *)ppaf24->samples, 0, (unsigned long )(10 * ppaf24->channels));
    }
#line 492
    return (1);
  }
  {
#line 496
  __cil_tmp7 = psf_fread((void *)ppaf24->block, (sf_count_t )1, (sf_count_t )ppaf24->blocksize,
                         psf);
#line 496
  k = (int )__cil_tmp7;
  }
#line 496
  if (k != ppaf24->blocksize) {
    {
#line 497
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, ppaf24->blocksize);
    }
  }
#line 501
  if (psf->endian == 536870912) {
    {
#line 502
    endswap_int_array(ppaf24->data, 8 * ppaf24->channels);
    }
  }
#line 505
  k = 0;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;

#line 505
    if (! (k < 10 * ppaf24->channels)) {
#line 505
      goto while_break;
    }
#line 506
    channel = k % ppaf24->channels;
#line 507
    cptr = (ppaf24->block + 32 * channel) + 3 * (k / ppaf24->channels);
#line 508
    *(ppaf24->samples + k) = (int )((unsigned int )(((int )*(cptr + 0) << 8) | ((int )*(cptr + 1) << 16)) | ((unsigned int )*(cptr + 2) << 24));
#line 505
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 511
  return (1);
}
}
#line 515 "/root/patchweave_donee/23/src/paf.c"
static int paf24_read(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 , int *ptr , int len ) 
{ 
  int count___0 ;
  int total ;
  int tmp ;

  {
#line 516
  total = 0;
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;

#line 518
    if (! (total < len)) {
#line 518
      goto while_break;
    }
#line 519
    if ((long )(ppaf24->read_block * 10) >= ppaf24->sample_count) {
      {
#line 520
      memset((void *)(ptr + total), 0, (unsigned long )(len - total) * sizeof(int ));
      }
#line 521
      return (total);
    }
#line 524
    if (ppaf24->read_count >= 10) {
      {
#line 525
      paf24_read_block(psf, ppaf24);
      }
    }
#line 527
    count___0 = (10 - ppaf24->read_count) * ppaf24->channels;
#line 528
    if (len - total > count___0) {
#line 528
      tmp = count___0;
    } else {
#line 528
      tmp = len - total;
    }
    {
#line 528
    count___0 = tmp;
#line 530
    memcpy((void *)(ptr + total), (void const   *)(ppaf24->samples + ppaf24->read_count * ppaf24->channels),
           (unsigned long )count___0 * sizeof(int ));
#line 531
    total += count___0;
#line 532
    ppaf24->read_count += count___0 / ppaf24->channels;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 535
  return (total);
}
}
#line 539 "/root/patchweave_donee/23/src/paf.c"
static sf_count_t paf24_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 544
  total = (sf_count_t )0;
#line 546
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 547
    return ((sf_count_t )0);
  }
#line 548
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 550
  iptr = ubuf.ibuf;
#line 551
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;

#line 552
    if (! (len > 0L)) {
#line 552
      goto while_break;
    }
#line 553
    if (len >= (long )bufferlen) {
#line 553
      tmp = (long )bufferlen;
    } else {
#line 553
      tmp = len;
    }
    {
#line 553
    readcount = (int )tmp;
#line 554
    count___0 = paf24_read(psf, ppaf24, iptr, readcount);
#line 555
    k = 0;
    }
    {
#line 555
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 555
      if (! (k < readcount)) {
#line 555
        goto while_break___0;
      }
#line 556
      *(ptr + (total + (long )k)) = (short )(*(iptr + k) >> 16);
#line 555
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 557
    total += (long )count___0;
#line 558
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 560
  return (total);
}
}
#line 564 "/root/patchweave_donee/23/src/paf.c"
static sf_count_t paf24_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int total ;

  {
#line 568
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 569
    return ((sf_count_t )0);
  }
  {
#line 570
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 572
  total = paf24_read(psf, ppaf24, ptr, (int )len);
  }
#line 574
  return ((sf_count_t )total);
}
}
#line 578 "/root/patchweave_donee/23/src/paf.c"
static sf_count_t paf24_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 583
  total = (sf_count_t )0;
#line 586
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 587
    return ((sf_count_t )0);
  }
#line 588
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 590
  if (psf->norm_float == 1) {
#line 590
    tmp = 1. / (double )2147483648U;
  } else {
#line 590
    tmp = 1. / (double )256;
  }
#line 590
  normfact = (float )tmp;
#line 592
  iptr = ubuf.ibuf;
#line 593
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;

#line 594
    if (! (len > 0L)) {
#line 594
      goto while_break;
    }
#line 595
    if (len >= (long )bufferlen) {
#line 595
      tmp___0 = (long )bufferlen;
    } else {
#line 595
      tmp___0 = len;
    }
    {
#line 595
    readcount = (int )tmp___0;
#line 596
    count___0 = paf24_read(psf, ppaf24, iptr, readcount);
#line 597
    k = 0;
    }
    {
#line 597
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 597
      if (! (k < readcount)) {
#line 597
        goto while_break___0;
      }
#line 598
      *(ptr + (total + (long )k)) = normfact * (float )*(iptr + k);
#line 597
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 599
    total += (long )count___0;
#line 600
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 602
  return (total);
}
}
#line 606 "/root/patchweave_donee/23/src/paf.c"
static sf_count_t paf24_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 611
  total = (sf_count_t )0;
#line 614
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 615
    return ((sf_count_t )0);
  }
#line 616
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 618
  if (psf->norm_double == 1) {
#line 618
    tmp = 1. / (double )2147483648U;
  } else {
#line 618
    tmp = 1. / (double )256;
  }
#line 618
  normfact = tmp;
#line 620
  iptr = ubuf.ibuf;
#line 621
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;

#line 622
    if (! (len > 0L)) {
#line 622
      goto while_break;
    }
#line 623
    if (len >= (long )bufferlen) {
#line 623
      tmp___0 = (long )bufferlen;
    } else {
#line 623
      tmp___0 = len;
    }
    {
#line 623
    readcount = (int )tmp___0;
#line 624
    count___0 = paf24_read(psf, ppaf24, iptr, readcount);
#line 625
    k = 0;
    }
    {
#line 625
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 625
      if (! (k < readcount)) {
#line 625
        goto while_break___0;
      }
#line 626
      *(ptr + (total + (long )k)) = normfact * (double )*(iptr + k);
#line 625
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 627
    total += (long )count___0;
#line 628
    len -= (long )readcount;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 630
  return (total);
}
}
#line 637 "/root/patchweave_donee/23/src/paf.c"
static int paf24_write_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) 
{ 
  int k ;
  int nextsample ;
  int channel ;
  unsigned char *cptr ;
  sf_count_t __cil_tmp9 ;

  {
#line 643
  if (1) {
#line 644
    k = 0;
    {
#line 644
    while (1) {
      while_continue: /* CIL Label */ ;

#line 644
      if (! (k < 10 * ppaf24->channels)) {
#line 644
        goto while_break;
      }
#line 645
      channel = k % ppaf24->channels;
#line 646
      cptr = (ppaf24->block + 32 * channel) + 3 * (k / ppaf24->channels);
#line 647
      nextsample = *(ppaf24->samples + k) >> 8;
#line 648
      *(cptr + 0) = (unsigned char )nextsample;
#line 649
      *(cptr + 1) = (unsigned char )(nextsample >> 8);
#line 650
      *(cptr + 2) = (unsigned char )(nextsample >> 16);
#line 644
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
#line 654
    if (psf->endian == 536870912) {
      {
#line 655
      endswap_int_array(ppaf24->data, 8 * ppaf24->channels);
      }
    }
  } else
#line 657
  if (0) {
#line 659
    k = 0;
    {
#line 659
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 659
      if (! (k < 10 * ppaf24->channels)) {
#line 659
        goto while_break___0;
      }
#line 660
      channel = k % ppaf24->channels;
#line 661
      cptr = (ppaf24->block + 32 * channel) + 3 * (k / ppaf24->channels);
#line 662
      nextsample = *(ppaf24->samples + k) >> 8;
#line 663
      *(cptr + 0) = (unsigned char )nextsample;
#line 664
      *(cptr + 1) = (unsigned char )(nextsample >> 8);
#line 665
      *(cptr + 2) = (unsigned char )(nextsample >> 16);
#line 659
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 667
    if (psf->endian == 536870912) {
      {
#line 668
      endswap_int_array(ppaf24->data, 8 * ppaf24->channels);
      }
    }
  }
  {
#line 672
  __cil_tmp9 = psf_fwrite((void const   *)ppaf24->block, (sf_count_t )1, (sf_count_t )ppaf24->blocksize,
                          psf);
#line 672
  k = (int )__cil_tmp9;
  }
#line 672
  if (k != ppaf24->blocksize) {
    {
#line 673
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, ppaf24->blocksize);
    }
  }
#line 675
  if (ppaf24->sample_count < (long )(ppaf24->write_block * 10 + ppaf24->write_count)) {
#line 676
    ppaf24->sample_count = (sf_count_t )(ppaf24->write_block * 10 + ppaf24->write_count);
  }
#line 678
  if (ppaf24->write_count == 10) {
#line 679
    (ppaf24->write_block) ++;
#line 680
    ppaf24->write_count = 0;
  }
#line 683
  return (1);
}
}
#line 687 "/root/patchweave_donee/23/src/paf.c"
static int paf24_write(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 , int const   *ptr ,
                       int len ) 
{ 
  int count___0 ;
  int total ;

  {
#line 688
  total = 0;
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;

#line 690
    if (! (total < len)) {
#line 690
      goto while_break;
    }
#line 691
    count___0 = (10 - ppaf24->write_count) * ppaf24->channels;
#line 693
    if (count___0 > len - total) {
#line 694
      count___0 = len - total;
    }
    {
#line 696
    memcpy((void *)(ppaf24->samples + ppaf24->write_count * ppaf24->channels), (void const   *)(ptr + total),
           (unsigned long )count___0 * sizeof(int ));
#line 697
    total += count___0;
#line 698
    ppaf24->write_count += count___0 / ppaf24->channels;
    }
#line 700
    if (ppaf24->write_count >= 10) {
      {
#line 701
      paf24_write_block(psf, ppaf24);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 704
  return (total);
}
}
#line 708 "/root/patchweave_donee/23/src/paf.c"
static sf_count_t paf24_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 712
  writecount = 0;
#line 713
  total = (sf_count_t )0;
#line 715
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 716
    return ((sf_count_t )0);
  }
#line 717
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 719
  iptr = ubuf.ibuf;
#line 720
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;

#line 721
    if (! (len > 0L)) {
#line 721
      goto while_break;
    }
#line 722
    if (len >= (long )bufferlen) {
#line 722
      tmp = (long )bufferlen;
    } else {
#line 722
      tmp = len;
    }
#line 722
    writecount = (int )tmp;
#line 723
    k = 0;
    {
#line 723
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 723
      if (! (k < writecount)) {
#line 723
        goto while_break___0;
      }
#line 724
      *(iptr + k) = (int )*(ptr + (total + (long )k)) << 16;
#line 723
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 725
    count___0 = paf24_write(psf, ppaf24, (int const   *)iptr, writecount);
#line 726
    total += (long )count___0;
#line 727
    len -= (long )writecount;
    }
#line 728
    if (count___0 != writecount) {
#line 729
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 731
  return (total);
}
}
#line 735 "/root/patchweave_donee/23/src/paf.c"
static sf_count_t paf24_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 738
  total = (sf_count_t )0;
#line 740
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 741
    return ((sf_count_t )0);
  }
#line 742
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;

#line 744
    if (! (len > 0L)) {
#line 744
      goto while_break;
    }
#line 745
    if (len > 268435456L) {
#line 745
      tmp = 268435456;
    } else {
#line 745
      tmp = (int )len;
    }
    {
#line 745
    writecount = tmp;
#line 747
    count___0 = paf24_write(psf, ppaf24, ptr, writecount);
#line 749
    total += (long )count___0;
#line 750
    len -= (long )count___0;
    }
#line 751
    if (count___0 != writecount) {
#line 752
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 755
  return (total);
}
}
#line 759 "/root/patchweave_donee/23/src/paf.c"
static sf_count_t paf24_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 763
  writecount = 0;
#line 764
  total = (sf_count_t )0;
#line 767
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 768
    return ((sf_count_t )0);
  }
#line 769
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 771
  if (psf->norm_float == 1) {
#line 771
    tmp = 1. * (double )2147483647;
  } else {
#line 771
    tmp = 1. / (double )256;
  }
#line 771
  normfact = (float )tmp;
#line 773
  iptr = ubuf.ibuf;
#line 774
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;

#line 775
    if (! (len > 0L)) {
#line 775
      goto while_break;
    }
#line 776
    if (len >= (long )bufferlen) {
#line 776
      tmp___0 = (long )bufferlen;
    } else {
#line 776
      tmp___0 = len;
    }
#line 776
    writecount = (int )tmp___0;
#line 777
    k = 0;
    {
#line 777
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 777
      if (! (k < writecount)) {
#line 777
        goto while_break___0;
      }
      {
#line 778
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 778
      *(iptr + k) = (int )__cil_tmp15;
#line 777
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 779
    count___0 = paf24_write(psf, ppaf24, (int const   *)iptr, writecount);
#line 780
    total += (long )count___0;
#line 781
    len -= (long )writecount;
    }
#line 782
    if (count___0 != writecount) {
#line 783
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 786
  return (total);
}
}
#line 790 "/root/patchweave_donee/23/src/paf.c"
static sf_count_t paf24_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 794
  writecount = 0;
#line 795
  total = (sf_count_t )0;
#line 798
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 799
    return ((sf_count_t )0);
  }
#line 800
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 802
  if (psf->norm_double == 1) {
#line 802
    tmp = 1. * (double )2147483647;
  } else {
#line 802
    tmp = 1. / (double )256;
  }
#line 802
  normfact = tmp;
#line 804
  iptr = ubuf.ibuf;
#line 805
  bufferlen = (int )(sizeof(ubuf.ibuf) / sizeof(ubuf.ibuf[0]));
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;

#line 806
    if (! (len > 0L)) {
#line 806
      goto while_break;
    }
#line 807
    if (len >= (long )bufferlen) {
#line 807
      tmp___0 = (long )bufferlen;
    } else {
#line 807
      tmp___0 = len;
    }
#line 807
    writecount = (int )tmp___0;
#line 808
    k = 0;
    {
#line 808
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 808
      if (! (k < writecount)) {
#line 808
        goto while_break___0;
      }
      {
#line 809
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 809
      *(iptr + k) = (int )__cil_tmp15;
#line 808
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 810
    count___0 = paf24_write(psf, ppaf24, (int const   *)iptr, writecount);
#line 811
    total += (long )count___0;
#line 812
    len -= (long )writecount;
    }
#line 813
    if (count___0 != writecount) {
#line 814
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 817
  return (total);
}
}
#line 46 "/root/patchweave_donee/23/src/nist.c"
static int nist_close(SF_PRIVATE *psf ) ;
#line 47
static int nist_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 48
static int nist_read_header(SF_PRIVATE *psf ) ;
#line 54 "/root/patchweave_donee/23/src/nist.c"
int nist_open(SF_PRIVATE *psf ) 
{ 
  int error ;
  int tmp ;

  {
#line 57
  if (psf->file.mode == 16) {
    _L: 
    {
#line 58
    error = nist_read_header(psf);
    }
#line 58
    if (error) {
#line 59
      return (error);
    }
  } else
#line 57
  if (psf->file.mode == 48) {
#line 57
    if (psf->filelength > 0L) {
#line 57
      goto _L;
    }
  }
#line 62
  if (psf->file.mode == 32) {
    _L___33: 
#line 63
    if (psf->is_pipe) {
#line 64
      return (29);
    }
#line 66
    if ((psf->sf.format & 268369920) != 458752) {
#line 67
      return (1);
    }
#line 69
    psf->endian = psf->sf.format & 805306368;
#line 70
    if (psf->endian == 0) {
#line 71
      tmp = 268435456;
#line 71
      psf->endian = tmp;
    } else
#line 70
    if (psf->endian == 805306368) {
#line 71
      tmp = 268435456;
#line 71
      psf->endian = tmp;
    }
    {
#line 73
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 74
    psf->sf.frames = (sf_count_t )0;
#line 76
    error = nist_write_header(psf, 0);
    }
#line 76
    if (error) {
#line 77
      return (error);
    }
#line 79
    psf->write_header = & nist_write_header;
  } else
#line 62
  if (psf->file.mode == 48) {
#line 62
    goto _L___33;
  }
#line 82
  psf->container_close = & nist_close;
#line 85
  if ((psf->sf.format & 65535) == 1) {
#line 85
    goto case_1;
  }
#line 91
  if ((psf->sf.format & 65535) == 4) {
#line 91
    goto case_4;
  }
#line 91
  if ((psf->sf.format & 65535) == 3) {
#line 91
    goto case_4;
  }
#line 91
  if ((psf->sf.format & 65535) == 2) {
#line 91
    goto case_4;
  }
#line 95
  if ((psf->sf.format & 65535) == 16) {
#line 95
    goto case_16;
  }
#line 99
  if ((psf->sf.format & 65535) == 17) {
#line 99
    goto case_17;
  }
#line 103
  goto switch_default;
  case_1: 
  {
#line 86
  error = pcm_init(psf);
  }
#line 87
  goto switch_break;
  case_4: 
  {
#line 92
  error = pcm_init(psf);
  }
#line 93
  goto switch_break;
  case_16: 
  {
#line 96
  error = ulaw_init(psf);
  }
#line 97
  goto switch_break;
  case_17: 
  {
#line 100
  error = alaw_init(psf);
  }
#line 101
  goto switch_break;
  switch_default: 
#line 103
  error = 18;
#line 104
  goto switch_break;
  switch_break: ;
#line 107
  return (error);
}
}
#line 113 "/root/patchweave_donee/23/src/nist.c"
static char bad_header[19]  = 
#line 113
  {      (char )'N',      (char )'I',      (char )'S',      (char )'T', 
        (char )'_',      (char )'1',      (char )'A',      (char)13, 
        (char)10,      (char )' ',      (char )' ',      (char )' ', 
        (char )'1',      (char )'0',      (char )'2',      (char )'4', 
        (char)13,      (char)10,      (char)0};
#line 120 "/root/patchweave_donee/23/src/nist.c"
static int nist_read_header(SF_PRIVATE *psf ) 
{ 
  char psf_header[1026] ;
  int bitwidth ;
  int count___0 ;
  int encoding ;
  unsigned int bytes ;
  char str[64] ;
  char *cptr ;
  long samples ;
  unsigned long __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  char *__cil_tmp31 ;

  {
#line 122
  bitwidth = 0;
#line 123
  bytes = 0U;
#line 127
  if (sizeof(psf->header) <= 1024UL) {
#line 128
    return (30);
  }
  {
#line 131
  psf_binheader_readf(psf, "pb\316\331\204U", 0, psf_header, 1024);
#line 134
  psf_header[1024] = (char)0;
#line 137
  cptr = strstr((char const   *)(psf_header), "end_head\220");
  }
#line 137
  if (cptr) {
    {
#line 138
    __cil_tmp11 = strlen("end_head\220");
#line 138
    cptr += __cil_tmp11 + 1UL;
#line 139
    *(cptr + 0) = (char)0;
    }
  }
  {
#line 142
  __cil_tmp12 = strstr((char const   *)(psf_header), (char const   *)(bad_header));
  }
#line 142
  if ((unsigned long )__cil_tmp12 == (unsigned long )(psf_header)) {
#line 143
    return (108);
  }
  {
#line 146
  __cil_tmp13 = strstr((char const   *)(psf_header), "NIST_1A\n\220");
  }
#line 146
  if ((unsigned long )__cil_tmp13 != (unsigned long )(psf_header)) {
    {
#line 147
    psf_log_printf(psf, "Not a NIST file.\n");
    }
#line 148
    return (107);
  }
  {
#line 151
  __cil_tmp14 = sscanf((char const   *)(psf_header), "NIST_1A\n%d\n", & count___0);
  }
#line 151
  if (__cil_tmp14 == 1) {
#line 152
    psf->dataoffset = (sf_count_t )count___0;
  } else {
    {
#line 154
    psf_log_printf(psf, "*** Suspicious header length.\n");
#line 155
    psf->dataoffset = (sf_count_t )1024;
    }
  }
  {
#line 159
  encoding = 5;
#line 160
  cptr = strstr((char const   *)(psf_header), "sample_coding -s\220");
  }
#line 160
  if (cptr) {
    {
#line 161
    sscanf((char const   *)cptr, "sample_coding -s%d %63s", & count___0, str);
#line 163
    __cil_tmp16 = strcmp((char const   *)(str), "pcm\331\204U");
    }
#line 163
    if (__cil_tmp16 == 0) {
#line 165
      encoding = 5;
    } else {
      {
#line 167
      __cil_tmp17 = strcmp((char const   *)(str), "alaw");
      }
#line 167
      if (__cil_tmp17 == 0) {
#line 168
        encoding = 17;
      } else {
        {
#line 169
        __cil_tmp19 = strcmp((char const   *)(str), "mu-law");
#line 169
        __cil_tmp18 = strcmp((char const   *)(str), "ulaw\204U");
        }
#line 169
        if (__cil_tmp18 == 0) {
#line 170
          encoding = 16;
        } else
#line 169
        if (__cil_tmp19 == 0) {
#line 170
          encoding = 16;
        } else {
          {
#line 172
          psf_log_printf(psf, "*** Unknown encoding : %s\n", str);
#line 173
          encoding = 0;
          }
        }
      }
    }
  }
  {
#line 177
  cptr = strstr((char const   *)(psf_header), "channel_count -i H\316\331\204U");
  }
#line 177
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 178
    sscanf((char const   *)cptr, "channel_count -i %d", & psf->sf.channels);
    }
  }
  {
#line 180
  cptr = strstr((char const   *)(psf_header), "sample_rate -i ");
  }
#line 180
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 181
    sscanf((char const   *)cptr, "sample_rate -i %d", & psf->sf.samplerate);
    }
  }
  {
#line 183
  cptr = strstr((char const   *)(psf_header), "sample_count -i \220");
  }
#line 183
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 184
    sscanf((char const   *)cptr, "sample_count -i %ld", & samples);
#line 185
    psf->sf.frames = samples;
    }
  }
  {
#line 188
  cptr = strstr((char const   *)(psf_header), "sample_n_bytes -i ");
  }
#line 188
  if ((unsigned long )cptr != (unsigned long )((void *)0)) {
    {
#line 189
    sscanf((char const   *)cptr, "sample_n_bytes -i %d", & psf->bytewidth);
    }
  }
  {
#line 192
  tmp = 268435456;
#line 192
  psf->endian = tmp;
#line 195
  __cil_tmp26 = sscanf((char const   *)cptr, "sample_byte_format -s%u %8s", & bytes,
                       str);
#line 195
  cptr = strstr((char const   *)(psf_header), "sample_byte_format -s");
  }
#line 195
  if (cptr) {
#line 195
    if (__cil_tmp26 == 2) {
      {
#line 198
      __cil_tmp27 = strlen((char const   *)(str));
      }
#line 198
      if ((unsigned long )bytes != __cil_tmp27) {
        {
#line 199
        psf_log_printf(psf, "Weird sample_byte_format : strlen \'%s\' != %d\n", str,
                       bytes);
        }
      }
#line 201
      if (bytes > 1U) {
#line 202
        if (psf->bytewidth == 0) {
#line 203
          psf->bytewidth = (int )bytes;
        } else
#line 204
        if ((unsigned int )psf->bytewidth - bytes != 0U) {
          {
#line 205
          psf_log_printf(psf, "psf->bytewidth (%d) != bytes (%d)\n", psf->bytewidth,
                         bytes);
          }
#line 206
          return (109);
        }
        {
#line 209
        __cil_tmp28 = strcmp((char const   *)(str), "01");
        }
#line 209
        if (__cil_tmp28 == 0) {
#line 210
          psf->endian = 268435456;
        } else {
          {
#line 211
          __cil_tmp29 = strcmp((char const   *)(str), "10");
          }
#line 211
          if (__cil_tmp29 == 0) {
#line 212
            psf->endian = 536870912;
          } else {
            {
#line 214
            psf_log_printf(psf, "Weird endian-ness : %s\n", str);
            }
#line 215
            return (109);
          }
        }
      }
#line 219
      psf->sf.format |= psf->endian;
    }
  }
  {
#line 222
  cptr = strstr((char const   *)(psf_header), "sample_sig_bits -i ");
  }
#line 222
  if (cptr) {
    {
#line 223
    sscanf((char const   *)cptr, "sample_sig_bits -i %d", & bitwidth);
    }
  }
  {
#line 225
  __cil_tmp31 = strstr((char const   *)(psf_header), "channels_interleaved -s5 FALSE");
  }
#line 225
  if (__cil_tmp31) {
    {
#line 226
    psf_log_printf(psf, "Non-interleaved data unsupported.\n", str);
    }
#line 227
    return (109);
  }
  {
#line 230
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 231
  psf->datalength = psf->filelength - psf->dataoffset;
#line 233
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 235
  if (encoding == 5) {
#line 237
    if (psf->bytewidth == 1) {
#line 237
      goto case_1;
    }
#line 241
    if (psf->bytewidth == 2) {
#line 241
      goto case_2;
    }
#line 245
    if (psf->bytewidth == 3) {
#line 245
      goto case_3;
    }
#line 249
    if (psf->bytewidth == 4) {
#line 249
      goto case_4;
    }
#line 253
    goto switch_default;
    case_1: 
#line 238
    psf->sf.format |= 1;
#line 239
    goto switch_break;
    case_2: 
#line 242
    psf->sf.format |= 2;
#line 243
    goto switch_break;
    case_3: 
#line 246
    psf->sf.format |= 3;
#line 247
    goto switch_break;
    case_4: 
#line 250
    psf->sf.format |= 4;
#line 251
    goto switch_break;
    switch_default: 
#line 253
    goto switch_break;
    switch_break: ;
  } else
#line 256
  if (encoding != 0) {
#line 257
    psf->sf.format |= encoding;
  } else {
#line 259
    return (18);
  }
#line 265
  if ((psf->sf.format & 65535) == 5) {
#line 265
    goto case_5;
  }
#line 265
  if ((psf->sf.format & 65535) == 17) {
#line 265
    goto case_5;
  }
#line 265
  if ((psf->sf.format & 65535) == 16) {
#line 265
    goto case_5;
  }
#line 270
  goto switch_default___0;
  case_5: 
#line 267
  psf->sf.format = 458752 | (psf->sf.format & 65535);
#line 268
  goto switch_break___0;
  switch_default___0: 
#line 271
  goto switch_break___0;
  switch_break___0: ;
#line 274
  return (0);
}
}
#line 278 "/root/patchweave_donee/23/src/nist.c"
static int nist_close(SF_PRIVATE *psf ) 
{ 


  {
#line 280
  if (psf->file.mode == 32) {
    {
#line 281
    nist_write_header(psf, 1);
    }
  } else
#line 280
  if (psf->file.mode == 48) {
    {
#line 281
    nist_write_header(psf, 1);
    }
  }
#line 283
  return (0);
}
}
#line 290 "/root/patchweave_donee/23/src/nist.c"
static int nist_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  char const   *end_str ;
  long samples ;
  sf_count_t current ;

  {
  {
#line 295
  current = psf_ftell(psf);
  }
#line 297
  if (calc_length) {
    {
#line 298
    psf->filelength = psf_get_filelen(psf);
#line 300
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 302
    if (psf->dataend) {
#line 303
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 305
    if (psf->bytewidth > 0) {
#line 306
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
#line 309
  if (psf->endian == 536870912) {
#line 310
    end_str = "10";
  } else
#line 311
  if (psf->endian == 268435456) {
#line 312
    end_str = "01";
  } else {
#line 314
    end_str = "errorU";
  }
  {
#line 317
  memset((void *)(psf->header), 0, sizeof(psf->header));
#line 318
  psf->headindex = 0;
#line 320
  psf_fseek(psf, (sf_count_t )0, 0);
#line 322
  psf_asciiheader_printf(psf, "NIST_1A\n   1024\n\220");
#line 323
  psf_asciiheader_printf(psf, "channel_count -i %d\n\204U", psf->sf.channels);
#line 324
  psf_asciiheader_printf(psf, "sample_rate -i %d\n\316\331\204U", psf->sf.samplerate);
  }
#line 327
  if ((psf->sf.format & 65535) == 1) {
#line 327
    goto case_1;
  }
#line 335
  if ((psf->sf.format & 65535) == 4) {
#line 335
    goto case_4;
  }
#line 335
  if ((psf->sf.format & 65535) == 3) {
#line 335
    goto case_4;
  }
#line 335
  if ((psf->sf.format & 65535) == 2) {
#line 335
    goto case_4;
  }
#line 342
  if ((psf->sf.format & 65535) == 17) {
#line 342
    goto case_17;
  }
#line 347
  if ((psf->sf.format & 65535) == 16) {
#line 347
    goto case_16;
  }
#line 352
  goto switch_default;
  case_1: 
  {
#line 328
  psf_asciiheader_printf(psf, "sample_coding -s3 pcm\n");
#line 329
  psf_asciiheader_printf(psf, "sample_n_bytes -i 1\nsample_sig_bits -i 8\n");
  }
#line 331
  goto switch_break;
  case_4: 
  {
#line 336
  psf_asciiheader_printf(psf, "sample_n_bytes -i %d\nU", psf->bytewidth);
#line 337
  psf_asciiheader_printf(psf, "sample_sig_bits -i %d\n", psf->bytewidth * 8);
#line 338
  psf_asciiheader_printf(psf, "sample_coding -s3 pcm\nsample_byte_format -s%d %s\n",
                         psf->bytewidth, end_str);
  }
#line 340
  goto switch_break;
  case_17: 
  {
#line 343
  psf_asciiheader_printf(psf, "sample_coding -s4 alaw\n");
#line 344
  psf_asciiheader_printf(psf, "sample_n_bytes -s1 1\nU");
  }
#line 345
  goto switch_break;
  case_16: 
  {
#line 348
  psf_asciiheader_printf(psf, "sample_coding -s4 ulaw\n");
#line 349
  psf_asciiheader_printf(psf, "sample_n_bytes -s1 1\n");
  }
#line 350
  goto switch_break;
  switch_default: 
#line 352
  return (18);
  switch_break: 
  {
#line 355
  psf->dataoffset = (sf_count_t )1024;
#line 358
  samples = psf->sf.frames;
#line 359
  psf_asciiheader_printf(psf, "sample_count -i %ld\n", samples);
#line 360
  psf_asciiheader_printf(psf, "end_head\n");
#line 363
  psf_binheader_writef(psf, "z\301\316\331\204U", (size_t )(1024 - psf->headindex));
#line 365
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 367
  if (psf->error) {
#line 368
    return (psf->error);
  }
#line 370
  if (current > 0L) {
    {
#line 371
    psf_fseek(psf, current, 0);
    }
  }
#line 373
  return (psf->error);
}
}
#line 76 "/root/patchweave_donee/23/src/mat5.c"
static int mat5_close(SF_PRIVATE *psf ) ;
#line 78
static int mat5_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 79
static int mat5_read_header(SF_PRIVATE *psf ) ;
#line 86 "/root/patchweave_donee/23/src/mat5.c"
int mat5_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;

  {
#line 87
  error = 0;
#line 89
  if (psf->file.mode == 16) {
    _L: 
    {
#line 90
    error = mat5_read_header(psf);
    }
#line 90
    if (error) {
#line 91
      return (error);
    }
  } else
#line 89
  if (psf->file.mode == 48) {
#line 89
    if (psf->filelength > 0L) {
#line 89
      goto _L;
    }
  }
#line 94
  if ((psf->sf.format & 268369920) != 851968) {
#line 95
    return (1);
  }
#line 97
  subformat = psf->sf.format & 65535;
#line 99
  if (psf->file.mode == 32) {
    _L___34: 
#line 100
    if (psf->is_pipe) {
#line 101
      return (29);
    }
#line 103
    psf->endian = psf->sf.format & 805306368;
#line 104
    if (psf->endian == 805306368) {
#line 105
      psf->endian = 268435456;
    } else
#line 104
    if (psf->endian == 0) {
#line 105
      psf->endian = 268435456;
    }
    {
#line 109
    error = mat5_write_header(psf, 0);
    }
#line 109
    if (error) {
#line 110
      return (error);
    }
#line 112
    psf->write_header = & mat5_write_header;
  } else
#line 99
  if (psf->file.mode == 48) {
#line 99
    goto _L___34;
  }
#line 115
  psf->container_close = & mat5_close;
#line 117
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 122
  if (subformat == 4) {
#line 122
    goto case_4;
  }
#line 122
  if (subformat == 2) {
#line 122
    goto case_4;
  }
#line 122
  if (subformat == 5) {
#line 122
    goto case_4;
  }
#line 126
  if (subformat == 6) {
#line 126
    goto case_6;
  }
#line 130
  if (subformat == 7) {
#line 130
    goto case_7;
  }
#line 134
  goto switch_default;
  case_4: 
  {
#line 123
  error = pcm_init(psf);
  }
#line 124
  goto switch_break;
  case_6: 
  {
#line 127
  error = float32_init(psf);
  }
#line 128
  goto switch_break;
  case_7: 
  {
#line 131
  error = double64_init(psf);
  }
#line 132
  goto switch_break;
  switch_default: 
#line 134
  goto switch_break;
  switch_break: ;
#line 137
  return (error);
}
}
#line 144 "/root/patchweave_donee/23/src/mat5.c"
static int mat5_close(SF_PRIVATE *psf ) 
{ 


  {
#line 146
  if (psf->file.mode == 32) {
    {
#line 147
    mat5_write_header(psf, 1);
    }
  } else
#line 146
  if (psf->file.mode == 48) {
    {
#line 147
    mat5_write_header(psf, 1);
    }
  }
#line 149
  return (0);
}
}
#line 158 "/root/patchweave_donee/23/src/mat5.c"
static char const   *filename  ;
#line 159 "/root/patchweave_donee/23/src/mat5.c"
static char const   *sr_name  ;
#line 160 "/root/patchweave_donee/23/src/mat5.c"
static char const   *wd_name  ;
#line 156 "/root/patchweave_donee/23/src/mat5.c"
static int mat5_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  char buffer[256] ;
  sf_count_t current ;
  sf_count_t datasize ;
  int encoding ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  size_t __cil_tmp18 ;
  unsigned short samplerate ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;

  {
  {
#line 157
  filename = "MATLAB 5.0 MAT-file, written by libsndfile-1.0.26, ";
#line 158
  sr_name = "samplerate";
#line 159
  wd_name = "wavedata";
#line 164
  current = psf_ftell(psf);
  }
#line 166
  if (calc_length) {
    {
#line 167
    psf_fseek(psf, (sf_count_t )0, 2);
#line 168
    psf->filelength = psf_ftell(psf);
#line 169
    psf_fseek(psf, (sf_count_t )0, 0);
#line 171
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 172
    if (psf->dataend) {
#line 173
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 175
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
#line 179
  if ((psf->sf.format & 65535) == 5) {
#line 179
    goto case_5;
  }
#line 183
  if ((psf->sf.format & 65535) == 2) {
#line 183
    goto case_2;
  }
#line 187
  if ((psf->sf.format & 65535) == 4) {
#line 187
    goto case_4;
  }
#line 191
  if ((psf->sf.format & 65535) == 6) {
#line 191
    goto case_6;
  }
#line 195
  if ((psf->sf.format & 65535) == 7) {
#line 195
    goto case_7;
  }
#line 199
  goto switch_default;
  case_5: 
#line 180
  encoding = 2;
#line 181
  goto switch_break;
  case_2: 
#line 184
  encoding = 3;
#line 185
  goto switch_break;
  case_4: 
#line 188
  encoding = 5;
#line 189
  goto switch_break;
  case_6: 
#line 192
  encoding = 7;
#line 193
  goto switch_break;
  case_7: 
#line 196
  encoding = 9;
#line 197
  goto switch_break;
  switch_default: 
#line 200
  return (1);
  switch_break: 
  {
#line 204
  psf->header[0] = (unsigned char)0;
#line 205
  psf->headindex = 0;
#line 206
  psf_fseek(psf, (sf_count_t )0, 0);
#line 208
  psf_get_date_str(buffer, (int )sizeof(buffer));
#line 209
  __cil_tmp12 = strlen(filename);
#line 209
  __cil_tmp13 = strlen((char const   *)(buffer));
#line 209
  psf_binheader_writef(psf, "bb", filename, __cil_tmp12, buffer, __cil_tmp13 + 1UL);
#line 211
  memset((void *)(buffer), ' ', (unsigned long )(124 - psf->headindex));
#line 212
  __cil_tmp14 = make_size_t(124 - psf->headindex);
#line 212
  psf_binheader_writef(psf, "b\274\322\331\204U", buffer, __cil_tmp14);
#line 214
  psf->rwf_endian = psf->endian;
  }
#line 216
  if (psf->rwf_endian == 536870912) {
    {
#line 217
    __cil_tmp15 = make_size_t(2);
#line 217
    psf_binheader_writef(psf, "2b", 256, "MI", __cil_tmp15);
    }
  } else {
    {
#line 219
    __cil_tmp16 = make_size_t(2);
#line 219
    psf_binheader_writef(psf, "2b\374\331\204U", 256, "IM\374\331\204U", __cil_tmp16);
    }
  }
  {
#line 221
  psf_binheader_writef(psf, "444444", 14, 64, 6, 8, 6, 0);
#line 222
  psf_binheader_writef(psf, "4444", 5, 8, 1, 1);
#line 223
  __cil_tmp17 = strlen(sr_name);
#line 223
  __cil_tmp18 = make_size_t(16);
#line 223
  psf_binheader_writef(psf, "44b\331\204U", 1, __cil_tmp17, sr_name, __cil_tmp18);
  }
#line 225
  if (psf->sf.samplerate > 65535) {
    {
#line 226
    psf_binheader_writef(psf, "44", 262150, psf->sf.samplerate);
    }
  } else {
    {
#line 228
    samplerate = (unsigned short )psf->sf.samplerate;
#line 230
    psf_binheader_writef(psf, "422\331\204U", 131076, (int )samplerate, 0);
    }
  }
  {
#line 233
  datasize = (psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth;
#line 235
  psf_binheader_writef(psf, "t484444", 14, datasize + 64L, 6, 8, 6, 0);
#line 236
  psf_binheader_writef(psf, "t4448", 5, 8, psf->sf.channels, psf->sf.frames);
#line 237
  __cil_tmp20 = strlen(wd_name);
#line 237
  __cil_tmp21 = strlen(wd_name);
#line 237
  psf_binheader_writef(psf, "44b", 1, __cil_tmp20, wd_name, __cil_tmp21);
#line 239
  datasize = (psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth;
  }
#line 240
  if (datasize > 2147483647L) {
#line 241
    datasize = (sf_count_t )2147483647;
  }
  {
#line 243
  psf_binheader_writef(psf, "t48", encoding, datasize);
#line 246
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 248
  if (psf->error) {
#line 249
    return (psf->error);
  }
#line 251
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 253
  if (current > 0L) {
    {
#line 254
    psf_fseek(psf, current, 0);
    }
  }
#line 256
  return (psf->error);
}
}
#line 260 "/root/patchweave_donee/23/src/mat5.c"
static int mat5_read_header(SF_PRIVATE *psf ) 
{ 
  char buffer[256] ;
  char name[32] ;
  short version ;
  short endian ;
  int type ;
  int flags1 ;
  int flags2 ;
  int rows ;
  int cols ;
  unsigned int size ;
  int have_samplerate ;
  unsigned long __cil_tmp13 ;
  char *__cil_tmp14 ;
  char const   *tmp ;
  double samplerate ;
  long __cil_tmp20 ;
  unsigned short samplerate___0 ;

  {
  {
#line 265
  have_samplerate = 1;
#line 267
  psf_binheader_readf(psf, "pb", 0, buffer, 124);
#line 269
  buffer[125] = (char)0;
#line 271
  __cil_tmp13 = strlen((char const   *)(buffer));
  }
#line 271
  if (__cil_tmp13 >= 124UL) {
#line 272
    return (18);
  }
  {
#line 274
  __cil_tmp14 = strstr((char const   *)(buffer), "MATLAB 5.0 MAT-file");
  }
#line 274
  if ((unsigned long )__cil_tmp14 == (unsigned long )(buffer)) {
    {
#line 275
    psf_log_printf(psf, "%s\n", buffer);
    }
  }
  {
#line 278
  psf_binheader_readf(psf, "E22", & version, & endian);
  }
#line 280
  if ((int )endian == (77 << 8) + 73) {
    {
#line 281
    psf->rwf_endian = 536870912;
#line 281
    psf->endian = psf->rwf_endian;
#line 282
    version = ENDSWAP_16(version);
    }
  } else
#line 284
  if ((int )endian == (73 << 8) + 77) {
#line 285
    psf->rwf_endian = 268435456;
#line 285
    psf->endian = psf->rwf_endian;
  } else {
#line 289
    return (132);
  }
#line 291
  if ((int )endian == (73 << 8) + 77) {
    {
#line 293
    version = ENDSWAP_16(version);
    }
  }
  {
#line 295
  psf_log_printf(psf, "Version : 0x%04X\n", (int )version);
  }
#line 296
  if (psf->endian == 268435456) {
#line 296
    tmp = "Little";
  } else {
#line 296
    tmp = "Big";
  }
  {
#line 296
  psf_log_printf(psf, "Endian  : 0x%04X => %s\n", (int )endian, tmp);
#line 300
  psf_binheader_readf(psf, "44", & type, & size);
#line 301
  psf_log_printf(psf, "Block\n Type : %X    Size : %d\n", type, size);
  }
#line 303
  if (type != 14) {
#line 304
    return (133);
  }
  {
#line 306
  psf_binheader_readf(psf, "44", & type, & size);
#line 307
  psf_log_printf(psf, "    Type : %X    Size : %d\n", type, size);
  }
#line 309
  if (type != 6) {
#line 310
    return (133);
  }
  {
#line 312
  psf_binheader_readf(psf, "44", & flags1, & flags2);
#line 313
  psf_log_printf(psf, "    Flg1 : %X    Flg2 : %d\n", flags1, flags2);
#line 315
  psf_binheader_readf(psf, "44", & type, & size);
#line 316
  psf_log_printf(psf, "    Type : %X    Size : %d\n", type, size);
  }
#line 318
  if (type != 5) {
#line 319
    return (133);
  }
  {
#line 321
  psf_binheader_readf(psf, "44", & rows, & cols);
#line 322
  psf_log_printf(psf, "    Rows : %d    Cols : %d\n", rows, cols);
  }
#line 324
  if (rows != 1) {
    _L: 
#line 325
    if (psf->sf.samplerate == 0) {
#line 326
      psf->sf.samplerate = 44100;
    }
#line 327
    have_samplerate = 0;
  } else
#line 324
  if (cols != 1) {
#line 324
    goto _L;
  }
  {
#line 329
  psf_binheader_readf(psf, "4", & type);
  }
#line 331
  if (type == 1) {
    {
#line 332
    psf_binheader_readf(psf, "4", & size);
#line 333
    psf_log_printf(psf, "    Type : %X    Size : %d\n\331\204U", type, size);
    }
#line 334
    if (size > (unsigned int )((int )sizeof(name) - 1)) {
      {
#line 335
      psf_log_printf(psf, "Error : Bad name length.\n");
      }
#line 336
      return (133);
    }
    {
#line 339
    psf_binheader_readf(psf, "bj\374\331\204U", name, size, (8U - size % 8U) % 8U);
#line 340
    name[size] = (char)0;
    }
  } else
#line 342
  if ((type & 65535) == 1) {
#line 343
    size = (unsigned int )(type >> 16);
#line 344
    if (size > 4U) {
      {
#line 345
      psf_log_printf(psf, "Error : Bad name length.\n\324\374\331\204U");
      }
#line 346
      return (133);
    }
    {
#line 349
    psf_log_printf(psf, "    Type : %X\n", type);
#line 350
    psf_binheader_readf(psf, "4\321\374\331\204U", & name);
#line 351
    name[size] = (char)0;
    }
  } else {
#line 354
    return (133);
  }
  {
#line 356
  psf_log_printf(psf, "    Name : %s\n", name);
#line 360
  psf_binheader_readf(psf, "44\374\331\204U", & type, & size);
  }
#line 362
  if (! have_samplerate) {
#line 363
    goto skip_samplerate;
  }
#line 366
  if (type == 9) {
#line 366
    goto case_9;
  }
#line 377
  if (type == 131076) {
#line 377
    goto case_131076;
  }
#line 386
  if (type == 262150) {
#line 386
    goto case_262150;
  }
#line 391
  goto switch_default;
  case_9: 
  {
#line 369
  psf_binheader_readf(psf, "d", & samplerate);
#line 370
  snprintf(name, sizeof(name), "%f\n", samplerate);
#line 371
  psf_log_printf(psf, "    Val  : %s\n", name);
#line 373
  __cil_tmp20 = lrint(samplerate);
#line 373
  psf->sf.samplerate = (int )__cil_tmp20;
  }
#line 375
  goto switch_break;
  case_131076: 
  {
#line 380
  psf_binheader_readf(psf, "j2j\331\204U", -4, & samplerate___0, 2);
#line 381
  psf_log_printf(psf, "    Val  : %u\n", (int )samplerate___0);
#line 382
  psf->sf.samplerate = (int )samplerate___0;
  }
#line 384
  goto switch_break;
  case_262150: 
  {
#line 387
  psf_log_printf(psf, "    Val  : %u\n", size);
#line 388
  psf->sf.samplerate = (int )size;
  }
#line 389
  goto switch_break;
  switch_default: 
  {
#line 392
  psf_log_printf(psf, "    Type : %X    Size : %d  ***\n\230\001", type, size);
  }
#line 393
  return (134);
  switch_break: 
  {
#line 399
  psf_binheader_readf(psf, "44", & type, & size);
#line 400
  psf_log_printf(psf, " Type : %X    Size : %d\n\230\001", type, size);
  }
#line 402
  if (type != 14) {
#line 403
    return (133);
  }
  {
#line 405
  psf_binheader_readf(psf, "44\374\331\204U", & type, & size);
#line 406
  psf_log_printf(psf, "    Type : %X    Size : %d\n\331\204U", type, size);
  }
#line 408
  if (type != 6) {
#line 409
    return (133);
  }
  {
#line 411
  psf_binheader_readf(psf, "44\374\331\204U", & flags1, & flags2);
#line 412
  psf_log_printf(psf, "    Flg1 : %X    Flg2 : %d\n", flags1, flags2);
#line 414
  psf_binheader_readf(psf, "44", & type, & size);
#line 415
  psf_log_printf(psf, "    Type : %X    Size : %d\n\331\204U", type, size);
  }
#line 417
  if (type != 5) {
#line 418
    return (133);
  }
  {
#line 420
  psf_binheader_readf(psf, "44", & rows, & cols);
#line 421
  psf_log_printf(psf, "    Rows : %X    Cols : %d\n", rows, cols);
#line 423
  psf_binheader_readf(psf, "4", & type);
  }
#line 425
  if (type == 1) {
    {
#line 426
    psf_binheader_readf(psf, "4", & size);
#line 427
    psf_log_printf(psf, "    Type : %X    Size : %d\n\331\204U", type, size);
    }
#line 428
    if (size > (unsigned int )((int )sizeof(name) - 1)) {
      {
#line 429
      psf_log_printf(psf, "Error : Bad name length.\n");
      }
#line 430
      return (133);
    }
    {
#line 433
    psf_binheader_readf(psf, "bj\374\331\204U", name, size, (8U - size % 8U) % 8U);
#line 434
    name[size] = (char)0;
    }
  } else
#line 436
  if ((type & 65535) == 1) {
#line 437
    size = (unsigned int )(type >> 16);
#line 438
    if (size > 4U) {
      {
#line 439
      psf_log_printf(psf, "Error : Bad name length.\nG\375\331\204U");
      }
#line 440
      return (133);
    }
    {
#line 443
    psf_log_printf(psf, "    Type : %X\n", type);
#line 444
    psf_binheader_readf(psf, "4\247\374\331\204U", & name);
#line 445
    name[size] = (char)0;
    }
  } else {
#line 448
    return (133);
  }
  {
#line 450
  psf_log_printf(psf, "    Name : %s\n", name);
#line 452
  psf_binheader_readf(psf, "44\375\331\204U", & type, & size);
#line 453
  psf_log_printf(psf, "    Type : %X    Size : %d\n\331\204U", type, size);
  }
  skip_samplerate: 
#line 458
  if (rows == 0) {
#line 458
    if (cols == 0) {
      {
#line 459
      psf_log_printf(psf, "*** Error : zero channel count.\n\220");
      }
#line 460
      return (33);
    }
  }
#line 463
  psf->sf.channels = rows;
#line 464
  psf->sf.frames = (sf_count_t )cols;
#line 466
  psf->sf.format = psf->endian | 851968;
#line 469
  if (type == 9) {
#line 469
    goto case_9___0;
  }
#line 475
  if (type == 7) {
#line 475
    goto case_7;
  }
#line 481
  if (type == 5) {
#line 481
    goto case_5;
  }
#line 487
  if (type == 3) {
#line 487
    goto case_3;
  }
#line 493
  if (type == 2) {
#line 493
    goto case_2;
  }
#line 499
  goto switch_default___0;
  case_9___0: 
  {
#line 470
  psf_log_printf(psf, "Data type : double\n\331\204U");
#line 471
  psf->sf.format |= 7;
#line 472
  psf->bytewidth = 8;
  }
#line 473
  goto switch_break___0;
  case_7: 
  {
#line 476
  psf_log_printf(psf, "Data type : float\n");
#line 477
  psf->sf.format |= 6;
#line 478
  psf->bytewidth = 4;
  }
#line 479
  goto switch_break___0;
  case_5: 
  {
#line 482
  psf_log_printf(psf, "Data type : 32 bit PCM\n");
#line 483
  psf->sf.format |= 4;
#line 484
  psf->bytewidth = 4;
  }
#line 485
  goto switch_break___0;
  case_3: 
  {
#line 488
  psf_log_printf(psf, "Data type : 16 bit PCM\n");
#line 489
  psf->sf.format |= 2;
#line 490
  psf->bytewidth = 2;
  }
#line 491
  goto switch_break___0;
  case_2: 
  {
#line 494
  psf_log_printf(psf, "Data type : unsigned 8 bit PCM\n");
#line 495
  psf->sf.format |= 5;
#line 496
  psf->bytewidth = 1;
  }
#line 497
  goto switch_break___0;
  switch_default___0: 
  {
#line 500
  psf_log_printf(psf, "*** Error : Bad marker %08X\n", type);
  }
#line 501
  return (18);
  switch_break___0: 
  {
#line 504
  psf->dataoffset = psf_ftell(psf);
#line 505
  psf->datalength = psf->filelength - psf->dataoffset;
  }
#line 507
  return (0);
}
}
#line 62 "/root/patchweave_donee/23/src/mat4.c"
static int mat4_close(SF_PRIVATE *psf ) ;
#line 64
static int mat4_format_to_encoding(int format , int endian ) ;
#line 66
static int mat4_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 67
static int mat4_read_header(SF_PRIVATE *psf ) ;
#line 69
static char const   *mat4_marker_to_str(int marker ) ;
#line 76 "/root/patchweave_donee/23/src/mat4.c"
int mat4_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;

  {
#line 77
  error = 0;
#line 79
  if (psf->file.mode == 16) {
    _L: 
    {
#line 80
    error = mat4_read_header(psf);
    }
#line 80
    if (error) {
#line 81
      return (error);
    }
  } else
#line 79
  if (psf->file.mode == 48) {
#line 79
    if (psf->filelength > 0L) {
#line 79
      goto _L;
    }
  }
#line 84
  if ((psf->sf.format & 268369920) != 786432) {
#line 85
    return (1);
  }
#line 87
  subformat = psf->sf.format & 65535;
#line 89
  if (psf->file.mode == 32) {
    _L___35: 
#line 90
    if (psf->is_pipe) {
#line 91
      return (29);
    }
#line 93
    psf->endian = psf->sf.format & 805306368;
#line 94
    if (psf->endian == 805306368) {
#line 95
      psf->endian = 268435456;
    } else
#line 94
    if (psf->endian == 0) {
#line 95
      psf->endian = 268435456;
    }
    {
#line 99
    error = mat4_write_header(psf, 0);
    }
#line 99
    if (error) {
#line 100
      return (error);
    }
#line 102
    psf->write_header = & mat4_write_header;
  } else
#line 89
  if (psf->file.mode == 48) {
#line 89
    goto _L___35;
  }
#line 105
  psf->container_close = & mat4_close;
#line 107
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 111
  if (subformat == 4) {
#line 111
    goto case_4;
  }
#line 111
  if (subformat == 2) {
#line 111
    goto case_4;
  }
#line 115
  if (subformat == 6) {
#line 115
    goto case_6;
  }
#line 119
  if (subformat == 7) {
#line 119
    goto case_7;
  }
#line 123
  goto switch_default;
  case_4: 
  {
#line 112
  error = pcm_init(psf);
  }
#line 113
  goto switch_break;
  case_6: 
  {
#line 116
  error = float32_init(psf);
  }
#line 117
  goto switch_break;
  case_7: 
  {
#line 120
  error = double64_init(psf);
  }
#line 121
  goto switch_break;
  switch_default: 
#line 123
  goto switch_break;
  switch_break: ;
#line 126
  return (error);
}
}
#line 133 "/root/patchweave_donee/23/src/mat4.c"
static int mat4_close(SF_PRIVATE *psf ) 
{ 


  {
#line 135
  if (psf->file.mode == 32) {
    {
#line 136
    mat4_write_header(psf, 1);
    }
  } else
#line 135
  if (psf->file.mode == 48) {
    {
#line 136
    mat4_write_header(psf, 1);
    }
  }
#line 138
  return (0);
}
}
#line 145 "/root/patchweave_donee/23/src/mat4.c"
static int mat4_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int encoding ;
  double samplerate ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;

  {
  {
#line 150
  current = psf_ftell(psf);
  }
#line 152
  if (calc_length) {
    {
#line 153
    psf->filelength = psf_get_filelen(psf);
#line 155
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 156
    if (psf->dataend) {
#line 157
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 159
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 162
  encoding = mat4_format_to_encoding(psf->sf.format & 65535, psf->endian);
  }
#line 164
  if (encoding == -1) {
#line 165
    return (1);
  }
  {
#line 168
  psf->header[0] = (unsigned char)0;
#line 169
  psf->headindex = 0;
#line 170
  psf_fseek(psf, (sf_count_t )0, 0);
#line 173
  samplerate = (double )psf->sf.samplerate;
  }
#line 175
  if (psf->endian == 536870912) {
    {
#line 176
    psf_binheader_writef(psf, "Em444U", (unsigned int )(3 << 16) | (232U << 24), 1,
                         1, 0);
#line 177
    __cil_tmp9 = make_size_t(11);
#line 177
    psf_binheader_writef(psf, "E4bd\204U", 11, "samplerate*\332\204U", __cil_tmp9,
                         samplerate);
#line 178
    psf_binheader_writef(psf, "tEm484", encoding, psf->sf.channels, psf->sf.frames,
                         0);
#line 179
    __cil_tmp10 = make_size_t(9);
#line 179
    psf_binheader_writef(psf, "E4b\332\204U", 9, "wavedata\230", __cil_tmp10);
    }
  } else
#line 181
  if (psf->endian == 268435456) {
    {
#line 182
    psf_binheader_writef(psf, "em444U", 0U, 1, 1, 0);
#line 183
    __cil_tmp11 = make_size_t(11);
#line 183
    psf_binheader_writef(psf, "e4bd", 11, "samplerate*\332\204U", __cil_tmp11, samplerate);
#line 184
    psf_binheader_writef(psf, "tem484", encoding, psf->sf.channels, psf->sf.frames,
                         0);
#line 185
    __cil_tmp12 = make_size_t(9);
#line 185
    psf_binheader_writef(psf, "e4b\332\204U", 9, "wavedata\230", __cil_tmp12);
    }
  } else {
#line 188
    return (1);
  }
  {
#line 191
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 193
  if (psf->error) {
#line 194
    return (psf->error);
  }
#line 196
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 198
  if (current > 0L) {
    {
#line 199
    psf_fseek(psf, current, 0);
    }
  }
#line 201
  return (psf->error);
}
}
#line 205 "/root/patchweave_donee/23/src/mat4.c"
static int mat4_read_header(SF_PRIVATE *psf ) 
{ 
  char buffer[256] ;
  uint32_t marker ;
  uint32_t namesize ;
  int rows ;
  int cols ;
  int imag ;
  double value___0 ;
  char const   *marker_str ;
  char name[64] ;
  char const   *tmp ;
  long __cil_tmp12 ;
  char const   *__cil_tmp13 ;
  char const   *tmp___0 ;

  {
  {
#line 213
  psf_binheader_readf(psf, "pm", 0, & marker);
  }
#line 216
  if (marker == ((unsigned int )(3 << 16) | (232U << 24))) {
#line 217
    psf->rwf_endian = 536870912;
#line 217
    psf->endian = psf->rwf_endian;
#line 218
    marker_str = "big endian double";
  } else
#line 220
  if (marker == 0U) {
#line 221
    psf->rwf_endian = 268435456;
#line 221
    psf->endian = psf->rwf_endian;
#line 222
    marker_str = "little endian double";
  } else {
#line 225
    return (18);
  }
  {
#line 227
  psf_log_printf(psf, "GNU Octave 2.0 / MATLAB v4.2 format\nMarker : %s\n\230\001",
                 marker_str);
#line 229
  psf_binheader_readf(psf, "444\332\204U", & rows, & cols, & imag);
  }
#line 231
  if (imag) {
#line 231
    tmp = "True";
  } else {
#line 231
    tmp = "False";
  }
  {
#line 231
  psf_log_printf(psf, " Rows  : %d\n Cols  : %d\n Imag  : %s\n", rows, cols, tmp);
#line 233
  psf_binheader_readf(psf, "4\324*\332\204U", & namesize);
  }
#line 235
  if (namesize >= (unsigned int )((int )sizeof(name))) {
#line 236
    return (130);
  }
  {
#line 238
  psf_binheader_readf(psf, "b\323*\332\204U", name, namesize);
#line 239
  name[namesize] = (char)0;
#line 241
  psf_log_printf(psf, " Name  : %s\n\204U", name);
#line 243
  psf_binheader_readf(psf, "d", & value___0);
#line 245
  snprintf(buffer, sizeof(buffer), " Value : %f\n", value___0);
#line 246
  psf_log_printf(psf, (char const   *)(buffer));
  }
#line 248
  if (rows != 1) {
#line 249
    return (131);
  } else
#line 248
  if (cols != 1) {
#line 249
    return (131);
  }
  {
#line 251
  __cil_tmp12 = lrint(value___0);
#line 251
  psf->sf.samplerate = (int )__cil_tmp12;
#line 255
  psf_binheader_readf(psf, "m\311*\332\204U", & marker);
#line 257
  __cil_tmp13 = mat4_marker_to_str((int )marker);
#line 257
  psf_log_printf(psf, "Marker : %s\n\204U", __cil_tmp13);
#line 259
  psf_binheader_readf(psf, "444", & rows, & cols, & imag);
  }
#line 261
  if (imag) {
#line 261
    tmp___0 = "True";
  } else {
#line 261
    tmp___0 = "False";
  }
  {
#line 261
  psf_log_printf(psf, " Rows  : %d\n Cols  : %d\n Imag  : %s\n", rows, cols, tmp___0);
#line 263
  psf_binheader_readf(psf, "4", & namesize);
  }
#line 265
  if (namesize >= (unsigned int )((int )sizeof(name))) {
#line 266
    return (130);
  }
  {
#line 268
  psf_binheader_readf(psf, "b", name, namesize);
#line 269
  name[namesize] = (char)0;
#line 271
  psf_log_printf(psf, " Name  : %s\n\204U", name);
#line 273
  psf->dataoffset = psf_ftell(psf);
  }
#line 275
  if (rows == 0) {
    {
#line 276
    psf_log_printf(psf, "*** Error : zero channel count.\n\220");
    }
#line 277
    return (33);
  } else
#line 279
  if (rows > 1024) {
    {
#line 280
    psf_log_printf(psf, "*** Error : channel count %d > SF_MAX_CHANNELS.\n\230\001",
                   rows);
    }
#line 281
    return (34);
  }
#line 284
  psf->sf.channels = rows;
#line 285
  psf->sf.frames = (sf_count_t )cols;
#line 287
  psf->sf.format = psf->endian | 786432;
#line 290
  if (marker == 0U) {
#line 290
    goto case_0;
  }
#line 290
  if (marker == ((unsigned int )(3 << 16) | (232U << 24))) {
#line 290
    goto case_0;
  }
#line 296
  if (marker == 10U) {
#line 296
    goto case_10;
  }
#line 296
  if (marker == ((unsigned int )(3 << 16) | (242U << 24))) {
#line 296
    goto case_10;
  }
#line 302
  if (marker == 20U) {
#line 302
    goto case_20;
  }
#line 302
  if (marker == ((unsigned int )(3 << 16) | (252U << 24))) {
#line 302
    goto case_20;
  }
#line 308
  if (marker == 30U) {
#line 308
    goto case_30;
  }
#line 308
  if (marker == ((unsigned int )(4 << 16) | (6U << 24))) {
#line 308
    goto case_30;
  }
#line 313
  goto switch_default;
  case_0: 
#line 291
  psf->sf.format |= 7;
#line 292
  psf->bytewidth = 8;
#line 293
  goto switch_break;
  case_10: 
#line 297
  psf->sf.format |= 6;
#line 298
  psf->bytewidth = 4;
#line 299
  goto switch_break;
  case_20: 
#line 303
  psf->sf.format |= 4;
#line 304
  psf->bytewidth = 4;
#line 305
  goto switch_break;
  case_30: 
#line 309
  psf->sf.format |= 2;
#line 310
  psf->bytewidth = 2;
#line 311
  goto switch_break;
  switch_default: 
  {
#line 314
  psf_log_printf(psf, "*** Error : Bad marker %08X\n", marker);
  }
#line 315
  return (18);
  switch_break: ;
#line 318
  if (psf->filelength - psf->dataoffset < ((long )psf->sf.channels * psf->sf.frames) * (long )psf->bytewidth) {
    {
#line 319
    psf_log_printf(psf, "*** File seems to be truncated. %D <--> %D\n", psf->filelength - psf->dataoffset,
                   ((long )psf->sf.channels * psf->sf.frames) * (long )psf->bytewidth);
    }
  } else
#line 322
  if (psf->filelength - psf->dataoffset > ((long )psf->sf.channels * psf->sf.frames) * (long )psf->bytewidth) {
#line 323
    psf->dataend = psf->dataoffset + (long )((rows * cols) * psf->bytewidth);
  }
#line 325
  psf->datalength = (psf->filelength - psf->dataoffset) - psf->dataend;
#line 327
  psf->sf.sections = 1;
#line 329
  return (0);
}
}
#line 333 "/root/patchweave_donee/23/src/mat4.c"
static int mat4_format_to_encoding(int format , int endian ) 
{ 


  {
#line 336
  if ((format | endian) == 536870914) {
#line 336
    goto case_536870914;
  }
#line 339
  if ((format | endian) == 268435458) {
#line 339
    goto case_268435458;
  }
#line 342
  if ((format | endian) == 536870916) {
#line 342
    goto case_536870916;
  }
#line 345
  if ((format | endian) == 268435460) {
#line 345
    goto case_268435460;
  }
#line 348
  if ((format | endian) == 536870918) {
#line 348
    goto case_536870918;
  }
#line 351
  if ((format | endian) == 268435462) {
#line 351
    goto case_268435462;
  }
#line 354
  if ((format | endian) == 536870919) {
#line 354
    goto case_536870919;
  }
#line 357
  if ((format | endian) == 268435463) {
#line 357
    goto case_268435463;
  }
#line 360
  goto switch_default;
  case_536870914: 
#line 337
  return ((int )((unsigned int )(4 << 16) | (6U << 24)));
  case_268435458: 
#line 340
  return (30);
  case_536870916: 
#line 343
  return ((int )((unsigned int )(3 << 16) | (252U << 24)));
  case_268435460: 
#line 346
  return (20);
  case_536870918: 
#line 349
  return ((int )((unsigned int )(3 << 16) | (242U << 24)));
  case_268435462: 
#line 352
  return (10);
  case_536870919: 
#line 355
  return ((int )((unsigned int )(3 << 16) | (232U << 24)));
  case_268435463: 
#line 358
  return (0);
  switch_default: 
#line 360
  goto switch_break;
  switch_break: ;
#line 363
  return (-1);
}
}
#line 369 "/root/patchweave_donee/23/src/mat4.c"
static char str[32]  ;
#line 367 "/root/patchweave_donee/23/src/mat4.c"
static char const   *mat4_marker_to_str(int marker ) 
{ 


  {
#line 372
  if (marker == (int )((unsigned int )(4 << 16) | (6U << 24))) {
#line 372
    goto case_exp;
  }
#line 373
  if (marker == 30) {
#line 373
    goto case_30;
  }
#line 375
  if (marker == (int )((unsigned int )(3 << 16) | (252U << 24))) {
#line 375
    goto case_exp___0;
  }
#line 376
  if (marker == 20) {
#line 376
    goto case_20;
  }
#line 379
  if (marker == (int )((unsigned int )(3 << 16) | (242U << 24))) {
#line 379
    goto case_exp___1;
  }
#line 380
  if (marker == 10) {
#line 380
    goto case_10;
  }
#line 382
  if (marker == (int )((unsigned int )(3 << 16) | (232U << 24))) {
#line 382
    goto case_exp___2;
  }
#line 383
  if (marker == 0) {
#line 383
    goto case_0;
  }
#line 370
  goto switch_break;
  case_exp: 
#line 372
  return ("big endian 16 bit PCM");
  case_30: 
#line 373
  return ("little endian 16 bit PCM\220");
  case_exp___0: 
#line 375
  return ("big endian 32 bit PCM");
  case_20: 
#line 376
  return ("little endian 32 bit PCM\220");
  case_exp___1: 
#line 379
  return ("big endian float\220");
  case_10: 
#line 380
  return ("big endian float\220");
  case_exp___2: 
#line 382
  return ("big endian double");
  case_0: 
#line 383
  return ("little endian double");
  switch_break: 
  {
#line 387
  str[sizeof(str) - 1UL] = (char)0;
#line 388
  snprintf(str, sizeof(str) - 1UL, "%08X\204U", marker);
  }
#line 389
  return ((char const   *)(str));
}
}
#line 34 "/root/patchweave_donee/23/src/macos.c"
static char rsrc_name[1024]  ;
#line 32 "/root/patchweave_donee/23/src/macos.c"
int macos_guess_file_type(SF_PRIVATE *psf , char const   *filename___0 ) 
{ 
  struct stat statbuf ;
  int __cil_tmp5 ;

  {
  {
#line 36
  snprintf(rsrc_name, sizeof(rsrc_name), "%s/rsrc", filename___0);
#line 39
  __cil_tmp5 = stat((char const   *)(rsrc_name), & statbuf);
  }
#line 39
  if (__cil_tmp5 != 0) {
    {
#line 40
    psf_log_printf(psf, "No resource fork.\n");
    }
#line 41
    return (0);
  }
#line 44
  if (statbuf.st_size == 0L) {
    {
#line 45
    psf_log_printf(psf, "Have zero size resource fork.\n");
    }
#line 46
    return (0);
  }
#line 49
  return (0);
}
}
#line 39 "/root/patchweave_donee/23/src/macbinary3.c"
int macbinary3_open(SF_PRIVATE *UNUSED_psf ) 
{ 


  {
#line 41
  return (0);
}
}
#line 66 "/root/patchweave_donee/23/src/ircam.c"
static int ircam_close(SF_PRIVATE *psf ) ;
#line 67
static int ircam_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 68
static int ircam_read_header(SF_PRIVATE *psf ) ;
#line 70
static int get_encoding(int subformat ) ;
#line 72
static char const   *get_encoding_str(int encoding ) ;
#line 79 "/root/patchweave_donee/23/src/ircam.c"
int ircam_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int tmp ;

  {
#line 81
  error = 0;
#line 83
  if (psf->file.mode == 16) {
    _L: 
    {
#line 84
    error = ircam_read_header(psf);
    }
#line 84
    if (error) {
#line 85
      return (error);
    }
  } else
#line 83
  if (psf->file.mode == 48) {
#line 83
    if (psf->filelength > 0L) {
#line 83
      goto _L;
    }
  }
#line 88
  subformat = psf->sf.format & 65535;
#line 90
  if (psf->file.mode == 32) {
    _L___36: 
#line 91
    if ((psf->sf.format & 268369920) != 655360) {
#line 92
      return (1);
    }
#line 94
    psf->endian = psf->sf.format & 805306368;
#line 95
    if (psf->endian == 0) {
#line 96
      tmp = 268435456;
#line 96
      psf->endian = tmp;
    } else
#line 95
    if (psf->endian == 805306368) {
#line 96
      tmp = 268435456;
#line 96
      psf->endian = tmp;
    }
    {
#line 98
    psf->dataoffset = (sf_count_t )1024;
#line 100
    error = ircam_write_header(psf, 0);
    }
#line 100
    if (error) {
#line 101
      return (error);
    }
#line 103
    psf->write_header = & ircam_write_header;
  } else
#line 90
  if (psf->file.mode == 48) {
#line 90
    goto _L___36;
  }
#line 106
  psf->container_close = & ircam_close;
#line 109
  if (subformat == 16) {
#line 109
    goto case_16;
  }
#line 113
  if (subformat == 17) {
#line 113
    goto case_17;
  }
#line 118
  if (subformat == 4) {
#line 118
    goto case_4;
  }
#line 118
  if (subformat == 2) {
#line 118
    goto case_4;
  }
#line 122
  if (subformat == 6) {
#line 122
    goto case_6;
  }
#line 126
  goto switch_default;
  case_16: 
  {
#line 110
  error = ulaw_init(psf);
  }
#line 111
  goto switch_break;
  case_17: 
  {
#line 114
  error = alaw_init(psf);
  }
#line 115
  goto switch_break;
  case_4: 
  {
#line 119
  error = pcm_init(psf);
  }
#line 120
  goto switch_break;
  case_6: 
  {
#line 123
  error = float32_init(psf);
  }
#line 124
  goto switch_break;
  switch_default: 
#line 126
  goto switch_break;
  switch_break: ;
#line 129
  return (error);
}
}
#line 136 "/root/patchweave_donee/23/src/ircam.c"
static int ircam_read_header(SF_PRIVATE *psf ) 
{ 
  unsigned int marker ;
  unsigned int encoding ;
  float samplerate ;
  int error ;
  char const   *__cil_tmp6 ;

  {
  {
#line 139
  error = 0;
#line 141
  psf_binheader_readf(psf, "epmf44", 0, & marker, & samplerate, & psf->sf.channels,
                      & encoding);
  }
#line 143
  if ((marker & ((unsigned int )(255 | (255 << 8)) | (255U << 24))) != (unsigned int )(100 | (163 << 8))) {
#line 143
    if ((marker & ((unsigned int )(255 | (255 << 16)) | (255U << 24))) != ((unsigned int )(163 << 16) | (100U << 24))) {
      {
#line 144
      psf_log_printf(psf, "marker: 0x%X\n", marker);
      }
#line 145
      return (120);
    }
  }
#line 148
  psf->endian = 268435456;
#line 150
  if (psf->sf.channels > 1024) {
    {
#line 151
    psf_binheader_readf(psf, "Epmf44", 0, & marker, & samplerate, & psf->sf.channels,
                        & encoding);
    }
#line 154
    if (psf->sf.channels > 1024) {
      {
#line 155
      psf_log_printf(psf, "marker: 0x%X\n", marker);
      }
#line 156
      return (121);
    }
#line 159
    psf->endian = 536870912;
  }
  {
#line 162
  psf_log_printf(psf, "marker: 0x%X\nU", marker);
#line 164
  psf->sf.samplerate = (int )samplerate;
#line 166
  __cil_tmp6 = get_encoding_str((int )encoding);
#line 166
  psf_log_printf(psf, "  Sample Rate : %d\n  Channels    : %d\n  Encoding    : %X => %s\n",
                 psf->sf.samplerate, psf->sf.channels, encoding, __cil_tmp6);
  }
#line 172
  if (encoding == 2U) {
#line 172
    goto case_2;
  }
#line 179
  if (encoding == 262148U) {
#line 179
    goto case_262148;
  }
#line 186
  if (encoding == 4U) {
#line 186
    goto case_4;
  }
#line 193
  if (encoding == 65537U) {
#line 193
    goto case_65537;
  }
#line 200
  if (encoding == 131073U) {
#line 200
    goto case_131073;
  }
#line 207
  goto switch_default;
  case_2: 
#line 173
  psf->bytewidth = 2;
#line 174
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 176
  psf->sf.format = 655362;
#line 177
  goto switch_break;
  case_262148: 
#line 180
  psf->bytewidth = 4;
#line 181
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 183
  psf->sf.format = 655364;
#line 184
  goto switch_break;
  case_4: 
#line 187
  psf->bytewidth = 4;
#line 188
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 190
  psf->sf.format = 655366;
#line 191
  goto switch_break;
  case_65537: 
#line 194
  psf->bytewidth = 1;
#line 195
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 197
  psf->sf.format = 655377;
#line 198
  goto switch_break;
  case_131073: 
#line 201
  psf->bytewidth = 1;
#line 202
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 204
  psf->sf.format = 655376;
#line 205
  goto switch_break;
  switch_default: 
#line 208
  error = 122;
#line 209
  goto switch_break;
  switch_break: ;
#line 212
  if (psf->endian == 536870912) {
#line 213
    psf->sf.format |= 536870912;
  } else {
#line 215
    psf->sf.format |= 268435456;
  }
#line 217
  if (error) {
#line 218
    return (error);
  }
#line 220
  psf->dataoffset = (sf_count_t )1024;
#line 221
  psf->datalength = psf->filelength - psf->dataoffset;
#line 223
  if (psf->sf.frames == 0L) {
#line 223
    if (psf->blockwidth) {
#line 224
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
  }
  {
#line 226
  psf_log_printf(psf, "  Samples     : %d\n", psf->sf.frames);
#line 228
  psf_binheader_readf(psf, "p", 1024);
  }
#line 230
  return (0);
}
}
#line 234 "/root/patchweave_donee/23/src/ircam.c"
static int ircam_close(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 236
  psf_log_printf(psf, "close\n");
  }
#line 238
  return (0);
}
}
#line 242 "/root/patchweave_donee/23/src/ircam.c"
static int ircam_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  int encoding ;
  float samplerate ;
  sf_count_t current ;

  {
#line 247
  if (psf->pipeoffset > 0L) {
#line 248
    return (0);
  }
  {
#line 250
  current = psf_ftell(psf);
#line 253
  encoding = get_encoding(psf->sf.format & 65535);
  }
#line 255
  if (encoding == 0) {
#line 256
    return (1);
  }
#line 259
  psf->header[0] = (unsigned char)0;
#line 260
  psf->headindex = 0;
#line 262
  if (psf->is_pipe == 0) {
    {
#line 263
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
#line 265
  samplerate = (float )psf->sf.samplerate;
#line 268
  if (psf->endian == 536870912) {
#line 268
    goto case_536870912;
  }
#line 273
  if (psf->endian == 268435456) {
#line 273
    goto case_268435456;
  }
#line 278
  goto switch_default;
  case_536870912: 
  {
#line 269
  psf_binheader_writef(psf, "Emf", (unsigned int )((100 | (163 << 8)) | (2 << 16)),
                       (double )samplerate);
#line 270
  psf_binheader_writef(psf, "E44\332\204U", psf->sf.channels, encoding);
  }
#line 271
  goto switch_break;
  case_268435456: 
  {
#line 274
  psf_binheader_writef(psf, "emf\332\204U", (unsigned int )((100 | (163 << 8)) | (3 << 16)),
                       (double )samplerate);
#line 275
  psf_binheader_writef(psf, "e44\332\204U", psf->sf.channels, encoding);
  }
#line 276
  goto switch_break;
  switch_default: 
#line 278
  return (1);
  switch_break: 
  {
#line 281
  psf_binheader_writef(psf, "z", (size_t )(1024 - psf->headindex));
#line 284
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 286
  if (psf->error) {
#line 287
    return (psf->error);
  }
#line 289
  if (current > 0L) {
    {
#line 290
    psf_fseek(psf, current, 0);
    }
  }
#line 292
  return (psf->error);
}
}
#line 296 "/root/patchweave_donee/23/src/ircam.c"
static int get_encoding(int subformat ) 
{ 


  {
#line 298
  if (subformat == 2) {
#line 298
    goto case_2;
  }
#line 299
  if (subformat == 4) {
#line 299
    goto case_4;
  }
#line 301
  if (subformat == 6) {
#line 301
    goto case_6;
  }
#line 303
  if (subformat == 16) {
#line 303
    goto case_16;
  }
#line 304
  if (subformat == 17) {
#line 304
    goto case_17;
  }
#line 306
  goto switch_default;
  case_2: 
#line 298
  return (2);
  case_4: 
#line 299
  return (262148);
  case_6: 
#line 301
  return (4);
  case_16: 
#line 303
  return (131073);
  case_17: 
#line 304
  return (65537);
  switch_default: 
#line 306
  goto switch_break;
  switch_break: ;
#line 309
  return (0);
}
}
#line 313 "/root/patchweave_donee/23/src/ircam.c"
static char const   *get_encoding_str(int encoding ) 
{ 


  {
#line 315
  if (encoding == 2) {
#line 315
    goto case_2;
  }
#line 316
  if (encoding == 4) {
#line 316
    goto case_4;
  }
#line 317
  if (encoding == 65537) {
#line 317
    goto case_65537;
  }
#line 318
  if (encoding == 131073) {
#line 318
    goto case_131073;
  }
#line 319
  if (encoding == 262148) {
#line 319
    goto case_262148;
  }
#line 314
  goto switch_break;
  case_2: 
#line 315
  return ("16 bit PCM");
  case_4: 
#line 316
  return ("32 bit float");
  case_65537: 
#line 317
  return ("A lawU");
  case_131073: 
#line 318
  return ("u law");
  case_262148: 
#line 319
  return ("32 bit PCM\200\332\204U");
  switch_break: ;
#line 321
  return ("Unknown encoding\220");
}
}
#line 41 "/root/patchweave_donee/23/src/htk.c"
static int htk_close(SF_PRIVATE *psf ) ;
#line 43
static int htk_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 44
static int htk_read_header(SF_PRIVATE *psf ) ;
#line 51 "/root/patchweave_donee/23/src/htk.c"
int htk_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp5 ;

  {
#line 53
  error = 0;
#line 55
  if (psf->is_pipe) {
#line 56
    return (143);
  }
#line 58
  if (psf->file.mode == 16) {
    _L: 
    {
#line 59
    error = htk_read_header(psf);
    }
#line 59
    if (error) {
#line 60
      return (error);
    }
  } else
#line 58
  if (psf->file.mode == 48) {
#line 58
    if (psf->filelength > 0L) {
#line 58
      goto _L;
    }
  }
#line 63
  subformat = psf->sf.format & 65535;
#line 65
  if (psf->file.mode == 32) {
    _L___37: 
#line 66
    if ((psf->sf.format & 268369920) != 1048576) {
#line 67
      return (1);
    }
    {
#line 69
    psf->endian = 536870912;
#line 71
    __cil_tmp5 = htk_write_header(psf, 0);
    }
#line 71
    if (__cil_tmp5) {
#line 72
      return (psf->error);
    }
#line 74
    psf->write_header = & htk_write_header;
  } else
#line 65
  if (psf->file.mode == 48) {
#line 65
    goto _L___37;
  }
#line 77
  psf->container_close = & htk_close;
#line 79
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 82
  if (subformat == 2) {
#line 82
    goto case_2;
  }
#line 86
  goto switch_default;
  case_2: 
  {
#line 83
  error = pcm_init(psf);
  }
#line 84
  goto switch_break;
  switch_default: 
#line 86
  goto switch_break;
  switch_break: ;
#line 89
  return (error);
}
}
#line 96 "/root/patchweave_donee/23/src/htk.c"
static int htk_close(SF_PRIVATE *psf ) 
{ 


  {
#line 98
  if (psf->file.mode == 32) {
    {
#line 99
    htk_write_header(psf, 1);
    }
  } else
#line 98
  if (psf->file.mode == 48) {
    {
#line 99
    htk_write_header(psf, 1);
    }
  }
#line 101
  return (0);
}
}
#line 105 "/root/patchweave_donee/23/src/htk.c"
static int htk_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int sample_count ;
  int sample_period ;

  {
  {
#line 109
  current = psf_ftell(psf);
  }
#line 111
  if (calc_length) {
    {
#line 112
    psf->filelength = psf_get_filelen(psf);
    }
  }
  {
#line 115
  psf->header[0] = (unsigned char)0;
#line 116
  psf->headindex = 0;
#line 117
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 119
  if (psf->filelength > 12L) {
#line 120
    sample_count = (int )((psf->filelength - 12L) / 2L);
  } else {
#line 122
    sample_count = 0;
  }
  {
#line 124
  sample_period = 10000000 / psf->sf.samplerate;
#line 126
  psf_binheader_writef(psf, "E444\204U", sample_count, sample_period, 131072);
#line 129
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 131
  if (psf->error) {
#line 132
    return (psf->error);
  }
#line 134
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 136
  if (current > 0L) {
    {
#line 137
    psf_fseek(psf, current, 0);
    }
  }
#line 139
  return (psf->error);
}
}
#line 186 "/root/patchweave_donee/23/src/htk.c"
static int htk_read_header(SF_PRIVATE *psf ) 
{ 
  int sample_count ;
  int sample_period ;
  int marker ;

  {
  {
#line 189
  psf_binheader_readf(psf, "pE444", 0, & sample_count, & sample_period, & marker);
  }
#line 191
  if ((long )(2 * sample_count + 12) != psf->filelength) {
#line 192
    return (1666);
  }
#line 194
  if (marker != 131072) {
#line 195
    return (1667);
  }
#line 197
  psf->sf.channels = 1;
#line 199
  if (sample_period > 0) {
    {
#line 200
    psf->sf.samplerate = 10000000 / sample_period;
#line 201
    psf_log_printf(psf, "HTK Waveform file\n  Sample Count  : %d\n  Sample Period : %d => %d Hz\nU",
                   sample_count, sample_period, psf->sf.samplerate);
    }
  } else {
    {
#line 205
    psf->sf.samplerate = 16000;
#line 206
    psf_log_printf(psf, "HTK Waveform file\n  Sample Count  : %d\n  Sample Period : %d (should be > 0) => Guessed sample rate %d Hz\n",
                   sample_count, sample_period, psf->sf.samplerate);
    }
  }
#line 210
  psf->sf.format = 1048578;
#line 211
  psf->bytewidth = 2;
#line 214
  psf->dataoffset = (sf_count_t )12;
#line 215
  psf->endian = 536870912;
#line 217
  psf->datalength = psf->filelength - psf->dataoffset;
#line 219
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 221
  if (! psf->sf.frames) {
#line 221
    if (psf->blockwidth) {
#line 222
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 224
  return (0);
}
}
#line 48 "/root/patchweave_donee/23/src/g72x.c"
static int psf_g72x_decode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) ;
#line 49
static int psf_g72x_encode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) ;
#line 51
static sf_count_t g72x_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 52
static sf_count_t g72x_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 53
static sf_count_t g72x_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 54
static sf_count_t g72x_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 56
static sf_count_t g72x_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 57
static sf_count_t g72x_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 58
static sf_count_t g72x_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 59
static sf_count_t g72x_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 61
static sf_count_t g72x_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t UNUSED_offset ) ;
#line 63
static int g72x_close(SF_PRIVATE *psf ) ;
#line 71 "/root/patchweave_donee/23/src/g72x.c"
int g72x_init(SF_PRIVATE *psf ) 
{ 
  G72x_PRIVATE *pg72x ;
  int bitspersample ;
  int bytesperblock ;
  int codec ;
  void *tmp ;

  {
#line 75
  if ((unsigned long )psf->codec_data != (unsigned long )((void *)0)) {
    {
#line 76
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n");
    }
#line 77
    return (30);
  }
#line 80
  psf->sf.seekable = 0;
#line 82
  if (psf->sf.channels != 1) {
#line 83
    return (139);
  }
  {
#line 85
  tmp = calloc(1UL, sizeof(G72x_PRIVATE ));
#line 85
  pg72x = (G72x_PRIVATE *)tmp;
  }
#line 85
  if ((unsigned long )pg72x == (unsigned long )((void *)0)) {
#line 86
    return (17);
  }
#line 88
  psf->codec_data = (void *)pg72x;
#line 90
  pg72x->block_curr = 0;
#line 91
  pg72x->sample_curr = 0;
#line 94
  if ((psf->sf.format & 65535) == 48) {
#line 94
    goto case_48;
  }
#line 100
  if ((psf->sf.format & 65535) == 49) {
#line 100
    goto case_49;
  }
#line 106
  if ((psf->sf.format & 65535) == 50) {
#line 106
    goto case_50;
  }
#line 112
  goto switch_default;
  case_48: 
#line 95
  codec = 4;
#line 96
  bytesperblock = 60;
#line 97
  bitspersample = 4;
#line 98
  goto switch_break;
  case_49: 
#line 101
  codec = 3;
#line 102
  bytesperblock = 45;
#line 103
  bitspersample = 3;
#line 104
  goto switch_break;
  case_50: 
#line 107
  codec = 5;
#line 108
  bytesperblock = 75;
#line 109
  bitspersample = 5;
#line 110
  goto switch_break;
  switch_default: 
#line 112
  return (18);
  switch_break: 
  {
#line 115
  psf->filelength = psf_get_filelen(psf);
  }
#line 116
  if (psf->filelength < psf->dataoffset) {
#line 117
    psf->filelength = psf->dataoffset;
  }
#line 119
  psf->datalength = psf->filelength - psf->dataoffset;
#line 120
  if (psf->dataend > 0L) {
#line 121
    psf->datalength -= psf->filelength - psf->dataend;
  }
#line 123
  if (psf->file.mode == 16) {
    {
#line 124
    pg72x->private = g72x_reader_init(codec, & pg72x->blocksize, & pg72x->samplesperblock);
    }
#line 125
    if ((unsigned long )pg72x->private == (unsigned long )((void *)0)) {
#line 126
      return (17);
    }
#line 128
    pg72x->bytesperblock = bytesperblock;
#line 130
    psf->read_short = & g72x_read_s;
#line 131
    psf->read_int = & g72x_read_i;
#line 132
    psf->read_float = & g72x_read_f;
#line 133
    psf->read_double = & g72x_read_d;
#line 135
    psf->seek = & g72x_seek;
#line 137
    if (psf->datalength % (long )pg72x->blocksize) {
      {
#line 138
      psf_log_printf(psf, "*** Odd psf->datalength (%D) should be a multiple of %d\n\230\001",
                     psf->datalength, pg72x->blocksize);
#line 139
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize + 1L);
      }
    } else {
#line 142
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize);
    }
    {
#line 144
    psf->sf.frames = (sf_count_t )(pg72x->blocks_total * pg72x->samplesperblock);
#line 146
    psf_g72x_decode_block(psf, pg72x);
    }
  } else
#line 148
  if (psf->file.mode == 32) {
    {
#line 149
    pg72x->private = g72x_writer_init(codec, & pg72x->blocksize, & pg72x->samplesperblock);
    }
#line 150
    if ((unsigned long )pg72x->private == (unsigned long )((void *)0)) {
#line 151
      return (17);
    }
#line 153
    pg72x->bytesperblock = bytesperblock;
#line 155
    psf->write_short = & g72x_write_s;
#line 156
    psf->write_int = & g72x_write_i;
#line 157
    psf->write_float = & g72x_write_f;
#line 158
    psf->write_double = & g72x_write_d;
#line 160
    if (psf->datalength % (long )pg72x->blocksize) {
#line 161
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize + 1L);
    } else {
#line 163
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize);
    }
#line 165
    if (psf->datalength > 0L) {
#line 166
      psf->sf.frames = (8L * psf->datalength) / (long )bitspersample;
    }
#line 168
    if ((psf->sf.frames * (long )bitspersample) / 8L != psf->datalength) {
      {
#line 169
      psf_log_printf(psf, "*** Warning : weird psf->datalength.\n");
      }
    }
  }
#line 172
  psf->codec_close = & g72x_close;
#line 174
  return (0);
}
}
#line 182 "/root/patchweave_donee/23/src/g72x.c"
static int psf_g72x_decode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) 
{ 
  int k ;
  sf_count_t __cil_tmp5 ;

  {
#line 185
  (pg72x->block_curr) ++;
#line 186
  pg72x->sample_curr = 0;
#line 188
  if (pg72x->block_curr > pg72x->blocks_total) {
    {
#line 189
    memset((void *)(pg72x->samples), 0, 120UL * sizeof(short ));
    }
#line 190
    return (1);
  }
  {
#line 193
  __cil_tmp5 = psf_fread((void *)(pg72x->block), (sf_count_t )1, (sf_count_t )pg72x->bytesperblock,
                         psf);
#line 193
  k = (int )__cil_tmp5;
  }
#line 193
  if (k != pg72x->bytesperblock) {
    {
#line 194
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, pg72x->bytesperblock);
    }
  }
  {
#line 196
  pg72x->blocksize = k;
#line 197
  g72x_decode_block(pg72x->private, (unsigned char const   *)(pg72x->block), pg72x->samples);
  }
#line 199
  return (1);
}
}
#line 203 "/root/patchweave_donee/23/src/g72x.c"
static int g72x_read_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x , short *ptr , int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;
  int tmp ;

  {
#line 204
  total = 0;
#line 204
  indx = 0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;

#line 206
    if (! (indx < len)) {
#line 206
      goto while_break;
    }
#line 207
    if (pg72x->block_curr > pg72x->blocks_total) {
      {
#line 208
      memset((void *)(ptr + indx), 0, (unsigned long )(len - indx) * sizeof(short ));
      }
#line 209
      return (total);
    }
#line 212
    if (pg72x->sample_curr >= pg72x->samplesperblock) {
      {
#line 213
      psf_g72x_decode_block(psf, pg72x);
      }
    }
#line 215
    count___0 = pg72x->samplesperblock - pg72x->sample_curr;
#line 216
    if (len - indx > count___0) {
#line 216
      tmp = count___0;
    } else {
#line 216
      tmp = len - indx;
    }
    {
#line 216
    count___0 = tmp;
#line 218
    memcpy((void *)(ptr + indx), (void const   *)(& pg72x->samples[pg72x->sample_curr]),
           (unsigned long )count___0 * sizeof(short ));
#line 219
    indx += count___0;
#line 220
    pg72x->sample_curr += count___0;
#line 221
    total = indx;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 224
  return (total);
}
}
#line 228 "/root/patchweave_donee/23/src/g72x.c"
static sf_count_t g72x_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 231
  total = (sf_count_t )0;
#line 233
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 234
    return ((sf_count_t )0);
  }
#line 235
  pg72x = (G72x_PRIVATE *)psf->codec_data;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;

#line 237
    if (! (len > 0L)) {
#line 237
      goto while_break;
    }
#line 238
    if (len > 268435456L) {
#line 238
      tmp = 268435456;
    } else {
#line 238
      tmp = (int )len;
    }
    {
#line 238
    readcount = tmp;
#line 240
    count___0 = g72x_read_block(psf, pg72x, ptr, readcount);
#line 242
    total += (long )count___0;
#line 243
    len -= (long )count___0;
    }
#line 245
    if (count___0 != readcount) {
#line 246
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 249
  return (total);
}
}
#line 253 "/root/patchweave_donee/23/src/g72x.c"
static sf_count_t g72x_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 257
  readcount = 0;
#line 258
  total = (sf_count_t )0;
#line 260
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 261
    return ((sf_count_t )0);
  }
#line 262
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 264
  sptr = ubuf.sbuf;
#line 265
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;

#line 266
    if (! (len > 0L)) {
#line 266
      goto while_break;
    }
#line 267
    if (len >= (long )bufferlen) {
#line 267
      tmp = (long )bufferlen;
    } else {
#line 267
      tmp = len;
    }
    {
#line 267
    readcount = (int )tmp;
#line 268
    count___0 = g72x_read_block(psf, pg72x, sptr, readcount);
#line 270
    k = 0;
    }
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 270
      if (! (k < readcount)) {
#line 270
        goto while_break___0;
      }
      {
#line 271
      *(ptr + (total + (long )k)) = arith_shift_left((int32_t )*(sptr + k), 16);
#line 270
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 273
    total += (long )count___0;
#line 274
    len -= (long )readcount;
#line 275
    if (count___0 != readcount) {
#line 276
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 279
  return (total);
}
}
#line 283 "/root/patchweave_donee/23/src/g72x.c"
static sf_count_t g72x_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 287
  readcount = 0;
#line 288
  total = (sf_count_t )0;
#line 291
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 292
    return ((sf_count_t )0);
  }
#line 293
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 295
  if (psf->norm_float == 1) {
#line 295
    tmp = 1. / (double )((float )32768);
  } else {
#line 295
    tmp = 1.;
  }
#line 295
  normfact = (float )tmp;
#line 297
  sptr = ubuf.sbuf;
#line 298
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;

#line 299
    if (! (len > 0L)) {
#line 299
      goto while_break;
    }
#line 300
    if (len >= (long )bufferlen) {
#line 300
      tmp___0 = (long )bufferlen;
    } else {
#line 300
      tmp___0 = len;
    }
    {
#line 300
    readcount = (int )tmp___0;
#line 301
    count___0 = g72x_read_block(psf, pg72x, sptr, readcount);
#line 302
    k = 0;
    }
    {
#line 302
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 302
      if (! (k < readcount)) {
#line 302
        goto while_break___0;
      }
#line 303
      *(ptr + (total + (long )k)) = normfact * (float )((int )*(sptr + k));
#line 302
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 305
    total += (long )count___0;
#line 306
    len -= (long )readcount;
#line 307
    if (count___0 != readcount) {
#line 308
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 311
  return (total);
}
}
#line 315 "/root/patchweave_donee/23/src/g72x.c"
static sf_count_t g72x_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;

  {
#line 319
  readcount = 0;
#line 320
  total = (sf_count_t )0;
#line 323
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 324
    return ((sf_count_t )0);
  }
#line 325
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 327
  if (psf->norm_double == 1) {
#line 327
    tmp = 1. / (double )32768;
  } else {
#line 327
    tmp = 1.;
  }
#line 327
  normfact = tmp;
#line 329
  sptr = ubuf.sbuf;
#line 330
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;

#line 331
    if (! (len > 0L)) {
#line 331
      goto while_break;
    }
#line 332
    if (len >= (long )bufferlen) {
#line 332
      tmp___0 = (long )bufferlen;
    } else {
#line 332
      tmp___0 = len;
    }
    {
#line 332
    readcount = (int )tmp___0;
#line 333
    count___0 = g72x_read_block(psf, pg72x, sptr, readcount);
#line 334
    k = 0;
    }
    {
#line 334
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 334
      if (! (k < readcount)) {
#line 334
        goto while_break___0;
      }
#line 335
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 334
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 337
    total += (long )count___0;
#line 338
    len -= (long )readcount;
#line 339
    if (count___0 != readcount) {
#line 340
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 343
  return (total);
}
}
#line 347 "/root/patchweave_donee/23/src/g72x.c"
static sf_count_t g72x_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t UNUSED_offset ) 
{ 


  {
  {
#line 349
  psf_log_printf(psf, "seek unsupported\n");
  }
#line 355
  return ((sf_count_t )0);
}
}
#line 428 "/root/patchweave_donee/23/src/g72x.c"
static int psf_g72x_encode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) 
{ 
  int k ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 432
  g72x_encode_block(pg72x->private, pg72x->samples, pg72x->block);
#line 435
  __cil_tmp4 = psf_fwrite((void const   *)(pg72x->block), (sf_count_t )1, (sf_count_t )pg72x->blocksize,
                          psf);
#line 435
  k = (int )__cil_tmp4;
  }
#line 435
  if (k != pg72x->blocksize) {
    {
#line 436
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pg72x->blocksize);
    }
  }
  {
#line 438
  pg72x->sample_curr = 0;
#line 439
  (pg72x->block_curr) ++;
#line 442
  memset((void *)(pg72x->samples), 0, 120UL * sizeof(short ));
  }
#line 444
  return (1);
}
}
#line 448 "/root/patchweave_donee/23/src/g72x.c"
static int g72x_write_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x , short const   *ptr ,
                            int len ) 
{ 
  int count___0 ;
  int total ;
  int indx ;

  {
#line 449
  total = 0;
#line 449
  indx = 0;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;

#line 451
    if (! (indx < len)) {
#line 451
      goto while_break;
    }
#line 452
    count___0 = pg72x->samplesperblock - pg72x->sample_curr;
#line 454
    if (count___0 > len - indx) {
#line 455
      count___0 = len - indx;
    }
    {
#line 457
    memcpy((void *)(& pg72x->samples[pg72x->sample_curr]), (void const   *)(ptr + indx),
           (unsigned long )count___0 * sizeof(short ));
#line 458
    indx += count___0;
#line 459
    pg72x->sample_curr += count___0;
#line 460
    total = indx;
    }
#line 462
    if (pg72x->sample_curr >= pg72x->samplesperblock) {
      {
#line 463
      psf_g72x_encode_block(psf, pg72x);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 466
  return (total);
}
}
#line 470 "/root/patchweave_donee/23/src/g72x.c"
static sf_count_t g72x_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  int tmp ;

  {
#line 473
  total = (sf_count_t )0;
#line 475
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 476
    return ((sf_count_t )0);
  }
#line 477
  pg72x = (G72x_PRIVATE *)psf->codec_data;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;

#line 479
    if (! (len > 0L)) {
#line 479
      goto while_break;
    }
#line 480
    if (len > 268435456L) {
#line 480
      tmp = 268435456;
    } else {
#line 480
      tmp = (int )len;
    }
    {
#line 480
    writecount = tmp;
#line 482
    count___0 = g72x_write_block(psf, pg72x, ptr, writecount);
#line 484
    total += (long )count___0;
#line 485
    len -= (long )count___0;
    }
#line 486
    if (count___0 != writecount) {
#line 487
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 490
  return (total);
}
}
#line 494 "/root/patchweave_donee/23/src/g72x.c"
static sf_count_t g72x_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  long tmp ;

  {
#line 498
  writecount = 0;
#line 499
  total = (sf_count_t )0;
#line 501
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 502
    return ((sf_count_t )0);
  }
#line 503
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 505
  sptr = ubuf.sbuf;
#line 506
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;

#line 507
    if (! (len > 0L)) {
#line 507
      goto while_break;
    }
#line 508
    if (len >= (long )bufferlen) {
#line 508
      tmp = (long )bufferlen;
    } else {
#line 508
      tmp = len;
    }
#line 508
    writecount = (int )tmp;
#line 509
    k = 0;
    {
#line 509
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 509
      if (! (k < writecount)) {
#line 509
        goto while_break___0;
      }
#line 510
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 509
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 511
    count___0 = g72x_write_block(psf, pg72x, (short const   *)sptr, writecount);
#line 513
    total += (long )count___0;
#line 514
    len -= (long )writecount;
    }
#line 515
    if (count___0 != writecount) {
#line 516
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 518
  return (total);
}
}
#line 522 "/root/patchweave_donee/23/src/g72x.c"
static sf_count_t g72x_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 526
  writecount = 0;
#line 527
  total = (sf_count_t )0;
#line 530
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 531
    return ((sf_count_t )0);
  }
#line 532
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 534
  if (psf->norm_float == 1) {
#line 534
    tmp = 1. * (double )32768;
  } else {
#line 534
    tmp = 1.;
  }
#line 534
  normfact = (float )tmp;
#line 536
  sptr = ubuf.sbuf;
#line 537
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;

#line 538
    if (! (len > 0L)) {
#line 538
      goto while_break;
    }
#line 539
    if (len >= (long )bufferlen) {
#line 539
      tmp___0 = (long )bufferlen;
    } else {
#line 539
      tmp___0 = len;
    }
#line 539
    writecount = (int )tmp___0;
#line 540
    k = 0;
    {
#line 540
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 540
      if (! (k < writecount)) {
#line 540
        goto while_break___0;
      }
      {
#line 541
      __cil_tmp15 = lrintf(normfact * (float )*(ptr + (total + (long )k)));
#line 541
      *(sptr + k) = (short )__cil_tmp15;
#line 540
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 542
    count___0 = g72x_write_block(psf, pg72x, (short const   *)sptr, writecount);
#line 544
    total += (long )count___0;
#line 545
    len -= (long )writecount;
    }
#line 546
    if (count___0 != writecount) {
#line 547
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 550
  return (total);
}
}
#line 554 "/root/patchweave_donee/23/src/g72x.c"
static sf_count_t g72x_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  BUF_UNION ubuf ;
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count___0 ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp15 ;

  {
#line 558
  writecount = 0;
#line 559
  total = (sf_count_t )0;
#line 562
  if ((unsigned long )psf->codec_data == (unsigned long )((void *)0)) {
#line 563
    return ((sf_count_t )0);
  }
#line 564
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 566
  if (psf->norm_double == 1) {
#line 566
    tmp = 1. * (double )32768;
  } else {
#line 566
    tmp = 1.;
  }
#line 566
  normfact = tmp;
#line 568
  sptr = ubuf.sbuf;
#line 569
  bufferlen = (int )(8192UL / sizeof(short ));
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;

#line 570
    if (! (len > 0L)) {
#line 570
      goto while_break;
    }
#line 571
    if (len >= (long )bufferlen) {
#line 571
      tmp___0 = (long )bufferlen;
    } else {
#line 571
      tmp___0 = len;
    }
#line 571
    writecount = (int )tmp___0;
#line 572
    k = 0;
    {
#line 572
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 572
      if (! (k < writecount)) {
#line 572
        goto while_break___0;
      }
      {
#line 573
      __cil_tmp15 = lrint(normfact * (double )*(ptr + (total + (long )k)));
#line 573
      *(sptr + k) = (short )__cil_tmp15;
#line 572
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 574
    count___0 = g72x_write_block(psf, pg72x, (short const   *)sptr, writecount);
#line 576
    total += (long )count___0;
#line 577
    len -= (long )writecount;
    }
#line 578
    if (count___0 != writecount) {
#line 579
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 582
  return (total);
}
}
#line 586 "/root/patchweave_donee/23/src/g72x.c"
static int g72x_close(SF_PRIVATE *psf ) 
{ 
  G72x_PRIVATE *pg72x ;

  {
#line 589
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 591
  if (psf->file.mode == 32) {
#line 596
    if (pg72x->sample_curr) {
#line 596
      if (pg72x->sample_curr < 120) {
        {
#line 597
        psf_g72x_encode_block(psf, pg72x);
        }
      }
    }
#line 599
    if (psf->write_header) {
      {
#line 600
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 604
  free((void *)pg72x->private);
  }
#line 606
  return (0);
}
}
#line 448 "/usr/include/FLAC/stream_decoder.h"
extern char const   * const  FLAC__StreamDecoderErrorStatusString[] ;
#line 743
extern FLAC__StreamDecoder *FLAC__stream_decoder_new(void) ;
#line 751
extern void FLAC__stream_decoder_delete(FLAC__StreamDecoder *decoder ) ;
#line 839
extern FLAC__bool FLAC__stream_decoder_set_metadata_respond_all(FLAC__StreamDecoder *decoder ) ;
#line 890
extern FLAC__StreamDecoderState FLAC__stream_decoder_get_state(FLAC__StreamDecoder *decoder ) ;
#line 1007
extern FLAC__bool FLAC__stream_decoder_get_decode_position(FLAC__StreamDecoder *decoder ,
                                                           FLAC__uint64 *position ) ;
#line 1073
extern FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_stream(FLAC__StreamDecoder *decoder ,
                                                                      FLAC__StreamDecoderReadStatus (*read_callback)(FLAC__StreamDecoder * ,
                                                                                                                     FLAC__byte * ,
                                                                                                                     size_t * ,
                                                                                                                     void * ) ,
                                                                      FLAC__StreamDecoderSeekStatus (*seek_callback)(FLAC__StreamDecoder * ,
                                                                                                                     FLAC__uint64  ,
                                                                                                                     void * ) ,
                                                                      FLAC__StreamDecoderTellStatus (*tell_callback)(FLAC__StreamDecoder * ,
                                                                                                                     FLAC__uint64 * ,
                                                                                                                     void * ) ,
                                                                      FLAC__StreamDecoderLengthStatus (*length_callback)(FLAC__StreamDecoder * ,
                                                                                                                         FLAC__uint64 * ,
                                                                                                                         void * ) ,
                                                                      FLAC__bool (*eof_callback)(FLAC__StreamDecoder * ,
                                                                                                 void * ) ,
                                                                      FLAC__StreamDecoderWriteStatus (*write_callback)(FLAC__StreamDecoder * ,
                                                                                                                       FLAC__Frame * ,
                                                                                                                       FLAC__int32 * const  * ,
                                                                                                                       void * ) ,
                                                                      void (*metadata_callback)(FLAC__StreamDecoder * ,
                                                                                                FLAC__StreamMetadata * ,
                                                                                                void * ) ,
                                                                      void (*error_callback)(FLAC__StreamDecoder * ,
                                                                                             FLAC__StreamDecoderErrorStatus  ,
                                                                                             void * ) ,
                                                                      void *client_data ) ;
#line 1370
extern FLAC__bool FLAC__stream_decoder_finish(FLAC__StreamDecoder *decoder ) ;
#line 1450
extern FLAC__bool FLAC__stream_decoder_process_single(FLAC__StreamDecoder *decoder ) ;
#line 1471
extern FLAC__bool FLAC__stream_decoder_process_until_end_of_metadata(FLAC__StreamDecoder *decoder ) ;
#line 1551
extern FLAC__bool FLAC__stream_decoder_seek_absolute(FLAC__StreamDecoder *decoder ,
                                                     FLAC__uint64 sample ) ;
#line 358 "/usr/include/FLAC/stream_encoder.h"
extern char const   * const  FLAC__StreamEncoderInitStatusString[] ;
#line 694
extern FLAC__StreamEncoder *FLAC__stream_encoder_new(void) ;
#line 702
extern void FLAC__stream_encoder_delete(FLAC__StreamEncoder *encoder ) ;
#line 774
extern FLAC__bool FLAC__stream_encoder_set_channels(FLAC__StreamEncoder *encoder ,
                                                    uint32_t value ) ;
#line 790
extern FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder ,
                                                           uint32_t value ) ;
#line 802
extern FLAC__bool FLAC__stream_encoder_set_sample_rate(FLAC__StreamEncoder *encoder ,
                                                       uint32_t value ) ;
#line 865
extern FLAC__bool FLAC__stream_encoder_set_compression_level(FLAC__StreamEncoder *encoder ,
                                                             uint32_t value ) ;
#line 1203
extern FLAC__bool FLAC__stream_encoder_set_metadata(FLAC__StreamEncoder *encoder ,
                                                    FLAC__StreamMetadata **metadata ,
                                                    uint32_t num_blocks ) ;
#line 1493
extern FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_stream(FLAC__StreamEncoder *encoder ,
                                                                      FLAC__StreamEncoderWriteStatus (*write_callback)(FLAC__StreamEncoder * ,
                                                                                                                       FLAC__byte * ,
                                                                                                                       size_t  ,
                                                                                                                       uint32_t  ,
                                                                                                                       uint32_t  ,
                                                                                                                       void * ) ,
                                                                      FLAC__StreamEncoderSeekStatus (*seek_callback)(FLAC__StreamEncoder * ,
                                                                                                                     FLAC__uint64  ,
                                                                                                                     void * ) ,
                                                                      FLAC__StreamEncoderTellStatus (*tell_callback)(FLAC__StreamEncoder * ,
                                                                                                                     FLAC__uint64 * ,
                                                                                                                     void * ) ,
                                                                      void (*metadata_callback)(FLAC__StreamEncoder * ,
                                                                                                FLAC__StreamMetadata * ,
                                                                                                void * ) ,
                                                                      void *client_data ) ;
#line 1723
extern FLAC__bool FLAC__stream_encoder_finish(FLAC__StreamEncoder *encoder ) ;
#line 1782
extern FLAC__bool FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *encoder ,
                                                           FLAC__int32 *buffer , uint32_t samples ) ;
#line 1313 "/usr/include/FLAC/metadata.h"
extern FLAC__StreamMetadata *FLAC__metadata_object_new(FLAC__MetadataType type ) ;
#line 1338
extern void FLAC__metadata_object_delete(FLAC__StreamMetadata *object ) ;
#line 1688
extern FLAC__bool FLAC__metadata_object_vorbiscomment_append_comment(FLAC__StreamMetadata *object ,
                                                                     FLAC__StreamMetadata_VorbisComment_Entry entry ,
                                                                     FLAC__bool copy ) ;
#line 1757
extern FLAC__bool FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(FLAC__StreamMetadata_VorbisComment_Entry *entry ,
                                                                                 char const   *field_name ,
                                                                                 char const   *field_value ) ;
#line 1811
extern int FLAC__metadata_object_vorbiscomment_find_entry_from(FLAC__StreamMetadata *object ,
                                                               uint32_t offset , char const   *field_name ) ;
#line 81 "/root/patchweave_donee/23/src/flac.c"
static sf_count_t flac_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 82
static int flac_byterate(SF_PRIVATE *psf ) ;
#line 83
static int flac_close(SF_PRIVATE *psf ) ;
#line 85
static int flac_enc_init(SF_PRIVATE *psf ) ;
#line 86
static int flac_read_header(SF_PRIVATE *psf ) ;
#line 88
static sf_count_t flac_read_flac2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 89
static sf_count_t flac_read_flac2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 90
static sf_count_t flac_read_flac2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 91
static sf_count_t flac_read_flac2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 93
static sf_count_t flac_write_s2flac(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 94
static sf_count_t flac_write_i2flac(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 95
static sf_count_t flac_write_f2flac(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 96
static sf_count_t flac_write_d2flac(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 98
static void f2flac8_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                          int normalize ) ;
#line 99
static void f2flac16_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                           int normalize ) ;
#line 100
static void f2flac24_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                           int normalize ) ;
#line 101
static void f2flac8_clip_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                               int normalize ) ;
#line 102
static void f2flac16_clip_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                                int normalize ) ;
#line 103
static void f2flac24_clip_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                                int normalize ) ;
#line 104
static void d2flac8_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                          int normalize ) ;
#line 105
static void d2flac16_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                           int normalize ) ;
#line 106
static void d2flac24_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                           int normalize ) ;
#line 107
static void d2flac8_clip_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                               int normalize ) ;
#line 108
static void d2flac16_clip_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                                int normalize ) ;
#line 109
static void d2flac24_clip_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                                int normalize ) ;
#line 111
static int flac_command(SF_PRIVATE *psf , int command , void *data , int datasize ) ;
#line 114
static FLAC__StreamDecoderReadStatus sf_flac_read_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__byte *buffer , size_t *bytes ,
                                                           void *client_data ) ;
#line 115
static FLAC__StreamDecoderSeekStatus sf_flac_seek_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 absolute_byte_offset ,
                                                           void *client_data ) ;
#line 116
static FLAC__StreamDecoderTellStatus sf_flac_tell_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 *absolute_byte_offset ,
                                                           void *client_data ) ;
#line 117
static FLAC__StreamDecoderLengthStatus sf_flac_length_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                               FLAC__uint64 *stream_length ,
                                                               void *client_data ) ;
#line 118
static FLAC__bool sf_flac_eof_callback(FLAC__StreamDecoder *UNUSED_decoder , void *client_data ) ;
#line 119
static FLAC__StreamDecoderWriteStatus sf_flac_write_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                             FLAC__Frame *frame ,
                                                             FLAC__int32 * const  *buffer ,
                                                             void *client_data ) ;
#line 120
static void sf_flac_meta_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamMetadata *metadata ,
                                  void *client_data ) ;
#line 121
static void sf_flac_error_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamDecoderErrorStatus status ,
                                   void *client_data ) ;
#line 124
static FLAC__StreamEncoderSeekStatus sf_flac_enc_seek_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 absolute_byte_offset ,
                                                               void *client_data ) ;
#line 125
static FLAC__StreamEncoderTellStatus sf_flac_enc_tell_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 *absolute_byte_offset ,
                                                               void *client_data ) ;
#line 126
static FLAC__StreamEncoderWriteStatus sf_flac_enc_write_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                                 FLAC__byte *buffer ,
                                                                 size_t bytes , unsigned int UNUSED_samples ,
                                                                 unsigned int UNUSED_current_frame ,
                                                                 void *client_data ) ;
#line 129 "/root/patchweave_donee/23/src/flac.c"
static void s2flac8_array(short const   *src , FLAC__int32 *dest , int count___0 ) 
{ 


  {
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    count___0 --;
#line 130
    if (! (count___0 >= 0)) {
#line 130
      goto while_break;
    }
#line 131
    *(dest + count___0) = (int )*(src + count___0) >> 8;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 135
  return;
}
}
#line 135 "/root/patchweave_donee/23/src/flac.c"
static void s2flac16_array(short const   *src , FLAC__int32 *dest , int count___0 ) 
{ 


  {
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    count___0 --;
#line 136
    if (! (count___0 >= 0)) {
#line 136
      goto while_break;
    }
#line 137
    *(dest + count___0) = (FLAC__int32 )*(src + count___0);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 141
  return;
}
}
#line 141 "/root/patchweave_donee/23/src/flac.c"
static void s2flac24_array(short const   *src , FLAC__int32 *dest , int count___0 ) 
{ 


  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    count___0 --;
#line 142
    if (! (count___0 >= 0)) {
#line 142
      goto while_break;
    }
#line 143
    *(dest + count___0) = (int )*(src + count___0) << 8;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 147
  return;
}
}
#line 147 "/root/patchweave_donee/23/src/flac.c"
static void i2flac8_array(int const   *src , FLAC__int32 *dest , int count___0 ) 
{ 


  {
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    count___0 --;
#line 148
    if (! (count___0 >= 0)) {
#line 148
      goto while_break;
    }
#line 149
    *(dest + count___0) = (FLAC__int32 )(*(src + count___0) >> 24);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 153
  return;
}
}
#line 153 "/root/patchweave_donee/23/src/flac.c"
static void i2flac16_array(int const   *src , FLAC__int32 *dest , int count___0 ) 
{ 


  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    count___0 --;
#line 155
    if (! (count___0 >= 0)) {
#line 155
      goto while_break;
    }
#line 156
    *(dest + count___0) = (FLAC__int32 )(*(src + count___0) >> 16);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 160
  return;
}
}
#line 160 "/root/patchweave_donee/23/src/flac.c"
static void i2flac24_array(int const   *src , FLAC__int32 *dest , int count___0 ) 
{ 


  {
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    count___0 --;
#line 161
    if (! (count___0 >= 0)) {
#line 161
      goto while_break;
    }
#line 162
    *(dest + count___0) = (FLAC__int32 )(*(src + count___0) >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 166
  return;
}
}
#line 166 "/root/patchweave_donee/23/src/flac.c"
static sf_count_t flac_buffer_copy(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__Frame *frame ;
  FLAC__int32 * const  *buffer ;
  unsigned int i ;
  unsigned int j ;
  unsigned int offset ;
  short *retpcm ;
  int shift ;
  int *retpcm___0 ;
  int shift___0 ;
  float *retpcm___1 ;
  float norm ;
  double tmp ;
  double *retpcm___2 ;
  double norm___0 ;
  double tmp___0 ;
  void *tmp___1 ;

  {
#line 167
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 168
  frame = pflac->frame;
#line 169
  buffer = pflac->wbuffer;
#line 170
  i = 0U;
#line 177
  if (frame->header.blocksize > 65535U) {
    {
#line 178
    psf_log_printf(psf, "Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n",
                   "flac_buffer_copy\312\001@", 178, frame->header.blocksize, 65535U);
#line 179
    psf->error = 30;
    }
#line 180
    return ((sf_count_t )0);
  }
#line 183
  if ((unsigned long )pflac->ptr == (unsigned long )((void *)0)) {
#line 188
    pflac->bufferbackup = 1;
#line 189
    i = 0U;
    {
#line 189
    while (1) {
      while_continue: /* CIL Label */ ;

#line 189
      if (! (i < frame->header.channels)) {
#line 189
        goto while_break;
      }
#line 191
      if ((unsigned long )pflac->rbuffer[i] == (unsigned long )((void *)0)) {
        {
#line 192
        tmp___1 = calloc(65535UL, sizeof(FLAC__int32 ));
#line 192
        pflac->rbuffer[i] = (FLAC__int32 *)tmp___1;
        }
      }
      {
#line 194
      memcpy((void *)pflac->rbuffer[i], (void const   *)*(buffer + i), (unsigned long )frame->header.blocksize * sizeof(FLAC__int32 ));
#line 189
      i ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break: 
#line 196
    pflac->wbuffer = (FLAC__int32 * const  *)(pflac->rbuffer);
#line 198
    return ((sf_count_t )0);
  }
#line 202
  if ((unsigned int )pflac->pcmtype == 50U) {
#line 202
    goto case_50;
  }
#line 236
  if ((unsigned int )pflac->pcmtype == 51U) {
#line 236
    goto case_51;
  }
#line 253
  if ((unsigned int )pflac->pcmtype == 52U) {
#line 253
    goto case_52;
  }
#line 271
  if ((unsigned int )pflac->pcmtype == 53U) {
#line 271
    goto case_53;
  }
#line 289
  goto switch_default;
  case_50: 
#line 203
  retpcm = (short *)pflac->ptr;
#line 204
  shift = (int )(16U - frame->header.bits_per_sample);
#line 205
  if (shift < 0) {
    {
#line 206
    shift = abs(shift);
#line 207
    i = 0U;
    }
    {
#line 207
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 207
      if (i < frame->header.blocksize) {
#line 207
        if (! (pflac->remain > 0U)) {
#line 207
          goto while_break___0;
        }
      } else {
#line 207
        goto while_break___0;
      }
#line 208
      offset = pflac->pos + i * frame->header.channels;
#line 210
      if (pflac->bufferpos >= frame->header.blocksize) {
#line 211
        goto while_break___0;
      }
#line 213
      j = 0U;
      {
#line 213
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 213
        if (! (j < frame->header.channels)) {
#line 213
          goto while_break___1;
        }
#line 214
        *(retpcm + (offset + j)) = (short )(*(*(buffer + j) + pflac->bufferpos) >> shift);
#line 213
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___1: 
#line 215
      pflac->remain -= frame->header.channels;
#line 216
      (pflac->bufferpos) ++;
#line 207
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 220
    i = 0U;
    {
#line 220
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 220
      if (i < frame->header.blocksize) {
#line 220
        if (! (pflac->remain > 0U)) {
#line 220
          goto while_break___2;
        }
      } else {
#line 220
        goto while_break___2;
      }
#line 221
      offset = pflac->pos + i * frame->header.channels;
#line 223
      if (pflac->bufferpos >= frame->header.blocksize) {
#line 224
        goto while_break___2;
      }
#line 226
      j = 0U;
      {
#line 226
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 226
        if (! (j < frame->header.channels)) {
#line 226
          goto while_break___3;
        }
#line 227
        *(retpcm + (offset + j)) = (short )((int )((uint16_t )*(*(buffer + j) + pflac->bufferpos)) << shift);
#line 226
        j ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___3: 
#line 229
      pflac->remain -= frame->header.channels;
#line 230
      (pflac->bufferpos) ++;
#line 220
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 234
  goto switch_break;
  case_51: 
#line 237
  retpcm___0 = (int *)pflac->ptr;
#line 238
  shift___0 = (int )(32U - frame->header.bits_per_sample);
#line 239
  i = 0U;
  {
#line 239
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 239
    if (i < frame->header.blocksize) {
#line 239
      if (! (pflac->remain > 0U)) {
#line 239
        goto while_break___4;
      }
    } else {
#line 239
      goto while_break___4;
    }
#line 240
    offset = pflac->pos + i * frame->header.channels;
#line 242
    if (pflac->bufferpos >= frame->header.blocksize) {
#line 243
      goto while_break___4;
    }
#line 245
    j = 0U;
    {
#line 245
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 245
      if (! (j < frame->header.channels)) {
#line 245
        goto while_break___5;
      }
#line 246
      *(retpcm___0 + (offset + j)) = (int )((uint32_t )*(*(buffer + j) + pflac->bufferpos) << shift___0);
#line 245
      j ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___5: 
#line 247
    pflac->remain -= frame->header.channels;
#line 248
    (pflac->bufferpos) ++;
#line 239
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___4: ;
#line 251
  goto switch_break;
  case_52: 
#line 254
  retpcm___1 = (float *)pflac->ptr;
#line 255
  if (psf->norm_float == 1) {
#line 255
    tmp = 1. / (double )(1 << (frame->header.bits_per_sample - 1U));
  } else {
#line 255
    tmp = 1.;
  }
#line 255
  norm = (float )tmp;
#line 257
  i = 0U;
  {
#line 257
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 257
    if (i < frame->header.blocksize) {
#line 257
      if (! (pflac->remain > 0U)) {
#line 257
        goto while_break___6;
      }
    } else {
#line 257
      goto while_break___6;
    }
#line 258
    offset = pflac->pos + i * frame->header.channels;
#line 260
    if (pflac->bufferpos >= frame->header.blocksize) {
#line 261
      goto while_break___6;
    }
#line 263
    j = 0U;
    {
#line 263
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 263
      if (! (j < frame->header.channels)) {
#line 263
        goto while_break___7;
      }
#line 264
      *(retpcm___1 + (offset + j)) = (float )*(*(buffer + j) + pflac->bufferpos) * norm;
#line 263
      j ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___7: 
#line 265
    pflac->remain -= frame->header.channels;
#line 266
    (pflac->bufferpos) ++;
#line 257
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___6: ;
#line 269
  goto switch_break;
  case_53: 
#line 272
  retpcm___2 = (double *)pflac->ptr;
#line 273
  if (psf->norm_double == 1) {
#line 273
    tmp___0 = 1. / (double )(1 << (frame->header.bits_per_sample - 1U));
  } else {
#line 273
    tmp___0 = 1.;
  }
#line 273
  norm___0 = tmp___0;
#line 275
  i = 0U;
  {
#line 275
  while (1) {
    while_continue___8: /* CIL Label */ ;

#line 275
    if (i < frame->header.blocksize) {
#line 275
      if (! (pflac->remain > 0U)) {
#line 275
        goto while_break___8;
      }
    } else {
#line 275
      goto while_break___8;
    }
#line 276
    offset = pflac->pos + i * frame->header.channels;
#line 278
    if (pflac->bufferpos >= frame->header.blocksize) {
#line 279
      goto while_break___8;
    }
#line 281
    j = 0U;
    {
#line 281
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 281
      if (! (j < frame->header.channels)) {
#line 281
        goto while_break___9;
      }
#line 282
      *(retpcm___2 + (offset + j)) = (double )*(*(buffer + j) + pflac->bufferpos) * norm___0;
#line 281
      j ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___9: 
#line 283
    pflac->remain -= frame->header.channels;
#line 284
    (pflac->bufferpos) ++;
#line 275
    i ++;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___8: ;
#line 287
  goto switch_break;
  switch_default: 
#line 290
  return ((sf_count_t )0);
  switch_break: 
#line 293
  offset = i * frame->header.channels;
#line 294
  pflac->pos += i * frame->header.channels;
#line 296
  return ((sf_count_t )offset);
}
}
#line 301 "/root/patchweave_donee/23/src/flac.c"
static FLAC__StreamDecoderReadStatus sf_flac_read_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__byte *buffer , size_t *bytes ,
                                                           void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp6 ;

  {
  {
#line 302
  psf = (SF_PRIVATE *)client_data;
#line 304
  __cil_tmp6 = psf_fread((void *)buffer, (sf_count_t )1, (sf_count_t )*bytes, psf);
#line 304
  *bytes = (size_t )__cil_tmp6;
  }
#line 305
  if (*bytes > 0UL) {
#line 305
    if (psf->error == 0) {
#line 306
      return ((FLAC__StreamDecoderReadStatus )0);
    }
  }
#line 308
  return ((FLAC__StreamDecoderReadStatus )2);
}
}
#line 312 "/root/patchweave_donee/23/src/flac.c"
static FLAC__StreamDecoderSeekStatus sf_flac_seek_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 absolute_byte_offset ,
                                                           void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
  {
#line 313
  psf = (SF_PRIVATE *)client_data;
#line 315
  psf_fseek(psf, (sf_count_t )absolute_byte_offset, 0);
  }
#line 316
  if (psf->error) {
#line 317
    return ((FLAC__StreamDecoderSeekStatus )1);
  }
#line 319
  return ((FLAC__StreamDecoderSeekStatus )0);
}
}
#line 323 "/root/patchweave_donee/23/src/flac.c"
static FLAC__StreamDecoderTellStatus sf_flac_tell_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 *absolute_byte_offset ,
                                                           void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 324
  psf = (SF_PRIVATE *)client_data;
#line 326
  __cil_tmp5 = psf_ftell(psf);
#line 326
  *absolute_byte_offset = (FLAC__uint64 )__cil_tmp5;
  }
#line 327
  if (psf->error) {
#line 328
    return ((FLAC__StreamDecoderTellStatus )1);
  }
#line 330
  return ((FLAC__StreamDecoderTellStatus )0);
}
}
#line 334 "/root/patchweave_donee/23/src/flac.c"
static FLAC__StreamDecoderLengthStatus sf_flac_length_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                               FLAC__uint64 *stream_length ,
                                                               void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
#line 335
  psf = (SF_PRIVATE *)client_data;
#line 337
  *stream_length = (FLAC__uint64 )psf->filelength;
#line 337
  if (*stream_length == 0UL) {
#line 338
    return ((FLAC__StreamDecoderLengthStatus )1);
  }
#line 340
  return ((FLAC__StreamDecoderLengthStatus )0);
}
}
#line 344 "/root/patchweave_donee/23/src/flac.c"
static FLAC__bool sf_flac_eof_callback(FLAC__StreamDecoder *UNUSED_decoder , void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 345
  psf = (SF_PRIVATE *)client_data;
#line 347
  __cil_tmp4 = psf_ftell(psf);
  }
#line 347
  if (__cil_tmp4 == psf->filelength) {
#line 348
    return (1);
  }
#line 350
  return (0);
}
}
#line 354 "/root/patchweave_donee/23/src/flac.c"
static FLAC__StreamDecoderWriteStatus sf_flac_write_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                             FLAC__Frame *frame ,
                                                             FLAC__int32 * const  *buffer ,
                                                             void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  FLAC_PRIVATE *pflac ;

  {
  {
#line 355
  psf = (SF_PRIVATE *)client_data;
#line 356
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 358
  pflac->frame = frame;
#line 359
  pflac->bufferpos = 0U;
#line 361
  pflac->bufferbackup = 0;
#line 362
  pflac->wbuffer = buffer;
#line 364
  flac_buffer_copy(psf);
  }
#line 366
  return ((FLAC__StreamDecoderWriteStatus )0);
}
}
#line 370 "/root/patchweave_donee/23/src/flac.c"
static void sf_flac_meta_get_vorbiscomments(SF_PRIVATE *psf , FLAC__StreamMetadata *metadata ) 
{ 
  FLAC_TAG tags[10] ;
  char const   *value___0 ;
  char const   *cptr ;
  int k ;
  int tag_num ;
  char *__cil_tmp9 ;

  {
#line 371
  tags[0].tag = "title";
#line 371
  tags[0].type = 1;
#line 371
  tags[1].tag = "copyright";
#line 371
  tags[1].type = 2;
#line 371
  tags[2].tag = "software\230";
#line 371
  tags[2].type = 3;
#line 371
  tags[3].tag = "artist";
#line 371
  tags[3].type = 4;
#line 371
  tags[4].tag = "comment";
#line 371
  tags[4].type = 5;
#line 371
  tags[5].tag = "date\204U";
#line 371
  tags[5].type = 6;
#line 371
  tags[6].tag = "album";
#line 371
  tags[6].type = 7;
#line 371
  tags[7].tag = "license";
#line 371
  tags[7].type = 8;
#line 371
  tags[8].tag = "tracknumber\332\204U";
#line 371
  tags[8].type = 9;
#line 371
  tags[9].tag = "genreU";
#line 371
  tags[9].type = 16;
#line 387
  k = 0;
  {
#line 387
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 387
    if (! (k < (int )(sizeof(tags) / sizeof(tags[0])))) {
#line 387
      goto while_break;
    }
    {
#line 388
    tag_num = FLAC__metadata_object_vorbiscomment_find_entry_from(metadata, (uint32_t )0,
                                                                  tags[k].tag);
    }
#line 390
    if (tag_num < 0) {
#line 391
      goto while_continue;
    }
    {
#line 393
    value___0 = (char const   *)(metadata->data.vorbis_comment.comments + tag_num)->entry;
#line 394
    __cil_tmp9 = strchr(value___0, '=');
#line 394
    cptr = (char const   *)__cil_tmp9;
    }
#line 394
    if ((unsigned long )cptr != (unsigned long )((void *)0)) {
#line 395
      value___0 = cptr + 1;
    }
    {
#line 397
    psf_log_printf(psf, "  %-10s : %s\nU", tags[k].tag, value___0);
#line 398
    psf_store_string(psf, tags[k].type, value___0);
#line 387
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 401
  return;
}
}
#line 405 "/root/patchweave_donee/23/src/flac.c"
static void sf_flac_meta_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamMetadata *metadata ,
                                  void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  int bitwidth ;

  {
#line 406
  psf = (SF_PRIVATE *)client_data;
#line 407
  bitwidth = 0;
#line 410
  if ((unsigned int )metadata->type == 0U) {
#line 410
    goto case_0;
  }
#line 425
  if ((unsigned int )metadata->type == 8U) {
#line 425
    goto case_8;
  }
#line 429
  if ((unsigned int )metadata->type == 16U) {
#line 429
    goto case_16;
  }
#line 433
  if ((unsigned int )metadata->type == 24U) {
#line 433
    goto case_24;
  }
#line 446
  if ((unsigned int )metadata->type == 4U) {
#line 446
    goto case_4;
  }
#line 451
  if ((unsigned int )metadata->type == 1U) {
#line 451
    goto case_1;
  }
#line 455
  if ((unsigned int )metadata->type == 2U) {
#line 455
    goto case_2;
  }
#line 459
  if ((unsigned int )metadata->type == 3U) {
#line 459
    goto case_3;
  }
#line 463
  if ((unsigned int )metadata->type == 5U) {
#line 463
    goto case_5;
  }
#line 467
  if ((unsigned int )metadata->type == 6U) {
#line 467
    goto case_6;
  }
#line 471
  if ((unsigned int )metadata->type == 7U) {
#line 471
    goto case_7;
  }
#line 475
  goto switch_default___0;
  case_0: 
  {
#line 411
  psf->sf.channels = (int )metadata->data.stream_info.channels;
#line 412
  psf->sf.samplerate = (int )metadata->data.stream_info.sample_rate;
#line 413
  psf->sf.frames = (sf_count_t )metadata->data.stream_info.total_samples;
#line 415
  psf_log_printf(psf, "FLAC Stream Metadata\n  Channels    : %d\n  Sample rate : %d\n\332\204U",
                 psf->sf.channels, psf->sf.samplerate);
  }
#line 417
  if (psf->sf.frames == 0L) {
    {
#line 418
    psf_log_printf(psf, "  Frames      : 0 (bumping to SF_COUNT_MAX)\n");
#line 419
    psf->sf.frames = (sf_count_t )-1LL;
    }
  } else {
    {
#line 422
    psf_log_printf(psf, "  Frames      : %D\n\332\204U", psf->sf.frames);
    }
  }
#line 425
  if (metadata->data.stream_info.bits_per_sample == 8U) {
#line 425
    goto case_8;
  }
#line 429
  if (metadata->data.stream_info.bits_per_sample == 16U) {
#line 429
    goto case_16;
  }
#line 433
  if (metadata->data.stream_info.bits_per_sample == 24U) {
#line 433
    goto case_24;
  }
#line 437
  goto switch_default;
  case_8: 
#line 426
  psf->sf.format |= 1;
#line 427
  bitwidth = 8;
#line 428
  goto switch_break___0;
  case_16: 
#line 430
  psf->sf.format |= 2;
#line 431
  bitwidth = 16;
#line 432
  goto switch_break___0;
  case_24: 
#line 434
  psf->sf.format |= 3;
#line 435
  bitwidth = 24;
#line 436
  goto switch_break___0;
  switch_default: 
  {
#line 438
  psf_log_printf(psf, "sf_flac_meta_callback : bits_per_sample %d not yet implemented.\n\230\001",
                 metadata->data.stream_info.bits_per_sample);
  }
#line 439
  goto switch_break___0;
  switch_break___0: ;
#line 442
  if (bitwidth > 0) {
    {
#line 443
    psf_log_printf(psf, "  Bit width   : %d\n\332\204U", bitwidth);
    }
  }
#line 444
  goto switch_break;
  case_4: 
  {
#line 447
  psf_log_printf(psf, "Vorbis Comment Metadata\n\220");
#line 448
  sf_flac_meta_get_vorbiscomments(psf, metadata);
  }
#line 449
  goto switch_break;
  case_1: 
  {
#line 452
  psf_log_printf(psf, "Padding Metadata\n\367\375\332\204U");
  }
#line 453
  goto switch_break;
  case_2: 
  {
#line 456
  psf_log_printf(psf, "Application Metadata\n");
  }
#line 457
  goto switch_break;
  case_3: 
  {
#line 460
  psf_log_printf(psf, "Seektable Metadata\n");
  }
#line 461
  goto switch_break;
  case_5: 
  {
#line 464
  psf_log_printf(psf, "Cuesheet Metadata\n");
  }
#line 465
  goto switch_break;
  case_6: 
  {
#line 468
  psf_log_printf(psf, "Picture Metadata\n\303\375\332\204U");
  }
#line 469
  goto switch_break;
  case_7: 
  {
#line 472
  psf_log_printf(psf, "Undefined Metadata\n");
  }
#line 473
  goto switch_break;
  switch_default___0: 
  {
#line 476
  psf_log_printf(psf, "sf_flac_meta_callback : metadata-type %d not yet implemented.\n",
                 (unsigned int )metadata->type);
  }
#line 477
  goto switch_break;
  switch_break: ;
#line 480
  return;
}
}
#line 484 "/root/patchweave_donee/23/src/flac.c"
static void sf_flac_error_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamDecoderErrorStatus status ,
                                   void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
  {
#line 485
  psf = (SF_PRIVATE *)client_data;
#line 487
  psf_log_printf(psf, "ERROR : %s\n", FLAC__StreamDecoderErrorStatusString[status]);
  }
#line 490
  if ((unsigned int )status == 0U) {
#line 490
    goto case_0;
  }
#line 493
  if ((unsigned int )status == 1U) {
#line 493
    goto case_1;
  }
#line 496
  goto switch_default;
  case_0: 
#line 491
  psf->error = 156;
#line 492
  goto switch_break;
  case_1: 
#line 494
  psf->error = 153;
#line 495
  goto switch_break;
  switch_default: 
#line 497
  psf->error = 158;
#line 498
  goto switch_break;
  switch_break: ;
#line 501
  return;
}
}
#line 505 "/root/patchweave_donee/23/src/flac.c"
static FLAC__StreamEncoderSeekStatus sf_flac_enc_seek_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 absolute_byte_offset ,
                                                               void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
  {
#line 506
  psf = (SF_PRIVATE *)client_data;
#line 508
  psf_fseek(psf, (sf_count_t )absolute_byte_offset, 0);
  }
#line 509
  if (psf->error) {
#line 510
    return ((FLAC__StreamEncoderSeekStatus )1);
  }
#line 512
  return ((FLAC__StreamEncoderSeekStatus )0);
}
}
#line 516 "/root/patchweave_donee/23/src/flac.c"
static FLAC__StreamEncoderTellStatus sf_flac_enc_tell_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 *absolute_byte_offset ,
                                                               void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 517
  psf = (SF_PRIVATE *)client_data;
#line 519
  __cil_tmp5 = psf_ftell(psf);
#line 519
  *absolute_byte_offset = (FLAC__uint64 )__cil_tmp5;
  }
#line 520
  if (psf->error) {
#line 521
    return ((FLAC__StreamEncoderTellStatus )1);
  }
#line 523
  return ((FLAC__StreamEncoderTellStatus )0);
}
}
#line 527 "/root/patchweave_donee/23/src/flac.c"
static FLAC__StreamEncoderWriteStatus sf_flac_enc_write_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                                 FLAC__byte *buffer ,
                                                                 size_t bytes , unsigned int UNUSED_samples ,
                                                                 unsigned int UNUSED_current_frame ,
                                                                 void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp8 ;

  {
  {
#line 528
  psf = (SF_PRIVATE *)client_data;
#line 530
  __cil_tmp8 = psf_fwrite((void const   *)buffer, (sf_count_t )1, (sf_count_t )bytes,
                          psf);
  }
#line 530
  if (__cil_tmp8 == (sf_count_t )bytes) {
#line 530
    if (psf->error == 0) {
#line 531
      return ((FLAC__StreamEncoderWriteStatus )0);
    }
  }
#line 533
  return ((FLAC__StreamEncoderWriteStatus )1);
}
}
#line 537 "/root/patchweave_donee/23/src/flac.c"
static void flac_write_strings(SF_PRIVATE *psf , FLAC_PRIVATE *pflac ) 
{ 
  FLAC__StreamMetadata_VorbisComment_Entry entry ;
  int k ;
  int string_count ;
  char const   *key ;
  char const   *value___0 ;
  FLAC__bool __cil_tmp12 ;

  {
#line 539
  string_count = 0;
#line 541
  k = 0;
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;

#line 541
    if (! (k < 32)) {
#line 541
      goto while_break;
    }
#line 542
    if (psf->strings.data[k].type != 0) {
#line 543
      string_count ++;
    }
#line 541
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 546
  if (string_count == 0) {
#line 547
    return;
  }
  {
#line 549
  pflac->metadata = FLAC__metadata_object_new((FLAC__MetadataType )4);
  }
#line 549
  if ((unsigned long )pflac->metadata == (unsigned long )((void *)0)) {
#line 549
    if ((unsigned long )pflac->metadata == (unsigned long )((void *)0)) {
      {
#line 550
      psf_log_printf(psf, "FLAC__metadata_object_new returned NULL\n\220");
      }
#line 551
      return;
    }
  }
#line 554
  k = 0;
  {
#line 554
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: ;
#line 554
    if (k < 32) {
#line 554
      if (! (psf->strings.data[k].type != 0)) {
#line 554
        goto while_break___0;
      }
    } else {
#line 554
      goto while_break___0;
    }
#line 558
    if (psf->strings.data[k].type == 3) {
#line 558
      goto case_3;
    }
#line 561
    if (psf->strings.data[k].type == 1) {
#line 561
      goto case_1;
    }
#line 564
    if (psf->strings.data[k].type == 2) {
#line 564
      goto case_2;
    }
#line 567
    if (psf->strings.data[k].type == 4) {
#line 567
      goto case_4;
    }
#line 570
    if (psf->strings.data[k].type == 5) {
#line 570
      goto case_5;
    }
#line 573
    if (psf->strings.data[k].type == 6) {
#line 573
      goto case_6;
    }
#line 576
    if (psf->strings.data[k].type == 7) {
#line 576
      goto case_7;
    }
#line 579
    if (psf->strings.data[k].type == 8) {
#line 579
      goto case_8;
    }
#line 582
    if (psf->strings.data[k].type == 9) {
#line 582
      goto case_9;
    }
#line 585
    if (psf->strings.data[k].type == 16) {
#line 585
      goto case_16;
    }
#line 588
    goto switch_default;
    case_3: 
#line 559
    key = "software\220";
#line 560
    goto switch_break;
    case_1: 
#line 562
    key = "title";
#line 563
    goto switch_break;
    case_2: 
#line 565
    key = "copyright";
#line 566
    goto switch_break;
    case_4: 
#line 568
    key = "artist";
#line 569
    goto switch_break;
    case_5: 
#line 571
    key = "comment";
#line 572
    goto switch_break;
    case_6: 
#line 574
    key = "date";
#line 575
    goto switch_break;
    case_7: 
#line 577
    key = "album";
#line 578
    goto switch_break;
    case_8: 
#line 580
    key = "license";
#line 581
    goto switch_break;
    case_9: 
#line 583
    key = "tracknumber";
#line 584
    goto switch_break;
    case_16: 
#line 586
    key = "genre";
#line 587
    goto switch_break;
    switch_default: 
#line 589
    goto while_continue___0;
    switch_break: 
    {
#line 592
    value___0 = (char const   *)(psf->strings.storage + psf->strings.data[k].offset);
#line 594
    FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(& entry, key, value___0);
#line 595
    FLAC__metadata_object_vorbiscomment_append_comment(pflac->metadata, entry, 0);
#line 554
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 598
  __cil_tmp12 = FLAC__stream_encoder_set_metadata(pflac->fse, & pflac->metadata, (uint32_t )1);
  }
#line 598
  if (! __cil_tmp12) {
    {
#line 599
    printf("%s %d : fail\n", "flac_write_strings", 599);
    }
#line 600
    return;
  }
#line 603
  return;
}
}
#line 607 "/root/patchweave_donee/23/src/flac.c"
static int flac_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  FLAC_PRIVATE *pflac ;
  int err ;
  FLAC__StreamEncoderInitStatus __cil_tmp5 ;
  void *tmp ;

  {
  {
#line 608
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 611
  flac_write_strings(psf, pflac);
#line 613
  __cil_tmp5 = FLAC__stream_encoder_init_stream(pflac->fse, & sf_flac_enc_write_callback,
                                                & sf_flac_enc_seek_callback, & sf_flac_enc_tell_callback,
                                                (void (*)(FLAC__StreamEncoder * ,
                                                          FLAC__StreamMetadata * ,
                                                          void * ))((void *)0), (void *)psf);
#line 613
  err = (int )__cil_tmp5;
  }
#line 613
  if (err != 0) {
    {
#line 614
    psf_log_printf(psf, "Error : FLAC encoder init returned error : %s\n", FLAC__StreamEncoderInitStatusString[err]);
    }
#line 615
    return (155);
  }
#line 618
  if (psf->error == 0) {
    {
#line 619
    psf->dataoffset = psf_ftell(psf);
    }
  }
  {
#line 620
  tmp = calloc(8192UL, sizeof(FLAC__int32 ));
#line 620
  pflac->encbuffer = (FLAC__int32 *)tmp;
  }
#line 622
  return (psf->error);
}
}
#line 630 "/root/patchweave_donee/23/src/flac.c"
int flac_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  FLAC_PRIVATE *pflac ;
  void *__cil_tmp5 ;

  {
  {
#line 632
  error = 0;
#line 634
  __cil_tmp5 = calloc(1UL, sizeof(FLAC_PRIVATE ));
#line 634
  pflac = (FLAC_PRIVATE *)__cil_tmp5;
#line 635
  psf->codec_data = (void *)pflac;
#line 638
  pflac->compression = 5U;
  }
#line 641
  if (psf->file.mode == 48) {
#line 642
    return (24);
  }
#line 644
  if (psf->file.mode == 16) {
    {
#line 645
    error = flac_read_header(psf);
    }
#line 645
    if (error) {
#line 646
      return (error);
    }
  }
#line 649
  subformat = psf->sf.format & 65535;
#line 651
  if (psf->file.mode == 32) {
#line 652
    if ((psf->sf.format & 268369920) != 1507328) {
#line 653
      return (1);
    }
    {
#line 655
    psf->endian = 536870912;
#line 656
    psf->sf.seekable = 0;
#line 658
    psf->strings.flags = (uint32_t )256;
#line 660
    error = flac_enc_init(psf);
    }
#line 660
    if (error) {
#line 661
      return (error);
    }
#line 663
    psf->write_header = & flac_write_header;
  }
#line 666
  psf->datalength = psf->filelength;
#line 667
  psf->dataoffset = (sf_count_t )0;
#line 669
  psf->container_close = & flac_close;
#line 670
  psf->seek = & flac_seek;
#line 671
  psf->byterate = & flac_byterate;
#line 673
  psf->command = & flac_command;
#line 678
  if (subformat == 3) {
#line 678
    goto case_3;
  }
#line 678
  if (subformat == 2) {
#line 678
    goto case_3;
  }
#line 678
  if (subformat == 1) {
#line 678
    goto case_3;
  }
#line 682
  goto switch_default;
  case_3: 
  {
#line 679
  error = flac_init(psf);
  }
#line 680
  goto switch_break;
  switch_default: 
#line 682
  return (18);
  switch_break: ;
#line 685
  return (error);
}
}
#line 692 "/root/patchweave_donee/23/src/flac.c"
static int flac_close(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  int k ;

  {
#line 696
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 696
  if ((unsigned long )pflac == (unsigned long )((void *)0)) {
#line 697
    return (0);
  }
#line 699
  if ((unsigned long )pflac->metadata != (unsigned long )((void *)0)) {
    {
#line 700
    FLAC__metadata_object_delete(pflac->metadata);
    }
  }
#line 702
  if (psf->file.mode == 32) {
    {
#line 703
    FLAC__stream_encoder_finish(pflac->fse);
#line 704
    FLAC__stream_encoder_delete(pflac->fse);
    }
#line 706
    if (pflac->encbuffer) {
      {
#line 707
      free((void *)pflac->encbuffer);
      }
    }
  }
#line 710
  if (psf->file.mode == 16) {
    {
#line 711
    FLAC__stream_decoder_finish(pflac->fsd);
#line 712
    FLAC__stream_decoder_delete(pflac->fsd);
    }
  }
#line 715
  k = 0;
  {
#line 715
  while (1) {
    while_continue: /* CIL Label */ ;

#line 715
    if (! (k < (int )(sizeof(pflac->rbuffer) / sizeof(pflac->rbuffer[0])))) {
#line 715
      goto while_break;
    }
    {
#line 716
    free((void *)pflac->rbuffer[k]);
#line 715
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 718
  free((void *)pflac);
#line 719
  psf->codec_data = (void *)0;
  }
#line 721
  return (0);
}
}
#line 725 "/root/patchweave_donee/23/src/flac.c"
static int flac_enc_init(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  unsigned int bps ;
  FLAC__bool __cil_tmp5 ;
  FLAC__bool __cil_tmp6 ;
  FLAC__bool __cil_tmp7 ;
  FLAC__bool __cil_tmp8 ;

  {
#line 726
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 734
  if (psf->sf.samplerate < 1) {
    {
#line 735
    psf_log_printf(psf, "flac sample rate out of range.\n", psf->sf.samplerate);
    }
#line 736
    return (157);
  } else
#line 734
  if (psf->sf.samplerate > 655350) {
    {
#line 735
    psf_log_printf(psf, "flac sample rate out of range.\n", psf->sf.samplerate);
    }
#line 736
    return (157);
  }
  {
#line 739
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 742
  if ((psf->sf.format & 65535) == 1) {
#line 742
    goto case_1;
  }
#line 745
  if ((psf->sf.format & 65535) == 2) {
#line 745
    goto case_2;
  }
#line 748
  if ((psf->sf.format & 65535) == 3) {
#line 748
    goto case_3;
  }
#line 752
  goto switch_default;
  case_1: 
#line 743
  bps = 8U;
#line 744
  goto switch_break;
  case_2: 
#line 746
  bps = 16U;
#line 747
  goto switch_break;
  case_3: 
#line 749
  bps = 24U;
#line 750
  goto switch_break;
  switch_default: 
#line 753
  bps = 0U;
#line 754
  goto switch_break;
  switch_break: ;
#line 757
  if (pflac->fse) {
    {
#line 758
    FLAC__stream_encoder_delete(pflac->fse);
    }
  }
  {
#line 759
  pflac->fse = FLAC__stream_encoder_new();
  }
#line 759
  if ((unsigned long )pflac->fse == (unsigned long )((void *)0)) {
#line 760
    return (154);
  }
  {
#line 762
  __cil_tmp5 = FLAC__stream_encoder_set_channels(pflac->fse, (uint32_t )psf->sf.channels);
  }
#line 762
  if (! __cil_tmp5) {
    {
#line 763
    psf_log_printf(psf, "FLAC__stream_encoder_set_channels (%d) return false.\n",
                   psf->sf.channels);
    }
#line 764
    return (155);
  }
  {
#line 767
  __cil_tmp6 = FLAC__stream_encoder_set_sample_rate(pflac->fse, (uint32_t )psf->sf.samplerate);
  }
#line 767
  if (! __cil_tmp6) {
    {
#line 768
    psf_log_printf(psf, "FLAC__stream_encoder_set_sample_rate (%d) returned false.\n",
                   psf->sf.samplerate);
    }
#line 769
    return (157);
  }
  {
#line 772
  __cil_tmp7 = FLAC__stream_encoder_set_bits_per_sample(pflac->fse, bps);
  }
#line 772
  if (! __cil_tmp7) {
    {
#line 773
    psf_log_printf(psf, "FLAC__stream_encoder_set_bits_per_sample (%d) return false.\n",
                   bps);
    }
#line 774
    return (155);
  }
  {
#line 777
  __cil_tmp8 = FLAC__stream_encoder_set_compression_level(pflac->fse, pflac->compression);
  }
#line 777
  if (! __cil_tmp8) {
    {
#line 778
    psf_log_printf(psf, "FLAC__stream_encoder_set_compression_level (%d) return false.\n",
                   pflac->compression);
    }
#line 779
    return (155);
  }
#line 782
  return (0);
}
}
#line 786 "/root/patchweave_donee/23/src/flac.c"
static int flac_read_header(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__StreamDecoderInitStatus __cil_tmp4 ;
  FLAC__uint64 position ;

  {
  {
#line 787
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 789
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 790
  if (pflac->fsd) {
    {
#line 791
    FLAC__stream_decoder_delete(pflac->fsd);
    }
  }
  {
#line 792
  pflac->fsd = FLAC__stream_decoder_new();
  }
#line 792
  if ((unsigned long )pflac->fsd == (unsigned long )((void *)0)) {
#line 793
    return (154);
  }
  {
#line 795
  FLAC__stream_decoder_set_metadata_respond_all(pflac->fsd);
#line 797
  __cil_tmp4 = FLAC__stream_decoder_init_stream(pflac->fsd, & sf_flac_read_callback,
                                                & sf_flac_seek_callback, & sf_flac_tell_callback,
                                                & sf_flac_length_callback, & sf_flac_eof_callback,
                                                & sf_flac_write_callback, & sf_flac_meta_callback,
                                                & sf_flac_error_callback, (void *)psf);
  }
#line 797
  if ((unsigned int )__cil_tmp4 != 0U) {
#line 798
    return (155);
  }
  {
#line 800
  FLAC__stream_decoder_process_until_end_of_metadata(pflac->fsd);
#line 802
  psf_log_printf(psf, "End\n");
  }
#line 804
  if (psf->error == 0) {
    {
#line 807
    FLAC__stream_decoder_get_decode_position(pflac->fsd, & position);
#line 808
    psf->dataoffset = (sf_count_t )position;
    }
  }
#line 811
  return (psf->error);
}
}
#line 815 "/root/patchweave_donee/23/src/flac.c"
static int flac_command(SF_PRIVATE *psf , int command , void *data , int datasize ) 
{ 
  FLAC_PRIVATE *pflac ;
  double quality ;
  long __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 816
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 820
  if (command == 4865) {
#line 820
    goto case_4865;
  }
#line 841
  goto switch_default;
  case_4865: 
#line 821
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 822
    return (0);
  } else
#line 821
  if ((unsigned long )datasize != sizeof(double )) {
#line 822
    return (0);
  }
#line 824
  if (psf->have_written) {
#line 825
    return (0);
  }
  {
#line 830
  quality = *((double *)data) * 8.;
#line 832
  __cil_tmp7 = lrint((double )0);
#line 832
  pflac->compression = (unsigned int )__cil_tmp7;
#line 834
  psf_log_printf(psf, "%s : Setting SFC_SET_COMPRESSION_LEVEL to %u.\n", "flac_command",
                 pflac->compression);
#line 836
  __cil_tmp8 = flac_enc_init(psf);
  }
#line 836
  if (__cil_tmp8) {
#line 837
    return (0);
  }
#line 839
  return (1);
  switch_default: 
#line 842
  return (0);

#line 845
  return (0);
}
}
#line 849 "/root/patchweave_donee/23/src/flac.c"
int flac_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;

  {
#line 851
  if (psf->file.mode == 48) {
#line 852
    return (24);
  }
#line 854
  if (psf->file.mode == 16) {
#line 855
    psf->read_short = & flac_read_flac2s;
#line 856
    psf->read_int = & flac_read_flac2i;
#line 857
    psf->read_float = & flac_read_flac2f;
#line 858
    psf->read_double = & flac_read_flac2d;
  }
#line 861
  if (psf->file.mode == 32) {
#line 862
    psf->write_short = & flac_write_s2flac;
#line 863
    psf->write_int = & flac_write_i2flac;
#line 864
    psf->write_float = & flac_write_f2flac;
#line 865
    psf->write_double = & flac_write_d2flac;
  }
#line 868
  if (psf->filelength > psf->dataoffset) {
#line 869
    if (psf->dataend) {
#line 869
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 869
      tmp = psf->filelength - psf->dataoffset;
    }
#line 869
    psf->datalength = tmp;
  } else {
#line 871
    psf->datalength = (sf_count_t )0;
  }
#line 873
  return (0);
}
}
#line 877 "/root/patchweave_donee/23/src/flac.c"
static unsigned int flac_read_loop(SF_PRIVATE *psf , unsigned int len ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__bool __cil_tmp4 ;
  FLAC__StreamDecoderState __cil_tmp5 ;

  {
#line 878
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 880
  pflac->pos = 0U;
#line 881
  pflac->len = len;
#line 882
  pflac->remain = len;
#line 883
  if ((unsigned long )pflac->frame != (unsigned long )((void *)0)) {
#line 883
    if (pflac->bufferpos < (pflac->frame)->header.blocksize) {
      {
#line 884
      flac_buffer_copy(psf);
      }
    }
  }
  {
#line 886
  while (1) {
    while_continue: /* CIL Label */ ;

#line 886
    if (! (pflac->pos < pflac->len)) {
#line 886
      goto while_break;
    }
    {
#line 887
    __cil_tmp4 = FLAC__stream_decoder_process_single(pflac->fsd);
    }
#line 887
    if (__cil_tmp4 == 0) {
#line 888
      goto while_break;
    }
    {
#line 889
    __cil_tmp5 = FLAC__stream_decoder_get_state(pflac->fsd);
    }
#line 889
    if ((unsigned int )__cil_tmp5 >= 4U) {
#line 890
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 893
  pflac->ptr = (void *)0;
#line 895
  return (pflac->pos);
}
}
#line 899 "/root/patchweave_donee/23/src/flac.c"
static sf_count_t flac_read_flac2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 900
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 901
  total = (sf_count_t )0;
#line 904
  pflac->pcmtype = (PFLAC_PCM )50;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;

#line 906
    if (! (total < len)) {
#line 906
      goto while_break;
    }
#line 907
    pflac->ptr = (void *)(ptr + total);
#line 908
    if (len - total > 16777216L) {
#line 908
      tmp = 16777216U;
    } else {
#line 908
      tmp = (unsigned int )(len - total);
    }
    {
#line 908
    readlen = tmp;
#line 909
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 909
    current = (sf_count_t )__cil_tmp9;
    }
#line 910
    if (current == 0L) {
#line 911
      goto while_break;
    }
#line 912
    total += current;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 915
  return (total);
}
}
#line 919 "/root/patchweave_donee/23/src/flac.c"
static sf_count_t flac_read_flac2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 920
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 921
  total = (sf_count_t )0;
#line 924
  pflac->pcmtype = (PFLAC_PCM )51;
  {
#line 926
  while (1) {
    while_continue: /* CIL Label */ ;

#line 926
    if (! (total < len)) {
#line 926
      goto while_break;
    }
#line 927
    pflac->ptr = (void *)(ptr + total);
#line 928
    if (len - total > 16777216L) {
#line 928
      tmp = 16777216U;
    } else {
#line 928
      tmp = (unsigned int )(len - total);
    }
    {
#line 928
    readlen = tmp;
#line 929
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 929
    current = (sf_count_t )__cil_tmp9;
    }
#line 930
    if (current == 0L) {
#line 931
      goto while_break;
    }
#line 932
    total += current;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 935
  return (total);
}
}
#line 939 "/root/patchweave_donee/23/src/flac.c"
static sf_count_t flac_read_flac2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 940
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 941
  total = (sf_count_t )0;
#line 944
  pflac->pcmtype = (PFLAC_PCM )52;
  {
#line 946
  while (1) {
    while_continue: /* CIL Label */ ;

#line 946
    if (! (total < len)) {
#line 946
      goto while_break;
    }
#line 947
    pflac->ptr = (void *)(ptr + total);
#line 948
    if (len - total > 16777216L) {
#line 948
      tmp = 16777216U;
    } else {
#line 948
      tmp = (unsigned int )(len - total);
    }
    {
#line 948
    readlen = tmp;
#line 949
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 949
    current = (sf_count_t )__cil_tmp9;
    }
#line 950
    if (current == 0L) {
#line 951
      goto while_break;
    }
#line 952
    total += current;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 955
  return (total);
}
}
#line 959 "/root/patchweave_donee/23/src/flac.c"
static sf_count_t flac_read_flac2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 960
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 961
  total = (sf_count_t )0;
#line 964
  pflac->pcmtype = (PFLAC_PCM )53;
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;

#line 966
    if (! (total < len)) {
#line 966
      goto while_break;
    }
#line 967
    pflac->ptr = (void *)(ptr + total);
#line 968
    if (len - total > 16777216L) {
#line 968
      tmp = 16777216U;
    } else {
#line 968
      tmp = (unsigned int )(len - total);
    }
    {
#line 968
    readlen = tmp;
#line 969
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 969
    current = (sf_count_t )__cil_tmp9;
    }
#line 970
    if (current == 0L) {
#line 971
      goto while_break;
    }
#line 972
    total += current;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 975
  return (total);
}
}
#line 979 "/root/patchweave_donee/23/src/flac.c"
static sf_count_t flac_write_s2flac(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(short const   * , FLAC__int32 * , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  FLAC__int32 *buffer ;
  int tmp ;
  FLAC__bool __cil_tmp12 ;

  {
#line 980
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 983
  total = (sf_count_t )0;
#line 984
  buffer = pflac->encbuffer;
#line 987
  if ((psf->sf.format & 65535) == 1) {
#line 987
    goto case_1;
  }
#line 990
  if ((psf->sf.format & 65535) == 2) {
#line 990
    goto case_2;
  }
#line 993
  if ((psf->sf.format & 65535) == 3) {
#line 993
    goto case_3;
  }
#line 996
  goto switch_default;
  case_1: 
#line 988
  convert = & s2flac8_array;
#line 989
  goto switch_break;
  case_2: 
#line 991
  convert = & s2flac16_array;
#line 992
  goto switch_break;
  case_3: 
#line 994
  convert = & s2flac24_array;
#line 995
  goto switch_break;
  switch_default: 
#line 997
  return ((sf_count_t )-1);
  switch_break: 
#line 1000
  bufferlen = (int )(8192UL / (sizeof(FLAC__int32 ) * (unsigned long )psf->sf.channels));
#line 1001
  bufferlen *= psf->sf.channels;
  {
#line 1003
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1003
    if (! (len > 0L)) {
#line 1003
      goto while_break;
    }
#line 1004
    if (len >= (long )bufferlen) {
#line 1004
      tmp = bufferlen;
    } else {
#line 1004
      tmp = (int )len;
    }
    {
#line 1004
    writecount = tmp;
#line 1005
    (*convert)(ptr + total, buffer, writecount);
#line 1006
    __cil_tmp12 = FLAC__stream_encoder_process_interleaved(pflac->fse, buffer, (uint32_t )(writecount / psf->sf.channels));
    }
#line 1006
    if (__cil_tmp12) {
#line 1007
      thiswrite = writecount;
    } else {
#line 1009
      goto while_break;
    }
#line 1010
    total += (long )thiswrite;
#line 1011
    if (thiswrite < writecount) {
#line 1012
      goto while_break;
    }
#line 1014
    len -= (long )thiswrite;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1017
  return (total);
}
}
#line 1021 "/root/patchweave_donee/23/src/flac.c"
static sf_count_t flac_write_i2flac(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(int const   * , FLAC__int32 * , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  FLAC__int32 *buffer ;
  int tmp ;
  FLAC__bool __cil_tmp12 ;

  {
#line 1022
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1025
  total = (sf_count_t )0;
#line 1026
  buffer = pflac->encbuffer;
#line 1029
  if ((psf->sf.format & 65535) == 1) {
#line 1029
    goto case_1;
  }
#line 1032
  if ((psf->sf.format & 65535) == 2) {
#line 1032
    goto case_2;
  }
#line 1035
  if ((psf->sf.format & 65535) == 3) {
#line 1035
    goto case_3;
  }
#line 1038
  goto switch_default;
  case_1: 
#line 1030
  convert = & i2flac8_array;
#line 1031
  goto switch_break;
  case_2: 
#line 1033
  convert = & i2flac16_array;
#line 1034
  goto switch_break;
  case_3: 
#line 1036
  convert = & i2flac24_array;
#line 1037
  goto switch_break;
  switch_default: 
#line 1039
  return ((sf_count_t )-1);
  switch_break: 
#line 1042
  bufferlen = (int )(8192UL / (sizeof(FLAC__int32 ) * (unsigned long )psf->sf.channels));
#line 1043
  bufferlen *= psf->sf.channels;
  {
#line 1045
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1045
    if (! (len > 0L)) {
#line 1045
      goto while_break;
    }
#line 1046
    if (len >= (long )bufferlen) {
#line 1046
      tmp = bufferlen;
    } else {
#line 1046
      tmp = (int )len;
    }
    {
#line 1046
    writecount = tmp;
#line 1047
    (*convert)(ptr + total, buffer, writecount);
#line 1048
    __cil_tmp12 = FLAC__stream_encoder_process_interleaved(pflac->fse, buffer, (uint32_t )(writecount / psf->sf.channels));
    }
#line 1048
    if (__cil_tmp12) {
#line 1049
      thiswrite = writecount;
    } else {
#line 1051
      goto while_break;
    }
#line 1052
    total += (long )thiswrite;
#line 1053
    if (thiswrite < writecount) {
#line 1054
      goto while_break;
    }
#line 1056
    len -= (long )thiswrite;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1059
  return (total);
}
}
#line 1063 "/root/patchweave_donee/23/src/flac.c"
static sf_count_t flac_write_f2flac(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(float const   * , FLAC__int32 * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  FLAC__int32 *buffer ;
  void (*tmp)(float const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  void (*tmp___0)(float const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  void (*tmp___1)(float const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  int tmp___2 ;
  FLAC__bool __cil_tmp15 ;

  {
#line 1064
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1067
  total = (sf_count_t )0;
#line 1068
  buffer = pflac->encbuffer;
#line 1071
  if ((psf->sf.format & 65535) == 1) {
#line 1071
    goto case_1;
  }
#line 1074
  if ((psf->sf.format & 65535) == 2) {
#line 1074
    goto case_2;
  }
#line 1077
  if ((psf->sf.format & 65535) == 3) {
#line 1077
    goto case_3;
  }
#line 1080
  goto switch_default;
  case_1: 
#line 1072
  if (psf->add_clipping) {
#line 1072
    tmp = & f2flac8_clip_array;
  } else {
#line 1072
    tmp = & f2flac8_array;
  }
#line 1072
  convert = tmp;
#line 1073
  goto switch_break;
  case_2: 
#line 1075
  if (psf->add_clipping) {
#line 1075
    tmp___0 = & f2flac16_clip_array;
  } else {
#line 1075
    tmp___0 = & f2flac16_array;
  }
#line 1075
  convert = tmp___0;
#line 1076
  goto switch_break;
  case_3: 
#line 1078
  if (psf->add_clipping) {
#line 1078
    tmp___1 = & f2flac24_clip_array;
  } else {
#line 1078
    tmp___1 = & f2flac24_array;
  }
#line 1078
  convert = tmp___1;
#line 1079
  goto switch_break;
  switch_default: 
#line 1081
  return ((sf_count_t )-1);
  switch_break: 
#line 1084
  bufferlen = (int )(8192UL / (sizeof(FLAC__int32 ) * (unsigned long )psf->sf.channels));
#line 1085
  bufferlen *= psf->sf.channels;
  {
#line 1087
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1087
    if (! (len > 0L)) {
#line 1087
      goto while_break;
    }
#line 1088
    if (len >= (long )bufferlen) {
#line 1088
      tmp___2 = bufferlen;
    } else {
#line 1088
      tmp___2 = (int )len;
    }
    {
#line 1088
    writecount = tmp___2;
#line 1089
    (*convert)(ptr + total, buffer, writecount, psf->norm_float);
#line 1090
    __cil_tmp15 = FLAC__stream_encoder_process_interleaved(pflac->fse, buffer, (uint32_t )(writecount / psf->sf.channels));
    }
#line 1090
    if (__cil_tmp15) {
#line 1091
      thiswrite = writecount;
    } else {
#line 1093
      goto while_break;
    }
#line 1094
    total += (long )thiswrite;
#line 1095
    if (thiswrite < writecount) {
#line 1096
      goto while_break;
    }
#line 1098
    len -= (long )thiswrite;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1101
  return (total);
}
}
#line 1105 "/root/patchweave_donee/23/src/flac.c"
static void f2flac8_clip_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                               int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1108
  if (normalize) {
#line 1108
    tmp = 8. * (double )16;
  } else {
#line 1108
    tmp = 1.;
  }
#line 1108
  normfact = (float )tmp;
  {
#line 1110
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1110
    count___0 --;
#line 1110
    if (! (count___0 >= 0)) {
#line 1110
      goto while_break;
    }
#line 1111
    scaled_value = (float )(*(src + count___0) * (float const   )normfact);
#line 1112
    if ((double )scaled_value >= 1. * (double )127) {
#line 1113
      *(dest + count___0) = 127;
#line 1114
      goto while_continue;
    }
#line 1116
    if ((double )scaled_value <= - 8. * (double )16) {
#line 1117
      *(dest + count___0) = 128;
#line 1118
      goto while_continue;
    }
    {
#line 1120
    __cil_tmp8 = lrintf(scaled_value);
#line 1120
    *(dest + count___0) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1123
  return;
}
}
#line 1127 "/root/patchweave_donee/23/src/flac.c"
static void f2flac16_clip_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                                int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1130
  if (normalize) {
#line 1130
    tmp = 8. * (double )4096;
  } else {
#line 1130
    tmp = 1.;
  }
#line 1130
  normfact = (float )tmp;
  {
#line 1132
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1132
    count___0 --;
#line 1132
    if (! (count___0 >= 0)) {
#line 1132
      goto while_break;
    }
#line 1133
    scaled_value = (float )(*(src + count___0) * (float const   )normfact);
#line 1134
    if ((double )scaled_value >= 1. * (double )32767) {
#line 1135
      *(dest + count___0) = 32767;
#line 1136
      goto while_continue;
    }
#line 1138
    if ((double )scaled_value <= - 8. * (double )4096) {
#line 1139
      *(dest + count___0) = 32768;
#line 1140
      goto while_continue;
    }
    {
#line 1142
    __cil_tmp8 = lrintf(scaled_value);
#line 1142
    *(dest + count___0) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1148
  return;
}
}
#line 1147 "/root/patchweave_donee/23/src/flac.c"
static void f2flac24_clip_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                                int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1150
  if (normalize) {
#line 1150
    tmp = 8. * (double )1048576;
  } else {
#line 1150
    tmp = 1.;
  }
#line 1150
  normfact = (float )tmp;
  {
#line 1152
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1152
    count___0 --;
#line 1152
    if (! (count___0 >= 0)) {
#line 1152
      goto while_break;
    }
#line 1153
    scaled_value = (float )(*(src + count___0) * (float const   )normfact);
#line 1154
    if ((double )scaled_value >= 1. * (double )8388607) {
#line 1155
      *(dest + count___0) = 8388607;
#line 1156
      goto while_continue;
    }
#line 1159
    if ((double )scaled_value <= - 8. * (double )1048576) {
#line 1160
      *(dest + count___0) = 8388608;
#line 1161
      goto while_continue;
    }
    {
#line 1163
    __cil_tmp8 = lrintf(scaled_value);
#line 1163
    *(dest + count___0) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1166
  return;
}
}
#line 1170 "/root/patchweave_donee/23/src/flac.c"
static void f2flac8_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                          int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1171
  if (normalize) {
#line 1171
    tmp = 1. * (double )127;
  } else {
#line 1171
    tmp = 1.;
  }
#line 1171
  normfact = (float )tmp;
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    count___0 --;
#line 1173
    if (! (count___0 >= 0)) {
#line 1173
      goto while_break;
    }
    {
#line 1174
    __cil_tmp7 = lrintf((float )(*(src + count___0) * (float const   )normfact));
#line 1174
    *(dest + count___0) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1179
  return;
}
}
#line 1178 "/root/patchweave_donee/23/src/flac.c"
static void f2flac16_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                           int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1179
  if (normalize) {
#line 1179
    tmp = 1. * (double )32767;
  } else {
#line 1179
    tmp = 1.;
  }
#line 1179
  normfact = (float )tmp;
  {
#line 1181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1181
    count___0 --;
#line 1181
    if (! (count___0 >= 0)) {
#line 1181
      goto while_break;
    }
    {
#line 1182
    __cil_tmp7 = lrintf((float )(*(src + count___0) * (float const   )normfact));
#line 1182
    *(dest + count___0) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1187
  return;
}
}
#line 1186 "/root/patchweave_donee/23/src/flac.c"
static void f2flac24_array(float const   *src , FLAC__int32 *dest , int count___0 ,
                           int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1187
  if (normalize) {
#line 1187
    tmp = 1. * (double )8388607;
  } else {
#line 1187
    tmp = 1.;
  }
#line 1187
  normfact = (float )tmp;
  {
#line 1189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1189
    count___0 --;
#line 1189
    if (! (count___0 >= 0)) {
#line 1189
      goto while_break;
    }
    {
#line 1190
    __cil_tmp7 = lrintf((float )(*(src + count___0) * (float const   )normfact));
#line 1190
    *(dest + count___0) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1195
  return;
}
}
#line 1194 "/root/patchweave_donee/23/src/flac.c"
static sf_count_t flac_write_d2flac(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(double const   * , FLAC__int32 * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  FLAC__int32 *buffer ;
  void (*tmp)(double const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  void (*tmp___0)(double const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  void (*tmp___1)(double const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  int tmp___2 ;
  FLAC__bool __cil_tmp15 ;

  {
#line 1195
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1198
  total = (sf_count_t )0;
#line 1199
  buffer = pflac->encbuffer;
#line 1202
  if ((psf->sf.format & 65535) == 1) {
#line 1202
    goto case_1;
  }
#line 1205
  if ((psf->sf.format & 65535) == 2) {
#line 1205
    goto case_2;
  }
#line 1208
  if ((psf->sf.format & 65535) == 3) {
#line 1208
    goto case_3;
  }
#line 1211
  goto switch_default;
  case_1: 
#line 1203
  if (psf->add_clipping) {
#line 1203
    tmp = & d2flac8_clip_array;
  } else {
#line 1203
    tmp = & d2flac8_array;
  }
#line 1203
  convert = tmp;
#line 1204
  goto switch_break;
  case_2: 
#line 1206
  if (psf->add_clipping) {
#line 1206
    tmp___0 = & d2flac16_clip_array;
  } else {
#line 1206
    tmp___0 = & d2flac16_array;
  }
#line 1206
  convert = tmp___0;
#line 1207
  goto switch_break;
  case_3: 
#line 1209
  if (psf->add_clipping) {
#line 1209
    tmp___1 = & d2flac24_clip_array;
  } else {
#line 1209
    tmp___1 = & d2flac24_array;
  }
#line 1209
  convert = tmp___1;
#line 1210
  goto switch_break;
  switch_default: 
#line 1212
  return ((sf_count_t )-1);
  switch_break: 
#line 1215
  bufferlen = (int )(8192UL / (sizeof(FLAC__int32 ) * (unsigned long )psf->sf.channels));
#line 1216
  bufferlen *= psf->sf.channels;
  {
#line 1218
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1218
    if (! (len > 0L)) {
#line 1218
      goto while_break;
    }
#line 1219
    if (len >= (long )bufferlen) {
#line 1219
      tmp___2 = bufferlen;
    } else {
#line 1219
      tmp___2 = (int )len;
    }
    {
#line 1219
    writecount = tmp___2;
#line 1220
    (*convert)(ptr + total, buffer, writecount, psf->norm_double);
#line 1221
    __cil_tmp15 = FLAC__stream_encoder_process_interleaved(pflac->fse, buffer, (uint32_t )(writecount / psf->sf.channels));
    }
#line 1221
    if (__cil_tmp15) {
#line 1222
      thiswrite = writecount;
    } else {
#line 1224
      goto while_break;
    }
#line 1225
    total += (long )thiswrite;
#line 1226
    if (thiswrite < writecount) {
#line 1227
      goto while_break;
    }
#line 1229
    len -= (long )thiswrite;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1232
  return (total);
}
}
#line 1236 "/root/patchweave_donee/23/src/flac.c"
static void d2flac8_clip_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                               int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1239
  if (normalize) {
#line 1239
    tmp = 8. * (double )16;
  } else {
#line 1239
    tmp = 1.;
  }
#line 1239
  normfact = tmp;
  {
#line 1241
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1241
    count___0 --;
#line 1241
    if (! (count___0 >= 0)) {
#line 1241
      goto while_break;
    }
#line 1242
    scaled_value = (double )(*(src + count___0) * (double const   )normfact);
#line 1243
    if (scaled_value >= 1. * (double )127) {
#line 1244
      *(dest + count___0) = 127;
#line 1245
      goto while_continue;
    }
#line 1247
    if (scaled_value <= - 8. * (double )16) {
#line 1248
      *(dest + count___0) = 128;
#line 1249
      goto while_continue;
    }
    {
#line 1251
    __cil_tmp8 = lrint(scaled_value);
#line 1251
    *(dest + count___0) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1254
  return;
}
}
#line 1258 "/root/patchweave_donee/23/src/flac.c"
static void d2flac16_clip_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                                int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1261
  if (normalize) {
#line 1261
    tmp = 8. * (double )4096;
  } else {
#line 1261
    tmp = 1.;
  }
#line 1261
  normfact = tmp;
  {
#line 1263
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1263
    count___0 --;
#line 1263
    if (! (count___0 >= 0)) {
#line 1263
      goto while_break;
    }
#line 1264
    scaled_value = (double )(*(src + count___0) * (double const   )normfact);
#line 1265
    if (scaled_value >= 1. * (double )32767) {
#line 1266
      *(dest + count___0) = 32767;
#line 1267
      goto while_continue;
    }
#line 1269
    if (scaled_value <= - 8. * (double )4096) {
#line 1270
      *(dest + count___0) = 32768;
#line 1271
      goto while_continue;
    }
    {
#line 1273
    __cil_tmp8 = lrint(scaled_value);
#line 1273
    *(dest + count___0) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1276
  return;
}
}
#line 1280 "/root/patchweave_donee/23/src/flac.c"
static void d2flac24_clip_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                                int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1283
  if (normalize) {
#line 1283
    tmp = 8. * (double )1048576;
  } else {
#line 1283
    tmp = 1.;
  }
#line 1283
  normfact = tmp;
  {
#line 1285
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
#line 1285
    count___0 --;
#line 1285
    if (! (count___0 >= 0)) {
#line 1285
      goto while_break;
    }
#line 1286
    scaled_value = (double )(*(src + count___0) * (double const   )normfact);
#line 1287
    if (scaled_value >= 1. * (double )8388607) {
#line 1288
      *(dest + count___0) = 8388607;
#line 1289
      goto while_continue;
    }
#line 1291
    if (scaled_value <= - 8. * (double )1048576) {
#line 1292
      *(dest + count___0) = 8388608;
#line 1293
      goto while_continue;
    }
    {
#line 1295
    __cil_tmp8 = lrint(scaled_value);
#line 1295
    *(dest + count___0) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1298
  return;
}
}
#line 1302 "/root/patchweave_donee/23/src/flac.c"
static void d2flac8_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                          int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1303
  if (normalize) {
#line 1303
    tmp = 1. * (double )127;
  } else {
#line 1303
    tmp = 1.;
  }
#line 1303
  normfact = tmp;
  {
#line 1305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1305
    count___0 --;
#line 1305
    if (! (count___0 >= 0)) {
#line 1305
      goto while_break;
    }
    {
#line 1306
    __cil_tmp7 = lrint((double )(*(src + count___0) * (double const   )normfact));
#line 1306
    *(dest + count___0) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1311
  return;
}
}
#line 1310 "/root/patchweave_donee/23/src/flac.c"
static void d2flac16_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                           int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1311
  if (normalize) {
#line 1311
    tmp = 1. * (double )32767;
  } else {
#line 1311
    tmp = 1.;
  }
#line 1311
  normfact = tmp;
  {
#line 1313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1313
    count___0 --;
#line 1313
    if (! (count___0 >= 0)) {
#line 1313
      goto while_break;
    }
    {
#line 1314
    __cil_tmp7 = lrint((double )(*(src + count___0) * (double const   )normfact));
#line 1314
    *(dest + count___0) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1319
  return;
}
}
#line 1318 "/root/patchweave_donee/23/src/flac.c"
static void d2flac24_array(double const   *src , FLAC__int32 *dest , int count___0 ,
                           int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1319
  if (normalize) {
#line 1319
    tmp = 1. * (double )8388607;
  } else {
#line 1319
    tmp = 1.;
  }
#line 1319
  normfact = tmp;
  {
#line 1321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1321
    count___0 --;
#line 1321
    if (! (count___0 >= 0)) {
#line 1321
      goto while_break;
    }
    {
#line 1322
    __cil_tmp7 = lrint((double )(*(src + count___0) * (double const   )normfact));
#line 1322
    *(dest + count___0) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1327
  return;
}
}
#line 1326 "/root/patchweave_donee/23/src/flac.c"
static sf_count_t flac_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__bool __cil_tmp5 ;

  {
#line 1327
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1329
  if ((unsigned long )pflac == (unsigned long )((void *)0)) {
#line 1330
    return ((sf_count_t )0);
  }
#line 1332
  if (psf->dataoffset < 0L) {
#line 1333
    psf->error = 39;
#line 1334
    return ((sf_count_t )-1);
  }
#line 1337
  pflac->frame = (FLAC__Frame *)((void *)0);
#line 1339
  if (psf->file.mode == 16) {
    {
#line 1340
    __cil_tmp5 = FLAC__stream_decoder_seek_absolute(pflac->fsd, (FLAC__uint64 )offset);
    }
#line 1340
    if (__cil_tmp5) {
#line 1341
      return (offset);
    }
#line 1343
    if (offset == psf->sf.frames) {
#line 1349
      return (offset);
    }
#line 1352
    psf->error = 39;
#line 1353
    return ((sf_count_t )-1);
  }
#line 1357
  psf->error = 39;
#line 1359
  return ((sf_count_t )-1);
}
}
#line 1363 "/root/patchweave_donee/23/src/flac.c"
static int flac_byterate(SF_PRIVATE *psf ) 
{ 


  {
#line 1365
  if (psf->file.mode == 16) {
#line 1366
    return ((int )((psf->datalength * (long )psf->sf.samplerate) / psf->sf.frames));
  }
#line 1368
  return (-1);
}
}
#line 33 "/root/patchweave_donee/23/src/dwd.c"
int dwd_open(SF_PRIVATE *psf ) 
{ 


  {
#line 34
  if (psf) {
#line 35
    return (18);
  }
#line 36
  return (0);
}
}
#line 97 "/root/patchweave_donee/23/src/caf.c"
static int caf_close(SF_PRIVATE *psf ) ;
#line 98
static int caf_read_header(SF_PRIVATE *psf ) ;
#line 99
static int caf_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 100
static int caf_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int UNUSED_datasize ) ;
#line 101
static int caf_read_chanmap(SF_PRIVATE *psf , sf_count_t chunk_size ) ;
#line 103
static int caf_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) ;
#line 104
static SF_CHUNK_ITERATOR *caf_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) ;
#line 105
static int caf_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 106
static int caf_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 113 "/root/patchweave_donee/23/src/caf.c"
int caf_open(SF_PRIVATE *psf ) 
{ 
  CAF_PRIVATE *pcaf ;
  int subformat ;
  int format ;
  int error ;

  {
  {
#line 115
  error = 0;
#line 117
  psf->container_data = calloc(1UL, sizeof(CAF_PRIVATE ));
  }
#line 117
  if ((unsigned long )psf->container_data == (unsigned long )((void *)0)) {
#line 118
    return (17);
  }
#line 120
  pcaf = (CAF_PRIVATE *)psf->container_data;
#line 122
  if (psf->file.mode == 16) {
    _L: 
    {
#line 123
    error = caf_read_header(psf);
    }
#line 123
    if (error) {
#line 124
      return (error);
    }
#line 126
    psf->next_chunk_iterator = & caf_next_chunk_iterator;
#line 127
    psf->get_chunk_size = & caf_get_chunk_size;
#line 128
    psf->get_chunk_data = & caf_get_chunk_data;
  } else
#line 122
  if (psf->file.mode == 48) {
#line 122
    if (psf->filelength > 0L) {
#line 122
      goto _L;
    }
  }
#line 131
  subformat = psf->sf.format & 65535;
#line 133
  if (psf->file.mode == 32) {
    _L___39: 
#line 134
    if (psf->is_pipe) {
#line 135
      return (29);
    }
#line 137
    format = psf->sf.format & 268369920;
#line 138
    if (format != 1572864) {
#line 139
      return (1);
    }
#line 141
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 143
    if (psf->file.mode != 48) {
#line 144
      psf->filelength = (sf_count_t )0;
#line 145
      psf->datalength = (sf_count_t )0;
#line 146
      psf->dataoffset = (sf_count_t )0;
#line 147
      psf->sf.frames = (sf_count_t )0;
    } else
#line 143
    if (psf->filelength < 44L) {
#line 144
      psf->filelength = (sf_count_t )0;
#line 145
      psf->datalength = (sf_count_t )0;
#line 146
      psf->dataoffset = (sf_count_t )0;
#line 147
      psf->sf.frames = (sf_count_t )0;
    }
#line 150
    psf->strings.flags = (uint32_t )256;
#line 156
    if (psf->file.mode == 32) {
#line 156
      if (subformat == 6) {
        _L___38: 
        {
#line 157
        psf->peak_info = peak_info_calloc(psf->sf.channels);
        }
#line 157
        if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 158
          return (17);
        }
#line 159
        (psf->peak_info)->peak_loc = 42;
      } else
#line 156
      if (subformat == 7) {
#line 156
        goto _L___38;
      }
    }
    {
#line 162
    error = caf_write_header(psf, 0);
    }
#line 162
    if (error != 0) {
#line 163
      return (error);
    }
#line 165
    psf->write_header = & caf_write_header;
#line 166
    psf->set_chunk = & caf_set_chunk;
  } else
#line 133
  if (psf->file.mode == 48) {
#line 133
    goto _L___39;
  }
#line 169
  psf->container_close = & caf_close;
#line 170
  psf->command = & caf_command;
#line 176
  if (subformat == 4) {
#line 176
    goto case_4;
  }
#line 176
  if (subformat == 3) {
#line 176
    goto case_4;
  }
#line 176
  if (subformat == 2) {
#line 176
    goto case_4;
  }
#line 176
  if (subformat == 1) {
#line 176
    goto case_4;
  }
#line 180
  if (subformat == 16) {
#line 180
    goto case_16;
  }
#line 184
  if (subformat == 17) {
#line 184
    goto case_17;
  }
#line 189
  if (subformat == 6) {
#line 189
    goto case_6;
  }
#line 193
  if (subformat == 7) {
#line 193
    goto case_7;
  }
#line 200
  if (subformat == 115) {
#line 200
    goto case_115;
  }
#line 200
  if (subformat == 114) {
#line 200
    goto case_115;
  }
#line 200
  if (subformat == 113) {
#line 200
    goto case_115;
  }
#line 200
  if (subformat == 112) {
#line 200
    goto case_115;
  }
#line 210
  goto switch_default;
  case_4: 
  {
#line 177
  error = pcm_init(psf);
  }
#line 178
  goto switch_break;
  case_16: 
  {
#line 181
  error = ulaw_init(psf);
  }
#line 182
  goto switch_break;
  case_17: 
  {
#line 185
  error = alaw_init(psf);
  }
#line 186
  goto switch_break;
  case_6: 
  {
#line 190
  error = float32_init(psf);
  }
#line 191
  goto switch_break;
  case_7: 
  {
#line 194
  error = double64_init(psf);
  }
#line 195
  goto switch_break;
  case_115: 
#line 201
  if (psf->file.mode == 16) {
    {
#line 203
    error = alac_init(psf, & pcaf->alac);
    }
  } else {
    {
#line 205
    error = alac_init(psf, (ALAC_DECODER_INFO *)((void *)0));
    }
  }
#line 206
  goto switch_break;
  switch_default: 
#line 211
  return (4);
  switch_break: ;
#line 214
  return (error);
}
}
#line 218 "/root/patchweave_donee/23/src/caf.c"
static int caf_close(SF_PRIVATE *psf ) 
{ 


  {
#line 220
  if (psf->file.mode == 32) {
    {
#line 221
    caf_write_header(psf, 1);
    }
  } else
#line 220
  if (psf->file.mode == 48) {
    {
#line 221
    caf_write_header(psf, 1);
    }
  }
#line 223
  return (0);
}
}
#line 227 "/root/patchweave_donee/23/src/caf.c"
static int caf_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int UNUSED_datasize ) 
{ 
  CAF_PRIVATE *pcaf ;

  {
#line 230
  pcaf = (CAF_PRIVATE *)psf->container_data;
#line 230
  if ((unsigned long )pcaf == (unsigned long )((void *)0)) {
#line 231
    return (30);
  }
#line 234
  if (command == 4353) {
#line 234
    goto case_4353;
  }
#line 238
  goto switch_default;
  case_4353: 
  {
#line 235
  pcaf->chanmap_tag = aiff_caf_find_channel_layout_tag((int const   *)psf->channel_map,
                                                       psf->sf.channels);
  }
#line 236
  return (pcaf->chanmap_tag != 0);
  switch_default: 
#line 239
  goto switch_break;
  switch_break: ;
#line 242
  return (0);
}
}
#line 249 "/root/patchweave_donee/23/src/caf.c"
static int decode_desc_chunk(SF_PRIVATE *psf , DESC_CHUNK *desc ) 
{ 
  int format ;
  CAF_PRIVATE *pcaf ;
  int tmp ;

  {
#line 250
  format = 1572864;
#line 252
  psf->sf.channels = (int )desc->channels_per_frame;
#line 254
  if (desc->fmt_id == ((unsigned int )((97 | (108 << 8)) | (97 << 16)) | (99U << 24))) {
#line 257
    pcaf = (CAF_PRIVATE *)psf->container_data;
#line 257
    if ((unsigned long )pcaf != (unsigned long )((void *)0)) {
#line 259
      if (desc->fmt_flags == 1U) {
#line 259
        goto case_1;
      }
#line 263
      if (desc->fmt_flags == 2U) {
#line 263
        goto case_2;
      }
#line 267
      if (desc->fmt_flags == 3U) {
#line 267
        goto case_3;
      }
#line 271
      if (desc->fmt_flags == 4U) {
#line 271
        goto case_4;
      }
#line 275
      goto switch_default;
      case_1: 
#line 260
      pcaf->alac.bits_per_sample = 16U;
#line 261
      format |= 112;
#line 262
      goto switch_break;
      case_2: 
#line 264
      pcaf->alac.bits_per_sample = 20U;
#line 265
      format |= 113;
#line 266
      goto switch_break;
      case_3: 
#line 268
      pcaf->alac.bits_per_sample = 24U;
#line 269
      format |= 114;
#line 270
      goto switch_break;
      case_4: 
#line 272
      pcaf->alac.bits_per_sample = 32U;
#line 273
      format |= 115;
#line 274
      goto switch_break;
      switch_default: 
      {
#line 276
      psf_log_printf(psf, "Bad ALAC format flag value of %d\n", desc->fmt_flags);
      }
      switch_break: 
#line 279
      pcaf->alac.frames_per_packet = desc->frames_per_packet;
    }
#line 282
    return (format);
  }
#line 285
  if (psf->endian == 268435456) {
#line 285
    tmp = 268435456;
  } else {
#line 285
    tmp = 0;
  }
#line 285
  format |= tmp;
#line 287
  if (desc->fmt_id == ((unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24))) {
#line 287
    if (desc->fmt_flags & 1U) {
#line 289
      if (desc->bits_per_chan == 32U) {
#line 289
        if (desc->pkt_bytes == 4U * desc->channels_per_frame) {
#line 290
          psf->bytewidth = 4;
#line 291
          return (format | 6);
        }
      }
#line 293
      if (desc->bits_per_chan == 64U) {
#line 293
        if (desc->pkt_bytes == 8U * desc->channels_per_frame) {
#line 294
          psf->bytewidth = 8;
#line 295
          return (format | 7);
        }
      }
    }
  }
#line 299
  if (desc->fmt_id == ((unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24))) {
#line 299
    if ((desc->fmt_flags & 1U) == 0U) {
#line 301
      if (desc->bits_per_chan == 32U) {
#line 301
        if (desc->pkt_bytes == 4U * desc->channels_per_frame) {
#line 302
          psf->bytewidth = 4;
#line 303
          return (format | 4);
        }
      }
#line 305
      if (desc->bits_per_chan == 24U) {
#line 305
        if (desc->pkt_bytes == 3U * desc->channels_per_frame) {
#line 306
          psf->bytewidth = 3;
#line 307
          return (format | 3);
        }
      }
#line 309
      if (desc->bits_per_chan == 16U) {
#line 309
        if (desc->pkt_bytes == 2U * desc->channels_per_frame) {
#line 310
          psf->bytewidth = 2;
#line 311
          return (format | 2);
        }
      }
#line 313
      if (desc->bits_per_chan == 8U) {
#line 313
        if (desc->pkt_bytes == desc->channels_per_frame) {
#line 314
          psf->bytewidth = 1;
#line 315
          return (format | 1);
        }
      }
    }
  }
#line 319
  if (desc->fmt_id == ((unsigned int )((97 | (108 << 8)) | (97 << 16)) | (119U << 24))) {
#line 319
    if (desc->bits_per_chan == 8U) {
#line 320
      psf->bytewidth = 1;
#line 321
      return (format | 17);
    }
  }
#line 324
  if (desc->fmt_id == ((unsigned int )((117 | (108 << 8)) | (97 << 16)) | (119U << 24))) {
#line 324
    if (desc->bits_per_chan == 8U) {
#line 325
      psf->bytewidth = 1;
#line 326
      return (format | 16);
    }
  }
  {
#line 329
  psf_log_printf(psf, "**** Unknown format identifier.\n\220");
  }
#line 331
  return (0);
}
}
#line 335 "/root/patchweave_donee/23/src/caf.c"
static int caf_read_header(SF_PRIVATE *psf ) 
{ 
  CAF_PRIVATE *pcaf ;
  BUF_UNION ubuf ;
  DESC_CHUNK desc ;
  sf_count_t chunk_size ;
  double srate ;
  short version ;
  short flags ;
  int marker ;
  int k ;
  int have_data ;
  int error ;
  long __cil_tmp14 ;
  sf_count_t pos ;
  sf_count_t __cil_tmp16 ;
  sf_count_t __cil_tmp17 ;
  size_t __cil_tmp18 ;
  sf_count_t position ;
  float value___0 ;
  size_t __cil_tmp23 ;
  size_t __cil_tmp25 ;
  size_t __cil_tmp26 ;
  sf_count_t __cil_tmp27 ;
  size_t __cil_tmp28 ;
  sf_count_t __cil_tmp29 ;
  size_t __cil_tmp30 ;
  size_t __cil_tmp31 ;
  sf_count_t __cil_tmp32 ;
  int tmp ;

  {
#line 342
  have_data = 0;
#line 344
  pcaf = (CAF_PRIVATE *)psf->container_data;
#line 344
  if ((unsigned long )pcaf == (unsigned long )((void *)0)) {
#line 345
    return (30);
  }
  {
#line 347
  memset((void *)(& desc), 0, sizeof(desc));
#line 350
  psf_binheader_readf(psf, "pmE2E2", 0, & marker, & version, & flags);
#line 351
  psf_log_printf(psf, "%M\n  Version : %d\n  Flags   : %x\n\371J\333\204U", marker,
                 (int )version, (int )flags);
  }
#line 352
  if ((unsigned int )marker != ((unsigned int )((99 | (97 << 8)) | (102 << 16)) | (102U << 24))) {
#line 353
    return (666);
  }
  {
#line 355
  psf_binheader_readf(psf, "mE8b", & marker, & chunk_size, ubuf.ucbuf, 8);
#line 356
  srate = double64_be_read((unsigned char const   *)(ubuf.ucbuf));
#line 357
  snprintf(ubuf.cbuf, sizeof(ubuf.cbuf), "%5.3f", srate);
#line 358
  psf_log_printf(psf, "%M : %D\n  Sample rate  : %s\n\204U", marker, chunk_size, ubuf.cbuf);
  }
#line 359
  if ((unsigned int )marker != ((unsigned int )((100 | (101 << 8)) | (115 << 16)) | (99U << 24))) {
#line 360
    return (667);
  }
#line 362
  if (chunk_size < (long )((int )sizeof(DESC_CHUNK ))) {
    {
#line 363
    psf_log_printf(psf, "**** Chunk size too small. Should be > 32 bytes.\n");
    }
#line 364
    return (3);
  }
  {
#line 367
  __cil_tmp14 = lrint(srate);
#line 367
  psf->sf.samplerate = (int )__cil_tmp14;
#line 369
  psf_binheader_readf(psf, "mE44444", & desc.fmt_id, & desc.fmt_flags, & desc.pkt_bytes,
                      & desc.frames_per_packet, & desc.channels_per_frame, & desc.bits_per_chan);
#line 371
  psf_log_printf(psf, "  Format id    : %M\n  Format flags : %x\n  Bytes / packet   : %u\n  Frames / packet  : %u\n  Channels / frame : %u\n  Bits / channel   : %u\n",
                 desc.fmt_id, desc.fmt_flags, desc.pkt_bytes, desc.frames_per_packet,
                 desc.channels_per_frame, desc.bits_per_chan);
  }
#line 375
  if (desc.channels_per_frame > 1024U) {
    {
#line 376
    psf_log_printf(psf, "**** Bad channels per frame value %u.\n", desc.channels_per_frame);
    }
#line 377
    return (3);
  }
#line 380
  if (chunk_size > (long )((int )sizeof(DESC_CHUNK ))) {
    {
#line 381
    psf_binheader_readf(psf, "j", (int )((unsigned long )chunk_size - sizeof(DESC_CHUNK )));
    }
  }
#line 383
  psf->sf.channels = (int )desc.channels_per_frame;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 386
    marker = 0;
#line 387
    chunk_size = (sf_count_t )0;
#line 389
    psf_binheader_readf(psf, "mE8\333\204U", & marker, & chunk_size);
    }
#line 390
    if (marker == 0) {
      {
#line 391
      __cil_tmp16 = psf_ftell(psf);
#line 391
      pos = __cil_tmp16;
#line 392
      psf_log_printf(psf, "Have 0 marker at position %D (0x%x).\nU", pos, pos);
      }
#line 393
      goto while_break;
    }
#line 395
    if (chunk_size < 0L) {
      {
#line 396
      psf_log_printf(psf, "%M : %D *** Should be >= 0 ***\n", marker, chunk_size);
      }
#line 397
      goto while_break;
    }
    {
#line 400
    __cil_tmp17 = psf_ftell(psf);
#line 400
    psf_store_read_chunk_u32(& psf->rchunks, (uint32_t )marker, __cil_tmp17, (uint32_t )chunk_size);
    }
#line 403
    if (marker == (int )((unsigned int )((112 | (101 << 8)) | (97 << 16)) | (107U << 24))) {
#line 403
      goto case_exp;
    }
#line 434
    if (marker == (int )((unsigned int )((99 | (104 << 8)) | (97 << 16)) | (110U << 24))) {
#line 434
      goto case_exp___0;
    }
#line 447
    if (marker == (int )((unsigned int )((102 | (114 << 8)) | (101 << 16)) | (101U << 24))) {
#line 447
      goto case_exp___1;
    }
#line 452
    if (marker == (int )((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 452
      goto case_exp___2;
    }
#line 474
    if (marker == (int )((unsigned int )((107 | (117 << 8)) | (107 << 16)) | (105U << 24))) {
#line 474
      goto case_exp___3;
    }
#line 480
    if (marker == (int )((unsigned int )((112 | (97 << 8)) | (107 << 16)) | (116U << 24))) {
#line 480
      goto case_exp___4;
    }
#line 503
    goto switch_default;
    case_exp: 
    {
#line 404
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
    }
#line 405
    if (chunk_size != (long )((int )(sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + 8UL)))) {
      {
#line 406
      __cil_tmp18 = make_size_t((int )chunk_size);
#line 406
      psf_binheader_readf(psf, "j", __cil_tmp18);
#line 407
      psf_log_printf(psf, "*** File PEAK chunk %D should be %d.\nU", chunk_size, (int )(sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + 8UL)));
      }
#line 408
      return (668);
    }
    {
#line 411
    psf->peak_info = peak_info_calloc(psf->sf.channels);
    }
#line 411
    if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 412
      return (17);
    }
    {
#line 415
    psf_binheader_readf(psf, "E4", & (psf->peak_info)->edit_number);
#line 416
    psf_log_printf(psf, "  edit count : %d\n", (psf->peak_info)->edit_number);
#line 418
    psf_log_printf(psf, "     Ch   Position       Value\n");
#line 419
    k = 0;
    }
    {
#line 419
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 419
      if (! (k < psf->sf.channels)) {
#line 419
        goto while_break___0;
      }
      {
#line 423
      psf_binheader_readf(psf, "Ef8\333\204U", & value___0, & position);
#line 424
      (psf->peak_info)->peaks[k].value = (double )value___0;
#line 425
      (psf->peak_info)->peaks[k].position = position;
#line 427
      snprintf(ubuf.cbuf, sizeof(ubuf.cbuf), "    %2d   %-12ld   %g\nJ\333\204U",
               k, position, (double )value___0);
#line 428
      psf_log_printf(psf, (char const   *)(ubuf.cbuf));
#line 419
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 431
    (psf->peak_info)->peak_loc = 42;
#line 432
    goto switch_break;
    case_exp___0: 
#line 435
    if (chunk_size < 12L) {
      {
#line 436
      psf_log_printf(psf, "%M : %D (should be >= 12)\n", marker, chunk_size);
#line 437
      __cil_tmp23 = make_size_t((int )chunk_size);
#line 437
      psf_binheader_readf(psf, "j", __cil_tmp23);
      }
#line 438
      goto switch_break;
    }
    {
#line 441
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
#line 443
    error = caf_read_chanmap(psf, chunk_size);
    }
#line 443
    if (error) {
#line 444
      return (error);
    }
#line 445
    goto switch_break;
    case_exp___1: 
    {
#line 448
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
#line 449
    __cil_tmp25 = make_size_t((int )chunk_size);
#line 449
    psf_binheader_readf(psf, "j", __cil_tmp25);
    }
#line 450
    goto switch_break;
    case_exp___2: 
    {
#line 453
    psf_binheader_readf(psf, "E4", & k);
    }
#line 454
    if (chunk_size == -1L) {
      {
#line 455
      psf_log_printf(psf, "%M : -1\n\220");
#line 456
      chunk_size = psf->filelength - (long )psf->headindex;
      }
    } else
#line 458
    if (psf->filelength > 0L) {
#line 458
      if (psf->filelength < ((long )psf->headindex + chunk_size) - 16L) {
        {
#line 459
        psf_log_printf(psf, "%M : %D (should be %D)\n", marker, chunk_size, (psf->filelength - (long )psf->headindex) - 8L);
        }
      } else {
        {
#line 461
        psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
        }
      }
    } else {
      {
#line 461
      psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
      }
    }
    {
#line 463
    psf_log_printf(psf, "  edit : %u\n", k);
#line 465
    psf->dataoffset = (sf_count_t )psf->headindex;
#line 468
    psf->datalength = chunk_size - 4L;
#line 470
    __cil_tmp26 = make_size_t((int )psf->datalength);
#line 470
    psf_binheader_readf(psf, "j", __cil_tmp26);
#line 471
    have_data = 1;
    }
#line 472
    goto switch_break;
    case_exp___3: 
    {
#line 475
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
#line 476
    __cil_tmp27 = psf_ftell(psf);
#line 476
    pcaf->alac.kuki_offset = (unsigned int )(__cil_tmp27 - 12L);
#line 477
    __cil_tmp28 = make_size_t((int )chunk_size);
#line 477
    psf_binheader_readf(psf, "j", __cil_tmp28);
    }
#line 478
    goto switch_break;
    case_exp___4: 
    {
#line 481
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
#line 483
    psf_binheader_readf(psf, "E8844", & pcaf->alac.packets, & pcaf->alac.valid_frames,
                        & pcaf->alac.priming_frames, & pcaf->alac.remainder_frames);
#line 486
    psf_log_printf(psf, "  Packets          : %D\n  Valid frames     : %D\n  Priming frames   : %d\n  Remainder frames : %d\n",
                   pcaf->alac.packets, pcaf->alac.valid_frames, pcaf->alac.priming_frames,
                   pcaf->alac.remainder_frames);
    }
#line 495
    if (pcaf->alac.packets == 0L) {
#line 495
      if (pcaf->alac.valid_frames == 0L) {
#line 495
        if (pcaf->alac.priming_frames == 0) {
#line 495
          if (pcaf->alac.remainder_frames == 0) {
            {
#line 497
            psf_log_printf(psf, "*** \'pakt\' chunk header is all zero.\n");
            }
          }
        }
      }
    }
    {
#line 499
    __cil_tmp29 = psf_ftell(psf);
#line 499
    pcaf->alac.pakt_offset = (unsigned int )(__cil_tmp29 - 12L);
#line 500
    __cil_tmp30 = make_size_t((int )chunk_size);
#line 500
    psf_binheader_readf(psf, "j", __cil_tmp30 - 24UL);
    }
#line 501
    goto switch_break;
    switch_default: 
    {
#line 504
    psf_log_printf(psf, "%M : %D (skipped)\n", marker, chunk_size);
#line 505
    __cil_tmp31 = make_size_t((int )chunk_size);
#line 505
    psf_binheader_readf(psf, "j", __cil_tmp31);
    }
#line 506
    goto switch_break;
    switch_break: ;
#line 509
    if ((unsigned int )marker != ((unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24))) {
#line 509
      if (chunk_size >= 4294967040L) {
#line 510
        goto while_break;
      }
    }
#line 512
    if (! psf->sf.seekable) {
#line 512
      if (have_data) {
#line 513
        goto while_break;
      }
    }
    {
#line 515
    __cil_tmp32 = psf_ftell(psf);
    }
#line 515
    if (__cil_tmp32 >= psf->filelength - (long )((int )sizeof(chunk_size))) {
      {
#line 516
      psf_log_printf(psf, "End\n");
      }
#line 517
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 521
  if (have_data == 0) {
    {
#line 522
    psf_log_printf(psf, "**** Error, could not find \'data\' chunk.\n");
    }
#line 523
    return (3);
  }
#line 526
  if (desc.fmt_flags & 2U) {
#line 526
    tmp = 268435456;
  } else {
#line 526
    tmp = 536870912;
  }
  {
#line 526
  psf->endian = tmp;
#line 528
  psf_fseek(psf, psf->dataoffset, 0);
#line 530
  psf->sf.format = decode_desc_chunk(psf, & desc);
  }
#line 530
  if (psf->sf.format == 0) {
#line 531
    return (4);
  }
#line 533
  if (psf->bytewidth > 0) {
#line 534
    psf->sf.frames = psf->datalength / (long )psf->bytewidth;
  }
#line 536
  return (0);
}
}
#line 543 "/root/patchweave_donee/23/src/caf.c"
static int caf_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  BUF_UNION ubuf ;
  CAF_PRIVATE *pcaf ;
  DESC_CHUNK desc ;
  sf_count_t current ;
  sf_count_t free_len ;
  uint32_t uk ;
  int subformat ;
  int append_free_block ;
  size_t __cil_tmp13 ;
  int k ;
  size_t __cil_tmp16 ;

  {
#line 549
  append_free_block = 1;
#line 551
  pcaf = (CAF_PRIVATE *)psf->container_data;
#line 551
  if ((unsigned long )pcaf == (unsigned long )((void *)0)) {
#line 552
    return (30);
  }
  {
#line 554
  memset((void *)(& desc), 0, sizeof(desc));
#line 556
  current = psf_ftell(psf);
  }
#line 558
  if (calc_length) {
    {
#line 559
    psf->filelength = psf_get_filelen(psf);
#line 561
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 563
    if (psf->dataend) {
#line 564
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 566
    if (psf->bytewidth > 0) {
#line 567
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
  {
#line 571
  psf->header[0] = (unsigned char)0;
#line 572
  psf->headindex = 0;
#line 573
  psf_fseek(psf, (sf_count_t )0, 0);
#line 576
  psf_binheader_writef(psf, "Em22", (unsigned int )((99 | (97 << 8)) | (102 << 16)) | (102U << 24),
                       1, 0);
#line 579
  psf_binheader_writef(psf, "Em8\333\204U", (unsigned int )((100 | (101 << 8)) | (115 << 16)) | (99U << 24),
                       (sf_count_t )sizeof(DESC_CHUNK ));
#line 581
  double64_be_write(1. * (double )psf->sf.samplerate, ubuf.ucbuf);
#line 582
  __cil_tmp13 = make_size_t(8);
#line 582
  psf_binheader_writef(psf, "b0L\333\204U", ubuf.ucbuf, __cil_tmp13);
#line 584
  subformat = psf->sf.format & 65535;
#line 586
  psf->endian = psf->sf.format & 805306368;
  }
#line 590
  if (psf->endian == 268435456) {
#line 591
    psf->endian = 268435456;
  } else
#line 590
  if (psf->endian == 805306368) {
#line 591
    psf->endian = 268435456;
  }
#line 593
  if (psf->endian == 268435456) {
#line 594
    desc.fmt_flags = (uint32_t )2;
  } else {
#line 596
    psf->endian = 536870912;
  }
#line 600
  if (subformat == 1) {
#line 600
    goto case_1;
  }
#line 609
  if (subformat == 2) {
#line 609
    goto case_2;
  }
#line 618
  if (subformat == 3) {
#line 618
    goto case_3;
  }
#line 627
  if (subformat == 4) {
#line 627
    goto case_4;
  }
#line 636
  if (subformat == 6) {
#line 636
    goto case_6;
  }
#line 646
  if (subformat == 7) {
#line 646
    goto case_7;
  }
#line 656
  if (subformat == 17) {
#line 656
    goto case_17;
  }
#line 665
  if (subformat == 16) {
#line 665
    goto case_16;
  }
#line 677
  if (subformat == 115) {
#line 677
    goto case_115;
  }
#line 677
  if (subformat == 114) {
#line 677
    goto case_115;
  }
#line 677
  if (subformat == 113) {
#line 677
    goto case_115;
  }
#line 677
  if (subformat == 112) {
#line 677
    goto case_115;
  }
#line 685
  goto switch_default;
  case_1: 
#line 601
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 602
  psf->bytewidth = 1;
#line 603
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 604
  desc.frames_per_packet = (uint32_t )1;
#line 605
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 606
  desc.bits_per_chan = (uint32_t )8;
#line 607
  goto switch_break;
  case_2: 
#line 610
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 611
  psf->bytewidth = 2;
#line 612
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 613
  desc.frames_per_packet = (uint32_t )1;
#line 614
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 615
  desc.bits_per_chan = (uint32_t )16;
#line 616
  goto switch_break;
  case_3: 
#line 619
  psf->bytewidth = 3;
#line 620
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 621
  desc.frames_per_packet = (uint32_t )1;
#line 622
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 623
  desc.bits_per_chan = (uint32_t )24;
#line 624
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 625
  goto switch_break;
  case_4: 
#line 628
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 629
  psf->bytewidth = 4;
#line 630
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 631
  desc.frames_per_packet = (uint32_t )1;
#line 632
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 633
  desc.bits_per_chan = (uint32_t )32;
#line 634
  goto switch_break;
  case_6: 
#line 637
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 638
  desc.fmt_flags |= 1U;
#line 639
  psf->bytewidth = 4;
#line 640
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 641
  desc.frames_per_packet = (uint32_t )1;
#line 642
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 643
  desc.bits_per_chan = (uint32_t )32;
#line 644
  goto switch_break;
  case_7: 
#line 647
  desc.fmt_id = (unsigned int )((108 | (112 << 8)) | (99 << 16)) | (109U << 24);
#line 648
  desc.fmt_flags |= 1U;
#line 649
  psf->bytewidth = 8;
#line 650
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 651
  desc.frames_per_packet = (uint32_t )1;
#line 652
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 653
  desc.bits_per_chan = (uint32_t )64;
#line 654
  goto switch_break;
  case_17: 
#line 657
  desc.fmt_id = (unsigned int )((97 | (108 << 8)) | (97 << 16)) | (119U << 24);
#line 658
  psf->bytewidth = 1;
#line 659
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 660
  desc.frames_per_packet = (uint32_t )1;
#line 661
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 662
  desc.bits_per_chan = (uint32_t )8;
#line 663
  goto switch_break;
  case_16: 
#line 666
  desc.fmt_id = (unsigned int )((117 | (108 << 8)) | (97 << 16)) | (119U << 24);
#line 667
  psf->bytewidth = 1;
#line 668
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 669
  desc.frames_per_packet = (uint32_t )1;
#line 670
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 671
  desc.bits_per_chan = (uint32_t )8;
#line 672
  goto switch_break;
  case_115: 
  {
#line 678
  desc.fmt_id = (unsigned int )((97 | (108 << 8)) | (97 << 16)) | (99U << 24);
#line 679
  desc.pkt_bytes = (uint32_t )(psf->bytewidth * psf->sf.channels);
#line 680
  desc.channels_per_frame = (uint32_t )psf->sf.channels;
#line 681
  alac_get_desc_chunk_items(subformat, & desc.fmt_flags, & desc.frames_per_packet);
#line 682
  append_free_block = 0;
  }
#line 683
  goto switch_break;
  switch_default: 
#line 686
  return (18);
  switch_break: 
  {
#line 689
  psf_binheader_writef(psf, "mE44444", desc.fmt_id, desc.fmt_flags, desc.pkt_bytes,
                       desc.frames_per_packet, desc.channels_per_frame, desc.bits_per_chan);
  }
#line 696
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
    {
#line 698
    psf_binheader_writef(psf, "Em84", (unsigned int )((112 | (101 << 8)) | (97 << 16)) | (107U << 24),
                         (sf_count_t )((int )(sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + 8UL))),
                         (psf->peak_info)->edit_number);
#line 699
    k = 0;
    }
    {
#line 699
    while (1) {
      while_continue: /* CIL Label */ ;

#line 699
      if (! (k < psf->sf.channels)) {
#line 699
        goto while_break;
      }
      {
#line 700
      psf_binheader_writef(psf, "Ef8", (double )((float )(psf->peak_info)->peaks[k].value),
                           (psf->peak_info)->peaks[k].position);
#line 699
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 703
  if (psf->channel_map) {
#line 703
    if (pcaf->chanmap_tag) {
      {
#line 704
      psf_binheader_writef(psf, "Em8444", (unsigned int )((99 | (104 << 8)) | (97 << 16)) | (110U << 24),
                           (sf_count_t )12, pcaf->chanmap_tag, 0, 0);
      }
    }
  }
#line 707
  uk = (uint32_t )0;
  {
#line 707
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 707
    if (! (uk < psf->wchunks.used)) {
#line 707
      goto while_break___0;
    }
    {
#line 708
    __cil_tmp16 = make_size_t((int )(psf->wchunks.chunks + uk)->len);
#line 708
    psf_binheader_writef(psf, "m44b\204U", (int )(psf->wchunks.chunks + uk)->mark32,
                         0, (psf->wchunks.chunks + uk)->len, (psf->wchunks.chunks + uk)->data,
                         __cil_tmp16);
#line 707
    uk ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 710
  if (append_free_block) {
#line 712
    free_len = (sf_count_t )(((4096 - psf->headindex) - 16) - 12);
    {
#line 713
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 713
      if (! (free_len < 0L)) {
#line 713
        goto while_break___1;
      }
#line 714
      free_len += 4096L;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 715
    psf_binheader_writef(psf, "Em8z\204U", (unsigned int )((102 | (114 << 8)) | (101 << 16)) | (101U << 24),
                         free_len, (int )free_len);
    }
  }
  {
#line 718
  psf_binheader_writef(psf, "Em84\204U", (unsigned int )((100 | (97 << 8)) | (116 << 16)) | (97U << 24),
                       psf->datalength + 4L, 0);
#line 720
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 721
  if (psf->error) {
#line 722
    return (psf->error);
  }
#line 724
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 725
  if (current < psf->dataoffset) {
    {
#line 726
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 727
  if (current > 0L) {
    {
#line 728
    psf_fseek(psf, current, 0);
    }
  }
#line 730
  return (psf->error);
}
}
#line 734 "/root/patchweave_donee/23/src/caf.c"
static int caf_read_chanmap(SF_PRIVATE *psf , sf_count_t chunk_size ) 
{ 
  AIFF_CAF_CHANNEL_MAP *map_info ;
  unsigned int channel_bitmap ;
  unsigned int channel_decriptions ;
  unsigned int bytesread ;
  int layout_tag ;
  int __cil_tmp8 ;
  size_t chanmap_size ;
  void *tmp ;

  {
  {
#line 739
  __cil_tmp8 = psf_binheader_readf(psf, "E444\204U", & layout_tag, & channel_bitmap,
                                   & channel_decriptions);
#line 739
  bytesread = (unsigned int )__cil_tmp8;
#line 741
  map_info = aiff_caf_of_channel_layout_tag(layout_tag);
#line 743
  psf_log_printf(psf, "  Tag    : %x\n", layout_tag);
  }
#line 744
  if (map_info) {
    {
#line 745
    psf_log_printf(psf, "  Layout : %s\n", map_info->name);
    }
  }
#line 747
  if ((long )bytesread < chunk_size) {
    {
#line 748
    psf_binheader_readf(psf, "j\375J\333\204U", chunk_size - (long )bytesread);
    }
  }
#line 750
  if (map_info) {
#line 750
    if ((unsigned long )map_info->channel_map != (unsigned long )((void *)0)) {
      {
#line 751
      chanmap_size = 0UL;
#line 753
      free((void *)psf->channel_map);
#line 755
      tmp = malloc(chanmap_size);
#line 755
      psf->channel_map = (int *)tmp;
      }
#line 755
      if ((unsigned long )psf->channel_map == (unsigned long )((void *)0)) {
#line 756
        return (17);
      }
      {
#line 758
      memcpy((void *)psf->channel_map, (void const   *)map_info->channel_map, chanmap_size);
      }
    }
  }
#line 761
  return (0);
}
}
#line 768 "/root/patchweave_donee/23/src/caf.c"
static int caf_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 769
  __cil_tmp3 = psf_save_write_chunk(& psf->wchunks, chunk_info);
  }
#line 769
  return (__cil_tmp3);
}
}
#line 773 "/root/patchweave_donee/23/src/caf.c"
static SF_CHUNK_ITERATOR *caf_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) 
{ 
  SF_CHUNK_ITERATOR *__cil_tmp3 ;

  {
  {
#line 774
  __cil_tmp3 = psf_next_chunk_iterator(& psf->rchunks, iterator);
  }
#line 774
  return (__cil_tmp3);
}
}
#line 778 "/root/patchweave_donee/23/src/caf.c"
static int caf_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;

  {
  {
#line 781
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 781
  if (indx < 0) {
#line 782
    return (164);
  }
#line 784
  chunk_info->datalen = (psf->rchunks.chunks + indx)->len;
#line 786
  return (0);
}
}
#line 790 "/root/patchweave_donee/23/src/caf.c"
static int caf_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;
  sf_count_t pos ;

  {
  {
#line 794
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 794
  if (indx < 0) {
#line 795
    return (164);
  }
#line 797
  if ((unsigned long )chunk_info->data == (unsigned long )((void *)0)) {
#line 798
    return (167);
  }
  {
#line 800
  chunk_info->id_size = (psf->rchunks.chunks + indx)->id_size;
#line 801
  memcpy((void *)(chunk_info->id), (void const   *)((psf->rchunks.chunks + indx)->id),
         sizeof(chunk_info->id) / sizeof(chunk_info->id[0]));
#line 803
  pos = psf_ftell(psf);
#line 804
  psf_fseek(psf, (psf->rchunks.chunks + indx)->offset, 0);
#line 805
  psf_fread(chunk_info->data, (sf_count_t )0, (sf_count_t )1, psf);
#line 806
  psf_fseek(psf, pos, 0);
  }
#line 808
  return (0);
}
}
#line 70 "/root/patchweave_donee/23/src/avr.c"
static int avr_close(SF_PRIVATE *psf ) ;
#line 72
static int avr_read_header(SF_PRIVATE *psf ) ;
#line 73
static int avr_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 80 "/root/patchweave_donee/23/src/avr.c"
int avr_open(SF_PRIVATE *psf ) 
{ 
  int error ;
  int __cil_tmp4 ;

  {
#line 81
  error = 0;
#line 83
  if (psf->file.mode == 16) {
    _L: 
    {
#line 84
    error = avr_read_header(psf);
    }
#line 84
    if (error) {
#line 85
      return (error);
    }
  } else
#line 83
  if (psf->file.mode == 48) {
#line 83
    if (psf->filelength > 0L) {
#line 83
      goto _L;
    }
  }
#line 88
  if ((psf->sf.format & 268369920) != 1179648) {
#line 89
    return (1);
  }
#line 91
  if (psf->file.mode == 32) {
    _L___40: 
    {
#line 92
    psf->endian = 536870912;
#line 94
    __cil_tmp4 = avr_write_header(psf, 0);
    }
#line 94
    if (__cil_tmp4) {
#line 95
      return (psf->error);
    }
#line 97
    psf->write_header = & avr_write_header;
  } else
#line 91
  if (psf->file.mode == 48) {
#line 91
    goto _L___40;
  }
  {
#line 100
  psf->container_close = & avr_close;
#line 102
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 104
  error = pcm_init(psf);
  }
#line 106
  return (error);
}
}
#line 110 "/root/patchweave_donee/23/src/avr.c"
static int avr_read_header(SF_PRIVATE *psf ) 
{ 
  AVR_HEADER hdr ;
  char const   *tmp ;
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 113
  memset((void *)(& hdr), 0, sizeof(hdr));
#line 115
  psf_binheader_readf(psf, "pmb", 0, & hdr.marker, & hdr.name, sizeof(hdr.name));
#line 116
  psf_log_printf(psf, "%M\n", hdr.marker);
  }
#line 118
  if ((unsigned int )hdr.marker != ((unsigned int )((50 | (66 << 8)) | (73 << 16)) | (84U << 24))) {
#line 119
    return (666);
  }
  {
#line 121
  psf_log_printf(psf, "  Name        : %s\n", hdr.name);
#line 123
  psf_binheader_readf(psf, "E22222", & hdr.mono, & hdr.rez, & hdr.sign, & hdr.loop,
                      & hdr.midi);
#line 125
  psf->sf.channels = ((int )hdr.mono & 1) + 1;
  }
#line 127
  if ((int )hdr.sign) {
#line 127
    tmp = "yes\333\204U";
  } else {
#line 127
    tmp = "no";
  }
  {
#line 127
  psf_log_printf(psf, "  Channels    : %d\n  Bit width   : %d\n  Signed      : %s\n\361g\333\204U",
                 ((int )hdr.mono & 1) + 1, (int )hdr.rez, tmp);
  }
#line 131
  if (((int )hdr.rez << 16) + ((int )hdr.sign & 1) == 8 << 16) {
#line 131
    goto case_exp;
  }
#line 136
  if (((int )hdr.rez << 16) + ((int )hdr.sign & 1) == (8 << 16) + 1) {
#line 136
    goto case_exp___0;
  }
#line 141
  if (((int )hdr.rez << 16) + ((int )hdr.sign & 1) == (16 << 16) + 1) {
#line 141
    goto case_exp___1;
  }
#line 146
  goto switch_default;
  case_exp: 
#line 132
  psf->sf.format = 1179653;
#line 133
  psf->bytewidth = 1;
#line 134
  goto switch_break;
  case_exp___0: 
#line 137
  psf->sf.format = 1179649;
#line 138
  psf->bytewidth = 1;
#line 139
  goto switch_break;
  case_exp___1: 
#line 142
  psf->sf.format = 1179650;
#line 143
  psf->bytewidth = 2;
#line 144
  goto switch_break;
  switch_default: 
  {
#line 147
  psf_log_printf(psf, "Error : bad rez/sign combination.\n");
  }
#line 148
  return (666);
  switch_break: 
  {
#line 151
  psf_binheader_readf(psf, "E4444", & hdr.srate, & hdr.frames, & hdr.lbeg, & hdr.lend);
#line 153
  psf->sf.frames = (sf_count_t )hdr.frames;
#line 154
  psf->sf.samplerate = hdr.srate;
#line 156
  psf_log_printf(psf, "  Frames      : %D\n", psf->sf.frames);
#line 157
  psf_log_printf(psf, "  Sample rate : %d\n", psf->sf.samplerate);
#line 159
  psf_binheader_readf(psf, "E222", & hdr.res1, & hdr.res2, & hdr.res3);
#line 160
  psf_binheader_readf(psf, "bb", hdr.ext, sizeof(hdr.ext), hdr.user, sizeof(hdr.user));
#line 162
  psf_log_printf(psf, "  Ext         : %s\n  User        : %s\n", hdr.ext, hdr.user);
#line 164
  psf->endian = 536870912;
#line 166
  psf->dataoffset = (sf_count_t )128;
#line 167
  psf->datalength = (sf_count_t )(hdr.frames * ((int )hdr.rez / 8));
  }
#line 169
  if (psf->fileoffset > 0L) {
#line 170
    psf->filelength = 128L + psf->datalength;
  }
  {
#line 172
  __cil_tmp4 = psf_ftell(psf);
  }
#line 172
  if (__cil_tmp4 != psf->dataoffset) {
    {
#line 173
    __cil_tmp5 = psf_ftell(psf);
#line 173
    psf_binheader_readf(psf, "j", psf->dataoffset - __cil_tmp5);
    }
  }
#line 175
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 177
  if (psf->sf.frames == 0L) {
#line 177
    if (psf->blockwidth) {
#line 178
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 180
  return (0);
}
}
#line 184 "/root/patchweave_donee/23/src/avr.c"
static int avr_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int sign ;
  size_t __cil_tmp7 ;
  int tmp ;
  int tmp___0 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
#line 188
  if (psf->pipeoffset > 0L) {
#line 189
    return (0);
  }
  {
#line 191
  current = psf_ftell(psf);
  }
#line 193
  if (calc_length) {
    {
#line 194
    psf->filelength = psf_get_filelen(psf);
#line 196
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 197
    if (psf->dataend) {
#line 198
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 200
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
#line 204
  psf->header[0] = (unsigned char)0;
#line 205
  psf->headindex = 0;
#line 211
  if (psf->is_pipe == 0) {
    {
#line 212
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 214
  __cil_tmp7 = make_size_t(8);
  }
#line 214
  if (psf->sf.channels == 2) {
#line 214
    tmp = 65535;
  } else {
#line 214
    tmp = 0;
  }
  {
#line 214
  psf_binheader_writef(psf, "Emz22U", (unsigned int )((50 | (66 << 8)) | (73 << 16)) | (84U << 24),
                       __cil_tmp7, tmp, psf->bytewidth * 8);
  }
#line 217
  if ((psf->sf.format & 65535) == 5) {
#line 217
    tmp___0 = 0;
  } else {
#line 217
    tmp___0 = 65535;
  }
  {
#line 217
  sign = tmp___0;
#line 219
  psf_binheader_writef(psf, "E222\204U", sign, 0, 65535);
#line 220
  psf_binheader_writef(psf, "E4444U", psf->sf.samplerate, psf->sf.frames, 0, 0);
#line 222
  __cil_tmp10 = make_size_t(20);
#line 222
  __cil_tmp11 = make_size_t(64);
#line 222
  psf_binheader_writef(psf, "E222zz", 0, 0, 0, __cil_tmp10, __cil_tmp11);
#line 225
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 227
  if (psf->error) {
#line 228
    return (psf->error);
  }
#line 230
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 232
  if (current > 0L) {
    {
#line 233
    psf_fseek(psf, current, 0);
    }
  }
#line 235
  return (psf->error);
}
}
#line 239 "/root/patchweave_donee/23/src/avr.c"
static int avr_close(SF_PRIVATE *psf ) 
{ 


  {
#line 241
  if (psf->file.mode == 32) {
    {
#line 242
    avr_write_header(psf, 1);
    }
  } else
#line 241
  if (psf->file.mode == 48) {
    {
#line 242
    avr_write_header(psf, 1);
    }
  }
#line 244
  return (0);
}
}
#line 93 "/root/patchweave_donee/23/src/au.c"
static int au_close(SF_PRIVATE *psf ) ;
#line 95
static int au_format_to_encoding(int format ) ;
#line 97
static int au_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 98
static int au_read_header(SF_PRIVATE *psf ) ;
#line 105 "/root/patchweave_donee/23/src/au.c"
int au_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp5 ;

  {
#line 107
  error = 0;
#line 109
  if (psf->file.mode == 16) {
    _L: 
    {
#line 110
    error = au_read_header(psf);
    }
#line 110
    if (error) {
#line 111
      return (error);
    }
  } else
#line 109
  if (psf->file.mode == 48) {
#line 109
    if (psf->filelength > 0L) {
#line 109
      goto _L;
    }
  }
#line 114
  if ((psf->sf.format & 268369920) != 196608) {
#line 115
    return (1);
  }
#line 117
  subformat = psf->sf.format & 65535;
#line 119
  if (psf->file.mode == 32) {
    _L___41: 
#line 120
    psf->endian = psf->sf.format & 805306368;
#line 121
    if (psf->endian == 805306368) {
#line 122
      psf->endian = 268435456;
    } else
#line 123
    if (psf->endian != 268435456) {
#line 124
      psf->endian = 536870912;
    }
    {
#line 126
    __cil_tmp5 = au_write_header(psf, 0);
    }
#line 126
    if (__cil_tmp5) {
#line 127
      return (psf->error);
    }
#line 129
    psf->write_header = & au_write_header;
  } else
#line 119
  if (psf->file.mode == 48) {
#line 119
    goto _L___41;
  }
#line 132
  psf->container_close = & au_close;
#line 134
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 137
  if (subformat == 16) {
#line 137
    goto case_16;
  }
#line 141
  if (subformat == 1) {
#line 141
    goto case_1;
  }
#line 147
  if (subformat == 4) {
#line 147
    goto case_4;
  }
#line 147
  if (subformat == 3) {
#line 147
    goto case_4;
  }
#line 147
  if (subformat == 2) {
#line 147
    goto case_4;
  }
#line 151
  if (subformat == 17) {
#line 151
    goto case_17;
  }
#line 156
  if (subformat == 6) {
#line 156
    goto case_6;
  }
#line 160
  if (subformat == 7) {
#line 160
    goto case_7;
  }
#line 164
  if (subformat == 48) {
#line 164
    goto case_48;
  }
#line 169
  if (subformat == 49) {
#line 169
    goto case_49;
  }
#line 174
  if (subformat == 50) {
#line 174
    goto case_50;
  }
#line 180
  goto switch_default;
  case_16: 
  {
#line 138
  ulaw_init(psf);
  }
#line 139
  goto switch_break;
  case_1: 
  {
#line 142
  error = pcm_init(psf);
  }
#line 143
  goto switch_break;
  case_4: 
  {
#line 148
  error = pcm_init(psf);
  }
#line 149
  goto switch_break;
  case_17: 
  {
#line 152
  alaw_init(psf);
  }
#line 153
  goto switch_break;
  case_6: 
  {
#line 157
  error = float32_init(psf);
  }
#line 158
  goto switch_break;
  case_7: 
  {
#line 161
  error = double64_init(psf);
  }
#line 162
  goto switch_break;
  case_48: 
  {
#line 165
  error = g72x_init(psf);
#line 166
  psf->sf.seekable = 0;
  }
#line 167
  goto switch_break;
  case_49: 
  {
#line 170
  error = g72x_init(psf);
#line 171
  psf->sf.seekable = 0;
  }
#line 172
  goto switch_break;
  case_50: 
  {
#line 175
  error = g72x_init(psf);
#line 176
  psf->sf.seekable = 0;
  }
#line 177
  goto switch_break;
  switch_default: 
#line 180
  goto switch_break;
  switch_break: ;
#line 183
  return (error);
}
}
#line 190 "/root/patchweave_donee/23/src/au.c"
static int au_close(SF_PRIVATE *psf ) 
{ 


  {
#line 192
  if (psf->file.mode == 32) {
    {
#line 193
    au_write_header(psf, 1);
    }
  } else
#line 192
  if (psf->file.mode == 48) {
    {
#line 193
    au_write_header(psf, 1);
    }
  }
#line 195
  return (0);
}
}
#line 199 "/root/patchweave_donee/23/src/au.c"
static int au_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int encoding ;
  int datalength ;

  {
#line 203
  if (psf->pipeoffset > 0L) {
#line 204
    return (0);
  }
  {
#line 206
  current = psf_ftell(psf);
  }
#line 208
  if (calc_length) {
    {
#line 209
    psf->filelength = psf_get_filelen(psf);
#line 211
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 212
    if (psf->dataend) {
#line 213
      psf->datalength -= psf->filelength - psf->dataend;
    }
  }
  {
#line 216
  encoding = au_format_to_encoding(psf->sf.format & 65535);
  }
#line 217
  if (! encoding) {
#line 218
    psf->error = 1;
#line 218
    return (psf->error);
  }
#line 221
  psf->header[0] = (unsigned char)0;
#line 222
  psf->headindex = 0;
#line 228
  if (psf->is_pipe == 0) {
    {
#line 229
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
#line 236
  if (psf->datalength < 0L) {
#line 237
    datalength = -1;
  } else
#line 236
  if (psf->datalength > 2147483647L) {
#line 237
    datalength = -1;
  } else {
#line 239
    datalength = (int )(psf->datalength & 2147483647L);
  }
#line 241
  if (psf->endian == 536870912) {
    {
#line 242
    psf_binheader_writef(psf, "Em4\333\204U", (unsigned int )((46 | (115 << 8)) | (110 << 16)) | (100U << 24),
                         24);
#line 243
    psf_binheader_writef(psf, "E4444", datalength, encoding, psf->sf.samplerate, psf->sf.channels);
    }
  } else
#line 245
  if (psf->endian == 268435456) {
    {
#line 246
    psf_binheader_writef(psf, "em4\333\204U", (unsigned int )((100 | (110 << 8)) | (115 << 16)) | (46U << 24),
                         24);
#line 247
    psf_binheader_writef(psf, "e4444", datalength, encoding, psf->sf.samplerate, psf->sf.channels);
    }
  } else {
#line 250
    psf->error = 1;
#line 250
    return (psf->error);
  }
  {
#line 253
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 255
  if (psf->error) {
#line 256
    return (psf->error);
  }
#line 258
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 260
  if (current > 0L) {
    {
#line 261
    psf_fseek(psf, current, 0);
    }
  }
#line 263
  return (psf->error);
}
}
#line 267 "/root/patchweave_donee/23/src/au.c"
static int au_format_to_encoding(int format ) 
{ 


  {
#line 270
  if (format == 1) {
#line 270
    goto case_1;
  }
#line 271
  if (format == 2) {
#line 271
    goto case_2;
  }
#line 272
  if (format == 3) {
#line 272
    goto case_3;
  }
#line 273
  if (format == 4) {
#line 273
    goto case_4;
  }
#line 275
  if (format == 6) {
#line 275
    goto case_6;
  }
#line 276
  if (format == 7) {
#line 276
    goto case_7;
  }
#line 278
  if (format == 16) {
#line 278
    goto case_16;
  }
#line 279
  if (format == 17) {
#line 279
    goto case_17;
  }
#line 281
  if (format == 48) {
#line 281
    goto case_48;
  }
#line 282
  if (format == 49) {
#line 282
    goto case_49;
  }
#line 283
  if (format == 50) {
#line 283
    goto case_50;
  }
#line 285
  goto switch_default;
  case_1: 
#line 270
  return (2);
  case_2: 
#line 271
  return (3);
  case_3: 
#line 272
  return (4);
  case_4: 
#line 273
  return (5);
  case_6: 
#line 275
  return (6);
  case_7: 
#line 276
  return (7);
  case_16: 
#line 278
  return (1);
  case_17: 
#line 279
  return (27);
  case_48: 
#line 281
  return (23);
  case_49: 
#line 282
  return (25);
  case_50: 
#line 283
  return (26);
  switch_default: 
#line 285
  goto switch_break;
  switch_break: ;
#line 287
  return (0);
}
}
#line 291 "/root/patchweave_donee/23/src/au.c"
static int au_read_header(SF_PRIVATE *psf ) 
{ 
  AU_FMT au_fmt ;
  int marker ;
  int dword ;
  sf_count_t __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;

  {
  {
#line 295
  memset((void *)(& au_fmt), 0, sizeof(au_fmt));
#line 296
  psf_binheader_readf(psf, "pm", 0, & marker);
#line 297
  psf_log_printf(psf, "%M\n", marker);
  }
#line 299
  if ((unsigned int )marker == ((unsigned int )((46 | (115 << 8)) | (110 << 16)) | (100U << 24))) {
    {
#line 300
    psf->endian = 536870912;
#line 302
    psf_binheader_readf(psf, "E44444", & au_fmt.dataoffset, & au_fmt.datasize, & au_fmt.encoding,
                        & au_fmt.samplerate, & au_fmt.channels);
    }
  } else
#line 305
  if ((unsigned int )marker == ((unsigned int )((100 | (110 << 8)) | (115 << 16)) | (46U << 24))) {
    {
#line 306
    psf->endian = 268435456;
#line 307
    psf_binheader_readf(psf, "e44444", & au_fmt.dataoffset, & au_fmt.datasize, & au_fmt.encoding,
                        & au_fmt.samplerate, & au_fmt.channels);
    }
  } else {
#line 311
    return (92);
  }
  {
#line 313
  psf_log_printf(psf, "  Data Offset : %d\n\333\204U", au_fmt.dataoffset);
  }
#line 315
  if (psf->fileoffset > 0L) {
#line 315
    if (au_fmt.datasize == -1) {
      {
#line 316
      psf_log_printf(psf, "  Data Size   : -1\n\333\204U");
      }
#line 317
      return (93);
    }
  }
#line 320
  if (psf->fileoffset > 0L) {
    {
#line 321
    psf->filelength = (sf_count_t )(au_fmt.dataoffset + au_fmt.datasize);
#line 322
    psf_log_printf(psf, "  Data Size   : %d\n\333\204U", au_fmt.datasize);
    }
  } else
#line 324
  if (au_fmt.datasize == -1) {
    {
#line 325
    psf_log_printf(psf, "  Data Size   : %d\n\333\204U", au_fmt.datasize);
    }
  } else
#line 324
  if ((long )(au_fmt.dataoffset + au_fmt.datasize) == psf->filelength) {
    {
#line 325
    psf_log_printf(psf, "  Data Size   : %d\n\333\204U", au_fmt.datasize);
    }
  } else
#line 326
  if ((long )(au_fmt.dataoffset + au_fmt.datasize) < psf->filelength) {
    {
#line 327
    psf->filelength = (sf_count_t )(au_fmt.dataoffset + au_fmt.datasize);
#line 328
    psf_log_printf(psf, "  Data Size   : %d\n\333\204U", au_fmt.datasize);
    }
  } else {
    {
#line 331
    dword = (int )(psf->filelength - (long )au_fmt.dataoffset);
#line 332
    psf_log_printf(psf, "  Data Size   : %d (should be %d)\n", au_fmt.datasize, dword);
#line 333
    au_fmt.datasize = dword;
    }
  }
  {
#line 336
  psf->dataoffset = (sf_count_t )au_fmt.dataoffset;
#line 337
  psf->datalength = psf->filelength - psf->dataoffset;
#line 339
  __cil_tmp5 = psf_ftell(psf);
  }
#line 339
  if (__cil_tmp5 < psf->dataoffset) {
    {
#line 340
    __cil_tmp6 = psf_ftell(psf);
#line 340
    psf_binheader_readf(psf, "j", psf->dataoffset - __cil_tmp6);
    }
  }
#line 342
  psf->sf.samplerate = au_fmt.samplerate;
#line 343
  psf->sf.channels = au_fmt.channels;
#line 346
  if (psf->endian == 536870912) {
#line 347
    psf->sf.format = 196608;
  } else
#line 348
  if (psf->endian == 268435456) {
#line 349
    psf->sf.format = 268632064;
  }
  {
#line 351
  psf_log_printf(psf, "  Encoding    : %d => ", au_fmt.encoding);
#line 353
  psf->sf.format &= 805306368;
  }
#line 356
  if (au_fmt.encoding == 1) {
#line 356
    goto case_1;
  }
#line 362
  if (au_fmt.encoding == 2) {
#line 362
    goto case_2;
  }
#line 368
  if (au_fmt.encoding == 3) {
#line 368
    goto case_3;
  }
#line 374
  if (au_fmt.encoding == 4) {
#line 374
    goto case_4;
  }
#line 380
  if (au_fmt.encoding == 5) {
#line 380
    goto case_5;
  }
#line 386
  if (au_fmt.encoding == 6) {
#line 386
    goto case_6;
  }
#line 392
  if (au_fmt.encoding == 7) {
#line 392
    goto case_7;
  }
#line 398
  if (au_fmt.encoding == 27) {
#line 398
    goto case_27;
  }
#line 404
  if (au_fmt.encoding == 23) {
#line 404
    goto case_23;
  }
#line 410
  if (au_fmt.encoding == 25) {
#line 410
    goto case_25;
  }
#line 416
  if (au_fmt.encoding == 26) {
#line 416
    goto case_26;
  }
#line 422
  if (au_fmt.encoding == 24) {
#line 422
    goto case_24;
  }
#line 426
  if (au_fmt.encoding == 19) {
#line 426
    goto case_19;
  }
#line 430
  goto switch_default;
  case_1: 
  {
#line 357
  psf->sf.format |= 196624;
#line 358
  psf->bytewidth = 1;
#line 359
  psf_log_printf(psf, "8-bit ISDN u-law\n");
  }
#line 360
  goto switch_break;
  case_2: 
  {
#line 363
  psf->sf.format |= 196609;
#line 364
  psf->bytewidth = 1;
#line 365
  psf_log_printf(psf, "8-bit linear PCM\n");
  }
#line 366
  goto switch_break;
  case_3: 
  {
#line 369
  psf->sf.format |= 196610;
#line 370
  psf->bytewidth = 2;
#line 371
  psf_log_printf(psf, "16-bit linear PCM\n");
  }
#line 372
  goto switch_break;
  case_4: 
  {
#line 375
  psf->sf.format |= 196611;
#line 376
  psf->bytewidth = 3;
#line 377
  psf_log_printf(psf, "24-bit linear PCM\n");
  }
#line 378
  goto switch_break;
  case_5: 
  {
#line 381
  psf->sf.format |= 196612;
#line 382
  psf->bytewidth = 4;
#line 383
  psf_log_printf(psf, "32-bit linear PCM\n");
  }
#line 384
  goto switch_break;
  case_6: 
  {
#line 387
  psf->sf.format |= 196614;
#line 388
  psf->bytewidth = 4;
#line 389
  psf_log_printf(psf, "32-bit float\n");
  }
#line 390
  goto switch_break;
  case_7: 
  {
#line 393
  psf->sf.format |= 196615;
#line 394
  psf->bytewidth = 8;
#line 395
  psf_log_printf(psf, "64-bit double precision float\n");
  }
#line 396
  goto switch_break;
  case_27: 
  {
#line 399
  psf->sf.format |= 196625;
#line 400
  psf->bytewidth = 1;
#line 401
  psf_log_printf(psf, "8-bit ISDN A-law\n");
  }
#line 402
  goto switch_break;
  case_23: 
  {
#line 405
  psf->sf.format |= 196656;
#line 406
  psf->bytewidth = 0;
#line 407
  psf_log_printf(psf, "G721 32kbs ADPCM\n");
  }
#line 408
  goto switch_break;
  case_25: 
  {
#line 411
  psf->sf.format |= 196657;
#line 412
  psf->bytewidth = 0;
#line 413
  psf_log_printf(psf, "G723 24kbs ADPCM\n");
  }
#line 414
  goto switch_break;
  case_26: 
  {
#line 417
  psf->sf.format |= 196658;
#line 418
  psf->bytewidth = 0;
#line 419
  psf_log_printf(psf, "G723 40kbs ADPCM\n");
  }
#line 420
  goto switch_break;
  case_24: 
  {
#line 423
  psf_log_printf(psf, "G722 64 kbs ADPCM (unsupported)\n\220");
  }
#line 424
  goto switch_break;
  case_19: 
  {
#line 427
  psf_log_printf(psf, "Weird NeXT encoding format (unsupported)\n");
  }
#line 428
  goto switch_break;
  switch_default: 
  {
#line 431
  psf_log_printf(psf, "Unknown!!\n");
  }
#line 432
  goto switch_break;
  switch_break: 
  {
#line 435
  psf_log_printf(psf, "  Sample Rate : %d\n", au_fmt.samplerate);
  }
#line 436
  if (au_fmt.channels < 1) {
    {
#line 437
    psf_log_printf(psf, "  Channels    : %d  **** should be >= 1\n\230\001", au_fmt.channels);
    }
#line 438
    return (33);
  } else
#line 440
  if (au_fmt.channels > 1024) {
    {
#line 441
    psf_log_printf(psf, "  Channels    : %d  **** should be <= %d\n", au_fmt.channels,
                   1024);
    }
#line 442
    return (34);
  }
  {
#line 445
  psf_log_printf(psf, "  Channels    : %d\n", au_fmt.channels);
#line 447
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
  }
#line 449
  if (! psf->sf.frames) {
#line 449
    if (psf->blockwidth) {
#line 450
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 452
  return (0);
}
}
#line 200 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_close(SF_PRIVATE *psf ) ;
#line 202
static int tenbytefloat2int(unsigned char *bytes ) ;
#line 203
static void uint2tenbytefloat(unsigned int num , unsigned char *bytes ) ;
#line 205
static int aiff_read_comm_chunk(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) ;
#line 207
static int aiff_read_header(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) ;
#line 209
static int aiff_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 210
static int aiff_write_tailer(SF_PRIVATE *psf ) ;
#line 211
static void aiff_write_strings(SF_PRIVATE *psf , int location ) ;
#line 213
static int aiff_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int UNUSED_datasize ) ;
#line 215
static char const   *get_loop_mode_str(short mode ) ;
#line 217
static short get_loop_mode(short mode ) ;
#line 219
static int aiff_read_basc_chunk(SF_PRIVATE *psf , int datasize ) ;
#line 221
static int aiff_read_chanmap(SF_PRIVATE *psf , unsigned int dword ) ;
#line 223
static unsigned int marker_to_position(MARK_ID_POS *m , unsigned short n , int marksize ) ;
#line 225
static int aiff_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) ;
#line 226
static SF_CHUNK_ITERATOR *aiff_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) ;
#line 227
static int aiff_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 228
static int aiff_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) ;
#line 235 "/root/patchweave_donee/23/src/aiff.c"
int aiff_open(SF_PRIVATE *psf ) 
{ 
  COMM_CHUNK comm_fmt ;
  int error ;
  int subformat ;

  {
  {
#line 239
  memset((void *)(& comm_fmt), 0, sizeof(comm_fmt));
#line 241
  subformat = psf->sf.format & 65535;
#line 243
  psf->container_data = calloc(1UL, sizeof(AIFF_PRIVATE ));
  }
#line 243
  if ((unsigned long )psf->container_data == (unsigned long )((void *)0)) {
#line 244
    return (17);
  }
#line 246
  if (psf->file.mode == 16) {
    _L: 
    {
#line 247
    error = aiff_read_header(psf, & comm_fmt);
    }
#line 247
    if (error) {
#line 248
      return (error);
    }
    {
#line 250
    psf->next_chunk_iterator = & aiff_next_chunk_iterator;
#line 251
    psf->get_chunk_size = & aiff_get_chunk_size;
#line 252
    psf->get_chunk_data = & aiff_get_chunk_data;
#line 254
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 246
  if (psf->file.mode == 48) {
#line 246
    if (psf->filelength > 0L) {
#line 246
      goto _L;
    }
  }
#line 257
  if (psf->file.mode == 32) {
    _L___43: 
#line 258
    if (psf->is_pipe) {
#line 259
      return (29);
    }
#line 261
    if ((psf->sf.format & 268369920) != 131072) {
#line 262
      return (1);
    }
#line 264
    if (psf->file.mode == 32) {
#line 264
      if (subformat == 6) {
        _L___42: 
        {
#line 265
        psf->peak_info = peak_info_calloc(psf->sf.channels);
        }
#line 265
        if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 266
          return (17);
        }
#line 267
        (psf->peak_info)->peak_loc = 42;
      } else
#line 264
      if (subformat == 7) {
#line 264
        goto _L___42;
      }
    }
#line 270
    if (psf->file.mode != 48) {
#line 271
      psf->filelength = (sf_count_t )0;
#line 272
      psf->datalength = (sf_count_t )0;
#line 273
      psf->dataoffset = (sf_count_t )0;
#line 274
      psf->sf.frames = (sf_count_t )0;
    } else
#line 270
    if (psf->filelength < 40L) {
#line 271
      psf->filelength = (sf_count_t )0;
#line 272
      psf->datalength = (sf_count_t )0;
#line 273
      psf->dataoffset = (sf_count_t )0;
#line 274
      psf->sf.frames = (sf_count_t )0;
    }
    {
#line 277
    psf->strings.flags = (uint32_t )768;
#line 279
    error = aiff_write_header(psf, 0);
    }
#line 279
    if (error) {
#line 280
      return (error);
    }
#line 282
    psf->write_header = & aiff_write_header;
#line 283
    psf->set_chunk = & aiff_set_chunk;
  } else
#line 257
  if (psf->file.mode == 48) {
#line 257
    goto _L___43;
  }
#line 286
  psf->container_close = & aiff_close;
#line 287
  psf->command = & aiff_command;
#line 290
  if ((psf->sf.format & 65535) == 5) {
#line 290
    goto case_5;
  }
#line 294
  if ((psf->sf.format & 65535) == 1) {
#line 294
    goto case_1;
  }
#line 300
  if ((psf->sf.format & 65535) == 4) {
#line 300
    goto case_4;
  }
#line 300
  if ((psf->sf.format & 65535) == 3) {
#line 300
    goto case_4;
  }
#line 300
  if ((psf->sf.format & 65535) == 2) {
#line 300
    goto case_4;
  }
#line 304
  if ((psf->sf.format & 65535) == 16) {
#line 304
    goto case_16;
  }
#line 308
  if ((psf->sf.format & 65535) == 17) {
#line 308
    goto case_17;
  }
#line 313
  if ((psf->sf.format & 65535) == 6) {
#line 313
    goto case_6;
  }
#line 317
  if ((psf->sf.format & 65535) == 7) {
#line 317
    goto case_7;
  }
#line 321
  if ((psf->sf.format & 65535) == 64) {
#line 321
    goto case_64;
  }
#line 325
  if ((psf->sf.format & 65535) == 65) {
#line 325
    goto case_65;
  }
#line 329
  if ((psf->sf.format & 65535) == 66) {
#line 329
    goto case_66;
  }
#line 333
  if ((psf->sf.format & 65535) == 67) {
#line 333
    goto case_67;
  }
#line 347
  if ((psf->sf.format & 65535) == 18) {
#line 347
    goto case_18;
  }
#line 356
  if ((psf->sf.format & 65535) == 32) {
#line 356
    goto case_32;
  }
#line 360
  goto switch_default;
  case_5: 
  {
#line 291
  error = pcm_init(psf);
  }
#line 292
  goto switch_break;
  case_1: 
  {
#line 295
  error = pcm_init(psf);
  }
#line 296
  goto switch_break;
  case_4: 
  {
#line 301
  error = pcm_init(psf);
  }
#line 302
  goto switch_break;
  case_16: 
  {
#line 305
  error = ulaw_init(psf);
  }
#line 306
  goto switch_break;
  case_17: 
  {
#line 309
  error = alaw_init(psf);
  }
#line 310
  goto switch_break;
  case_6: 
  {
#line 314
  error = float32_init(psf);
  }
#line 315
  goto switch_break;
  case_7: 
  {
#line 318
  error = double64_init(psf);
  }
#line 319
  goto switch_break;
  case_64: 
  {
#line 322
  error = dwvw_init(psf, 12);
  }
#line 323
  goto switch_break;
  case_65: 
  {
#line 326
  error = dwvw_init(psf, 16);
  }
#line 327
  goto switch_break;
  case_66: 
  {
#line 330
  error = dwvw_init(psf, 24);
  }
#line 331
  goto switch_break;
  case_67: 
#line 334
  if (psf->file.mode != 16) {
#line 335
    error = 138;
#line 336
    goto switch_break;
  }
#line 338
  if ((int )comm_fmt.sampleSize >= 8) {
#line 338
    if ((int )comm_fmt.sampleSize < 24) {
      {
#line 339
      error = dwvw_init(psf, (int )comm_fmt.sampleSize);
#line 340
      psf->sf.frames = (sf_count_t )comm_fmt.numSampleFrames;
      }
#line 341
      goto switch_break;
    }
  }
  {
#line 343
  psf_log_printf(psf, "AIFC/DWVW : Bad bitwidth %d\n", (int )comm_fmt.sampleSize);
#line 344
  error = 138;
  }
#line 345
  goto switch_break;
  case_18: 
  {
#line 352
  error = aiff_ima_init(psf, 34, 64);
  }
#line 353
  goto switch_break;
  case_32: 
  {
#line 357
  error = gsm610_init(psf);
  }
#line 358
  goto switch_break;
  switch_default: 
#line 360
  return (18);
  switch_break: ;
#line 364
  return (error);
}
}
#line 373 "/root/patchweave_donee/23/src/aiff.c"
static unsigned int marker_to_position(MARK_ID_POS *m , unsigned short n , int marksize ) 
{ 
  int i ;

  {
#line 376
  i = 0;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;

#line 376
    if (! (i < marksize)) {
#line 376
      goto while_break;
    }
#line 377
    if ((int )(m + i)->markerID == (int )n) {
#line 378
      return ((m + i)->position);
    }
#line 376
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 379
  return (0U);
}
}
#line 383 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_read_header(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) 
{ 
  SSND_CHUNK ssnd_fmt ;
  AIFF_PRIVATE *paiff ;
  BUF_UNION ubuf ;
  unsigned int chunk_size ;
  unsigned int FORMsize ;
  unsigned int SSNDsize ;
  unsigned int bytesread ;
  int k ;
  int found_chunk ;
  int done ;
  int error ;
  char *cptr ;
  int instr_found ;
  int mark_found ;
  int mark_count ;
  unsigned int marker ;
  size_t jump ;
  sf_count_t pos ;
  sf_count_t __cil_tmp21 ;
  sf_count_t __cil_tmp22 ;
  int tmp ;
  sf_count_t __cil_tmp24 ;
  float value___0 ;
  unsigned int position ;
  int tmp___0 ;
  sf_count_t __cil_tmp31 ;
  unsigned short count___0 ;
  unsigned short id ;
  unsigned short len ;
  unsigned int timestamp ;
  unsigned int bytes ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  unsigned int appl_marker ;
  int __cil_tmp43 ;
  unsigned char bytes___0[6] ;
  short gain ;
  short mode ;
  char const   *loop_mode ;
  unsigned short begin ;
  unsigned short end ;
  unsigned short mark_id ;
  unsigned short n ;
  unsigned int position___0 ;
  int __cil_tmp61 ;
  unsigned int pstr_len ;
  unsigned char ch ;
  int __cil_tmp65 ;
  int tmp___1 ;
  int __cil_tmp67 ;
  unsigned int read_len ;
  int __cil_tmp69 ;
  size_t __cil_tmp72 ;
  sf_count_t __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  sf_count_t __cil_tmp79 ;
  sf_count_t __cil_tmp80 ;
  sf_count_t __cil_tmp81 ;
  sf_count_t __cil_tmp82 ;
  int j ;
  void *tmp___2 ;

  {
#line 387
  chunk_size = 0U;
#line 388
  found_chunk = 0;
#line 388
  done = 0;
#line 388
  error = 0;
#line 390
  instr_found = 0;
#line 390
  mark_found = 0;
#line 390
  mark_count = 0;
#line 392
  if (psf->filelength > 4294967295L) {
    {
#line 393
    psf_log_printf(psf, "Warning : filelength > 0xffffffff. This is bad!!!!\n");
    }
  }
#line 395
  paiff = (AIFF_PRIVATE *)psf->container_data;
#line 395
  if ((unsigned long )paiff == (unsigned long )((void *)0)) {
#line 396
    return (30);
  }
  {
#line 398
  paiff->comm_offset = (sf_count_t )0;
#line 399
  paiff->ssnd_offset = (sf_count_t )0;
#line 402
  psf_binheader_readf(psf, "p", 0);
#line 404
  memset((void *)comm_fmt, 0, sizeof(COMM_CHUNK ));
#line 407
  psf->endian = 536870912;
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;

#line 413
    if (! (! done)) {
#line 413
      goto while_break;
    }
    {
#line 415
    jump = (size_t )(chunk_size & 1U);
#line 417
    chunk_size = 0U;
#line 417
    marker = chunk_size;
#line 418
    psf_binheader_readf(psf, "Ejm4\204U", jump, & marker, & chunk_size);
    }
#line 419
    if (marker == 0U) {
      {
#line 420
      __cil_tmp21 = psf_ftell(psf);
#line 420
      pos = __cil_tmp21;
#line 421
      psf_log_printf(psf, "Have 0 marker at position %D (0x%x).\nU", pos, pos);
      }
#line 422
      goto while_break;
    }
#line 425
    if (psf->file.mode == 48) {
#line 425
      if (found_chunk & 32) {
#line 426
        return (90);
      }
    }
    {
#line 428
    __cil_tmp22 = psf_ftell(psf);
#line 428
    psf_store_read_chunk_u32(& psf->rchunks, marker, __cil_tmp22, chunk_size);
    }
#line 431
    if (marker == ((unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24))) {
#line 431
      goto case_exp;
    }
#line 441
    if (marker == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
#line 441
      goto case_exp___0;
    }
#line 441
    if (marker == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
#line 441
      goto case_exp___0;
    }
#line 465
    if (marker == ((unsigned int )((67 | (79 << 8)) | (77 << 16)) | (77U << 24))) {
#line 465
      goto case_exp___2;
    }
#line 475
    if (marker == ((unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24))) {
#line 475
      goto case_exp___3;
    }
#line 519
    if (marker == ((unsigned int )((83 | (83 << 8)) | (78 << 16)) | (68U << 24))) {
#line 519
      goto case_exp___4;
    }
#line 564
    if (marker == ((unsigned int )((40 | (99 << 8)) | (41 << 16)) | (32U << 24))) {
#line 564
      goto case_exp___5;
    }
#line 583
    if (marker == ((unsigned int )((65 | (85 << 8)) | (84 << 16)) | (72U << 24))) {
#line 583
      goto case_exp___6;
    }
#line 599
    if (marker == ((unsigned int )((67 | (79 << 8)) | (77 << 16)) | (84U << 24))) {
#line 599
      goto case_exp___7;
    }
#line 629
    if (marker == ((unsigned int )((65 | (80 << 8)) | (80 << 16)) | (76U << 24))) {
#line 629
      goto case_exp___8;
    }
#line 662
    if (marker == ((unsigned int )((78 | (65 << 8)) | (77 << 16)) | (69U << 24))) {
#line 662
      goto case_exp___9;
    }
#line 678
    if (marker == ((unsigned int )((65 | (78 << 8)) | (78 << 16)) | (79U << 24))) {
#line 678
      goto case_exp___10;
    }
#line 694
    if (marker == ((unsigned int )((73 | (78 << 8)) | (83 << 16)) | (84U << 24))) {
#line 694
      goto case_exp___11;
    }
#line 760
    if (marker == ((unsigned int )((98 | (97 << 8)) | (115 << 16)) | (99U << 24))) {
#line 760
      goto case_exp___12;
    }
#line 767
    if (marker == ((unsigned int )((77 | (65 << 8)) | (82 << 16)) | (75U << 24))) {
#line 767
      goto case_exp___13;
    }
#line 818
    if (marker == ((unsigned int )((70 | (86 << 8)) | (69 << 16)) | (82U << 24))) {
#line 818
      goto case_exp___14;
    }
#line 822
    if (marker == ((unsigned int )((83 | (70 << 8)) | (88 << 16)) | (33U << 24))) {
#line 822
      goto case_exp___15;
    }
#line 827
    if (marker == ((unsigned int )((78 | (79 << 8)) | (78 << 16)) | (69U << 24))) {
#line 827
      goto case_exp___16;
    }
#line 834
    if (marker == ((unsigned int )((67 | (72 << 8)) | (65 << 16)) | (78U << 24))) {
#line 834
      goto case_exp___17;
    }
#line 847
    goto switch_default___0;
    case_exp: 
#line 432
    if (found_chunk) {
#line 433
      return (79);
    }
    {
#line 435
    FORMsize = chunk_size;
#line 437
    found_chunk |= 1;
#line 438
    psf_binheader_readf(psf, "m", & marker);
    }
#line 441
    if (marker == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
#line 441
      goto case_exp___0;
    }
#line 441
    if (marker == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
#line 441
      goto case_exp___0;
    }
#line 444
    goto switch_default;
    case_exp___0: 
#line 442
    if (marker == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
#line 442
      tmp = 6;
    } else {
#line 442
      tmp = 2;
    }
#line 442
    found_chunk |= tmp;
#line 443
    goto switch_break___0;
    switch_default: 
#line 445
    goto switch_break___0;
    switch_break___0: ;
#line 448
    if (psf->fileoffset > 0L) {
#line 448
      if (psf->filelength > (long )(FORMsize + 8U)) {
        {
#line 450
        psf->filelength = (sf_count_t )(FORMsize + 8U);
#line 451
        psf_log_printf(psf, "FORM : %u\n %M\n", FORMsize, marker);
        }
      } else {
#line 448
        goto _L;
      }
    } else
    _L: 
#line 453
    if ((long )FORMsize != psf->filelength - (long )(2 * (int )sizeof(chunk_size))) {
      {
#line 454
      chunk_size = (unsigned int )((unsigned long )psf->filelength - 2UL * sizeof(chunk_size));
#line 455
      psf_log_printf(psf, "FORM : %u (should be %u)\n %M\n", FORMsize, chunk_size,
                     marker);
#line 456
      FORMsize = chunk_size;
      }
    } else {
      {
#line 459
      psf_log_printf(psf, "FORM : %u\n %M\n", FORMsize, marker);
      }
    }
#line 461
    chunk_size = 0U;
#line 462
    goto switch_break;
    case_exp___2: 
    {
#line 466
    __cil_tmp24 = psf_ftell(psf);
#line 466
    paiff->comm_offset = __cil_tmp24 - 8L;
#line 467
    chunk_size += chunk_size & 1U;
#line 468
    comm_fmt->size = chunk_size;
#line 469
    error = aiff_read_comm_chunk(psf, comm_fmt);
    }
#line 469
    if (error != 0) {
#line 470
      return (error);
    }
#line 472
    found_chunk |= 16;
#line 473
    goto switch_break;
    case_exp___3: 
#line 477
    if ((found_chunk & 19) != 19) {
#line 478
      return (86);
    }
    {
#line 480
    psf_log_printf(psf, "%M : %d\n\230\001", marker, chunk_size);
    }
#line 481
    if ((unsigned long )chunk_size != 2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int ))) {
      {
#line 482
      psf_binheader_readf(psf, "j\330\244\333\204U", chunk_size);
#line 483
      psf_log_printf(psf, "*** File PEAK chunk too big.\n");
      }
#line 484
      return (67);
    }
    {
#line 487
    psf->peak_info = peak_info_calloc(psf->sf.channels);
    }
#line 487
    if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
#line 488
      return (17);
    }
    {
#line 491
    psf_binheader_readf(psf, "E44", & (psf->peak_info)->version, & (psf->peak_info)->timestamp);
    }
#line 493
    if ((psf->peak_info)->version != 1U) {
      {
#line 494
      psf_log_printf(psf, "  version    : %d *** (should be version 1)\n", (psf->peak_info)->version);
      }
    } else {
      {
#line 496
      psf_log_printf(psf, "  version    : %d\n", (psf->peak_info)->version);
      }
    }
    {
#line 498
    psf_log_printf(psf, "  time stamp : %d\n", (psf->peak_info)->timestamp);
#line 499
    psf_log_printf(psf, "    Ch   Position       Value\n");
#line 501
    cptr = ubuf.cbuf;
#line 502
    k = 0;
    }
    {
#line 502
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 502
      if (! (k < psf->sf.channels)) {
#line 502
        goto while_break___0;
      }
      {
#line 506
      psf_binheader_readf(psf, "Ef4", & value___0, & position);
#line 507
      (psf->peak_info)->peaks[k].value = (double )value___0;
#line 508
      (psf->peak_info)->peaks[k].position = (sf_count_t )position;
#line 510
      snprintf(cptr, sizeof(ubuf.scbuf), "    %2d   %-12ld   %g\n", k, (psf->peak_info)->peaks[k].position,
               (psf->peak_info)->peaks[k].value);
#line 512
      *(cptr + (sizeof(ubuf.scbuf) - 1UL)) = (char)0;
#line 513
      psf_log_printf(psf, "%s", cptr);
#line 502
      k ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: ;
#line 516
    if ((found_chunk & 32) == 0) {
#line 516
      tmp___0 = 42;
    } else {
#line 516
      tmp___0 = 43;
    }
#line 516
    (psf->peak_info)->peak_loc = tmp___0;
#line 517
    goto switch_break;
    case_exp___4: 
#line 520
    if (found_chunk & 4) {
#line 520
      if ((found_chunk & 8) == 0) {
        {
#line 521
        psf_log_printf(psf, "*** Valid AIFC files should have an FVER chunk.\n\220");
        }
      }
    }
    {
#line 523
    __cil_tmp31 = psf_ftell(psf);
#line 523
    paiff->ssnd_offset = __cil_tmp31 - 8L;
#line 524
    SSNDsize = chunk_size;
#line 525
    psf_binheader_readf(psf, "E44", & ssnd_fmt.offset, & ssnd_fmt.blocksize);
#line 527
    psf->datalength = (sf_count_t )((unsigned long )SSNDsize - sizeof(ssnd_fmt));
#line 528
    psf->dataoffset = psf_ftell(psf);
    }
#line 530
    if (psf->datalength > psf->filelength - psf->dataoffset) {
      {
#line 531
      psf_log_printf(psf, " SSND : %u (should be %D)\n", SSNDsize, (unsigned long )(psf->filelength - psf->dataoffset) + sizeof(SSND_CHUNK ));
#line 532
      psf->datalength = psf->filelength - psf->dataoffset;
      }
    } else
#line 530
    if (psf->datalength < 0L) {
      {
#line 531
      psf_log_printf(psf, " SSND : %u (should be %D)\n", SSNDsize, (unsigned long )(psf->filelength - psf->dataoffset) + sizeof(SSND_CHUNK ));
#line 532
      psf->datalength = psf->filelength - psf->dataoffset;
      }
    } else {
      {
#line 535
      psf_log_printf(psf, " SSND : %u\n", SSNDsize);
      }
    }
#line 537
    if (ssnd_fmt.offset == 0U) {
      {
#line 538
      psf_log_printf(psf, "  Offset     : %u\n", ssnd_fmt.offset);
#line 539
      psf_log_printf(psf, "  Block Size : %u\n", ssnd_fmt.blocksize);
#line 541
      psf->dataoffset += (long )ssnd_fmt.offset;
#line 542
      psf->datalength -= (long )ssnd_fmt.offset;
      }
    } else
#line 537
    if (psf->dataoffset + (long )ssnd_fmt.offset == (long )ssnd_fmt.blocksize) {
      {
#line 538
      psf_log_printf(psf, "  Offset     : %u\n", ssnd_fmt.offset);
#line 539
      psf_log_printf(psf, "  Block Size : %u\n", ssnd_fmt.blocksize);
#line 541
      psf->dataoffset += (long )ssnd_fmt.offset;
#line 542
      psf->datalength -= (long )ssnd_fmt.offset;
      }
    } else {
      {
#line 545
      psf_log_printf(psf, "  Offset     : %u\n", ssnd_fmt.offset);
#line 546
      psf_log_printf(psf, "  Block Size : %u ???\n", ssnd_fmt.blocksize);
#line 547
      psf->dataoffset += (long )ssnd_fmt.offset;
#line 548
      psf->datalength -= (long )ssnd_fmt.offset;
      }
    }
#line 552
    if (psf->datalength + psf->dataoffset < psf->filelength) {
#line 553
      psf->dataend = psf->datalength + psf->dataoffset;
    }
#line 555
    found_chunk |= 32;
#line 557
    if (! psf->sf.seekable) {
#line 558
      goto switch_break;
    }
    {
#line 561
    psf_fseek(psf, psf->dataoffset + psf->datalength, 0);
    }
#line 562
    goto switch_break;
    case_exp___5: 
#line 565
    if (chunk_size == 0U) {
#line 566
      goto switch_break;
    }
#line 567
    if (chunk_size >= (unsigned int )((int )sizeof(ubuf.scbuf))) {
      {
#line 568
      psf_log_printf(psf, " %M : %d (too big)\n", marker, chunk_size);
      }
#line 569
      return (30);
    }
    {
#line 572
    cptr = ubuf.cbuf;
#line 573
    psf_binheader_readf(psf, "b", cptr, chunk_size + (chunk_size & 1U));
#line 574
    *(cptr + chunk_size) = (char)0;
#line 576
    psf_sanitize_string(cptr, (int )chunk_size);
#line 578
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 579
    psf_store_string(psf, 2, (char const   *)cptr);
#line 580
    chunk_size += chunk_size & 1U;
    }
#line 581
    goto switch_break;
    case_exp___6: 
#line 584
    if (chunk_size == 0U) {
#line 585
      goto switch_break;
    }
#line 586
    if (chunk_size >= (unsigned int )((int )sizeof(ubuf.scbuf) - 1)) {
      {
#line 587
      psf_log_printf(psf, " %M : %d (too big)\n", marker, chunk_size);
      }
#line 588
      return (30);
    }
    {
#line 591
    cptr = ubuf.cbuf;
#line 592
    psf_binheader_readf(psf, "b", cptr, chunk_size + (chunk_size & 1U));
#line 593
    *(cptr + chunk_size) = (char)0;
#line 594
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 595
    psf_store_string(psf, 4, (char const   *)cptr);
#line 596
    chunk_size += chunk_size & 1U;
    }
#line 597
    goto switch_break;
    case_exp___7: 
#line 603
    if (chunk_size == 0U) {
#line 604
      goto switch_break;
    }
    {
#line 605
    bytes = chunk_size;
#line 606
    __cil_tmp38 = psf_binheader_readf(psf, "E2", & count___0);
#line 606
    bytes -= (unsigned int )__cil_tmp38;
#line 607
    psf_log_printf(psf, " %M : %d\n  count  : %d\n", marker, chunk_size, (int )count___0);
#line 609
    k = 0;
    }
    {
#line 609
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 609
      if (! (k < (int )count___0)) {
#line 609
        goto while_break___1;
      }
      {
#line 610
      __cil_tmp39 = psf_binheader_readf(psf, "E422", & timestamp, & id, & len);
#line 610
      bytes -= (unsigned int )__cil_tmp39;
#line 611
      psf_log_printf(psf, "   time   : 0x%x\n   marker : %x\n   length : %d\n", timestamp,
                     (int )id, (int )len);
      }
#line 613
      if ((int )len + 1 > (int )sizeof(ubuf.scbuf)) {
        {
#line 614
        psf_log_printf(psf, "\nError : string length (%d) too big.\n", (int )len);
        }
#line 615
        return (30);
      }
      {
#line 618
      cptr = ubuf.cbuf;
#line 619
      __cil_tmp40 = psf_binheader_readf(psf, "b", cptr, (int )len);
#line 619
      bytes -= (unsigned int )__cil_tmp40;
#line 620
      *(cptr + (int )len) = (char)0;
#line 621
      psf_log_printf(psf, "   string : %s\n", cptr);
#line 609
      k ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: ;
#line 624
    if (bytes > 0U) {
      {
#line 625
      psf_binheader_readf(psf, "j", bytes);
      }
    }
#line 627
    goto switch_break;
    case_exp___8: 
#line 632
    if (chunk_size == 0U) {
#line 633
      goto switch_break;
    }
#line 634
    if (chunk_size >= (unsigned int )((int )sizeof(ubuf.scbuf) - 1)) {
      {
#line 635
      psf_log_printf(psf, " %M : %u (too big, skipping)\n", marker, chunk_size);
#line 636
      psf_binheader_readf(psf, "j", chunk_size + (chunk_size & 1U));
      }
#line 637
      goto switch_break;
    }
#line 640
    if (chunk_size < 4U) {
      {
#line 641
      psf_log_printf(psf, " %M : %d (too small, skipping)\n", marker, chunk_size);
#line 642
      psf_binheader_readf(psf, "j", chunk_size + (chunk_size & 1U));
      }
#line 643
      goto switch_break;
    }
    {
#line 646
    cptr = ubuf.cbuf;
#line 647
    psf_binheader_readf(psf, "mb", & appl_marker, cptr, (chunk_size + (chunk_size & 1U)) - 4U);
#line 648
    *(cptr + chunk_size) = (char)0;
#line 650
    k = 0;
    }
    {
#line 650
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 650
      if (! (k < (int )chunk_size)) {
#line 650
        goto while_break___2;
      }
      {
#line 651
      __cil_tmp43 = psf_isprint((int )*(cptr + k));
      }
#line 651
      if (! __cil_tmp43) {
#line 652
        *(cptr + k) = (char)0;
#line 653
        goto while_break___2;
      }
#line 650
      k ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 656
    psf_log_printf(psf, " %M : %d\n  AppSig : %M\n  Name   : %s\n", marker, chunk_size,
                   appl_marker, cptr);
#line 657
    psf_store_string(psf, 3, (char const   *)cptr);
#line 658
    chunk_size += chunk_size & 1U;
    }
#line 660
    goto switch_break;
    case_exp___9: 
#line 663
    if (chunk_size == 0U) {
#line 664
      goto switch_break;
    }
#line 665
    if (chunk_size >= (unsigned int )((int )sizeof(ubuf.scbuf) - 2)) {
      {
#line 666
      psf_log_printf(psf, " %M : %d (too big)\n", marker, chunk_size);
      }
#line 667
      return (30);
    }
    {
#line 670
    cptr = ubuf.cbuf;
#line 671
    psf_binheader_readf(psf, "b", cptr, chunk_size + (chunk_size & 1U));
#line 672
    *(cptr + chunk_size) = (char)0;
#line 673
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 674
    psf_store_string(psf, 1, (char const   *)cptr);
#line 675
    chunk_size += chunk_size & 1U;
    }
#line 676
    goto switch_break;
    case_exp___10: 
#line 679
    if (chunk_size == 0U) {
#line 680
      goto switch_break;
    }
#line 681
    if (chunk_size >= (unsigned int )((int )sizeof(ubuf.scbuf) - 2)) {
      {
#line 682
      psf_log_printf(psf, " %M : %d (too big)\n", marker, chunk_size);
      }
#line 683
      return (30);
    }
    {
#line 686
    cptr = ubuf.cbuf;
#line 687
    psf_binheader_readf(psf, "b", cptr, chunk_size + (chunk_size & 1U));
#line 688
    *(cptr + chunk_size) = (char)0;
#line 689
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 690
    psf_store_string(psf, 5, (char const   *)cptr);
#line 691
    chunk_size += chunk_size & 1U;
    }
#line 692
    goto switch_break;
    case_exp___11: 
#line 695
    if (chunk_size != 20U) {
      {
#line 696
      psf_log_printf(psf, " %M : %d (should be %d)\n\230\001", marker, chunk_size,
                     20);
#line 697
      psf_binheader_readf(psf, "j", chunk_size);
      }
#line 698
      goto switch_break;
    }
    {
#line 700
    psf_log_printf(psf, " %M : %d\n", marker, chunk_size);
#line 704
    psf->instrument = psf_instrument_alloc();
    }
#line 704
    if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 704
      if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 705
        return (17);
      }
    }
    {
#line 707
    psf_binheader_readf(psf, "b", bytes___0, 6);
#line 708
    psf_log_printf(psf, "  Base Note : %u\n  Detune    : %u\n  Low  Note : %u\n  High Note : %u\n  Low  Vel. : %u\n  High Vel. : %u\n",
                   (int )bytes___0[0], (int )bytes___0[1], (int )bytes___0[2], (int )bytes___0[3],
                   (int )bytes___0[4], (int )bytes___0[5]);
#line 712
    (psf->instrument)->basenote = (char )bytes___0[0];
#line 713
    (psf->instrument)->detune = (char )bytes___0[1];
#line 714
    (psf->instrument)->key_lo = (char )bytes___0[2];
#line 715
    (psf->instrument)->key_hi = (char )bytes___0[3];
#line 716
    (psf->instrument)->velocity_lo = (char )bytes___0[4];
#line 717
    (psf->instrument)->velocity_hi = (char )bytes___0[5];
#line 718
    psf_binheader_readf(psf, "E2", & gain);
#line 719
    (psf->instrument)->gain = (int )gain;
#line 720
    psf_log_printf(psf, "  Gain (dB) : %d\n", (int )gain);
#line 726
    psf_binheader_readf(psf, "E222", & mode, & begin, & end);
#line 727
    loop_mode = get_loop_mode_str(mode);
#line 728
    mode = get_loop_mode(mode);
    }
#line 729
    if ((int )mode == 800) {
#line 730
      (psf->instrument)->loop_count = 0;
#line 731
      (psf->instrument)->loops[0].mode = 800;
    } else {
#line 734
      (psf->instrument)->loop_count = 1;
#line 735
      (psf->instrument)->loops[0].mode = 801;
#line 736
      (psf->instrument)->loops[0].start = (uint32_t )begin;
#line 737
      (psf->instrument)->loops[0].end = (uint32_t )end;
#line 738
      (psf->instrument)->loops[0].count = (uint32_t )0;
    }
    {
#line 740
    psf_log_printf(psf, "  Sustain\n   mode  : %d => %s\n   begin : %u\n   end   : %u\n",
                   (int )mode, loop_mode, (int )begin, (int )end);
#line 742
    psf_binheader_readf(psf, "E222", & mode, & begin, & end);
#line 743
    loop_mode = get_loop_mode_str(mode);
#line 744
    mode = get_loop_mode(mode);
    }
#line 745
    if ((int )mode == 800) {
#line 746
      (psf->instrument)->loops[1].mode = 800;
    } else {
#line 748
      ((psf->instrument)->loop_count) ++;
#line 749
      (psf->instrument)->loops[1].mode = 801;
#line 750
      (psf->instrument)->loops[1].start = (uint32_t )begin;
#line 751
      (psf->instrument)->loops[1].end = (uint32_t )end;
#line 752
      (psf->instrument)->loops[1].count = (uint32_t )0;
    }
    {
#line 754
    psf_log_printf(psf, "  Release\n   mode  : %d => %s\n   begin : %u\n   end   : %u\n",
                   (int )mode, loop_mode, (int )begin, (int )end);
#line 757
    instr_found ++;
    }
#line 758
    goto switch_break;
    case_exp___12: 
    {
#line 761
    psf_log_printf(psf, " basc : %u\n", chunk_size);
#line 763
    error = aiff_read_basc_chunk(psf, (int )chunk_size);
    }
#line 763
    if (error) {
#line 764
      return (error);
    }
#line 765
    goto switch_break;
    case_exp___13: 
    {
#line 768
    psf_log_printf(psf, " %M : %d\n", marker, chunk_size);
#line 769
    n = (unsigned short)0;
#line 772
    __cil_tmp61 = psf_binheader_readf(psf, "E2", & n);
#line 772
    bytesread = (unsigned int )__cil_tmp61;
#line 773
    mark_count = (int )n;
#line 774
    psf_log_printf(psf, "  Count : %d\n", mark_count);
    }
#line 775
    if ((unsigned long )paiff->markstr != (unsigned long )((void *)0)) {
      {
#line 776
      psf_log_printf(psf, "*** Second MARK chunk found. Throwing away the first.\n");
#line 777
      free((void *)paiff->markstr);
      }
    }
    {
#line 779
    tmp___2 = calloc((unsigned long )mark_count, sizeof(MARK_ID_POS ));
#line 779
    paiff->markstr = (MARK_ID_POS *)tmp___2;
    }
#line 780
    if ((unsigned long )paiff->markstr == (unsigned long )((void *)0)) {
#line 781
      return (17);
    }
#line 783
    n = (unsigned short)0;
    {
#line 783
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 783
      if ((int )n < mark_count) {
#line 783
        if (! (bytesread < chunk_size)) {
#line 783
          goto while_break___3;
        }
      } else {
#line 783
        goto while_break___3;
      }
      {
#line 787
      __cil_tmp65 = psf_binheader_readf(psf, "E241", & mark_id, & position___0, & ch);
#line 787
      bytesread += (unsigned int )__cil_tmp65;
#line 788
      psf_log_printf(psf, "   Mark ID  : %u\n   Position : %u\n", (int )mark_id, position___0);
      }
#line 790
      if ((int )ch & 1) {
#line 790
        tmp___1 = (int )ch;
      } else {
#line 790
        tmp___1 = (int )ch + 1;
      }
#line 790
      pstr_len = (unsigned int )tmp___1;
#line 792
      if ((unsigned long )pstr_len < sizeof(ubuf.scbuf) - 1UL) {
        {
#line 793
        __cil_tmp67 = psf_binheader_readf(psf, "b", ubuf.scbuf, pstr_len);
#line 793
        bytesread += (unsigned int )__cil_tmp67;
#line 794
        ubuf.scbuf[pstr_len] = (signed char)0;
        }
      } else {
        {
#line 797
        read_len = (unsigned int )((unsigned long )pstr_len - (sizeof(ubuf.scbuf) - 1UL));
#line 798
        __cil_tmp69 = psf_binheader_readf(psf, "bj", ubuf.scbuf, read_len, pstr_len - read_len);
#line 798
        bytesread += (unsigned int )__cil_tmp69;
#line 799
        ubuf.scbuf[sizeof(ubuf.scbuf) - 1UL] = (signed char)0;
        }
      }
      {
#line 802
      psf_log_printf(psf, "   Name     : %s\n", ubuf.scbuf);
#line 804
      (paiff->markstr + (int )n)->markerID = mark_id;
#line 805
      (paiff->markstr + (int )n)->position = position___0;
#line 783
      n = (unsigned short )((int )n + 1);
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
    {
#line 814
    mark_found ++;
#line 815
    psf_binheader_readf(psf, "j", chunk_size - bytesread);
    }
#line 816
    goto switch_break;
    case_exp___14: 
#line 819
    found_chunk |= 8;
    case_exp___15: 
    {
#line 823
    psf_log_printf(psf, " %M : %d\n", marker, chunk_size);
#line 824
    psf_binheader_readf(psf, "j", chunk_size);
    }
#line 825
    goto switch_break;
    case_exp___16: 
    {
#line 829
    chunk_size = (chunk_size >> 24) - 3U;
#line 830
    psf_log_printf(psf, " %M : %d\n", marker, chunk_size);
#line 831
    __cil_tmp72 = make_size_t((int )chunk_size);
#line 831
    psf_binheader_readf(psf, "j", __cil_tmp72);
    }
#line 832
    goto switch_break;
    case_exp___17: 
#line 835
    if (chunk_size < 12U) {
      {
#line 836
      psf_log_printf(psf, " %M : %d (should be >= 12)\n", marker, chunk_size);
#line 837
      psf_binheader_readf(psf, "j", chunk_size);
      }
#line 838
      goto switch_break;
    }
    {
#line 841
    psf_log_printf(psf, " %M : %d\n", marker, chunk_size);
#line 843
    error = aiff_read_chanmap(psf, chunk_size);
    }
#line 843
    if (error) {
#line 844
      return (error);
    }
#line 845
    goto switch_break;
    switch_default___0: 
#line 848
    if (chunk_size >= 4294901760U) {
      {
#line 849
      done = 1;
#line 850
      __cil_tmp74 = psf_ftell(psf);
#line 850
      psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\n",
                     marker, __cil_tmp74 - 8L, chunk_size);
      }
#line 851
      goto switch_break;
    }
    {
#line 854
    __cil_tmp78 = psf_isprint((int )(marker & 255U));
#line 854
    __cil_tmp77 = psf_isprint((int )((marker >> 8) & 255U));
#line 854
    __cil_tmp76 = psf_isprint((int )((marker >> 16) & 255U));
#line 854
    __cil_tmp75 = psf_isprint((int )((marker >> 24) & 255U));
    }
#line 854
    if (__cil_tmp75) {
#line 854
      if (__cil_tmp76) {
#line 854
        if (__cil_tmp77) {
#line 854
          if (__cil_tmp78) {
            {
#line 856
            psf_log_printf(psf, " %M : %u (unknown marker)\n", marker, chunk_size);
#line 858
            psf_binheader_readf(psf, "j", chunk_size);
            }
#line 859
            goto switch_break;
          }
        }
      }
    }
    {
#line 862
    __cil_tmp79 = psf_ftell(psf);
    }
#line 862
    if (__cil_tmp79 & 3L) {
      {
#line 863
      __cil_tmp80 = psf_ftell(psf);
#line 863
      psf_log_printf(psf, "  Unknown chunk marker at position %D. Resynching.\n",
                     __cil_tmp80 - 8L);
#line 864
      psf_binheader_readf(psf, "j", -3);
      }
#line 865
      goto switch_break;
    }
    {
#line 867
    __cil_tmp81 = psf_ftell(psf);
#line 867
    psf_log_printf(psf, "*** Unknown chunk marker %X at position %D. Exiting parser.\n",
                   marker, __cil_tmp81);
#line 868
    done = 1;
    }
#line 869
    goto switch_break;
    switch_break: ;
#line 872
    if ((long )chunk_size >= psf->filelength) {
      {
#line 873
      psf_log_printf(psf, "*** Chunk size %u > file length %D. Exiting parser.\n",
                     chunk_size, psf->filelength);
      }
#line 874
      goto while_break;
    }
#line 877
    if (! psf->sf.seekable) {
#line 877
      if (found_chunk & 32) {
#line 878
        goto while_break;
      }
    }
    {
#line 880
    __cil_tmp82 = psf_ftell(psf);
    }
#line 880
    if (__cil_tmp82 >= psf->filelength - (long )(2 * (int )sizeof(int32_t ))) {
#line 881
      goto while_break;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 884
  if (instr_found) {
#line 884
    if (mark_found) {
#line 887
      j = 0;
      {
#line 887
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 887
        if (! (j < (psf->instrument)->loop_count)) {
#line 887
          goto while_break___4;
        }
#line 888
        if (j < (int )(sizeof((psf->instrument)->loops) / sizeof((psf->instrument)->loops[0]))) {
          {
#line 889
          (psf->instrument)->loops[j].start = marker_to_position(paiff->markstr, (unsigned short )(psf->instrument)->loops[j].start,
                                                                 mark_count);
#line 890
          (psf->instrument)->loops[j].end = marker_to_position(paiff->markstr, (unsigned short )(psf->instrument)->loops[j].end,
                                                               mark_count);
#line 891
          (psf->instrument)->loops[j].mode = 801;
          }
        }
#line 887
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: ;
    }
  }
#line 896
  if (psf->sf.channels < 1) {
#line 897
    return (33);
  }
#line 899
  if (psf->sf.channels >= 1024) {
#line 900
    return (34);
  }
#line 902
  if (! (found_chunk & 1)) {
#line 903
    return (79);
  }
#line 905
  if (! (found_chunk & 2)) {
#line 906
    return (81);
  }
#line 908
  if (! (found_chunk & 16)) {
#line 909
    return (82);
  }
#line 911
  if (! psf->dataoffset) {
#line 912
    return (89);
  }
#line 914
  return (0);
}
}
#line 918 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_close(SF_PRIVATE *psf ) 
{ 
  AIFF_PRIVATE *paiff ;

  {
#line 919
  paiff = (AIFF_PRIVATE *)psf->container_data;
#line 921
  if ((unsigned long )paiff != (unsigned long )((void *)0)) {
#line 921
    if ((unsigned long )paiff->markstr != (unsigned long )((void *)0)) {
      {
#line 922
      free((void *)paiff->markstr);
#line 923
      paiff->markstr = (MARK_ID_POS *)((void *)0);
      }
    }
  }
#line 926
  if (psf->file.mode == 32) {
    {
#line 927
    aiff_write_tailer(psf);
#line 928
    aiff_write_header(psf, 1);
    }
  } else
#line 926
  if (psf->file.mode == 48) {
    {
#line 927
    aiff_write_tailer(psf);
#line 928
    aiff_write_header(psf, 1);
    }
  }
#line 931
  return (0);
}
}
#line 935 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_read_comm_chunk(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) 
{ 
  BUF_UNION ubuf ;
  int subformat ;
  int samplerate ;
  int32_t __cil_tmp6 ;
  unsigned char encoding_len ;
  unsigned int read_len ;
  char const   *tmp ;

  {
  {
#line 939
  ubuf.scbuf[0] = (signed char)0;
#line 946
  psf_binheader_readf(psf, "E242b", & comm_fmt->numChannels, & comm_fmt->numSampleFrames,
                      & comm_fmt->sampleSize, & comm_fmt->sampleRate, (int )sizeof(comm_fmt->sampleRate));
  }
#line 949
  if (comm_fmt->size > 65536U) {
#line 949
    if ((comm_fmt->size & 65535U) == 0U) {
      {
#line 950
      psf_log_printf(psf, " COMM : %d (0x%x) *** should be \230\001", comm_fmt->size,
                     comm_fmt->size);
#line 951
      __cil_tmp6 = ENDSWAP_32((int32_t )comm_fmt->size);
#line 951
      comm_fmt->size = (unsigned int )__cil_tmp6;
#line 952
      psf_log_printf(psf, "%d (0x%x)\n", comm_fmt->size, comm_fmt->size);
      }
    } else {
      {
#line 955
      psf_log_printf(psf, " COMM : %d\n\333\204U", comm_fmt->size);
      }
    }
  } else {
    {
#line 955
    psf_log_printf(psf, " COMM : %d\n\333\204U", comm_fmt->size);
    }
  }
#line 957
  if (comm_fmt->size == 18U) {
#line 958
    comm_fmt->encoding = (unsigned int )((78 | (79 << 8)) | (78 << 16)) | (69U << 24);
  } else
#line 959
  if (comm_fmt->size == 22U) {
    {
#line 960
    psf_binheader_readf(psf, "Em\212\333\204U", & comm_fmt->encoding);
    }
  } else
#line 961
  if (comm_fmt->size >= 24U) {
    {
#line 965
    psf_binheader_readf(psf, "Em1\333\204U", & comm_fmt->encoding, & encoding_len);
#line 967
    comm_fmt->size = 0U;
#line 968
    memset((void *)(ubuf.scbuf), 0, (unsigned long )comm_fmt->size);
#line 969
    read_len = (comm_fmt->size - 24U) + 1U;
#line 970
    psf_binheader_readf(psf, "b", ubuf.scbuf, read_len);
#line 971
    ubuf.scbuf[read_len + 1U] = (signed char)0;
    }
  }
  {
#line 974
  samplerate = tenbytefloat2int(comm_fmt->sampleRate);
#line 976
  psf_log_printf(psf, "  Sample Rate : %d\n\333\204U", samplerate);
  }
#line 977
  if (comm_fmt->numSampleFrames == 0U) {
#line 977
    if (psf->filelength > 104L) {
#line 977
      tmp = " (Should not be 0)";
    } else {
#line 977
      tmp = "\220";
    }
  } else {
#line 977
    tmp = "\220";
  }
  {
#line 977
  psf_log_printf(psf, "  Frames      : %u%s\n", comm_fmt->numSampleFrames, tmp);
#line 978
  psf_log_printf(psf, "  Channels    : %d\n", (int )comm_fmt->numChannels);
  }
#line 981
  if (comm_fmt->encoding == ((unsigned int )((102 | (108 << 8)) | (51 << 16)) | (50U << 24))) {
    _L___45: 
#line 981
    if ((int )comm_fmt->sampleSize != 32) {
      {
#line 982
      psf_log_printf(psf, "  Sample Size : %d (should be 32)\n", (int )comm_fmt->sampleSize);
#line 983
      comm_fmt->sampleSize = (short)32;
      }
    } else {
#line 981
      goto _L___44;
    }
  } else
#line 981
  if (comm_fmt->encoding == ((unsigned int )((70 | (76 << 8)) | (51 << 16)) | (50U << 24))) {
#line 981
    goto _L___45;
  } else
  _L___44: 
#line 985
  if (comm_fmt->encoding == ((unsigned int )((102 | (108 << 8)) | (54 << 16)) | (52U << 24))) {
    _L: 
#line 985
    if ((int )comm_fmt->sampleSize != 64) {
      {
#line 986
      psf_log_printf(psf, "  Sample Size : %d (should be 64)\n", (int )comm_fmt->sampleSize);
#line 987
      comm_fmt->sampleSize = (short)64;
      }
    } else {
      {
#line 990
      psf_log_printf(psf, "  Sample Size : %d\n\333\204U", (int )comm_fmt->sampleSize);
      }
    }
  } else
#line 985
  if (comm_fmt->encoding == ((unsigned int )((70 | (76 << 8)) | (54 << 16)) | (52U << 24))) {
#line 985
    goto _L;
  } else {
    {
#line 990
    psf_log_printf(psf, "  Sample Size : %d\n\333\204U", (int )comm_fmt->sampleSize);
    }
  }
  {
#line 992
  subformat = s_bitwidth_to_subformat((int )comm_fmt->sampleSize);
#line 994
  psf->sf.samplerate = samplerate;
#line 995
  psf->sf.frames = (sf_count_t )comm_fmt->numSampleFrames;
#line 996
  psf->sf.channels = (int )comm_fmt->numChannels;
#line 997
  psf->bytewidth = ((int )comm_fmt->sampleSize + 7) / 8;
#line 999
  psf->endian = 536870912;
  }
#line 1002
  if (comm_fmt->encoding == ((unsigned int )((78 | (79 << 8)) | (78 << 16)) | (69U << 24))) {
#line 1002
    goto case_exp;
  }
#line 1008
  if (comm_fmt->encoding == ((unsigned int )((105 | (110 << 8)) | (51 << 16)) | (50U << 24))) {
#line 1008
    goto case_exp___0;
  }
#line 1008
  if (comm_fmt->encoding == ((unsigned int )((105 | (110 << 8)) | (50 << 16)) | (52U << 24))) {
#line 1008
    goto case_exp___0;
  }
#line 1008
  if (comm_fmt->encoding == ((unsigned int )((116 | (119 << 8)) | (111 << 16)) | (115U << 24))) {
#line 1008
    goto case_exp___0;
  }
#line 1014
  if (comm_fmt->encoding == ((unsigned int )((50 | (51 << 8)) | (110 << 16)) | (105U << 24))) {
#line 1014
    goto case_exp___3;
  }
#line 1014
  if (comm_fmt->encoding == ((unsigned int )((52 | (50 << 8)) | (110 << 16)) | (49U << 24))) {
#line 1014
    goto case_exp___3;
  }
#line 1014
  if (comm_fmt->encoding == ((unsigned int )((115 | (111 << 8)) | (119 << 16)) | (116U << 24))) {
#line 1014
    goto case_exp___3;
  }
#line 1020
  if (comm_fmt->encoding == ((unsigned int )((70 | (76 << 8)) | (51 << 16)) | (50U << 24))) {
#line 1020
    goto case_exp___6;
  }
#line 1020
  if (comm_fmt->encoding == ((unsigned int )((102 | (108 << 8)) | (51 << 16)) | (50U << 24))) {
#line 1020
    goto case_exp___6;
  }
#line 1025
  if (comm_fmt->encoding == ((unsigned int )((85 | (76 << 8)) | (65 << 16)) | (87U << 24))) {
#line 1025
    goto case_exp___8;
  }
#line 1025
  if (comm_fmt->encoding == ((unsigned int )((117 | (108 << 8)) | (97 << 16)) | (119U << 24))) {
#line 1025
    goto case_exp___8;
  }
#line 1030
  if (comm_fmt->encoding == ((unsigned int )((65 | (76 << 8)) | (65 << 16)) | (87U << 24))) {
#line 1030
    goto case_exp___10;
  }
#line 1030
  if (comm_fmt->encoding == ((unsigned int )((97 | (108 << 8)) | (97 << 16)) | (119U << 24))) {
#line 1030
    goto case_exp___10;
  }
#line 1035
  if (comm_fmt->encoding == ((unsigned int )((70 | (76 << 8)) | (54 << 16)) | (52U << 24))) {
#line 1035
    goto case_exp___12;
  }
#line 1035
  if (comm_fmt->encoding == ((unsigned int )((102 | (108 << 8)) | (54 << 16)) | (52U << 24))) {
#line 1035
    goto case_exp___12;
  }
#line 1039
  if (comm_fmt->encoding == ((unsigned int )((114 | (97 << 8)) | (119 << 16)) | (32U << 24))) {
#line 1039
    goto case_exp___14;
  }
#line 1043
  if (comm_fmt->encoding == ((unsigned int )((68 | (87 << 8)) | (86 << 16)) | (87U << 24))) {
#line 1043
    goto case_exp___15;
  }
#line 1046
  if (comm_fmt->encoding == 12U) {
#line 1046
    goto case_12;
  }
#line 1049
  if (comm_fmt->encoding == 16U) {
#line 1049
    goto case_16;
  }
#line 1052
  if (comm_fmt->encoding == 24U) {
#line 1052
    goto case_24;
  }
#line 1062
  if (comm_fmt->encoding == ((unsigned int )((71 | (83 << 8)) | (77 << 16)) | (32U << 24))) {
#line 1062
    goto case_exp___16;
  }
#line 1068
  if (comm_fmt->encoding == ((unsigned int )((105 | (109 << 8)) | (97 << 16)) | (52U << 24))) {
#line 1068
    goto case_exp___17;
  }
#line 1073
  goto switch_default___0;
  case_exp: 
#line 1003
  psf->sf.format = 131072 | subformat;
#line 1004
  goto switch_break;
  case_exp___0: 
#line 1009
  psf->sf.format = 537001984 | subformat;
#line 1010
  goto switch_break;
  case_exp___3: 
#line 1015
  psf->endian = 268435456;
#line 1016
  psf->sf.format = 268566528 | subformat;
#line 1017
  goto switch_break;
  case_exp___6: 
#line 1021
  psf->sf.format = 131078;
#line 1022
  goto switch_break;
  case_exp___8: 
#line 1026
  psf->sf.format = 131088;
#line 1027
  goto switch_break;
  case_exp___10: 
#line 1031
  psf->sf.format = 131089;
#line 1032
  goto switch_break;
  case_exp___12: 
#line 1036
  psf->sf.format = 131079;
#line 1037
  goto switch_break;
  case_exp___14: 
#line 1040
  psf->sf.format = 131077;
#line 1041
  goto switch_break;
  case_exp___15: 
#line 1044
  psf->sf.format = 131072;
#line 1046
  if ((int )comm_fmt->sampleSize == 12) {
#line 1046
    goto case_12;
  }
#line 1049
  if ((int )comm_fmt->sampleSize == 16) {
#line 1049
    goto case_16;
  }
#line 1052
  if ((int )comm_fmt->sampleSize == 24) {
#line 1052
    goto case_24;
  }
#line 1056
  goto switch_default;
  case_12: 
#line 1047
  psf->sf.format |= 64;
#line 1048
  goto switch_break___0;
  case_16: 
#line 1050
  psf->sf.format |= 65;
#line 1051
  goto switch_break___0;
  case_24: 
#line 1053
  psf->sf.format |= 66;
#line 1054
  goto switch_break___0;
  switch_default: 
#line 1057
  psf->sf.format |= 67;
#line 1058
  goto switch_break___0;
  switch_break___0: ;
#line 1060
  goto switch_break;
  case_exp___16: 
#line 1063
  psf->sf.format = 131072;
#line 1064
  psf->sf.format = 131104;
#line 1065
  goto switch_break;
  case_exp___17: 
#line 1069
  psf->endian = 536870912;
#line 1070
  psf->sf.format = 131090;
#line 1071
  goto switch_break;
  switch_default___0: 
  {
#line 1074
  psf_log_printf(psf, "AIFC : Unimplemented format : %M\n\360\245\333\204U", comm_fmt->encoding);
  }
#line 1075
  return (18);
  switch_break: ;
#line 1078
  if (! ubuf.scbuf[0]) {
    {
#line 1079
    psf_log_printf(psf, "  Encoding    : %M\n\333\204U", comm_fmt->encoding);
    }
  } else {
    {
#line 1081
    psf_log_printf(psf, "  Encoding    : %M => %s\n\020", comm_fmt->encoding, ubuf.scbuf);
    }
  }
#line 1083
  return (0);
}
}
#line 1091 "/root/patchweave_donee/23/src/aiff.c"
static void aiff_rewrite_header(SF_PRIVATE *psf ) 
{ 
  int k ;
  int ch ;
  int comm_size ;
  int comm_frames ;
  time_t __cil_tmp8 ;

  {
  {
#line 1100
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1101
  psf_fread((void *)(psf->header), psf->dataoffset, (sf_count_t )1, psf);
#line 1103
  psf->headindex = 0;
#line 1106
  psf_binheader_writef(psf, "Etm8\204U", (unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24),
                       psf->filelength - 8L);
#line 1109
  k = psf_find_read_chunk_m32(& psf->rchunks, (unsigned int )((67 | (79 << 8)) | (77 << 16)) | (77U << 24));
  }
#line 1109
  if (k >= 0) {
    {
#line 1110
    psf->headindex = (int )((psf->rchunks.chunks + k)->offset - 8L);
#line 1111
    comm_frames = (int )psf->sf.frames;
#line 1112
    comm_size = (int )(psf->rchunks.chunks + k)->len;
#line 1113
    psf_binheader_writef(psf, "Em42t4", (unsigned int )((67 | (79 << 8)) | (77 << 16)) | (77U << 24),
                         comm_size, psf->sf.channels, comm_frames);
    }
  }
  {
#line 1117
  k = psf_find_read_chunk_m32(& psf->rchunks, (unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24));
  }
#line 1117
  if (k >= 0) {
    {
#line 1118
    psf->headindex = (int )((psf->rchunks.chunks + k)->offset - 8L);
#line 1119
    psf_binheader_writef(psf, "Em4", (unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24),
                         2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1120
    __cil_tmp8 = time((time_t *)((void *)0));
#line 1120
    psf_binheader_writef(psf, "E44", 1, __cil_tmp8);
#line 1121
    ch = 0;
    }
    {
#line 1121
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1121
      if (! (ch < psf->sf.channels)) {
#line 1121
        goto while_break;
      }
      {
#line 1122
      psf_binheader_writef(psf, "Eft8", (double )((float )(psf->peak_info)->peaks[ch].value),
                           (psf->peak_info)->peaks[ch].position);
#line 1121
      ch ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 1127
  k = psf_find_read_chunk_m32(& psf->rchunks, (unsigned int )((83 | (83 << 8)) | (78 << 16)) | (68U << 24));
  }
#line 1127
  if (k >= 0) {
    {
#line 1128
    psf->headindex = (int )((psf->rchunks.chunks + k)->offset - 8L);
#line 1129
    psf_binheader_writef(psf, "Etm8\204U", (unsigned int )((83 | (83 << 8)) | (78 << 16)) | (68U << 24),
                         psf->datalength + 8L);
    }
  }
  {
#line 1133
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1134
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 1136
  return;
}
}
#line 1140 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  AIFF_PRIVATE *paiff ;
  unsigned char comm_sample_rate[10] ;
  unsigned char comm_zero_bytes[2] ;
  unsigned int comm_type ;
  unsigned int comm_size ;
  unsigned int comm_encoding ;
  unsigned int comm_frames ;
  unsigned int uk ;
  int k ;
  int endian ;
  int has_data ;
  short bit_width ;
  long tmp ;
  MARK_ID_POS m[4] ;
  INST_CHUNK ch ;
  unsigned short ct ;
  unsigned short __cil_tmp22 ;
  unsigned short __cil_tmp23 ;
  unsigned short __cil_tmp24 ;
  unsigned short __cil_tmp25 ;
  size_t __cil_tmp26 ;
  size_t __cil_tmp27 ;
  size_t __cil_tmp28 ;
  size_t __cil_tmp29 ;
  size_t __cil_tmp30 ;
  size_t __cil_tmp31 ;
  time_t __cil_tmp32 ;
  size_t __cil_tmp34 ;

  {
#line 1143
  comm_zero_bytes[0] = (unsigned char)0;
#line 1143
  comm_zero_bytes[1] = (unsigned char)0;
#line 1144
  comm_frames = 0U;
#line 1145
  has_data = 0;
#line 1148
  paiff = (AIFF_PRIVATE *)psf->container_data;
#line 1148
  if ((unsigned long )paiff == (unsigned long )((void *)0)) {
#line 1149
    return (30);
  }
  {
#line 1151
  current = psf_ftell(psf);
  }
#line 1153
  if (current > psf->dataoffset) {
#line 1154
    has_data = 1;
  }
#line 1156
  if (calc_length) {
    {
#line 1157
    psf->filelength = psf_get_filelen(psf);
#line 1159
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 1160
    if (psf->dataend) {
#line 1161
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 1163
    if (psf->bytewidth > 0) {
#line 1164
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
#line 1167
  if (psf->file.mode == 48) {
#line 1167
    if (psf->dataoffset > 0L) {
#line 1167
      if (psf->rchunks.count > 0U) {
        {
#line 1168
        aiff_rewrite_header(psf);
        }
#line 1169
        if (current > 0L) {
          {
#line 1170
          psf_fseek(psf, current, 0);
          }
        }
#line 1171
        return (0);
      }
    }
  }
#line 1174
  endian = psf->sf.format & 805306368;
#line 1175
  if (endian == 805306368) {
#line 1176
    endian = 268435456;
  }
#line 1179
  bit_width = (short )(psf->bytewidth * 8);
#line 1180
  if (psf->sf.frames > 4294967295L) {
#line 1180
    tmp = 4294967295L;
  } else {
#line 1180
    tmp = psf->sf.frames;
  }
#line 1180
  comm_frames = (unsigned int )tmp;
#line 1183
  if (((psf->sf.format & 65535) | endian) == 536870913) {
#line 1183
    goto case_536870913;
  }
#line 1190
  if (((psf->sf.format & 65535) | endian) == 268435457) {
#line 1190
    goto case_268435457;
  }
#line 1197
  if (((psf->sf.format & 65535) | endian) == 536870914) {
#line 1197
    goto case_536870914;
  }
#line 1204
  if (((psf->sf.format & 65535) | endian) == 268435458) {
#line 1204
    goto case_268435458;
  }
#line 1211
  if (((psf->sf.format & 65535) | endian) == 536870915) {
#line 1211
    goto case_536870915;
  }
#line 1218
  if (((psf->sf.format & 65535) | endian) == 268435459) {
#line 1218
    goto case_268435459;
  }
#line 1225
  if (((psf->sf.format & 65535) | endian) == 536870916) {
#line 1225
    goto case_536870916;
  }
#line 1232
  if (((psf->sf.format & 65535) | endian) == 268435460) {
#line 1232
    goto case_268435460;
  }
#line 1242
  if (((psf->sf.format & 65535) | endian) == 4) {
#line 1242
    goto case_4;
  }
#line 1242
  if (((psf->sf.format & 65535) | endian) == 3) {
#line 1242
    goto case_4;
  }
#line 1242
  if (((psf->sf.format & 65535) | endian) == 2) {
#line 1242
    goto case_4;
  }
#line 1242
  if (((psf->sf.format & 65535) | endian) == 1) {
#line 1242
    goto case_4;
  }
#line 1249
  if (((psf->sf.format & 65535) | endian) == 6) {
#line 1249
    goto case_6;
  }
#line 1256
  if (((psf->sf.format & 65535) | endian) == 7) {
#line 1256
    goto case_7;
  }
#line 1263
  if (((psf->sf.format & 65535) | endian) == 16) {
#line 1263
    goto case_16;
  }
#line 1270
  if (((psf->sf.format & 65535) | endian) == 17) {
#line 1270
    goto case_17;
  }
#line 1277
  if (((psf->sf.format & 65535) | endian) == 5) {
#line 1277
    goto case_5;
  }
#line 1284
  if (((psf->sf.format & 65535) | endian) == 64) {
#line 1284
    goto case_64;
  }
#line 1294
  if (((psf->sf.format & 65535) | endian) == 65) {
#line 1294
    goto case_65;
  }
#line 1304
  if (((psf->sf.format & 65535) | endian) == 66) {
#line 1304
    goto case_66;
  }
#line 1314
  if (((psf->sf.format & 65535) | endian) == 32) {
#line 1314
    goto case_32;
  }
#line 1324
  if (((psf->sf.format & 65535) | endian) == 18) {
#line 1324
    goto case_18;
  }
#line 1335
  goto switch_default;
  case_536870913: 
#line 1184
  psf->endian = 536870912;
#line 1185
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1186
  comm_size = 24U;
#line 1187
  comm_encoding = (unsigned int )((116 | (119 << 8)) | (111 << 16)) | (115U << 24);
#line 1188
  goto switch_break;
  case_268435457: 
#line 1191
  psf->endian = 268435456;
#line 1192
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1193
  comm_size = 24U;
#line 1194
  comm_encoding = (unsigned int )((115 | (111 << 8)) | (119 << 16)) | (116U << 24);
#line 1195
  goto switch_break;
  case_536870914: 
#line 1198
  psf->endian = 536870912;
#line 1199
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1200
  comm_size = 24U;
#line 1201
  comm_encoding = (unsigned int )((116 | (119 << 8)) | (111 << 16)) | (115U << 24);
#line 1202
  goto switch_break;
  case_268435458: 
#line 1205
  psf->endian = 268435456;
#line 1206
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1207
  comm_size = 24U;
#line 1208
  comm_encoding = (unsigned int )((115 | (111 << 8)) | (119 << 16)) | (116U << 24);
#line 1209
  goto switch_break;
  case_536870915: 
#line 1212
  psf->endian = 536870912;
#line 1213
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1214
  comm_size = 24U;
#line 1215
  comm_encoding = (unsigned int )((105 | (110 << 8)) | (50 << 16)) | (52U << 24);
#line 1216
  goto switch_break;
  case_268435459: 
#line 1219
  psf->endian = 268435456;
#line 1220
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1221
  comm_size = 24U;
#line 1222
  comm_encoding = (unsigned int )((52 | (50 << 8)) | (110 << 16)) | (49U << 24);
#line 1223
  goto switch_break;
  case_536870916: 
#line 1226
  psf->endian = 536870912;
#line 1227
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1228
  comm_size = 24U;
#line 1229
  comm_encoding = (unsigned int )((105 | (110 << 8)) | (51 << 16)) | (50U << 24);
#line 1230
  goto switch_break;
  case_268435460: 
#line 1233
  psf->endian = 268435456;
#line 1234
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1235
  comm_size = 24U;
#line 1236
  comm_encoding = (unsigned int )((50 | (51 << 8)) | (110 << 16)) | (105U << 24);
#line 1237
  goto switch_break;
  case_4: 
#line 1243
  psf->endian = 536870912;
#line 1244
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (70U << 24);
#line 1245
  comm_size = 18U;
#line 1246
  comm_encoding = 0U;
#line 1247
  goto switch_break;
  case_6: 
#line 1250
  psf->endian = 536870912;
#line 1251
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1252
  comm_size = 24U;
#line 1253
  comm_encoding = (unsigned int )((70 | (76 << 8)) | (51 << 16)) | (50U << 24);
#line 1254
  goto switch_break;
  case_7: 
#line 1257
  psf->endian = 536870912;
#line 1258
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1259
  comm_size = 24U;
#line 1260
  comm_encoding = (unsigned int )((70 | (76 << 8)) | (54 << 16)) | (52U << 24);
#line 1261
  goto switch_break;
  case_16: 
#line 1264
  psf->endian = 536870912;
#line 1265
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1266
  comm_size = 24U;
#line 1267
  comm_encoding = (unsigned int )((117 | (108 << 8)) | (97 << 16)) | (119U << 24);
#line 1268
  goto switch_break;
  case_17: 
#line 1271
  psf->endian = 536870912;
#line 1272
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1273
  comm_size = 24U;
#line 1274
  comm_encoding = (unsigned int )((97 | (108 << 8)) | (97 << 16)) | (119U << 24);
#line 1275
  goto switch_break;
  case_5: 
#line 1278
  psf->endian = 536870912;
#line 1279
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1280
  comm_size = 24U;
#line 1281
  comm_encoding = (unsigned int )((114 | (97 << 8)) | (119 << 16)) | (32U << 24);
#line 1282
  goto switch_break;
  case_64: 
#line 1285
  psf->endian = 536870912;
#line 1286
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1287
  comm_size = 24U;
#line 1288
  comm_encoding = (unsigned int )((68 | (87 << 8)) | (86 << 16)) | (87U << 24);
#line 1291
  bit_width = (short)12;
#line 1292
  goto switch_break;
  case_65: 
#line 1295
  psf->endian = 536870912;
#line 1296
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1297
  comm_size = 24U;
#line 1298
  comm_encoding = (unsigned int )((68 | (87 << 8)) | (86 << 16)) | (87U << 24);
#line 1301
  bit_width = (short)16;
#line 1302
  goto switch_break;
  case_66: 
#line 1305
  psf->endian = 536870912;
#line 1306
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1307
  comm_size = 24U;
#line 1308
  comm_encoding = (unsigned int )((68 | (87 << 8)) | (86 << 16)) | (87U << 24);
#line 1311
  bit_width = (short)24;
#line 1312
  goto switch_break;
  case_32: 
#line 1315
  psf->endian = 536870912;
#line 1316
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1317
  comm_size = 24U;
#line 1318
  comm_encoding = (unsigned int )((71 | (83 << 8)) | (77 << 16)) | (32U << 24);
#line 1321
  bit_width = (short)16;
#line 1322
  goto switch_break;
  case_18: 
#line 1325
  psf->endian = 536870912;
#line 1326
  comm_type = (unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24);
#line 1327
  comm_size = 24U;
#line 1328
  comm_encoding = (unsigned int )((105 | (109 << 8)) | (97 << 16)) | (52U << 24);
#line 1331
  bit_width = (short)16;
#line 1332
  comm_frames = (unsigned int )(psf->sf.frames / 64L);
#line 1333
  goto switch_break;
  switch_default: 
#line 1335
  return (1);
  switch_break: 
  {
#line 1339
  psf->header[0] = (unsigned char)0;
#line 1340
  psf->headindex = 0;
#line 1341
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1343
  psf_binheader_writef(psf, "Etm8", (unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24),
                       psf->filelength - 8L);
  }
#line 1346
  if (comm_type == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
    {
#line 1348
    psf_binheader_writef(psf, "Emm44", comm_type, (unsigned int )((70 | (86 << 8)) | (69 << 16)) | (82U << 24),
                         4, 2726318400U);
    }
  } else {
    {
#line 1350
    psf_binheader_writef(psf, "Em\244\333\204U", comm_type);
    }
  }
  {
#line 1352
  paiff->comm_offset = (sf_count_t )(psf->headindex - 8);
#line 1354
  memset((void *)(comm_sample_rate), 0, sizeof(comm_sample_rate));
#line 1355
  uint2tenbytefloat((unsigned int )psf->sf.samplerate, comm_sample_rate);
#line 1357
  psf_binheader_writef(psf, "Em42t42", (unsigned int )((67 | (79 << 8)) | (77 << 16)) | (77U << 24),
                       comm_size, psf->sf.channels, comm_frames, (int )bit_width);
#line 1358
  psf_binheader_writef(psf, "b", comm_sample_rate, sizeof(comm_sample_rate));
  }
#line 1361
  if (comm_type == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
    {
#line 1362
    psf_binheader_writef(psf, "mb", comm_encoding, comm_zero_bytes, sizeof(comm_zero_bytes));
    }
  }
#line 1364
  if (psf->channel_map) {
#line 1364
    if (paiff->chanmap_tag) {
      {
#line 1365
      psf_binheader_writef(psf, "Em4444", (unsigned int )((67 | (72 << 8)) | (65 << 16)) | (78U << 24),
                           12, paiff->chanmap_tag, 0, 0);
      }
    }
  }
#line 1367
  if ((unsigned long )psf->instrument != (unsigned long )((void *)0)) {
    {
#line 1370
    ct = (unsigned short)0;
#line 1372
    memset((void *)(m), 0, sizeof(m));
#line 1373
    memset((void *)(& ch), 0, sizeof(ch));
#line 1375
    ch.baseNote = (psf->instrument)->basenote;
#line 1376
    ch.detune = (psf->instrument)->detune;
#line 1377
    ch.lowNote = (psf->instrument)->key_lo;
#line 1378
    ch.highNote = (psf->instrument)->key_hi;
#line 1379
    ch.lowVelocity = (psf->instrument)->velocity_lo;
#line 1380
    ch.highVelocity = (psf->instrument)->velocity_hi;
#line 1381
    ch.gain = (short )(psf->instrument)->gain;
    }
#line 1382
    if ((psf->instrument)->loops[0].mode != 800) {
#line 1383
      ch.sustain_loop.playMode = (short)1;
#line 1384
      ch.sustain_loop.beginLoop = ct;
#line 1385
      __cil_tmp22 = ct;
#line 1385
      ct = (unsigned short )((int )ct + 1);
#line 1385
      m[0].markerID = __cil_tmp22;
#line 1386
      m[0].position = (psf->instrument)->loops[0].start;
#line 1387
      ch.sustain_loop.endLoop = ct;
#line 1388
      __cil_tmp23 = ct;
#line 1388
      ct = (unsigned short )((int )ct + 1);
#line 1388
      m[1].markerID = __cil_tmp23;
#line 1389
      m[1].position = (psf->instrument)->loops[0].end;
    }
#line 1391
    if ((psf->instrument)->loops[1].mode != 800) {
#line 1392
      ch.release_loop.playMode = (short)1;
#line 1393
      ch.release_loop.beginLoop = ct;
#line 1394
      __cil_tmp24 = ct;
#line 1394
      ct = (unsigned short )((int )ct + 1);
#line 1394
      m[2].markerID = __cil_tmp24;
#line 1395
      m[2].position = (psf->instrument)->loops[1].start;
#line 1396
      ch.release_loop.endLoop = ct;
#line 1397
      __cil_tmp25 = ct;
#line 1397
      ct = (unsigned short )((int )ct + 1);
#line 1397
      m[3].markerID = __cil_tmp25;
#line 1398
      m[3].position = (psf->instrument)->loops[1].end;
    } else {
#line 1401
      ch.release_loop.playMode = (short)0;
#line 1402
      ch.release_loop.beginLoop = (unsigned short)0;
#line 1403
      ch.release_loop.endLoop = (unsigned short)0;
    }
    {
#line 1406
    psf_binheader_writef(psf, "Em4111111", (unsigned int )((73 | (78 << 8)) | (83 << 16)) | (84U << 24),
                         20, (int )ch.baseNote, (int )ch.detune, (int )ch.lowNote,
                         (int )ch.highNote, (int )ch.lowVelocity, (int )ch.highVelocity);
#line 1408
    psf_binheader_writef(psf, "2222222", (int )ch.gain, (int )ch.sustain_loop.playMode,
                         (int )ch.sustain_loop.beginLoop, (int )ch.sustain_loop.endLoop,
                         (int )ch.release_loop.playMode, (int )ch.release_loop.beginLoop,
                         (int )ch.release_loop.endLoop);
    }
#line 1412
    if ((int )ct == 2) {
      {
#line 1413
      __cil_tmp26 = make_size_t(9);
#line 1413
      __cil_tmp27 = make_size_t(9);
#line 1413
      psf_binheader_writef(psf, "Em42241b241b", (unsigned int )((77 | (65 << 8)) | (82 << 16)) | (75U << 24),
                           34, 2, (int )m[0].markerID, m[0].position, 8, "beg loop\230",
                           __cil_tmp26, (int )m[1].markerID, m[1].position, 8, "end loop\230",
                           __cil_tmp27);
      }
    } else
#line 1417
    if ((int )ct == 4) {
      {
#line 1418
      __cil_tmp28 = make_size_t(9);
#line 1418
      __cil_tmp29 = make_size_t(9);
#line 1418
      __cil_tmp30 = make_size_t(9);
#line 1418
      __cil_tmp31 = make_size_t(9);
#line 1418
      psf_binheader_writef(psf, "Em42 241b 241b 241b 241b\221", (unsigned int )((77 | (65 << 8)) | (82 << 16)) | (75U << 24),
                           66, 4, (int )m[0].markerID, m[0].position, 8, "beg loop\230",
                           __cil_tmp28, (int )m[1].markerID, m[1].position, 8, "end loop\230",
                           __cil_tmp29, (int )m[2].markerID, m[2].position, 8, "beg loop\230",
                           __cil_tmp30, (int )m[3].markerID, m[3].position, 8, "end loop\230",
                           __cil_tmp31);
      }
    }
  }
#line 1426
  if (psf->strings.flags & 1024U) {
    {
#line 1427
    aiff_write_strings(psf, 1024);
    }
  }
#line 1429
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1429
    if ((psf->peak_info)->peak_loc == 42) {
      {
#line 1430
      psf_binheader_writef(psf, "Em4", (unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24),
                           2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1431
      __cil_tmp32 = time((time_t *)((void *)0));
#line 1431
      psf_binheader_writef(psf, "E44", 1, __cil_tmp32);
#line 1432
      k = 0;
      }
      {
#line 1432
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1432
        if (! (k < psf->sf.channels)) {
#line 1432
          goto while_break;
        }
        {
#line 1433
        psf_binheader_writef(psf, "Eft8", (double )((float )(psf->peak_info)->peaks[k].value),
                             (psf->peak_info)->peaks[k].position);
#line 1432
        k ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 1437
  uk = 0U;
  {
#line 1437
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1437
    if (! (uk < psf->wchunks.used)) {
#line 1437
      goto while_break___0;
    }
    {
#line 1438
    __cil_tmp34 = make_size_t((int )(psf->wchunks.chunks + uk)->len);
#line 1438
    psf_binheader_writef(psf, "Em4b", (psf->wchunks.chunks + uk)->mark32, (psf->wchunks.chunks + uk)->len,
                         (psf->wchunks.chunks + uk)->data, __cil_tmp34);
#line 1437
    uk ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1441
  paiff->ssnd_offset = (sf_count_t )psf->headindex;
#line 1442
  psf_binheader_writef(psf, "Etm844", (unsigned int )((83 | (83 << 8)) | (78 << 16)) | (68U << 24),
                       psf->datalength + 8L, 0, 0);
#line 1445
  psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 1447
  if (psf->error) {
#line 1448
    return (psf->error);
  }
#line 1450
  if (has_data) {
#line 1450
    if (psf->dataoffset != (long )psf->headindex) {
#line 1451
      psf->error = 30;
#line 1451
      return (psf->error);
    }
  }
#line 1453
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 1455
  if (! has_data) {
    {
#line 1456
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 1457
  if (current > 0L) {
    {
#line 1458
    psf_fseek(psf, current, 0);
    }
  }
#line 1460
  return (psf->error);
}
}
#line 1464 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_write_tailer(SF_PRIVATE *psf ) 
{ 
  int k ;
  time_t __cil_tmp5 ;

  {
  {
#line 1468
  psf->header[0] = (unsigned char)0;
#line 1469
  psf->headindex = 0;
#line 1471
  psf->dataend = psf_fseek(psf, (sf_count_t )0, 2);
  }
#line 1474
  if (psf->dataend % 2L == 1L) {
    {
#line 1475
    psf_fwrite((void const   *)(psf->header), (sf_count_t )1, (sf_count_t )1, psf);
#line 1476
    (psf->dataend) ++;
    }
  }
#line 1479
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1479
    if ((psf->peak_info)->peak_loc == 43) {
      {
#line 1480
      psf_binheader_writef(psf, "Em4", (unsigned int )((80 | (69 << 8)) | (65 << 16)) | (75U << 24),
                           2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1481
      __cil_tmp5 = time((time_t *)((void *)0));
#line 1481
      psf_binheader_writef(psf, "E44", 1, __cil_tmp5);
#line 1482
      k = 0;
      }
      {
#line 1482
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1482
        if (! (k < psf->sf.channels)) {
#line 1482
          goto while_break;
        }
        {
#line 1483
        psf_binheader_writef(psf, "Eft8\204U", (double )((float )(psf->peak_info)->peaks[k].value),
                             (psf->peak_info)->peaks[k].position);
#line 1482
        k ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 1486
  if (psf->strings.flags & 2048U) {
    {
#line 1487
    aiff_write_strings(psf, 2048);
    }
  }
#line 1490
  if (psf->headindex > 0) {
    {
#line 1491
    psf_fwrite((void const   *)(psf->header), (sf_count_t )psf->headindex, (sf_count_t )1,
               psf);
    }
  }
#line 1493
  return (0);
}
}
#line 1497 "/root/patchweave_donee/23/src/aiff.c"
static void aiff_write_strings(SF_PRIVATE *psf , int location ) 
{ 
  int k ;
  int slen ;
  unsigned long __cil_tmp5 ;
  size_t __cil_tmp6 ;

  {
#line 1500
  k = 0;
  {
#line 1500
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1500
    if (! (k < 32)) {
#line 1500
      goto while_break;
    }
#line 1501
    if (psf->strings.data[k].type == 0) {
#line 1502
      goto while_break;
    }
#line 1504
    if (psf->strings.data[k].flags != location) {
#line 1505
      goto while_continue;
    }
#line 1508
    if (psf->strings.data[k].type == 3) {
#line 1508
      goto case_3;
    }
#line 1513
    if (psf->strings.data[k].type == 1) {
#line 1513
      goto case_1;
    }
#line 1517
    if (psf->strings.data[k].type == 2) {
#line 1517
      goto case_2;
    }
#line 1521
    if (psf->strings.data[k].type == 4) {
#line 1521
      goto case_4;
    }
#line 1525
    if (psf->strings.data[k].type == 5) {
#line 1525
      goto case_5;
    }
#line 1507
    goto switch_break;
    case_3: 
    {
#line 1509
    __cil_tmp5 = strlen((char const   *)(psf->strings.storage + psf->strings.data[k].offset));
#line 1509
    slen = (int )__cil_tmp5;
#line 1510
    __cil_tmp6 = make_size_t(slen + (slen & 1));
#line 1510
    psf_binheader_writef(psf, "Em4mb", (unsigned int )((65 | (80 << 8)) | (80 << 16)) | (76U << 24),
                         slen + 4, (unsigned int )((109 | (51 << 8)) | (103 << 16)) | (97U << 24),
                         psf->strings.storage + psf->strings.data[k].offset, __cil_tmp6);
    }
#line 1511
    goto switch_break;
    case_1: 
    {
#line 1514
    psf_binheader_writef(psf, "EmS\333\204U", (unsigned int )((78 | (65 << 8)) | (77 << 16)) | (69U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1515
    goto switch_break;
    case_2: 
    {
#line 1518
    psf_binheader_writef(psf, "EmS", (unsigned int )((40 | (99 << 8)) | (41 << 16)) | (32U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1519
    goto switch_break;
    case_4: 
    {
#line 1522
    psf_binheader_writef(psf, "EmS\333\204U", (unsigned int )((65 | (85 << 8)) | (84 << 16)) | (72U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1523
    goto switch_break;
    case_5: 
    {
#line 1526
    psf_binheader_writef(psf, "EmS", (unsigned int )((65 | (78 << 8)) | (78 << 16)) | (79U << 24),
                         psf->strings.storage + psf->strings.data[k].offset);
    }
#line 1527
    goto switch_break;
    switch_break: 
#line 1500
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1537
  return;
}
}
#line 1541 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int UNUSED_datasize ) 
{ 
  AIFF_PRIVATE *paiff ;

  {
#line 1544
  paiff = (AIFF_PRIVATE *)psf->container_data;
#line 1544
  if ((unsigned long )paiff == (unsigned long )((void *)0)) {
#line 1545
    return (30);
  }
#line 1548
  if (command == 4353) {
#line 1548
    goto case_4353;
  }
#line 1552
  goto switch_default;
  case_4353: 
  {
#line 1549
  paiff->chanmap_tag = aiff_caf_find_channel_layout_tag((int const   *)psf->channel_map,
                                                        psf->sf.channels);
  }
#line 1550
  return (paiff->chanmap_tag != 0);
  switch_default: 
#line 1553
  goto switch_break;
  switch_break: ;
#line 1556
  return (0);
}
}
#line 1560 "/root/patchweave_donee/23/src/aiff.c"
static char const   *get_loop_mode_str(short mode ) 
{ 


  {
#line 1562
  if ((int )mode == 0) {
#line 1562
    goto case_0;
  }
#line 1563
  if ((int )mode == 1) {
#line 1563
    goto case_1;
  }
#line 1564
  if ((int )mode == 2) {
#line 1564
    goto case_2;
  }
#line 1561
  goto switch_break;
  case_0: 
#line 1562
  return ("none\204U");
  case_1: 
#line 1563
  return ("forward");
  case_2: 
#line 1564
  return ("backward\220");
  switch_break: ;
#line 1567
  return ("*** unknown");
}
}
#line 1571 "/root/patchweave_donee/23/src/aiff.c"
static short get_loop_mode(short mode ) 
{ 


  {
#line 1573
  if ((int )mode == 0) {
#line 1573
    goto case_0;
  }
#line 1574
  if ((int )mode == 1) {
#line 1574
    goto case_1;
  }
#line 1575
  if ((int )mode == 2) {
#line 1575
    goto case_2;
  }
#line 1572
  goto switch_break;
  case_0: 
#line 1573
  return ((short)800);
  case_1: 
#line 1574
  return ((short)801);
  case_2: 
#line 1575
  return ((short)802);
  switch_break: ;
#line 1578
  return ((short)800);
}
}
#line 1591 "/root/patchweave_donee/23/src/aiff.c"
static int tenbytefloat2int(unsigned char *bytes ) 
{ 
  int val ;

  {
#line 1592
  val = 3;
#line 1594
  if ((int )*(bytes + 0) & 128) {
#line 1595
    return (0);
  }
#line 1597
  if ((int )*(bytes + 0) <= 63) {
#line 1598
    return (1);
  }
#line 1600
  if ((int )*(bytes + 0) > 64) {
#line 1601
    return (67108864);
  }
#line 1603
  if ((int )*(bytes + 0) == 64) {
#line 1603
    if ((int )*(bytes + 1) > 28) {
#line 1604
      return (800000000);
    }
  }
#line 1608
  val = ((((int )*(bytes + 2) << 23) | ((int )*(bytes + 3) << 15)) | ((int )*(bytes + 4) << 7)) | ((int )*(bytes + 5) >> 1);
#line 1610
  val >>= 29 - (int )*(bytes + 1);
#line 1612
  return (val);
}
}
#line 1616 "/root/patchweave_donee/23/src/aiff.c"
static void uint2tenbytefloat(unsigned int num , unsigned char *bytes ) 
{ 
  unsigned int mask ;
  int count___0 ;

  {
#line 1617
  mask = 1073741824U;
#line 1620
  if (num <= 1U) {
#line 1621
    *(bytes + 0) = (unsigned char)63;
#line 1622
    *(bytes + 1) = (unsigned char)255;
#line 1623
    *(bytes + 2) = (unsigned char)128;
#line 1624
    return;
  }
#line 1627
  *(bytes + 0) = (unsigned char)64;
#line 1629
  if (num >= mask) {
#line 1630
    *(bytes + 1) = (unsigned char)29;
#line 1631
    return;
  }
#line 1634
  count___0 = 0;
  {
#line 1634
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1634
    if (! (count___0 < 32)) {
#line 1634
      goto while_break;
    }
#line 1635
    if (num & mask) {
#line 1636
      goto while_break;
    }
#line 1637
    mask >>= 1;
#line 1634
    count___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1640
  num <<= count___0 + 1;
#line 1641
  *(bytes + 1) = (unsigned char )(29 - count___0);
#line 1642
  *(bytes + 2) = (unsigned char )((num >> 24) & 255U);
#line 1643
  *(bytes + 3) = (unsigned char )((num >> 16) & 255U);
#line 1644
  *(bytes + 4) = (unsigned char )((num >> 8) & 255U);
#line 1645
  *(bytes + 5) = (unsigned char )(num & 255U);
#line 1646
  return;
}
}
#line 1650 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_read_basc_chunk(SF_PRIVATE *psf , int datasize ) 
{ 
  char const   *type_str ;
  basc_CHUNK bc ;
  int count___0 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1655
  count___0 = psf_binheader_readf(psf, "E442", & bc.version, & bc.numBeats, & bc.rootNote);
#line 1656
  __cil_tmp7 = psf_binheader_readf(psf, "E222", & bc.scaleType, & bc.sigNumerator,
                                   & bc.sigDenominator);
#line 1656
  count___0 += __cil_tmp7;
#line 1657
  __cil_tmp8 = psf_binheader_readf(psf, "E2j\333\204U", & bc.loopType, (unsigned long )datasize - sizeof(bc));
#line 1657
  count___0 += __cil_tmp8;
#line 1659
  psf_log_printf(psf, "  Version ? : %u\n  Num Beats : %u\n  Root Note : 0x%x\nU",
                 bc.version, bc.numBeats, (int )bc.rootNote);
  }
#line 1663
  if ((int )bc.scaleType == 1) {
#line 1663
    goto case_1;
  }
#line 1666
  if ((int )bc.scaleType == 2) {
#line 1666
    goto case_2;
  }
#line 1669
  if ((int )bc.scaleType == 3) {
#line 1669
    goto case_3;
  }
#line 1672
  if ((int )bc.scaleType == 4) {
#line 1672
    goto case_4;
  }
#line 1675
  goto switch_default;
  case_1: 
#line 1664
  type_str = "MINORU";
#line 1665
  goto switch_break;
  case_2: 
#line 1667
  type_str = "MAJOR";
#line 1668
  goto switch_break;
  case_3: 
#line 1670
  type_str = "NEITHER";
#line 1671
  goto switch_break;
  case_4: 
#line 1673
  type_str = "BOTH\204U";
#line 1674
  goto switch_break;
  switch_default: 
#line 1676
  type_str = "!!WRONG!!\327\250\333\204U";
#line 1677
  goto switch_break;
  switch_break: 
  {
#line 1680
  psf_log_printf(psf, "  ScaleType : 0x%x (%s)\n\230\001", (int )bc.scaleType, type_str);
#line 1681
  psf_log_printf(psf, "  Time Sig  : %d/%d\n\204U", (int )bc.sigNumerator, (int )bc.sigDenominator);
  }
#line 1684
  if ((int )bc.loopType == 1) {
#line 1684
    goto case_1___0;
  }
#line 1687
  if ((int )bc.loopType == 0) {
#line 1687
    goto case_0;
  }
#line 1690
  goto switch_default___0;
  case_1___0: 
#line 1685
  type_str = "One Shot\220";
#line 1686
  goto switch_break___0;
  case_0: 
#line 1688
  type_str = "Loop\204U";
#line 1689
  goto switch_break___0;
  switch_default___0: 
#line 1691
  type_str = "!!WRONG!!\311\250\333\204U";
#line 1692
  goto switch_break___0;
  switch_break___0: 
  {
#line 1695
  psf_log_printf(psf, "  Loop Type : 0x%x (%s)\n\230\001", (int )bc.loopType, type_str);
#line 1697
  tmp___0 = calloc(1UL, sizeof(SF_LOOP_INFO ));
#line 1697
  psf->loop_info = (SF_LOOP_INFO *)tmp___0;
  }
#line 1697
  if ((unsigned long )psf->loop_info == (unsigned long )((void *)0)) {
#line 1698
    return (17);
  }
#line 1700
  (psf->loop_info)->time_sig_num = (short )bc.sigNumerator;
#line 1701
  (psf->loop_info)->time_sig_den = (short )bc.sigDenominator;
#line 1702
  if ((int )bc.loopType == 1) {
#line 1702
    tmp = 800;
  } else {
#line 1702
    tmp = 801;
  }
#line 1702
  (psf->loop_info)->loop_mode = tmp;
#line 1703
  (psf->loop_info)->num_beats = (int )bc.numBeats;
#line 1706
  (psf->loop_info)->bpm = (float )((((1. / (double )psf->sf.frames) * (double )psf->sf.samplerate) * (((double )bc.numBeats * 4.) / (double )((int )bc.sigDenominator))) * 60.);
#line 1708
  (psf->loop_info)->root_key = (int )bc.rootNote;
#line 1710
  if (count___0 < datasize) {
    {
#line 1711
    psf_binheader_readf(psf, "j", datasize - count___0);
    }
  }
#line 1713
  return (0);
}
}
#line 1718 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_read_chanmap(SF_PRIVATE *psf , unsigned int dword ) 
{ 
  AIFF_CAF_CHANNEL_MAP *map_info ;
  unsigned int channel_bitmap ;
  unsigned int channel_decriptions ;
  unsigned int bytesread ;
  int layout_tag ;
  int __cil_tmp8 ;
  size_t chanmap_size ;
  void *tmp ;

  {
  {
#line 1723
  __cil_tmp8 = psf_binheader_readf(psf, "444", & layout_tag, & channel_bitmap, & channel_decriptions);
#line 1723
  bytesread = (unsigned int )__cil_tmp8;
#line 1725
  map_info = aiff_caf_of_channel_layout_tag(layout_tag);
  }
#line 1725
  if ((unsigned long )map_info == (unsigned long )((void *)0)) {
#line 1726
    return (0);
  }
  {
#line 1728
  psf_log_printf(psf, "  Tag    : %x\n", layout_tag);
  }
#line 1729
  if (map_info) {
    {
#line 1730
    psf_log_printf(psf, "  Layout : %s\n", map_info->name);
    }
  }
#line 1732
  if (bytesread < dword) {
    {
#line 1733
    psf_binheader_readf(psf, "j", dword - bytesread);
    }
  }
#line 1735
  if ((unsigned long )map_info->channel_map != (unsigned long )((void *)0)) {
    {
#line 1736
    chanmap_size = (unsigned long )psf->sf.channels * sizeof(*(psf->channel_map + 0));
#line 1738
    free((void *)psf->channel_map);
#line 1740
    tmp = malloc(chanmap_size);
#line 1740
    psf->channel_map = (int *)tmp;
    }
#line 1740
    if ((unsigned long )psf->channel_map == (unsigned long )((void *)0)) {
#line 1741
      return (17);
    }
    {
#line 1743
    memcpy((void *)psf->channel_map, (void const   *)map_info->channel_map, chanmap_size);
    }
  }
#line 1746
  return (0);
}
}
#line 1753 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_set_chunk(SF_PRIVATE *psf , SF_CHUNK_INFO *chunk_info ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1754
  __cil_tmp3 = psf_save_write_chunk(& psf->wchunks, chunk_info);
  }
#line 1754
  return (__cil_tmp3);
}
}
#line 1758 "/root/patchweave_donee/23/src/aiff.c"
static SF_CHUNK_ITERATOR *aiff_next_chunk_iterator(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator ) 
{ 
  SF_CHUNK_ITERATOR *__cil_tmp3 ;

  {
  {
#line 1759
  __cil_tmp3 = psf_next_chunk_iterator(& psf->rchunks, iterator);
  }
#line 1759
  return (__cil_tmp3);
}
}
#line 1763 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_get_chunk_size(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  int indx ;

  {
  {
#line 1766
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 1766
  if (indx < 0) {
#line 1767
    return (164);
  }
#line 1769
  chunk_info->datalen = (psf->rchunks.chunks + indx)->len;
#line 1771
  return (0);
}
}
#line 1775 "/root/patchweave_donee/23/src/aiff.c"
static int aiff_get_chunk_data(SF_PRIVATE *psf , SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  sf_count_t pos ;
  int indx ;

  {
  {
#line 1779
  indx = psf_find_read_chunk_iterator(& psf->rchunks, iterator);
  }
#line 1779
  if (indx < 0) {
#line 1780
    return (164);
  }
#line 1782
  if ((unsigned long )chunk_info->data == (unsigned long )((void *)0)) {
#line 1783
    return (167);
  }
  {
#line 1785
  chunk_info->id_size = (psf->rchunks.chunks + indx)->id_size;
#line 1786
  memcpy((void *)(chunk_info->id), (void const   *)((psf->rchunks.chunks + indx)->id),
         sizeof(chunk_info->id) / sizeof(chunk_info->id[0]));
#line 1788
  pos = psf_ftell(psf);
#line 1789
  psf_fseek(psf, (psf->rchunks.chunks + indx)->offset, 0);
#line 1790
  psf_fread(chunk_info->data, (sf_count_t )0, (sf_count_t )1, psf);
#line 1791
  psf_fseek(psf, pos, 0);
  }
#line 1793
  return (0);
}
}
#line 57 "/root/patchweave_donee/23/src/sndfile.c"
static ErrorStruct SndfileErrors[172]  = 
#line 57 "/root/patchweave_donee/23/src/sndfile.c"
  {      {0, "No Error."}, 
        {1, "Format not recognised."}, 
        {2, "System error."}, 
        {3, "Supported file format but file is malformed."}, 
        {4, "Supported file format but unsupported encoding."}, 
        {5, "Error : major format is 0."}, 
        {6, "Error : minor format is 0."}, 
        {7, "File does not exist or is not a regular file (possibly a pipe?).\250"}, 
        {8, "File exists but no data could be read."}, 
        {9, "Could not open file."}, 
        {10, "Not a valid SNDFILE* pointer."}, 
        {11, "NULL SF_INFO pointer passed to libsndfile."}, 
        {12, "SF_PRIVATE struct incomplete and end of header parsing."}, 
        {13, "Bad FILE pointer."}, 
        {14, "Internal error, Bad pointer.\204U"}, 
        {15, "Error : software was misconfigured at compile time (sizeof statbuf.st_size)."}, 
        {16,
      "Error : Could not file temp dir.\250"}, 
        {17, "Internal malloc () failed.\306\333\204U"}, 
        {18, "File contains data in an unimplemented format."}, 
        {19, "Attempt to read a non-integer number of channels.\360\306\333\204U"}, 
        {20, "Attempt to write a non-integer number of channels."}, 
        {21, "File contains data in an unknown format.\250"}, 
        {22, "Read attempted on file currently open for write.\250"}, 
        {23, "Write attempted on file currently open for read.\250"}, 
        {24, "Error : This file format does not support read/write mode."}, 
        {25, "Internal error : SF_INFO struct incomplete."}, 
        {26, "Error : supplied offset beyond end of file.`\375\177"}, 
        {27, "Error : embedding not supported for this file format."}, 
        {28, "Error : cannot open embedded file read/write."}, 
        {29, "Error : this file format does not support pipe write."}, 
        {35, "Error : bad pointer on SF_VIRTUAL_IO struct."}, 
        {49, "Error : bad coding_history_size in SF_BROADCAST_INFO struct.\004"}, 
        {50, "Error : SF_BROADCAST_INFO struct too large."}, 
        {51, "Error: SF_CART_INFO struct too large."}, 
        {52, "Error: bag tag_text_size in SF_CART_INFO struct.\250"}, 
        {36, "Attempt to write to file with non-interleaved data."}, 
        {37, "Bad karma in seek during interleave read operation."}, 
        {38, "Bad karma in read during interleave read operation."}, 
        {30, "Unspecified internal error."}, 
        {31, "Bad parameter passed to function sf_command."}, 
        {32, "Bad endian-ness. Try default endian-ness\250"}, 
        {33, "Channel count is zero."}, 
        {34, "Too many channels specified."}, 
        {39, "Internal psf_fseek() failed."}, 
        {40, "Seek attempted on unseekable file type."}, 
        {41, "Error : combination of file open mode and seek command is ambiguous."}, 
        {42,
      "Error : invalid seek parameters.\250"}, 
        {43, "Error : parameters OK, but psf_seek() failed."}, 
        {44, "Error : bad mode parameter for file open."}, 
        {45, "Error : attempt to open a pipe in read/write mode."}, 
        {46, "Error on RDWR position (cryptic)."}, 
        {47, "Error : Cannot open file in read/write mode due to string data in header."}, 
        {48,
      "Error : Command fails because file already has audio data."}, 
        {53, "Error : File type does not support string data."}, 
        {54, "Error : Trying to set a string when file is not in write mode."}, 
        {55, "Error : Maximum string data storage reached."}, 
        {56, "Error : Maximum string data count reached."}, 
        {57, "Error : Bad string data type."}, 
        {58, "Error : file type does not support strings added at end of file.\250"}, 
        {59,
      "Error : bad string."}, 
        {60, "Error : Weird string error."}, 
        {61, "Error in WAV file. No \'RIFF\' chunk marker."}, 
        {62, "Error in WAV file. No \'WAVE\' chunk marker."}, 
        {63, "Error in WAV/W64/RF64 file. No \'fmt \' chunk marker."}, 
        {64, "Error in WAV/W64/RF64 file. Malformed \'fmt \' chunk."}, 
        {65, "Error in WAV/W64/RF64 file. Short \'fmt \' chunk."}, 
        {66, "Error in WAV file. \'fact\' chunk out of place."}, 
        {67, "Error in WAV file. Bad \'PEAK\' chunk."}, 
        {68, "Error in WAV file. \'PEAK\' chunk found before \'fmt \' chunk."}, 
        {69, "Error in WAV file. Errors in \'fmt \' chunk."}, 
        {70, "Error in WAV file. Block alignment in \'fmt \' chunk is incorrect.\250"}, 
        {71,
      "Error in WAV file. No \'data\' chunk marker."}, 
        {72, "Error in WAV file. Malformed LIST chunk.\250"}, 
        {77, "Error in WAV file. File contains an unknown chunk marker."}, 
        {78, "Error in WAV file. Data is in WAVPACK format."}, 
        {73, "Error in ADPCM WAV file. Invalid bit width."}, 
        {74, "Error in ADPCM WAV file. Invalid number of channels."}, 
        {75, "Error in ADPCM WAV file. Invalid number of samples per block."}, 
        {76, "Error in GSM610 WAV file. Invalid format chunk."}, 
        {79, "Error in AIFF file, bad \'FORM\' marker."}, 
        {80, "Error in AIFF file, \'AIFF\' marker without \'FORM\'."}, 
        {81, "Error in AIFF file, \'COMM\' marker without \'FORM\'."}, 
        {82, "Error in AIFF file, \'SSND\' marker without \'COMM\'."}, 
        {83, "Error in AIFF file, unknown chunk."}, 
        {84, "Error in AIFF file, bad \'COMM\' chunk size."}, 
        {85, "Error in AIFF file, bad \'COMM\' chunk."}, 
        {86, "Error in AIFF file. \'PEAK\' chunk found before \'COMM\' chunk."}, 
        {87, "Error in AIFF file. Bad \'PEAK\' chunk."}, 
        {88, "Error in AIFF file, bad \'SSND\' chunk."}, 
        {89, "Error in AIFF file, no sound data."}, 
        {90, "Error in AIFF file, RDWR only possible if SSND chunk at end of file."}, 
        {91,
      "Error in AU file, unknown format."}, 
        {92, "Error in AU file, missing \'.snd\' or \'dns.\' marker."}, 
        {93, "Embedded AU file with unknown length."}, 
        {94, "Error while opening RAW file for read. Must specify format and channels.\nPossibly trying to open unsupported format.\250"}, 
        {95,
      "Error. RAW file bitwidth must be a multiple of 8."}, 
        {96, "Error. Bad format field in SF_INFO struct when openning a RAW file for read."}, 
        {97,
      "Error in PAF file, no marker."}, 
        {98, "Error in PAF file, bad version."}, 
        {99, "Error in PAF file, unknown format."}, 
        {100, "Error in PAF file. File shorter than minimal header."}, 
        {101, "Error in PAF file. Bad channel count."}, 
        {102, "Error in 8SVX / 16SV file, no \'FORM\' marker."}, 
        {103, "Error in 8SVX / 16SV file, no \'BODY\' marker."}, 
        {104, "Error in 8SVX / 16SV file, no sound data."}, 
        {105, "Error in 8SVX / 16SV file, unsupported compression format."}, 
        {106, "Error in 8SVX / 16SV file, NAME chunk too long."}, 
        {107, "Error in NIST file, bad header."}, 
        {108, "Error : NIST file damaged by Windows CR -> CRLF conversion process."}, 
        {109,
      "Error in NIST file, unsupported compression format."}, 
        {110, "Error in VOC file, no \'Creative Voice File\' marker."}, 
        {111, "Error in VOC file, bad format."}, 
        {112, "Error in VOC file, bad version number."}, 
        {113, "Error in VOC file, bad marker in file."}, 
        {114, "Error in VOC file, incompatible VOC sections."}, 
        {115, "Error in VOC file, more than one sample rate defined."}, 
        {116, "Unimplemented VOC file feature, file contains multiple sound sections."}, 
        {117,
      "Error in VOC file, file contains multiple bit or channel widths.\250"}, 
        {118, "Error in VOC file, too many sections."}, 
        {119, "Error : not able to operate on VOC files over a pipe."}, 
        {120, "Error in IRCAM file, bad IRCAM marker."}, 
        {121, "Error in IRCAM file, bad channel count."}, 
        {122, "Error in IRCAM file, unknow encoding format."}, 
        {123, "Error in W64 file, file contains 64 bit offset."}, 
        {124, "Error in W64 file. No \'riff\' chunk marker."}, 
        {125, "Error in W64 file. No \'wave\' chunk marker."}, 
        {126, "Error in W64 file. No \'data\' chunk marker."}, 
        {127, "Error in ADPCM W64 file. Invalid bit width."}, 
        {128, "Error in ADPCM W64 file. Invalid number of channels."}, 
        {129, "Error in GSM610 W64 file. Invalid format chunk."}, 
        {130, "Error in MAT4 file. No variable name."}, 
        {131, "Error in MAT4 file. No sample rate."}, 
        {132, "Error in MAT5 file. Not able to determine endian-ness."}, 
        {133, "Error in MAT5 file. Bad block structure.\250"}, 
        {134, "Error in MAT5 file. Not able to determine sample rate."}, 
        {135, "Error in PVF file. No PVF1 marker."}, 
        {136, "Error in PVF file. Bad header."}, 
        {137, "Error in PVF file. Bad bit width."}, 
        {140, "Error in XI file. Bad header."}, 
        {141, "Error in XI file. Excess samples in file."}, 
        {142, "Error : not able to operate on XI files over a pipe."}, 
        {143, "Error : not able to operate on HTK files over a pipe."}, 
        {144, "Error : not an SDS file.\250"}, 
        {145, "Error : bad bit width for SDS file."}, 
        {146, "Error : cannot open SD2 file without a file name."}, 
        {147, "Error : bad data offset.\250"}, 
        {148, "Error : bad map offset."}, 
        {149, "Error : bad data length.\250"}, 
        {150, "Error : bad map length."}, 
        {151, "Error : bad resource fork."}, 
        {152, "Error : bad sample size.\250"}, 
        {153, "Error : bad flac header.\250"}, 
        {154, "Error : problem while creating flac decoder."}, 
        {155, "Error : problem while initialization of the flac decoder."}, 
        {156, "Error : flac decoder lost sync."}, 
        {157, "Error : flac does not support this sample rate."}, 
        {158, "Error : unknown error in flac decoder."}, 
        {159, "Error : not a WVE file."}, 
        {160, "Error : not able to operate on WVE files over a pipe."}, 
        {138, "Error : Bad bit width for DWVW encoding. Must be 12, 16 or 24."}, 
        {139, "Error : G72x encoding does not support more than 1 channel."}, 
        {161, "Error : Sample rate chosen is known to trigger a Vorbis encoder bug on this CPU.\250"}, 
        {162,
      "Error : Not an RF64 file."}, 
        {168, "Error : Failed to open tmp file for ALAC encoding."}, 
        {163, "Error : Bad SF_CHUNK_INFO pointer."}, 
        {164, "Error : Unknown chunk marker."}, 
        {165, "Error : Reading/writing chunks from this file format is not supported."}, 
        {166,
      "Error : Bad chunk marker."}, 
        {167, "Error : Bad data pointer in SF_CHUNK_INFO struct."}, 
        {169, "Error : Supplied filename too long."}, 
        {170, "Maximum error number."}, 
        {171, (char const   *)((void *)0)}};
#line 275
static int format_from_extension(SF_PRIVATE *psf ) ;
#line 276
static int guess_file_type(SF_PRIVATE *psf ) ;
#line 277
static int validate_sfinfo(SF_INFO *sfinfo ) ;
#line 278
static int validate_psf(SF_PRIVATE *psf ) ;
#line 279
static void save_header_info(SF_PRIVATE *psf ) ;
#line 280
static int copy_filename(SF_PRIVATE *psf , char const   *path ) ;
#line 281
static int psf_close(SF_PRIVATE *psf ) ;
#line 283
static int try_resource_fork(SF_PRIVATE *psf ) ;
#line 289 "/root/patchweave_donee/23/src/sndfile.c"
int sf_errno  =    0;
#line 290 "/root/patchweave_donee/23/src/sndfile.c"
static char sf_parselog[8192]  = {      (char)0};
#line 291 "/root/patchweave_donee/23/src/sndfile.c"
static char sf_syserr[256]  = {      (char)0};
#line 319 "/root/patchweave_donee/23/src/sndfile.c"
SNDFILE *sf_open(char const   *path , int mode , SF_INFO *sfinfo ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  SNDFILE *__cil_tmp11 ;
  void *tmp___0 ;

  {
  {
#line 325
  tmp___0 = calloc(1UL, sizeof(SF_PRIVATE ));
#line 325
  psf = (SF_PRIVATE *)tmp___0;
  }
#line 325
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 326
    sf_errno = 17;
#line 327
    return ((SNDFILE *)((void *)0));
  }
  {
#line 330
  psf_init_files(psf);
#line 332
  psf_log_printf(psf, "File : %s\n", path);
#line 334
  __cil_tmp7 = copy_filename(psf, path);
  }
#line 334
  if (__cil_tmp7 != 0) {
#line 335
    sf_errno = psf->error;
#line 336
    return ((SNDFILE *)((void *)0));
  }
  {
#line 339
  psf->file.mode = mode;
#line 340
  __cil_tmp8 = strcmp(path, "-");
  }
#line 340
  if (__cil_tmp8 == 0) {
    {
#line 341
    psf->error = psf_set_stdio(psf);
    }
  } else {
    {
#line 343
    psf->error = psf_fopen(psf);
    }
  }
  {
#line 345
  __cil_tmp11 = psf_open_file(psf, sfinfo);
  }
#line 345
  return (__cil_tmp11);
}
}
#line 349 "/root/patchweave_donee/23/src/sndfile.c"
SNDFILE *sf_open_fd(int fd , int mode , SF_INFO *sfinfo , int close_desc ) 
{ 
  SF_PRIVATE *psf ;
  SNDFILE *__cil_tmp9 ;
  void *tmp ;

  {
#line 352
  if ((sfinfo->format & 268369920) == 1441792) {
#line 353
    sf_errno = 146;
#line 354
    return ((SNDFILE *)((void *)0));
  }
  {
#line 357
  tmp = calloc(1UL, sizeof(SF_PRIVATE ));
#line 357
  psf = (SF_PRIVATE *)tmp;
  }
#line 357
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 358
    sf_errno = 17;
#line 359
    return ((SNDFILE *)((void *)0));
  }
  {
#line 362
  psf_init_files(psf);
#line 363
  copy_filename(psf, "\220");
#line 365
  psf->file.mode = mode;
#line 366
  psf_set_file(psf, fd);
#line 367
  psf->is_pipe = psf_is_pipe(psf);
#line 368
  psf->fileoffset = psf_ftell(psf);
  }
#line 370
  if (! close_desc) {
#line 371
    psf->file.do_not_close_descriptor = 1;
  }
  {
#line 373
  __cil_tmp9 = psf_open_file(psf, sfinfo);
  }
#line 373
  return (__cil_tmp9);
}
}
#line 377 "/root/patchweave_donee/23/src/sndfile.c"
SNDFILE *sf_open_virtual(SF_VIRTUAL_IO *sfvirtual , int mode , SF_INFO *sfinfo , void *user_data ) 
{ 
  SF_PRIVATE *psf ;
  SNDFILE *__cil_tmp7 ;
  void *tmp ;

  {
#line 381
  if ((unsigned long )sfvirtual->get_filelen == (unsigned long )((void *)0)) {
    {
#line 382
    sf_errno = 35;
#line 383
    snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n");
    }
#line 384
    return ((SNDFILE *)((void *)0));
  } else
#line 381
  if ((unsigned long )sfvirtual->seek == (unsigned long )((void *)0)) {
    {
#line 382
    sf_errno = 35;
#line 383
    snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n");
    }
#line 384
    return ((SNDFILE *)((void *)0));
  } else
#line 381
  if ((unsigned long )sfvirtual->tell == (unsigned long )((void *)0)) {
    {
#line 382
    sf_errno = 35;
#line 383
    snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n");
    }
#line 384
    return ((SNDFILE *)((void *)0));
  }
#line 387
  if ((unsigned long )sfvirtual->read == (unsigned long )((void *)0)) {
#line 387
    if (mode == 16) {
      {
#line 388
      sf_errno = 35;
#line 389
      snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_read in SF_VIRTUAL_IO struct.\n");
      }
#line 390
      return ((SNDFILE *)((void *)0));
    } else
#line 387
    if (mode == 48) {
      {
#line 388
      sf_errno = 35;
#line 389
      snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_read in SF_VIRTUAL_IO struct.\n");
      }
#line 390
      return ((SNDFILE *)((void *)0));
    }
  }
#line 393
  if ((unsigned long )sfvirtual->write == (unsigned long )((void *)0)) {
#line 393
    if (mode == 32) {
      {
#line 394
      sf_errno = 35;
#line 395
      snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_write in SF_VIRTUAL_IO struct.\n");
      }
#line 396
      return ((SNDFILE *)((void *)0));
    } else
#line 393
    if (mode == 48) {
      {
#line 394
      sf_errno = 35;
#line 395
      snprintf(sf_parselog, sizeof(sf_parselog), "Bad vio_write in SF_VIRTUAL_IO struct.\n");
      }
#line 396
      return ((SNDFILE *)((void *)0));
    }
  }
  {
#line 399
  tmp = calloc(1UL, sizeof(SF_PRIVATE ));
#line 399
  psf = (SF_PRIVATE *)tmp;
  }
#line 399
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 400
    sf_errno = 17;
#line 401
    return ((SNDFILE *)((void *)0));
  }
  {
#line 404
  psf_init_files(psf);
#line 406
  psf->virtual_io = 1;
#line 407
  psf->vio = *sfvirtual;
#line 408
  psf->vio_user_data = user_data;
#line 410
  psf->file.mode = mode;
#line 412
  __cil_tmp7 = psf_open_file(psf, sfinfo);
  }
#line 412
  return (__cil_tmp7);
}
}
#line 416 "/root/patchweave_donee/23/src/sndfile.c"
int sf_close(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 419
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 419
    sf_errno = 10;
#line 419
    return (0);
  }
  {
#line 419
  psf = (SF_PRIVATE *)sndfile;
#line 419
  __cil_tmp3 = psf_file_valid(psf);
  }
#line 419
  if (psf->virtual_io == 0) {
#line 419
    if (__cil_tmp3 == 0) {
#line 419
      psf->error = 13;
#line 419
      return (0);
    }
  }
#line 419
  if (psf->Magick != 305447134) {
#line 419
    psf->error = 10;
#line 419
    return (0);
  }
  {
#line 419
  psf->error = 0;
#line 421
  __cil_tmp4 = psf_close(psf);
  }
#line 421
  return (__cil_tmp4);
}
}
#line 425 "/root/patchweave_donee/23/src/sndfile.c"
void sf_write_sync(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;

  {
#line 428
  psf = (SF_PRIVATE *)sndfile;
#line 428
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 429
    return;
  }
  {
#line 431
  psf_fsync(psf);
  }
#line 433
  return;
}
}
#line 442 "/root/patchweave_donee/23/src/sndfile.c"
static char const   *bad_errnum  ;
#line 440 "/root/patchweave_donee/23/src/sndfile.c"
char const   *sf_error_number(int errnum ) 
{ 
  int k ;

  {
#line 441
  bad_errnum = "No error defined for this error number. This is a bug in libsndfile.\204U";
#line 445
  if (errnum == 170) {
#line 446
    return (SndfileErrors[0].str);
  }
#line 448
  if (errnum < 0) {
    {
#line 450
    printf("Not a valid error number (%d).\n", errnum);
    }
#line 451
    return (bad_errnum);
  } else
#line 448
  if (errnum > 170) {
    {
#line 450
    printf("Not a valid error number (%d).\n", errnum);
    }
#line 451
    return (bad_errnum);
  }
#line 454
  k = 0;
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;

#line 454
    if (! SndfileErrors[k].str) {
#line 454
      goto while_break;
    }
#line 455
    if (errnum == SndfileErrors[k].error) {
#line 456
      return (SndfileErrors[k].str);
    }
#line 454
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 458
  return (bad_errnum);
}
}
#line 462 "/root/patchweave_donee/23/src/sndfile.c"
char const   *sf_strerror(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int errnum ;
  char const   *__cil_tmp4 ;

  {
#line 463
  psf = (SF_PRIVATE *)((void *)0);
#line 466
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 467
    errnum = sf_errno;
#line 468
    if (errnum == 2) {
#line 468
      if ((int )sf_syserr[0]) {
#line 469
        return ((char const   *)(sf_syserr));
      }
    }
  } else {
#line 472
    psf = (SF_PRIVATE *)sndfile;
#line 474
    if (psf->Magick != 305447134) {
#line 475
      return ("sf_strerror : Bad magic number.");
    }
#line 477
    errnum = psf->error;
#line 479
    if (errnum == 2) {
#line 479
      if ((int )psf->syserr[0]) {
#line 480
        return ((char const   *)(psf->syserr));
      }
    }
  }
  {
#line 483
  __cil_tmp4 = sf_error_number(errnum);
  }
#line 483
  return (__cil_tmp4);
}
}
#line 490 "/root/patchweave_donee/23/src/sndfile.c"
int sf_error(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp3 ;

  {
#line 493
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 494
    return (sf_errno);
  }
#line 496
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 496
    sf_errno = 10;
#line 496
    return (0);
  }
  {
#line 496
  psf = (SF_PRIVATE *)sndfile;
#line 496
  __cil_tmp3 = psf_file_valid(psf);
  }
#line 496
  if (psf->virtual_io == 0) {
#line 496
    if (__cil_tmp3 == 0) {
#line 496
      psf->error = 13;
#line 496
      return (0);
    }
  }
#line 496
  if (psf->Magick != 305447134) {
#line 496
    psf->error = 10;
#line 496
    return (0);
  }
#line 498
  if (psf->error) {
#line 499
    return (psf->error);
  }
#line 501
  return (0);
}
}
#line 508 "/root/patchweave_donee/23/src/sndfile.c"
int sf_perror(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int errnum ;
  int __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
#line 512
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 513
    errnum = sf_errno;
  } else {
#line 516
    if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 516
      sf_errno = 10;
#line 516
      return (0);
    }
    {
#line 516
    psf = (SF_PRIVATE *)sndfile;
#line 516
    __cil_tmp4 = psf_file_valid(psf);
    }
#line 516
    if (psf->virtual_io == 0) {
#line 516
      if (__cil_tmp4 == 0) {
#line 516
        psf->error = 13;
#line 516
        return (0);
      }
    }
#line 516
    if (psf->Magick != 305447134) {
#line 516
      psf->error = 10;
#line 516
      return (0);
    }
#line 517
    errnum = psf->error;
  }
  {
#line 520
  __cil_tmp5 = sf_error_number(errnum);
#line 520
  fprintf(stderr, "%s\n\333\204U", __cil_tmp5);
  }
#line 521
  return (0);
}
}
#line 529 "/root/patchweave_donee/23/src/sndfile.c"
int sf_error_str(SNDFILE *sndfile , char *str___0 , size_t maxlen ) 
{ 
  SF_PRIVATE *psf ;
  int errnum ;
  int __cil_tmp6 ;
  char const   *__cil_tmp7 ;

  {
#line 533
  if ((unsigned long )str___0 == (unsigned long )((void *)0)) {
#line 534
    return (30);
  }
#line 536
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 537
    errnum = sf_errno;
  } else {
#line 539
    if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 539
      sf_errno = 10;
#line 539
      return (0);
    }
    {
#line 539
    psf = (SF_PRIVATE *)sndfile;
#line 539
    __cil_tmp6 = psf_file_valid(psf);
    }
#line 539
    if (psf->virtual_io == 0) {
#line 539
      if (__cil_tmp6 == 0) {
#line 539
        psf->error = 13;
#line 539
        return (0);
      }
    }
#line 539
    if (psf->Magick != 305447134) {
#line 539
      psf->error = 10;
#line 539
      return (0);
    }
#line 540
    errnum = psf->error;
  }
  {
#line 543
  __cil_tmp7 = sf_error_number(errnum);
#line 543
  snprintf(str___0, maxlen, "%s", __cil_tmp7);
  }
#line 545
  return (0);
}
}
#line 552 "/root/patchweave_donee/23/src/sndfile.c"
int sf_format_check(SF_INFO *info ) 
{ 
  int subformat ;
  int endian ;

  {
#line 555
  subformat = info->format & 65535;
#line 556
  endian = info->format & 805306368;
#line 563
  if (info->channels < 1) {
#line 564
    return (0);
  } else
#line 563
  if (info->channels > 1024) {
#line 564
    return (0);
  }
#line 566
  if (info->samplerate < 0) {
#line 567
    return (0);
  }
#line 570
  if ((info->format & 268369920) == 65536) {
#line 570
    goto case_65536;
  }
#line 588
  if ((info->format & 268369920) == 1245184) {
#line 588
    goto case_1245184;
  }
#line 601
  if ((info->format & 268369920) == 131072) {
#line 601
    goto case_131072;
  }
#line 623
  if ((info->format & 268369920) == 196608) {
#line 623
    goto case_196608;
  }
#line 640
  if ((info->format & 268369920) == 1572864) {
#line 640
    goto case_1572864;
  }
#line 655
  if ((info->format & 268369920) == 262144) {
#line 655
    goto case_262144;
  }
#line 673
  if ((info->format & 268369920) == 327680) {
#line 673
    goto case_327680;
  }
#line 678
  if ((info->format & 268369920) == 393216) {
#line 678
    goto case_393216;
  }
#line 690
  if ((info->format & 268369920) == 458752) {
#line 690
    goto case_458752;
  }
#line 699
  if ((info->format & 268369920) == 655360) {
#line 699
    goto case_655360;
  }
#line 708
  if ((info->format & 268369920) == 524288) {
#line 708
    goto case_524288;
  }
#line 720
  if ((info->format & 268369920) == 720896) {
#line 720
    goto case_720896;
  }
#line 738
  if ((info->format & 268369920) == 786432) {
#line 738
    goto case_786432;
  }
#line 745
  if ((info->format & 268369920) == 851968) {
#line 745
    goto case_851968;
  }
#line 752
  if ((info->format & 268369920) == 917504) {
#line 752
    goto case_917504;
  }
#line 757
  if ((info->format & 268369920) == 983040) {
#line 757
    goto case_983040;
  }
#line 764
  if ((info->format & 268369920) == 1048576) {
#line 764
    goto case_1048576;
  }
#line 774
  if ((info->format & 268369920) == 1114112) {
#line 774
    goto case_1114112;
  }
#line 784
  if ((info->format & 268369920) == 1179648) {
#line 784
    goto case_1179648;
  }
#line 794
  if ((info->format & 268369920) == 1507328) {
#line 794
    goto case_1507328;
  }
#line 804
  if ((info->format & 268369920) == 1441792) {
#line 804
    goto case_1441792;
  }
#line 812
  if ((info->format & 268369920) == 1638400) {
#line 812
    goto case_1638400;
  }
#line 822
  if ((info->format & 268369920) == 2097152) {
#line 822
    goto case_2097152;
  }
#line 829
  if ((info->format & 268369920) == 2162688) {
#line 829
    goto case_2162688;
  }
#line 839
  if ((info->format & 268369920) == 2228224) {
#line 839
    goto case_2228224;
  }
#line 851
  goto switch_default;
  case_65536: 
#line 572
  if (subformat == 5) {
#line 573
    return (1);
  } else
#line 572
  if (subformat == 2) {
#line 573
    return (1);
  }
#line 574
  if (subformat == 3) {
#line 575
    return (1);
  } else
#line 574
  if (subformat == 4) {
#line 575
    return (1);
  }
#line 576
  if (subformat == 18) {
    _L: 
#line 576
    if (info->channels <= 2) {
#line 577
      return (1);
    }
  } else
#line 576
  if (subformat == 19) {
#line 576
    goto _L;
  }
#line 578
  if (subformat == 32) {
#line 578
    if (info->channels == 1) {
#line 579
      return (1);
    }
  }
#line 580
  if (subformat == 48) {
#line 580
    if (info->channels == 1) {
#line 581
      return (1);
    }
  }
#line 582
  if (subformat == 16) {
#line 583
    return (1);
  } else
#line 582
  if (subformat == 17) {
#line 583
    return (1);
  }
#line 584
  if (subformat == 6) {
#line 585
    return (1);
  } else
#line 584
  if (subformat == 7) {
#line 585
    return (1);
  }
#line 586
  goto switch_break;
  case_1245184: 
#line 589
  if (endian == 536870912) {
#line 590
    return (0);
  } else
#line 589
  if (endian == 805306368) {
#line 590
    return (0);
  }
#line 591
  if (subformat == 5) {
#line 592
    return (1);
  } else
#line 591
  if (subformat == 2) {
#line 592
    return (1);
  }
#line 593
  if (subformat == 3) {
#line 594
    return (1);
  } else
#line 593
  if (subformat == 4) {
#line 594
    return (1);
  }
#line 595
  if (subformat == 16) {
#line 596
    return (1);
  } else
#line 595
  if (subformat == 17) {
#line 596
    return (1);
  }
#line 597
  if (subformat == 6) {
#line 598
    return (1);
  } else
#line 597
  if (subformat == 7) {
#line 598
    return (1);
  }
#line 599
  goto switch_break;
  case_131072: 
#line 603
  if (subformat == 2) {
#line 604
    return (1);
  } else
#line 603
  if (subformat == 3) {
#line 604
    return (1);
  } else
#line 603
  if (subformat == 4) {
#line 604
    return (1);
  }
#line 606
  if (endian != 0) {
#line 607
    return (0);
  }
#line 608
  if (subformat == 5) {
#line 609
    return (1);
  } else
#line 608
  if (subformat == 1) {
#line 609
    return (1);
  }
#line 610
  if (subformat == 6) {
#line 611
    return (1);
  } else
#line 610
  if (subformat == 7) {
#line 611
    return (1);
  }
#line 612
  if (subformat == 16) {
#line 613
    return (1);
  } else
#line 612
  if (subformat == 17) {
#line 613
    return (1);
  }
#line 614
  if (subformat == 64) {
    _L___46: 
#line 614
    if (info->channels == 1) {
#line 616
      return (1);
    }
  } else
#line 614
  if (subformat == 65) {
#line 614
    goto _L___46;
  } else
#line 614
  if (subformat == 66) {
#line 614
    goto _L___46;
  }
#line 617
  if (subformat == 32) {
#line 617
    if (info->channels == 1) {
#line 618
      return (1);
    }
  }
#line 619
  if (subformat == 18) {
#line 619
    if (info->channels == 1) {
#line 620
      return (1);
    } else
#line 619
    if (info->channels == 2) {
#line 620
      return (1);
    }
  }
#line 621
  goto switch_break;
  case_196608: 
#line 624
  if (subformat == 1) {
#line 625
    return (1);
  } else
#line 624
  if (subformat == 2) {
#line 625
    return (1);
  }
#line 626
  if (subformat == 3) {
#line 627
    return (1);
  } else
#line 626
  if (subformat == 4) {
#line 627
    return (1);
  }
#line 628
  if (subformat == 16) {
#line 629
    return (1);
  } else
#line 628
  if (subformat == 17) {
#line 629
    return (1);
  }
#line 630
  if (subformat == 6) {
#line 631
    return (1);
  } else
#line 630
  if (subformat == 7) {
#line 631
    return (1);
  }
#line 632
  if (subformat == 48) {
#line 632
    if (info->channels == 1) {
#line 633
      return (1);
    }
  }
#line 634
  if (subformat == 49) {
#line 634
    if (info->channels == 1) {
#line 635
      return (1);
    }
  }
#line 636
  if (subformat == 50) {
#line 636
    if (info->channels == 1) {
#line 637
      return (1);
    }
  }
#line 638
  goto switch_break;
  case_1572864: 
#line 641
  if (subformat == 1) {
#line 642
    return (1);
  } else
#line 641
  if (subformat == 2) {
#line 642
    return (1);
  }
#line 643
  if (subformat == 3) {
#line 644
    return (1);
  } else
#line 643
  if (subformat == 4) {
#line 644
    return (1);
  }
#line 645
  if (subformat == 16) {
#line 646
    return (1);
  } else
#line 645
  if (subformat == 17) {
#line 646
    return (1);
  }
#line 647
  if (subformat == 112) {
#line 648
    return (1);
  } else
#line 647
  if (subformat == 113) {
#line 648
    return (1);
  }
#line 649
  if (subformat == 114) {
#line 650
    return (1);
  } else
#line 649
  if (subformat == 115) {
#line 650
    return (1);
  }
#line 651
  if (subformat == 6) {
#line 652
    return (1);
  } else
#line 651
  if (subformat == 7) {
#line 652
    return (1);
  }
#line 653
  goto switch_break;
  case_262144: 
#line 656
  if (subformat == 5) {
#line 657
    return (1);
  } else
#line 656
  if (subformat == 1) {
#line 657
    return (1);
  } else
#line 656
  if (subformat == 2) {
#line 657
    return (1);
  }
#line 658
  if (subformat == 3) {
#line 659
    return (1);
  } else
#line 658
  if (subformat == 4) {
#line 659
    return (1);
  }
#line 660
  if (subformat == 6) {
#line 661
    return (1);
  } else
#line 660
  if (subformat == 7) {
#line 661
    return (1);
  }
#line 662
  if (subformat == 17) {
#line 663
    return (1);
  } else
#line 662
  if (subformat == 16) {
#line 663
    return (1);
  }
#line 664
  if (subformat == 64) {
    _L___48: 
#line 664
    if (info->channels == 1) {
#line 666
      return (1);
    }
  } else
#line 664
  if (subformat == 65) {
#line 664
    goto _L___48;
  } else
#line 664
  if (subformat == 66) {
#line 664
    goto _L___48;
  }
#line 667
  if (subformat == 32) {
#line 667
    if (info->channels == 1) {
#line 668
      return (1);
    }
  }
#line 669
  if (subformat == 33) {
#line 669
    if (info->channels == 1) {
#line 670
      return (1);
    }
  }
#line 671
  goto switch_break;
  case_327680: 
#line 674
  if (subformat == 1) {
#line 675
    return (1);
  } else
#line 674
  if (subformat == 2) {
#line 675
    return (1);
  } else
#line 674
  if (subformat == 3) {
#line 675
    return (1);
  }
#line 676
  goto switch_break;
  case_393216: 
#line 680
  if (info->channels > 1) {
#line 681
    return (0);
  }
#line 683
  if (endian == 268435456) {
#line 684
    return (0);
  } else
#line 683
  if (endian == 805306368) {
#line 684
    return (0);
  }
#line 686
  if (subformat == 1) {
#line 687
    return (1);
  } else
#line 686
  if (subformat == 2) {
#line 687
    return (1);
  }
#line 688
  goto switch_break;
  case_458752: 
#line 691
  if (subformat == 1) {
#line 692
    return (1);
  } else
#line 691
  if (subformat == 2) {
#line 692
    return (1);
  }
#line 693
  if (subformat == 3) {
#line 694
    return (1);
  } else
#line 693
  if (subformat == 4) {
#line 694
    return (1);
  }
#line 695
  if (subformat == 16) {
#line 696
    return (1);
  } else
#line 695
  if (subformat == 17) {
#line 696
    return (1);
  }
#line 697
  goto switch_break;
  case_655360: 
#line 700
  if (info->channels > 256) {
#line 701
    return (0);
  }
#line 702
  if (subformat == 2) {
#line 703
    return (1);
  } else
#line 702
  if (subformat == 4) {
#line 703
    return (1);
  }
#line 704
  if (subformat == 16) {
#line 705
    return (1);
  } else
#line 704
  if (subformat == 17) {
#line 705
    return (1);
  } else
#line 704
  if (subformat == 6) {
#line 705
    return (1);
  }
#line 706
  goto switch_break;
  case_524288: 
#line 709
  if (info->channels > 2) {
#line 710
    return (0);
  }
#line 712
  if (endian == 536870912) {
#line 713
    return (0);
  } else
#line 712
  if (endian == 805306368) {
#line 713
    return (0);
  }
#line 714
  if (subformat == 5) {
#line 715
    return (1);
  } else
#line 714
  if (subformat == 2) {
#line 715
    return (1);
  }
#line 716
  if (subformat == 16) {
#line 717
    return (1);
  } else
#line 716
  if (subformat == 17) {
#line 717
    return (1);
  }
#line 718
  goto switch_break;
  case_720896: 
#line 722
  if (endian == 536870912) {
#line 723
    return (0);
  } else
#line 722
  if (endian == 805306368) {
#line 723
    return (0);
  }
#line 724
  if (subformat == 5) {
#line 725
    return (1);
  } else
#line 724
  if (subformat == 2) {
#line 725
    return (1);
  }
#line 726
  if (subformat == 3) {
#line 727
    return (1);
  } else
#line 726
  if (subformat == 4) {
#line 727
    return (1);
  }
#line 728
  if (subformat == 18) {
    _L___50: 
#line 728
    if (info->channels <= 2) {
#line 729
      return (1);
    }
  } else
#line 728
  if (subformat == 19) {
#line 728
    goto _L___50;
  }
#line 730
  if (subformat == 32) {
#line 730
    if (info->channels == 1) {
#line 731
      return (1);
    }
  }
#line 732
  if (subformat == 16) {
#line 733
    return (1);
  } else
#line 732
  if (subformat == 17) {
#line 733
    return (1);
  }
#line 734
  if (subformat == 6) {
#line 735
    return (1);
  } else
#line 734
  if (subformat == 7) {
#line 735
    return (1);
  }
#line 736
  goto switch_break;
  case_786432: 
#line 739
  if (subformat == 2) {
#line 740
    return (1);
  } else
#line 739
  if (subformat == 4) {
#line 740
    return (1);
  }
#line 741
  if (subformat == 6) {
#line 742
    return (1);
  } else
#line 741
  if (subformat == 7) {
#line 742
    return (1);
  }
#line 743
  goto switch_break;
  case_851968: 
#line 746
  if (subformat == 5) {
#line 747
    return (1);
  } else
#line 746
  if (subformat == 2) {
#line 747
    return (1);
  } else
#line 746
  if (subformat == 4) {
#line 747
    return (1);
  }
#line 748
  if (subformat == 6) {
#line 749
    return (1);
  } else
#line 748
  if (subformat == 7) {
#line 749
    return (1);
  }
#line 750
  goto switch_break;
  case_917504: 
#line 753
  if (subformat == 1) {
#line 754
    return (1);
  } else
#line 753
  if (subformat == 2) {
#line 754
    return (1);
  } else
#line 753
  if (subformat == 4) {
#line 754
    return (1);
  }
#line 755
  goto switch_break;
  case_983040: 
#line 758
  if (info->channels != 1) {
#line 759
    return (0);
  }
#line 760
  if (subformat == 80) {
#line 761
    return (1);
  } else
#line 760
  if (subformat == 81) {
#line 761
    return (1);
  }
#line 762
  goto switch_break;
  case_1048576: 
#line 765
  if (info->channels != 1) {
#line 766
    return (0);
  }
#line 768
  if (endian == 268435456) {
#line 769
    return (0);
  } else
#line 768
  if (endian == 805306368) {
#line 769
    return (0);
  }
#line 770
  if (subformat == 2) {
#line 771
    return (1);
  }
#line 772
  goto switch_break;
  case_1114112: 
#line 775
  if (info->channels != 1) {
#line 776
    return (0);
  }
#line 778
  if (endian == 268435456) {
#line 779
    return (0);
  } else
#line 778
  if (endian == 805306368) {
#line 779
    return (0);
  }
#line 780
  if (subformat == 1) {
#line 781
    return (1);
  } else
#line 780
  if (subformat == 2) {
#line 781
    return (1);
  } else
#line 780
  if (subformat == 3) {
#line 781
    return (1);
  }
#line 782
  goto switch_break;
  case_1179648: 
#line 785
  if (info->channels > 2) {
#line 786
    return (0);
  }
#line 788
  if (endian == 268435456) {
#line 789
    return (0);
  } else
#line 788
  if (endian == 805306368) {
#line 789
    return (0);
  }
#line 790
  if (subformat == 5) {
#line 791
    return (1);
  } else
#line 790
  if (subformat == 1) {
#line 791
    return (1);
  } else
#line 790
  if (subformat == 2) {
#line 791
    return (1);
  }
#line 792
  goto switch_break;
  case_1507328: 
#line 796
  if (info->channels > 8) {
#line 797
    return (0);
  }
#line 798
  if (endian != 0) {
#line 799
    return (0);
  }
#line 800
  if (subformat == 1) {
#line 801
    return (1);
  } else
#line 800
  if (subformat == 2) {
#line 801
    return (1);
  } else
#line 800
  if (subformat == 3) {
#line 801
    return (1);
  }
#line 802
  goto switch_break;
  case_1441792: 
#line 806
  if (endian == 268435456) {
#line 807
    return (0);
  } else
#line 806
  if (endian == 805306368) {
#line 807
    return (0);
  }
#line 808
  if (subformat == 1) {
#line 809
    return (1);
  } else
#line 808
  if (subformat == 2) {
#line 809
    return (1);
  } else
#line 808
  if (subformat == 3) {
#line 809
    return (1);
  } else
#line 808
  if (subformat == 4) {
#line 809
    return (1);
  }
#line 810
  goto switch_break;
  case_1638400: 
#line 813
  if (info->channels > 1) {
#line 814
    return (0);
  }
#line 816
  if (endian == 536870912) {
#line 817
    return (0);
  } else
#line 816
  if (endian == 805306368) {
#line 817
    return (0);
  }
#line 818
  if (subformat == 17) {
#line 819
    return (1);
  }
#line 820
  goto switch_break;
  case_2097152: 
#line 823
  if (endian != 0) {
#line 824
    return (0);
  }
#line 825
  if (subformat == 96) {
#line 826
    return (1);
  }
#line 827
  goto switch_break;
  case_2162688: 
#line 830
  if (info->channels > 2) {
#line 831
    return (0);
  }
#line 833
  if (endian == 536870912) {
#line 834
    return (0);
  } else
#line 833
  if (endian == 805306368) {
#line 834
    return (0);
  }
#line 835
  if (subformat == 2) {
#line 836
    return (1);
  }
#line 837
  goto switch_break;
  case_2228224: 
#line 840
  if (endian == 536870912) {
#line 841
    return (0);
  } else
#line 840
  if (endian == 805306368) {
#line 841
    return (0);
  }
#line 842
  if (subformat == 5) {
#line 843
    return (1);
  } else
#line 842
  if (subformat == 2) {
#line 843
    return (1);
  }
#line 844
  if (subformat == 3) {
#line 845
    return (1);
  } else
#line 844
  if (subformat == 4) {
#line 845
    return (1);
  }
#line 846
  if (subformat == 16) {
#line 847
    return (1);
  } else
#line 846
  if (subformat == 17) {
#line 847
    return (1);
  }
#line 848
  if (subformat == 6) {
#line 849
    return (1);
  } else
#line 848
  if (subformat == 7) {
#line 849
    return (1);
  }
#line 850
  goto switch_break;
  switch_default: 
#line 851
  goto switch_break;
  switch_break: ;
#line 854
  return (0);
}
}
#line 861 "/root/patchweave_donee/23/src/sndfile.c"
char const   *sf_version_string(void) 
{ 


  {
#line 866
  return ("libsndfile-1.0.26");
}
}
#line 875 "/root/patchweave_donee/23/src/sndfile.c"
int sf_command(SNDFILE *sndfile , int command , void *data , int datasize ) 
{ 
  SF_PRIVATE *psf ;
  double quality ;
  int old_value ;
  char const   *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp11 ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double __cil_tmp22 ;
  int tmp___2 ;
  int format ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int tmp___3 ;
  sf_count_t position ;
  sf_count_t __cil_tmp34 ;
  int __cil_tmp36 ;
  int tmp___4 ;
  int tmp___5 ;
  int format___0 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int format___1 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int *iptr ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  void *tmp___6 ;

  {
#line 876
  psf = (SF_PRIVATE *)sndfile;
#line 882
  if (command == 4096) {
#line 882
    goto case_4096;
  }
#line 891
  if (command == 4128) {
#line 891
    goto case_4128;
  }
#line 897
  if (command == 4129) {
#line 897
    goto case_4129;
  }
#line 902
  if (command == 4144) {
#line 902
    goto case_4144;
  }
#line 908
  if (command == 4145) {
#line 908
    goto case_4145;
  }
#line 913
  if (command == 4146) {
#line 913
    goto case_4146;
  }
#line 919
  if (command == 4147) {
#line 919
    goto case_4147;
  }
#line 924
  if (command == 4136) {
#line 924
    goto case_4136;
  }
#line 881
  goto switch_break;
  case_4096: 
#line 883
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 884
    if (psf) {
#line 885
      psf->error = 31;
    }
#line 886
    return (31);
  }
  {
#line 888
  __cil_tmp8 = sf_version_string();
#line 888
  snprintf((char *)data, (unsigned long )datasize, "%s", __cil_tmp8);
#line 889
  __cil_tmp9 = strlen((char const   *)data);
  }
#line 889
  return ((int )__cil_tmp9);
  case_4128: 
#line 892
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 893
    sf_errno = 31;
#line 893
    return (sf_errno);
  } else
#line 892
  if (datasize != (int )sizeof(int )) {
#line 893
    sf_errno = 31;
#line 893
    return (sf_errno);
  }
  {
#line 894
  *((int *)data) = psf_get_format_simple_count();
  }
#line 895
  return (0);
  case_4129: 
#line 898
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 899
    sf_errno = 31;
#line 899
    return (sf_errno);
  } else
#line 898
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 899
    sf_errno = 31;
#line 899
    return (sf_errno);
  }
  {
#line 900
  __cil_tmp11 = psf_get_format_simple((SF_FORMAT_INFO *)data);
  }
#line 900
  return (__cil_tmp11);
  case_4144: 
#line 903
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 904
    sf_errno = 31;
#line 904
    return (sf_errno);
  } else
#line 903
  if (datasize != (int )sizeof(int )) {
#line 904
    sf_errno = 31;
#line 904
    return (sf_errno);
  }
  {
#line 905
  *((int *)data) = psf_get_format_major_count();
  }
#line 906
  return (0);
  case_4145: 
#line 909
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 910
    sf_errno = 31;
#line 910
    return (sf_errno);
  } else
#line 909
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 910
    sf_errno = 31;
#line 910
    return (sf_errno);
  }
  {
#line 911
  __cil_tmp13 = psf_get_format_major((SF_FORMAT_INFO *)data);
  }
#line 911
  return (__cil_tmp13);
  case_4146: 
#line 914
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 915
    sf_errno = 31;
#line 915
    return (sf_errno);
  } else
#line 914
  if (datasize != (int )sizeof(int )) {
#line 915
    sf_errno = 31;
#line 915
    return (sf_errno);
  }
  {
#line 916
  *((int *)data) = psf_get_format_subtype_count();
  }
#line 917
  return (0);
  case_4147: 
#line 920
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 921
    sf_errno = 31;
#line 921
    return (sf_errno);
  } else
#line 920
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 921
    sf_errno = 31;
#line 921
    return (sf_errno);
  }
  {
#line 922
  __cil_tmp15 = psf_get_format_subtype((SF_FORMAT_INFO *)data);
  }
#line 922
  return (__cil_tmp15);
  case_4136: 
#line 925
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 926
    sf_errno = 31;
#line 926
    return (sf_errno);
  } else
#line 925
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 926
    sf_errno = 31;
#line 926
    return (sf_errno);
  }
  {
#line 927
  __cil_tmp16 = psf_get_format_info((SF_FORMAT_INFO *)data);
  }
#line 927
  return (__cil_tmp16);
  switch_break: ;
#line 930
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 930
    if (command == 4097) {
#line 931
      if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 932
        sf_errno = 31;
#line 932
        return (sf_errno);
      }
      {
#line 933
      snprintf((char *)data, (unsigned long )datasize, "%s\311\333\204U", sf_parselog);
#line 934
      __cil_tmp17 = strlen((char const   *)data);
      }
#line 934
      return ((int )__cil_tmp17);
    }
  }
#line 937
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 937
    sf_errno = 10;
#line 937
    return (0);
  }
  {
#line 937
  psf = (SF_PRIVATE *)sndfile;
#line 937
  __cil_tmp18 = psf_file_valid(psf);
  }
#line 937
  if (psf->virtual_io == 0) {
#line 937
    if (__cil_tmp18 == 0) {
#line 937
      psf->error = 13;
#line 937
      return (0);
    }
  }
#line 937
  if (psf->Magick != 305447134) {
#line 937
    psf->error = 10;
#line 937
    return (0);
  }
#line 937
  psf->error = 0;
#line 940
  if (command == 4115) {
#line 940
    goto case_4115;
  }
#line 945
  if (command == 4098) {
#line 945
    goto case_4098;
  }
#line 951
  if (command == 4114) {
#line 951
    goto case_4114;
  }
#line 956
  if (command == 4113) {
#line 956
    goto case_4113;
  }
#line 959
  if (command == 4112) {
#line 959
    goto case_4112;
  }
#line 962
  if (command == 4116) {
#line 962
    goto case_4116;
  }
#line 971
  if (command == 4117) {
#line 971
    goto case_4117;
  }
#line 976
  if (command == 4176) {
#line 976
    goto case_4176;
  }
#line 984
  if (command == 1245184) {
#line 984
    goto case_1245184;
  }
#line 984
  if (command == 65536) {
#line 984
    goto case_1245184;
  }
#line 984
  if (command == 1572864) {
#line 984
    goto case_1245184;
  }
#line 984
  if (command == 131072) {
#line 984
    goto case_1245184;
  }
#line 1021
  if (command == 4177) {
#line 1021
    goto case_4177;
  }
#line 1024
  if (command == 4097) {
#line 1024
    goto case_4097;
  }
#line 1030
  if (command == 4160) {
#line 1030
    goto case_4160;
  }
#line 1036
  if (command == 4161) {
#line 1036
    goto case_4161;
  }
#line 1042
  if (command == 4162) {
#line 1042
    goto case_4162;
  }
#line 1047
  if (command == 4163) {
#line 1047
    goto case_4163;
  }
#line 1052
  if (command == 4164) {
#line 1052
    goto case_4164;
  }
#line 1059
  if (command == 4165) {
#line 1059
    goto case_4165;
  }
#line 1066
  if (command == 4192) {
#line 1066
    goto case_4192;
  }
#line 1071
  if (command == 4193) {
#line 1071
    goto case_4193;
  }
#line 1077
  if (command == 4209) {
#line 1077
    goto case_4209;
  }
#line 1077
  if (command == 4208) {
#line 1077
    goto case_4209;
  }
#line 1085
  if (command == 4256) {
#line 1085
    goto case_4256;
  }
#line 1093
  if (command == 4257) {
#line 1093
    goto case_4257;
  }
#line 1101
  if (command == 4224) {
#line 1101
    goto case_4224;
  }
#line 1126
  if (command == 4240) {
#line 1126
    goto case_4240;
  }
#line 1137
  if (command == 4272) {
#line 1137
    goto case_4272;
  }
#line 1146
  if (command == 24577) {
#line 1146
    goto case_24577;
  }
#line 1157
  if (command == 4288) {
#line 1157
    goto case_4288;
  }
#line 1161
  if (command == 4289) {
#line 1161
    goto case_4289;
  }
#line 1164
  if (command == 4320) {
#line 1164
    goto case_4320;
  }
#line 1174
  if (command == 4337) {
#line 1174
    goto case_4337;
  }
#line 1198
  if (command == 4336) {
#line 1198
    goto case_4336;
  }
#line 1205
  if (command == 5120) {
#line 1205
    goto case_5120;
  }
#line 1226
  if (command == 5121) {
#line 1226
    goto case_5121;
  }
#line 1233
  if (command == 4304) {
#line 1233
    goto case_4304;
  }
#line 1243
  if (command == 4305) {
#line 1243
    goto case_4305;
  }
#line 1261
  if (command == 4368) {
#line 1261
    goto case_4368;
  }
#line 1264
  if (command == 4352) {
#line 1264
    goto case_4352;
  }
#line 1276
  if (command == 4353) {
#line 1276
    goto case_4353;
  }
#line 1312
  if (command == 4864) {
#line 1312
    goto case_4864;
  }
#line 1321
  goto switch_default___0;
  case_4115: 
#line 941
  old_value = psf->norm_float;
#line 942
  if (datasize) {
#line 942
    tmp = 1;
  } else {
#line 942
    tmp = 0;
  }
#line 942
  psf->norm_float = tmp;
#line 943
  return (old_value);
  case_4098: 
#line 946
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 947
    sf_errno = 31;
#line 947
    return (sf_errno);
  } else
#line 946
  if (datasize != (int )sizeof(SF_INFO )) {
#line 947
    sf_errno = 31;
#line 947
    return (sf_errno);
  }
  {
#line 948
  memcpy(data, (void const   *)(& psf->sf), sizeof(SF_INFO ));
  }
#line 949
  goto switch_break___0;
  case_4114: 
#line 952
  old_value = psf->norm_double;
#line 953
  if (datasize) {
#line 953
    tmp___0 = 1;
  } else {
#line 953
    tmp___0 = 0;
  }
#line 953
  psf->norm_double = tmp___0;
#line 954
  return (old_value);
  case_4113: 
#line 957
  return (psf->norm_float);
  case_4112: 
#line 960
  return (psf->norm_double);
  case_4116: 
#line 963
  old_value = psf->float_int_mult;
#line 965
  if (datasize != 0) {
#line 965
    tmp___1 = 1;
  } else {
#line 965
    tmp___1 = 0;
  }
#line 965
  psf->float_int_mult = tmp___1;
#line 966
  if (psf->float_int_mult) {
#line 966
    if ((double )psf->float_max < 0.) {
      {
#line 968
      __cil_tmp22 = psf_calc_signal_max(psf, 0);
#line 968
      psf->float_max = (float )((32768. / 32767.) * __cil_tmp22);
      }
    }
  }
#line 969
  return (old_value);
  case_4117: 
#line 972
  old_value = psf->scale_int_float;
#line 973
  if (datasize != 0) {
#line 973
    tmp___2 = 1;
  } else {
#line 973
    tmp___2 = 0;
  }
#line 973
  psf->scale_int_float = tmp___2;
#line 974
  return (old_value);
  case_4176: 
#line 977
  format = psf->sf.format & 268369920;
#line 984
  if (format == 1245184) {
#line 984
    goto case_1245184;
  }
#line 984
  if (format == 65536) {
#line 984
    goto case_1245184;
  }
#line 984
  if (format == 1572864) {
#line 984
    goto case_1245184;
  }
#line 984
  if (format == 131072) {
#line 984
    goto case_1245184;
  }
#line 987
  goto switch_default;
  case_1245184: 
#line 985
  goto switch_break___1;
  switch_default: 
#line 988
  return (0);
  switch_break___1: 
#line 991
  format = psf->sf.format & 65535;
#line 994
  if (format != 6) {
#line 994
    if (format != 7) {
#line 995
      return (0);
    }
  }
#line 999
  if (psf->file.mode != 32) {
#line 999
    if (psf->file.mode != 48) {
#line 1000
      return (0);
    }
  }
#line 1002
  if (psf->have_written) {
#line 1003
    psf->error = 48;
#line 1004
    return (0);
  }
#line 1007
  if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1007
    if (datasize == 0) {
      {
#line 1008
      free((void *)psf->peak_info);
#line 1009
      psf->peak_info = (PEAK_INFO *)((void *)0);
      }
    } else {
#line 1007
      goto _L;
    }
  } else
  _L: 
#line 1011
  if ((unsigned long )psf->peak_info == (unsigned long )((void *)0)) {
    {
#line 1012
    psf->peak_info = peak_info_calloc(psf->sf.channels);
    }
#line 1013
    if ((unsigned long )psf->peak_info != (unsigned long )((void *)0)) {
#line 1014
      (psf->peak_info)->peak_loc = 42;
    }
  }
#line 1017
  if (psf->write_header) {
    {
#line 1018
    (*(psf->write_header))(psf, 1);
    }
  }
#line 1019
  return (datasize);
  case_4177: 
#line 1022
  return (0);
  case_4097: 
#line 1025
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1026
    return (31);
  }
  {
#line 1027
  snprintf((char *)data, (unsigned long )datasize, "%s\311\333\204U", psf->parselog.buf);
  }
#line 1028
  goto switch_break___0;
  case_4160: 
#line 1031
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1032
    psf->error = 31;
#line 1032
    return (psf->error);
  } else
#line 1031
  if ((unsigned long )datasize != sizeof(double )) {
#line 1032
    psf->error = 31;
#line 1032
    return (psf->error);
  }
  {
#line 1033
  *((double *)data) = psf_calc_signal_max(psf, 0);
  }
#line 1034
  goto switch_break___0;
  case_4161: 
#line 1037
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1038
    psf->error = 31;
#line 1038
    return (psf->error);
  } else
#line 1037
  if ((unsigned long )datasize != sizeof(double )) {
#line 1038
    psf->error = 31;
#line 1038
    return (psf->error);
  }
  {
#line 1039
  *((double *)data) = psf_calc_signal_max(psf, 1);
  }
#line 1040
  goto switch_break___0;
  case_4162: 
#line 1043
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1044
    psf->error = 31;
#line 1044
    return (psf->error);
  } else
#line 1043
  if (datasize != (int )sizeof(double ) * psf->sf.channels) {
#line 1044
    psf->error = 31;
#line 1044
    return (psf->error);
  }
  {
#line 1045
  __cil_tmp28 = psf_calc_max_all_channels(psf, (double *)data, 0);
  }
#line 1045
  return (__cil_tmp28);
  case_4163: 
#line 1048
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1049
    psf->error = 31;
#line 1049
    return (psf->error);
  } else
#line 1048
  if (datasize != (int )sizeof(double ) * psf->sf.channels) {
#line 1049
    psf->error = 31;
#line 1049
    return (psf->error);
  }
  {
#line 1050
  __cil_tmp29 = psf_calc_max_all_channels(psf, (double *)data, 1);
  }
#line 1050
  return (__cil_tmp29);
  case_4164: 
#line 1053
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1054
    psf->error = 31;
#line 1055
    return (0);
  } else
#line 1053
  if ((unsigned long )datasize != sizeof(double )) {
#line 1054
    psf->error = 31;
#line 1055
    return (0);
  }
  {
#line 1057
  __cil_tmp30 = psf_get_signal_max(psf, (double *)data);
  }
#line 1057
  return (__cil_tmp30);
  case_4165: 
#line 1060
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1061
    psf->error = 31;
#line 1062
    return (0);
  } else
#line 1060
  if (datasize != (int )sizeof(double ) * psf->sf.channels) {
#line 1061
    psf->error = 31;
#line 1062
    return (0);
  }
  {
#line 1064
  __cil_tmp31 = psf_get_max_all_channels(psf, (double *)data);
  }
#line 1064
  return (__cil_tmp31);
  case_4192: 
#line 1067
  if (psf->write_header) {
    {
#line 1068
    (*(psf->write_header))(psf, 1);
    }
  }
#line 1069
  goto switch_break___0;
  case_4193: 
#line 1072
  if (datasize) {
#line 1072
    tmp___3 = 1;
  } else {
#line 1072
    tmp___3 = 0;
  }
#line 1072
  psf->auto_header = tmp___3;
#line 1073
  return (psf->auto_header);
#line 1074
  goto switch_break___0;
  case_4209: 
#line 1083
  goto switch_break___0;
  case_4256: 
#line 1086
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1087
    psf->error = 31;
#line 1087
    return (psf->error);
  } else
#line 1086
  if (datasize != (int )sizeof(SF_DITHER_INFO )) {
#line 1087
    psf->error = 31;
#line 1087
    return (psf->error);
  }
  {
#line 1088
  memcpy((void *)(& psf->write_dither), (void const   *)data, sizeof(psf->write_dither));
  }
#line 1089
  if (psf->file.mode == 32) {
    {
#line 1090
    dither_init(psf, 32);
    }
  } else
#line 1089
  if (psf->file.mode == 48) {
    {
#line 1090
    dither_init(psf, 32);
    }
  }
#line 1091
  goto switch_break___0;
  case_4257: 
#line 1094
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1095
    psf->error = 31;
#line 1095
    return (psf->error);
  } else
#line 1094
  if (datasize != (int )sizeof(SF_DITHER_INFO )) {
#line 1095
    psf->error = 31;
#line 1095
    return (psf->error);
  }
  {
#line 1096
  memcpy((void *)(& psf->read_dither), (void const   *)data, sizeof(psf->read_dither));
  }
#line 1097
  if (psf->file.mode == 16) {
    {
#line 1098
    dither_init(psf, 16);
    }
  } else
#line 1097
  if (psf->file.mode == 48) {
    {
#line 1098
    dither_init(psf, 16);
    }
  }
#line 1099
  goto switch_break___0;
  case_4224: 
#line 1102
  if (psf->file.mode != 32) {
#line 1102
    if (psf->file.mode != 48) {
#line 1103
      return (1);
    }
  }
#line 1104
  if ((unsigned long )datasize != sizeof(sf_count_t )) {
#line 1105
    return (1);
  }
#line 1106
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1107
    psf->error = 31;
#line 1108
    return (0);
  } else
#line 1106
  if ((unsigned long )datasize != sizeof(sf_count_t )) {
#line 1107
    psf->error = 31;
#line 1108
    return (0);
  } else {
    {
#line 1113
    position = *((sf_count_t *)data);
#line 1115
    __cil_tmp34 = sf_seek(sndfile, position, 0);
    }
#line 1115
    if (__cil_tmp34 != position) {
#line 1116
      return (1);
    }
    {
#line 1118
    psf->sf.frames = position;
#line 1120
    position = psf_fseek(psf, (sf_count_t )0, 1);
#line 1122
    __cil_tmp36 = psf_ftruncate(psf, position);
    }
#line 1122
    return (__cil_tmp36);
  }
#line 1124
  goto switch_break___0;
  case_4240: 
#line 1127
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1128
    psf->error = 31;
#line 1128
    return (psf->error);
  } else
#line 1127
  if ((unsigned long )datasize != sizeof(sf_count_t )) {
#line 1128
    psf->error = 31;
#line 1128
    return (psf->error);
  }
#line 1130
  if ((psf->sf.format & 268369920) != 262144) {
#line 1131
    psf->error = 31;
#line 1131
    return (psf->error);
  }
  {
#line 1133
  psf->dataoffset = *((sf_count_t *)data);
#line 1134
  sf_seek(sndfile, (sf_count_t )0, 1);
  }
#line 1135
  goto switch_break___0;
  case_4272: 
#line 1138
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1139
    psf->error = 31;
#line 1139
    return (psf->error);
  } else
#line 1138
  if ((unsigned long )datasize != sizeof(SF_EMBED_FILE_INFO )) {
#line 1139
    psf->error = 31;
#line 1139
    return (psf->error);
  }
#line 1141
  ((SF_EMBED_FILE_INFO *)data)->offset = psf->fileoffset;
#line 1142
  ((SF_EMBED_FILE_INFO *)data)->length = psf->filelength;
#line 1143
  goto switch_break___0;
  case_24577: 
#line 1147
  if (datasize) {
#line 1147
    tmp___4 = 1;
  } else {
#line 1147
    tmp___4 = 0;
  }
#line 1147
  psf->ieee_replace = tmp___4;
#line 1148
  if ((psf->sf.format & 65535) == 6) {
    {
#line 1149
    float32_init(psf);
    }
  } else
#line 1150
  if ((psf->sf.format & 65535) == 7) {
    {
#line 1151
    double64_init(psf);
    }
  } else {
#line 1153
    psf->error = 31;
#line 1153
    return (psf->error);
  }
#line 1154
  goto switch_break___0;
  case_4288: 
#line 1158
  if (datasize) {
#line 1158
    tmp___5 = 1;
  } else {
#line 1158
    tmp___5 = 0;
  }
#line 1158
  psf->add_clipping = tmp___5;
#line 1159
  return (psf->add_clipping);
  case_4289: 
#line 1162
  return (psf->add_clipping);
  case_4320: 
#line 1165
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1166
    psf->error = 31;
#line 1167
    return (0);
  } else
#line 1165
  if ((unsigned long )datasize != sizeof(SF_LOOP_INFO )) {
#line 1166
    psf->error = 31;
#line 1167
    return (0);
  }
#line 1169
  if ((unsigned long )psf->loop_info == (unsigned long )((void *)0)) {
#line 1170
    return (0);
  }
  {
#line 1171
  memcpy(data, (void const   *)psf->loop_info, sizeof(SF_LOOP_INFO ));
  }
#line 1172
  return (1);
  case_4337: 
#line 1175
  format___0 = psf->sf.format & 268369920;
#line 1178
  if (format___0 != 65536) {
#line 1178
    if (format___0 != 1245184) {
#line 1178
      if (format___0 != 2228224) {
#line 1179
        return (0);
      }
    }
  }
#line 1183
  if (psf->file.mode != 32) {
#line 1183
    if (psf->file.mode != 48) {
#line 1184
      return (0);
    }
  }
#line 1186
  if ((unsigned long )psf->broadcast_16k == (unsigned long )((void *)0)) {
#line 1186
    if (psf->have_written) {
#line 1187
      psf->error = 48;
#line 1188
      return (0);
    }
  }
  {
#line 1191
  __cil_tmp40 = broadcast_var_set(psf, (SF_BROADCAST_INFO *)data, (size_t )datasize);
  }
#line 1191
  if (! __cil_tmp40) {
#line 1192
    return (0);
  }
#line 1194
  if (psf->write_header) {
    {
#line 1195
    (*(psf->write_header))(psf, 1);
    }
  }
#line 1196
  return (1);
  case_4336: 
#line 1199
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1200
    psf->error = 31;
#line 1201
    return (0);
  }
  {
#line 1203
  __cil_tmp41 = broadcast_var_get(psf, (SF_BROADCAST_INFO *)data, (size_t )datasize);
  }
#line 1203
  return (__cil_tmp41);
  case_5120: 
#line 1206
  format___1 = psf->sf.format & 268369920;
#line 1208
  if (format___1 != 65536) {
#line 1208
    if (format___1 != 2228224) {
#line 1209
      return (0);
    }
  }
#line 1213
  if (psf->file.mode != 32) {
#line 1213
    if (psf->file.mode != 48) {
#line 1214
      return (0);
    }
  }
#line 1216
  if ((unsigned long )psf->cart_16k == (unsigned long )((void *)0)) {
#line 1216
    if (psf->have_written) {
#line 1217
      psf->error = 48;
#line 1218
      return (0);
    }
  }
  {
#line 1220
  __cil_tmp43 = cart_var_set(psf, (SF_CART_INFO *)data, (size_t )datasize);
  }
#line 1220
  if (! __cil_tmp43) {
#line 1221
    return (0);
  }
#line 1222
  if (psf->write_header) {
    {
#line 1223
    (*(psf->write_header))(psf, 1);
    }
  }
#line 1224
  return (1);
  case_5121: 
#line 1227
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1228
    psf->error = 31;
#line 1229
    return (0);
  }
  {
#line 1231
  __cil_tmp44 = cart_var_get(psf, (SF_CART_INFO *)data, (size_t )datasize);
  }
#line 1231
  return (__cil_tmp44);
  case_4304: 
#line 1234
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1235
    psf->error = 31;
#line 1236
    return (0);
  } else
#line 1234
  if ((unsigned long )datasize != sizeof(SF_INSTRUMENT )) {
#line 1235
    psf->error = 31;
#line 1236
    return (0);
  }
#line 1238
  if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 1239
    return (0);
  }
  {
#line 1240
  memcpy(data, (void const   *)psf->instrument, sizeof(SF_INSTRUMENT ));
  }
#line 1241
  return (1);
  case_4305: 
#line 1245
  if (psf->have_written) {
#line 1246
    psf->error = 48;
#line 1247
    return (0);
  }
#line 1249
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1250
    psf->error = 31;
#line 1251
    return (0);
  } else
#line 1249
  if ((unsigned long )datasize != sizeof(SF_INSTRUMENT )) {
#line 1250
    psf->error = 31;
#line 1251
    return (0);
  }
  {
#line 1254
  psf->instrument = psf_instrument_alloc();
  }
#line 1254
  if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 1254
    if ((unsigned long )psf->instrument == (unsigned long )((void *)0)) {
#line 1255
      psf->error = 17;
#line 1256
      return (0);
    }
  }
  {
#line 1258
  memcpy((void *)psf->instrument, (void const   *)data, sizeof(SF_INSTRUMENT ));
  }
#line 1259
  return (1);
  case_4368: 
#line 1262
  return (psf->data_endswap);
  case_4352: 
#line 1265
  if ((unsigned long )psf->channel_map == (unsigned long )((void *)0)) {
#line 1266
    return (0);
  }
#line 1268
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1269
    psf->error = 31;
#line 1270
    return (0);
  } else
#line 1268
  if (datasize != (int )sizeof(*(psf->channel_map + 0)) * psf->sf.channels) {
#line 1269
    psf->error = 31;
#line 1270
    return (0);
  }
  {
#line 1273
  memcpy(data, (void const   *)psf->channel_map, (unsigned long )datasize);
  }
#line 1274
  return (1);
  case_4353: 
#line 1277
  if (psf->have_written) {
#line 1278
    psf->error = 48;
#line 1279
    return (0);
  }
#line 1281
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1282
    psf->error = 31;
#line 1283
    return (0);
  } else
#line 1281
  if (datasize != (int )sizeof(*(psf->channel_map + 0)) * psf->sf.channels) {
#line 1282
    psf->error = 31;
#line 1283
    return (0);
  }
#line 1288
  iptr = (int *)data;
  {
#line 1288
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1288
    if (! ((unsigned long )iptr < (unsigned long )((int *)data + psf->sf.channels))) {
#line 1288
      goto while_break;
    }
#line 1289
    if (*iptr <= 0) {
#line 1290
      psf->error = 31;
#line 1291
      return (0);
    } else
#line 1289
    if (*iptr >= 27) {
#line 1290
      psf->error = 31;
#line 1291
      return (0);
    }
#line 1288
    iptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1296
  free((void *)psf->channel_map);
#line 1297
  tmp___6 = malloc((unsigned long )datasize);
#line 1297
  psf->channel_map = (int *)tmp___6;
  }
#line 1297
  if ((unsigned long )psf->channel_map == (unsigned long )((void *)0)) {
#line 1298
    psf->error = 17;
#line 1299
    return (0);
  }
  {
#line 1302
  memcpy((void *)psf->channel_map, (void const   *)data, (unsigned long )datasize);
  }
#line 1308
  if (psf->command) {
    {
#line 1309
    __cil_tmp49 = (*(psf->command))(psf, command, (void *)0, 0);
    }
#line 1309
    return (__cil_tmp49);
  }
#line 1310
  return (0);
  case_4864: 
#line 1313
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1314
    return (0);
  } else
#line 1313
  if ((unsigned long )datasize != sizeof(double )) {
#line 1314
    return (0);
  }
  {
#line 1316
  quality = *((double *)data);
#line 1317
  quality = 1. - (double )0;
#line 1318
  __cil_tmp50 = sf_command(sndfile, 4865, (void *)(& quality), (int )sizeof(quality));
  }
#line 1318
  return (__cil_tmp50);
  switch_default___0: 
#line 1323
  if (psf->command) {
    {
#line 1324
    __cil_tmp51 = (*(psf->command))(psf, command, data, datasize);
    }
#line 1324
    return (__cil_tmp51);
  }
  {
#line 1326
  psf_log_printf(psf, "*** sf_command : cmd = 0x%X\n\204U", command);
#line 1327
  psf->error = 31;
  }
#line 1327
  return (psf->error);
  switch_break___0: ;
#line 1330
  return (0);
}
}
#line 1337 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_seek(SNDFILE *sndfile , sf_count_t offset , int whence ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t seek_from_start ;
  sf_count_t retval ;
  int __cil_tmp7 ;
  int new_mode ;
  int tmp ;

  {
#line 1339
  seek_from_start = (sf_count_t )0;
#line 1341
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1341
    sf_errno = 10;
#line 1341
    return ((sf_count_t )0);
  }
  {
#line 1341
  psf = (SF_PRIVATE *)sndfile;
#line 1341
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1341
  if (psf->virtual_io == 0) {
#line 1341
    if (__cil_tmp7 == 0) {
#line 1341
      psf->error = 13;
#line 1341
      return ((sf_count_t )0);
    }
  }
#line 1341
  if (psf->Magick != 305447134) {
#line 1341
    psf->error = 10;
#line 1341
    return ((sf_count_t )0);
  }
#line 1341
  psf->error = 0;
#line 1343
  if (! psf->sf.seekable) {
#line 1344
    psf->error = 40;
#line 1345
    return ((sf_count_t )-1);
  }
#line 1351
  if ((whence & 48) == 32) {
#line 1351
    if (psf->file.mode == 16) {
#line 1353
      psf->error = 42;
#line 1354
      return ((sf_count_t )-1);
    } else {
#line 1351
      goto _L;
    }
  } else
  _L: 
#line 1351
  if ((whence & 48) == 16) {
#line 1351
    if (psf->file.mode == 32) {
#line 1353
      psf->error = 42;
#line 1354
      return ((sf_count_t )-1);
    }
  }
#line 1365
  if (whence == 48) {
#line 1365
    goto case_48;
  }
#line 1365
  if (whence == 32) {
#line 1365
    goto case_48;
  }
#line 1365
  if (whence == 16) {
#line 1365
    goto case_48;
  }
#line 1365
  if (whence == 0) {
#line 1365
    goto case_48;
  }
#line 1370
  if (whence == 1) {
#line 1370
    goto case_1;
  }
#line 1385
  if (whence == 17) {
#line 1385
    goto case_17;
  }
#line 1391
  if (whence == 33) {
#line 1391
    goto case_33;
  }
#line 1400
  if (whence == 34) {
#line 1400
    goto case_34;
  }
#line 1400
  if (whence == 18) {
#line 1400
    goto case_34;
  }
#line 1400
  if (whence == 2) {
#line 1400
    goto case_34;
  }
#line 1404
  goto switch_default;
  case_48: 
#line 1366
  seek_from_start = offset;
#line 1367
  goto switch_break;
  case_1: 
#line 1371
  if (offset == 0L) {
#line 1372
    if (psf->file.mode == 16) {
#line 1373
      return (psf->read_current);
    }
#line 1374
    if (psf->file.mode == 32) {
#line 1375
      return (psf->write_current);
    }
  }
#line 1377
  if (psf->file.mode == 16) {
#line 1378
    seek_from_start = psf->read_current + offset;
  } else
#line 1379
  if (psf->file.mode == 32) {
#line 1380
    seek_from_start = psf->write_current + offset;
  } else
#line 1379
  if (psf->file.mode == 48) {
#line 1380
    seek_from_start = psf->write_current + offset;
  } else {
#line 1382
    psf->error = 41;
  }
#line 1383
  goto switch_break;
  case_17: 
#line 1386
  if (offset == 0L) {
#line 1387
    return (psf->read_current);
  }
#line 1388
  seek_from_start = psf->read_current + offset;
#line 1389
  goto switch_break;
  case_33: 
#line 1392
  if (offset == 0L) {
#line 1393
    return (psf->write_current);
  }
#line 1394
  seek_from_start = psf->write_current + offset;
#line 1395
  goto switch_break;
  case_34: 
#line 1401
  seek_from_start = psf->sf.frames + offset;
#line 1402
  goto switch_break;
  switch_default: 
#line 1405
  psf->error = 39;
#line 1406
  goto switch_break;
  switch_break: ;
#line 1409
  if (psf->error) {
#line 1410
    return ((sf_count_t )-1);
  }
#line 1412
  if (psf->file.mode == 48) {
    _L___51: 
#line 1413
    if (seek_from_start < 0L) {
#line 1414
      psf->error = 39;
#line 1415
      return ((sf_count_t )-1);
    }
  } else
#line 1412
  if (psf->file.mode == 32) {
#line 1412
    goto _L___51;
  } else
#line 1418
  if (seek_from_start < 0L) {
#line 1419
    psf->error = 39;
#line 1420
    return ((sf_count_t )-1);
  } else
#line 1418
  if (seek_from_start > psf->sf.frames) {
#line 1419
    psf->error = 39;
#line 1420
    return ((sf_count_t )-1);
  }
#line 1423
  if (psf->seek) {
#line 1424
    if (whence & 48) {
#line 1424
      tmp = whence & 48;
    } else {
#line 1424
      tmp = psf->file.mode;
    }
    {
#line 1424
    new_mode = tmp;
#line 1426
    retval = (*(psf->seek))(psf, new_mode, seek_from_start);
    }
#line 1429
    if (new_mode == 16) {
#line 1429
      goto case_16___0;
    }
#line 1432
    if (new_mode == 32) {
#line 1432
      goto case_32___0;
    }
#line 1435
    if (new_mode == 48) {
#line 1435
      goto case_48___0;
    }
#line 1428
    goto switch_break___0;
    case_16___0: 
#line 1430
    psf->read_current = retval;
#line 1431
    goto switch_break___0;
    case_32___0: 
#line 1433
    psf->write_current = retval;
#line 1434
    goto switch_break___0;
    case_48___0: 
#line 1436
    psf->read_current = retval;
#line 1437
    psf->write_current = retval;
#line 1438
    new_mode = 16;
#line 1439
    goto switch_break___0;
    switch_break___0: 
#line 1442
    psf->last_op = new_mode;
#line 1444
    return (retval);
  }
#line 1447
  psf->error = 41;
#line 1448
  return ((sf_count_t )-1);
}
}
#line 1455 "/root/patchweave_donee/23/src/sndfile.c"
char const   *sf_get_string(SNDFILE *sndfile , int str_type ) 
{ 
  SF_PRIVATE *psf ;
  char const   *__cil_tmp4 ;

  {
#line 1458
  psf = (SF_PRIVATE *)sndfile;
#line 1458
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 1459
    return ((char const   *)((void *)0));
  }
#line 1460
  if (psf->Magick != 305447134) {
#line 1461
    return ((char const   *)((void *)0));
  }
  {
#line 1463
  __cil_tmp4 = psf_get_string(psf, str_type);
  }
#line 1463
  return (__cil_tmp4);
}
}
#line 1467 "/root/patchweave_donee/23/src/sndfile.c"
int sf_set_string(SNDFILE *sndfile , int str_type , char const   *str___0 ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 1470
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1470
    sf_errno = 10;
#line 1470
    return (0);
  }
  {
#line 1470
  psf = (SF_PRIVATE *)sndfile;
#line 1470
  __cil_tmp5 = psf_file_valid(psf);
  }
#line 1470
  if (psf->virtual_io == 0) {
#line 1470
    if (__cil_tmp5 == 0) {
#line 1470
      psf->error = 13;
#line 1470
      return (0);
    }
  }
#line 1470
  if (psf->Magick != 305447134) {
#line 1470
    psf->error = 10;
#line 1470
    return (0);
  }
  {
#line 1470
  psf->error = 0;
#line 1472
  __cil_tmp6 = psf_set_string(psf, str_type, str___0);
  }
#line 1472
  return (__cil_tmp6);
}
}
#line 1479 "/root/patchweave_donee/23/src/sndfile.c"
int sf_current_byterate(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp3 ;

  {
#line 1482
  psf = (SF_PRIVATE *)sndfile;
#line 1482
  if ((unsigned long )psf == (unsigned long )((void *)0)) {
#line 1483
    return (-1);
  }
#line 1484
  if (psf->Magick != 305447134) {
#line 1485
    return (-1);
  }
#line 1488
  if (psf->bytewidth) {
#line 1489
    return ((psf->sf.samplerate * psf->sf.channels) * psf->bytewidth);
  }
#line 1491
  if (psf->byterate) {
    {
#line 1492
    __cil_tmp3 = (*(psf->byterate))(psf);
    }
#line 1492
    return (__cil_tmp3);
  }
#line 1497
  if ((psf->sf.format & 65535) == 33) {
#line 1497
    goto case_33;
  }
#line 1497
  if ((psf->sf.format & 65535) == 19) {
#line 1497
    goto case_33;
  }
#line 1497
  if ((psf->sf.format & 65535) == 18) {
#line 1497
    goto case_33;
  }
#line 1500
  if ((psf->sf.format & 65535) == 32) {
#line 1500
    goto case_32;
  }
#line 1503
  if ((psf->sf.format & 65535) == 48) {
#line 1503
    goto case_48;
  }
#line 1506
  if ((psf->sf.format & 65535) == 49) {
#line 1506
    goto case_49;
  }
#line 1509
  if ((psf->sf.format & 65535) == 50) {
#line 1509
    goto case_50;
  }
#line 1512
  goto switch_default;
  case_33: 
#line 1498
  return ((psf->sf.samplerate * psf->sf.channels) / 2);
  case_32: 
#line 1501
  return (((psf->sf.samplerate * psf->sf.channels) * 13000) / 8000);
  case_48: 
#line 1504
  return ((psf->sf.samplerate * psf->sf.channels) / 2);
  case_49: 
#line 1507
  return (((psf->sf.samplerate * psf->sf.channels) * 3) / 8);
  case_50: 
#line 1510
  return (((psf->sf.samplerate * psf->sf.channels) * 5) / 8);
  switch_default: 
#line 1513
  goto switch_break;
  switch_break: ;
#line 1516
  return (-1);
}
}
#line 1523 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_read_raw(SNDFILE *sndfile , void *ptr , sf_count_t bytes ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int bytewidth ;
  int blockwidth ;
  int __cil_tmp9 ;
  int tmp ;
  int tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 1528
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1528
    sf_errno = 10;
#line 1528
    return ((sf_count_t )0);
  }
  {
#line 1528
  psf = (SF_PRIVATE *)sndfile;
#line 1528
  __cil_tmp9 = psf_file_valid(psf);
  }
#line 1528
  if (psf->virtual_io == 0) {
#line 1528
    if (__cil_tmp9 == 0) {
#line 1528
      psf->error = 13;
#line 1528
      return ((sf_count_t )0);
    }
  }
#line 1528
  if (psf->Magick != 305447134) {
#line 1528
    psf->error = 10;
#line 1528
    return ((sf_count_t )0);
  }
#line 1528
  psf->error = 0;
#line 1530
  if (psf->bytewidth > 0) {
#line 1530
    tmp = psf->bytewidth;
  } else {
#line 1530
    tmp = 1;
  }
#line 1530
  bytewidth = tmp;
#line 1531
  if (psf->blockwidth > 0) {
#line 1531
    tmp___0 = psf->blockwidth;
  } else {
#line 1531
    tmp___0 = 1;
  }
#line 1531
  blockwidth = tmp___0;
#line 1533
  if (psf->file.mode == 32) {
#line 1534
    psf->error = 22;
#line 1535
    return ((sf_count_t )0);
  }
#line 1538
  if (bytes < 0L) {
    {
#line 1539
    psf_memset(ptr, 0, bytes);
    }
#line 1540
    return ((sf_count_t )0);
  } else
#line 1538
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1539
    psf_memset(ptr, 0, bytes);
    }
#line 1540
    return ((sf_count_t )0);
  }
#line 1543
  if (bytes % (long )(psf->sf.channels * bytewidth)) {
#line 1544
    psf->error = 19;
#line 1545
    return ((sf_count_t )0);
  }
#line 1548
  if (psf->last_op != 16) {
    {
#line 1549
    __cil_tmp12 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1549
    if (__cil_tmp12 < 0L) {
#line 1550
      return ((sf_count_t )0);
    }
  }
  {
#line 1552
  count___0 = psf_fread(ptr, (sf_count_t )1, bytes, psf);
  }
#line 1554
  if (psf->read_current + count___0 / (long )blockwidth <= psf->sf.frames) {
#line 1555
    psf->read_current += count___0 / (long )blockwidth;
  } else {
    {
#line 1557
    count___0 = (psf->sf.frames - psf->read_current) * (long )blockwidth;
#line 1558
    extra = bytes - count___0;
#line 1559
    psf_memset((void *)((char *)ptr + count___0), 0, extra);
#line 1560
    psf->read_current = psf->sf.frames;
    }
  }
#line 1563
  psf->last_op = 16;
#line 1565
  return (count___0);
}
}
#line 1572 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_read_short(SNDFILE *sndfile , short *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1576
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1576
    sf_errno = 10;
#line 1576
    return ((sf_count_t )0);
  }
  {
#line 1576
  psf = (SF_PRIVATE *)sndfile;
#line 1576
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1576
  if (psf->virtual_io == 0) {
#line 1576
    if (__cil_tmp7 == 0) {
#line 1576
      psf->error = 13;
#line 1576
      return ((sf_count_t )0);
    }
  }
#line 1576
  if (psf->Magick != 305447134) {
#line 1576
    psf->error = 10;
#line 1576
    return ((sf_count_t )0);
  }
#line 1576
  psf->error = 0;
#line 1578
  if (psf->file.mode == 32) {
#line 1579
    psf->error = 22;
#line 1580
    return ((sf_count_t )0);
  }
#line 1583
  if (len % (long )psf->sf.channels) {
#line 1584
    psf->error = 19;
#line 1585
    return ((sf_count_t )0);
  }
#line 1588
  if (len <= 0L) {
    {
#line 1589
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(short )));
    }
#line 1590
    return ((sf_count_t )0);
  } else
#line 1588
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1589
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(short )));
    }
#line 1590
    return ((sf_count_t )0);
  }
#line 1593
  if ((unsigned long )psf->read_short == (unsigned long )((void *)0)) {
#line 1594
    psf->error = 18;
#line 1595
    return ((sf_count_t )0);
  } else
#line 1593
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1594
    psf->error = 18;
#line 1595
    return ((sf_count_t )0);
  }
#line 1598
  if (psf->last_op != 16) {
    {
#line 1599
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1599
    if (__cil_tmp8 < 0L) {
#line 1600
      return ((sf_count_t )0);
    }
  }
  {
#line 1602
  count___0 = (*(psf->read_short))(psf, ptr, len);
  }
#line 1604
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1605
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1607
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1608
    extra = len - count___0;
#line 1609
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(short )));
#line 1610
    psf->read_current = psf->sf.frames;
    }
  }
#line 1613
  psf->last_op = 16;
#line 1615
  return (count___0);
}
}
#line 1619 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_readf_short(SNDFILE *sndfile , short *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1623
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1623
    sf_errno = 10;
#line 1623
    return ((sf_count_t )0);
  }
  {
#line 1623
  psf = (SF_PRIVATE *)sndfile;
#line 1623
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1623
  if (psf->virtual_io == 0) {
#line 1623
    if (__cil_tmp7 == 0) {
#line 1623
      psf->error = 13;
#line 1623
      return ((sf_count_t )0);
    }
  }
#line 1623
  if (psf->Magick != 305447134) {
#line 1623
    psf->error = 10;
#line 1623
    return ((sf_count_t )0);
  }
#line 1623
  psf->error = 0;
#line 1625
  if (psf->file.mode == 32) {
#line 1626
    psf->error = 22;
#line 1627
    return ((sf_count_t )0);
  }
#line 1630
  if (frames <= 0L) {
    {
#line 1631
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(short )));
    }
#line 1632
    return ((sf_count_t )0);
  } else
#line 1630
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1631
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(short )));
    }
#line 1632
    return ((sf_count_t )0);
  }
#line 1635
  if ((unsigned long )psf->read_short == (unsigned long )((void *)0)) {
#line 1636
    psf->error = 18;
#line 1637
    return ((sf_count_t )0);
  } else
#line 1635
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1636
    psf->error = 18;
#line 1637
    return ((sf_count_t )0);
  }
#line 1640
  if (psf->last_op != 16) {
    {
#line 1641
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1641
    if (__cil_tmp8 < 0L) {
#line 1642
      return ((sf_count_t )0);
    }
  }
  {
#line 1644
  count___0 = (*(psf->read_short))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 1646
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1647
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1649
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1650
    extra = frames * (long )psf->sf.channels - count___0;
#line 1651
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(short )));
#line 1652
    psf->read_current = psf->sf.frames;
    }
  }
#line 1655
  psf->last_op = 16;
#line 1657
  return (count___0 / (long )psf->sf.channels);
}
}
#line 1664 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_read_int(SNDFILE *sndfile , int *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1668
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1668
    sf_errno = 10;
#line 1668
    return ((sf_count_t )0);
  }
  {
#line 1668
  psf = (SF_PRIVATE *)sndfile;
#line 1668
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1668
  if (psf->virtual_io == 0) {
#line 1668
    if (__cil_tmp7 == 0) {
#line 1668
      psf->error = 13;
#line 1668
      return ((sf_count_t )0);
    }
  }
#line 1668
  if (psf->Magick != 305447134) {
#line 1668
    psf->error = 10;
#line 1668
    return ((sf_count_t )0);
  }
#line 1668
  psf->error = 0;
#line 1670
  if (psf->file.mode == 32) {
#line 1671
    psf->error = 22;
#line 1672
    return ((sf_count_t )0);
  }
#line 1675
  if (len % (long )psf->sf.channels) {
#line 1676
    psf->error = 19;
#line 1677
    return ((sf_count_t )0);
  }
#line 1680
  if (len <= 0L) {
    {
#line 1681
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(int )));
    }
#line 1682
    return ((sf_count_t )0);
  } else
#line 1680
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1681
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(int )));
    }
#line 1682
    return ((sf_count_t )0);
  }
#line 1685
  if ((unsigned long )psf->read_int == (unsigned long )((void *)0)) {
#line 1686
    psf->error = 18;
#line 1687
    return ((sf_count_t )0);
  } else
#line 1685
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1686
    psf->error = 18;
#line 1687
    return ((sf_count_t )0);
  }
#line 1690
  if (psf->last_op != 16) {
    {
#line 1691
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1691
    if (__cil_tmp8 < 0L) {
#line 1692
      return ((sf_count_t )0);
    }
  }
  {
#line 1694
  count___0 = (*(psf->read_int))(psf, ptr, len);
  }
#line 1696
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1697
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1699
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1700
    extra = len - count___0;
#line 1701
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(int )));
#line 1702
    psf->read_current = psf->sf.frames;
    }
  }
#line 1705
  psf->last_op = 16;
#line 1707
  return (count___0);
}
}
#line 1711 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_readf_int(SNDFILE *sndfile , int *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1715
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1715
    sf_errno = 10;
#line 1715
    return ((sf_count_t )0);
  }
  {
#line 1715
  psf = (SF_PRIVATE *)sndfile;
#line 1715
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1715
  if (psf->virtual_io == 0) {
#line 1715
    if (__cil_tmp7 == 0) {
#line 1715
      psf->error = 13;
#line 1715
      return ((sf_count_t )0);
    }
  }
#line 1715
  if (psf->Magick != 305447134) {
#line 1715
    psf->error = 10;
#line 1715
    return ((sf_count_t )0);
  }
#line 1715
  psf->error = 0;
#line 1717
  if (psf->file.mode == 32) {
#line 1718
    psf->error = 22;
#line 1719
    return ((sf_count_t )0);
  }
#line 1722
  if (frames <= 0L) {
    {
#line 1723
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(int )));
    }
#line 1724
    return ((sf_count_t )0);
  } else
#line 1722
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1723
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(int )));
    }
#line 1724
    return ((sf_count_t )0);
  }
#line 1727
  if ((unsigned long )psf->read_int == (unsigned long )((void *)0)) {
#line 1728
    psf->error = 18;
#line 1729
    return ((sf_count_t )0);
  } else
#line 1727
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1728
    psf->error = 18;
#line 1729
    return ((sf_count_t )0);
  }
#line 1732
  if (psf->last_op != 16) {
    {
#line 1733
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1733
    if (__cil_tmp8 < 0L) {
#line 1734
      return ((sf_count_t )0);
    }
  }
  {
#line 1736
  count___0 = (*(psf->read_int))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 1738
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1739
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1741
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1742
    extra = frames * (long )psf->sf.channels - count___0;
#line 1743
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(int )));
#line 1744
    psf->read_current = psf->sf.frames;
    }
  }
#line 1747
  psf->last_op = 16;
#line 1749
  return (count___0 / (long )psf->sf.channels);
}
}
#line 1756 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_read_float(SNDFILE *sndfile , float *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1760
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1760
    sf_errno = 10;
#line 1760
    return ((sf_count_t )0);
  }
  {
#line 1760
  psf = (SF_PRIVATE *)sndfile;
#line 1760
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1760
  if (psf->virtual_io == 0) {
#line 1760
    if (__cil_tmp7 == 0) {
#line 1760
      psf->error = 13;
#line 1760
      return ((sf_count_t )0);
    }
  }
#line 1760
  if (psf->Magick != 305447134) {
#line 1760
    psf->error = 10;
#line 1760
    return ((sf_count_t )0);
  }
#line 1760
  psf->error = 0;
#line 1762
  if (psf->file.mode == 32) {
#line 1763
    psf->error = 22;
#line 1764
    return ((sf_count_t )0);
  }
#line 1767
  if (len % (long )psf->sf.channels) {
#line 1768
    psf->error = 19;
#line 1769
    return ((sf_count_t )0);
  }
#line 1772
  if (len <= 0L) {
    {
#line 1773
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(float )));
    }
#line 1774
    return ((sf_count_t )0);
  } else
#line 1772
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1773
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(float )));
    }
#line 1774
    return ((sf_count_t )0);
  }
#line 1777
  if ((unsigned long )psf->read_float == (unsigned long )((void *)0)) {
#line 1778
    psf->error = 18;
#line 1779
    return ((sf_count_t )0);
  } else
#line 1777
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1778
    psf->error = 18;
#line 1779
    return ((sf_count_t )0);
  }
#line 1782
  if (psf->last_op != 16) {
    {
#line 1783
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1783
    if (__cil_tmp8 < 0L) {
#line 1784
      return ((sf_count_t )0);
    }
  }
  {
#line 1786
  count___0 = (*(psf->read_float))(psf, ptr, len);
  }
#line 1788
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1789
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1791
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1792
    extra = len - count___0;
#line 1793
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(float )));
#line 1794
    psf->read_current = psf->sf.frames;
    }
  }
#line 1797
  psf->last_op = 16;
#line 1799
  return (count___0);
}
}
#line 1803 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_readf_float(SNDFILE *sndfile , float *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1807
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1807
    sf_errno = 10;
#line 1807
    return ((sf_count_t )0);
  }
  {
#line 1807
  psf = (SF_PRIVATE *)sndfile;
#line 1807
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1807
  if (psf->virtual_io == 0) {
#line 1807
    if (__cil_tmp7 == 0) {
#line 1807
      psf->error = 13;
#line 1807
      return ((sf_count_t )0);
    }
  }
#line 1807
  if (psf->Magick != 305447134) {
#line 1807
    psf->error = 10;
#line 1807
    return ((sf_count_t )0);
  }
#line 1807
  psf->error = 0;
#line 1809
  if (psf->file.mode == 32) {
#line 1810
    psf->error = 22;
#line 1811
    return ((sf_count_t )0);
  }
#line 1814
  if (frames <= 0L) {
    {
#line 1815
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(float )));
    }
#line 1816
    return ((sf_count_t )0);
  } else
#line 1814
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1815
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(float )));
    }
#line 1816
    return ((sf_count_t )0);
  }
#line 1819
  if ((unsigned long )psf->read_float == (unsigned long )((void *)0)) {
#line 1820
    psf->error = 18;
#line 1821
    return ((sf_count_t )0);
  } else
#line 1819
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1820
    psf->error = 18;
#line 1821
    return ((sf_count_t )0);
  }
#line 1824
  if (psf->last_op != 16) {
    {
#line 1825
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1825
    if (__cil_tmp8 < 0L) {
#line 1826
      return ((sf_count_t )0);
    }
  }
  {
#line 1828
  count___0 = (*(psf->read_float))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 1830
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1831
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1833
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1834
    extra = frames * (long )psf->sf.channels - count___0;
#line 1835
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(float )));
#line 1836
    psf->read_current = psf->sf.frames;
    }
  }
#line 1839
  psf->last_op = 16;
#line 1841
  return (count___0 / (long )psf->sf.channels);
}
}
#line 1848 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_read_double(SNDFILE *sndfile , double *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1852
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1852
    sf_errno = 10;
#line 1852
    return ((sf_count_t )0);
  }
  {
#line 1852
  psf = (SF_PRIVATE *)sndfile;
#line 1852
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1852
  if (psf->virtual_io == 0) {
#line 1852
    if (__cil_tmp7 == 0) {
#line 1852
      psf->error = 13;
#line 1852
      return ((sf_count_t )0);
    }
  }
#line 1852
  if (psf->Magick != 305447134) {
#line 1852
    psf->error = 10;
#line 1852
    return ((sf_count_t )0);
  }
#line 1852
  psf->error = 0;
#line 1854
  if (psf->file.mode == 32) {
#line 1855
    psf->error = 22;
#line 1856
    return ((sf_count_t )0);
  }
#line 1859
  if (len % (long )psf->sf.channels) {
#line 1860
    psf->error = 19;
#line 1861
    return ((sf_count_t )0);
  }
#line 1864
  if (len <= 0L) {
    {
#line 1865
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(double )));
    }
#line 1866
    return ((sf_count_t )0);
  } else
#line 1864
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1865
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )len * sizeof(double )));
    }
#line 1866
    return ((sf_count_t )0);
  }
#line 1869
  if ((unsigned long )psf->read_double == (unsigned long )((void *)0)) {
#line 1870
    psf->error = 18;
#line 1871
    return ((sf_count_t )0);
  } else
#line 1869
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1870
    psf->error = 18;
#line 1871
    return ((sf_count_t )0);
  }
#line 1874
  if (psf->last_op != 16) {
    {
#line 1875
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1875
    if (__cil_tmp8 < 0L) {
#line 1876
      return ((sf_count_t )0);
    }
  }
  {
#line 1878
  count___0 = (*(psf->read_double))(psf, ptr, len);
  }
#line 1880
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1881
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1883
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1884
    extra = len - count___0;
#line 1885
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(double )));
#line 1886
    psf->read_current = psf->sf.frames;
    }
  }
#line 1889
  psf->last_op = 16;
#line 1891
  return (count___0);
}
}
#line 1895 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_readf_double(SNDFILE *sndfile , double *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1899
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1899
    sf_errno = 10;
#line 1899
    return ((sf_count_t )0);
  }
  {
#line 1899
  psf = (SF_PRIVATE *)sndfile;
#line 1899
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1899
  if (psf->virtual_io == 0) {
#line 1899
    if (__cil_tmp7 == 0) {
#line 1899
      psf->error = 13;
#line 1899
      return ((sf_count_t )0);
    }
  }
#line 1899
  if (psf->Magick != 305447134) {
#line 1899
    psf->error = 10;
#line 1899
    return ((sf_count_t )0);
  }
#line 1899
  psf->error = 0;
#line 1901
  if (psf->file.mode == 32) {
#line 1902
    psf->error = 22;
#line 1903
    return ((sf_count_t )0);
  }
#line 1906
  if (frames <= 0L) {
    {
#line 1907
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(double )));
    }
#line 1908
    return ((sf_count_t )0);
  } else
#line 1906
  if (psf->read_current >= psf->sf.frames) {
    {
#line 1907
    psf_memset((void *)ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(double )));
    }
#line 1908
    return ((sf_count_t )0);
  }
#line 1911
  if ((unsigned long )psf->read_double == (unsigned long )((void *)0)) {
#line 1912
    psf->error = 18;
#line 1913
    return ((sf_count_t )0);
  } else
#line 1911
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 1912
    psf->error = 18;
#line 1913
    return ((sf_count_t )0);
  }
#line 1916
  if (psf->last_op != 16) {
    {
#line 1917
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1917
    if (__cil_tmp8 < 0L) {
#line 1918
      return ((sf_count_t )0);
    }
  }
  {
#line 1920
  count___0 = (*(psf->read_double))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 1922
  if (psf->read_current + count___0 / (long )psf->sf.channels <= psf->sf.frames) {
#line 1923
    psf->read_current += count___0 / (long )psf->sf.channels;
  } else {
    {
#line 1925
    count___0 = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1926
    extra = frames * (long )psf->sf.channels - count___0;
#line 1927
    psf_memset((void *)(ptr + count___0), 0, (sf_count_t )((unsigned long )extra * sizeof(double )));
#line 1928
    psf->read_current = psf->sf.frames;
    }
  }
#line 1931
  psf->last_op = 16;
#line 1933
  return (count___0 / (long )psf->sf.channels);
}
}
#line 1940 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_write_raw(SNDFILE *sndfile , void const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int bytewidth ;
  int blockwidth ;
  int __cil_tmp8 ;
  int tmp ;
  int tmp___0 ;
  sf_count_t __cil_tmp11 ;

  {
#line 1945
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1945
    sf_errno = 10;
#line 1945
    return ((sf_count_t )0);
  }
  {
#line 1945
  psf = (SF_PRIVATE *)sndfile;
#line 1945
  __cil_tmp8 = psf_file_valid(psf);
  }
#line 1945
  if (psf->virtual_io == 0) {
#line 1945
    if (__cil_tmp8 == 0) {
#line 1945
      psf->error = 13;
#line 1945
      return ((sf_count_t )0);
    }
  }
#line 1945
  if (psf->Magick != 305447134) {
#line 1945
    psf->error = 10;
#line 1945
    return ((sf_count_t )0);
  }
#line 1945
  psf->error = 0;
#line 1947
  if (psf->bytewidth > 0) {
#line 1947
    tmp = psf->bytewidth;
  } else {
#line 1947
    tmp = 1;
  }
#line 1947
  bytewidth = tmp;
#line 1948
  if (psf->blockwidth > 0) {
#line 1948
    tmp___0 = psf->blockwidth;
  } else {
#line 1948
    tmp___0 = 1;
  }
#line 1948
  blockwidth = tmp___0;
#line 1950
  if (psf->file.mode == 16) {
#line 1951
    psf->error = 23;
#line 1952
    return ((sf_count_t )0);
  }
#line 1955
  if (len % (long )(psf->sf.channels * bytewidth)) {
#line 1956
    psf->error = 20;
#line 1957
    return ((sf_count_t )0);
  }
#line 1960
  if (psf->last_op != 32) {
    {
#line 1961
    __cil_tmp11 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 1961
    if (__cil_tmp11 < 0L) {
#line 1962
      return ((sf_count_t )0);
    }
  }
#line 1964
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 1964
    if (psf->have_written == 0) {
      {
#line 1965
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 1966
  psf->have_written = 1;
#line 1968
  count___0 = psf_fwrite(ptr, (sf_count_t )1, len, psf);
#line 1970
  psf->write_current += count___0 / (long )blockwidth;
#line 1972
  psf->last_op = 32;
  }
#line 1974
  if (psf->write_current > psf->sf.frames) {
#line 1975
    psf->sf.frames = psf->write_current;
#line 1976
    psf->dataend = (sf_count_t )0;
  }
#line 1979
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 1979
    if (psf->auto_header) {
      {
#line 1980
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 1982
  return (count___0);
}
}
#line 1989 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_write_short(SNDFILE *sndfile , short const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 1993
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 1993
    sf_errno = 10;
#line 1993
    return ((sf_count_t )0);
  }
  {
#line 1993
  psf = (SF_PRIVATE *)sndfile;
#line 1993
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 1993
  if (psf->virtual_io == 0) {
#line 1993
    if (__cil_tmp6 == 0) {
#line 1993
      psf->error = 13;
#line 1993
      return ((sf_count_t )0);
    }
  }
#line 1993
  if (psf->Magick != 305447134) {
#line 1993
    psf->error = 10;
#line 1993
    return ((sf_count_t )0);
  }
#line 1993
  psf->error = 0;
#line 1995
  if (psf->file.mode == 16) {
#line 1996
    psf->error = 23;
#line 1997
    return ((sf_count_t )0);
  }
#line 2000
  if (len % (long )psf->sf.channels) {
#line 2001
    psf->error = 20;
#line 2002
    return ((sf_count_t )0);
  }
#line 2005
  if ((unsigned long )psf->write_short == (unsigned long )((void *)0)) {
#line 2006
    psf->error = 18;
#line 2007
    return ((sf_count_t )0);
  } else
#line 2005
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2006
    psf->error = 18;
#line 2007
    return ((sf_count_t )0);
  }
#line 2010
  if (psf->last_op != 32) {
    {
#line 2011
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2011
    if (__cil_tmp7 < 0L) {
#line 2012
      return ((sf_count_t )0);
    }
  }
#line 2014
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2014
    if (psf->have_written == 0) {
      {
#line 2015
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2016
  psf->have_written = 1;
#line 2018
  count___0 = (*(psf->write_short))(psf, ptr, len);
#line 2020
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2022
  psf->last_op = 32;
  }
#line 2024
  if (psf->write_current > psf->sf.frames) {
#line 2025
    psf->sf.frames = psf->write_current;
#line 2026
    psf->dataend = (sf_count_t )0;
  }
#line 2029
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2029
    if (psf->auto_header) {
      {
#line 2030
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2032
  return (count___0);
}
}
#line 2036 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_writef_short(SNDFILE *sndfile , short const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2040
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2040
    sf_errno = 10;
#line 2040
    return ((sf_count_t )0);
  }
  {
#line 2040
  psf = (SF_PRIVATE *)sndfile;
#line 2040
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2040
  if (psf->virtual_io == 0) {
#line 2040
    if (__cil_tmp6 == 0) {
#line 2040
      psf->error = 13;
#line 2040
      return ((sf_count_t )0);
    }
  }
#line 2040
  if (psf->Magick != 305447134) {
#line 2040
    psf->error = 10;
#line 2040
    return ((sf_count_t )0);
  }
#line 2040
  psf->error = 0;
#line 2042
  if (psf->file.mode == 16) {
#line 2043
    psf->error = 23;
#line 2044
    return ((sf_count_t )0);
  }
#line 2047
  if ((unsigned long )psf->write_short == (unsigned long )((void *)0)) {
#line 2048
    psf->error = 18;
#line 2049
    return ((sf_count_t )0);
  } else
#line 2047
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2048
    psf->error = 18;
#line 2049
    return ((sf_count_t )0);
  }
#line 2052
  if (psf->last_op != 32) {
    {
#line 2053
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2053
    if (__cil_tmp7 < 0L) {
#line 2054
      return ((sf_count_t )0);
    }
  }
#line 2056
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2056
    if (psf->have_written == 0) {
      {
#line 2057
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2058
  psf->have_written = 1;
#line 2060
  count___0 = (*(psf->write_short))(psf, ptr, frames * (long )psf->sf.channels);
#line 2062
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2064
  psf->last_op = 32;
  }
#line 2066
  if (psf->write_current > psf->sf.frames) {
#line 2067
    psf->sf.frames = psf->write_current;
#line 2068
    psf->dataend = (sf_count_t )0;
  }
#line 2071
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2071
    if (psf->auto_header) {
      {
#line 2072
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2074
  return (count___0 / (long )psf->sf.channels);
}
}
#line 2081 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_write_int(SNDFILE *sndfile , int const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2085
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2085
    sf_errno = 10;
#line 2085
    return ((sf_count_t )0);
  }
  {
#line 2085
  psf = (SF_PRIVATE *)sndfile;
#line 2085
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2085
  if (psf->virtual_io == 0) {
#line 2085
    if (__cil_tmp6 == 0) {
#line 2085
      psf->error = 13;
#line 2085
      return ((sf_count_t )0);
    }
  }
#line 2085
  if (psf->Magick != 305447134) {
#line 2085
    psf->error = 10;
#line 2085
    return ((sf_count_t )0);
  }
#line 2085
  psf->error = 0;
#line 2087
  if (psf->file.mode == 16) {
#line 2088
    psf->error = 23;
#line 2089
    return ((sf_count_t )0);
  }
#line 2092
  if (len % (long )psf->sf.channels) {
#line 2093
    psf->error = 20;
#line 2094
    return ((sf_count_t )0);
  }
#line 2097
  if ((unsigned long )psf->write_int == (unsigned long )((void *)0)) {
#line 2098
    psf->error = 18;
#line 2099
    return ((sf_count_t )0);
  } else
#line 2097
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2098
    psf->error = 18;
#line 2099
    return ((sf_count_t )0);
  }
#line 2102
  if (psf->last_op != 32) {
    {
#line 2103
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2103
    if (__cil_tmp7 < 0L) {
#line 2104
      return ((sf_count_t )0);
    }
  }
#line 2106
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2106
    if (psf->have_written == 0) {
      {
#line 2107
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2108
  psf->have_written = 1;
#line 2110
  count___0 = (*(psf->write_int))(psf, ptr, len);
#line 2112
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2114
  psf->last_op = 32;
  }
#line 2116
  if (psf->write_current > psf->sf.frames) {
#line 2117
    psf->sf.frames = psf->write_current;
#line 2118
    psf->dataend = (sf_count_t )0;
  }
#line 2121
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2121
    if (psf->auto_header) {
      {
#line 2122
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2124
  return (count___0);
}
}
#line 2128 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_writef_int(SNDFILE *sndfile , int const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2132
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2132
    sf_errno = 10;
#line 2132
    return ((sf_count_t )0);
  }
  {
#line 2132
  psf = (SF_PRIVATE *)sndfile;
#line 2132
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2132
  if (psf->virtual_io == 0) {
#line 2132
    if (__cil_tmp6 == 0) {
#line 2132
      psf->error = 13;
#line 2132
      return ((sf_count_t )0);
    }
  }
#line 2132
  if (psf->Magick != 305447134) {
#line 2132
    psf->error = 10;
#line 2132
    return ((sf_count_t )0);
  }
#line 2132
  psf->error = 0;
#line 2134
  if (psf->file.mode == 16) {
#line 2135
    psf->error = 23;
#line 2136
    return ((sf_count_t )0);
  }
#line 2139
  if ((unsigned long )psf->write_int == (unsigned long )((void *)0)) {
#line 2140
    psf->error = 18;
#line 2141
    return ((sf_count_t )0);
  } else
#line 2139
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2140
    psf->error = 18;
#line 2141
    return ((sf_count_t )0);
  }
#line 2144
  if (psf->last_op != 32) {
    {
#line 2145
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2145
    if (__cil_tmp7 < 0L) {
#line 2146
      return ((sf_count_t )0);
    }
  }
#line 2148
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2148
    if (psf->have_written == 0) {
      {
#line 2149
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2150
  psf->have_written = 1;
#line 2152
  count___0 = (*(psf->write_int))(psf, ptr, frames * (long )psf->sf.channels);
#line 2154
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2156
  psf->last_op = 32;
  }
#line 2158
  if (psf->write_current > psf->sf.frames) {
#line 2159
    psf->sf.frames = psf->write_current;
#line 2160
    psf->dataend = (sf_count_t )0;
  }
#line 2163
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2163
    if (psf->auto_header) {
      {
#line 2164
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2166
  return (count___0 / (long )psf->sf.channels);
}
}
#line 2173 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_write_float(SNDFILE *sndfile , float const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2177
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2177
    sf_errno = 10;
#line 2177
    return ((sf_count_t )0);
  }
  {
#line 2177
  psf = (SF_PRIVATE *)sndfile;
#line 2177
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2177
  if (psf->virtual_io == 0) {
#line 2177
    if (__cil_tmp6 == 0) {
#line 2177
      psf->error = 13;
#line 2177
      return ((sf_count_t )0);
    }
  }
#line 2177
  if (psf->Magick != 305447134) {
#line 2177
    psf->error = 10;
#line 2177
    return ((sf_count_t )0);
  }
#line 2177
  psf->error = 0;
#line 2179
  if (psf->file.mode == 16) {
#line 2180
    psf->error = 23;
#line 2181
    return ((sf_count_t )0);
  }
#line 2184
  if (len % (long )psf->sf.channels) {
#line 2185
    psf->error = 20;
#line 2186
    return ((sf_count_t )0);
  }
#line 2189
  if ((unsigned long )psf->write_float == (unsigned long )((void *)0)) {
#line 2190
    psf->error = 18;
#line 2191
    return ((sf_count_t )0);
  } else
#line 2189
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2190
    psf->error = 18;
#line 2191
    return ((sf_count_t )0);
  }
#line 2194
  if (psf->last_op != 32) {
    {
#line 2195
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2195
    if (__cil_tmp7 < 0L) {
#line 2196
      return ((sf_count_t )0);
    }
  }
#line 2198
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2198
    if (psf->have_written == 0) {
      {
#line 2199
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2200
  psf->have_written = 1;
#line 2202
  count___0 = (*(psf->write_float))(psf, ptr, len);
#line 2204
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2206
  psf->last_op = 32;
  }
#line 2208
  if (psf->write_current > psf->sf.frames) {
#line 2209
    psf->sf.frames = psf->write_current;
#line 2210
    psf->dataend = (sf_count_t )0;
  }
#line 2213
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2213
    if (psf->auto_header) {
      {
#line 2214
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2216
  return (count___0);
}
}
#line 2220 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_writef_float(SNDFILE *sndfile , float const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2224
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2224
    sf_errno = 10;
#line 2224
    return ((sf_count_t )0);
  }
  {
#line 2224
  psf = (SF_PRIVATE *)sndfile;
#line 2224
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2224
  if (psf->virtual_io == 0) {
#line 2224
    if (__cil_tmp6 == 0) {
#line 2224
      psf->error = 13;
#line 2224
      return ((sf_count_t )0);
    }
  }
#line 2224
  if (psf->Magick != 305447134) {
#line 2224
    psf->error = 10;
#line 2224
    return ((sf_count_t )0);
  }
#line 2224
  psf->error = 0;
#line 2226
  if (psf->file.mode == 16) {
#line 2227
    psf->error = 23;
#line 2228
    return ((sf_count_t )0);
  }
#line 2231
  if ((unsigned long )psf->write_float == (unsigned long )((void *)0)) {
#line 2232
    psf->error = 18;
#line 2233
    return ((sf_count_t )0);
  } else
#line 2231
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2232
    psf->error = 18;
#line 2233
    return ((sf_count_t )0);
  }
#line 2236
  if (psf->last_op != 32) {
    {
#line 2237
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2237
    if (__cil_tmp7 < 0L) {
#line 2238
      return ((sf_count_t )0);
    }
  }
#line 2240
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2240
    if (psf->have_written == 0) {
      {
#line 2241
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2242
  psf->have_written = 1;
#line 2244
  count___0 = (*(psf->write_float))(psf, ptr, frames * (long )psf->sf.channels);
#line 2246
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2248
  psf->last_op = 32;
  }
#line 2250
  if (psf->write_current > psf->sf.frames) {
#line 2251
    psf->sf.frames = psf->write_current;
#line 2252
    psf->dataend = (sf_count_t )0;
  }
#line 2255
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2255
    if (psf->auto_header) {
      {
#line 2256
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2258
  return (count___0 / (long )psf->sf.channels);
}
}
#line 2265 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_write_double(SNDFILE *sndfile , double const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2269
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2269
    sf_errno = 10;
#line 2269
    return ((sf_count_t )0);
  }
  {
#line 2269
  psf = (SF_PRIVATE *)sndfile;
#line 2269
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2269
  if (psf->virtual_io == 0) {
#line 2269
    if (__cil_tmp6 == 0) {
#line 2269
      psf->error = 13;
#line 2269
      return ((sf_count_t )0);
    }
  }
#line 2269
  if (psf->Magick != 305447134) {
#line 2269
    psf->error = 10;
#line 2269
    return ((sf_count_t )0);
  }
#line 2269
  psf->error = 0;
#line 2271
  if (psf->file.mode == 16) {
#line 2272
    psf->error = 23;
#line 2273
    return ((sf_count_t )0);
  }
#line 2276
  if (len % (long )psf->sf.channels) {
#line 2277
    psf->error = 20;
#line 2278
    return ((sf_count_t )0);
  }
#line 2281
  if ((unsigned long )psf->write_double == (unsigned long )((void *)0)) {
#line 2282
    psf->error = 18;
#line 2283
    return ((sf_count_t )0);
  } else
#line 2281
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2282
    psf->error = 18;
#line 2283
    return ((sf_count_t )0);
  }
#line 2286
  if (psf->last_op != 32) {
    {
#line 2287
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2287
    if (__cil_tmp7 < 0L) {
#line 2288
      return ((sf_count_t )0);
    }
  }
#line 2290
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2290
    if (psf->have_written == 0) {
      {
#line 2291
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2292
  psf->have_written = 1;
#line 2294
  count___0 = (*(psf->write_double))(psf, ptr, len);
#line 2296
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2298
  psf->last_op = 32;
  }
#line 2300
  if (psf->write_current > psf->sf.frames) {
#line 2301
    psf->sf.frames = psf->write_current;
#line 2302
    psf->dataend = (sf_count_t )0;
  }
#line 2305
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2305
    if (psf->auto_header) {
      {
#line 2306
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2308
  return (count___0);
}
}
#line 2312 "/root/patchweave_donee/23/src/sndfile.c"
sf_count_t sf_writef_double(SNDFILE *sndfile , double const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count___0 ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
#line 2316
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 2316
    sf_errno = 10;
#line 2316
    return ((sf_count_t )0);
  }
  {
#line 2316
  psf = (SF_PRIVATE *)sndfile;
#line 2316
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2316
  if (psf->virtual_io == 0) {
#line 2316
    if (__cil_tmp6 == 0) {
#line 2316
      psf->error = 13;
#line 2316
      return ((sf_count_t )0);
    }
  }
#line 2316
  if (psf->Magick != 305447134) {
#line 2316
    psf->error = 10;
#line 2316
    return ((sf_count_t )0);
  }
#line 2316
  psf->error = 0;
#line 2318
  if (psf->file.mode == 16) {
#line 2319
    psf->error = 23;
#line 2320
    return ((sf_count_t )0);
  }
#line 2323
  if ((unsigned long )psf->write_double == (unsigned long )((void *)0)) {
#line 2324
    psf->error = 18;
#line 2325
    return ((sf_count_t )0);
  } else
#line 2323
  if ((unsigned long )psf->seek == (unsigned long )((void *)0)) {
#line 2324
    psf->error = 18;
#line 2325
    return ((sf_count_t )0);
  }
#line 2328
  if (psf->last_op != 32) {
    {
#line 2329
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2329
    if (__cil_tmp7 < 0L) {
#line 2330
      return ((sf_count_t )0);
    }
  }
#line 2332
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2332
    if (psf->have_written == 0) {
      {
#line 2333
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2334
  psf->have_written = 1;
#line 2336
  count___0 = (*(psf->write_double))(psf, ptr, frames * (long )psf->sf.channels);
#line 2338
  psf->write_current += count___0 / (long )psf->sf.channels;
#line 2340
  psf->last_op = 32;
  }
#line 2342
  if (psf->write_current > psf->sf.frames) {
#line 2343
    psf->sf.frames = psf->write_current;
#line 2344
    psf->dataend = (sf_count_t )0;
  }
#line 2347
  if ((unsigned long )psf->write_header != (unsigned long )((void *)0)) {
#line 2347
    if (psf->auto_header) {
      {
#line 2348
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2350
  return (count___0 / (long )psf->sf.channels);
}
}
#line 2358 "/root/patchweave_donee/23/src/sndfile.c"
static int try_resource_fork(SF_PRIVATE *psf ) 
{ 
  int old_error ;
  int __cil_tmp3 ;

  {
  {
#line 2359
  old_error = psf->error;
#line 2362
  psf->rsrc.mode = 16;
#line 2363
  __cil_tmp3 = psf_open_rsrc(psf);
  }
#line 2363
  if (__cil_tmp3 != 0) {
#line 2364
    psf->error = old_error;
#line 2365
    return (0);
  }
  {
#line 2369
  psf_log_printf(psf, "Resource fork : %s\n\333\204U", psf->rsrc.path.c);
  }
#line 2371
  return (1441792);
}
}
#line 2375 "/root/patchweave_donee/23/src/sndfile.c"
static int format_from_extension(SF_PRIVATE *psf ) 
{ 
  char *cptr ;
  char buffer[16] ;
  int format ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 2378
  format = 0;
#line 2380
  cptr = strrchr((char const   *)(psf->file.name.c), '.');
  }
#line 2380
  if ((unsigned long )cptr == (unsigned long )((void *)0)) {
#line 2381
    return (0);
  }
  {
#line 2383
  cptr ++;
#line 2384
  __cil_tmp7 = strlen((char const   *)cptr);
  }
#line 2384
  if (__cil_tmp7 > sizeof(buffer) - 1UL) {
#line 2385
    return (0);
  }
  {
#line 2387
  psf_strlcpy(buffer, sizeof(buffer), (char const   *)cptr);
#line 2388
  buffer[sizeof(buffer) - 1UL] = (char)0;
#line 2391
  cptr = buffer;
  }
  {
#line 2392
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2392
    if (! *cptr) {
#line 2392
      goto while_break;
    }
#line 2393
    *cptr = (char)0;
#line 2394
    cptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2397
  cptr = buffer;
#line 2399
  __cil_tmp9 = strcmp((char const   *)cptr, "au\276\333\204U");
  }
#line 2399
  if (__cil_tmp9 == 0) {
#line 2400
    psf->sf.channels = 1;
#line 2401
    psf->sf.samplerate = 8000;
#line 2402
    format = 262160;
  } else {
    {
#line 2404
    __cil_tmp10 = strcmp((char const   *)cptr, "snd");
    }
#line 2404
    if (__cil_tmp10 == 0) {
#line 2405
      psf->sf.channels = 1;
#line 2406
      psf->sf.samplerate = 8000;
#line 2407
      format = 262160;
    } else {
      {
#line 2410
      __cil_tmp12 = strcmp((char const   *)cptr, "vox8\204U");
#line 2410
      __cil_tmp11 = strcmp((char const   *)cptr, "vox");
      }
#line 2410
      if (__cil_tmp11 == 0) {
#line 2411
        psf->sf.channels = 1;
#line 2412
        psf->sf.samplerate = 8000;
#line 2413
        format = 262177;
      } else
#line 2410
      if (__cil_tmp12 == 0) {
#line 2411
        psf->sf.channels = 1;
#line 2412
        psf->sf.samplerate = 8000;
#line 2413
        format = 262177;
      } else {
        {
#line 2415
        __cil_tmp13 = strcmp((char const   *)cptr, "vox6");
        }
#line 2415
        if (__cil_tmp13 == 0) {
#line 2416
          psf->sf.channels = 1;
#line 2417
          psf->sf.samplerate = 6000;
#line 2418
          format = 262177;
        } else {
          {
#line 2420
          __cil_tmp14 = strcmp((char const   *)cptr, "gsm\333\204U");
          }
#line 2420
          if (__cil_tmp14 == 0) {
#line 2421
            psf->sf.channels = 1;
#line 2422
            psf->sf.samplerate = 8000;
#line 2423
            format = 262176;
          }
        }
      }
    }
  }
#line 2427
  if ((format & 268369920) == 262144) {
#line 2428
    psf->dataoffset = (sf_count_t )0;
  }
#line 2430
  return (format);
}
}
#line 2434 "/root/patchweave_donee/23/src/sndfile.c"
static int guess_file_type(SF_PRIVATE *psf ) 
{ 
  uint32_t buffer[3] ;
  uint32_t format ;
  int __cil_tmp4 ;
  int32_t __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 2437
  __cil_tmp4 = psf_binheader_readf(psf, "b", & buffer, (int )sizeof(buffer));
  }
#line 2437
  if (__cil_tmp4 != (int )sizeof(buffer)) {
#line 2438
    psf->error = 8;
#line 2439
    return (0);
  }
#line 2442
  if (buffer[0] == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
    _L: 
#line 2442
    if (buffer[2] == ((unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24))) {
#line 2444
      return (65536);
    }
  } else
#line 2442
  if (buffer[0] == ((unsigned int )((82 | (73 << 8)) | (70 << 16)) | (88U << 24))) {
#line 2442
    goto _L;
  }
#line 2446
  if (buffer[0] == ((unsigned int )((70 | (79 << 8)) | (82 << 16)) | (77U << 24))) {
#line 2447
    if (buffer[2] == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (70U << 24))) {
#line 2448
      return (131072);
    } else
#line 2447
    if (buffer[2] == ((unsigned int )((65 | (73 << 8)) | (70 << 16)) | (67U << 24))) {
#line 2448
      return (131072);
    }
#line 2449
    if (buffer[2] == ((unsigned int )((56 | (83 << 8)) | (86 << 16)) | (88U << 24))) {
#line 2450
      return (393216);
    } else
#line 2449
    if (buffer[2] == ((unsigned int )((49 | (54 << 8)) | (83 << 16)) | (86U << 24))) {
#line 2450
      return (393216);
    }
#line 2451
    return (0);
  }
#line 2454
  if (buffer[0] == ((unsigned int )((46 | (115 << 8)) | (110 << 16)) | (100U << 24))) {
#line 2455
    return (196608);
  } else
#line 2454
  if (buffer[0] == ((unsigned int )((100 | (110 << 8)) | (115 << 16)) | (46U << 24))) {
#line 2455
    return (196608);
  }
#line 2457
  if (buffer[0] == ((unsigned int )((102 | (97 << 8)) | (112 << 16)) | (32U << 24))) {
#line 2458
    return (327680);
  } else
#line 2457
  if (buffer[0] == ((unsigned int )((32 | (112 << 8)) | (97 << 16)) | (102U << 24))) {
#line 2458
    return (327680);
  }
#line 2460
  if (buffer[0] == ((unsigned int )((78 | (73 << 8)) | (83 << 16)) | (84U << 24))) {
#line 2461
    return (458752);
  }
#line 2463
  if (buffer[0] == ((unsigned int )((67 | (114 << 8)) | (101 << 16)) | (97U << 24))) {
#line 2463
    if (buffer[1] == ((unsigned int )((116 | (105 << 8)) | (118 << 16)) | (101U << 24))) {
#line 2464
      return (524288);
    }
  }
#line 2466
  if ((buffer[0] & ((unsigned int )((255 | (255 << 8)) | (248 << 16)) | (255U << 24))) == (unsigned int )(100 | (163 << 8))) {
#line 2468
    return (655360);
  } else
#line 2466
  if ((buffer[0] & ((unsigned int )((255 | (248 << 8)) | (255 << 16)) | (255U << 24))) == ((unsigned int )(163 << 16) | (100U << 24))) {
#line 2468
    return (655360);
  }
#line 2470
  if (buffer[0] == ((unsigned int )((114 | (105 << 8)) | (102 << 16)) | (102U << 24))) {
#line 2471
    return (720896);
  }
#line 2473
  if (buffer[0] == ((unsigned int )(3 << 16) | (232U << 24))) {
#line 2473
    if (buffer[1] == 1U << 24) {
#line 2473
      if (buffer[2] == 1U << 24) {
#line 2475
        return (786432);
      }
    }
  }
#line 2477
  if (buffer[0] == 0U) {
#line 2477
    if (buffer[1] == 1U) {
#line 2477
      if (buffer[2] == 1U) {
#line 2479
        return (786432);
      }
    }
  }
#line 2481
  if (buffer[0] == ((unsigned int )((77 | (65 << 8)) | (84 << 16)) | (76U << 24))) {
#line 2481
    if (buffer[1] == ((unsigned int )((65 | (66 << 8)) | (32 << 16)) | (53U << 24))) {
#line 2482
      return (851968);
    }
  }
#line 2484
  if (buffer[0] == ((unsigned int )((80 | (86 << 8)) | (70 << 16)) | (49U << 24))) {
#line 2485
    return (917504);
  }
#line 2487
  if (buffer[0] == ((unsigned int )((69 | (120 << 8)) | (116 << 16)) | (101U << 24))) {
#line 2487
    if (buffer[1] == ((unsigned int )((110 | (100 << 8)) | (101 << 16)) | (100U << 24))) {
#line 2487
      if (buffer[2] == ((unsigned int )((32 | (73 << 8)) | (110 << 16)) | (115U << 24))) {
#line 2489
        return (983040);
      }
    }
  }
#line 2491
  if (buffer[0] == ((unsigned int )((99 | (97 << 8)) | (102 << 16)) | (102U << 24))) {
#line 2491
    if (buffer[2] == ((unsigned int )((100 | (101 << 8)) | (115 << 16)) | (99U << 24))) {
#line 2492
      return (1572864);
    }
  }
#line 2494
  if (buffer[0] == ((unsigned int )((79 | (103 << 8)) | (103 << 16)) | (83U << 24))) {
#line 2495
    return (2097152);
  }
#line 2497
  if (buffer[0] == ((unsigned int )((65 | (76 << 8)) | (97 << 16)) | (119U << 24))) {
#line 2497
    if (buffer[1] == ((unsigned int )((83 | (111 << 8)) | (117 << 16)) | (110U << 24))) {
#line 2497
      if (buffer[2] == ((unsigned int )((100 | (70 << 8)) | (105 << 16)) | (108U << 24))) {
#line 2499
        return (1638400);
      }
    }
  }
#line 2501
  if (buffer[0] == ((unsigned int )((68 | (105 << 8)) | (97 << 16)) | (109U << 24))) {
#line 2501
    if (buffer[1] == ((unsigned int )((111 | (110 << 8)) | (100 << 16)) | (87U << 24))) {
#line 2501
      if (buffer[2] == ((unsigned int )((97 | (114 << 8)) | (101 << 16)) | (32U << 24))) {
#line 2503
        return (67371008);
      }
    }
  }
#line 2505
  if (buffer[0] == ((unsigned int )((76 | (77 << 8)) | (56 << 16)) | (57U << 24))) {
#line 2506
    return (67305472);
  } else
#line 2505
  if (buffer[0] == (unsigned int )(53 | (51 << 8))) {
#line 2506
    return (67305472);
  }
#line 2508
  if ((buffer[0] & ((unsigned int )((255 | (255 << 8)) | (128 << 16)) | (255U << 24))) == ((unsigned int )(240 | (126 << 8)) | (1U << 24))) {
#line 2509
    return (1114112);
  }
#line 2511
  if ((buffer[0] & (unsigned int )(255 | (255 << 8))) == (unsigned int )(1 | (4 << 8))) {
#line 2512
    return (2162688);
  }
#line 2514
  if (buffer[0] == ((unsigned int )((67 | (65 << 8)) | (84 << 16)) | (32U << 24))) {
#line 2514
    if (buffer[2] == ((unsigned int )((82 | (69 << 8)) | (88 << 16)) | (50U << 24))) {
#line 2515
      return (67960832);
    }
  }
#line 2517
  if (buffer[0] == ((unsigned int )((48 | (38 << 8)) | (178 << 16)) | (117U << 24))) {
#line 2517
    if (buffer[1] == ((unsigned int )((142 | (102 << 8)) | (207 << 16)) | (17U << 24))) {
#line 2518
      return (0);
    }
  }
  {
#line 2521
  __cil_tmp5 = ENDSWAP_32((int32_t )buffer[0]);
  }
#line 2521
  if (buffer[2] == (unsigned int )(2 << 8)) {
#line 2521
    if (2L * (int64_t )__cil_tmp5 + 12L == psf->filelength) {
#line 2522
      return (1048576);
    }
  }
#line 2524
  if (buffer[0] == ((unsigned int )((102 | (76 << 8)) | (97 << 16)) | (67U << 24))) {
#line 2525
    return (1507328);
  }
#line 2527
  if (buffer[0] == ((unsigned int )((50 | (66 << 8)) | (73 << 16)) | (84U << 24))) {
#line 2528
    return (1179648);
  }
#line 2530
  if (buffer[0] == ((unsigned int )((82 | (70 << 8)) | (54 << 16)) | (52U << 24))) {
#line 2530
    if (buffer[2] == ((unsigned int )((87 | (65 << 8)) | (86 << 16)) | (69U << 24))) {
#line 2531
      return (2228224);
    }
  }
#line 2533
  if (buffer[0] == ((unsigned int )((73 | (68 << 8)) | (51 << 16)) | (3U << 24))) {
    {
#line 2534
    psf_log_printf(psf, "Found \'ID3\' marker.\n");
#line 2535
    __cil_tmp6 = id3_skip(psf);
    }
#line 2535
    if (__cil_tmp6) {
      {
#line 2536
      __cil_tmp7 = guess_file_type(psf);
      }
#line 2536
      return (__cil_tmp7);
    }
#line 2537
    return (0);
  }
#line 2541
  if (buffer[0] == ((unsigned int )((83 | (79 << 8)) | (85 << 16)) | (78U << 24))) {
#line 2541
    if (buffer[1] == ((unsigned int )((68 | (32 << 8)) | (83 << 16)) | (65U << 24))) {
#line 2542
      return (0);
    }
  }
#line 2545
  if (buffer[0] == ((unsigned int )((83 | (89 << 8)) | (56 << 16)) | (48U << 24))) {
#line 2546
    return (0);
  } else
#line 2545
  if (buffer[0] == ((unsigned int )((83 | (89 << 8)) | (56 << 16)) | (53U << 24))) {
#line 2546
    return (0);
  }
#line 2548
  if (buffer[0] == ((unsigned int )((97 | (106 << 8)) | (107 << 16)) | (103U << 24))) {
#line 2549
    return (0);
  }
  {
#line 2552
  __cil_tmp8 = try_resource_fork(psf);
#line 2552
  format = (uint32_t )__cil_tmp8;
  }
#line 2552
  if (psf->filelength > 0L) {
#line 2552
    if (format != 0U) {
#line 2553
      return ((int )format);
    }
  }
#line 2555
  return (0);
}
}
#line 2560 "/root/patchweave_donee/23/src/sndfile.c"
static int validate_sfinfo(SF_INFO *sfinfo ) 
{ 


  {
#line 2561
  if (sfinfo->samplerate < 1) {
#line 2562
    return (0);
  }
#line 2563
  if (sfinfo->frames < 0L) {
#line 2564
    return (0);
  }
#line 2565
  if (sfinfo->channels < 1) {
#line 2566
    return (0);
  }
#line 2567
  if ((sfinfo->format & 268369920) == 0) {
#line 2568
    return (0);
  }
#line 2569
  if ((sfinfo->format & 65535) == 0) {
#line 2570
    return (0);
  }
#line 2571
  if (sfinfo->sections < 1) {
#line 2572
    return (0);
  }
#line 2573
  return (1);
}
}
#line 2577 "/root/patchweave_donee/23/src/sndfile.c"
static int validate_psf(SF_PRIVATE *psf ) 
{ 


  {
#line 2579
  if (psf->datalength < 0L) {
    {
#line 2580
    psf_log_printf(psf, "Invalid SF_PRIVATE field : datalength == %D.\nU", psf->datalength);
    }
#line 2581
    return (0);
  }
#line 2583
  if (psf->dataoffset < 0L) {
    {
#line 2584
    psf_log_printf(psf, "Invalid SF_PRIVATE field : dataoffset == %D.\nU", psf->dataoffset);
    }
#line 2585
    return (0);
  }
#line 2587
  if (psf->blockwidth) {
#line 2587
    if (psf->blockwidth != psf->sf.channels * psf->bytewidth) {
      {
#line 2588
      psf_log_printf(psf, "Invalid SF_PRIVATE field : channels * bytewidth == %d.\n",
                     psf->sf.channels * psf->bytewidth);
      }
#line 2590
      return (0);
    }
  }
#line 2592
  return (1);
}
}
#line 2596 "/root/patchweave_donee/23/src/sndfile.c"
static void save_header_info(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 2597
  snprintf(sf_parselog, sizeof(sf_parselog), "%s", psf->parselog.buf);
  }
#line 2599
  return;
}
}
#line 2601 "/root/patchweave_donee/23/src/sndfile.c"
static int copy_filename(SF_PRIVATE *psf , char const   *path ) 
{ 
  char const   *ccptr ;
  char *cptr ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2605
  __cil_tmp6 = strlen(path);
#line 2605
  __cil_tmp5 = strlen(path);
  }
#line 2605
  if (__cil_tmp5 > 1UL) {
#line 2605
    if (__cil_tmp6 - 1UL >= sizeof(psf->file.path.c)) {
#line 2606
      psf->error = 169;
#line 2607
      return (psf->error);
    }
  }
  {
#line 2610
  snprintf(psf->file.path.c, sizeof(psf->file.path.c), "%s\320\333\204U", path);
#line 2611
  __cil_tmp8 = strrchr(path, '\\');
#line 2611
  ccptr = (char const   *)__cil_tmp8;
#line 2611
  __cil_tmp7 = strrchr(path, '/');
#line 2611
  ccptr = (char const   *)__cil_tmp7;
  }
#line 2611
  if (ccptr) {
#line 2612
    ccptr ++;
  } else
#line 2611
  if (ccptr) {
#line 2612
    ccptr ++;
  } else {
#line 2614
    ccptr = path;
  }
  {
#line 2616
  snprintf(psf->file.name.c, sizeof(psf->file.name.c), "%s", ccptr);
#line 2619
  snprintf(psf->file.dir.c, sizeof(psf->file.dir.c), "%s", path);
#line 2620
  cptr = strrchr((char const   *)(psf->file.dir.c), '\\');
#line 2620
  cptr = strrchr((char const   *)(psf->file.dir.c), '/');
  }
#line 2620
  if (cptr) {
#line 2621
    *(cptr + 1) = (char)0;
  } else
#line 2620
  if (cptr) {
#line 2621
    *(cptr + 1) = (char)0;
  } else {
#line 2623
    psf->file.dir.c[0] = (char)0;
  }
#line 2625
  return (0);
}
}
#line 2632 "/root/patchweave_donee/23/src/sndfile.c"
static int psf_close(SF_PRIVATE *psf ) 
{ 
  uint32_t k ;
  int error ;

  {
#line 2634
  error = 0;
#line 2636
  if (psf->codec_close) {
    {
#line 2637
    error = (*(psf->codec_close))(psf);
#line 2639
    psf->codec_close = (int (*)(struct sf_private_tag * ))((void *)0);
    }
  }
#line 2642
  if (psf->container_close) {
    {
#line 2643
    error = (*(psf->container_close))(psf);
    }
  }
  {
#line 2645
  error = psf_fclose(psf);
#line 2646
  psf_close_rsrc(psf);
#line 2649
  free(psf->container_data);
#line 2650
  free(psf->codec_data);
#line 2651
  free(psf->interleave);
#line 2652
  free(psf->dither);
#line 2653
  free((void *)psf->peak_info);
#line 2654
  free((void *)psf->broadcast_16k);
#line 2655
  free((void *)psf->loop_info);
#line 2656
  free((void *)psf->instrument);
#line 2657
  free((void *)psf->channel_map);
#line 2658
  free((void *)psf->format_desc);
#line 2659
  free((void *)psf->strings.storage);
  }
#line 2661
  if (psf->wchunks.chunks) {
#line 2662
    k = (uint32_t )0;
    {
#line 2662
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2662
      if (! (k < psf->wchunks.used)) {
#line 2662
        goto while_break;
      }
      {
#line 2663
      free((psf->wchunks.chunks + k)->data);
#line 2662
      k ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 2664
  free((void *)psf->rchunks.chunks);
#line 2665
  free((void *)psf->wchunks.chunks);
#line 2666
  free((void *)psf->iterator);
#line 2667
  free((void *)psf->cart_16k);
#line 2669
  memset((void *)psf, 0, sizeof(SF_PRIVATE ));
#line 2670
  free((void *)psf);
  }
#line 2672
  return (error);
}
}
#line 2676 "/root/patchweave_donee/23/src/sndfile.c"
SNDFILE *psf_open_file(SF_PRIVATE *psf , SF_INFO *sfinfo ) 
{ 
  int error ;
  int format ;
  int __cil_tmp5 ;
  int32_t __cil_tmp6 ;
  int __cil_tmp10 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int tmp ;
  char const   *__cil_tmp44 ;

  {
#line 2679
  error = 0;
#line 2679
  sf_errno = error;
#line 2680
  sf_parselog[0] = (char)0;
#line 2682
  if (psf->error) {
#line 2683
    error = psf->error;
#line 2684
    goto error_exit;
  }
#line 2687
  if (psf->file.mode != 16) {
#line 2687
    if (psf->file.mode != 32) {
#line 2687
      if (psf->file.mode != 48) {
#line 2688
        error = 44;
#line 2689
        goto error_exit;
      }
    }
  }
#line 2692
  if ((unsigned long )sfinfo == (unsigned long )((void *)0)) {
#line 2693
    error = 11;
#line 2694
    goto error_exit;
  }
#line 2697
  if (psf->file.mode == 16) {
#line 2698
    if ((sfinfo->format & 268369920) == 262144) {
      {
#line 2699
      __cil_tmp5 = sf_format_check(sfinfo);
      }
#line 2699
      if (__cil_tmp5 == 0) {
#line 2700
        error = 96;
#line 2701
        goto error_exit;
      }
    } else {
      {
#line 2705
      memset((void *)sfinfo, 0, sizeof(SF_INFO ));
      }
    }
  }
  {
#line 2708
  memcpy((void *)(& psf->sf), (void const   *)sfinfo, sizeof(SF_INFO ));
#line 2710
  psf->Magick = 305447134;
#line 2711
  psf->norm_float = 1;
#line 2712
  psf->norm_double = 1;
#line 2713
  psf->dataoffset = (sf_count_t )-1;
#line 2714
  psf->datalength = (sf_count_t )-1;
#line 2715
  psf->read_current = (sf_count_t )-1;
#line 2716
  psf->write_current = (sf_count_t )-1;
#line 2717
  psf->auto_header = 0;
#line 2718
  psf->rwf_endian = 268435456;
#line 2719
  psf->seek = & psf_default_seek;
#line 2720
  psf->float_int_mult = 0;
#line 2721
  psf->float_max = (float )(- 1.);
#line 2724
  __cil_tmp6 = psf_rand_int32();
#line 2724
  psf->unique_id = (unsigned int )__cil_tmp6;
#line 2726
  psf->sf.sections = 1;
#line 2728
  psf->is_pipe = psf_is_pipe(psf);
  }
#line 2730
  if (psf->is_pipe) {
#line 2731
    psf->sf.seekable = 0;
#line 2732
    psf->filelength = (sf_count_t )-1LL;
  } else {
    {
#line 2735
    psf->sf.seekable = 1;
#line 2738
    psf->filelength = psf_get_filelen(psf);
    }
  }
#line 2741
  if (psf->fileoffset > 0L) {
#line 2743
    if (psf->file.mode == 16) {
#line 2743
      goto case_16;
    }
#line 2751
    if (psf->file.mode == 32) {
#line 2751
      goto case_32;
    }
#line 2757
    if (psf->file.mode == 48) {
#line 2757
      goto case_48;
    }
#line 2742
    goto switch_break;
    case_16: 
#line 2744
    if (psf->filelength < 44L) {
      {
#line 2745
      psf_log_printf(psf, "Short filelength: %D (fileoffset: %D)\n", psf->filelength,
                     psf->fileoffset);
#line 2746
      error = 26;
      }
#line 2747
      goto error_exit;
    }
#line 2749
    goto switch_break;
    case_32: 
    {
#line 2752
    psf->fileoffset = (sf_count_t )0;
#line 2753
    psf_fseek(psf, (sf_count_t )0, 2);
#line 2754
    psf->fileoffset = psf_ftell(psf);
    }
#line 2755
    goto switch_break;
    case_48: 
#line 2758
    error = 28;
#line 2759
    goto error_exit;
    switch_break: 
    {
#line 2762
    psf_log_printf(psf, "Embedded file offset : %D\n\320\333\204U", psf->fileoffset);
    }
  }
#line 2765
  if ((long long )psf->filelength == -1LL) {
    {
#line 2766
    psf_log_printf(psf, "Length : unknown\n");
    }
  } else {
    {
#line 2768
    psf_log_printf(psf, "Length : %D\n\204U", psf->filelength);
    }
  }
#line 2770
  if (psf->file.mode == 32) {
    _L: 
#line 2774
    if ((psf->sf.format & 268369920) == 0) {
#line 2775
      error = 5;
#line 2776
      goto error_exit;
    }
#line 2778
    if ((psf->sf.format & 65535) == 0) {
#line 2779
      error = 6;
#line 2780
      goto error_exit;
    }
    {
#line 2783
    __cil_tmp10 = sf_format_check(& psf->sf);
    }
#line 2783
    if (__cil_tmp10 == 0) {
#line 2784
      error = 1;
#line 2785
      goto error_exit;
    }
  } else
#line 2770
  if (psf->file.mode == 48) {
#line 2770
    if (psf->filelength == 0L) {
#line 2770
      goto _L;
    } else {
#line 2770
      goto _L___52;
    }
  } else
  _L___52: 
#line 2788
  if ((psf->sf.format & 268369920) != 262144) {
    {
#line 2790
    psf->sf.format = guess_file_type(psf);
    }
#line 2792
    if (psf->sf.format == 0) {
      {
#line 2793
      psf->sf.format = format_from_extension(psf);
      }
    }
  }
#line 2797
  psf->last_op = psf->file.mode;
#line 2805
  if ((psf->sf.format & 65535) == 80) {
#line 2805
    goto case_80;
  }
#line 2805
  if ((psf->sf.format & 65535) == 17) {
#line 2805
    goto case_80;
  }
#line 2805
  if ((psf->sf.format & 65535) == 16) {
#line 2805
    goto case_80;
  }
#line 2805
  if ((psf->sf.format & 65535) == 5) {
#line 2805
    goto case_80;
  }
#line 2805
  if ((psf->sf.format & 65535) == 1) {
#line 2805
    goto case_80;
  }
#line 2810
  if ((psf->sf.format & 65535) == 81) {
#line 2810
    goto case_81;
  }
#line 2810
  if ((psf->sf.format & 65535) == 2) {
#line 2810
    goto case_81;
  }
#line 2814
  if ((psf->sf.format & 65535) == 3) {
#line 2814
    goto case_3;
  }
#line 2819
  if ((psf->sf.format & 65535) == 6) {
#line 2819
    goto case_6;
  }
#line 2819
  if ((psf->sf.format & 65535) == 4) {
#line 2819
    goto case_6;
  }
#line 2823
  if ((psf->sf.format & 65535) == 7) {
#line 2823
    goto case_7;
  }
#line 2800
  goto switch_break___0;
  case_80: 
#line 2806
  psf->bytewidth = 1;
#line 2807
  goto switch_break___0;
  case_81: 
#line 2811
  psf->bytewidth = 2;
#line 2812
  goto switch_break___0;
  case_3: 
#line 2815
  psf->bytewidth = 3;
#line 2816
  goto switch_break___0;
  case_6: 
#line 2820
  psf->bytewidth = 4;
#line 2821
  goto switch_break___0;
  case_7: 
#line 2824
  psf->bytewidth = 8;
#line 2825
  goto switch_break___0;
  switch_break___0: ;
#line 2831
  if ((psf->sf.format & 268369920) == 1245184) {
#line 2831
    goto case_1245184;
  }
#line 2831
  if ((psf->sf.format & 268369920) == 65536) {
#line 2831
    goto case_1245184;
  }
#line 2835
  if ((psf->sf.format & 268369920) == 131072) {
#line 2835
    goto case_131072;
  }
#line 2839
  if ((psf->sf.format & 268369920) == 196608) {
#line 2839
    goto case_196608;
  }
#line 2843
  if ((psf->sf.format & 268369920) == 262144) {
#line 2843
    goto case_262144;
  }
#line 2847
  if ((psf->sf.format & 268369920) == 720896) {
#line 2847
    goto case_720896;
  }
#line 2851
  if ((psf->sf.format & 268369920) == 2228224) {
#line 2851
    goto case_2228224;
  }
#line 2856
  if ((psf->sf.format & 268369920) == 327680) {
#line 2856
    goto case_327680;
  }
#line 2860
  if ((psf->sf.format & 268369920) == 393216) {
#line 2860
    goto case_393216;
  }
#line 2864
  if ((psf->sf.format & 268369920) == 458752) {
#line 2864
    goto case_458752;
  }
#line 2868
  if ((psf->sf.format & 268369920) == 655360) {
#line 2868
    goto case_655360;
  }
#line 2872
  if ((psf->sf.format & 268369920) == 524288) {
#line 2872
    goto case_524288;
  }
#line 2876
  if ((psf->sf.format & 268369920) == 1114112) {
#line 2876
    goto case_1114112;
  }
#line 2880
  if ((psf->sf.format & 268369920) == 2097152) {
#line 2880
    goto case_2097152;
  }
#line 2884
  if ((psf->sf.format & 268369920) == 67305472) {
#line 2884
    goto case_67305472;
  }
#line 2888
  if ((psf->sf.format & 268369920) == 1638400) {
#line 2888
    goto case_1638400;
  }
#line 2892
  if ((psf->sf.format & 268369920) == 67371008) {
#line 2892
    goto case_67371008;
  }
#line 2896
  if ((psf->sf.format & 268369920) == 786432) {
#line 2896
    goto case_786432;
  }
#line 2900
  if ((psf->sf.format & 268369920) == 851968) {
#line 2900
    goto case_851968;
  }
#line 2904
  if ((psf->sf.format & 268369920) == 917504) {
#line 2904
    goto case_917504;
  }
#line 2908
  if ((psf->sf.format & 268369920) == 983040) {
#line 2908
    goto case_983040;
  }
#line 2912
  if ((psf->sf.format & 268369920) == 1048576) {
#line 2912
    goto case_1048576;
  }
#line 2916
  if ((psf->sf.format & 268369920) == 1441792) {
#line 2916
    goto case_1441792;
  }
#line 2920
  if ((psf->sf.format & 268369920) == 67960832) {
#line 2920
    goto case_67960832;
  }
#line 2924
  if ((psf->sf.format & 268369920) == 1179648) {
#line 2924
    goto case_1179648;
  }
#line 2928
  if ((psf->sf.format & 268369920) == 1507328) {
#line 2928
    goto case_1507328;
  }
#line 2932
  if ((psf->sf.format & 268369920) == 1572864) {
#line 2932
    goto case_1572864;
  }
#line 2936
  if ((psf->sf.format & 268369920) == 2162688) {
#line 2936
    goto case_2162688;
  }
#line 2942
  goto switch_default;
  case_1245184: 
  {
#line 2832
  error = wav_open(psf);
  }
#line 2833
  goto switch_break___1;
  case_131072: 
  {
#line 2836
  error = aiff_open(psf);
  }
#line 2837
  goto switch_break___1;
  case_196608: 
  {
#line 2840
  error = au_open(psf);
  }
#line 2841
  goto switch_break___1;
  case_262144: 
  {
#line 2844
  error = raw_open(psf);
  }
#line 2845
  goto switch_break___1;
  case_720896: 
  {
#line 2848
  error = w64_open(psf);
  }
#line 2849
  goto switch_break___1;
  case_2228224: 
  {
#line 2852
  error = rf64_open(psf);
  }
#line 2853
  goto switch_break___1;
  case_327680: 
  {
#line 2857
  error = paf_open(psf);
  }
#line 2858
  goto switch_break___1;
  case_393216: 
  {
#line 2861
  error = svx_open(psf);
  }
#line 2862
  goto switch_break___1;
  case_458752: 
  {
#line 2865
  error = nist_open(psf);
  }
#line 2866
  goto switch_break___1;
  case_655360: 
  {
#line 2869
  error = ircam_open(psf);
  }
#line 2870
  goto switch_break___1;
  case_524288: 
  {
#line 2873
  error = voc_open(psf);
  }
#line 2874
  goto switch_break___1;
  case_1114112: 
  {
#line 2877
  error = sds_open(psf);
  }
#line 2878
  goto switch_break___1;
  case_2097152: 
  {
#line 2881
  error = ogg_open(psf);
  }
#line 2882
  goto switch_break___1;
  case_67305472: 
  {
#line 2885
  error = txw_open(psf);
  }
#line 2886
  goto switch_break___1;
  case_1638400: 
  {
#line 2889
  error = wve_open(psf);
  }
#line 2890
  goto switch_break___1;
  case_67371008: 
  {
#line 2893
  error = dwd_open(psf);
  }
#line 2894
  goto switch_break___1;
  case_786432: 
  {
#line 2897
  error = mat4_open(psf);
  }
#line 2898
  goto switch_break___1;
  case_851968: 
  {
#line 2901
  error = mat5_open(psf);
  }
#line 2902
  goto switch_break___1;
  case_917504: 
  {
#line 2905
  error = pvf_open(psf);
  }
#line 2906
  goto switch_break___1;
  case_983040: 
  {
#line 2909
  error = xi_open(psf);
  }
#line 2910
  goto switch_break___1;
  case_1048576: 
  {
#line 2913
  error = htk_open(psf);
  }
#line 2914
  goto switch_break___1;
  case_1441792: 
  {
#line 2917
  error = sd2_open(psf);
  }
#line 2918
  goto switch_break___1;
  case_67960832: 
  {
#line 2921
  error = rx2_open(psf);
  }
#line 2922
  goto switch_break___1;
  case_1179648: 
  {
#line 2925
  error = avr_open(psf);
  }
#line 2926
  goto switch_break___1;
  case_1507328: 
  {
#line 2929
  error = flac_open(psf);
  }
#line 2930
  goto switch_break___1;
  case_1572864: 
  {
#line 2933
  error = caf_open(psf);
  }
#line 2934
  goto switch_break___1;
  case_2162688: 
  {
#line 2937
  error = mpc2k_open(psf);
  }
#line 2938
  goto switch_break___1;
  switch_default: 
#line 2943
  error = 21;
  switch_break___1: ;
#line 2946
  if (error) {
#line 2947
    goto error_exit;
  }
#line 2950
  format = psf->sf.format & 268369920;
#line 2951
  if (psf->fileoffset > 0L) {
#line 2956
    if (format == 196608) {
#line 2956
      goto case_196608___0;
    }
#line 2956
    if (format == 131072) {
#line 2956
      goto case_196608___0;
    }
#line 2956
    if (format == 1245184) {
#line 2956
      goto case_196608___0;
    }
#line 2956
    if (format == 65536) {
#line 2956
      goto case_196608___0;
    }
#line 2960
    if (format == 1507328) {
#line 2960
      goto case_1507328___0;
    }
#line 2964
    goto switch_default___0;
    case_196608___0: 
#line 2958
    goto switch_break___2;
    case_1507328___0: 
#line 2962
    goto switch_break___2;
    switch_default___0: 
#line 2965
    error = 27;
#line 2966
    goto error_exit;
    switch_break___2: ;
  }
#line 2970
  if (psf->fileoffset > 0L) {
    {
#line 2971
    psf_log_printf(psf, "Embedded file length : %D\n", psf->filelength);
    }
  }
  {
#line 2973
  __cil_tmp40 = sf_format_check(& psf->sf);
  }
#line 2973
  if (psf->file.mode == 48) {
#line 2973
    if (__cil_tmp40 == 0) {
#line 2974
      error = 24;
#line 2975
      goto error_exit;
    }
  }
  {
#line 2978
  __cil_tmp41 = validate_sfinfo(& psf->sf);
  }
#line 2978
  if (__cil_tmp41 == 0) {
    {
#line 2979
    psf_log_SF_INFO(psf);
#line 2980
    save_header_info(psf);
#line 2981
    error = 25;
    }
#line 2982
    goto error_exit;
  }
  {
#line 2985
  __cil_tmp42 = validate_psf(psf);
  }
#line 2985
  if (__cil_tmp42 == 0) {
    {
#line 2986
    save_header_info(psf);
#line 2987
    error = 30;
    }
#line 2988
    goto error_exit;
  }
#line 2991
  psf->read_current = (sf_count_t )0;
#line 2992
  psf->write_current = (sf_count_t )0;
#line 2993
  if (psf->file.mode == 48) {
#line 2994
    psf->write_current = psf->sf.frames;
#line 2995
    if (psf->sf.frames > 0L) {
#line 2995
      tmp = 1;
    } else {
#line 2995
      tmp = 0;
    }
#line 2995
    psf->have_written = tmp;
  }
  {
#line 2998
  memcpy((void *)sfinfo, (void const   *)(& psf->sf), sizeof(SF_INFO ));
  }
#line 3000
  if (psf->file.mode == 32) {
#line 3002
    sfinfo->frames = (sf_count_t )0;
  }
#line 3005
  sfinfo->sections = 0;
#line 3006
  sfinfo->seekable = 0;
#line 3008
  return ((SNDFILE *)psf);
  error_exit: 
#line 3011
  sf_errno = error;
#line 3013
  if (error == 2) {
    {
#line 3014
    snprintf(sf_syserr, sizeof(sf_syserr), "%s", psf->syserr);
    }
  }
  {
#line 3015
  snprintf(sf_parselog, sizeof(sf_parselog), "%s", psf->parselog.buf);
  }
#line 3020
  if (error == 18) {
#line 3020
    goto case_18;
  }
#line 3020
  if (error == 4) {
#line 3020
    goto case_18;
  }
#line 3020
  if (error == 2) {
#line 3020
    goto case_18;
  }
#line 3023
  if (error == 96) {
#line 3023
    goto case_96;
  }
#line 3026
  goto switch_default___1;
  case_18: 
#line 3021
  goto switch_break___3;
  case_96: 
#line 3024
  goto switch_break___3;
  switch_default___1: 
#line 3027
  if (psf->file.mode == 16) {
    {
#line 3028
    __cil_tmp44 = sf_error_number(error);
#line 3028
    psf_log_printf(psf, "Parse error : %s\n", __cil_tmp44);
#line 3029
    error = 3;
    }
  }
  switch_break___3: 
  {
#line 3033
  psf_close(psf);
  }
#line 3034
  return ((SNDFILE *)((void *)0));
}
}
#line 3042 "/root/patchweave_donee/23/src/sndfile.c"
int sf_set_chunk(SNDFILE *sndfile , SF_CHUNK_INFO *chunk_info ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 3045
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 3045
    sf_errno = 10;
#line 3045
    return (0);
  }
  {
#line 3045
  psf = (SF_PRIVATE *)sndfile;
#line 3045
  __cil_tmp4 = psf_file_valid(psf);
  }
#line 3045
  if (psf->virtual_io == 0) {
#line 3045
    if (__cil_tmp4 == 0) {
#line 3045
      psf->error = 13;
#line 3045
      return (0);
    }
  }
#line 3045
  if (psf->Magick != 305447134) {
#line 3045
    psf->error = 10;
#line 3045
    return (0);
  }
#line 3045
  psf->error = 0;
#line 3047
  if ((unsigned long )chunk_info == (unsigned long )((void *)0)) {
#line 3048
    return (163);
  } else
#line 3047
  if ((unsigned long )chunk_info->data == (unsigned long )((void *)0)) {
#line 3048
    return (163);
  }
#line 3050
  if (psf->set_chunk) {
    {
#line 3051
    __cil_tmp5 = (*(psf->set_chunk))(psf, chunk_info);
    }
#line 3051
    return (__cil_tmp5);
  }
#line 3053
  return (165);
}
}
#line 3057 "/root/patchweave_donee/23/src/sndfile.c"
SF_CHUNK_ITERATOR *sf_get_chunk_iterator(SNDFILE *sndfile , SF_CHUNK_INFO *chunk_info ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp4 ;
  SF_CHUNK_ITERATOR *__cil_tmp5 ;
  SF_CHUNK_ITERATOR *__cil_tmp6 ;

  {
#line 3060
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 3060
    sf_errno = 10;
#line 3060
    return ((SF_CHUNK_ITERATOR *)0);
  }
  {
#line 3060
  psf = (SF_PRIVATE *)sndfile;
#line 3060
  __cil_tmp4 = psf_file_valid(psf);
  }
#line 3060
  if (psf->virtual_io == 0) {
#line 3060
    if (__cil_tmp4 == 0) {
#line 3060
      psf->error = 13;
#line 3060
      return ((SF_CHUNK_ITERATOR *)0);
    }
  }
#line 3060
  if (psf->Magick != 305447134) {
#line 3060
    psf->error = 10;
#line 3060
    return ((SF_CHUNK_ITERATOR *)0);
  }
#line 3060
  psf->error = 0;
#line 3062
  if (chunk_info) {
    {
#line 3063
    __cil_tmp5 = psf_get_chunk_iterator(psf, (char const   *)(chunk_info->id));
    }
#line 3063
    return (__cil_tmp5);
  }
  {
#line 3065
  __cil_tmp6 = psf_get_chunk_iterator(psf, (char const   *)((void *)0));
  }
#line 3065
  return (__cil_tmp6);
}
}
#line 3069 "/root/patchweave_donee/23/src/sndfile.c"
SF_CHUNK_ITERATOR *sf_next_chunk_iterator(SF_CHUNK_ITERATOR *iterator ) 
{ 
  SF_PRIVATE *psf ;
  SNDFILE *sndfile ;
  SNDFILE *tmp ;
  int __cil_tmp5 ;
  SF_CHUNK_ITERATOR *__cil_tmp6 ;

  {
#line 3071
  if (iterator) {
#line 3071
    tmp = iterator->sndfile;
  } else {
#line 3071
    tmp = (SNDFILE *)((void *)0);
  }
#line 3071
  sndfile = tmp;
#line 3073
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 3073
    sf_errno = 10;
#line 3073
    return ((SF_CHUNK_ITERATOR *)0);
  }
  {
#line 3073
  psf = (SF_PRIVATE *)sndfile;
#line 3073
  __cil_tmp5 = psf_file_valid(psf);
  }
#line 3073
  if (psf->virtual_io == 0) {
#line 3073
    if (__cil_tmp5 == 0) {
#line 3073
      psf->error = 13;
#line 3073
      return ((SF_CHUNK_ITERATOR *)0);
    }
  }
#line 3073
  if (psf->Magick != 305447134) {
#line 3073
    psf->error = 10;
#line 3073
    return ((SF_CHUNK_ITERATOR *)0);
  }
#line 3073
  psf->error = 0;
#line 3075
  if (psf->next_chunk_iterator) {
    {
#line 3076
    __cil_tmp6 = (*(psf->next_chunk_iterator))(psf, iterator);
    }
#line 3076
    return (__cil_tmp6);
  }
#line 3078
  return ((SF_CHUNK_ITERATOR *)((void *)0));
}
}
#line 3082 "/root/patchweave_donee/23/src/sndfile.c"
int sf_get_chunk_size(SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  SF_PRIVATE *psf ;
  SNDFILE *sndfile ;
  SNDFILE *tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 3084
  if (iterator) {
#line 3084
    tmp = iterator->sndfile;
  } else {
#line 3084
    tmp = (SNDFILE *)((void *)0);
  }
#line 3084
  sndfile = tmp;
#line 3086
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 3086
    sf_errno = 10;
#line 3086
    return (0);
  }
  {
#line 3086
  psf = (SF_PRIVATE *)sndfile;
#line 3086
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 3086
  if (psf->virtual_io == 0) {
#line 3086
    if (__cil_tmp6 == 0) {
#line 3086
      psf->error = 13;
#line 3086
      return (0);
    }
  }
#line 3086
  if (psf->Magick != 305447134) {
#line 3086
    psf->error = 10;
#line 3086
    return (0);
  }
#line 3086
  psf->error = 0;
#line 3088
  if ((unsigned long )chunk_info == (unsigned long )((void *)0)) {
#line 3089
    return (163);
  }
#line 3091
  if (psf->get_chunk_size) {
    {
#line 3092
    __cil_tmp7 = (*(psf->get_chunk_size))(psf, iterator, chunk_info);
    }
#line 3092
    return (__cil_tmp7);
  }
#line 3094
  return (165);
#line 3095
  return (0);
}
}
#line 3099 "/root/patchweave_donee/23/src/sndfile.c"
int sf_get_chunk_data(SF_CHUNK_ITERATOR *iterator , SF_CHUNK_INFO *chunk_info ) 
{ 
  SF_PRIVATE *psf ;
  SNDFILE *sndfile ;
  SNDFILE *tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 3101
  if (iterator) {
#line 3101
    tmp = iterator->sndfile;
  } else {
#line 3101
    tmp = (SNDFILE *)((void *)0);
  }
#line 3101
  sndfile = tmp;
#line 3103
  if ((unsigned long )sndfile == (unsigned long )((void *)0)) {
#line 3103
    sf_errno = 10;
#line 3103
    return (0);
  }
  {
#line 3103
  psf = (SF_PRIVATE *)sndfile;
#line 3103
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 3103
  if (psf->virtual_io == 0) {
#line 3103
    if (__cil_tmp6 == 0) {
#line 3103
      psf->error = 13;
#line 3103
      return (0);
    }
  }
#line 3103
  if (psf->Magick != 305447134) {
#line 3103
    psf->error = 10;
#line 3103
    return (0);
  }
#line 3103
  psf->error = 0;
#line 3105
  if ((unsigned long )chunk_info == (unsigned long )((void *)0)) {
#line 3106
    return (163);
  } else
#line 3105
  if ((unsigned long )chunk_info->data == (unsigned long )((void *)0)) {
#line 3106
    return (163);
  }
#line 3108
  if (psf->get_chunk_data) {
    {
#line 3109
    __cil_tmp7 = (*(psf->get_chunk_data))(psf, iterator, chunk_info);
    }
#line 3109
    return (__cil_tmp7);
  }
#line 3111
  return (165);
}
}
#line 63 "/root/patchweave_donee/23/programs/common.h"
void sfe_apply_metadata_changes(char const   **filenames , METADATA_INFO *info ) ;
#line 65
void sfe_copy_data_fp(SNDFILE *outfile , SNDFILE *infile , int channels , int normalize ) ;
#line 67
void sfe_copy_data_int(SNDFILE *outfile , SNDFILE *infile , int channels ) ;
#line 69
int sfe_file_type_of_ext(char const   *str___0 , int format ) ;
#line 71
void sfe_dump_format_map(void) ;
#line 73
char const   *program_name(char const   *argv0 ) ;
#line 75
char const   *sfe_endian_name(int format ) ;
#line 76
char const   *sfe_container_name(int format ) ;
#line 77
char const   *sfe_codec_name(int format ) ;
#line 51 "/root/patchweave_donee/23/programs/common.c"
static double data[4096]  ;
#line 52 "/root/patchweave_donee/23/programs/common.c"
static double max  ;
#line 49 "/root/patchweave_donee/23/programs/common.c"
void sfe_copy_data_fp(SNDFILE *outfile , SNDFILE *infile , int channels , int normalize ) 
{ 
  int frames ;
  int readcount ;
  int k ;
  sf_count_t __cil_tmp10 ;
  sf_count_t __cil_tmp11 ;

  {
  {
#line 53
  frames = 4096 / channels;
#line 54
  readcount = frames;
#line 56
  sf_command(infile, 4160, (void *)(& max), (int )sizeof(max));
  }
#line 58
  if (! normalize) {
#line 58
    if (max < 1.) {
      {
#line 59
      while (1) {
        while_continue: /* CIL Label */ ;

#line 59
        if (! (readcount > 0)) {
#line 59
          goto while_break;
        }
        {
#line 60
        __cil_tmp10 = sf_readf_double(infile, data, (sf_count_t )frames);
#line 60
        readcount = (int )__cil_tmp10;
#line 61
        sf_writef_double(outfile, (double const   *)(data), (sf_count_t )readcount);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: ;
    } else {
#line 58
      goto _L;
    }
  } else {
    _L: 
    {
#line 65
    sf_command(infile, 4114, (void *)0, 0);
    }
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 67
      if (! (readcount > 0)) {
#line 67
        goto while_break___0;
      }
      {
#line 68
      __cil_tmp11 = sf_readf_double(infile, data, (sf_count_t )frames);
#line 68
      readcount = (int )__cil_tmp11;
#line 69
      k = 0;
      }
      {
#line 69
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 69
        if (! (k < readcount * channels)) {
#line 69
          goto while_break___1;
        }
#line 70
        data[k] /= max;
#line 69
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 71
      sf_writef_double(outfile, (double const   *)(data), (sf_count_t )readcount);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 75
  return;
}
}
#line 81 "/root/patchweave_donee/23/programs/common.c"
static int data___0[4096]  ;
#line 79 "/root/patchweave_donee/23/programs/common.c"
void sfe_copy_data_int(SNDFILE *outfile , SNDFILE *infile , int channels ) 
{ 
  int frames ;
  int readcount ;
  sf_count_t __cil_tmp7 ;

  {
#line 83
  frames = 4096 / channels;
#line 84
  readcount = frames;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;

#line 86
    if (! (readcount > 0)) {
#line 86
      goto while_break;
    }
    {
#line 87
    __cil_tmp7 = sf_readf_int(infile, data___0, (sf_count_t )frames);
#line 87
    readcount = (int )__cil_tmp7;
#line 88
    sf_writef_int(outfile, (int const   *)(data___0), (sf_count_t )readcount);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 91
  return;
}
}
#line 98 "/root/patchweave_donee/23/programs/common.c"
static int merge_broadcast_info(SNDFILE *infile , SNDFILE *outfile , int format ,
                                METADATA_INFO *info ) 
{ 
  SF_BROADCAST_INFO_2K binfo ;
  int infileminor ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long tmp ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long tmp___0 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long tmp___1 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long tmp___2 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long tmp___3 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long tmp___4 ;
  uint64_t ts ;
  long long __cil_tmp27 ;
  int slen ;
  unsigned long __cil_tmp29 ;
  unsigned short const   **__cil_tmp30 ;
  int __cil_tmp31 ;
  size_t slen___0 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned long tmp___5 ;
  int __cil_tmp36 ;

  {
  {
#line 102
  memset((void *)(& binfo), 0, sizeof(binfo));
  }
#line 104
  if ((268369920 & format) != 65536) {
    {
#line 105
    printf("Error : This is not a WAV file and hence broadcast info cannot be added to it.\n\n\220");
    }
#line 106
    return (1);
  }
#line 109
  infileminor = 65535 & format;
#line 114
  if (infileminor == 4) {
#line 114
    goto case_4;
  }
#line 114
  if (infileminor == 3) {
#line 114
    goto case_4;
  }
#line 114
  if (infileminor == 2) {
#line 114
    goto case_4;
  }
#line 117
  goto switch_default;
  case_4: 
#line 115
  goto switch_break;
  switch_default: 
  {
#line 118
  printf("Warning : The EBU Technical Recommendation R68-2000 states that the only\n          allowed encodings are Linear PCM and MPEG3. This file is not in\n          the right format.\n\n\220");
  }
#line 123
  goto switch_break;
  switch_break: 
  {
#line 126
  __cil_tmp7 = sf_command(infile, 4336, (void *)(& binfo), (int )sizeof(binfo));
  }
#line 126
  if (__cil_tmp7 == 0) {
#line 127
    if ((unsigned long )infile == (unsigned long )outfile) {
      {
#line 128
      printf("Error : Attempting in-place broadcast info update, but file does not\n        have a \'bext\' chunk to modify. The solution is to specify both\n        input and output files on the command line.\n\n\267\350\333\204U");
      }
#line 133
      return (1);
    }
  }
#line 143
  if ((unsigned long )info->description != (unsigned long )((void *)0)) {
    {
#line 143
    memset((void *)(binfo.description), 0, sizeof(binfo.description));
#line 143
    __cil_tmp8 = strlen(info->description);
    }
#line 143
    if (__cil_tmp8 < sizeof(binfo.description)) {
      {
#line 143
      __cil_tmp9 = strlen(info->description);
#line 143
      tmp = __cil_tmp9;
      }
    } else {
#line 143
      tmp = sizeof(binfo.description);
    }
    {
#line 143
    memcpy((void *)(binfo.description), (void const   *)info->description, tmp);
    }
  }
#line 144
  if ((unsigned long )info->originator != (unsigned long )((void *)0)) {
    {
#line 144
    memset((void *)(binfo.originator), 0, sizeof(binfo.originator));
#line 144
    __cil_tmp11 = strlen(info->originator);
    }
#line 144
    if (__cil_tmp11 < sizeof(binfo.originator)) {
      {
#line 144
      __cil_tmp12 = strlen(info->originator);
#line 144
      tmp___0 = __cil_tmp12;
      }
    } else {
#line 144
      tmp___0 = sizeof(binfo.originator);
    }
    {
#line 144
    memcpy((void *)(binfo.originator), (void const   *)info->originator, tmp___0);
    }
  }
#line 145
  if ((unsigned long )info->originator_reference != (unsigned long )((void *)0)) {
    {
#line 145
    memset((void *)(binfo.originator_reference), 0, sizeof(binfo.originator_reference));
#line 145
    __cil_tmp14 = strlen(info->originator_reference);
    }
#line 145
    if (__cil_tmp14 < sizeof(binfo.originator_reference)) {
      {
#line 145
      __cil_tmp15 = strlen(info->originator_reference);
#line 145
      tmp___1 = __cil_tmp15;
      }
    } else {
#line 145
      tmp___1 = sizeof(binfo.originator_reference);
    }
    {
#line 145
    memcpy((void *)(binfo.originator_reference), (void const   *)info->originator_reference,
           tmp___1);
    }
  }
#line 146
  if ((unsigned long )info->origination_date != (unsigned long )((void *)0)) {
    {
#line 146
    memset((void *)(binfo.origination_date), 0, sizeof(binfo.origination_date));
#line 146
    __cil_tmp17 = strlen(info->origination_date);
    }
#line 146
    if (__cil_tmp17 < sizeof(binfo.origination_date)) {
      {
#line 146
      __cil_tmp18 = strlen(info->origination_date);
#line 146
      tmp___2 = __cil_tmp18;
      }
    } else {
#line 146
      tmp___2 = sizeof(binfo.origination_date);
    }
    {
#line 146
    memcpy((void *)(binfo.origination_date), (void const   *)info->origination_date,
           tmp___2);
    }
  }
#line 147
  if ((unsigned long )info->origination_time != (unsigned long )((void *)0)) {
    {
#line 147
    memset((void *)(binfo.origination_time), 0, sizeof(binfo.origination_time));
#line 147
    __cil_tmp20 = strlen(info->origination_time);
    }
#line 147
    if (__cil_tmp20 < sizeof(binfo.origination_time)) {
      {
#line 147
      __cil_tmp21 = strlen(info->origination_time);
#line 147
      tmp___3 = __cil_tmp21;
      }
    } else {
#line 147
      tmp___3 = sizeof(binfo.origination_time);
    }
    {
#line 147
    memcpy((void *)(binfo.origination_time), (void const   *)info->origination_time,
           tmp___3);
    }
  }
#line 148
  if ((unsigned long )info->umid != (unsigned long )((void *)0)) {
    {
#line 148
    memset((void *)(binfo.umid), 0, sizeof(binfo.umid));
#line 148
    __cil_tmp23 = strlen(info->umid);
    }
#line 148
    if (__cil_tmp23 < sizeof(binfo.umid)) {
      {
#line 148
      __cil_tmp24 = strlen(info->umid);
#line 148
      tmp___4 = __cil_tmp24;
      }
    } else {
#line 148
      tmp___4 = sizeof(binfo.umid);
    }
    {
#line 148
    memcpy((void *)(binfo.umid), (void const   *)info->umid, tmp___4);
    }
  }
#line 151
  if ((unsigned long )info->time_ref != (unsigned long )((void *)0)) {
    {
#line 152
    __cil_tmp27 = atoll(info->time_ref);
#line 152
    ts = (uint64_t )__cil_tmp27;
#line 154
    binfo.time_reference_high = (uint32_t )(ts >> 32);
#line 155
    binfo.time_reference_low = (uint32_t )(ts & 4294967295UL);
    }
  }
#line 159
  if ((unsigned long )info->coding_history != (unsigned long )((void *)0)) {
#line 160
    if (info->coding_hist_append) {
      {
#line 161
      __cil_tmp29 = strlen((char const   *)(binfo.coding_history));
#line 161
      slen = (int )__cil_tmp29;
      }
      {
#line 163
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 163
        __cil_tmp30 = __ctype_b_loc();
        }
#line 163
        if (slen > 1) {
#line 163
          if (! ((int )*(*__cil_tmp30 + (int )binfo.coding_history[slen - 1]) & 8192)) {
#line 163
            goto while_break;
          }
        } else {
#line 163
          goto while_break;
        }
#line 164
        __cil_tmp31 = slen;
#line 164
        slen --;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 166
      memcpy((void *)(binfo.coding_history + slen), (void const   *)info->coding_history,
             sizeof(binfo.coding_history) - (unsigned long )slen);
      }
    } else {
      {
#line 169
      __cil_tmp33 = strlen(info->coding_history);
      }
#line 169
      if (__cil_tmp33 < sizeof(binfo.coding_history)) {
        {
#line 169
        __cil_tmp34 = strlen(info->coding_history);
#line 169
        tmp___5 = __cil_tmp34;
        }
      } else {
#line 169
        tmp___5 = sizeof(binfo.coding_history);
      }
      {
#line 169
      slen___0 = tmp___5;
#line 171
      memset((void *)(binfo.coding_history), 0, sizeof(binfo.coding_history));
#line 172
      memcpy((void *)(binfo.coding_history), (void const   *)info->coding_history,
             slen___0);
#line 173
      binfo.coding_history_size = (uint32_t )slen___0;
      }
    }
  }
  {
#line 177
  __cil_tmp36 = sf_command(outfile, 4337, (void *)(& binfo), (int )sizeof(binfo));
  }
#line 177
  if (__cil_tmp36 == 0) {
    {
#line 178
    printf("Error : Setting of broadcast info chunks failed.\n\n");
    }
#line 179
    return (1);
  }
#line 182
  return (0);
}
}
#line 186 "/root/patchweave_donee/23/programs/common.c"
static void update_strings(SNDFILE *outfile , METADATA_INFO *info ) 
{ 


  {
#line 188
  if ((unsigned long )info->title != (unsigned long )((void *)0)) {
    {
#line 189
    sf_set_string(outfile, 1, info->title);
    }
  }
#line 191
  if ((unsigned long )info->copyright != (unsigned long )((void *)0)) {
    {
#line 192
    sf_set_string(outfile, 2, info->copyright);
    }
  }
#line 194
  if ((unsigned long )info->artist != (unsigned long )((void *)0)) {
    {
#line 195
    sf_set_string(outfile, 4, info->artist);
    }
  }
#line 197
  if ((unsigned long )info->comment != (unsigned long )((void *)0)) {
    {
#line 198
    sf_set_string(outfile, 5, info->comment);
    }
  }
#line 200
  if ((unsigned long )info->date != (unsigned long )((void *)0)) {
    {
#line 201
    sf_set_string(outfile, 6, info->date);
    }
  }
#line 203
  if ((unsigned long )info->album != (unsigned long )((void *)0)) {
    {
#line 204
    sf_set_string(outfile, 7, info->album);
    }
  }
#line 206
  if ((unsigned long )info->license != (unsigned long )((void *)0)) {
    {
#line 207
    sf_set_string(outfile, 8, info->license);
    }
  }
#line 210
  return;
}
}
#line 214 "/root/patchweave_donee/23/programs/common.c"
void sfe_apply_metadata_changes(char const   **filenames , METADATA_INFO *info ) 
{ 
  SNDFILE *infile ;
  SNDFILE *outfile ;
  SF_INFO sfinfo ;
  METADATA_INFO tmpinfo ;
  int error_code ;
  char const   *__cil_tmp11 ;
  char const   *__cil_tmp12 ;
  int __cil_tmp13 ;
  int infileminor ;

  {
  {
#line 215
  infile = (SNDFILE *)((void *)0);
#line 215
  outfile = (SNDFILE *)((void *)0);
#line 218
  error_code = 0;
#line 220
  memset((void *)(& sfinfo), 0, sizeof(sfinfo));
#line 221
  memset((void *)(& tmpinfo), 0, sizeof(tmpinfo));
  }
#line 223
  if ((unsigned long )*(filenames + 1) == (unsigned long )((void *)0)) {
    {
#line 224
    infile = sf_open(*(filenames + 0), 48, & sfinfo);
    }
  } else {
    {
#line 226
    infile = sf_open(*(filenames + 0), 16, & sfinfo);
#line 229
    sfinfo.format = 65536 | (65535 & sfinfo.format);
#line 230
    outfile = sf_open(*(filenames + 1), 32, & sfinfo);
    }
  }
#line 233
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 234
    __cil_tmp11 = sf_strerror(infile);
#line 234
    printf("Error : Not able to open input file \'%s\' : %s\n", *(filenames + 0),
           __cil_tmp11);
#line 235
    error_code = 1;
    }
#line 236
    goto cleanup_exit;
  }
#line 239
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    {
#line 240
    __cil_tmp12 = sf_strerror(outfile);
#line 240
    printf("Error : Not able to open output file \'%s\' : %s\n", *(filenames + 1),
           __cil_tmp12);
#line 241
    error_code = 1;
    }
#line 242
    goto cleanup_exit;
  }
  {
#line 245
  __cil_tmp13 = merge_broadcast_info(infile, outfile, sfinfo.format, info);
  }
#line 245
  if (info->has_bext_fields) {
#line 245
    if (__cil_tmp13) {
#line 246
      error_code = 1;
#line 247
      goto cleanup_exit;
    }
  }
#line 250
  if ((unsigned long )infile != (unsigned long )outfile) {
#line 251
    infileminor = 65535 & sfinfo.format;
#line 254
    if (infileminor == 7) {
      {
#line 255
      sfe_copy_data_fp(outfile, infile, sfinfo.channels, 0);
      }
    } else
#line 254
    if (infileminor == 6) {
      {
#line 255
      sfe_copy_data_fp(outfile, infile, sfinfo.channels, 0);
      }
    } else {
      {
#line 257
      sfe_copy_data_int(outfile, infile, sfinfo.channels);
      }
    }
  }
  {
#line 260
  update_strings(outfile, info);
  }
  cleanup_exit: 
#line 264
  if ((unsigned long )outfile != (unsigned long )((void *)0)) {
#line 264
    if ((unsigned long )outfile != (unsigned long )infile) {
      {
#line 265
      sf_close(outfile);
      }
    }
  }
#line 267
  if ((unsigned long )infile != (unsigned long )((void *)0)) {
    {
#line 268
    sf_close(infile);
    }
  }
#line 270
  if (error_code) {
    {
#line 271
    exit(error_code);
    }
  }
#line 273
  return;
}
}
#line 285 "/root/patchweave_donee/23/programs/common.c"
static OUTPUT_FORMAT_MAP format_map[34]  = 
#line 285
  {      {"wav\333\204U", 0, 65536}, 
        {"aif\333\204U", 3, 131072}, 
        {"au\351\333\204U", 0, 196608}, 
        {"snd\333\204U", 0, 196608}, 
        {"raw", 0, 262144}, 
        {"gsm\333\204U", 0, 262144}, 
        {"vox", 0, 262144}, 
        {"paf\333\204U", 0, 537198592}, 
        {"fap", 0, 268763136}, 
        {"svx", 0, 393216}, 
        {"nist", 0, 458752}, 
        {"sph\333\204U", 0, 458752}, 
        {"voc\333\204U", 0, 524288}, 
        {"ircam", 0, 655360}, 
        {"sf", 0, 655360}, 
        {"w64\333\204U", 0, 720896}, 
        {"mat\333\204U", 0, 786432}, 
        {"mat4", 0, 786432}, 
        {"mat5\204U", 0, 851968}, 
        {"pvf\333\204U", 0, 917504}, 
        {"xi", 0, 983040}, 
        {"htk\333\204U", 0, 1048576}, 
        {"sds", 0, 1114112}, 
        {"avr\333\204U", 0, 1179648}, 
        {"wavex", 0, 1245184}, 
        {"sd2", 0, 1441792}, 
        {"flac\204U", 0, 1507328}, 
        {"caf\333\204U", 0, 1572864}, 
        {"wve\333\204U", 0, 1638400}, 
        {"prc", 0, 1638400}, 
        {"ogg\333\204U", 0, 2097152}, 
        {"oga", 0, 2097152}, 
        {"mpc\333\204U", 0, 2162688}, 
        {"rf64", 0, 2228224}};
#line 324 "/root/patchweave_donee/23/programs/common.c"
int sfe_file_type_of_ext(char const   *str___0 , int format ) 
{ 
  char buffer[16] ;
  char *cptr ;
  int k ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 328
  format &= 65535;
#line 330
  cptr = strrchr(str___0, '.');
  }
#line 330
  if ((unsigned long )cptr == (unsigned long )((void *)0)) {
#line 331
    return (0);
  }
  {
#line 333
  strncpy(buffer, (char const   *)(cptr + 1), 15UL);
#line 334
  buffer[15] = (char)0;
#line 336
  k = 0;
  }
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;

#line 336
    if (! buffer[k]) {
#line 336
      goto while_break;
    }
#line 337
    buffer[k] = (char)0;
#line 336
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 339
  __cil_tmp8 = strcmp((char const   *)(buffer), "gsm");
  }
#line 339
  if (__cil_tmp8 == 0) {
#line 340
    return (262176);
  }
  {
#line 342
  __cil_tmp9 = strcmp((char const   *)(buffer), "vox");
  }
#line 342
  if (__cil_tmp9 == 0) {
#line 343
    return (262177);
  }
#line 345
  k = 0;
  {
#line 345
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 345
    if (! (k < (int )(sizeof(format_map) / sizeof(format_map[0])))) {
#line 345
      goto while_break___0;
    }
    {
#line 346
    __cil_tmp10 = strncmp((char const   *)(buffer), format_map[k].ext, (unsigned long )format_map[k].len);
    }
#line 346
    if (format_map[k].len > 0) {
#line 346
      if (__cil_tmp10 == 0) {
#line 347
        return (format_map[k].format | format);
      } else {
#line 346
        goto _L;
      }
    } else {
      _L: 
      {
#line 348
      __cil_tmp11 = strcmp((char const   *)(buffer), format_map[k].ext);
      }
#line 348
      if (__cil_tmp11 == 0) {
#line 349
        return (format_map[k].format | format);
      }
    }
#line 345
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 353
  return (65539);
}
}
#line 357 "/root/patchweave_donee/23/programs/common.c"
void sfe_dump_format_map(void) 
{ 
  SF_FORMAT_INFO info ;
  int k ;
  char const   *tmp ;

  {
#line 361
  k = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;

#line 361
    if (! (k < (int )(sizeof(format_map) / sizeof(format_map[0])))) {
#line 361
      goto while_break;
    }
    {
#line 362
    info.format = format_map[k].format;
#line 363
    sf_command((SNDFILE *)((void *)0), 4136, (void *)(& info), (int )sizeof(info));
    }
#line 364
    if ((unsigned long )info.name == (unsigned long )((void *)0)) {
#line 364
      tmp = "????";
    } else {
#line 364
      tmp = info.name;
    }
    {
#line 364
    printf("        %-10s : %s\n", format_map[k].ext, tmp);
#line 361
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 366
  return;
}
}
#line 370 "/root/patchweave_donee/23/programs/common.c"
char const   *program_name(char const   *argv0 ) 
{ 
  char const   *tmp ;
  char *__cil_tmp3 ;
  char const   *tmp___53 ;
  char *__cil_tmp5 ;

  {
  {
#line 373
  __cil_tmp3 = strrchr(argv0, '/');
#line 373
  tmp = (char const   *)__cil_tmp3;
  }
#line 374
  if (tmp) {
#line 374
    tmp___53 = tmp + 1;
  } else {
#line 374
    tmp___53 = argv0;
  }
  {
#line 374
  argv0 = tmp___53;
#line 377
  __cil_tmp5 = strstr(argv0, "lt-");
  }
#line 377
  if ((unsigned long )__cil_tmp5 == (unsigned long )argv0) {
#line 378
    return (argv0 + 3);
  }
#line 380
  return (argv0);
}
}
#line 384 "/root/patchweave_donee/23/programs/common.c"
char const   *sfe_endian_name(int format ) 
{ 


  {
#line 387
  if ((format & 805306368) == 0) {
#line 387
    goto case_0;
  }
#line 388
  if ((format & 805306368) == 268435456) {
#line 388
    goto case_268435456;
  }
#line 389
  if ((format & 805306368) == 536870912) {
#line 389
    goto case_536870912;
  }
#line 390
  if ((format & 805306368) == 805306368) {
#line 390
    goto case_805306368;
  }
#line 391
  goto switch_default;
  case_0: 
#line 387
  return ("file");
  case_268435456: 
#line 388
  return ("little");
  case_536870912: 
#line 389
  return ("big");
  case_805306368: 
#line 390
  return ("cpu\333\204U");
  switch_default: 
#line 391
  goto switch_break;
  switch_break: ;
#line 394
  return ("unknown");
}
}
#line 398 "/root/patchweave_donee/23/programs/common.c"
char const   *sfe_container_name(int format ) 
{ 


  {
#line 401
  if ((format & 268369920) == 65536) {
#line 401
    goto case_65536;
  }
#line 402
  if ((format & 268369920) == 131072) {
#line 402
    goto case_131072;
  }
#line 403
  if ((format & 268369920) == 196608) {
#line 403
    goto case_196608;
  }
#line 404
  if ((format & 268369920) == 262144) {
#line 404
    goto case_262144;
  }
#line 405
  if ((format & 268369920) == 327680) {
#line 405
    goto case_327680;
  }
#line 406
  if ((format & 268369920) == 393216) {
#line 406
    goto case_393216;
  }
#line 407
  if ((format & 268369920) == 458752) {
#line 407
    goto case_458752;
  }
#line 408
  if ((format & 268369920) == 524288) {
#line 408
    goto case_524288;
  }
#line 409
  if ((format & 268369920) == 655360) {
#line 409
    goto case_655360;
  }
#line 410
  if ((format & 268369920) == 720896) {
#line 410
    goto case_720896;
  }
#line 411
  if ((format & 268369920) == 786432) {
#line 411
    goto case_786432;
  }
#line 412
  if ((format & 268369920) == 851968) {
#line 412
    goto case_851968;
  }
#line 413
  if ((format & 268369920) == 917504) {
#line 413
    goto case_917504;
  }
#line 414
  if ((format & 268369920) == 983040) {
#line 414
    goto case_983040;
  }
#line 415
  if ((format & 268369920) == 1048576) {
#line 415
    goto case_1048576;
  }
#line 416
  if ((format & 268369920) == 1114112) {
#line 416
    goto case_1114112;
  }
#line 417
  if ((format & 268369920) == 1179648) {
#line 417
    goto case_1179648;
  }
#line 418
  if ((format & 268369920) == 1245184) {
#line 418
    goto case_1245184;
  }
#line 419
  if ((format & 268369920) == 1441792) {
#line 419
    goto case_1441792;
  }
#line 420
  if ((format & 268369920) == 1507328) {
#line 420
    goto case_1507328;
  }
#line 421
  if ((format & 268369920) == 1572864) {
#line 421
    goto case_1572864;
  }
#line 422
  if ((format & 268369920) == 1638400) {
#line 422
    goto case_1638400;
  }
#line 423
  if ((format & 268369920) == 2097152) {
#line 423
    goto case_2097152;
  }
#line 424
  if ((format & 268369920) == 2162688) {
#line 424
    goto case_2162688;
  }
#line 425
  if ((format & 268369920) == 2228224) {
#line 425
    goto case_2228224;
  }
#line 426
  goto switch_default;
  case_65536: 
#line 401
  return ("WAV\333\204U");
  case_131072: 
#line 402
  return ("AIFF\204U");
  case_196608: 
#line 403
  return ("AU\351\333\204U");
  case_262144: 
#line 404
  return ("RAW\333\204U");
  case_327680: 
#line 405
  return ("PAF\333\204U");
  case_393216: 
#line 406
  return ("SVX\333\204U");
  case_458752: 
#line 407
  return ("NIST");
  case_524288: 
#line 408
  return ("VOC");
  case_655360: 
#line 409
  return ("IRCAM");
  case_720896: 
#line 410
  return ("W64");
  case_786432: 
#line 411
  return ("MAT4\204U");
  case_851968: 
#line 412
  return ("MAT5\204U");
  case_917504: 
#line 413
  return ("PVF\333\204U");
  case_983040: 
#line 414
  return ("XI\351\333\204U");
  case_1048576: 
#line 415
  return ("HTK");
  case_1114112: 
#line 416
  return ("SDS");
  case_1179648: 
#line 417
  return ("AVR");
  case_1245184: 
#line 418
  return ("WAVEX");
  case_1441792: 
#line 419
  return ("SD2\333\204U");
  case_1507328: 
#line 420
  return ("FLAC");
  case_1572864: 
#line 421
  return ("CAF\333\204U");
  case_1638400: 
#line 422
  return ("WVE\333\204U");
  case_2097152: 
#line 423
  return ("OGG\333\204U");
  case_2162688: 
#line 424
  return ("MPC2K");
  case_2228224: 
#line 425
  return ("RF64");
  switch_default: 
#line 426
  goto switch_break;
  switch_break: ;
#line 429
  return ("unknown");
}
}
#line 433 "/root/patchweave_donee/23/programs/common.c"
char const   *sfe_codec_name(int format ) 
{ 


  {
#line 436
  if ((format & 65535) == 1) {
#line 436
    goto case_1;
  }
#line 437
  if ((format & 65535) == 2) {
#line 437
    goto case_2;
  }
#line 438
  if ((format & 65535) == 3) {
#line 438
    goto case_3;
  }
#line 439
  if ((format & 65535) == 4) {
#line 439
    goto case_4;
  }
#line 440
  if ((format & 65535) == 5) {
#line 440
    goto case_5;
  }
#line 441
  if ((format & 65535) == 6) {
#line 441
    goto case_6;
  }
#line 442
  if ((format & 65535) == 7) {
#line 442
    goto case_7;
  }
#line 443
  if ((format & 65535) == 16) {
#line 443
    goto case_16;
  }
#line 444
  if ((format & 65535) == 17) {
#line 444
    goto case_17;
  }
#line 445
  if ((format & 65535) == 18) {
#line 445
    goto case_18;
  }
#line 446
  if ((format & 65535) == 19) {
#line 446
    goto case_19;
  }
#line 447
  if ((format & 65535) == 32) {
#line 447
    goto case_32;
  }
#line 448
  if ((format & 65535) == 33) {
#line 448
    goto case_33;
  }
#line 449
  if ((format & 65535) == 48) {
#line 449
    goto case_48;
  }
#line 450
  if ((format & 65535) == 49) {
#line 450
    goto case_49;
  }
#line 451
  if ((format & 65535) == 50) {
#line 451
    goto case_50;
  }
#line 452
  if ((format & 65535) == 64) {
#line 452
    goto case_64;
  }
#line 453
  if ((format & 65535) == 65) {
#line 453
    goto case_65;
  }
#line 454
  if ((format & 65535) == 66) {
#line 454
    goto case_66;
  }
#line 455
  if ((format & 65535) == 67) {
#line 455
    goto case_67;
  }
#line 456
  if ((format & 65535) == 80) {
#line 456
    goto case_80;
  }
#line 457
  if ((format & 65535) == 81) {
#line 457
    goto case_81;
  }
#line 458
  if ((format & 65535) == 96) {
#line 458
    goto case_96;
  }
#line 459
  if ((format & 65535) == 112) {
#line 459
    goto case_112;
  }
#line 460
  if ((format & 65535) == 113) {
#line 460
    goto case_113;
  }
#line 461
  if ((format & 65535) == 114) {
#line 461
    goto case_114;
  }
#line 462
  if ((format & 65535) == 115) {
#line 462
    goto case_115;
  }
#line 463
  goto switch_default;
  case_1: 
#line 436
  return ("signed 8 bit PCM\220");
  case_2: 
#line 437
  return ("16 bit PCM");
  case_3: 
#line 438
  return ("24 bit PCM");
  case_4: 
#line 439
  return ("32 bit PCM");
  case_5: 
#line 440
  return ("unsigned 8 bit PCM\351\333\204U");
  case_6: 
#line 441
  return ("32 bit float\204U");
  case_7: 
#line 442
  return ("64 bit double");
  case_16: 
#line 443
  return ("u-law");
  case_17: 
#line 444
  return ("a-lawU");
  case_18: 
#line 445
  return ("IMA ADPCM");
  case_19: 
#line 446
  return ("MS ADPCM\220");
  case_32: 
#line 447
  return ("gsm610");
  case_33: 
#line 448
  return ("Vox ADPCM");
  case_48: 
#line 449
  return ("g721 32kbps\333\204U");
  case_49: 
#line 450
  return ("g723 24kbps\333\204U");
  case_50: 
#line 451
  return ("g723 40kbps\333\204U");
  case_64: 
#line 452
  return ("12 bit DWVW\333\204U");
  case_65: 
#line 453
  return ("16 bit DWVW");
  case_66: 
#line 454
  return ("14 bit DWVW");
  case_67: 
#line 455
  return ("DWVW\204U");
  case_80: 
#line 456
  return ("8 bit DPCM\351\333\204U");
  case_81: 
#line 457
  return ("16 bit DPCM");
  case_96: 
#line 458
  return ("Vorbis");
  case_112: 
#line 459
  return ("16 bit ALAC\333\204U");
  case_113: 
#line 460
  return ("20 bit ALAC\333\204U");
  case_114: 
#line 461
  return ("24 bit ALAC");
  case_115: 
#line 462
  return ("32 bit ALAC");
  switch_default: 
#line 463
  goto switch_break;
  switch_break: ;
#line 465
  return ("unknown");
}
}
#line 48 "/root/patchweave_donee/23/programs/sndfile-convert.c"
static void copy_metadata(SNDFILE *outfile , SNDFILE *infile , int channels ) ;
#line 51 "/root/patchweave_donee/23/programs/sndfile-convert.c"
static void usage_exit(char const   *progname ) 
{ 


  {
  {
#line 53
  printf("\nUsage : %s [options] [encoding] <input file> <output file>\n", progname);
#line 54
  puts("\n    where [option] may be:\n\n        -override-sample-rate=X  : force sample rate of input to X\n        -endian=little           : force output file to little endian data\n        -endian=big              : force output file to big endian data\n        -endian=cpu              : force output file same endian-ness as the CPU\n        -normalize               : normalize the data in the output file\n");
#line 63
  puts("    where [encoding] may be one of the following:\n\n        -pcms8     : signed 8 bit pcm\n        -pcmu8     : unsigned 8 bit pcm\n        -pcm16     : 16 bit pcm\n        -pcm24     : 24 bit pcm\n        -pcm32     : 32 bit pcm\n        -float32   : 32 bit floating point\n        -ulaw      : ULAW\n        -alaw      : ALAW\n        -alac16    : 16 bit ALAC (CAF only)\n        -alac20    : 20 bit ALAC (CAF only)\n        -alac24    : 24 bit ALAC (CAF only)\n        -alac32    : 32 bit ALAC (CAF only)\n        -ima-adpcm : IMA ADPCM (WAV only)\n        -ms-adpcm  : MS ADPCM (WAV only)\n        -gsm610    : GSM6.10 (WAV only)\n        -dwvw12    : 12 bit DWVW (AIFF only)\n        -dwvw16    : 16 bit DWVW (AIFF only)\n        -dwvw24    : 24 bit DWVW (AIFF only)\n        -vorbis    : Vorbis (OGG only)\n");
#line 86
  puts("    If no encoding is specified, the program will try to use the encoding\n    of the input file in the output file. This will not always work as\n    most container formats (eg WAV, AIFF etc) only support a small subset\n    of codec formats (eg 16 bit PCM, a-law, Vorbis etc).\n\220");
#line 93
  puts("    The format of the output file is determined by the file extension of the\n    output file name. The following extensions are currently understood:\n");
#line 98
  sfe_dump_format_map();
#line 100
  puts("\220");
#line 101
  exit(1);
  }
}
}
#line 105 "/root/patchweave_donee/23/programs/sndfile-convert.c"
static void report_format_error_exit(char const   *argv0 , SF_INFO *sfinfo ) 
{ 
  int old_format ;
  int endian ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;
  char const   *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  char const   *__cil_tmp9 ;

  {
  {
#line 106
  old_format = sfinfo->format;
#line 107
  endian = sfinfo->format & 805306368;
#line 109
  sfinfo->format = old_format & 268435455;
#line 111
  __cil_tmp5 = sf_format_check(sfinfo);
  }
#line 111
  if (endian) {
#line 111
    if (__cil_tmp5) {
      {
#line 112
      __cil_tmp6 = sfe_endian_name(endian);
#line 112
      printf("Error : output file format does not support %s endian-ness.\n", __cil_tmp6);
#line 113
      exit(1);
      }
    }
  }
  {
#line 116
  __cil_tmp7 = sfe_container_name(sfinfo->format);
#line 116
  __cil_tmp8 = sfe_codec_name(sfinfo->format);
#line 116
  __cil_tmp9 = program_name(argv0);
#line 116
  printf("\nError : output file format is invalid.\nThe \'%s\' container does not support \'%s\' codec data.\nRun \'%s --help\' for clues.\n\n",
         __cil_tmp7, __cil_tmp8, __cil_tmp9);
#line 121
  exit(1);
  }
}
}
#line 125 "/root/patchweave_donee/23/programs/sndfile-convert.c"
int main(int argc , char **argv ) 
{ 
  char const   *progname ;
  char const   *infilename ;
  char const   *outfilename ;
  SNDFILE *infile ;
  SNDFILE *outfile ;
  SF_INFO sfinfo ;
  int k ;
  int outfilemajor ;
  int outfileminor ;
  int infileminor ;
  int override_sample_rate ;
  int endian ;
  int normalize ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  char *__cil_tmp38 ;
  char const   *ptr ;
  unsigned long __cil_tmp40 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  char const   *__cil_tmp49 ;
  int __cil_tmp51 ;
  char const   *__cil_tmp53 ;

  {
  {
#line 127
  infile = (SNDFILE *)((void *)0);
#line 127
  outfile = (SNDFILE *)((void *)0);
#line 129
  outfileminor = 0;
#line 130
  override_sample_rate = 0;
#line 131
  endian = 0;
#line 131
  normalize = 0;
#line 133
  progname = program_name((char const   *)*(argv + 0));
  }
#line 135
  if (argc < 3) {
    {
#line 136
    usage_exit(progname);
    }
  } else
#line 135
  if (argc > 5) {
    {
#line 136
    usage_exit(progname);
    }
  }
  {
#line 138
  infilename = (char const   *)*(argv + (argc - 2));
#line 139
  outfilename = (char const   *)*(argv + (argc - 1));
#line 141
  __cil_tmp17 = strcmp(infilename, outfilename);
  }
#line 141
  if (__cil_tmp17 == 0) {
    {
#line 142
    printf("Error : Input and output filenames are the same.\n\n");
#line 143
    usage_exit(progname);
    }
  }
  {
#line 146
  __cil_tmp18 = strlen(infilename);
  }
#line 146
  if (__cil_tmp18 > 1UL) {
#line 146
    if ((int )*(infilename + 0) == 45) {
      {
#line 147
      printf("Error : Input filename (%s) looks like an option.\n\n", infilename);
#line 148
      usage_exit(progname);
      }
    }
  }
#line 151
  if ((int )*(outfilename + 0) == 45) {
    {
#line 152
    printf("Error : Output filename (%s) looks like an option.\n\n", outfilename);
#line 153
    usage_exit(progname);
    }
  }
#line 156
  k = 1;
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 156
    if (! (k < argc - 2)) {
#line 156
      goto while_break;
    }
    {
#line 157
    __cil_tmp19 = strcmp((char const   *)*(argv + k), "-pcms8");
    }
#line 157
    if (! __cil_tmp19) {
#line 158
      outfileminor = 1;
#line 159
      goto while_continue;
    }
    {
#line 161
    __cil_tmp20 = strcmp((char const   *)*(argv + k), "-pcmu8");
    }
#line 161
    if (! __cil_tmp20) {
#line 162
      outfileminor = 5;
#line 163
      goto while_continue;
    }
    {
#line 165
    __cil_tmp21 = strcmp((char const   *)*(argv + k), "-pcm16");
    }
#line 165
    if (! __cil_tmp21) {
#line 166
      outfileminor = 2;
#line 167
      goto while_continue;
    }
    {
#line 169
    __cil_tmp22 = strcmp((char const   *)*(argv + k), "-pcm24");
    }
#line 169
    if (! __cil_tmp22) {
#line 170
      outfileminor = 3;
#line 171
      goto while_continue;
    }
    {
#line 173
    __cil_tmp23 = strcmp((char const   *)*(argv + k), "-pcm32");
    }
#line 173
    if (! __cil_tmp23) {
#line 174
      outfileminor = 4;
#line 175
      goto while_continue;
    }
    {
#line 177
    __cil_tmp24 = strcmp((char const   *)*(argv + k), "-float32\220");
    }
#line 177
    if (! __cil_tmp24) {
#line 178
      outfileminor = 6;
#line 179
      goto while_continue;
    }
    {
#line 181
    __cil_tmp25 = strcmp((char const   *)*(argv + k), "-ulaw");
    }
#line 181
    if (! __cil_tmp25) {
#line 182
      outfileminor = 16;
#line 183
      goto while_continue;
    }
    {
#line 185
    __cil_tmp26 = strcmp((char const   *)*(argv + k), "-alaw");
    }
#line 185
    if (! __cil_tmp26) {
#line 186
      outfileminor = 17;
#line 187
      goto while_continue;
    }
    {
#line 189
    __cil_tmp27 = strcmp((char const   *)*(argv + k), "-alac16");
    }
#line 189
    if (! __cil_tmp27) {
#line 190
      outfileminor = 112;
#line 191
      goto while_continue;
    }
    {
#line 193
    __cil_tmp28 = strcmp((char const   *)*(argv + k), "-alac20");
    }
#line 193
    if (! __cil_tmp28) {
#line 194
      outfileminor = 113;
#line 195
      goto while_continue;
    }
    {
#line 197
    __cil_tmp29 = strcmp((char const   *)*(argv + k), "-alac24");
    }
#line 197
    if (! __cil_tmp29) {
#line 198
      outfileminor = 114;
#line 199
      goto while_continue;
    }
    {
#line 201
    __cil_tmp30 = strcmp((char const   *)*(argv + k), "-alac32");
    }
#line 201
    if (! __cil_tmp30) {
#line 202
      outfileminor = 115;
#line 203
      goto while_continue;
    }
    {
#line 205
    __cil_tmp31 = strcmp((char const   *)*(argv + k), "-ima-adpcm");
    }
#line 205
    if (! __cil_tmp31) {
#line 206
      outfileminor = 18;
#line 207
      goto while_continue;
    }
    {
#line 209
    __cil_tmp32 = strcmp((char const   *)*(argv + k), "-ms-adpcm");
    }
#line 209
    if (! __cil_tmp32) {
#line 210
      outfileminor = 19;
#line 211
      goto while_continue;
    }
    {
#line 213
    __cil_tmp33 = strcmp((char const   *)*(argv + k), "-gsm610");
    }
#line 213
    if (! __cil_tmp33) {
#line 214
      outfileminor = 32;
#line 215
      goto while_continue;
    }
    {
#line 217
    __cil_tmp34 = strcmp((char const   *)*(argv + k), "-dwvw12");
    }
#line 217
    if (! __cil_tmp34) {
#line 218
      outfileminor = 64;
#line 219
      goto while_continue;
    }
    {
#line 221
    __cil_tmp35 = strcmp((char const   *)*(argv + k), "-dwvw16");
    }
#line 221
    if (! __cil_tmp35) {
#line 222
      outfileminor = 65;
#line 223
      goto while_continue;
    }
    {
#line 225
    __cil_tmp36 = strcmp((char const   *)*(argv + k), "-dwvw24");
    }
#line 225
    if (! __cil_tmp36) {
#line 226
      outfileminor = 66;
#line 227
      goto while_continue;
    }
    {
#line 229
    __cil_tmp37 = strcmp((char const   *)*(argv + k), "-vorbis");
    }
#line 229
    if (! __cil_tmp37) {
#line 230
      outfileminor = 96;
#line 231
      goto while_continue;
    }
    {
#line 234
    __cil_tmp38 = strstr((char const   *)*(argv + k), "-override-sample-rate=");
    }
#line 234
    if ((unsigned long )__cil_tmp38 == (unsigned long )*(argv + k)) {
      {
#line 237
      __cil_tmp40 = strlen("-override-sample-rate=");
#line 237
      ptr = (char const   *)(*(argv + k) + __cil_tmp40);
#line 238
      override_sample_rate = atoi(ptr);
      }
#line 239
      goto while_continue;
    }
    {
#line 242
    __cil_tmp42 = strcmp((char const   *)*(argv + k), "-endian=little");
    }
#line 242
    if (! __cil_tmp42) {
#line 243
      endian = 268435456;
#line 244
      goto while_continue;
    }
    {
#line 247
    __cil_tmp43 = strcmp((char const   *)*(argv + k), "-endian=big");
    }
#line 247
    if (! __cil_tmp43) {
#line 248
      endian = 536870912;
#line 249
      goto while_continue;
    }
    {
#line 252
    __cil_tmp44 = strcmp((char const   *)*(argv + k), "-endian=cpu");
    }
#line 252
    if (! __cil_tmp44) {
#line 253
      endian = 805306368;
#line 254
      goto while_continue;
    }
    {
#line 257
    __cil_tmp45 = strcmp((char const   *)*(argv + k), "-endian=file");
    }
#line 257
    if (! __cil_tmp45) {
#line 258
      endian = 0;
#line 259
      goto while_continue;
    }
    {
#line 262
    __cil_tmp46 = strcmp((char const   *)*(argv + k), "-normalize");
    }
#line 262
    if (! __cil_tmp46) {
#line 263
      normalize = 1;
#line 264
      goto while_continue;
    }
    {
#line 267
    printf("Error : Not able to decode argunment \'%s\'.\n", *(argv + k));
#line 268
    exit(1);
#line 156
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 271
  memset((void *)(& sfinfo), 0, sizeof(sfinfo));
#line 273
  infile = sf_open(infilename, 16, & sfinfo);
  }
#line 273
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 274
    printf("Not able to open input file %s.\n\230\001", infilename);
#line 275
    __cil_tmp49 = sf_strerror((SNDFILE *)((void *)0));
#line 275
    puts(__cil_tmp49);
    }
#line 276
    return (1);
  }
#line 280
  if (override_sample_rate) {
#line 281
    sfinfo.samplerate = override_sample_rate;
  }
  {
#line 283
  infileminor = sfinfo.format & 65535;
#line 285
  sfinfo.format = sfe_file_type_of_ext(outfilename, sfinfo.format);
  }
#line 285
  if (sfinfo.format == 0) {
    {
#line 286
    printf("Error : Not able to determine output file type for %s.\n", outfilename);
    }
#line 287
    return (1);
  }
#line 290
  outfilemajor = sfinfo.format & 1073676288;
#line 292
  if (outfileminor == 0) {
#line 293
    outfileminor = sfinfo.format & 65535;
  }
#line 295
  if (outfileminor != 0) {
#line 296
    sfinfo.format = outfilemajor | outfileminor;
  } else {
#line 298
    sfinfo.format = outfilemajor | (sfinfo.format & 65535);
  }
#line 300
  sfinfo.format |= endian;
#line 302
  if ((sfinfo.format & 268369920) == 983040) {
#line 304
    if ((sfinfo.format & 65535) == 2) {
#line 304
      goto case_2;
    }
#line 309
    if ((sfinfo.format & 65535) == 5) {
#line 309
      goto case_5;
    }
#line 309
    if ((sfinfo.format & 65535) == 1) {
#line 309
      goto case_5;
    }
#line 303
    goto switch_break;
    case_2: 
#line 305
    sfinfo.format = outfilemajor | 81;
#line 306
    goto switch_break;
    case_5: 
#line 310
    sfinfo.format = outfilemajor | 80;
#line 311
    goto switch_break;
    switch_break: ;
  }
  {
#line 314
  __cil_tmp51 = sf_format_check(& sfinfo);
  }
#line 314
  if (__cil_tmp51 == 0) {
    {
#line 315
    report_format_error_exit((char const   *)*(argv + 0), & sfinfo);
    }
  }
#line 317
  if ((sfinfo.format & 65535) == 32) {
#line 317
    if (sfinfo.samplerate != 8000) {
      {
#line 318
      printf("WARNING: GSM 6.10 data format only supports 8kHz sample rate. The converted\nouput file will contain the input data converted to the GSM 6.10 data format\nbut not re-sampled.\n");
      }
    }
  }
  {
#line 326
  outfile = sf_open(outfilename, 32, & sfinfo);
  }
#line 326
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    {
#line 327
    __cil_tmp53 = sf_strerror((SNDFILE *)((void *)0));
#line 327
    printf("Not able to open output file %s : %s\n", outfilename, __cil_tmp53);
    }
#line 328
    return (1);
  }
  {
#line 332
  copy_metadata(outfile, infile, sfinfo.channels);
  }
#line 334
  if (normalize) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (outfileminor == 7) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (outfileminor == 6) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (infileminor == 7) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (infileminor == 6) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (infileminor == 96) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else
#line 334
  if (outfileminor == 96) {
    {
#line 338
    sfe_copy_data_fp(outfile, infile, sfinfo.channels, normalize);
    }
  } else {
    {
#line 340
    sfe_copy_data_int(outfile, infile, sfinfo.channels);
    }
  }
  {
#line 342
  sf_close(infile);
#line 343
  sf_close(outfile);
  }
#line 345
  return (0);
}
}
#line 349 "/root/patchweave_donee/23/programs/sndfile-convert.c"
static void copy_metadata(SNDFILE *outfile , SNDFILE *infile , int channels ) 
{ 
  SF_INSTRUMENT inst ;
  SF_BROADCAST_INFO_2K binfo ;
  char const   *str___0 ;
  int k ;
  int chanmap[256] ;
  size_t size ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 355
  k = 1;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;

#line 355
    if (! (k <= 16)) {
#line 355
      goto while_break;
    }
    {
#line 356
    str___0 = sf_get_string(infile, k);
    }
#line 357
    if ((unsigned long )str___0 != (unsigned long )((void *)0)) {
      {
#line 358
      sf_set_string(outfile, k, str___0);
      }
    }
#line 355
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 361
  memset((void *)(& inst), 0, sizeof(inst));
#line 362
  memset((void *)(& binfo), 0, sizeof(binfo));
  }
#line 364
  if (channels < (int )(sizeof(chanmap) / sizeof(chanmap[0]))) {
    {
#line 365
    size = (unsigned long )channels * sizeof(chanmap[0]);
#line 367
    __cil_tmp12 = sf_command(infile, 4352, (void *)(chanmap), (int )size);
    }
#line 367
    if (__cil_tmp12 == 1) {
      {
#line 368
      sf_command(outfile, 4353, (void *)(chanmap), (int )size);
      }
    }
  }
  {
#line 371
  __cil_tmp13 = sf_command(infile, 4304, (void *)(& inst), (int )sizeof(inst));
  }
#line 371
  if (__cil_tmp13 == 1) {
    {
#line 372
    sf_command(outfile, 4305, (void *)(& inst), (int )sizeof(inst));
    }
  }
  {
#line 374
  __cil_tmp14 = sf_command(infile, 4336, (void *)(& binfo), (int )sizeof(binfo));
  }
#line 374
  if (__cil_tmp14 == 1) {
    {
#line 375
    sf_command(outfile, 4337, (void *)(& binfo), (int )sizeof(binfo));
    }
  }
#line 378
  return;
}
}
