/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef int wchar_t;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_5 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_5 __sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_8 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_7 {
   unsigned long long __wseq ;
   struct __anonstruct_8 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_10 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_9 {
   unsigned long long __g1_start ;
   struct __anonstruct_10 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_7 __annonCompField1 ;
   unsigned long long __wseq ;
   struct __anonstruct_8 __wseq32 ;
   union __anonunion_9 __annonCompField2 ;
   unsigned long long __g1_start ;
   struct __anonstruct_10 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_11 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_11 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_condattr_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_cond_t;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef long ptrdiff_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 718 "/usr/include/pthread.h"
struct __jmp_buf_tag ;
#line 44 "/root/patchweave_new/13/src/utils/./thread.h"
enum __anonenum__47 {
    NOT_OK = 0,
    OK = 1,
    WORK = 2
} ;
#line 48 "/root/patchweave_new/13/src/utils/./thread.h"
typedef enum __anonenum__47 WebPWorkerStatus;
#line 55 "/root/patchweave_new/13/src/utils/./thread.h"
struct __anonstruct_48 {
   pthread_mutex_t mutex_ ;
   pthread_cond_t condition_ ;
   pthread_t thread_ ;
   WebPWorkerStatus status_ ;
   int (*hook)(void * , void * ) ;
   void *data1 ;
   void *data2 ;
   int had_error ;
};
#line 66 "/root/patchweave_new/13/src/utils/./thread.h"
typedef struct __anonstruct_48 WebPWorker;
#line 22 "/root/patchweave_new/13/src/utils/./rescaler.h"
struct __anonstruct_69 {
   int x_expand ;
   int num_channels ;
   int fy_scale ;
   int fx_scale ;
   int64_t fxy_scale ;
   int y_accum ;
   int y_add ;
   int y_sub ;
   int x_add ;
   int x_sub ;
   int src_width ;
   int src_height ;
   int dst_width ;
   int dst_height ;
   uint8_t *dst ;
   int dst_stride ;
   int32_t *irow ;
   int32_t *frow ;
};
#line 36 "/root/patchweave_new/13/src/utils/./rescaler.h"
typedef struct __anonstruct_69 WebPRescaler;
#line 22 "/root/patchweave_new/13/src/utils/./huffman_encode.h"
struct __anonstruct_75 {
   uint8_t code ;
   uint8_t extra_bits ;
};
#line 25 "/root/patchweave_new/13/src/utils/./huffman_encode.h"
typedef struct __anonstruct_75 HuffmanTreeToken;
#line 28 "/root/patchweave_new/13/src/utils/./huffman_encode.h"
struct __anonstruct_76 {
   int num_symbols ;
   uint8_t *code_lengths ;
   uint16_t *codes ;
};
#line 32 "/root/patchweave_new/13/src/utils/./huffman_encode.h"
typedef struct __anonstruct_76 HuffmanTreeCode;
#line 53 "/root/patchweave_new/13/src/utils/../webp/format_constants.h"
enum __anonenum__77 {
    PREDICTOR_TRANSFORM = 0,
    CROSS_COLOR_TRANSFORM = 1,
    SUBTRACT_GREEN = 2,
    COLOR_INDEXING_TRANSFORM = 3
} ;
#line 58 "/root/patchweave_new/13/src/utils/../webp/format_constants.h"
typedef enum __anonenum__77 VP8LImageTransformType;
#line 124 "/root/patchweave_new/13/src/utils/huffman_encode.c"
struct __anonstruct_78 {
   int total_count_ ;
   int value_ ;
   int pool_index_left_ ;
   int pool_index_right_ ;
};
#line 129 "/root/patchweave_new/13/src/utils/huffman_encode.c"
typedef struct __anonstruct_78 HuffmanTree;
#line 23 "/root/patchweave_new/13/src/utils/./huffman.h"
struct __anonstruct_69___0 {
   int symbol_ ;
   int children_ ;
};
#line 26 "/root/patchweave_new/13/src/utils/./huffman.h"
typedef struct __anonstruct_69___0 HuffmanTreeNode;
#line 29
struct HuffmanTree ;
#line 29 "/root/patchweave_new/13/src/utils/./huffman.h"
typedef struct HuffmanTree HuffmanTree___0;
#line 30 "/root/patchweave_new/13/src/utils/./huffman.h"
struct HuffmanTree {
   HuffmanTreeNode *root_ ;
   int max_nodes_ ;
   int num_nodes_ ;
};
#line 22 "/root/patchweave_new/13/src/utils/./filters.h"
enum __anonenum__80 {
    WEBP_FILTER_NONE = 0,
    WEBP_FILTER_HORIZONTAL = 1,
    WEBP_FILTER_VERTICAL = 2,
    WEBP_FILTER_GRADIENT = 3,
    WEBP_FILTER_LAST = 4,
    WEBP_FILTER_BEST = 5,
    WEBP_FILTER_FAST = 6
} ;
#line 30 "/root/patchweave_new/13/src/utils/./filters.h"
typedef enum __anonenum__80 WEBP_FILTER_TYPE;
#line 32 "/root/patchweave_new/13/src/utils/./filters.h"
typedef void (*WebPFilterFunc)(uint8_t * , int  , int  , int  , uint8_t * );
#line 34 "/root/patchweave_new/13/src/utils/./filters.h"
typedef void (*WebPUnfilterFunc)(int  , int  , int  , uint8_t * );
#line 23 "/root/patchweave_new/13/src/utils/./color_cache.h"
struct __anonstruct_69___1 {
   uint32_t *colors_ ;
   int hash_shift_ ;
};
#line 26 "/root/patchweave_new/13/src/utils/./color_cache.h"
typedef struct __anonstruct_69___1 VP8LColorCache;
#line 24 "/root/patchweave_new/13/src/utils/./bit_writer.h"
struct VP8BitWriter ;
#line 24 "/root/patchweave_new/13/src/utils/./bit_writer.h"
typedef struct VP8BitWriter VP8BitWriter;
#line 25 "/root/patchweave_new/13/src/utils/./bit_writer.h"
struct VP8BitWriter {
   int32_t range_ ;
   int32_t value_ ;
   int run_ ;
   int nb_bits_ ;
   uint8_t *buf_ ;
   size_t pos_ ;
   size_t max_pos_ ;
   int error_ ;
};
#line 73 "/root/patchweave_new/13/src/utils/./bit_writer.h"
struct __anonstruct_120 {
   uint8_t *buf_ ;
   size_t bit_pos_ ;
   size_t max_bytes_ ;
   int error_ ;
};
#line 83 "/root/patchweave_new/13/src/utils/./bit_writer.h"
typedef struct __anonstruct_120 VP8LBitWriter;
#line 93 "/root/patchweave_new/13/src/utils/./bit_reader.h"
typedef uint64_t bit_t;
#line 94 "/root/patchweave_new/13/src/utils/./bit_reader.h"
typedef uint64_t lbit_t;
#line 113 "/root/patchweave_new/13/src/utils/./bit_reader.h"
typedef uint32_t range_t;
#line 119
struct VP8BitReader ;
#line 119 "/root/patchweave_new/13/src/utils/./bit_reader.h"
typedef struct VP8BitReader VP8BitReader;
#line 120 "/root/patchweave_new/13/src/utils/./bit_reader.h"
struct VP8BitReader {
   uint8_t *buf_ ;
   uint8_t *buf_end_ ;
   int eof_ ;
   range_t range_ ;
   bit_t value_ ;
   int bits_ ;
};
#line 286 "/root/patchweave_new/13/src/utils/./bit_reader.h"
typedef uint64_t vp8l_val_t;
#line 288 "/root/patchweave_new/13/src/utils/./bit_reader.h"
struct __anonstruct_124 {
   vp8l_val_t val_ ;
   uint8_t *buf_ ;
   size_t len_ ;
   size_t pos_ ;
   int bit_pos_ ;
   int eos_ ;
   int error_ ;
};
#line 296 "/root/patchweave_new/13/src/utils/./bit_reader.h"
typedef struct __anonstruct_124 VP8LBitReader;
#line 24 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
enum WebPImageHint {
    WEBP_HINT_DEFAULT = 0,
    WEBP_HINT_PICTURE = 1,
    WEBP_HINT_PHOTO = 2,
    WEBP_HINT_GRAPH = 3,
    WEBP_HINT_LAST = 4
} ;
#line 25
enum WebPEncCSP {
    WEBP_YUV420 = 0,
    WEBP_YUV422 = 1,
    WEBP_YUV444 = 2,
    WEBP_YUV400 = 3,
    WEBP_CSP_UV_MASK = 3,
    WEBP_YUV420A = 4,
    WEBP_YUV422A = 5,
    WEBP_YUV444A = 6,
    WEBP_YUV400A = 7,
    WEBP_CSP_ALPHA_BIT = 4
} ;
#line 26
enum WebPPreset {
    WEBP_PRESET_DEFAULT = 0,
    WEBP_PRESET_PICTURE = 1,
    WEBP_PRESET_PHOTO = 2,
    WEBP_PRESET_DRAWING = 3,
    WEBP_PRESET_ICON = 4,
    WEBP_PRESET_TEXT = 5
} ;
#line 27
enum WebPEncodingError {
    VP8_ENC_OK = 0,
    VP8_ENC_ERROR_OUT_OF_MEMORY = 1,
    VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY = 2,
    VP8_ENC_ERROR_NULL_PARAMETER = 3,
    VP8_ENC_ERROR_INVALID_CONFIGURATION = 4,
    VP8_ENC_ERROR_BAD_DIMENSION = 5,
    VP8_ENC_ERROR_PARTITION0_OVERFLOW = 6,
    VP8_ENC_ERROR_PARTITION_OVERFLOW = 7,
    VP8_ENC_ERROR_BAD_WRITE = 8,
    VP8_ENC_ERROR_FILE_TOO_BIG = 9,
    VP8_ENC_ERROR_USER_ABORT = 10,
    VP8_ENC_ERROR_LAST = 11
} ;
#line 29
struct WebPConfig ;
#line 29 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
typedef struct WebPConfig WebPConfig;
#line 30
struct WebPPicture ;
#line 30 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
typedef struct WebPPicture WebPPicture;
#line 31
struct WebPAuxStats ;
#line 31 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
typedef struct WebPAuxStats WebPAuxStats;
#line 32
struct WebPMemoryWriter ;
#line 32 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
typedef struct WebPMemoryWriter WebPMemoryWriter;
#line 80
enum WebPImageHint___0 {
    WEBP_HINT_DEFAULT___0 = 0,
    WEBP_HINT_PICTURE___0 = 1,
    WEBP_HINT_PHOTO___0 = 2,
    WEBP_HINT_GRAPH___0 = 3,
    WEBP_HINT_LAST___0 = 4
} ;
#line 89 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
struct WebPConfig {
   int lossless ;
   float quality ;
   int method ;
   enum WebPImageHint___0 image_hint ;
   int target_size ;
   float target_PSNR ;
   int segments ;
   int sns_strength ;
   int filter_strength ;
   int filter_sharpness ;
   int filter_type ;
   int autofilter ;
   int alpha_compression ;
   int alpha_filtering ;
   int alpha_quality ;
   int pass ;
   int show_compressed ;
   int preprocessing ;
   int partitions ;
   int partition_limit ;
   int emulate_jpeg_size ;
   int thread_level ;
   int low_memory ;
   uint32_t pad[5] ;
};
#line 175 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
struct WebPAuxStats {
   int coded_size ;
   float PSNR[5] ;
   int block_count[3] ;
   int header_bytes[2] ;
   int residual_bytes[3][4] ;
   int segment_size[4] ;
   int segment_quant[4] ;
   int segment_level[4] ;
   int alpha_data_size ;
   int layer_data_size ;
   uint32_t lossless_features ;
   int histogram_bits ;
   int transform_bits ;
   int cache_bits ;
   int palette_size ;
   int lossless_size ;
   uint32_t pad[4] ;
};
#line 211 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
struct WebPMemoryWriter {
   uint8_t *mem ;
   size_t size ;
   size_t max_size ;
   uint32_t pad[1] ;
};
#line 233
enum WebPEncCSP___0 {
    WEBP_YUV420___0 = 0,
    WEBP_YUV422___0 = 1,
    WEBP_YUV444___0 = 2,
    WEBP_YUV400___0 = 3,
    WEBP_CSP_UV_MASK___0 = 3,
    WEBP_YUV420A___0 = 4,
    WEBP_YUV422A___0 = 5,
    WEBP_YUV444A___0 = 6,
    WEBP_YUV400A___0 = 7,
    WEBP_CSP_ALPHA_BIT___0 = 4
} ;
#line 249
enum WebPEncodingError___0 {
    VP8_ENC_OK___0 = 0,
    VP8_ENC_ERROR_OUT_OF_MEMORY___0 = 1,
    VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY___0 = 2,
    VP8_ENC_ERROR_NULL_PARAMETER___0 = 3,
    VP8_ENC_ERROR_INVALID_CONFIGURATION___0 = 4,
    VP8_ENC_ERROR_BAD_DIMENSION___0 = 5,
    VP8_ENC_ERROR_PARTITION0_OVERFLOW___0 = 6,
    VP8_ENC_ERROR_PARTITION_OVERFLOW___0 = 7,
    VP8_ENC_ERROR_BAD_WRITE___0 = 8,
    VP8_ENC_ERROR_FILE_TOO_BIG___0 = 9,
    VP8_ENC_ERROR_USER_ABORT___0 = 10,
    VP8_ENC_ERROR_LAST___0 = 11
} ;
#line 268 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
struct WebPPicture {
   int use_argb ;
   enum WebPEncCSP___0 colorspace ;
   int width ;
   int height ;
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   int y_stride ;
   int uv_stride ;
   uint8_t *a ;
   int a_stride ;
   uint32_t pad1[2] ;
   uint32_t *argb ;
   int argb_stride ;
   uint32_t pad2[3] ;
   int (*writer)(uint8_t * , size_t  , WebPPicture * ) ;
   void *custom_ptr ;
   int extra_info_type ;
   uint8_t *extra_info ;
   WebPAuxStats *stats ;
   enum WebPEncodingError___0 error_code ;
   int (*progress_hook)(int  , WebPPicture * ) ;
   void *user_data ;
   uint32_t pad3[3] ;
   uint8_t *u0 ;
   uint8_t *v0 ;
   int uv0_stride ;
   uint32_t pad4[7] ;
   void *memory_ ;
   void *memory_argb_ ;
   void *pad5[2] ;
};
#line 40 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
enum __anonenum__128 {
    kSSE2 = 0,
    kSSE3 = 1,
    kNEON = 2
} ;
#line 44 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
typedef enum __anonenum__128 CPUFeature;
#line 81
struct VP8Matrix ;
#line 87
struct VP8Histogram ;
#line 110 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
typedef void (*VP8PredFunc)(uint8_t * );
#line 147 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
typedef void (*WebPUpsampleLinePairFunc)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                         uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                         int  );
#line 167 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
typedef void (*WebPSampleLinePairFunc)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                       uint8_t * , uint8_t * , int  );
#line 180 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
typedef void (*WebPYUV444Converter)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                    int  );
#line 63 "/root/patchweave_new/13/src/enc/./vp8enci.h"
enum __anonenum__147 {
    RD_OPT_NONE = 0,
    RD_OPT_BASIC = 1,
    RD_OPT_TRELLIS = 2,
    RD_OPT_TRELLIS_ALL = 3
} ;
#line 68 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef enum __anonenum__147 VP8RDLevel;
#line 160 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef int64_t score_t;
#line 173 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct VP8Histogram VP8Histogram;
#line 174 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct VP8Histogram {
   int distribution[32] ;
};
#line 185 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef uint32_t proba_t;
#line 186 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef uint8_t ProbaArray[3][11];
#line 187 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef proba_t StatsArray[3][11];
#line 188 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef uint16_t CostArray[3][68];
#line 189 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef double LFStats[4][64];
#line 191
struct VP8Encoder ;
#line 191 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct VP8Encoder VP8Encoder;
#line 194 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct __anonstruct_148 {
   int num_segments_ ;
   int update_map_ ;
   int size_ ;
};
#line 199 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct __anonstruct_148 VP8SegmentHeader;
#line 202 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct __anonstruct_149 {
   uint8_t segments_[3] ;
   uint8_t skip_proba_ ;
   ProbaArray coeffs_[4][8] ;
   StatsArray stats_[4][8] ;
   CostArray level_cost_[4][8] ;
   int dirty_ ;
   int use_skip_proba_ ;
   int nb_skip_ ;
};
#line 211 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct __anonstruct_149 VP8Proba;
#line 215 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct __anonstruct_150 {
   int simple_ ;
   int level_ ;
   int sharpness_ ;
   int i4x4_lf_delta_ ;
};
#line 220 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct __anonstruct_150 VP8FilterHeader;
#line 225 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct __anonstruct_151 {
   unsigned int type_ ;
   unsigned int uv_mode_ ;
   unsigned int skip_ ;
   unsigned int segment_ ;
   uint8_t alpha_ ;
};
#line 232 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct __anonstruct_151 VP8MBInfo;
#line 234 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct VP8Matrix {
   uint16_t q_[16] ;
   uint16_t iq_[16] ;
   uint16_t bias_[16] ;
   uint16_t zthresh_[16] ;
   uint16_t sharpen_[16] ;
};
#line 240 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct VP8Matrix VP8Matrix;
#line 242 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct __anonstruct_152 {
   VP8Matrix y1_ ;
   VP8Matrix y2_ ;
   VP8Matrix uv_ ;
   int alpha_ ;
   int beta_ ;
   int quant_ ;
   int fstrength_ ;
   int lambda_i16_ ;
   int lambda_i4_ ;
   int lambda_uv_ ;
   int lambda_mode_ ;
   int lambda_trellis_ ;
   int tlambda_ ;
   int lambda_trellis_i16_ ;
   int lambda_trellis_i4_ ;
   int lambda_trellis_uv_ ;
};
#line 253 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct __anonstruct_152 VP8SegmentInfo;
#line 257 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct __anonstruct_153 {
   score_t D ;
   score_t SD ;
   score_t R ;
   score_t score ;
   int16_t y_dc_levels[16] ;
   int16_t y_ac_levels[16][16] ;
   int16_t uv_levels[8][16] ;
   int mode_i16 ;
   uint8_t modes_i4[16] ;
   int mode_uv ;
   uint32_t nz ;
};
#line 266 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct __anonstruct_153 VP8ModeScore;
#line 270 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct __anonstruct_154 {
   int x_ ;
   int y_ ;
   int y_offset_ ;
   int uv_offset_ ;
   int y_stride_ ;
   int uv_stride_ ;
   uint8_t *yuv_in_ ;
   uint8_t *yuv_out_ ;
   uint8_t *yuv_out2_ ;
   uint8_t *yuv_p_ ;
   VP8Encoder *enc_ ;
   VP8MBInfo *mb_ ;
   VP8BitWriter *bw_ ;
   uint8_t *preds_ ;
   uint32_t *nz_ ;
   uint8_t i4_boundary_[37] ;
   uint8_t *i4_top_ ;
   int i4_ ;
   int top_nz_[9] ;
   int left_nz_[9] ;
   uint64_t bit_count_[4][3] ;
   uint64_t luma_bits_ ;
   uint64_t uv_bits_ ;
   LFStats *lf_stats_ ;
   int do_trellis_ ;
   int done_ ;
   int percent0_ ;
};
#line 295 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct __anonstruct_154 VP8EncIterator;
#line 334
struct VP8Tokens ;
#line 334 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct VP8Tokens VP8Tokens;
#line 336 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct __anonstruct_155 {
   VP8Tokens *pages_ ;
   VP8Tokens **last_page_ ;
   uint16_t *tokens_ ;
   int left_ ;
   int error_ ;
};
#line 344 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct __anonstruct_155 VP8TBuffer;
#line 369 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct VP8Encoder {
   WebPConfig *config_ ;
   WebPPicture *pic_ ;
   VP8FilterHeader filter_hdr_ ;
   VP8SegmentHeader segment_hdr_ ;
   int profile_ ;
   int mb_w_ ;
   int mb_h_ ;
   int preds_w_ ;
   int num_parts_ ;
   VP8BitWriter bw_ ;
   VP8BitWriter parts_[8] ;
   VP8TBuffer tokens_ ;
   int percent_ ;
   int has_alpha_ ;
   uint8_t *alpha_data_ ;
   uint32_t alpha_data_size_ ;
   WebPWorker alpha_worker_ ;
   int use_layer_ ;
   VP8BitWriter layer_bw_ ;
   uint8_t *layer_data_ ;
   size_t layer_data_size_ ;
   VP8SegmentInfo dqm_[4] ;
   int base_quant_ ;
   int alpha_ ;
   int uv_alpha_ ;
   int dq_y1_dc_ ;
   int dq_y2_dc_ ;
   int dq_y2_ac_ ;
   int dq_uv_dc_ ;
   int dq_uv_ac_ ;
   VP8Proba proba_ ;
   uint64_t sse_[4] ;
   uint64_t sse_count_ ;
   int coded_size_ ;
   int residual_bytes_[3][4] ;
   int block_count_[3] ;
   int method_ ;
   VP8RDLevel rd_opt_level_ ;
   int max_i4_header_bits_ ;
   int thread_level_ ;
   int do_search_ ;
   int use_tokens_ ;
   VP8MBInfo *mb_info_ ;
   uint8_t *preds_ ;
   uint32_t *nz_ ;
   uint8_t *yuv_in_ ;
   uint8_t *yuv_out_ ;
   uint8_t *yuv_out2_ ;
   uint8_t *yuv_p_ ;
   uint8_t *y_top_ ;
   uint8_t *uv_top_ ;
   uint8_t *y_left_ ;
   uint8_t *u_left_ ;
   uint8_t *v_left_ ;
   LFStats *lf_stats_ ;
};
#line 527 "/root/patchweave_new/13/src/enc/./vp8enci.h"
struct __anonstruct_156 {
   double w ;
   double xm ;
   double ym ;
   double xxm ;
   double xym ;
   double yym ;
};
#line 529 "/root/patchweave_new/13/src/enc/./vp8enci.h"
typedef struct __anonstruct_156 DistoStats;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 108 "/root/patchweave_new/13/src/enc/./././backward_references.h"
struct __anonstruct_160 {
   uint8_t mode ;
   uint16_t len ;
   uint32_t argb_or_distance ;
};
#line 113 "/root/patchweave_new/13/src/enc/./././backward_references.h"
typedef struct __anonstruct_160 PixOrCopy;
#line 183 "/root/patchweave_new/13/src/enc/./././backward_references.h"
struct __anonstruct_161 {
   PixOrCopy *refs ;
   int size ;
   int max_size ;
};
#line 187 "/root/patchweave_new/13/src/enc/./././backward_references.h"
typedef struct __anonstruct_161 VP8LBackwardRefs;
#line 30 "/root/patchweave_new/13/src/enc/././histogram.h"
struct __anonstruct_162 {
   int literal_[792] ;
   int red_[256] ;
   int blue_[256] ;
   int alpha_[256] ;
   int distance_[40] ;
   int palette_code_bits_ ;
   double bit_cost_ ;
};
#line 41 "/root/patchweave_new/13/src/enc/././histogram.h"
typedef struct __anonstruct_162 VP8LHistogram;
#line 45 "/root/patchweave_new/13/src/enc/././histogram.h"
struct __anonstruct_163 {
   int size ;
   int max_size ;
   VP8LHistogram **histograms ;
};
#line 49 "/root/patchweave_new/13/src/enc/././histogram.h"
typedef struct __anonstruct_163 VP8LHistogramSet;
#line 24 "/root/patchweave_new/13/src/enc/./vp8li.h"
struct __anonstruct_164 {
   WebPConfig *config_ ;
   WebPPicture *pic_ ;
   uint32_t *argb_ ;
   uint32_t *argb_scratch_ ;
   uint32_t *transform_data_ ;
   int current_width_ ;
   int histo_bits_ ;
   int transform_bits_ ;
   int cache_bits_ ;
   int use_cross_color_ ;
   int use_subtract_green_ ;
   int use_predict_ ;
   int use_palette_ ;
   int palette_size_ ;
   uint32_t palette_[256] ;
};
#line 46 "/root/patchweave_new/13/src/enc/./vp8li.h"
typedef struct __anonstruct_164 VP8LEncoder;
#line 23 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
struct WebPRGBABuffer ;
#line 23 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
typedef struct WebPRGBABuffer WebPRGBABuffer;
#line 24
struct WebPYUVABuffer ;
#line 24 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
typedef struct WebPYUVABuffer WebPYUVABuffer;
#line 25
struct WebPDecBuffer ;
#line 25 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
typedef struct WebPDecBuffer WebPDecBuffer;
#line 27
enum VP8StatusCode {
    VP8_STATUS_OK = 0,
    VP8_STATUS_OUT_OF_MEMORY = 1,
    VP8_STATUS_INVALID_PARAM = 2,
    VP8_STATUS_BITSTREAM_ERROR = 3,
    VP8_STATUS_UNSUPPORTED_FEATURE = 4,
    VP8_STATUS_SUSPENDED = 5,
    VP8_STATUS_USER_ABORT = 6,
    VP8_STATUS_NOT_ENOUGH_DATA = 7
} ;
#line 28
enum WEBP_CSP_MODE {
    MODE_RGB = 0,
    MODE_RGBA = 1,
    MODE_BGR = 2,
    MODE_BGRA = 3,
    MODE_ARGB = 4,
    MODE_RGBA_4444 = 5,
    MODE_RGB_565 = 6,
    MODE_rgbA = 7,
    MODE_bgrA = 8,
    MODE_Argb = 9,
    MODE_rgbA_4444 = 10,
    MODE_YUV = 11,
    MODE_YUVA = 12,
    MODE_LAST = 13
} ;
#line 30
struct WebPIDecoder ;
#line 30 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
typedef struct WebPIDecoder WebPIDecoder;
#line 31
struct WebPBitstreamFeatures ;
#line 31 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
typedef struct WebPBitstreamFeatures WebPBitstreamFeatures;
#line 32
struct WebPDecoderOptions ;
#line 32 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
typedef struct WebPDecoderOptions WebPDecoderOptions;
#line 33
struct WebPDecoderConfig ;
#line 33 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
typedef struct WebPDecoderConfig WebPDecoderConfig;
#line 141
enum WEBP_CSP_MODE___0 {
    MODE_RGB___0 = 0,
    MODE_RGBA___0 = 1,
    MODE_BGR___0 = 2,
    MODE_BGRA___0 = 3,
    MODE_ARGB___0 = 4,
    MODE_RGBA_4444___0 = 5,
    MODE_RGB_565___0 = 6,
    MODE_rgbA___0 = 7,
    MODE_bgrA___0 = 8,
    MODE_Argb___0 = 9,
    MODE_rgbA_4444___0 = 10,
    MODE_YUV___0 = 11,
    MODE_YUVA___0 = 12,
    MODE_LAST___0 = 13
} ;
#line 175 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
struct WebPRGBABuffer {
   uint8_t *rgba ;
   int stride ;
   size_t size ;
};
#line 181 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
struct WebPYUVABuffer {
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   uint8_t *a ;
   int y_stride ;
   int u_stride ;
   int v_stride ;
   int a_stride ;
   size_t y_size ;
   size_t u_size ;
   size_t v_size ;
   size_t a_size ;
};
#line 196 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
union __anonunion_223 {
   WebPRGBABuffer RGBA ;
   WebPYUVABuffer YUVA ;
};
#line 192 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
struct WebPDecBuffer {
   enum WEBP_CSP_MODE___0 colorspace ;
   int width ;
   int height ;
   int is_external_memory ;
   union __anonunion_223 u ;
   uint32_t pad[4] ;
   uint8_t *private_memory ;
};
#line 223
enum VP8StatusCode___0 {
    VP8_STATUS_OK___0 = 0,
    VP8_STATUS_OUT_OF_MEMORY___0 = 1,
    VP8_STATUS_INVALID_PARAM___0 = 2,
    VP8_STATUS_BITSTREAM_ERROR___0 = 3,
    VP8_STATUS_UNSUPPORTED_FEATURE___0 = 4,
    VP8_STATUS_SUSPENDED___0 = 5,
    VP8_STATUS_USER_ABORT___0 = 6,
    VP8_STATUS_NOT_ENOUGH_DATA___0 = 7
} ;
#line 400 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
struct WebPBitstreamFeatures {
   int width ;
   int height ;
   int has_alpha ;
   int has_animation ;
   int bitstream_version ;
   int no_incremental_decoding ;
   int rotate ;
   int uv_sampling ;
   uint32_t pad[2] ;
};
#line 432 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
struct WebPDecoderOptions {
   int bypass_filtering ;
   int no_fancy_upsampling ;
   int use_cropping ;
   int crop_left ;
   int crop_top ;
   int crop_width ;
   int crop_height ;
   int use_scaling ;
   int scaled_width ;
   int scaled_height ;
   int use_threads ;
   int force_rotation ;
   int no_enhancement ;
   uint32_t pad[6] ;
};
#line 450 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
struct WebPDecoderConfig {
   WebPBitstreamFeatures input ;
   WebPDecBuffer output ;
   WebPDecoderOptions options ;
};
#line 26 "/root/patchweave_new/13/src/enc/../dsp/lossless.h"
struct VP8LTransform ;
#line 33 "/root/patchweave_new/13/src/enc/token.c"
struct VP8Tokens {
   uint16_t tokens_[8192] ;
   VP8Tokens *next_ ;
};
#line 458 "/root/patchweave_new/13/src/enc/quant.c"
struct __anonstruct_395 {
   int prev ;
   int level ;
   int sign ;
   score_t cost ;
   score_t error ;
   int ctx ;
};
#line 465 "/root/patchweave_new/13/src/enc/quant.c"
typedef struct __anonstruct_395 Node;
#line 40 "/root/patchweave_new/13/src/enc/../dsp/../dec/decode_vp8.h"
struct VP8Io ;
#line 40 "/root/patchweave_new/13/src/enc/../dsp/../dec/decode_vp8.h"
typedef struct VP8Io VP8Io;
#line 45 "/root/patchweave_new/13/src/enc/../dsp/../dec/decode_vp8.h"
struct VP8Io {
   int width ;
   int height ;
   int mb_y ;
   int mb_w ;
   int mb_h ;
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   int y_stride ;
   int uv_stride ;
   void *opaque ;
   int (*put)(VP8Io * ) ;
   int (*setup)(VP8Io * ) ;
   void (*teardown)(VP8Io * ) ;
   int fancy_upsampling ;
   size_t data_size ;
   uint8_t *data ;
   int bypass_filtering ;
   int use_cropping ;
   int crop_left ;
   int crop_right ;
   int crop_top ;
   int crop_bottom ;
   int use_scaling ;
   int scaled_width ;
   int scaled_height ;
   uint8_t *a ;
};
#line 121
struct VP8Decoder ;
#line 121 "/root/patchweave_new/13/src/enc/../dsp/../dec/decode_vp8.h"
typedef struct VP8Decoder VP8Decoder;
#line 29 "/root/patchweave_new/13/src/enc/picture.c"
union __anonunion_431 {
   uint32_t argb ;
   uint8_t bytes[4] ;
};
#line 29 "/root/patchweave_new/13/src/enc/frame.c"
struct __anonstruct_493 {
   int first ;
   int last ;
   int16_t *coeffs ;
   int coeff_type ;
   ProbaArray *prob ;
   StatsArray *stats ;
   CostArray *cost ;
};
#line 38 "/root/patchweave_new/13/src/enc/frame.c"
typedef struct __anonstruct_493 VP8Residual;
#line 34 "/root/patchweave_new/13/src/enc/backward_references.c"
struct __anonstruct_516 {
   int32_t hash_to_first_index_[262144] ;
   int32_t *chain_ ;
};
#line 40 "/root/patchweave_new/13/src/enc/backward_references.c"
typedef struct __anonstruct_516 HashChain;
#line 376 "/root/patchweave_new/13/src/enc/backward_references.c"
struct __anonstruct_517 {
   double alpha_[256] ;
   double red_[256] ;
   double literal_[792] ;
   double blue_[256] ;
   double distance_[40] ;
};
#line 382 "/root/patchweave_new/13/src/enc/backward_references.c"
typedef struct __anonstruct_517 CostModel;
#line 42 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __m64;
#line 48 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v2si;
#line 49 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v4hi;
#line 50 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
typedef int __v8qi;
#line 37 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
enum _mm_hint {
    _MM_HINT_ET0 = 7,
    _MM_HINT_ET1 = 6,
    _MM_HINT_T0 = 3,
    _MM_HINT_T1 = 2,
    _MM_HINT_T2 = 1,
    _MM_HINT_NTA = 0
} ;
#line 69 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __m128;
#line 72 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __m128_u;
#line 75 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
typedef int __v4sf;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2df;
#line 41 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2di;
#line 42 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v2du;
#line 43 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v4si;
#line 44 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v4su;
#line 45 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v8hi;
#line 46 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v8hu;
#line 47 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v16qi;
#line 49 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __v16qu;
#line 53 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128i;
#line 54 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128d;
#line 57 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128i_u;
#line 58 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
typedef int __m128d_u;
#line 25 "/root/patchweave_new/13/src/dsp/../dec/./webpi.h"
struct WebPDecParams ;
#line 25 "/root/patchweave_new/13/src/dsp/../dec/./webpi.h"
typedef struct WebPDecParams WebPDecParams;
#line 29 "/root/patchweave_new/13/src/dsp/../dec/./webpi.h"
struct WebPDecParams {
   WebPDecBuffer *output ;
   uint8_t *tmp_y ;
   uint8_t *tmp_u ;
   uint8_t *tmp_v ;
   int last_y ;
   WebPDecoderOptions *options ;
   WebPRescaler scaler_y ;
   WebPRescaler scaler_u ;
   WebPRescaler scaler_v ;
   WebPRescaler scaler_a ;
   void *memory ;
   int (*emit)(VP8Io * const   , WebPDecParams * const   ) ;
   int (*emit_alpha)(VP8Io * const   , WebPDecParams * const   ) ;
   int (*emit_alpha_row)(WebPDecParams * const   , int  ) ;
};
#line 52 "/root/patchweave_new/13/src/dsp/../dec/./webpi.h"
struct __anonstruct_598 {
   uint8_t *data ;
   size_t data_size ;
   size_t offset ;
   uint8_t *alpha_data ;
   size_t alpha_data_size ;
   size_t compressed_size ;
   size_t riff_size ;
   int is_lossless ;
};
#line 61 "/root/patchweave_new/13/src/dsp/../dec/./webpi.h"
typedef struct __anonstruct_598 WebPHeaderStructure;
#line 27 "/root/patchweave_new/13/src/dsp/../dec/vp8li.h"
enum __anonenum__603 {
    READ_DATA = 0,
    READ_HDR = 1,
    READ_DIM = 2
} ;
#line 31 "/root/patchweave_new/13/src/dsp/../dec/vp8li.h"
typedef enum __anonenum__603 VP8LDecodeState;
#line 33 "/root/patchweave_new/13/src/dsp/../dec/vp8li.h"
typedef struct VP8LTransform VP8LTransform;
#line 34 "/root/patchweave_new/13/src/dsp/../dec/vp8li.h"
struct VP8LTransform {
   VP8LImageTransformType type_ ;
   int bits_ ;
   int xsize_ ;
   int ysize_ ;
   uint32_t *data_ ;
};
#line 42 "/root/patchweave_new/13/src/dsp/../dec/vp8li.h"
struct __anonstruct_604 {
   HuffmanTree___0 htrees_[5] ;
};
#line 44 "/root/patchweave_new/13/src/dsp/../dec/vp8li.h"
typedef struct __anonstruct_604 HTreeGroup;
#line 46 "/root/patchweave_new/13/src/dsp/../dec/vp8li.h"
struct __anonstruct_605 {
   int color_cache_size_ ;
   VP8LColorCache color_cache_ ;
   int huffman_mask_ ;
   int huffman_subsample_bits_ ;
   int huffman_xsize_ ;
   uint32_t *huffman_image_ ;
   int num_htree_groups_ ;
   HTreeGroup *htree_groups_ ;
};
#line 56 "/root/patchweave_new/13/src/dsp/../dec/vp8li.h"
typedef struct __anonstruct_605 VP8LMetadata;
#line 58 "/root/patchweave_new/13/src/dsp/../dec/vp8li.h"
struct __anonstruct_606 {
   enum VP8StatusCode status_ ;
   VP8LDecodeState action_ ;
   VP8LDecodeState state_ ;
   VP8Io *io_ ;
   WebPDecBuffer *output_ ;
   uint32_t *argb_ ;
   uint32_t *argb_cache_ ;
   VP8LBitReader br_ ;
   int width_ ;
   int height_ ;
   int last_row_ ;
   int last_out_row_ ;
   VP8LMetadata hdr_ ;
   int next_transform_ ;
   VP8LTransform transforms_[4] ;
   uint32_t transforms_seen_ ;
   uint8_t *rescaler_memory ;
   WebPRescaler *rescaler ;
};
#line 85 "/root/patchweave_new/13/src/dsp/../dec/vp8li.h"
typedef struct __anonstruct_606 VP8LDecoder;
#line 462 "/root/patchweave_new/13/src/dsp/lossless.c"
typedef uint32_t (*PredictorFunc)(uint32_t  , uint32_t * const   );
#line 770 "/root/patchweave_new/13/src/dsp/lossless.c"
struct __anonstruct_608 {
   uint8_t green_to_red_ ;
   uint8_t green_to_blue_ ;
   uint8_t red_to_blue_ ;
};
#line 776 "/root/patchweave_new/13/src/dsp/lossless.c"
typedef struct __anonstruct_608 Multipliers;
#line 1175 "/root/patchweave_new/13/src/dsp/lossless.c"
union __anonunion_609 {
   uint16_t w ;
   uint8_t b[2] ;
};
#line 104 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
struct __anonstruct_733 {
   uint8_t key_frame_ ;
   uint8_t profile_ ;
   uint8_t show_ ;
   uint32_t partition_length_ ;
};
#line 109 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_733 VP8FrameHeader;
#line 111 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
struct __anonstruct_734 {
   uint16_t width_ ;
   uint16_t height_ ;
   uint8_t xscale_ ;
   uint8_t yscale_ ;
   uint8_t colorspace_ ;
   uint8_t clamp_type_ ;
};
#line 118 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_734 VP8PictureHeader;
#line 121 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
struct __anonstruct_735 {
   int use_segment_ ;
   int update_map_ ;
   int absolute_delta_ ;
   int8_t quantizer_[4] ;
   int8_t filter_strength_[4] ;
};
#line 127 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_735 VP8SegmentHeader___0;
#line 130 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
struct __anonstruct_736 {
   uint8_t segments_[3] ;
   uint8_t coeffs_[4][8][3][11] ;
};
#line 138 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_736 VP8Proba___0;
#line 141 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
struct __anonstruct_737 {
   int simple_ ;
   int level_ ;
   int sharpness_ ;
   int use_lf_delta_ ;
   int ref_lf_delta_[4] ;
   int mode_lf_delta_[4] ;
};
#line 148 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_737 VP8FilterHeader___0;
#line 153 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
struct __anonstruct_738 {
   unsigned int f_level_ ;
   unsigned int f_ilevel_ ;
   unsigned int f_inner_ ;
};
#line 157 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_738 VP8FInfo;
#line 159 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
struct __anonstruct_739 {
   unsigned int nz_ ;
   unsigned int dc_nz_ ;
   unsigned int skip_ ;
};
#line 163 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_739 VP8MB;
#line 166 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
typedef int quant_t[2];
#line 167 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
struct __anonstruct_740 {
   quant_t y1_mat_ ;
   quant_t y2_mat_ ;
   quant_t uv_mat_ ;
};
#line 169 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_740 VP8QuantMatrix;
#line 172 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
struct __anonstruct_741 {
   int id_ ;
   int mb_y_ ;
   int filter_row_ ;
   VP8FInfo *f_info_ ;
   VP8Io io_ ;
};
#line 178 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_741 VP8ThreadContext;
#line 183 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
struct VP8Decoder {
   enum VP8StatusCode status_ ;
   int ready_ ;
   char const   *error_msg_ ;
   VP8BitReader br_ ;
   VP8FrameHeader frm_hdr_ ;
   VP8PictureHeader pic_hdr_ ;
   VP8FilterHeader___0 filter_hdr_ ;
   VP8SegmentHeader___0 segment_hdr_ ;
   WebPWorker worker_ ;
   int use_threads_ ;
   int cache_id_ ;
   int num_caches_ ;
   VP8ThreadContext thread_ctx_ ;
   int mb_w_ ;
   int mb_h_ ;
   int tl_mb_x_ ;
   int tl_mb_y_ ;
   int br_mb_x_ ;
   int br_mb_y_ ;
   int num_parts_ ;
   VP8BitReader parts_[8] ;
   uint32_t buffer_flags_ ;
   VP8QuantMatrix dqm_[4] ;
   VP8Proba___0 proba_ ;
   int use_skip_proba_ ;
   uint8_t skip_p_ ;
   uint8_t *intra_t_ ;
   uint8_t intra_l_[4] ;
   uint8_t *y_t_ ;
   uint8_t *u_t_ ;
   uint8_t *v_t_ ;
   VP8MB *mb_info_ ;
   VP8FInfo *f_info_ ;
   uint8_t *yuv_b_ ;
   int16_t *coeffs_ ;
   uint8_t *cache_y_ ;
   uint8_t *cache_u_ ;
   uint8_t *cache_v_ ;
   int cache_y_stride_ ;
   int cache_uv_stride_ ;
   void *mem_ ;
   size_t mem_size_ ;
   int mb_x_ ;
   int mb_y_ ;
   uint8_t is_i4x4_ ;
   uint8_t imodes_[16] ;
   uint8_t uvmode_ ;
   uint8_t segment_ ;
   uint32_t non_zero_ ;
   uint32_t non_zero_ac_ ;
   int filter_type_ ;
   int filter_row_ ;
   VP8FInfo fstrengths_[4][2] ;
   uint8_t *alpha_data_ ;
   size_t alpha_data_size_ ;
   int is_alpha_decoded_ ;
   uint8_t *alpha_plane_ ;
   int layer_colorspace_ ;
   uint8_t *layer_data_ ;
   size_t layer_data_size_ ;
};
#line 462 "/root/patchweave_new/13/src/dec/vp8.c"
typedef uint8_t (*ProbaArray___0)[3][11];
#line 463 "/root/patchweave_new/13/src/dec/vp8.c"
typedef uint8_t (*ProbaCtxArray)[11];
#line 529 "/root/patchweave_new/13/src/dec/vp8.c"
union __anonunion_865 {
   uint8_t i8[4] ;
   uint32_t i32 ;
};
#line 532 "/root/patchweave_new/13/src/dec/vp8.c"
typedef union __anonunion_865 PackedNz;
#line 34 "/root/patchweave_new/13/src/dec/idec.c"
enum __anonenum__994 {
    STATE_PRE_VP8 = 0,
    STATE_VP8_FRAME_HEADER = 1,
    STATE_VP8_PARTS0 = 2,
    STATE_VP8_DATA = 3,
    STATE_VP8L_HEADER = 4,
    STATE_VP8L_DATA = 5,
    STATE_DONE = 6,
    STATE_ERROR = 7
} ;
#line 43 "/root/patchweave_new/13/src/dec/idec.c"
typedef enum __anonenum__994 DecState;
#line 46
enum __anonenum__995 {
    MEM_MODE_NONE = 0,
    MEM_MODE_APPEND = 1,
    MEM_MODE_MAP = 2
} ;
#line 50 "/root/patchweave_new/13/src/dec/idec.c"
typedef enum __anonenum__995 MemBufferMode;
#line 53 "/root/patchweave_new/13/src/dec/idec.c"
struct __anonstruct_996 {
   MemBufferMode mode_ ;
   size_t start_ ;
   size_t end_ ;
   size_t buf_size_ ;
   uint8_t *buf_ ;
   size_t part0_size_ ;
   uint8_t *part0_buf_ ;
};
#line 62 "/root/patchweave_new/13/src/dec/idec.c"
typedef struct __anonstruct_996 MemBuffer;
#line 64 "/root/patchweave_new/13/src/dec/idec.c"
struct WebPIDecoder {
   DecState state_ ;
   WebPDecParams params_ ;
   int is_lossless_ ;
   void *dec_ ;
   VP8Io io_ ;
   MemBuffer mem_ ;
   WebPDecBuffer output_ ;
   size_t chunk_size_ ;
};
#line 77 "/root/patchweave_new/13/src/dec/idec.c"
struct __anonstruct_997 {
   VP8MB left_ ;
   VP8MB info_ ;
   uint8_t intra_t_[4] ;
   uint8_t intra_l_[4] ;
   VP8BitReader br_ ;
   VP8BitReader token_br_ ;
};
#line 84 "/root/patchweave_new/13/src/dec/idec.c"
typedef struct __anonstruct_997 MBContext;
#line 17 "/root/patchweave_new/13/examples/./wicdec.h"
struct Metadata ;
#line 70 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned short uint16;
#line 73 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned int uint32;
#line 76 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned long uint64;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct tiff ;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct tiff TIFF;
#line 65 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef long tmsize_t;
#line 66 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint64 toff_t;
#line 69 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 ttag_t;
#line 70 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint16 tdir_t;
#line 20 "/root/patchweave_new/13/examples/./metadata.h"
struct MetadataPayload {
   uint8_t *bytes ;
   size_t size ;
};
#line 23 "/root/patchweave_new/13/examples/./metadata.h"
typedef struct MetadataPayload MetadataPayload;
#line 25 "/root/patchweave_new/13/examples/./metadata.h"
struct Metadata {
   MetadataPayload exif ;
   MetadataPayload iccp ;
   MetadataPayload xmp ;
};
#line 29 "/root/patchweave_new/13/examples/./metadata.h"
typedef struct Metadata Metadata;
#line 24 "/root/patchweave_new/13/examples/tiffdec.c"
struct __anonstruct_1014 {
   ttag_t tag ;
   size_t storage_offset ;
};
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 481 "/usr/include/libpng16/pngconf.h"
typedef unsigned char png_byte;
#line 511 "/usr/include/libpng16/pngconf.h"
typedef unsigned int png_uint_32;
#line 523 "/usr/include/libpng16/pngconf.h"
typedef size_t png_size_t;
#line 577 "/usr/include/libpng16/pngconf.h"
typedef void *png_voidp;
#line 579 "/usr/include/libpng16/pngconf.h"
typedef png_byte *png_bytep;
#line 589 "/usr/include/libpng16/pngconf.h"
typedef char *png_charp;
#line 590 "/usr/include/libpng16/pngconf.h"
typedef char const   *png_const_charp;
#line 597 "/usr/include/libpng16/pngconf.h"
typedef FILE *png_FILE_p;
#line 606 "/usr/include/libpng16/pngconf.h"
typedef png_byte **png_bytepp;
#line 612 "/usr/include/libpng16/pngconf.h"
typedef char **png_charpp;
#line 454 "/usr/include/libpng16/png.h"
struct png_struct_def ;
#line 454 "/usr/include/libpng16/png.h"
typedef struct png_struct_def png_struct;
#line 456 "/usr/include/libpng16/png.h"
typedef png_struct *png_structp;
#line 457 "/usr/include/libpng16/png.h"
typedef png_struct **png_structpp;
#line 468
struct png_info_def ;
#line 468 "/usr/include/libpng16/png.h"
typedef struct png_info_def png_info;
#line 469 "/usr/include/libpng16/png.h"
typedef png_info *png_infop;
#line 471 "/usr/include/libpng16/png.h"
typedef png_info **png_infopp;
#line 484 "/usr/include/libpng16/png.h"
typedef png_struct *png_structrp;
#line 485 "/usr/include/libpng16/png.h"
typedef png_struct *png_const_structrp;
#line 486 "/usr/include/libpng16/png.h"
typedef png_info *png_inforp;
#line 487 "/usr/include/libpng16/png.h"
typedef png_info *png_const_inforp;
#line 577 "/usr/include/libpng16/png.h"
struct png_text_struct {
   int compression ;
   png_charp key ;
   png_charp text ;
   size_t text_length ;
   size_t itxt_length ;
   png_charp lang ;
   png_charp lang_key ;
};
#line 593 "/usr/include/libpng16/png.h"
typedef struct png_text_struct png_text;
#line 594 "/usr/include/libpng16/png.h"
typedef png_text *png_textp;
#line 101 "/root/patchweave_new/13/examples/pngdec.c"
struct __anonstruct_1036 {
   char const   *name ;
   int (*process)(char const   * , size_t  , MetadataPayload * const   ) ;
   size_t storage_offset ;
};
#line 51 "/usr/include/jmorecfg.h"
typedef unsigned char JSAMPLE;
#line 91 "/usr/include/jmorecfg.h"
typedef short JCOEF;
#line 102 "/usr/include/jmorecfg.h"
typedef unsigned char JOCTET;
#line 127 "/usr/include/jmorecfg.h"
typedef unsigned char UINT8;
#line 139 "/usr/include/jmorecfg.h"
typedef unsigned short UINT16;
#line 194 "/usr/include/jmorecfg.h"
typedef unsigned int JDIMENSION;
#line 242 "/usr/include/jmorecfg.h"
typedef int boolean;
#line 69 "/usr/include/jpeglib.h"
typedef JSAMPLE *JSAMPROW;
#line 70 "/usr/include/jpeglib.h"
typedef JSAMPROW *JSAMPARRAY;
#line 73 "/usr/include/jpeglib.h"
typedef JCOEF JBLOCK[64];
#line 74 "/usr/include/jpeglib.h"
typedef JBLOCK *JBLOCKROW;
#line 75 "/usr/include/jpeglib.h"
typedef JBLOCKROW *JBLOCKARRAY;
#line 86 "/usr/include/jpeglib.h"
struct __anonstruct_1038 {
   UINT16 quantval[64] ;
   boolean sent_table ;
};
#line 98 "/usr/include/jpeglib.h"
typedef struct __anonstruct_1038 JQUANT_TBL;
#line 103 "/usr/include/jpeglib.h"
struct __anonstruct_1039 {
   UINT8 bits[17] ;
   UINT8 huffval[256] ;
   boolean sent_table ;
};
#line 114 "/usr/include/jpeglib.h"
typedef struct __anonstruct_1039 JHUFF_TBL;
#line 119 "/usr/include/jpeglib.h"
struct __anonstruct_1040 {
   int component_id ;
   int component_index ;
   int h_samp_factor ;
   int v_samp_factor ;
   int quant_tbl_no ;
   int dc_tbl_no ;
   int ac_tbl_no ;
   JDIMENSION width_in_blocks ;
   JDIMENSION height_in_blocks ;
   int DCT_h_scaled_size ;
   int DCT_v_scaled_size ;
   JDIMENSION downsampled_width ;
   JDIMENSION downsampled_height ;
   boolean component_needed ;
   int MCU_width ;
   int MCU_height ;
   int MCU_blocks ;
   int MCU_sample_width ;
   int last_col_width ;
   int last_row_height ;
   JQUANT_TBL *quant_table ;
   void *dct_table ;
};
#line 187 "/usr/include/jpeglib.h"
typedef struct __anonstruct_1040 jpeg_component_info;
#line 201
struct jpeg_marker_struct ;
#line 201 "/usr/include/jpeglib.h"
typedef struct jpeg_marker_struct *jpeg_saved_marker_ptr;
#line 203 "/usr/include/jpeglib.h"
struct jpeg_marker_struct {
   jpeg_saved_marker_ptr next ;
   UINT8 marker ;
   unsigned int original_length ;
   unsigned int data_length ;
   JOCTET *data ;
};
#line 217
enum __anonenum__1042 {
    JCS_UNKNOWN = 0,
    JCS_GRAYSCALE = 1,
    JCS_RGB = 2,
    JCS_YCbCr = 3,
    JCS_CMYK = 4,
    JCS_YCCK = 5,
    JCS_EXT_RGB = 6,
    JCS_EXT_RGBX = 7,
    JCS_EXT_BGR = 8,
    JCS_EXT_BGRX = 9,
    JCS_EXT_XBGR = 10,
    JCS_EXT_XRGB = 11,
    JCS_EXT_RGBA = 12,
    JCS_EXT_BGRA = 13,
    JCS_EXT_ABGR = 14,
    JCS_EXT_ARGB = 15,
    JCS_RGB565 = 16
} ;
#line 242 "/usr/include/jpeglib.h"
typedef enum __anonenum__1042 J_COLOR_SPACE;
#line 246
enum __anonenum__1043 {
    JDCT_ISLOW = 0,
    JDCT_IFAST = 1,
    JDCT_FLOAT = 2
} ;
#line 250 "/usr/include/jpeglib.h"
typedef enum __anonenum__1043 J_DCT_METHOD;
#line 261
enum __anonenum__1044 {
    JDITHER_NONE = 0,
    JDITHER_ORDERED = 1,
    JDITHER_FS = 2
} ;
#line 265 "/usr/include/jpeglib.h"
typedef enum __anonenum__1044 J_DITHER_MODE;
#line 283
struct jpeg_error_mgr ;
#line 283
struct jpeg_memory_mgr ;
#line 283
struct jpeg_progress_mgr ;
#line 282 "/usr/include/jpeglib.h"
struct jpeg_common_struct {
   struct jpeg_error_mgr *err ;
   struct jpeg_memory_mgr *mem ;
   struct jpeg_progress_mgr *progress ;
   void *client_data ;
   boolean is_decompressor ;
   int global_state ;
};
#line 290 "/usr/include/jpeglib.h"
typedef struct jpeg_common_struct *j_common_ptr;
#line 292
struct jpeg_decompress_struct ;
#line 292 "/usr/include/jpeglib.h"
typedef struct jpeg_decompress_struct *j_decompress_ptr;
#line 476
struct jpeg_source_mgr ;
#line 696
struct jpeg_decomp_master ;
#line 697
struct jpeg_d_main_controller ;
#line 698
struct jpeg_d_coef_controller ;
#line 699
struct jpeg_d_post_controller ;
#line 700
struct jpeg_input_controller ;
#line 701
struct jpeg_marker_reader ;
#line 702
struct jpeg_entropy_decoder ;
#line 703
struct jpeg_inverse_dct ;
#line 704
struct jpeg_upsampler ;
#line 705
struct jpeg_color_deconverter ;
#line 706
struct jpeg_color_quantizer ;
#line 472 "/usr/include/jpeglib.h"
struct jpeg_decompress_struct {
   struct jpeg_error_mgr *err ;
   struct jpeg_memory_mgr *mem ;
   struct jpeg_progress_mgr *progress ;
   void *client_data ;
   boolean is_decompressor ;
   int global_state ;
   struct jpeg_source_mgr *src ;
   JDIMENSION image_width ;
   JDIMENSION image_height ;
   int num_components ;
   J_COLOR_SPACE jpeg_color_space ;
   J_COLOR_SPACE out_color_space ;
   unsigned int scale_num ;
   unsigned int scale_denom ;
   double output_gamma ;
   boolean buffered_image ;
   boolean raw_data_out ;
   J_DCT_METHOD dct_method ;
   boolean do_fancy_upsampling ;
   boolean do_block_smoothing ;
   boolean quantize_colors ;
   J_DITHER_MODE dither_mode ;
   boolean two_pass_quantize ;
   int desired_number_of_colors ;
   boolean enable_1pass_quant ;
   boolean enable_external_quant ;
   boolean enable_2pass_quant ;
   JDIMENSION output_width ;
   JDIMENSION output_height ;
   int out_color_components ;
   int output_components ;
   int rec_outbuf_height ;
   int actual_number_of_colors ;
   JSAMPARRAY colormap ;
   JDIMENSION output_scanline ;
   int input_scan_number ;
   JDIMENSION input_iMCU_row ;
   int output_scan_number ;
   JDIMENSION output_iMCU_row ;
   int (*coef_bits)[64] ;
   JQUANT_TBL *quant_tbl_ptrs[4] ;
   JHUFF_TBL *dc_huff_tbl_ptrs[4] ;
   JHUFF_TBL *ac_huff_tbl_ptrs[4] ;
   int data_precision ;
   jpeg_component_info *comp_info ;
   boolean is_baseline ;
   boolean progressive_mode ;
   boolean arith_code ;
   UINT8 arith_dc_L[16] ;
   UINT8 arith_dc_U[16] ;
   UINT8 arith_ac_K[16] ;
   unsigned int restart_interval ;
   boolean saw_JFIF_marker ;
   UINT8 JFIF_major_version ;
   UINT8 JFIF_minor_version ;
   UINT8 density_unit ;
   UINT16 X_density ;
   UINT16 Y_density ;
   boolean saw_Adobe_marker ;
   UINT8 Adobe_transform ;
   boolean CCIR601_sampling ;
   jpeg_saved_marker_ptr marker_list ;
   int max_h_samp_factor ;
   int max_v_samp_factor ;
   int min_DCT_h_scaled_size ;
   int min_DCT_v_scaled_size ;
   JDIMENSION total_iMCU_rows ;
   JSAMPLE *sample_range_limit ;
   int comps_in_scan ;
   jpeg_component_info *cur_comp_info[4] ;
   JDIMENSION MCUs_per_row ;
   JDIMENSION MCU_rows_in_scan ;
   int blocks_in_MCU ;
   int MCU_membership[10] ;
   int Ss ;
   int Se ;
   int Ah ;
   int Al ;
   int block_size ;
   int const   *natural_order ;
   int lim_Se ;
   int unread_marker ;
   struct jpeg_decomp_master *master ;
   struct jpeg_d_main_controller *main ;
   struct jpeg_d_coef_controller *coef ;
   struct jpeg_d_post_controller *post ;
   struct jpeg_input_controller *inputctl ;
   struct jpeg_marker_reader *marker ;
   struct jpeg_entropy_decoder *entropy ;
   struct jpeg_inverse_dct *idct ;
   struct jpeg_upsampler *upsample ;
   struct jpeg_color_deconverter *cconvert ;
   struct jpeg_color_quantizer *cquantize ;
};
#line 738 "/usr/include/jpeglib.h"
union __anonunion_1045 {
   int i[8] ;
   char s[80] ;
};
#line 720 "/usr/include/jpeglib.h"
struct jpeg_error_mgr {
   void (*error_exit)(j_common_ptr  ) ;
   void (*emit_message)(j_common_ptr  , int  ) ;
   void (*output_message)(j_common_ptr  ) ;
   void (*format_message)(j_common_ptr  , char * ) ;
   void (*reset_error_mgr)(j_common_ptr  ) ;
   int msg_code ;
   union __anonunion_1045 msg_parm ;
   int trace_level ;
   long num_warnings ;
   char const   * const  *jpeg_message_table ;
   int last_jpeg_message ;
   char const   * const  *addon_message_table ;
   int first_addon_message ;
   int last_addon_message ;
};
#line 778 "/usr/include/jpeglib.h"
struct jpeg_progress_mgr {
   void (*progress_monitor)(j_common_ptr  ) ;
   long pass_counter ;
   long pass_limit ;
   int completed_passes ;
   int total_passes ;
};
#line 802 "/usr/include/jpeglib.h"
struct jpeg_source_mgr {
   JOCTET *next_input_byte ;
   size_t bytes_in_buffer ;
   void (*init_source)(j_decompress_ptr  ) ;
   boolean (*fill_input_buffer)(j_decompress_ptr  ) ;
   void (*skip_input_data)(j_decompress_ptr  , long  ) ;
   boolean (*resync_to_restart)(j_decompress_ptr  , int  ) ;
   void (*term_source)(j_decompress_ptr  ) ;
};
#line 829
struct jvirt_sarray_control ;
#line 829 "/usr/include/jpeglib.h"
typedef struct jvirt_sarray_control *jvirt_sarray_ptr;
#line 830
struct jvirt_barray_control ;
#line 830 "/usr/include/jpeglib.h"
typedef struct jvirt_barray_control *jvirt_barray_ptr;
#line 833 "/usr/include/jpeglib.h"
struct jpeg_memory_mgr {
   void *(*alloc_small)(j_common_ptr  , int  , size_t  ) ;
   void *(*alloc_large)(j_common_ptr  , int  , size_t  ) ;
   JSAMPARRAY (*alloc_sarray)(j_common_ptr  , int  , JDIMENSION  , JDIMENSION  ) ;
   JBLOCKARRAY (*alloc_barray)(j_common_ptr  , int  , JDIMENSION  , JDIMENSION  ) ;
   jvirt_sarray_ptr (*request_virt_sarray)(j_common_ptr  , int  , boolean  , JDIMENSION  ,
                                           JDIMENSION  , JDIMENSION  ) ;
   jvirt_barray_ptr (*request_virt_barray)(j_common_ptr  , int  , boolean  , JDIMENSION  ,
                                           JDIMENSION  , JDIMENSION  ) ;
   void (*realize_virt_arrays)(j_common_ptr  ) ;
   JSAMPARRAY (*access_virt_sarray)(j_common_ptr  , jvirt_sarray_ptr  , JDIMENSION  ,
                                    JDIMENSION  , boolean  ) ;
   JBLOCKARRAY (*access_virt_barray)(j_common_ptr  , jvirt_barray_ptr  , JDIMENSION  ,
                                     JDIMENSION  , boolean  ) ;
   void (*free_pool)(j_common_ptr  , int  ) ;
   void (*self_destruct)(j_common_ptr  ) ;
   long max_memory_to_use ;
   long max_alloc_chunk ;
};
#line 37 "/root/patchweave_new/13/examples/jpegdec.c"
struct __anonstruct_1063 {
   uint8_t *data ;
   size_t data_length ;
   int seq ;
};
#line 41 "/root/patchweave_new/13/examples/jpegdec.c"
typedef struct __anonstruct_1063 ICCPSegment;
#line 198 "/root/patchweave_new/13/examples/jpegdec.c"
struct my_error_mgr {
   struct jpeg_error_mgr pub ;
   jmp_buf setjmp_buffer ;
};
#line 148 "/root/patchweave_new/13/examples/jpegdec.c"
struct __anonstruct_1064 {
   int marker ;
   char const   *signature ;
   size_t signature_length ;
   size_t storage_offset ;
};
#line 36 "/root/patchweave_new/13/examples/./stopwatch.h"
typedef struct timeval Stopwatch;
#line 103 "/root/patchweave_new/13/examples/cwebp.c"
enum __anonenum__1083 {
    PNG_ = 0,
    JPEG_ = 1,
    TIFF_ = 2,
    UNSUPPORTED = 3
} ;
#line 108 "/root/patchweave_new/13/examples/cwebp.c"
typedef enum __anonenum__1083 InputFileFormat;
#line 775
struct __anonstruct_1085 ;
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 820
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__gnu_inline__)) bsearch)(void const   *__key ,
                                                                 void const   *__base ,
                                                                 size_t __nmemb ,
                                                                 size_t __size , int (*__compar)(void const   * ,
                                                                                                 void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;

#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd ,
                                                                                               char *__buf ,
                                                                                               size_t __buflen ) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) ptsname_r)(int __fd , char *__buf ,
                                                                 size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size((void *)__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 68
    __cil_tmp5 = 0;
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size((void *)__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size((void *)__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size((void *)__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctomb)(char *__s ,
                                                                                            wchar_t __wchar ) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__gnu_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 92
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                                                 char const   *__src ,
                                                                                                 size_t __len ) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) mbstowcs)(wchar_t *__dst ,
                                                                   char const   *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    __cil_tmp5 = 0;
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst ,
                                                                                                 wchar_t *__src ,
                                                                                                 size_t __len ) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) wcstombs)(char *__dst , wchar_t *__src ,
                                                                   size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size((void *)__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 149
    __cil_tmp5 = 0;
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size((void *)__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size((void *)__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size((void *)__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 297 "/usr/include/inttypes.h"
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                                                    char **endptr ,
                                                                                                    int base ) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   *nptr ,
                                                                      char **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                                                     char **endptr ,
                                                                                                     int base ) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   *nptr ,
                                                                       char **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                                                    __gwchar_t **endptr ,
                                                                                                    int base ) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t *nptr ,
                                                                      __gwchar_t **endptr ,
                                                                      int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                                                     __gwchar_t **endptr ,
                                                                                                     int base ) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t *nptr ,
                                                                       __gwchar_t **endptr ,
                                                                       int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 36 "/root/patchweave_new/13/src/utils/./utils.h"
void *WebPSafeMalloc(uint64_t nmemb , size_t size ) ;
#line 39
void *WebPSafeCalloc(uint64_t nmemb , size_t size ) ;
#line 58 "/root/patchweave_new/13/src/utils/./utils.h"
__inline static void PutLE16(uint8_t *data , int val ) 
{ 


  {
#line 60
  *(data + 0) = (uint8_t )val;
#line 61
  *(data + 1) = (uint8_t )(val >> 8);
#line 62
  return;
}
}
#line 64 "/root/patchweave_new/13/src/utils/./utils.h"
__inline static void PutLE24(uint8_t *data , int val ) 
{ 


  {
  {
#line 66
  PutLE16(data, val & 65535);
#line 67
  *(data + 2) = (uint8_t )(val >> 16);
  }
#line 69
  return;
}
}
#line 70 "/root/patchweave_new/13/src/utils/./utils.h"
__inline static void PutLE32(uint8_t *data , uint32_t val ) 
{ 


  {
  {
#line 71
  PutLE16(data, (int )(val & 65535U));
#line 72
  PutLE16(data + 2, (int )(val >> 16));
  }
#line 74
  return;
}
}
#line 23 "/root/patchweave_new/13/src/utils/utils.c"
static int CheckSizeArgumentsOverflow(uint64_t nmemb , size_t size ) 
{ 
  uint64_t total_size ;

  {
#line 24
  total_size = nmemb * size;
#line 25
  if (nmemb == 0UL) {
#line 25
    return (1);
  }
#line 26
  if ((unsigned long long )size > (1ULL << 40) / (unsigned long long )nmemb) {
#line 26
    return (0);
  }
#line 27
  if (total_size != total_size) {
#line 27
    return (0);
  }
#line 28
  return (1);
}
}
#line 31 "/root/patchweave_new/13/src/utils/utils.c"
void *WebPSafeMalloc(uint64_t nmemb , size_t size ) 
{ 
  int __cil_tmp3 ;
  void *__cil_tmp5 ;

  {
  {
#line 32
  __cil_tmp3 = CheckSizeArgumentsOverflow(nmemb, size);
  }
#line 32
  if (! __cil_tmp3) {
#line 32
    return ((void *)0);
  }
  {
#line 34
  __cil_tmp5 = malloc(nmemb * size);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 37 "/root/patchweave_new/13/src/utils/utils.c"
void *WebPSafeCalloc(uint64_t nmemb , size_t size ) 
{ 
  int __cil_tmp3 ;
  void *__cil_tmp5 ;

  {
  {
#line 38
  __cil_tmp3 = CheckSizeArgumentsOverflow(nmemb, size);
  }
#line 38
  if (! __cil_tmp3) {
#line 38
    return ((void *)0);
  }
  {
#line 40
  __cil_tmp5 = calloc(nmemb, size);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 38 "/usr/include/strings.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                                                            void *__dest ,
                                                                                            size_t __len ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) bcopy)(void const   *__src ,
                                                              void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 27
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) bzero)(void *__dest ,
                                                                                            size_t __len ) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) bzero)(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
#line 33
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                                                     size_t __len ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest ,
                                                                                              void const   *__src ,
                                                                                              size_t __len ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memcpy)(void *__dest , void const   *__src ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memmove)(void *__dest ,
                                                                                               void const   *__src ,
                                                                                               size_t __len ) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memmove)(void *__dest , void const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__gnu_inline__)) memset)(void *__dest ,
                                                                                              int __ch ,
                                                                                              size_t __len ) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__gnu_inline__)) memset)(void *__dest , int __ch ,
                                                                size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
extern  __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                               size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                                                     size_t __len ) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void ( __attribute__((__gnu_inline__)) explicit_bzero)(void *__dest ,
                                                                       size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
#line 85
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcpy)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncpy)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __n ) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                                                 size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size((void *)__dest, 1);
#line 118
  __cil_tmp5 = 0;
#line 118
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void *)__dest, 1);
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strcat)(char *__dest ,
                                                                                              char const   *__src ) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strcat)(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size((void *)__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) strncat)(char *__dest ,
                                                                                               char const   *__src ,
                                                                                               size_t __len ) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__gnu_inline__)) strncat)(char *__dest , char const   *__src ,
                                                                 size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size((void *)__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 198 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 215
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 254
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 ) ;
#line 725
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 730
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 738
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 756
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 965
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 970
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 974
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 986
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 1165
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 ) ;
#line 1165 "/usr/include/pthread.h"
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
#line 1167
  return (__thread1 == __thread2);
}
}
#line 69 "/root/patchweave_new/13/src/utils/./thread.h"
void WebPWorkerInit(WebPWorker *worker ) ;
#line 72
int WebPWorkerReset(WebPWorker *worker ) ;
#line 75
int WebPWorkerSync(WebPWorker *worker ) ;
#line 79
void WebPWorkerLaunch(WebPWorker *worker ) ;
#line 82
void WebPWorkerEnd(WebPWorker *worker ) ;
#line 134 "/root/patchweave_new/13/src/utils/thread.c"
static void *WebPWorkerThreadLoop(void *ptr ) 
{ 
  WebPWorker *worker ;
  int done___0 ;
  int __cil_tmp4 ;

  {
#line 135
  worker = (WebPWorker *)ptr;
#line 136
  done___0 = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;

#line 137
    if (! (! done___0)) {
#line 137
      goto while_break;
    }
    {
#line 138
    pthread_mutex_lock(& worker->mutex_);
    }
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 139
      if (! ((unsigned int )worker->status_ == 1U)) {
#line 139
        goto while_break___0;
      }
      {
#line 140
      pthread_cond_wait(& worker->condition_, & worker->mutex_);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 142
    if ((unsigned int )worker->status_ == 2U) {
#line 143
      if (worker->hook) {
        {
#line 144
        __cil_tmp4 = (*(worker->hook))(worker->data1, worker->data2);
#line 144
        worker->had_error |= ! __cil_tmp4;
        }
      }
#line 146
      worker->status_ = (WebPWorkerStatus )1;
    } else
#line 147
    if ((unsigned int )worker->status_ == 0U) {
#line 148
      done___0 = 1;
    }
    {
#line 151
    pthread_cond_signal(& worker->condition_);
#line 152
    pthread_mutex_unlock(& worker->mutex_);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 154
  return ((void *)0);
}
}
#line 158 "/root/patchweave_new/13/src/utils/thread.c"
static void WebPWorkerChangeState(WebPWorker *worker , WebPWorkerStatus new_status ) 
{ 


  {
#line 161
  if ((unsigned int )worker->status_ < 1U) {
#line 161
    return;
  }
  {
#line 163
  pthread_mutex_lock(& worker->mutex_);
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;

#line 165
    if (! ((unsigned int )worker->status_ != 1U)) {
#line 165
      goto while_break;
    }
    {
#line 166
    pthread_cond_wait(& worker->condition_, & worker->mutex_);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 169
  if ((unsigned int )new_status != 1U) {
    {
#line 170
    worker->status_ = new_status;
#line 171
    pthread_cond_signal(& worker->condition_);
    }
  }
  {
#line 173
  pthread_mutex_unlock(& worker->mutex_);
  }
#line 175
  return;
}
}
#line 180 "/root/patchweave_new/13/src/utils/thread.c"
void WebPWorkerInit(WebPWorker *worker ) 
{ 


  {
  {
#line 181
  memset((void *)worker, 0, sizeof(*worker));
#line 182
  worker->status_ = (WebPWorkerStatus )0;
  }
#line 184
  return;
}
}
#line 185 "/root/patchweave_new/13/src/utils/thread.c"
int WebPWorkerSync(WebPWorker *worker ) 
{ 


  {
  {
#line 187
  WebPWorkerChangeState(worker, (WebPWorkerStatus )1);
  }
#line 190
  return (! worker->had_error);
}
}
#line 193 "/root/patchweave_new/13/src/utils/thread.c"
int WebPWorkerReset(WebPWorker *worker ) 
{ 
  int ok ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 194
  ok = 1;
#line 195
  worker->had_error = 0;
#line 196
  if ((unsigned int )worker->status_ < 1U) {
    {
#line 198
    __cil_tmp4 = pthread_cond_init(& worker->condition_, (pthread_condattr_t *)((void *)0));
#line 198
    __cil_tmp3 = pthread_mutex_init(& worker->mutex_, (pthread_mutexattr_t *)((void *)0));
    }
#line 198
    if (__cil_tmp3) {
#line 200
      return (0);
    } else
#line 198
    if (__cil_tmp4) {
#line 200
      return (0);
    }
    {
#line 202
    pthread_mutex_lock(& worker->mutex_);
#line 203
    __cil_tmp5 = pthread_create(& worker->thread_, (pthread_attr_t *)((void *)0),
                                & WebPWorkerThreadLoop, (void *)worker);
#line 203
    ok = ! __cil_tmp5;
    }
#line 204
    if (ok) {
#line 204
      worker->status_ = (WebPWorkerStatus )1;
    }
    {
#line 205
    pthread_mutex_unlock(& worker->mutex_);
    }
  } else
#line 209
  if ((unsigned int )worker->status_ > 1U) {
    {
#line 210
    ok = WebPWorkerSync(worker);
    }
  }
#line 213
  return (ok);
}
}
#line 216 "/root/patchweave_new/13/src/utils/thread.c"
void WebPWorkerLaunch(WebPWorker *worker ) 
{ 


  {
  {
#line 218
  WebPWorkerChangeState(worker, (WebPWorkerStatus )2);
  }
#line 220
  return;
}
}
#line 225 "/root/patchweave_new/13/src/utils/thread.c"
void WebPWorkerEnd(WebPWorker *worker ) 
{ 


  {
#line 226
  if ((unsigned int )worker->status_ >= 1U) {
    {
#line 228
    WebPWorkerChangeState(worker, (WebPWorkerStatus )0);
#line 229
    pthread_join(worker->thread_, (void **)((void *)0));
#line 230
    pthread_mutex_destroy(& worker->mutex_);
#line 231
    pthread_cond_destroy(& worker->condition_);
    }
  }
#line 234
  return;
}
}
#line 39 "/root/patchweave_new/13/src/utils/./rescaler.h"
void WebPRescalerInit(WebPRescaler *wrk , int src_width , int src_height , uint8_t *dst ,
                      int dst_width , int dst_height , int dst_stride , int num_channels ,
                      int x_add , int x_sub , int y_add , int y_sub , int32_t *work ) ;
#line 49
void WebPRescalerImportRow(WebPRescaler *wrk , uint8_t *src , int channel ) ;
#line 54
int WebPRescalerImport(WebPRescaler *wrk , int num_lines , uint8_t *src , int src_stride ) ;
#line 59 "/root/patchweave_new/13/src/utils/./rescaler.h"
__inline static int WebPRescalerHasPendingOutput(WebPRescaler *rescaler ) 
{ 


  {
#line 60
  return (rescaler->y_accum <= 0);
}
}
#line 65
uint8_t *WebPRescalerExportRow(WebPRescaler *wrk ) ;
#line 68
int WebPRescalerExport(WebPRescaler *rescaler ) ;
#line 25 "/root/patchweave_new/13/src/utils/rescaler.c"
void WebPRescalerInit(WebPRescaler *wrk , int src_width , int src_height , uint8_t *dst ,
                      int dst_width , int dst_height , int dst_stride , int num_channels ,
                      int x_add , int x_sub , int y_add , int y_sub , int32_t *work ) 
{ 
  int tmp ;
  int tmp___0 ;
  int64_t tmp___1 ;

  {
#line 29
  wrk->x_expand = src_width < dst_width;
#line 30
  wrk->src_width = src_width;
#line 31
  wrk->src_height = src_height;
#line 32
  wrk->dst_width = dst_width;
#line 33
  wrk->dst_height = dst_height;
#line 34
  wrk->dst = dst;
#line 35
  wrk->dst_stride = dst_stride;
#line 36
  wrk->num_channels = num_channels;
#line 38
  if (wrk->x_expand) {
#line 38
    tmp = x_sub - 1;
  } else {
#line 38
    tmp = x_add - x_sub;
  }
#line 38
  wrk->x_add = tmp;
#line 39
  if (wrk->x_expand) {
#line 39
    tmp___0 = x_add - 1;
  } else {
#line 39
    tmp___0 = x_sub;
  }
#line 39
  wrk->x_sub = tmp___0;
#line 40
  wrk->y_accum = y_add;
#line 41
  wrk->y_add = y_add;
#line 42
  wrk->y_sub = y_sub;
#line 43
  wrk->fx_scale = (1 << 30) / x_sub;
#line 44
  wrk->fy_scale = (1 << 30) / y_sub;
#line 45
  if (wrk->x_expand) {
#line 45
    tmp___1 = ((int64_t )dst_height << 30) / (long )(x_sub * src_height);
  } else {
#line 45
    tmp___1 = ((int64_t )dst_height << 30) / (long )(x_add * src_height);
  }
#line 45
  wrk->fxy_scale = tmp___1;
#line 48
  wrk->irow = work;
#line 49
  wrk->frow = work + num_channels * dst_width;
#line 50
  return;
}
}
#line 52 "/root/patchweave_new/13/src/utils/rescaler.c"
void WebPRescalerImportRow(WebPRescaler *wrk , uint8_t *src , int channel ) 
{ 
  int x_stride ;
  int x_out_max ;
  int x_in ;
  int x_out ;
  int accum ;
  int sum ;
  int32_t base ;
  int32_t frac ;
  int left ;
  int right ;

  {
#line 54
  x_stride = wrk->num_channels;
#line 55
  x_out_max = wrk->dst_width * wrk->num_channels;
#line 56
  x_in = channel;
#line 58
  accum = 0;
#line 59
  if (! wrk->x_expand) {
#line 60
    sum = 0;
#line 61
    x_out = channel;
    {
#line 61
    while (1) {
      while_continue: /* CIL Label */ ;

#line 61
      if (! (x_out < x_out_max)) {
#line 61
        goto while_break;
      }
#line 62
      accum += wrk->x_add;
      {
#line 63
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 63
        if (! (accum > 0)) {
#line 63
          goto while_break___0;
        }
#line 64
        sum += (int )*(src + x_in);
#line 65
        x_in += x_stride;
#line 63
        accum -= wrk->x_sub;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
#line 68
      base = (int32_t )*(src + x_in);
#line 69
      frac = base * - accum;
#line 70
      x_in += x_stride;
#line 71
      *(wrk->frow + x_out) = (sum + base) * wrk->x_sub - frac;
#line 73
      sum = (int )(((int64_t )frac * (long )wrk->fx_scale + (long )(1 << 29)) >> 30);
#line 61
      x_out += x_stride;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 77
    left = (int )*(src + channel);
#line 77
    right = (int )*(src + channel);
#line 78
    x_out = channel;
    {
#line 78
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 78
      if (! (x_out < x_out_max)) {
#line 78
        goto while_break___1;
      }
#line 79
      if (accum < 0) {
#line 80
        left = right;
#line 81
        x_in += x_stride;
#line 82
        right = (int )*(src + x_in);
#line 83
        accum += wrk->x_add;
      }
#line 85
      *(wrk->frow + x_out) = right * wrk->x_add + (left - right) * accum;
#line 86
      accum -= wrk->x_sub;
#line 78
      x_out += x_stride;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 90
  x_out = channel;
  {
#line 90
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 90
    if (! (x_out < x_out_max)) {
#line 90
      goto while_break___2;
    }
#line 91
    *(wrk->irow + x_out) += *(wrk->frow + x_out);
#line 90
    x_out += x_stride;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 94
  return;
}
}
#line 95 "/root/patchweave_new/13/src/utils/rescaler.c"
uint8_t *WebPRescalerExportRow(WebPRescaler *wrk ) 
{ 
  int x_out ;
  uint8_t *dst ;
  int32_t *irow ;
  int32_t *frow ;
  int yscale ;
  int x_out_max ;
  int frac ;
  int v ;
  int tmp ;
  int tmp___0 ;

  {
#line 96
  if (wrk->y_accum <= 0) {
#line 98
    dst = wrk->dst;
#line 99
    irow = wrk->irow;
#line 100
    frow = wrk->frow;
#line 101
    yscale = wrk->fy_scale * - wrk->y_accum;
#line 102
    x_out_max = wrk->dst_width * wrk->num_channels;
#line 104
    x_out = 0;
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;

#line 104
      if (! (x_out < x_out_max)) {
#line 104
        goto while_break;
      }
#line 105
      frac = (int )(((int64_t )*(frow + x_out) * (long )yscale + (long )(1 << 29)) >> 30);
#line 106
      v = (int )(((int64_t )(*(irow + x_out) - frac) * wrk->fxy_scale + (long )(1 << 29)) >> 30);
#line 107
      if (! (v & -256)) {
#line 107
        tmp___0 = v;
      } else {
#line 107
        if (v < 0) {
#line 107
          tmp = 0;
        } else {
#line 107
          tmp = 255;
        }
#line 107
        tmp___0 = tmp;
      }
#line 107
      *(dst + x_out) = (uint8_t )tmp___0;
#line 108
      *(irow + x_out) = frac;
#line 104
      x_out ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 110
    wrk->y_accum += wrk->y_add;
#line 111
    wrk->dst += wrk->dst_stride;
#line 112
    return (dst);
  } else {
#line 114
    return ((uint8_t *)((void *)0));
  }
}
}
#line 124 "/root/patchweave_new/13/src/utils/rescaler.c"
int WebPRescalerImport(WebPRescaler *wrk , int num_lines , uint8_t *src , int src_stride ) 
{ 
  int total_imported ;
  int channel ;

  {
#line 126
  total_imported = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;

#line 127
    if (total_imported < num_lines) {
#line 127
      if (! (wrk->y_accum > 0)) {
#line 127
        goto while_break;
      }
    } else {
#line 127
      goto while_break;
    }
#line 129
    channel = 0;
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 129
      if (! (channel < wrk->num_channels)) {
#line 129
        goto while_break___0;
      }
      {
#line 130
      WebPRescalerImportRow(wrk, src, channel);
#line 129
      channel ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 132
    src += src_stride;
#line 133
    total_imported ++;
#line 134
    wrk->y_accum -= wrk->y_sub;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 136
  return (total_imported);
}
}
#line 139 "/root/patchweave_new/13/src/utils/rescaler.c"
int WebPRescalerExport(WebPRescaler *rescaler ) 
{ 
  int total_exported ;
  int __cil_tmp3 ;

  {
#line 140
  total_exported = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    __cil_tmp3 = WebPRescalerHasPendingOutput(rescaler);
    }
#line 141
    if (! __cil_tmp3) {
#line 141
      goto while_break;
    }
    {
#line 142
    WebPRescalerExportRow(rescaler);
#line 143
    total_exported ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 145
  return (total_exported);
}
}
#line 24 "/root/patchweave_new/13/src/utils/./quant_levels_dec.h"
int DequantizeLevels(uint8_t *data , int width , int height ) ;
#line 18 "/root/patchweave_new/13/src/utils/quant_levels_dec.c"
int DequantizeLevels(uint8_t *data , int width , int height ) 
{ 


  {
#line 19
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 19
    return (0);
  } else
#line 19
  if (width <= 0) {
#line 19
    return (0);
  } else
#line 19
  if (height <= 0) {
#line 19
    return (0);
  }
#line 23
  return (1);
}
}
#line 27 "/root/patchweave_new/13/src/utils/./quant_levels.h"
int QuantizeLevels(uint8_t *data , int width , int height , int num_levels , uint64_t *sse ) ;
#line 29 "/root/patchweave_new/13/src/utils/quant_levels.c"
int QuantizeLevels(uint8_t *data , int width , int height , int num_levels , uint64_t *sse ) 
{ 
  int freq[256] ;
  unsigned int tmp ;
  int q_level[256] ;
  unsigned int tmp___0 ;
  double inv_q_level[256] ;
  unsigned int tmp___1 ;
  int min_s ;
  int max_s ;
  size_t data_size ;
  int i ;
  int num_levels_in ;
  int iter ;
  double last_err ;
  double err ;
  double err_threshold ;
  size_t n ;
  double q_sum[256] ;
  unsigned int tmp___4 ;
  double q_count[256] ;
  unsigned int tmp___5 ;
  int s ;
  int slot ;
  double count ;
  double error ;
  uint8_t map[256] ;
  int s___0 ;
  size_t n___0 ;
  int slot___0 ;

  {
#line 31
  freq[0] = 0;
#line 31
  tmp = 1U;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;

#line 31
    if (tmp >= 256U) {
#line 31
      goto while_break;
    }
#line 31
    freq[tmp] = 0;
#line 31
    tmp ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break: 
#line 32
  q_level[0] = 0;
#line 32
  tmp___0 = 1U;
  {
#line 32
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 32
    if (tmp___0 >= 256U) {
#line 32
      goto while_break___0;
    }
#line 32
    q_level[tmp___0] = 0;
#line 32
    tmp___0 ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___0: 
#line 33
  inv_q_level[0] = (double )0;
#line 33
  tmp___1 = 1U;
  {
#line 33
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 33
    if (tmp___1 >= 256U) {
#line 33
      goto while_break___1;
    }
#line 33
    inv_q_level[tmp___1] = (double )0;
#line 33
    tmp___1 ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___1: 
#line 34
  min_s = 255;
#line 34
  max_s = 0;
#line 35
  data_size = (size_t )(height * width);
#line 37
  last_err = 1e+38;
#line 37
  err = 0.;
#line 38
  err_threshold = 0.000100000000001 * (double )data_size;
#line 40
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 41
    return (0);
  }
#line 44
  if (width <= 0) {
#line 45
    return (0);
  } else
#line 44
  if (height <= 0) {
#line 45
    return (0);
  }
#line 48
  if (num_levels < 2) {
#line 49
    return (0);
  } else
#line 48
  if (num_levels > 256) {
#line 49
    return (0);
  }
#line 54
  num_levels_in = 0;
#line 55
  n = (size_t )0;
  {
#line 55
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 55
    if (! (n < data_size)) {
#line 55
      goto while_break___2;
    }
#line 56
    num_levels_in += freq[*(data + n)] == 0;
#line 57
    if (min_s > (int )*(data + n)) {
#line 57
      min_s = (int )*(data + n);
    }
#line 58
    if (max_s < (int )*(data + n)) {
#line 58
      max_s = (int )*(data + n);
    }
#line 59
    (freq[*(data + n)]) ++;
#line 55
    n ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___2: ;
#line 63
  if (num_levels_in <= num_levels) {
#line 63
    goto End;
  }
#line 66
  i = 0;
  {
#line 66
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 66
    if (! (i < num_levels)) {
#line 66
      goto while_break___3;
    }
#line 67
    inv_q_level[i] = (double )min_s + ((double )(max_s - min_s) * (double )i) / (double )(num_levels - 1);
#line 66
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___3: 
#line 71
  q_level[min_s] = 0;
#line 72
  q_level[max_s] = num_levels - 1;
#line 77
  iter = 0;
  {
#line 77
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 77
    if (! (iter < 6)) {
#line 77
      goto while_break___4;
    }
#line 78
    q_sum[0] = (double )0;
#line 78
    tmp___4 = 1U;
    {
#line 78
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 78
      if (tmp___4 >= 256U) {
#line 78
        goto while_break___5;
      }
#line 78
      q_sum[tmp___4] = (double )0;
#line 78
      tmp___4 ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___5: 
#line 79
    q_count[0] = (double )0;
#line 79
    tmp___5 = 1U;
    {
#line 79
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 79
      if (tmp___5 >= 256U) {
#line 79
        goto while_break___6;
      }
#line 79
      q_count[tmp___5] = (double )0;
#line 79
      tmp___5 ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___6: 
#line 80
    slot = 0;
#line 83
    s = min_s;
    {
#line 83
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 83
      if (! (s <= max_s)) {
#line 83
        goto while_break___7;
      }
      {
#line 85
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 85
        if (slot < num_levels - 1) {
#line 85
          if (! ((double )(2 * s) > inv_q_level[slot] + inv_q_level[slot + 1])) {
#line 85
            goto while_break___8;
          }
        } else {
#line 85
          goto while_break___8;
        }
#line 87
        slot ++;
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___8: ;
#line 89
      if (freq[s] > 0) {
#line 90
        q_sum[slot] += (double )(s * freq[s]);
#line 91
        q_count[slot] += (double )freq[s];
      }
#line 93
      q_level[s] = slot;
#line 83
      s ++;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___7: ;
#line 97
    if (num_levels > 2) {
#line 98
      slot = 1;
      {
#line 98
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 98
        if (! (slot < num_levels - 1)) {
#line 98
          goto while_break___9;
        }
#line 99
        count = q_count[slot];
#line 100
        if (count > 0.) {
#line 101
          inv_q_level[slot] = q_sum[slot] / count;
        }
#line 98
        slot ++;
      }
      while_break___23: /* CIL Label */ ;
      }
      while_break___9: ;
    }
#line 107
    err = 0.;
#line 108
    s = min_s;
    {
#line 108
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 108
      if (! (s <= max_s)) {
#line 108
        goto while_break___10;
      }
#line 109
      error = (double )s - inv_q_level[q_level[s]];
#line 110
      err += ((double )freq[s] * error) * error;
#line 108
      s ++;
    }
    while_break___24: /* CIL Label */ ;
    }
    while_break___10: ;
#line 115
    if (last_err - err < err_threshold) {
#line 115
      goto while_break___4;
    }
#line 116
    last_err = err;
#line 77
    iter ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___4: 
#line 127
  s___0 = min_s;
  {
#line 127
  while (1) {
    while_continue___11: /* CIL Label */ ;

#line 127
    if (! (s___0 <= max_s)) {
#line 127
      goto while_break___11;
    }
#line 128
    slot___0 = q_level[s___0];
#line 129
    map[s___0] = (uint8_t )(inv_q_level[slot___0] + 0.5);
#line 127
    s___0 ++;
  }
  while_break___25: /* CIL Label */ ;
  }
  while_break___11: 
#line 132
  n___0 = (size_t )0;
  {
#line 132
  while (1) {
    while_continue___12: /* CIL Label */ ;

#line 132
    if (! (n___0 < data_size)) {
#line 132
      goto while_break___12;
    }
#line 133
    *(data + n___0) = map[*(data + n___0)];
#line 132
    n___0 ++;
  }
  while_break___26: /* CIL Label */ ;
  }
  while_break___12: ;
  End: 
#line 138
  if ((unsigned long )sse != (unsigned long )((void *)0)) {
#line 138
    *sse = (uint64_t )err;
  }
#line 140
  return (1);
}
}
#line 36 "/root/patchweave_new/13/src/utils/./huffman_encode.h"
int VP8LCreateCompressedHuffmanTree(HuffmanTreeCode *tree , HuffmanTreeToken *tokens ,
                                    int max_tokens ) ;
#line 40
int VP8LCreateHuffmanTree(int *histogram , int tree_depth_limit , HuffmanTreeCode *tree ) ;
#line 23 "/root/patchweave_new/13/src/utils/huffman_encode.c"
static int ValuesShouldBeCollapsedToStrideAverage(int a , int b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 24
  __cil_tmp3 = abs(a - b);
  }
#line 24
  return (__cil_tmp3 < 4);
}
}
#line 29 "/root/patchweave_new/13/src/utils/huffman_encode.c"
static int OptimizeHuffmanForRle(int length , int *counts ) 
{ 
  uint8_t *good_for_rle ;
  int i ;
  void *__cil_tmp5 ;
  int symbol ;
  int stride ;
  int k ;
  int stride___0 ;
  int limit ;
  int sum ;
  int __cil_tmp12 ;
  int k___0 ;
  int count ;

  {
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;

#line 33
    if (! (length >= 0)) {
#line 33
      goto while_break;
    }
#line 34
    if (length == 0) {
#line 35
      return (1);
    }
#line 37
    if (*(counts + (length - 1)) != 0) {
#line 39
      goto while_break;
    }
#line 33
    length --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 44
  __cil_tmp5 = calloc((unsigned long )length, 1UL);
#line 44
  good_for_rle = (uint8_t *)__cil_tmp5;
  }
#line 45
  if ((unsigned long )good_for_rle == (unsigned long )((void *)0)) {
#line 46
    return (0);
  }
#line 52
  symbol = *(counts + 0);
#line 53
  stride = 0;
#line 54
  i = 0;
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 54
    if (! (i < length + 1)) {
#line 54
      goto while_break___0;
    }
#line 55
    if (i == length) {
      _L___1: 
#line 56
      if (symbol == 0) {
#line 56
        if (stride >= 5) {
          _L: 
#line 59
          k = 0;
          {
#line 59
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 59
            if (! (k < stride)) {
#line 59
              goto while_break___1;
            }
#line 60
            *(good_for_rle + ((i - k) - 1)) = (uint8_t )1;
#line 59
            k ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          while_break___1: ;
        } else {
#line 56
          goto _L___0;
        }
      } else
      _L___0: 
#line 56
      if (symbol != 0) {
#line 56
        if (stride >= 7) {
#line 56
          goto _L;
        }
      }
#line 63
      stride = 1;
#line 64
      if (i != length) {
#line 65
        symbol = *(counts + i);
      }
    } else
#line 55
    if (*(counts + i) != symbol) {
#line 55
      goto _L___1;
    } else {
#line 68
      stride ++;
    }
#line 54
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
#line 74
  stride___0 = 0;
#line 75
  limit = *(counts + 0);
#line 76
  sum = 0;
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 77
    if (! (i < length + 1)) {
#line 77
      goto while_break___2;
    }
    {
#line 78
    __cil_tmp12 = ValuesShouldBeCollapsedToStrideAverage(*(counts + i), limit);
    }
#line 78
    if (i == length) {
      _L___3: 
#line 81
      if (stride___0 >= 4) {
        _L___2: 
#line 84
        count = (sum + stride___0 / 2) / stride___0;
#line 85
        if (count < 1) {
#line 86
          count = 1;
        }
#line 88
        if (sum == 0) {
#line 90
          count = 0;
        }
#line 92
        k___0 = 0;
        {
#line 92
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 92
          if (! (k___0 < stride___0)) {
#line 92
            goto while_break___3;
          }
#line 95
          *(counts + ((i - k___0) - 1)) = count;
#line 92
          k___0 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: ;
      } else
#line 81
      if (stride___0 >= 3) {
#line 81
        if (sum == 0) {
#line 81
          goto _L___2;
        }
      }
#line 98
      stride___0 = 0;
#line 99
      sum = 0;
#line 100
      if (i < length - 3) {
#line 103
        limit = ((((*(counts + i) + *(counts + (i + 1))) + *(counts + (i + 2))) + *(counts + (i + 3))) + 2) / 4;
      } else
#line 105
      if (i < length) {
#line 106
        limit = *(counts + i);
      } else {
#line 108
        limit = 0;
      }
    } else
#line 78
    if ((int )*(good_for_rle + i)) {
#line 78
      goto _L___3;
    } else
#line 78
    if (i != 0) {
#line 78
      if ((int )*(good_for_rle + (i - 1))) {
#line 78
        goto _L___3;
      } else {
#line 78
        goto _L___5;
      }
    } else
    _L___5: 
#line 78
    if (! __cil_tmp12) {
#line 78
      goto _L___3;
    }
#line 111
    stride___0 ++;
#line 112
    if (i != length) {
#line 113
      sum += *(counts + i);
#line 114
      if (stride___0 >= 4) {
#line 115
        limit = (sum + stride___0 / 2) / stride___0;
      }
    }
#line 77
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 120
  free((void *)good_for_rle);
  }
#line 121
  return (1);
}
}
#line 133 "/root/patchweave_new/13/src/utils/huffman_encode.c"
static int CompareHuffmanTrees(void const   *ptr1 , void const   *ptr2 ) 
{ 
  HuffmanTree *t1 ;
  HuffmanTree *t2 ;
  int tmp___0 ;

  {
#line 134
  t1 = (HuffmanTree *)ptr1;
#line 135
  t2 = (HuffmanTree *)ptr2;
#line 136
  if (t1->total_count_ > t2->total_count_) {
#line 137
    return (-1);
  } else
#line 138
  if (t1->total_count_ < t2->total_count_) {
#line 139
    return (1);
  } else {
#line 142
    if (t1->value_ < t2->value_) {
#line 142
      tmp___0 = -1;
    } else {
#line 142
      tmp___0 = 1;
    }
#line 142
    return (tmp___0);
  }
}
}
#line 146 "/root/patchweave_new/13/src/utils/huffman_encode.c"
static void SetBitDepths(HuffmanTree *tree , HuffmanTree *pool , uint8_t *bit_depths ,
                         int level ) 
{ 


  {
#line 149
  if (tree->pool_index_left_ >= 0) {
    {
#line 150
    SetBitDepths(pool + tree->pool_index_left_, pool, bit_depths, level + 1);
#line 151
    SetBitDepths(pool + tree->pool_index_right_, pool, bit_depths, level + 1);
    }
  } else {
#line 153
    *(bit_depths + tree->value_) = (uint8_t )level;
  }
#line 155
  return;
}
}
#line 176 "/root/patchweave_new/13/src/utils/huffman_encode.c"
static int GenerateOptimalTree(int const   *histogram , int histogram_size , int tree_depth_limit ,
                               uint8_t *bit_depths ) 
{ 
  int count_min ;
  HuffmanTree *tree_pool ;
  HuffmanTree *tree ;
  int tree_size_orig ;
  int i ;
  void *__cil_tmp10 ;
  int tree_size ;
  int idx ;
  int j ;
  int count ;
  int tmp___0 ;
  int tree_pool_size ;
  int count___0 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int k ;
  int max_depth ;

  {
#line 182
  tree_size_orig = 0;
#line 185
  i = 0;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;

#line 185
    if (! (i < histogram_size)) {
#line 185
      goto while_break;
    }
#line 186
    if (*(histogram + i) != 0) {
#line 187
      tree_size_orig ++;
    }
#line 185
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 191
  if (tree_size_orig == 0) {
#line 192
    return (1);
  }
  {
#line 199
  __cil_tmp10 = WebPSafeMalloc((uint64_t )(3ULL * (unsigned long long )tree_size_orig),
                               sizeof(*tree));
#line 199
  tree = (HuffmanTree *)__cil_tmp10;
  }
#line 200
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 200
    return (0);
  }
#line 201
  tree_pool = tree + tree_size_orig;
#line 208
  count_min = 1;
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 209
    tree_size = tree_size_orig;
#line 212
    idx = 0;
#line 214
    j = 0;
    {
#line 214
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 214
      if (! (j < histogram_size)) {
#line 214
        goto while_break___1;
      }
#line 215
      if (*(histogram + j) != 0) {
#line 216
        if (*(histogram + j) < (int const   )count_min) {
#line 216
          tmp___0 = count_min;
        } else {
#line 216
          tmp___0 = (int )*(histogram + j);
        }
#line 216
        count = tmp___0;
#line 218
        (tree + idx)->total_count_ = count;
#line 219
        (tree + idx)->value_ = j;
#line 220
        (tree + idx)->pool_index_left_ = -1;
#line 221
        (tree + idx)->pool_index_right_ = -1;
#line 222
        idx ++;
      }
#line 214
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 227
    qsort((void *)tree, (size_t )tree_size, sizeof(*tree), & CompareHuffmanTrees);
    }
#line 229
    if (tree_size > 1) {
#line 230
      tree_pool_size = 0;
      {
#line 231
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 231
        if (! (tree_size > 1)) {
#line 231
          goto while_break___2;
        }
#line 233
        __cil_tmp19 = tree_pool_size;
#line 233
        tree_pool_size ++;
#line 233
        *(tree_pool + __cil_tmp19) = *(tree + (tree_size - 1));
#line 234
        __cil_tmp20 = tree_pool_size;
#line 234
        tree_pool_size ++;
#line 234
        *(tree_pool + __cil_tmp20) = *(tree + (tree_size - 2));
#line 235
        count___0 = (tree_pool + (tree_pool_size - 1))->total_count_ + (tree_pool + (tree_pool_size - 2))->total_count_;
#line 237
        tree_size -= 2;
#line 241
        k = 0;
        {
#line 241
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 241
          if (! (k < tree_size)) {
#line 241
            goto while_break___3;
          }
#line 242
          if ((tree + k)->total_count_ <= count___0) {
#line 243
            goto while_break___3;
          }
#line 241
          k ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: 
        {
#line 246
        memmove((void *)(tree + (k + 1)), (void const   *)(tree + k), (unsigned long )(tree_size - k) * sizeof(*tree));
#line 247
        (tree + k)->total_count_ = count___0;
#line 248
        (tree + k)->value_ = -1;
#line 250
        (tree + k)->pool_index_left_ = tree_pool_size - 1;
#line 251
        (tree + k)->pool_index_right_ = tree_pool_size - 2;
#line 252
        tree_size ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
      {
#line 255
      SetBitDepths(tree + 0, tree_pool, bit_depths, 0);
      }
    } else
#line 256
    if (tree_size == 1) {
#line 257
      *(bit_depths + (tree + 0)->value_) = (uint8_t )1;
    }
#line 262
    max_depth = (int )*(bit_depths + 0);
#line 263
    j = 1;
    {
#line 263
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 263
      if (! (j < histogram_size)) {
#line 263
        goto while_break___4;
      }
#line 264
      if (max_depth < (int )*(bit_depths + j)) {
#line 265
        max_depth = (int )*(bit_depths + j);
      }
#line 263
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: ;
#line 268
    if (max_depth <= tree_depth_limit) {
#line 269
      goto while_break___0;
    }
#line 208
    count_min *= 2;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 273
  free((void *)tree);
  }
#line 274
  return (1);
}
}
#line 280 "/root/patchweave_new/13/src/utils/huffman_encode.c"
static HuffmanTreeToken *CodeRepeatedValues(int repetitions , HuffmanTreeToken *tokens ,
                                            int value , int prev_value ) 
{ 
  int i ;

  {
#line 284
  if (value != prev_value) {
#line 285
    tokens->code = (uint8_t )value;
#line 286
    tokens->extra_bits = (uint8_t )0;
#line 287
    tokens ++;
#line 288
    repetitions --;
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;

#line 290
    if (! (repetitions >= 1)) {
#line 290
      goto while_break;
    }
#line 291
    if (repetitions < 3) {
#line 293
      i = 0;
      {
#line 293
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 293
        if (! (i < repetitions)) {
#line 293
          goto while_break___0;
        }
#line 294
        tokens->code = (uint8_t )value;
#line 295
        tokens->extra_bits = (uint8_t )0;
#line 296
        tokens ++;
#line 293
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
#line 298
      goto while_break;
    } else
#line 299
    if (repetitions < 7) {
#line 300
      tokens->code = (uint8_t )16;
#line 301
      tokens->extra_bits = (uint8_t )(repetitions - 3);
#line 302
      tokens ++;
#line 303
      goto while_break;
    } else {
#line 305
      tokens->code = (uint8_t )16;
#line 306
      tokens->extra_bits = (uint8_t )3;
#line 307
      tokens ++;
#line 308
      repetitions -= 6;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 311
  return (tokens);
}
}
#line 314 "/root/patchweave_new/13/src/utils/huffman_encode.c"
static HuffmanTreeToken *CodeRepeatedZeros(int repetitions , HuffmanTreeToken *tokens ) 
{ 
  int i ;

  {
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;

#line 316
    if (! (repetitions >= 1)) {
#line 316
      goto while_break;
    }
#line 317
    if (repetitions < 3) {
#line 319
      i = 0;
      {
#line 319
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 319
        if (! (i < repetitions)) {
#line 319
          goto while_break___0;
        }
#line 320
        tokens->code = (uint8_t )0;
#line 321
        tokens->extra_bits = (uint8_t )0;
#line 322
        tokens ++;
#line 319
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
#line 324
      goto while_break;
    } else
#line 325
    if (repetitions < 11) {
#line 326
      tokens->code = (uint8_t )17;
#line 327
      tokens->extra_bits = (uint8_t )(repetitions - 3);
#line 328
      tokens ++;
#line 329
      goto while_break;
    } else
#line 330
    if (repetitions < 139) {
#line 331
      tokens->code = (uint8_t )18;
#line 332
      tokens->extra_bits = (uint8_t )(repetitions - 11);
#line 333
      tokens ++;
#line 334
      goto while_break;
    } else {
#line 336
      tokens->code = (uint8_t )18;
#line 337
      tokens->extra_bits = (uint8_t )127;
#line 338
      tokens ++;
#line 339
      repetitions -= 138;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 342
  return (tokens);
}
}
#line 345 "/root/patchweave_new/13/src/utils/huffman_encode.c"
int VP8LCreateCompressedHuffmanTree(HuffmanTreeCode *tree , HuffmanTreeToken *tokens ,
                                    int max_tokens ) 
{ 
  HuffmanTreeToken *starting_token ;
  HuffmanTreeToken *ending_token ;
  int depth_size ;
  int prev_value ;
  int i ;
  int value ;
  int k ;
  int runs ;

  {
#line 347
  starting_token = tokens;
#line 348
  ending_token = tokens + max_tokens;
#line 349
  depth_size = tree->num_symbols;
#line 350
  prev_value = 8;
#line 351
  i = 0;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;

#line 353
    if (! (i < depth_size)) {
#line 353
      goto while_break;
    }
#line 354
    value = (int )*(tree->code_lengths + i);
#line 355
    k = i + 1;
    {
#line 357
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 357
      if (k < depth_size) {
#line 357
        if (! ((int )*(tree->code_lengths + k) == value)) {
#line 357
          goto while_break___0;
        }
      } else {
#line 357
        goto while_break___0;
      }
#line 357
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 358
    runs = k - i;
#line 359
    if (value == 0) {
      {
#line 360
      tokens = CodeRepeatedZeros(runs, tokens);
      }
    } else {
      {
#line 362
      tokens = CodeRepeatedValues(runs, tokens, value, prev_value);
#line 363
      prev_value = value;
      }
    }
#line 365
    i += runs;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 369
  return ((int )(tokens - starting_token));
}
}
#line 375 "/root/patchweave_new/13/src/utils/huffman_encode.c"
static uint8_t kReversedBits[16]  = 
#line 375
  {      (uint8_t )0,      (uint8_t )8,      (uint8_t )4,      (uint8_t )12, 
        (uint8_t )2,      (uint8_t )10,      (uint8_t )6,      (uint8_t )14, 
        (uint8_t )1,      (uint8_t )9,      (uint8_t )5,      (uint8_t )13, 
        (uint8_t )3,      (uint8_t )11,      (uint8_t )7,      (uint8_t )15};
#line 380 "/root/patchweave_new/13/src/utils/huffman_encode.c"
static uint32_t ReverseBits(int num_bits , uint32_t bits ) 
{ 
  uint32_t retval ;
  int i ;

  {
#line 381
  retval = (uint32_t )0;
#line 382
  i = 0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;

#line 383
    if (! (i < num_bits)) {
#line 383
      goto while_break;
    }
#line 384
    i += 4;
#line 385
    retval |= (unsigned int )((int )kReversedBits[bits & 15U] << (16 - i));
#line 386
    bits >>= 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 388
  retval >>= 16 - num_bits;
#line 389
  return (retval);
}
}
#line 393 "/root/patchweave_new/13/src/utils/huffman_encode.c"
static void ConvertBitDepthsToSymbols(HuffmanTreeCode *tree ) 
{ 
  int i ;
  int len ;
  uint32_t next_code[16] ;
  int depth_count[16] ;
  unsigned int tmp ;
  int code_length ;
  uint32_t code ;
  int code_length___0 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;

  {
#line 398
  depth_count[0] = 0;
#line 398
  tmp = 1U;
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;

#line 398
    if (tmp >= 16U) {
#line 398
      goto while_break;
    }
#line 398
    depth_count[tmp] = 0;
#line 398
    tmp ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 401
  len = tree->num_symbols;
#line 402
  i = 0;
  {
#line 402
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 402
    if (! (i < len)) {
#line 402
      goto while_break___0;
    }
#line 403
    code_length = (int )*(tree->code_lengths + i);
#line 405
    (depth_count[code_length]) ++;
#line 402
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 407
  depth_count[0] = 0;
#line 408
  next_code[0] = (uint32_t )0;
#line 410
  code = (uint32_t )0;
#line 411
  i = 1;
  {
#line 411
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 411
    if (! (i <= 15)) {
#line 411
      goto while_break___1;
    }
#line 412
    code = (code + (unsigned int )depth_count[i - 1]) << 1;
#line 413
    next_code[i] = code;
#line 411
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: 
#line 416
  i = 0;
  {
#line 416
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 416
    if (! (i < len)) {
#line 416
      goto while_break___2;
    }
    {
#line 417
    code_length___0 = (int )*(tree->code_lengths + i);
#line 418
    __cil_tmp12 = next_code[code_length___0];
#line 418
    (next_code[code_length___0]) ++;
#line 418
    __cil_tmp13 = ReverseBits(code_length___0, __cil_tmp12);
#line 418
    *(tree->codes + i) = (uint16_t )__cil_tmp13;
#line 416
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 420
  return;
}
}
#line 425 "/root/patchweave_new/13/src/utils/huffman_encode.c"
int VP8LCreateHuffmanTree(int *histogram , int tree_depth_limit , HuffmanTreeCode *tree ) 
{ 
  int num_symbols ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 427
  num_symbols = tree->num_symbols;
#line 428
  __cil_tmp5 = OptimizeHuffmanForRle(num_symbols, histogram);
  }
#line 428
  if (! __cil_tmp5) {
#line 429
    return (0);
  }
  {
#line 431
  __cil_tmp6 = GenerateOptimalTree((int const   *)histogram, num_symbols, tree_depth_limit,
                                   tree->code_lengths);
  }
#line 431
  if (! __cil_tmp6) {
#line 433
    return (0);
  }
  {
#line 436
  ConvertBitDepthsToSymbols(tree);
  }
#line 437
  return (1);
}
}
#line 37 "/root/patchweave_new/13/src/utils/./huffman.h"
__inline static int HuffmanTreeNodeIsLeaf(HuffmanTreeNode *node ) 
{ 


  {
#line 39
  return (node->children_ == 0);
}
}
#line 43 "/root/patchweave_new/13/src/utils/./huffman.h"
__inline static HuffmanTreeNode *HuffmanTreeNextNode(HuffmanTreeNode *node , int right_child ) 
{ 


  {
#line 45
  return ((node + node->children_) + right_child);
}
}
#line 50
void HuffmanTreeRelease(HuffmanTree___0 *tree ) ;
#line 54
int HuffmanTreeBuildImplicit(HuffmanTree___0 *tree , int const   *code_lengths , int code_lengths_size ) ;
#line 61
int HuffmanTreeBuildExplicit(HuffmanTree___0 *tree , int const   *code_lengths , int const   *codes ,
                             int const   *symbols , int max_symbol , int num_symbols ) ;
#line 70
int HuffmanCodeLengthsToCodes(int const   *code_lengths , int code_lengths_size ,
                              int *huff_codes ) ;
#line 24 "/root/patchweave_new/13/src/utils/huffman.c"
static void TreeNodeInit(HuffmanTreeNode *node ) 
{ 


  {
#line 25
  node->children_ = -1;
#line 26
  return;
}
}
#line 28 "/root/patchweave_new/13/src/utils/huffman.c"
static int NodeIsEmpty(HuffmanTreeNode *node ) 
{ 


  {
#line 29
  return (node->children_ < 0);
}
}
#line 32 "/root/patchweave_new/13/src/utils/huffman.c"
static int IsFull(HuffmanTree___0 *tree ) 
{ 


  {
#line 33
  return (tree->num_nodes_ == tree->max_nodes_);
}
}
#line 36 "/root/patchweave_new/13/src/utils/huffman.c"
static void AssignChildren(HuffmanTree___0 *tree , HuffmanTreeNode *node ) 
{ 
  HuffmanTreeNode *children ;

  {
  {
#line 38
  children = tree->root_ + tree->num_nodes_;
#line 39
  node->children_ = (int )(children - node);
#line 41
  tree->num_nodes_ += 2;
#line 42
  TreeNodeInit(children + 0);
#line 43
  TreeNodeInit(children + 1);
  }
#line 45
  return;
}
}
#line 46 "/root/patchweave_new/13/src/utils/huffman.c"
static int TreeInit(HuffmanTree___0 *tree , int num_leaves ) 
{ 
  void *__cil_tmp4 ;

  {
#line 48
  if (num_leaves == 0) {
#line 48
    return (0);
  }
  {
#line 52
  tree->max_nodes_ = 2 * num_leaves - 1;
#line 53
  __cil_tmp4 = WebPSafeMalloc((uint64_t )tree->max_nodes_, sizeof(*(tree->root_)));
#line 53
  tree->root_ = (HuffmanTreeNode *)__cil_tmp4;
  }
#line 55
  if ((unsigned long )tree->root_ == (unsigned long )((void *)0)) {
#line 55
    return (0);
  }
  {
#line 56
  TreeNodeInit(tree->root_);
#line 57
  tree->num_nodes_ = 1;
  }
#line 58
  return (1);
}
}
#line 61 "/root/patchweave_new/13/src/utils/huffman.c"
void HuffmanTreeRelease(HuffmanTree___0 *tree ) 
{ 


  {
#line 62
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
    {
#line 63
    free((void *)tree->root_);
#line 64
    tree->root_ = (HuffmanTreeNode *)((void *)0);
#line 65
    tree->max_nodes_ = 0;
#line 66
    tree->num_nodes_ = 0;
    }
  }
#line 69
  return;
}
}
#line 70 "/root/patchweave_new/13/src/utils/huffman.c"
int HuffmanCodeLengthsToCodes(int const   *code_lengths , int code_lengths_size ,
                              int *huff_codes ) 
{ 
  int symbol ;
  int code_len ;
  int code_length_hist[16] ;
  unsigned int tmp ;
  int curr_code ;
  int next_codes[16] ;
  unsigned int tmp___0 ;
  int max_code_length ;
  int __cil_tmp15 ;

  {
#line 74
  code_length_hist[0] = 0;
#line 74
  tmp = 1U;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;

#line 74
    if (tmp >= 16U) {
#line 74
      goto while_break;
    }
#line 74
    code_length_hist[tmp] = 0;
#line 74
    tmp ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 76
  next_codes[0] = 0;
#line 76
  tmp___0 = 1U;
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 76
    if (tmp___0 >= 16U) {
#line 76
      goto while_break___0;
    }
#line 76
    next_codes[tmp___0] = 0;
#line 76
    tmp___0 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 77
  max_code_length = 0;
#line 84
  symbol = 0;
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 84
    if (! (symbol < code_lengths_size)) {
#line 84
      goto while_break___1;
    }
#line 85
    if (*(code_lengths + symbol) > (int const   )max_code_length) {
#line 86
      max_code_length = (int )*(code_lengths + symbol);
    }
#line 84
    symbol ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: ;
#line 89
  if (max_code_length > 15) {
#line 89
    return (0);
  }
#line 92
  symbol = 0;
  {
#line 92
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 92
    if (! (symbol < code_lengths_size)) {
#line 92
      goto while_break___2;
    }
#line 93
    (code_length_hist[*(code_lengths + symbol)]) ++;
#line 92
    symbol ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
#line 95
  code_length_hist[0] = 0;
#line 100
  curr_code = 0;
#line 101
  next_codes[0] = -1;
#line 102
  code_len = 1;
  {
#line 102
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 102
    if (! (code_len <= max_code_length)) {
#line 102
      goto while_break___3;
    }
#line 103
    curr_code = (curr_code + code_length_hist[code_len - 1]) << 1;
#line 104
    next_codes[code_len] = curr_code;
#line 102
    code_len ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___3: 
#line 108
  symbol = 0;
  {
#line 108
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 108
    if (! (symbol < code_lengths_size)) {
#line 108
      goto while_break___4;
    }
#line 109
    if (*(code_lengths + symbol) > 0) {
#line 110
      __cil_tmp15 = next_codes[*(code_lengths + symbol)];
#line 110
      (next_codes[*(code_lengths + symbol)]) ++;
#line 110
      *(huff_codes + symbol) = __cil_tmp15;
    } else {
#line 112
      *(huff_codes + symbol) = -1;
    }
#line 108
    symbol ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: ;
#line 115
  return (1);
}
}
#line 118 "/root/patchweave_new/13/src/utils/huffman.c"
static int TreeAddSymbol(HuffmanTree___0 *tree , int symbol , int code , int code_length ) 
{ 
  HuffmanTreeNode *node ;
  HuffmanTreeNode *max_node ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 120
  node = tree->root_;
#line 121
  max_node = tree->root_ + tree->max_nodes_;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    __cil_tmp7 = code_length;
#line 122
    code_length --;
#line 122
    if (! (__cil_tmp7 > 0)) {
#line 122
      goto while_break;
    }
#line 123
    if ((unsigned long )node >= (unsigned long )max_node) {
#line 124
      return (0);
    }
    {
#line 126
    __cil_tmp8 = NodeIsEmpty(node);
    }
#line 126
    if (__cil_tmp8) {
      {
#line 127
      __cil_tmp9 = IsFull(tree);
      }
#line 127
      if (__cil_tmp9) {
#line 127
        return (0);
      }
      {
#line 128
      AssignChildren(tree, node);
      }
    } else {
      {
#line 129
      __cil_tmp10 = HuffmanTreeNodeIsLeaf(node);
      }
#line 129
      if (__cil_tmp10) {
#line 130
        return (0);
      }
    }
#line 132
    node += node->children_ + ((code >> code_length) & 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 134
  __cil_tmp11 = NodeIsEmpty(node);
  }
#line 134
  if (__cil_tmp11) {
#line 135
    node->children_ = 0;
  } else {
    {
#line 136
    __cil_tmp12 = HuffmanTreeNodeIsLeaf(node);
    }
#line 136
    if (! __cil_tmp12) {
#line 137
      return (0);
    }
  }
#line 139
  node->symbol_ = symbol;
#line 140
  return (1);
}
}
#line 143 "/root/patchweave_new/13/src/utils/huffman.c"
int HuffmanTreeBuildImplicit(HuffmanTree___0 *tree , int const   *code_lengths , int code_lengths_size ) 
{ 
  int symbol ;
  int num_symbols ;
  int root_symbol ;
  int __cil_tmp9 ;
  int max_symbol ;
  int __cil_tmp11 ;
  int ok ;
  int *codes ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp___1 ;

  {
#line 147
  num_symbols = 0;
#line 148
  root_symbol = 0;
#line 154
  symbol = 0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;

#line 154
    if (! (symbol < code_lengths_size)) {
#line 154
      goto while_break;
    }
#line 155
    if (*(code_lengths + symbol) > 0) {
#line 157
      num_symbols ++;
#line 158
      root_symbol = symbol;
    }
#line 154
    symbol ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 163
  __cil_tmp9 = TreeInit(tree, num_symbols);
  }
#line 163
  if (! __cil_tmp9) {
#line 163
    return (0);
  }
#line 166
  if (num_symbols == 1) {
#line 167
    max_symbol = code_lengths_size;
#line 168
    if (root_symbol < 0) {
      {
#line 169
      HuffmanTreeRelease(tree);
      }
#line 170
      return (0);
    } else
#line 168
    if (root_symbol >= max_symbol) {
      {
#line 169
      HuffmanTreeRelease(tree);
      }
#line 170
      return (0);
    }
    {
#line 172
    __cil_tmp11 = TreeAddSymbol(tree, root_symbol, 0, 0);
    }
#line 172
    return (__cil_tmp11);
  } else {
    {
#line 174
    ok = 0;
#line 177
    __cil_tmp14 = WebPSafeMalloc((uint64_t )code_lengths_size, sizeof(*codes));
#line 177
    codes = (int *)__cil_tmp14;
    }
#line 179
    if ((unsigned long )codes == (unsigned long )((void *)0)) {
#line 179
      goto End;
    }
    {
#line 181
    __cil_tmp15 = HuffmanCodeLengthsToCodes(code_lengths, code_lengths_size, codes);
    }
#line 181
    if (! __cil_tmp15) {
#line 182
      goto End;
    }
#line 186
    symbol = 0;
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 186
      if (! (symbol < code_lengths_size)) {
#line 186
        goto while_break___0;
      }
#line 187
      if (*(code_lengths + symbol) > 0) {
        {
#line 188
        __cil_tmp16 = TreeAddSymbol(tree, symbol, *(codes + symbol), (int )*(code_lengths + symbol));
        }
#line 188
        if (! __cil_tmp16) {
#line 189
          goto End;
        }
      }
#line 186
      symbol ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 193
    ok = 1;
    End: 
    {
#line 195
    free((void *)codes);
#line 196
    __cil_tmp17 = IsFull(tree);
    }
#line 196
    if (ok) {
#line 196
      if (__cil_tmp17) {
#line 196
        tmp___1 = 1;
      } else {
#line 196
        tmp___1 = 0;
      }
    } else {
#line 196
      tmp___1 = 0;
    }
#line 196
    ok = tmp___1;
#line 197
    if (! ok) {
      {
#line 197
      HuffmanTreeRelease(tree);
      }
    }
#line 198
    return (ok);
  }
}
}
#line 202 "/root/patchweave_new/13/src/utils/huffman.c"
int HuffmanTreeBuildExplicit(HuffmanTree___0 *tree , int const   *code_lengths , int const   *codes ,
                             int const   *symbols , int max_symbol , int num_symbols ) 
{ 
  int ok ;
  int i ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___3 ;

  {
  {
#line 207
  ok = 0;
#line 216
  __cil_tmp13 = TreeInit(tree, num_symbols);
  }
#line 216
  if (! __cil_tmp13) {
#line 216
    return (0);
  }
#line 219
  i = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;

#line 219
    if (! (i < num_symbols)) {
#line 219
      goto while_break;
    }
#line 220
    if (*(codes + i) != -1) {
#line 221
      if (*(symbols + i) < 0) {
#line 222
        goto End;
      } else
#line 221
      if (*(symbols + i) >= (int const   )max_symbol) {
#line 222
        goto End;
      }
      {
#line 224
      __cil_tmp14 = TreeAddSymbol(tree, (int )*(symbols + i), (int )*(codes + i),
                                  (int )*(code_lengths + i));
      }
#line 224
      if (! __cil_tmp14) {
#line 225
        goto End;
      }
    }
#line 219
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 229
  ok = 1;
  End: 
  {
#line 231
  __cil_tmp15 = IsFull(tree);
  }
#line 231
  if (ok) {
#line 231
    if (__cil_tmp15) {
#line 231
      tmp___3 = 1;
    } else {
#line 231
      tmp___3 = 0;
    }
  } else {
#line 231
    tmp___3 = 0;
  }
#line 231
  ok = tmp___3;
#line 232
  if (! ok) {
    {
#line 232
    HuffmanTreeRelease(tree);
    }
  }
#line 233
  return (ok);
}
}
#line 42 "/root/patchweave_new/13/src/utils/./filters.h"
WebPFilterFunc WebPFilters[4] ;
#line 45
WebPUnfilterFunc WebPUnfilters[4] ;
#line 48
WEBP_FILTER_TYPE EstimateBestFilter(uint8_t *data , int width , int height , int stride ) ;
#line 31 "/root/patchweave_new/13/src/utils/filters.c"
__inline static void PredictLine(uint8_t *src , uint8_t *pred , uint8_t *dst , int length ,
                                 int inverse ) 
{ 
  int i ;

  {
#line 34
  if (inverse) {
#line 35
    i = 0;
    {
#line 35
    while (1) {
      while_continue: /* CIL Label */ ;

#line 35
      if (! (i < length)) {
#line 35
        goto while_break;
      }
#line 35
      *(dst + i) = (uint8_t )((int )*(src + i) + (int )*(pred + i));
#line 35
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 37
      if (! (i < length)) {
#line 37
        goto while_break___0;
      }
#line 37
      *(dst + i) = (uint8_t )((int )*(src + i) - (int )*(pred + i));
#line 37
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 42
  return;
}
}
#line 44 "/root/patchweave_new/13/src/utils/filters.c"
__inline static void DoHorizontalFilter(uint8_t *in , int width , int height , int stride ,
                                        int inverse , uint8_t *out ) 
{ 
  int h ;
  uint8_t *preds ;
  uint8_t *tmp ;

  {
#line 48
  if (inverse) {
#line 48
    tmp = out;
  } else {
#line 48
    tmp = in;
  }
#line 48
  preds = tmp;
#line 52
  h = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;

#line 52
    if (! (h < height)) {
#line 52
      goto while_break;
    }
#line 54
    if (h == 0) {
#line 55
      *(out + 0) = *(in + 0);
    } else {
      {
#line 57
      PredictLine(in, preds - stride, out, 1, inverse);
      }
    }
    {
#line 59
    PredictLine(in + 1, preds, out + 1, width - 1, inverse);
#line 60
    preds += stride;
#line 61
    in += stride;
#line 62
    out += stride;
#line 52
    h ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 56
  return;
}
}
#line 66 "/root/patchweave_new/13/src/utils/filters.c"
static void HorizontalFilter(uint8_t *data , int width , int height , int stride ,
                             uint8_t *filtered_data ) 
{ 


  {
  {
#line 68
  DoHorizontalFilter(data, width, height, stride, 0, filtered_data);
  }
#line 70
  return;
}
}
#line 71 "/root/patchweave_new/13/src/utils/filters.c"
static void HorizontalUnfilter(int width , int height , int stride , uint8_t *data ) 
{ 


  {
  {
#line 73
  DoHorizontalFilter(data, width, height, stride, 1, data);
  }
#line 75
  return;
}
}
#line 79 "/root/patchweave_new/13/src/utils/filters.c"
__inline static void DoVerticalFilter(uint8_t *in , int width , int height , int stride ,
                                      int inverse , uint8_t *out ) 
{ 
  int h ;
  uint8_t *preds ;
  uint8_t *tmp ;

  {
#line 83
  if (inverse) {
#line 83
    tmp = out;
  } else {
#line 83
    tmp = in;
  }
  {
#line 83
  preds = tmp;
#line 87
  *(out + 0) = *(in + 0);
#line 89
  PredictLine(in + 1, preds, out + 1, width - 1, inverse);
#line 92
  h = 1;
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;

#line 92
    if (! (h < height)) {
#line 92
      goto while_break;
    }
    {
#line 93
    in += stride;
#line 94
    out += stride;
#line 95
    PredictLine(in, preds, out, width, inverse);
#line 96
    preds += stride;
#line 92
    h ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 96
  return;
}
}
#line 100 "/root/patchweave_new/13/src/utils/filters.c"
static void VerticalFilter(uint8_t *data , int width , int height , int stride , uint8_t *filtered_data ) 
{ 


  {
  {
#line 102
  DoVerticalFilter(data, width, height, stride, 0, filtered_data);
  }
#line 104
  return;
}
}
#line 105 "/root/patchweave_new/13/src/utils/filters.c"
static void VerticalUnfilter(int width , int height , int stride , uint8_t *data ) 
{ 


  {
  {
#line 106
  DoVerticalFilter(data, width, height, stride, 1, data);
  }
#line 108
  return;
}
}
#line 112 "/root/patchweave_new/13/src/utils/filters.c"
__inline static int GradientPredictor(uint8_t a , uint8_t b , uint8_t c ) 
{ 
  int g ;
  int tmp ;
  int tmp___0 ;

  {
#line 113
  g = ((int )a + (int )b) - (int )c;
#line 114
  if ((g & -256) == 0) {
#line 114
    tmp___0 = g;
  } else {
#line 114
    if (g < 0) {
#line 114
      tmp = 0;
    } else {
#line 114
      tmp = 255;
    }
#line 114
    tmp___0 = tmp;
  }
#line 114
  return (tmp___0);
}
}
#line 118 "/root/patchweave_new/13/src/utils/filters.c"
__inline static void DoGradientFilter(uint8_t *in , int width , int height , int stride ,
                                      int inverse , uint8_t *out ) 
{ 
  uint8_t *preds ;
  uint8_t *tmp ;
  int h ;
  int w ;
  int pred ;
  int __cil_tmp17 ;
  int tmp___5 ;

  {
#line 120
  if (inverse) {
#line 120
    tmp = out;
  } else {
#line 120
    tmp = in;
  }
  {
#line 120
  preds = tmp;
#line 125
  *(out + 0) = *(in + 0);
#line 126
  PredictLine(in + 1, preds, out + 1, width - 1, inverse);
#line 129
  h = 1;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;

#line 129
    if (! (h < height)) {
#line 129
      goto while_break;
    }
    {
#line 131
    preds += stride;
#line 132
    in += stride;
#line 133
    out += stride;
#line 135
    PredictLine(in, preds - stride, out, 1, inverse);
#line 136
    w = 1;
    }
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 136
      if (! (w < width)) {
#line 136
        goto while_break___0;
      }
      {
#line 137
      __cil_tmp17 = GradientPredictor(*(preds + (w - 1)), *(preds + (w - stride)),
                                      *(preds + ((w - stride) - 1)));
#line 137
      pred = __cil_tmp17;
      }
#line 140
      if (inverse) {
#line 140
        tmp___5 = pred;
      } else {
#line 140
        tmp___5 = - pred;
      }
#line 140
      *(out + w) = (uint8_t )((int )*(in + w) + tmp___5);
#line 136
      w ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 129
    h ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 133
  return;
}
}
#line 145 "/root/patchweave_new/13/src/utils/filters.c"
static void GradientFilter(uint8_t *data , int width , int height , int stride , uint8_t *filtered_data ) 
{ 


  {
  {
#line 147
  DoGradientFilter(data, width, height, stride, 0, filtered_data);
  }
#line 149
  return;
}
}
#line 150 "/root/patchweave_new/13/src/utils/filters.c"
static void GradientUnfilter(int width , int height , int stride , uint8_t *data ) 
{ 


  {
  {
#line 151
  DoGradientFilter(data, width, height, stride, 1, data);
  }
#line 153
  return;
}
}
#line 163 "/root/patchweave_new/13/src/utils/filters.c"
WEBP_FILTER_TYPE EstimateBestFilter(uint8_t *data , int width , int height , int stride ) 
{ 
  int i ;
  int j ;
  int bins[4][16] ;
  uint8_t *p ;
  int mean ;
  int diff0 ;
  int __cil_tmp11 ;
  int diff1 ;
  int __cil_tmp13 ;
  int diff2 ;
  int __cil_tmp15 ;
  int grad_pred ;
  int __cil_tmp17 ;
  int diff3 ;
  int __cil_tmp19 ;
  WEBP_FILTER_TYPE filter ;
  WEBP_FILTER_TYPE best_filter ;
  int best_score ;
  int score ;

  {
  {
#line 167
  memset((void *)(bins), 0, sizeof(bins));
#line 169
  j = 2;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;

#line 169
    if (! (j < height - 1)) {
#line 169
      goto while_break;
    }
#line 170
    p = data + j * stride;
#line 171
    mean = (int )*(p + 0);
#line 172
    i = 2;
    {
#line 172
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 172
      if (! (i < width - 1)) {
#line 172
        goto while_break___0;
      }
      {
#line 173
      __cil_tmp11 = abs((int )*(p + i) - mean);
#line 173
      diff0 = __cil_tmp11 >> 4;
#line 174
      __cil_tmp13 = abs((int )*(p + i) - (int )*(p + (i - 1)));
#line 174
      diff1 = __cil_tmp13 >> 4;
#line 175
      __cil_tmp15 = abs((int )*(p + i) - (int )*(p + (i - width)));
#line 175
      diff2 = __cil_tmp15 >> 4;
#line 176
      __cil_tmp17 = GradientPredictor(*(p + (i - 1)), *(p + (i - width)), *(p + ((i - width) - 1)));
#line 176
      grad_pred = __cil_tmp17;
#line 178
      __cil_tmp19 = abs((int )*(p + i) - grad_pred);
#line 178
      diff3 = __cil_tmp19 >> 4;
#line 179
      bins[0][diff0] = 1;
#line 180
      bins[1][diff1] = 1;
#line 181
      bins[2][diff2] = 1;
#line 182
      bins[3][diff3] = 1;
#line 183
      mean = ((3 * mean + (int )*(p + i)) + 2) >> 2;
#line 172
      i += 2;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 169
    j += 2;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 187
  best_filter = (WEBP_FILTER_TYPE )0;
#line 188
  best_score = 2147483647;
#line 189
  filter = (WEBP_FILTER_TYPE )0;
  {
#line 189
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 189
    if (! ((unsigned int )filter < 4U)) {
#line 189
      goto while_break___1;
    }
#line 190
    score = 0;
#line 191
    i = 0;
    {
#line 191
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 191
      if (! (i < 16)) {
#line 191
        goto while_break___2;
      }
#line 192
      if (bins[filter][i] > 0) {
#line 193
        score += i;
      }
#line 191
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
#line 196
    if (score < best_score) {
#line 197
      best_score = score;
#line 198
      best_filter = filter;
    }
#line 189
    filter = (WEBP_FILTER_TYPE )((unsigned int )filter + 1U);
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 201
  return (best_filter);
}
}
#line 210 "/root/patchweave_new/13/src/utils/filters.c"
WebPFilterFunc WebPFilters[4]  = {      (void (*)(uint8_t * , int  , int  , int  , uint8_t * ))((void *)0),      & HorizontalFilter,      & VerticalFilter,      & GradientFilter};
#line 217 "/root/patchweave_new/13/src/utils/filters.c"
WebPUnfilterFunc WebPUnfilters[4]  = {      (void (*)(int  , int  , int  , uint8_t * ))((void *)0),      & HorizontalUnfilter,      & VerticalUnfilter,      & GradientUnfilter};
#line 30 "/root/patchweave_new/13/src/utils/./color_cache.h"
__inline static uint32_t VP8LColorCacheLookup(VP8LColorCache *cc , uint32_t key ) 
{ 


  {
#line 33
  return (*(cc->colors_ + key));
}
}
#line 57
int VP8LColorCacheInit(VP8LColorCache *cc , int hash_bits ) ;
#line 60
void VP8LColorCacheClear(VP8LColorCache *cc ) ;
#line 24 "/root/patchweave_new/13/src/utils/color_cache.c"
int VP8LColorCacheInit(VP8LColorCache *cc , int hash_bits ) 
{ 
  int hash_size ;
  void *__cil_tmp6 ;

  {
  {
#line 25
  hash_size = 1 << hash_bits;
#line 28
  __cil_tmp6 = WebPSafeCalloc((uint64_t )hash_size, sizeof(*(cc->colors_)));
#line 28
  cc->colors_ = (uint32_t *)__cil_tmp6;
  }
#line 30
  if ((unsigned long )cc->colors_ == (unsigned long )((void *)0)) {
#line 30
    return (0);
  }
#line 31
  cc->hash_shift_ = 32 - hash_bits;
#line 32
  return (1);
}
}
#line 35 "/root/patchweave_new/13/src/utils/color_cache.c"
void VP8LColorCacheClear(VP8LColorCache *cc ) 
{ 


  {
#line 36
  if ((unsigned long )cc != (unsigned long )((void *)0)) {
    {
#line 37
    free((void *)cc->colors_);
#line 38
    cc->colors_ = (uint32_t *)((void *)0);
    }
  }
#line 41
  return;
}
}
#line 37 "/root/patchweave_new/13/src/utils/./bit_writer.h"
int VP8BitWriterInit(VP8BitWriter *bw , size_t expected_size ) ;
#line 39
uint8_t *VP8BitWriterFinish(VP8BitWriter *bw ) ;
#line 42
void VP8BitWriterWipeOut(VP8BitWriter *bw ) ;
#line 44
int VP8PutBit(VP8BitWriter *bw , int bit , int prob ) ;
#line 45
int VP8PutBitUniform(VP8BitWriter *bw , int bit ) ;
#line 46
void VP8PutValue(VP8BitWriter *bw , int value , int nb_bits ) ;
#line 47
void VP8PutSignedValue(VP8BitWriter *bw , int value , int nb_bits ) ;
#line 50
int VP8BitWriterAppend(VP8BitWriter *bw , uint8_t *data , size_t size ) ;
#line 54 "/root/patchweave_new/13/src/utils/./bit_writer.h"
__inline static uint64_t VP8BitWriterPos(VP8BitWriter *bw ) 
{ 


  {
#line 55
  return (((bw->pos_ + (unsigned long )bw->run_) * 8UL + 8UL) + (unsigned long )bw->nb_bits_);
}
}
#line 59 "/root/patchweave_new/13/src/utils/./bit_writer.h"
__inline static uint8_t *VP8BitWriterBuf(VP8BitWriter *bw ) 
{ 


  {
#line 60
  return (bw->buf_);
}
}
#line 63 "/root/patchweave_new/13/src/utils/./bit_writer.h"
__inline static size_t VP8BitWriterSize(VP8BitWriter *bw ) 
{ 


  {
#line 64
  return (bw->pos_);
}
}
#line 85 "/root/patchweave_new/13/src/utils/./bit_writer.h"
__inline static size_t VP8LBitWriterNumBytes(VP8LBitWriter *bw ) 
{ 


  {
#line 86
  return ((bw->bit_pos_ + 7UL) >> 3);
}
}
#line 89 "/root/patchweave_new/13/src/utils/./bit_writer.h"
__inline static uint8_t *VP8LBitWriterFinish(VP8LBitWriter *bw ) 
{ 


  {
#line 90
  return (bw->buf_);
}
}
#line 94
int VP8LBitWriterInit(VP8LBitWriter *bw , size_t expected_size ) ;
#line 96
void VP8LBitWriterDestroy(VP8LBitWriter *bw ) ;
#line 115
void VP8LWriteBits(VP8LBitWriter *bw , int n_bits , uint32_t bits ) ;
#line 25 "/root/patchweave_new/13/src/utils/bit_writer.c"
static int BitWriterResize(VP8BitWriter *bw , size_t extra_size ) 
{ 
  uint8_t *new_buf ;
  size_t new_size ;
  uint64_t needed_size_64b ;
  size_t needed_size ;
  void *__cil_tmp7 ;

  {
#line 28
  needed_size_64b = bw->pos_ + extra_size;
#line 29
  needed_size = needed_size_64b;
#line 30
  if (needed_size_64b != needed_size) {
#line 31
    bw->error_ = 1;
#line 32
    return (0);
  }
#line 34
  if (needed_size <= bw->max_pos_) {
#line 34
    return (1);
  }
#line 36
  new_size = 2UL * bw->max_pos_;
#line 37
  if (new_size < needed_size) {
#line 37
    new_size = needed_size;
  }
#line 38
  if (new_size < 1024UL) {
#line 38
    new_size = (size_t )1024;
  }
  {
#line 39
  __cil_tmp7 = malloc(new_size);
#line 39
  new_buf = (uint8_t *)__cil_tmp7;
  }
#line 40
  if ((unsigned long )new_buf == (unsigned long )((void *)0)) {
#line 41
    bw->error_ = 1;
#line 42
    return (0);
  }
  {
#line 44
  memcpy((void *)new_buf, (void const   *)bw->buf_, bw->pos_);
#line 45
  free((void *)bw->buf_);
#line 46
  bw->buf_ = new_buf;
#line 47
  bw->max_pos_ = new_size;
  }
#line 48
  return (1);
}
}
#line 51 "/root/patchweave_new/13/src/utils/bit_writer.c"
static void kFlush(VP8BitWriter *bw ) 
{ 
  int s ;
  int32_t bits ;
  size_t pos ;
  int __cil_tmp6 ;
  int value ;
  int tmp___0 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
#line 52
  s = 8 + bw->nb_bits_;
#line 53
  bits = bw->value_ >> s;
#line 55
  bw->value_ -= bits << s;
#line 56
  bw->nb_bits_ -= 8;
#line 57
  if ((bits & 255) != 255) {
    {
#line 58
    pos = bw->pos_;
#line 59
    __cil_tmp6 = BitWriterResize(bw, (size_t )(bw->run_ + 1));
    }
#line 59
    if (! __cil_tmp6) {
#line 60
      return;
    }
#line 62
    if (bits & 256) {
#line 63
      if (pos > 0UL) {
#line 63
        *(bw->buf_ + (pos - 1UL)) = (uint8_t )((int )*(bw->buf_ + (pos - 1UL)) + 1);
      }
    }
#line 65
    if (bw->run_ > 0) {
#line 66
      if (bits & 256) {
#line 66
        tmp___0 = 0;
      } else {
#line 66
        tmp___0 = 255;
      }
#line 66
      value = tmp___0;
      {
#line 67
      while (1) {
        while_continue: /* CIL Label */ ;

#line 67
        if (! (bw->run_ > 0)) {
#line 67
          goto while_break;
        }
#line 67
        __cil_tmp10 = pos;
#line 67
        pos ++;
#line 67
        *(bw->buf_ + __cil_tmp10) = (uint8_t )value;
#line 67
        (bw->run_) --;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: ;
    }
#line 69
    __cil_tmp11 = pos;
#line 69
    pos ++;
#line 69
    *(bw->buf_ + __cil_tmp11) = (uint8_t )bits;
#line 70
    bw->pos_ = pos;
  } else {
#line 72
    (bw->run_) ++;
  }
#line 74
  return;
}
}
#line 79 "/root/patchweave_new/13/src/utils/bit_writer.c"
static uint8_t kNorm[128]  = 
#line 79
  {      (uint8_t )7,      (uint8_t )6,      (uint8_t )6,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )0};
#line 92 "/root/patchweave_new/13/src/utils/bit_writer.c"
static uint8_t kNewRange[128]  = 
#line 92
  {      (uint8_t )127,      (uint8_t )127,      (uint8_t )191,      (uint8_t )127, 
        (uint8_t )159,      (uint8_t )191,      (uint8_t )223,      (uint8_t )127, 
        (uint8_t )143,      (uint8_t )159,      (uint8_t )175,      (uint8_t )191, 
        (uint8_t )207,      (uint8_t )223,      (uint8_t )239,      (uint8_t )127, 
        (uint8_t )135,      (uint8_t )143,      (uint8_t )151,      (uint8_t )159, 
        (uint8_t )167,      (uint8_t )175,      (uint8_t )183,      (uint8_t )191, 
        (uint8_t )199,      (uint8_t )207,      (uint8_t )215,      (uint8_t )223, 
        (uint8_t )231,      (uint8_t )239,      (uint8_t )247,      (uint8_t )127, 
        (uint8_t )131,      (uint8_t )135,      (uint8_t )139,      (uint8_t )143, 
        (uint8_t )147,      (uint8_t )151,      (uint8_t )155,      (uint8_t )159, 
        (uint8_t )163,      (uint8_t )167,      (uint8_t )171,      (uint8_t )175, 
        (uint8_t )179,      (uint8_t )183,      (uint8_t )187,      (uint8_t )191, 
        (uint8_t )195,      (uint8_t )199,      (uint8_t )203,      (uint8_t )207, 
        (uint8_t )211,      (uint8_t )215,      (uint8_t )219,      (uint8_t )223, 
        (uint8_t )227,      (uint8_t )231,      (uint8_t )235,      (uint8_t )239, 
        (uint8_t )243,      (uint8_t )247,      (uint8_t )251,      (uint8_t )127, 
        (uint8_t )129,      (uint8_t )131,      (uint8_t )133,      (uint8_t )135, 
        (uint8_t )137,      (uint8_t )139,      (uint8_t )141,      (uint8_t )143, 
        (uint8_t )145,      (uint8_t )147,      (uint8_t )149,      (uint8_t )151, 
        (uint8_t )153,      (uint8_t )155,      (uint8_t )157,      (uint8_t )159, 
        (uint8_t )161,      (uint8_t )163,      (uint8_t )165,      (uint8_t )167, 
        (uint8_t )169,      (uint8_t )171,      (uint8_t )173,      (uint8_t )175, 
        (uint8_t )177,      (uint8_t )179,      (uint8_t )181,      (uint8_t )183, 
        (uint8_t )185,      (uint8_t )187,      (uint8_t )189,      (uint8_t )191, 
        (uint8_t )193,      (uint8_t )195,      (uint8_t )197,      (uint8_t )199, 
        (uint8_t )201,      (uint8_t )203,      (uint8_t )205,      (uint8_t )207, 
        (uint8_t )209,      (uint8_t )211,      (uint8_t )213,      (uint8_t )215, 
        (uint8_t )217,      (uint8_t )219,      (uint8_t )221,      (uint8_t )223, 
        (uint8_t )225,      (uint8_t )227,      (uint8_t )229,      (uint8_t )231, 
        (uint8_t )233,      (uint8_t )235,      (uint8_t )237,      (uint8_t )239, 
        (uint8_t )241,      (uint8_t )243,      (uint8_t )245,      (uint8_t )247, 
        (uint8_t )249,      (uint8_t )251,      (uint8_t )253,      (uint8_t )127};
#line 104 "/root/patchweave_new/13/src/utils/bit_writer.c"
int VP8PutBit(VP8BitWriter *bw , int bit , int prob ) 
{ 
  int split ;
  int shift ;

  {
#line 105
  split = bw->range_ * prob >> 8;
#line 106
  if (bit) {
#line 107
    bw->value_ += split + 1;
#line 108
    bw->range_ -= split + 1;
  } else {
#line 110
    bw->range_ = split;
  }
#line 112
  if (bw->range_ < 127) {
#line 113
    shift = (int )kNorm[bw->range_];
#line 114
    bw->range_ = (int32_t )kNewRange[bw->range_];
#line 115
    bw->value_ <<= shift;
#line 116
    bw->nb_bits_ += shift;
#line 117
    if (bw->nb_bits_ > 0) {
      {
#line 117
      kFlush(bw);
      }
    }
  }
#line 119
  return (bit);
}
}
#line 122 "/root/patchweave_new/13/src/utils/bit_writer.c"
int VP8PutBitUniform(VP8BitWriter *bw , int bit ) 
{ 
  int split ;

  {
#line 123
  split = bw->range_ >> 1;
#line 124
  if (bit) {
#line 125
    bw->value_ += split + 1;
#line 126
    bw->range_ -= split + 1;
  } else {
#line 128
    bw->range_ = split;
  }
#line 130
  if (bw->range_ < 127) {
#line 131
    bw->range_ = (int32_t )kNewRange[bw->range_];
#line 132
    bw->value_ <<= 1;
#line 133
    (bw->nb_bits_) ++;
#line 134
    if (bw->nb_bits_ > 0) {
      {
#line 134
      kFlush(bw);
      }
    }
  }
#line 136
  return (bit);
}
}
#line 139 "/root/patchweave_new/13/src/utils/bit_writer.c"
void VP8PutValue(VP8BitWriter *bw , int value , int nb_bits ) 
{ 
  int mask ;

  {
#line 141
  mask = 1 << (nb_bits - 1);
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;

#line 141
    if (! mask) {
#line 141
      goto while_break;
    }
    {
#line 142
    VP8PutBitUniform(bw, value & mask);
#line 141
    mask >>= 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 145
  return;
}
}
#line 145 "/root/patchweave_new/13/src/utils/bit_writer.c"
void VP8PutSignedValue(VP8BitWriter *bw , int value , int nb_bits ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 146
  __cil_tmp4 = VP8PutBitUniform(bw, value != 0);
  }
#line 146
  if (! __cil_tmp4) {
#line 147
    return;
  }
#line 148
  if (value < 0) {
    {
#line 149
    VP8PutValue(bw, (- value << 1) | 1, nb_bits + 1);
    }
  } else {
    {
#line 151
    VP8PutValue(bw, value << 1, nb_bits + 1);
    }
  }
#line 154
  return;
}
}
#line 157 "/root/patchweave_new/13/src/utils/bit_writer.c"
int VP8BitWriterInit(VP8BitWriter *bw , size_t expected_size ) 
{ 
  int __cil_tmp3 ;
  int tmp ;

  {
#line 158
  bw->range_ = 254;
#line 159
  bw->value_ = 0;
#line 160
  bw->run_ = 0;
#line 161
  bw->nb_bits_ = -8;
#line 162
  bw->pos_ = (size_t )0;
#line 163
  bw->max_pos_ = (size_t )0;
#line 164
  bw->error_ = 0;
#line 165
  bw->buf_ = (uint8_t *)((void *)0);
#line 166
  if (expected_size > 0UL) {
    {
#line 166
    __cil_tmp3 = BitWriterResize(bw, expected_size);
#line 166
    tmp = __cil_tmp3;
    }
  } else {
#line 166
    tmp = 1;
  }
#line 166
  return (tmp);
}
}
#line 169 "/root/patchweave_new/13/src/utils/bit_writer.c"
uint8_t *VP8BitWriterFinish(VP8BitWriter *bw ) 
{ 


  {
  {
#line 170
  VP8PutValue(bw, 0, 9 - bw->nb_bits_);
#line 171
  bw->nb_bits_ = 0;
#line 172
  kFlush(bw);
  }
#line 173
  return (bw->buf_);
}
}
#line 176 "/root/patchweave_new/13/src/utils/bit_writer.c"
int VP8BitWriterAppend(VP8BitWriter *bw , uint8_t *data , size_t size ) 
{ 
  int __cil_tmp5 ;

  {
#line 179
  if (bw->nb_bits_ != -8) {
#line 179
    return (0);
  }
  {
#line 180
  __cil_tmp5 = BitWriterResize(bw, size);
  }
#line 180
  if (! __cil_tmp5) {
#line 180
    return (0);
  }
  {
#line 181
  memcpy((void *)(bw->buf_ + bw->pos_), (void const   *)data, size);
#line 182
  bw->pos_ += size;
  }
#line 183
  return (1);
}
}
#line 186 "/root/patchweave_new/13/src/utils/bit_writer.c"
void VP8BitWriterWipeOut(VP8BitWriter *bw ) 
{ 


  {
#line 187
  if (bw) {
    {
#line 188
    free((void *)bw->buf_);
#line 189
    memset((void *)bw, 0, sizeof(*bw));
    }
  }
#line 192
  return;
}
}
#line 197 "/root/patchweave_new/13/src/utils/bit_writer.c"
static int VP8LBitWriterResize(VP8LBitWriter *bw , size_t extra_size ) 
{ 
  uint8_t *allocated_buf ;
  size_t allocated_size ;
  size_t current_size ;
  size_t __cil_tmp6 ;
  uint64_t size_required_64b ;
  size_t size_required ;
  void *__cil_tmp9 ;

  {
  {
#line 200
  __cil_tmp6 = VP8LBitWriterNumBytes(bw);
#line 200
  current_size = __cil_tmp6;
#line 201
  size_required_64b = current_size + extra_size;
#line 202
  size_required = size_required_64b;
  }
#line 203
  if (size_required != size_required_64b) {
#line 204
    bw->error_ = 1;
#line 205
    return (0);
  }
#line 207
  if (bw->max_bytes_ > 0UL) {
#line 207
    if (size_required <= bw->max_bytes_) {
#line 207
      return (1);
    }
  }
#line 208
  allocated_size = 3UL * bw->max_bytes_ >> 1;
#line 209
  if (allocated_size < size_required) {
#line 209
    allocated_size = size_required;
  }
  {
#line 211
  allocated_size = ((allocated_size >> 10) + 1UL) << 10;
#line 212
  __cil_tmp9 = malloc(allocated_size);
#line 212
  allocated_buf = (uint8_t *)__cil_tmp9;
  }
#line 213
  if ((unsigned long )allocated_buf == (unsigned long )((void *)0)) {
#line 214
    bw->error_ = 1;
#line 215
    return (0);
  }
  {
#line 217
  memcpy((void *)allocated_buf, (void const   *)bw->buf_, current_size);
#line 218
  free((void *)bw->buf_);
#line 219
  bw->buf_ = allocated_buf;
#line 220
  bw->max_bytes_ = allocated_size;
#line 221
  memset((void *)(allocated_buf + current_size), 0, allocated_size - current_size);
  }
#line 222
  return (1);
}
}
#line 225 "/root/patchweave_new/13/src/utils/bit_writer.c"
int VP8LBitWriterInit(VP8LBitWriter *bw , size_t expected_size ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 226
  memset((void *)bw, 0, sizeof(*bw));
#line 227
  __cil_tmp3 = VP8LBitWriterResize(bw, expected_size);
  }
#line 227
  return (__cil_tmp3);
}
}
#line 230 "/root/patchweave_new/13/src/utils/bit_writer.c"
void VP8LBitWriterDestroy(VP8LBitWriter *bw ) 
{ 


  {
#line 231
  if ((unsigned long )bw != (unsigned long )((void *)0)) {
    {
#line 232
    free((void *)bw->buf_);
#line 233
    memset((void *)bw, 0, sizeof(*bw));
    }
  }
#line 236
  return;
}
}
#line 237 "/root/patchweave_new/13/src/utils/bit_writer.c"
void VP8LWriteBits(VP8LBitWriter *bw , int n_bits , uint32_t bits ) 
{ 
  uint8_t *p ;
  uint32_t v ;
  uint64_t extra_size ;
  int __cil_tmp7 ;

  {
#line 238
  if (n_bits < 1) {
#line 238
    return;
  }
#line 243
  p = bw->buf_ + (bw->bit_pos_ >> 3);
#line 244
  v = *((uint32_t *)p);
#line 245
  v |= bits << (bw->bit_pos_ & 7UL);
#line 246
  *((uint32_t *)p) = v;
#line 247
  bw->bit_pos_ += (unsigned long )n_bits;
#line 270
  if (bw->bit_pos_ >> 3 > bw->max_bytes_ - 8UL) {
    {
#line 271
    extra_size = (uint64_t )(32768ULL + (unsigned long long )bw->max_bytes_);
#line 272
    __cil_tmp7 = VP8LBitWriterResize(bw, extra_size);
    }
#line 272
    if (extra_size != extra_size) {
#line 274
      bw->bit_pos_ = (size_t )0;
#line 275
      bw->error_ = 1;
    } else
#line 272
    if (! __cil_tmp7) {
#line 274
      bw->bit_pos_ = (size_t )0;
#line 275
      bw->error_ = 1;
    }
  }
#line 278
  return;
}
}
#line 132 "/root/patchweave_new/13/src/utils/./bit_reader.h"
void VP8InitBitReader(VP8BitReader *br , uint8_t *start , uint8_t *end ) ;
#line 136
uint32_t VP8GetValue(VP8BitReader *br , int bits ) ;
#line 137 "/root/patchweave_new/13/src/utils/./bit_reader.h"
__inline static uint32_t VP8Get(VP8BitReader *br ) 
{ 
  uint32_t __cil_tmp2 ;

  {
  {
#line 138
  __cil_tmp2 = VP8GetValue(br, 1);
  }
#line 138
  return (__cil_tmp2);
}
}
#line 142
int32_t VP8GetSignedValue(VP8BitReader *br , int bits ) ;
#line 145
uint8_t kVP8Log2Range[128] ;
#line 146
range_t kVP8NewRange[128] ;
#line 148
void VP8LoadFinalBytes(VP8BitReader *br ) ;
#line 150 "/root/patchweave_new/13/src/utils/./bit_reader.h"
__inline static void VP8LoadNewBytes(VP8BitReader *br ) 
{ 
  bit_t bits ;
  lbit_t in_bits ;
  long __cil_tmp5 ;

  {
#line 153
  if ((unsigned long )(br->buf_ + sizeof(lbit_t )) <= (unsigned long )br->buf_end_) {
    {
#line 156
    in_bits = *((lbit_t *)br->buf_);
#line 157
    br->buf_ += 56 >> 3;
#line 163
    __cil_tmp5 = __builtin_bswap64((long )in_bits);
#line 163
    bits = (bit_t )__cil_tmp5;
#line 177
    bits >>= 8;
#line 201
    br->value_ = bits | (br->value_ << 56);
#line 203
    br->bits_ += 56;
    }
  } else {
    {
#line 205
    VP8LoadFinalBytes(br);
    }
  }
#line 208
  return;
}
}
#line 209 "/root/patchweave_new/13/src/utils/./bit_reader.h"
__inline static int VP8BitUpdate(VP8BitReader *br , range_t split ) 
{ 
  int pos ;
  range_t value ;

  {
#line 210
  if (br->bits_ < 0) {
    {
#line 211
    VP8LoadNewBytes(br);
    }
  }
#line 225
  pos = br->bits_;
#line 226
  value = (range_t )(br->value_ >> pos);
#line 227
  if (value > split) {
#line 228
    br->range_ -= split + 1U;
#line 229
    br->value_ -= (bit_t )(split + 1U) << pos;
#line 230
    return (1);
  } else {
#line 232
    br->range_ = split;
#line 233
    return (0);
  }
}
}
#line 239 "/root/patchweave_new/13/src/utils/./bit_reader.h"
__inline static void VP8Shift(VP8BitReader *br ) 
{ 
  int shift ;

  {
#line 248
  shift = (int )kVP8Log2Range[br->range_];
#line 250
  br->range_ = kVP8NewRange[br->range_];
#line 251
  br->bits_ -= shift;
#line 252
  return;
}
}
#line 254 "/root/patchweave_new/13/src/utils/./bit_reader.h"
__inline static int VP8GetBit(VP8BitReader *br , int prob ) 
{ 
  range_t split ;
  int bit ;
  int __cil_tmp5 ;

  {
  {
#line 266
  split = br->range_ * (unsigned int )prob >> 8;
#line 267
  __cil_tmp5 = VP8BitUpdate(br, split);
#line 267
  bit = __cil_tmp5;
  }
#line 268
  if (br->range_ <= 126U) {
    {
#line 269
    VP8Shift(br);
    }
  }
#line 271
  return (bit);
}
}
#line 275 "/root/patchweave_new/13/src/utils/./bit_reader.h"
__inline static int VP8GetSigned(VP8BitReader *br , int v ) 
{ 
  range_t split ;
  int bit ;
  int __cil_tmp5 ;
  int tmp ;

  {
  {
#line 276
  split = br->range_ >> 1;
#line 277
  __cil_tmp5 = VP8BitUpdate(br, split);
#line 277
  bit = __cil_tmp5;
#line 278
  VP8Shift(br);
  }
#line 279
  if (bit) {
#line 279
    tmp = - v;
  } else {
#line 279
    tmp = v;
  }
#line 279
  return (tmp);
}
}
#line 298
void VP8LInitBitReader(VP8LBitReader *br , uint8_t *start , size_t length ) ;
#line 303
void VP8LBitReaderSetBuffer(VP8LBitReader *br , uint8_t *buf , size_t len ) ;
#line 309
uint32_t VP8LReadBits(VP8LBitReader *br , int n_bits ) ;
#line 312 "/root/patchweave_new/13/src/utils/./bit_reader.h"
__inline static uint32_t VP8LPrefetchBits(VP8LBitReader *br ) 
{ 


  {
#line 313
  return ((uint32_t )(br->val_ >> br->bit_pos_));
}
}
#line 317 "/root/patchweave_new/13/src/utils/./bit_reader.h"
__inline static void VP8LDiscardBits(VP8LBitReader *br , int num_bits ) 
{ 


  {
#line 318
  br->bit_pos_ += num_bits;
#line 319
  return;
}
}
#line 322
void VP8LFillBitWindow(VP8LBitReader *br ) ;
#line 27 "/root/patchweave_new/13/src/utils/bit_reader.c"
void VP8InitBitReader(VP8BitReader *br , uint8_t *start , uint8_t *end ) 
{ 


  {
#line 32
  br->range_ = (range_t )254;
#line 33
  br->buf_ = start;
#line 34
  br->buf_end_ = end;
#line 35
  br->value_ = (bit_t )0;
#line 36
  br->bits_ = -8;
#line 37
  br->eof_ = 0;
#line 38
  return;
}
}
#line 40 "/root/patchweave_new/13/src/utils/bit_reader.c"
uint8_t kVP8Log2Range[128]  = 
#line 40
  {      (uint8_t )7,      (uint8_t )6,      (uint8_t )6,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )0};
#line 53 "/root/patchweave_new/13/src/utils/bit_reader.c"
range_t kVP8NewRange[128]  = 
#line 53
  {      (range_t )127,      (range_t )127,      (range_t )191,      (range_t )127, 
        (range_t )159,      (range_t )191,      (range_t )223,      (range_t )127, 
        (range_t )143,      (range_t )159,      (range_t )175,      (range_t )191, 
        (range_t )207,      (range_t )223,      (range_t )239,      (range_t )127, 
        (range_t )135,      (range_t )143,      (range_t )151,      (range_t )159, 
        (range_t )167,      (range_t )175,      (range_t )183,      (range_t )191, 
        (range_t )199,      (range_t )207,      (range_t )215,      (range_t )223, 
        (range_t )231,      (range_t )239,      (range_t )247,      (range_t )127, 
        (range_t )131,      (range_t )135,      (range_t )139,      (range_t )143, 
        (range_t )147,      (range_t )151,      (range_t )155,      (range_t )159, 
        (range_t )163,      (range_t )167,      (range_t )171,      (range_t )175, 
        (range_t )179,      (range_t )183,      (range_t )187,      (range_t )191, 
        (range_t )195,      (range_t )199,      (range_t )203,      (range_t )207, 
        (range_t )211,      (range_t )215,      (range_t )219,      (range_t )223, 
        (range_t )227,      (range_t )231,      (range_t )235,      (range_t )239, 
        (range_t )243,      (range_t )247,      (range_t )251,      (range_t )127, 
        (range_t )129,      (range_t )131,      (range_t )133,      (range_t )135, 
        (range_t )137,      (range_t )139,      (range_t )141,      (range_t )143, 
        (range_t )145,      (range_t )147,      (range_t )149,      (range_t )151, 
        (range_t )153,      (range_t )155,      (range_t )157,      (range_t )159, 
        (range_t )161,      (range_t )163,      (range_t )165,      (range_t )167, 
        (range_t )169,      (range_t )171,      (range_t )173,      (range_t )175, 
        (range_t )177,      (range_t )179,      (range_t )181,      (range_t )183, 
        (range_t )185,      (range_t )187,      (range_t )189,      (range_t )191, 
        (range_t )193,      (range_t )195,      (range_t )197,      (range_t )199, 
        (range_t )201,      (range_t )203,      (range_t )205,      (range_t )207, 
        (range_t )209,      (range_t )211,      (range_t )213,      (range_t )215, 
        (range_t )217,      (range_t )219,      (range_t )221,      (range_t )223, 
        (range_t )225,      (range_t )227,      (range_t )229,      (range_t )231, 
        (range_t )233,      (range_t )235,      (range_t )237,      (range_t )239, 
        (range_t )241,      (range_t )243,      (range_t )245,      (range_t )247, 
        (range_t )249,      (range_t )251,      (range_t )253,      (range_t )127};
#line 74 "/root/patchweave_new/13/src/utils/bit_reader.c"
void VP8LoadFinalBytes(VP8BitReader *br ) 
{ 
  uint8_t *__cil_tmp3 ;

  {
#line 77
  if ((unsigned long )br->buf_ < (unsigned long )br->buf_end_) {
#line 81
    __cil_tmp3 = br->buf_;
#line 81
    (br->buf_) ++;
#line 81
    br->value_ = (bit_t )*__cil_tmp3 | (br->value_ << 8);
#line 83
    br->bits_ += 8;
  } else
#line 84
  if (! br->eof_) {
#line 88
    br->value_ <<= 8;
#line 89
    br->bits_ += 8;
#line 91
    br->eof_ = 1;
  }
#line 93
  return;
}
}
#line 98 "/root/patchweave_new/13/src/utils/bit_reader.c"
uint32_t VP8GetValue(VP8BitReader *br , int bits ) 
{ 
  uint32_t v ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 99
  v = (uint32_t )0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    __cil_tmp4 = bits;
#line 100
    bits --;
#line 100
    if (! (__cil_tmp4 > 0)) {
#line 100
      goto while_break;
    }
    {
#line 101
    __cil_tmp5 = VP8GetBit(br, 128);
#line 101
    v |= (unsigned int )(__cil_tmp5 << bits);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 103
  return (v);
}
}
#line 106 "/root/patchweave_new/13/src/utils/bit_reader.c"
int32_t VP8GetSignedValue(VP8BitReader *br , int bits ) 
{ 
  int value ;
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;
  int tmp ;

  {
  {
#line 107
  __cil_tmp4 = VP8GetValue(br, bits);
#line 107
  value = (int )__cil_tmp4;
#line 108
  __cil_tmp5 = VP8Get(br);
  }
#line 108
  if (__cil_tmp5) {
#line 108
    tmp = - value;
  } else {
#line 108
    tmp = value;
  }
#line 108
  return (tmp);
}
}
#line 120 "/root/patchweave_new/13/src/utils/bit_reader.c"
static uint32_t kBitMask[25]  = 
#line 120
  {      (uint32_t )0,      (uint32_t )1,      (uint32_t )3,      (uint32_t )7, 
        (uint32_t )15,      (uint32_t )31,      (uint32_t )63,      (uint32_t )127, 
        (uint32_t )255,      (uint32_t )511,      (uint32_t )1023,      (uint32_t )2047, 
        (uint32_t )4095,      (uint32_t )8191,      (uint32_t )16383,      (uint32_t )32767, 
        (uint32_t )65535,      (uint32_t )131071,      (uint32_t )262143,      (uint32_t )524287, 
        (uint32_t )1048575,      (uint32_t )2097151,      (uint32_t )4194303,      (uint32_t )8388607, 
        (uint32_t )16777215};
#line 125 "/root/patchweave_new/13/src/utils/bit_reader.c"
void VP8LInitBitReader(VP8LBitReader *br , uint8_t *start , size_t length ) 
{ 
  size_t i ;

  {
#line 133
  br->buf_ = start;
#line 134
  br->len_ = length;
#line 135
  br->val_ = (vp8l_val_t )0;
#line 136
  br->pos_ = (size_t )0;
#line 137
  br->bit_pos_ = 0;
#line 138
  br->eos_ = 0;
#line 139
  br->error_ = 0;
#line 140
  i = (size_t )0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;

#line 140
    if (i < sizeof(br->val_)) {
#line 140
      if (! (i < br->len_)) {
#line 140
        goto while_break;
      }
    } else {
#line 140
      goto while_break;
    }
#line 141
    br->val_ |= (vp8l_val_t )*(br->buf_ + br->pos_) << 8UL * i;
#line 142
    (br->pos_) ++;
#line 140
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 144
  return;
}
}
#line 146 "/root/patchweave_new/13/src/utils/bit_reader.c"
void VP8LBitReaderSetBuffer(VP8LBitReader *br , uint8_t *buf , size_t len ) 
{ 


  {
#line 151
  br->eos_ = br->pos_ >= len;
#line 152
  br->buf_ = buf;
#line 153
  br->len_ = len;
#line 154
  return;
}
}
#line 157 "/root/patchweave_new/13/src/utils/bit_reader.c"
static void ShiftBytes(VP8LBitReader *br ) 
{ 


  {
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;

#line 158
    if (br->bit_pos_ >= 8) {
#line 158
      if (! (br->pos_ < br->len_)) {
#line 158
        goto while_break;
      }
    } else {
#line 158
      goto while_break;
    }
#line 159
    br->val_ >>= 8;
#line 160
    br->val_ |= (vp8l_val_t )*(br->buf_ + br->pos_) << 56;
#line 161
    (br->pos_) ++;
#line 162
    br->bit_pos_ -= 8;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 166
  return;
}
}
#line 166 "/root/patchweave_new/13/src/utils/bit_reader.c"
void VP8LFillBitWindow(VP8LBitReader *br ) 
{ 


  {
#line 167
  if (br->bit_pos_ >= 32) {
#line 169
    if (br->pos_ + sizeof(br->val_) < br->len_) {
#line 170
      br->val_ >>= 32;
#line 171
      br->bit_pos_ -= 32;
#line 174
      br->val_ |= *((vp8l_val_t *)(br->buf_ + br->pos_)) << 32;
#line 175
      br->pos_ += 4UL;
#line 176
      return;
    }
    {
#line 179
    ShiftBytes(br);
    }
#line 180
    if (br->pos_ == br->len_) {
#line 180
      if (br->bit_pos_ == 64) {
#line 181
        br->eos_ = 1;
      }
    }
  }
#line 185
  return;
}
}
#line 186 "/root/patchweave_new/13/src/utils/bit_reader.c"
uint32_t VP8LReadBits(VP8LBitReader *br , int n_bits ) 
{ 
  uint32_t val ;
  int new_bits ;

  {
#line 189
  if (! br->eos_) {
#line 189
    if (n_bits < 25) {
#line 190
      val = (uint32_t )(br->val_ >> br->bit_pos_) & kBitMask[n_bits];
#line 192
      new_bits = br->bit_pos_ + n_bits;
#line 193
      br->bit_pos_ = new_bits;
#line 195
      if (br->pos_ == br->len_) {
#line 196
        if (new_bits >= 64) {
#line 197
          br->eos_ = 1;
        }
      }
      {
#line 200
      ShiftBytes(br);
      }
#line 201
      return (val);
    } else {
#line 203
      br->error_ = 1;
#line 204
      return ((uint32_t )0);
    }
  } else {
#line 203
    br->error_ = 1;
#line 204
    return ((uint32_t )0);
  }
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 36 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
int WebPGetEncoderVersion(void) ;
#line 47
size_t WebPEncodeRGB(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 50
size_t WebPEncodeBGR(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 53
size_t WebPEncodeRGBA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 56
size_t WebPEncodeBGRA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 63
size_t WebPEncodeLosslessRGB(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 66
size_t WebPEncodeLosslessBGR(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 69
size_t WebPEncodeLosslessRGBA(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 72
size_t WebPEncodeLosslessBGRA(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 146
int WebPConfigInitInternal(WebPConfig *config , enum WebPPreset preset , float quality ,
                           int version ) ;
#line 169
int WebPValidateConfig(WebPConfig *config ) ;
#line 219
void WebPMemoryWriterInit(WebPMemoryWriter *writer ) ;
#line 224
int WebPMemoryWrite(uint8_t *data , size_t data_size , WebPPicture *picture ) ;
#line 337
int WebPPictureInitInternal(WebPPicture *picture , int version ) ;
#line 343 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
__inline static int WebPPictureInit(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 344
  __cil_tmp2 = WebPPictureInitInternal(picture, 513);
  }
#line 344
  return (__cil_tmp2);
}
}
#line 354
int WebPPictureAlloc(WebPPicture *picture ) ;
#line 361
void WebPPictureFree(WebPPicture *picture ) ;
#line 366
int WebPPictureCopy(WebPPicture *src , WebPPicture *dst ) ;
#line 372
int WebPPictureDistortion(WebPPicture *src , WebPPicture *ref , int type , float *result ) ;
#line 385
int WebPPictureCrop(WebPPicture *pic , int left , int top , int width , int height ) ;
#line 397
int WebPPictureView(WebPPicture *src , int left , int top , int width , int height ,
                    WebPPicture *dst ) ;
#line 403
int WebPPictureIsView(WebPPicture *picture ) ;
#line 408
int WebPPictureRescale(WebPPicture *pic , int width , int height ) ;
#line 414
int WebPPictureImportRGB(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) ;
#line 417
int WebPPictureImportRGBA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 422
int WebPPictureImportRGBX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 426
int WebPPictureImportBGR(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) ;
#line 428
int WebPPictureImportBGRA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 430
int WebPPictureImportBGRX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 438
int WebPPictureARGBToYUVA(WebPPicture *picture , enum WebPEncCSP colorspace ) ;
#line 447
int WebPPictureYUVAToARGB(WebPPicture *picture ) ;
#line 452
void WebPCleanupTransparentArea(WebPPicture *pic ) ;
#line 457
int WebPPictureHasTransparency(WebPPicture *picture ) ;
#line 462
void WebPBlendAlpha(WebPPicture *pic , uint32_t background_rgb ) ;
#line 477
int WebPEncode(WebPConfig *config , WebPPicture *pic ) ;
#line 47 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
int (*VP8GetCPUInfo)(CPUFeature  ) ;
#line 59 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8ITransform)(uint8_t * , int16_t * , uint8_t * , int  )  ;
#line 60 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8FTransform)(uint8_t * , uint8_t * , int16_t * )  ;
#line 61 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8ITransformWHT)(int16_t * , int16_t * )  ;
#line 62 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8FTransformWHT)(int16_t * , int16_t * )  ;
#line 68 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8EncPredLuma4)(uint8_t * , uint8_t * )  ;
#line 69 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8EncPredLuma16)(uint8_t * , uint8_t * , uint8_t * )  ;
#line 70 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8EncPredChroma8)(uint8_t * , uint8_t * , uint8_t * )  ;
#line 73 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
int (*VP8SSE16x16)(uint8_t * , uint8_t * )  ;
#line 73 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
int (*VP8SSE16x8)(uint8_t * , uint8_t * )  ;
#line 73 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
int (*VP8SSE8x8)(uint8_t * , uint8_t * )  ;
#line 73 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
int (*VP8SSE4x4)(uint8_t * , uint8_t * )  ;
#line 76 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
int (*VP8TDisto4x4)(uint8_t * , uint8_t * , uint16_t * const   )  ;
#line 76 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
int (*VP8TDisto16x16)(uint8_t * , uint8_t * , uint16_t * const   )  ;
#line 79 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8Copy4x4)(uint8_t * , uint8_t * )  ;
#line 84 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
int (*VP8EncQuantizeBlock)(int16_t * , int16_t * , int  , struct VP8Matrix * const   )  ;
#line 91
int const   VP8DspScan[24] ;
#line 92 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8CollectHistogram)(uint8_t * , uint8_t * , int  , int  , struct VP8Histogram * const   )  ;
#line 94
void VP8EncDspInit(void) ;
#line 102 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8Transform)(int16_t * , uint8_t * , int  )  ;
#line 103 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8TransformUV)(int16_t * , uint8_t * )  ;
#line 104 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8TransformDC)(int16_t * , uint8_t * )  ;
#line 105 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8TransformDCUV)(int16_t * , uint8_t * )  ;
#line 106
void (*VP8TransformWHT)(int16_t * , int16_t * ) ;
#line 111
VP8PredFunc VP8PredLuma16[7] ;
#line 112
VP8PredFunc VP8PredChroma8[7] ;
#line 113
VP8PredFunc VP8PredLuma4[10] ;
#line 117 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8SimpleVFilter16)(uint8_t * , int  , int  )  ;
#line 118 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8SimpleHFilter16)(uint8_t * , int  , int  )  ;
#line 119 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8SimpleVFilter16i)(uint8_t * , int  , int  )  ;
#line 120 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8SimpleHFilter16i)(uint8_t * , int  , int  )  ;
#line 128 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8VFilter16)(uint8_t * , int  , int  , int  , int  )  ;
#line 129 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8HFilter16)(uint8_t * , int  , int  , int  , int  )  ;
#line 130 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8VFilter8)(uint8_t * , uint8_t * , int  , int  , int  , int  )  ;
#line 131 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8HFilter8)(uint8_t * , uint8_t * , int  , int  , int  , int  )  ;
#line 134 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8VFilter16i)(uint8_t * , int  , int  , int  , int  )  ;
#line 135 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8HFilter16i)(uint8_t * , int  , int  , int  , int  )  ;
#line 136 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8VFilter8i)(uint8_t * , uint8_t * , int  , int  , int  , int  )  ;
#line 137 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
void (*VP8HFilter8i)(uint8_t * , uint8_t * , int  , int  , int  , int  )  ;
#line 140
void VP8DspInit(void) ;
#line 156 "/root/patchweave_new/13/src/enc/./../dsp/dsp.h"
WebPUpsampleLinePairFunc WebPUpsamplers[13]  ;
#line 159
void WebPInitUpsamplersSSE2(void) ;
#line 162
void WebPInitUpsamplersNEON(void) ;
#line 172
WebPSampleLinePairFunc WebPSamplers[13] ;
#line 177
WebPUpsampleLinePairFunc WebPGetLinePairConverter(int alpha_is_last ) ;
#line 184
WebPYUV444Converter WebPYUV444Converters[13] ;
#line 187
void WebPInitUpsamplers(void) ;
#line 194
void (*WebPApplyAlphaMultiply)(uint8_t * , int  , int  , int  , int  ) ;
#line 198
void (*WebPApplyAlphaMultiply4444)(uint8_t * , int  , int  , int  ) ;
#line 202
void WebPInitPremultiply(void) ;
#line 204
void WebPInitPremultiplySSE2(void) ;
#line 205
void WebPInitPremultiplyNEON(void) ;
#line 131 "/root/patchweave_new/13/src/enc/./vp8enci.h"
int const   VP8Scan[24] ;
#line 132
int const   VP8UVModeOffsets[4] ;
#line 133
int const   VP8I16ModeOffsets[4] ;
#line 134
int const   VP8I4ModeOffsets[10] ;
#line 167 "/root/patchweave_new/13/src/enc/./vp8enci.h"
__inline static int QUANTDIV(int n , int iQ , int B ) 
{ 


  {
#line 168
  return ((n * iQ + B) >> 17);
}
}
#line 299
void VP8IteratorInit(VP8Encoder *enc , VP8EncIterator *it ) ;
#line 301
void VP8IteratorReset(VP8EncIterator *it ) ;
#line 303
void VP8IteratorImport(VP8EncIterator *it ) ;
#line 305
void VP8IteratorExport(VP8EncIterator *it ) ;
#line 309
int VP8IteratorNext(VP8EncIterator *it , uint8_t *block_to_save ) ;
#line 312
int VP8IteratorProgress(VP8EncIterator *it , int delta ) ;
#line 315
void VP8IteratorStartI4(VP8EncIterator *it ) ;
#line 317
int VP8IteratorRotateI4(VP8EncIterator *it , uint8_t *yuv_out ) ;
#line 321
void VP8IteratorNzToBytes(VP8EncIterator *it ) ;
#line 322
void VP8IteratorBytesToNz(VP8EncIterator *it ) ;
#line 325
void VP8SetIntra16Mode(VP8EncIterator *it , int mode ) ;
#line 326
void VP8SetIntra4Mode(VP8EncIterator *it , uint8_t *modes ) ;
#line 327
void VP8SetIntraUVMode(VP8EncIterator *it , int mode ) ;
#line 328
void VP8SetSkip(VP8EncIterator *it , int skip ) ;
#line 329
void VP8SetSegment(VP8EncIterator *it , int segment ) ;
#line 346
void VP8TBufferInit(VP8TBuffer *b ) ;
#line 347
void VP8TBufferClear(VP8TBuffer *b ) ;
#line 353
int VP8EmitTokens(VP8TBuffer *b , VP8BitWriter *bw , uint8_t *probas , int final_pass ) ;
#line 357
int VP8RecordCoeffTokens(int ctx , int coeff_type , int first , int last , int16_t *coeffs ,
                         VP8TBuffer *tokens ) ;
#line 454
uint8_t VP8CoeffsProba0[4][8][3][11] ;
#line 456
uint8_t VP8CoeffsUpdateProba[4][8][3][11] ;
#line 458
void VP8DefaultProbas(VP8Encoder *enc ) ;
#line 460
void VP8WriteProbas(VP8BitWriter *bw , VP8Proba *probas ) ;
#line 462
void VP8CodeIntraModes(VP8Encoder *enc ) ;
#line 468
int VP8EncWrite(VP8Encoder *enc ) ;
#line 470
void VP8EncFreeBitWriters(VP8Encoder *enc ) ;
#line 473
uint8_t VP8EncBands[17] ;
#line 474
uint8_t VP8Cat3[3] ;
#line 475
uint8_t VP8Cat4[4] ;
#line 476
uint8_t VP8Cat5[5] ;
#line 477
uint8_t VP8Cat6[11] ;
#line 480
void VP8MakeLuma16Preds(VP8EncIterator *it ) ;
#line 482
void VP8MakeChroma8Preds(VP8EncIterator *it ) ;
#line 485
void VP8MakeIntra4Preds(VP8EncIterator *it ) ;
#line 487
int VP8GetCostLuma16(VP8EncIterator *it , VP8ModeScore *rd ) ;
#line 488
int VP8GetCostLuma4(VP8EncIterator *it , int16_t *levels ) ;
#line 489
int VP8GetCostUV(VP8EncIterator *it , VP8ModeScore *rd ) ;
#line 491
int VP8EncLoop(VP8Encoder *enc ) ;
#line 492
int VP8EncTokenLoop(VP8Encoder *enc ) ;
#line 496
int WebPEncodingSetError(WebPPicture *pic , enum WebPEncodingError___0 error ) ;
#line 497
int WebPReportProgress(WebPPicture *pic , int percent , int *percent_store ) ;
#line 503
int VP8EncAnalyze(VP8Encoder *enc ) ;
#line 507
void VP8SetSegmentParams(VP8Encoder *enc , float quality ) ;
#line 509
int VP8Decimate(VP8EncIterator *it , VP8ModeScore *rd , VP8RDLevel rd_opt ) ;
#line 513
void VP8EncInitAlpha(VP8Encoder *enc ) ;
#line 514
int VP8EncStartAlpha(VP8Encoder *enc ) ;
#line 515
int VP8EncFinishAlpha(VP8Encoder *enc ) ;
#line 516
int VP8EncDeleteAlpha(VP8Encoder *enc ) ;
#line 519
void VP8EncInitLayer(VP8Encoder *enc ) ;
#line 520
void VP8EncCodeLayerBlock(VP8EncIterator *it ) ;
#line 521
int VP8EncFinishLayer(VP8Encoder *enc ) ;
#line 522
void VP8EncDeleteLayer(VP8Encoder *enc ) ;
#line 530
void VP8SSIMAddStats(DistoStats *src , DistoStats *dst ) ;
#line 531
void VP8SSIMAccumulatePlane(uint8_t *src1 , int stride1 , uint8_t *src2 , int stride2 ,
                            int W , int H , DistoStats *stats ) ;
#line 534
double VP8SSIMGet(DistoStats *stats ) ;
#line 535
double VP8SSIMGetSquaredError(DistoStats *s ) ;
#line 538
void VP8InitFilter(VP8EncIterator *it ) ;
#line 539
void VP8StoreFilterStats(VP8EncIterator *it ) ;
#line 540
void VP8AdjustFilterStrength(VP8EncIterator *it ) ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 326
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 379
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) ;
#line 382
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 499
extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 500
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 510
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) ;
#line 646
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                                0L);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                                0L);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                                0L);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                                0L);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) sprintf)(char *__s ,
                                                                                             char const   *__fmt 
                                                                                             , ...) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) sprintf)(char *__s , char const   *__fmt 
                                                               , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size((void *)__s, 1);
#line 36
  __cil_tmp4 = (int )__builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s ,
                                                                                              char const   *__fmt ,
                                                                                              __gnuc_va_list __ap ) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsprintf)(char *__s , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 64
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) snprintf)(char *__s ,
                                                                                              size_t __n ,
                                                                                              char const   *__fmt 
                                                                                              , ...) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) snprintf)(char *__s , size_t __n ,
                                                                char const   *__fmt 
                                                                , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
#line 67
  __cil_tmp5 = (int )__builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s ,
                                                                                               size_t __n ,
                                                                                               char const   *__fmt ,
                                                                                               __gnuc_va_list __ap ) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vsnprintf)(char *__s , size_t __n ,
                                                                 char const   *__fmt ,
                                                                 __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size((void *)__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) fprintf)(FILE *__stream , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) printf)(char const   *__fmt 
                                                              , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = (int )__builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   *__fmt ,
                                                               __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vfprintf)(FILE *__stream , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) dprintf)(int __fd , char const   *__fmt 
                                                               , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = (int )__builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__)) vdprintf)(int __fd , char const   *__fmt ,
                                                                __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__gnu_inline__)) fgets)(char *__s , int __n ,
                                                               FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size((void *)__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 259
    __cil_tmp5 = 0;
#line 259
    if (! __cil_tmp5) {
      {
#line 260
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
#line 260
      __cil_tmp6 = __builtin_object_size((void *)__s, 1);
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size((void *)__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size((void *)__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long ( __attribute__((__gnu_inline__)) fread)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 289
    __cil_tmp7 = 0;
#line 289
    __cil_tmp6 = 0;
#line 289
    if (! __cil_tmp6) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) fread_unlocked)(void *__ptr ,
                                                                         size_t __size ,
                                                                         size_t __n ,
                                                                         FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
#line 350
    __cil_tmp7 = 0;
#line 350
    __cil_tmp6 = 0;
#line 350
    if (! __cil_tmp6) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
#line 362
  __cil_tmp14 = 0;
#line 362
  __cil_tmp13 = 0;
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;

#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: ;
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 37 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static int BitsLog2Floor(uint32_t n ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_clz(n);
  }
#line 39
  return (31 ^ __cil_tmp3);
}
}
#line 71 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static int VP8LBitsLog2Ceiling(uint32_t n ) 
{ 
  int log_floor ;
  int __cil_tmp3 ;

  {
  {
#line 72
  __cil_tmp3 = BitsLog2Floor(n);
#line 72
  log_floor = __cil_tmp3;
  }
#line 73
  if (n == (n & ~ (n - 1U))) {
#line 74
    return (log_floor);
  } else {
#line 76
    return (log_floor + 1);
  }
}
}
#line 82 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static void PrefixEncode(int distance , int *code , int *extra_bits_count ,
                                  int *extra_bits_value ) 
{ 
  int highest_bit ;
  int __cil_tmp6 ;
  int second_highest_bit ;
  int tmp ;

  {
#line 85
  if (distance > 2) {
    {
#line 86
    distance --;
#line 86
    __cil_tmp6 = BitsLog2Floor((uint32_t )distance);
#line 86
    highest_bit = __cil_tmp6;
#line 87
    second_highest_bit = (distance >> (highest_bit - 1)) & 1;
#line 88
    *extra_bits_count = highest_bit - 1;
#line 89
    *extra_bits_value = distance & ((1 << *extra_bits_count) - 1);
#line 90
    *code = 2 * highest_bit + second_highest_bit;
    }
  } else {
#line 92
    *extra_bits_count = 0;
#line 93
    *extra_bits_value = 0;
#line 94
    if (distance == 2) {
#line 94
      tmp = 1;
    } else {
#line 94
      tmp = 0;
    }
#line 94
    *code = tmp;
  }
#line 96
  return;
}
}
#line 115 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static PixOrCopy PixOrCopyCreateCopy(uint32_t distance , uint16_t len ) 
{ 
  PixOrCopy retval ;

  {
#line 118
  retval.mode = (uint8_t )2;
#line 119
  retval.argb_or_distance = distance;
#line 120
  retval.len = len;
#line 121
  return (retval);
}
}
#line 124 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static PixOrCopy PixOrCopyCreateCacheIdx(int idx ) 
{ 
  PixOrCopy retval ;

  {
#line 128
  retval.mode = (uint8_t )1;
#line 129
  retval.argb_or_distance = (uint32_t )idx;
#line 130
  retval.len = (uint16_t )1;
#line 131
  return (retval);
}
}
#line 134 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static PixOrCopy PixOrCopyCreateLiteral(uint32_t argb ) 
{ 
  PixOrCopy retval ;

  {
#line 136
  retval.mode = (uint8_t )0;
#line 137
  retval.argb_or_distance = argb;
#line 138
  retval.len = (uint16_t )1;
#line 139
  return (retval);
}
}
#line 142 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static int PixOrCopyIsLiteral(PixOrCopy *p ) 
{ 


  {
#line 143
  return ((int )p->mode == 0);
}
}
#line 146 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static int PixOrCopyIsCacheIdx(PixOrCopy *p ) 
{ 


  {
#line 147
  return ((int )p->mode == 1);
}
}
#line 150 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static int PixOrCopyIsCopy(PixOrCopy *p ) 
{ 


  {
#line 151
  return ((int )p->mode == 2);
}
}
#line 154 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static uint32_t PixOrCopyLiteral(PixOrCopy *p , int component ) 
{ 


  {
#line 157
  return ((p->argb_or_distance >> component * 8) & 255U);
}
}
#line 160 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static uint32_t PixOrCopyLength(PixOrCopy *p ) 
{ 


  {
#line 161
  return ((uint32_t )p->len);
}
}
#line 164 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static uint32_t PixOrCopyArgb(PixOrCopy *p ) 
{ 


  {
#line 166
  return (p->argb_or_distance);
}
}
#line 169 "/root/patchweave_new/13/src/enc/./././backward_references.h"
__inline static uint32_t PixOrCopyCacheIdx(PixOrCopy *p ) 
{ 


  {
#line 172
  return (p->argb_or_distance);
}
}
#line 190
void VP8LInitBackwardRefs(VP8LBackwardRefs *refs ) ;
#line 193
void VP8LClearBackwardRefs(VP8LBackwardRefs *refs ) ;
#line 196
int VP8LBackwardRefsAlloc(VP8LBackwardRefs *refs , int max_size ) ;
#line 203
int VP8LGetBackwardReferences(int width , int height , uint32_t *argb , int quality ,
                              int cache_bits , int use_2d_locality , VP8LBackwardRefs *best ) ;
#line 209
int VP8LCalculateEstimateForCacheSize(uint32_t *argb , int xsize , int ysize , int *best_cache_bits ) ;
#line 56 "/root/patchweave_new/13/src/enc/././histogram.h"
void VP8LHistogramCreate(VP8LHistogram *p , VP8LBackwardRefs *refs , int palette_code_bits ) ;
#line 61
void VP8LHistogramInit(VP8LHistogram *p , int palette_code_bits ) ;
#line 64
void VP8LHistogramStoreRefs(VP8LBackwardRefs *refs , VP8LHistogram *histo ) ;
#line 69
VP8LHistogramSet *VP8LAllocateHistogramSet(int size , int cache_bits ) ;
#line 72
void VP8LHistogramAddSinglePixOrCopy(VP8LHistogram *histo , PixOrCopy *v ) ;
#line 77
double VP8LHistogramEstimateBits(VP8LHistogram *p ) ;
#line 81
double VP8LHistogramEstimateBitsBulk(VP8LHistogram *p ) ;
#line 83 "/root/patchweave_new/13/src/enc/././histogram.h"
__inline static int VP8LHistogramNumCodes(VP8LHistogram *p ) 
{ 
  int tmp ;

  {
#line 84
  if (p->palette_code_bits_ > 0) {
#line 84
    tmp = 1 << p->palette_code_bits_;
  } else {
#line 84
    tmp = 0;
  }
#line 84
  return (280 + tmp);
}
}
#line 89
int VP8LGetHistoImageSymbols(int xsize , int ysize , VP8LBackwardRefs *refs , int quality ,
                             int histo_bits , int cache_bits , VP8LHistogramSet *image_in ,
                             uint16_t *histogram_symbols ) ;
#line 54 "/root/patchweave_new/13/src/enc/./vp8li.h"
int VP8LEncodeImage(WebPConfig *config , WebPPicture *picture ) ;
#line 58
enum WebPEncodingError___0 VP8LEncodeStream(WebPConfig *config , WebPPicture *picture ,
                                            VP8LBitWriter *bw ) ;
#line 33 "/root/patchweave_new/13/src/enc/webpenc.c"
int WebPGetEncoderVersion(void) 
{ 


  {
#line 34
  return (3 << 8);
}
}
#line 41 "/root/patchweave_new/13/src/enc/webpenc.c"
static int DummyWriter(uint8_t *data , size_t data_size , WebPPicture *picture ) 
{ 


  {
#line 47
  return (1);
}
}
#line 50 "/root/patchweave_new/13/src/enc/webpenc.c"
int WebPPictureInitInternal(WebPPicture *picture , int version ) 
{ 


  {
#line 51
  if (version >> 8 != 513 >> 8) {
#line 52
    return (0);
  }
#line 54
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
    {
#line 55
    memset((void *)picture, 0, sizeof(*picture));
#line 56
    picture->writer = & DummyWriter;
#line 57
    WebPEncodingSetError(picture, (enum WebPEncodingError___0 )0);
    }
  }
#line 59
  return (1);
}
}
#line 66 "/root/patchweave_new/13/src/enc/webpenc.c"
static void ResetSegmentHeader(VP8Encoder *enc ) 
{ 
  VP8SegmentHeader *hdr ;

  {
#line 67
  hdr = & enc->segment_hdr_;
#line 68
  hdr->num_segments_ = (enc->config_)->segments;
#line 69
  hdr->update_map_ = hdr->num_segments_ > 1;
#line 70
  hdr->size_ = 0;
#line 71
  return;
}
}
#line 73 "/root/patchweave_new/13/src/enc/webpenc.c"
static void ResetFilterHeader(VP8Encoder *enc ) 
{ 
  VP8FilterHeader *hdr ;

  {
#line 74
  hdr = & enc->filter_hdr_;
#line 75
  hdr->simple_ = 1;
#line 76
  hdr->level_ = 0;
#line 77
  hdr->sharpness_ = 0;
#line 78
  hdr->i4x4_lf_delta_ = 0;
#line 79
  return;
}
}
#line 81 "/root/patchweave_new/13/src/enc/webpenc.c"
static void ResetBoundaryPredictions(VP8Encoder *enc ) 
{ 
  int i ;
  uint8_t *top ;
  uint8_t *left ;

  {
#line 85
  top = enc->preds_ - enc->preds_w_;
#line 86
  left = enc->preds_ - 1;
#line 87
  i = -1;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;

#line 87
    if (! (i < 4 * enc->mb_w_)) {
#line 87
      goto while_break;
    }
#line 88
    *(top + i) = (uint8_t )0;
#line 87
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 90
    if (! (i < 4 * enc->mb_h_)) {
#line 90
      goto while_break___0;
    }
#line 91
    *(left + i * enc->preds_w_) = (uint8_t )0;
#line 90
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 93
  *(enc->nz_ + -1) = (uint32_t )0;
#line 94
  return;
}
}
#line 119 "/root/patchweave_new/13/src/enc/webpenc.c"
static void MapConfigToTools(VP8Encoder *enc ) 
{ 
  WebPConfig *config ;
  int method ;
  int limit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 120
  config = enc->config_;
#line 121
  method = config->method;
#line 122
  limit = 100 - config->partition_limit;
#line 123
  enc->method_ = method;
#line 124
  if (method >= 6) {
#line 124
    tmp___1 = 3;
  } else {
#line 124
    if (method >= 5) {
#line 124
      tmp___0 = 2;
    } else {
#line 124
      if (method >= 3) {
#line 124
        tmp = 1;
      } else {
#line 124
        tmp = 0;
      }
#line 124
      tmp___0 = tmp;
    }
#line 124
    tmp___1 = tmp___0;
  }
#line 124
  enc->rd_opt_level_ = (VP8RDLevel )tmp___1;
#line 128
  enc->max_i4_header_bits_ = (65536 * (limit * limit)) / 10000;
#line 132
  enc->thread_level_ = config->thread_level;
#line 134
  if (config->target_size > 0) {
#line 134
    tmp___2 = 1;
  } else
#line 134
  if (config->target_PSNR > (float )0) {
#line 134
    tmp___2 = 1;
  } else {
#line 134
    tmp___2 = 0;
  }
#line 134
  enc->do_search_ = tmp___2;
#line 135
  if (! config->low_memory) {
#line 137
    if (method >= 3) {
#line 137
      if (! enc->do_search_) {
#line 137
        tmp___3 = 1;
      } else {
#line 137
        tmp___3 = 0;
      }
    } else {
#line 137
      tmp___3 = 0;
    }
#line 137
    enc->use_tokens_ = tmp___3;
#line 139
    if (enc->use_tokens_) {
#line 140
      enc->num_parts_ = 1;
    }
  }
#line 143
  return;
}
}
#line 166 "/root/patchweave_new/13/src/enc/webpenc.c"
static VP8Encoder *InitVP8Encoder(WebPConfig *config , WebPPicture *picture ) 
{ 
  int use_filter ;
  int mb_w ;
  int mb_h ;
  int preds_w ;
  int preds_h ;
  size_t preds_size ;
  int top_stride ;
  size_t nz_size ;
  size_t cache_size ;
  size_t info_size ;
  size_t samples_size ;
  size_t lf_stats_size ;
  unsigned long tmp ;
  VP8Encoder *enc ;
  uint8_t *mem ;
  uint64_t size ;
  void *__cil_tmp19 ;
  LFStats *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 168
  if (config->filter_strength > 0) {
#line 168
    tmp___3 = 1;
  } else
#line 168
  if (config->autofilter > 0) {
#line 168
    tmp___3 = 1;
  } else {
#line 168
    tmp___3 = 0;
  }
#line 168
  use_filter = tmp___3;
#line 170
  mb_w = (picture->width + 15) >> 4;
#line 171
  mb_h = (picture->height + 15) >> 4;
#line 172
  preds_w = 4 * mb_w + 1;
#line 173
  preds_h = 4 * mb_h + 1;
#line 174
  preds_size = (unsigned long )(preds_w * preds_h) * sizeof(uint8_t );
#line 175
  top_stride = mb_w * 16;
#line 176
  nz_size = (unsigned long )(mb_w + 1) * sizeof(uint32_t );
#line 177
  cache_size = 2880UL * sizeof(uint8_t );
#line 178
  info_size = (unsigned long )(mb_w * mb_h) * sizeof(VP8MBInfo );
#line 179
  samples_size = (unsigned long )((((((2 * top_stride + 16) + 16) + 16) + 8) + 1) + 30) * sizeof(uint8_t );
#line 183
  if (config->autofilter) {
#line 183
    tmp = sizeof(LFStats ) + 15UL;
  } else {
#line 183
    tmp = 0UL;
  }
  {
#line 183
  lf_stats_size = tmp;
#line 187
  size = ((((((sizeof(VP8Encoder ) + 15UL) + cache_size) + info_size) + preds_size) + samples_size) + nz_size) + lf_stats_size;
#line 222
  __cil_tmp19 = WebPSafeMalloc(size, sizeof(*mem));
#line 222
  mem = (uint8_t *)__cil_tmp19;
  }
#line 223
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
    {
#line 224
    WebPEncodingSetError(picture, (enum WebPEncodingError___0 )1);
    }
#line 225
    return ((VP8Encoder *)((void *)0));
  }
  {
#line 227
  enc = (VP8Encoder *)mem;
#line 228
  mem = (uint8_t *)((uintptr_t )((mem + sizeof(*enc)) + 15) & 0xfffffffffffffff0UL);
#line 229
  memset((void *)enc, 0, sizeof(*enc));
#line 230
  enc->num_parts_ = 1 << config->partitions;
#line 231
  enc->mb_w_ = mb_w;
#line 232
  enc->mb_h_ = mb_h;
#line 233
  enc->preds_w_ = preds_w;
#line 234
  enc->yuv_in_ = mem;
#line 235
  mem += 384;
#line 236
  enc->yuv_out_ = mem;
#line 237
  mem += 384;
#line 238
  enc->yuv_out2_ = mem;
#line 239
  mem += 384;
#line 240
  enc->yuv_p_ = mem;
#line 241
  mem += 1728;
#line 242
  enc->mb_info_ = (VP8MBInfo *)mem;
#line 243
  mem += info_size;
#line 244
  enc->preds_ = (mem + 1) + enc->preds_w_;
#line 245
  mem += (unsigned long )(preds_w * preds_h) * sizeof(uint8_t );
#line 246
  enc->nz_ = (uint32_t *)mem + 1;
#line 247
  mem += nz_size;
  }
#line 248
  if (lf_stats_size) {
#line 248
    tmp___0 = (LFStats *)((uintptr_t )(mem + 15) & 0xfffffffffffffff0UL);
  } else {
#line 248
    tmp___0 = (LFStats *)((void *)0);
  }
#line 248
  enc->lf_stats_ = (LFStats *)((int )tmp___0);
#line 249
  mem += lf_stats_size;
#line 252
  mem = (uint8_t *)((uintptr_t )(mem + 15) & 0xfffffffffffffff0UL);
#line 253
  enc->y_top_ = mem;
#line 254
  enc->uv_top_ = enc->y_top_ + top_stride;
#line 255
  mem += 2 * top_stride;
#line 256
  mem = (uint8_t *)((uintptr_t )((mem + 1) + 15) & 0xfffffffffffffff0UL);
#line 257
  enc->y_left_ = mem;
#line 258
  mem += 32;
#line 259
  enc->u_left_ = mem;
#line 260
  mem += 16;
#line 261
  enc->v_left_ = mem;
#line 262
  mem += 8;
#line 264
  enc->config_ = config;
#line 265
  if (use_filter) {
#line 265
    if (config->filter_type == 1) {
#line 265
      tmp___1 = 0;
    } else {
#line 265
      tmp___1 = 1;
    }
#line 265
    tmp___2 = tmp___1;
  } else {
#line 265
    tmp___2 = 2;
  }
  {
#line 265
  enc->profile_ = tmp___2;
#line 266
  enc->pic_ = picture;
#line 267
  enc->percent_ = 0;
#line 269
  MapConfigToTools(enc);
#line 270
  VP8EncDspInit();
#line 271
  VP8DefaultProbas(enc);
#line 272
  ResetSegmentHeader(enc);
#line 273
  ResetFilterHeader(enc);
#line 274
  ResetBoundaryPredictions(enc);
#line 276
  VP8EncInitAlpha(enc);
#line 281
  VP8TBufferInit(& enc->tokens_);
  }
#line 282
  return (enc);
}
}
#line 285 "/root/patchweave_new/13/src/enc/webpenc.c"
static int DeleteVP8Encoder(VP8Encoder *enc ) 
{ 
  int ok ;

  {
#line 286
  ok = 1;
#line 287
  if ((unsigned long )enc != (unsigned long )((void *)0)) {
    {
#line 288
    ok = VP8EncDeleteAlpha(enc);
#line 292
    VP8TBufferClear(& enc->tokens_);
#line 293
    free((void *)enc);
    }
  }
#line 295
  return (ok);
}
}
#line 300 "/root/patchweave_new/13/src/enc/webpenc.c"
static double GetPSNR(uint64_t err , uint64_t size ) 
{ 
  double __cil_tmp3 ;
  double tmp ;

  {
#line 301
  if (err) {
    {
#line 301
    __cil_tmp3 = log10(((255. * 255.) * (double )size) / (double )err);
#line 301
    tmp = 10. * __cil_tmp3;
    }
  } else {
#line 301
    tmp = 99.;
  }
#line 301
  return (tmp);
}
}
#line 304 "/root/patchweave_new/13/src/enc/webpenc.c"
static void FinalizePSNR(VP8Encoder *enc ) 
{ 
  WebPAuxStats *stats ;
  uint64_t size ;
  uint64_t *sse ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;

  {
  {
#line 305
  stats = (enc->pic_)->stats;
#line 306
  size = enc->sse_count_;
#line 307
  sse = enc->sse_;
#line 308
  __cil_tmp5 = GetPSNR(*(sse + 0), size);
#line 308
  stats->PSNR[0] = (float )__cil_tmp5;
#line 309
  __cil_tmp6 = GetPSNR(*(sse + 1), size / 4UL);
#line 309
  stats->PSNR[1] = (float )__cil_tmp6;
#line 310
  __cil_tmp7 = GetPSNR(*(sse + 2), size / 4UL);
#line 310
  stats->PSNR[2] = (float )__cil_tmp7;
#line 311
  __cil_tmp8 = GetPSNR((*(sse + 0) + *(sse + 1)) + *(sse + 2), (size * 3UL) / 2UL);
#line 311
  stats->PSNR[3] = (float )__cil_tmp8;
#line 312
  __cil_tmp9 = GetPSNR(*(sse + 3), size);
#line 312
  stats->PSNR[4] = (float )__cil_tmp9;
  }
#line 314
  return;
}
}
#line 315 "/root/patchweave_new/13/src/enc/webpenc.c"
static void StoreStats(VP8Encoder *enc ) 
{ 
  WebPAuxStats *stats ;
  int i ;
  int s ;

  {
#line 316
  stats = (enc->pic_)->stats;
#line 317
  if ((unsigned long )stats != (unsigned long )((void *)0)) {
#line 319
    i = 0;
    {
#line 319
    while (1) {
      while_continue: /* CIL Label */ ;

#line 319
      if (! (i < 4)) {
#line 319
        goto while_break;
      }
#line 320
      stats->segment_level[i] = enc->dqm_[i].fstrength_;
#line 321
      stats->segment_quant[i] = enc->dqm_[i].quant_;
#line 322
      s = 0;
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 322
        if (! (s <= 2)) {
#line 322
          goto while_break___0;
        }
#line 323
        stats->residual_bytes[s][i] = enc->residual_bytes_[s][i];
#line 322
        s ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: 
#line 319
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
    {
#line 326
    FinalizePSNR(enc);
#line 327
    stats->coded_size = enc->coded_size_;
#line 328
    i = 0;
    }
    {
#line 328
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 328
      if (! (i < 3)) {
#line 328
        goto while_break___1;
      }
#line 329
      stats->block_count[i] = enc->block_count_[i];
#line 328
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
  {
#line 332
  WebPReportProgress(enc->pic_, 100, & enc->percent_);
  }
#line 334
  return;
}
}
#line 335 "/root/patchweave_new/13/src/enc/webpenc.c"
int WebPEncodingSetError(WebPPicture *pic , enum WebPEncodingError___0 error ) 
{ 


  {
#line 339
  pic->error_code = error;
#line 340
  return (0);
}
}
#line 343 "/root/patchweave_new/13/src/enc/webpenc.c"
int WebPReportProgress(WebPPicture *pic , int percent , int *percent_store ) 
{ 
  int __cil_tmp4 ;

  {
#line 345
  if ((unsigned long )percent_store != (unsigned long )((void *)0)) {
#line 345
    if (percent != *percent_store) {
      {
#line 346
      *percent_store = percent;
#line 347
      __cil_tmp4 = (*(pic->progress_hook))(percent, pic);
      }
#line 347
      if (pic->progress_hook) {
#line 347
        if (! __cil_tmp4) {
          {
#line 349
          WebPEncodingSetError(pic, (enum WebPEncodingError___0 )10);
          }
#line 350
          return (0);
        }
      }
    }
  }
#line 353
  return (1);
}
}
#line 357 "/root/patchweave_new/13/src/enc/webpenc.c"
int WebPEncode(WebPConfig *config , WebPPicture *pic ) 
{ 
  int ok ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  VP8Encoder *enc ;
  int __cil_tmp10 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 358
  ok = 0;
#line 360
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 361
    return (0);
  }
  {
#line 362
  WebPEncodingSetError(pic, (enum WebPEncodingError___0 )0);
  }
#line 363
  if ((unsigned long )config == (unsigned long )((void *)0)) {
    {
#line 364
    __cil_tmp4 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )3);
    }
#line 364
    return (__cil_tmp4);
  }
  {
#line 365
  __cil_tmp5 = WebPValidateConfig(config);
  }
#line 365
  if (! __cil_tmp5) {
    {
#line 366
    __cil_tmp6 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )4);
    }
#line 366
    return (__cil_tmp6);
  }
#line 367
  if (pic->width <= 0) {
    {
#line 368
    __cil_tmp7 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )5);
    }
#line 368
    return (__cil_tmp7);
  } else
#line 367
  if (pic->height <= 0) {
    {
#line 368
    __cil_tmp7 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )5);
    }
#line 368
    return (__cil_tmp7);
  }
#line 369
  if (pic->width > 16383) {
    {
#line 370
    __cil_tmp8 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )5);
    }
#line 370
    return (__cil_tmp8);
  } else
#line 369
  if (pic->height > 16383) {
    {
#line 370
    __cil_tmp8 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )5);
    }
#line 370
    return (__cil_tmp8);
  }
#line 372
  if ((unsigned long )pic->stats != (unsigned long )((void *)0)) {
    {
#line 372
    memset((void *)pic->stats, 0, sizeof(*(pic->stats)));
    }
  }
#line 374
  if (! config->lossless) {
#line 375
    enc = (VP8Encoder *)((void *)0);
#line 376
    if ((unsigned long )pic->y == (unsigned long )((void *)0)) {
      _L: 
      {
#line 378
      __cil_tmp10 = WebPPictureARGBToYUVA(pic, (enum WebPEncCSP )((enum WebPEncCSP___0 )0));
      }
#line 378
      if (! __cil_tmp10) {
#line 378
        return (0);
      }
    } else
#line 376
    if ((unsigned long )pic->u == (unsigned long )((void *)0)) {
#line 376
      goto _L;
    } else
#line 376
    if ((unsigned long )pic->v == (unsigned long )((void *)0)) {
#line 376
      goto _L;
    }
    {
#line 381
    enc = InitVP8Encoder(config, pic);
    }
#line 382
    if ((unsigned long )enc == (unsigned long )((void *)0)) {
#line 382
      return (0);
    }
    {
#line 384
    ok = VP8EncAnalyze(enc);
#line 387
    __cil_tmp13 = VP8EncStartAlpha(enc);
    }
#line 387
    if (ok) {
#line 387
      if (__cil_tmp13) {
#line 387
        tmp = 1;
      } else {
#line 387
        tmp = 0;
      }
    } else {
#line 387
      tmp = 0;
    }
#line 387
    ok = tmp;
#line 388
    if (! enc->use_tokens_) {
      {
#line 389
      __cil_tmp14 = VP8EncLoop(enc);
      }
#line 389
      if (ok) {
#line 389
        if (__cil_tmp14) {
#line 389
          tmp___0 = 1;
        } else {
#line 389
          tmp___0 = 0;
        }
      } else {
#line 389
        tmp___0 = 0;
      }
#line 389
      ok = tmp___0;
    } else {
      {
#line 391
      __cil_tmp15 = VP8EncTokenLoop(enc);
      }
#line 391
      if (ok) {
#line 391
        if (__cil_tmp15) {
#line 391
          tmp___1 = 1;
        } else {
#line 391
          tmp___1 = 0;
        }
      } else {
#line 391
        tmp___1 = 0;
      }
#line 391
      ok = tmp___1;
    }
    {
#line 393
    __cil_tmp16 = VP8EncFinishAlpha(enc);
    }
#line 393
    if (ok) {
#line 393
      if (__cil_tmp16) {
#line 393
        tmp___2 = 1;
      } else {
#line 393
        tmp___2 = 0;
      }
    } else {
#line 393
      tmp___2 = 0;
    }
    {
#line 393
    ok = tmp___2;
#line 398
    __cil_tmp17 = VP8EncWrite(enc);
    }
#line 398
    if (ok) {
#line 398
      if (__cil_tmp17) {
#line 398
        tmp___3 = 1;
      } else {
#line 398
        tmp___3 = 0;
      }
    } else {
#line 398
      tmp___3 = 0;
    }
    {
#line 398
    ok = tmp___3;
#line 399
    StoreStats(enc);
    }
#line 400
    if (! ok) {
      {
#line 401
      VP8EncFreeBitWriters(enc);
      }
    }
    {
#line 403
    __cil_tmp18 = DeleteVP8Encoder(enc);
#line 403
    ok &= __cil_tmp18;
    }
  } else {
    {
#line 406
    __cil_tmp19 = WebPPictureYUVAToARGB(pic);
    }
#line 406
    if ((unsigned long )pic->argb == (unsigned long )((void *)0)) {
#line 406
      if (! __cil_tmp19) {
#line 407
        return (0);
      }
    }
    {
#line 410
    ok = VP8LEncodeImage(config, pic);
    }
  }
#line 413
  return (ok);
}
}
#line 152 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
__inline static int WebPConfigInit___0(WebPConfig *config ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 153
  __cil_tmp2 = WebPConfigInitInternal(config, (enum WebPPreset )0, 75.f, 513);
  }
#line 153
  return (__cil_tmp2);
}
}
#line 161 "/root/patchweave_new/13/src/enc/./../webp/encode.h"
__inline static int WebPConfigPreset___0(WebPConfig *config , enum WebPPreset preset ,
                                         float quality ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 163
  __cil_tmp4 = WebPConfigInitInternal(config, preset, quality, 513);
  }
#line 163
  return (__cil_tmp4);
}
}
#line 37 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
int WebPGetDecoderVersion(void) ;
#line 43
int WebPGetInfo(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 51
uint8_t *WebPDecodeRGBA(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 55
uint8_t *WebPDecodeARGB(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 59
uint8_t *WebPDecodeBGRA(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 64
uint8_t *WebPDecodeRGB(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 68
uint8_t *WebPDecodeBGR(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 81
uint8_t *WebPDecodeYUV(uint8_t *data , size_t data_size , int *width , int *height ,
                       uint8_t **u , uint8_t **v , int *stride , int *uv_stride ) ;
#line 94
uint8_t *WebPDecodeRGBAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) ;
#line 97
uint8_t *WebPDecodeARGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) ;
#line 100
uint8_t *WebPDecodeBGRAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) ;
#line 106
uint8_t *WebPDecodeRGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) ;
#line 109
uint8_t *WebPDecodeBGRInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) ;
#line 120
uint8_t *WebPDecodeYUVInto(uint8_t *data , size_t data_size , uint8_t *luma , size_t luma_size ,
                           int luma_stride , uint8_t *u , size_t u_size , int u_stride ,
                           uint8_t *v , size_t v_size , int v_stride ) ;
#line 208
int WebPInitDecBufferInternal(WebPDecBuffer *buffer , int version ) ;
#line 212 "/root/patchweave_new/13/src/enc/../dsp/../webp/decode.h"
__inline static int WebPInitDecBuffer(WebPDecBuffer *buffer ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 213
  __cil_tmp2 = WebPInitDecBufferInternal(buffer, 513);
  }
#line 213
  return (__cil_tmp2);
}
}
#line 218
void WebPFreeDecBuffer(WebPDecBuffer *buffer ) ;
#line 272
WebPIDecoder *WebPINewDecoder(WebPDecBuffer *output_buffer ) ;
#line 284
WebPIDecoder *WebPINewRGB(enum WEBP_CSP_MODE mode , uint8_t *output_buffer , size_t output_buffer_size ,
                          int output_stride ) ;
#line 299
WebPIDecoder *WebPINewYUVA(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                           size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                           int v_stride , uint8_t *a , size_t a_size , int a_stride ) ;
#line 307
WebPIDecoder *WebPINewYUV(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                          size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                          int v_stride ) ;
#line 314
void WebPIDelete(WebPIDecoder *idec ) ;
#line 319
enum VP8StatusCode___0 WebPIAppend(WebPIDecoder *idec , uint8_t *data , size_t data_size ) ;
#line 327
enum VP8StatusCode___0 WebPIUpdate(WebPIDecoder *idec , uint8_t *data , size_t data_size ) ;
#line 336
uint8_t *WebPIDecGetRGB(WebPIDecoder *idec , int *last_y , int *width , int *height ,
                        int *stride ) ;
#line 343
uint8_t *WebPIDecGetYUVA(WebPIDecoder *idec , int *last_y , uint8_t **u , uint8_t **v ,
                         uint8_t **a , int *width , int *height , int *stride , int *uv_stride ,
                         int *a_stride ) ;
#line 363
WebPDecBuffer *WebPIDecodedArea(WebPIDecoder *idec , int *left , int *top , int *width ,
                                int *height ) ;
#line 416
enum VP8StatusCode___0 WebPGetFeaturesInternal(uint8_t *data , size_t data_size ,
                                               WebPBitstreamFeatures *features , int version ) ;
#line 457
int WebPInitDecoderConfigInternal(WebPDecoderConfig *config , int version ) ;
#line 475
WebPIDecoder *WebPIDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) ;
#line 481
enum VP8StatusCode___0 WebPDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) ;
#line 32 "/root/patchweave_new/13/src/enc/../dsp/lossless.h"
void VP8LInverseTransform(VP8LTransform *transform , int row_start , int row_end ,
                          uint32_t *in , uint32_t *out ) ;
#line 37
void VP8LSubtractGreenFromBlueAndRed(uint32_t *argb_data , int num_pixs ) ;
#line 39
void VP8LResidualImage(int width , int height , int bits , uint32_t *argb , uint32_t *argb_scratch ,
                       uint32_t *image ) ;
#line 43
void VP8LColorSpaceTransform(int width , int height , int bits , int step , uint32_t *argb ,
                             uint32_t *image ) ;
#line 50
void VP8LConvertFromBGRA(uint32_t *in_data , int num_pixels , enum WEBP_CSP_MODE out_colorspace ,
                         uint8_t *rgba ) ;
#line 57 "/root/patchweave_new/13/src/enc/../dsp/lossless.h"
__inline static uint32_t VP8LSubSampleSize(uint32_t size , uint32_t sampling_bits ) 
{ 


  {
#line 59
  return (((size + (unsigned int )(1 << sampling_bits)) - 1U) >> sampling_bits);
}
}
#line 64
float const   kLog2Table[256] ;
#line 65
float const   kSLog2Table[256] ;
#line 66
float VP8LFastLog2Slow(int v ) ;
#line 67
float VP8LFastSLog2Slow(int v ) ;
#line 68 "/root/patchweave_new/13/src/enc/../dsp/lossless.h"
__inline static float VP8LFastLog2(int v ) 
{ 
  float __cil_tmp2 ;
  float tmp ;

  {
#line 69
  if (v < 256) {
#line 69
    tmp = (float )kLog2Table[v];
  } else {
    {
#line 69
    __cil_tmp2 = VP8LFastLog2Slow(v);
#line 69
    tmp = (float )((float const   )__cil_tmp2);
    }
  }
#line 69
  return ((float )((int )tmp));
}
}
#line 72 "/root/patchweave_new/13/src/enc/../dsp/lossless.h"
__inline static float VP8LFastSLog2(int v ) 
{ 
  float __cil_tmp2 ;
  float tmp ;

  {
#line 73
  if (v < 256) {
#line 73
    tmp = (float )kSLog2Table[v];
  } else {
    {
#line 73
    __cil_tmp2 = VP8LFastSLog2Slow(v);
#line 73
    tmp = (float )((float const   )__cil_tmp2);
    }
  }
#line 73
  return ((float )((int )tmp));
}
}
#line 78 "/root/patchweave_new/13/src/enc/../dsp/lossless.h"
__inline static uint32_t VP8LSubPixels(uint32_t a , uint32_t b ) 
{ 
  uint32_t alpha_and_green ;
  uint32_t red_and_blue ;

  {
#line 79
  alpha_and_green = (16711935U + (a & 4278255360U)) - (b & 4278255360U);
#line 81
  red_and_blue = (4278255360U + (a & 16711935U)) - (b & 16711935U);
#line 83
  return ((alpha_and_green & 4278255360U) | (red_and_blue & 16711935U));
}
}
#line 37 "/root/patchweave_new/13/src/enc/vp8l.c"
static int CompareColors(void const   *p1 , void const   *p2 ) 
{ 
  uint32_t a ;
  uint32_t b ;
  int tmp___0 ;

  {
#line 38
  a = *((uint32_t *)p1);
#line 39
  b = *((uint32_t *)p2);
#line 41
  if (a < b) {
#line 41
    tmp___0 = -1;
  } else {
#line 41
    tmp___0 = 1;
  }
#line 41
  return (tmp___0);
}
}
#line 56 "/root/patchweave_new/13/src/enc/vp8l.c"
static uint32_t kHashMul___15  ;
#line 46 "/root/patchweave_new/13/src/enc/vp8l.c"
static int AnalyzeAndCreatePalette(WebPPicture *pic , uint32_t *palette , int *palette_size ) 
{ 
  int i ;
  int x ;
  int y ;
  int key ;
  int num_colors ;
  uint8_t in_use[1024] ;
  unsigned int tmp ;
  uint32_t colors[1024] ;
  uint32_t *argb ;
  int width ;
  int height ;
  uint32_t last_pix ;

  {
#line 50
  num_colors = 0;
#line 51
  in_use[0] = (uint8_t )0;
#line 51
  tmp = 1U;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;

#line 51
    if (tmp >= 1024U) {
#line 51
      goto while_break;
    }
#line 51
    in_use[tmp] = (uint8_t )0;
#line 51
    tmp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 53
  kHashMul___15 = (uint32_t )506832829;
#line 54
  argb = pic->argb;
#line 55
  width = pic->width;
#line 56
  height = pic->height;
#line 57
  last_pix = ~ *(argb + 0);
#line 59
  y = 0;
  {
#line 59
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 59
    if (! (y < height)) {
#line 59
      goto while_break___0;
    }
#line 60
    x = 0;
    {
#line 60
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___1: ;
#line 60
      if (! (x < width)) {
#line 60
        goto while_break___1;
      }
#line 61
      if (*(argb + x) == last_pix) {
#line 62
        goto while_continue___1;
      }
#line 64
      last_pix = *(argb + x);
#line 65
      key = (int )(kHashMul___15 * last_pix >> 22);
      {
#line 66
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 67
        if (! in_use[key]) {
#line 68
          colors[key] = last_pix;
#line 69
          in_use[key] = (uint8_t )1;
#line 70
          num_colors ++;
#line 71
          if (num_colors > 256) {
#line 72
            return (0);
          }
#line 74
          goto while_break___2;
        } else
#line 75
        if (colors[key] == last_pix) {
#line 77
          goto while_break___2;
        } else {
#line 81
          key ++;
#line 82
          key &= 1023;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: 
#line 60
      x ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
#line 86
    argb += pic->argb_stride;
#line 59
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
#line 90
  num_colors = 0;
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 91
    if (! (i < (int )(sizeof(in_use) / sizeof(in_use[0])))) {
#line 91
      goto while_break___3;
    }
#line 92
    if (in_use[i]) {
#line 93
      *(palette + num_colors) = colors[i];
#line 94
      num_colors ++;
    }
#line 91
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: 
  {
#line 98
  qsort((void *)palette, (size_t )num_colors, sizeof(*(palette + 0)), & CompareColors);
#line 99
  *palette_size = num_colors;
  }
#line 100
  return (1);
}
}
#line 103 "/root/patchweave_new/13/src/enc/vp8l.c"
static int AnalyzeEntropy(uint32_t *argb , int width , int height , int argb_stride ,
                          double *nonpredicted_bits , double *predicted_bits ) 
{ 
  int x ;
  int y ;
  uint32_t *last_line ;
  uint32_t last_pix ;
  VP8LHistogram *nonpredicted ;
  VP8LHistogram *predicted ;
  void *__cil_tmp13 ;
  uint32_t pix ;
  uint32_t pix_diff ;
  uint32_t __cil_tmp16 ;
  PixOrCopy pix_token ;
  PixOrCopy __cil_tmp18 ;
  PixOrCopy pix_diff_token ;
  PixOrCopy __cil_tmp20 ;

  {
  {
#line 108
  last_line = (uint32_t *)((void *)0);
#line 109
  last_pix = *(argb + 0);
#line 111
  nonpredicted = (VP8LHistogram *)((void *)0);
#line 112
  __cil_tmp13 = malloc(2UL * sizeof(*predicted));
#line 112
  predicted = (VP8LHistogram *)__cil_tmp13;
  }
#line 114
  if ((unsigned long )predicted == (unsigned long )((void *)0)) {
#line 114
    return (0);
  }
  {
#line 115
  nonpredicted = predicted + 1;
#line 117
  VP8LHistogramInit(predicted, 0);
#line 118
  VP8LHistogramInit(nonpredicted, 0);
#line 119
  y = 0;
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;

#line 119
    if (! (y < height)) {
#line 119
      goto while_break;
    }
#line 120
    x = 0;
    {
#line 120
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 120
      if (! (x < width)) {
#line 120
        goto while_break___0;
      }
      {
#line 121
      pix = *(argb + x);
#line 122
      __cil_tmp16 = VP8LSubPixels(pix, last_pix);
#line 122
      pix_diff = __cil_tmp16;
      }
#line 123
      if (pix_diff == 0U) {
#line 123
        goto while_continue___0;
      }
#line 124
      if ((unsigned long )last_line != (unsigned long )((void *)0)) {
#line 124
        if (pix == *(last_line + x)) {
#line 125
          goto while_continue___0;
        }
      }
      {
#line 127
      last_pix = pix;
#line 129
      __cil_tmp18 = PixOrCopyCreateLiteral(pix);
#line 129
      pix_token = __cil_tmp18;
#line 130
      __cil_tmp20 = PixOrCopyCreateLiteral(pix_diff);
#line 130
      pix_diff_token = __cil_tmp20;
#line 131
      VP8LHistogramAddSinglePixOrCopy(nonpredicted, & pix_token);
#line 132
      VP8LHistogramAddSinglePixOrCopy(predicted, & pix_diff_token);
#line 120
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 135
    last_line = argb;
#line 136
    argb += argb_stride;
#line 119
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 138
  *nonpredicted_bits = VP8LHistogramEstimateBitsBulk(nonpredicted);
#line 139
  *predicted_bits = VP8LHistogramEstimateBitsBulk(predicted);
#line 140
  free((void *)predicted);
  }
#line 141
  return (1);
}
}
#line 144 "/root/patchweave_new/13/src/enc/vp8l.c"
static int VP8LEncAnalyze(VP8LEncoder *enc , enum WebPImageHint image_hint ) 
{ 
  WebPPicture *pic ;
  double non_pred_entropy ;
  double pred_entropy ;
  int __cil_tmp8 ;

  {
  {
#line 145
  pic = enc->pic_;
#line 148
  enc->use_palette_ = AnalyzeAndCreatePalette(pic, (uint32_t *)(enc->palette_), & enc->palette_size_);
  }
#line 151
  if ((unsigned int )image_hint == 3U) {
#line 152
    if (enc->use_palette_) {
#line 152
      if (enc->palette_size_ < 64) {
#line 153
        enc->use_palette_ = 0;
      }
    }
  }
#line 157
  if (! enc->use_palette_) {
#line 158
    if ((unsigned int )image_hint == 2U) {
#line 159
      enc->use_predict_ = 1;
#line 160
      enc->use_cross_color_ = 1;
    } else {
      {
#line 163
      __cil_tmp8 = AnalyzeEntropy(pic->argb, pic->width, pic->height, pic->argb_stride,
                                  & non_pred_entropy, & pred_entropy);
      }
#line 163
      if (! __cil_tmp8) {
#line 165
        return (0);
      }
#line 167
      if (pred_entropy < 0.95 * non_pred_entropy) {
#line 168
        enc->use_predict_ = 1;
#line 172
        enc->use_cross_color_ = 1;
      }
    }
  }
#line 177
  return (1);
}
}
#line 180 "/root/patchweave_new/13/src/enc/vp8l.c"
static int GetHuffBitLengthsAndCodes(VP8LHistogramSet *histogram_image , HuffmanTreeCode *huffman_codes ) 
{ 
  int i ;
  int k ;
  int ok ;
  uint64_t total_length_size ;
  uint8_t *mem_buf ;
  int histogram_image_size ;
  VP8LHistogram *histo ;
  HuffmanTreeCode *codes ;
  int num_symbols ;
  int __cil_tmp12 ;
  int tmp ;
  int tmp___0 ;
  uint16_t *codes___0 ;
  uint8_t *lengths ;
  void *__cil_tmp17 ;
  int bit_length ;
  HuffmanTreeCode *codes___1 ;
  VP8LHistogram *histo___0 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 184
  ok = 1;
#line 185
  total_length_size = (uint64_t )0;
#line 186
  mem_buf = (uint8_t *)((void *)0);
#line 187
  histogram_image_size = histogram_image->size;
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;

#line 190
    if (! (i < histogram_image_size)) {
#line 190
      goto while_break;
    }
#line 191
    histo = *(histogram_image->histograms + i);
#line 192
    codes = huffman_codes + 5 * i;
#line 193
    k = 0;
    {
#line 193
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 193
      if (! (k < 5)) {
#line 193
        goto while_break___0;
      }
#line 194
      if (k == 0) {
        {
#line 194
        __cil_tmp12 = VP8LHistogramNumCodes(histo);
#line 194
        tmp___0 = __cil_tmp12;
        }
      } else {
#line 194
        if (k == 4) {
#line 194
          tmp = 40;
        } else {
#line 194
          tmp = 256;
        }
#line 194
        tmp___0 = tmp;
      }
#line 194
      num_symbols = tmp___0;
#line 197
      (codes + k)->num_symbols = num_symbols;
#line 198
      total_length_size += (unsigned long )num_symbols;
#line 193
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 190
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 206
  __cil_tmp17 = WebPSafeCalloc(total_length_size, sizeof(*lengths) + sizeof(*codes___0));
#line 206
  mem_buf = (uint8_t *)__cil_tmp17;
  }
#line 208
  if ((unsigned long )mem_buf == (unsigned long )((void *)0)) {
#line 209
    ok = 0;
#line 210
    goto End;
  }
#line 212
  codes___0 = (uint16_t *)mem_buf;
#line 213
  lengths = (uint8_t *)(codes___0 + total_length_size);
#line 214
  i = 0;
  {
#line 214
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 214
    if (! (i < 5 * histogram_image_size)) {
#line 214
      goto while_break___1;
    }
#line 215
    bit_length = (huffman_codes + i)->num_symbols;
#line 216
    (huffman_codes + i)->codes = codes___0;
#line 217
    (huffman_codes + i)->code_lengths = lengths;
#line 218
    codes___0 += bit_length;
#line 219
    lengths += bit_length;
#line 214
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: 
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 224
    if (ok) {
#line 224
      if (! (i < histogram_image_size)) {
#line 224
        goto while_break___2;
      }
    } else {
#line 224
      goto while_break___2;
    }
    {
#line 225
    codes___1 = huffman_codes + 5 * i;
#line 226
    histo___0 = *(histogram_image->histograms + i);
#line 227
    __cil_tmp21 = VP8LCreateHuffmanTree(histo___0->literal_, 15, codes___1 + 0);
    }
#line 227
    if (ok) {
#line 227
      if (__cil_tmp21) {
#line 227
        tmp___1 = 1;
      } else {
#line 227
        tmp___1 = 0;
      }
    } else {
#line 227
      tmp___1 = 0;
    }
    {
#line 227
    ok = tmp___1;
#line 228
    __cil_tmp22 = VP8LCreateHuffmanTree(histo___0->red_, 15, codes___1 + 1);
    }
#line 228
    if (ok) {
#line 228
      if (__cil_tmp22) {
#line 228
        tmp___2 = 1;
      } else {
#line 228
        tmp___2 = 0;
      }
    } else {
#line 228
      tmp___2 = 0;
    }
    {
#line 228
    ok = tmp___2;
#line 229
    __cil_tmp23 = VP8LCreateHuffmanTree(histo___0->blue_, 15, codes___1 + 2);
    }
#line 229
    if (ok) {
#line 229
      if (__cil_tmp23) {
#line 229
        tmp___3 = 1;
      } else {
#line 229
        tmp___3 = 0;
      }
    } else {
#line 229
      tmp___3 = 0;
    }
    {
#line 229
    ok = tmp___3;
#line 230
    __cil_tmp24 = VP8LCreateHuffmanTree(histo___0->alpha_, 15, codes___1 + 3);
    }
#line 230
    if (ok) {
#line 230
      if (__cil_tmp24) {
#line 230
        tmp___4 = 1;
      } else {
#line 230
        tmp___4 = 0;
      }
    } else {
#line 230
      tmp___4 = 0;
    }
    {
#line 230
    ok = tmp___4;
#line 231
    __cil_tmp25 = VP8LCreateHuffmanTree(histo___0->distance_, 15, codes___1 + 4);
    }
#line 231
    if (ok) {
#line 231
      if (__cil_tmp25) {
#line 231
        tmp___5 = 1;
      } else {
#line 231
        tmp___5 = 0;
      }
    } else {
#line 231
      tmp___5 = 0;
    }
#line 231
    ok = tmp___5;
#line 224
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
  End: 
#line 235
  if (! ok) {
    {
#line 236
    free((void *)mem_buf);
#line 238
    memset((void *)huffman_codes, 0, (unsigned long )(5 * histogram_image_size) * sizeof(*huffman_codes));
    }
  }
#line 240
  return (ok);
}
}
#line 245 "/root/patchweave_new/13/src/enc/vp8l.c"
static uint8_t kStorageOrder[19]  ;
#line 243 "/root/patchweave_new/13/src/enc/vp8l.c"
static void StoreHuffmanTreeOfHuffmanTreeToBitMask(VP8LBitWriter *bw , uint8_t *code_length_bitdepth ) 
{ 
  int i ;
  int codes_to_store ;

  {
#line 248
  kStorageOrder[0] = (uint8_t )17;
#line 248
  kStorageOrder[1] = (uint8_t )18;
#line 248
  kStorageOrder[2] = (uint8_t )0;
#line 248
  kStorageOrder[3] = (uint8_t )1;
#line 248
  kStorageOrder[4] = (uint8_t )2;
#line 248
  kStorageOrder[5] = (uint8_t )3;
#line 248
  kStorageOrder[6] = (uint8_t )4;
#line 248
  kStorageOrder[7] = (uint8_t )5;
#line 248
  kStorageOrder[8] = (uint8_t )16;
#line 248
  kStorageOrder[9] = (uint8_t )6;
#line 248
  kStorageOrder[10] = (uint8_t )7;
#line 248
  kStorageOrder[11] = (uint8_t )8;
#line 248
  kStorageOrder[12] = (uint8_t )9;
#line 248
  kStorageOrder[13] = (uint8_t )10;
#line 248
  kStorageOrder[14] = (uint8_t )11;
#line 248
  kStorageOrder[15] = (uint8_t )12;
#line 248
  kStorageOrder[16] = (uint8_t )13;
#line 248
  kStorageOrder[17] = (uint8_t )14;
#line 248
  kStorageOrder[18] = (uint8_t )15;
#line 253
  codes_to_store = 19;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;

#line 254
    if (! (codes_to_store > 4)) {
#line 254
      goto while_break;
    }
#line 255
    if ((int )*(code_length_bitdepth + (int )kStorageOrder[codes_to_store - 1]) != 0) {
#line 256
      goto while_break;
    }
#line 254
    codes_to_store --;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 259
  VP8LWriteBits(bw, 4, (uint32_t )(codes_to_store - 4));
#line 260
  i = 0;
  }
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 260
    if (! (i < codes_to_store)) {
#line 260
      goto while_break___0;
    }
    {
#line 261
    VP8LWriteBits(bw, 3, (uint32_t )*(code_length_bitdepth + (int )kStorageOrder[i]));
#line 260
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 264
  return;
}
}
#line 265 "/root/patchweave_new/13/src/enc/vp8l.c"
static void ClearHuffmanTreeIfOnlyOneSymbol(HuffmanTreeCode *huffman_code ) 
{ 
  int k ;
  int count ;

  {
#line 268
  count = 0;
#line 269
  k = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;

#line 269
    if (! (k < huffman_code->num_symbols)) {
#line 269
      goto while_break;
    }
#line 270
    if ((int )*(huffman_code->code_lengths + k) != 0) {
#line 271
      count ++;
#line 272
      if (count > 1) {
#line 272
        return;
      }
    }
#line 269
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 275
  k = 0;
  {
#line 275
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 275
    if (! (k < huffman_code->num_symbols)) {
#line 275
      goto while_break___0;
    }
#line 276
    *(huffman_code->code_lengths + k) = (uint8_t )0;
#line 277
    *(huffman_code->codes + k) = (uint16_t )0;
#line 275
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 279
  return;
}
}
#line 281 "/root/patchweave_new/13/src/enc/vp8l.c"
static void StoreHuffmanTreeToBitMask(VP8LBitWriter *bw , HuffmanTreeToken *tokens ,
                                      int num_tokens , HuffmanTreeCode *huffman_code ) 
{ 
  int i ;
  int ix ;
  int extra_bits ;

  {
#line 286
  i = 0;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;

#line 286
    if (! (i < num_tokens)) {
#line 286
      goto while_break;
    }
    {
#line 287
    ix = (int )(tokens + i)->code;
#line 288
    extra_bits = (int )(tokens + i)->extra_bits;
#line 289
    VP8LWriteBits(bw, (int )*(huffman_code->code_lengths + ix), (uint32_t )*(huffman_code->codes + ix));
    }
#line 291
    if (ix == 16) {
#line 291
      goto case_16;
    }
#line 294
    if (ix == 17) {
#line 294
      goto case_17;
    }
#line 297
    if (ix == 18) {
#line 297
      goto case_18;
    }
#line 290
    goto switch_break;
    case_16: 
    {
#line 292
    VP8LWriteBits(bw, 2, (uint32_t )extra_bits);
    }
#line 293
    goto switch_break;
    case_17: 
    {
#line 295
    VP8LWriteBits(bw, 3, (uint32_t )extra_bits);
    }
#line 296
    goto switch_break;
    case_18: 
    {
#line 298
    VP8LWriteBits(bw, 7, (uint32_t )extra_bits);
    }
#line 299
    goto switch_break;
    switch_break: 
#line 286
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 290
  return;
}
}
#line 304 "/root/patchweave_new/13/src/enc/vp8l.c"
static int StoreFullHuffmanCode(VP8LBitWriter *bw , HuffmanTreeCode *tree ) 
{ 
  int ok ;
  uint8_t code_length_bitdepth[19] ;
  unsigned int tmp ;
  uint16_t code_length_bitdepth_symbols[19] ;
  unsigned int tmp___0 ;
  int max_tokens ;
  int num_tokens ;
  HuffmanTreeCode huffman_code ;
  HuffmanTreeToken *tokens ;
  void *__cil_tmp12 ;
  int histogram[19] ;
  unsigned int tmp___1 ;
  int i ;
  int __cil_tmp17 ;
  int trailing_zero_bits ;
  int trimmed_length ;
  int write_trimmed_length ;
  int length ;
  int i___0 ;
  int __cil_tmp23 ;
  int ix ;
  int tmp___2 ;
  int nbits ;
  int __cil_tmp27 ;
  int nbitpairs ;
  int tmp___3 ;
  int tmp___5 ;

  {
#line 306
  ok = 0;
#line 307
  code_length_bitdepth[0] = (uint8_t )0;
#line 307
  tmp = 1U;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;

#line 307
    if (tmp >= 19U) {
#line 307
      goto while_break;
    }
#line 307
    code_length_bitdepth[tmp] = (uint8_t )0;
#line 307
    tmp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 308
  code_length_bitdepth_symbols[0] = (uint16_t )0;
#line 308
  tmp___0 = 1U;
  {
#line 308
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 308
    if (tmp___0 >= 19U) {
#line 308
      goto while_break___0;
    }
#line 308
    code_length_bitdepth_symbols[tmp___0] = (uint16_t )0;
#line 308
    tmp___0 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 309
  max_tokens = tree->num_symbols;
#line 312
  __cil_tmp12 = WebPSafeMalloc((uint64_t )max_tokens, sizeof(*tokens));
#line 312
  tokens = (HuffmanTreeToken *)__cil_tmp12;
  }
#line 314
  if ((unsigned long )tokens == (unsigned long )((void *)0)) {
#line 314
    return (0);
  }
  {
#line 316
  huffman_code.num_symbols = 19;
#line 317
  huffman_code.code_lengths = code_length_bitdepth;
#line 318
  huffman_code.codes = code_length_bitdepth_symbols;
#line 320
  VP8LWriteBits(bw, 1, (uint32_t )0);
#line 321
  num_tokens = VP8LCreateCompressedHuffmanTree(tree, tokens, max_tokens);
#line 323
  histogram[0] = 0;
#line 323
  tmp___1 = 1U;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 323
    if (tmp___1 >= 19U) {
#line 323
      goto while_break___1;
    }
#line 323
    histogram[tmp___1] = 0;
#line 323
    tmp___1 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 325
    if (! (i < num_tokens)) {
#line 325
      goto while_break___2;
    }
#line 326
    (histogram[(tokens + i)->code]) ++;
#line 325
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 329
  __cil_tmp17 = VP8LCreateHuffmanTree(histogram, 7, & huffman_code);
  }
#line 329
  if (! __cil_tmp17) {
#line 330
    goto End;
  }
  {
#line 334
  StoreHuffmanTreeOfHuffmanTreeToBitMask(bw, code_length_bitdepth);
#line 335
  ClearHuffmanTreeIfOnlyOneSymbol(& huffman_code);
#line 337
  trailing_zero_bits = 0;
#line 338
  trimmed_length = num_tokens;
#line 341
  i___0 = num_tokens;
  }
  {
#line 342
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 342
    __cil_tmp23 = i___0;
#line 342
    i___0 --;
#line 342
    if (! (__cil_tmp23 > 0)) {
#line 342
      goto while_break___3;
    }
#line 343
    ix = (int )(tokens + i___0)->code;
#line 344
    if (ix == 0) {
      _L: 
#line 345
      trimmed_length --;
#line 346
      trailing_zero_bits += (int )code_length_bitdepth[ix];
#line 347
      if (ix == 17) {
#line 348
        trailing_zero_bits += 3;
      } else
#line 349
      if (ix == 18) {
#line 350
        trailing_zero_bits += 7;
      }
    } else
#line 344
    if (ix == 17) {
#line 344
      goto _L;
    } else
#line 344
    if (ix == 18) {
#line 344
      goto _L;
    } else {
#line 353
      goto while_break___3;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: ;
#line 356
  if (trimmed_length > 1) {
#line 356
    if (trailing_zero_bits > 12) {
#line 356
      tmp___5 = 1;
    } else {
#line 356
      tmp___5 = 0;
    }
  } else {
#line 356
    tmp___5 = 0;
  }
#line 356
  write_trimmed_length = tmp___5;
#line 357
  if (write_trimmed_length) {
#line 357
    tmp___2 = trimmed_length;
  } else {
#line 357
    tmp___2 = num_tokens;
  }
  {
#line 357
  length = tmp___2;
#line 358
  VP8LWriteBits(bw, 1, (uint32_t )write_trimmed_length);
  }
#line 359
  if (write_trimmed_length) {
    {
#line 360
    __cil_tmp27 = VP8LBitsLog2Ceiling((uint32_t )(trimmed_length - 1));
#line 360
    nbits = __cil_tmp27;
    }
#line 361
    if (nbits == 0) {
#line 361
      tmp___3 = 1;
    } else {
#line 361
      tmp___3 = (nbits + 1) / 2;
    }
    {
#line 361
    nbitpairs = tmp___3;
#line 362
    VP8LWriteBits(bw, 3, (uint32_t )(nbitpairs - 1));
#line 364
    VP8LWriteBits(bw, nbitpairs * 2, (uint32_t )(trimmed_length - 2));
    }
  }
  {
#line 366
  StoreHuffmanTreeToBitMask(bw, tokens, length, & huffman_code);
#line 368
  ok = 1;
  }
  End: 
  {
#line 370
  free((void *)tokens);
  }
#line 371
  return (ok);
}
}
#line 374 "/root/patchweave_new/13/src/enc/vp8l.c"
static int StoreHuffmanCode(VP8LBitWriter *bw , HuffmanTreeCode *huffman_code ) 
{ 
  int i ;
  int count ;
  int symbols[2] ;
  int kMaxBits ;
  int kMaxSymbol ;
  int __cil_tmp8 ;

  {
#line 377
  count = 0;
#line 378
  symbols[0] = 0;
#line 378
  symbols[1] = 0;
#line 379
  kMaxBits = 8;
#line 380
  kMaxSymbol = 1 << kMaxBits;
#line 383
  i = 0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;

#line 383
    if (i < huffman_code->num_symbols) {
#line 383
      if (! (count < 3)) {
#line 383
        goto while_break;
      }
    } else {
#line 383
      goto while_break;
    }
#line 384
    if ((int )*(huffman_code->code_lengths + i) != 0) {
#line 385
      if (count < 2) {
#line 385
        symbols[count] = i;
      }
#line 386
      count ++;
    }
#line 383
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 390
  if (count == 0) {
    {
#line 392
    VP8LWriteBits(bw, 4, (uint32_t )1);
    }
#line 393
    return (1);
  } else
#line 394
  if (count <= 2) {
#line 394
    if (symbols[0] < kMaxSymbol) {
#line 394
      if (symbols[1] < kMaxSymbol) {
        {
#line 395
        VP8LWriteBits(bw, 1, (uint32_t )1);
#line 396
        VP8LWriteBits(bw, 1, (uint32_t )(count - 1));
        }
#line 397
        if (symbols[0] <= 1) {
          {
#line 398
          VP8LWriteBits(bw, 1, (uint32_t )0);
#line 399
          VP8LWriteBits(bw, 1, (uint32_t )symbols[0]);
          }
        } else {
          {
#line 401
          VP8LWriteBits(bw, 1, (uint32_t )1);
#line 402
          VP8LWriteBits(bw, 8, (uint32_t )symbols[0]);
          }
        }
#line 404
        if (count == 2) {
          {
#line 405
          VP8LWriteBits(bw, 8, (uint32_t )symbols[1]);
          }
        }
#line 407
        return (1);
      } else {
        {
#line 409
        __cil_tmp8 = StoreFullHuffmanCode(bw, huffman_code);
        }
#line 409
        return (__cil_tmp8);
      }
    } else {
      {
#line 409
      __cil_tmp8 = StoreFullHuffmanCode(bw, huffman_code);
      }
#line 409
      return (__cil_tmp8);
    }
  } else {
    {
#line 409
    __cil_tmp8 = StoreFullHuffmanCode(bw, huffman_code);
    }
#line 409
    return (__cil_tmp8);
  }
}
}
#line 413 "/root/patchweave_new/13/src/enc/vp8l.c"
static void WriteHuffmanCode(VP8LBitWriter *bw , HuffmanTreeCode *code , int code_index ) 
{ 
  int depth ;
  int symbol ;

  {
  {
#line 416
  depth = (int )*(code->code_lengths + code_index);
#line 417
  symbol = (int )*(code->codes + code_index);
#line 418
  VP8LWriteBits(bw, depth, (uint32_t )symbol);
  }
#line 420
  return;
}
}
#line 439 "/root/patchweave_new/13/src/enc/vp8l.c"
static int const   order[4]  ;
#line 421 "/root/patchweave_new/13/src/enc/vp8l.c"
static void StoreImageToBitMask(VP8LBitWriter *bw , int width , int histo_bits , VP8LBackwardRefs *refs ,
                                uint16_t *histogram_symbols , HuffmanTreeCode *huffman_codes ) 
{ 
  int x ;
  int y ;
  int histo_xsize ;
  uint32_t __cil_tmp10 ;
  uint32_t tmp ;
  int i ;
  PixOrCopy *v ;
  int histogram_ix ;
  int tmp___0 ;
  HuffmanTreeCode *codes ;
  int __cil_tmp17 ;
  int code ;
  uint32_t __cil_tmp19 ;
  int literal_ix ;
  int __cil_tmp21 ;
  int k ;
  int code___0 ;
  uint32_t __cil_tmp25 ;
  int bits ;
  int n_bits ;
  int code___1 ;
  int distance ;
  uint32_t __cil_tmp30 ;
  uint32_t __cil_tmp31 ;

  {
#line 427
  x = 0;
#line 428
  y = 0;
#line 429
  if (histo_bits) {
    {
#line 429
    __cil_tmp10 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histo_bits);
#line 429
    tmp = __cil_tmp10;
    }
  } else {
#line 429
    tmp = 1U;
  }
#line 429
  histo_xsize = (int )tmp;
#line 431
  i = 0;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;

#line 431
    if (! (i < refs->size)) {
#line 431
      goto while_break;
    }
#line 432
    v = refs->refs + i;
#line 433
    if (histo_bits) {
#line 433
      tmp___0 = (y >> histo_bits) * histo_xsize + (x >> histo_bits);
    } else {
#line 433
      tmp___0 = 0;
    }
    {
#line 433
    histogram_ix = (int )*(histogram_symbols + tmp___0);
#line 436
    codes = huffman_codes + 5 * histogram_ix;
#line 437
    __cil_tmp17 = PixOrCopyIsCacheIdx(v);
    }
#line 437
    if (__cil_tmp17) {
      {
#line 438
      __cil_tmp19 = PixOrCopyCacheIdx(v);
#line 438
      code = (int )__cil_tmp19;
#line 439
      literal_ix = 280 + code;
#line 440
      WriteHuffmanCode(bw, codes, literal_ix);
      }
    } else {
      {
#line 441
      __cil_tmp21 = PixOrCopyIsLiteral(v);
      }
#line 441
      if (__cil_tmp21) {
#line 442
        order[0] = (int const   )1;
#line 442
        order[1] = (int const   )2;
#line 442
        order[2] = (int const   )0;
#line 442
        order[3] = (int const   )3;
#line 444
        k = 0;
        {
#line 444
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 444
          if (! (k < 4)) {
#line 444
            goto while_break___0;
          }
          {
#line 445
          __cil_tmp25 = PixOrCopyLiteral(v, (int )order[k]);
#line 445
          code___0 = (int )__cil_tmp25;
#line 446
          WriteHuffmanCode(bw, codes + k, code___0);
#line 444
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break___0: ;
      } else {
        {
#line 452
        PrefixEncode((int )v->len, & code___1, & n_bits, & bits);
#line 453
        WriteHuffmanCode(bw, codes, 256 + code___1);
#line 454
        VP8LWriteBits(bw, n_bits, (uint32_t )bits);
#line 456
        __cil_tmp30 = PixOrCopyArgb(v);
#line 456
        distance = (int )__cil_tmp30;
#line 457
        PrefixEncode(distance, & code___1, & n_bits, & bits);
#line 458
        WriteHuffmanCode(bw, codes + 4, code___1);
#line 459
        VP8LWriteBits(bw, n_bits, (uint32_t )bits);
        }
      }
    }
    {
#line 461
    __cil_tmp31 = PixOrCopyLength(v);
#line 461
    x = (int )((uint32_t )x + __cil_tmp31);
    }
    {
#line 462
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 462
      if (! (x >= width)) {
#line 462
        goto while_break___1;
      }
#line 463
      x -= width;
#line 464
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 431
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 435
  return;
}
}
#line 470 "/root/patchweave_new/13/src/enc/vp8l.c"
static int EncodeImageNoHuffman(VP8LBitWriter *bw , uint32_t *argb , int width , int height ,
                                int quality ) 
{ 
  int i ;
  int ok ;
  VP8LBackwardRefs refs ;
  HuffmanTreeCode huffman_codes[5] ;
  uint16_t histogram_symbols[1] ;
  VP8LHistogramSet *histogram_image ;
  VP8LHistogramSet *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;
  HuffmanTreeCode *codes ;
  int __cil_tmp17 ;

  {
  {
#line 474
  ok = 0;
#line 476
  huffman_codes[0].num_symbols = 0;
#line 476
  huffman_codes[0].code_lengths = (uint8_t *)((void *)0);
#line 476
  huffman_codes[0].codes = (uint16_t *)((void *)0);
#line 477
  histogram_symbols[0] = (uint16_t )0;
#line 478
  __cil_tmp12 = VP8LAllocateHistogramSet(1, 0);
#line 478
  histogram_image = __cil_tmp12;
  }
#line 479
  if ((unsigned long )histogram_image == (unsigned long )((void *)0)) {
#line 479
    return (0);
  }
  {
#line 482
  __cil_tmp13 = VP8LGetBackwardReferences(width, height, argb, quality, 0, 1, & refs);
  }
#line 482
  if (! __cil_tmp13) {
#line 483
    goto Error;
  }
  {
#line 486
  VP8LHistogramStoreRefs(& refs, *(histogram_image->histograms + 0));
#line 490
  __cil_tmp15 = GetHuffBitLengthsAndCodes(histogram_image, huffman_codes);
  }
#line 490
  if (! __cil_tmp15) {
#line 491
    goto Error;
  }
  {
#line 495
  VP8LWriteBits(bw, 1, (uint32_t )0);
#line 498
  i = 0;
  }
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;

#line 498
    if (! (i < 5)) {
#line 498
      goto while_break;
    }
    {
#line 499
    codes = & huffman_codes[i];
#line 500
    __cil_tmp17 = StoreHuffmanCode(bw, codes);
    }
#line 500
    if (! __cil_tmp17) {
#line 501
      goto Error;
    }
    {
#line 503
    ClearHuffmanTreeIfOnlyOneSymbol(codes);
#line 498
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 507
  StoreImageToBitMask(bw, width, 0, & refs, histogram_symbols, huffman_codes);
#line 508
  ok = 1;
  }
  Error: 
  {
#line 511
  free((void *)histogram_image);
#line 512
  VP8LClearBackwardRefs(& refs);
#line 513
  free((void *)huffman_codes[0].codes);
  }
#line 514
  return (ok);
}
}
#line 517 "/root/patchweave_new/13/src/enc/vp8l.c"
static int EncodeImageInternal(VP8LBitWriter *bw , uint32_t *argb , int width , int height ,
                               int quality , int cache_bits , int histogram_bits ) 
{ 
  int ok ;
  int use_2d_locality ;
  int use_color_cache ;
  uint32_t histogram_image_xysize ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  VP8LHistogramSet *histogram_image ;
  VP8LHistogramSet *__cil_tmp15 ;
  int histogram_image_size ;
  size_t bit_array_size ;
  HuffmanTreeCode *huffman_codes ;
  VP8LBackwardRefs refs ;
  uint16_t *histogram_symbols ;
  void *__cil_tmp21 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  int write_histogram_image ;
  uint32_t *histogram_argb ;
  void *__cil_tmp30 ;
  int max_index ;
  uint32_t i ;
  int symbol_index ;
  uint32_t __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  int __cil_tmp36 ;
  int i___0 ;
  HuffmanTreeCode *codes ;
  int __cil_tmp39 ;

  {
  {
#line 521
  ok = 0;
#line 522
  use_2d_locality = 1;
#line 523
  use_color_cache = cache_bits > 0;
#line 524
  __cil_tmp13 = VP8LSubSampleSize((uint32_t )height, (uint32_t )histogram_bits);
#line 524
  __cil_tmp12 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histogram_bits);
#line 524
  histogram_image_xysize = __cil_tmp12 * __cil_tmp13;
#line 527
  __cil_tmp15 = VP8LAllocateHistogramSet((int )histogram_image_xysize, 0);
#line 527
  histogram_image = __cil_tmp15;
#line 529
  histogram_image_size = 0;
#line 530
  bit_array_size = (size_t )0;
#line 531
  huffman_codes = (HuffmanTreeCode *)((void *)0);
#line 533
  __cil_tmp21 = WebPSafeMalloc((uint64_t )histogram_image_xysize, sizeof(*histogram_symbols));
#line 533
  histogram_symbols = (uint16_t *)__cil_tmp21;
  }
#line 539
  if ((unsigned long )histogram_image == (unsigned long )((void *)0)) {
    {
#line 540
    free((void *)histogram_image);
#line 541
    free((void *)histogram_symbols);
    }
#line 542
    return (0);
  } else
#line 539
  if ((unsigned long )histogram_symbols == (unsigned long )((void *)0)) {
    {
#line 540
    free((void *)histogram_image);
#line 541
    free((void *)histogram_symbols);
    }
#line 542
    return (0);
  }
  {
#line 546
  __cil_tmp24 = VP8LGetBackwardReferences(width, height, argb, quality, cache_bits,
                                          use_2d_locality, & refs);
  }
#line 546
  if (! __cil_tmp24) {
#line 548
    goto Error;
  }
  {
#line 551
  __cil_tmp25 = VP8LGetHistoImageSymbols(width, height, & refs, quality, histogram_bits,
                                         cache_bits, histogram_image, histogram_symbols);
  }
#line 551
  if (! __cil_tmp25) {
#line 555
    goto Error;
  }
  {
#line 558
  histogram_image_size = histogram_image->size;
#line 559
  bit_array_size = (size_t )(5 * histogram_image_size);
#line 560
  __cil_tmp26 = WebPSafeCalloc(bit_array_size, sizeof(*huffman_codes));
#line 560
  huffman_codes = (HuffmanTreeCode *)__cil_tmp26;
#line 562
  __cil_tmp27 = GetHuffBitLengthsAndCodes(histogram_image, huffman_codes);
  }
#line 562
  if ((unsigned long )huffman_codes == (unsigned long )((void *)0)) {
#line 564
    goto Error;
  } else
#line 562
  if (! __cil_tmp27) {
#line 564
    goto Error;
  }
  {
#line 567
  free((void *)histogram_image);
#line 568
  histogram_image = (VP8LHistogramSet *)((void *)0);
#line 571
  VP8LWriteBits(bw, 1, (uint32_t )use_color_cache);
  }
#line 572
  if (use_color_cache) {
    {
#line 573
    VP8LWriteBits(bw, 4, (uint32_t )cache_bits);
    }
  }
  {
#line 578
  write_histogram_image = histogram_image_size > 1;
#line 579
  VP8LWriteBits(bw, 1, (uint32_t )write_histogram_image);
  }
#line 580
  if (write_histogram_image) {
    {
#line 581
    __cil_tmp30 = WebPSafeMalloc((uint64_t )histogram_image_xysize, sizeof(*histogram_argb));
#line 581
    histogram_argb = (uint32_t *)__cil_tmp30;
#line 584
    max_index = 0;
    }
#line 586
    if ((unsigned long )histogram_argb == (unsigned long )((void *)0)) {
#line 586
      goto Error;
    }
#line 587
    i = (uint32_t )0;
    {
#line 587
    while (1) {
      while_continue: /* CIL Label */ ;

#line 587
      if (! (i < histogram_image_xysize)) {
#line 587
        goto while_break;
      }
#line 588
      symbol_index = (int )*(histogram_symbols + i) & 65535;
#line 589
      *(histogram_argb + i) = 4278190080U | (unsigned int )(symbol_index << 8);
#line 590
      if (symbol_index >= max_index) {
#line 591
        max_index = symbol_index + 1;
      }
#line 587
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 594
    histogram_image_size = max_index;
#line 596
    VP8LWriteBits(bw, 3, (uint32_t )(histogram_bits - 2));
#line 597
    __cil_tmp34 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histogram_bits);
#line 597
    __cil_tmp35 = VP8LSubSampleSize((uint32_t )height, (uint32_t )histogram_bits);
#line 597
    __cil_tmp36 = EncodeImageNoHuffman(bw, histogram_argb, (int )__cil_tmp34, (int )__cil_tmp35,
                                       quality);
#line 597
    ok = __cil_tmp36;
#line 601
    free((void *)histogram_argb);
    }
#line 602
    if (! ok) {
#line 602
      goto Error;
    }
  }
#line 609
  i___0 = 0;
  {
#line 609
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 609
    if (! (i___0 < 5 * histogram_image_size)) {
#line 609
      goto while_break___0;
    }
    {
#line 610
    codes = huffman_codes + i___0;
#line 611
    __cil_tmp39 = StoreHuffmanCode(bw, codes);
    }
#line 611
    if (! __cil_tmp39) {
#line 611
      goto Error;
    }
    {
#line 612
    ClearHuffmanTreeIfOnlyOneSymbol(codes);
#line 609
    i___0 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 617
  StoreImageToBitMask(bw, width, histogram_bits, & refs, histogram_symbols, huffman_codes);
#line 619
  ok = 1;
  }
  Error: 
  {
#line 622
  free((void *)histogram_image);
#line 624
  VP8LClearBackwardRefs(& refs);
  }
#line 625
  if ((unsigned long )huffman_codes != (unsigned long )((void *)0)) {
    {
#line 626
    free((void *)huffman_codes->codes);
#line 627
    free((void *)huffman_codes);
    }
  }
  {
#line 629
  free((void *)histogram_symbols);
  }
#line 630
  return (ok);
}
}
#line 638 "/root/patchweave_new/13/src/enc/vp8l.c"
static int EvalAndApplySubtractGreen(VP8LEncoder *enc , int width , int height , VP8LBitWriter *bw ) 
{ 
  int i ;
  uint32_t *argb ;
  double bit_cost_before ;
  double bit_cost_after ;
  VP8LHistogram *histo ;
  void *__cil_tmp10 ;
  uint32_t c ;
  uint32_t c___0 ;
  int green ;

  {
#line 641
  if (! enc->use_palette_) {
    {
#line 643
    argb = enc->argb_;
#line 645
    __cil_tmp10 = malloc(sizeof(*histo));
#line 645
    histo = (VP8LHistogram *)__cil_tmp10;
    }
#line 646
    if ((unsigned long )histo == (unsigned long )((void *)0)) {
#line 646
      return (0);
    }
    {
#line 648
    VP8LHistogramInit(histo, 1);
#line 649
    i = 0;
    }
    {
#line 649
    while (1) {
      while_continue: /* CIL Label */ ;

#line 649
      if (! (i < width * height)) {
#line 649
        goto while_break;
      }
#line 650
      c = *(argb + i);
#line 651
      (histo->red_[(c >> 16) & 255U]) ++;
#line 652
      (histo->blue_[c & 255U]) ++;
#line 649
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 654
    bit_cost_before = VP8LHistogramEstimateBits(histo);
#line 656
    VP8LHistogramInit(histo, 1);
#line 657
    i = 0;
    }
    {
#line 657
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 657
      if (! (i < width * height)) {
#line 657
        goto while_break___0;
      }
#line 658
      c___0 = *(argb + i);
#line 659
      green = (int )((c___0 >> 8) & 255U);
#line 660
      (histo->red_[((c___0 >> 16) - (unsigned int )green) & 255U]) ++;
#line 661
      (histo->blue_[(c___0 - (unsigned int )green) & 255U]) ++;
#line 657
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 663
    bit_cost_after = VP8LHistogramEstimateBits(histo);
#line 664
    free((void *)histo);
#line 667
    enc->use_subtract_green_ = bit_cost_after < bit_cost_before;
    }
#line 668
    if (enc->use_subtract_green_) {
      {
#line 669
      VP8LWriteBits(bw, 1, (uint32_t )1);
#line 670
      VP8LWriteBits(bw, 2, (uint32_t )2);
#line 671
      VP8LSubtractGreenFromBlueAndRed(enc->argb_, width * height);
      }
    }
  }
#line 674
  return (1);
}
}
#line 677 "/root/patchweave_new/13/src/enc/vp8l.c"
static int ApplyPredictFilter(VP8LEncoder *enc , int width , int height , int quality ,
                              VP8LBitWriter *bw ) 
{ 
  int pred_bits ;
  int transform_width ;
  uint32_t __cil_tmp8 ;
  int transform_height ;
  uint32_t __cil_tmp10 ;
  int __cil_tmp12 ;

  {
  {
#line 680
  pred_bits = enc->transform_bits_;
#line 681
  __cil_tmp8 = VP8LSubSampleSize((uint32_t )width, (uint32_t )pred_bits);
#line 681
  transform_width = (int )__cil_tmp8;
#line 682
  __cil_tmp10 = VP8LSubSampleSize((uint32_t )height, (uint32_t )pred_bits);
#line 682
  transform_height = (int )__cil_tmp10;
#line 684
  VP8LResidualImage(width, height, pred_bits, enc->argb_, enc->argb_scratch_, enc->transform_data_);
#line 686
  VP8LWriteBits(bw, 1, (uint32_t )1);
#line 687
  VP8LWriteBits(bw, 2, (uint32_t )0);
#line 689
  VP8LWriteBits(bw, 3, (uint32_t )(pred_bits - 2));
#line 690
  __cil_tmp12 = EncodeImageNoHuffman(bw, enc->transform_data_, transform_width, transform_height,
                                     quality);
  }
#line 690
  if (! __cil_tmp12) {
#line 692
    return (0);
  }
#line 694
  return (1);
}
}
#line 697 "/root/patchweave_new/13/src/enc/vp8l.c"
static int ApplyCrossColorFilter(VP8LEncoder *enc , int width , int height , int quality ,
                                 VP8LBitWriter *bw ) 
{ 
  int ccolor_transform_bits ;
  int transform_width ;
  uint32_t __cil_tmp8 ;
  int transform_height ;
  uint32_t __cil_tmp10 ;
  int step ;
  int tmp ;
  int __cil_tmp14 ;

  {
  {
#line 700
  ccolor_transform_bits = enc->transform_bits_;
#line 701
  __cil_tmp8 = VP8LSubSampleSize((uint32_t )width, (uint32_t )ccolor_transform_bits);
#line 701
  transform_width = (int )__cil_tmp8;
#line 702
  __cil_tmp10 = VP8LSubSampleSize((uint32_t )height, (uint32_t )ccolor_transform_bits);
#line 702
  transform_height = (int )__cil_tmp10;
  }
#line 703
  if (quality == 0) {
#line 703
    tmp = 32;
  } else {
#line 703
    tmp = 8;
  }
  {
#line 703
  step = tmp;
#line 705
  VP8LColorSpaceTransform(width, height, ccolor_transform_bits, step, enc->argb_,
                          enc->transform_data_);
#line 707
  VP8LWriteBits(bw, 1, (uint32_t )1);
#line 708
  VP8LWriteBits(bw, 2, (uint32_t )1);
#line 710
  VP8LWriteBits(bw, 3, (uint32_t )(ccolor_transform_bits - 2));
#line 711
  __cil_tmp14 = EncodeImageNoHuffman(bw, enc->transform_data_, transform_width, transform_height,
                                     quality);
  }
#line 711
  if (! __cil_tmp14) {
#line 713
    return (0);
  }
#line 715
  return (1);
}
}
#line 720 "/root/patchweave_new/13/src/enc/vp8l.c"
static enum WebPEncodingError WriteRiffHeader(WebPPicture *pic , size_t riff_size ,
                                              size_t vp8l_size ) 
{ 
  uint8_t riff[21] ;
  int __cil_tmp5 ;

  {
  {
#line 722
  riff[0] = (uint8_t )'R';
#line 722
  riff[1] = (uint8_t )'I';
#line 722
  riff[2] = (uint8_t )'F';
#line 722
  riff[3] = (uint8_t )'F';
#line 722
  riff[4] = (uint8_t )0;
#line 722
  riff[5] = (uint8_t )0;
#line 722
  riff[6] = (uint8_t )0;
#line 722
  riff[7] = (uint8_t )0;
#line 722
  riff[8] = (uint8_t )'W';
#line 722
  riff[9] = (uint8_t )'E';
#line 722
  riff[10] = (uint8_t )'B';
#line 722
  riff[11] = (uint8_t )'P';
#line 722
  riff[12] = (uint8_t )'V';
#line 722
  riff[13] = (uint8_t )'P';
#line 722
  riff[14] = (uint8_t )'8';
#line 722
  riff[15] = (uint8_t )'L';
#line 722
  riff[16] = (uint8_t )0;
#line 722
  riff[17] = (uint8_t )0;
#line 722
  riff[18] = (uint8_t )0;
#line 722
  riff[19] = (uint8_t )0;
#line 722
  riff[20] = (uint8_t )47;
#line 726
  PutLE32(riff + 4, (uint32_t )riff_size);
#line 727
  PutLE32((riff + 12) + 4, (uint32_t )vp8l_size);
#line 728
  __cil_tmp5 = (*(pic->writer))(riff, sizeof(riff), pic);
  }
#line 728
  if (! __cil_tmp5) {
#line 729
    return ((enum WebPEncodingError )8);
  }
#line 731
  return ((enum WebPEncodingError )0);
}
}
#line 734 "/root/patchweave_new/13/src/enc/vp8l.c"
static int WriteImageSize(WebPPicture *pic , VP8LBitWriter *bw ) 
{ 
  int width ;
  int height ;

  {
  {
#line 736
  width = pic->width - 1;
#line 737
  height = pic->height - 1;
#line 740
  VP8LWriteBits(bw, 14, (uint32_t )width);
#line 741
  VP8LWriteBits(bw, 14, (uint32_t )height);
  }
#line 742
  return (! bw->error_);
}
}
#line 745 "/root/patchweave_new/13/src/enc/vp8l.c"
static int WriteRealAlphaAndVersion(VP8LBitWriter *bw , int has_alpha ) 
{ 


  {
  {
#line 746
  VP8LWriteBits(bw, 1, (uint32_t )has_alpha);
#line 747
  VP8LWriteBits(bw, 3, (uint32_t )0);
  }
#line 748
  return (! bw->error_);
}
}
#line 751 "/root/patchweave_new/13/src/enc/vp8l.c"
static enum WebPEncodingError WriteImage(WebPPicture *pic , VP8LBitWriter *bw , size_t *coded_size ) 
{ 
  enum WebPEncodingError err ;
  uint8_t *webpll_data ;
  uint8_t *__cil_tmp6 ;
  size_t webpll_size ;
  size_t __cil_tmp8 ;
  size_t vp8l_size ;
  size_t pad ;
  size_t riff_size ;
  int __cil_tmp13 ;
  uint8_t pad_byte[1] ;
  int __cil_tmp15 ;

  {
  {
#line 754
  err = (enum WebPEncodingError )0;
#line 755
  __cil_tmp6 = VP8LBitWriterFinish(bw);
#line 755
  webpll_data = __cil_tmp6;
#line 756
  __cil_tmp8 = VP8LBitWriterNumBytes(bw);
#line 756
  webpll_size = __cil_tmp8;
#line 757
  vp8l_size = 1UL + webpll_size;
#line 758
  pad = vp8l_size & 1UL;
#line 759
  riff_size = (12UL + vp8l_size) + pad;
#line 761
  err = WriteRiffHeader(pic, riff_size, vp8l_size);
  }
#line 762
  if ((unsigned int )err != 0U) {
#line 762
    goto Error;
  }
  {
#line 764
  __cil_tmp13 = (*(pic->writer))(webpll_data, webpll_size, pic);
  }
#line 764
  if (! __cil_tmp13) {
#line 765
    err = (enum WebPEncodingError )8;
#line 766
    goto Error;
  }
#line 769
  if (pad) {
    {
#line 770
    pad_byte[0] = (uint8_t )0;
#line 771
    __cil_tmp15 = (*(pic->writer))(pad_byte, (size_t )1, pic);
    }
#line 771
    if (! __cil_tmp15) {
#line 772
      err = (enum WebPEncodingError )8;
#line 773
      goto Error;
    }
  }
#line 776
  *coded_size = 8UL + riff_size;
#line 777
  return ((enum WebPEncodingError )0);
  Error: 
#line 780
  return (err);
}
}
#line 787 "/root/patchweave_new/13/src/enc/vp8l.c"
static enum WebPEncodingError AllocateTransformBuffer(VP8LEncoder *enc , int width ,
                                                      int height ) 
{ 
  enum WebPEncodingError err ;
  int tile_size ;
  uint64_t image_size ;
  uint64_t argb_scratch_size ;
  uint64_t transform_data_size ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint64_t total_size ;
  uint32_t *mem ;
  void *__cil_tmp13 ;

  {
  {
#line 789
  err = (enum WebPEncodingError )0;
#line 790
  tile_size = 1 << enc->transform_bits_;
#line 791
  image_size = (uint64_t )(width * height);
#line 792
  argb_scratch_size = (uint64_t )(tile_size * width + width);
#line 793
  __cil_tmp10 = VP8LSubSampleSize((uint32_t )height, (uint32_t )enc->transform_bits_);
#line 793
  __cil_tmp9 = VP8LSubSampleSize((uint32_t )width, (uint32_t )enc->transform_bits_);
#line 793
  transform_data_size = (uint64_t )__cil_tmp9 * (uint64_t )__cil_tmp10;
#line 796
  total_size = (image_size + argb_scratch_size) + transform_data_size;
#line 798
  __cil_tmp13 = WebPSafeMalloc(total_size, sizeof(*mem));
#line 798
  mem = (uint32_t *)__cil_tmp13;
  }
#line 799
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 800
    err = (enum WebPEncodingError )1;
#line 801
    goto Error;
  }
#line 803
  enc->argb_ = mem;
#line 804
  mem += image_size;
#line 805
  enc->argb_scratch_ = mem;
#line 806
  mem += argb_scratch_size;
#line 807
  enc->transform_data_ = mem;
#line 808
  enc->current_width_ = width;
  Error: 
#line 811
  return (err);
}
}
#line 815 "/root/patchweave_new/13/src/enc/vp8l.c"
static void BundleColorMap(uint8_t *row , int width , int xbits , uint32_t *dst ) 
{ 
  int x ;
  int bit_depth ;
  int mask ;
  uint32_t code ;
  int xsub ;

  {
#line 818
  if (xbits > 0) {
#line 819
    bit_depth = 1 << (3 - xbits);
#line 820
    mask = (1 << xbits) - 1;
#line 821
    code = 4278190080U;
#line 822
    x = 0;
    {
#line 822
    while (1) {
      while_continue: /* CIL Label */ ;

#line 822
      if (! (x < width)) {
#line 822
        goto while_break;
      }
#line 823
      xsub = x & mask;
#line 824
      if (xsub == 0) {
#line 825
        code = 4278190080U;
      }
#line 827
      code |= (unsigned int )((int )*(row + x) << (8 + bit_depth * xsub));
#line 828
      *(dst + (x >> xbits)) = code;
#line 822
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 831
    x = 0;
    {
#line 831
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 831
      if (! (x < width)) {
#line 831
        goto while_break___0;
      }
#line 831
      *(dst + x) = 4278190080U | (unsigned int )((int )*(row + x) << 8);
#line 831
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 836
  return;
}
}
#line 838 "/root/patchweave_new/13/src/enc/vp8l.c"
static enum WebPEncodingError ApplyPalette(VP8LBitWriter *bw , VP8LEncoder *enc ,
                                           int quality ) 
{ 
  enum WebPEncodingError err ;
  int i ;
  int x ;
  int y ;
  WebPPicture *pic ;
  uint32_t *src ;
  uint32_t *dst ;
  int width ;
  int height ;
  uint32_t *palette ;
  int palette_size ;
  uint8_t *row ;
  int xbits ;
  int tmp ;
  int tmp___0 ;
  uint32_t __cil_tmp19 ;
  enum WebPEncodingError __cil_tmp20 ;
  uint32_t pix ;
  int __cil_tmp25 ;
  void *tmp___2 ;

  {
#line 840
  err = (enum WebPEncodingError )0;
#line 842
  pic = enc->pic_;
#line 843
  src = pic->argb;
#line 845
  width = pic->width;
#line 846
  height = pic->height;
#line 847
  palette = enc->palette_;
#line 848
  palette_size = enc->palette_size_;
#line 849
  row = (uint8_t *)((void *)0);
#line 854
  if (palette_size <= 4) {
#line 855
    if (palette_size <= 2) {
#line 855
      tmp = 3;
    } else {
#line 855
      tmp = 2;
    }
#line 855
    xbits = tmp;
  } else {
#line 857
    if (palette_size <= 16) {
#line 857
      tmp___0 = 1;
    } else {
#line 857
      tmp___0 = 0;
    }
#line 857
    xbits = tmp___0;
  }
  {
#line 860
  __cil_tmp19 = VP8LSubSampleSize((uint32_t )width, (uint32_t )xbits);
#line 860
  __cil_tmp20 = AllocateTransformBuffer(enc, (int )__cil_tmp19, height);
#line 860
  err = __cil_tmp20;
  }
#line 861
  if ((unsigned int )err != 0U) {
#line 861
    goto Error;
  }
  {
#line 862
  dst = enc->argb_;
#line 864
  tmp___2 = WebPSafeMalloc((uint64_t )width, sizeof(*row));
#line 864
  row = (uint8_t *)tmp___2;
  }
#line 865
  if ((unsigned long )row == (unsigned long )((void *)0)) {
#line 865
    return ((enum WebPEncodingError )1);
  }
#line 867
  y = 0;
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;

#line 867
    if (! (y < height)) {
#line 867
      goto while_break;
    }
#line 868
    x = 0;
    {
#line 868
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 868
      if (! (x < width)) {
#line 868
        goto while_break___0;
      }
#line 869
      pix = *(src + x);
#line 870
      i = 0;
      {
#line 870
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 870
        if (! (i < palette_size)) {
#line 870
          goto while_break___1;
        }
#line 871
        if (pix == *(palette + i)) {
#line 872
          *(row + x) = (uint8_t )i;
#line 873
          goto while_break___1;
        }
#line 870
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 868
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 877
    BundleColorMap(row, width, xbits, dst);
#line 878
    src += pic->argb_stride;
#line 879
    dst += enc->current_width_;
#line 867
    y ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 883
  VP8LWriteBits(bw, 1, (uint32_t )1);
#line 884
  VP8LWriteBits(bw, 2, (uint32_t )3);
#line 886
  VP8LWriteBits(bw, 8, (uint32_t )(palette_size - 1));
#line 887
  i = palette_size - 1;
  }
  {
#line 887
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 887
    if (! (i >= 1)) {
#line 887
      goto while_break___2;
    }
    {
#line 888
    *(palette + i) = VP8LSubPixels(*(palette + i), *(palette + (i - 1)));
#line 887
    i --;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 890
  __cil_tmp25 = EncodeImageNoHuffman(bw, palette, palette_size, 1, quality);
  }
#line 890
  if (! __cil_tmp25) {
#line 891
    err = (enum WebPEncodingError )4;
#line 892
    goto Error;
  }
  Error: 
  {
#line 896
  free((void *)row);
  }
#line 897
  return (err);
}
}
#line 902 "/root/patchweave_new/13/src/enc/vp8l.c"
static int GetHistoBits(WebPConfig *config , WebPPicture *pic ) 
{ 
  int width ;
  int height ;
  uint64_t hist_size ;
  int histo_bits ;
  uint64_t huff_image_size ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  int tmp ;
  int tmp___0 ;

  {
#line 904
  width = pic->width;
#line 905
  height = pic->height;
#line 906
  hist_size = sizeof(VP8LHistogram );
#line 908
  histo_bits = 7 - config->method;
  {
#line 909
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 910
    __cil_tmp9 = VP8LSubSampleSize((uint32_t )height, (uint32_t )histo_bits);
#line 910
    __cil_tmp8 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histo_bits);
#line 910
    huff_image_size = (unsigned long )(__cil_tmp8 * __cil_tmp9) * hist_size;
    }
#line 913
    if (huff_image_size <= 16777216UL) {
#line 913
      goto while_break;
    }
#line 914
    histo_bits ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 916
  if (histo_bits < 2) {
#line 916
    tmp___0 = 2;
  } else {
#line 916
    if (histo_bits > 9) {
#line 916
      tmp = 9;
    } else {
#line 916
      tmp = histo_bits;
    }
#line 916
    tmp___0 = tmp;
  }
#line 916
  return (tmp___0);
}
}
#line 920 "/root/patchweave_new/13/src/enc/vp8l.c"
static void InitEncParams(VP8LEncoder *enc ) 
{ 
  WebPConfig *config ;
  WebPPicture *picture ;
  int method ;
  float quality ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 921
  config = enc->config_;
#line 922
  picture = enc->pic_;
#line 923
  method = config->method;
#line 924
  quality = config->quality;
#line 925
  if (method < 4) {
#line 925
    tmp___0 = 5;
  } else {
#line 925
    if (method > 4) {
#line 925
      tmp = 3;
    } else {
#line 925
      tmp = 4;
    }
#line 925
    tmp___0 = tmp;
  }
  {
#line 925
  enc->transform_bits_ = tmp___0;
#line 926
  enc->histo_bits_ = GetHistoBits(config, picture);
  }
#line 927
  if (quality <= 25.f) {
#line 927
    tmp___1 = 0;
  } else {
#line 927
    tmp___1 = 7;
  }
#line 927
  enc->cache_bits_ = tmp___1;
#line 928
  return;
}
}
#line 933 "/root/patchweave_new/13/src/enc/vp8l.c"
static VP8LEncoder *VP8LEncoderNew(WebPConfig *config , WebPPicture *picture ) 
{ 
  VP8LEncoder *enc ;
  void *__cil_tmp4 ;

  {
  {
#line 935
  __cil_tmp4 = calloc(1UL, sizeof(*enc));
#line 935
  enc = (VP8LEncoder *)__cil_tmp4;
  }
#line 936
  if ((unsigned long )enc == (unsigned long )((void *)0)) {
    {
#line 937
    WebPEncodingSetError(picture, (enum WebPEncodingError___0 )((enum WebPEncodingError )1));
    }
#line 938
    return ((VP8LEncoder *)((void *)0));
  }
#line 940
  enc->config_ = config;
#line 941
  enc->pic_ = picture;
#line 942
  return (enc);
}
}
#line 945 "/root/patchweave_new/13/src/enc/vp8l.c"
static void VP8LEncoderDelete(VP8LEncoder *enc ) 
{ 


  {
  {
#line 946
  free((void *)enc->argb_);
#line 947
  free((void *)enc);
  }
#line 949
  return;
}
}
#line 953 "/root/patchweave_new/13/src/enc/vp8l.c"
enum WebPEncodingError___0 VP8LEncodeStream(WebPConfig *config , WebPPicture *picture ,
                                            VP8LBitWriter *bw ) 
{ 
  enum WebPEncodingError err ;
  int quality ;
  int width ;
  int height ;
  VP8LEncoder *enc ;
  VP8LEncoder *__cil_tmp9 ;
  size_t byte_position ;
  size_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int y ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  WebPAuxStats *stats ;
  size_t __cil_tmp22 ;

  {
  {
#line 956
  err = (enum WebPEncodingError )0;
#line 957
  quality = (int )config->quality;
#line 958
  width = picture->width;
#line 959
  height = picture->height;
#line 960
  __cil_tmp9 = VP8LEncoderNew(config, picture);
#line 960
  enc = __cil_tmp9;
#line 961
  __cil_tmp11 = VP8LBitWriterNumBytes(bw);
#line 961
  byte_position = __cil_tmp11;
  }
#line 963
  if ((unsigned long )enc == (unsigned long )((void *)0)) {
#line 964
    err = (enum WebPEncodingError )1;
#line 965
    goto Error;
  }
  {
#line 968
  InitEncParams(enc);
#line 973
  __cil_tmp12 = VP8LEncAnalyze(enc, (enum WebPImageHint )config->image_hint);
  }
#line 973
  if (! __cil_tmp12) {
#line 974
    err = (enum WebPEncodingError )1;
#line 975
    goto Error;
  }
#line 978
  if (enc->use_palette_) {
    {
#line 979
    err = ApplyPalette(bw, enc, quality);
    }
#line 980
    if ((unsigned int )err != 0U) {
#line 980
      goto Error;
    }
#line 982
    enc->cache_bits_ = 0;
  }
#line 986
  if ((unsigned long )enc->argb_ == (unsigned long )((void *)0)) {
    {
#line 988
    err = AllocateTransformBuffer(enc, width, height);
    }
#line 989
    if ((unsigned int )err != 0U) {
#line 989
      goto Error;
    }
#line 990
    y = 0;
    {
#line 990
    while (1) {
      while_continue: /* CIL Label */ ;

#line 990
      if (! (y < height)) {
#line 990
        goto while_break;
      }
      {
#line 991
      memcpy((void *)(enc->argb_ + y * width), (void const   *)(picture->argb + y * picture->argb_stride),
             (unsigned long )width * sizeof(*(enc->argb_)));
#line 990
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 995
    enc->current_width_ = width;
  }
  {
#line 1001
  __cil_tmp16 = EvalAndApplySubtractGreen(enc, enc->current_width_, height, bw);
  }
#line 1001
  if (! __cil_tmp16) {
#line 1002
    err = (enum WebPEncodingError )1;
#line 1003
    goto Error;
  }
#line 1006
  if (enc->use_predict_) {
    {
#line 1007
    __cil_tmp17 = ApplyPredictFilter(enc, enc->current_width_, height, quality, bw);
    }
#line 1007
    if (! __cil_tmp17) {
#line 1008
      err = (enum WebPEncodingError )4;
#line 1009
      goto Error;
    }
  }
#line 1013
  if (enc->use_cross_color_) {
    {
#line 1014
    __cil_tmp18 = ApplyCrossColorFilter(enc, enc->current_width_, height, quality,
                                        bw);
    }
#line 1014
    if (! __cil_tmp18) {
#line 1015
      err = (enum WebPEncodingError )4;
#line 1016
      goto Error;
    }
  }
  {
#line 1020
  VP8LWriteBits(bw, 1, (uint32_t )0);
  }
#line 1025
  if (enc->cache_bits_ > 0) {
    {
#line 1026
    __cil_tmp19 = VP8LCalculateEstimateForCacheSize(enc->argb_, enc->current_width_,
                                                    height, & enc->cache_bits_);
    }
#line 1026
    if (! __cil_tmp19) {
#line 1028
      err = (enum WebPEncodingError )4;
#line 1029
      goto Error;
    }
  }
  {
#line 1036
  __cil_tmp20 = EncodeImageInternal(bw, enc->argb_, enc->current_width_, height, quality,
                                    enc->cache_bits_, enc->histo_bits_);
  }
#line 1036
  if (! __cil_tmp20) {
#line 1038
    err = (enum WebPEncodingError )1;
#line 1039
    goto Error;
  }
#line 1042
  if ((unsigned long )picture->stats != (unsigned long )((void *)0)) {
#line 1043
    stats = picture->stats;
#line 1044
    stats->lossless_features = (uint32_t )0;
#line 1045
    if (enc->use_predict_) {
#line 1045
      stats->lossless_features |= 1U;
    }
#line 1046
    if (enc->use_cross_color_) {
#line 1046
      stats->lossless_features |= 2U;
    }
#line 1047
    if (enc->use_subtract_green_) {
#line 1047
      stats->lossless_features |= 4U;
    }
#line 1048
    if (enc->use_palette_) {
#line 1048
      stats->lossless_features |= 8U;
    }
    {
#line 1049
    stats->histogram_bits = enc->histo_bits_;
#line 1050
    stats->transform_bits = enc->transform_bits_;
#line 1051
    stats->cache_bits = enc->cache_bits_;
#line 1052
    stats->palette_size = enc->palette_size_;
#line 1053
    __cil_tmp22 = VP8LBitWriterNumBytes(bw);
#line 1053
    stats->lossless_size = (int )(__cil_tmp22 - byte_position);
    }
  }
  Error: 
  {
#line 1057
  VP8LEncoderDelete(enc);
  }
#line 1058
  return ((enum WebPEncodingError___0 )err);
}
}
#line 1061 "/root/patchweave_new/13/src/enc/vp8l.c"
int VP8LEncodeImage(WebPConfig *config , WebPPicture *picture ) 
{ 
  int width ;
  int height ;
  int has_alpha ;
  size_t coded_size ;
  int percent ;
  enum WebPEncodingError err ;
  VP8LBitWriter bw ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  WebPAuxStats *stats ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  int __cil_tmp20 ;
  int mb_w ;
  int mb_h ;
  enum WebPEncodingError___0 tmp ;

  {
#line 1066
  percent = 0;
#line 1067
  err = (enum WebPEncodingError )0;
#line 1070
  if ((unsigned long )picture == (unsigned long )((void *)0)) {
#line 1070
    return (0);
  }
#line 1072
  if ((unsigned long )config == (unsigned long )((void *)0)) {
    {
#line 1073
    err = (enum WebPEncodingError )3;
#line 1074
    WebPEncodingSetError(picture, (enum WebPEncodingError___0 )err);
    }
#line 1075
    return (0);
  } else
#line 1072
  if ((unsigned long )picture->argb == (unsigned long )((void *)0)) {
    {
#line 1073
    err = (enum WebPEncodingError )3;
#line 1074
    WebPEncodingSetError(picture, (enum WebPEncodingError___0 )err);
    }
#line 1075
    return (0);
  }
  {
#line 1078
  width = picture->width;
#line 1079
  height = picture->height;
#line 1080
  __cil_tmp10 = VP8LBitWriterInit(& bw, (size_t )(width * height >> 1));
  }
#line 1080
  if (! __cil_tmp10) {
#line 1081
    err = (enum WebPEncodingError )1;
#line 1082
    goto Error;
  }
  {
#line 1085
  __cil_tmp11 = WebPReportProgress(picture, 1, & percent);
  }
#line 1085
  if (! __cil_tmp11) {
    UserAbort: 
#line 1087
    err = (enum WebPEncodingError )10;
#line 1088
    goto Error;
  }
#line 1091
  if ((unsigned long )picture->stats != (unsigned long )((void *)0)) {
    {
#line 1092
    stats = picture->stats;
#line 1093
    memset((void *)stats, 0, sizeof(*stats));
#line 1094
    stats->PSNR[0] = 99.f;
#line 1095
    stats->PSNR[1] = 99.f;
#line 1096
    stats->PSNR[2] = 99.f;
#line 1097
    stats->PSNR[3] = 99.f;
#line 1098
    stats->PSNR[4] = 99.f;
    }
  }
  {
#line 1102
  __cil_tmp13 = WriteImageSize(picture, & bw);
  }
#line 1102
  if (! __cil_tmp13) {
#line 1103
    err = (enum WebPEncodingError )1;
#line 1104
    goto Error;
  }
  {
#line 1107
  has_alpha = WebPPictureHasTransparency(picture);
#line 1109
  __cil_tmp15 = WriteRealAlphaAndVersion(& bw, has_alpha);
  }
#line 1109
  if (! __cil_tmp15) {
#line 1110
    err = (enum WebPEncodingError )1;
#line 1111
    goto Error;
  }
  {
#line 1114
  __cil_tmp16 = WebPReportProgress(picture, 5, & percent);
  }
#line 1114
  if (! __cil_tmp16) {
#line 1114
    goto UserAbort;
  }
  {
#line 1117
  tmp = VP8LEncodeStream(config, picture, & bw);
#line 1117
  err = (enum WebPEncodingError )tmp;
  }
#line 1118
  if ((unsigned int )err != 0U) {
#line 1118
    goto Error;
  }
  {
#line 1121
  __cil_tmp18 = WebPReportProgress(picture, 90, & percent);
  }
#line 1121
  if (! __cil_tmp18) {
#line 1121
    goto UserAbort;
  }
  {
#line 1124
  err = WriteImage(picture, & bw, & coded_size);
  }
#line 1125
  if ((unsigned int )err != 0U) {
#line 1125
    goto Error;
  }
  {
#line 1127
  __cil_tmp20 = WebPReportProgress(picture, 100, & percent);
  }
#line 1127
  if (! __cil_tmp20) {
#line 1127
    goto UserAbort;
  }
#line 1130
  if ((unsigned long )picture->stats != (unsigned long )((void *)0)) {
#line 1131
    (picture->stats)->coded_size += (int )coded_size;
#line 1132
    (picture->stats)->lossless_size = (int )coded_size;
  }
#line 1135
  if ((unsigned long )picture->extra_info != (unsigned long )((void *)0)) {
    {
#line 1136
    mb_w = (width + 15) >> 4;
#line 1137
    mb_h = (height + 15) >> 4;
#line 1138
    memset((void *)picture->extra_info, 0, (unsigned long )(mb_w * mb_h) * sizeof(*(picture->extra_info)));
    }
  }
  Error: 
#line 1142
  if (bw.error_) {
#line 1142
    err = (enum WebPEncodingError )1;
  }
  {
#line 1143
  VP8LBitWriterDestroy(& bw);
  }
#line 1144
  if ((unsigned int )err != 0U) {
    {
#line 1145
    WebPEncodingSetError(picture, (enum WebPEncodingError___0 )err);
    }
#line 1146
    return (0);
  }
#line 1148
  return (1);
}
}
#line 23 "/root/patchweave_new/13/src/enc/tree.c"
uint8_t VP8CoeffsProba0[4][8][3][11]  = { { { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )253,            (uint8_t )136,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )228,            (uint8_t )219,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )189,            (uint8_t )129,            (uint8_t )242,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )213,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )106,            (uint8_t )126,            (uint8_t )227,            (uint8_t )252, 
                    (uint8_t )214,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )98,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )226,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )181,            (uint8_t )133,            (uint8_t )238,            (uint8_t )254, 
                    (uint8_t )221,            (uint8_t )234,            (uint8_t )255,            (uint8_t )154, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )78,            (uint8_t )134,            (uint8_t )202,            (uint8_t )247, 
                    (uint8_t )198,            (uint8_t )180,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )185,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )243,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )150,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )77,            (uint8_t )110,            (uint8_t )216,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )230,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )101,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )241,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )170,            (uint8_t )139,            (uint8_t )241,            (uint8_t )252, 
                    (uint8_t )236,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )37,            (uint8_t )116,            (uint8_t )196,            (uint8_t )243, 
                    (uint8_t )228,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )204,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )245,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )207,            (uint8_t )160,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )238,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )102,            (uint8_t )103,            (uint8_t )231,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )171,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )152,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )240,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )177,            (uint8_t )135,            (uint8_t )243,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )225,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )80,            (uint8_t )129,            (uint8_t )211,            (uint8_t )255, 
                    (uint8_t )194,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )246,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )198,            (uint8_t )35,            (uint8_t )237,            (uint8_t )223, 
                    (uint8_t )193,            (uint8_t )187,            (uint8_t )162,            (uint8_t )160, 
                    (uint8_t )145,            (uint8_t )155,            (uint8_t )62}, 
       {            (uint8_t )131,            (uint8_t )45,            (uint8_t )198,            (uint8_t )221, 
                    (uint8_t )172,            (uint8_t )176,            (uint8_t )220,            (uint8_t )157, 
                    (uint8_t )252,            (uint8_t )221,            (uint8_t )1}, 
       {            (uint8_t )68,            (uint8_t )47,            (uint8_t )146,            (uint8_t )208, 
                    (uint8_t )149,            (uint8_t )167,            (uint8_t )221,            (uint8_t )162, 
                    (uint8_t )255,            (uint8_t )223,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )149,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )221,            (uint8_t )224,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )141,            (uint8_t )234,            (uint8_t )253, 
                    (uint8_t )222,            (uint8_t )220,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )81,            (uint8_t )99,            (uint8_t )181,            (uint8_t )242, 
                    (uint8_t )176,            (uint8_t )190,            (uint8_t )249,            (uint8_t )202, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )129,            (uint8_t )232,            (uint8_t )253, 
                    (uint8_t )214,            (uint8_t )197,            (uint8_t )242,            (uint8_t )196, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )99,            (uint8_t )121,            (uint8_t )210,            (uint8_t )250, 
                    (uint8_t )201,            (uint8_t )198,            (uint8_t )255,            (uint8_t )202, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )23,            (uint8_t )91,            (uint8_t )163,            (uint8_t )242, 
                    (uint8_t )170,            (uint8_t )187,            (uint8_t )247,            (uint8_t )210, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )200,            (uint8_t )246,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )109,            (uint8_t )178,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )231,            (uint8_t )245,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )44,            (uint8_t )130,            (uint8_t )201,            (uint8_t )253, 
                    (uint8_t )205,            (uint8_t )192,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )132,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )219,            (uint8_t )209,            (uint8_t )255,            (uint8_t )165, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )94,            (uint8_t )136,            (uint8_t )225,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )190,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )22,            (uint8_t )100,            (uint8_t )174,            (uint8_t )245, 
                    (uint8_t )186,            (uint8_t )161,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )232,            (uint8_t )235,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )143,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )234,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )35,            (uint8_t )77,            (uint8_t )181,            (uint8_t )251, 
                    (uint8_t )193,            (uint8_t )211,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )157,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )231,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )121,            (uint8_t )141,            (uint8_t )235,            (uint8_t )255, 
                    (uint8_t )225,            (uint8_t )227,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )45,            (uint8_t )99,            (uint8_t )188,            (uint8_t )251, 
                    (uint8_t )195,            (uint8_t )217,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )203,            (uint8_t )1,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )137,            (uint8_t )1,            (uint8_t )177,            (uint8_t )255, 
                    (uint8_t )224,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )253,            (uint8_t )9,            (uint8_t )248,            (uint8_t )251, 
                    (uint8_t )207,            (uint8_t )208,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )175,            (uint8_t )13,            (uint8_t )224,            (uint8_t )243, 
                    (uint8_t )193,            (uint8_t )185,            (uint8_t )249,            (uint8_t )198, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )73,            (uint8_t )17,            (uint8_t )171,            (uint8_t )221, 
                    (uint8_t )161,            (uint8_t )179,            (uint8_t )236,            (uint8_t )167, 
                    (uint8_t )255,            (uint8_t )234,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )95,            (uint8_t )247,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )183,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )239,            (uint8_t )90,            (uint8_t )244,            (uint8_t )250, 
                    (uint8_t )211,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )155,            (uint8_t )77,            (uint8_t )195,            (uint8_t )248, 
                    (uint8_t )188,            (uint8_t )195,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )24,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )219,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )201,            (uint8_t )51,            (uint8_t )219,            (uint8_t )255, 
                    (uint8_t )196,            (uint8_t )186,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )69,            (uint8_t )46,            (uint8_t )190,            (uint8_t )239, 
                    (uint8_t )201,            (uint8_t )218,            (uint8_t )255,            (uint8_t )228, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )191,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )223,            (uint8_t )165,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )124,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )16,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )190,            (uint8_t )36,            (uint8_t )230,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )226,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )247,            (uint8_t )192,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )240,            (uint8_t )128,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )134,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )213,            (uint8_t )62,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )55,            (uint8_t )93,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )202,            (uint8_t )24,            (uint8_t )213,            (uint8_t )235, 
                    (uint8_t )186,            (uint8_t )191,            (uint8_t )220,            (uint8_t )160, 
                    (uint8_t )240,            (uint8_t )175,            (uint8_t )255}, 
       {            (uint8_t )126,            (uint8_t )38,            (uint8_t )182,            (uint8_t )232, 
                    (uint8_t )169,            (uint8_t )184,            (uint8_t )228,            (uint8_t )174, 
                    (uint8_t )255,            (uint8_t )187,            (uint8_t )128}, 
       {            (uint8_t )61,            (uint8_t )46,            (uint8_t )138,            (uint8_t )219, 
                    (uint8_t )151,            (uint8_t )178,            (uint8_t )240,            (uint8_t )170, 
                    (uint8_t )255,            (uint8_t )216,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )112,            (uint8_t )230,            (uint8_t )250, 
                    (uint8_t )199,            (uint8_t )191,            (uint8_t )247,            (uint8_t )159, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )166,            (uint8_t )109,            (uint8_t )228,            (uint8_t )252, 
                    (uint8_t )211,            (uint8_t )215,            (uint8_t )255,            (uint8_t )174, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )39,            (uint8_t )77,            (uint8_t )162,            (uint8_t )232, 
                    (uint8_t )172,            (uint8_t )180,            (uint8_t )245,            (uint8_t )178, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )52,            (uint8_t )220,            (uint8_t )246, 
                    (uint8_t )198,            (uint8_t )199,            (uint8_t )249,            (uint8_t )220, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )74,            (uint8_t )191,            (uint8_t )243, 
                    (uint8_t )183,            (uint8_t )193,            (uint8_t )250,            (uint8_t )221, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )24,            (uint8_t )71,            (uint8_t )130,            (uint8_t )219, 
                    (uint8_t )154,            (uint8_t )170,            (uint8_t )243,            (uint8_t )182, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )225,            (uint8_t )249, 
                    (uint8_t )219,            (uint8_t )240,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )150,            (uint8_t )226,            (uint8_t )252, 
                    (uint8_t )216,            (uint8_t )205,            (uint8_t )255,            (uint8_t )171, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )28,            (uint8_t )108,            (uint8_t )170,            (uint8_t )242, 
                    (uint8_t )183,            (uint8_t )194,            (uint8_t )254,            (uint8_t )223, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )81,            (uint8_t )230,            (uint8_t )252, 
                    (uint8_t )204,            (uint8_t )203,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )123,            (uint8_t )102,            (uint8_t )209,            (uint8_t )247, 
                    (uint8_t )188,            (uint8_t )196,            (uint8_t )255,            (uint8_t )233, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )20,            (uint8_t )95,            (uint8_t )153,            (uint8_t )243, 
                    (uint8_t )164,            (uint8_t )173,            (uint8_t )255,            (uint8_t )203, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )222,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )216,            (uint8_t )213,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )168,            (uint8_t )175,            (uint8_t )246,            (uint8_t )252, 
                    (uint8_t )235,            (uint8_t )205,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )47,            (uint8_t )116,            (uint8_t )215,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )212,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )121,            (uint8_t )236,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )214,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )84,            (uint8_t )213,            (uint8_t )252, 
                    (uint8_t )201,            (uint8_t )202,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )42,            (uint8_t )80,            (uint8_t )160,            (uint8_t )240, 
                    (uint8_t )162,            (uint8_t )185,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )244,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )238,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}};
#line 159 "/root/patchweave_new/13/src/enc/tree.c"
void VP8DefaultProbas(VP8Encoder *enc ) 
{ 
  VP8Proba *probas ;

  {
  {
#line 160
  probas = & enc->proba_;
#line 161
  probas->use_skip_proba_ = 0;
#line 162
  memset((void *)(probas->segments_), 255, sizeof(probas->segments_));
#line 163
  memcpy((void *)(probas->coeffs_), (void const   *)(VP8CoeffsProba0), sizeof(VP8CoeffsProba0));
#line 166
  probas->dirty_ = 1;
  }
#line 168
  return;
}
}
#line 170 "/root/patchweave_new/13/src/enc/tree.c"
static uint8_t kBModesProba[10][10][9]  = 
#line 170
  { { {          (uint8_t )231,          (uint8_t )120,          (uint8_t )48,          (uint8_t )89, 
                (uint8_t )115,          (uint8_t )113,          (uint8_t )120,          (uint8_t )152, 
                (uint8_t )112}, 
     {          (uint8_t )152,          (uint8_t )179,          (uint8_t )64,          (uint8_t )126, 
                (uint8_t )170,          (uint8_t )118,          (uint8_t )46,          (uint8_t )70, 
                (uint8_t )95}, 
     {          (uint8_t )175,          (uint8_t )69,          (uint8_t )143,          (uint8_t )80, 
                (uint8_t )85,          (uint8_t )82,          (uint8_t )72,          (uint8_t )155, 
                (uint8_t )103}, 
     {          (uint8_t )56,          (uint8_t )58,          (uint8_t )10,          (uint8_t )171, 
                (uint8_t )218,          (uint8_t )189,          (uint8_t )17,          (uint8_t )13, 
                (uint8_t )152}, 
     {          (uint8_t )114,          (uint8_t )26,          (uint8_t )17,          (uint8_t )163, 
                (uint8_t )44,          (uint8_t )195,          (uint8_t )21,          (uint8_t )10, 
                (uint8_t )173}, 
     {          (uint8_t )121,          (uint8_t )24,          (uint8_t )80,          (uint8_t )195, 
                (uint8_t )26,          (uint8_t )62,          (uint8_t )44,          (uint8_t )64, 
                (uint8_t )85}, 
     {          (uint8_t )144,          (uint8_t )71,          (uint8_t )10,          (uint8_t )38, 
                (uint8_t )171,          (uint8_t )213,          (uint8_t )144,          (uint8_t )34, 
                (uint8_t )26}, 
     {          (uint8_t )170,          (uint8_t )46,          (uint8_t )55,          (uint8_t )19, 
                (uint8_t )136,          (uint8_t )160,          (uint8_t )33,          (uint8_t )206, 
                (uint8_t )71}, 
     {          (uint8_t )63,          (uint8_t )20,          (uint8_t )8,          (uint8_t )114, 
                (uint8_t )114,          (uint8_t )208,          (uint8_t )12,          (uint8_t )9, 
                (uint8_t )226}, 
     {          (uint8_t )81,          (uint8_t )40,          (uint8_t )11,          (uint8_t )96, 
                (uint8_t )182,          (uint8_t )84,          (uint8_t )29,          (uint8_t )16, 
                (uint8_t )36}}, 
   { {          (uint8_t )134,          (uint8_t )183,          (uint8_t )89,          (uint8_t )137, 
                (uint8_t )98,          (uint8_t )101,          (uint8_t )106,          (uint8_t )165, 
                (uint8_t )148}, 
     {          (uint8_t )72,          (uint8_t )187,          (uint8_t )100,          (uint8_t )130, 
                (uint8_t )157,          (uint8_t )111,          (uint8_t )32,          (uint8_t )75, 
                (uint8_t )80}, 
     {          (uint8_t )66,          (uint8_t )102,          (uint8_t )167,          (uint8_t )99, 
                (uint8_t )74,          (uint8_t )62,          (uint8_t )40,          (uint8_t )234, 
                (uint8_t )128}, 
     {          (uint8_t )41,          (uint8_t )53,          (uint8_t )9,          (uint8_t )178, 
                (uint8_t )241,          (uint8_t )141,          (uint8_t )26,          (uint8_t )8, 
                (uint8_t )107}, 
     {          (uint8_t )74,          (uint8_t )43,          (uint8_t )26,          (uint8_t )146, 
                (uint8_t )73,          (uint8_t )166,          (uint8_t )49,          (uint8_t )23, 
                (uint8_t )157}, 
     {          (uint8_t )65,          (uint8_t )38,          (uint8_t )105,          (uint8_t )160, 
                (uint8_t )51,          (uint8_t )52,          (uint8_t )31,          (uint8_t )115, 
                (uint8_t )128}, 
     {          (uint8_t )104,          (uint8_t )79,          (uint8_t )12,          (uint8_t )27, 
                (uint8_t )217,          (uint8_t )255,          (uint8_t )87,          (uint8_t )17, 
                (uint8_t )7}, 
     {          (uint8_t )87,          (uint8_t )68,          (uint8_t )71,          (uint8_t )44, 
                (uint8_t )114,          (uint8_t )51,          (uint8_t )15,          (uint8_t )186, 
                (uint8_t )23}, 
     {          (uint8_t )47,          (uint8_t )41,          (uint8_t )14,          (uint8_t )110, 
                (uint8_t )182,          (uint8_t )183,          (uint8_t )21,          (uint8_t )17, 
                (uint8_t )194}, 
     {          (uint8_t )66,          (uint8_t )45,          (uint8_t )25,          (uint8_t )102, 
                (uint8_t )197,          (uint8_t )189,          (uint8_t )23,          (uint8_t )18, 
                (uint8_t )22}}, 
   { {          (uint8_t )88,          (uint8_t )88,          (uint8_t )147,          (uint8_t )150, 
                (uint8_t )42,          (uint8_t )46,          (uint8_t )45,          (uint8_t )196, 
                (uint8_t )205}, 
     {          (uint8_t )43,          (uint8_t )97,          (uint8_t )183,          (uint8_t )117, 
                (uint8_t )85,          (uint8_t )38,          (uint8_t )35,          (uint8_t )179, 
                (uint8_t )61}, 
     {          (uint8_t )39,          (uint8_t )53,          (uint8_t )200,          (uint8_t )87, 
                (uint8_t )26,          (uint8_t )21,          (uint8_t )43,          (uint8_t )232, 
                (uint8_t )171}, 
     {          (uint8_t )56,          (uint8_t )34,          (uint8_t )51,          (uint8_t )104, 
                (uint8_t )114,          (uint8_t )102,          (uint8_t )29,          (uint8_t )93, 
                (uint8_t )77}, 
     {          (uint8_t )39,          (uint8_t )28,          (uint8_t )85,          (uint8_t )171, 
                (uint8_t )58,          (uint8_t )165,          (uint8_t )90,          (uint8_t )98, 
                (uint8_t )64}, 
     {          (uint8_t )34,          (uint8_t )22,          (uint8_t )116,          (uint8_t )206, 
                (uint8_t )23,          (uint8_t )34,          (uint8_t )43,          (uint8_t )166, 
                (uint8_t )73}, 
     {          (uint8_t )107,          (uint8_t )54,          (uint8_t )32,          (uint8_t )26, 
                (uint8_t )51,          (uint8_t )1,          (uint8_t )81,          (uint8_t )43, 
                (uint8_t )31}, 
     {          (uint8_t )68,          (uint8_t )25,          (uint8_t )106,          (uint8_t )22, 
                (uint8_t )64,          (uint8_t )171,          (uint8_t )36,          (uint8_t )225, 
                (uint8_t )114}, 
     {          (uint8_t )34,          (uint8_t )19,          (uint8_t )21,          (uint8_t )102, 
                (uint8_t )132,          (uint8_t )188,          (uint8_t )16,          (uint8_t )76, 
                (uint8_t )124}, 
     {          (uint8_t )62,          (uint8_t )18,          (uint8_t )78,          (uint8_t )95, 
                (uint8_t )85,          (uint8_t )57,          (uint8_t )50,          (uint8_t )48, 
                (uint8_t )51}}, 
   { {          (uint8_t )193,          (uint8_t )101,          (uint8_t )35,          (uint8_t )159, 
                (uint8_t )215,          (uint8_t )111,          (uint8_t )89,          (uint8_t )46, 
                (uint8_t )111}, 
     {          (uint8_t )60,          (uint8_t )148,          (uint8_t )31,          (uint8_t )172, 
                (uint8_t )219,          (uint8_t )228,          (uint8_t )21,          (uint8_t )18, 
                (uint8_t )111}, 
     {          (uint8_t )112,          (uint8_t )113,          (uint8_t )77,          (uint8_t )85, 
                (uint8_t )179,          (uint8_t )255,          (uint8_t )38,          (uint8_t )120, 
                (uint8_t )114}, 
     {          (uint8_t )40,          (uint8_t )42,          (uint8_t )1,          (uint8_t )196, 
                (uint8_t )245,          (uint8_t )209,          (uint8_t )10,          (uint8_t )25, 
                (uint8_t )109}, 
     {          (uint8_t )88,          (uint8_t )43,          (uint8_t )29,          (uint8_t )140, 
                (uint8_t )166,          (uint8_t )213,          (uint8_t )37,          (uint8_t )43, 
                (uint8_t )154}, 
     {          (uint8_t )61,          (uint8_t )63,          (uint8_t )30,          (uint8_t )155, 
                (uint8_t )67,          (uint8_t )45,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )100,          (uint8_t )80,          (uint8_t )8,          (uint8_t )43, 
                (uint8_t )154,          (uint8_t )1,          (uint8_t )51,          (uint8_t )26, 
                (uint8_t )71}, 
     {          (uint8_t )142,          (uint8_t )78,          (uint8_t )78,          (uint8_t )16, 
                (uint8_t )255,          (uint8_t )128,          (uint8_t )34,          (uint8_t )197, 
                (uint8_t )171}, 
     {          (uint8_t )41,          (uint8_t )40,          (uint8_t )5,          (uint8_t )102, 
                (uint8_t )211,          (uint8_t )183,          (uint8_t )4,          (uint8_t )1, 
                (uint8_t )221}, 
     {          (uint8_t )51,          (uint8_t )50,          (uint8_t )17,          (uint8_t )168, 
                (uint8_t )209,          (uint8_t )192,          (uint8_t )23,          (uint8_t )25, 
                (uint8_t )82}}, 
   { {          (uint8_t )138,          (uint8_t )31,          (uint8_t )36,          (uint8_t )171, 
                (uint8_t )27,          (uint8_t )166,          (uint8_t )38,          (uint8_t )44, 
                (uint8_t )229}, 
     {          (uint8_t )67,          (uint8_t )87,          (uint8_t )58,          (uint8_t )169, 
                (uint8_t )82,          (uint8_t )115,          (uint8_t )26,          (uint8_t )59, 
                (uint8_t )179}, 
     {          (uint8_t )63,          (uint8_t )59,          (uint8_t )90,          (uint8_t )180, 
                (uint8_t )59,          (uint8_t )166,          (uint8_t )93,          (uint8_t )73, 
                (uint8_t )154}, 
     {          (uint8_t )40,          (uint8_t )40,          (uint8_t )21,          (uint8_t )116, 
                (uint8_t )143,          (uint8_t )209,          (uint8_t )34,          (uint8_t )39, 
                (uint8_t )175}, 
     {          (uint8_t )47,          (uint8_t )15,          (uint8_t )16,          (uint8_t )183, 
                (uint8_t )34,          (uint8_t )223,          (uint8_t )49,          (uint8_t )45, 
                (uint8_t )183}, 
     {          (uint8_t )46,          (uint8_t )17,          (uint8_t )33,          (uint8_t )183, 
                (uint8_t )6,          (uint8_t )98,          (uint8_t )15,          (uint8_t )32, 
                (uint8_t )183}, 
     {          (uint8_t )57,          (uint8_t )46,          (uint8_t )22,          (uint8_t )24, 
                (uint8_t )128,          (uint8_t )1,          (uint8_t )54,          (uint8_t )17, 
                (uint8_t )37}, 
     {          (uint8_t )65,          (uint8_t )32,          (uint8_t )73,          (uint8_t )115, 
                (uint8_t )28,          (uint8_t )128,          (uint8_t )23,          (uint8_t )128, 
                (uint8_t )205}, 
     {          (uint8_t )40,          (uint8_t )3,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )51,          (uint8_t )192,          (uint8_t )18,          (uint8_t )6, 
                (uint8_t )223}, 
     {          (uint8_t )87,          (uint8_t )37,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )59,          (uint8_t )77,          (uint8_t )64,          (uint8_t )21, 
                (uint8_t )47}}, 
   { {          (uint8_t )104,          (uint8_t )55,          (uint8_t )44,          (uint8_t )218, 
                (uint8_t )9,          (uint8_t )54,          (uint8_t )53,          (uint8_t )130, 
                (uint8_t )226}, 
     {          (uint8_t )64,          (uint8_t )90,          (uint8_t )70,          (uint8_t )205, 
                (uint8_t )40,          (uint8_t )41,          (uint8_t )23,          (uint8_t )26, 
                (uint8_t )57}, 
     {          (uint8_t )54,          (uint8_t )57,          (uint8_t )112,          (uint8_t )184, 
                (uint8_t )5,          (uint8_t )41,          (uint8_t )38,          (uint8_t )166, 
                (uint8_t )213}, 
     {          (uint8_t )30,          (uint8_t )34,          (uint8_t )26,          (uint8_t )133, 
                (uint8_t )152,          (uint8_t )116,          (uint8_t )10,          (uint8_t )32, 
                (uint8_t )134}, 
     {          (uint8_t )39,          (uint8_t )19,          (uint8_t )53,          (uint8_t )221, 
                (uint8_t )26,          (uint8_t )114,          (uint8_t )32,          (uint8_t )73, 
                (uint8_t )255}, 
     {          (uint8_t )31,          (uint8_t )9,          (uint8_t )65,          (uint8_t )234, 
                (uint8_t )2,          (uint8_t )15,          (uint8_t )1,          (uint8_t )118, 
                (uint8_t )73}, 
     {          (uint8_t )75,          (uint8_t )32,          (uint8_t )12,          (uint8_t )51, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )160,          (uint8_t )43, 
                (uint8_t )51}, 
     {          (uint8_t )88,          (uint8_t )31,          (uint8_t )35,          (uint8_t )67, 
                (uint8_t )102,          (uint8_t )85,          (uint8_t )55,          (uint8_t )186, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )23,          (uint8_t )111, 
                (uint8_t )59,          (uint8_t )205,          (uint8_t )45,          (uint8_t )37, 
                (uint8_t )192}, 
     {          (uint8_t )55,          (uint8_t )38,          (uint8_t )70,          (uint8_t )124, 
                (uint8_t )73,          (uint8_t )102,          (uint8_t )1,          (uint8_t )34, 
                (uint8_t )98}}, 
   { {          (uint8_t )125,          (uint8_t )98,          (uint8_t )42,          (uint8_t )88, 
                (uint8_t )104,          (uint8_t )85,          (uint8_t )117,          (uint8_t )175, 
                (uint8_t )82}, 
     {          (uint8_t )95,          (uint8_t )84,          (uint8_t )53,          (uint8_t )89, 
                (uint8_t )128,          (uint8_t )100,          (uint8_t )113,          (uint8_t )101, 
                (uint8_t )45}, 
     {          (uint8_t )75,          (uint8_t )79,          (uint8_t )123,          (uint8_t )47, 
                (uint8_t )51,          (uint8_t )128,          (uint8_t )81,          (uint8_t )171, 
                (uint8_t )1}, 
     {          (uint8_t )57,          (uint8_t )17,          (uint8_t )5,          (uint8_t )71, 
                (uint8_t )102,          (uint8_t )57,          (uint8_t )53,          (uint8_t )41, 
                (uint8_t )49}, 
     {          (uint8_t )38,          (uint8_t )33,          (uint8_t )13,          (uint8_t )121, 
                (uint8_t )57,          (uint8_t )73,          (uint8_t )26,          (uint8_t )1, 
                (uint8_t )85}, 
     {          (uint8_t )41,          (uint8_t )10,          (uint8_t )67,          (uint8_t )138, 
                (uint8_t )77,          (uint8_t )110,          (uint8_t )90,          (uint8_t )47, 
                (uint8_t )114}, 
     {          (uint8_t )115,          (uint8_t )21,          (uint8_t )2,          (uint8_t )10, 
                (uint8_t )102,          (uint8_t )255,          (uint8_t )166,          (uint8_t )23, 
                (uint8_t )6}, 
     {          (uint8_t )101,          (uint8_t )29,          (uint8_t )16,          (uint8_t )10, 
                (uint8_t )85,          (uint8_t )128,          (uint8_t )101,          (uint8_t )196, 
                (uint8_t )26}, 
     {          (uint8_t )57,          (uint8_t )18,          (uint8_t )10,          (uint8_t )102, 
                (uint8_t )102,          (uint8_t )213,          (uint8_t )34,          (uint8_t )20, 
                (uint8_t )43}, 
     {          (uint8_t )117,          (uint8_t )20,          (uint8_t )15,          (uint8_t )36, 
                (uint8_t )163,          (uint8_t )128,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )26}}, 
   { {          (uint8_t )102,          (uint8_t )61,          (uint8_t )71,          (uint8_t )37, 
                (uint8_t )34,          (uint8_t )53,          (uint8_t )31,          (uint8_t )243, 
                (uint8_t )192}, 
     {          (uint8_t )69,          (uint8_t )60,          (uint8_t )71,          (uint8_t )38, 
                (uint8_t )73,          (uint8_t )119,          (uint8_t )28,          (uint8_t )222, 
                (uint8_t )37}, 
     {          (uint8_t )68,          (uint8_t )45,          (uint8_t )128,          (uint8_t )34, 
                (uint8_t )1,          (uint8_t )47,          (uint8_t )11,          (uint8_t )245, 
                (uint8_t )171}, 
     {          (uint8_t )62,          (uint8_t )17,          (uint8_t )19,          (uint8_t )70, 
                (uint8_t )146,          (uint8_t )85,          (uint8_t )55,          (uint8_t )62, 
                (uint8_t )70}, 
     {          (uint8_t )37,          (uint8_t )43,          (uint8_t )37,          (uint8_t )154, 
                (uint8_t )100,          (uint8_t )163,          (uint8_t )85,          (uint8_t )160, 
                (uint8_t )1}, 
     {          (uint8_t )63,          (uint8_t )9,          (uint8_t )92,          (uint8_t )136, 
                (uint8_t )28,          (uint8_t )64,          (uint8_t )32,          (uint8_t )201, 
                (uint8_t )85}, 
     {          (uint8_t )75,          (uint8_t )15,          (uint8_t )9,          (uint8_t )9, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )184,          (uint8_t )119, 
                (uint8_t )16}, 
     {          (uint8_t )86,          (uint8_t )6,          (uint8_t )28,          (uint8_t )5, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )25,          (uint8_t )248, 
                (uint8_t )1}, 
     {          (uint8_t )56,          (uint8_t )8,          (uint8_t )17,          (uint8_t )132, 
                (uint8_t )137,          (uint8_t )255,          (uint8_t )55,          (uint8_t )116, 
                (uint8_t )128}, 
     {          (uint8_t )58,          (uint8_t )15,          (uint8_t )20,          (uint8_t )82, 
                (uint8_t )135,          (uint8_t )57,          (uint8_t )26,          (uint8_t )121, 
                (uint8_t )40}}, 
   { {          (uint8_t )164,          (uint8_t )50,          (uint8_t )31,          (uint8_t )137, 
                (uint8_t )154,          (uint8_t )133,          (uint8_t )25,          (uint8_t )35, 
                (uint8_t )218}, 
     {          (uint8_t )51,          (uint8_t )103,          (uint8_t )44,          (uint8_t )131, 
                (uint8_t )131,          (uint8_t )123,          (uint8_t )31,          (uint8_t )6, 
                (uint8_t )158}, 
     {          (uint8_t )86,          (uint8_t )40,          (uint8_t )64,          (uint8_t )135, 
                (uint8_t )148,          (uint8_t )224,          (uint8_t )45,          (uint8_t )183, 
                (uint8_t )128}, 
     {          (uint8_t )22,          (uint8_t )26,          (uint8_t )17,          (uint8_t )131, 
                (uint8_t )240,          (uint8_t )154,          (uint8_t )14,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )45,          (uint8_t )16,          (uint8_t )21,          (uint8_t )91, 
                (uint8_t )64,          (uint8_t )222,          (uint8_t )7,          (uint8_t )1, 
                (uint8_t )197}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )39,          (uint8_t )155, 
                (uint8_t )60,          (uint8_t )138,          (uint8_t )23,          (uint8_t )102, 
                (uint8_t )213}, 
     {          (uint8_t )83,          (uint8_t )12,          (uint8_t )13,          (uint8_t )54, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )68,          (uint8_t )47, 
                (uint8_t )28}, 
     {          (uint8_t )85,          (uint8_t )26,          (uint8_t )85,          (uint8_t )85, 
                (uint8_t )128,          (uint8_t )128,          (uint8_t )32,          (uint8_t )146, 
                (uint8_t )171}, 
     {          (uint8_t )18,          (uint8_t )11,          (uint8_t )7,          (uint8_t )63, 
                (uint8_t )144,          (uint8_t )171,          (uint8_t )4,          (uint8_t )4, 
                (uint8_t )246}, 
     {          (uint8_t )35,          (uint8_t )27,          (uint8_t )10,          (uint8_t )146, 
                (uint8_t )174,          (uint8_t )171,          (uint8_t )12,          (uint8_t )26, 
                (uint8_t )128}}, 
   { {          (uint8_t )190,          (uint8_t )80,          (uint8_t )35,          (uint8_t )99, 
                (uint8_t )180,          (uint8_t )80,          (uint8_t )126,          (uint8_t )54, 
                (uint8_t )45}, 
     {          (uint8_t )85,          (uint8_t )126,          (uint8_t )47,          (uint8_t )87, 
                (uint8_t )176,          (uint8_t )51,          (uint8_t )41,          (uint8_t )20, 
                (uint8_t )32}, 
     {          (uint8_t )101,          (uint8_t )75,          (uint8_t )128,          (uint8_t )139, 
                (uint8_t )118,          (uint8_t )146,          (uint8_t )116,          (uint8_t )128, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )41,          (uint8_t )15,          (uint8_t )176, 
                (uint8_t )236,          (uint8_t )85,          (uint8_t )37,          (uint8_t )9, 
                (uint8_t )62}, 
     {          (uint8_t )71,          (uint8_t )30,          (uint8_t )17,          (uint8_t )119, 
                (uint8_t )118,          (uint8_t )255,          (uint8_t )17,          (uint8_t )18, 
                (uint8_t )138}, 
     {          (uint8_t )101,          (uint8_t )38,          (uint8_t )60,          (uint8_t )138, 
                (uint8_t )55,          (uint8_t )70,          (uint8_t )43,          (uint8_t )26, 
                (uint8_t )142}, 
     {          (uint8_t )146,          (uint8_t )36,          (uint8_t )19,          (uint8_t )30, 
                (uint8_t )171,          (uint8_t )255,          (uint8_t )97,          (uint8_t )27, 
                (uint8_t )20}, 
     {          (uint8_t )138,          (uint8_t )45,          (uint8_t )61,          (uint8_t )62, 
                (uint8_t )219,          (uint8_t )1,          (uint8_t )81,          (uint8_t )188, 
                (uint8_t )64}, 
     {          (uint8_t )32,          (uint8_t )41,          (uint8_t )20,          (uint8_t )117, 
                (uint8_t )151,          (uint8_t )142,          (uint8_t )20,          (uint8_t )21, 
                (uint8_t )163}, 
     {          (uint8_t )112,          (uint8_t )19,          (uint8_t )12,          (uint8_t )61, 
                (uint8_t )195,          (uint8_t )128,          (uint8_t )48,          (uint8_t )4, 
                (uint8_t )24}}};
#line 273 "/root/patchweave_new/13/src/enc/tree.c"
static int PutI4Mode(VP8BitWriter *bw , int mode , uint8_t *prob ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 275
  __cil_tmp4 = VP8PutBit(bw, mode != 0, (int )*(prob + 0));
  }
#line 275
  if (__cil_tmp4) {
    {
#line 276
    __cil_tmp5 = VP8PutBit(bw, mode != 1, (int )*(prob + 1));
    }
#line 276
    if (__cil_tmp5) {
      {
#line 277
      __cil_tmp6 = VP8PutBit(bw, mode != 2, (int )*(prob + 2));
      }
#line 277
      if (__cil_tmp6) {
        {
#line 278
        __cil_tmp7 = VP8PutBit(bw, mode >= 6, (int )*(prob + 3));
        }
#line 278
        if (! __cil_tmp7) {
          {
#line 279
          __cil_tmp8 = VP8PutBit(bw, mode != 3, (int )*(prob + 4));
          }
#line 279
          if (__cil_tmp8) {
            {
#line 280
            VP8PutBit(bw, mode != 4, (int )*(prob + 5));
            }
          }
        } else {
          {
#line 283
          __cil_tmp9 = VP8PutBit(bw, mode != 6, (int )*(prob + 6));
          }
#line 283
          if (__cil_tmp9) {
            {
#line 284
            __cil_tmp10 = VP8PutBit(bw, mode != 7, (int )*(prob + 7));
            }
#line 284
            if (__cil_tmp10) {
              {
#line 285
              VP8PutBit(bw, mode != 8, (int )*(prob + 8));
              }
            }
          }
        }
      }
    }
  }
#line 292
  return (mode);
}
}
#line 295 "/root/patchweave_new/13/src/enc/tree.c"
static void PutI16Mode(VP8BitWriter *bw , int mode ) 
{ 
  int __cil_tmp3 ;
  int tmp ;

  {
#line 296
  if (mode == 1) {
#line 296
    tmp = 1;
  } else
#line 296
  if (mode == 3) {
#line 296
    tmp = 1;
  } else {
#line 296
    tmp = 0;
  }
  {
#line 296
  __cil_tmp3 = VP8PutBit(bw, tmp, 156);
  }
#line 296
  if (__cil_tmp3) {
    {
#line 297
    VP8PutBit(bw, mode == 1, 128);
    }
  } else {
    {
#line 299
    VP8PutBit(bw, mode == 2, 163);
    }
  }
#line 302
  return;
}
}
#line 303 "/root/patchweave_new/13/src/enc/tree.c"
static void PutUVMode(VP8BitWriter *bw , int uv_mode ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 304
  __cil_tmp3 = VP8PutBit(bw, uv_mode != 0, 142);
  }
#line 304
  if (__cil_tmp3) {
    {
#line 305
    __cil_tmp4 = VP8PutBit(bw, uv_mode != 2, 114);
    }
#line 305
    if (__cil_tmp4) {
      {
#line 306
      VP8PutBit(bw, uv_mode != 3, 183);
      }
    }
  }
#line 310
  return;
}
}
#line 311 "/root/patchweave_new/13/src/enc/tree.c"
static void PutSegment(VP8BitWriter *bw , int s , uint8_t *p ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 312
  __cil_tmp4 = VP8PutBit(bw, s >= 2, (int )*(p + 0));
  }
#line 312
  if (__cil_tmp4) {
#line 312
    p ++;
  }
  {
#line 313
  VP8PutBit(bw, s & 1, (int )*(p + 1));
  }
#line 315
  return;
}
}
#line 316 "/root/patchweave_new/13/src/enc/tree.c"
void VP8CodeIntraModes(VP8Encoder *enc ) 
{ 
  VP8BitWriter *bw ;
  VP8EncIterator it ;
  int __cil_tmp4 ;
  VP8MBInfo *mb ;
  uint8_t *preds ;
  int __cil_tmp7 ;
  int preds_w ;
  uint8_t *top_pred ;
  int x ;
  int y ;
  int left ;
  uint8_t *probas ;

  {
  {
#line 317
  bw = & enc->bw_;
#line 319
  VP8IteratorInit(enc, & it);
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    mb = it.mb_;
#line 322
    preds = it.preds_;
#line 323
    if (enc->segment_hdr_.update_map_) {
      {
#line 324
      PutSegment(bw, (int )mb->segment_, enc->proba_.segments_);
      }
    }
#line 326
    if (enc->proba_.use_skip_proba_) {
      {
#line 327
      VP8PutBit(bw, (int )mb->skip_, (int )enc->proba_.skip_proba_);
      }
    }
    {
#line 329
    __cil_tmp7 = VP8PutBit(bw, (int )mb->type_ != 0, 145);
    }
#line 329
    if (__cil_tmp7) {
      {
#line 330
      PutI16Mode(bw, (int )*(preds + 0));
      }
    } else {
#line 332
      preds_w = enc->preds_w_;
#line 333
      top_pred = preds - preds_w;
#line 335
      y = 0;
      {
#line 335
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 335
        if (! (y < 4)) {
#line 335
          goto while_break___0;
        }
#line 336
        left = (int )*(preds + -1);
#line 337
        x = 0;
        {
#line 337
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 337
          if (! (x < 4)) {
#line 337
            goto while_break___1;
          }
          {
#line 338
          probas = kBModesProba[*(top_pred + x)][left];
#line 339
          left = PutI4Mode(bw, (int )*(preds + x), probas);
#line 337
          x ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: 
#line 341
        top_pred = preds;
#line 342
        preds += preds_w;
#line 335
        y ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    }
    {
#line 345
    PutUVMode(bw, (int )mb->uv_mode_);
    }
#line 320
    if (! __cil_tmp4) {
#line 320
      goto while_break;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 325
  return;
}
}
#line 353 "/root/patchweave_new/13/src/enc/tree.c"
uint8_t VP8CoeffsUpdateProba[4][8][3][11]  = { { { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )176,            (uint8_t )246,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )241,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )244,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )246,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )239,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )217,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )225,            (uint8_t )252,            (uint8_t )241,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )250,            (uint8_t )241,            (uint8_t )250, 
                    (uint8_t )253,            (uint8_t )255,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )238,            (uint8_t )253,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )247,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )186,            (uint8_t )251,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )251,            (uint8_t )244,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )251,            (uint8_t )243,            (uint8_t )253, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )236,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )253,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )248,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )254,            (uint8_t )252,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )249,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )246,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )254,            (uint8_t )251,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )245,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )252,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}};
#line 488 "/root/patchweave_new/13/src/enc/tree.c"
void VP8WriteProbas(VP8BitWriter *bw , VP8Proba *probas ) 
{ 
  int t ;
  int b ;
  int c ;
  int p ;
  uint8_t p0 ;
  int update ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 490
  t = 0;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;

#line 490
    if (! (t < 4)) {
#line 490
      goto while_break;
    }
#line 491
    b = 0;
    {
#line 491
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 491
      if (! (b < 8)) {
#line 491
        goto while_break___0;
      }
#line 492
      c = 0;
      {
#line 492
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 492
        if (! (c < 3)) {
#line 492
          goto while_break___1;
        }
#line 493
        p = 0;
        {
#line 493
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 493
          if (! (p < 11)) {
#line 493
            goto while_break___2;
          }
          {
#line 494
          p0 = probas->coeffs_[t][b][c][p];
#line 495
          update = (int )p0 != (int )VP8CoeffsProba0[t][b][c][p];
#line 496
          __cil_tmp9 = VP8PutBit(bw, update, (int )VP8CoeffsUpdateProba[t][b][c][p]);
          }
#line 496
          if (__cil_tmp9) {
            {
#line 497
            VP8PutValue(bw, (int )p0, 8);
            }
          }
#line 493
          p ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 492
        c ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 491
      b ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 490
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 503
  __cil_tmp10 = VP8PutBitUniform(bw, probas->use_skip_proba_);
  }
#line 503
  if (__cil_tmp10) {
    {
#line 504
    VP8PutValue(bw, (int )probas->skip_proba_, 8);
    }
  }
#line 507
  return;
}
}
#line 42 "/root/patchweave_new/13/src/enc/token.c"
void VP8TBufferInit(VP8TBuffer *b ) 
{ 


  {
#line 43
  b->tokens_ = (uint16_t *)((void *)0);
#line 44
  b->pages_ = (VP8Tokens *)((void *)0);
#line 45
  b->last_page_ = & b->pages_;
#line 46
  b->left_ = 0;
#line 47
  b->error_ = 0;
#line 48
  return;
}
}
#line 50 "/root/patchweave_new/13/src/enc/token.c"
void VP8TBufferClear(VP8TBuffer *b ) 
{ 
  VP8Tokens *p ;
  VP8Tokens *next ;

  {
#line 51
  if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 52
    p = b->pages_;
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;

#line 53
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 53
        goto while_break;
      }
      {
#line 54
      next = p->next_;
#line 55
      free((void *)p);
#line 56
      p = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 58
    VP8TBufferInit(b);
    }
  }
#line 61
  return;
}
}
#line 62 "/root/patchweave_new/13/src/enc/token.c"
static int TBufferNewPage(VP8TBuffer *b ) 
{ 
  VP8Tokens *page ;
  void *__cil_tmp3 ;
  VP8Tokens *tmp ;

  {
#line 63
  if (b->error_) {
#line 63
    tmp = (VP8Tokens *)((void *)0);
  } else {
    {
#line 63
    __cil_tmp3 = malloc(sizeof(*page));
#line 63
    tmp = (VP8Tokens *)__cil_tmp3;
    }
  }
#line 63
  page = tmp;
#line 64
  if ((unsigned long )page == (unsigned long )((void *)0)) {
#line 65
    b->error_ = 1;
#line 66
    return (0);
  }
#line 68
  *(b->last_page_) = page;
#line 69
  b->last_page_ = & page->next_;
#line 70
  b->left_ = 8192;
#line 71
  b->tokens_ = page->tokens_;
#line 72
  page->next_ = (VP8Tokens *)((void *)0);
#line 73
  return (1);
}
}
#line 81 "/root/patchweave_new/13/src/enc/token.c"
__inline static int AddToken(VP8TBuffer *b , int bit , uint32_t proba_idx ) 
{ 
  int __cil_tmp6 ;
  int slot ;

  {
  {
#line 85
  __cil_tmp6 = TBufferNewPage(b);
  }
#line 85
  if (b->left_ > 0) {
#line 86
    (b->left_) --;
#line 86
    slot = b->left_;
#line 87
    *(b->tokens_ + slot) = (uint16_t )((unsigned int )(bit << 15) | proba_idx);
  } else
#line 85
  if (__cil_tmp6) {
#line 86
    (b->left_) --;
#line 86
    slot = b->left_;
#line 87
    *(b->tokens_ + slot) = (uint16_t )((unsigned int )(bit << 15) | proba_idx);
  }
#line 89
  return (bit);
}
}
#line 92 "/root/patchweave_new/13/src/enc/token.c"
__inline static void AddConstantToken(VP8TBuffer *b , int bit , int proba ) 
{ 
  int __cil_tmp6 ;
  int slot ;

  {
  {
#line 96
  __cil_tmp6 = TBufferNewPage(b);
  }
#line 96
  if (b->left_ > 0) {
#line 97
    (b->left_) --;
#line 97
    slot = b->left_;
#line 98
    *(b->tokens_ + slot) = (uint16_t )(((unsigned int )(bit << 15) | (1U << 14)) | (unsigned int )proba);
  } else
#line 96
  if (__cil_tmp6) {
#line 97
    (b->left_) --;
#line 97
    slot = b->left_;
#line 98
    *(b->tokens_ + slot) = (uint16_t )(((unsigned int )(bit << 15) | (1U << 14)) | (unsigned int )proba);
  }
#line 100
  return;
}
}
#line 102 "/root/patchweave_new/13/src/enc/token.c"
int VP8RecordCoeffTokens(int ctx , int coeff_type , int first , int last , int16_t *coeffs ,
                         VP8TBuffer *tokens ) 
{ 
  int n ;
  uint32_t base_id ;
  int __cil_tmp9 ;
  int c ;
  int __cil_tmp11 ;
  int sign ;
  int v ;
  int tmp ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int mask ;
  uint8_t *tab ;
  uint8_t *__cil_tmp23 ;
  int __cil_tmp24 ;

  {
  {
#line 105
  n = first;
#line 106
  base_id = (uint32_t )(11 * (ctx + 3 * (n + 8 * coeff_type)));
#line 107
  __cil_tmp9 = AddToken(tokens, last >= 0, base_id);
  }
#line 107
  if (! __cil_tmp9) {
#line 108
    return (0);
  }
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 111
    if (! (n < 16)) {
#line 111
      goto while_break;
    }
#line 112
    __cil_tmp11 = n;
#line 112
    n ++;
#line 112
    c = (int )*(coeffs + __cil_tmp11);
#line 113
    sign = c < 0;
#line 114
    if (sign) {
#line 114
      tmp = - c;
    } else {
#line 114
      tmp = c;
    }
    {
#line 114
    v = tmp;
#line 115
    __cil_tmp15 = AddToken(tokens, v != 0, base_id + 1U);
    }
#line 115
    if (! __cil_tmp15) {
#line 116
      ctx = 0;
#line 117
      base_id = (uint32_t )(11 * (ctx + 3 * ((int )VP8EncBands[n] + 8 * coeff_type)));
#line 118
      goto while_continue;
    }
    {
#line 120
    __cil_tmp16 = AddToken(tokens, v > 1, base_id + 2U);
    }
#line 120
    if (! __cil_tmp16) {
#line 121
      ctx = 1;
    } else {
      {
#line 123
      __cil_tmp17 = AddToken(tokens, v > 4, base_id + 3U);
      }
#line 123
      if (! __cil_tmp17) {
        {
#line 124
        __cil_tmp18 = AddToken(tokens, v != 2, base_id + 4U);
        }
#line 124
        if (__cil_tmp18) {
          {
#line 125
          AddToken(tokens, v == 4, base_id + 5U);
          }
        }
      } else {
        {
#line 126
        __cil_tmp19 = AddToken(tokens, v > 10, base_id + 6U);
        }
#line 126
        if (! __cil_tmp19) {
          {
#line 127
          __cil_tmp20 = AddToken(tokens, v > 6, base_id + 7U);
          }
#line 127
          if (! __cil_tmp20) {
            {
#line 128
            AddConstantToken(tokens, v == 6, 159);
            }
          } else {
            {
#line 130
            AddConstantToken(tokens, v >= 9, 165);
#line 131
            AddConstantToken(tokens, ! (v & 1), 145);
            }
          }
        } else {
#line 136
          if (v < 3 + (8 << 1)) {
            {
#line 137
            AddToken(tokens, 0, base_id + 8U);
#line 138
            AddToken(tokens, 0, base_id + 9U);
#line 139
            v -= 11;
#line 140
            mask = 1 << 2;
#line 141
            tab = VP8Cat3;
            }
          } else
#line 142
          if (v < 3 + (8 << 2)) {
            {
#line 143
            AddToken(tokens, 0, base_id + 8U);
#line 144
            AddToken(tokens, 1, base_id + 9U);
#line 145
            v -= 3 + (8 << 1);
#line 146
            mask = 1 << 3;
#line 147
            tab = VP8Cat4;
            }
          } else
#line 148
          if (v < 3 + (8 << 3)) {
            {
#line 149
            AddToken(tokens, 1, base_id + 8U);
#line 150
            AddToken(tokens, 0, base_id + 10U);
#line 151
            v -= 3 + (8 << 2);
#line 152
            mask = 1 << 4;
#line 153
            tab = VP8Cat5;
            }
          } else {
            {
#line 155
            AddToken(tokens, 1, base_id + 8U);
#line 156
            AddToken(tokens, 1, base_id + 10U);
#line 157
            v -= 3 + (8 << 3);
#line 158
            mask = 1 << 10;
#line 159
            tab = VP8Cat6;
            }
          }
          {
#line 161
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 161
            if (! mask) {
#line 161
              goto while_break___0;
            }
            {
#line 162
            __cil_tmp23 = tab;
#line 162
            tab ++;
#line 162
            AddConstantToken(tokens, ! (! (v & mask)), (int )*__cil_tmp23);
#line 163
            mask >>= 1;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break___0: ;
        }
      }
#line 166
      ctx = 2;
    }
    {
#line 168
    AddConstantToken(tokens, sign, 128);
#line 169
    base_id = (uint32_t )(11 * (ctx + 3 * ((int )VP8EncBands[n] + 8 * coeff_type)));
#line 170
    __cil_tmp24 = AddToken(tokens, n <= last, base_id);
    }
#line 170
    if (n == 16) {
#line 171
      return (1);
    } else
#line 170
    if (! __cil_tmp24) {
#line 171
      return (1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 174
  return (1);
}
}
#line 214 "/root/patchweave_new/13/src/enc/token.c"
int VP8EmitTokens(VP8TBuffer *b , VP8BitWriter *bw , uint8_t *probas , int final_pass ) 
{ 
  VP8Tokens *p ;
  VP8Tokens *next ;
  int N ;
  int tmp ;
  int n ;
  int __cil_tmp10 ;
  uint16_t token ;
  int bit ;

  {
#line 216
  p = b->pages_;
#line 218
  if (b->error_) {
#line 218
    return (0);
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;

#line 219
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 219
      goto while_break;
    }
#line 220
    next = p->next_;
#line 221
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 221
      tmp = b->left_;
    } else {
#line 221
      tmp = 0;
    }
#line 221
    N = tmp;
#line 222
    n = 8192;
    {
#line 223
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 223
      __cil_tmp10 = n;
#line 223
      n --;
#line 223
      if (! (__cil_tmp10 > N)) {
#line 223
        goto while_break___0;
      }
#line 224
      token = p->tokens_[n];
#line 225
      bit = ((int )token >> 15) & 1;
#line 226
      if ((unsigned int )token & (1U << 14)) {
        {
#line 227
        VP8PutBit(bw, bit, (int )((unsigned int )token & 255U));
        }
      } else {
        {
#line 229
        VP8PutBit(bw, bit, (int )*(probas + ((unsigned int )token & 16383U)));
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 232
    if (final_pass) {
      {
#line 232
      free((void *)p);
      }
    }
#line 233
    p = next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 235
  if (final_pass) {
#line 235
    b->pages_ = (VP8Tokens *)((void *)0);
  }
#line 236
  return (1);
}
}
#line 26 "/root/patchweave_new/13/src/enc/syntax.c"
static int IsVP8XNeeded(VP8Encoder *enc ) 
{ 


  {
#line 27
  return (! (! enc->has_alpha_));
}
}
#line 31 "/root/patchweave_new/13/src/enc/syntax.c"
static int PutPaddingByte(WebPPicture *pic ) 
{ 
  uint8_t pad_byte[1] ;
  int __cil_tmp3 ;

  {
  {
#line 32
  pad_byte[0] = (uint8_t )0;
#line 33
  __cil_tmp3 = (*(pic->writer))(pad_byte, (size_t )1, pic);
  }
#line 33
  return (! (! __cil_tmp3));
}
}
#line 39 "/root/patchweave_new/13/src/enc/syntax.c"
static enum WebPEncodingError PutRIFFHeader(VP8Encoder *enc , size_t riff_size ) 
{ 
  WebPPicture *pic ;
  uint8_t riff[12] ;
  int __cil_tmp6 ;

  {
  {
#line 41
  pic = enc->pic_;
#line 42
  riff[0] = (uint8_t )'R';
#line 42
  riff[1] = (uint8_t )'I';
#line 42
  riff[2] = (uint8_t )'F';
#line 42
  riff[3] = (uint8_t )'F';
#line 42
  riff[4] = (uint8_t )0;
#line 42
  riff[5] = (uint8_t )0;
#line 42
  riff[6] = (uint8_t )0;
#line 42
  riff[7] = (uint8_t )0;
#line 42
  riff[8] = (uint8_t )'W';
#line 42
  riff[9] = (uint8_t )'E';
#line 42
  riff[10] = (uint8_t )'B';
#line 42
  riff[11] = (uint8_t )'P';
#line 46
  PutLE32(riff + 4, (uint32_t )riff_size);
#line 47
  __cil_tmp6 = (*(pic->writer))(riff, sizeof(riff), pic);
  }
#line 47
  if (! __cil_tmp6) {
#line 48
    return ((enum WebPEncodingError )8);
  }
#line 50
  return ((enum WebPEncodingError )0);
}
}
#line 53 "/root/patchweave_new/13/src/enc/syntax.c"
static enum WebPEncodingError PutVP8XHeader(VP8Encoder *enc ) 
{ 
  WebPPicture *pic ;
  uint8_t vp8x[18] ;
  unsigned int tmp ;
  uint32_t flags ;
  int __cil_tmp10 ;

  {
#line 54
  pic = enc->pic_;
#line 55
  vp8x[0] = (uint8_t )'V';
#line 55
  vp8x[1] = (uint8_t )'P';
#line 55
  vp8x[2] = (uint8_t )'8';
#line 55
  vp8x[3] = (uint8_t )'X';
#line 55
  tmp = 4U;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;

#line 55
    if (tmp >= 18U) {
#line 55
      goto while_break;
    }
#line 55
    vp8x[tmp] = (uint8_t )0;
#line 55
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 58
  flags = (uint32_t )0;
#line 64
  if (enc->has_alpha_) {
#line 65
    flags |= 16U;
  }
  {
#line 68
  PutLE32(vp8x + 4, (uint32_t )10);
#line 69
  PutLE32(vp8x + 8, flags);
#line 70
  PutLE24((vp8x + 8) + 4, pic->width - 1);
#line 71
  PutLE24((vp8x + 8) + 7, pic->height - 1);
#line 72
  __cil_tmp10 = (*(pic->writer))(vp8x, sizeof(vp8x), pic);
  }
#line 72
  if (! __cil_tmp10) {
#line 73
    return ((enum WebPEncodingError )8);
  }
#line 75
  return ((enum WebPEncodingError )0);
}
}
#line 78 "/root/patchweave_new/13/src/enc/syntax.c"
static enum WebPEncodingError PutAlphaChunk(VP8Encoder *enc ) 
{ 
  WebPPicture *pic ;
  uint8_t alpha_chunk_hdr[8] ;
  unsigned int tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 79
  pic = enc->pic_;
#line 80
  alpha_chunk_hdr[0] = (uint8_t )'A';
#line 80
  alpha_chunk_hdr[1] = (uint8_t )'L';
#line 80
  alpha_chunk_hdr[2] = (uint8_t )'P';
#line 80
  alpha_chunk_hdr[3] = (uint8_t )'H';
#line 80
  tmp = 4U;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;

#line 80
    if (tmp >= 8U) {
#line 80
      goto while_break;
    }
#line 80
    alpha_chunk_hdr[tmp] = (uint8_t )0;
#line 80
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 87
  PutLE32(alpha_chunk_hdr + 4, enc->alpha_data_size_);
#line 88
  __cil_tmp6 = (*(pic->writer))(alpha_chunk_hdr, sizeof(alpha_chunk_hdr), pic);
  }
#line 88
  if (! __cil_tmp6) {
#line 89
    return ((enum WebPEncodingError )8);
  }
  {
#line 93
  __cil_tmp7 = (*(pic->writer))(enc->alpha_data_, (size_t )enc->alpha_data_size_,
                                pic);
  }
#line 93
  if (! __cil_tmp7) {
#line 94
    return ((enum WebPEncodingError )8);
  }
  {
#line 98
  __cil_tmp8 = PutPaddingByte(pic);
  }
#line 98
  if (enc->alpha_data_size_ & 1U) {
#line 98
    if (! __cil_tmp8) {
#line 99
      return ((enum WebPEncodingError )8);
    }
  }
#line 101
  return ((enum WebPEncodingError )0);
}
}
#line 104 "/root/patchweave_new/13/src/enc/syntax.c"
static enum WebPEncodingError PutVP8Header(WebPPicture *pic , size_t vp8_size ) 
{ 
  uint8_t vp8_chunk_hdr[8] ;
  unsigned int tmp ;
  int __cil_tmp6 ;

  {
#line 106
  vp8_chunk_hdr[0] = (uint8_t )'V';
#line 106
  vp8_chunk_hdr[1] = (uint8_t )'P';
#line 106
  vp8_chunk_hdr[2] = (uint8_t )'8';
#line 106
  vp8_chunk_hdr[3] = (uint8_t )' ';
#line 106
  tmp = 4U;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;

#line 106
    if (tmp >= 8U) {
#line 106
      goto while_break;
    }
#line 106
    vp8_chunk_hdr[tmp] = (uint8_t )0;
#line 106
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 110
  PutLE32(vp8_chunk_hdr + 4, (uint32_t )vp8_size);
#line 111
  __cil_tmp6 = (*(pic->writer))(vp8_chunk_hdr, sizeof(vp8_chunk_hdr), pic);
  }
#line 111
  if (! __cil_tmp6) {
#line 112
    return ((enum WebPEncodingError )8);
  }
#line 114
  return ((enum WebPEncodingError )0);
}
}
#line 117 "/root/patchweave_new/13/src/enc/syntax.c"
static enum WebPEncodingError PutVP8FrameHeader(WebPPicture *pic , int profile , size_t size0 ) 
{ 
  uint8_t vp8_frm_hdr[10] ;
  uint32_t bits ;
  int __cil_tmp6 ;

  {
#line 122
  if (size0 >= (unsigned long )(1 << 19)) {
#line 123
    return ((enum WebPEncodingError )6);
  }
  {
#line 127
  bits = (unsigned int )((profile << 1) | (1 << 4)) | ((uint32_t )size0 << 5);
#line 131
  vp8_frm_hdr[0] = (uint8_t )(bits & 255U);
#line 132
  vp8_frm_hdr[1] = (uint8_t )((bits >> 8) & 255U);
#line 133
  vp8_frm_hdr[2] = (uint8_t )((bits >> 16) & 255U);
#line 135
  vp8_frm_hdr[3] = (uint8_t )((10289450 >> 16) & 255);
#line 136
  vp8_frm_hdr[4] = (uint8_t )((10289450 >> 8) & 255);
#line 137
  vp8_frm_hdr[5] = (uint8_t )42;
#line 139
  vp8_frm_hdr[6] = (uint8_t )(pic->width & 255);
#line 140
  vp8_frm_hdr[7] = (uint8_t )(pic->width >> 8);
#line 141
  vp8_frm_hdr[8] = (uint8_t )(pic->height & 255);
#line 142
  vp8_frm_hdr[9] = (uint8_t )(pic->height >> 8);
#line 144
  __cil_tmp6 = (*(pic->writer))(vp8_frm_hdr, sizeof(vp8_frm_hdr), pic);
  }
#line 144
  if (! __cil_tmp6) {
#line 145
    return ((enum WebPEncodingError )8);
  }
#line 147
  return ((enum WebPEncodingError )0);
}
}
#line 151 "/root/patchweave_new/13/src/enc/syntax.c"
static int PutWebPHeaders(VP8Encoder *enc , size_t size0 , size_t vp8_size , size_t riff_size ) 
{ 
  WebPPicture *pic ;
  enum WebPEncodingError err ;
  int __cil_tmp8 ;
  int __cil_tmp13 ;

  {
  {
#line 153
  pic = enc->pic_;
#line 154
  err = (enum WebPEncodingError )0;
#line 157
  err = PutRIFFHeader(enc, riff_size);
  }
#line 158
  if ((unsigned int )err != 0U) {
#line 158
    goto Error;
  }
  {
#line 161
  __cil_tmp8 = IsVP8XNeeded(enc);
  }
#line 161
  if (__cil_tmp8) {
    {
#line 162
    err = PutVP8XHeader(enc);
    }
#line 163
    if ((unsigned int )err != 0U) {
#line 163
      goto Error;
    }
  }
#line 167
  if (enc->has_alpha_) {
    {
#line 168
    err = PutAlphaChunk(enc);
    }
#line 169
    if ((unsigned int )err != 0U) {
#line 169
      goto Error;
    }
  }
  {
#line 173
  err = PutVP8Header(pic, vp8_size);
  }
#line 174
  if ((unsigned int )err != 0U) {
#line 174
    goto Error;
  }
  {
#line 177
  err = PutVP8FrameHeader(pic, enc->profile_, size0);
  }
#line 178
  if ((unsigned int )err != 0U) {
#line 178
    goto Error;
  }
#line 181
  return (1);
  Error: 
  {
#line 185
  __cil_tmp13 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )err);
  }
#line 185
  return (__cil_tmp13);
}
}
#line 189 "/root/patchweave_new/13/src/enc/syntax.c"
static void PutSegmentHeader(VP8BitWriter *bw , VP8Encoder *enc ) 
{ 
  VP8SegmentHeader *hdr ;
  VP8Proba *proba ;
  int __cil_tmp5 ;
  int update_data ;
  int s ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 191
  hdr = & enc->segment_hdr_;
#line 192
  proba = & enc->proba_;
#line 193
  __cil_tmp5 = VP8PutBitUniform(bw, hdr->num_segments_ > 1);
  }
#line 193
  if (__cil_tmp5) {
    {
#line 195
    update_data = 1;
#line 197
    VP8PutBitUniform(bw, hdr->update_map_);
#line 198
    __cil_tmp8 = VP8PutBitUniform(bw, update_data);
    }
#line 198
    if (__cil_tmp8) {
      {
#line 200
      VP8PutBitUniform(bw, 1);
#line 201
      s = 0;
      }
      {
#line 201
      while (1) {
        while_continue: /* CIL Label */ ;

#line 201
        if (! (s < 4)) {
#line 201
          goto while_break;
        }
        {
#line 202
        VP8PutSignedValue(bw, enc->dqm_[s].quant_, 7);
#line 201
        s ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: 
#line 204
      s = 0;
      {
#line 204
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 204
        if (! (s < 4)) {
#line 204
          goto while_break___0;
        }
        {
#line 205
        VP8PutSignedValue(bw, enc->dqm_[s].fstrength_, 6);
#line 204
        s ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 208
    if (hdr->update_map_) {
#line 209
      s = 0;
      {
#line 209
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 209
        if (! (s < 3)) {
#line 209
          goto while_break___1;
        }
        {
#line 210
        __cil_tmp9 = VP8PutBitUniform(bw, (unsigned int )proba->segments_[s] != 255U);
        }
#line 210
        if (__cil_tmp9) {
          {
#line 211
          VP8PutValue(bw, (int )proba->segments_[s], 8);
          }
        }
#line 209
        s ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
  }
#line 215
  return;
}
}
#line 219 "/root/patchweave_new/13/src/enc/syntax.c"
static void PutFilterHeader(VP8BitWriter *bw , VP8FilterHeader *hdr ) 
{ 
  int use_lf_delta ;
  int __cil_tmp4 ;
  int need_update ;
  int __cil_tmp6 ;

  {
  {
#line 221
  use_lf_delta = hdr->i4x4_lf_delta_ != 0;
#line 222
  VP8PutBitUniform(bw, hdr->simple_);
#line 223
  VP8PutValue(bw, hdr->level_, 6);
#line 224
  VP8PutValue(bw, hdr->sharpness_, 3);
#line 225
  __cil_tmp4 = VP8PutBitUniform(bw, use_lf_delta);
  }
#line 225
  if (__cil_tmp4) {
    {
#line 227
    need_update = hdr->i4x4_lf_delta_ != 0;
#line 228
    __cil_tmp6 = VP8PutBitUniform(bw, need_update);
    }
#line 228
    if (__cil_tmp6) {
      {
#line 230
      VP8PutValue(bw, 0, 4);
#line 232
      VP8PutSignedValue(bw, hdr->i4x4_lf_delta_, 6);
#line 233
      VP8PutValue(bw, 0, 3);
      }
    }
  }
#line 237
  return;
}
}
#line 239 "/root/patchweave_new/13/src/enc/syntax.c"
static void PutQuant(VP8BitWriter *bw , VP8Encoder *enc ) 
{ 


  {
  {
#line 241
  VP8PutValue(bw, enc->base_quant_, 7);
#line 242
  VP8PutSignedValue(bw, enc->dq_y1_dc_, 4);
#line 243
  VP8PutSignedValue(bw, enc->dq_y2_dc_, 4);
#line 244
  VP8PutSignedValue(bw, enc->dq_y2_ac_, 4);
#line 245
  VP8PutSignedValue(bw, enc->dq_uv_dc_, 4);
#line 246
  VP8PutSignedValue(bw, enc->dq_uv_ac_, 4);
  }
#line 248
  return;
}
}
#line 250 "/root/patchweave_new/13/src/enc/syntax.c"
static int EmitPartitionsSize(VP8Encoder *enc , WebPPicture *pic ) 
{ 
  uint8_t buf[21] ;
  int p ;
  size_t part_size ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;

  {
#line 254
  p = 0;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;

#line 254
    if (! (p < enc->num_parts_ - 1)) {
#line 254
      goto while_break;
    }
    {
#line 255
    __cil_tmp6 = VP8BitWriterSize(enc->parts_ + p);
#line 255
    part_size = __cil_tmp6;
    }
#line 256
    if (part_size >= (unsigned long )(1 << 24)) {
      {
#line 257
      __cil_tmp7 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )((enum WebPEncodingError )7));
      }
#line 257
      return (__cil_tmp7);
    }
#line 259
    buf[3 * p] = (uint8_t )(part_size & 255UL);
#line 260
    buf[3 * p + 1] = (uint8_t )((part_size >> 8) & 255UL);
#line 261
    buf[3 * p + 2] = (uint8_t )((part_size >> 16) & 255UL);
#line 254
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 263
  if (p) {
    {
#line 263
    __cil_tmp8 = (*(pic->writer))(buf, (size_t )(3 * p), pic);
#line 263
    tmp = __cil_tmp8;
    }
  } else {
#line 263
    tmp = 1;
  }
#line 263
  return (tmp);
}
}
#line 300 "/root/patchweave_new/13/src/enc/syntax.c"
static size_t GeneratePartition0(VP8Encoder *enc ) 
{ 
  VP8BitWriter *bw ;
  int mb_size ;
  uint64_t pos1 ;
  uint64_t pos2 ;
  uint64_t pos3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 301
  bw = & enc->bw_;
#line 302
  mb_size = enc->mb_w_ * enc->mb_h_;
#line 308
  pos1 = VP8BitWriterPos(bw);
#line 309
  VP8BitWriterInit(bw, (size_t )((mb_size * 7) / 8));
#line 313
  VP8PutBitUniform(bw, 0);
#line 315
  VP8PutBitUniform(bw, 0);
#line 317
  PutSegmentHeader(bw, enc);
#line 318
  PutFilterHeader(bw, & enc->filter_hdr_);
  }
#line 319
  if (enc->num_parts_ == 8) {
#line 319
    tmp___1 = 3;
  } else {
#line 319
    if (enc->num_parts_ == 4) {
#line 319
      tmp___0 = 2;
    } else {
#line 319
      if (enc->num_parts_ == 2) {
#line 319
        tmp = 1;
      } else {
#line 319
        tmp = 0;
      }
#line 319
      tmp___0 = tmp;
    }
#line 319
    tmp___1 = tmp___0;
  }
  {
#line 319
  VP8PutValue(bw, tmp___1, 2);
#line 322
  PutQuant(bw, enc);
#line 323
  VP8PutBitUniform(bw, 0);
#line 324
  VP8WriteProbas(bw, & enc->proba_);
#line 325
  pos2 = VP8BitWriterPos(bw);
#line 326
  VP8CodeIntraModes(enc);
#line 327
  VP8BitWriterFinish(bw);
#line 335
  pos3 = VP8BitWriterPos(bw);
  }
#line 337
  if ((enc->pic_)->stats) {
#line 338
    ((enc->pic_)->stats)->header_bytes[0] = (int )(((pos2 - pos1) + 7UL) >> 3);
#line 339
    ((enc->pic_)->stats)->header_bytes[1] = (int )(((pos3 - pos2) + 7UL) >> 3);
#line 340
    ((enc->pic_)->stats)->alpha_data_size = (int )enc->alpha_data_size_;
#line 341
    ((enc->pic_)->stats)->layer_data_size = (int )enc->layer_data_size_;
  }
#line 343
  return ((size_t )(! bw->error_));
}
}
#line 346 "/root/patchweave_new/13/src/enc/syntax.c"
void VP8EncFreeBitWriters(VP8Encoder *enc ) 
{ 
  int p ;

  {
  {
#line 348
  VP8BitWriterWipeOut(& enc->bw_);
#line 349
  p = 0;
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;

#line 349
    if (! (p < enc->num_parts_)) {
#line 349
      goto while_break;
    }
    {
#line 350
    VP8BitWriterWipeOut(enc->parts_ + p);
#line 349
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 353
  return;
}
}
#line 354 "/root/patchweave_new/13/src/enc/syntax.c"
int VP8EncWrite(VP8Encoder *enc ) 
{ 
  WebPPicture *pic ;
  VP8BitWriter *bw ;
  int task_percent ;
  int percent_per_part ;
  int final_percent ;
  int ok ;
  size_t vp8_size ;
  size_t pad ;
  size_t riff_size ;
  int p ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  int __cil_tmp15 ;
  uint32_t padded_alpha_size ;
  int __cil_tmp17 ;
  uint8_t *part0 ;
  uint8_t *__cil_tmp19 ;
  size_t size0 ;
  size_t __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  uint8_t *buf ;
  uint8_t *__cil_tmp26 ;
  size_t size ;
  size_t __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp32 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 355
  pic = enc->pic_;
#line 356
  bw = & enc->bw_;
#line 357
  task_percent = 19;
#line 358
  percent_per_part = task_percent / enc->num_parts_;
#line 359
  final_percent = enc->percent_ + task_percent;
#line 360
  ok = 0;
#line 365
  __cil_tmp12 = GeneratePartition0(enc);
#line 365
  ok = ! (! __cil_tmp12);
#line 368
  __cil_tmp13 = VP8BitWriterSize(bw);
#line 368
  vp8_size = (10UL + __cil_tmp13) + (unsigned long )(3 * (enc->num_parts_ - 1));
#line 371
  p = 0;
  }
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;

#line 371
    if (! (p < enc->num_parts_)) {
#line 371
      goto while_break;
    }
    {
#line 372
    __cil_tmp14 = VP8BitWriterSize(enc->parts_ + p);
#line 372
    vp8_size += __cil_tmp14;
#line 371
    p ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 374
  pad = vp8_size & 1UL;
#line 375
  vp8_size += pad;
#line 379
  riff_size = 12UL + vp8_size;
#line 380
  __cil_tmp15 = IsVP8XNeeded(enc);
  }
#line 380
  if (__cil_tmp15) {
#line 381
    riff_size += 18UL;
  }
#line 383
  if (enc->has_alpha_) {
#line 384
    padded_alpha_size = enc->alpha_data_size_ + (enc->alpha_data_size_ & 1U);
#line 386
    riff_size += (unsigned long )(8U + padded_alpha_size);
  }
#line 389
  if (riff_size > 4294967294UL) {
    {
#line 390
    __cil_tmp17 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )((enum WebPEncodingError )9));
    }
#line 390
    return (__cil_tmp17);
  }
  {
#line 395
  __cil_tmp19 = VP8BitWriterBuf(bw);
#line 395
  part0 = __cil_tmp19;
#line 396
  __cil_tmp21 = VP8BitWriterSize(bw);
#line 396
  size0 = __cil_tmp21;
#line 397
  __cil_tmp24 = EmitPartitionsSize(enc, pic);
#line 397
  __cil_tmp23 = (*(pic->writer))(part0, size0, pic);
#line 397
  __cil_tmp22 = PutWebPHeaders(enc, size0, vp8_size, riff_size);
  }
#line 397
  if (ok) {
#line 397
    if (__cil_tmp22) {
#line 397
      if (__cil_tmp23) {
#line 397
        if (__cil_tmp24) {
#line 397
          tmp = 1;
        } else {
#line 397
          tmp = 0;
        }
      } else {
#line 397
        tmp = 0;
      }
    } else {
#line 397
      tmp = 0;
    }
  } else {
#line 397
    tmp = 0;
  }
  {
#line 397
  ok = tmp;
#line 400
  VP8BitWriterWipeOut(bw);
#line 404
  p = 0;
  }
  {
#line 404
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 404
    if (! (p < enc->num_parts_)) {
#line 404
      goto while_break___0;
    }
    {
#line 405
    __cil_tmp26 = VP8BitWriterBuf(enc->parts_ + p);
#line 405
    buf = __cil_tmp26;
#line 406
    __cil_tmp28 = VP8BitWriterSize(enc->parts_ + p);
#line 406
    size = __cil_tmp28;
    }
#line 407
    if (size) {
      {
#line 408
      __cil_tmp29 = (*(pic->writer))(buf, size, pic);
      }
#line 408
      if (ok) {
#line 408
        if (__cil_tmp29) {
#line 408
          tmp___0 = 1;
        } else {
#line 408
          tmp___0 = 0;
        }
      } else {
#line 408
        tmp___0 = 0;
      }
#line 408
      ok = tmp___0;
    }
    {
#line 409
    VP8BitWriterWipeOut(enc->parts_ + p);
#line 410
    __cil_tmp30 = WebPReportProgress(pic, enc->percent_ + percent_per_part, & enc->percent_);
    }
#line 410
    if (ok) {
#line 410
      if (__cil_tmp30) {
#line 410
        tmp___1 = 1;
      } else {
#line 410
        tmp___1 = 0;
      }
    } else {
#line 410
      tmp___1 = 0;
    }
#line 410
    ok = tmp___1;
#line 404
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 415
  if (ok) {
#line 415
    if (pad) {
      {
#line 416
      ok = PutPaddingByte(pic);
      }
    }
  }
  {
#line 419
  enc->coded_size_ = (int )(8UL + riff_size);
#line 420
  __cil_tmp32 = WebPReportProgress(pic, final_percent, & enc->percent_);
  }
#line 420
  if (ok) {
#line 420
    if (__cil_tmp32) {
#line 420
      tmp___2 = 1;
    } else {
#line 420
      tmp___2 = 0;
    }
  } else {
#line 420
    tmp___2 = 0;
  }
#line 420
  ok = tmp___2;
#line 421
  return (ok);
}
}
#line 22 "/root/patchweave_new/13/src/enc/./cost.h"
uint16_t VP8LevelFixedCosts[2048] ;
#line 23
uint16_t VP8EntropyCost[256] ;
#line 26 "/root/patchweave_new/13/src/enc/./cost.h"
__inline static int VP8BitCost(int bit , uint8_t proba ) 
{ 
  int tmp ;

  {
#line 27
  if (! bit) {
#line 27
    tmp = (int )VP8EntropyCost[proba];
  } else {
#line 27
    tmp = (int )VP8EntropyCost[255 - (int )proba];
  }
#line 27
  return (tmp);
}
}
#line 31
uint16_t VP8LevelCodes[67][2] ;
#line 32
void VP8CalculateLevelCosts(VP8Proba *proba ) ;
#line 33 "/root/patchweave_new/13/src/enc/./cost.h"
__inline static int VP8LevelCost(uint16_t *table , int level ) 
{ 
  int tmp ;

  {
#line 34
  if (level > 67) {
#line 34
    tmp = 67;
  } else {
#line 34
    tmp = level;
  }
#line 34
  return ((int )VP8LevelFixedCosts[level] + (int )*(table + tmp));
}
}
#line 39
uint16_t VP8FixedCostsUV[4] ;
#line 40
uint16_t VP8FixedCostsI16[4] ;
#line 41
uint16_t VP8FixedCostsI4[10][10][10] ;
#line 40 "/root/patchweave_new/13/src/enc/quant.c"
__inline static int clip(int v , int m , int M ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 41
  if (v < m) {
#line 41
    tmp___0 = m;
  } else {
#line 41
    if (v > M) {
#line 41
      tmp = M;
    } else {
#line 41
      tmp = v;
    }
#line 41
    tmp___0 = tmp;
  }
#line 41
  return (tmp___0);
}
}
#line 44 "/root/patchweave_new/13/src/enc/quant.c"
static uint8_t kZigzag[16]  = 
#line 44
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )4,      (uint8_t )8, 
        (uint8_t )5,      (uint8_t )2,      (uint8_t )3,      (uint8_t )6, 
        (uint8_t )9,      (uint8_t )12,      (uint8_t )13,      (uint8_t )10, 
        (uint8_t )7,      (uint8_t )11,      (uint8_t )14,      (uint8_t )15};
#line 48 "/root/patchweave_new/13/src/enc/quant.c"
static uint8_t kDcTable[128]  = 
#line 48
  {      (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )17, 
        (uint8_t )18,      (uint8_t )19,      (uint8_t )20,      (uint8_t )20, 
        (uint8_t )21,      (uint8_t )21,      (uint8_t )22,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )23,      (uint8_t )24,      (uint8_t )25, 
        (uint8_t )25,      (uint8_t )26,      (uint8_t )27,      (uint8_t )28, 
        (uint8_t )29,      (uint8_t )30,      (uint8_t )31,      (uint8_t )32, 
        (uint8_t )33,      (uint8_t )34,      (uint8_t )35,      (uint8_t )36, 
        (uint8_t )37,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )46, 
        (uint8_t )47,      (uint8_t )48,      (uint8_t )49,      (uint8_t )50, 
        (uint8_t )51,      (uint8_t )52,      (uint8_t )53,      (uint8_t )54, 
        (uint8_t )55,      (uint8_t )56,      (uint8_t )57,      (uint8_t )58, 
        (uint8_t )59,      (uint8_t )60,      (uint8_t )61,      (uint8_t )62, 
        (uint8_t )63,      (uint8_t )64,      (uint8_t )65,      (uint8_t )66, 
        (uint8_t )67,      (uint8_t )68,      (uint8_t )69,      (uint8_t )70, 
        (uint8_t )71,      (uint8_t )72,      (uint8_t )73,      (uint8_t )74, 
        (uint8_t )75,      (uint8_t )76,      (uint8_t )76,      (uint8_t )77, 
        (uint8_t )78,      (uint8_t )79,      (uint8_t )80,      (uint8_t )81, 
        (uint8_t )82,      (uint8_t )83,      (uint8_t )84,      (uint8_t )85, 
        (uint8_t )86,      (uint8_t )87,      (uint8_t )88,      (uint8_t )89, 
        (uint8_t )91,      (uint8_t )93,      (uint8_t )95,      (uint8_t )96, 
        (uint8_t )98,      (uint8_t )100,      (uint8_t )101,      (uint8_t )102, 
        (uint8_t )104,      (uint8_t )106,      (uint8_t )108,      (uint8_t )110, 
        (uint8_t )112,      (uint8_t )114,      (uint8_t )116,      (uint8_t )118, 
        (uint8_t )122,      (uint8_t )124,      (uint8_t )126,      (uint8_t )128, 
        (uint8_t )130,      (uint8_t )132,      (uint8_t )134,      (uint8_t )136, 
        (uint8_t )138,      (uint8_t )140,      (uint8_t )143,      (uint8_t )145, 
        (uint8_t )148,      (uint8_t )151,      (uint8_t )154,      (uint8_t )157};
#line 113 "/root/patchweave_new/13/src/enc/quant.c"
static uint8_t kBiasMatrices[3][16]  = { {        (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96}, 
   {        (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96}, 
   {        (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96}};
#line 130 "/root/patchweave_new/13/src/enc/quant.c"
static uint8_t kFreqSharpening[16]  = 
#line 130
  {      (uint8_t )0,      (uint8_t )30,      (uint8_t )60,      (uint8_t )90, 
        (uint8_t )30,      (uint8_t )60,      (uint8_t )90,      (uint8_t )90, 
        (uint8_t )60,      (uint8_t )90,      (uint8_t )90,      (uint8_t )90, 
        (uint8_t )90,      (uint8_t )90,      (uint8_t )90,      (uint8_t )90};
#line 141 "/root/patchweave_new/13/src/enc/quant.c"
static int ExpandMatrix(VP8Matrix *m , int type ) 
{ 
  int i ;
  int sum ;
  int j ;
  int bias ;

  {
#line 143
  sum = 0;
#line 144
  i = 2;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;

#line 144
    if (! (i < 16)) {
#line 144
      goto while_break;
    }
#line 145
    m->q_[i] = m->q_[1];
#line 144
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 147
  i = 0;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 147
    if (! (i < 16)) {
#line 147
      goto while_break___0;
    }
#line 148
    j = (int )kZigzag[i];
#line 149
    bias = (int )kBiasMatrices[type][j];
#line 150
    m->iq_[j] = (uint16_t )((1 << 17) / (int )m->q_[j]);
#line 151
    m->bias_[j] = (uint16_t )(bias << 9);
#line 153
    m->zthresh_[j] = (uint16_t )(((256 - bias) * (int )m->q_[j] + 127) >> 8);
#line 154
    m->sharpen_[j] = (uint16_t )((int )kFreqSharpening[j] * (int )m->q_[j] >> 11);
#line 155
    sum += (int )m->q_[j];
#line 147
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 157
  return ((sum + 8) >> 4);
}
}
#line 160 "/root/patchweave_new/13/src/enc/quant.c"
static void SetupMatrices(VP8Encoder *enc ) 
{ 
  int i ;
  int tlambda_scale ;
  int tmp ;
  int num_segments ;
  VP8SegmentInfo *m ;
  int q ;
  int q4 ;
  int q16 ;
  int quv ;
  int __cil_tmp11 ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 162
  if (enc->method_ >= 4) {
#line 162
    tmp = (enc->config_)->sns_strength;
  } else {
#line 162
    tmp = 0;
  }
#line 162
  tlambda_scale = tmp;
#line 165
  num_segments = enc->segment_hdr_.num_segments_;
#line 166
  i = 0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;

#line 166
    if (! (i < num_segments)) {
#line 166
      goto while_break;
    }
    {
#line 167
    m = & enc->dqm_[i];
#line 168
    q = m->quant_;
#line 170
    __cil_tmp11 = clip(q + enc->dq_y1_dc_, 0, 127);
#line 170
    m->y1_.q_[0] = (uint16_t )kDcTable[__cil_tmp11];
#line 171
    tmp___0 = clip(q, 0, 127);
#line 171
    m->y1_.q_[1] = (uint16_t )tmp___0;
#line 173
    __cil_tmp13 = clip(q + enc->dq_y2_dc_, 0, 127);
#line 173
    m->y2_.q_[0] = (uint16_t )((int )kDcTable[__cil_tmp13] * 2);
#line 174
    tmp___1 = clip(q + enc->dq_y2_ac_, 0, 127);
#line 174
    m->y2_.q_[1] = (uint16_t )tmp___1;
#line 176
    __cil_tmp15 = clip(q + enc->dq_uv_dc_, 0, 117);
#line 176
    m->uv_.q_[0] = (uint16_t )kDcTable[__cil_tmp15];
#line 177
    tmp___2 = clip(q + enc->dq_uv_ac_, 0, 127);
#line 177
    m->uv_.q_[1] = (uint16_t )tmp___2;
#line 179
    q4 = ExpandMatrix(& m->y1_, 0);
#line 180
    q16 = ExpandMatrix(& m->y2_, 1);
#line 181
    quv = ExpandMatrix(& m->uv_, 2);
#line 185
    m->lambda_i4_ = (3 * q4) * q4 >> 7;
#line 186
    m->lambda_i16_ = (3 * q16) * q16;
#line 187
    m->lambda_uv_ = (3 * quv) * quv >> 6;
#line 188
    m->lambda_mode_ = q4 * q4 >> 7;
#line 189
    m->lambda_trellis_i4_ = (7 * q4) * q4 >> 3;
#line 190
    m->lambda_trellis_i16_ = q16 * q16 >> 2;
#line 191
    m->lambda_trellis_uv_ = quv * quv << 1;
#line 192
    m->tlambda_ = tlambda_scale * q4 >> 5;
#line 166
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 170
  return;
}
}
#line 204 "/root/patchweave_new/13/src/enc/quant.c"
static void SetupFilterStrength(VP8Encoder *enc ) 
{ 
  int i ;
  int level0 ;
  int level ;
  int f ;
  int tmp ;
  int tmp___0 ;

  {
#line 206
  level0 = (enc->config_)->filter_strength;
#line 207
  i = 0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;

#line 207
    if (! (i < 4)) {
#line 207
      goto while_break;
    }
#line 209
    level = ((level0 * 256) * enc->dqm_[i].quant_) / 128;
#line 210
    f = level / (256 + enc->dqm_[i].beta_);
#line 211
    if (f < 3) {
#line 211
      tmp___0 = 0;
    } else {
#line 211
      if (f > 63) {
#line 211
        tmp = 63;
      } else {
#line 211
        tmp = f;
      }
#line 211
      tmp___0 = tmp;
    }
#line 211
    enc->dqm_[i].fstrength_ = tmp___0;
#line 207
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 214
  enc->filter_hdr_.level_ = enc->dqm_[0].fstrength_;
#line 215
  enc->filter_hdr_.simple_ = (enc->config_)->filter_type == 0;
#line 216
  enc->filter_hdr_.sharpness_ = (enc->config_)->filter_sharpness;
#line 217
  return;
}
}
#line 229 "/root/patchweave_new/13/src/enc/quant.c"
static double QualityToCompression(double c ) 
{ 
  double linear_c ;
  double tmp ;
  double v ;
  double __cil_tmp5 ;

  {
#line 230
  if (c < 0.75) {
#line 230
    tmp = c * (2. / 3.);
  } else {
#line 230
    tmp = 2. * c - 1.;
  }
  {
#line 230
  linear_c = tmp;
#line 237
  __cil_tmp5 = pow(linear_c, (double )1 / 3.);
#line 237
  v = __cil_tmp5;
  }
#line 238
  return (v);
}
}
#line 241 "/root/patchweave_new/13/src/enc/quant.c"
static double QualityToJPEGCompression(double c , double alpha ) 
{ 
  double amin ;
  double amax ;
  double exp_min ;
  double exp_max ;
  double slope ;
  double expn ;
  double tmp ;
  double tmp___0 ;
  double v ;
  double __cil_tmp12 ;

  {
#line 246
  amin = 0.3;
#line 247
  amax = 0.85;
#line 248
  exp_min = 0.400000000001;
#line 249
  exp_max = 0.900000000001;
#line 250
  slope = (exp_min - exp_max) / (amax - amin);
#line 253
  if (alpha > amax) {
#line 253
    tmp___0 = exp_min;
  } else {
#line 253
    if (alpha < amin) {
#line 253
      tmp = exp_max;
    } else {
#line 253
      tmp = exp_max + slope * (alpha - amin);
    }
#line 253
    tmp___0 = tmp;
  }
  {
#line 253
  expn = tmp___0;
#line 256
  __cil_tmp12 = pow(c, expn);
#line 256
  v = __cil_tmp12;
  }
#line 257
  return (v);
}
}
#line 260 "/root/patchweave_new/13/src/enc/quant.c"
static int SegmentsAreEquivalent(VP8SegmentInfo *S1 , VP8SegmentInfo *S2 ) 
{ 
  int tmp ;

  {
#line 262
  if (S1->quant_ == S2->quant_) {
#line 262
    if (S1->fstrength_ == S2->fstrength_) {
#line 262
      tmp = 1;
    } else {
#line 262
      tmp = 0;
    }
  } else {
#line 262
    tmp = 0;
  }
#line 262
  return (tmp);
}
}
#line 265 "/root/patchweave_new/13/src/enc/quant.c"
static void SimplifySegments(VP8Encoder *enc ) 
{ 
  int map[4] ;
  int num_segments ;
  int num_final_segments ;
  int s1 ;
  int s2 ;
  VP8SegmentInfo *S1 ;
  int found ;
  VP8SegmentInfo *S2 ;
  int __cil_tmp10 ;
  int i ;
  int __cil_tmp12 ;

  {
#line 266
  map[0] = 0;
#line 266
  map[1] = 1;
#line 266
  map[2] = 2;
#line 266
  map[3] = 3;
#line 267
  num_segments = enc->segment_hdr_.num_segments_;
#line 268
  num_final_segments = 1;
#line 270
  s1 = 1;
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;

#line 270
    if (! (s1 < num_segments)) {
#line 270
      goto while_break;
    }
#line 271
    S1 = & enc->dqm_[s1];
#line 272
    found = 0;
#line 274
    s2 = 0;
    {
#line 274
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 274
      if (! (s2 < num_final_segments)) {
#line 274
        goto while_break___0;
      }
      {
#line 275
      S2 = & enc->dqm_[s2];
#line 276
      __cil_tmp10 = SegmentsAreEquivalent(S1, S2);
      }
#line 276
      if (__cil_tmp10) {
#line 277
        found = 1;
#line 278
        goto while_break___0;
      }
#line 274
      s2 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 281
    map[s1] = s2;
#line 282
    if (! found) {
#line 283
      if (num_final_segments != s1) {
#line 284
        enc->dqm_[num_final_segments] = enc->dqm_[s1];
      }
#line 286
      num_final_segments ++;
    }
#line 270
    s1 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 289
  if (num_final_segments < num_segments) {
#line 290
    i = enc->mb_w_ * enc->mb_h_;
    {
#line 291
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 291
      __cil_tmp12 = i;
#line 291
      i --;
#line 291
      if (! (__cil_tmp12 > 0)) {
#line 291
        goto while_break___1;
      }
#line 291
      (enc->mb_info_ + i)->segment_ = (unsigned int )map[(enc->mb_info_ + i)->segment_];
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 292
    enc->segment_hdr_.num_segments_ = num_final_segments;
#line 294
    i = num_final_segments;
    {
#line 294
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 294
      if (! (i < num_segments)) {
#line 294
        goto while_break___2;
      }
#line 295
      enc->dqm_[i] = enc->dqm_[num_final_segments - 1];
#line 294
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 299
  return;
}
}
#line 300 "/root/patchweave_new/13/src/enc/quant.c"
void VP8SetSegmentParams(VP8Encoder *enc , float quality ) 
{ 
  int i ;
  int dq_uv_ac ;
  int dq_uv_dc ;
  int num_segments ;
  double amp ;
  double Q ;
  double c_base ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;
  double tmp ;
  double expn ;
  double c ;
  double __cil_tmp15 ;
  int q ;

  {
#line 303
  num_segments = enc->segment_hdr_.num_segments_;
#line 304
  amp = ((0.900000000001 * (double )(enc->config_)->sns_strength) / 100.) / 128.;
#line 305
  Q = (double )quality / 100.;
#line 306
  if ((enc->config_)->emulate_jpeg_size) {
    {
#line 306
    __cil_tmp10 = QualityToJPEGCompression(Q, (double )enc->alpha_ / 255.);
#line 306
    tmp = __cil_tmp10;
    }
  } else {
    {
#line 306
    __cil_tmp11 = QualityToCompression(Q);
#line 306
    tmp = __cil_tmp11;
    }
  }
#line 306
  c_base = tmp;
#line 309
  i = 0;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;

#line 309
    if (! (i < num_segments)) {
#line 309
      goto while_break;
    }
    {
#line 312
    expn = 1. - amp * (double )enc->dqm_[i].alpha_;
#line 313
    __cil_tmp15 = pow(c_base, expn);
#line 313
    c = __cil_tmp15;
#line 314
    q = (int )(127. * (1. - c));
#line 316
    enc->dqm_[i].quant_ = clip(q, 0, 127);
#line 309
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 320
  enc->base_quant_ = enc->dqm_[0].quant_;
#line 323
  i = num_segments;
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 323
    if (! (i < 4)) {
#line 323
      goto while_break___0;
    }
#line 324
    enc->dqm_[i].quant_ = enc->base_quant_;
#line 323
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 330
  dq_uv_ac = ((enc->uv_alpha_ - 64) * 10) / 70;
#line 333
  dq_uv_ac = (dq_uv_ac * (enc->config_)->sns_strength) / 100;
#line 335
  dq_uv_ac = clip(dq_uv_ac, -4, 6);
#line 339
  dq_uv_dc = (-4 * (enc->config_)->sns_strength) / 100;
#line 340
  dq_uv_dc = clip(dq_uv_dc, -15, 15);
#line 342
  enc->dq_y1_dc_ = 0;
#line 343
  enc->dq_y2_dc_ = 0;
#line 344
  enc->dq_y2_ac_ = 0;
#line 345
  enc->dq_uv_dc_ = dq_uv_dc;
#line 346
  enc->dq_uv_ac_ = dq_uv_ac;
#line 348
  SetupFilterStrength(enc);
  }
#line 350
  if (num_segments > 1) {
    {
#line 350
    SimplifySegments(enc);
    }
  }
  {
#line 352
  SetupMatrices(enc);
  }
#line 354
  return;
}
}
#line 359 "/root/patchweave_new/13/src/enc/quant.c"
int const   VP8I16ModeOffsets[4]  = {      (int const   )0,      (int const   )256,      (int const   )512,      (int const   )768};
#line 360 "/root/patchweave_new/13/src/enc/quant.c"
int const   VP8UVModeOffsets[4]  = {      (int const   )1024,      (int const   )1152,      (int const   )1280,      (int const   )1408};
#line 363 "/root/patchweave_new/13/src/enc/quant.c"
int const   VP8I4ModeOffsets[10]  = 
#line 363
  {      (int const   )1536,      (int const   )1540,      (int const   )1544,      (int const   )1548, 
        (int const   )1600,      (int const   )1604,      (int const   )1608,      (int const   )1612, 
        (int const   )1664,      (int const   )1668};
#line 367 "/root/patchweave_new/13/src/enc/quant.c"
void VP8MakeLuma16Preds(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  uint8_t *left ;
  uint8_t *tmp ;
  uint8_t *top ;
  uint8_t *tmp___0 ;

  {
#line 368
  enc = it->enc_;
#line 369
  if (it->x_) {
#line 369
    tmp = enc->y_left_;
  } else {
#line 369
    tmp = (uint8_t *)((void *)0);
  }
#line 369
  left = tmp;
#line 370
  if (it->y_) {
#line 370
    tmp___0 = enc->y_top_ + it->x_ * 16;
  } else {
#line 370
    tmp___0 = (uint8_t *)((void *)0);
  }
  {
#line 370
  top = tmp___0;
#line 371
  (*VP8EncPredLuma16)(it->yuv_p_, left, top);
  }
#line 373
  return;
}
}
#line 374 "/root/patchweave_new/13/src/enc/quant.c"
void VP8MakeChroma8Preds(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  uint8_t *left ;
  uint8_t *tmp ;
  uint8_t *top ;
  uint8_t *tmp___0 ;

  {
#line 375
  enc = it->enc_;
#line 376
  if (it->x_) {
#line 376
    tmp = enc->u_left_;
  } else {
#line 376
    tmp = (uint8_t *)((void *)0);
  }
#line 376
  left = tmp;
#line 377
  if (it->y_) {
#line 377
    tmp___0 = enc->uv_top_ + it->x_ * 16;
  } else {
#line 377
    tmp___0 = (uint8_t *)((void *)0);
  }
  {
#line 377
  top = tmp___0;
#line 378
  (*VP8EncPredChroma8)(it->yuv_p_, left, top);
  }
#line 380
  return;
}
}
#line 381 "/root/patchweave_new/13/src/enc/quant.c"
void VP8MakeIntra4Preds(VP8EncIterator *it ) 
{ 


  {
  {
#line 382
  (*VP8EncPredLuma4)(it->yuv_p_, it->i4_top_);
  }
#line 384
  return;
}
}
#line 399 "/root/patchweave_new/13/src/enc/quant.c"
int const   VP8Scan[24]  = 
#line 399
  {      (int const   )0,      (int const   )4,      (int const   )8,      (int const   )12, 
        (int const   )64,      (int const   )68,      (int const   )72,      (int const   )76, 
        (int const   )128,      (int const   )132,      (int const   )136,      (int const   )140, 
        (int const   )192,      (int const   )196,      (int const   )200,      (int const   )204, 
        (int const   )0,      (int const   )4,      (int const   )64,      (int const   )68, 
        (int const   )8,      (int const   )12,      (int const   )72,      (int const   )76};
#line 413 "/root/patchweave_new/13/src/enc/quant.c"
static uint16_t kWeightY[16]  = 
#line 413
  {      (uint16_t )38,      (uint16_t )32,      (uint16_t )20,      (uint16_t )9, 
        (uint16_t )32,      (uint16_t )28,      (uint16_t )17,      (uint16_t )7, 
        (uint16_t )20,      (uint16_t )17,      (uint16_t )10,      (uint16_t )4, 
        (uint16_t )9,      (uint16_t )7,      (uint16_t )4,      (uint16_t )2};
#line 417 "/root/patchweave_new/13/src/enc/quant.c"
static uint16_t kWeightTrellis[16]  = 
#line 417
  {      (uint16_t )30,      (uint16_t )27,      (uint16_t )19,      (uint16_t )11, 
        (uint16_t )27,      (uint16_t )24,      (uint16_t )17,      (uint16_t )10, 
        (uint16_t )19,      (uint16_t )17,      (uint16_t )12,      (uint16_t )8, 
        (uint16_t )11,      (uint16_t )10,      (uint16_t )8,      (uint16_t )6};
#line 429 "/root/patchweave_new/13/src/enc/quant.c"
static void InitScore(VP8ModeScore *rd ) 
{ 


  {
#line 430
  rd->D = (score_t )0;
#line 431
  rd->SD = (score_t )0;
#line 432
  rd->R = (score_t )0;
#line 433
  rd->nz = (uint32_t )0;
#line 434
  rd->score = (score_t )36028797018963967LL;
#line 435
  return;
}
}
#line 437 "/root/patchweave_new/13/src/enc/quant.c"
static void CopyScore(VP8ModeScore *dst , VP8ModeScore *src ) 
{ 


  {
#line 438
  dst->D = src->D;
#line 439
  dst->SD = src->SD;
#line 440
  dst->R = src->R;
#line 441
  dst->nz = src->nz;
#line 442
  dst->score = src->score;
#line 443
  return;
}
}
#line 445 "/root/patchweave_new/13/src/enc/quant.c"
static void AddScore(VP8ModeScore *dst , VP8ModeScore *src ) 
{ 


  {
#line 446
  dst->D += src->D;
#line 447
  dst->SD += src->SD;
#line 448
  dst->R += src->R;
#line 449
  dst->nz |= src->nz;
#line 450
  dst->score += src->score;
#line 451
  return;
}
}
#line 475 "/root/patchweave_new/13/src/enc/quant.c"
__inline static void SetRDScore(int lambda , VP8ModeScore *rd ) 
{ 


  {
#line 477
  rd->score = rd->R * (long )lambda + 256L * (rd->D + rd->SD);
#line 478
  return;
}
}
#line 480 "/root/patchweave_new/13/src/enc/quant.c"
__inline static score_t RDScoreTrellis(int lambda , score_t rate , score_t distortion ) 
{ 


  {
#line 482
  return (rate * (long )lambda + 256L * distortion);
}
}
#line 485 "/root/patchweave_new/13/src/enc/quant.c"
static int TrellisQuantizeBlock(VP8EncIterator *it , int16_t *in , int16_t *out ,
                                int ctx0 , int coeff_type , VP8Matrix *mtx , int lambda ) 
{ 
  ProbaArray *last_costs ;
  CostArray *costs ;
  int first ;
  int tmp ;
  Node nodes[17][2] ;
  int best_path[3] ;
  score_t best_score ;
  int best_node ;
  int last ;
  int n ;
  int m ;
  int p ;
  int nz ;
  score_t cost ;
  score_t max_error ;
  int thresh ;
  int last_proba ;
  int j ;
  int err ;
  int __cil_tmp27 ;
  int j___0 ;
  int Q ;
  int iQ ;
  int B ;
  int sign ;
  int coeff0 ;
  int tmp___0 ;
  int level0 ;
  Node *cur ;
  int delta_error ;
  int new_error ;
  score_t cur_score ;
  int level ;
  int last_proba___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Node *prev ;
  int prev_ctx ;
  uint16_t *tcost ;
  score_t total_error ;
  score_t cost___0 ;
  score_t base_cost ;
  score_t score ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp56 ;
  Node *node ;
  int j___1 ;
  int tmp___3 ;

  {
#line 490
  last_costs = (it->enc_)->proba_.coeffs_[coeff_type];
#line 491
  costs = (it->enc_)->proba_.level_cost_[coeff_type];
#line 492
  if (coeff_type == 0) {
#line 492
    tmp = 1;
  } else {
#line 492
    tmp = 0;
  }
#line 492
  first = tmp;
#line 494
  best_path[0] = -1;
#line 494
  best_path[1] = -1;
#line 494
  best_path[2] = -1;
#line 497
  last = first - 1;
#line 503
  thresh = ((int )mtx->q_[1] * (int )mtx->q_[1]) / 4;
#line 504
  last_proba = (int )(*(last_costs + (int )VP8EncBands[first]))[ctx0][0];
#line 507
  max_error = (score_t )0;
#line 508
  n = first;
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;

#line 508
    if (! (n < 16)) {
#line 508
      goto while_break;
    }
#line 509
    j = (int )kZigzag[n];
#line 510
    err = (int )*(in + j) * (int )*(in + j);
#line 511
    max_error += (long )((int )kWeightTrellis[j] * err);
#line 512
    if (err > thresh) {
#line 512
      last = n;
    }
#line 508
    n ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 516
  if (last < 15) {
#line 516
    last ++;
  }
  {
#line 519
  __cil_tmp27 = VP8BitCost(0, (uint8_t )last_proba);
#line 519
  cost = (score_t )__cil_tmp27;
#line 520
  best_score = RDScoreTrellis(lambda, cost, max_error);
#line 523
  n = first - 1;
#line 524
  m = 0;
  }
  {
#line 524
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 524
    if (! (m <= 1)) {
#line 524
      goto while_break___0;
    }
#line 525
    nodes[n + 1][m].cost = (score_t )0;
#line 526
    nodes[n + 1][m].error = max_error;
#line 527
    nodes[n + 1][m].ctx = ctx0;
#line 524
    m ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 532
  n = first;
  {
#line 532
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 532
    if (! (n <= last)) {
#line 532
      goto while_break___1;
    }
#line 533
    j___0 = (int )kZigzag[n];
#line 534
    Q = (int )mtx->q_[j___0];
#line 535
    iQ = (int )mtx->iq_[j___0];
#line 536
    B = 0;
#line 539
    sign = (int )*(in + j___0) < 0;
#line 540
    if (sign) {
#line 540
      tmp___0 = - ((int )*(in + j___0));
    } else {
#line 540
      tmp___0 = (int )*(in + j___0);
    }
#line 540
    coeff0 = tmp___0 + (int )mtx->sharpen_[j___0];
#line 542
    if (coeff0 > 2047) {
#line 542
      coeff0 = 2047;
    }
    {
#line 544
    level0 = QUANTDIV(coeff0, iQ, B);
#line 546
    m = 0;
    }
    {
#line 546
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: ;
#line 546
      if (! (m <= 1)) {
#line 546
        goto while_break___2;
      }
#line 547
      cur = & nodes[n + 1][m];
#line 549
      cur_score = (score_t )36028797018963967LL;
#line 550
      level = level0 + m;
#line 553
      cur->sign = sign;
#line 554
      cur->level = level;
#line 555
      if (level == 0) {
#line 555
        tmp___2 = 0;
      } else {
#line 555
        if (level == 1) {
#line 555
          tmp___1 = 1;
        } else {
#line 555
          tmp___1 = 2;
        }
#line 555
        tmp___2 = tmp___1;
      }
#line 555
      cur->ctx = tmp___2;
#line 556
      if (level >= 2048) {
#line 557
        cur->cost = (score_t )36028797018963967LL;
#line 558
        goto while_continue___2;
      } else
#line 556
      if (level < 0) {
#line 557
        cur->cost = (score_t )36028797018963967LL;
#line 558
        goto while_continue___2;
      }
#line 560
      last_proba___0 = (int )(*(last_costs + (int )VP8EncBands[n + 1]))[cur->ctx][0];
#line 564
      new_error = coeff0 - level * Q;
#line 565
      delta_error = (int )kWeightTrellis[j___0] * (coeff0 * coeff0 - new_error * new_error);
#line 569
      p = 0;
      {
#line 569
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___3: ;
#line 569
        if (! (p <= 1)) {
#line 569
          goto while_break___3;
        }
#line 570
        prev = & nodes[(n - 1) + 1][p];
#line 571
        prev_ctx = prev->ctx;
#line 572
        tcost = (*(costs + (int )VP8EncBands[n]))[prev_ctx];
#line 573
        total_error = prev->error - (long )delta_error;
#line 576
        if (prev->cost >= 36028797018963967L) {
#line 577
          goto while_continue___3;
        }
        {
#line 581
        __cil_tmp53 = VP8LevelCost(tcost, level);
#line 581
        base_cost = prev->cost + (long )__cil_tmp53;
#line 584
        cost___0 = base_cost;
        }
#line 585
        if (level) {
#line 585
          if (n < 15) {
            {
#line 586
            __cil_tmp54 = VP8BitCost(1, (uint8_t )last_proba___0);
#line 586
            cost___0 += (long )__cil_tmp54;
            }
          }
        }
        {
#line 588
        score = RDScoreTrellis(lambda, cost___0, total_error);
        }
#line 589
        if (score < cur_score) {
#line 590
          cur_score = score;
#line 591
          cur->cost = cost___0;
#line 592
          cur->error = total_error;
#line 593
          cur->prev = p;
        }
#line 597
        if (level) {
#line 598
          cost___0 = base_cost;
#line 599
          if (n < 15) {
            {
#line 599
            __cil_tmp56 = VP8BitCost(0, (uint8_t )last_proba___0);
#line 599
            cost___0 += (long )__cil_tmp56;
            }
          }
          {
#line 600
          score = RDScoreTrellis(lambda, cost___0, total_error);
          }
#line 601
          if (score < best_score) {
#line 602
            best_score = score;
#line 603
            best_path[0] = n;
#line 604
            best_path[1] = m;
#line 605
            best_path[2] = p;
          }
        }
#line 569
        p ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: 
#line 546
      m ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
#line 532
    n ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 613
  memset((void *)(in + first), 0, (unsigned long )(16 - first) * sizeof(*(in + 0)));
#line 614
  memset((void *)(out + first), 0, (unsigned long )(16 - first) * sizeof(*(out + 0)));
  }
#line 615
  if (best_path[0] == -1) {
#line 616
    return (0);
  }
#line 622
  n = best_path[0];
#line 623
  best_node = best_path[1];
#line 624
  nodes[n + 1][best_node].prev = best_path[2];
#line 625
  nz = 0;
  {
#line 627
  while (1) {
    while_continue___8: /* CIL Label */ ;

#line 627
    if (! (n >= first)) {
#line 627
      goto while_break___4;
    }
#line 628
    node = & nodes[n + 1][best_node];
#line 629
    j___1 = (int )kZigzag[n];
#line 630
    if (node->sign) {
#line 630
      tmp___3 = - node->level;
    } else {
#line 630
      tmp___3 = node->level;
    }
#line 630
    *(out + n) = (int16_t )tmp___3;
#line 631
    nz |= node->level != 0;
#line 632
    *(in + j___1) = (int16_t )((int )*(out + n) * (int )mtx->q_[j___1]);
#line 633
    best_node = node->prev;
#line 627
    n --;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: ;
#line 635
  return (nz);
}
}
#line 645 "/root/patchweave_new/13/src/enc/quant.c"
static int ReconstructIntra16(VP8EncIterator *it , VP8ModeScore *rd , uint8_t *yuv_out ,
                              int mode ) 
{ 
  VP8Encoder *enc ;
  uint8_t *ref ;
  uint8_t *src ;
  VP8SegmentInfo *dqm ;
  int nz ;
  int n ;
  int16_t tmp[16][16] ;
  int16_t dc_tmp[16] ;
  int __cil_tmp13 ;
  int x ;
  int y ;
  int ctx ;
  int non_zero ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 649
  enc = it->enc_;
#line 650
  ref = it->yuv_p_ + VP8I16ModeOffsets[mode];
#line 651
  src = it->yuv_in_ + 0;
#line 652
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 653
  nz = 0;
#line 657
  n = 0;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;

#line 657
    if (! (n < 16)) {
#line 657
      goto while_break;
    }
    {
#line 658
    (*VP8FTransform)(src + VP8Scan[n], ref + VP8Scan[n], tmp[n]);
#line 657
    n ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 660
  (*VP8FTransformWHT)(tmp[0], dc_tmp);
#line 661
  __cil_tmp13 = (*VP8EncQuantizeBlock)((int16_t *)(dc_tmp), (int16_t *)(rd->y_dc_levels),
                                       0, (struct VP8Matrix */* const  */)(& dqm->y2_));
#line 661
  nz |= __cil_tmp13 << 24;
  }
#line 663
  if (it->do_trellis_) {
    {
#line 665
    VP8IteratorNzToBytes(it);
#line 666
    n = 0;
#line 666
    y = 0;
    }
    {
#line 666
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 666
      if (! (y < 4)) {
#line 666
        goto while_break___0;
      }
#line 667
      x = 0;
      {
#line 667
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 667
        if (! (x < 4)) {
#line 667
          goto while_break___1;
        }
        {
#line 668
        ctx = it->top_nz_[x] + it->left_nz_[y];
#line 669
        __cil_tmp18 = TrellisQuantizeBlock(it, (int16_t *)(tmp[n]), (int16_t *)(rd->y_ac_levels[n]),
                                           ctx, 0, & dqm->y1_, dqm->lambda_trellis_i16_);
#line 669
        non_zero = __cil_tmp18;
#line 672
        it->left_nz_[y] = non_zero;
#line 672
        it->top_nz_[x] = it->left_nz_[y];
#line 673
        nz |= non_zero << n;
#line 667
        n ++;
#line 667
        x ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 666
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 677
    n = 0;
    {
#line 677
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 677
      if (! (n < 16)) {
#line 677
        goto while_break___2;
      }
      {
#line 678
      __cil_tmp19 = (*VP8EncQuantizeBlock)((int16_t *)(tmp[n]), (int16_t *)(rd->y_ac_levels[n]),
                                           1, (struct VP8Matrix */* const  */)(& dqm->y1_));
#line 678
      nz |= __cil_tmp19 << n;
#line 677
      n ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
  }
  {
#line 683
  (*VP8ITransformWHT)(dc_tmp, tmp[0]);
#line 684
  n = 0;
  }
  {
#line 684
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 684
    if (! (n < 16)) {
#line 684
      goto while_break___3;
    }
    {
#line 685
    (*VP8ITransform)(ref + VP8Scan[n], tmp[n], yuv_out + VP8Scan[n], 1);
#line 684
    n += 2;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: ;
#line 688
  return (nz);
}
}
#line 691 "/root/patchweave_new/13/src/enc/quant.c"
static int ReconstructIntra4(VP8EncIterator *it , int16_t *levels , uint8_t *src ,
                             uint8_t *yuv_out , int mode ) 
{ 
  VP8Encoder *enc ;
  uint8_t *ref ;
  VP8SegmentInfo *dqm ;
  int nz ;
  int16_t tmp[16] ;
  int x ;
  int y ;
  int ctx ;

  {
  {
#line 696
  enc = it->enc_;
#line 697
  ref = it->yuv_p_ + VP8I4ModeOffsets[mode];
#line 698
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 699
  nz = 0;
#line 702
  (*VP8FTransform)(src, ref, tmp);
  }
#line 703
  if (it->do_trellis_) {
    {
#line 704
    x = it->i4_ & 3;
#line 704
    y = it->i4_ >> 2;
#line 705
    ctx = it->top_nz_[x] + it->left_nz_[y];
#line 706
    nz = TrellisQuantizeBlock(it, (int16_t *)(tmp), levels, ctx, 3, & dqm->y1_, dqm->lambda_trellis_i4_);
    }
  } else {
    {
#line 709
    nz = (*VP8EncQuantizeBlock)((int16_t *)(tmp), levels, 0, (struct VP8Matrix */* const  */)(& dqm->y1_));
    }
  }
  {
#line 711
  (*VP8ITransform)(ref, tmp, yuv_out, 0);
  }
#line 712
  return (nz);
}
}
#line 715 "/root/patchweave_new/13/src/enc/quant.c"
static int ReconstructUV(VP8EncIterator *it , VP8ModeScore *rd , uint8_t *yuv_out ,
                         int mode ) 
{ 
  VP8Encoder *enc ;
  uint8_t *ref ;
  uint8_t *src ;
  VP8SegmentInfo *dqm ;
  int nz ;
  int n ;
  int16_t tmp[8][16] ;
  int ch ;
  int x ;
  int y ;
  int ctx ;
  int non_zero ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 717
  enc = it->enc_;
#line 718
  ref = it->yuv_p_ + VP8UVModeOffsets[mode];
#line 719
  src = it->yuv_in_ + 256;
#line 720
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 721
  nz = 0;
#line 725
  n = 0;
  {
#line 725
  while (1) {
    while_continue: /* CIL Label */ ;

#line 725
    if (! (n < 8)) {
#line 725
      goto while_break;
    }
    {
#line 726
    (*VP8FTransform)(src + VP8Scan[16 + n], ref + VP8Scan[16 + n], tmp[n]);
#line 725
    n ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 728
  if (0) {
#line 730
    n = 0;
#line 730
    ch = 0;
    {
#line 730
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 730
      if (! (ch <= 2)) {
#line 730
        goto while_break___0;
      }
#line 731
      y = 0;
      {
#line 731
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 731
        if (! (y < 2)) {
#line 731
          goto while_break___1;
        }
#line 732
        x = 0;
        {
#line 732
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 732
          if (! (x < 2)) {
#line 732
            goto while_break___2;
          }
          {
#line 733
          ctx = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 734
          __cil_tmp17 = TrellisQuantizeBlock(it, (int16_t *)(tmp[n]), (int16_t *)(rd->uv_levels[n]),
                                             ctx, 2, & dqm->uv_, dqm->lambda_trellis_uv_);
#line 734
          non_zero = __cil_tmp17;
#line 737
          it->left_nz_[(4 + ch) + y] = non_zero;
#line 737
          it->top_nz_[(4 + ch) + x] = it->left_nz_[(4 + ch) + y];
#line 738
          nz |= non_zero << n;
#line 732
          n ++;
#line 732
          x ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: 
#line 731
        y ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
#line 730
      ch += 2;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 743
    n = 0;
    {
#line 743
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 743
      if (! (n < 8)) {
#line 743
        goto while_break___3;
      }
      {
#line 744
      __cil_tmp18 = (*VP8EncQuantizeBlock)((int16_t *)(tmp[n]), (int16_t *)(rd->uv_levels[n]),
                                           0, (struct VP8Matrix */* const  */)(& dqm->uv_));
#line 744
      nz |= __cil_tmp18 << n;
#line 743
      n ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: ;
  }
#line 748
  n = 0;
  {
#line 748
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 748
    if (! (n < 8)) {
#line 748
      goto while_break___4;
    }
    {
#line 749
    (*VP8ITransform)(ref + VP8Scan[16 + n], tmp[n], yuv_out + VP8Scan[16 + n], 1);
#line 748
    n += 2;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: ;
#line 751
  return (nz << 16);
}
}
#line 758 "/root/patchweave_new/13/src/enc/quant.c"
static void SwapPtr(uint8_t **a , uint8_t **b ) 
{ 
  uint8_t *tmp ;

  {
#line 759
  tmp = *a;
#line 760
  *a = *b;
#line 761
  *b = tmp;
#line 762
  return;
}
}
#line 764 "/root/patchweave_new/13/src/enc/quant.c"
static void SwapOut(VP8EncIterator *it ) 
{ 


  {
  {
#line 765
  SwapPtr(& it->yuv_out_, & it->yuv_out2_);
  }
#line 767
  return;
}
}
#line 768 "/root/patchweave_new/13/src/enc/quant.c"
static void PickBestIntra16(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Encoder *enc ;
  VP8SegmentInfo *dqm ;
  int lambda ;
  int tlambda ;
  uint8_t *src ;
  VP8ModeScore rd16 ;
  int mode ;
  uint8_t *tmp_dst ;
  int nz ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;

  {
#line 769
  enc = it->enc_;
#line 770
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 771
  lambda = dqm->lambda_i16_;
#line 772
  tlambda = dqm->tlambda_;
#line 773
  src = it->yuv_in_ + 0;
#line 777
  rd->mode_i16 = -1;
#line 778
  mode = 0;
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;

#line 778
    if (! (mode < 4)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp_dst = it->yuv_out2_ + 0;
#line 783
    nz = ReconstructIntra16(it, & rd16, tmp_dst, mode);
#line 786
    __cil_tmp13 = (*VP8SSE16x16)(src, tmp_dst);
#line 786
    rd16.D = (score_t )__cil_tmp13;
    }
#line 787
    if (tlambda) {
      {
#line 787
      __cil_tmp14 = (*VP8TDisto16x16)(src, tmp_dst, (uint16_t */* const  */)(kWeightY));
#line 787
      tmp = (tlambda * __cil_tmp14 + 128) >> 8;
      }
    } else {
#line 787
      tmp = 0;
    }
    {
#line 787
    rd16.SD = (score_t )tmp;
#line 789
    __cil_tmp16 = VP8GetCostLuma16(it, & rd16);
#line 789
    rd16.R = (score_t )__cil_tmp16;
#line 790
    rd16.R += (long )VP8FixedCostsI16[mode];
#line 793
    SetRDScore(lambda, & rd16);
    }
#line 794
    if (mode == 0) {
      _L: 
      {
#line 795
      CopyScore(rd, & rd16);
#line 796
      rd->mode_i16 = mode;
#line 797
      rd->nz = (uint32_t )nz;
#line 798
      memcpy((void *)(rd->y_ac_levels), (void const   *)(rd16.y_ac_levels), sizeof(rd16.y_ac_levels));
#line 799
      memcpy((void *)(rd->y_dc_levels), (void const   *)(rd16.y_dc_levels), sizeof(rd16.y_dc_levels));
#line 800
      SwapOut(it);
      }
    } else
#line 794
    if (rd16.score < rd->score) {
#line 794
      goto _L;
    }
#line 778
    mode ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 803
  SetRDScore(dqm->lambda_mode_, rd);
#line 804
  VP8SetIntra16Mode(it, rd->mode_i16);
  }
#line 806
  return;
}
}
#line 810 "/root/patchweave_new/13/src/enc/quant.c"
static uint16_t *GetCostModeI4(VP8EncIterator *it , uint8_t *modes ) 
{ 
  int preds_w ;
  int x ;
  int y ;
  int left ;
  int tmp ;
  int top ;
  int tmp___0 ;

  {
#line 812
  preds_w = (it->enc_)->preds_w_;
#line 813
  x = it->i4_ & 3;
#line 813
  y = it->i4_ >> 2;
#line 814
  if (x == 0) {
#line 814
    tmp = (int )*(it->preds_ + (y * preds_w - 1));
  } else {
#line 814
    tmp = (int )*(modes + (it->i4_ - 1));
  }
#line 814
  left = tmp;
#line 815
  if (y == 0) {
#line 815
    tmp___0 = (int )*(it->preds_ + (- preds_w + x));
  } else {
#line 815
    tmp___0 = (int )*(modes + (it->i4_ - 4));
  }
#line 815
  top = tmp___0;
#line 816
  return (VP8FixedCostsI4[top][left]);
}
}
#line 819 "/root/patchweave_new/13/src/enc/quant.c"
static int PickBestIntra4(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Encoder *enc ;
  VP8SegmentInfo *dqm ;
  int lambda ;
  int tlambda ;
  uint8_t *src0 ;
  uint8_t *best_blocks ;
  int total_header_bits ;
  VP8ModeScore rd_best ;
  int __cil_tmp11 ;
  VP8ModeScore rd_i4 ;
  int mode ;
  int best_mode ;
  uint8_t *src ;
  uint16_t *mode_costs ;
  uint16_t *__cil_tmp17 ;
  uint8_t *best_block ;
  uint8_t *tmp_dst ;
  VP8ModeScore rd_tmp ;
  int16_t tmp_levels[16] ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int tmp ;
  int __cil_tmp26 ;
  int tmp___0 ;

  {
#line 820
  enc = it->enc_;
#line 821
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 822
  lambda = dqm->lambda_i4_;
#line 823
  tlambda = dqm->tlambda_;
#line 824
  src0 = it->yuv_in_ + 0;
#line 825
  best_blocks = it->yuv_out2_ + 0;
#line 826
  total_header_bits = 0;
#line 829
  if (enc->max_i4_header_bits_ == 0) {
#line 830
    return (0);
  }
  {
#line 833
  InitScore(& rd_best);
#line 834
  rd_best.score = (score_t )211;
#line 835
  VP8IteratorStartI4(it);
  }
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 839
    best_mode = -1;
#line 840
    src = src0 + VP8Scan[it->i4_];
#line 841
    __asm__  ("booo_exp(/root/patchweave_new/13/src/enc/quant.c:841)":);
#line 841
    __cil_tmp17 = GetCostModeI4(it, (uint8_t *)0);
#line 841
    mode_costs = __cil_tmp17;
#line 842
    best_block = best_blocks + VP8Scan[it->i4_];
#line 843
    tmp_dst = it->yuv_p_ + 1672;
#line 845
    InitScore(& rd_i4);
#line 846
    VP8MakeIntra4Preds(it);
#line 847
    mode = 0;
    }
    {
#line 847
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 847
      if (! (mode < 10)) {
#line 847
        goto while_break___0;
      }
      {
#line 852
      __cil_tmp22 = ReconstructIntra4(it, (int16_t *)(tmp_levels), src, tmp_dst, mode);
#line 852
      rd_tmp.nz = (uint32_t )(__cil_tmp22 << it->i4_);
#line 856
      __cil_tmp23 = (*VP8SSE4x4)(src, tmp_dst);
#line 856
      rd_tmp.D = (score_t )__cil_tmp23;
      }
#line 857
      if (tlambda) {
        {
#line 857
        __cil_tmp24 = (*VP8TDisto4x4)(src, tmp_dst, (uint16_t */* const  */)(kWeightY));
#line 857
        tmp = (tlambda * __cil_tmp24 + 128) >> 8;
        }
      } else {
#line 857
        tmp = 0;
      }
      {
#line 857
      rd_tmp.SD = (score_t )tmp;
#line 860
      __asm__  ("booo_exp(/root/patchweave_new/13/src/enc/quant.c:860)":);
#line 860
      __cil_tmp26 = VP8GetCostLuma4(it, (int16_t *)0);
#line 860
      rd_tmp.R = (score_t )__cil_tmp26;
#line 861
      rd_tmp.R += (long )*(mode_costs + mode);
#line 863
      SetRDScore(lambda, & rd_tmp);
      }
#line 864
      if (best_mode < 0) {
        {
#line 865
        CopyScore(& rd_i4, & rd_tmp);
#line 866
        best_mode = mode;
#line 867
        SwapPtr(& tmp_dst, & best_block);
#line 868
        memcpy((void *)(rd_best.y_ac_levels[it->i4_]), (void const   *)(tmp_levels),
               sizeof(tmp_levels));
        }
      } else
#line 864
      if (rd_tmp.score < rd_i4.score) {
        {
#line 865
        CopyScore(& rd_i4, & rd_tmp);
#line 866
        best_mode = mode;
#line 867
        SwapPtr(& tmp_dst, & best_block);
#line 868
        memcpy((void *)(rd_best.y_ac_levels[it->i4_]), (void const   *)(tmp_levels),
               sizeof(tmp_levels));
        }
      }
#line 847
      mode ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 871
    SetRDScore(dqm->lambda_mode_, & rd_i4);
#line 872
    AddScore(& rd_best, & rd_i4);
#line 873
    total_header_bits += (int )*(mode_costs + best_mode);
    }
#line 874
    if (rd_best.score >= rd->score) {
#line 876
      return (0);
    } else
#line 874
    if (total_header_bits > enc->max_i4_header_bits_) {
#line 876
      return (0);
    }
#line 879
    if ((unsigned long )best_block != (unsigned long )(best_blocks + VP8Scan[it->i4_])) {
      {
#line 880
      (*VP8Copy4x4)(best_block, best_blocks + VP8Scan[it->i4_]);
      }
    }
#line 881
    rd->modes_i4[it->i4_] = (uint8_t )best_mode;
#line 882
    if (rd_i4.nz) {
#line 882
      tmp___0 = 1;
    } else {
#line 882
      tmp___0 = 0;
    }
#line 882
    it->left_nz_[it->i4_ >> 2] = tmp___0;
#line 882
    it->top_nz_[it->i4_ & 3] = it->left_nz_[it->i4_ >> 2];
#line 836
    if (! __cil_tmp11) {
#line 836
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 886
  CopyScore(rd, & rd_best);
#line 887
  VP8SetIntra4Mode(it, rd->modes_i4);
#line 888
  SwapOut(it);
#line 889
  memcpy((void *)(rd->y_ac_levels), (void const   *)(rd_best.y_ac_levels), sizeof(rd->y_ac_levels));
  }
#line 890
  return (1);
}
}
#line 895 "/root/patchweave_new/13/src/enc/quant.c"
static void PickBestUV(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Encoder *enc ;
  VP8SegmentInfo *dqm ;
  int lambda ;
  uint8_t *src ;
  uint8_t *tmp_dst ;
  uint8_t *dst0 ;
  VP8ModeScore rd_best ;
  int mode ;
  VP8ModeScore rd_uv ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 896
  enc = it->enc_;
#line 897
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 898
  lambda = dqm->lambda_uv_;
#line 899
  src = it->yuv_in_ + 256;
#line 900
  tmp_dst = it->yuv_out2_ + 256;
#line 901
  dst0 = it->yuv_out_ + 256;
#line 905
  rd->mode_uv = -1;
#line 906
  InitScore(& rd_best);
#line 907
  mode = 0;
  }
  {
#line 907
  while (1) {
    while_continue: /* CIL Label */ ;

#line 907
    if (! (mode < 4)) {
#line 907
      goto while_break;
    }
    {
#line 911
    __cil_tmp12 = ReconstructUV(it, & rd_uv, tmp_dst, mode);
#line 911
    rd_uv.nz = (uint32_t )__cil_tmp12;
#line 914
    __cil_tmp13 = (*VP8SSE16x8)(src, tmp_dst);
#line 914
    rd_uv.D = (score_t )__cil_tmp13;
#line 915
    rd_uv.SD = (score_t )0;
#line 916
    __cil_tmp14 = VP8GetCostUV(it, & rd_uv);
#line 916
    rd_uv.R = (score_t )__cil_tmp14;
#line 917
    rd_uv.R += (long )VP8FixedCostsUV[mode];
#line 919
    SetRDScore(lambda, & rd_uv);
    }
#line 920
    if (mode == 0) {
      {
#line 921
      CopyScore(& rd_best, & rd_uv);
#line 922
      rd->mode_uv = mode;
#line 923
      memcpy((void *)(rd->uv_levels), (void const   *)(rd_uv.uv_levels), sizeof(rd->uv_levels));
#line 924
      memcpy((void *)dst0, (void const   *)tmp_dst, 128UL);
      }
    } else
#line 920
    if (rd_uv.score < rd_best.score) {
      {
#line 921
      CopyScore(& rd_best, & rd_uv);
#line 922
      rd->mode_uv = mode;
#line 923
      memcpy((void *)(rd->uv_levels), (void const   *)(rd_uv.uv_levels), sizeof(rd->uv_levels));
#line 924
      memcpy((void *)dst0, (void const   *)tmp_dst, 128UL);
      }
    }
#line 907
    mode ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 927
  VP8SetIntraUVMode(it, rd->mode_uv);
#line 928
  AddScore(rd, & rd_best);
  }
#line 930
  return;
}
}
#line 934 "/root/patchweave_new/13/src/enc/quant.c"
static void SimpleQuantize(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Encoder *enc ;
  int is_i16 ;
  int nz ;
  int __cil_tmp7 ;
  int mode ;
  uint8_t *src ;
  uint8_t *dst ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 935
  enc = it->enc_;
#line 936
  is_i16 = (int )(it->mb_)->type_ == 1;
#line 937
  nz = 0;
#line 939
  if (is_i16) {
    {
#line 940
    nz = ReconstructIntra16(it, rd, it->yuv_out_ + 0, (int )*(it->preds_ + 0));
    }
  } else {
    {
#line 942
    VP8IteratorStartI4(it);
    }
    {
#line 943
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 944
      mode = (int )*(it->preds_ + ((it->i4_ & 3) + (it->i4_ >> 2) * enc->preds_w_));
#line 946
      src = (it->yuv_in_ + 0) + VP8Scan[it->i4_];
#line 947
      dst = (it->yuv_out_ + 0) + VP8Scan[it->i4_];
#line 948
      VP8MakeIntra4Preds(it);
#line 949
      __cil_tmp11 = ReconstructIntra4(it, (int16_t *)(rd->y_ac_levels[it->i4_]), src,
                                      dst, mode);
#line 949
      nz |= __cil_tmp11 << it->i4_;
      }
#line 943
      if (! __cil_tmp7) {
#line 943
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 954
  __cil_tmp12 = ReconstructUV(it, rd, it->yuv_out_ + 256, (int )(it->mb_)->uv_mode_);
#line 954
  nz |= __cil_tmp12;
#line 955
  rd->nz = (uint32_t )nz;
  }
#line 956
  return;
}
}
#line 959 "/root/patchweave_new/13/src/enc/quant.c"
static void DistoRefine(VP8EncIterator *it , int try_both_i4_i16 ) 
{ 
  int is_i16 ;
  score_t best_score ;
  int mode ;
  int best_mode ;
  uint8_t *ref ;
  uint8_t *src ;
  score_t score ;
  int __cil_tmp10 ;
  uint8_t modes_i4[16] ;
  score_t score_i4 ;
  int __cil_tmp13 ;
  int mode___0 ;
  int best_sub_mode ;
  score_t best_sub_score ;
  uint8_t *src___0 ;
  uint8_t *ref___0 ;
  score_t score___0 ;
  int __cil_tmp20 ;

  {
#line 960
  is_i16 = (int )(it->mb_)->type_ == 1;
#line 961
  best_score = (score_t )36028797018963967LL;
#line 963
  if (try_both_i4_i16) {
    _L: 
#line 965
    best_mode = -1;
#line 966
    mode = 0;
    {
#line 966
    while (1) {
      while_continue: /* CIL Label */ ;

#line 966
      if (! (mode < 4)) {
#line 966
        goto while_break;
      }
      {
#line 967
      ref = it->yuv_p_ + VP8I16ModeOffsets[mode];
#line 968
      src = it->yuv_in_ + 0;
#line 969
      __cil_tmp10 = (*VP8SSE16x16)(src, ref);
#line 969
      score = (score_t )__cil_tmp10;
      }
#line 970
      if (score < best_score) {
#line 971
        best_mode = mode;
#line 972
        best_score = score;
      }
#line 966
      mode ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
    {
#line 975
    VP8SetIntra16Mode(it, best_mode);
    }
  } else
#line 963
  if (is_i16) {
#line 963
    goto _L;
  }
#line 977
  if (try_both_i4_i16) {
    _L___9: 
    {
#line 981
    score_i4 = (score_t )4000;
#line 983
    VP8IteratorStartI4(it);
    }
    {
#line 984
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 986
      best_sub_mode = -1;
#line 987
      best_sub_score = (score_t )36028797018963967LL;
#line 988
      src___0 = (it->yuv_in_ + 0) + VP8Scan[it->i4_];
#line 992
      VP8MakeIntra4Preds(it);
#line 993
      mode___0 = 0;
      }
      {
#line 993
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 993
        if (! (mode___0 < 10)) {
#line 993
          goto while_break___1;
        }
        {
#line 994
        ref___0 = it->yuv_p_ + VP8I4ModeOffsets[mode___0];
#line 995
        __cil_tmp20 = (*VP8SSE4x4)(src___0, ref___0);
#line 995
        score___0 = (score_t )__cil_tmp20;
        }
#line 996
        if (score___0 < best_sub_score) {
#line 997
          best_sub_mode = mode___0;
#line 998
          best_sub_score = score___0;
        }
#line 993
        mode___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 1001
      modes_i4[it->i4_] = (uint8_t )best_sub_mode;
#line 1002
      score_i4 += best_sub_score;
#line 1003
      if (score_i4 >= best_score) {
#line 1003
        goto while_break___0;
      }
#line 984
      if (! __cil_tmp13) {
#line 984
        goto while_break___0;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
#line 1005
    if (score_i4 < best_score) {
      {
#line 1006
      VP8SetIntra4Mode(it, modes_i4);
      }
    }
  } else
#line 977
  if (! is_i16) {
#line 977
    goto _L___9;
  }
#line 979
  return;
}
}
#line 1014 "/root/patchweave_new/13/src/enc/quant.c"
int VP8Decimate(VP8EncIterator *it , VP8ModeScore *rd , VP8RDLevel rd_opt ) 
{ 
  int is_skipped ;
  int method ;

  {
  {
#line 1017
  method = (it->enc_)->method_;
#line 1019
  InitScore(rd);
#line 1023
  VP8MakeLuma16Preds(it);
#line 1024
  VP8MakeChroma8Preds(it);
  }
#line 1026
  if ((unsigned int )rd_opt > 0U) {
    {
#line 1027
    it->do_trellis_ = (unsigned int )rd_opt >= 3U;
#line 1028
    PickBestIntra16(it, rd);
    }
#line 1029
    if (method >= 2) {
      {
#line 1030
      PickBestIntra4(it, rd);
      }
    }
    {
#line 1032
    PickBestUV(it, rd);
    }
#line 1033
    if ((unsigned int )rd_opt == 2U) {
      {
#line 1034
      it->do_trellis_ = 1;
#line 1035
      SimpleQuantize(it, rd);
      }
    }
  } else {
    {
#line 1040
    DistoRefine(it, method >= 2);
#line 1041
    SimpleQuantize(it, rd);
    }
  }
  {
#line 1043
  is_skipped = rd->nz == 0U;
#line 1044
  VP8SetSkip(it, is_skipped);
  }
#line 1045
  return (is_skipped);
}
}
#line 157 "/root/patchweave_new/13/src/enc/../dsp/../dec/../webp/decode.h"
__inline static int WebPIsPremultipliedMode___0(enum WEBP_CSP_MODE mode ) 
{ 
  int tmp ;

  {
#line 158
  if ((unsigned int )mode == 7U) {
#line 158
    tmp = 1;
  } else
#line 158
  if ((unsigned int )mode == 8U) {
#line 158
    tmp = 1;
  } else
#line 158
  if ((unsigned int )mode == 9U) {
#line 158
    tmp = 1;
  } else
#line 158
  if ((unsigned int )mode == 10U) {
#line 158
    tmp = 1;
  } else {
#line 158
    tmp = 0;
  }
#line 158
  return (tmp);
}
}
#line 162 "/root/patchweave_new/13/src/enc/../dsp/../dec/../webp/decode.h"
__inline static int WebPIsAlphaMode___0(enum WEBP_CSP_MODE mode ) 
{ 
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 163
  __cil_tmp2 = WebPIsPremultipliedMode___0(mode);
  }
#line 163
  if ((unsigned int )mode == 1U) {
#line 163
    tmp = 1;
  } else
#line 163
  if ((unsigned int )mode == 3U) {
#line 163
    tmp = 1;
  } else
#line 163
  if ((unsigned int )mode == 4U) {
#line 163
    tmp = 1;
  } else
#line 163
  if ((unsigned int )mode == 5U) {
#line 163
    tmp = 1;
  } else
#line 163
  if ((unsigned int )mode == 12U) {
#line 163
    tmp = 1;
  } else
#line 163
  if (__cil_tmp2) {
#line 163
    tmp = 1;
  } else {
#line 163
    tmp = 0;
  }
#line 163
  return (tmp);
}
}
#line 168 "/root/patchweave_new/13/src/enc/../dsp/../dec/../webp/decode.h"
__inline static int WebPIsRGBMode___0(enum WEBP_CSP_MODE mode ) 
{ 


  {
#line 169
  return ((unsigned int )mode < 11U);
}
}
#line 424 "/root/patchweave_new/13/src/enc/../dsp/../dec/../webp/decode.h"
__inline static enum VP8StatusCode WebPGetFeatures___0(uint8_t *data , size_t data_size ,
                                                       WebPBitstreamFeatures *features ) 
{ 
  enum VP8StatusCode __cil_tmp4 ;
  enum VP8StatusCode___0 tmp ;

  {
  {
#line 427
  tmp = WebPGetFeaturesInternal(data, data_size, features, 513);
#line 427
  __cil_tmp4 = (enum VP8StatusCode )tmp;
  }
#line 427
  return (__cil_tmp4);
}
}
#line 109 "/root/patchweave_new/13/src/enc/../dsp/../dec/decode_vp8.h"
int VP8InitIoInternal(VP8Io *io , int version ) ;
#line 114
int WebPISetIOHooks(WebPIDecoder *idec , int (*put)(VP8Io * ) , int (*setup)(VP8Io * ) ,
                    void (*teardown)(VP8Io * ) , void *user_data ) ;
#line 124
VP8Decoder *VP8New(void) ;
#line 129 "/root/patchweave_new/13/src/enc/../dsp/../dec/decode_vp8.h"
__inline static int VP8InitIo(VP8Io *io ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 130
  __cil_tmp2 = VP8InitIoInternal(io, 513);
  }
#line 130
  return (__cil_tmp2);
}
}
#line 134
int VP8GetHeaders(VP8Decoder *dec , VP8Io *io ) ;
#line 138
int VP8Decode(VP8Decoder *dec , VP8Io *io ) ;
#line 141
enum VP8StatusCode VP8Status(VP8Decoder *dec ) ;
#line 144
char const   *VP8StatusMessage(VP8Decoder *dec ) ;
#line 148
void VP8Clear(VP8Decoder *dec ) ;
#line 151
void VP8Delete(VP8Decoder *dec ) ;
#line 157
int VP8CheckSignature(uint8_t *data , size_t data_size ) ;
#line 162
int VP8GetInfo(uint8_t *data , size_t data_size , size_t chunk_size , int *width ,
               int *height ) ;
#line 169
int VP8LCheckSignature(uint8_t *data , size_t size ) ;
#line 174
int VP8LGetInfo(uint8_t *data , size_t data_size , int *width , int *height , int *has_alpha ) ;
#line 66 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
int16_t VP8kVToR[256]  ;
#line 66 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
int16_t VP8kUToB[256]  ;
#line 67 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
int32_t VP8kVToG[256]  ;
#line 67 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
int32_t VP8kUToG[256]  ;
#line 68 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
uint8_t VP8kClip[709]  ;
#line 69 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
uint8_t VP8kClip4Bits[709]  ;
#line 71 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToRgb(uint8_t y , uint8_t u , uint8_t v , uint8_t *rgb ) 
{ 
  int r_off ;
  int g_off ;
  int b_off ;

  {
#line 73
  r_off = (int )VP8kVToR[v];
#line 74
  g_off = (VP8kVToG[v] + VP8kUToG[u]) >> 16;
#line 75
  b_off = (int )VP8kUToB[u];
#line 76
  *(rgb + 0) = VP8kClip[((int )y + r_off) - -227];
#line 77
  *(rgb + 1) = VP8kClip[((int )y + g_off) - -227];
#line 78
  *(rgb + 2) = VP8kClip[((int )y + b_off) - -227];
#line 79
  return;
}
}
#line 81 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToBgr(uint8_t y , uint8_t u , uint8_t v , uint8_t *bgr ) 
{ 
  int r_off ;
  int g_off ;
  int b_off ;

  {
#line 83
  r_off = (int )VP8kVToR[v];
#line 84
  g_off = (VP8kVToG[v] + VP8kUToG[u]) >> 16;
#line 85
  b_off = (int )VP8kUToB[u];
#line 86
  *(bgr + 0) = VP8kClip[((int )y + b_off) - -227];
#line 87
  *(bgr + 1) = VP8kClip[((int )y + g_off) - -227];
#line 88
  *(bgr + 2) = VP8kClip[((int )y + r_off) - -227];
#line 89
  return;
}
}
#line 91 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToRgb565(uint8_t y , uint8_t u , uint8_t v , uint8_t *rgb ) 
{ 
  int r_off ;
  int g_off ;
  int b_off ;
  uint8_t rg ;
  uint8_t gb ;

  {
#line 93
  r_off = (int )VP8kVToR[v];
#line 94
  g_off = (VP8kVToG[v] + VP8kUToG[u]) >> 16;
#line 95
  b_off = (int )VP8kUToB[u];
#line 96
  rg = (uint8_t )(((int )VP8kClip[((int )y + r_off) - -227] & 248) | ((int )VP8kClip[((int )y + g_off) - -227] >> 5));
#line 98
  gb = (uint8_t )((((int )VP8kClip[((int )y + g_off) - -227] << 3) & 224) | ((int )VP8kClip[((int )y + b_off) - -227] >> 3));
#line 104
  *(rgb + 0) = rg;
#line 105
  *(rgb + 1) = gb;
#line 106
  return;
}
}
#line 109 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToRgba4444(uint8_t y , uint8_t u , uint8_t v , uint8_t *argb ) 
{ 
  int r_off ;
  int g_off ;
  int b_off ;
  uint8_t rg ;
  uint8_t ba ;

  {
#line 111
  r_off = (int )VP8kVToR[v];
#line 112
  g_off = (VP8kVToG[v] + VP8kUToG[u]) >> 16;
#line 113
  b_off = (int )VP8kUToB[u];
#line 114
  rg = (uint8_t )(((int )VP8kClip4Bits[((int )y + r_off) - -227] << 4) | (int )VP8kClip4Bits[((int )y + g_off) - -227]);
#line 116
  ba = (uint8_t )(((int )VP8kClip4Bits[((int )y + b_off) - -227] << 4) | 15);
#line 121
  *(argb + 0) = rg;
#line 122
  *(argb + 1) = ba;
#line 123
  return;
}
}
#line 208 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToArgb(uint8_t y , uint8_t u , uint8_t v , uint8_t *argb ) 
{ 


  {
  {
#line 210
  *(argb + 0) = (uint8_t )255;
#line 211
  VP8YuvToRgb(y, u, v, argb + 1);
  }
#line 213
  return;
}
}
#line 214 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToBgra(uint8_t y , uint8_t u , uint8_t v , uint8_t *bgra ) 
{ 


  {
  {
#line 216
  VP8YuvToBgr(y, u, v, bgra);
#line 217
  *(bgra + 3) = (uint8_t )255;
  }
#line 219
  return;
}
}
#line 220 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToRgba(uint8_t y , uint8_t u , uint8_t v , uint8_t *rgba ) 
{ 


  {
  {
#line 222
  VP8YuvToRgb(y, u, v, rgba);
#line 223
  *(rgba + 3) = (uint8_t )255;
  }
#line 225
  return;
}
}
#line 227
void VP8YUVInit(void) ;
#line 232 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
__inline static int VP8ClipUV(int v ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 233
  v = (v + (257 << 17)) >> 18;
#line 234
  if ((v & -256) == 0) {
#line 234
    tmp___0 = v;
  } else {
#line 234
    if (v < 0) {
#line 234
      tmp = 0;
    } else {
#line 234
      tmp = 255;
    }
#line 234
    tmp___0 = tmp;
  }
#line 234
  return (tmp___0);
}
}
#line 239 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
__inline static int VP8RGBToY(int r , int g , int b ) 
{ 
  int kRound ;
  int luma ;

  {
#line 240
  kRound = (1 << 15) + (16 << 16);
#line 241
  luma = (16839 * r + 33059 * g) + 6420 * b;
#line 242
  return ((luma + kRound) >> 16);
}
}
#line 245 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
__inline static int VP8RGBToU(int r , int g , int b ) 
{ 
  int u ;
  int __cil_tmp5 ;

  {
  {
#line 246
  u = (-9719 * r - 19081 * g) + 28800 * b;
#line 247
  __cil_tmp5 = VP8ClipUV(u);
  }
#line 247
  return (__cil_tmp5);
}
}
#line 250 "/root/patchweave_new/13/src/enc/../dsp/yuv.h"
__inline static int VP8RGBToV(int r , int g , int b ) 
{ 
  int v ;
  int __cil_tmp5 ;

  {
  {
#line 251
  v = (28800 * r - 24116 * g) - 4684 * b;
#line 252
  __cil_tmp5 = VP8ClipUV(v);
  }
#line 252
  return (__cil_tmp5);
}
}
#line 32 "/root/patchweave_new/13/src/enc/picture.c"
static union __anonunion_431 test_endian  =    {4278190080U};
#line 35 "/root/patchweave_new/13/src/enc/picture.c"
__inline static uint32_t MakeARGB32(int r , int g , int b ) 
{ 


  {
#line 36
  return (((4278190080U | (unsigned int )(r << 16)) | (unsigned int )(g << 8)) | (unsigned int )b);
}
}
#line 43 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureAlloc(WebPPicture *picture ) 
{ 
  enum WebPEncCSP uv_csp ;
  int has_alpha ;
  int width ;
  int height ;
  int y_stride ;
  int uv_width ;
  int uv_height ;
  int uv_stride ;
  int uv0_stride ;
  int a_width ;
  int a_stride ;
  uint64_t y_size ;
  uint64_t uv_size ;
  uint64_t uv0_size ;
  uint64_t a_size ;
  uint64_t total_size ;
  uint8_t *mem ;
  int tmp ;
  void *__cil_tmp20 ;
  void *memory ;
  uint64_t argb_size ;

  {
#line 44
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
#line 45
    uv_csp = (enum WebPEncCSP )((unsigned int )picture->colorspace & 3U);
#line 46
    has_alpha = (int )((unsigned int )picture->colorspace & 4U);
#line 47
    width = picture->width;
#line 48
    height = picture->height;
#line 50
    if (! picture->use_argb) {
#line 51
      y_stride = width;
#line 52
      uv_width = (width + 1) >> 1;
#line 53
      uv_height = (height + 1) >> 1;
#line 54
      uv_stride = uv_width;
#line 55
      uv0_stride = 0;
#line 62
      if ((unsigned int )uv_csp == 0U) {
#line 62
        goto case_0;
      }
#line 74
      goto switch_default;
      case_0: 
#line 63
      goto switch_break;
      switch_default: 
#line 75
      return (0);
      switch_break: 
#line 77
      uv0_size = (uint64_t )(height * uv0_stride);
#line 80
      if (has_alpha) {
#line 80
        tmp = width;
      } else {
#line 80
        tmp = 0;
      }
#line 80
      a_width = tmp;
#line 81
      a_stride = a_width;
#line 82
      y_size = (uint64_t )y_stride * (unsigned long )height;
#line 83
      uv_size = (uint64_t )uv_stride * (unsigned long )uv_height;
#line 84
      a_size = (uint64_t )a_stride * (unsigned long )height;
#line 86
      total_size = ((y_size + a_size) + 2UL * uv_size) + 2UL * uv0_size;
#line 89
      if (width <= 0) {
#line 91
        return (0);
      } else
#line 89
      if (height <= 0) {
#line 91
        return (0);
      } else
#line 89
      if (uv_width < 0) {
#line 91
        return (0);
      } else
#line 89
      if (uv_height < 0) {
#line 91
        return (0);
      }
      {
#line 94
      WebPPictureFree(picture);
#line 95
      __cil_tmp20 = WebPSafeMalloc(total_size, sizeof(*mem));
#line 95
      mem = (uint8_t *)__cil_tmp20;
      }
#line 96
      if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 96
        return (0);
      }
#line 99
      picture->memory_ = (void *)mem;
#line 100
      picture->y_stride = y_stride;
#line 101
      picture->uv_stride = uv_stride;
#line 102
      picture->a_stride = a_stride;
#line 103
      picture->uv0_stride = uv0_stride;
#line 105
      picture->y = mem;
#line 106
      mem += y_size;
#line 108
      picture->u = mem;
#line 109
      mem += uv_size;
#line 110
      picture->v = mem;
#line 111
      mem += uv_size;
#line 113
      if (a_size) {
#line 114
        picture->a = mem;
#line 115
        mem += a_size;
      }
#line 117
      if (uv0_size) {
#line 118
        picture->u0 = mem;
#line 119
        mem += uv0_size;
#line 120
        picture->v0 = mem;
#line 121
        mem += uv0_size;
      }
    } else {
#line 125
      argb_size = (uint64_t )width * (unsigned long )height;
#line 126
      if (width <= 0) {
#line 127
        return (0);
      } else
#line 126
      if (height <= 0) {
#line 127
        return (0);
      }
      {
#line 130
      WebPPictureFree(picture);
#line 131
      memory = WebPSafeMalloc(argb_size, sizeof(*(picture->argb)));
      }
#line 132
      if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 132
        return (0);
      }
#line 135
      picture->memory_argb_ = memory;
#line 136
      picture->argb = (uint32_t *)memory;
#line 137
      picture->argb_stride = width;
    }
  }
#line 140
  return (1);
}
}
#line 144 "/root/patchweave_new/13/src/enc/picture.c"
static void PictureResetARGB(WebPPicture *picture ) 
{ 


  {
#line 145
  picture->memory_argb_ = (void *)0;
#line 146
  picture->argb = (uint32_t *)((void *)0);
#line 147
  picture->argb_stride = 0;
#line 148
  return;
}
}
#line 151 "/root/patchweave_new/13/src/enc/picture.c"
static void PictureResetYUVA(WebPPicture *picture ) 
{ 


  {
#line 152
  picture->memory_ = (void *)0;
#line 153
  picture->a = (uint8_t *)((void *)0);
#line 153
  picture->v = picture->a;
#line 153
  picture->u = picture->v;
#line 153
  picture->y = picture->u;
#line 154
  picture->v0 = (uint8_t *)((void *)0);
#line 154
  picture->u0 = picture->v0;
#line 155
  picture->uv_stride = 0;
#line 155
  picture->y_stride = picture->uv_stride;
#line 156
  picture->a_stride = 0;
#line 157
  picture->uv0_stride = 0;
#line 158
  return;
}
}
#line 162 "/root/patchweave_new/13/src/enc/picture.c"
static void WebPPictureGrabSpecs(WebPPicture *src , WebPPicture *dst ) 
{ 


  {
  {
#line 165
  *dst = *src;
#line 166
  PictureResetYUVA(dst);
#line 167
  PictureResetARGB(dst);
  }
#line 169
  return;
}
}
#line 172 "/root/patchweave_new/13/src/enc/picture.c"
static int PictureAllocARGB(WebPPicture *picture ) 
{ 
  WebPPicture tmp ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 174
  free(picture->memory_argb_);
#line 175
  PictureResetARGB(picture);
#line 176
  picture->use_argb = 1;
#line 177
  WebPPictureGrabSpecs(picture, & tmp);
#line 178
  __cil_tmp3 = WebPPictureAlloc(& tmp);
  }
#line 178
  if (! __cil_tmp3) {
    {
#line 179
    __cil_tmp4 = WebPEncodingSetError(picture, (enum WebPEncodingError___0 )((enum WebPEncodingError )1));
    }
#line 179
    return (__cil_tmp4);
  }
#line 181
  picture->memory_argb_ = tmp.memory_argb_;
#line 182
  picture->argb = tmp.argb;
#line 183
  picture->argb_stride = tmp.argb_stride;
#line 184
  return (1);
}
}
#line 188 "/root/patchweave_new/13/src/enc/picture.c"
void WebPPictureFree(WebPPicture *picture ) 
{ 


  {
#line 189
  if ((unsigned long )picture != (unsigned long )((void *)0)) {
    {
#line 190
    free(picture->memory_);
#line 191
    free(picture->memory_argb_);
#line 192
    PictureResetYUVA(picture);
#line 193
    PictureResetARGB(picture);
    }
  }
#line 196
  return;
}
}
#line 201 "/root/patchweave_new/13/src/enc/picture.c"
static void CopyPlane(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                      int width , int height ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    __cil_tmp7 = height;
#line 203
    height --;
#line 203
    if (! (__cil_tmp7 > 0)) {
#line 203
      goto while_break;
    }
    {
#line 204
    memcpy((void *)dst, (void const   *)src, (unsigned long )width);
#line 205
    src += src_stride;
#line 206
    dst += dst_stride;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 211
  return;
}
}
#line 211 "/root/patchweave_new/13/src/enc/picture.c"
static void SnapTopLeftPosition(WebPPicture *pic , int *left , int *top ) 
{ 
  int is_yuv422 ;

  {
#line 213
  if (! pic->use_argb) {
#line 214
    is_yuv422 = ((unsigned int )pic->colorspace & 3U) == 1U;
#line 215
    if (((unsigned int )pic->colorspace & 3U) == 0U) {
      _L: 
#line 216
      *left &= -2;
#line 217
      if (! is_yuv422) {
#line 217
        *top &= -2;
      }
    } else
#line 215
    if (is_yuv422) {
#line 215
      goto _L;
    }
  }
#line 218
  return;
}
}
#line 223 "/root/patchweave_new/13/src/enc/picture.c"
static int AdjustAndCheckRectangle(WebPPicture *pic , int *left , int *top , int width ,
                                   int height ) 
{ 


  {
  {
#line 226
  SnapTopLeftPosition(pic, left, top);
  }
#line 227
  if (*left < 0) {
#line 227
    return (0);
  } else
#line 227
  if (*top < 0) {
#line 227
    return (0);
  }
#line 228
  if (width <= 0) {
#line 228
    return (0);
  } else
#line 228
  if (height <= 0) {
#line 228
    return (0);
  }
#line 229
  if (*left + width > pic->width) {
#line 229
    return (0);
  }
#line 230
  if (*top + height > pic->height) {
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 234 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureCopy(WebPPicture *src , WebPPicture *dst ) 
{ 
  int __cil_tmp3 ;

  {
#line 235
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 235
    return (0);
  } else
#line 235
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 235
    return (0);
  }
#line 236
  if ((unsigned long )src == (unsigned long )dst) {
#line 236
    return (1);
  }
  {
#line 238
  WebPPictureGrabSpecs(src, dst);
#line 239
  __cil_tmp3 = WebPPictureAlloc(dst);
  }
#line 239
  if (! __cil_tmp3) {
#line 239
    return (0);
  }
#line 241
  if (! src->use_argb) {
    {
#line 242
    CopyPlane(src->y, src->y_stride, dst->y, dst->y_stride, dst->width, dst->height);
#line 244
    CopyPlane(src->u, src->uv_stride, dst->u, dst->uv_stride, (dst->width + 1) >> 1,
              (dst->height + 1) >> 1);
#line 246
    CopyPlane(src->v, src->uv_stride, dst->v, dst->uv_stride, (dst->width + 1) >> 1,
              (dst->height + 1) >> 1);
    }
#line 248
    if ((unsigned long )dst->a != (unsigned long )((void *)0)) {
      {
#line 249
      CopyPlane(src->a, src->a_stride, dst->a, dst->a_stride, dst->width, dst->height);
      }
    }
  } else {
    {
#line 265
    CopyPlane((uint8_t *)src->argb, 4 * src->argb_stride, (uint8_t *)dst->argb, 4 * dst->argb_stride,
              4 * dst->width, dst->height);
    }
  }
#line 269
  return (1);
}
}
#line 272 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureIsView(WebPPicture *picture ) 
{ 


  {
#line 273
  if ((unsigned long )picture == (unsigned long )((void *)0)) {
#line 273
    return (0);
  }
#line 274
  if (picture->use_argb) {
#line 275
    return ((unsigned long )picture->memory_argb_ == (unsigned long )((void *)0));
  }
#line 277
  return ((unsigned long )picture->memory_ == (unsigned long )((void *)0));
}
}
#line 280 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureView(WebPPicture *src , int left , int top , int width , int height ,
                    WebPPicture *dst ) 
{ 
  int __cil_tmp7 ;

  {
#line 283
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 283
    return (0);
  } else
#line 283
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 283
    return (0);
  }
  {
#line 286
  __cil_tmp7 = AdjustAndCheckRectangle(src, & left, & top, width, height);
  }
#line 286
  if (! __cil_tmp7) {
#line 286
    return (0);
  }
#line 288
  if ((unsigned long )src != (unsigned long )dst) {
    {
#line 289
    WebPPictureGrabSpecs(src, dst);
    }
  }
#line 291
  dst->width = width;
#line 292
  dst->height = height;
#line 293
  if (! src->use_argb) {
#line 294
    dst->y = (src->y + top * src->y_stride) + left;
#line 295
    dst->u = (src->u + (top >> 1) * src->uv_stride) + (left >> 1);
#line 296
    dst->v = (src->v + (top >> 1) * src->uv_stride) + (left >> 1);
#line 297
    dst->y_stride = src->y_stride;
#line 298
    dst->uv_stride = src->uv_stride;
#line 299
    if ((unsigned long )src->a != (unsigned long )((void *)0)) {
#line 300
      dst->a = (src->a + top * src->a_stride) + left;
#line 301
      dst->a_stride = src->a_stride;
    }
  } else {
#line 313
    dst->argb = (src->argb + top * src->argb_stride) + left;
#line 314
    dst->argb_stride = src->argb_stride;
  }
#line 316
  return (1);
}
}
#line 322 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureCrop(WebPPicture *pic , int left , int top , int width , int height ) 
{ 
  WebPPicture tmp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int y_offset ;
  int uv_offset ;
  int a_offset ;
  uint8_t *src ;

  {
#line 326
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 326
    return (0);
  }
  {
#line 327
  __cil_tmp7 = AdjustAndCheckRectangle(pic, & left, & top, width, height);
  }
#line 327
  if (! __cil_tmp7) {
#line 327
    return (0);
  }
  {
#line 329
  WebPPictureGrabSpecs(pic, & tmp);
#line 330
  tmp.width = width;
#line 331
  tmp.height = height;
#line 332
  __cil_tmp8 = WebPPictureAlloc(& tmp);
  }
#line 332
  if (! __cil_tmp8) {
#line 332
    return (0);
  }
#line 334
  if (! pic->use_argb) {
    {
#line 335
    y_offset = top * pic->y_stride + left;
#line 336
    uv_offset = (top / 2) * pic->uv_stride + left / 2;
#line 337
    CopyPlane(pic->y + y_offset, pic->y_stride, tmp.y, tmp.y_stride, width, height);
#line 339
    CopyPlane(pic->u + uv_offset, pic->uv_stride, tmp.u, tmp.uv_stride, (width + 1) >> 1,
              (height + 1) >> 1);
#line 341
    CopyPlane(pic->v + uv_offset, pic->uv_stride, tmp.v, tmp.uv_stride, (width + 1) >> 1,
              (height + 1) >> 1);
    }
#line 344
    if ((unsigned long )tmp.a != (unsigned long )((void *)0)) {
      {
#line 345
      a_offset = top * pic->a_stride + left;
#line 346
      CopyPlane(pic->a + a_offset, pic->a_stride, tmp.a, tmp.a_stride, width, height);
      }
    }
  } else {
    {
#line 364
    src = (uint8_t *)((pic->argb + top * pic->argb_stride) + left);
#line 366
    CopyPlane(src, pic->argb_stride * 4, (uint8_t *)tmp.argb, tmp.argb_stride * 4,
              width * 4, height);
    }
  }
  {
#line 370
  WebPPictureFree(pic);
#line 371
  *pic = tmp;
  }
#line 372
  return (1);
}
}
#line 378 "/root/patchweave_new/13/src/enc/picture.c"
static void RescalePlane(uint8_t *src , int src_width , int src_height , int src_stride ,
                         uint8_t *dst , int dst_width , int dst_height , int dst_stride ,
                         int32_t *work , int num_channels ) 
{ 
  WebPRescaler rescaler ;
  int y ;
  int __cil_tmp13 ;

  {
  {
#line 385
  y = 0;
#line 386
  WebPRescalerInit(& rescaler, src_width, src_height, dst, dst_width, dst_height,
                   dst_stride, num_channels, src_width, dst_width, src_height, dst_height,
                   work);
#line 392
  memset((void *)work, 0, (unsigned long )((2 * dst_width) * num_channels) * sizeof(*work));
  }
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;

#line 393
    if (! (y < src_height)) {
#line 393
      goto while_break;
    }
    {
#line 394
    __cil_tmp13 = WebPRescalerImport(& rescaler, src_height - y, src + y * src_stride,
                                     src_stride);
#line 394
    y += __cil_tmp13;
#line 396
    WebPRescalerExport(& rescaler);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 401
  return;
}
}
#line 400 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureRescale(WebPPicture *pic , int width , int height ) 
{ 
  WebPPicture tmp ;
  int prev_width ;
  int prev_height ;
  int32_t *work ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
#line 405
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 405
    return (0);
  }
#line 406
  prev_width = pic->width;
#line 407
  prev_height = pic->height;
#line 409
  if (width == 0) {
#line 410
    width = (prev_width * height + prev_height / 2) / prev_height;
  }
#line 413
  if (height == 0) {
#line 414
    height = (prev_height * width + prev_width / 2) / prev_width;
  }
#line 417
  if (width <= 0) {
#line 417
    return (0);
  } else
#line 417
  if (height <= 0) {
#line 417
    return (0);
  }
  {
#line 419
  WebPPictureGrabSpecs(pic, & tmp);
#line 420
  tmp.width = width;
#line 421
  tmp.height = height;
#line 422
  __cil_tmp8 = WebPPictureAlloc(& tmp);
  }
#line 422
  if (! __cil_tmp8) {
#line 422
    return (0);
  }
#line 424
  if (! pic->use_argb) {
    {
#line 425
    __cil_tmp9 = WebPSafeMalloc((uint64_t )(2ULL * (unsigned long long )width), sizeof(*work));
#line 425
    work = (int32_t *)__cil_tmp9;
    }
#line 426
    if ((unsigned long )work == (unsigned long )((void *)0)) {
      {
#line 427
      WebPPictureFree(& tmp);
      }
#line 428
      return (0);
    }
    {
#line 431
    RescalePlane(pic->y, prev_width, prev_height, pic->y_stride, tmp.y, width, height,
                 tmp.y_stride, work, 1);
#line 433
    RescalePlane(pic->u, (prev_width + 1) >> 1, (prev_height + 1) >> 1, pic->uv_stride,
                 tmp.u, (width + 1) >> 1, (height + 1) >> 1, tmp.uv_stride, work,
                 1);
#line 437
    RescalePlane(pic->v, (prev_width + 1) >> 1, (prev_height + 1) >> 1, pic->uv_stride,
                 tmp.v, (width + 1) >> 1, (height + 1) >> 1, tmp.uv_stride, work,
                 1);
    }
#line 442
    if ((unsigned long )tmp.a != (unsigned long )((void *)0)) {
      {
#line 443
      RescalePlane(pic->a, prev_width, prev_height, pic->a_stride, tmp.a, width, height,
                   tmp.a_stride, work, 1);
      }
    }
  } else {
    {
#line 458
    __cil_tmp10 = WebPSafeMalloc((uint64_t )((2ULL * (unsigned long long )width) * 4ULL),
                                 sizeof(*work));
#line 458
    work = (int32_t *)__cil_tmp10;
    }
#line 459
    if ((unsigned long )work == (unsigned long )((void *)0)) {
      {
#line 460
      WebPPictureFree(& tmp);
      }
#line 461
      return (0);
    }
    {
#line 464
    RescalePlane((uint8_t *)pic->argb, prev_width, prev_height, pic->argb_stride * 4,
                 (uint8_t *)tmp.argb, width, height, tmp.argb_stride * 4, work, 4);
    }
  }
  {
#line 470
  WebPPictureFree(pic);
#line 471
  free((void *)work);
#line 472
  *pic = tmp;
  }
#line 473
  return (1);
}
}
#line 479 "/root/patchweave_new/13/src/enc/picture.c"
void WebPMemoryWriterInit(WebPMemoryWriter *writer ) 
{ 


  {
#line 480
  writer->mem = (uint8_t *)((void *)0);
#line 481
  writer->size = (size_t )0;
#line 482
  writer->max_size = (size_t )0;
#line 483
  return;
}
}
#line 485 "/root/patchweave_new/13/src/enc/picture.c"
int WebPMemoryWrite(uint8_t *data , size_t data_size , WebPPicture *picture ) 
{ 
  WebPMemoryWriter *w ;
  uint64_t next_size ;
  uint8_t *new_mem ;
  uint64_t next_max_size ;
  void *__cil_tmp8 ;

  {
#line 487
  w = (WebPMemoryWriter *)picture->custom_ptr;
#line 489
  if ((unsigned long )w == (unsigned long )((void *)0)) {
#line 490
    return (1);
  }
#line 492
  next_size = w->size + data_size;
#line 493
  if (next_size > w->max_size) {
#line 495
    next_max_size = (uint64_t )(2ULL * (unsigned long long )w->max_size);
#line 496
    if (next_max_size < next_size) {
#line 496
      next_max_size = next_size;
    }
#line 497
    if ((unsigned long long )next_max_size < 8192ULL) {
#line 497
      next_max_size = (uint64_t )8192ULL;
    }
    {
#line 498
    __cil_tmp8 = WebPSafeMalloc(next_max_size, (size_t )1);
#line 498
    new_mem = (uint8_t *)__cil_tmp8;
    }
#line 499
    if ((unsigned long )new_mem == (unsigned long )((void *)0)) {
#line 500
      return (0);
    }
#line 502
    if (w->size > 0UL) {
      {
#line 503
      memcpy((void *)new_mem, (void const   *)w->mem, w->size);
      }
    }
    {
#line 505
    free((void *)w->mem);
#line 506
    w->mem = new_mem;
#line 508
    w->max_size = next_max_size;
    }
  }
#line 510
  if (data_size > 0UL) {
    {
#line 511
    memcpy((void *)(w->mem + w->size), (void const   *)data, data_size);
#line 512
    w->size += data_size;
    }
  }
#line 514
  return (1);
}
}
#line 521 "/root/patchweave_new/13/src/enc/picture.c"
static int CheckNonOpaque(uint8_t *alpha , int width , int height , int x_step , int y_step ) 
{ 
  int __cil_tmp6 ;
  int x ;

  {
#line 523
  if ((unsigned long )alpha == (unsigned long )((void *)0)) {
#line 523
    return (0);
  }
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    __cil_tmp6 = height;
#line 524
    height --;
#line 524
    if (! (__cil_tmp6 > 0)) {
#line 524
      goto while_break;
    }
#line 526
    x = 0;
    {
#line 526
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 526
      if (! (x < width * x_step)) {
#line 526
        goto while_break___0;
      }
#line 527
      if ((int )*(alpha + x) != 255) {
#line 527
        return (1);
      }
#line 526
      x += x_step;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 529
    alpha += y_step;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 531
  return (0);
}
}
#line 535 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureHasTransparency(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;
  int x ;
  int y ;
  uint32_t *argb ;

  {
#line 536
  if ((unsigned long )picture == (unsigned long )((void *)0)) {
#line 536
    return (0);
  }
#line 537
  if (! picture->use_argb) {
    {
#line 538
    __cil_tmp2 = CheckNonOpaque(picture->a, picture->width, picture->height, 1, picture->a_stride);
    }
#line 538
    return (__cil_tmp2);
  } else {
#line 542
    argb = picture->argb;
#line 543
    if ((unsigned long )argb == (unsigned long )((void *)0)) {
#line 543
      return (0);
    }
#line 544
    y = 0;
    {
#line 544
    while (1) {
      while_continue: /* CIL Label */ ;

#line 544
      if (! (y < picture->height)) {
#line 544
        goto while_break;
      }
#line 545
      x = 0;
      {
#line 545
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 545
        if (! (x < picture->width)) {
#line 545
          goto while_break___0;
        }
#line 546
        if (*(argb + x) < 4278190080U) {
#line 546
          return (1);
        }
#line 545
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 548
      argb += picture->argb_stride;
#line 544
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 551
  return (0);
}
}
#line 583 "/root/patchweave_new/13/src/enc/picture.c"
static void MakeGray(WebPPicture *picture ) 
{ 
  int y ;
  int uv_width ;
  int uv_height ;

  {
#line 585
  uv_width = (picture->width + 1) >> 1;
#line 586
  uv_height = (picture->height + 1) >> 1;
#line 587
  y = 0;
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;

#line 587
    if (! (y < uv_height)) {
#line 587
      goto while_break;
    }
    {
#line 588
    memset((void *)(picture->u + y * picture->uv_stride), 128, (unsigned long )uv_width);
#line 589
    memset((void *)(picture->v + y * picture->uv_stride), 128, (unsigned long )uv_width);
#line 587
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 591
  return;
}
}
#line 593 "/root/patchweave_new/13/src/enc/picture.c"
static int ImportYUVAFromRGBA(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr , uint8_t *a_ptr ,
                              int step , int rgb_stride , WebPPicture *picture ) 
{ 
  enum WebPEncCSP uv_csp ;
  int x ;
  int y ;
  int width ;
  int height ;
  int has_alpha ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int offset ;
  int __cil_tmp17 ;
  int src ;
  int dst ;
  int r ;
  int g ;
  int b ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int src___0 ;
  int dst___0 ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int src___1 ;
  int dst___1 ;
  int r___1 ;
  int g___1 ;
  int b___1 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int src___2 ;
  int dst___2 ;
  int r___2 ;
  int g___2 ;
  int b___2 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;

  {
  {
#line 600
  uv_csp = (enum WebPEncCSP )((unsigned int )picture->colorspace & 3U);
#line 602
  width = picture->width;
#line 603
  height = picture->height;
#line 604
  __cil_tmp14 = CheckNonOpaque(a_ptr, width, height, step, rgb_stride);
#line 604
  has_alpha = __cil_tmp14;
#line 606
  picture->colorspace = (enum WebPEncCSP___0 )uv_csp;
#line 607
  picture->use_argb = 0;
  }
#line 608
  if (has_alpha) {
#line 609
    picture->colorspace = (enum WebPEncCSP___0 )((unsigned int )picture->colorspace | 4U);
  }
  {
#line 611
  __cil_tmp15 = WebPPictureAlloc(picture);
  }
#line 611
  if (! __cil_tmp15) {
#line 611
    return (0);
  }
#line 614
  y = 0;
  {
#line 614
  while (1) {
    while_continue: /* CIL Label */ ;

#line 614
    if (! (y < height)) {
#line 614
      goto while_break;
    }
#line 615
    x = 0;
    {
#line 615
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 615
      if (! (x < width)) {
#line 615
        goto while_break___0;
      }
      {
#line 616
      offset = step * x + y * rgb_stride;
#line 617
      __cil_tmp17 = VP8RGBToY((int )*(r_ptr + offset), (int )*(g_ptr + offset), (int )*(b_ptr + offset));
#line 617
      *(picture->y + (x + y * picture->y_stride)) = (uint8_t )__cil_tmp17;
#line 615
      x ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: 
#line 614
    y ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: ;
#line 623
  if ((unsigned int )uv_csp != 3U) {
#line 624
    y = 0;
    {
#line 624
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 624
      if (! (y < height >> 1)) {
#line 624
        goto while_break___1;
      }
#line 625
      x = 0;
      {
#line 625
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 625
        if (! (x < width >> 1)) {
#line 625
          goto while_break___2;
        }
        {
#line 626
        src = 2 * (step * x + y * rgb_stride);
#line 626
        dst = x + y * picture->uv_stride;
#line 626
        r = (((int )*((r_ptr + src) + 0) + (int )*((r_ptr + src) + step)) + (int )*((r_ptr + src) + rgb_stride)) + (int )*((r_ptr + src) + (rgb_stride + step));
#line 626
        g = (((int )*((g_ptr + src) + 0) + (int )*((g_ptr + src) + step)) + (int )*((g_ptr + src) + rgb_stride)) + (int )*((g_ptr + src) + (rgb_stride + step));
#line 626
        b = (((int )*((b_ptr + src) + 0) + (int )*((b_ptr + src) + step)) + (int )*((b_ptr + src) + rgb_stride)) + (int )*((b_ptr + src) + (rgb_stride + step));
#line 626
        __cil_tmp23 = VP8RGBToU(r, g, b);
#line 626
        *(picture->u + dst) = (uint8_t )__cil_tmp23;
#line 626
        __cil_tmp24 = VP8RGBToV(r, g, b);
#line 626
        *(picture->v + dst) = (uint8_t )__cil_tmp24;
#line 625
        x ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___2: ;
#line 628
      if (width & 1) {
        {
#line 629
        src___0 = 2 * (step * x + y * rgb_stride);
#line 629
        dst___0 = x + y * picture->uv_stride;
#line 629
        r___0 = 2 * (int )*((r_ptr + src___0) + 0) + 2 * (int )*((r_ptr + src___0) + rgb_stride);
#line 629
        g___0 = 2 * (int )*((g_ptr + src___0) + 0) + 2 * (int )*((g_ptr + src___0) + rgb_stride);
#line 629
        b___0 = 2 * (int )*((b_ptr + src___0) + 0) + 2 * (int )*((b_ptr + src___0) + rgb_stride);
#line 629
        __cil_tmp30 = VP8RGBToU(r___0, g___0, b___0);
#line 629
        *(picture->u + dst___0) = (uint8_t )__cil_tmp30;
#line 629
        __cil_tmp31 = VP8RGBToV(r___0, g___0, b___0);
#line 629
        *(picture->v + dst___0) = (uint8_t )__cil_tmp31;
        }
      }
#line 624
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___1: ;
#line 632
    if (height & 1) {
#line 633
      x = 0;
      {
#line 633
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 633
        if (! (x < width >> 1)) {
#line 633
          goto while_break___3;
        }
        {
#line 634
        src___1 = 2 * (step * x + y * rgb_stride);
#line 634
        dst___1 = x + y * picture->uv_stride;
#line 634
        r___1 = 2 * (int )*((r_ptr + src___1) + 0) + 2 * (int )*((r_ptr + src___1) + step);
#line 634
        g___1 = 2 * (int )*((g_ptr + src___1) + 0) + 2 * (int )*((g_ptr + src___1) + step);
#line 634
        b___1 = 2 * (int )*((b_ptr + src___1) + 0) + 2 * (int )*((b_ptr + src___1) + step);
#line 634
        __cil_tmp37 = VP8RGBToU(r___1, g___1, b___1);
#line 634
        *(picture->u + dst___1) = (uint8_t )__cil_tmp37;
#line 634
        __cil_tmp38 = VP8RGBToV(r___1, g___1, b___1);
#line 634
        *(picture->v + dst___1) = (uint8_t )__cil_tmp38;
#line 633
        x ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: ;
#line 636
      if (width & 1) {
        {
#line 637
        src___2 = 2 * (step * x + y * rgb_stride);
#line 637
        dst___2 = x + y * picture->uv_stride;
#line 637
        r___2 = 4 * (int )*((r_ptr + src___2) + 0);
#line 637
        g___2 = 4 * (int )*((g_ptr + src___2) + 0);
#line 637
        b___2 = 4 * (int )*((b_ptr + src___2) + 0);
#line 637
        __cil_tmp44 = VP8RGBToU(r___2, g___2, b___2);
#line 637
        *(picture->u + dst___2) = (uint8_t )__cil_tmp44;
#line 637
        __cil_tmp45 = VP8RGBToV(r___2, g___2, b___2);
#line 637
        *(picture->v + dst___2) = (uint8_t )__cil_tmp45;
        }
      }
    }
  } else {
    {
#line 661
    MakeGray(picture);
    }
  }
#line 664
  if (has_alpha) {
#line 666
    y = 0;
    {
#line 666
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 666
      if (! (y < height)) {
#line 666
        goto while_break___4;
      }
#line 667
      x = 0;
      {
#line 667
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 667
        if (! (x < width)) {
#line 667
          goto while_break___5;
        }
#line 668
        *(picture->a + (x + y * picture->a_stride)) = *(a_ptr + (step * x + y * rgb_stride));
#line 667
        x ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___5: 
#line 666
      y ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___4: ;
  }
#line 673
  return (1);
}
}
#line 676 "/root/patchweave_new/13/src/enc/picture.c"
static int Import(WebPPicture *picture , uint8_t *rgb , int rgb_stride , int step ,
                  int swap_rb , int import_alpha ) 
{ 
  uint8_t *r_ptr ;
  int tmp ;
  uint8_t *g_ptr ;
  uint8_t *b_ptr ;
  int tmp___0 ;
  uint8_t *a_ptr ;
  uint8_t *tmp___1 ;
  int width ;
  int height ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int x ;
  int y ;
  int offset ;
  uint32_t argb ;
  uint32_t __cil_tmp22 ;
  int x___0 ;
  int y___0 ;
  int offset___0 ;
  uint32_t argb___0 ;

  {
#line 679
  if (swap_rb) {
#line 679
    tmp = 2;
  } else {
#line 679
    tmp = 0;
  }
#line 679
  r_ptr = rgb + tmp;
#line 680
  g_ptr = rgb + 1;
#line 681
  if (swap_rb) {
#line 681
    tmp___0 = 0;
  } else {
#line 681
    tmp___0 = 2;
  }
#line 681
  b_ptr = rgb + tmp___0;
#line 682
  if (import_alpha) {
#line 682
    tmp___1 = rgb + 3;
  } else {
#line 682
    tmp___1 = (uint8_t *)((void *)0);
  }
#line 682
  a_ptr = tmp___1;
#line 683
  width = picture->width;
#line 684
  height = picture->height;
#line 686
  if (! picture->use_argb) {
    {
#line 687
    __cil_tmp16 = ImportYUVAFromRGBA(r_ptr, g_ptr, b_ptr, a_ptr, step, rgb_stride,
                                     picture);
    }
#line 687
    return (__cil_tmp16);
  }
#line 690
  if (import_alpha) {
#line 691
    picture->colorspace = (enum WebPEncCSP___0 )((unsigned int )picture->colorspace | 4U);
  } else {
#line 693
    picture->colorspace = (enum WebPEncCSP___0 )((unsigned int )picture->colorspace & 4294967291U);
  }
  {
#line 695
  __cil_tmp17 = WebPPictureAlloc(picture);
  }
#line 695
  if (! __cil_tmp17) {
#line 695
    return (0);
  }
#line 697
  if (! import_alpha) {
#line 699
    y = 0;
    {
#line 699
    while (1) {
      while_continue: /* CIL Label */ ;

#line 699
      if (! (y < height)) {
#line 699
        goto while_break;
      }
#line 700
      x = 0;
      {
#line 700
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 700
        if (! (x < width)) {
#line 700
          goto while_break___0;
        }
        {
#line 701
        offset = step * x + y * rgb_stride;
#line 702
        __cil_tmp22 = MakeARGB32((int )*(r_ptr + offset), (int )*(g_ptr + offset),
                                 (int )*(b_ptr + offset));
#line 702
        argb = __cil_tmp22;
#line 704
        *(picture->argb + (x + y * picture->argb_stride)) = argb;
#line 700
        x ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
#line 699
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 710
    y___0 = 0;
    {
#line 710
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 710
      if (! (y___0 < height)) {
#line 710
        goto while_break___1;
      }
#line 711
      x___0 = 0;
      {
#line 711
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 711
        if (! (x___0 < width)) {
#line 711
          goto while_break___2;
        }
#line 712
        offset___0 = step * x___0 + y___0 * rgb_stride;
#line 713
        argb___0 = (((unsigned int )((int )*(a_ptr + offset___0) << 24) | (unsigned int )((int )*(r_ptr + offset___0) << 16)) | (unsigned int )((int )*(g_ptr + offset___0) << 8)) | (unsigned int )*(b_ptr + offset___0);
#line 717
        *(picture->argb + (x___0 + y___0 * picture->argb_stride)) = argb___0;
#line 711
        x___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 710
      y___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 721
  return (1);
}
}
#line 729 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureImportRGB(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 731
  __cil_tmp4 = Import(picture, rgb, rgb_stride, 3, 0, 0);
  }
#line 731
  return (__cil_tmp4);
}
}
#line 734 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureImportBGR(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 736
  __cil_tmp4 = Import(picture, rgb, rgb_stride, 3, 1, 0);
  }
#line 736
  return (__cil_tmp4);
}
}
#line 739 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureImportRGBA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 741
  __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 0, 1);
  }
#line 741
  return (__cil_tmp4);
}
}
#line 744 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureImportBGRA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 746
  __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 1, 1);
  }
#line 746
  return (__cil_tmp4);
}
}
#line 749 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureImportRGBX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 751
  __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 0, 0);
  }
#line 751
  return (__cil_tmp4);
}
}
#line 754 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureImportBGRX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 756
  __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 1, 0);
  }
#line 756
  return (__cil_tmp4);
}
}
#line 762 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureYUVAToARGB(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int y ;
  int width ;
  int height ;
  int argb_stride ;
  uint8_t *dst ;
  uint8_t *cur_u ;
  uint8_t *cur_v ;
  uint8_t *cur_y ;
  void (*upsample)(uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                   uint8_t * , uint8_t * , int  ) ;
  void (*__cil_tmp15)(uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                      uint8_t * , uint8_t * , uint8_t * , int  ) ;
  uint8_t *top_u ;
  uint8_t *top_v ;
  uint32_t *argb_dst ;
  uint8_t *src ;
  int x ;

  {
#line 763
  if ((unsigned long )picture == (unsigned long )((void *)0)) {
#line 763
    return (0);
  }
#line 764
  if ((unsigned long )picture->memory_ == (unsigned long )((void *)0)) {
    {
#line 766
    __cil_tmp2 = WebPEncodingSetError(picture, (enum WebPEncodingError___0 )((enum WebPEncodingError )3));
    }
#line 766
    return (__cil_tmp2);
  } else
#line 764
  if ((unsigned long )picture->y == (unsigned long )((void *)0)) {
    {
#line 766
    __cil_tmp2 = WebPEncodingSetError(picture, (enum WebPEncodingError___0 )((enum WebPEncodingError )3));
    }
#line 766
    return (__cil_tmp2);
  } else
#line 764
  if ((unsigned long )picture->u == (unsigned long )((void *)0)) {
    {
#line 766
    __cil_tmp2 = WebPEncodingSetError(picture, (enum WebPEncodingError___0 )((enum WebPEncodingError )3));
    }
#line 766
    return (__cil_tmp2);
  } else
#line 764
  if ((unsigned long )picture->v == (unsigned long )((void *)0)) {
    {
#line 766
    __cil_tmp2 = WebPEncodingSetError(picture, (enum WebPEncodingError___0 )((enum WebPEncodingError )3));
    }
#line 766
    return (__cil_tmp2);
  }
#line 768
  if ((unsigned long )picture->a == (unsigned long )((void *)0)) {
#line 768
    if ((unsigned int )picture->colorspace & 4U) {
      {
#line 769
      __cil_tmp3 = WebPEncodingSetError(picture, (enum WebPEncodingError___0 )((enum WebPEncodingError )3));
      }
#line 769
      return (__cil_tmp3);
    }
  }
#line 771
  if (((unsigned int )picture->colorspace & 3U) != 0U) {
    {
#line 772
    __cil_tmp4 = WebPEncodingSetError(picture, (enum WebPEncodingError___0 )((enum WebPEncodingError )4));
    }
#line 772
    return (__cil_tmp4);
  }
  {
#line 775
  __cil_tmp5 = PictureAllocARGB(picture);
  }
#line 775
  if (! __cil_tmp5) {
#line 775
    return (0);
  }
  {
#line 780
  width = picture->width;
#line 781
  height = picture->height;
#line 782
  argb_stride = 4 * picture->argb_stride;
#line 783
  dst = (uint8_t *)picture->argb;
#line 784
  cur_u = picture->u;
#line 784
  cur_v = picture->v;
#line 784
  cur_y = picture->y;
#line 785
  __cil_tmp15 = WebPGetLinePairConverter((int )test_endian.bytes[3] == 255);
#line 785
  upsample = __cil_tmp15;
#line 788
  (*upsample)((uint8_t *)((void *)0), cur_y, cur_u, cur_v, cur_u, cur_v, (uint8_t *)((void *)0),
              dst, width);
#line 789
  cur_y += picture->y_stride;
#line 790
  dst += argb_stride;
#line 792
  y = 1;
  }
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;

#line 792
    if (! (y + 1 < height)) {
#line 792
      goto while_break;
    }
    {
#line 793
    top_u = cur_u;
#line 794
    top_v = cur_v;
#line 795
    cur_u += picture->uv_stride;
#line 796
    cur_v += picture->uv_stride;
#line 797
    (*upsample)(cur_y, cur_y + picture->y_stride, top_u, top_v, cur_u, cur_v, dst,
                dst + argb_stride, width);
#line 799
    cur_y += 2 * picture->y_stride;
#line 800
    dst += 2 * argb_stride;
#line 792
    y += 2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 803
  if (height > 1) {
#line 803
    if (! (height & 1)) {
      {
#line 804
      (*upsample)(cur_y, (uint8_t *)((void *)0), cur_u, cur_v, cur_u, cur_v, dst,
                  (uint8_t *)((void *)0), width);
      }
    }
  }
#line 807
  if ((unsigned int )picture->colorspace & 4U) {
#line 808
    y = 0;
    {
#line 808
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 808
      if (! (y < height)) {
#line 808
        goto while_break___0;
      }
#line 809
      argb_dst = picture->argb + y * picture->argb_stride;
#line 810
      src = picture->a + y * picture->a_stride;
#line 812
      x = 0;
      {
#line 812
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 812
        if (! (x < width)) {
#line 812
          goto while_break___1;
        }
#line 813
        *(argb_dst + x) = (*(argb_dst + x) & 16777215U) | (unsigned int )((int )*(src + x) << 24);
#line 812
        x ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 808
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 818
  return (1);
}
}
#line 821 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureARGBToYUVA(WebPPicture *picture , enum WebPEncCSP colorspace ) 
{ 
  int __cil_tmp3 ;
  uint8_t *argb ;
  uint8_t *r ;
  uint8_t *tmp ;
  uint8_t *g ;
  uint8_t *tmp___0 ;
  uint8_t *b ;
  uint8_t *tmp___1 ;
  uint8_t *a ;
  uint8_t *tmp___2 ;
  WebPPicture tmp___3 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 822
  if ((unsigned long )picture == (unsigned long )((void *)0)) {
#line 822
    return (0);
  }
#line 823
  if ((unsigned long )picture->argb == (unsigned long )((void *)0)) {
    {
#line 824
    __cil_tmp3 = WebPEncodingSetError(picture, (enum WebPEncodingError___0 )((enum WebPEncodingError )3));
    }
#line 824
    return (__cil_tmp3);
  } else {
#line 826
    argb = (uint8_t *)picture->argb;
#line 827
    if ((int )test_endian.bytes[3] == 255) {
#line 827
      tmp = argb + 2;
    } else {
#line 827
      tmp = argb + 1;
    }
#line 827
    r = tmp;
#line 828
    if ((int )test_endian.bytes[3] == 255) {
#line 828
      tmp___0 = argb + 1;
    } else {
#line 828
      tmp___0 = argb + 2;
    }
#line 828
    g = tmp___0;
#line 829
    if ((int )test_endian.bytes[3] == 255) {
#line 829
      tmp___1 = argb + 0;
    } else {
#line 829
      tmp___1 = argb + 3;
    }
#line 829
    b = tmp___1;
#line 830
    if ((int )test_endian.bytes[3] == 255) {
#line 830
      tmp___2 = argb + 3;
    } else {
#line 830
      tmp___2 = argb + 0;
    }
    {
#line 830
    a = tmp___2;
#line 833
    tmp___3 = *picture;
#line 834
    PictureResetARGB(& tmp___3);
#line 835
    tmp___3.use_argb = 0;
#line 836
    tmp___3.colorspace = (enum WebPEncCSP___0 )((enum WebPEncCSP )((unsigned int )colorspace & 3U));
#line 837
    __cil_tmp14 = ImportYUVAFromRGBA(r, g, b, a, 4, 4 * picture->argb_stride, & tmp___3);
    }
#line 837
    if (! __cil_tmp14) {
      {
#line 838
      __cil_tmp15 = WebPEncodingSetError(picture, (enum WebPEncodingError___0 )((enum WebPEncodingError )1));
      }
#line 838
      return (__cil_tmp15);
    }
#line 841
    tmp___3.argb = picture->argb;
#line 842
    tmp___3.argb_stride = picture->argb_stride;
#line 843
    tmp___3.memory_argb_ = picture->memory_argb_;
#line 844
    *picture = tmp___3;
  }
#line 846
  return (1);
}
}
#line 854 "/root/patchweave_new/13/src/enc/picture.c"
static int is_transparent_area(uint8_t *ptr , int stride , int size ) 
{ 
  int y ;
  int x ;

  {
#line 856
  y = 0;
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;

#line 856
    if (! (y < size)) {
#line 856
      goto while_break;
    }
#line 857
    x = 0;
    {
#line 857
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 857
      if (! (x < size)) {
#line 857
        goto while_break___0;
      }
#line 858
      if (*(ptr + x)) {
#line 859
        return (0);
      }
#line 857
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 862
    ptr += stride;
#line 856
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 864
  return (1);
}
}
#line 867 "/root/patchweave_new/13/src/enc/picture.c"
__inline static void flatten(uint8_t *ptr , int v , int stride , int size ) 
{ 
  int y ;

  {
#line 869
  y = 0;
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;

#line 869
    if (! (y < size)) {
#line 869
      goto while_break;
    }
    {
#line 870
    memset((void *)ptr, v, (unsigned long )size);
#line 871
    ptr += stride;
#line 869
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 873
  return;
}
}
#line 875 "/root/patchweave_new/13/src/enc/picture.c"
void WebPCleanupTransparentArea(WebPPicture *pic ) 
{ 
  int x ;
  int y ;
  int w ;
  int h ;
  uint8_t *a_ptr ;
  int values[3] ;
  unsigned int tmp ;
  int need_reset ;
  int off_a ;
  int off_y ;
  int off_uv ;
  int __cil_tmp13 ;

  {
#line 878
  values[0] = 0;
#line 878
  tmp = 1U;
  {
#line 878
  while (1) {
    while_continue: /* CIL Label */ ;

#line 878
    if (tmp >= 3U) {
#line 878
      goto while_break;
    }
#line 878
    values[tmp] = 0;
#line 878
    tmp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 880
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 880
    return;
  }
#line 882
  a_ptr = pic->a;
#line 883
  if ((unsigned long )a_ptr == (unsigned long )((void *)0)) {
#line 883
    return;
  }
#line 885
  w = pic->width / 8;
#line 886
  h = pic->height / 8;
#line 887
  y = 0;
  {
#line 887
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 887
    if (! (y < h)) {
#line 887
      goto while_break___0;
    }
#line 888
    need_reset = 1;
#line 889
    x = 0;
    {
#line 889
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 889
      if (! (x < w)) {
#line 889
        goto while_break___1;
      }
      {
#line 890
      off_a = (y * pic->a_stride + x) * 8;
#line 891
      off_y = (y * pic->y_stride + x) * 8;
#line 892
      off_uv = (y * pic->uv_stride + x) * 4;
#line 893
      __cil_tmp13 = is_transparent_area(a_ptr + off_a, pic->a_stride, 8);
      }
#line 893
      if (__cil_tmp13) {
#line 894
        if (need_reset) {
#line 895
          values[0] = (int )*(pic->y + off_y);
#line 896
          values[1] = (int )*(pic->u + off_uv);
#line 897
          values[2] = (int )*(pic->v + off_uv);
#line 898
          need_reset = 0;
        }
        {
#line 900
        flatten(pic->y + off_y, values[0], pic->y_stride, 8);
#line 901
        flatten(pic->u + off_uv, values[1], pic->uv_stride, 4);
#line 902
        flatten(pic->v + off_uv, values[2], pic->uv_stride, 4);
        }
      } else {
#line 904
        need_reset = 1;
      }
#line 889
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 887
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 891
  return;
}
}
#line 922 "/root/patchweave_new/13/src/enc/picture.c"
void WebPBlendAlpha(WebPPicture *pic , uint32_t background_rgb ) 
{ 
  int red ;
  int green ;
  int blue ;
  int x ;
  int y ;
  int uv_width ;
  int Y0 ;
  int __cil_tmp10 ;
  int U0 ;
  int __cil_tmp12 ;
  int V0 ;
  int __cil_tmp14 ;
  int has_alpha ;
  uint8_t *y_ptr ;
  uint8_t *a_ptr ;
  int alpha ;
  uint8_t *u ;
  uint8_t *v ;
  uint8_t *a_ptr2 ;
  uint8_t *tmp ;
  int alpha___0 ;
  int alpha___1 ;
  uint32_t *argb ;
  uint32_t background ;
  uint32_t __cil_tmp27 ;
  int alpha___2 ;
  int r ;
  int g ;
  int b ;

  {
#line 923
  red = (int )((background_rgb >> 16) & 255U);
#line 924
  green = (int )((background_rgb >> 8) & 255U);
#line 925
  blue = (int )(background_rgb & 255U);
#line 927
  if ((unsigned long )pic == (unsigned long )((void *)0)) {
#line 927
    return;
  }
#line 928
  if (! pic->use_argb) {
    {
#line 929
    uv_width = pic->width >> 1;
#line 930
    __cil_tmp10 = VP8RGBToY(red, green, blue);
#line 930
    Y0 = __cil_tmp10;
#line 932
    __cil_tmp12 = VP8RGBToU(4 * red, 4 * green, 4 * blue);
#line 932
    U0 = __cil_tmp12;
#line 933
    __cil_tmp14 = VP8RGBToV(4 * red, 4 * green, 4 * blue);
#line 933
    V0 = __cil_tmp14;
#line 934
    has_alpha = (int )((unsigned int )pic->colorspace & 4U);
    }
#line 935
    if ((unsigned long )pic->a == (unsigned long )((void *)0)) {
#line 935
      return;
    } else
#line 935
    if (! has_alpha) {
#line 935
      return;
    }
#line 936
    y = 0;
    {
#line 936
    while (1) {
      while_continue: /* CIL Label */ ;

#line 936
      if (! (y < pic->height)) {
#line 936
        goto while_break;
      }
#line 938
      y_ptr = pic->y + y * pic->y_stride;
#line 939
      a_ptr = pic->a + y * pic->a_stride;
#line 940
      x = 0;
      {
#line 940
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 940
        if (! (x < pic->width)) {
#line 940
          goto while_break___0;
        }
#line 941
        alpha = (int )*(a_ptr + x);
#line 942
        if (alpha < 255) {
#line 943
          *(y_ptr + x) = (uint8_t )((Y0 * (255 - (int )*(a_ptr + x)) + (int )*(y_ptr + x) * (int )*(a_ptr + x)) * 257 >> 16);
        }
#line 940
        x ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: ;
#line 947
      if ((y & 1) == 0) {
#line 948
        u = pic->u + (y >> 1) * pic->uv_stride;
#line 949
        v = pic->v + (y >> 1) * pic->uv_stride;
#line 950
        if (y + 1 == pic->height) {
#line 950
          tmp = a_ptr;
        } else {
#line 950
          tmp = a_ptr + pic->a_stride;
        }
#line 950
        a_ptr2 = tmp;
#line 952
        x = 0;
        {
#line 952
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 952
          if (! (x < uv_width)) {
#line 952
            goto while_break___1;
          }
#line 955
          alpha___0 = (((int )*(a_ptr + 2 * x) + (int )*(a_ptr + (2 * x + 1))) + (int )*(a_ptr2 + 2 * x)) + (int )*(a_ptr2 + (2 * x + 1));
#line 958
          *(u + x) = (uint8_t )((U0 * (1020 - alpha___0) + (int )*(u + x) * alpha___0) * 257 >> 18);
#line 959
          *(v + x) = (uint8_t )((V0 * (1020 - alpha___0) + (int )*(v + x) * alpha___0) * 257 >> 18);
#line 952
          x ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: ;
#line 961
        if (pic->width & 1) {
#line 962
          alpha___1 = 2 * ((int )*(a_ptr + 2 * x) + (int )*(a_ptr2 + 2 * x));
#line 963
          *(u + x) = (uint8_t )((U0 * (1020 - alpha___1) + (int )*(u + x) * alpha___1) * 257 >> 18);
#line 964
          *(v + x) = (uint8_t )((V0 * (1020 - alpha___1) + (int )*(v + x) * alpha___1) * 257 >> 18);
        }
      }
      {
#line 967
      memset((void *)a_ptr, 255, (unsigned long )pic->width);
#line 936
      y ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 970
    argb = pic->argb;
#line 971
    __cil_tmp27 = MakeARGB32(red, green, blue);
#line 971
    background = __cil_tmp27;
#line 972
    y = 0;
    }
    {
#line 972
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 972
      if (! (y < pic->height)) {
#line 972
        goto while_break___2;
      }
#line 973
      x = 0;
      {
#line 973
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 973
        if (! (x < pic->width)) {
#line 973
          goto while_break___3;
        }
#line 974
        alpha___2 = (int )((*(argb + x) >> 24) & 255U);
#line 975
        if (alpha___2 != 255) {
#line 976
          if (alpha___2 > 0) {
            {
#line 977
            r = (int )((*(argb + x) >> 16) & 255U);
#line 978
            g = (int )((*(argb + x) >> 8) & 255U);
#line 979
            b = (int )(*(argb + x) & 255U);
#line 980
            r = (red * (255 - alpha___2) + r * alpha___2) * 257 >> 16;
#line 981
            g = (green * (255 - alpha___2) + g * alpha___2) * 257 >> 16;
#line 982
            b = (blue * (255 - alpha___2) + b * alpha___2) * 257 >> 16;
#line 983
            *(argb + x) = MakeARGB32(r, g, b);
            }
          } else {
#line 985
            *(argb + x) = background;
          }
        }
#line 973
        x ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 989
      argb += pic->argb_stride;
#line 972
      y ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
  }
#line 977
  return;
}
}
#line 1006 "/root/patchweave_new/13/src/enc/picture.c"
static float AccumulateLSIM(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride ,
                            int w , int h ) 
{ 
  int x ;
  int y ;
  double total_sse ;
  int y_0 ;
  int tmp ;
  int y_1 ;
  int tmp___0 ;
  int x_0 ;
  int tmp___1 ;
  int x_1 ;
  int tmp___2 ;
  double best_sse ;
  double value ;
  int i ;
  int j ;
  uint8_t *s ;
  double sse ;

  {
#line 1010
  total_sse = 0.;
#line 1011
  y = 0;
  {
#line 1011
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1011
    if (! (y < h)) {
#line 1011
      goto while_break;
    }
#line 1012
    if (y - 2 < 0) {
#line 1012
      tmp = 0;
    } else {
#line 1012
      tmp = y - 2;
    }
#line 1012
    y_0 = tmp;
#line 1013
    if ((y + 2) + 1 >= h) {
#line 1013
      tmp___0 = h;
    } else {
#line 1013
      tmp___0 = (y + 2) + 1;
    }
#line 1013
    y_1 = tmp___0;
#line 1014
    x = 0;
    {
#line 1014
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1014
      if (! (x < w)) {
#line 1014
        goto while_break___0;
      }
#line 1015
      if (x - 2 < 0) {
#line 1015
        tmp___1 = 0;
      } else {
#line 1015
        tmp___1 = x - 2;
      }
#line 1015
      x_0 = tmp___1;
#line 1016
      if ((x + 2) + 1 >= w) {
#line 1016
        tmp___2 = w;
      } else {
#line 1016
        tmp___2 = (x + 2) + 1;
      }
#line 1016
      x_1 = tmp___2;
#line 1017
      best_sse = 255. * 255.;
#line 1018
      value = (double )*(ref + (y * ref_stride + x));
#line 1020
      j = y_0;
      {
#line 1020
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1020
        if (! (j < y_1)) {
#line 1020
          goto while_break___1;
        }
#line 1021
        s = src + j * src_stride;
#line 1022
        i = x_0;
        {
#line 1022
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1022
          if (! (i < x_1)) {
#line 1022
            goto while_break___2;
          }
#line 1023
          sse = ((double )((int )*(s + i)) - value) * ((double )((int )*(s + i)) - value);
#line 1024
          if (sse < best_sse) {
#line 1024
            best_sse = sse;
          }
#line 1022
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 1020
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 1027
      total_sse += best_sse;
#line 1014
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 1011
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 1030
  return ((float )total_sse);
}
}
#line 1038 "/root/patchweave_new/13/src/enc/picture.c"
static double const   kMinDistortion_dB  =    (double const   )99.;
#line 1039 "/root/patchweave_new/13/src/enc/picture.c"
static float GetPSNR___0(double v ) 
{ 
  double __cil_tmp2 ;
  double tmp ;

  {
#line 1040
  if (v > 0.) {
    {
#line 1040
    __cil_tmp2 = log(v / ((double )255 * 255.));
#line 1040
    tmp = - 4.3429448 * __cil_tmp2;
    }
  } else {
#line 1040
    tmp = (double )kMinDistortion_dB;
  }
#line 1040
  return ((float )((int )tmp));
}
}
#line 1044 "/root/patchweave_new/13/src/enc/picture.c"
int WebPPictureDistortion(WebPPicture *src , WebPPicture *ref , int type , float *result ) 
{ 
  DistoStats stats[5] ;
  int has_alpha ;
  int uv_w ;
  int uv_h ;
  float sse[4] ;
  float __cil_tmp13 ;
  float tmp ;
  double total_sse ;
  int total_pixels ;
  int c ;
  double v ;
  double __cil_tmp24 ;
  double __cil_tmp25 ;
  double tmp___0 ;
  double v___0 ;
  double __cil_tmp28 ;

  {
#line 1050
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 1056
    return (0);
  } else
#line 1050
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
#line 1056
    return (0);
  } else
#line 1050
  if (src->width != ref->width) {
#line 1056
    return (0);
  } else
#line 1050
  if (src->height != ref->height) {
#line 1056
    return (0);
  } else
#line 1050
  if ((unsigned long )src->y == (unsigned long )((void *)0)) {
#line 1056
    return (0);
  } else
#line 1050
  if ((unsigned long )ref->y == (unsigned long )((void *)0)) {
#line 1056
    return (0);
  } else
#line 1050
  if ((unsigned long )src->u == (unsigned long )((void *)0)) {
#line 1056
    return (0);
  } else
#line 1050
  if ((unsigned long )ref->u == (unsigned long )((void *)0)) {
#line 1056
    return (0);
  } else
#line 1050
  if ((unsigned long )src->v == (unsigned long )((void *)0)) {
#line 1056
    return (0);
  } else
#line 1050
  if ((unsigned long )ref->v == (unsigned long )((void *)0)) {
#line 1056
    return (0);
  } else
#line 1050
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 1056
    return (0);
  }
#line 1059
  if (src->use_argb == 1) {
#line 1060
    return (0);
  } else
#line 1059
  if (src->use_argb != ref->use_argb) {
#line 1060
    return (0);
  }
#line 1063
  has_alpha = ! (! ((unsigned int )src->colorspace & 4U));
#line 1064
  if ((unsigned long )src->a == (unsigned long )((void *)0)) {
    _L___10: 
#line 1064
    if (has_alpha) {
#line 1066
      return (0);
    } else {
#line 1064
      goto _L;
    }
  } else
#line 1064
  if ((unsigned long )ref->a == (unsigned long )((void *)0)) {
#line 1064
    goto _L___10;
  } else
  _L: 
#line 1064
  if (has_alpha != ! (! ((unsigned int )ref->colorspace & 4U))) {
#line 1066
    return (0);
  }
  {
#line 1069
  memset((void *)(stats), 0, sizeof(stats));
#line 1071
  uv_w = (src->width + 1) >> 1;
#line 1072
  uv_h = (src->height + 1) >> 1;
  }
#line 1073
  if (type >= 2) {
    {
#line 1075
    sse[0] = AccumulateLSIM(src->y, src->y_stride, ref->y, ref->y_stride, src->width,
                            src->height);
#line 1077
    sse[1] = AccumulateLSIM(src->u, src->uv_stride, ref->u, ref->uv_stride, uv_w,
                            uv_h);
#line 1079
    sse[2] = AccumulateLSIM(src->v, src->uv_stride, ref->v, ref->uv_stride, uv_w,
                            uv_h);
    }
#line 1081
    if (has_alpha) {
      {
#line 1081
      __cil_tmp13 = AccumulateLSIM(src->a, src->a_stride, ref->a, ref->a_stride, src->width,
                                   src->height);
#line 1081
      tmp = __cil_tmp13;
      }
    } else {
#line 1081
      tmp = 0.f;
    }
    {
#line 1081
    sse[3] = tmp;
#line 1085
    *(result + 0) = GetPSNR___0((double )(sse[0] / (float )(src->width * src->height)));
#line 1086
    *(result + 1) = GetPSNR___0((double )(sse[1] / (float )(uv_w * uv_h)));
#line 1087
    *(result + 2) = GetPSNR___0((double )(sse[2] / (float )(uv_w * uv_h)));
#line 1088
    *(result + 3) = GetPSNR___0((double )(sse[3] / (float )(src->width * src->height)));
#line 1090
    total_sse = (double )((sse[0] + sse[1]) + sse[2]);
#line 1091
    total_pixels = src->width * src->height + (2 * uv_w) * uv_h;
    }
#line 1092
    if (has_alpha) {
#line 1093
      total_pixels += src->width * src->height;
#line 1094
      total_sse += (double )sse[3];
    }
    {
#line 1096
    *(result + 4) = GetPSNR___0(total_sse / (double )total_pixels);
    }
  } else {
    {
#line 1100
    VP8SSIMAccumulatePlane(src->y, src->y_stride, ref->y, ref->y_stride, src->width,
                           src->height, & stats[0]);
#line 1103
    VP8SSIMAccumulatePlane(src->u, src->uv_stride, ref->u, ref->uv_stride, uv_w, uv_h,
                           & stats[1]);
#line 1106
    VP8SSIMAccumulatePlane(src->v, src->uv_stride, ref->v, ref->uv_stride, uv_w, uv_h,
                           & stats[2]);
    }
#line 1109
    if (has_alpha) {
      {
#line 1110
      VP8SSIMAccumulatePlane(src->a, src->a_stride, ref->a, ref->a_stride, src->width,
                             src->height, & stats[3]);
      }
    }
#line 1114
    c = 0;
    {
#line 1114
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1114
      if (! (c <= 4)) {
#line 1114
        goto while_break;
      }
#line 1115
      if (type == 1) {
        {
#line 1116
        __cil_tmp24 = VP8SSIMGet(& stats[c]);
#line 1116
        v = __cil_tmp24;
        }
#line 1117
        if (v < 1.) {
          {
#line 1117
          __cil_tmp25 = log10(1. - v);
#line 1117
          tmp___0 = - 10. * __cil_tmp25;
          }
        } else {
#line 1117
          tmp___0 = (double )kMinDistortion_dB;
        }
#line 1117
        *(result + c) = (float )((int )tmp___0);
      } else {
        {
#line 1120
        __cil_tmp28 = VP8SSIMGetSquaredError(& stats[c]);
#line 1120
        v___0 = __cil_tmp28;
#line 1121
        *(result + c) = GetPSNR___0(v___0);
        }
      }
#line 1124
      if (c < 4) {
        {
#line 1124
        VP8SSIMAddStats(& stats[c], & stats[4]);
        }
      }
#line 1114
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 1127
  return (1);
}
}
#line 1135 "/root/patchweave_new/13/src/enc/picture.c"
static size_t Encode(uint8_t *rgba , int width , int height , int stride , int (*import)(WebPPicture * const   ,
                                                                                         uint8_t * const   ,
                                                                                         int  ) ,
                     float quality_factor , int lossless , uint8_t **output ) 
{ 
  WebPPicture pic ;
  WebPConfig config ;
  WebPMemoryWriter wrt ;
  int ok ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;

  {
  {
#line 1143
  __cil_tmp14 = WebPPictureInit(& pic);
#line 1143
  __cil_tmp13 = WebPConfigPreset___0(& config, (enum WebPPreset )0, quality_factor);
  }
#line 1143
  if (! __cil_tmp13) {
#line 1145
    return ((size_t )0);
  } else
#line 1143
  if (! __cil_tmp14) {
#line 1145
    return ((size_t )0);
  }
  {
#line 1148
  config.lossless = ! (! lossless);
#line 1149
  pic.use_argb = ! (! lossless);
#line 1150
  pic.width = width;
#line 1151
  pic.height = height;
#line 1152
  pic.writer = & WebPMemoryWrite;
#line 1153
  pic.custom_ptr = (void *)(& wrt);
#line 1154
  WebPMemoryWriterInit(& wrt);
#line 1156
  __cil_tmp16 = WebPEncode(& config, & pic);
#line 1156
  __cil_tmp15 = (*import)((WebPPicture */* const  */)(& pic), (uint8_t */* const  */)rgba,
                          stride);
  }
#line 1156
  if (__cil_tmp15) {
#line 1156
    if (__cil_tmp16) {
#line 1156
      tmp = 1;
    } else {
#line 1156
      tmp = 0;
    }
  } else {
#line 1156
    tmp = 0;
  }
  {
#line 1156
  ok = tmp;
#line 1157
  WebPPictureFree(& pic);
  }
#line 1158
  if (! ok) {
    {
#line 1159
    free((void *)wrt.mem);
#line 1160
    *output = (uint8_t *)((void *)0);
    }
#line 1161
    return ((size_t )0);
  }
#line 1163
  *output = wrt.mem;
#line 1164
  return (wrt.size);
}
}
#line 1173 "/root/patchweave_new/13/src/enc/picture.c"
size_t WebPEncodeRGB(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 1173
  __cil_tmp7 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportRGB), q,
                      0, out);
  }
#line 1173
  return (__cil_tmp7);
}
}
#line 1174 "/root/patchweave_new/13/src/enc/picture.c"
size_t WebPEncodeBGR(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 1174
  __cil_tmp7 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportBGR), q,
                      0, out);
  }
#line 1174
  return (__cil_tmp7);
}
}
#line 1175 "/root/patchweave_new/13/src/enc/picture.c"
size_t WebPEncodeRGBA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 1175
  __cil_tmp7 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportRGBA), q,
                      0, out);
  }
#line 1175
  return (__cil_tmp7);
}
}
#line 1176 "/root/patchweave_new/13/src/enc/picture.c"
size_t WebPEncodeBGRA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 1176
  __cil_tmp7 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportBGRA), q,
                      0, out);
  }
#line 1176
  return (__cil_tmp7);
}
}
#line 1186 "/root/patchweave_new/13/src/enc/picture.c"
size_t WebPEncodeLosslessRGB(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 1186
  __cil_tmp6 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportRGB), (float )70.,
                      1, out);
  }
#line 1186
  return (__cil_tmp6);
}
}
#line 1187 "/root/patchweave_new/13/src/enc/picture.c"
size_t WebPEncodeLosslessBGR(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 1187
  __cil_tmp6 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportBGR), (float )70.,
                      1, out);
  }
#line 1187
  return (__cil_tmp6);
}
}
#line 1188 "/root/patchweave_new/13/src/enc/picture.c"
size_t WebPEncodeLosslessRGBA(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 1188
  __cil_tmp6 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportRGBA), (float )70.,
                      1, out);
  }
#line 1188
  return (__cil_tmp6);
}
}
#line 1189 "/root/patchweave_new/13/src/enc/picture.c"
size_t WebPEncodeLosslessBGRA(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 1189
  __cil_tmp6 = Encode(in, w, h, bps, (int (*)(WebPPicture * const   , uint8_t * const   ,
                                              int  ))(& WebPPictureImportBGRA), (float )70.,
                      1, out);
  }
#line 1189
  return (__cil_tmp6);
}
}
#line 22 "/root/patchweave_new/13/src/enc/layer.c"
void VP8EncInitLayer(VP8Encoder *enc ) 
{ 


  {
#line 23
  enc->use_layer_ = (unsigned long )(enc->pic_)->u0 != (unsigned long )((void *)0);
#line 24
  enc->layer_data_size_ = (size_t )0;
#line 25
  enc->layer_data_ = (uint8_t *)((void *)0);
#line 26
  if (enc->use_layer_) {
    {
#line 27
    VP8BitWriterInit(& enc->layer_bw_, (size_t )((enc->mb_w_ * enc->mb_h_) * 3));
    }
  }
#line 30
  return;
}
}
#line 31 "/root/patchweave_new/13/src/enc/layer.c"
void VP8EncCodeLayerBlock(VP8EncIterator *it ) 
{ 


  {
#line 36
  return;
}
}
#line 35 "/root/patchweave_new/13/src/enc/layer.c"
int VP8EncFinishLayer(VP8Encoder *enc ) 
{ 


  {
#line 36
  if (enc->use_layer_) {
    {
#line 37
    enc->layer_data_ = VP8BitWriterFinish(& enc->layer_bw_);
#line 38
    enc->layer_data_size_ = VP8BitWriterSize(& enc->layer_bw_);
    }
  }
#line 40
  return (1);
}
}
#line 43 "/root/patchweave_new/13/src/enc/layer.c"
void VP8EncDeleteLayer(VP8Encoder *enc ) 
{ 


  {
  {
#line 44
  free((void *)enc->layer_data_);
  }
#line 46
  return;
}
}
#line 24 "/root/patchweave_new/13/src/enc/iterator.c"
static void InitLeft(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int tmp ;

  {
#line 25
  enc = it->enc_;
#line 26
  if (it->y_ > 0) {
#line 26
    tmp = 129;
  } else {
#line 26
    tmp = 127;
  }
  {
#line 26
  *(enc->v_left_ + -1) = (uint8_t )tmp;
#line 26
  *(enc->u_left_ + -1) = *(enc->v_left_ + -1);
#line 26
  *(enc->y_left_ + -1) = *(enc->u_left_ + -1);
#line 28
  memset((void *)enc->y_left_, 129, 16UL);
#line 29
  memset((void *)enc->u_left_, 129, 8UL);
#line 30
  memset((void *)enc->v_left_, 129, 8UL);
#line 31
  it->left_nz_[8] = 0;
  }
#line 33
  return;
}
}
#line 34 "/root/patchweave_new/13/src/enc/iterator.c"
static void InitTop(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  size_t top_size ;

  {
  {
#line 35
  enc = it->enc_;
#line 36
  top_size = (size_t )(enc->mb_w_ * 16);
#line 37
  memset((void *)enc->y_top_, 127, 2UL * top_size);
#line 38
  memset((void *)enc->nz_, 0, (unsigned long )enc->mb_w_ * sizeof(*(enc->nz_)));
  }
#line 40
  return;
}
}
#line 41 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8IteratorReset(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;

  {
  {
#line 42
  enc = it->enc_;
#line 43
  it->x_ = 0;
#line 44
  it->y_ = 0;
#line 45
  it->y_offset_ = 0;
#line 46
  it->uv_offset_ = 0;
#line 47
  it->mb_ = enc->mb_info_;
#line 48
  it->preds_ = enc->preds_;
#line 49
  it->nz_ = enc->nz_;
#line 50
  it->bw_ = & enc->parts_[0];
#line 51
  it->done_ = enc->mb_w_ * enc->mb_h_;
#line 52
  InitTop(it);
#line 53
  InitLeft(it);
#line 54
  memset((void *)(it->bit_count_), 0, sizeof(it->bit_count_));
#line 55
  it->do_trellis_ = 0;
  }
#line 57
  return;
}
}
#line 58 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8IteratorInit(VP8Encoder *enc , VP8EncIterator *it ) 
{ 


  {
  {
#line 59
  it->enc_ = enc;
#line 60
  it->y_stride_ = (enc->pic_)->y_stride;
#line 61
  it->uv_stride_ = (enc->pic_)->uv_stride;
#line 63
  it->yuv_in_ = enc->yuv_in_;
#line 64
  it->yuv_out_ = enc->yuv_out_;
#line 65
  it->yuv_out2_ = enc->yuv_out2_;
#line 66
  it->yuv_p_ = enc->yuv_p_;
#line 67
  it->lf_stats_ = enc->lf_stats_;
#line 68
  it->percent0_ = enc->percent_;
#line 69
  VP8IteratorReset(it);
  }
#line 71
  return;
}
}
#line 72 "/root/patchweave_new/13/src/enc/iterator.c"
int VP8IteratorProgress(VP8EncIterator *it , int delta ) 
{ 
  VP8Encoder *enc ;
  int percent ;
  int tmp ;
  int __cil_tmp6 ;

  {
#line 73
  enc = it->enc_;
#line 74
  if ((enc->pic_)->progress_hook) {
#line 74
    if (delta) {
#line 75
      if (enc->mb_h_ <= 1) {
#line 75
        tmp = it->percent0_;
      } else {
#line 75
        tmp = it->percent0_ + (delta * it->y_) / (enc->mb_h_ - 1);
      }
      {
#line 75
      percent = tmp;
#line 78
      __cil_tmp6 = WebPReportProgress(enc->pic_, percent, & enc->percent_);
      }
#line 78
      return (__cil_tmp6);
    }
  }
#line 80
  return (1);
}
}
#line 87 "/root/patchweave_new/13/src/enc/iterator.c"
static void ImportBlock(uint8_t *src , int src_stride , uint8_t *dst , int w , int h ,
                        int size ) 
{ 
  int i ;

  {
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;

#line 90
    if (! (i < h)) {
#line 90
      goto while_break;
    }
    {
#line 91
    memcpy((void *)dst, (void const   *)src, (unsigned long )w);
    }
#line 92
    if (w < size) {
      {
#line 93
      memset((void *)(dst + w), (int )*(dst + (w - 1)), (unsigned long )(size - w));
      }
    }
#line 95
    dst += 16;
#line 96
    src += src_stride;
#line 90
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 98
  i = h;
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 98
    if (! (i < size)) {
#line 98
      goto while_break___0;
    }
    {
#line 99
    memcpy((void *)dst, (void const   *)(dst - 16), (unsigned long )size);
#line 100
    dst += 16;
#line 98
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 102
  return;
}
}
#line 104 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8IteratorImport(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int x ;
  int y ;
  WebPPicture *pic ;
  uint8_t *ysrc ;
  uint8_t *usrc ;
  uint8_t *vsrc ;
  uint8_t *ydst ;
  uint8_t *udst ;
  uint8_t *vdst ;
  int w ;
  int h ;
  int uv_w ;
  int uv_h ;

  {
#line 105
  enc = it->enc_;
#line 106
  x = it->x_;
#line 106
  y = it->y_;
#line 107
  pic = enc->pic_;
#line 108
  ysrc = pic->y + (y * pic->y_stride + x) * 16;
#line 109
  usrc = pic->u + (y * pic->uv_stride + x) * 8;
#line 110
  vsrc = pic->v + (y * pic->uv_stride + x) * 8;
#line 111
  ydst = it->yuv_in_ + 0;
#line 112
  udst = it->yuv_in_ + 256;
#line 113
  vdst = it->yuv_in_ + 264;
#line 114
  w = pic->width - x * 16;
#line 115
  h = pic->height - y * 16;
#line 117
  if (w > 16) {
#line 117
    w = 16;
  }
#line 118
  if (h > 16) {
#line 118
    h = 16;
  }
  {
#line 121
  ImportBlock(ysrc, pic->y_stride, ydst, w, h, 16);
#line 124
  uv_w = (w + 1) >> 1;
#line 125
  uv_h = (h + 1) >> 1;
#line 126
  ImportBlock(usrc, pic->uv_stride, udst, uv_w, uv_h, 8);
#line 127
  ImportBlock(vsrc, pic->uv_stride, vdst, uv_w, uv_h, 8);
  }
#line 129
  return;
}
}
#line 134 "/root/patchweave_new/13/src/enc/iterator.c"
static void ExportBlock(uint8_t *src , uint8_t *dst , int dst_stride , int w , int h ) 
{ 
  int __cil_tmp6 ;

  {
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    __cil_tmp6 = h;
#line 136
    h --;
#line 136
    if (! (__cil_tmp6 > 0)) {
#line 136
      goto while_break;
    }
    {
#line 137
    memcpy((void *)dst, (void const   *)src, (unsigned long )w);
#line 138
    dst += dst_stride;
#line 139
    src += 16;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 144
  return;
}
}
#line 143 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8IteratorExport(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int x ;
  int y ;
  uint8_t *ysrc ;
  uint8_t *usrc ;
  uint8_t *vsrc ;
  WebPPicture *pic ;
  uint8_t *ydst ;
  uint8_t *udst ;
  uint8_t *vdst ;
  int w ;
  int h ;
  int uv_w ;
  int uv_h ;

  {
#line 144
  enc = it->enc_;
#line 145
  if ((enc->config_)->show_compressed) {
#line 146
    x = it->x_;
#line 146
    y = it->y_;
#line 147
    ysrc = it->yuv_out_ + 0;
#line 148
    usrc = it->yuv_out_ + 256;
#line 149
    vsrc = it->yuv_out_ + 264;
#line 150
    pic = enc->pic_;
#line 151
    ydst = pic->y + (y * pic->y_stride + x) * 16;
#line 152
    udst = pic->u + (y * pic->uv_stride + x) * 8;
#line 153
    vdst = pic->v + (y * pic->uv_stride + x) * 8;
#line 154
    w = pic->width - x * 16;
#line 155
    h = pic->height - y * 16;
#line 157
    if (w > 16) {
#line 157
      w = 16;
    }
#line 158
    if (h > 16) {
#line 158
      h = 16;
    }
    {
#line 161
    ExportBlock(ysrc, ydst, pic->y_stride, w, h);
#line 164
    uv_w = (w + 1) >> 1;
#line 165
    uv_h = (h + 1) >> 1;
#line 166
    ExportBlock(usrc, udst, pic->uv_stride, uv_w, uv_h);
#line 167
    ExportBlock(vsrc, vdst, pic->uv_stride, uv_w, uv_h);
    }
  }
#line 170
  return;
}
}
#line 189 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8IteratorNzToBytes(VP8EncIterator *it ) 
{ 
  int tnz ;
  int lnz ;
  int *top_nz ;
  int *left_nz ;

  {
#line 190
  tnz = (int )*(it->nz_ + 0);
#line 190
  lnz = (int )*(it->nz_ + -1);
#line 191
  top_nz = it->top_nz_;
#line 192
  left_nz = it->left_nz_;
#line 195
  *(top_nz + 0) = ! (! (tnz & (1 << 12)));
#line 196
  *(top_nz + 1) = ! (! (tnz & (1 << 13)));
#line 197
  *(top_nz + 2) = ! (! (tnz & (1 << 14)));
#line 198
  *(top_nz + 3) = ! (! (tnz & (1 << 15)));
#line 200
  *(top_nz + 4) = ! (! (tnz & (1 << 18)));
#line 201
  *(top_nz + 5) = ! (! (tnz & (1 << 19)));
#line 203
  *(top_nz + 6) = ! (! (tnz & (1 << 22)));
#line 204
  *(top_nz + 7) = ! (! (tnz & (1 << 23)));
#line 206
  *(top_nz + 8) = ! (! (tnz & (1 << 24)));
#line 209
  *(left_nz + 0) = ! (! (lnz & (1 << 3)));
#line 210
  *(left_nz + 1) = ! (! (lnz & (1 << 7)));
#line 211
  *(left_nz + 2) = ! (! (lnz & (1 << 11)));
#line 212
  *(left_nz + 3) = ! (! (lnz & (1 << 15)));
#line 214
  *(left_nz + 4) = ! (! (lnz & (1 << 17)));
#line 215
  *(left_nz + 5) = ! (! (lnz & (1 << 19)));
#line 217
  *(left_nz + 6) = ! (! (lnz & (1 << 21)));
#line 218
  *(left_nz + 7) = ! (! (lnz & (1 << 23)));
#line 219
  return;
}
}
#line 222 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8IteratorBytesToNz(VP8EncIterator *it ) 
{ 
  uint32_t nz ;
  int const   *top_nz ;
  int const   *left_nz ;

  {
#line 223
  nz = (uint32_t )0;
#line 224
  top_nz = (int const   *)(it->top_nz_);
#line 225
  left_nz = (int const   *)(it->left_nz_);
#line 227
  nz |= (unsigned int )((*(top_nz + 0) << 12) | (*(top_nz + 1) << 13));
#line 228
  nz |= (unsigned int )((*(top_nz + 2) << 14) | (*(top_nz + 3) << 15));
#line 229
  nz |= (unsigned int )((*(top_nz + 4) << 18) | (*(top_nz + 5) << 19));
#line 230
  nz |= (unsigned int )((*(top_nz + 6) << 22) | (*(top_nz + 7) << 23));
#line 231
  nz |= (unsigned int )(*(top_nz + 8) << 24);
#line 233
  nz |= (unsigned int )((*(left_nz + 0) << 3) | (*(left_nz + 1) << 7));
#line 234
  nz |= (unsigned int )(*(left_nz + 2) << 11);
#line 235
  nz |= (unsigned int )((*(left_nz + 4) << 17) | (*(left_nz + 6) << 21));
#line 237
  *(it->nz_) = nz;
#line 238
  return;
}
}
#line 245 "/root/patchweave_new/13/src/enc/iterator.c"
int VP8IteratorNext(VP8EncIterator *it , uint8_t *block_to_save ) 
{ 
  VP8Encoder *enc ;
  int x ;
  int y ;
  uint8_t *ysrc ;
  uint8_t *usrc ;
  int i ;

  {
#line 247
  enc = it->enc_;
#line 248
  if (block_to_save) {
#line 249
    x = it->x_;
#line 249
    y = it->y_;
#line 250
    ysrc = block_to_save + 0;
#line 251
    usrc = block_to_save + 256;
#line 252
    if (x < enc->mb_w_ - 1) {
#line 254
      i = 0;
      {
#line 254
      while (1) {
        while_continue: /* CIL Label */ ;

#line 254
        if (! (i < 16)) {
#line 254
          goto while_break;
        }
#line 255
        *(enc->y_left_ + i) = *(ysrc + (15 + i * 16));
#line 254
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: 
#line 257
      i = 0;
      {
#line 257
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 257
        if (! (i < 8)) {
#line 257
          goto while_break___0;
        }
#line 258
        *(enc->u_left_ + i) = *(usrc + (7 + i * 16));
#line 259
        *(enc->v_left_ + i) = *(usrc + (15 + i * 16));
#line 257
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 262
      *(enc->y_left_ + -1) = *(enc->y_top_ + (x * 16 + 15));
#line 263
      *(enc->u_left_ + -1) = *(enc->uv_top_ + (x * 16 + 7));
#line 264
      *(enc->v_left_ + -1) = *(enc->uv_top_ + ((x * 16 + 8) + 7));
    }
#line 266
    if (y < enc->mb_h_ - 1) {
      {
#line 267
      memcpy((void *)(enc->y_top_ + x * 16), (void const   *)(ysrc + 240), 16UL);
#line 268
      memcpy((void *)(enc->uv_top_ + x * 16), (void const   *)(usrc + 112), 16UL);
      }
    }
  }
#line 272
  (it->mb_) ++;
#line 273
  it->preds_ += 4;
#line 274
  (it->nz_) ++;
#line 275
  (it->x_) ++;
#line 276
  if (it->x_ == enc->mb_w_) {
    {
#line 277
    it->x_ = 0;
#line 278
    (it->y_) ++;
#line 279
    it->bw_ = & enc->parts_[it->y_ & (enc->num_parts_ - 1)];
#line 280
    it->preds_ = enc->preds_ + (it->y_ * 4) * enc->preds_w_;
#line 281
    it->nz_ = enc->nz_;
#line 282
    InitLeft(it);
    }
  }
#line 284
  (it->done_) --;
#line 284
  return (0 < it->done_);
}
}
#line 290 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8SetIntra16Mode(VP8EncIterator *it , int mode ) 
{ 
  uint8_t *preds ;
  int y ;

  {
#line 291
  preds = it->preds_;
#line 293
  y = 0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;

#line 293
    if (! (y < 4)) {
#line 293
      goto while_break;
    }
    {
#line 294
    memset((void *)preds, mode, 4UL);
#line 295
    preds += (it->enc_)->preds_w_;
#line 293
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 297
  (it->mb_)->type_ = 1U;
#line 298
  return;
}
}
#line 300 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8SetIntra4Mode(VP8EncIterator *it , uint8_t *modes ) 
{ 
  uint8_t *preds ;
  int y ;

  {
#line 301
  preds = it->preds_;
#line 303
  y = 4;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;

#line 303
    if (! (y > 0)) {
#line 303
      goto while_break;
    }
    {
#line 304
    memcpy((void *)preds, (void const   *)modes, 4UL * sizeof(*modes));
#line 305
    preds += (it->enc_)->preds_w_;
#line 306
    modes += 4;
#line 303
    y --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 308
  (it->mb_)->type_ = 0U;
#line 309
  return;
}
}
#line 311 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8SetIntraUVMode(VP8EncIterator *it , int mode ) 
{ 


  {
#line 312
  (it->mb_)->uv_mode_ = (unsigned int )mode;
#line 313
  return;
}
}
#line 315 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8SetSkip(VP8EncIterator *it , int skip ) 
{ 


  {
#line 316
  (it->mb_)->skip_ = (unsigned int )skip;
#line 317
  return;
}
}
#line 319 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8SetSegment(VP8EncIterator *it , int segment ) 
{ 


  {
#line 320
  (it->mb_)->segment_ = (unsigned int )segment;
#line 321
  return;
}
}
#line 355 "/root/patchweave_new/13/src/enc/iterator.c"
static uint8_t VP8TopLeftI4[16]  = 
#line 355
  {      (uint8_t )17,      (uint8_t )21,      (uint8_t )25,      (uint8_t )29, 
        (uint8_t )13,      (uint8_t )17,      (uint8_t )21,      (uint8_t )25, 
        (uint8_t )9,      (uint8_t )13,      (uint8_t )17,      (uint8_t )21, 
        (uint8_t )5,      (uint8_t )9,      (uint8_t )13,      (uint8_t )17};
#line 362 "/root/patchweave_new/13/src/enc/iterator.c"
void VP8IteratorStartI4(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int i ;

  {
#line 363
  enc = it->enc_;
#line 366
  it->i4_ = 0;
#line 367
  it->i4_top_ = it->i4_boundary_ + (int )VP8TopLeftI4[0];
#line 370
  i = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;

#line 370
    if (! (i < 17)) {
#line 370
      goto while_break;
    }
#line 371
    it->i4_boundary_[i] = *(enc->y_left_ + (15 - i));
#line 370
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 373
  i = 0;
  {
#line 373
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 373
    if (! (i < 16)) {
#line 373
      goto while_break___0;
    }
#line 374
    it->i4_boundary_[17 + i] = *(enc->y_top_ + (it->x_ * 16 + i));
#line 373
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
#line 377
  if (it->x_ < enc->mb_w_ - 1) {
#line 378
    i = 16;
    {
#line 378
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 378
      if (! (i < 20)) {
#line 378
        goto while_break___1;
      }
#line 379
      it->i4_boundary_[17 + i] = *(enc->y_top_ + (it->x_ * 16 + i));
#line 378
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  } else {
#line 382
    i = 16;
    {
#line 382
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 382
      if (! (i < 20)) {
#line 382
        goto while_break___2;
      }
#line 383
      it->i4_boundary_[17 + i] = it->i4_boundary_[32];
#line 382
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
  {
#line 386
  VP8IteratorNzToBytes(it);
  }
#line 388
  return;
}
}
#line 389 "/root/patchweave_new/13/src/enc/iterator.c"
int VP8IteratorRotateI4(VP8EncIterator *it , uint8_t *yuv_out ) 
{ 
  uint8_t *blk ;
  uint8_t *top ;
  int i ;

  {
#line 391
  blk = yuv_out + VP8Scan[it->i4_];
#line 392
  top = it->i4_top_;
#line 396
  i = 0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;

#line 396
    if (! (i <= 3)) {
#line 396
      goto while_break;
    }
#line 397
    *(top + (-4 + i)) = *(blk + (i + 48));
#line 396
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 399
  if ((it->i4_ & 3) != 3) {
#line 400
    i = 0;
    {
#line 400
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 400
      if (! (i <= 2)) {
#line 400
        goto while_break___0;
      }
#line 401
      *(top + i) = *(blk + (3 + (2 - i) * 16));
#line 400
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 404
    i = 0;
    {
#line 404
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 404
      if (! (i <= 3)) {
#line 404
        goto while_break___1;
      }
#line 405
      *(top + i) = *(top + (i + 4));
#line 404
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 409
  (it->i4_) ++;
#line 410
  if (it->i4_ == 16) {
#line 411
    return (0);
  }
#line 414
  it->i4_top_ = it->i4_boundary_ + (int )VP8TopLeftI4[it->i4_];
#line 415
  return (1);
}
}
#line 22 "/root/patchweave_new/13/src/enc/histogram.c"
static void HistogramClear(VP8LHistogram *p ) 
{ 


  {
  {
#line 23
  memset((void *)(p->literal_), 0, sizeof(p->literal_));
#line 24
  memset((void *)(p->red_), 0, sizeof(p->red_));
#line 25
  memset((void *)(p->blue_), 0, sizeof(p->blue_));
#line 26
  memset((void *)(p->alpha_), 0, sizeof(p->alpha_));
#line 27
  memset((void *)(p->distance_), 0, sizeof(p->distance_));
#line 28
  p->bit_cost_ = (double )0;
  }
#line 30
  return;
}
}
#line 31 "/root/patchweave_new/13/src/enc/histogram.c"
void VP8LHistogramStoreRefs(VP8LBackwardRefs *refs , VP8LHistogram *histo ) 
{ 
  int i ;

  {
#line 34
  i = 0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;

#line 34
    if (! (i < refs->size)) {
#line 34
      goto while_break;
    }
    {
#line 35
    VP8LHistogramAddSinglePixOrCopy(histo, refs->refs + i);
#line 34
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 38
  return;
}
}
#line 39 "/root/patchweave_new/13/src/enc/histogram.c"
void VP8LHistogramCreate(VP8LHistogram *p , VP8LBackwardRefs *refs , int palette_code_bits ) 
{ 


  {
#line 42
  if (palette_code_bits >= 0) {
#line 43
    p->palette_code_bits_ = palette_code_bits;
  }
  {
#line 45
  HistogramClear(p);
#line 46
  VP8LHistogramStoreRefs(refs, p);
  }
#line 48
  return;
}
}
#line 49 "/root/patchweave_new/13/src/enc/histogram.c"
void VP8LHistogramInit(VP8LHistogram *p , int palette_code_bits ) 
{ 


  {
  {
#line 50
  p->palette_code_bits_ = palette_code_bits;
#line 51
  HistogramClear(p);
  }
#line 53
  return;
}
}
#line 54 "/root/patchweave_new/13/src/enc/histogram.c"
VP8LHistogramSet *VP8LAllocateHistogramSet(int size , int cache_bits ) 
{ 
  int i ;
  VP8LHistogramSet *set ;
  VP8LHistogram *bulk ;
  uint64_t total_size ;
  uint8_t *memory ;
  void *__cil_tmp8 ;

  {
  {
#line 58
  total_size = (sizeof(*set) + (uint64_t )size * sizeof(*(set->histograms))) + (uint64_t )size * sizeof(*(*(set->histograms)));
#line 61
  __cil_tmp8 = WebPSafeMalloc(total_size, sizeof(*memory));
#line 61
  memory = (uint8_t *)__cil_tmp8;
  }
#line 62
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 62
    return ((VP8LHistogramSet *)((void *)0));
  }
#line 64
  set = (VP8LHistogramSet *)memory;
#line 65
  memory += sizeof(*set);
#line 66
  set->histograms = (VP8LHistogram **)memory;
#line 67
  memory += (unsigned long )size * sizeof(*(set->histograms));
#line 68
  bulk = (VP8LHistogram *)memory;
#line 69
  set->max_size = size;
#line 70
  set->size = size;
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;

#line 71
    if (! (i < size)) {
#line 71
      goto while_break;
    }
    {
#line 72
    *(set->histograms + i) = bulk + i;
#line 73
    VP8LHistogramInit(*(set->histograms + i), cache_bits);
#line 71
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 75
  return (set);
}
}
#line 80 "/root/patchweave_new/13/src/enc/histogram.c"
void VP8LHistogramAddSinglePixOrCopy(VP8LHistogram *histo , PixOrCopy *v ) 
{ 
  int __cil_tmp3 ;
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  int __cil_tmp8 ;
  int literal_ix ;
  uint32_t __cil_tmp10 ;
  int code ;
  int extra_bits_count ;
  int extra_bits_value ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;

  {
  {
#line 82
  __cil_tmp3 = PixOrCopyIsLiteral(v);
  }
#line 82
  if (__cil_tmp3) {
    {
#line 83
    __cil_tmp4 = PixOrCopyLiteral(v, 3);
#line 83
    (histo->alpha_[__cil_tmp4]) ++;
#line 84
    __cil_tmp5 = PixOrCopyLiteral(v, 2);
#line 84
    (histo->red_[__cil_tmp5]) ++;
#line 85
    __cil_tmp6 = PixOrCopyLiteral(v, 1);
#line 85
    (histo->literal_[__cil_tmp6]) ++;
#line 86
    __cil_tmp7 = PixOrCopyLiteral(v, 0);
#line 86
    (histo->blue_[__cil_tmp7]) ++;
    }
  } else {
    {
#line 87
    __cil_tmp8 = PixOrCopyIsCacheIdx(v);
    }
#line 87
    if (__cil_tmp8) {
      {
#line 88
      __cil_tmp10 = PixOrCopyCacheIdx(v);
#line 88
      literal_ix = (int )(280U + __cil_tmp10);
#line 89
      (histo->literal_[literal_ix]) ++;
      }
    } else {
      {
#line 92
      __cil_tmp14 = PixOrCopyLength(v);
#line 92
      PrefixEncode((int )__cil_tmp14, & code, & extra_bits_count, & extra_bits_value);
#line 94
      (histo->literal_[256 + code]) ++;
#line 95
      __cil_tmp15 = PixOrCopyArgb(v);
#line 95
      PrefixEncode((int )__cil_tmp15, & code, & extra_bits_count, & extra_bits_value);
#line 97
      (histo->distance_[code]) ++;
      }
    }
  }
#line 101
  return;
}
}
#line 101 "/root/patchweave_new/13/src/enc/histogram.c"
static double BitsEntropy(int const   *array , int n ) 
{ 
  double retval ;
  int sum ;
  int nonzeros ;
  int max_val ;
  int i ;
  double mix ;
  float __cil_tmp9 ;
  float __cil_tmp10 ;
  double min_limit ;
  double tmp ;

  {
#line 102
  retval = 0.;
#line 103
  sum = 0;
#line 104
  nonzeros = 0;
#line 105
  max_val = 0;
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;

#line 108
    if (! (i < n)) {
#line 108
      goto while_break;
    }
#line 109
    if (*(array + i) != 0) {
      {
#line 110
      sum += (int )*(array + i);
#line 111
      nonzeros ++;
#line 112
      __cil_tmp9 = VP8LFastSLog2((int )*(array + i));
#line 112
      retval -= (double )__cil_tmp9;
      }
#line 113
      if (max_val < (int )*(array + i)) {
#line 114
        max_val = (int )*(array + i);
      }
    }
#line 108
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 118
  __cil_tmp10 = VP8LFastSLog2(sum);
#line 118
  retval += (double )__cil_tmp10;
  }
#line 120
  if (nonzeros < 5) {
#line 121
    if (nonzeros <= 1) {
#line 122
      return ((double )0);
    }
#line 127
    if (nonzeros == 2) {
#line 128
      return (0.99 * (double )sum + 0.0100000000001 * retval);
    }
#line 134
    if (nonzeros == 3) {
#line 135
      mix = 0.95;
    } else {
#line 137
      mix = 0.7;
    }
  } else {
#line 140
    mix = 0.627000000001;
  }
#line 144
  min_limit = (double )(2 * sum - max_val);
#line 145
  min_limit = mix * min_limit + (1. - mix) * retval;
#line 146
  if (retval < min_limit) {
#line 146
    tmp = min_limit;
  } else {
#line 146
    tmp = retval;
  }
#line 146
  return (tmp);
}
}
#line 154 "/root/patchweave_new/13/src/enc/histogram.c"
static int kHuffmanCodeOfHuffmanCodeSize  ;
#line 155 "/root/patchweave_new/13/src/enc/histogram.c"
static double kSmallBias  ;
#line 152 "/root/patchweave_new/13/src/enc/histogram.c"
static double HuffmanCost(int const   *population , int length ) 
{ 
  double retval ;
  int streak ;
  int i ;

  {
#line 155
  kHuffmanCodeOfHuffmanCodeSize = 57;
#line 156
  kSmallBias = 9.1;
#line 157
  retval = (double )kHuffmanCodeOfHuffmanCodeSize - kSmallBias;
#line 158
  streak = 0;
#line 159
  i = 0;
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 160
    if (! (i < length - 1)) {
#line 160
      goto while_break;
    }
#line 161
    streak ++;
#line 162
    if (*(population + i) == *(population + (i + 1))) {
#line 163
      goto while_continue;
    }
    last_streak_hack: 
#line 167
    if (streak > 3) {
#line 168
      if (*(population + i) == 0) {
#line 169
        retval += 1.5625 + 0.234375 * (double )streak;
      } else {
#line 171
        retval += 2.578125 + 0.703125 * (double )streak;
      }
    } else
#line 174
    if (*(population + i) == 0) {
#line 175
      retval += 1.796875 * (double )streak;
    } else {
#line 177
      retval += 3.28125 * (double )streak;
    }
#line 180
    streak = 0;
#line 160
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 182
  if (i == length - 1) {
#line 183
    streak ++;
#line 184
    goto last_streak_hack;
  }
#line 186
  return (retval);
}
}
#line 189 "/root/patchweave_new/13/src/enc/histogram.c"
static double PopulationCost(int const   *population , int length ) 
{ 
  double __cil_tmp3 ;
  double __cil_tmp4 ;

  {
  {
#line 190
  __cil_tmp4 = HuffmanCost(population, length);
#line 190
  __cil_tmp3 = BitsEntropy(population, length);
  }
#line 190
  return (__cil_tmp3 + __cil_tmp4);
}
}
#line 193 "/root/patchweave_new/13/src/enc/histogram.c"
static double ExtraCost(int const   *population , int length ) 
{ 
  int i ;
  double cost ;

  {
#line 195
  cost = 0.;
#line 196
  i = 2;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 196
    if (! (i < length - 2)) {
#line 196
      goto while_break;
    }
#line 196
    cost += (double )((i >> 1) * (int )*(population + (i + 2)));
#line 196
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 197
  return (cost);
}
}
#line 201 "/root/patchweave_new/13/src/enc/histogram.c"
double VP8LHistogramEstimateBits(VP8LHistogram *p ) 
{ 
  int __cil_tmp2 ;
  double __cil_tmp3 ;
  double __cil_tmp4 ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;

  {
  {
#line 202
  __cil_tmp9 = ExtraCost((int const   *)(p->distance_), 40);
#line 202
  __cil_tmp8 = ExtraCost((int const   *)(p->literal_) + 256, 24);
#line 202
  __cil_tmp7 = PopulationCost((int const   *)(p->distance_), 40);
#line 202
  __cil_tmp6 = PopulationCost((int const   *)(p->alpha_), 256);
#line 202
  __cil_tmp5 = PopulationCost((int const   *)(p->blue_), 256);
#line 202
  __cil_tmp4 = PopulationCost((int const   *)(p->red_), 256);
#line 202
  __cil_tmp2 = VP8LHistogramNumCodes(p);
#line 202
  __cil_tmp3 = PopulationCost((int const   *)(p->literal_), __cil_tmp2);
  }
#line 202
  return ((((((__cil_tmp3 + __cil_tmp4) + __cil_tmp5) + __cil_tmp6) + __cil_tmp7) + __cil_tmp8) + __cil_tmp9);
}
}
#line 211 "/root/patchweave_new/13/src/enc/histogram.c"
double VP8LHistogramEstimateBitsBulk(VP8LHistogram *p ) 
{ 
  int __cil_tmp2 ;
  double __cil_tmp3 ;
  double __cil_tmp4 ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;

  {
  {
#line 212
  __cil_tmp9 = ExtraCost((int const   *)(p->distance_), 40);
#line 212
  __cil_tmp8 = ExtraCost((int const   *)(p->literal_) + 256, 24);
#line 212
  __cil_tmp7 = BitsEntropy((int const   *)(p->distance_), 40);
#line 212
  __cil_tmp6 = BitsEntropy((int const   *)(p->alpha_), 256);
#line 212
  __cil_tmp5 = BitsEntropy((int const   *)(p->blue_), 256);
#line 212
  __cil_tmp4 = BitsEntropy((int const   *)(p->red_), 256);
#line 212
  __cil_tmp2 = VP8LHistogramNumCodes(p);
#line 212
  __cil_tmp3 = BitsEntropy((int const   *)(p->literal_), __cil_tmp2);
  }
#line 212
  return ((((((__cil_tmp3 + __cil_tmp4) + __cil_tmp5) + __cil_tmp6) + __cil_tmp7) + __cil_tmp8) + __cil_tmp9);
}
}
#line 225 "/root/patchweave_new/13/src/enc/histogram.c"
static void HistogramAdd(VP8LHistogram *in , VP8LHistogram *out ) 
{ 
  int i ;

  {
#line 228
  i = 0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;

#line 228
    if (! (i < 280 + (1 << 9))) {
#line 228
      goto while_break;
    }
#line 229
    out->literal_[i] += in->literal_[i];
#line 228
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 231
  i = 0;
  {
#line 231
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 231
    if (! (i < 40)) {
#line 231
      goto while_break___0;
    }
#line 232
    out->distance_[i] += in->distance_[i];
#line 231
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 234
  i = 0;
  {
#line 234
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 234
    if (! (i < 256)) {
#line 234
      goto while_break___1;
    }
#line 235
    out->red_[i] += in->red_[i];
#line 236
    out->blue_[i] += in->blue_[i];
#line 237
    out->alpha_[i] += in->alpha_[i];
#line 234
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 238
  return;
}
}
#line 247 "/root/patchweave_new/13/src/enc/histogram.c"
static double HistogramAddEval(VP8LHistogram *a , VP8LHistogram *b , VP8LHistogram *out ,
                               double cost_threshold ) 
{ 
  double cost ;
  double sum_cost ;
  int i ;
  int tmp ;
  int __cil_tmp9 ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;
  double __cil_tmp14 ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;

  {
#line 251
  cost = (double )0;
#line 252
  sum_cost = a->bit_cost_ + b->bit_cost_;
#line 255
  cost_threshold += sum_cost;
#line 259
  if (a->palette_code_bits_ > b->palette_code_bits_) {
#line 259
    tmp = a->palette_code_bits_;
  } else {
#line 259
    tmp = b->palette_code_bits_;
  }
#line 259
  out->palette_code_bits_ = tmp;
#line 262
  i = 0;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;

#line 262
    if (! (i < 280 + (1 << 9))) {
#line 262
      goto while_break;
    }
#line 263
    out->literal_[i] = a->literal_[i] + b->literal_[i];
#line 262
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 265
  __cil_tmp9 = VP8LHistogramNumCodes(out);
#line 265
  __cil_tmp10 = PopulationCost((int const   *)(out->literal_), __cil_tmp9);
#line 265
  cost += __cil_tmp10;
#line 266
  __cil_tmp11 = ExtraCost((int const   *)(out->literal_ + 256), 24);
#line 266
  cost += __cil_tmp11;
  }
#line 267
  if (cost > cost_threshold) {
#line 267
    return (cost);
  }
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 269
    if (! (i < 256)) {
#line 269
      goto while_break___0;
    }
#line 269
    out->red_[i] = a->red_[i] + b->red_[i];
#line 269
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 270
  __cil_tmp12 = PopulationCost((int const   *)(out->red_), 256);
#line 270
  cost += __cil_tmp12;
  }
#line 271
  if (cost > cost_threshold) {
#line 271
    return (cost);
  }
#line 273
  i = 0;
  {
#line 273
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 273
    if (! (i < 256)) {
#line 273
      goto while_break___1;
    }
#line 273
    out->blue_[i] = a->blue_[i] + b->blue_[i];
#line 273
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 274
  __cil_tmp13 = PopulationCost((int const   *)(out->blue_), 256);
#line 274
  cost += __cil_tmp13;
  }
#line 275
  if (cost > cost_threshold) {
#line 275
    return (cost);
  }
#line 277
  i = 0;
  {
#line 277
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 277
    if (! (i < 40)) {
#line 277
      goto while_break___2;
    }
#line 278
    out->distance_[i] = a->distance_[i] + b->distance_[i];
#line 277
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 280
  __cil_tmp14 = PopulationCost((int const   *)(out->distance_), 40);
#line 280
  cost += __cil_tmp14;
#line 281
  __cil_tmp15 = ExtraCost((int const   *)(out->distance_), 40);
#line 281
  cost += __cil_tmp15;
  }
#line 282
  if (cost > cost_threshold) {
#line 282
    return (cost);
  }
#line 284
  i = 0;
  {
#line 284
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 284
    if (! (i < 256)) {
#line 284
      goto while_break___3;
    }
#line 284
    out->alpha_[i] = a->alpha_[i] + b->alpha_[i];
#line 284
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: 
  {
#line 285
  __cil_tmp16 = PopulationCost((int const   *)(out->alpha_), 256);
#line 285
  cost += __cil_tmp16;
#line 287
  out->bit_cost_ = cost;
  }
#line 288
  return (cost - sum_cost);
}
}
#line 294 "/root/patchweave_new/13/src/enc/histogram.c"
static double HistogramAddThresh(VP8LHistogram *a , VP8LHistogram *b , double cost_threshold ) 
{ 
  int tmp[792] ;
  int i ;
  double cost ;
  int __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;
  double __cil_tmp14 ;

  {
#line 299
  cost = - a->bit_cost_;
#line 301
  i = 0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;

#line 301
    if (! (i < 280 + (1 << 9))) {
#line 301
      goto while_break;
    }
#line 302
    tmp[i] = a->literal_[i] + b->literal_[i];
#line 301
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 306
  __cil_tmp7 = VP8LHistogramNumCodes(a);
#line 306
  __cil_tmp8 = PopulationCost((int const   *)(tmp), __cil_tmp7);
#line 306
  cost += __cil_tmp8;
#line 307
  __cil_tmp9 = ExtraCost((int const   *)(tmp + 256), 24);
#line 307
  cost += __cil_tmp9;
  }
#line 308
  if (cost > cost_threshold) {
#line 308
    return (cost);
  }
#line 310
  i = 0;
  {
#line 310
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 310
    if (! (i < 256)) {
#line 310
      goto while_break___0;
    }
#line 310
    tmp[i] = a->red_[i] + b->red_[i];
#line 310
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 311
  __cil_tmp10 = PopulationCost((int const   *)(tmp), 256);
#line 311
  cost += __cil_tmp10;
  }
#line 312
  if (cost > cost_threshold) {
#line 312
    return (cost);
  }
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 314
    if (! (i < 256)) {
#line 314
      goto while_break___1;
    }
#line 314
    tmp[i] = a->blue_[i] + b->blue_[i];
#line 314
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 315
  __cil_tmp11 = PopulationCost((int const   *)(tmp), 256);
#line 315
  cost += __cil_tmp11;
  }
#line 316
  if (cost > cost_threshold) {
#line 316
    return (cost);
  }
#line 318
  i = 0;
  {
#line 318
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 318
    if (! (i < 40)) {
#line 318
      goto while_break___2;
    }
#line 319
    tmp[i] = a->distance_[i] + b->distance_[i];
#line 318
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 321
  __cil_tmp12 = PopulationCost((int const   *)(tmp), 40);
#line 321
  cost += __cil_tmp12;
#line 322
  __cil_tmp13 = ExtraCost((int const   *)(tmp), 40);
#line 322
  cost += __cil_tmp13;
  }
#line 323
  if (cost > cost_threshold) {
#line 323
    return (cost);
  }
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 325
    if (! (i < 256)) {
#line 325
      goto while_break___3;
    }
#line 325
    tmp[i] = a->alpha_[i] + b->alpha_[i];
#line 325
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: 
  {
#line 326
  __cil_tmp14 = PopulationCost((int const   *)(tmp), 256);
#line 326
  cost += __cil_tmp14;
  }
#line 328
  return (cost);
}
}
#line 333 "/root/patchweave_new/13/src/enc/histogram.c"
static void HistogramBuildImage(int xsize , int histo_bits , VP8LBackwardRefs *backward_refs ,
                                VP8LHistogramSet *image ) 
{ 
  int i ;
  int x ;
  int y ;
  int histo_xsize ;
  uint32_t __cil_tmp9 ;
  VP8LHistogram **histograms ;
  PixOrCopy *v ;
  int ix ;
  uint32_t __cil_tmp14 ;

  {
  {
#line 337
  x = 0;
#line 337
  y = 0;
#line 338
  __cil_tmp9 = VP8LSubSampleSize((uint32_t )xsize, (uint32_t )histo_bits);
#line 338
  histo_xsize = (int )__cil_tmp9;
#line 339
  histograms = image->histograms;
#line 341
  i = 0;
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;

#line 341
    if (! (i < backward_refs->size)) {
#line 341
      goto while_break;
    }
    {
#line 342
    v = backward_refs->refs + i;
#line 343
    ix = (y >> histo_bits) * histo_xsize + (x >> histo_bits);
#line 344
    VP8LHistogramAddSinglePixOrCopy(*(histograms + ix), v);
#line 345
    __cil_tmp14 = PixOrCopyLength(v);
#line 345
    x = (int )((uint32_t )x + __cil_tmp14);
    }
    {
#line 346
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 346
      if (! (x >= xsize)) {
#line 346
        goto while_break___0;
      }
#line 347
      x -= xsize;
#line 348
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 341
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 345
  return;
}
}
#line 353 "/root/patchweave_new/13/src/enc/histogram.c"
static uint32_t MyRand(uint32_t *seed ) 
{ 


  {
#line 354
  *seed *= 16807U;
#line 355
  if (*seed == 0U) {
#line 356
    *seed = (uint32_t )1;
  }
#line 358
  return (*seed);
}
}
#line 361 "/root/patchweave_new/13/src/enc/histogram.c"
static int HistogramCombine(VP8LHistogramSet *in , VP8LHistogramSet *out , int iter_mult ,
                            int num_pairs , int num_tries_no_success ) 
{ 
  int ok ;
  int i ;
  int iter ;
  uint32_t seed ;
  int tries_with_no_success ;
  int out_size ;
  int outer_iters ;
  int min_cluster_size ;
  VP8LHistogram *histos ;
  void *__cil_tmp15 ;
  VP8LHistogram *cur_combo ;
  VP8LHistogram *best_combo ;
  double best_cost_diff ;
  int best_idx1 ;
  int best_idx2 ;
  int j ;
  int num_tries ;
  int tmp___0 ;
  double curr_cost_diff ;
  uint32_t idx1 ;
  uint32_t __cil_tmp28 ;
  uint32_t tmp___1 ;
  uint32_t diff ;
  uint32_t __cil_tmp31 ;
  uint32_t tmp___11 ;
  uint32_t idx2 ;
  VP8LHistogram *tmp_histo ;

  {
  {
#line 364
  ok = 0;
#line 366
  seed = (uint32_t )0;
#line 367
  tries_with_no_success = 0;
#line 368
  out_size = in->size;
#line 369
  outer_iters = in->size * iter_mult;
#line 370
  min_cluster_size = 2;
#line 371
  __cil_tmp15 = malloc(2UL * sizeof(*histos));
#line 371
  histos = (VP8LHistogram *)__cil_tmp15;
#line 372
  cur_combo = histos + 0;
#line 373
  best_combo = histos + 1;
  }
#line 374
  if ((unsigned long )histos == (unsigned long )((void *)0)) {
#line 374
    goto End;
  }
#line 378
  i = 0;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;

#line 378
    if (! (i < in->size)) {
#line 378
      goto while_break;
    }
    {
#line 379
    (*(in->histograms + i))->bit_cost_ = VP8LHistogramEstimateBits(*(in->histograms + i));
#line 380
    *(*(out->histograms + i)) = *(*(in->histograms + i));
#line 378
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 384
  iter = 0;
  {
#line 384
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 384
    if (iter < outer_iters) {
#line 384
      if (! (out_size >= min_cluster_size)) {
#line 384
        goto while_break___0;
      }
    } else {
#line 384
      goto while_break___0;
    }
#line 385
    best_cost_diff = 0.;
#line 386
    best_idx1 = -1;
#line 386
    best_idx2 = 1;
#line 388
    if (num_pairs < out_size) {
#line 388
      tmp___0 = num_pairs;
    } else {
#line 388
      tmp___0 = out_size;
    }
#line 388
    num_tries = tmp___0;
#line 389
    seed += (unsigned int )iter;
#line 390
    j = 0;
    {
#line 390
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___1: ;
#line 390
      if (! (j < num_tries)) {
#line 390
        goto while_break___1;
      }
      {
#line 393
      __cil_tmp28 = MyRand(& seed);
#line 393
      idx1 = __cil_tmp28 % (unsigned int )out_size;
#line 394
      tmp___1 = (uint32_t )((j & 7) + 1);
      }
#line 395
      if (tmp___1 < 3U) {
#line 395
        tmp___11 = tmp___1;
      } else {
        {
#line 395
        __cil_tmp31 = MyRand(& seed);
#line 395
        tmp___11 = __cil_tmp31 % (unsigned int )(out_size - 1);
        }
      }
#line 395
      diff = tmp___11;
#line 396
      idx2 = ((idx1 + diff) + 1U) % (unsigned int )out_size;
#line 397
      if (idx1 == idx2) {
#line 398
        goto while_continue___1;
      }
      {
#line 401
      curr_cost_diff = HistogramAddEval(*(out->histograms + idx1), *(out->histograms + idx2),
                                        cur_combo, best_cost_diff);
      }
#line 404
      if (curr_cost_diff < best_cost_diff) {
#line 406
        tmp_histo = cur_combo;
#line 407
        cur_combo = best_combo;
#line 408
        best_combo = tmp_histo;
#line 410
        best_cost_diff = curr_cost_diff;
#line 411
        best_idx1 = (int )idx1;
#line 412
        best_idx2 = (int )idx2;
      }
#line 390
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
#line 416
    if (best_idx1 >= 0) {
#line 417
      *(*(out->histograms + best_idx1)) = *best_combo;
#line 419
      out_size --;
#line 420
      if (best_idx2 != out_size) {
#line 421
        *(out->histograms + best_idx2) = *(out->histograms + out_size);
#line 422
        *(out->histograms + out_size) = (VP8LHistogram *)((void *)0);
      }
#line 424
      tries_with_no_success = 0;
    }
#line 426
    tries_with_no_success ++;
#line 426
    if (tries_with_no_success >= num_tries_no_success) {
#line 427
      goto while_break___0;
    }
#line 384
    iter ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 430
  out->size = out_size;
#line 431
  ok = 1;
  End: 
  {
#line 434
  free((void *)histos);
  }
#line 435
  return (ok);
}
}
#line 442 "/root/patchweave_new/13/src/enc/histogram.c"
static double HistogramDistance(VP8LHistogram *square_histogram , VP8LHistogram *candidate ,
                                double cost_threshold ) 
{ 
  double __cil_tmp4 ;

  {
  {
#line 445
  __cil_tmp4 = HistogramAddThresh(candidate, square_histogram, cost_threshold);
  }
#line 445
  return (__cil_tmp4);
}
}
#line 450 "/root/patchweave_new/13/src/enc/histogram.c"
static void HistogramRemap(VP8LHistogramSet *in , VP8LHistogramSet *out , uint16_t *symbols ) 
{ 
  int i ;
  int best_out ;
  double best_bits ;
  double __cil_tmp7 ;
  int k ;
  double cur_bits ;
  double __cil_tmp10 ;

  {
#line 454
  i = 0;
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;

#line 454
    if (! (i < in->size)) {
#line 454
      goto while_break;
    }
    {
#line 455
    best_out = 0;
#line 456
    __cil_tmp7 = HistogramDistance(*(in->histograms + i), *(out->histograms + 0),
                                   1e+38);
#line 456
    best_bits = __cil_tmp7;
#line 459
    k = 1;
    }
    {
#line 459
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 459
      if (! (k < out->size)) {
#line 459
        goto while_break___0;
      }
      {
#line 460
      __cil_tmp10 = HistogramDistance(*(in->histograms + i), *(out->histograms + k),
                                      best_bits);
#line 460
      cur_bits = __cil_tmp10;
      }
#line 462
      if (cur_bits < best_bits) {
#line 463
        best_bits = cur_bits;
#line 464
        best_out = k;
      }
#line 459
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 467
    *(symbols + i) = (uint16_t )best_out;
#line 454
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 471
  i = 0;
  {
#line 471
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 471
    if (! (i < out->size)) {
#line 471
      goto while_break___1;
    }
    {
#line 472
    HistogramClear(*(out->histograms + i));
#line 471
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: 
#line 474
  i = 0;
  {
#line 474
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 474
    if (! (i < in->size)) {
#line 474
      goto while_break___2;
    }
    {
#line 475
    HistogramAdd(*(in->histograms + i), *(out->histograms + (int )*(symbols + i)));
#line 474
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 478
  return;
}
}
#line 479 "/root/patchweave_new/13/src/enc/histogram.c"
int VP8LGetHistoImageSymbols(int xsize , int ysize , VP8LBackwardRefs *refs , int quality ,
                             int histo_bits , int cache_bits , VP8LHistogramSet *image_in ,
                             uint16_t *histogram_symbols ) 
{ 
  int ok ;
  int histo_xsize ;
  uint32_t __cil_tmp11 ;
  uint32_t tmp ;
  int histo_ysize ;
  uint32_t __cil_tmp14 ;
  uint32_t tmp___0 ;
  int histo_image_raw_size ;
  int num_tries_no_success ;
  int iter_mult ;
  int tmp___1 ;
  int num_pairs ;
  int tmp___2 ;
  VP8LHistogramSet *image_out ;
  VP8LHistogramSet *__cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 484
  ok = 0;
#line 485
  if (histo_bits) {
    {
#line 485
    __cil_tmp11 = VP8LSubSampleSize((uint32_t )xsize, (uint32_t )histo_bits);
#line 485
    tmp = __cil_tmp11;
    }
  } else {
#line 485
    tmp = 1U;
  }
#line 485
  histo_xsize = (int )tmp;
#line 486
  if (histo_bits) {
    {
#line 486
    __cil_tmp14 = VP8LSubSampleSize((uint32_t )ysize, (uint32_t )histo_bits);
#line 486
    tmp___0 = __cil_tmp14;
    }
  } else {
#line 486
    tmp___0 = 1U;
  }
#line 486
  histo_ysize = (int )tmp___0;
#line 487
  histo_image_raw_size = histo_xsize * histo_ysize;
#line 490
  num_tries_no_success = 8 + (quality >> 1);
#line 491
  if (quality < 27) {
#line 491
    tmp___1 = 1;
  } else {
#line 491
    tmp___1 = 1 + ((quality - 27) >> 4);
  }
#line 491
  iter_mult = tmp___1;
#line 492
  if (quality < 25) {
#line 492
    tmp___2 = 10;
  } else {
#line 492
    tmp___2 = 5 * quality >> 3;
  }
  {
#line 492
  num_pairs = tmp___2;
#line 494
  __cil_tmp23 = VP8LAllocateHistogramSet(histo_image_raw_size, cache_bits);
#line 494
  image_out = __cil_tmp23;
  }
#line 496
  if ((unsigned long )image_out == (unsigned long )((void *)0)) {
#line 496
    return (0);
  }
  {
#line 499
  HistogramBuildImage(xsize, histo_bits, refs, image_out);
#line 501
  __cil_tmp24 = HistogramCombine(image_out, image_in, iter_mult, num_pairs, num_tries_no_success);
  }
#line 501
  if (! __cil_tmp24) {
#line 503
    goto Error;
  }
  {
#line 506
  HistogramRemap(image_out, image_in, histogram_symbols);
#line 507
  ok = 1;
  }
  Error: 
  {
#line 510
  free((void *)image_out);
  }
#line 511
  return (ok);
}
}
#line 43 "/root/patchweave_new/13/src/enc/frame.c"
uint8_t VP8EncBands[17]  = 
#line 43 "/root/patchweave_new/13/src/enc/frame.c"
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )6,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0};
#line 48 "/root/patchweave_new/13/src/enc/frame.c"
uint8_t VP8Cat3[3]  = {      (uint8_t )173,      (uint8_t )148,      (uint8_t )140};
#line 49 "/root/patchweave_new/13/src/enc/frame.c"
uint8_t VP8Cat4[4]  = {      (uint8_t )176,      (uint8_t )155,      (uint8_t )140,      (uint8_t )135};
#line 50 "/root/patchweave_new/13/src/enc/frame.c"
uint8_t VP8Cat5[5]  = {      (uint8_t )180,      (uint8_t )157,      (uint8_t )141,      (uint8_t )134, 
        (uint8_t )130};
#line 51 "/root/patchweave_new/13/src/enc/frame.c"
uint8_t VP8Cat6[11]  = 
#line 51
  {      (uint8_t )254,      (uint8_t )254,      (uint8_t )243,      (uint8_t )230, 
        (uint8_t )196,      (uint8_t )177,      (uint8_t )153,      (uint8_t )140, 
        (uint8_t )133,      (uint8_t )130,      (uint8_t )129};
#line 57 "/root/patchweave_new/13/src/enc/frame.c"
static void ResetStats(VP8Encoder *enc ) 
{ 
  VP8Proba *proba ;

  {
  {
#line 58
  proba = & enc->proba_;
#line 59
  VP8CalculateLevelCosts(proba);
#line 60
  proba->nb_skip_ = 0;
  }
#line 62
  return;
}
}
#line 68 "/root/patchweave_new/13/src/enc/frame.c"
static int CalcSkipProba(uint64_t nb , uint64_t total ) 
{ 
  uint64_t tmp ;

  {
#line 69
  if (total) {
#line 69
    tmp = ((total - nb) * 255UL) / total;
  } else {
#line 69
    tmp = 255UL;
  }
#line 69
  return ((int )tmp);
}
}
#line 73 "/root/patchweave_new/13/src/enc/frame.c"
static int FinalizeSkipProba(VP8Encoder *enc ) 
{ 
  VP8Proba *proba ;
  int nb_mbs ;
  int nb_events ;
  int size ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 74
  proba = & enc->proba_;
#line 75
  nb_mbs = enc->mb_w_ * enc->mb_h_;
#line 76
  nb_events = proba->nb_skip_;
#line 78
  __cil_tmp6 = CalcSkipProba((uint64_t )nb_events, (uint64_t )nb_mbs);
#line 78
  proba->skip_proba_ = (uint8_t )__cil_tmp6;
#line 79
  proba->use_skip_proba_ = (int )proba->skip_proba_ < 250;
#line 80
  size = 256;
  }
#line 81
  if (proba->use_skip_proba_) {
    {
#line 82
    __cil_tmp8 = VP8BitCost(0, proba->skip_proba_);
#line 82
    __cil_tmp7 = VP8BitCost(1, proba->skip_proba_);
#line 82
    size += nb_events * __cil_tmp7 + (nb_mbs - nb_events) * __cil_tmp8;
#line 84
    size += 2048;
    }
  }
#line 86
  return (size);
}
}
#line 92 "/root/patchweave_new/13/src/enc/frame.c"
static void ResetTokenStats(VP8Encoder *enc ) 
{ 
  VP8Proba *proba ;

  {
  {
#line 93
  proba = & enc->proba_;
#line 94
  memset((void *)(proba->stats_), 0, sizeof(proba->stats_));
  }
#line 96
  return;
}
}
#line 98 "/root/patchweave_new/13/src/enc/frame.c"
static int Record(int bit , proba_t *stats ) 
{ 
  proba_t p ;

  {
#line 99
  p = *stats;
#line 100
  if (p >= 4294901760U) {
#line 101
    p = ((p + 1U) >> 1) & 2147450879U;
  }
#line 104
  p += 65536U + (unsigned int )bit;
#line 105
  *stats = p;
#line 106
  return (bit);
}
}
#line 114 "/root/patchweave_new/13/src/enc/frame.c"
static int RecordCoeffs(int ctx , VP8Residual *res ) 
{ 
  int n ;
  proba_t *s ;
  int v ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int bits ;
  int pattern ;
  int i ;
  int mask ;

  {
#line 115
  n = res->first;
#line 117
  s = (*(res->stats + n))[ctx];
#line 118
  if (res->last < 0) {
    {
#line 119
    Record(0, s + 0);
    }
#line 120
    return (0);
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;

#line 122
    if (! (n <= res->last)) {
#line 122
      goto while_break;
    }
    {
#line 124
    Record(1, s + 0);
    }
    {
#line 125
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 125
      __cil_tmp6 = n;
#line 125
      n ++;
#line 125
      v = (int )*(res->coeffs + __cil_tmp6);
#line 125
      if (! (v == 0)) {
#line 125
        goto while_break___0;
      }
      {
#line 126
      Record(0, s + 1);
#line 127
      s = (*(res->stats + (int )VP8EncBands[n]))[0];
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 129
    Record(1, s + 1);
#line 130
    __cil_tmp7 = Record(2U < (unsigned int )(v + 1), s + 2);
    }
#line 130
    if (! __cil_tmp7) {
#line 131
      s = (*(res->stats + (int )VP8EncBands[n]))[1];
    } else {
      {
#line 133
      v = abs(v);
      }
#line 146
      if (v > 67) {
#line 147
        v = 67;
      }
#line 150
      bits = (int )VP8LevelCodes[v - 1][1];
#line 151
      pattern = (int )VP8LevelCodes[v - 1][0];
#line 153
      i = 0;
      {
#line 153
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 153
        if (! (pattern != 0)) {
#line 153
          goto while_break___1;
        }
#line 154
        mask = 2 << i;
#line 155
        if (pattern & 1) {
          {
#line 155
          Record(! (! (bits & mask)), (s + 3) + i);
          }
        }
#line 153
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 159
      s = (*(res->stats + (int )VP8EncBands[n]))[2];
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 162
  if (n < 16) {
    {
#line 162
    Record(0, s + 0);
    }
  }
#line 163
  return (1);
}
}
#line 168 "/root/patchweave_new/13/src/enc/frame.c"
static int CalcTokenProba(int nb , int total ) 
{ 
  int tmp___0 ;

  {
#line 170
  if (nb) {
#line 170
    tmp___0 = 255 - (nb * 255) / total;
  } else {
#line 170
    tmp___0 = 255;
  }
#line 170
  return (tmp___0);
}
}
#line 174 "/root/patchweave_new/13/src/enc/frame.c"
static int BranchCost(int nb , int total , int proba ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 175
  __cil_tmp5 = VP8BitCost(0, (uint8_t )proba);
#line 175
  __cil_tmp4 = VP8BitCost(1, (uint8_t )proba);
  }
#line 175
  return (nb * __cil_tmp4 + (total - nb) * __cil_tmp5);
}
}
#line 178 "/root/patchweave_new/13/src/enc/frame.c"
static int FinalizeTokenProbas(VP8Proba *proba ) 
{ 
  int has_changed ;
  int size ;
  int t ;
  int b ;
  int c ;
  int p ;
  proba_t stats ;
  int nb ;
  int total ;
  int update_proba ;
  int old_p ;
  int new_p ;
  int __cil_tmp14 ;
  int old_cost ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int new_cost ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int use_new_p ;
  int __cil_tmp22 ;

  {
#line 179
  has_changed = 0;
#line 180
  size = 0;
#line 182
  t = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;

#line 182
    if (! (t < 4)) {
#line 182
      goto while_break;
    }
#line 183
    b = 0;
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 183
      if (! (b < 8)) {
#line 183
        goto while_break___0;
      }
#line 184
      c = 0;
      {
#line 184
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 184
        if (! (c < 3)) {
#line 184
          goto while_break___1;
        }
#line 185
        p = 0;
        {
#line 185
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 185
          if (! (p < 11)) {
#line 185
            goto while_break___2;
          }
          {
#line 186
          stats = proba->stats_[t][b][c][p];
#line 187
          nb = (int )(stats & 65535U);
#line 188
          total = (int )((stats >> 16) & 65535U);
#line 189
          update_proba = (int )VP8CoeffsUpdateProba[t][b][c][p];
#line 190
          old_p = (int )VP8CoeffsProba0[t][b][c][p];
#line 191
          __cil_tmp14 = CalcTokenProba(nb, total);
#line 191
          new_p = __cil_tmp14;
#line 192
          __cil_tmp17 = VP8BitCost(0, (uint8_t )update_proba);
#line 192
          __cil_tmp16 = BranchCost(nb, total, old_p);
#line 192
          old_cost = __cil_tmp16 + __cil_tmp17;
#line 194
          __cil_tmp20 = VP8BitCost(1, (uint8_t )update_proba);
#line 194
          __cil_tmp19 = BranchCost(nb, total, new_p);
#line 194
          new_cost = (__cil_tmp19 + __cil_tmp20) + 2048;
#line 197
          use_new_p = old_cost > new_cost;
#line 198
          __cil_tmp22 = VP8BitCost(use_new_p, (uint8_t )update_proba);
#line 198
          size += __cil_tmp22;
          }
#line 199
          if (use_new_p) {
#line 200
            proba->coeffs_[t][b][c][p] = (uint8_t )new_p;
#line 201
            has_changed |= new_p != old_p;
#line 202
            size += 2048;
          } else {
#line 204
            proba->coeffs_[t][b][c][p] = (uint8_t )old_p;
          }
#line 185
          p ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 184
        c ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 183
      b ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 182
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 210
  proba->dirty_ = has_changed;
#line 211
  return (size);
}
}
#line 217 "/root/patchweave_new/13/src/enc/frame.c"
static int GetProba(int a , int b ) 
{ 
  int total ;
  int tmp ;

  {
#line 218
  total = a + b;
#line 219
  if (total == 0) {
#line 219
    tmp = 255;
  } else {
#line 219
    tmp = (255 * a + total / 2) / total;
  }
#line 219
  return (tmp);
}
}
#line 223 "/root/patchweave_new/13/src/enc/frame.c"
static void SetSegmentProbas(VP8Encoder *enc ) 
{ 
  int p[4] ;
  unsigned int tmp ;
  int n ;
  VP8MBInfo *mb ;
  uint8_t *probas ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int tmp___0 ;

  {
#line 224
  p[0] = 0;
#line 224
  tmp = 1U;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;

#line 224
    if (tmp >= 4U) {
#line 224
      goto while_break;
    }
#line 224
    p[tmp] = 0;
#line 224
    tmp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 227
  n = 0;
  {
#line 227
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 227
    if (! (n < enc->mb_w_ * enc->mb_h_)) {
#line 227
      goto while_break___0;
    }
#line 228
    mb = enc->mb_info_ + n;
#line 229
    (p[mb->segment_]) ++;
#line 227
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 231
  if ((unsigned long )(enc->pic_)->stats != (unsigned long )((void *)0)) {
#line 232
    n = 0;
    {
#line 232
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 232
      if (! (n < 4)) {
#line 232
        goto while_break___1;
      }
#line 233
      ((enc->pic_)->stats)->segment_size[n] = p[n];
#line 232
      n ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 236
  if (enc->segment_hdr_.num_segments_ > 1) {
    {
#line 237
    probas = enc->proba_.segments_;
#line 238
    __cil_tmp8 = GetProba(p[0] + p[1], p[2] + p[3]);
#line 238
    *(probas + 0) = (uint8_t )__cil_tmp8;
#line 239
    __cil_tmp9 = GetProba(p[0], p[1]);
#line 239
    *(probas + 1) = (uint8_t )__cil_tmp9;
#line 240
    __cil_tmp10 = GetProba(p[2], p[3]);
#line 240
    *(probas + 2) = (uint8_t )__cil_tmp10;
    }
#line 242
    if ((int )*(probas + 0) != 255) {
#line 242
      tmp___0 = 1;
    } else
#line 242
    if ((int )*(probas + 1) != 255) {
#line 242
      tmp___0 = 1;
    } else
#line 242
    if ((int )*(probas + 2) != 255) {
#line 242
      tmp___0 = 1;
    } else {
#line 242
      tmp___0 = 0;
    }
    {
#line 242
    enc->segment_hdr_.update_map_ = tmp___0;
#line 244
    __cil_tmp18 = VP8BitCost(1, *(probas + 2));
#line 244
    __cil_tmp17 = VP8BitCost(1, *(probas + 0));
#line 244
    __cil_tmp16 = VP8BitCost(0, *(probas + 2));
#line 244
    __cil_tmp15 = VP8BitCost(1, *(probas + 0));
#line 244
    __cil_tmp14 = VP8BitCost(1, *(probas + 1));
#line 244
    __cil_tmp13 = VP8BitCost(0, *(probas + 0));
#line 244
    __cil_tmp12 = VP8BitCost(0, *(probas + 1));
#line 244
    __cil_tmp11 = VP8BitCost(0, *(probas + 0));
#line 244
    enc->segment_hdr_.size_ = ((p[0] * (__cil_tmp11 + __cil_tmp12) + p[1] * (__cil_tmp13 + __cil_tmp14)) + p[2] * (__cil_tmp15 + __cil_tmp16)) + p[3] * (__cil_tmp17 + __cil_tmp18);
    }
  } else {
#line 250
    enc->segment_hdr_.update_map_ = 0;
#line 251
    enc->segment_hdr_.size_ = 0;
  }
#line 253
  return;
}
}
#line 258 "/root/patchweave_new/13/src/enc/frame.c"
static void InitResidual(int first , int coeff_type , VP8Encoder *enc , VP8Residual *res ) 
{ 


  {
#line 260
  res->coeff_type = coeff_type;
#line 261
  res->prob = enc->proba_.coeffs_[coeff_type];
#line 262
  res->stats = enc->proba_.stats_[coeff_type];
#line 263
  res->cost = enc->proba_.level_cost_[coeff_type];
#line 264
  res->first = first;
#line 265
  return;
}
}
#line 267 "/root/patchweave_new/13/src/enc/frame.c"
static void SetResidualCoeffs(int16_t *coeffs , VP8Residual *res ) 
{ 
  int n ;

  {
#line 270
  res->last = -1;
#line 271
  n = 15;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;

#line 271
    if (! (n >= res->first)) {
#line 271
      goto while_break;
    }
#line 272
    if (*(coeffs + n)) {
#line 273
      res->last = n;
#line 274
      goto while_break;
    }
#line 271
    n --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 277
  res->coeffs = coeffs;
#line 278
  return;
}
}
#line 283 "/root/patchweave_new/13/src/enc/frame.c"
static int GetResidualCost(int ctx0 , VP8Residual *res ) 
{ 
  int n ;
  int p0 ;
  uint16_t *t ;
  int cost ;
  int __cil_tmp7 ;
  int v ;
  int b ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int ctx ;
  int tmp ;
  int v___0 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int b___0 ;
  int ctx___0 ;
  int tmp___1 ;
  int last_p0 ;
  int __cil_tmp24 ;

  {
#line 284
  n = res->first;
#line 286
  p0 = (int )(*(res->prob + n))[ctx0][0];
#line 287
  t = (*(res->cost + n))[ctx0];
#line 290
  if (res->last < 0) {
    {
#line 291
    __cil_tmp7 = VP8BitCost(0, (uint8_t )p0);
    }
#line 291
    return (__cil_tmp7);
  }
#line 293
  cost = 0;
  {
#line 294
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 294
    if (! (n < res->last)) {
#line 294
      goto while_break;
    }
#line 295
    v = (int )*(res->coeffs + n);
#line 296
    b = (int )VP8EncBands[n + 1];
#line 297
    n ++;
#line 298
    if (v == 0) {
#line 300
      cost += (int )*(t + 0);
#line 301
      t = (*(res->cost + b))[0];
#line 302
      goto while_continue;
    }
    {
#line 304
    v = abs(v);
#line 305
    __cil_tmp11 = VP8BitCost(1, (uint8_t )p0);
#line 305
    cost += __cil_tmp11;
#line 306
    __cil_tmp12 = VP8LevelCost(t, v);
#line 306
    cost += __cil_tmp12;
    }
#line 308
    if (v == 1) {
#line 308
      tmp = 1;
    } else {
#line 308
      tmp = 2;
    }
#line 308
    ctx = tmp;
#line 309
    p0 = (int )(*(res->prob + b))[ctx][0];
#line 310
    t = (*(res->cost + b))[ctx];
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 315
  __cil_tmp16 = abs((int )*(res->coeffs + n));
#line 315
  v___0 = __cil_tmp16;
#line 317
  __cil_tmp18 = VP8BitCost(1, (uint8_t )p0);
#line 317
  cost += __cil_tmp18;
#line 318
  __cil_tmp19 = VP8LevelCost(t, v___0);
#line 318
  cost += __cil_tmp19;
  }
#line 319
  if (n < 15) {
#line 320
    b___0 = (int )VP8EncBands[n + 1];
#line 321
    if (v___0 == 1) {
#line 321
      tmp___1 = 1;
    } else {
#line 321
      tmp___1 = 2;
    }
    {
#line 321
    ctx___0 = tmp___1;
#line 322
    last_p0 = (int )(*(res->prob + b___0))[ctx___0][0];
#line 323
    __cil_tmp24 = VP8BitCost(0, (uint8_t )last_p0);
#line 323
    cost += __cil_tmp24;
    }
  }
#line 326
  return (cost);
}
}
#line 329 "/root/patchweave_new/13/src/enc/frame.c"
int VP8GetCostLuma4(VP8EncIterator *it , int16_t *levels ) 
{ 
  int x ;
  int y ;
  VP8Residual res ;
  VP8Encoder *enc ;
  int R ;
  int ctx ;
  int __cil_tmp9 ;

  {
  {
#line 330
  x = it->i4_ & 3;
#line 330
  y = it->i4_ >> 2;
#line 332
  enc = it->enc_;
#line 333
  R = 0;
#line 336
  InitResidual(0, 3, enc, & res);
#line 337
  ctx = it->top_nz_[x] + it->left_nz_[y];
#line 338
  SetResidualCoeffs((int16_t *)levels, & res);
#line 339
  __cil_tmp9 = GetResidualCost(ctx, & res);
#line 339
  R += __cil_tmp9;
  }
#line 340
  return (R);
}
}
#line 343 "/root/patchweave_new/13/src/enc/frame.c"
int VP8GetCostLuma16(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Residual res ;
  VP8Encoder *enc ;
  int x ;
  int y ;
  int R ;
  int __cil_tmp8 ;
  int ctx ;
  int __cil_tmp10 ;

  {
  {
#line 345
  enc = it->enc_;
#line 347
  R = 0;
#line 349
  VP8IteratorNzToBytes(it);
#line 352
  InitResidual(0, 1, enc, & res);
#line 353
  SetResidualCoeffs(rd->y_dc_levels, & res);
#line 354
  __cil_tmp8 = GetResidualCost(it->top_nz_[8] + it->left_nz_[8], & res);
#line 354
  R += __cil_tmp8;
#line 357
  InitResidual(1, 0, enc, & res);
#line 358
  y = 0;
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;

#line 358
    if (! (y < 4)) {
#line 358
      goto while_break;
    }
#line 359
    x = 0;
    {
#line 359
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 359
      if (! (x < 4)) {
#line 359
        goto while_break___0;
      }
      {
#line 360
      ctx = it->top_nz_[x] + it->left_nz_[y];
#line 361
      SetResidualCoeffs(rd->y_ac_levels[x + y * 4], & res);
#line 362
      __cil_tmp10 = GetResidualCost(ctx, & res);
#line 362
      R += __cil_tmp10;
#line 363
      it->left_nz_[y] = res.last >= 0;
#line 363
      it->top_nz_[x] = it->left_nz_[y];
#line 359
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 358
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 366
  return (R);
}
}
#line 369 "/root/patchweave_new/13/src/enc/frame.c"
int VP8GetCostUV(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Residual res ;
  VP8Encoder *enc ;
  int ch ;
  int x ;
  int y ;
  int R ;
  int ctx ;
  int __cil_tmp10 ;

  {
  {
#line 371
  enc = it->enc_;
#line 373
  R = 0;
#line 375
  VP8IteratorNzToBytes(it);
#line 377
  InitResidual(0, 2, enc, & res);
#line 378
  ch = 0;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;

#line 378
    if (! (ch <= 2)) {
#line 378
      goto while_break;
    }
#line 379
    y = 0;
    {
#line 379
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 379
      if (! (y < 2)) {
#line 379
        goto while_break___0;
      }
#line 380
      x = 0;
      {
#line 380
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 380
        if (! (x < 2)) {
#line 380
          goto while_break___1;
        }
        {
#line 381
        ctx = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 382
        SetResidualCoeffs(rd->uv_levels[(ch * 2 + x) + y * 2], & res);
#line 383
        __cil_tmp10 = GetResidualCost(ctx, & res);
#line 383
        R += __cil_tmp10;
#line 384
        it->left_nz_[(4 + ch) + y] = res.last >= 0;
#line 384
        it->top_nz_[(4 + ch) + x] = it->left_nz_[(4 + ch) + y];
#line 380
        x ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 379
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 378
    ch += 2;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 388
  return (R);
}
}
#line 394 "/root/patchweave_new/13/src/enc/frame.c"
static int PutCoeffs(VP8BitWriter *bw , int ctx , VP8Residual *res ) 
{ 
  int n ;
  uint8_t *p ;
  int __cil_tmp6 ;
  int c ;
  int __cil_tmp8 ;
  int sign ;
  int v ;
  int tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int mask ;
  uint8_t *tab ;
  uint8_t *__cil_tmp20 ;
  int __cil_tmp21 ;

  {
  {
#line 395
  n = res->first;
#line 397
  p = (*(res->prob + n))[ctx];
#line 398
  __cil_tmp6 = VP8PutBit(bw, res->last >= 0, (int )*(p + 0));
  }
#line 398
  if (! __cil_tmp6) {
#line 399
    return (0);
  }
  {
#line 402
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 402
    if (! (n < 16)) {
#line 402
      goto while_break;
    }
#line 403
    __cil_tmp8 = n;
#line 403
    n ++;
#line 403
    c = (int )*(res->coeffs + __cil_tmp8);
#line 404
    sign = c < 0;
#line 405
    if (sign) {
#line 405
      tmp = - c;
    } else {
#line 405
      tmp = c;
    }
    {
#line 405
    v = tmp;
#line 406
    __cil_tmp12 = VP8PutBit(bw, v != 0, (int )*(p + 1));
    }
#line 406
    if (! __cil_tmp12) {
#line 407
      p = (*(res->prob + (int )VP8EncBands[n]))[0];
#line 408
      goto while_continue;
    }
    {
#line 410
    __cil_tmp13 = VP8PutBit(bw, v > 1, (int )*(p + 2));
    }
#line 410
    if (! __cil_tmp13) {
#line 411
      p = (*(res->prob + (int )VP8EncBands[n]))[1];
    } else {
      {
#line 413
      __cil_tmp14 = VP8PutBit(bw, v > 4, (int )*(p + 3));
      }
#line 413
      if (! __cil_tmp14) {
        {
#line 414
        __cil_tmp15 = VP8PutBit(bw, v != 2, (int )*(p + 4));
        }
#line 414
        if (__cil_tmp15) {
          {
#line 415
          VP8PutBit(bw, v == 4, (int )*(p + 5));
          }
        }
      } else {
        {
#line 416
        __cil_tmp16 = VP8PutBit(bw, v > 10, (int )*(p + 6));
        }
#line 416
        if (! __cil_tmp16) {
          {
#line 417
          __cil_tmp17 = VP8PutBit(bw, v > 6, (int )*(p + 7));
          }
#line 417
          if (! __cil_tmp17) {
            {
#line 418
            VP8PutBit(bw, v == 6, 159);
            }
          } else {
            {
#line 420
            VP8PutBit(bw, v >= 9, 165);
#line 421
            VP8PutBit(bw, ! (v & 1), 145);
            }
          }
        } else {
#line 426
          if (v < 3 + (8 << 1)) {
            {
#line 427
            VP8PutBit(bw, 0, (int )*(p + 8));
#line 428
            VP8PutBit(bw, 0, (int )*(p + 9));
#line 429
            v -= 11;
#line 430
            mask = 1 << 2;
#line 431
            tab = VP8Cat3;
            }
          } else
#line 432
          if (v < 3 + (8 << 2)) {
            {
#line 433
            VP8PutBit(bw, 0, (int )*(p + 8));
#line 434
            VP8PutBit(bw, 1, (int )*(p + 9));
#line 435
            v -= 3 + (8 << 1);
#line 436
            mask = 1 << 3;
#line 437
            tab = VP8Cat4;
            }
          } else
#line 438
          if (v < 3 + (8 << 3)) {
            {
#line 439
            VP8PutBit(bw, 1, (int )*(p + 8));
#line 440
            VP8PutBit(bw, 0, (int )*(p + 10));
#line 441
            v -= 3 + (8 << 2);
#line 442
            mask = 1 << 4;
#line 443
            tab = VP8Cat5;
            }
          } else {
            {
#line 445
            VP8PutBit(bw, 1, (int )*(p + 8));
#line 446
            VP8PutBit(bw, 1, (int )*(p + 10));
#line 447
            v -= 3 + (8 << 3);
#line 448
            mask = 1 << 10;
#line 449
            tab = VP8Cat6;
            }
          }
          {
#line 451
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 451
            if (! mask) {
#line 451
              goto while_break___0;
            }
            {
#line 452
            __cil_tmp20 = tab;
#line 452
            tab ++;
#line 452
            VP8PutBit(bw, ! (! (v & mask)), (int )*__cil_tmp20);
#line 453
            mask >>= 1;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break___0: ;
        }
      }
#line 456
      p = (*(res->prob + (int )VP8EncBands[n]))[2];
    }
    {
#line 458
    VP8PutBitUniform(bw, sign);
#line 459
    __cil_tmp21 = VP8PutBit(bw, n <= res->last, (int )*(p + 0));
    }
#line 459
    if (n == 16) {
#line 460
      return (1);
    } else
#line 459
    if (! __cil_tmp21) {
#line 460
      return (1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 463
  return (1);
}
}
#line 466 "/root/patchweave_new/13/src/enc/frame.c"
static void CodeResiduals(VP8BitWriter *bw , VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  int x ;
  int y ;
  int ch ;
  VP8Residual res ;
  uint64_t pos1 ;
  uint64_t pos2 ;
  uint64_t pos3 ;
  int i16 ;
  int segment ;
  VP8Encoder *enc ;
  int ctx ;
  int ctx___0 ;

  {
  {
#line 471
  i16 = (int )(it->mb_)->type_ == 1;
#line 472
  segment = (int )(it->mb_)->segment_;
#line 473
  enc = it->enc_;
#line 475
  VP8IteratorNzToBytes(it);
#line 477
  pos1 = VP8BitWriterPos(bw);
  }
#line 478
  if (i16) {
    {
#line 479
    InitResidual(0, 1, enc, & res);
#line 480
    SetResidualCoeffs(rd->y_dc_levels, & res);
#line 481
    it->top_nz_[8] = PutCoeffs(bw, it->top_nz_[8] + it->left_nz_[8], & res);
#line 483
    InitResidual(1, 0, enc, & res);
    }
  } else {
    {
#line 485
    InitResidual(0, 3, enc, & res);
    }
  }
#line 489
  y = 0;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;

#line 489
    if (! (y < 4)) {
#line 489
      goto while_break;
    }
#line 490
    x = 0;
    {
#line 490
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 490
      if (! (x < 4)) {
#line 490
        goto while_break___0;
      }
      {
#line 491
      ctx = it->top_nz_[x] + it->left_nz_[y];
#line 492
      SetResidualCoeffs(rd->y_ac_levels[x + y * 4], & res);
#line 493
      it->top_nz_[x] = PutCoeffs(bw, ctx, & res);
#line 490
      x ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 489
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 496
  pos2 = VP8BitWriterPos(bw);
#line 499
  InitResidual(0, 2, enc, & res);
#line 500
  ch = 0;
  }
  {
#line 500
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 500
    if (! (ch <= 2)) {
#line 500
      goto while_break___1;
    }
#line 501
    y = 0;
    {
#line 501
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 501
      if (! (y < 2)) {
#line 501
        goto while_break___2;
      }
#line 502
      x = 0;
      {
#line 502
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 502
        if (! (x < 2)) {
#line 502
          goto while_break___3;
        }
        {
#line 503
        ctx___0 = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 504
        SetResidualCoeffs(rd->uv_levels[(ch * 2 + x) + y * 2], & res);
#line 505
        it->top_nz_[(4 + ch) + x] = PutCoeffs(bw, ctx___0, & res);
#line 502
        x ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 501
      y ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 500
    ch += 2;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 510
  pos3 = VP8BitWriterPos(bw);
#line 511
  it->luma_bits_ = pos2 - pos1;
#line 512
  it->uv_bits_ = pos3 - pos2;
#line 513
  it->bit_count_[segment][i16] += it->luma_bits_;
#line 514
  it->bit_count_[segment][2] += it->uv_bits_;
#line 515
  VP8IteratorBytesToNz(it);
  }
#line 517
  return;
}
}
#line 520 "/root/patchweave_new/13/src/enc/frame.c"
static void RecordResiduals(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  int x ;
  int y ;
  int ch ;
  VP8Residual res ;
  VP8Encoder *enc ;
  int ctx ;
  int ctx___0 ;

  {
  {
#line 524
  enc = it->enc_;
#line 526
  VP8IteratorNzToBytes(it);
  }
#line 528
  if ((int )(it->mb_)->type_ == 1) {
    {
#line 529
    InitResidual(0, 1, enc, & res);
#line 530
    SetResidualCoeffs(rd->y_dc_levels, & res);
#line 531
    it->top_nz_[8] = RecordCoeffs(it->top_nz_[8] + it->left_nz_[8], & res);
#line 533
    InitResidual(1, 0, enc, & res);
    }
  } else {
    {
#line 535
    InitResidual(0, 3, enc, & res);
    }
  }
#line 539
  y = 0;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;

#line 539
    if (! (y < 4)) {
#line 539
      goto while_break;
    }
#line 540
    x = 0;
    {
#line 540
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 540
      if (! (x < 4)) {
#line 540
        goto while_break___0;
      }
      {
#line 541
      ctx = it->top_nz_[x] + it->left_nz_[y];
#line 542
      SetResidualCoeffs(rd->y_ac_levels[x + y * 4], & res);
#line 543
      it->top_nz_[x] = RecordCoeffs(ctx, & res);
#line 540
      x ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 539
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 548
  InitResidual(0, 2, enc, & res);
#line 549
  ch = 0;
  }
  {
#line 549
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 549
    if (! (ch <= 2)) {
#line 549
      goto while_break___1;
    }
#line 550
    y = 0;
    {
#line 550
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 550
      if (! (y < 2)) {
#line 550
        goto while_break___2;
      }
#line 551
      x = 0;
      {
#line 551
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 551
        if (! (x < 2)) {
#line 551
          goto while_break___3;
        }
        {
#line 552
        ctx___0 = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 553
        SetResidualCoeffs(rd->uv_levels[(ch * 2 + x) + y * 2], & res);
#line 554
        it->top_nz_[(4 + ch) + x] = RecordCoeffs(ctx___0, & res);
#line 551
        x ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 550
      y ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 549
    ch += 2;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 560
  VP8IteratorBytesToNz(it);
  }
#line 562
  return;
}
}
#line 568 "/root/patchweave_new/13/src/enc/frame.c"
static void RecordTokens(VP8EncIterator *it , VP8ModeScore *rd , VP8TBuffer *tokens ) 
{ 
  int x ;
  int y ;
  int ch ;
  VP8Residual res ;
  VP8Encoder *enc ;
  int ctx ;
  int ctx___0 ;
  int ctx___1 ;

  {
  {
#line 572
  enc = it->enc_;
#line 574
  VP8IteratorNzToBytes(it);
  }
#line 575
  if ((int )(it->mb_)->type_ == 1) {
    {
#line 576
    ctx = it->top_nz_[8] + it->left_nz_[8];
#line 577
    InitResidual(0, 1, enc, & res);
#line 578
    SetResidualCoeffs(rd->y_dc_levels, & res);
#line 579
    it->top_nz_[8] = VP8RecordCoeffTokens(ctx, 1, res.first, res.last, res.coeffs,
                                          tokens);
#line 582
    RecordCoeffs(ctx, & res);
#line 583
    InitResidual(1, 0, enc, & res);
    }
  } else {
    {
#line 585
    InitResidual(0, 3, enc, & res);
    }
  }
#line 589
  y = 0;
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;

#line 589
    if (! (y < 4)) {
#line 589
      goto while_break;
    }
#line 590
    x = 0;
    {
#line 590
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 590
      if (! (x < 4)) {
#line 590
        goto while_break___0;
      }
      {
#line 591
      ctx___0 = it->top_nz_[x] + it->left_nz_[y];
#line 592
      SetResidualCoeffs(rd->y_ac_levels[x + y * 4], & res);
#line 593
      it->top_nz_[x] = VP8RecordCoeffTokens(ctx___0, res.coeff_type, res.first, res.last,
                                            res.coeffs, tokens);
#line 596
      RecordCoeffs(ctx___0, & res);
#line 590
      x ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 589
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 601
  InitResidual(0, 2, enc, & res);
#line 602
  ch = 0;
  }
  {
#line 602
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 602
    if (! (ch <= 2)) {
#line 602
      goto while_break___1;
    }
#line 603
    y = 0;
    {
#line 603
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 603
      if (! (y < 2)) {
#line 603
        goto while_break___2;
      }
#line 604
      x = 0;
      {
#line 604
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 604
        if (! (x < 2)) {
#line 604
          goto while_break___3;
        }
        {
#line 605
        ctx___1 = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 606
        SetResidualCoeffs(rd->uv_levels[(ch * 2 + x) + y * 2], & res);
#line 607
        it->top_nz_[(4 + ch) + x] = VP8RecordCoeffTokens(ctx___1, 2, res.first, res.last,
                                                         res.coeffs, tokens);
#line 610
        RecordCoeffs(ctx___1, & res);
#line 604
        x ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 603
      y ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 602
    ch += 2;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 614
  VP8IteratorBytesToNz(it);
  }
#line 616
  return;
}
}
#line 632 "/root/patchweave_new/13/src/enc/frame.c"
static void ResetSSE(VP8Encoder *enc ) 
{ 


  {
#line 633
  enc->sse_[0] = (uint64_t )0;
#line 634
  enc->sse_[1] = (uint64_t )0;
#line 635
  enc->sse_[2] = (uint64_t )0;
#line 637
  enc->sse_count_ = (uint64_t )0;
#line 638
  return;
}
}
#line 640 "/root/patchweave_new/13/src/enc/frame.c"
static void StoreSSE(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  uint8_t *in ;
  uint8_t *out ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 641
  enc = it->enc_;
#line 642
  in = it->yuv_in_;
#line 643
  out = it->yuv_out_;
#line 645
  __cil_tmp5 = (*VP8SSE16x16)(in + 0, out + 0);
#line 645
  enc->sse_[0] += (unsigned long )__cil_tmp5;
#line 646
  __cil_tmp6 = (*VP8SSE8x8)(in + 256, out + 256);
#line 646
  enc->sse_[1] += (unsigned long )__cil_tmp6;
#line 647
  __cil_tmp7 = (*VP8SSE8x8)(in + 264, out + 264);
#line 647
  enc->sse_[2] += (unsigned long )__cil_tmp7;
#line 648
  enc->sse_count_ += 256UL;
  }
#line 649
  return;
}
}
#line 651 "/root/patchweave_new/13/src/enc/frame.c"
static void StoreSideInfo(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  VP8MBInfo *mb ;
  WebPPicture *pic ;
  uint8_t *info ;
  int tmp ;
  int b ;
  int tmp___0 ;

  {
#line 652
  enc = it->enc_;
#line 653
  mb = it->mb_;
#line 654
  pic = enc->pic_;
#line 656
  if ((unsigned long )pic->stats != (unsigned long )((void *)0)) {
    {
#line 657
    StoreSSE(it);
#line 658
    enc->block_count_[0] += (int )mb->type_ == 0;
#line 659
    enc->block_count_[1] += (int )mb->type_ == 1;
#line 660
    enc->block_count_[2] += (int )mb->skip_ != 0;
    }
  }
#line 663
  if ((unsigned long )pic->extra_info != (unsigned long )((void *)0)) {
#line 664
    info = pic->extra_info + (it->x_ + it->y_ * enc->mb_w_);
#line 666
    if (pic->extra_info_type == 1) {
#line 666
      goto case_1;
    }
#line 667
    if (pic->extra_info_type == 2) {
#line 667
      goto case_2;
    }
#line 668
    if (pic->extra_info_type == 3) {
#line 668
      goto case_3;
    }
#line 669
    if (pic->extra_info_type == 4) {
#line 669
      goto case_4;
    }
#line 670
    if (pic->extra_info_type == 5) {
#line 670
      goto case_5;
    }
#line 671
    if (pic->extra_info_type == 6) {
#line 671
      goto case_6;
    }
#line 675
    if (pic->extra_info_type == 7) {
#line 675
      goto case_7;
    }
#line 676
    goto switch_default;
    case_1: 
#line 666
    *info = (uint8_t )mb->type_;
#line 666
    goto switch_break;
    case_2: 
#line 667
    *info = (uint8_t )mb->segment_;
#line 667
    goto switch_break;
    case_3: 
#line 668
    *info = (uint8_t )enc->dqm_[mb->segment_].quant_;
#line 668
    goto switch_break;
    case_4: 
#line 669
    if ((int )mb->type_ == 1) {
#line 669
      tmp = (int )*(it->preds_ + 0);
    } else {
#line 669
      tmp = 255;
    }
#line 669
    *info = (uint8_t )tmp;
#line 669
    goto switch_break;
    case_5: 
#line 670
    *info = (uint8_t )mb->uv_mode_;
#line 670
    goto switch_break;
    case_6: 
#line 672
    b = (int )(((it->luma_bits_ + it->uv_bits_) + 7UL) >> 3);
#line 673
    if (b > 255) {
#line 673
      tmp___0 = 255;
    } else {
#line 673
      tmp___0 = b;
    }
#line 673
    *info = (uint8_t )tmp___0;
#line 673
    goto switch_break;
    case_7: 
#line 675
    *info = mb->alpha_;
#line 675
    goto switch_break;
    switch_default: 
#line 676
    *info = (uint8_t )0;
#line 676
    goto switch_break;
    switch_break: ;
  }
#line 681
  return;
}
}
#line 693 "/root/patchweave_new/13/src/enc/frame.c"
static void SetLoopParams(VP8Encoder *enc , float q ) 
{ 


  {
#line 695
  if ((double )q < 0.) {
#line 696
    q = (float )0;
  } else
#line 697
  if ((double )q > 100.) {
#line 698
    q = (float )100;
  }
  {
#line 701
  VP8SetSegmentParams(enc, q);
#line 702
  SetSegmentProbas(enc);
#line 704
  ResetStats(enc);
#line 705
  ResetTokenStats(enc);
#line 707
  ResetSSE(enc);
  }
#line 709
  return;
}
}
#line 710 "/root/patchweave_new/13/src/enc/frame.c"
static int OneStatPass(VP8Encoder *enc , float q , VP8RDLevel rd_opt , int nb_mbs ,
                       float *PSNR , int percent_delta ) 
{ 
  VP8EncIterator it ;
  uint64_t size ;
  uint64_t distortion ;
  uint64_t pixel_count ;
  int __cil_tmp11 ;
  VP8ModeScore info ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  double __cil_tmp18 ;

  {
  {
#line 713
  size = (uint64_t )0;
#line 714
  distortion = (uint64_t )0;
#line 715
  pixel_count = (uint64_t )(nb_mbs * 384);
#line 717
  SetLoopParams(enc, q);
#line 719
  VP8IteratorInit(enc, & it);
  }
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 722
    VP8IteratorImport(& it);
#line 723
    __cil_tmp13 = VP8Decimate(& it, & info, rd_opt);
    }
#line 723
    if (__cil_tmp13) {
#line 725
      (enc->proba_.nb_skip_) ++;
    }
    {
#line 727
    RecordResiduals(& it, & info);
#line 728
    size += (unsigned long )info.R;
#line 729
    distortion += (unsigned long )info.D;
#line 730
    __cil_tmp15 = VP8IteratorProgress(& it, percent_delta);
    }
#line 730
    if (percent_delta) {
#line 730
      if (! __cil_tmp15) {
#line 731
        return (0);
      }
    }
#line 720
    if (__cil_tmp11) {
#line 720
      if (! (nb_mbs > 0)) {
#line 720
        goto while_break;
      }
    } else {
#line 720
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 733
  __cil_tmp16 = FinalizeSkipProba(enc);
#line 733
  size += (unsigned long )__cil_tmp16;
#line 734
  __cil_tmp17 = FinalizeTokenProbas(& enc->proba_);
#line 734
  size += (unsigned long )__cil_tmp17;
#line 735
  size += (unsigned long )enc->segment_hdr_.size_;
#line 736
  size = ((size + 1024UL) >> 11) + 45UL;
  }
#line 738
  if (PSNR) {
    {
#line 739
    __cil_tmp18 = log10(((255. * 255.) * (double )pixel_count) / (double )distortion);
#line 739
    *PSNR = (float )(10. * __cil_tmp18);
    }
  }
#line 741
  return ((int )size);
}
}
#line 745 "/root/patchweave_new/13/src/enc/frame.c"
static int const   dqs[9]  = 
#line 745
  {      (int const   )20,      (int const   )15,      (int const   )10,      (int const   )8, 
        (int const   )6,      (int const   )4,      (int const   )2,      (int const   )1, 
        (int const   )0};
#line 747 "/root/patchweave_new/13/src/enc/frame.c"
static int StatLoop(VP8Encoder *enc ) 
{ 
  int method ;
  int do_search ;
  int fast_probe ;
  float q ;
  int max_passes ;
  int task_percent ;
  int percent_per_pass ;
  int final_percent ;
  int pass ;
  int nb_mbs ;
  int tmp ;
  int tmp___0 ;
  VP8RDLevel rd_opt ;
  int tmp___1 ;
  int __cil_tmp16 ;
  float PSNR ;
  int criterion ;
  int size ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int tmp___2 ;

  {
#line 748
  method = enc->method_;
#line 749
  do_search = enc->do_search_;
#line 750
  if (method == 0) {
#line 750
    goto _L___11;
  } else
#line 750
  if (method == 3) {
    _L___11: /* CIL Label */ 
#line 750
    if (! do_search) {
#line 750
      tmp___2 = 1;
    } else {
#line 750
      tmp___2 = 0;
    }
  } else {
#line 750
    tmp___2 = 0;
  }
#line 750
  fast_probe = tmp___2;
#line 751
  q = (enc->config_)->quality;
#line 752
  max_passes = (enc->config_)->pass;
#line 753
  task_percent = 20;
#line 754
  percent_per_pass = (task_percent + max_passes / 2) / max_passes;
#line 755
  final_percent = enc->percent_ + task_percent;
#line 760
  nb_mbs = enc->mb_w_ * enc->mb_h_;
#line 761
  if (fast_probe) {
#line 762
    if (method == 3) {
#line 763
      if (nb_mbs > 200) {
#line 763
        tmp = nb_mbs >> 1;
      } else {
#line 763
        tmp = 100;
      }
#line 763
      nb_mbs = tmp;
    } else {
#line 765
      if (nb_mbs > 200) {
#line 765
        tmp___0 = nb_mbs >> 2;
      } else {
#line 765
        tmp___0 = 50;
      }
#line 765
      nb_mbs = tmp___0;
    }
  }
#line 770
  if (! do_search) {
#line 771
    pass = 0;
    {
#line 771
    while (1) {
      while_continue: /* CIL Label */ ;

#line 771
      if (! (pass < max_passes)) {
#line 771
        goto while_break;
      }
#line 772
      if (method >= 3) {
#line 772
        tmp___1 = 1;
      } else {
#line 772
        tmp___1 = 0;
      }
      {
#line 772
      rd_opt = (VP8RDLevel )tmp___1;
#line 773
      __cil_tmp16 = OneStatPass(enc, q, rd_opt, nb_mbs, (float *)((void *)0), percent_per_pass);
      }
#line 773
      if (! __cil_tmp16) {
#line 774
        return (0);
      }
#line 771
      pass ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 779
    pass = 0;
    {
#line 779
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 779
      if (pass < max_passes) {
#line 779
        if (! (dqs[pass] > 0)) {
#line 779
          goto while_break___0;
        }
      } else {
#line 779
        goto while_break___0;
      }
      {
#line 782
      __cil_tmp20 = OneStatPass(enc, q, (VP8RDLevel )1, nb_mbs, & PSNR, percent_per_pass);
#line 782
      size = __cil_tmp20;
      }
#line 787
      if (size == 0) {
#line 787
        return (0);
      }
#line 788
      if ((enc->config_)->target_PSNR > (float )0) {
#line 789
        criterion = PSNR < (enc->config_)->target_PSNR;
      } else {
#line 791
        criterion = size < (enc->config_)->target_size;
      }
#line 794
      if (criterion) {
#line 795
        q += (float )dqs[pass];
      } else {
#line 797
        q -= (float )dqs[pass];
      }
#line 779
      pass ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
  {
#line 801
  VP8CalculateLevelCosts(& enc->proba_);
#line 802
  __cil_tmp21 = WebPReportProgress(enc->pic_, final_percent, & enc->percent_);
  }
#line 802
  return (__cil_tmp21);
}
}
#line 809 "/root/patchweave_new/13/src/enc/frame.c"
static int const   kAverageBytesPerMB[8]  = 
#line 809
  {      (int const   )50,      (int const   )24,      (int const   )16,      (int const   )9, 
        (int const   )7,      (int const   )5,      (int const   )3,      (int const   )2};
#line 811 "/root/patchweave_new/13/src/enc/frame.c"
static int PreLoopInitialize(VP8Encoder *enc ) 
{ 
  int p ;
  int ok ;
  int average_bytes_per_MB ;
  int bytes_per_parts ;

  {
#line 813
  ok = 1;
#line 814
  average_bytes_per_MB = (int )kAverageBytesPerMB[enc->base_quant_ >> 4];
#line 815
  bytes_per_parts = ((enc->mb_w_ * enc->mb_h_) * average_bytes_per_MB) / enc->num_parts_;
#line 818
  p = 0;
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;

#line 818
    if (ok) {
#line 818
      if (! (p < enc->num_parts_)) {
#line 818
        goto while_break;
      }
    } else {
#line 818
      goto while_break;
    }
    {
#line 819
    ok = VP8BitWriterInit(enc->parts_ + p, (size_t )bytes_per_parts);
#line 818
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 821
  if (! ok) {
    {
#line 821
    VP8EncFreeBitWriters(enc);
    }
  }
#line 822
  return (ok);
}
}
#line 825 "/root/patchweave_new/13/src/enc/frame.c"
static int PostLoopFinalize(VP8EncIterator *it , int ok ) 
{ 
  VP8Encoder *enc ;
  int p ;
  int i ;
  int s ;

  {
#line 826
  enc = it->enc_;
#line 827
  if (ok) {
#line 829
    p = 0;
    {
#line 829
    while (1) {
      while_continue: /* CIL Label */ ;

#line 829
      if (! (p < enc->num_parts_)) {
#line 829
        goto while_break;
      }
      {
#line 830
      VP8BitWriterFinish(enc->parts_ + p);
#line 831
      ok &= ! enc->parts_[p].error_;
#line 829
      p ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 835
  if (ok) {
#line 836
    if ((enc->pic_)->stats) {
#line 838
      i = 0;
      {
#line 838
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 838
        if (! (i <= 2)) {
#line 838
          goto while_break___0;
        }
#line 839
        s = 0;
        {
#line 839
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 839
          if (! (s < 4)) {
#line 839
            goto while_break___1;
          }
#line 840
          enc->residual_bytes_[i][s] = (int )((it->bit_count_[s][i] + 7UL) >> 3);
#line 839
          s ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: 
#line 838
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    }
    {
#line 844
    VP8AdjustFilterStrength(it);
    }
  } else {
    {
#line 847
    VP8EncFreeBitWriters(enc);
    }
  }
#line 849
  return (ok);
}
}
#line 855 "/root/patchweave_new/13/src/enc/frame.c"
static void ResetAfterSkip(VP8EncIterator *it ) 
{ 


  {
#line 856
  if ((int )(it->mb_)->type_ == 1) {
#line 857
    *(it->nz_) = (uint32_t )0;
#line 858
    it->left_nz_[8] = 0;
  } else {
#line 860
    *(it->nz_) &= (unsigned int )(1 << 24);
  }
#line 862
  return;
}
}
#line 864 "/root/patchweave_new/13/src/enc/frame.c"
int VP8EncLoop(VP8Encoder *enc ) 
{ 
  VP8EncIterator it ;
  int ok ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  VP8ModeScore info ;
  int dont_use_skip ;
  VP8RDLevel rd_opt ;
  int __cil_tmp9 ;
  int __cil_tmp11 ;

  {
  {
#line 866
  __cil_tmp4 = PreLoopInitialize(enc);
#line 866
  ok = __cil_tmp4;
  }
#line 867
  if (! ok) {
#line 867
    return (0);
  }
  {
#line 869
  StatLoop(enc);
#line 871
  VP8IteratorInit(enc, & it);
#line 872
  VP8InitFilter(& it);
  }
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 875
    dont_use_skip = ! enc->proba_.use_skip_proba_;
#line 876
    rd_opt = enc->rd_opt_level_;
#line 878
    VP8IteratorImport(& it);
#line 881
    __cil_tmp9 = VP8Decimate(& it, & info, rd_opt);
    }
#line 881
    if (! __cil_tmp9) {
      {
#line 882
      CodeResiduals(it.bw_, & it, & info);
      }
    } else
#line 881
    if (dont_use_skip) {
      {
#line 882
      CodeResiduals(it.bw_, & it, & info);
      }
    } else {
      {
#line 884
      ResetAfterSkip(& it);
      }
    }
    {
#line 891
    StoreSideInfo(& it);
#line 892
    VP8StoreFilterStats(& it);
#line 893
    VP8IteratorExport(& it);
#line 894
    ok = VP8IteratorProgress(& it, 20);
    }
#line 873
    if (ok) {
#line 873
      if (! __cil_tmp5) {
#line 873
        goto while_break;
      }
    } else {
#line 873
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 897
  __cil_tmp11 = PostLoopFinalize(& it, ok);
  }
#line 897
  return (__cil_tmp11);
}
}
#line 907 "/root/patchweave_new/13/src/enc/frame.c"
int VP8EncTokenLoop(VP8Encoder *enc ) 
{ 
  int ok ;
  int max_count ;
  int cnt ;
  VP8EncIterator it ;
  VP8Proba *proba ;
  VP8RDLevel rd_opt ;
  int __cil_tmp14 ;
  VP8ModeScore info ;
  int __cil_tmp17 ;
  int __cil_tmp19 ;
  int tmp___4 ;

  {
#line 910
  max_count = enc->mb_w_ * enc->mb_h_ >> 3;
#line 913
  proba = & enc->proba_;
#line 914
  rd_opt = enc->rd_opt_level_;
#line 916
  if (max_count < 96) {
#line 916
    max_count = 96;
  }
  {
#line 917
  cnt = max_count;
#line 925
  SetLoopParams(enc, (enc->config_)->quality);
#line 927
  ok = PreLoopInitialize(enc);
  }
#line 928
  if (! ok) {
#line 928
    return (0);
  }
  {
#line 930
  VP8IteratorInit(enc, & it);
#line 931
  VP8InitFilter(& it);
  }
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 934
    VP8IteratorImport(& it);
#line 935
    cnt --;
    }
#line 935
    if (cnt < 0) {
      {
#line 936
      FinalizeTokenProbas(proba);
#line 937
      VP8CalculateLevelCosts(proba);
#line 938
      cnt = max_count;
      }
    }
    {
#line 940
    VP8Decimate(& it, & info, rd_opt);
#line 941
    RecordTokens(& it, & info, & enc->tokens_);
#line 947
    StoreSideInfo(& it);
#line 948
    VP8StoreFilterStats(& it);
#line 949
    VP8IteratorExport(& it);
#line 950
    ok = VP8IteratorProgress(& it, 20);
    }
#line 932
    if (ok) {
#line 932
      if (! __cil_tmp14) {
#line 932
        goto while_break;
      }
    } else {
#line 932
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 953
  __cil_tmp17 = WebPReportProgress(enc->pic_, enc->percent_ + 20, & enc->percent_);
  }
#line 953
  if (ok) {
#line 953
    if (__cil_tmp17) {
#line 953
      tmp___4 = 1;
    } else {
#line 953
      tmp___4 = 0;
    }
  } else {
#line 953
    tmp___4 = 0;
  }
#line 953
  ok = tmp___4;
#line 955
  if (ok) {
    {
#line 956
    FinalizeTokenProbas(proba);
#line 957
    ok = VP8EmitTokens(& enc->tokens_, enc->parts_ + 0, (uint8_t *)(proba->coeffs_),
                       1);
    }
  }
  {
#line 961
  __cil_tmp19 = PostLoopFinalize(& it, ok);
  }
#line 961
  return (__cil_tmp19);
}
}
#line 19 "/root/patchweave_new/13/src/enc/filter.c"
static uint8_t abs0[511]  ;
#line 20 "/root/patchweave_new/13/src/enc/filter.c"
static uint8_t abs1[511]  ;
#line 21 "/root/patchweave_new/13/src/enc/filter.c"
static int8_t sclip1[2041]  ;
#line 22 "/root/patchweave_new/13/src/enc/filter.c"
static int8_t sclip2[225]  ;
#line 23 "/root/patchweave_new/13/src/enc/filter.c"
static uint8_t clip1[766]  ;
#line 25 "/root/patchweave_new/13/src/enc/filter.c"
static int tables_ok  =    0;
#line 27 "/root/patchweave_new/13/src/enc/filter.c"
static void InitTables(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 28
  if (! tables_ok) {
#line 30
    i = -255;
    {
#line 30
    while (1) {
      while_continue: /* CIL Label */ ;

#line 30
      if (! (i <= 255)) {
#line 30
        goto while_break;
      }
#line 31
      if (i < 0) {
#line 31
        tmp = - i;
      } else {
#line 31
        tmp = i;
      }
#line 31
      abs0[255 + i] = (uint8_t )tmp;
#line 32
      abs1[255 + i] = (uint8_t )((int )abs0[255 + i] >> 1);
#line 30
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: 
#line 34
    i = -1020;
    {
#line 34
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 34
      if (! (i <= 1020)) {
#line 34
        goto while_break___0;
      }
#line 35
      if (i < -128) {
#line 35
        tmp___1 = -128;
      } else {
#line 35
        if (i > 127) {
#line 35
          tmp___0 = 127;
        } else {
#line 35
          tmp___0 = i;
        }
#line 35
        tmp___1 = tmp___0;
      }
#line 35
      sclip1[1020 + i] = (int8_t )tmp___1;
#line 34
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 37
    i = -112;
    {
#line 37
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 37
      if (! (i <= 112)) {
#line 37
        goto while_break___1;
      }
#line 38
      if (i < -16) {
#line 38
        tmp___3 = -16;
      } else {
#line 38
        if (i > 15) {
#line 38
          tmp___2 = 15;
        } else {
#line 38
          tmp___2 = i;
        }
#line 38
        tmp___3 = tmp___2;
      }
#line 38
      sclip2[112 + i] = (int8_t )tmp___3;
#line 37
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 40
    i = -255;
    {
#line 40
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 40
      if (! (i <= 510)) {
#line 40
        goto while_break___2;
      }
#line 41
      if (i < 0) {
#line 41
        tmp___5 = 0;
      } else {
#line 41
        if (i > 255) {
#line 41
          tmp___4 = 255;
        } else {
#line 41
          tmp___4 = i;
        }
#line 41
        tmp___5 = tmp___4;
      }
#line 41
      clip1[255 + i] = (uint8_t )tmp___5;
#line 40
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 43
    tables_ok = 1;
  }
#line 45
  return;
}
}
#line 51 "/root/patchweave_new/13/src/enc/filter.c"
__inline static void do_filter2(uint8_t *p , int step ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int a ;
  int a1 ;
  int a2 ;

  {
#line 52
  p1 = (int )*(p + -2 * step);
#line 52
  p0 = (int )*(p + - step);
#line 52
  q0 = (int )*(p + 0);
#line 52
  q1 = (int )*(p + step);
#line 53
  a = 3 * (q0 - p0) + (int )sclip1[(1020 + p1) - q1];
#line 54
  a1 = (int )sclip2[112 + ((a + 4) >> 3)];
#line 55
  a2 = (int )sclip2[112 + ((a + 3) >> 3)];
#line 56
  *(p + - step) = clip1[(255 + p0) + a2];
#line 57
  *(p + 0) = clip1[(255 + q0) - a1];
#line 58
  return;
}
}
#line 61 "/root/patchweave_new/13/src/enc/filter.c"
__inline static void do_filter4(uint8_t *p , int step ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int a ;
  int a1 ;
  int a2 ;
  int a3 ;

  {
#line 62
  p1 = (int )*(p + -2 * step);
#line 62
  p0 = (int )*(p + - step);
#line 62
  q0 = (int )*(p + 0);
#line 62
  q1 = (int )*(p + step);
#line 63
  a = 3 * (q0 - p0);
#line 64
  a1 = (int )sclip2[112 + ((a + 4) >> 3)];
#line 65
  a2 = (int )sclip2[112 + ((a + 3) >> 3)];
#line 66
  a3 = (a1 + 1) >> 1;
#line 67
  *(p + -2 * step) = clip1[(255 + p1) + a3];
#line 68
  *(p + - step) = clip1[(255 + p0) + a2];
#line 69
  *(p + 0) = clip1[(255 + q0) - a1];
#line 70
  *(p + step) = clip1[(255 + q1) - a3];
#line 71
  return;
}
}
#line 74 "/root/patchweave_new/13/src/enc/filter.c"
__inline static int hev(uint8_t *p , int step , int thresh ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int tmp ;

  {
#line 75
  p1 = (int )*(p + -2 * step);
#line 75
  p0 = (int )*(p + - step);
#line 75
  q0 = (int )*(p + 0);
#line 75
  q1 = (int )*(p + step);
#line 76
  if ((int )abs0[(255 + p1) - p0] > thresh) {
#line 76
    tmp = 1;
  } else
#line 76
  if ((int )abs0[(255 + q1) - q0] > thresh) {
#line 76
    tmp = 1;
  } else {
#line 76
    tmp = 0;
  }
#line 76
  return (tmp);
}
}
#line 79 "/root/patchweave_new/13/src/enc/filter.c"
__inline static int needs_filter(uint8_t *p , int step , int thresh ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;

  {
#line 80
  p1 = (int )*(p + -2 * step);
#line 80
  p0 = (int )*(p + - step);
#line 80
  q0 = (int )*(p + 0);
#line 80
  q1 = (int )*(p + step);
#line 81
  return (2 * (int )abs0[(255 + p0) - q0] + (int )abs1[(255 + p1) - q1] <= thresh);
}
}
#line 84 "/root/patchweave_new/13/src/enc/filter.c"
__inline static int needs_filter2(uint8_t *p , int step , int t , int it ) 
{ 
  int p3 ;
  int p2 ;
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int q2 ;
  int q3 ;
  int tmp ;

  {
#line 86
  p3 = (int )*(p + -4 * step);
#line 86
  p2 = (int )*(p + -3 * step);
#line 86
  p1 = (int )*(p + -2 * step);
#line 86
  p0 = (int )*(p + - step);
#line 87
  q0 = (int )*(p + 0);
#line 87
  q1 = (int )*(p + step);
#line 87
  q2 = (int )*(p + 2 * step);
#line 87
  q3 = (int )*(p + 3 * step);
#line 88
  if (2 * (int )abs0[(255 + p0) - q0] + (int )abs1[(255 + p1) - q1] > t) {
#line 89
    return (0);
  }
#line 90
  if ((int )abs0[(255 + p3) - p2] <= it) {
#line 90
    if ((int )abs0[(255 + p2) - p1] <= it) {
#line 90
      if ((int )abs0[(255 + p1) - p0] <= it) {
#line 90
        if ((int )abs0[(255 + q3) - q2] <= it) {
#line 90
          if ((int )abs0[(255 + q2) - q1] <= it) {
#line 90
            if ((int )abs0[(255 + q1) - q0] <= it) {
#line 90
              tmp = 1;
            } else {
#line 90
              tmp = 0;
            }
          } else {
#line 90
            tmp = 0;
          }
        } else {
#line 90
          tmp = 0;
        }
      } else {
#line 90
        tmp = 0;
      }
    } else {
#line 90
      tmp = 0;
    }
  } else {
#line 90
    tmp = 0;
  }
#line 90
  return (tmp);
}
}
#line 98 "/root/patchweave_new/13/src/enc/filter.c"
static void SimpleVFilter16(uint8_t *p , int stride , int thresh ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;

#line 100
    if (! (i < 16)) {
#line 100
      goto while_break;
    }
    {
#line 101
    __cil_tmp5 = needs_filter(p + i, stride, thresh);
    }
#line 101
    if (__cil_tmp5) {
      {
#line 102
      do_filter2(p + i, stride);
      }
    }
#line 100
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 104
  return;
}
}
#line 107 "/root/patchweave_new/13/src/enc/filter.c"
static void SimpleHFilter16(uint8_t *p , int stride , int thresh ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 109
  i = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;

#line 109
    if (! (i < 16)) {
#line 109
      goto while_break;
    }
    {
#line 110
    __cil_tmp5 = needs_filter(p + i * stride, 1, thresh);
    }
#line 110
    if (__cil_tmp5) {
      {
#line 111
      do_filter2(p + i * stride, 1);
      }
    }
#line 109
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 113
  return;
}
}
#line 116 "/root/patchweave_new/13/src/enc/filter.c"
static void SimpleVFilter16i(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 118
  k = 3;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;

#line 118
    if (! (k > 0)) {
#line 118
      goto while_break;
    }
    {
#line 119
    p += 4 * stride;
#line 120
    SimpleVFilter16(p, stride, thresh);
#line 118
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 122
  return;
}
}
#line 124 "/root/patchweave_new/13/src/enc/filter.c"
static void SimpleHFilter16i(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 126
  k = 3;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;

#line 126
    if (! (k > 0)) {
#line 126
      goto while_break;
    }
    {
#line 127
    p += 4;
#line 128
    SimpleHFilter16(p, stride, thresh);
#line 126
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 130
  return;
}
}
#line 135 "/root/patchweave_new/13/src/enc/filter.c"
__inline static void FilterLoop24(uint8_t *p , int hstride , int vstride , int size ,
                                  int thresh , int ithresh , int hev_thresh ) 
{ 
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    __cil_tmp8 = size;
#line 138
    size --;
#line 138
    if (! (__cil_tmp8 > 0)) {
#line 138
      goto while_break;
    }
    {
#line 139
    __cil_tmp9 = needs_filter2(p, hstride, thresh, ithresh);
    }
#line 139
    if (__cil_tmp9) {
      {
#line 140
      __cil_tmp10 = hev(p, hstride, hev_thresh);
      }
#line 140
      if (__cil_tmp10) {
        {
#line 141
        do_filter2(p, hstride);
        }
      } else {
        {
#line 143
        do_filter4(p, hstride);
        }
      }
    }
#line 146
    p += vstride;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 150
  return;
}
}
#line 151 "/root/patchweave_new/13/src/enc/filter.c"
static void VFilter16i(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;

  {
#line 154
  k = 3;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;

#line 154
    if (! (k > 0)) {
#line 154
      goto while_break;
    }
    {
#line 155
    p += 4 * stride;
#line 156
    FilterLoop24(p, stride, 1, 16, thresh, ithresh, hev_thresh);
#line 154
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 158
  return;
}
}
#line 160 "/root/patchweave_new/13/src/enc/filter.c"
static void HFilter16i(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;

  {
#line 163
  k = 3;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;

#line 163
    if (! (k > 0)) {
#line 163
      goto while_break;
    }
    {
#line 164
    p += 4;
#line 165
    FilterLoop24(p, 1, stride, 16, thresh, ithresh, hev_thresh);
#line 163
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 167
  return;
}
}
#line 169 "/root/patchweave_new/13/src/enc/filter.c"
static void VFilter8i(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                      int hev_thresh ) 
{ 


  {
  {
#line 171
  FilterLoop24(u + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
#line 172
  FilterLoop24(v + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
  }
#line 174
  return;
}
}
#line 175 "/root/patchweave_new/13/src/enc/filter.c"
static void HFilter8i(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                      int hev_thresh ) 
{ 


  {
  {
#line 177
  FilterLoop24(u + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
#line 178
  FilterLoop24(v + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
  }
#line 180
  return;
}
}
#line 183 "/root/patchweave_new/13/src/enc/filter.c"
void (*VP8EncVFilter16i)(uint8_t * , int  , int  , int  , int  )  =    & VFilter16i;
#line 184 "/root/patchweave_new/13/src/enc/filter.c"
void (*VP8EncHFilter16i)(uint8_t * , int  , int  , int  , int  )  =    & HFilter16i;
#line 185 "/root/patchweave_new/13/src/enc/filter.c"
void (*VP8EncVFilter8i)(uint8_t * , uint8_t * , int  , int  , int  , int  )  =    & VFilter8i;
#line 186 "/root/patchweave_new/13/src/enc/filter.c"
void (*VP8EncHFilter8i)(uint8_t * , uint8_t * , int  , int  , int  , int  )  =    & HFilter8i;
#line 188 "/root/patchweave_new/13/src/enc/filter.c"
void (*VP8EncSimpleVFilter16i)(uint8_t * , int  , int  )  =    & SimpleVFilter16i;
#line 189 "/root/patchweave_new/13/src/enc/filter.c"
void (*VP8EncSimpleHFilter16i)(uint8_t * , int  , int  )  =    & SimpleHFilter16i;
#line 194 "/root/patchweave_new/13/src/enc/filter.c"
static int GetILevel(int sharpness , int level ) 
{ 


  {
#line 195
  if (sharpness > 0) {
#line 196
    if (sharpness > 4) {
#line 197
      level >>= 2;
    } else {
#line 199
      level >>= 1;
    }
#line 201
    if (level > 9 - sharpness) {
#line 202
      level = 9 - sharpness;
    }
  }
#line 205
  if (level < 1) {
#line 205
    level = 1;
  }
#line 206
  return (level);
}
}
#line 209 "/root/patchweave_new/13/src/enc/filter.c"
static void DoFilter(VP8EncIterator *it , int level ) 
{ 
  VP8Encoder *enc ;
  int ilevel ;
  int __cil_tmp5 ;
  int limit ;
  uint8_t *y_dst ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  int hev_thresh ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 210
  enc = it->enc_;
#line 211
  __cil_tmp5 = GetILevel((enc->config_)->filter_sharpness, level);
#line 211
  ilevel = __cil_tmp5;
#line 212
  limit = 2 * level + ilevel;
#line 214
  y_dst = it->yuv_out2_ + 0;
#line 215
  u_dst = it->yuv_out2_ + 256;
#line 216
  v_dst = it->yuv_out2_ + 264;
#line 219
  memcpy((void *)y_dst, (void const   *)it->yuv_out_, 384UL * sizeof(uint8_t ));
  }
#line 221
  if (enc->filter_hdr_.simple_ == 1) {
    {
#line 222
    (*VP8EncSimpleHFilter16i)(y_dst, 16, limit);
#line 223
    (*VP8EncSimpleVFilter16i)(y_dst, 16, limit);
    }
  } else {
#line 225
    if (level >= 40) {
#line 225
      tmp___0 = 2;
    } else {
#line 225
      if (level >= 15) {
#line 225
        tmp = 1;
      } else {
#line 225
        tmp = 0;
      }
#line 225
      tmp___0 = tmp;
    }
    {
#line 225
    hev_thresh = tmp___0;
#line 226
    (*VP8EncHFilter16i)(y_dst, 16, limit, ilevel, hev_thresh);
#line 227
    (*VP8EncHFilter8i)(u_dst, v_dst, 16, limit, ilevel, hev_thresh);
#line 228
    (*VP8EncVFilter16i)(y_dst, 16, limit, ilevel, hev_thresh);
#line 229
    (*VP8EncVFilter8i)(u_dst, v_dst, 16, limit, ilevel, hev_thresh);
    }
  }
#line 232
  return;
}
}
#line 237 "/root/patchweave_new/13/src/enc/filter.c"
static double const   kMinValue  =    (double const   )1.00000000001e-10;
#line 239 "/root/patchweave_new/13/src/enc/filter.c"
void VP8SSIMAddStats(DistoStats *src , DistoStats *dst ) 
{ 


  {
#line 240
  dst->w += src->w;
#line 241
  dst->xm += src->xm;
#line 242
  dst->ym += src->ym;
#line 243
  dst->xxm += src->xxm;
#line 244
  dst->xym += src->xym;
#line 245
  dst->yym += src->yym;
#line 246
  return;
}
}
#line 248 "/root/patchweave_new/13/src/enc/filter.c"
static void VP8SSIMAccumulate(uint8_t *src1 , int stride1 , uint8_t *src2 , int stride2 ,
                              int xo , int yo , int W , int H , DistoStats *stats ) 
{ 
  int ymin ;
  int tmp ;
  int ymax ;
  int tmp___0 ;
  int xmin ;
  int tmp___1 ;
  int xmax ;
  int tmp___2 ;
  int x ;
  int y ;
  int s1 ;
  int s2 ;

  {
#line 252
  if (yo - 3 < 0) {
#line 252
    tmp = 0;
  } else {
#line 252
    tmp = yo - 3;
  }
#line 252
  ymin = tmp;
#line 253
  if (yo + 3 > H - 1) {
#line 253
    tmp___0 = H - 1;
  } else {
#line 253
    tmp___0 = yo + 3;
  }
#line 253
  ymax = tmp___0;
#line 254
  if (xo - 3 < 0) {
#line 254
    tmp___1 = 0;
  } else {
#line 254
    tmp___1 = xo - 3;
  }
#line 254
  xmin = tmp___1;
#line 255
  if (xo + 3 > W - 1) {
#line 255
    tmp___2 = W - 1;
  } else {
#line 255
    tmp___2 = xo + 3;
  }
#line 255
  xmax = tmp___2;
#line 257
  src1 += ymin * stride1;
#line 258
  src2 += ymin * stride2;
#line 259
  y = ymin;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;

#line 259
    if (! (y <= ymax)) {
#line 259
      goto while_break;
    }
#line 260
    x = xmin;
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 260
      if (! (x <= xmax)) {
#line 260
        goto while_break___0;
      }
#line 261
      s1 = (int )*(src1 + x);
#line 262
      s2 = (int )*(src2 + x);
#line 263
      stats->w += (double )1;
#line 264
      stats->xm += (double )s1;
#line 265
      stats->ym += (double )s2;
#line 266
      stats->xxm += (double )(s1 * s1);
#line 267
      stats->xym += (double )(s1 * s2);
#line 268
      stats->yym += (double )(s2 * s2);
#line 260
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 259
    src2 += stride2;
#line 259
    src1 += stride1;
#line 259
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 263
  return;
}
}
#line 273 "/root/patchweave_new/13/src/enc/filter.c"
double VP8SSIMGet(DistoStats *stats ) 
{ 
  double xmxm ;
  double ymym ;
  double xmym ;
  double w2 ;
  double sxx ;
  double syy ;
  double sxy ;
  double C1 ;
  double C2 ;
  double fnum ;
  double fden ;
  double tmp ;

  {
#line 274
  xmxm = stats->xm * stats->xm;
#line 275
  ymym = stats->ym * stats->ym;
#line 276
  xmym = stats->xm * stats->ym;
#line 277
  w2 = stats->w * stats->w;
#line 278
  sxx = stats->xxm * stats->w - xmxm;
#line 279
  syy = stats->yym * stats->w - ymym;
#line 280
  sxy = stats->xym * stats->w - xmym;
#line 285
  if (sxx < 0.) {
#line 285
    sxx = 0.;
  }
#line 286
  if (syy < 0.) {
#line 286
    syy = 0.;
  }
#line 287
  C1 = 6.50250000001 * w2;
#line 288
  C2 = 58.5225000001 * w2;
#line 289
  fnum = ((double )2 * xmym + C1) * ((double )2 * sxy + C2);
#line 290
  fden = ((xmxm + ymym) + C1) * ((sxx + syy) + C2);
#line 291
  if (fden != 0.) {
#line 291
    tmp = fnum / fden;
  } else {
#line 291
    tmp = (double )kMinValue;
  }
#line 291
  return ((double )((int )tmp));
}
}
#line 294 "/root/patchweave_new/13/src/enc/filter.c"
double VP8SSIMGetSquaredError(DistoStats *s ) 
{ 
  double iw2 ;
  double sxx ;
  double syy ;
  double sxy ;
  double SSE ;

  {
#line 295
  if (s->w > 0.) {
#line 296
    iw2 = 1. / (s->w * s->w);
#line 297
    sxx = s->xxm * s->w - s->xm * s->xm;
#line 298
    syy = s->yym * s->w - s->ym * s->ym;
#line 299
    sxy = s->xym * s->w - s->xm * s->ym;
#line 300
    SSE = iw2 * ((sxx + syy) - 2. * sxy);
#line 301
    if (SSE > (double )kMinValue) {
#line 301
      return (SSE);
    }
  }
#line 303
  return ((double )kMinValue);
}
}
#line 306 "/root/patchweave_new/13/src/enc/filter.c"
void VP8SSIMAccumulatePlane(uint8_t *src1 , int stride1 , uint8_t *src2 , int stride2 ,
                            int W , int H , DistoStats *stats ) 
{ 
  int x ;
  int y ;

  {
#line 310
  y = 0;
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;

#line 310
    if (! (y < H)) {
#line 310
      goto while_break;
    }
#line 311
    x = 0;
    {
#line 311
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 311
      if (! (x < W)) {
#line 311
        goto while_break___0;
      }
      {
#line 312
      VP8SSIMAccumulate(src1, stride1, src2, stride2, x, y, W, H, stats);
#line 311
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 310
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 314
  return;
}
}
#line 317 "/root/patchweave_new/13/src/enc/filter.c"
static double GetMBSSIM(uint8_t *yuv1 , uint8_t *yuv2 ) 
{ 
  int x ;
  int y ;
  DistoStats s ;
  double __cil_tmp10 ;

  {
#line 319
  s.w = 0.;
#line 319
  s.xm = 0.;
#line 319
  s.ym = 0.;
#line 319
  s.xxm = 0.;
#line 319
  s.xym = 0.;
#line 319
  s.yym = 0.;
#line 322
  x = 3;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;

#line 322
    if (! (x < 13)) {
#line 322
      goto while_break;
    }
#line 323
    y = 3;
    {
#line 323
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 323
      if (! (y < 13)) {
#line 323
        goto while_break___0;
      }
      {
#line 324
      VP8SSIMAccumulate(yuv1 + 0, 16, yuv2 + 0, 16, x, y, 16, 16, & s);
#line 323
      y ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 322
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 327
  x = 1;
  {
#line 327
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 327
    if (! (x < 7)) {
#line 327
      goto while_break___1;
    }
#line 328
    y = 1;
    {
#line 328
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 328
      if (! (y < 7)) {
#line 328
        goto while_break___2;
      }
      {
#line 329
      VP8SSIMAccumulate(yuv1 + 256, 16, yuv2 + 256, 16, x, y, 8, 8, & s);
#line 330
      VP8SSIMAccumulate(yuv1 + 264, 16, yuv2 + 264, 16, x, y, 8, 8, & s);
#line 328
      y ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 327
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 333
  __cil_tmp10 = VP8SSIMGet(& s);
  }
#line 333
  return (__cil_tmp10);
}
}
#line 340 "/root/patchweave_new/13/src/enc/filter.c"
void VP8InitFilter(VP8EncIterator *it ) 
{ 
  int s ;
  int i ;

  {
#line 342
  if (! it->lf_stats_) {
#line 342
    return;
  }
  {
#line 344
  InitTables();
#line 345
  s = 0;
  }
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;

#line 345
    if (! (s < 4)) {
#line 345
      goto while_break;
    }
#line 346
    i = 0;
    {
#line 346
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 346
      if (! (i < 64)) {
#line 346
        goto while_break___0;
      }
#line 347
      (*(it->lf_stats_))[s][i] = (double )0;
#line 346
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 345
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 349
  return;
}
}
#line 352 "/root/patchweave_new/13/src/enc/filter.c"
void VP8StoreFilterStats(VP8EncIterator *it ) 
{ 
  int d ;
  int s ;
  int level0 ;
  int delta_min ;
  int delta_max ;
  int step_size ;
  int tmp ;
  double __cil_tmp9 ;
  int level ;
  double __cil_tmp11 ;

  {
#line 354
  s = (int )(it->mb_)->segment_;
#line 355
  level0 = (it->enc_)->dqm_[s].fstrength_;
#line 358
  delta_min = - (it->enc_)->dqm_[s].quant_;
#line 359
  delta_max = (it->enc_)->dqm_[s].quant_;
#line 360
  if (delta_max - delta_min >= 4) {
#line 360
    tmp = 4;
  } else {
#line 360
    tmp = 1;
  }
#line 360
  step_size = tmp;
#line 362
  if (! it->lf_stats_) {
#line 362
    return;
  }
#line 370
  if ((int )(it->mb_)->type_ == 1) {
#line 370
    if ((int )(it->mb_)->skip_) {
#line 370
      return;
    }
  }
  {
#line 373
  __cil_tmp9 = GetMBSSIM(it->yuv_in_, it->yuv_out_);
#line 373
  (*(it->lf_stats_))[s][0] += __cil_tmp9;
#line 375
  d = delta_min;
  }
  {
#line 375
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 375
    if (! (d <= delta_max)) {
#line 375
      goto while_break;
    }
#line 376
    level = level0 + d;
#line 377
    if (level <= 0) {
#line 378
      goto while_continue;
    } else
#line 377
    if (level >= 64) {
#line 378
      goto while_continue;
    }
    {
#line 380
    DoFilter(it, level);
#line 381
    __cil_tmp11 = GetMBSSIM(it->yuv_in_, it->yuv_out2_);
#line 381
    (*(it->lf_stats_))[s][level] += __cil_tmp11;
#line 375
    d += step_size;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 379
  return;
}
}
#line 385 "/root/patchweave_new/13/src/enc/filter.c"
void VP8AdjustFilterStrength(VP8EncIterator *it ) 
{ 
  int s ;
  VP8Encoder *enc ;
  int i ;
  int best_level ;
  double best_v ;
  double v ;

  {
#line 387
  enc = it->enc_;
#line 389
  if (! it->lf_stats_) {
#line 390
    return;
  }
#line 392
  s = 0;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;

#line 392
    if (! (s < 4)) {
#line 392
      goto while_break;
    }
#line 393
    best_level = 0;
#line 395
    best_v = 1.00001000001 * (*(it->lf_stats_))[s][0];
#line 396
    i = 1;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 396
      if (! (i < 64)) {
#line 396
        goto while_break___0;
      }
#line 397
      v = (*(it->lf_stats_))[s][i];
#line 398
      if (v > best_v) {
#line 399
        best_v = v;
#line 400
        best_level = i;
      }
#line 396
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 403
    enc->dqm_[s].fstrength_ = best_level;
#line 392
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 396
  return;
}
}
#line 21 "/root/patchweave_new/13/src/enc/cost.c"
uint16_t VP8EntropyCost[256]  = 
#line 21 "/root/patchweave_new/13/src/enc/cost.c"
  {      (uint16_t )1792,      (uint16_t )1792,      (uint16_t )1792,      (uint16_t )1536, 
        (uint16_t )1536,      (uint16_t )1408,      (uint16_t )1366,      (uint16_t )1280, 
        (uint16_t )1280,      (uint16_t )1216,      (uint16_t )1178,      (uint16_t )1152, 
        (uint16_t )1110,      (uint16_t )1076,      (uint16_t )1061,      (uint16_t )1024, 
        (uint16_t )1024,      (uint16_t )992,      (uint16_t )968,      (uint16_t )951, 
        (uint16_t )939,      (uint16_t )911,      (uint16_t )896,      (uint16_t )878, 
        (uint16_t )871,      (uint16_t )854,      (uint16_t )838,      (uint16_t )820, 
        (uint16_t )811,      (uint16_t )794,      (uint16_t )786,      (uint16_t )768, 
        (uint16_t )768,      (uint16_t )752,      (uint16_t )740,      (uint16_t )732, 
        (uint16_t )720,      (uint16_t )709,      (uint16_t )704,      (uint16_t )690, 
        (uint16_t )683,      (uint16_t )672,      (uint16_t )666,      (uint16_t )655, 
        (uint16_t )647,      (uint16_t )640,      (uint16_t )631,      (uint16_t )622, 
        (uint16_t )615,      (uint16_t )607,      (uint16_t )598,      (uint16_t )592, 
        (uint16_t )586,      (uint16_t )576,      (uint16_t )572,      (uint16_t )564, 
        (uint16_t )559,      (uint16_t )555,      (uint16_t )547,      (uint16_t )541, 
        (uint16_t )534,      (uint16_t )528,      (uint16_t )522,      (uint16_t )512, 
        (uint16_t )512,      (uint16_t )504,      (uint16_t )500,      (uint16_t )494, 
        (uint16_t )488,      (uint16_t )483,      (uint16_t )477,      (uint16_t )473, 
        (uint16_t )467,      (uint16_t )461,      (uint16_t )458,      (uint16_t )452, 
        (uint16_t )448,      (uint16_t )443,      (uint16_t )438,      (uint16_t )434, 
        (uint16_t )427,      (uint16_t )424,      (uint16_t )419,      (uint16_t )415, 
        (uint16_t )410,      (uint16_t )406,      (uint16_t )403,      (uint16_t )399, 
        (uint16_t )394,      (uint16_t )390,      (uint16_t )384,      (uint16_t )384, 
        (uint16_t )377,      (uint16_t )374,      (uint16_t )370,      (uint16_t )366, 
        (uint16_t )362,      (uint16_t )359,      (uint16_t )355,      (uint16_t )351, 
        (uint16_t )347,      (uint16_t )342,      (uint16_t )342,      (uint16_t )336, 
        (uint16_t )333,      (uint16_t )330,      (uint16_t )326,      (uint16_t )323, 
        (uint16_t )320,      (uint16_t )316,      (uint16_t )312,      (uint16_t )308, 
        (uint16_t )305,      (uint16_t )302,      (uint16_t )299,      (uint16_t )296, 
        (uint16_t )293,      (uint16_t )288,      (uint16_t )287,      (uint16_t )283, 
        (uint16_t )280,      (uint16_t )277,      (uint16_t )274,      (uint16_t )272, 
        (uint16_t )268,      (uint16_t )266,      (uint16_t )262,      (uint16_t )256, 
        (uint16_t )256,      (uint16_t )256,      (uint16_t )251,      (uint16_t )248, 
        (uint16_t )245,      (uint16_t )242,      (uint16_t )240,      (uint16_t )237, 
        (uint16_t )234,      (uint16_t )232,      (uint16_t )228,      (uint16_t )226, 
        (uint16_t )223,      (uint16_t )221,      (uint16_t )218,      (uint16_t )216, 
        (uint16_t )214,      (uint16_t )211,      (uint16_t )208,      (uint16_t )205, 
        (uint16_t )203,      (uint16_t )201,      (uint16_t )198,      (uint16_t )196, 
        (uint16_t )192,      (uint16_t )191,      (uint16_t )188,      (uint16_t )187, 
        (uint16_t )183,      (uint16_t )181,      (uint16_t )179,      (uint16_t )176, 
        (uint16_t )175,      (uint16_t )171,      (uint16_t )171,      (uint16_t )168, 
        (uint16_t )165,      (uint16_t )163,      (uint16_t )160,      (uint16_t )159, 
        (uint16_t )156,      (uint16_t )154,      (uint16_t )152,      (uint16_t )150, 
        (uint16_t )148,      (uint16_t )146,      (uint16_t )144,      (uint16_t )142, 
        (uint16_t )139,      (uint16_t )138,      (uint16_t )135,      (uint16_t )133, 
        (uint16_t )131,      (uint16_t )128,      (uint16_t )128,      (uint16_t )125, 
        (uint16_t )123,      (uint16_t )121,      (uint16_t )119,      (uint16_t )117, 
        (uint16_t )115,      (uint16_t )113,      (uint16_t )111,      (uint16_t )110, 
        (uint16_t )107,      (uint16_t )105,      (uint16_t )103,      (uint16_t )102, 
        (uint16_t )100,      (uint16_t )98,      (uint16_t )96,      (uint16_t )94, 
        (uint16_t )92,      (uint16_t )91,      (uint16_t )89,      (uint16_t )86, 
        (uint16_t )86,      (uint16_t )83,      (uint16_t )82,      (uint16_t )80, 
        (uint16_t )77,      (uint16_t )76,      (uint16_t )74,      (uint16_t )73, 
        (uint16_t )71,      (uint16_t )69,      (uint16_t )67,      (uint16_t )66, 
        (uint16_t )64,      (uint16_t )63,      (uint16_t )61,      (uint16_t )59, 
        (uint16_t )57,      (uint16_t )55,      (uint16_t )54,      (uint16_t )52, 
        (uint16_t )51,      (uint16_t )49,      (uint16_t )47,      (uint16_t )46, 
        (uint16_t )44,      (uint16_t )43,      (uint16_t )41,      (uint16_t )40, 
        (uint16_t )38,      (uint16_t )36,      (uint16_t )35,      (uint16_t )33, 
        (uint16_t )32,      (uint16_t )30,      (uint16_t )29,      (uint16_t )27, 
        (uint16_t )25,      (uint16_t )24,      (uint16_t )22,      (uint16_t )21, 
        (uint16_t )19,      (uint16_t )18,      (uint16_t )16,      (uint16_t )15, 
        (uint16_t )13,      (uint16_t )12,      (uint16_t )10,      (uint16_t )9, 
        (uint16_t )7,      (uint16_t )6,      (uint16_t )4,      (uint16_t )3};
#line 56 "/root/patchweave_new/13/src/enc/cost.c"
uint16_t VP8LevelCodes[67][2]  = 
#line 56
  { {        (uint16_t )1,        (uint16_t )0}, 
   {        (uint16_t )7,        (uint16_t )1}, 
   {        (uint16_t )15,        (uint16_t )5}, 
   {        (uint16_t )15,        (uint16_t )13}, 
   {        (uint16_t )51,        (uint16_t )3}, 
   {        (uint16_t )51,        (uint16_t )3}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )339}};
#line 78 "/root/patchweave_new/13/src/enc/cost.c"
uint16_t VP8LevelFixedCosts[2048]  = 
#line 78
  {      (uint16_t )0,      (uint16_t )256,      (uint16_t )256,      (uint16_t )256, 
        (uint16_t )256,      (uint16_t )432,      (uint16_t )618,      (uint16_t )630, 
        (uint16_t )731,      (uint16_t )640,      (uint16_t )640,      (uint16_t )828, 
        (uint16_t )901,      (uint16_t )948,      (uint16_t )1021,      (uint16_t )1101, 
        (uint16_t )1174,      (uint16_t )1221,      (uint16_t )1294,      (uint16_t )1042, 
        (uint16_t )1085,      (uint16_t )1115,      (uint16_t )1158,      (uint16_t )1202, 
        (uint16_t )1245,      (uint16_t )1275,      (uint16_t )1318,      (uint16_t )1337, 
        (uint16_t )1380,      (uint16_t )1410,      (uint16_t )1453,      (uint16_t )1497, 
        (uint16_t )1540,      (uint16_t )1570,      (uint16_t )1613,      (uint16_t )1280, 
        (uint16_t )1295,      (uint16_t )1317,      (uint16_t )1332,      (uint16_t )1358, 
        (uint16_t )1373,      (uint16_t )1395,      (uint16_t )1410,      (uint16_t )1454, 
        (uint16_t )1469,      (uint16_t )1491,      (uint16_t )1506,      (uint16_t )1532, 
        (uint16_t )1547,      (uint16_t )1569,      (uint16_t )1584,      (uint16_t )1601, 
        (uint16_t )1616,      (uint16_t )1638,      (uint16_t )1653,      (uint16_t )1679, 
        (uint16_t )1694,      (uint16_t )1716,      (uint16_t )1731,      (uint16_t )1775, 
        (uint16_t )1790,      (uint16_t )1812,      (uint16_t )1827,      (uint16_t )1853, 
        (uint16_t )1868,      (uint16_t )1890,      (uint16_t )1905,      (uint16_t )1727, 
        (uint16_t )1733,      (uint16_t )1742,      (uint16_t )1748,      (uint16_t )1759, 
        (uint16_t )1765,      (uint16_t )1774,      (uint16_t )1780,      (uint16_t )1800, 
        (uint16_t )1806,      (uint16_t )1815,      (uint16_t )1821,      (uint16_t )1832, 
        (uint16_t )1838,      (uint16_t )1847,      (uint16_t )1853,      (uint16_t )1878, 
        (uint16_t )1884,      (uint16_t )1893,      (uint16_t )1899,      (uint16_t )1910, 
        (uint16_t )1916,      (uint16_t )1925,      (uint16_t )1931,      (uint16_t )1951, 
        (uint16_t )1957,      (uint16_t )1966,      (uint16_t )1972,      (uint16_t )1983, 
        (uint16_t )1989,      (uint16_t )1998,      (uint16_t )2004,      (uint16_t )2027, 
        (uint16_t )2033,      (uint16_t )2042,      (uint16_t )2048,      (uint16_t )2059, 
        (uint16_t )2065,      (uint16_t )2074,      (uint16_t )2080,      (uint16_t )2100, 
        (uint16_t )2106,      (uint16_t )2115,      (uint16_t )2121,      (uint16_t )2132, 
        (uint16_t )2138,      (uint16_t )2147,      (uint16_t )2153,      (uint16_t )2178, 
        (uint16_t )2184,      (uint16_t )2193,      (uint16_t )2199,      (uint16_t )2210, 
        (uint16_t )2216,      (uint16_t )2225,      (uint16_t )2231,      (uint16_t )2251, 
        (uint16_t )2257,      (uint16_t )2266,      (uint16_t )2272,      (uint16_t )2283, 
        (uint16_t )2289,      (uint16_t )2298,      (uint16_t )2304,      (uint16_t )2168, 
        (uint16_t )2174,      (uint16_t )2183,      (uint16_t )2189,      (uint16_t )2200, 
        (uint16_t )2206,      (uint16_t )2215,      (uint16_t )2221,      (uint16_t )2241, 
        (uint16_t )2247,      (uint16_t )2256,      (uint16_t )2262,      (uint16_t )2273, 
        (uint16_t )2279,      (uint16_t )2288,      (uint16_t )2294,      (uint16_t )2319, 
        (uint16_t )2325,      (uint16_t )2334,      (uint16_t )2340,      (uint16_t )2351, 
        (uint16_t )2357,      (uint16_t )2366,      (uint16_t )2372,      (uint16_t )2392, 
        (uint16_t )2398,      (uint16_t )2407,      (uint16_t )2413,      (uint16_t )2424, 
        (uint16_t )2430,      (uint16_t )2439,      (uint16_t )2445,      (uint16_t )2468, 
        (uint16_t )2474,      (uint16_t )2483,      (uint16_t )2489,      (uint16_t )2500, 
        (uint16_t )2506,      (uint16_t )2515,      (uint16_t )2521,      (uint16_t )2541, 
        (uint16_t )2547,      (uint16_t )2556,      (uint16_t )2562,      (uint16_t )2573, 
        (uint16_t )2579,      (uint16_t )2588,      (uint16_t )2594,      (uint16_t )2619, 
        (uint16_t )2625,      (uint16_t )2634,      (uint16_t )2640,      (uint16_t )2651, 
        (uint16_t )2657,      (uint16_t )2666,      (uint16_t )2672,      (uint16_t )2692, 
        (uint16_t )2698,      (uint16_t )2707,      (uint16_t )2713,      (uint16_t )2724, 
        (uint16_t )2730,      (uint16_t )2739,      (uint16_t )2745,      (uint16_t )2540, 
        (uint16_t )2546,      (uint16_t )2555,      (uint16_t )2561,      (uint16_t )2572, 
        (uint16_t )2578,      (uint16_t )2587,      (uint16_t )2593,      (uint16_t )2613, 
        (uint16_t )2619,      (uint16_t )2628,      (uint16_t )2634,      (uint16_t )2645, 
        (uint16_t )2651,      (uint16_t )2660,      (uint16_t )2666,      (uint16_t )2691, 
        (uint16_t )2697,      (uint16_t )2706,      (uint16_t )2712,      (uint16_t )2723, 
        (uint16_t )2729,      (uint16_t )2738,      (uint16_t )2744,      (uint16_t )2764, 
        (uint16_t )2770,      (uint16_t )2779,      (uint16_t )2785,      (uint16_t )2796, 
        (uint16_t )2802,      (uint16_t )2811,      (uint16_t )2817,      (uint16_t )2840, 
        (uint16_t )2846,      (uint16_t )2855,      (uint16_t )2861,      (uint16_t )2872, 
        (uint16_t )2878,      (uint16_t )2887,      (uint16_t )2893,      (uint16_t )2913, 
        (uint16_t )2919,      (uint16_t )2928,      (uint16_t )2934,      (uint16_t )2945, 
        (uint16_t )2951,      (uint16_t )2960,      (uint16_t )2966,      (uint16_t )2991, 
        (uint16_t )2997,      (uint16_t )3006,      (uint16_t )3012,      (uint16_t )3023, 
        (uint16_t )3029,      (uint16_t )3038,      (uint16_t )3044,      (uint16_t )3064, 
        (uint16_t )3070,      (uint16_t )3079,      (uint16_t )3085,      (uint16_t )3096, 
        (uint16_t )3102,      (uint16_t )3111,      (uint16_t )3117,      (uint16_t )2981, 
        (uint16_t )2987,      (uint16_t )2996,      (uint16_t )3002,      (uint16_t )3013, 
        (uint16_t )3019,      (uint16_t )3028,      (uint16_t )3034,      (uint16_t )3054, 
        (uint16_t )3060,      (uint16_t )3069,      (uint16_t )3075,      (uint16_t )3086, 
        (uint16_t )3092,      (uint16_t )3101,      (uint16_t )3107,      (uint16_t )3132, 
        (uint16_t )3138,      (uint16_t )3147,      (uint16_t )3153,      (uint16_t )3164, 
        (uint16_t )3170,      (uint16_t )3179,      (uint16_t )3185,      (uint16_t )3205, 
        (uint16_t )3211,      (uint16_t )3220,      (uint16_t )3226,      (uint16_t )3237, 
        (uint16_t )3243,      (uint16_t )3252,      (uint16_t )3258,      (uint16_t )3281, 
        (uint16_t )3287,      (uint16_t )3296,      (uint16_t )3302,      (uint16_t )3313, 
        (uint16_t )3319,      (uint16_t )3328,      (uint16_t )3334,      (uint16_t )3354, 
        (uint16_t )3360,      (uint16_t )3369,      (uint16_t )3375,      (uint16_t )3386, 
        (uint16_t )3392,      (uint16_t )3401,      (uint16_t )3407,      (uint16_t )3432, 
        (uint16_t )3438,      (uint16_t )3447,      (uint16_t )3453,      (uint16_t )3464, 
        (uint16_t )3470,      (uint16_t )3479,      (uint16_t )3485,      (uint16_t )3505, 
        (uint16_t )3511,      (uint16_t )3520,      (uint16_t )3526,      (uint16_t )3537, 
        (uint16_t )3543,      (uint16_t )3552,      (uint16_t )3558,      (uint16_t )2816, 
        (uint16_t )2822,      (uint16_t )2831,      (uint16_t )2837,      (uint16_t )2848, 
        (uint16_t )2854,      (uint16_t )2863,      (uint16_t )2869,      (uint16_t )2889, 
        (uint16_t )2895,      (uint16_t )2904,      (uint16_t )2910,      (uint16_t )2921, 
        (uint16_t )2927,      (uint16_t )2936,      (uint16_t )2942,      (uint16_t )2967, 
        (uint16_t )2973,      (uint16_t )2982,      (uint16_t )2988,      (uint16_t )2999, 
        (uint16_t )3005,      (uint16_t )3014,      (uint16_t )3020,      (uint16_t )3040, 
        (uint16_t )3046,      (uint16_t )3055,      (uint16_t )3061,      (uint16_t )3072, 
        (uint16_t )3078,      (uint16_t )3087,      (uint16_t )3093,      (uint16_t )3116, 
        (uint16_t )3122,      (uint16_t )3131,      (uint16_t )3137,      (uint16_t )3148, 
        (uint16_t )3154,      (uint16_t )3163,      (uint16_t )3169,      (uint16_t )3189, 
        (uint16_t )3195,      (uint16_t )3204,      (uint16_t )3210,      (uint16_t )3221, 
        (uint16_t )3227,      (uint16_t )3236,      (uint16_t )3242,      (uint16_t )3267, 
        (uint16_t )3273,      (uint16_t )3282,      (uint16_t )3288,      (uint16_t )3299, 
        (uint16_t )3305,      (uint16_t )3314,      (uint16_t )3320,      (uint16_t )3340, 
        (uint16_t )3346,      (uint16_t )3355,      (uint16_t )3361,      (uint16_t )3372, 
        (uint16_t )3378,      (uint16_t )3387,      (uint16_t )3393,      (uint16_t )3257, 
        (uint16_t )3263,      (uint16_t )3272,      (uint16_t )3278,      (uint16_t )3289, 
        (uint16_t )3295,      (uint16_t )3304,      (uint16_t )3310,      (uint16_t )3330, 
        (uint16_t )3336,      (uint16_t )3345,      (uint16_t )3351,      (uint16_t )3362, 
        (uint16_t )3368,      (uint16_t )3377,      (uint16_t )3383,      (uint16_t )3408, 
        (uint16_t )3414,      (uint16_t )3423,      (uint16_t )3429,      (uint16_t )3440, 
        (uint16_t )3446,      (uint16_t )3455,      (uint16_t )3461,      (uint16_t )3481, 
        (uint16_t )3487,      (uint16_t )3496,      (uint16_t )3502,      (uint16_t )3513, 
        (uint16_t )3519,      (uint16_t )3528,      (uint16_t )3534,      (uint16_t )3557, 
        (uint16_t )3563,      (uint16_t )3572,      (uint16_t )3578,      (uint16_t )3589, 
        (uint16_t )3595,      (uint16_t )3604,      (uint16_t )3610,      (uint16_t )3630, 
        (uint16_t )3636,      (uint16_t )3645,      (uint16_t )3651,      (uint16_t )3662, 
        (uint16_t )3668,      (uint16_t )3677,      (uint16_t )3683,      (uint16_t )3708, 
        (uint16_t )3714,      (uint16_t )3723,      (uint16_t )3729,      (uint16_t )3740, 
        (uint16_t )3746,      (uint16_t )3755,      (uint16_t )3761,      (uint16_t )3781, 
        (uint16_t )3787,      (uint16_t )3796,      (uint16_t )3802,      (uint16_t )3813, 
        (uint16_t )3819,      (uint16_t )3828,      (uint16_t )3834,      (uint16_t )3629, 
        (uint16_t )3635,      (uint16_t )3644,      (uint16_t )3650,      (uint16_t )3661, 
        (uint16_t )3667,      (uint16_t )3676,      (uint16_t )3682,      (uint16_t )3702, 
        (uint16_t )3708,      (uint16_t )3717,      (uint16_t )3723,      (uint16_t )3734, 
        (uint16_t )3740,      (uint16_t )3749,      (uint16_t )3755,      (uint16_t )3780, 
        (uint16_t )3786,      (uint16_t )3795,      (uint16_t )3801,      (uint16_t )3812, 
        (uint16_t )3818,      (uint16_t )3827,      (uint16_t )3833,      (uint16_t )3853, 
        (uint16_t )3859,      (uint16_t )3868,      (uint16_t )3874,      (uint16_t )3885, 
        (uint16_t )3891,      (uint16_t )3900,      (uint16_t )3906,      (uint16_t )3929, 
        (uint16_t )3935,      (uint16_t )3944,      (uint16_t )3950,      (uint16_t )3961, 
        (uint16_t )3967,      (uint16_t )3976,      (uint16_t )3982,      (uint16_t )4002, 
        (uint16_t )4008,      (uint16_t )4017,      (uint16_t )4023,      (uint16_t )4034, 
        (uint16_t )4040,      (uint16_t )4049,      (uint16_t )4055,      (uint16_t )4080, 
        (uint16_t )4086,      (uint16_t )4095,      (uint16_t )4101,      (uint16_t )4112, 
        (uint16_t )4118,      (uint16_t )4127,      (uint16_t )4133,      (uint16_t )4153, 
        (uint16_t )4159,      (uint16_t )4168,      (uint16_t )4174,      (uint16_t )4185, 
        (uint16_t )4191,      (uint16_t )4200,      (uint16_t )4206,      (uint16_t )4070, 
        (uint16_t )4076,      (uint16_t )4085,      (uint16_t )4091,      (uint16_t )4102, 
        (uint16_t )4108,      (uint16_t )4117,      (uint16_t )4123,      (uint16_t )4143, 
        (uint16_t )4149,      (uint16_t )4158,      (uint16_t )4164,      (uint16_t )4175, 
        (uint16_t )4181,      (uint16_t )4190,      (uint16_t )4196,      (uint16_t )4221, 
        (uint16_t )4227,      (uint16_t )4236,      (uint16_t )4242,      (uint16_t )4253, 
        (uint16_t )4259,      (uint16_t )4268,      (uint16_t )4274,      (uint16_t )4294, 
        (uint16_t )4300,      (uint16_t )4309,      (uint16_t )4315,      (uint16_t )4326, 
        (uint16_t )4332,      (uint16_t )4341,      (uint16_t )4347,      (uint16_t )4370, 
        (uint16_t )4376,      (uint16_t )4385,      (uint16_t )4391,      (uint16_t )4402, 
        (uint16_t )4408,      (uint16_t )4417,      (uint16_t )4423,      (uint16_t )4443, 
        (uint16_t )4449,      (uint16_t )4458,      (uint16_t )4464,      (uint16_t )4475, 
        (uint16_t )4481,      (uint16_t )4490,      (uint16_t )4496,      (uint16_t )4521, 
        (uint16_t )4527,      (uint16_t )4536,      (uint16_t )4542,      (uint16_t )4553, 
        (uint16_t )4559,      (uint16_t )4568,      (uint16_t )4574,      (uint16_t )4594, 
        (uint16_t )4600,      (uint16_t )4609,      (uint16_t )4615,      (uint16_t )4626, 
        (uint16_t )4632,      (uint16_t )4641,      (uint16_t )4647,      (uint16_t )3515, 
        (uint16_t )3521,      (uint16_t )3530,      (uint16_t )3536,      (uint16_t )3547, 
        (uint16_t )3553,      (uint16_t )3562,      (uint16_t )3568,      (uint16_t )3588, 
        (uint16_t )3594,      (uint16_t )3603,      (uint16_t )3609,      (uint16_t )3620, 
        (uint16_t )3626,      (uint16_t )3635,      (uint16_t )3641,      (uint16_t )3666, 
        (uint16_t )3672,      (uint16_t )3681,      (uint16_t )3687,      (uint16_t )3698, 
        (uint16_t )3704,      (uint16_t )3713,      (uint16_t )3719,      (uint16_t )3739, 
        (uint16_t )3745,      (uint16_t )3754,      (uint16_t )3760,      (uint16_t )3771, 
        (uint16_t )3777,      (uint16_t )3786,      (uint16_t )3792,      (uint16_t )3815, 
        (uint16_t )3821,      (uint16_t )3830,      (uint16_t )3836,      (uint16_t )3847, 
        (uint16_t )3853,      (uint16_t )3862,      (uint16_t )3868,      (uint16_t )3888, 
        (uint16_t )3894,      (uint16_t )3903,      (uint16_t )3909,      (uint16_t )3920, 
        (uint16_t )3926,      (uint16_t )3935,      (uint16_t )3941,      (uint16_t )3966, 
        (uint16_t )3972,      (uint16_t )3981,      (uint16_t )3987,      (uint16_t )3998, 
        (uint16_t )4004,      (uint16_t )4013,      (uint16_t )4019,      (uint16_t )4039, 
        (uint16_t )4045,      (uint16_t )4054,      (uint16_t )4060,      (uint16_t )4071, 
        (uint16_t )4077,      (uint16_t )4086,      (uint16_t )4092,      (uint16_t )3956, 
        (uint16_t )3962,      (uint16_t )3971,      (uint16_t )3977,      (uint16_t )3988, 
        (uint16_t )3994,      (uint16_t )4003,      (uint16_t )4009,      (uint16_t )4029, 
        (uint16_t )4035,      (uint16_t )4044,      (uint16_t )4050,      (uint16_t )4061, 
        (uint16_t )4067,      (uint16_t )4076,      (uint16_t )4082,      (uint16_t )4107, 
        (uint16_t )4113,      (uint16_t )4122,      (uint16_t )4128,      (uint16_t )4139, 
        (uint16_t )4145,      (uint16_t )4154,      (uint16_t )4160,      (uint16_t )4180, 
        (uint16_t )4186,      (uint16_t )4195,      (uint16_t )4201,      (uint16_t )4212, 
        (uint16_t )4218,      (uint16_t )4227,      (uint16_t )4233,      (uint16_t )4256, 
        (uint16_t )4262,      (uint16_t )4271,      (uint16_t )4277,      (uint16_t )4288, 
        (uint16_t )4294,      (uint16_t )4303,      (uint16_t )4309,      (uint16_t )4329, 
        (uint16_t )4335,      (uint16_t )4344,      (uint16_t )4350,      (uint16_t )4361, 
        (uint16_t )4367,      (uint16_t )4376,      (uint16_t )4382,      (uint16_t )4407, 
        (uint16_t )4413,      (uint16_t )4422,      (uint16_t )4428,      (uint16_t )4439, 
        (uint16_t )4445,      (uint16_t )4454,      (uint16_t )4460,      (uint16_t )4480, 
        (uint16_t )4486,      (uint16_t )4495,      (uint16_t )4501,      (uint16_t )4512, 
        (uint16_t )4518,      (uint16_t )4527,      (uint16_t )4533,      (uint16_t )4328, 
        (uint16_t )4334,      (uint16_t )4343,      (uint16_t )4349,      (uint16_t )4360, 
        (uint16_t )4366,      (uint16_t )4375,      (uint16_t )4381,      (uint16_t )4401, 
        (uint16_t )4407,      (uint16_t )4416,      (uint16_t )4422,      (uint16_t )4433, 
        (uint16_t )4439,      (uint16_t )4448,      (uint16_t )4454,      (uint16_t )4479, 
        (uint16_t )4485,      (uint16_t )4494,      (uint16_t )4500,      (uint16_t )4511, 
        (uint16_t )4517,      (uint16_t )4526,      (uint16_t )4532,      (uint16_t )4552, 
        (uint16_t )4558,      (uint16_t )4567,      (uint16_t )4573,      (uint16_t )4584, 
        (uint16_t )4590,      (uint16_t )4599,      (uint16_t )4605,      (uint16_t )4628, 
        (uint16_t )4634,      (uint16_t )4643,      (uint16_t )4649,      (uint16_t )4660, 
        (uint16_t )4666,      (uint16_t )4675,      (uint16_t )4681,      (uint16_t )4701, 
        (uint16_t )4707,      (uint16_t )4716,      (uint16_t )4722,      (uint16_t )4733, 
        (uint16_t )4739,      (uint16_t )4748,      (uint16_t )4754,      (uint16_t )4779, 
        (uint16_t )4785,      (uint16_t )4794,      (uint16_t )4800,      (uint16_t )4811, 
        (uint16_t )4817,      (uint16_t )4826,      (uint16_t )4832,      (uint16_t )4852, 
        (uint16_t )4858,      (uint16_t )4867,      (uint16_t )4873,      (uint16_t )4884, 
        (uint16_t )4890,      (uint16_t )4899,      (uint16_t )4905,      (uint16_t )4769, 
        (uint16_t )4775,      (uint16_t )4784,      (uint16_t )4790,      (uint16_t )4801, 
        (uint16_t )4807,      (uint16_t )4816,      (uint16_t )4822,      (uint16_t )4842, 
        (uint16_t )4848,      (uint16_t )4857,      (uint16_t )4863,      (uint16_t )4874, 
        (uint16_t )4880,      (uint16_t )4889,      (uint16_t )4895,      (uint16_t )4920, 
        (uint16_t )4926,      (uint16_t )4935,      (uint16_t )4941,      (uint16_t )4952, 
        (uint16_t )4958,      (uint16_t )4967,      (uint16_t )4973,      (uint16_t )4993, 
        (uint16_t )4999,      (uint16_t )5008,      (uint16_t )5014,      (uint16_t )5025, 
        (uint16_t )5031,      (uint16_t )5040,      (uint16_t )5046,      (uint16_t )5069, 
        (uint16_t )5075,      (uint16_t )5084,      (uint16_t )5090,      (uint16_t )5101, 
        (uint16_t )5107,      (uint16_t )5116,      (uint16_t )5122,      (uint16_t )5142, 
        (uint16_t )5148,      (uint16_t )5157,      (uint16_t )5163,      (uint16_t )5174, 
        (uint16_t )5180,      (uint16_t )5189,      (uint16_t )5195,      (uint16_t )5220, 
        (uint16_t )5226,      (uint16_t )5235,      (uint16_t )5241,      (uint16_t )5252, 
        (uint16_t )5258,      (uint16_t )5267,      (uint16_t )5273,      (uint16_t )5293, 
        (uint16_t )5299,      (uint16_t )5308,      (uint16_t )5314,      (uint16_t )5325, 
        (uint16_t )5331,      (uint16_t )5340,      (uint16_t )5346,      (uint16_t )4604, 
        (uint16_t )4610,      (uint16_t )4619,      (uint16_t )4625,      (uint16_t )4636, 
        (uint16_t )4642,      (uint16_t )4651,      (uint16_t )4657,      (uint16_t )4677, 
        (uint16_t )4683,      (uint16_t )4692,      (uint16_t )4698,      (uint16_t )4709, 
        (uint16_t )4715,      (uint16_t )4724,      (uint16_t )4730,      (uint16_t )4755, 
        (uint16_t )4761,      (uint16_t )4770,      (uint16_t )4776,      (uint16_t )4787, 
        (uint16_t )4793,      (uint16_t )4802,      (uint16_t )4808,      (uint16_t )4828, 
        (uint16_t )4834,      (uint16_t )4843,      (uint16_t )4849,      (uint16_t )4860, 
        (uint16_t )4866,      (uint16_t )4875,      (uint16_t )4881,      (uint16_t )4904, 
        (uint16_t )4910,      (uint16_t )4919,      (uint16_t )4925,      (uint16_t )4936, 
        (uint16_t )4942,      (uint16_t )4951,      (uint16_t )4957,      (uint16_t )4977, 
        (uint16_t )4983,      (uint16_t )4992,      (uint16_t )4998,      (uint16_t )5009, 
        (uint16_t )5015,      (uint16_t )5024,      (uint16_t )5030,      (uint16_t )5055, 
        (uint16_t )5061,      (uint16_t )5070,      (uint16_t )5076,      (uint16_t )5087, 
        (uint16_t )5093,      (uint16_t )5102,      (uint16_t )5108,      (uint16_t )5128, 
        (uint16_t )5134,      (uint16_t )5143,      (uint16_t )5149,      (uint16_t )5160, 
        (uint16_t )5166,      (uint16_t )5175,      (uint16_t )5181,      (uint16_t )5045, 
        (uint16_t )5051,      (uint16_t )5060,      (uint16_t )5066,      (uint16_t )5077, 
        (uint16_t )5083,      (uint16_t )5092,      (uint16_t )5098,      (uint16_t )5118, 
        (uint16_t )5124,      (uint16_t )5133,      (uint16_t )5139,      (uint16_t )5150, 
        (uint16_t )5156,      (uint16_t )5165,      (uint16_t )5171,      (uint16_t )5196, 
        (uint16_t )5202,      (uint16_t )5211,      (uint16_t )5217,      (uint16_t )5228, 
        (uint16_t )5234,      (uint16_t )5243,      (uint16_t )5249,      (uint16_t )5269, 
        (uint16_t )5275,      (uint16_t )5284,      (uint16_t )5290,      (uint16_t )5301, 
        (uint16_t )5307,      (uint16_t )5316,      (uint16_t )5322,      (uint16_t )5345, 
        (uint16_t )5351,      (uint16_t )5360,      (uint16_t )5366,      (uint16_t )5377, 
        (uint16_t )5383,      (uint16_t )5392,      (uint16_t )5398,      (uint16_t )5418, 
        (uint16_t )5424,      (uint16_t )5433,      (uint16_t )5439,      (uint16_t )5450, 
        (uint16_t )5456,      (uint16_t )5465,      (uint16_t )5471,      (uint16_t )5496, 
        (uint16_t )5502,      (uint16_t )5511,      (uint16_t )5517,      (uint16_t )5528, 
        (uint16_t )5534,      (uint16_t )5543,      (uint16_t )5549,      (uint16_t )5569, 
        (uint16_t )5575,      (uint16_t )5584,      (uint16_t )5590,      (uint16_t )5601, 
        (uint16_t )5607,      (uint16_t )5616,      (uint16_t )5622,      (uint16_t )5417, 
        (uint16_t )5423,      (uint16_t )5432,      (uint16_t )5438,      (uint16_t )5449, 
        (uint16_t )5455,      (uint16_t )5464,      (uint16_t )5470,      (uint16_t )5490, 
        (uint16_t )5496,      (uint16_t )5505,      (uint16_t )5511,      (uint16_t )5522, 
        (uint16_t )5528,      (uint16_t )5537,      (uint16_t )5543,      (uint16_t )5568, 
        (uint16_t )5574,      (uint16_t )5583,      (uint16_t )5589,      (uint16_t )5600, 
        (uint16_t )5606,      (uint16_t )5615,      (uint16_t )5621,      (uint16_t )5641, 
        (uint16_t )5647,      (uint16_t )5656,      (uint16_t )5662,      (uint16_t )5673, 
        (uint16_t )5679,      (uint16_t )5688,      (uint16_t )5694,      (uint16_t )5717, 
        (uint16_t )5723,      (uint16_t )5732,      (uint16_t )5738,      (uint16_t )5749, 
        (uint16_t )5755,      (uint16_t )5764,      (uint16_t )5770,      (uint16_t )5790, 
        (uint16_t )5796,      (uint16_t )5805,      (uint16_t )5811,      (uint16_t )5822, 
        (uint16_t )5828,      (uint16_t )5837,      (uint16_t )5843,      (uint16_t )5868, 
        (uint16_t )5874,      (uint16_t )5883,      (uint16_t )5889,      (uint16_t )5900, 
        (uint16_t )5906,      (uint16_t )5915,      (uint16_t )5921,      (uint16_t )5941, 
        (uint16_t )5947,      (uint16_t )5956,      (uint16_t )5962,      (uint16_t )5973, 
        (uint16_t )5979,      (uint16_t )5988,      (uint16_t )5994,      (uint16_t )5858, 
        (uint16_t )5864,      (uint16_t )5873,      (uint16_t )5879,      (uint16_t )5890, 
        (uint16_t )5896,      (uint16_t )5905,      (uint16_t )5911,      (uint16_t )5931, 
        (uint16_t )5937,      (uint16_t )5946,      (uint16_t )5952,      (uint16_t )5963, 
        (uint16_t )5969,      (uint16_t )5978,      (uint16_t )5984,      (uint16_t )6009, 
        (uint16_t )6015,      (uint16_t )6024,      (uint16_t )6030,      (uint16_t )6041, 
        (uint16_t )6047,      (uint16_t )6056,      (uint16_t )6062,      (uint16_t )6082, 
        (uint16_t )6088,      (uint16_t )6097,      (uint16_t )6103,      (uint16_t )6114, 
        (uint16_t )6120,      (uint16_t )6129,      (uint16_t )6135,      (uint16_t )6158, 
        (uint16_t )6164,      (uint16_t )6173,      (uint16_t )6179,      (uint16_t )6190, 
        (uint16_t )6196,      (uint16_t )6205,      (uint16_t )6211,      (uint16_t )6231, 
        (uint16_t )6237,      (uint16_t )6246,      (uint16_t )6252,      (uint16_t )6263, 
        (uint16_t )6269,      (uint16_t )6278,      (uint16_t )6284,      (uint16_t )6309, 
        (uint16_t )6315,      (uint16_t )6324,      (uint16_t )6330,      (uint16_t )6341, 
        (uint16_t )6347,      (uint16_t )6356,      (uint16_t )6362,      (uint16_t )6382, 
        (uint16_t )6388,      (uint16_t )6397,      (uint16_t )6403,      (uint16_t )6414, 
        (uint16_t )6420,      (uint16_t )6429,      (uint16_t )6435,      (uint16_t )3515, 
        (uint16_t )3521,      (uint16_t )3530,      (uint16_t )3536,      (uint16_t )3547, 
        (uint16_t )3553,      (uint16_t )3562,      (uint16_t )3568,      (uint16_t )3588, 
        (uint16_t )3594,      (uint16_t )3603,      (uint16_t )3609,      (uint16_t )3620, 
        (uint16_t )3626,      (uint16_t )3635,      (uint16_t )3641,      (uint16_t )3666, 
        (uint16_t )3672,      (uint16_t )3681,      (uint16_t )3687,      (uint16_t )3698, 
        (uint16_t )3704,      (uint16_t )3713,      (uint16_t )3719,      (uint16_t )3739, 
        (uint16_t )3745,      (uint16_t )3754,      (uint16_t )3760,      (uint16_t )3771, 
        (uint16_t )3777,      (uint16_t )3786,      (uint16_t )3792,      (uint16_t )3815, 
        (uint16_t )3821,      (uint16_t )3830,      (uint16_t )3836,      (uint16_t )3847, 
        (uint16_t )3853,      (uint16_t )3862,      (uint16_t )3868,      (uint16_t )3888, 
        (uint16_t )3894,      (uint16_t )3903,      (uint16_t )3909,      (uint16_t )3920, 
        (uint16_t )3926,      (uint16_t )3935,      (uint16_t )3941,      (uint16_t )3966, 
        (uint16_t )3972,      (uint16_t )3981,      (uint16_t )3987,      (uint16_t )3998, 
        (uint16_t )4004,      (uint16_t )4013,      (uint16_t )4019,      (uint16_t )4039, 
        (uint16_t )4045,      (uint16_t )4054,      (uint16_t )4060,      (uint16_t )4071, 
        (uint16_t )4077,      (uint16_t )4086,      (uint16_t )4092,      (uint16_t )3956, 
        (uint16_t )3962,      (uint16_t )3971,      (uint16_t )3977,      (uint16_t )3988, 
        (uint16_t )3994,      (uint16_t )4003,      (uint16_t )4009,      (uint16_t )4029, 
        (uint16_t )4035,      (uint16_t )4044,      (uint16_t )4050,      (uint16_t )4061, 
        (uint16_t )4067,      (uint16_t )4076,      (uint16_t )4082,      (uint16_t )4107, 
        (uint16_t )4113,      (uint16_t )4122,      (uint16_t )4128,      (uint16_t )4139, 
        (uint16_t )4145,      (uint16_t )4154,      (uint16_t )4160,      (uint16_t )4180, 
        (uint16_t )4186,      (uint16_t )4195,      (uint16_t )4201,      (uint16_t )4212, 
        (uint16_t )4218,      (uint16_t )4227,      (uint16_t )4233,      (uint16_t )4256, 
        (uint16_t )4262,      (uint16_t )4271,      (uint16_t )4277,      (uint16_t )4288, 
        (uint16_t )4294,      (uint16_t )4303,      (uint16_t )4309,      (uint16_t )4329, 
        (uint16_t )4335,      (uint16_t )4344,      (uint16_t )4350,      (uint16_t )4361, 
        (uint16_t )4367,      (uint16_t )4376,      (uint16_t )4382,      (uint16_t )4407, 
        (uint16_t )4413,      (uint16_t )4422,      (uint16_t )4428,      (uint16_t )4439, 
        (uint16_t )4445,      (uint16_t )4454,      (uint16_t )4460,      (uint16_t )4480, 
        (uint16_t )4486,      (uint16_t )4495,      (uint16_t )4501,      (uint16_t )4512, 
        (uint16_t )4518,      (uint16_t )4527,      (uint16_t )4533,      (uint16_t )4328, 
        (uint16_t )4334,      (uint16_t )4343,      (uint16_t )4349,      (uint16_t )4360, 
        (uint16_t )4366,      (uint16_t )4375,      (uint16_t )4381,      (uint16_t )4401, 
        (uint16_t )4407,      (uint16_t )4416,      (uint16_t )4422,      (uint16_t )4433, 
        (uint16_t )4439,      (uint16_t )4448,      (uint16_t )4454,      (uint16_t )4479, 
        (uint16_t )4485,      (uint16_t )4494,      (uint16_t )4500,      (uint16_t )4511, 
        (uint16_t )4517,      (uint16_t )4526,      (uint16_t )4532,      (uint16_t )4552, 
        (uint16_t )4558,      (uint16_t )4567,      (uint16_t )4573,      (uint16_t )4584, 
        (uint16_t )4590,      (uint16_t )4599,      (uint16_t )4605,      (uint16_t )4628, 
        (uint16_t )4634,      (uint16_t )4643,      (uint16_t )4649,      (uint16_t )4660, 
        (uint16_t )4666,      (uint16_t )4675,      (uint16_t )4681,      (uint16_t )4701, 
        (uint16_t )4707,      (uint16_t )4716,      (uint16_t )4722,      (uint16_t )4733, 
        (uint16_t )4739,      (uint16_t )4748,      (uint16_t )4754,      (uint16_t )4779, 
        (uint16_t )4785,      (uint16_t )4794,      (uint16_t )4800,      (uint16_t )4811, 
        (uint16_t )4817,      (uint16_t )4826,      (uint16_t )4832,      (uint16_t )4852, 
        (uint16_t )4858,      (uint16_t )4867,      (uint16_t )4873,      (uint16_t )4884, 
        (uint16_t )4890,      (uint16_t )4899,      (uint16_t )4905,      (uint16_t )4769, 
        (uint16_t )4775,      (uint16_t )4784,      (uint16_t )4790,      (uint16_t )4801, 
        (uint16_t )4807,      (uint16_t )4816,      (uint16_t )4822,      (uint16_t )4842, 
        (uint16_t )4848,      (uint16_t )4857,      (uint16_t )4863,      (uint16_t )4874, 
        (uint16_t )4880,      (uint16_t )4889,      (uint16_t )4895,      (uint16_t )4920, 
        (uint16_t )4926,      (uint16_t )4935,      (uint16_t )4941,      (uint16_t )4952, 
        (uint16_t )4958,      (uint16_t )4967,      (uint16_t )4973,      (uint16_t )4993, 
        (uint16_t )4999,      (uint16_t )5008,      (uint16_t )5014,      (uint16_t )5025, 
        (uint16_t )5031,      (uint16_t )5040,      (uint16_t )5046,      (uint16_t )5069, 
        (uint16_t )5075,      (uint16_t )5084,      (uint16_t )5090,      (uint16_t )5101, 
        (uint16_t )5107,      (uint16_t )5116,      (uint16_t )5122,      (uint16_t )5142, 
        (uint16_t )5148,      (uint16_t )5157,      (uint16_t )5163,      (uint16_t )5174, 
        (uint16_t )5180,      (uint16_t )5189,      (uint16_t )5195,      (uint16_t )5220, 
        (uint16_t )5226,      (uint16_t )5235,      (uint16_t )5241,      (uint16_t )5252, 
        (uint16_t )5258,      (uint16_t )5267,      (uint16_t )5273,      (uint16_t )5293, 
        (uint16_t )5299,      (uint16_t )5308,      (uint16_t )5314,      (uint16_t )5325, 
        (uint16_t )5331,      (uint16_t )5340,      (uint16_t )5346,      (uint16_t )4604, 
        (uint16_t )4610,      (uint16_t )4619,      (uint16_t )4625,      (uint16_t )4636, 
        (uint16_t )4642,      (uint16_t )4651,      (uint16_t )4657,      (uint16_t )4677, 
        (uint16_t )4683,      (uint16_t )4692,      (uint16_t )4698,      (uint16_t )4709, 
        (uint16_t )4715,      (uint16_t )4724,      (uint16_t )4730,      (uint16_t )4755, 
        (uint16_t )4761,      (uint16_t )4770,      (uint16_t )4776,      (uint16_t )4787, 
        (uint16_t )4793,      (uint16_t )4802,      (uint16_t )4808,      (uint16_t )4828, 
        (uint16_t )4834,      (uint16_t )4843,      (uint16_t )4849,      (uint16_t )4860, 
        (uint16_t )4866,      (uint16_t )4875,      (uint16_t )4881,      (uint16_t )4904, 
        (uint16_t )4910,      (uint16_t )4919,      (uint16_t )4925,      (uint16_t )4936, 
        (uint16_t )4942,      (uint16_t )4951,      (uint16_t )4957,      (uint16_t )4977, 
        (uint16_t )4983,      (uint16_t )4992,      (uint16_t )4998,      (uint16_t )5009, 
        (uint16_t )5015,      (uint16_t )5024,      (uint16_t )5030,      (uint16_t )5055, 
        (uint16_t )5061,      (uint16_t )5070,      (uint16_t )5076,      (uint16_t )5087, 
        (uint16_t )5093,      (uint16_t )5102,      (uint16_t )5108,      (uint16_t )5128, 
        (uint16_t )5134,      (uint16_t )5143,      (uint16_t )5149,      (uint16_t )5160, 
        (uint16_t )5166,      (uint16_t )5175,      (uint16_t )5181,      (uint16_t )5045, 
        (uint16_t )5051,      (uint16_t )5060,      (uint16_t )5066,      (uint16_t )5077, 
        (uint16_t )5083,      (uint16_t )5092,      (uint16_t )5098,      (uint16_t )5118, 
        (uint16_t )5124,      (uint16_t )5133,      (uint16_t )5139,      (uint16_t )5150, 
        (uint16_t )5156,      (uint16_t )5165,      (uint16_t )5171,      (uint16_t )5196, 
        (uint16_t )5202,      (uint16_t )5211,      (uint16_t )5217,      (uint16_t )5228, 
        (uint16_t )5234,      (uint16_t )5243,      (uint16_t )5249,      (uint16_t )5269, 
        (uint16_t )5275,      (uint16_t )5284,      (uint16_t )5290,      (uint16_t )5301, 
        (uint16_t )5307,      (uint16_t )5316,      (uint16_t )5322,      (uint16_t )5345, 
        (uint16_t )5351,      (uint16_t )5360,      (uint16_t )5366,      (uint16_t )5377, 
        (uint16_t )5383,      (uint16_t )5392,      (uint16_t )5398,      (uint16_t )5418, 
        (uint16_t )5424,      (uint16_t )5433,      (uint16_t )5439,      (uint16_t )5450, 
        (uint16_t )5456,      (uint16_t )5465,      (uint16_t )5471,      (uint16_t )5496, 
        (uint16_t )5502,      (uint16_t )5511,      (uint16_t )5517,      (uint16_t )5528, 
        (uint16_t )5534,      (uint16_t )5543,      (uint16_t )5549,      (uint16_t )5569, 
        (uint16_t )5575,      (uint16_t )5584,      (uint16_t )5590,      (uint16_t )5601, 
        (uint16_t )5607,      (uint16_t )5616,      (uint16_t )5622,      (uint16_t )5417, 
        (uint16_t )5423,      (uint16_t )5432,      (uint16_t )5438,      (uint16_t )5449, 
        (uint16_t )5455,      (uint16_t )5464,      (uint16_t )5470,      (uint16_t )5490, 
        (uint16_t )5496,      (uint16_t )5505,      (uint16_t )5511,      (uint16_t )5522, 
        (uint16_t )5528,      (uint16_t )5537,      (uint16_t )5543,      (uint16_t )5568, 
        (uint16_t )5574,      (uint16_t )5583,      (uint16_t )5589,      (uint16_t )5600, 
        (uint16_t )5606,      (uint16_t )5615,      (uint16_t )5621,      (uint16_t )5641, 
        (uint16_t )5647,      (uint16_t )5656,      (uint16_t )5662,      (uint16_t )5673, 
        (uint16_t )5679,      (uint16_t )5688,      (uint16_t )5694,      (uint16_t )5717, 
        (uint16_t )5723,      (uint16_t )5732,      (uint16_t )5738,      (uint16_t )5749, 
        (uint16_t )5755,      (uint16_t )5764,      (uint16_t )5770,      (uint16_t )5790, 
        (uint16_t )5796,      (uint16_t )5805,      (uint16_t )5811,      (uint16_t )5822, 
        (uint16_t )5828,      (uint16_t )5837,      (uint16_t )5843,      (uint16_t )5868, 
        (uint16_t )5874,      (uint16_t )5883,      (uint16_t )5889,      (uint16_t )5900, 
        (uint16_t )5906,      (uint16_t )5915,      (uint16_t )5921,      (uint16_t )5941, 
        (uint16_t )5947,      (uint16_t )5956,      (uint16_t )5962,      (uint16_t )5973, 
        (uint16_t )5979,      (uint16_t )5988,      (uint16_t )5994,      (uint16_t )5858, 
        (uint16_t )5864,      (uint16_t )5873,      (uint16_t )5879,      (uint16_t )5890, 
        (uint16_t )5896,      (uint16_t )5905,      (uint16_t )5911,      (uint16_t )5931, 
        (uint16_t )5937,      (uint16_t )5946,      (uint16_t )5952,      (uint16_t )5963, 
        (uint16_t )5969,      (uint16_t )5978,      (uint16_t )5984,      (uint16_t )6009, 
        (uint16_t )6015,      (uint16_t )6024,      (uint16_t )6030,      (uint16_t )6041, 
        (uint16_t )6047,      (uint16_t )6056,      (uint16_t )6062,      (uint16_t )6082, 
        (uint16_t )6088,      (uint16_t )6097,      (uint16_t )6103,      (uint16_t )6114, 
        (uint16_t )6120,      (uint16_t )6129,      (uint16_t )6135,      (uint16_t )6158, 
        (uint16_t )6164,      (uint16_t )6173,      (uint16_t )6179,      (uint16_t )6190, 
        (uint16_t )6196,      (uint16_t )6205,      (uint16_t )6211,      (uint16_t )6231, 
        (uint16_t )6237,      (uint16_t )6246,      (uint16_t )6252,      (uint16_t )6263, 
        (uint16_t )6269,      (uint16_t )6278,      (uint16_t )6284,      (uint16_t )6309, 
        (uint16_t )6315,      (uint16_t )6324,      (uint16_t )6330,      (uint16_t )6341, 
        (uint16_t )6347,      (uint16_t )6356,      (uint16_t )6362,      (uint16_t )6382, 
        (uint16_t )6388,      (uint16_t )6397,      (uint16_t )6403,      (uint16_t )6414, 
        (uint16_t )6420,      (uint16_t )6429,      (uint16_t )6435,      (uint16_t )5303, 
        (uint16_t )5309,      (uint16_t )5318,      (uint16_t )5324,      (uint16_t )5335, 
        (uint16_t )5341,      (uint16_t )5350,      (uint16_t )5356,      (uint16_t )5376, 
        (uint16_t )5382,      (uint16_t )5391,      (uint16_t )5397,      (uint16_t )5408, 
        (uint16_t )5414,      (uint16_t )5423,      (uint16_t )5429,      (uint16_t )5454, 
        (uint16_t )5460,      (uint16_t )5469,      (uint16_t )5475,      (uint16_t )5486, 
        (uint16_t )5492,      (uint16_t )5501,      (uint16_t )5507,      (uint16_t )5527, 
        (uint16_t )5533,      (uint16_t )5542,      (uint16_t )5548,      (uint16_t )5559, 
        (uint16_t )5565,      (uint16_t )5574,      (uint16_t )5580,      (uint16_t )5603, 
        (uint16_t )5609,      (uint16_t )5618,      (uint16_t )5624,      (uint16_t )5635, 
        (uint16_t )5641,      (uint16_t )5650,      (uint16_t )5656,      (uint16_t )5676, 
        (uint16_t )5682,      (uint16_t )5691,      (uint16_t )5697,      (uint16_t )5708, 
        (uint16_t )5714,      (uint16_t )5723,      (uint16_t )5729,      (uint16_t )5754, 
        (uint16_t )5760,      (uint16_t )5769,      (uint16_t )5775,      (uint16_t )5786, 
        (uint16_t )5792,      (uint16_t )5801,      (uint16_t )5807,      (uint16_t )5827, 
        (uint16_t )5833,      (uint16_t )5842,      (uint16_t )5848,      (uint16_t )5859, 
        (uint16_t )5865,      (uint16_t )5874,      (uint16_t )5880,      (uint16_t )5744, 
        (uint16_t )5750,      (uint16_t )5759,      (uint16_t )5765,      (uint16_t )5776, 
        (uint16_t )5782,      (uint16_t )5791,      (uint16_t )5797,      (uint16_t )5817, 
        (uint16_t )5823,      (uint16_t )5832,      (uint16_t )5838,      (uint16_t )5849, 
        (uint16_t )5855,      (uint16_t )5864,      (uint16_t )5870,      (uint16_t )5895, 
        (uint16_t )5901,      (uint16_t )5910,      (uint16_t )5916,      (uint16_t )5927, 
        (uint16_t )5933,      (uint16_t )5942,      (uint16_t )5948,      (uint16_t )5968, 
        (uint16_t )5974,      (uint16_t )5983,      (uint16_t )5989,      (uint16_t )6000, 
        (uint16_t )6006,      (uint16_t )6015,      (uint16_t )6021,      (uint16_t )6044, 
        (uint16_t )6050,      (uint16_t )6059,      (uint16_t )6065,      (uint16_t )6076, 
        (uint16_t )6082,      (uint16_t )6091,      (uint16_t )6097,      (uint16_t )6117, 
        (uint16_t )6123,      (uint16_t )6132,      (uint16_t )6138,      (uint16_t )6149, 
        (uint16_t )6155,      (uint16_t )6164,      (uint16_t )6170,      (uint16_t )6195, 
        (uint16_t )6201,      (uint16_t )6210,      (uint16_t )6216,      (uint16_t )6227, 
        (uint16_t )6233,      (uint16_t )6242,      (uint16_t )6248,      (uint16_t )6268, 
        (uint16_t )6274,      (uint16_t )6283,      (uint16_t )6289,      (uint16_t )6300, 
        (uint16_t )6306,      (uint16_t )6315,      (uint16_t )6321,      (uint16_t )6116, 
        (uint16_t )6122,      (uint16_t )6131,      (uint16_t )6137,      (uint16_t )6148, 
        (uint16_t )6154,      (uint16_t )6163,      (uint16_t )6169,      (uint16_t )6189, 
        (uint16_t )6195,      (uint16_t )6204,      (uint16_t )6210,      (uint16_t )6221, 
        (uint16_t )6227,      (uint16_t )6236,      (uint16_t )6242,      (uint16_t )6267, 
        (uint16_t )6273,      (uint16_t )6282,      (uint16_t )6288,      (uint16_t )6299, 
        (uint16_t )6305,      (uint16_t )6314,      (uint16_t )6320,      (uint16_t )6340, 
        (uint16_t )6346,      (uint16_t )6355,      (uint16_t )6361,      (uint16_t )6372, 
        (uint16_t )6378,      (uint16_t )6387,      (uint16_t )6393,      (uint16_t )6416, 
        (uint16_t )6422,      (uint16_t )6431,      (uint16_t )6437,      (uint16_t )6448, 
        (uint16_t )6454,      (uint16_t )6463,      (uint16_t )6469,      (uint16_t )6489, 
        (uint16_t )6495,      (uint16_t )6504,      (uint16_t )6510,      (uint16_t )6521, 
        (uint16_t )6527,      (uint16_t )6536,      (uint16_t )6542,      (uint16_t )6567, 
        (uint16_t )6573,      (uint16_t )6582,      (uint16_t )6588,      (uint16_t )6599, 
        (uint16_t )6605,      (uint16_t )6614,      (uint16_t )6620,      (uint16_t )6640, 
        (uint16_t )6646,      (uint16_t )6655,      (uint16_t )6661,      (uint16_t )6672, 
        (uint16_t )6678,      (uint16_t )6687,      (uint16_t )6693,      (uint16_t )6557, 
        (uint16_t )6563,      (uint16_t )6572,      (uint16_t )6578,      (uint16_t )6589, 
        (uint16_t )6595,      (uint16_t )6604,      (uint16_t )6610,      (uint16_t )6630, 
        (uint16_t )6636,      (uint16_t )6645,      (uint16_t )6651,      (uint16_t )6662, 
        (uint16_t )6668,      (uint16_t )6677,      (uint16_t )6683,      (uint16_t )6708, 
        (uint16_t )6714,      (uint16_t )6723,      (uint16_t )6729,      (uint16_t )6740, 
        (uint16_t )6746,      (uint16_t )6755,      (uint16_t )6761,      (uint16_t )6781, 
        (uint16_t )6787,      (uint16_t )6796,      (uint16_t )6802,      (uint16_t )6813, 
        (uint16_t )6819,      (uint16_t )6828,      (uint16_t )6834,      (uint16_t )6857, 
        (uint16_t )6863,      (uint16_t )6872,      (uint16_t )6878,      (uint16_t )6889, 
        (uint16_t )6895,      (uint16_t )6904,      (uint16_t )6910,      (uint16_t )6930, 
        (uint16_t )6936,      (uint16_t )6945,      (uint16_t )6951,      (uint16_t )6962, 
        (uint16_t )6968,      (uint16_t )6977,      (uint16_t )6983,      (uint16_t )7008, 
        (uint16_t )7014,      (uint16_t )7023,      (uint16_t )7029,      (uint16_t )7040, 
        (uint16_t )7046,      (uint16_t )7055,      (uint16_t )7061,      (uint16_t )7081, 
        (uint16_t )7087,      (uint16_t )7096,      (uint16_t )7102,      (uint16_t )7113, 
        (uint16_t )7119,      (uint16_t )7128,      (uint16_t )7134,      (uint16_t )6392, 
        (uint16_t )6398,      (uint16_t )6407,      (uint16_t )6413,      (uint16_t )6424, 
        (uint16_t )6430,      (uint16_t )6439,      (uint16_t )6445,      (uint16_t )6465, 
        (uint16_t )6471,      (uint16_t )6480,      (uint16_t )6486,      (uint16_t )6497, 
        (uint16_t )6503,      (uint16_t )6512,      (uint16_t )6518,      (uint16_t )6543, 
        (uint16_t )6549,      (uint16_t )6558,      (uint16_t )6564,      (uint16_t )6575, 
        (uint16_t )6581,      (uint16_t )6590,      (uint16_t )6596,      (uint16_t )6616, 
        (uint16_t )6622,      (uint16_t )6631,      (uint16_t )6637,      (uint16_t )6648, 
        (uint16_t )6654,      (uint16_t )6663,      (uint16_t )6669,      (uint16_t )6692, 
        (uint16_t )6698,      (uint16_t )6707,      (uint16_t )6713,      (uint16_t )6724, 
        (uint16_t )6730,      (uint16_t )6739,      (uint16_t )6745,      (uint16_t )6765, 
        (uint16_t )6771,      (uint16_t )6780,      (uint16_t )6786,      (uint16_t )6797, 
        (uint16_t )6803,      (uint16_t )6812,      (uint16_t )6818,      (uint16_t )6843, 
        (uint16_t )6849,      (uint16_t )6858,      (uint16_t )6864,      (uint16_t )6875, 
        (uint16_t )6881,      (uint16_t )6890,      (uint16_t )6896,      (uint16_t )6916, 
        (uint16_t )6922,      (uint16_t )6931,      (uint16_t )6937,      (uint16_t )6948, 
        (uint16_t )6954,      (uint16_t )6963,      (uint16_t )6969,      (uint16_t )6833, 
        (uint16_t )6839,      (uint16_t )6848,      (uint16_t )6854,      (uint16_t )6865, 
        (uint16_t )6871,      (uint16_t )6880,      (uint16_t )6886,      (uint16_t )6906, 
        (uint16_t )6912,      (uint16_t )6921,      (uint16_t )6927,      (uint16_t )6938, 
        (uint16_t )6944,      (uint16_t )6953,      (uint16_t )6959,      (uint16_t )6984, 
        (uint16_t )6990,      (uint16_t )6999,      (uint16_t )7005,      (uint16_t )7016, 
        (uint16_t )7022,      (uint16_t )7031,      (uint16_t )7037,      (uint16_t )7057, 
        (uint16_t )7063,      (uint16_t )7072,      (uint16_t )7078,      (uint16_t )7089, 
        (uint16_t )7095,      (uint16_t )7104,      (uint16_t )7110,      (uint16_t )7133, 
        (uint16_t )7139,      (uint16_t )7148,      (uint16_t )7154,      (uint16_t )7165, 
        (uint16_t )7171,      (uint16_t )7180,      (uint16_t )7186,      (uint16_t )7206, 
        (uint16_t )7212,      (uint16_t )7221,      (uint16_t )7227,      (uint16_t )7238, 
        (uint16_t )7244,      (uint16_t )7253,      (uint16_t )7259,      (uint16_t )7284, 
        (uint16_t )7290,      (uint16_t )7299,      (uint16_t )7305,      (uint16_t )7316, 
        (uint16_t )7322,      (uint16_t )7331,      (uint16_t )7337,      (uint16_t )7357, 
        (uint16_t )7363,      (uint16_t )7372,      (uint16_t )7378,      (uint16_t )7389, 
        (uint16_t )7395,      (uint16_t )7404,      (uint16_t )7410,      (uint16_t )7205, 
        (uint16_t )7211,      (uint16_t )7220,      (uint16_t )7226,      (uint16_t )7237, 
        (uint16_t )7243,      (uint16_t )7252,      (uint16_t )7258,      (uint16_t )7278, 
        (uint16_t )7284,      (uint16_t )7293,      (uint16_t )7299,      (uint16_t )7310, 
        (uint16_t )7316,      (uint16_t )7325,      (uint16_t )7331,      (uint16_t )7356, 
        (uint16_t )7362,      (uint16_t )7371,      (uint16_t )7377,      (uint16_t )7388, 
        (uint16_t )7394,      (uint16_t )7403,      (uint16_t )7409,      (uint16_t )7429, 
        (uint16_t )7435,      (uint16_t )7444,      (uint16_t )7450,      (uint16_t )7461, 
        (uint16_t )7467,      (uint16_t )7476,      (uint16_t )7482,      (uint16_t )7505, 
        (uint16_t )7511,      (uint16_t )7520,      (uint16_t )7526,      (uint16_t )7537, 
        (uint16_t )7543,      (uint16_t )7552,      (uint16_t )7558,      (uint16_t )7578, 
        (uint16_t )7584,      (uint16_t )7593,      (uint16_t )7599,      (uint16_t )7610, 
        (uint16_t )7616,      (uint16_t )7625,      (uint16_t )7631,      (uint16_t )7656, 
        (uint16_t )7662,      (uint16_t )7671,      (uint16_t )7677,      (uint16_t )7688, 
        (uint16_t )7694,      (uint16_t )7703,      (uint16_t )7709,      (uint16_t )7729, 
        (uint16_t )7735,      (uint16_t )7744,      (uint16_t )7750,      (uint16_t )7761};
#line 337 "/root/patchweave_new/13/src/enc/cost.c"
static int VariableLevelCost(int level , uint8_t *probas ) 
{ 
  int pattern ;
  int bits ;
  int cost ;
  int i ;
  int __cil_tmp7 ;

  {
#line 338
  pattern = (int )VP8LevelCodes[level - 1][0];
#line 339
  bits = (int )VP8LevelCodes[level - 1][1];
#line 340
  cost = 0;
#line 342
  i = 2;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;

#line 342
    if (! pattern) {
#line 342
      goto while_break;
    }
#line 343
    if (pattern & 1) {
      {
#line 344
      __cil_tmp7 = VP8BitCost(bits & 1, *(probas + i));
#line 344
      cost += __cil_tmp7;
      }
    }
#line 346
    bits >>= 1;
#line 347
    pattern >>= 1;
#line 342
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 349
  return (cost);
}
}
#line 355 "/root/patchweave_new/13/src/enc/cost.c"
void VP8CalculateLevelCosts(VP8Proba *proba ) 
{ 
  int ctype ;
  int band ;
  int ctx ;
  uint8_t *p ;
  uint16_t *table ;
  int cost_base ;
  int __cil_tmp8 ;
  int v ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 358
  if (! proba->dirty_) {
#line 358
    return;
  }
#line 360
  ctype = 0;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;

#line 360
    if (! (ctype < 4)) {
#line 360
      goto while_break;
    }
#line 361
    band = 0;
    {
#line 361
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 361
      if (! (band < 8)) {
#line 361
        goto while_break___0;
      }
#line 362
      ctx = 0;
      {
#line 362
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 362
        if (! (ctx < 3)) {
#line 362
          goto while_break___1;
        }
        {
#line 363
        p = proba->coeffs_[ctype][band][ctx];
#line 364
        table = proba->level_cost_[ctype][band][ctx];
#line 365
        __cil_tmp8 = VP8BitCost(1, *(p + 1));
#line 365
        cost_base = __cil_tmp8;
#line 367
        __cil_tmp10 = VP8BitCost(0, *(p + 1));
#line 367
        *(table + 0) = (uint16_t )__cil_tmp10;
#line 368
        v = 1;
        }
        {
#line 368
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 368
          if (! (v <= 67)) {
#line 368
            goto while_break___2;
          }
          {
#line 369
          __cil_tmp11 = VariableLevelCost(v, (uint8_t *)p);
#line 369
          *(table + v) = (uint16_t )(cost_base + __cil_tmp11);
#line 368
          v ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 362
        ctx ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 361
      band ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 360
    ctype ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 376
  proba->dirty_ = 0;
#line 377
  return;
}
}
#line 384 "/root/patchweave_new/13/src/enc/cost.c"
uint16_t VP8FixedCostsUV[4]  = {      (uint16_t )302,      (uint16_t )984,      (uint16_t )439,      (uint16_t )642};
#line 386 "/root/patchweave_new/13/src/enc/cost.c"
uint16_t VP8FixedCostsI16[4]  = {      (uint16_t )663,      (uint16_t )919,      (uint16_t )872,      (uint16_t )919};
#line 387 "/root/patchweave_new/13/src/enc/cost.c"
uint16_t VP8FixedCostsI4[10][10][10]  = 
#line 387
  { { {          (uint16_t )251,          (uint16_t )1362,          (uint16_t )1934,          (uint16_t )2085, 
                (uint16_t )2314,          (uint16_t )2230,          (uint16_t )1839,          (uint16_t )1988, 
                (uint16_t )2437,          (uint16_t )2348}, 
     {          (uint16_t )403,          (uint16_t )680,          (uint16_t )1507,          (uint16_t )1519, 
                (uint16_t )2060,          (uint16_t )2005,          (uint16_t )1992,          (uint16_t )1914, 
                (uint16_t )1924,          (uint16_t )1733}, 
     {          (uint16_t )353,          (uint16_t )1121,          (uint16_t )973,          (uint16_t )1895, 
                (uint16_t )2060,          (uint16_t )1787,          (uint16_t )1671,          (uint16_t )1516, 
                (uint16_t )2012,          (uint16_t )1868}, 
     {          (uint16_t )770,          (uint16_t )852,          (uint16_t )1581,          (uint16_t )632, 
                (uint16_t )1393,          (uint16_t )1780,          (uint16_t )1823,          (uint16_t )1936, 
                (uint16_t )1074,          (uint16_t )1218}, 
     {          (uint16_t )510,          (uint16_t )1270,          (uint16_t )1467,          (uint16_t )1319, 
                (uint16_t )847,          (uint16_t )1279,          (uint16_t )1792,          (uint16_t )2094, 
                (uint16_t )1080,          (uint16_t )1353}, 
     {          (uint16_t )488,          (uint16_t )1322,          (uint16_t )918,          (uint16_t )1573, 
                (uint16_t )1300,          (uint16_t )883,          (uint16_t )1814,          (uint16_t )1752, 
                (uint16_t )1756,          (uint16_t )1502}, 
     {          (uint16_t )425,          (uint16_t )992,          (uint16_t )1820,          (uint16_t )1514, 
                (uint16_t )1843,          (uint16_t )2440,          (uint16_t )937,          (uint16_t )1771, 
                (uint16_t )1924,          (uint16_t )1129}, 
     {          (uint16_t )363,          (uint16_t )1248,          (uint16_t )1257,          (uint16_t )1970, 
                (uint16_t )2194,          (uint16_t )2385,          (uint16_t )1569,          (uint16_t )953, 
                (uint16_t )1951,          (uint16_t )1601}, 
     {          (uint16_t )723,          (uint16_t )1257,          (uint16_t )1631,          (uint16_t )964, 
                (uint16_t )963,          (uint16_t )1508,          (uint16_t )1697,          (uint16_t )1824, 
                (uint16_t )671,          (uint16_t )1418}, 
     {          (uint16_t )635,          (uint16_t )1038,          (uint16_t )1573,          (uint16_t )930, 
                (uint16_t )1673,          (uint16_t )1413,          (uint16_t )1410,          (uint16_t )1687, 
                (uint16_t )1410,          (uint16_t )749}}, 
   { {          (uint16_t )451,          (uint16_t )613,          (uint16_t )1345,          (uint16_t )1702, 
                (uint16_t )1870,          (uint16_t )1716,          (uint16_t )1728,          (uint16_t )1766, 
                (uint16_t )2190,          (uint16_t )2310}, 
     {          (uint16_t )678,          (uint16_t )453,          (uint16_t )1171,          (uint16_t )1443, 
                (uint16_t )1925,          (uint16_t )1831,          (uint16_t )2045,          (uint16_t )1781, 
                (uint16_t )1887,          (uint16_t )1602}, 
     {          (uint16_t )711,          (uint16_t )666,          (uint16_t )674,          (uint16_t )1718, 
                (uint16_t )1910,          (uint16_t )1493,          (uint16_t )1775,          (uint16_t )1193, 
                (uint16_t )2325,          (uint16_t )2325}, 
     {          (uint16_t )883,          (uint16_t )854,          (uint16_t )1583,          (uint16_t )542, 
                (uint16_t )1800,          (uint16_t )1878,          (uint16_t )1664,          (uint16_t )2149, 
                (uint16_t )1207,          (uint16_t )1087}, 
     {          (uint16_t )669,          (uint16_t )994,          (uint16_t )1248,          (uint16_t )1122, 
                (uint16_t )949,          (uint16_t )1179,          (uint16_t )1376,          (uint16_t )1729, 
                (uint16_t )1070,          (uint16_t )1244}, 
     {          (uint16_t )715,          (uint16_t )1026,          (uint16_t )715,          (uint16_t )1350, 
                (uint16_t )1430,          (uint16_t )930,          (uint16_t )1717,          (uint16_t )1296, 
                (uint16_t )1479,          (uint16_t )1479}, 
     {          (uint16_t )544,          (uint16_t )841,          (uint16_t )1656,          (uint16_t )1450, 
                (uint16_t )2094,          (uint16_t )3883,          (uint16_t )1010,          (uint16_t )1759, 
                (uint16_t )2076,          (uint16_t )809}, 
     {          (uint16_t )610,          (uint16_t )855,          (uint16_t )957,          (uint16_t )1553, 
                (uint16_t )2067,          (uint16_t )1561,          (uint16_t )1704,          (uint16_t )824, 
                (uint16_t )2066,          (uint16_t )1226}, 
     {          (uint16_t )833,          (uint16_t )960,          (uint16_t )1416,          (uint16_t )819, 
                (uint16_t )1277,          (uint16_t )1619,          (uint16_t )1501,          (uint16_t )1617, 
                (uint16_t )757,          (uint16_t )1182}, 
     {          (uint16_t )711,          (uint16_t )964,          (uint16_t )1252,          (uint16_t )879, 
                (uint16_t )1441,          (uint16_t )1828,          (uint16_t )1508,          (uint16_t )1636, 
                (uint16_t )1594,          (uint16_t )734}}, 
   { {          (uint16_t )605,          (uint16_t )764,          (uint16_t )734,          (uint16_t )1713, 
                (uint16_t )1747,          (uint16_t )1192,          (uint16_t )1819,          (uint16_t )1353, 
                (uint16_t )1877,          (uint16_t )2392}, 
     {          (uint16_t )866,          (uint16_t )641,          (uint16_t )586,          (uint16_t )1622, 
                (uint16_t )2072,          (uint16_t )1431,          (uint16_t )1888,          (uint16_t )1346, 
                (uint16_t )2189,          (uint16_t )1764}, 
     {          (uint16_t )901,          (uint16_t )851,          (uint16_t )456,          (uint16_t )2165, 
                (uint16_t )2281,          (uint16_t )1405,          (uint16_t )1739,          (uint16_t )1193, 
                (uint16_t )2183,          (uint16_t )2443}, 
     {          (uint16_t )770,          (uint16_t )1045,          (uint16_t )952,          (uint16_t )1078, 
                (uint16_t )1342,          (uint16_t )1191,          (uint16_t )1436,          (uint16_t )1063, 
                (uint16_t )1303,          (uint16_t )995}, 
     {          (uint16_t )901,          (uint16_t )1086,          (uint16_t )727,          (uint16_t )1170, 
                (uint16_t )884,          (uint16_t )1105,          (uint16_t )1267,          (uint16_t )1401, 
                (uint16_t )1739,          (uint16_t )1337}, 
     {          (uint16_t )951,          (uint16_t )1162,          (uint16_t )595,          (uint16_t )1488, 
                (uint16_t )1388,          (uint16_t )703,          (uint16_t )1790,          (uint16_t )1366, 
                (uint16_t )2057,          (uint16_t )1724}, 
     {          (uint16_t )534,          (uint16_t )986,          (uint16_t )1273,          (uint16_t )1987, 
                (uint16_t )3273,          (uint16_t )1485,          (uint16_t )1024,          (uint16_t )1399, 
                (uint16_t )1583,          (uint16_t )866}, 
     {          (uint16_t )699,          (uint16_t )1182,          (uint16_t )695,          (uint16_t )1978, 
                (uint16_t )1726,          (uint16_t )1986,          (uint16_t )1326,          (uint16_t )714, 
                (uint16_t )1750,          (uint16_t )1672}, 
     {          (uint16_t )951,          (uint16_t )1217,          (uint16_t )1209,          (uint16_t )920, 
                (uint16_t )1062,          (uint16_t )1441,          (uint16_t )1548,          (uint16_t )999, 
                (uint16_t )952,          (uint16_t )932}, 
     {          (uint16_t )733,          (uint16_t )1284,          (uint16_t )784,          (uint16_t )1256, 
                (uint16_t )1557,          (uint16_t )1098,          (uint16_t )1257,          (uint16_t )1357, 
                (uint16_t )1414,          (uint16_t )908}}, 
   { {          (uint16_t )316,          (uint16_t )1075,          (uint16_t )1653,          (uint16_t )1220, 
                (uint16_t )2145,          (uint16_t )2051,          (uint16_t )1730,          (uint16_t )2131, 
                (uint16_t )1884,          (uint16_t )1790}, 
     {          (uint16_t )745,          (uint16_t )516,          (uint16_t )1404,          (uint16_t )894, 
                (uint16_t )1599,          (uint16_t )2375,          (uint16_t )2013,          (uint16_t )2105, 
                (uint16_t )1475,          (uint16_t )1381}, 
     {          (uint16_t )516,          (uint16_t )729,          (uint16_t )1088,          (uint16_t )1319, 
                (uint16_t )1637,          (uint16_t )3426,          (uint16_t )1636,          (uint16_t )1275, 
                (uint16_t )1531,          (uint16_t )1453}, 
     {          (uint16_t )894,          (uint16_t )943,          (uint16_t )2138,          (uint16_t )468, 
                (uint16_t )1704,          (uint16_t )2259,          (uint16_t )2069,          (uint16_t )1763, 
                (uint16_t )1266,          (uint16_t )1158}, 
     {          (uint16_t )605,          (uint16_t )1025,          (uint16_t )1235,          (uint16_t )871, 
                (uint16_t )1170,          (uint16_t )1767,          (uint16_t )1493,          (uint16_t )1500, 
                (uint16_t )1104,          (uint16_t )1258}, 
     {          (uint16_t )739,          (uint16_t )826,          (uint16_t )1207,          (uint16_t )1151, 
                (uint16_t )1412,          (uint16_t )846,          (uint16_t )1305,          (uint16_t )2726, 
                (uint16_t )1014,          (uint16_t )1569}, 
     {          (uint16_t )558,          (uint16_t )825,          (uint16_t )1820,          (uint16_t )1398, 
                (uint16_t )3344,          (uint16_t )1556,          (uint16_t )1218,          (uint16_t )1550, 
                (uint16_t )1228,          (uint16_t )878}, 
     {          (uint16_t )429,          (uint16_t )951,          (uint16_t )1089,          (uint16_t )1816, 
                (uint16_t )3861,          (uint16_t )3861,          (uint16_t )1556,          (uint16_t )969, 
                (uint16_t )1568,          (uint16_t )1828}, 
     {          (uint16_t )883,          (uint16_t )961,          (uint16_t )1752,          (uint16_t )769, 
                (uint16_t )1468,          (uint16_t )1810,          (uint16_t )2081,          (uint16_t )2346, 
                (uint16_t )613,          (uint16_t )1298}, 
     {          (uint16_t )803,          (uint16_t )895,          (uint16_t )1372,          (uint16_t )641, 
                (uint16_t )1303,          (uint16_t )1708,          (uint16_t )1686,          (uint16_t )1700, 
                (uint16_t )1306,          (uint16_t )1033}}, 
   { {          (uint16_t )439,          (uint16_t )1267,          (uint16_t )1270,          (uint16_t )1579, 
                (uint16_t )963,          (uint16_t )1193,          (uint16_t )1723,          (uint16_t )1729, 
                (uint16_t )1198,          (uint16_t )1993}, 
     {          (uint16_t )705,          (uint16_t )725,          (uint16_t )1029,          (uint16_t )1153, 
                (uint16_t )1176,          (uint16_t )1103,          (uint16_t )1821,          (uint16_t )1567, 
                (uint16_t )1259,          (uint16_t )1574}, 
     {          (uint16_t )723,          (uint16_t )859,          (uint16_t )802,          (uint16_t )1253, 
                (uint16_t )972,          (uint16_t )1202,          (uint16_t )1407,          (uint16_t )1665, 
                (uint16_t )1520,          (uint16_t )1674}, 
     {          (uint16_t )894,          (uint16_t )960,          (uint16_t )1254,          (uint16_t )887, 
                (uint16_t )1052,          (uint16_t )1607,          (uint16_t )1344,          (uint16_t )1349, 
                (uint16_t )865,          (uint16_t )1150}, 
     {          (uint16_t )833,          (uint16_t )1312,          (uint16_t )1337,          (uint16_t )1205, 
                (uint16_t )572,          (uint16_t )1288,          (uint16_t )1414,          (uint16_t )1529, 
                (uint16_t )1088,          (uint16_t )1430}, 
     {          (uint16_t )842,          (uint16_t )1279,          (uint16_t )1068,          (uint16_t )1861, 
                (uint16_t )862,          (uint16_t )688,          (uint16_t )1861,          (uint16_t )1630, 
                (uint16_t )1039,          (uint16_t )1381}, 
     {          (uint16_t )766,          (uint16_t )938,          (uint16_t )1279,          (uint16_t )1546, 
                (uint16_t )3338,          (uint16_t )1550,          (uint16_t )1031,          (uint16_t )1542, 
                (uint16_t )1288,          (uint16_t )640}, 
     {          (uint16_t )715,          (uint16_t )1090,          (uint16_t )835,          (uint16_t )1609, 
                (uint16_t )1100,          (uint16_t )1100,          (uint16_t )1603,          (uint16_t )1019, 
                (uint16_t )1102,          (uint16_t )1617}, 
     {          (uint16_t )894,          (uint16_t )1813,          (uint16_t )1500,          (uint16_t )1188, 
                (uint16_t )789,          (uint16_t )1194,          (uint16_t )1491,          (uint16_t )1919, 
                (uint16_t )617,          (uint16_t )1333}, 
     {          (uint16_t )610,          (uint16_t )1076,          (uint16_t )1644,          (uint16_t )1281, 
                (uint16_t )1283,          (uint16_t )975,          (uint16_t )1179,          (uint16_t )1688, 
                (uint16_t )1434,          (uint16_t )889}}, 
   { {          (uint16_t )544,          (uint16_t )971,          (uint16_t )1146,          (uint16_t )1849, 
                (uint16_t )1221,          (uint16_t )740,          (uint16_t )1857,          (uint16_t )1621, 
                (uint16_t )1683,          (uint16_t )2430}, 
     {          (uint16_t )723,          (uint16_t )705,          (uint16_t )961,          (uint16_t )1371, 
                (uint16_t )1426,          (uint16_t )821,          (uint16_t )2081,          (uint16_t )2079, 
                (uint16_t )1839,          (uint16_t )1380}, 
     {          (uint16_t )783,          (uint16_t )857,          (uint16_t )703,          (uint16_t )2145, 
                (uint16_t )1419,          (uint16_t )814,          (uint16_t )1791,          (uint16_t )1310, 
                (uint16_t )1609,          (uint16_t )2206}, 
     {          (uint16_t )997,          (uint16_t )1000,          (uint16_t )1153,          (uint16_t )792, 
                (uint16_t )1229,          (uint16_t )1162,          (uint16_t )1810,          (uint16_t )1418, 
                (uint16_t )942,          (uint16_t )979}, 
     {          (uint16_t )901,          (uint16_t )1226,          (uint16_t )883,          (uint16_t )1289, 
                (uint16_t )793,          (uint16_t )715,          (uint16_t )1904,          (uint16_t )1649, 
                (uint16_t )1319,          (uint16_t )3108}, 
     {          (uint16_t )979,          (uint16_t )1478,          (uint16_t )782,          (uint16_t )2216, 
                (uint16_t )1454,          (uint16_t )455,          (uint16_t )3092,          (uint16_t )1591, 
                (uint16_t )1997,          (uint16_t )1664}, 
     {          (uint16_t )663,          (uint16_t )1110,          (uint16_t )1504,          (uint16_t )1114, 
                (uint16_t )1522,          (uint16_t )3311,          (uint16_t )676,          (uint16_t )1522, 
                (uint16_t )1530,          (uint16_t )1024}, 
     {          (uint16_t )605,          (uint16_t )1138,          (uint16_t )1153,          (uint16_t )1314, 
                (uint16_t )1569,          (uint16_t )1315,          (uint16_t )1157,          (uint16_t )804, 
                (uint16_t )1574,          (uint16_t )1320}, 
     {          (uint16_t )770,          (uint16_t )1216,          (uint16_t )1218,          (uint16_t )1227, 
                (uint16_t )869,          (uint16_t )1384,          (uint16_t )1232,          (uint16_t )1375, 
                (uint16_t )834,          (uint16_t )1239}, 
     {          (uint16_t )775,          (uint16_t )1007,          (uint16_t )843,          (uint16_t )1216, 
                (uint16_t )1225,          (uint16_t )1074,          (uint16_t )2527,          (uint16_t )1479, 
                (uint16_t )1149,          (uint16_t )975}}, 
   { {          (uint16_t )477,          (uint16_t )817,          (uint16_t )1309,          (uint16_t )1439, 
                (uint16_t )1708,          (uint16_t )1454,          (uint16_t )1159,          (uint16_t )1241, 
                (uint16_t )1945,          (uint16_t )1672}, 
     {          (uint16_t )577,          (uint16_t )796,          (uint16_t )1112,          (uint16_t )1271, 
                (uint16_t )1618,          (uint16_t )1458,          (uint16_t )1087,          (uint16_t )1345, 
                (uint16_t )1831,          (uint16_t )1265}, 
     {          (uint16_t )663,          (uint16_t )776,          (uint16_t )753,          (uint16_t )1940, 
                (uint16_t )1690,          (uint16_t )1690,          (uint16_t )1227,          (uint16_t )1097, 
                (uint16_t )3149,          (uint16_t )1361}, 
     {          (uint16_t )766,          (uint16_t )1299,          (uint16_t )1744,          (uint16_t )1161, 
                (uint16_t )1565,          (uint16_t )1106,          (uint16_t )1045,          (uint16_t )1230, 
                (uint16_t )1232,          (uint16_t )707}, 
     {          (uint16_t )915,          (uint16_t )1026,          (uint16_t )1404,          (uint16_t )1182, 
                (uint16_t )1184,          (uint16_t )851,          (uint16_t )1428,          (uint16_t )2425, 
                (uint16_t )1043,          (uint16_t )789}, 
     {          (uint16_t )883,          (uint16_t )1456,          (uint16_t )790,          (uint16_t )1082, 
                (uint16_t )1086,          (uint16_t )985,          (uint16_t )1083,          (uint16_t )1484, 
                (uint16_t )1238,          (uint16_t )1160}, 
     {          (uint16_t )507,          (uint16_t )1345,          (uint16_t )2261,          (uint16_t )1995, 
                (uint16_t )1847,          (uint16_t )3636,          (uint16_t )653,          (uint16_t )1761, 
                (uint16_t )2287,          (uint16_t )933}, 
     {          (uint16_t )553,          (uint16_t )1193,          (uint16_t )1470,          (uint16_t )2057, 
                (uint16_t )2059,          (uint16_t )2059,          (uint16_t )833,          (uint16_t )779, 
                (uint16_t )2058,          (uint16_t )1263}, 
     {          (uint16_t )766,          (uint16_t )1275,          (uint16_t )1515,          (uint16_t )1039, 
                (uint16_t )957,          (uint16_t )1554,          (uint16_t )1286,          (uint16_t )1540, 
                (uint16_t )1289,          (uint16_t )705}, 
     {          (uint16_t )499,          (uint16_t )1378,          (uint16_t )1496,          (uint16_t )1385, 
                (uint16_t )1850,          (uint16_t )1850,          (uint16_t )1044,          (uint16_t )2465, 
                (uint16_t )1515,          (uint16_t )720}}, 
   { {          (uint16_t )553,          (uint16_t )930,          (uint16_t )978,          (uint16_t )2077, 
                (uint16_t )1968,          (uint16_t )1481,          (uint16_t )1457,          (uint16_t )761, 
                (uint16_t )1957,          (uint16_t )2362}, 
     {          (uint16_t )694,          (uint16_t )864,          (uint16_t )905,          (uint16_t )1720, 
                (uint16_t )1670,          (uint16_t )1621,          (uint16_t )1429,          (uint16_t )718, 
                (uint16_t )2125,          (uint16_t )1477}, 
     {          (uint16_t )699,          (uint16_t )968,          (uint16_t )658,          (uint16_t )3190, 
                (uint16_t )2024,          (uint16_t )1479,          (uint16_t )1865,          (uint16_t )750, 
                (uint16_t )2060,          (uint16_t )2320}, 
     {          (uint16_t )733,          (uint16_t )1308,          (uint16_t )1296,          (uint16_t )1062, 
                (uint16_t )1576,          (uint16_t )1322,          (uint16_t )1062,          (uint16_t )1112, 
                (uint16_t )1172,          (uint16_t )816}, 
     {          (uint16_t )920,          (uint16_t )927,          (uint16_t )1052,          (uint16_t )939, 
                (uint16_t )947,          (uint16_t )1156,          (uint16_t )1152,          (uint16_t )1073, 
                (uint16_t )3056,          (uint16_t )1268}, 
     {          (uint16_t )723,          (uint16_t )1534,          (uint16_t )711,          (uint16_t )1547, 
                (uint16_t )1294,          (uint16_t )892,          (uint16_t )1553,          (uint16_t )928, 
                (uint16_t )1815,          (uint16_t )1561}, 
     {          (uint16_t )663,          (uint16_t )1366,          (uint16_t )1583,          (uint16_t )2111, 
                (uint16_t )1712,          (uint16_t )3501,          (uint16_t )522,          (uint16_t )1155, 
                (uint16_t )2130,          (uint16_t )1133}, 
     {          (uint16_t )614,          (uint16_t )1731,          (uint16_t )1188,          (uint16_t )2343, 
                (uint16_t )1944,          (uint16_t )3733,          (uint16_t )1287,          (uint16_t )487, 
                (uint16_t )3546,          (uint16_t )1758}, 
     {          (uint16_t )770,          (uint16_t )1585,          (uint16_t )1312,          (uint16_t )826, 
                (uint16_t )884,          (uint16_t )2673,          (uint16_t )1185,          (uint16_t )1006, 
                (uint16_t )1195,          (uint16_t )1195}, 
     {          (uint16_t )758,          (uint16_t )1333,          (uint16_t )1273,          (uint16_t )1023, 
                (uint16_t )1621,          (uint16_t )1162,          (uint16_t )1351,          (uint16_t )833, 
                (uint16_t )1479,          (uint16_t )862}}, 
   { {          (uint16_t )376,          (uint16_t )1193,          (uint16_t )1446,          (uint16_t )1149, 
                (uint16_t )1545,          (uint16_t )1577,          (uint16_t )1870,          (uint16_t )1789, 
                (uint16_t )1175,          (uint16_t )1823}, 
     {          (uint16_t )803,          (uint16_t )633,          (uint16_t )1136,          (uint16_t )1058, 
                (uint16_t )1350,          (uint16_t )1323,          (uint16_t )1598,          (uint16_t )2247, 
                (uint16_t )1072,          (uint16_t )1252}, 
     {          (uint16_t )614,          (uint16_t )1048,          (uint16_t )943,          (uint16_t )981, 
                (uint16_t )1152,          (uint16_t )1869,          (uint16_t )1461,          (uint16_t )1020, 
                (uint16_t )1618,          (uint16_t )1618}, 
     {          (uint16_t )1107,          (uint16_t )1085,          (uint16_t )1282,          (uint16_t )592, 
                (uint16_t )1779,          (uint16_t )1933,          (uint16_t )1648,          (uint16_t )2403, 
                (uint16_t )691,          (uint16_t )1246}, 
     {          (uint16_t )851,          (uint16_t )1309,          (uint16_t )1223,          (uint16_t )1243, 
                (uint16_t )895,          (uint16_t )1593,          (uint16_t )1792,          (uint16_t )2317, 
                (uint16_t )627,          (uint16_t )1076}, 
     {          (uint16_t )770,          (uint16_t )1216,          (uint16_t )1030,          (uint16_t )1125, 
                (uint16_t )921,          (uint16_t )981,          (uint16_t )1629,          (uint16_t )1131, 
                (uint16_t )1049,          (uint16_t )1646}, 
     {          (uint16_t )626,          (uint16_t )1469,          (uint16_t )1456,          (uint16_t )1081, 
                (uint16_t )1489,          (uint16_t )3278,          (uint16_t )981,          (uint16_t )1232, 
                (uint16_t )1498,          (uint16_t )733}, 
     {          (uint16_t )617,          (uint16_t )1201,          (uint16_t )812,          (uint16_t )1220, 
                (uint16_t )1476,          (uint16_t )1476,          (uint16_t )1478,          (uint16_t )970, 
                (uint16_t )1228,          (uint16_t )1488}, 
     {          (uint16_t )1179,          (uint16_t )1393,          (uint16_t )1540,          (uint16_t )999, 
                (uint16_t )1243,          (uint16_t )1503,          (uint16_t )1916,          (uint16_t )1925, 
                (uint16_t )414,          (uint16_t )1614}, 
     {          (uint16_t )943,          (uint16_t )1088,          (uint16_t )1490,          (uint16_t )682, 
                (uint16_t )1112,          (uint16_t )1372,          (uint16_t )1756,          (uint16_t )1505, 
                (uint16_t )966,          (uint16_t )966}}, 
   { {          (uint16_t )322,          (uint16_t )1142,          (uint16_t )1589,          (uint16_t )1396, 
                (uint16_t )2144,          (uint16_t )1859,          (uint16_t )1359,          (uint16_t )1925, 
                (uint16_t )2084,          (uint16_t )1518}, 
     {          (uint16_t )617,          (uint16_t )625,          (uint16_t )1241,          (uint16_t )1234, 
                (uint16_t )2121,          (uint16_t )1615,          (uint16_t )1524,          (uint16_t )1858, 
                (uint16_t )1720,          (uint16_t )1004}, 
     {          (uint16_t )553,          (uint16_t )851,          (uint16_t )786,          (uint16_t )1299, 
                (uint16_t )1452,          (uint16_t )1560,          (uint16_t )1372,          (uint16_t )1561, 
                (uint16_t )1967,          (uint16_t )1713}, 
     {          (uint16_t )770,          (uint16_t )977,          (uint16_t )1396,          (uint16_t )568, 
                (uint16_t )1893,          (uint16_t )1639,          (uint16_t )1540,          (uint16_t )2108, 
                (uint16_t )1430,          (uint16_t )1013}, 
     {          (uint16_t )684,          (uint16_t )1120,          (uint16_t )1375,          (uint16_t )982, 
                (uint16_t )930,          (uint16_t )2719,          (uint16_t )1638,          (uint16_t )1643, 
                (uint16_t )933,          (uint16_t )993}, 
     {          (uint16_t )553,          (uint16_t )1103,          (uint16_t )996,          (uint16_t )1356, 
                (uint16_t )1361,          (uint16_t )1005,          (uint16_t )1507,          (uint16_t )1761, 
                (uint16_t )1184,          (uint16_t )1268}, 
     {          (uint16_t )419,          (uint16_t )1247,          (uint16_t )1537,          (uint16_t )1554, 
                (uint16_t )1817,          (uint16_t )3606,          (uint16_t )1026,          (uint16_t )1666, 
                (uint16_t )1829,          (uint16_t )923}, 
     {          (uint16_t )439,          (uint16_t )1139,          (uint16_t )1101,          (uint16_t )1257, 
                (uint16_t )3710,          (uint16_t )1922,          (uint16_t )1205,          (uint16_t )1040, 
                (uint16_t )1931,          (uint16_t )1529}, 
     {          (uint16_t )979,          (uint16_t )935,          (uint16_t )1269,          (uint16_t )847, 
                (uint16_t )1202,          (uint16_t )1286,          (uint16_t )1530,          (uint16_t )1535, 
                (uint16_t )827,          (uint16_t )1036}, 
     {          (uint16_t )516,          (uint16_t )1378,          (uint16_t )1569,          (uint16_t )1110, 
                (uint16_t )1798,          (uint16_t )1798,          (uint16_t )1198,          (uint16_t )2199, 
                (uint16_t )1543,          (uint16_t )712}}};
#line 22 "/root/patchweave_new/13/src/enc/config.c"
int WebPConfigInitInternal(WebPConfig *config , enum WebPPreset preset , float quality ,
                           int version ) 
{ 
  int __cil_tmp5 ;

  {
#line 24
  if (version >> 8 != 513 >> 8) {
#line 25
    return (0);
  }
#line 27
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 27
    return (0);
  }
#line 29
  config->quality = quality;
#line 30
  config->target_size = 0;
#line 31
  config->target_PSNR = (float )0.;
#line 32
  config->method = 4;
#line 33
  config->sns_strength = 50;
#line 34
  config->filter_strength = 60;
#line 35
  config->filter_sharpness = 0;
#line 36
  config->filter_type = 1;
#line 37
  config->partitions = 0;
#line 38
  config->segments = 4;
#line 39
  config->pass = 1;
#line 40
  config->show_compressed = 0;
#line 41
  config->preprocessing = 0;
#line 42
  config->autofilter = 0;
#line 43
  config->partition_limit = 0;
#line 44
  config->alpha_compression = 1;
#line 45
  config->alpha_filtering = 1;
#line 46
  config->alpha_quality = 100;
#line 47
  config->lossless = 0;
#line 48
  config->image_hint = (enum WebPImageHint___0 )((enum WebPImageHint )0);
#line 49
  config->emulate_jpeg_size = 0;
#line 50
  config->thread_level = 0;
#line 51
  config->low_memory = 0;
#line 55
  if ((unsigned int )preset == 1U) {
#line 55
    goto case_1;
  }
#line 60
  if ((unsigned int )preset == 2U) {
#line 60
    goto case_2;
  }
#line 65
  if ((unsigned int )preset == 3U) {
#line 65
    goto case_3;
  }
#line 70
  if ((unsigned int )preset == 4U) {
#line 70
    goto case_4;
  }
#line 74
  if ((unsigned int )preset == 5U) {
#line 74
    goto case_5;
  }
#line 80
  goto switch_default;
  case_1: 
#line 56
  config->sns_strength = 80;
#line 57
  config->filter_sharpness = 4;
#line 58
  config->filter_strength = 35;
#line 59
  goto switch_break;
  case_2: 
#line 61
  config->sns_strength = 80;
#line 62
  config->filter_sharpness = 3;
#line 63
  config->filter_strength = 30;
#line 64
  goto switch_break;
  case_3: 
#line 66
  config->sns_strength = 25;
#line 67
  config->filter_sharpness = 6;
#line 68
  config->filter_strength = 10;
#line 69
  goto switch_break;
  case_4: 
#line 71
  config->sns_strength = 0;
#line 72
  config->filter_strength = 0;
#line 73
  goto switch_break;
  case_5: 
#line 75
  config->sns_strength = 0;
#line 76
  config->filter_strength = 0;
#line 77
  config->segments = 2;
#line 78
  goto switch_break;
  switch_default: 
#line 81
  goto switch_break;
  switch_break: 
  {
#line 83
  __cil_tmp5 = WebPValidateConfig(config);
  }
#line 83
  return (__cil_tmp5);
}
}
#line 86 "/root/patchweave_new/13/src/enc/config.c"
int WebPValidateConfig(WebPConfig *config ) 
{ 


  {
#line 87
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 87
    return (0);
  }
#line 88
  if (config->quality < (float )0) {
#line 89
    return (0);
  } else
#line 88
  if (config->quality > (float )100) {
#line 89
    return (0);
  }
#line 90
  if (config->target_size < 0) {
#line 91
    return (0);
  }
#line 92
  if (config->target_PSNR < (float )0) {
#line 93
    return (0);
  }
#line 94
  if (config->method < 0) {
#line 95
    return (0);
  } else
#line 94
  if (config->method > 6) {
#line 95
    return (0);
  }
#line 96
  if (config->segments < 1) {
#line 97
    return (0);
  } else
#line 96
  if (config->segments > 4) {
#line 97
    return (0);
  }
#line 98
  if (config->sns_strength < 0) {
#line 99
    return (0);
  } else
#line 98
  if (config->sns_strength > 100) {
#line 99
    return (0);
  }
#line 100
  if (config->filter_strength < 0) {
#line 101
    return (0);
  } else
#line 100
  if (config->filter_strength > 100) {
#line 101
    return (0);
  }
#line 102
  if (config->filter_sharpness < 0) {
#line 103
    return (0);
  } else
#line 102
  if (config->filter_sharpness > 7) {
#line 103
    return (0);
  }
#line 104
  if (config->filter_type < 0) {
#line 105
    return (0);
  } else
#line 104
  if (config->filter_type > 1) {
#line 105
    return (0);
  }
#line 106
  if (config->autofilter < 0) {
#line 107
    return (0);
  } else
#line 106
  if (config->autofilter > 1) {
#line 107
    return (0);
  }
#line 108
  if (config->pass < 1) {
#line 109
    return (0);
  } else
#line 108
  if (config->pass > 10) {
#line 109
    return (0);
  }
#line 110
  if (config->show_compressed < 0) {
#line 111
    return (0);
  } else
#line 110
  if (config->show_compressed > 1) {
#line 111
    return (0);
  }
#line 112
  if (config->preprocessing < 0) {
#line 113
    return (0);
  } else
#line 112
  if (config->preprocessing > 1) {
#line 113
    return (0);
  }
#line 114
  if (config->partitions < 0) {
#line 115
    return (0);
  } else
#line 114
  if (config->partitions > 3) {
#line 115
    return (0);
  }
#line 116
  if (config->partition_limit < 0) {
#line 117
    return (0);
  } else
#line 116
  if (config->partition_limit > 100) {
#line 117
    return (0);
  }
#line 118
  if (config->alpha_compression < 0) {
#line 119
    return (0);
  }
#line 120
  if (config->alpha_filtering < 0) {
#line 121
    return (0);
  }
#line 122
  if (config->alpha_quality < 0) {
#line 123
    return (0);
  } else
#line 122
  if (config->alpha_quality > 100) {
#line 123
    return (0);
  }
#line 124
  if (config->lossless < 0) {
#line 125
    return (0);
  } else
#line 124
  if (config->lossless > 1) {
#line 125
    return (0);
  }
#line 126
  if ((unsigned int )config->image_hint >= 4U) {
#line 127
    return (0);
  }
#line 128
  if (config->emulate_jpeg_size < 0) {
#line 129
    return (0);
  } else
#line 128
  if (config->emulate_jpeg_size > 1) {
#line 129
    return (0);
  }
#line 130
  if (config->thread_level < 0) {
#line 131
    return (0);
  } else
#line 130
  if (config->thread_level > 1) {
#line 131
    return (0);
  }
#line 132
  if (config->low_memory < 0) {
#line 133
    return (0);
  } else
#line 132
  if (config->low_memory > 1) {
#line 133
    return (0);
  }
#line 134
  return (1);
}
}
#line 28 "/root/patchweave_new/13/src/enc/../utils/color_cache.h"
static uint32_t kHashMul___0  =    (uint32_t )506832829;
#line 36 "/root/patchweave_new/13/src/enc/../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___0(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___0 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
#line 40
  return;
}
}
#line 42 "/root/patchweave_new/13/src/enc/../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___0(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___0 * argb >> cc->hash_shift_));
}
}
#line 47 "/root/patchweave_new/13/src/enc/../utils/color_cache.h"
__inline static int VP8LColorCacheContains___0(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___0 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 44 "/root/patchweave_new/13/src/enc/backward_references.c"
static uint8_t plane_to_code_lut[128]  = 
#line 44 "/root/patchweave_new/13/src/enc/backward_references.c"
  {      (uint8_t )96,      (uint8_t )73,      (uint8_t )55,      (uint8_t )39, 
        (uint8_t )23,      (uint8_t )13,      (uint8_t )5,      (uint8_t )1, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )101,      (uint8_t )78,      (uint8_t )58,      (uint8_t )42, 
        (uint8_t )26,      (uint8_t )16,      (uint8_t )8,      (uint8_t )2, 
        (uint8_t )0,      (uint8_t )3,      (uint8_t )9,      (uint8_t )17, 
        (uint8_t )27,      (uint8_t )43,      (uint8_t )59,      (uint8_t )79, 
        (uint8_t )102,      (uint8_t )86,      (uint8_t )62,      (uint8_t )46, 
        (uint8_t )32,      (uint8_t )20,      (uint8_t )10,      (uint8_t )6, 
        (uint8_t )4,      (uint8_t )7,      (uint8_t )11,      (uint8_t )21, 
        (uint8_t )33,      (uint8_t )47,      (uint8_t )63,      (uint8_t )87, 
        (uint8_t )105,      (uint8_t )90,      (uint8_t )70,      (uint8_t )52, 
        (uint8_t )37,      (uint8_t )28,      (uint8_t )18,      (uint8_t )14, 
        (uint8_t )12,      (uint8_t )15,      (uint8_t )19,      (uint8_t )29, 
        (uint8_t )38,      (uint8_t )53,      (uint8_t )71,      (uint8_t )91, 
        (uint8_t )110,      (uint8_t )99,      (uint8_t )82,      (uint8_t )66, 
        (uint8_t )48,      (uint8_t )35,      (uint8_t )30,      (uint8_t )24, 
        (uint8_t )22,      (uint8_t )25,      (uint8_t )31,      (uint8_t )36, 
        (uint8_t )49,      (uint8_t )67,      (uint8_t )83,      (uint8_t )100, 
        (uint8_t )115,      (uint8_t )108,      (uint8_t )94,      (uint8_t )76, 
        (uint8_t )64,      (uint8_t )50,      (uint8_t )44,      (uint8_t )40, 
        (uint8_t )34,      (uint8_t )41,      (uint8_t )45,      (uint8_t )51, 
        (uint8_t )65,      (uint8_t )77,      (uint8_t )95,      (uint8_t )109, 
        (uint8_t )118,      (uint8_t )113,      (uint8_t )103,      (uint8_t )92, 
        (uint8_t )80,      (uint8_t )68,      (uint8_t )60,      (uint8_t )56, 
        (uint8_t )54,      (uint8_t )57,      (uint8_t )61,      (uint8_t )69, 
        (uint8_t )81,      (uint8_t )93,      (uint8_t )104,      (uint8_t )114, 
        (uint8_t )119,      (uint8_t )116,      (uint8_t )111,      (uint8_t )106, 
        (uint8_t )97,      (uint8_t )88,      (uint8_t )84,      (uint8_t )74, 
        (uint8_t )72,      (uint8_t )75,      (uint8_t )85,      (uint8_t )89, 
        (uint8_t )98,      (uint8_t )107,      (uint8_t )112,      (uint8_t )117};
#line 55 "/root/patchweave_new/13/src/enc/backward_references.c"
static int DistanceToPlaneCode(int xsize , int dist ) 
{ 
  int yoffset ;
  int xoffset ;

  {
#line 56
  yoffset = dist / xsize;
#line 57
  xoffset = dist - yoffset * xsize;
#line 58
  if (xoffset <= 8) {
#line 58
    if (yoffset < 8) {
#line 59
      return ((int )plane_to_code_lut[(yoffset * 16 + 8) - xoffset] + 1);
    } else {
#line 58
      goto _L;
    }
  } else
  _L: 
#line 60
  if (xoffset > xsize - 8) {
#line 60
    if (yoffset < 7) {
#line 61
      return ((int )plane_to_code_lut[((yoffset + 1) * 16 + 8) + (xsize - xoffset)] + 1);
    }
  }
#line 63
  return (dist + 120);
}
}
#line 66 "/root/patchweave_new/13/src/enc/backward_references.c"
__inline static int FindMatchLength(uint32_t *array1 , uint32_t *array2 , int max_limit ) 
{ 
  int match_len ;

  {
#line 69
  match_len = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;

#line 70
    if (match_len < max_limit) {
#line 70
      if (! (*(array1 + match_len) == *(array2 + match_len))) {
#line 70
        goto while_break;
      }
    } else {
#line 70
      goto while_break;
    }
#line 71
    match_len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 73
  return (match_len);
}
}
#line 79 "/root/patchweave_new/13/src/enc/backward_references.c"
void VP8LInitBackwardRefs(VP8LBackwardRefs *refs ) 
{ 


  {
#line 80
  if ((unsigned long )refs != (unsigned long )((void *)0)) {
#line 81
    refs->refs = (PixOrCopy *)((void *)0);
#line 82
    refs->size = 0;
#line 83
    refs->max_size = 0;
  }
#line 85
  return;
}
}
#line 87 "/root/patchweave_new/13/src/enc/backward_references.c"
void VP8LClearBackwardRefs(VP8LBackwardRefs *refs ) 
{ 


  {
#line 88
  if ((unsigned long )refs != (unsigned long )((void *)0)) {
    {
#line 89
    free((void *)refs->refs);
#line 90
    VP8LInitBackwardRefs(refs);
    }
  }
#line 93
  return;
}
}
#line 94 "/root/patchweave_new/13/src/enc/backward_references.c"
int VP8LBackwardRefsAlloc(VP8LBackwardRefs *refs , int max_size ) 
{ 
  void *__cil_tmp4 ;

  {
  {
#line 96
  refs->size = 0;
#line 97
  refs->max_size = 0;
#line 98
  __cil_tmp4 = WebPSafeMalloc((uint64_t )max_size, sizeof(*(refs->refs)));
#line 98
  refs->refs = (PixOrCopy *)__cil_tmp4;
  }
#line 100
  if ((unsigned long )refs->refs == (unsigned long )((void *)0)) {
#line 100
    return (0);
  }
#line 101
  refs->max_size = max_size;
#line 102
  return (1);
}
}
#line 108 "/root/patchweave_new/13/src/enc/backward_references.c"
__inline static uint64_t GetPixPairHash64(uint32_t *argb ) 
{ 
  uint64_t key ;

  {
#line 109
  key = ((uint64_t )*(argb + 1) << 32) | (unsigned long )*(argb + 0);
#line 110
  key = (uint64_t )((unsigned long long )key * 0xc6a4a7935bd1e995ULL >> 46);
#line 111
  return (key);
}
}
#line 114 "/root/patchweave_new/13/src/enc/backward_references.c"
static int HashChainInit(HashChain *p , int size ) 
{ 
  int i ;
  void *__cil_tmp4 ;

  {
  {
#line 116
  __cil_tmp4 = WebPSafeMalloc((uint64_t )size, sizeof(*(p->chain_)));
#line 116
  p->chain_ = (int *)__cil_tmp4;
  }
#line 117
  if ((unsigned long )p->chain_ == (unsigned long )((void *)0)) {
#line 118
    return (0);
  }
#line 120
  i = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;

#line 120
    if (! (i < size)) {
#line 120
      goto while_break;
    }
#line 121
    *(p->chain_ + i) = -1;
#line 120
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 123
    if (! (i < 1 << 18)) {
#line 123
      goto while_break___0;
    }
#line 124
    p->hash_to_first_index_[i] = -1;
#line 123
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 126
  return (1);
}
}
#line 129 "/root/patchweave_new/13/src/enc/backward_references.c"
static void HashChainDelete(HashChain *p ) 
{ 


  {
#line 130
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 131
    free((void *)p->chain_);
#line 132
    free((void *)p);
    }
  }
#line 135
  return;
}
}
#line 137 "/root/patchweave_new/13/src/enc/backward_references.c"
static void HashChainInsert(HashChain *p , uint32_t *argb , int pos ) 
{ 
  uint64_t hash_code ;
  uint64_t __cil_tmp5 ;

  {
  {
#line 139
  __cil_tmp5 = GetPixPairHash64(argb);
#line 139
  hash_code = __cil_tmp5;
#line 140
  *(p->chain_ + pos) = p->hash_to_first_index_[hash_code];
#line 141
  p->hash_to_first_index_[hash_code] = pos;
  }
#line 143
  return;
}
}
#line 144 "/root/patchweave_new/13/src/enc/backward_references.c"
static void GetParamsForHashChainFindCopy(int quality , int xsize , int *window_size ,
                                          int *iter_pos , int *iter_limit ) 
{ 
  int iter_mult ;
  int tmp ;
  int max_window_size ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;

  {
#line 147
  if (quality < 27) {
#line 147
    tmp = 1;
  } else {
#line 147
    tmp = 1 + ((quality - 27) >> 4);
  }
#line 147
  iter_mult = tmp;
#line 149
  if (quality > 50) {
#line 149
    tmp___1 = (1 << 20) - 120;
  } else {
#line 149
    if (quality > 25) {
#line 149
      tmp___0 = xsize << 8;
    } else {
#line 149
      tmp___0 = xsize << 4;
    }
#line 149
    tmp___1 = tmp___0;
  }
#line 149
  max_window_size = tmp___1;
#line 153
  if (max_window_size > (1 << 20) - 120) {
#line 153
    tmp___3 = (1 << 20) - 120;
  } else {
#line 153
    tmp___3 = max_window_size;
  }
#line 153
  *window_size = tmp___3;
#line 155
  *iter_pos = 5 + (quality >> 3);
#line 156
  *iter_limit = - quality * iter_mult;
#line 157
  return;
}
}
#line 159 "/root/patchweave_new/13/src/enc/backward_references.c"
static int HashChainFindCopy(HashChain *p , int base_position , int xsize , uint32_t *argb ,
                             int maxlen , int window_size , int iter_pos , int iter_limit ,
                             int *distance_ptr , int *length_ptr ) 
{ 
  uint64_t hash_code ;
  uint64_t __cil_tmp12 ;
  int prev_length ;
  int64_t best_val ;
  int best_length ;
  int best_distance ;
  uint32_t *argb_start ;
  int min_pos ;
  int tmp ;
  int pos ;
  int64_t val ;
  int curr_length ;
  int y ;
  int x ;

  {
  {
#line 165
  __cil_tmp12 = GetPixPairHash64(argb + base_position);
#line 165
  hash_code = __cil_tmp12;
#line 166
  prev_length = 0;
#line 167
  best_val = (int64_t )0;
#line 168
  best_length = 0;
#line 169
  best_distance = 0;
#line 170
  argb_start = argb + base_position;
  }
#line 171
  if (base_position > window_size) {
#line 171
    tmp = base_position - window_size;
  } else {
#line 171
    tmp = 0;
  }
#line 171
  min_pos = tmp;
#line 176
  pos = p->hash_to_first_index_[hash_code];
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 176
    if (! (pos >= min_pos)) {
#line 176
      goto while_break;
    }
#line 181
    if (iter_pos < 0) {
#line 182
      if (iter_pos < iter_limit) {
#line 183
        goto while_break;
      } else
#line 182
      if (best_val >= 16711680L) {
#line 183
        goto while_break;
      }
    }
#line 186
    iter_pos --;
#line 187
    if (best_length != 0) {
#line 187
      if (*(argb + ((pos + best_length) - 1)) != *(argb_start + (best_length - 1))) {
#line 189
        goto while_continue;
      }
    }
    {
#line 191
    curr_length = FindMatchLength(argb + pos, argb_start, maxlen);
    }
#line 192
    if (curr_length < prev_length) {
#line 193
      goto while_continue;
    }
#line 195
    val = (int64_t )(65536 * curr_length);
#line 197
    if (base_position - pos < 9 * xsize) {
#line 198
      y = (base_position - pos) / xsize;
#line 199
      x = (base_position - pos) % xsize;
#line 200
      if (x > xsize / 2) {
#line 201
        x = xsize - x;
      }
#line 203
      if (x <= 7) {
#line 203
        if (x >= -8) {
#line 204
          val -= (long )(y * y + x * x);
        } else {
#line 206
          val -= 162L;
        }
      } else {
#line 206
        val -= 162L;
      }
    } else {
#line 209
      val -= 162L;
    }
#line 211
    if (best_val < val) {
#line 212
      prev_length = curr_length;
#line 213
      best_val = val;
#line 214
      best_length = curr_length;
#line 215
      best_distance = base_position - pos;
#line 216
      if (curr_length >= 4096) {
#line 217
        goto while_break;
      }
#line 219
      if (best_distance == 1) {
        _L: 
#line 219
        if (best_length >= 128) {
#line 221
          goto while_break;
        }
      } else
#line 219
      if (best_distance == xsize) {
#line 219
        goto _L;
      }
    }
#line 178
    pos = *(p->chain_ + pos);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 225
  *distance_ptr = best_distance;
#line 226
  *length_ptr = best_length;
#line 227
  return (best_length >= 2);
}
}
#line 230 "/root/patchweave_new/13/src/enc/backward_references.c"
__inline static void PushBackCopy(VP8LBackwardRefs *refs , int length ) 
{ 
  int size ;
  int __cil_tmp4 ;
  int __cil_tmp6 ;

  {
#line 231
  size = refs->size;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;

#line 232
    if (! (length >= 4096)) {
#line 232
      goto while_break;
    }
    {
#line 233
    __cil_tmp4 = size;
#line 233
    size ++;
#line 233
    *(refs->refs + __cil_tmp4) = PixOrCopyCreateCopy((uint32_t )1, (uint16_t )4096);
#line 234
    length -= 4096;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 236
  if (length > 0) {
    {
#line 237
    __cil_tmp6 = size;
#line 237
    size ++;
#line 237
    *(refs->refs + __cil_tmp6) = PixOrCopyCreateCopy((uint32_t )1, (uint16_t )length);
    }
  }
#line 239
  refs->size = size;
#line 240
  return;
}
}
#line 242 "/root/patchweave_new/13/src/enc/backward_references.c"
static void BackwardReferencesRle(int xsize , int ysize , uint32_t *argb , VP8LBackwardRefs *refs ) 
{ 
  int pix_count ;
  int match_len ;
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp10 ;

  {
  {
#line 245
  pix_count = xsize * ysize;
#line 246
  match_len = 0;
#line 248
  refs->size = 0;
#line 249
  PushBackCopy(refs, match_len);
#line 250
  __cil_tmp8 = refs->size;
#line 250
  (refs->size) ++;
#line 250
  *(refs->refs + __cil_tmp8) = PixOrCopyCreateLiteral(*(argb + 0));
#line 251
  i = 1;
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;

#line 251
    if (! (i < pix_count)) {
#line 251
      goto while_break;
    }
#line 252
    if (*(argb + i) == *(argb + (i - 1))) {
#line 253
      match_len ++;
    } else {
      {
#line 255
      PushBackCopy(refs, match_len);
#line 256
      match_len = 0;
#line 257
      __cil_tmp10 = refs->size;
#line 257
      (refs->size) ++;
#line 257
      *(refs->refs + __cil_tmp10) = PixOrCopyCreateLiteral(*(argb + i));
      }
    }
#line 251
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 260
  PushBackCopy(refs, match_len);
  }
#line 262
  return;
}
}
#line 263 "/root/patchweave_new/13/src/enc/backward_references.c"
static int BackwardReferencesHashChain(int xsize , int ysize , uint32_t *argb , int cache_bits ,
                                       int quality , VP8LBackwardRefs *refs ) 
{ 
  int i ;
  int ok ;
  int cc_init ;
  int use_color_cache ;
  int pix_count ;
  HashChain *hash_chain ;
  void *__cil_tmp13 ;
  VP8LColorCache hashers ;
  int window_size ;
  int iter_pos ;
  int iter_limit ;
  int __cil_tmp19 ;
  int offset ;
  int len ;
  int maxlen ;
  int offset2 ;
  int len2 ;
  int k ;
  int maxlen___0 ;
  uint32_t pixel ;
  int __cil_tmp28 ;
  int ix ;
  int __cil_tmp30 ;
  int __cil_tmp34 ;
  int last ;
  int tmp ;
  uint32_t pixel___0 ;
  int __cil_tmp39 ;
  int ix___0 ;
  int __cil_tmp41 ;

  {
  {
#line 268
  ok = 0;
#line 269
  cc_init = 0;
#line 270
  use_color_cache = cache_bits > 0;
#line 271
  pix_count = xsize * ysize;
#line 272
  __cil_tmp13 = malloc(sizeof(*hash_chain));
#line 272
  hash_chain = (HashChain *)__cil_tmp13;
#line 274
  window_size = (1 << 20) - 120;
#line 275
  iter_pos = 1;
#line 276
  iter_limit = -1;
  }
#line 278
  if ((unsigned long )hash_chain == (unsigned long )((void *)0)) {
#line 278
    return (0);
  }
#line 279
  if (use_color_cache) {
    {
#line 280
    cc_init = VP8LColorCacheInit(& hashers, cache_bits);
    }
#line 281
    if (! cc_init) {
#line 281
      goto Error;
    }
  }
  {
#line 284
  __cil_tmp19 = HashChainInit(hash_chain, pix_count);
  }
#line 284
  if (! __cil_tmp19) {
#line 284
    goto Error;
  }
  {
#line 286
  refs->size = 0;
#line 287
  GetParamsForHashChainFindCopy(quality, xsize, & window_size, & iter_pos, & iter_limit);
#line 289
  i = 0;
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;

#line 289
    if (! (i < pix_count)) {
#line 289
      goto while_break;
    }
#line 291
    offset = 0;
#line 292
    len = 0;
#line 293
    if (i < pix_count - 1) {
#line 294
      maxlen = pix_count - i;
#line 295
      if (maxlen > 4096) {
#line 296
        maxlen = 4096;
      }
      {
#line 298
      HashChainFindCopy(hash_chain, i, xsize, argb, maxlen, window_size, iter_pos,
                        iter_limit, & offset, & len);
      }
    }
#line 302
    if (len >= 2) {
      {
#line 305
      offset2 = 0;
#line 306
      len2 = 0;
#line 308
      HashChainInsert(hash_chain, argb + i, i);
      }
#line 309
      if (i < pix_count - 2) {
#line 310
        maxlen___0 = pix_count - (i + 1);
#line 311
        if (maxlen___0 > 4096) {
#line 312
          maxlen___0 = 4096;
        }
        {
#line 314
        HashChainFindCopy(hash_chain, i + 1, xsize, argb, maxlen___0, window_size,
                          iter_pos, iter_limit, & offset2, & len2);
        }
#line 317
        if (len2 > len + 1) {
          {
#line 318
          pixel = *(argb + i);
#line 320
          __cil_tmp28 = VP8LColorCacheContains___0(& hashers, pixel);
          }
#line 320
          if (use_color_cache) {
#line 320
            if (__cil_tmp28) {
              {
#line 321
              __cil_tmp30 = VP8LColorCacheGetIndex___0(& hashers, pixel);
#line 321
              ix = __cil_tmp30;
#line 322
              *(refs->refs + refs->size) = PixOrCopyCreateCacheIdx(ix);
              }
            } else {
              {
#line 324
              *(refs->refs + refs->size) = PixOrCopyCreateLiteral(pixel);
              }
            }
          } else {
            {
#line 324
            *(refs->refs + refs->size) = PixOrCopyCreateLiteral(pixel);
            }
          }
#line 326
          (refs->size) ++;
#line 327
          if (use_color_cache) {
            {
#line 327
            VP8LColorCacheInsert___0(& hashers, pixel);
            }
          }
#line 328
          i ++;
#line 329
          len = len2;
#line 330
          offset = offset2;
        }
      }
#line 333
      if (len >= 4096) {
#line 334
        len = 4095;
      }
      {
#line 336
      __cil_tmp34 = refs->size;
#line 336
      (refs->size) ++;
#line 336
      *(refs->refs + __cil_tmp34) = PixOrCopyCreateCopy((uint32_t )offset, (uint16_t )len);
      }
#line 337
      if (use_color_cache) {
#line 338
        k = 0;
        {
#line 338
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 338
          if (! (k < len)) {
#line 338
            goto while_break___0;
          }
          {
#line 339
          VP8LColorCacheInsert___0(& hashers, *(argb + (i + k)));
#line 338
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break___0: ;
      }
#line 344
      if (len < (pix_count - 1) - i) {
#line 344
        tmp = len;
      } else {
#line 344
        tmp = (pix_count - 1) - i;
      }
#line 344
      last = tmp;
#line 345
      k = 1;
      {
#line 345
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 345
        if (! (k < last)) {
#line 345
          goto while_break___1;
        }
        {
#line 346
        HashChainInsert(hash_chain, argb + (i + k), i + k);
#line 345
        k ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 349
      i += len;
    } else {
      {
#line 351
      pixel___0 = *(argb + i);
#line 352
      __cil_tmp39 = VP8LColorCacheContains___0(& hashers, pixel___0);
      }
#line 352
      if (use_color_cache) {
#line 352
        if (__cil_tmp39) {
          {
#line 354
          __cil_tmp41 = VP8LColorCacheGetIndex___0(& hashers, pixel___0);
#line 354
          ix___0 = __cil_tmp41;
#line 355
          *(refs->refs + refs->size) = PixOrCopyCreateCacheIdx(ix___0);
          }
        } else {
          {
#line 357
          *(refs->refs + refs->size) = PixOrCopyCreateLiteral(pixel___0);
          }
        }
      } else {
        {
#line 357
        *(refs->refs + refs->size) = PixOrCopyCreateLiteral(pixel___0);
        }
      }
#line 359
      (refs->size) ++;
#line 360
      if (use_color_cache) {
        {
#line 360
        VP8LColorCacheInsert___0(& hashers, pixel___0);
        }
      }
#line 361
      if (i + 1 < pix_count) {
        {
#line 362
        HashChainInsert(hash_chain, argb + i, i);
        }
      }
#line 364
      i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 367
  ok = 1;
  Error: 
#line 369
  if (cc_init) {
    {
#line 369
    VP8LColorCacheClear(& hashers);
    }
  }
  {
#line 370
  HashChainDelete(hash_chain);
  }
#line 371
  return (ok);
}
}
#line 384
static int BackwardReferencesTraceBackwards(int xsize , int ysize , int recursive_cost_model ,
                                            uint32_t *argb , int quality , int cache_bits ,
                                            VP8LBackwardRefs *refs ) ;
#line 389 "/root/patchweave_new/13/src/enc/backward_references.c"
static void ConvertPopulationCountTableToBitEstimates(int num_symbols , int const   *population_counts ,
                                                      double *output ) 
{ 
  int sum ;
  int nonzeros ;
  int i ;
  double logsum ;
  float __cil_tmp8 ;
  float __cil_tmp9 ;

  {
#line 391
  sum = 0;
#line 392
  nonzeros = 0;
#line 394
  i = 0;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;

#line 394
    if (! (i < num_symbols)) {
#line 394
      goto while_break;
    }
#line 395
    sum += (int )*(population_counts + i);
#line 396
    if (*(population_counts + i) > 0) {
#line 397
      nonzeros ++;
    }
#line 394
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 400
  if (nonzeros <= 1) {
    {
#line 401
    memset((void *)output, 0, (unsigned long )num_symbols * sizeof(*(output + 0)));
    }
  } else {
    {
#line 403
    __cil_tmp8 = VP8LFastLog2(sum);
#line 403
    logsum = (double )__cil_tmp8;
#line 404
    i = 0;
    }
    {
#line 404
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 404
      if (! (i < num_symbols)) {
#line 404
        goto while_break___0;
      }
      {
#line 405
      __cil_tmp9 = VP8LFastLog2((int )*(population_counts + i));
#line 405
      *(output + i) = logsum - (double )__cil_tmp9;
#line 404
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 409
  return;
}
}
#line 410 "/root/patchweave_new/13/src/enc/backward_references.c"
static int CostModelBuild(CostModel *m , int xsize , int ysize , int recursion_level ,
                          uint32_t *argb , int quality , int cache_bits ) 
{ 
  int ok ;
  VP8LHistogram histo ;
  VP8LBackwardRefs refs ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 413
  ok = 0;
#line 417
  __cil_tmp11 = VP8LBackwardRefsAlloc(& refs, xsize * ysize);
  }
#line 417
  if (! __cil_tmp11) {
#line 417
    goto Error;
  }
#line 419
  if (recursion_level > 0) {
    {
#line 420
    __cil_tmp12 = BackwardReferencesTraceBackwards(xsize, ysize, recursion_level - 1,
                                                   argb, quality, cache_bits, & refs);
    }
#line 420
    if (! __cil_tmp12) {
#line 422
      goto Error;
    }
  } else {
    {
#line 425
    __cil_tmp13 = BackwardReferencesHashChain(xsize, ysize, argb, cache_bits, quality,
                                              & refs);
    }
#line 425
    if (! __cil_tmp13) {
#line 427
      goto Error;
    }
  }
  {
#line 430
  VP8LHistogramCreate(& histo, & refs, cache_bits);
#line 431
  __cil_tmp14 = VP8LHistogramNumCodes(& histo);
#line 431
  __asm__  ("booo_exp(/root/patchweave_new/13/src/enc/backward_references.c:431)":);
#line 431
  ConvertPopulationCountTableToBitEstimates(__cil_tmp14, (int const   *)0, m->literal_);
#line 433
  __asm__  ("booo_exp(/root/patchweave_new/13/src/enc/backward_references.c:433)":);
#line 433
  ConvertPopulationCountTableToBitEstimates(256, (int const   *)0, m->red_);
#line 435
  __asm__  ("booo_exp(/root/patchweave_new/13/src/enc/backward_references.c:435)":);
#line 435
  ConvertPopulationCountTableToBitEstimates(256, (int const   *)0, m->blue_);
#line 437
  __asm__  ("booo_exp(/root/patchweave_new/13/src/enc/backward_references.c:437)":);
#line 437
  ConvertPopulationCountTableToBitEstimates(256, (int const   *)0, m->alpha_);
#line 439
  __asm__  ("booo_exp(/root/patchweave_new/13/src/enc/backward_references.c:439)":);
#line 439
  ConvertPopulationCountTableToBitEstimates(40, (int const   *)0, m->distance_);
#line 441
  ok = 1;
  }
  Error: 
  {
#line 444
  VP8LClearBackwardRefs(& refs);
  }
#line 445
  return (ok);
}
}
#line 448 "/root/patchweave_new/13/src/enc/backward_references.c"
__inline static double GetLiteralCost(CostModel *m , uint32_t v ) 
{ 


  {
#line 449
  return (((m->alpha_[v >> 24] + m->red_[(v >> 16) & 255U]) + m->literal_[(v >> 8) & 255U]) + m->blue_[v & 255U]);
}
}
#line 455 "/root/patchweave_new/13/src/enc/backward_references.c"
__inline static double GetCacheCost(CostModel *m , uint32_t idx ) 
{ 
  int literal_idx ;

  {
#line 456
  literal_idx = (int )(280U + idx);
#line 457
  return (m->literal_[literal_idx]);
}
}
#line 460 "/root/patchweave_new/13/src/enc/backward_references.c"
__inline static double GetLengthCost(CostModel *m , uint32_t length ) 
{ 
  int code ;
  int extra_bits_count ;
  int extra_bits_value ;

  {
  {
#line 463
  PrefixEncode((int )length, & code, & extra_bits_count, & extra_bits_value);
  }
#line 464
  return (m->literal_[256 + code] + (double )extra_bits_count);
}
}
#line 467 "/root/patchweave_new/13/src/enc/backward_references.c"
__inline static double GetDistanceCost(CostModel *m , uint32_t distance ) 
{ 
  int code ;
  int extra_bits_count ;
  int extra_bits_value ;

  {
  {
#line 470
  PrefixEncode((int )distance, & code, & extra_bits_count, & extra_bits_value);
  }
#line 471
  return (m->distance_[code] + (double )extra_bits_count);
}
}
#line 474 "/root/patchweave_new/13/src/enc/backward_references.c"
static int BackwardReferencesHashChainDistanceOnly(int xsize , int ysize , int recursive_cost_model ,
                                                   uint32_t *argb , int quality ,
                                                   int cache_bits , uint32_t *dist_array ) 
{ 
  int i ;
  int ok ;
  int cc_init ;
  int pix_count ;
  int use_color_cache ;
  float *cost ;
  void *__cil_tmp14 ;
  CostModel *cost_model ;
  void *__cil_tmp16 ;
  HashChain *hash_chain ;
  void *__cil_tmp18 ;
  VP8LColorCache hashers ;
  double mul0 ;
  double tmp ;
  double mul1 ;
  double tmp___0 ;
  int min_distance_code ;
  int window_size ;
  int iter_pos ;
  int iter_limit ;
  int __cil_tmp28 ;
  int __cil_tmp30 ;
  double prev_cost ;
  int shortmax ;
  int offset ;
  int len ;
  int maxlen ;
  int tmp___1 ;
  int code ;
  int __cil_tmp38 ;
  double distance_cost ;
  double __cil_tmp40 ;
  int k ;
  double cost_val ;
  double __cil_tmp43 ;
  int last ;
  int tmp___2 ;
  double cost_val___0 ;
  int __cil_tmp47 ;
  int ix ;
  int __cil_tmp49 ;
  double __cil_tmp50 ;
  double __cil_tmp51 ;

  {
  {
#line 478
  ok = 0;
#line 479
  cc_init = 0;
#line 480
  pix_count = xsize * ysize;
#line 481
  use_color_cache = cache_bits > 0;
#line 482
  __cil_tmp14 = WebPSafeMalloc((uint64_t )pix_count, sizeof(*cost));
#line 482
  cost = (float *)__cil_tmp14;
#line 484
  __cil_tmp16 = malloc(sizeof(*cost_model));
#line 484
  cost_model = (CostModel *)__cil_tmp16;
#line 485
  __cil_tmp18 = malloc(sizeof(*hash_chain));
#line 485
  hash_chain = (HashChain *)__cil_tmp18;
  }
#line 487
  if (recursive_cost_model != 0) {
#line 487
    tmp = 1.;
  } else {
#line 487
    tmp = 0.680000000001;
  }
#line 487
  mul0 = tmp;
#line 488
  if (recursive_cost_model != 0) {
#line 488
    tmp___0 = 1.;
  } else {
#line 488
    tmp___0 = 0.82;
  }
#line 488
  mul1 = tmp___0;
#line 489
  min_distance_code = 2;
#line 490
  window_size = (1 << 20) - 120;
#line 491
  iter_pos = 1;
#line 492
  iter_limit = -1;
#line 494
  if ((unsigned long )cost == (unsigned long )((void *)0)) {
#line 494
    goto Error;
  } else
#line 494
  if ((unsigned long )cost_model == (unsigned long )((void *)0)) {
#line 494
    goto Error;
  } else
#line 494
  if ((unsigned long )hash_chain == (unsigned long )((void *)0)) {
#line 494
    goto Error;
  }
  {
#line 496
  __cil_tmp28 = HashChainInit(hash_chain, pix_count);
  }
#line 496
  if (! __cil_tmp28) {
#line 496
    goto Error;
  }
#line 498
  if (use_color_cache) {
    {
#line 499
    cc_init = VP8LColorCacheInit(& hashers, cache_bits);
    }
#line 500
    if (! cc_init) {
#line 500
      goto Error;
    }
  }
  {
#line 503
  __cil_tmp30 = CostModelBuild(cost_model, xsize, ysize, recursive_cost_model, argb,
                               quality, cache_bits);
  }
#line 503
  if (! __cil_tmp30) {
#line 505
    goto Error;
  }
#line 508
  i = 0;
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;

#line 508
    if (! (i < pix_count)) {
#line 508
      goto while_break;
    }
#line 508
    *(cost + i) = 9.99999968029e+37f;
#line 508
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 512
  *(dist_array + 0) = (uint32_t )0;
#line 513
  GetParamsForHashChainFindCopy(quality, xsize, & window_size, & iter_pos, & iter_limit);
#line 515
  i = 0;
  }
  {
#line 515
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 515
    if (! (i < pix_count)) {
#line 515
      goto while_break___0;
    }
#line 516
    prev_cost = 0.;
#line 518
    if (i > 0) {
#line 519
      prev_cost = (double )*(cost + (i - 1));
    }
#line 521
    shortmax = 0;
    {
#line 521
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 521
      if (! (shortmax < 2)) {
#line 521
        goto while_break___1;
      }
#line 522
      offset = 0;
#line 523
      len = 0;
#line 524
      if (i < pix_count - 1) {
#line 525
        if (shortmax) {
#line 525
          tmp___1 = 2;
        } else {
#line 525
          tmp___1 = 4096;
        }
#line 525
        maxlen = tmp___1;
#line 526
        if (maxlen > pix_count - i) {
#line 527
          maxlen = pix_count - i;
        }
        {
#line 529
        HashChainFindCopy(hash_chain, i, xsize, argb, maxlen, window_size, iter_pos,
                          iter_limit, & offset, & len);
        }
      }
#line 533
      if (len >= 2) {
        {
#line 534
        __cil_tmp38 = DistanceToPlaneCode(xsize, offset);
#line 534
        code = __cil_tmp38;
#line 535
        __cil_tmp40 = GetDistanceCost(cost_model, (uint32_t )code);
#line 535
        distance_cost = prev_cost + __cil_tmp40;
#line 538
        k = 1;
        }
        {
#line 538
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 538
          if (! (k < len)) {
#line 538
            goto while_break___2;
          }
          {
#line 539
          __cil_tmp43 = GetLengthCost(cost_model, (uint32_t )k);
#line 539
          cost_val = distance_cost + __cil_tmp43;
          }
#line 540
          if ((double )*(cost + (i + k)) > cost_val) {
#line 541
            *(cost + (i + k)) = (float )cost_val;
#line 542
            *(dist_array + (i + k)) = (uint32_t )(k + 1);
          }
#line 538
          k ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: ;
#line 547
        if (len >= 128) {
#line 547
          if (code <= min_distance_code) {
#line 551
            if (use_color_cache) {
#line 552
              k = 0;
              {
#line 552
              while (1) {
                while_continue___3: /* CIL Label */ ;

#line 552
                if (! (k < len)) {
#line 552
                  goto while_break___3;
                }
                {
#line 553
                VP8LColorCacheInsert___0(& hashers, *(argb + (i + k)));
#line 552
                k ++;
                }
              }
              while_break___9: /* CIL Label */ ;
              }
              while_break___3: ;
            }
#line 558
            if (len + i < pix_count - 1) {
#line 558
              tmp___2 = len + i;
            } else {
#line 558
              tmp___2 = pix_count - 1;
            }
#line 558
            last = tmp___2;
#line 560
            k = i;
            {
#line 560
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 560
              if (! (k < last)) {
#line 560
                goto while_break___4;
              }
              {
#line 561
              HashChainInsert(hash_chain, argb + k, k);
#line 560
              k ++;
              }
            }
            while_break___10: /* CIL Label */ ;
            }
            while_break___4: 
#line 565
            i += len - 1;
#line 566
            goto next_symbol;
          }
        }
      }
#line 521
      shortmax ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: ;
#line 570
    if (i < pix_count - 1) {
      {
#line 571
      HashChainInsert(hash_chain, argb + i, i);
      }
    }
    {
#line 575
    cost_val___0 = prev_cost;
#line 576
    __cil_tmp47 = VP8LColorCacheContains___0(& hashers, *(argb + i));
    }
#line 576
    if (use_color_cache) {
#line 576
      if (__cil_tmp47) {
        {
#line 577
        __cil_tmp49 = VP8LColorCacheGetIndex___0(& hashers, *(argb + i));
#line 577
        ix = __cil_tmp49;
#line 578
        __cil_tmp50 = GetCacheCost(cost_model, (uint32_t )ix);
#line 578
        cost_val___0 += __cil_tmp50 * mul0;
        }
      } else {
        {
#line 580
        __cil_tmp51 = GetLiteralCost(cost_model, *(argb + i));
#line 580
        cost_val___0 += __cil_tmp51 * mul1;
        }
      }
    } else {
      {
#line 580
      __cil_tmp51 = GetLiteralCost(cost_model, *(argb + i));
#line 580
      cost_val___0 += __cil_tmp51 * mul1;
      }
    }
#line 582
    if ((double )*(cost + i) > cost_val___0) {
#line 583
      *(cost + i) = (float )cost_val___0;
#line 584
      *(dist_array + i) = (uint32_t )1;
    }
#line 586
    if (use_color_cache) {
      {
#line 586
      VP8LColorCacheInsert___0(& hashers, *(argb + i));
      }
    }
    next_symbol: 
#line 515
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 592
  ok = 1;
  Error: 
#line 594
  if (cc_init) {
    {
#line 594
    VP8LColorCacheClear(& hashers);
    }
  }
  {
#line 595
  HashChainDelete(hash_chain);
#line 596
  free((void *)cost_model);
#line 597
  free((void *)cost);
  }
#line 598
  return (ok);
}
}
#line 604 "/root/patchweave_new/13/src/enc/backward_references.c"
static void TraceBackwards(uint32_t *dist_array , int dist_array_size , uint32_t **chosen_path ,
                           int *chosen_path_size ) 
{ 
  uint32_t *path ;
  uint32_t *cur ;
  int k ;

  {
#line 608
  path = dist_array + dist_array_size;
#line 609
  cur = (dist_array + dist_array_size) - 1;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;

#line 610
    if (! ((unsigned long )cur >= (unsigned long )dist_array)) {
#line 610
      goto while_break;
    }
#line 611
    k = (int )*cur;
#line 612
    path --;
#line 613
    *path = (uint32_t )k;
#line 614
    cur -= k;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 616
  *chosen_path = path;
#line 617
  *chosen_path_size = (int )((dist_array + dist_array_size) - path);
#line 618
  return;
}
}
#line 620 "/root/patchweave_new/13/src/enc/backward_references.c"
static int BackwardReferencesHashChainFollowChosenPath(int xsize , int ysize , uint32_t *argb ,
                                                       int quality , int cache_bits ,
                                                       uint32_t *chosen_path , int chosen_path_size ,
                                                       VP8LBackwardRefs *refs ) 
{ 
  int pix_count ;
  int use_color_cache ;
  int size ;
  int i ;
  int k ;
  int ix ;
  int ok ;
  int cc_init ;
  int window_size ;
  int iter_pos ;
  int iter_limit ;
  HashChain *hash_chain ;
  void *__cil_tmp21 ;
  VP8LColorCache hashers ;
  int __cil_tmp23 ;
  int offset ;
  int len ;
  int maxlen ;
  int last ;
  int tmp___0 ;
  int __cil_tmp32 ;
  int idx ;
  int __cil_tmp34 ;

  {
  {
#line 625
  pix_count = xsize * ysize;
#line 626
  use_color_cache = cache_bits > 0;
#line 627
  size = 0;
#line 628
  i = 0;
#line 631
  ok = 0;
#line 632
  cc_init = 0;
#line 633
  window_size = (1 << 20) - 120;
#line 634
  iter_pos = 1;
#line 635
  iter_limit = -1;
#line 636
  __cil_tmp21 = malloc(sizeof(*hash_chain));
#line 636
  hash_chain = (HashChain *)__cil_tmp21;
#line 639
  __cil_tmp23 = HashChainInit(hash_chain, pix_count);
  }
#line 639
  if ((unsigned long )hash_chain == (unsigned long )((void *)0)) {
#line 640
    goto Error;
  } else
#line 639
  if (! __cil_tmp23) {
#line 640
    goto Error;
  }
#line 642
  if (use_color_cache) {
    {
#line 643
    cc_init = VP8LColorCacheInit(& hashers, cache_bits);
    }
#line 644
    if (! cc_init) {
#line 644
      goto Error;
    }
  }
  {
#line 647
  refs->size = 0;
#line 648
  GetParamsForHashChainFindCopy(quality, xsize, & window_size, & iter_pos, & iter_limit);
#line 650
  ix = 0;
  }
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;

#line 650
    if (! (ix < chosen_path_size)) {
#line 650
      goto while_break;
    }
#line 651
    offset = 0;
#line 652
    len = 0;
#line 653
    maxlen = (int )*(chosen_path + ix);
#line 654
    if (maxlen != 1) {
      {
#line 655
      HashChainFindCopy(hash_chain, i, xsize, argb, maxlen, window_size, iter_pos,
                        iter_limit, & offset, & len);
#line 659
      *(refs->refs + size) = PixOrCopyCreateCopy((uint32_t )offset, (uint16_t )len);
      }
#line 660
      if (use_color_cache) {
#line 661
        k = 0;
        {
#line 661
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 661
          if (! (k < len)) {
#line 661
            goto while_break___0;
          }
          {
#line 662
          VP8LColorCacheInsert___0(& hashers, *(argb + (i + k)));
#line 661
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break___0: ;
      }
#line 666
      if (len < (pix_count - 1) - i) {
#line 666
        tmp___0 = len;
      } else {
#line 666
        tmp___0 = (pix_count - 1) - i;
      }
#line 666
      last = tmp___0;
#line 667
      k = 0;
      {
#line 667
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 667
        if (! (k < last)) {
#line 667
          goto while_break___1;
        }
        {
#line 668
        HashChainInsert(hash_chain, argb + (i + k), i + k);
#line 667
        k ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 671
      i += len;
    } else {
      {
#line 673
      __cil_tmp32 = VP8LColorCacheContains___0(& hashers, *(argb + i));
      }
#line 673
      if (use_color_cache) {
#line 673
        if (__cil_tmp32) {
          {
#line 675
          __cil_tmp34 = VP8LColorCacheGetIndex___0(& hashers, *(argb + i));
#line 675
          idx = __cil_tmp34;
#line 676
          *(refs->refs + size) = PixOrCopyCreateCacheIdx(idx);
          }
        } else {
          {
#line 678
          *(refs->refs + size) = PixOrCopyCreateLiteral(*(argb + i));
          }
        }
      } else {
        {
#line 678
        *(refs->refs + size) = PixOrCopyCreateLiteral(*(argb + i));
        }
      }
#line 680
      if (use_color_cache) {
        {
#line 680
        VP8LColorCacheInsert___0(& hashers, *(argb + i));
        }
      }
#line 681
      if (i + 1 < pix_count) {
        {
#line 682
        HashChainInsert(hash_chain, argb + i, i);
        }
      }
#line 684
      i ++;
    }
#line 650
    size ++;
#line 650
    ix ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 688
  refs->size = size;
#line 689
  ok = 1;
  Error: 
#line 691
  if (cc_init) {
    {
#line 691
    VP8LColorCacheClear(& hashers);
    }
  }
  {
#line 692
  HashChainDelete(hash_chain);
  }
#line 693
  return (ok);
}
}
#line 697 "/root/patchweave_new/13/src/enc/backward_references.c"
static int BackwardReferencesTraceBackwards(int xsize , int ysize , int recursive_cost_model ,
                                            uint32_t *argb , int quality , int cache_bits ,
                                            VP8LBackwardRefs *refs ) 
{ 
  int ok ;
  int dist_array_size ;
  uint32_t *chosen_path ;
  int chosen_path_size ;
  uint32_t *dist_array ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 702
  ok = 0;
#line 703
  dist_array_size = xsize * ysize;
#line 704
  chosen_path = (uint32_t *)((void *)0);
#line 705
  chosen_path_size = 0;
#line 706
  __cil_tmp13 = WebPSafeMalloc((uint64_t )dist_array_size, sizeof(*dist_array));
#line 706
  dist_array = (uint32_t *)__cil_tmp13;
  }
#line 709
  if ((unsigned long )dist_array == (unsigned long )((void *)0)) {
#line 709
    goto Error;
  }
  {
#line 711
  __cil_tmp14 = BackwardReferencesHashChainDistanceOnly(xsize, ysize, recursive_cost_model,
                                                        argb, quality, cache_bits,
                                                        dist_array);
  }
#line 711
  if (! __cil_tmp14) {
#line 714
    goto Error;
  }
  {
#line 716
  TraceBackwards(dist_array, dist_array_size, & chosen_path, & chosen_path_size);
#line 717
  __cil_tmp15 = BackwardReferencesHashChainFollowChosenPath(xsize, ysize, argb, quality,
                                                            cache_bits, chosen_path,
                                                            chosen_path_size, refs);
  }
#line 717
  if (! __cil_tmp15) {
#line 720
    goto Error;
  }
#line 722
  ok = 1;
  Error: 
  {
#line 724
  free((void *)dist_array);
  }
#line 725
  return (ok);
}
}
#line 728 "/root/patchweave_new/13/src/enc/backward_references.c"
static void BackwardReferences2DLocality(int xsize , VP8LBackwardRefs *refs ) 
{ 
  int i ;
  int __cil_tmp4 ;
  int dist ;
  int transformed_dist ;
  int __cil_tmp7 ;

  {
#line 731
  i = 0;
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;

#line 731
    if (! (i < refs->size)) {
#line 731
      goto while_break;
    }
    {
#line 732
    __cil_tmp4 = PixOrCopyIsCopy(refs->refs + i);
    }
#line 732
    if (__cil_tmp4) {
      {
#line 733
      dist = (int )(refs->refs + i)->argb_or_distance;
#line 734
      __cil_tmp7 = DistanceToPlaneCode(xsize, dist);
#line 734
      transformed_dist = __cil_tmp7;
#line 735
      (refs->refs + i)->argb_or_distance = (uint32_t )transformed_dist;
      }
    }
#line 731
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 735
  return;
}
}
#line 740 "/root/patchweave_new/13/src/enc/backward_references.c"
int VP8LGetBackwardReferences(int width , int height , uint32_t *argb , int quality ,
                              int cache_bits , int use_2d_locality , VP8LBackwardRefs *best ) 
{ 
  int ok ;
  int lz77_is_useful ;
  VP8LBackwardRefs refs_rle ;
  VP8LBackwardRefs refs_lz77 ;
  int num_pix ;
  int __cil_tmp13 ;
  double bit_cost_lz77 ;
  double bit_cost_rle ;
  VP8LHistogram *histo ;
  void *__cil_tmp17 ;
  int try_lz77_trace_backwards ;
  int recursion_level ;
  int tmp ;
  VP8LBackwardRefs refs_trace ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;

  {
  {
#line 744
  ok = 0;
#line 747
  num_pix = width * height;
#line 749
  VP8LBackwardRefsAlloc(& refs_rle, num_pix);
#line 750
  VP8LBackwardRefsAlloc(& refs_lz77, num_pix);
#line 751
  VP8LInitBackwardRefs(best);
  }
#line 752
  if ((unsigned long )refs_rle.refs == (unsigned long )((void *)0)) {
    Error1: 
    {
#line 754
    VP8LClearBackwardRefs(& refs_rle);
#line 755
    VP8LClearBackwardRefs(& refs_lz77);
    }
#line 756
    goto End;
  } else
#line 752
  if ((unsigned long )refs_lz77.refs == (unsigned long )((void *)0)) {
#line 752
    goto Error1;
  }
  {
#line 759
  __cil_tmp13 = BackwardReferencesHashChain(width, height, argb, cache_bits, quality,
                                            & refs_lz77);
  }
#line 759
  if (! __cil_tmp13) {
#line 761
    goto End;
  }
  {
#line 764
  BackwardReferencesRle(width, height, argb, & refs_rle);
#line 768
  __cil_tmp17 = malloc(sizeof(*histo));
#line 768
  histo = (VP8LHistogram *)__cil_tmp17;
  }
#line 769
  if ((unsigned long )histo == (unsigned long )((void *)0)) {
#line 769
    goto Error1;
  }
  {
#line 771
  VP8LHistogramCreate(histo, & refs_lz77, cache_bits);
#line 772
  bit_cost_lz77 = VP8LHistogramEstimateBits(histo);
#line 774
  VP8LHistogramCreate(histo, & refs_rle, cache_bits);
#line 775
  bit_cost_rle = VP8LHistogramEstimateBits(histo);
#line 777
  lz77_is_useful = bit_cost_lz77 < bit_cost_rle;
#line 778
  free((void *)histo);
  }
#line 782
  if (lz77_is_useful) {
    {
#line 784
    try_lz77_trace_backwards = quality > 10;
#line 785
    *best = refs_lz77;
#line 786
    VP8LClearBackwardRefs(& refs_rle);
    }
#line 787
    if (try_lz77_trace_backwards) {
#line 788
      if (num_pix < 64000) {
#line 788
        tmp = 1;
      } else {
#line 788
        tmp = 0;
      }
      {
#line 788
      recursion_level = tmp;
#line 790
      __cil_tmp24 = VP8LBackwardRefsAlloc(& refs_trace, num_pix);
      }
#line 790
      if (! __cil_tmp24) {
#line 791
        goto End;
      }
      {
#line 793
      __cil_tmp25 = BackwardReferencesTraceBackwards(width, height, recursion_level,
                                                     argb, quality, cache_bits, & refs_trace);
      }
#line 793
      if (__cil_tmp25) {
        {
#line 795
        VP8LClearBackwardRefs(& refs_lz77);
#line 796
        *best = refs_trace;
        }
      }
    }
  } else {
    {
#line 800
    VP8LClearBackwardRefs(& refs_lz77);
#line 801
    *best = refs_rle;
    }
  }
#line 804
  if (use_2d_locality) {
    {
#line 804
    BackwardReferences2DLocality(width, best);
    }
  }
#line 806
  ok = 1;
  End: 
#line 809
  if (! ok) {
    {
#line 810
    VP8LClearBackwardRefs(best);
    }
  }
#line 812
  return (ok);
}
}
#line 816 "/root/patchweave_new/13/src/enc/backward_references.c"
static int ComputeCacheHistogram(uint32_t *argb , int xsize , int ysize , VP8LBackwardRefs *refs ,
                                 int cache_bits , VP8LHistogram *histo ) 
{ 
  int pixel_index ;
  int i ;
  uint32_t k ;
  VP8LColorCache hashers ;
  int use_color_cache ;
  int cc_init ;
  PixOrCopy *v ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int ix ;
  int __cil_tmp18 ;
  PixOrCopy token ;
  PixOrCopy __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  uint32_t __cil_tmp22 ;

  {
#line 821
  pixel_index = 0;
#line 825
  use_color_cache = cache_bits > 0;
#line 826
  cc_init = 0;
#line 828
  if (use_color_cache) {
    {
#line 829
    cc_init = VP8LColorCacheInit(& hashers, cache_bits);
    }
#line 830
    if (! cc_init) {
#line 830
      return (0);
    }
  }
#line 833
  i = 0;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;

#line 833
    if (! (i < refs->size)) {
#line 833
      goto while_break;
    }
    {
#line 834
    v = refs->refs + i;
#line 835
    __cil_tmp15 = PixOrCopyIsLiteral(v);
    }
#line 835
    if (__cil_tmp15) {
      {
#line 836
      __cil_tmp16 = VP8LColorCacheContains___0(& hashers, *(argb + pixel_index));
      }
#line 836
      if (use_color_cache) {
#line 836
        if (__cil_tmp16) {
          {
#line 839
          __cil_tmp18 = VP8LColorCacheGetIndex___0(& hashers, *(argb + pixel_index));
#line 839
          ix = __cil_tmp18;
#line 840
          __cil_tmp20 = PixOrCopyCreateCacheIdx(ix);
#line 840
          token = __cil_tmp20;
#line 841
          VP8LHistogramAddSinglePixOrCopy(histo, & token);
          }
        } else {
          {
#line 843
          VP8LHistogramAddSinglePixOrCopy(histo, v);
          }
        }
      } else {
        {
#line 843
        VP8LHistogramAddSinglePixOrCopy(histo, v);
        }
      }
    } else {
      {
#line 846
      VP8LHistogramAddSinglePixOrCopy(histo, v);
      }
    }
#line 848
    if (use_color_cache) {
#line 849
      k = (uint32_t )0;
      {
#line 849
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 849
        if (! (k < __cil_tmp21)) {
#line 849
          goto while_break___0;
        }
        {
#line 850
        VP8LColorCacheInsert___0(& hashers, *(argb + ((unsigned int )pixel_index + k)));
#line 849
        k ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
    {
#line 853
    __cil_tmp22 = PixOrCopyLength(v);
#line 853
    pixel_index = (int )((uint32_t )pixel_index + __cil_tmp22);
#line 833
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 858
  if (cc_init) {
    {
#line 858
    VP8LColorCacheClear(& hashers);
    }
  }
#line 859
  return (1);
}
}
#line 869 "/root/patchweave_new/13/src/enc/backward_references.c"
static double kSmallPenaltyForLargeCache  ;
#line 870 "/root/patchweave_new/13/src/enc/backward_references.c"
static int quality  ;
#line 863 "/root/patchweave_new/13/src/enc/backward_references.c"
int VP8LCalculateEstimateForCacheSize(uint32_t *argb , int xsize , int ysize , int *best_cache_bits ) 
{ 
  int ok ;
  int cache_bits ;
  double lowest_entropy ;
  VP8LBackwardRefs refs ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  double cur_entropy ;
  VP8LHistogram histo ;
  double __cil_tmp15 ;

  {
  {
#line 866
  ok = 0;
#line 868
  lowest_entropy = 1e+99;
#line 870
  kSmallPenaltyForLargeCache = 4.;
#line 871
  quality = 30;
#line 872
  __cil_tmp12 = BackwardReferencesHashChain(xsize, ysize, argb, 0, quality, & refs);
#line 872
  __cil_tmp11 = VP8LBackwardRefsAlloc(& refs, xsize * ysize);
  }
#line 872
  if (! __cil_tmp11) {
#line 874
    goto Error;
  } else
#line 872
  if (! __cil_tmp12) {
#line 874
    goto Error;
  }
#line 876
  cache_bits = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;

#line 876
    if (! (cache_bits <= 9)) {
#line 876
      goto while_break;
    }
    {
#line 879
    VP8LHistogramInit(& histo, cache_bits);
#line 880
    ComputeCacheHistogram(argb, xsize, ysize, & refs, cache_bits, & histo);
#line 881
    __cil_tmp15 = VP8LHistogramEstimateBits(& histo);
#line 881
    cur_entropy = __cil_tmp15 + kSmallPenaltyForLargeCache * (double )cache_bits;
    }
#line 883
    if (cache_bits == 0) {
#line 884
      *best_cache_bits = cache_bits;
#line 885
      lowest_entropy = cur_entropy;
    } else
#line 883
    if (cur_entropy < lowest_entropy) {
#line 884
      *best_cache_bits = cache_bits;
#line 885
      lowest_entropy = cur_entropy;
    }
#line 876
    cache_bits ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 888
  ok = 1;
  Error: 
  {
#line 890
  VP8LClearBackwardRefs(& refs);
  }
#line 891
  return (ok);
}
}
#line 30 "/root/patchweave_new/13/src/enc/analysis.c"
static void SmoothSegmentMap(VP8Encoder *enc ) 
{ 
  int n ;
  int x ;
  int y ;
  int w ;
  int h ;
  int majority_cnt_3_x_3_grid ;
  uint8_t *tmp ;
  void *__cil_tmp9 ;
  int cnt[4] ;
  unsigned int tmp___13 ;
  VP8MBInfo *mb ;
  int majority_seg ;
  VP8MBInfo *mb___0 ;

  {
  {
#line 32
  w = enc->mb_w_;
#line 33
  h = enc->mb_h_;
#line 34
  majority_cnt_3_x_3_grid = 5;
#line 35
  __cil_tmp9 = WebPSafeMalloc((uint64_t )w * (unsigned long )h, sizeof(*tmp));
#line 35
  tmp = (uint8_t *)__cil_tmp9;
  }
#line 38
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 38
    return;
  }
#line 39
  y = 1;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;

#line 39
    if (! (y < h - 1)) {
#line 39
      goto while_break;
    }
#line 40
    x = 1;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 40
      if (! (x < w - 1)) {
#line 40
        goto while_break___0;
      }
#line 41
      cnt[0] = 0;
#line 41
      tmp___13 = 1U;
      {
#line 41
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 41
        if (tmp___13 >= 4U) {
#line 41
          goto while_break___1;
        }
#line 41
        cnt[tmp___13] = 0;
#line 41
        tmp___13 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
#line 42
      mb = enc->mb_info_ + (x + w * y);
#line 43
      majority_seg = (int )mb->segment_;
#line 45
      (cnt[(mb + (- w - 1))->segment_]) ++;
#line 46
      (cnt[(mb + - w)->segment_]) ++;
#line 47
      (cnt[(mb + (- w + 1))->segment_]) ++;
#line 48
      (cnt[(mb + -1)->segment_]) ++;
#line 49
      (cnt[(mb + 1)->segment_]) ++;
#line 50
      (cnt[(mb + (w - 1))->segment_]) ++;
#line 51
      (cnt[(mb + w)->segment_]) ++;
#line 52
      (cnt[(mb + (w + 1))->segment_]) ++;
#line 53
      n = 0;
      {
#line 53
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 53
        if (! (n < 4)) {
#line 53
          goto while_break___2;
        }
#line 54
        if (cnt[n] >= majority_cnt_3_x_3_grid) {
#line 55
          majority_seg = n;
        }
#line 53
        n ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
#line 58
      *(tmp + (x + y * w)) = (uint8_t )majority_seg;
#line 40
      x ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: 
#line 39
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 61
  y = 1;
  {
#line 61
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 61
    if (! (y < h - 1)) {
#line 61
      goto while_break___3;
    }
#line 62
    x = 1;
    {
#line 62
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 62
      if (! (x < w - 1)) {
#line 62
        goto while_break___4;
      }
#line 63
      mb___0 = enc->mb_info_ + (x + w * y);
#line 64
      mb___0->segment_ = (unsigned int )*(tmp + (x + y * w));
#line 62
      x ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: 
#line 61
    y ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___3: 
  {
#line 67
  free((void *)tmp);
  }
#line 69
  return;
}
}
#line 77 "/root/patchweave_new/13/src/enc/analysis.c"
static void SetSegmentAlphas(VP8Encoder *enc , int const   *centers , int mid ) 
{ 
  int nb ;
  int min ;
  int max ;
  int n ;
  int alpha ;
  int beta ;

  {
#line 80
  nb = enc->segment_hdr_.num_segments_;
#line 81
  min = (int )*(centers + 0);
#line 81
  max = (int )*(centers + 0);
#line 84
  if (nb > 1) {
#line 85
    n = 0;
    {
#line 85
    while (1) {
      while_continue: /* CIL Label */ ;

#line 85
      if (! (n < nb)) {
#line 85
        goto while_break;
      }
#line 86
      if (min > (int )*(centers + n)) {
#line 86
        min = (int )*(centers + n);
      }
#line 87
      if (max < (int )*(centers + n)) {
#line 87
        max = (int )*(centers + n);
      }
#line 85
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 90
  if (max == min) {
#line 90
    max = min + 1;
  }
#line 92
  n = 0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 92
    if (! (n < nb)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    alpha = (255 * (int )(*(centers + n) - (int const   )mid)) / (max - min);
#line 94
    beta = (255 * (int )(*(centers + n) - (int const   )min)) / (max - min);
#line 95
    enc->dqm_[n].alpha_ = clip(alpha, -127, 127);
#line 96
    enc->dqm_[n].beta_ = clip(beta, 0, 255);
#line 92
    n ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 96
  return;
}
}
#line 109 "/root/patchweave_new/13/src/enc/analysis.c"
static int FinalAlphaValue(int alpha ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 110
  alpha = 255 - alpha;
#line 111
  __cil_tmp2 = clip(alpha, 0, 255);
  }
#line 111
  return (__cil_tmp2);
}
}
#line 114 "/root/patchweave_new/13/src/enc/analysis.c"
static int GetAlpha(VP8Histogram *histo ) 
{ 
  int max_value ;
  int last_non_zero ;
  int k ;
  int alpha ;
  int value ;
  int tmp ;

  {
#line 115
  max_value = 0;
#line 115
  last_non_zero = 1;
#line 118
  k = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;

#line 118
    if (! (k <= 31)) {
#line 118
      goto while_break;
    }
#line 119
    value = histo->distribution[k];
#line 120
    if (value > 0) {
#line 121
      if (value > max_value) {
#line 121
        max_value = value;
      }
#line 122
      last_non_zero = k;
    }
#line 118
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 128
  if (max_value > 1) {
#line 128
    tmp = (510 * last_non_zero) / max_value;
  } else {
#line 128
    tmp = 0;
  }
#line 128
  alpha = tmp;
#line 129
  return (alpha);
}
}
#line 132 "/root/patchweave_new/13/src/enc/analysis.c"
static void MergeHistograms(VP8Histogram *in , VP8Histogram *out ) 
{ 
  int i ;

  {
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;

#line 135
    if (! (i <= 31)) {
#line 135
      goto while_break;
    }
#line 136
    out->distribution[i] += in->distribution[i];
#line 135
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 139
  return;
}
}
#line 143 "/root/patchweave_new/13/src/enc/analysis.c"
static void AssignSegments(VP8Encoder *enc , int const   *alphas ) 
{ 
  int nb ;
  int centers[4] ;
  int weighted_average ;
  int map[256] ;
  int a ;
  int n ;
  int k ;
  int min_a ;
  int max_a ;
  int range_a ;
  int accum[4] ;
  int dist_accum[4] ;
  int __cil_tmp15 ;
  int total_weight ;
  int displaced ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int new_center ;
  int __cil_tmp22 ;
  VP8MBInfo *mb ;
  int alpha ;
  int smooth ;

  {
#line 145
  nb = enc->segment_hdr_.num_segments_;
#line 147
  weighted_average = 0;
#line 150
  min_a = 0;
#line 150
  max_a = 255;
#line 155
  n = 0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;

#line 155
    if (n <= 255) {
#line 155
      if (! (*(alphas + n) == 0)) {
#line 155
        goto while_break;
      }
    } else {
#line 155
      goto while_break;
    }
#line 155
    n ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: 
#line 156
  min_a = n;
#line 157
  n = 255;
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 157
    if (n > min_a) {
#line 157
      if (! (*(alphas + n) == 0)) {
#line 157
        goto while_break___0;
      }
    } else {
#line 157
      goto while_break___0;
    }
#line 157
    n --;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___0: 
#line 158
  max_a = n;
#line 159
  range_a = max_a - min_a;
#line 162
  k = 0;
#line 162
  n = 1;
  {
#line 162
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 162
    if (! (n < 2 * nb)) {
#line 162
      goto while_break___1;
    }
#line 163
    __cil_tmp15 = k;
#line 163
    k ++;
#line 163
    centers[__cil_tmp15] = min_a + (n * range_a) / (2 * nb);
#line 162
    n += 2;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: 
#line 166
  k = 0;
  {
#line 166
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 166
    if (! (k < 6)) {
#line 166
      goto while_break___2;
    }
#line 170
    n = 0;
    {
#line 170
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 170
      if (! (n < nb)) {
#line 170
        goto while_break___3;
      }
#line 171
      accum[n] = 0;
#line 172
      dist_accum[n] = 0;
#line 170
      n ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___3: 
#line 175
    n = 0;
#line 176
    a = min_a;
    {
#line 176
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 176
      if (! (a <= max_a)) {
#line 176
        goto while_break___4;
      }
#line 177
      if (*(alphas + a)) {
        {
#line 178
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 178
          __cil_tmp19 = abs(a - centers[n]);
#line 178
          __cil_tmp18 = abs(a - centers[n + 1]);
          }
#line 178
          if (n < nb - 1) {
#line 178
            if (! (__cil_tmp18 < __cil_tmp19)) {
#line 178
              goto while_break___5;
            }
          } else {
#line 178
            goto while_break___5;
          }
#line 179
          n ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___5: 
#line 181
        map[a] = n;
#line 183
        dist_accum[n] += a * (int )*(alphas + a);
#line 184
        accum[n] += (int )*(alphas + a);
      }
#line 176
      a ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: 
#line 189
    displaced = 0;
#line 190
    weighted_average = 0;
#line 191
    total_weight = 0;
#line 192
    n = 0;
    {
#line 192
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 192
      if (! (n < nb)) {
#line 192
        goto while_break___6;
      }
#line 193
      if (accum[n]) {
        {
#line 194
        new_center = (dist_accum[n] + accum[n] / 2) / accum[n];
#line 195
        __cil_tmp22 = abs(centers[n] - new_center);
#line 195
        displaced += __cil_tmp22;
#line 196
        centers[n] = new_center;
#line 197
        weighted_average += new_center * accum[n];
#line 198
        total_weight += accum[n];
        }
      }
#line 192
      n ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___6: 
#line 201
    weighted_average = (weighted_average + total_weight / 2) / total_weight;
#line 202
    if (displaced < 5) {
#line 202
      goto while_break___2;
    }
#line 166
    k ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___2: 
#line 206
  n = 0;
  {
#line 206
  while (1) {
    while_continue___7: /* CIL Label */ ;

#line 206
    if (! (n < enc->mb_w_ * enc->mb_h_)) {
#line 206
      goto while_break___7;
    }
#line 207
    mb = enc->mb_info_ + n;
#line 208
    alpha = (int )mb->alpha_;
#line 209
    mb->segment_ = (unsigned int )map[alpha];
#line 210
    mb->alpha_ = (uint8_t )centers[map[alpha]];
#line 206
    n ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___7: ;
#line 213
  if (nb > 1) {
#line 214
    smooth = (enc->config_)->preprocessing & 1;
#line 215
    if (smooth) {
      {
#line 215
      SmoothSegmentMap(enc);
      }
    }
  }
  {
#line 218
  __asm__  ("booo_exp(/root/patchweave_new/13/src/enc/analysis.c:218)":);
#line 218
  SetSegmentAlphas(enc, (int const   *)0, weighted_average);
  }
#line 220
  return;
}
}
#line 234 "/root/patchweave_new/13/src/enc/analysis.c"
static int MBAnalyzeBestIntra16Mode(VP8EncIterator *it ) 
{ 
  int max_mode ;
  int tmp ;
  int mode ;
  int best_alpha ;
  int best_mode ;
  VP8Histogram histo ;
  unsigned int tmp___0 ;
  int alpha ;

  {
#line 235
  if ((it->enc_)->method_ >= 4) {
#line 235
    tmp = 2;
  } else {
#line 235
    tmp = 4;
  }
  {
#line 235
  max_mode = tmp;
#line 239
  best_alpha = -1;
#line 240
  best_mode = 0;
#line 242
  VP8MakeLuma16Preds(it);
#line 243
  mode = 0;
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;

#line 243
    if (! (mode < max_mode)) {
#line 243
      goto while_break;
    }
#line 244
    histo.distribution[0] = 0;
#line 244
    tmp___0 = 1U;
    {
#line 244
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 244
      if (tmp___0 >= 32U) {
#line 244
        goto while_break___0;
      }
#line 244
      histo.distribution[tmp___0] = 0;
#line 244
      tmp___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 247
    (*VP8CollectHistogram)(it->yuv_in_ + 0, it->yuv_p_ + VP8I16ModeOffsets[mode],
                           0, 16, (struct VP8Histogram */* const  */)(& histo));
#line 250
    alpha = GetAlpha(& histo);
    }
#line 251
    if (alpha > best_alpha) {
#line 252
      best_alpha = alpha;
#line 253
      best_mode = mode;
    }
#line 243
    mode ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 256
  VP8SetIntra16Mode(it, best_mode);
  }
#line 257
  return (best_alpha);
}
}
#line 260 "/root/patchweave_new/13/src/enc/analysis.c"
static int MBAnalyzeBestIntra4Mode(VP8EncIterator *it , int best_alpha ) 
{ 
  uint8_t modes[16] ;
  int max_mode ;
  int tmp ;
  int i4_alpha ;
  VP8Histogram total_histo ;
  unsigned int tmp___0 ;
  int cur_histo ;
  int __cil_tmp10 ;
  int mode ;
  int best_mode_alpha ;
  VP8Histogram histos[2] ;
  uint8_t *src ;
  int alpha ;

  {
#line 263
  if ((it->enc_)->method_ >= 4) {
#line 263
    tmp = 2;
  } else {
#line 263
    tmp = 10;
  }
#line 263
  max_mode = tmp;
#line 267
  total_histo.distribution[0] = 0;
#line 267
  tmp___0 = 1U;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;

#line 267
    if (tmp___0 >= 32U) {
#line 267
      goto while_break;
    }
#line 267
    total_histo.distribution[tmp___0] = 0;
#line 267
    tmp___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 268
  cur_histo = 0;
#line 270
  VP8IteratorStartI4(it);
  }
  {
#line 271
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 273
    best_mode_alpha = -1;
#line 275
    src = (it->yuv_in_ + 0) + VP8Scan[it->i4_];
#line 277
    VP8MakeIntra4Preds(it);
#line 278
    mode = 0;
    }
    {
#line 278
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 278
      if (! (mode < max_mode)) {
#line 278
        goto while_break___1;
      }
      {
#line 281
      memset((void *)(& histos[cur_histo]), 0, sizeof(histos[cur_histo]));
#line 282
      (*VP8CollectHistogram)(src, it->yuv_p_ + VP8I4ModeOffsets[mode], 0, 1, (struct VP8Histogram */* const  */)(& histos[cur_histo]));
#line 284
      alpha = GetAlpha(& histos[cur_histo]);
      }
#line 285
      if (alpha > best_mode_alpha) {
#line 286
        best_mode_alpha = alpha;
#line 287
        modes[it->i4_] = (uint8_t )mode;
#line 288
        cur_histo ^= 1;
      }
#line 278
      mode ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 292
    MergeHistograms(& histos[cur_histo ^ 1], & total_histo);
    }
#line 271
    if (! __cil_tmp10) {
#line 271
      goto while_break___0;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 296
  i4_alpha = GetAlpha(& total_histo);
  }
#line 297
  if (i4_alpha > best_alpha) {
    {
#line 298
    VP8SetIntra4Mode(it, modes);
#line 299
    best_alpha = i4_alpha;
    }
  }
#line 301
  return (best_alpha);
}
}
#line 304 "/root/patchweave_new/13/src/enc/analysis.c"
static int MBAnalyzeBestUVMode(VP8EncIterator *it ) 
{ 
  int best_alpha ;
  int best_mode ;
  int max_mode ;
  int tmp ;
  int mode ;
  VP8Histogram histo ;
  unsigned int tmp___0 ;
  int alpha ;

  {
#line 305
  best_alpha = -1;
#line 306
  best_mode = 0;
#line 307
  if ((it->enc_)->method_ >= 4) {
#line 307
    tmp = 2;
  } else {
#line 307
    tmp = 4;
  }
  {
#line 307
  max_mode = tmp;
#line 311
  VP8MakeChroma8Preds(it);
#line 312
  mode = 0;
  }
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;

#line 312
    if (! (mode < max_mode)) {
#line 312
      goto while_break;
    }
#line 313
    histo.distribution[0] = 0;
#line 313
    tmp___0 = 1U;
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 313
      if (tmp___0 >= 32U) {
#line 313
        goto while_break___0;
      }
#line 313
      histo.distribution[tmp___0] = 0;
#line 313
      tmp___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 315
    (*VP8CollectHistogram)(it->yuv_in_ + 256, it->yuv_p_ + VP8UVModeOffsets[mode],
                           16, 24, (struct VP8Histogram */* const  */)(& histo));
#line 318
    alpha = GetAlpha(& histo);
    }
#line 319
    if (alpha > best_alpha) {
#line 320
      best_alpha = alpha;
#line 321
      best_mode = mode;
    }
#line 312
    mode ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 324
  VP8SetIntraUVMode(it, best_mode);
  }
#line 325
  return (best_alpha);
}
}
#line 328 "/root/patchweave_new/13/src/enc/analysis.c"
static void MBAnalyze(VP8EncIterator *it , int *alphas , int *alpha , int *uv_alpha ) 
{ 
  VP8Encoder *enc ;
  int best_alpha ;
  int best_uv_alpha ;

  {
  {
#line 331
  enc = it->enc_;
#line 334
  VP8SetIntra16Mode(it, 0);
#line 335
  VP8SetSkip(it, 0);
#line 336
  VP8SetSegment(it, 0);
#line 338
  best_alpha = MBAnalyzeBestIntra16Mode(it);
  }
#line 339
  if (enc->method_ >= 5) {
    {
#line 344
    best_alpha = MBAnalyzeBestIntra4Mode(it, best_alpha);
    }
  }
  {
#line 346
  best_uv_alpha = MBAnalyzeBestUVMode(it);
#line 349
  best_alpha = ((3 * best_alpha + best_uv_alpha) + 2) >> 2;
#line 350
  best_alpha = FinalAlphaValue(best_alpha);
#line 351
  (*(alphas + best_alpha)) ++;
#line 352
  (it->mb_)->alpha_ = (uint8_t )best_alpha;
#line 355
  *alpha += best_alpha;
#line 356
  *uv_alpha += best_uv_alpha;
  }
#line 358
  return;
}
}
#line 359 "/root/patchweave_new/13/src/enc/analysis.c"
static void DefaultMBInfo(VP8MBInfo *mb ) 
{ 


  {
#line 360
  mb->type_ = 1U;
#line 361
  mb->uv_mode_ = 0U;
#line 362
  mb->skip_ = 0U;
#line 363
  mb->segment_ = 0U;
#line 364
  mb->alpha_ = (uint8_t )0;
#line 365
  return;
}
}
#line 377 "/root/patchweave_new/13/src/enc/analysis.c"
static void ResetAllMBInfo(VP8Encoder *enc ) 
{ 
  int n ;

  {
#line 379
  n = 0;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;

#line 379
    if (! (n < enc->mb_w_ * enc->mb_h_)) {
#line 379
      goto while_break;
    }
    {
#line 380
    DefaultMBInfo(enc->mb_info_ + n);
#line 379
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 383
  enc->dqm_[0].alpha_ = 0;
#line 384
  enc->dqm_[0].beta_ = 0;
#line 386
  WebPReportProgress(enc->pic_, enc->percent_ + 20, & enc->percent_);
  }
#line 388
  return;
}
}
#line 389 "/root/patchweave_new/13/src/enc/analysis.c"
int VP8EncAnalyze(VP8Encoder *enc ) 
{ 
  int ok ;
  int do_segments ;
  int alphas[256] ;
  unsigned int tmp ;
  VP8EncIterator it ;
  int __cil_tmp7 ;
  int tmp___0 ;

  {
#line 390
  ok = 1;
#line 391
  if ((enc->config_)->emulate_jpeg_size) {
#line 391
    tmp___0 = 1;
  } else
#line 391
  if (enc->segment_hdr_.num_segments_ > 1) {
#line 391
    tmp___0 = 1;
  } else
#line 391
  if (enc->method_ == 0) {
#line 391
    tmp___0 = 1;
  } else {
#line 391
    tmp___0 = 0;
  }
#line 391
  do_segments = tmp___0;
#line 395
  enc->alpha_ = 0;
#line 396
  enc->uv_alpha_ = 0;
#line 397
  if (do_segments) {
#line 398
    alphas[0] = 0;
#line 398
    tmp = 1U;
    {
#line 398
    while (1) {
      while_continue: /* CIL Label */ ;

#line 398
      if (tmp >= 256U) {
#line 398
        goto while_break;
      }
#line 398
      alphas[tmp] = 0;
#line 398
      tmp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 401
    VP8IteratorInit(enc, & it);
    }
    {
#line 402
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 403
      VP8IteratorImport(& it);
#line 404
      MBAnalyze(& it, (int *)(alphas), & enc->alpha_, & enc->uv_alpha_);
#line 405
      ok = VP8IteratorProgress(& it, 20);
      }
#line 402
      if (ok) {
#line 402
        if (! __cil_tmp7) {
#line 402
          goto while_break___0;
        }
      } else {
#line 402
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 408
    enc->alpha_ /= enc->mb_w_ * enc->mb_h_;
#line 409
    enc->uv_alpha_ /= enc->mb_w_ * enc->mb_h_;
#line 410
    if (ok) {
      {
#line 410
      __asm__  ("booo_exp(/root/patchweave_new/13/src/enc/analysis.c:410)":);
#line 410
      AssignSegments(enc, (int const   *)0);
      }
    }
  } else {
    {
#line 412
    ResetAllMBInfo(enc);
    }
  }
#line 414
  return (ok);
}
}
#line 49 "/root/patchweave_new/13/src/enc/alpha.c"
static int EncodeLossless(uint8_t *data , int width , int height , int effort_level ,
                          VP8BitWriter *bw , WebPAuxStats *stats ) 
{ 
  int ok ;
  WebPConfig config ;
  WebPPicture picture ;
  VP8LBitWriter tmp_bw ;
  int __cil_tmp11 ;
  int i ;
  int j ;
  uint32_t *dst ;
  uint8_t *src ;
  enum WebPEncodingError __cil_tmp18 ;
  uint8_t *buffer ;
  uint8_t *__cil_tmp20 ;
  size_t buffer_size ;
  size_t __cil_tmp22 ;
  enum WebPEncodingError___0 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 53
  ok = 0;
#line 58
  WebPPictureInit(& picture);
#line 59
  picture.width = width;
#line 60
  picture.height = height;
#line 61
  picture.use_argb = 1;
#line 62
  picture.stats = stats;
#line 63
  __cil_tmp11 = WebPPictureAlloc(& picture);
  }
#line 63
  if (! __cil_tmp11) {
#line 63
    return (0);
  }
#line 68
  dst = picture.argb;
#line 69
  src = data;
#line 70
  j = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;

#line 70
    if (! (j < picture.height)) {
#line 70
      goto while_break;
    }
#line 71
    i = 0;
    {
#line 71
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 71
      if (! (i < picture.width)) {
#line 71
        goto while_break___0;
      }
#line 72
      *(dst + i) = (unsigned int )((int )*(src + i) << 8) | 4278190080U;
#line 71
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 74
    src += width;
#line 75
    dst += picture.argb_stride;
#line 70
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 79
  WebPConfigInit___0(& config);
#line 80
  config.lossless = 1;
#line 81
  config.method = effort_level;
#line 83
  config.quality = 5.f * (float )effort_level;
#line 86
  ok = VP8LBitWriterInit(& tmp_bw, (size_t )(width * height >> 3));
#line 87
  tmp___0 = VP8LEncodeStream(& config, & picture, & tmp_bw);
#line 87
  __cil_tmp18 = (enum WebPEncodingError )tmp___0;
  }
#line 87
  if (ok) {
#line 87
    if ((unsigned int )__cil_tmp18 == 0U) {
#line 87
      tmp___1 = 1;
    } else {
#line 87
      tmp___1 = 0;
    }
  } else {
#line 87
    tmp___1 = 0;
  }
  {
#line 87
  ok = tmp___1;
#line 88
  WebPPictureFree(& picture);
  }
#line 89
  if (ok) {
    {
#line 90
    __cil_tmp20 = VP8LBitWriterFinish(& tmp_bw);
#line 90
    buffer = __cil_tmp20;
#line 91
    __cil_tmp22 = VP8LBitWriterNumBytes(& tmp_bw);
#line 91
    buffer_size = __cil_tmp22;
#line 92
    VP8BitWriterAppend(bw, buffer, buffer_size);
    }
  }
  {
#line 94
  VP8LBitWriterDestroy(& tmp_bw);
  }
#line 95
  if (ok) {
#line 95
    if (! bw->error_) {
#line 95
      tmp___2 = 1;
    } else {
#line 95
      tmp___2 = 0;
    }
  } else {
#line 95
    tmp___2 = 0;
  }
#line 95
  return (tmp___2);
}
}
#line 100 "/root/patchweave_new/13/src/enc/alpha.c"
static int EncodeAlphaInternal(uint8_t *data , int width , int height , int method ,
                               int filter , int reduce_levels , int effort_level ,
                               uint8_t *tmp_alpha , VP8BitWriter *bw , WebPAuxStats *stats ) 
{ 
  int ok ;
  uint8_t *alpha_src ;
  void (*filter_func)(uint8_t * , int  , int  , int  , uint8_t * ) ;
  uint8_t header ;
  size_t expected_size ;
  size_t data_size ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 106
  ok = 0;
#line 111
  data_size = (size_t )(width * height);
#line 120
  if (method == 0) {
#line 120
    tmp___4 = 1UL + data_size;
  } else {
#line 120
    tmp___4 = data_size >> 5;
  }
#line 120
  expected_size = tmp___4;
#line 123
  header = (uint8_t )(method | (filter << 2));
#line 124
  if (reduce_levels) {
#line 124
    header = (uint8_t )((int )header | (1 << 4));
  }
  {
#line 126
  VP8BitWriterInit(bw, expected_size);
#line 127
  VP8BitWriterAppend(bw, & header, (size_t )1);
#line 129
  filter_func = WebPFilters[filter];
  }
#line 130
  if ((unsigned long )filter_func != (unsigned long )((void *)0)) {
    {
#line 131
    (*filter_func)(data, width, height, width, tmp_alpha);
#line 132
    alpha_src = tmp_alpha;
    }
  } else {
#line 134
    alpha_src = data;
  }
#line 137
  if (method == 0) {
    {
#line 138
    ok = VP8BitWriterAppend(bw, alpha_src, (size_t )(width * height));
    }
#line 139
    if (ok) {
#line 139
      if (! bw->error_) {
#line 139
        tmp___5 = 1;
      } else {
#line 139
        tmp___5 = 0;
      }
    } else {
#line 139
      tmp___5 = 0;
    }
#line 139
    ok = tmp___5;
  } else {
    {
#line 141
    ok = EncodeLossless(alpha_src, width, height, effort_level, bw, stats);
#line 142
    VP8BitWriterFinish(bw);
    }
  }
#line 144
  return (ok);
}
}
#line 150 "/root/patchweave_new/13/src/enc/alpha.c"
static void CopyPlane___0(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                          int width , int height ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    __cil_tmp7 = height;
#line 152
    height --;
#line 152
    if (! (__cil_tmp7 > 0)) {
#line 152
      goto while_break;
    }
    {
#line 153
    memcpy((void *)dst, (void const   *)src, (unsigned long )width);
#line 154
    src += src_stride;
#line 155
    dst += dst_stride;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 160
  return;
}
}
#line 159 "/root/patchweave_new/13/src/enc/alpha.c"
static int EncodeAlpha(VP8Encoder *enc , int quality___0 , int method , int filter ,
                       int effort_level , uint8_t **output , size_t *output_size ) 
{ 
  WebPPicture *pic ;
  int width ;
  int height ;
  uint8_t *quant_alpha ;
  size_t data_size ;
  uint64_t sse ;
  int ok ;
  int reduce_levels ;
  void *__cil_tmp22 ;
  int alpha_levels ;
  int tmp___5 ;
  VP8BitWriter bw ;
  int test_filter ;
  uint8_t *filtered_alpha ;
  WEBP_FILTER_TYPE __cil_tmp30 ;
  void *__cil_tmp31 ;
  WebPAuxStats best_stats ;
  size_t best_score ;
  size_t __cil_tmp34 ;
  VP8BitWriter tmp_bw ;
  size_t score ;
  size_t __cil_tmp38 ;
  VP8BitWriter tmp___6 ;

  {
#line 163
  pic = enc->pic_;
#line 164
  width = pic->width;
#line 165
  height = pic->height;
#line 167
  quant_alpha = (uint8_t *)((void *)0);
#line 168
  data_size = (size_t )(width * height);
#line 169
  sse = (uint64_t )0;
#line 170
  ok = 1;
#line 171
  reduce_levels = quality___0 < 100;
#line 181
  if (quality___0 < 0) {
#line 182
    return (0);
  } else
#line 181
  if (quality___0 > 100) {
#line 182
    return (0);
  }
#line 185
  if (method < 0) {
#line 186
    return (0);
  } else
#line 185
  if (method > 1) {
#line 186
    return (0);
  }
  {
#line 189
  __cil_tmp22 = malloc(data_size);
#line 189
  quant_alpha = (uint8_t *)__cil_tmp22;
  }
#line 190
  if ((unsigned long )quant_alpha == (unsigned long )((void *)0)) {
#line 191
    return (0);
  }
  {
#line 195
  CopyPlane___0(pic->a, pic->a_stride, quant_alpha, width, width, height);
  }
#line 197
  if (reduce_levels) {
#line 201
    if (quality___0 <= 70) {
#line 201
      tmp___5 = 2 + quality___0 / 5;
    } else {
#line 201
      tmp___5 = 16 + (quality___0 - 70) * 8;
    }
    {
#line 201
    alpha_levels = tmp___5;
#line 203
    ok = QuantizeLevels(quant_alpha, width, height, alpha_levels, & sse);
    }
  }
#line 206
  if (ok) {
    {
#line 209
    filtered_alpha = (uint8_t *)((void *)0);
#line 212
    ok = EncodeAlphaInternal(quant_alpha, width, height, method, 0, reduce_levels,
                             effort_level, (uint8_t *)((void *)0), & bw, pic->stats);
    }
#line 215
    if (! ok) {
      {
#line 216
      VP8BitWriterWipeOut(& bw);
      }
#line 217
      goto End;
    }
#line 220
    if (filter == 6) {
      {
#line 221
      __cil_tmp30 = EstimateBestFilter(quant_alpha, width, height, width);
#line 221
      filter = (int )__cil_tmp30;
      }
    }
#line 224
    if (filter == 0) {
#line 225
      goto Ok;
    }
    {
#line 228
    __cil_tmp31 = malloc(data_size);
#line 228
    filtered_alpha = (uint8_t *)__cil_tmp31;
#line 229
    ok = (unsigned long )filtered_alpha != (unsigned long )((void *)0);
    }
#line 230
    if (! ok) {
#line 231
      goto End;
    }
    {
#line 237
    __cil_tmp34 = VP8BitWriterSize(& bw);
#line 237
    best_score = __cil_tmp34;
#line 239
    memset((void *)(& best_stats), 0, sizeof(best_stats));
    }
#line 240
    if ((unsigned long )pic->stats != (unsigned long )((void *)0)) {
#line 240
      best_stats = *(pic->stats);
    }
#line 241
    test_filter = 1;
    {
#line 241
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: ;
#line 241
      if (ok) {
#line 241
        if (! (test_filter <= 3)) {
#line 241
          goto while_break;
        }
      } else {
#line 241
        goto while_break;
      }
#line 245
      if (filter != 5) {
#line 245
        if (test_filter != filter) {
#line 246
          goto while_continue;
        }
      }
      {
#line 248
      ok = EncodeAlphaInternal(quant_alpha, width, height, method, test_filter, reduce_levels,
                               effort_level, filtered_alpha, & tmp_bw, pic->stats);
      }
#line 252
      if (ok) {
        {
#line 253
        __cil_tmp38 = VP8BitWriterSize(& tmp_bw);
#line 253
        score = __cil_tmp38;
        }
#line 254
        if (score < best_score) {
#line 256
          tmp___6 = tmp_bw;
#line 257
          tmp_bw = bw;
#line 258
          bw = tmp___6;
#line 259
          best_score = score;
#line 260
          if ((unsigned long )pic->stats != (unsigned long )((void *)0)) {
#line 260
            best_stats = *(pic->stats);
          }
        }
      } else {
        {
#line 263
        VP8BitWriterWipeOut(& bw);
        }
      }
      {
#line 265
      VP8BitWriterWipeOut(& tmp_bw);
#line 243
      test_filter ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 267
    if ((unsigned long )pic->stats != (unsigned long )((void *)0)) {
#line 267
      *(pic->stats) = best_stats;
    }
    Ok: 
#line 270
    if (ok) {
      {
#line 271
      *output_size = VP8BitWriterSize(& bw);
#line 272
      *output = VP8BitWriterBuf(& bw);
      }
#line 273
      if ((unsigned long )pic->stats != (unsigned long )((void *)0)) {
#line 274
        (pic->stats)->coded_size += (int )*output_size;
#line 275
        enc->sse_[3] = sse;
      }
    }
    {
#line 278
    free((void *)filtered_alpha);
    }
  }
  End: 
  {
#line 281
  free((void *)quant_alpha);
  }
#line 282
  return (ok);
}
}
#line 289 "/root/patchweave_new/13/src/enc/alpha.c"
static int CompressAlphaJob(VP8Encoder *enc , void *dummy ) 
{ 
  WebPConfig *config ;
  uint8_t *alpha_data ;
  size_t alpha_size ;
  int effort_level ;
  WEBP_FILTER_TYPE filter ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp10 ;

  {
#line 290
  config = enc->config_;
#line 291
  alpha_data = (uint8_t *)((void *)0);
#line 292
  alpha_size = (size_t )0;
#line 293
  effort_level = config->method;
#line 294
  if (config->alpha_filtering == 0) {
#line 294
    tmp___0 = 0;
  } else {
#line 294
    if (config->alpha_filtering == 1) {
#line 294
      tmp = 6;
    } else {
#line 294
      tmp = 5;
    }
#line 294
    tmp___0 = tmp;
  }
  {
#line 294
  filter = (WEBP_FILTER_TYPE )tmp___0;
#line 298
  __cil_tmp10 = EncodeAlpha(enc, config->alpha_quality, config->alpha_compression,
                            (int )filter, effort_level, & alpha_data, & alpha_size);
  }
#line 298
  if (! __cil_tmp10) {
#line 300
    return (0);
  }
#line 302
  if (alpha_size != (unsigned long )((uint32_t )alpha_size)) {
    {
#line 303
    free((void *)alpha_data);
    }
#line 304
    return (0);
  }
#line 306
  enc->alpha_data_size_ = (uint32_t )alpha_size;
#line 307
  enc->alpha_data_ = alpha_data;
#line 309
  return (1);
}
}
#line 312 "/root/patchweave_new/13/src/enc/alpha.c"
void VP8EncInitAlpha(VP8Encoder *enc ) 
{ 
  WebPWorker *worker ;

  {
  {
#line 313
  enc->has_alpha_ = WebPPictureHasTransparency(enc->pic_);
#line 314
  enc->alpha_data_ = (uint8_t *)((void *)0);
#line 315
  enc->alpha_data_size_ = (uint32_t )0;
  }
#line 316
  if (enc->thread_level_ > 0) {
    {
#line 317
    worker = & enc->alpha_worker_;
#line 318
    WebPWorkerInit(worker);
#line 319
    worker->data1 = (void *)enc;
#line 320
    worker->data2 = (void *)0;
#line 321
    worker->hook = (int (*)(void * , void * ))(& CompressAlphaJob);
    }
  }
#line 324
  return;
}
}
#line 325 "/root/patchweave_new/13/src/enc/alpha.c"
int VP8EncStartAlpha(VP8Encoder *enc ) 
{ 
  WebPWorker *worker ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 326
  if (enc->has_alpha_) {
#line 327
    if (enc->thread_level_ > 0) {
      {
#line 328
      worker = & enc->alpha_worker_;
#line 329
      __cil_tmp3 = WebPWorkerReset(worker);
      }
#line 329
      if (! __cil_tmp3) {
#line 330
        return (0);
      }
      {
#line 332
      WebPWorkerLaunch(worker);
      }
#line 333
      return (1);
    } else {
      {
#line 335
      __cil_tmp4 = CompressAlphaJob(enc, (void *)0);
      }
#line 335
      return (__cil_tmp4);
    }
  }
#line 338
  return (1);
}
}
#line 341 "/root/patchweave_new/13/src/enc/alpha.c"
int VP8EncFinishAlpha(VP8Encoder *enc ) 
{ 
  WebPWorker *worker ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 342
  if (enc->has_alpha_) {
#line 343
    if (enc->thread_level_ > 0) {
      {
#line 344
      worker = & enc->alpha_worker_;
#line 345
      __cil_tmp3 = WebPWorkerSync(worker);
      }
#line 345
      if (! __cil_tmp3) {
#line 345
        return (0);
      }
    }
  }
  {
#line 348
  __cil_tmp4 = WebPReportProgress(enc->pic_, enc->percent_ + 20, & enc->percent_);
  }
#line 348
  return (__cil_tmp4);
}
}
#line 351 "/root/patchweave_new/13/src/enc/alpha.c"
int VP8EncDeleteAlpha(VP8Encoder *enc ) 
{ 
  int ok ;
  WebPWorker *worker ;

  {
#line 352
  ok = 1;
#line 353
  if (enc->thread_level_ > 0) {
    {
#line 354
    worker = & enc->alpha_worker_;
#line 355
    ok = WebPWorkerSync(worker);
#line 356
    WebPWorkerEnd(worker);
    }
  }
  {
#line 358
  free((void *)enc->alpha_data_);
#line 359
  enc->alpha_data_ = (uint8_t *)((void *)0);
#line 360
  enc->alpha_data_size_ = (uint32_t )0;
#line 361
  enc->has_alpha_ = 0;
  }
#line 362
  return (ok);
}
}
#line 25 "/root/patchweave_new/13/src/dsp/yuv.c"
static int done  =    0;
#line 27 "/root/patchweave_new/13/src/dsp/yuv.c"
__inline static uint8_t clip___1(int v , int max_value ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 28
  if (v < 0) {
#line 28
    tmp___0 = 0;
  } else {
#line 28
    if (v > max_value) {
#line 28
      tmp = max_value;
    } else {
#line 28
      tmp = v;
    }
#line 28
    tmp___0 = tmp;
  }
#line 28
  return ((uint8_t )tmp___0);
}
}
#line 31 "/root/patchweave_new/13/src/dsp/yuv.c"
void VP8YUVInit(void) 
{ 
  int i ;
  int k ;

  {
#line 33
  if (done) {
#line 34
    return;
  }
#line 37
  i = 0;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;

#line 37
    if (! (i < 256)) {
#line 37
      goto while_break;
    }
#line 38
    VP8kVToR[i] = (int16_t )((89858 * (i - 128) + 32768) >> 16);
#line 39
    VP8kUToG[i] = -22014 * (i - 128) + 32768;
#line 40
    VP8kVToG[i] = -45773 * (i - 128);
#line 41
    VP8kUToB[i] = (int16_t )((113618 * (i - 128) + 32768) >> 16);
#line 37
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 43
  i = -227;
  {
#line 43
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 43
    if (! (i < 482)) {
#line 43
      goto while_break___0;
    }
    {
#line 44
    k = ((i - 16) * 76283 + 32768) >> 16;
#line 45
    VP8kClip[i - -227] = clip___1(k, 255);
#line 46
    VP8kClip4Bits[i - -227] = clip___1((k + 8) >> 4, 15);
#line 43
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 62
  done = 1;
#line 63
  return;
}
}
#line 56 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_empty)(void) ;
#line 58
extern int ( /* missing proto */  __builtin_ia32_emms)() ;
#line 56 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_empty)(void) 
{ 


  {
  {
#line 58
  __builtin_ia32_emms();
  }
#line 60
  return;
}
}
#line 62
__inline extern void ( __attribute__((__gnu_inline__)) _m_empty)(void) ;
#line 62 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _m_empty)(void) 
{ 


  {
  {
#line 64
  _mm_empty();
  }
#line 66
  return;
}
}
#line 69
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si64)(int __i ) ;
#line 71
extern int ( /* missing proto */  __builtin_ia32_vec_init_v2si)() ;
#line 69 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si64)(int __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 71
  __cil_tmp2 = __builtin_ia32_vec_init_v2si(__i, 0);
  }
#line 71
  return (__cil_tmp2);
}
}
#line 75
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int)(int __i ) ;
#line 75 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int)(int __i ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 77
  __cil_tmp2 = _mm_cvtsi32_si64(__i);
  }
#line 77
  return (__cil_tmp2);
}
}
#line 85
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int64)(long long __i ) ;
#line 85 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_from_int64)(long long __i ) 
{ 


  {
#line 87
  return ((__m64 )__i);
}
}
#line 112
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si32)(__m64 __i ) ;
#line 114
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v2si)() ;
#line 112 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si32)(__m64 __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 114
  __cil_tmp2 = __builtin_ia32_vec_ext_v2si(__i, 0);
  }
#line 114
  return (__cil_tmp2);
}
}
#line 118
__inline extern int ( __attribute__((__gnu_inline__)) _m_to_int)(__m64 __i ) ;
#line 118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _m_to_int)(__m64 __i ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 120
  __cil_tmp2 = _mm_cvtsi64_si32(__i);
  }
#line 120
  return (__cil_tmp2);
}
}
#line 128
__inline extern long long ( __attribute__((__gnu_inline__)) _m_to_int64)(__m64 __i ) ;
#line 128 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _m_to_int64)(__m64 __i ) 
{ 


  {
#line 130
  return ((long long )__i);
}
}
#line 151
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 153
extern int ( /* missing proto */  __builtin_ia32_packsswb)() ;
#line 151 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 153
  __cil_tmp3 = __builtin_ia32_packsswb(__m1, __m2);
  }
#line 153
  return (__cil_tmp3);
}
}
#line 157
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packsswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 157 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packsswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 159
  __cil_tmp3 = _mm_packs_pi16(__m1, __m2);
  }
#line 159
  return (__cil_tmp3);
}
}
#line 166
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 168
extern int ( /* missing proto */  __builtin_ia32_packssdw)() ;
#line 166 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 168
  __cil_tmp3 = __builtin_ia32_packssdw(__m1, __m2);
  }
#line 168
  return (__cil_tmp3);
}
}
#line 172
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packssdw)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 172 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packssdw)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 174
  __cil_tmp3 = _mm_packs_pi32(__m1, __m2);
  }
#line 174
  return (__cil_tmp3);
}
}
#line 181
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pu16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 183
extern int ( /* missing proto */  __builtin_ia32_packuswb)() ;
#line 181 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_packs_pu16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 183
  __cil_tmp3 = __builtin_ia32_packuswb(__m1, __m2);
  }
#line 183
  return (__cil_tmp3);
}
}
#line 187
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packuswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 187 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_packuswb)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 189
  __cil_tmp3 = _mm_packs_pu16(__m1, __m2);
  }
#line 189
  return (__cil_tmp3);
}
}
#line 195
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) ;
#line 197
extern int ( /* missing proto */  __builtin_ia32_punpckhbw)() ;
#line 195 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 197
  __cil_tmp3 = __builtin_ia32_punpckhbw(__m1, __m2);
  }
#line 197
  return (__cil_tmp3);
}
}
#line 201
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 201 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 203
  __cil_tmp3 = _mm_unpackhi_pi8(__m1, __m2);
  }
#line 203
  return (__cil_tmp3);
}
}
#line 209
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 211
extern int ( /* missing proto */  __builtin_ia32_punpckhwd)() ;
#line 209 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 211
  __cil_tmp3 = __builtin_ia32_punpckhwd(__m1, __m2);
  }
#line 211
  return (__cil_tmp3);
}
}
#line 215
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 215 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 217
  __cil_tmp3 = _mm_unpackhi_pi16(__m1, __m2);
  }
#line 217
  return (__cil_tmp3);
}
}
#line 223
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 225
extern int ( /* missing proto */  __builtin_ia32_punpckhdq)() ;
#line 223 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpackhi_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 225
  __cil_tmp3 = __builtin_ia32_punpckhdq(__m1, __m2);
  }
#line 225
  return (__cil_tmp3);
}
}
#line 229
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhdq)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 229 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckhdq)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 231
  __cil_tmp3 = _mm_unpackhi_pi32(__m1, __m2);
  }
#line 231
  return (__cil_tmp3);
}
}
#line 237
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) ;
#line 239
extern int ( /* missing proto */  __builtin_ia32_punpcklbw)() ;
#line 237 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi8)(__m64 __m1 ,
                                                                          __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 239
  __cil_tmp3 = __builtin_ia32_punpcklbw(__m1, __m2);
  }
#line 239
  return (__cil_tmp3);
}
}
#line 243
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 243 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklbw)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 245
  __cil_tmp3 = _mm_unpacklo_pi8(__m1, __m2);
  }
#line 245
  return (__cil_tmp3);
}
}
#line 251
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 253
extern int ( /* missing proto */  __builtin_ia32_punpcklwd)() ;
#line 251 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi16)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 253
  __cil_tmp3 = __builtin_ia32_punpcklwd(__m1, __m2);
  }
#line 253
  return (__cil_tmp3);
}
}
#line 257
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 257 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpcklwd)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 259
  __cil_tmp3 = _mm_unpacklo_pi16(__m1, __m2);
  }
#line 259
  return (__cil_tmp3);
}
}
#line 265
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) ;
#line 267
extern int ( /* missing proto */  __builtin_ia32_punpckldq)() ;
#line 265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_unpacklo_pi32)(__m64 __m1 ,
                                                                           __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_ia32_punpckldq(__m1, __m2);
  }
#line 267
  return (__cil_tmp3);
}
}
#line 271
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckldq)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 271 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_punpckldq)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 273
  __cil_tmp3 = _mm_unpacklo_pi32(__m1, __m2);
  }
#line 273
  return (__cil_tmp3);
}
}
#line 278
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 280
extern int ( /* missing proto */  __builtin_ia32_paddb)() ;
#line 278 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 280
  __cil_tmp3 = __builtin_ia32_paddb(__m1, __m2);
  }
#line 280
  return (__cil_tmp3);
}
}
#line 284
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddb)(__m64 __m1 , __m64 __m2 ) ;
#line 284 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 286
  __cil_tmp3 = _mm_add_pi8(__m1, __m2);
  }
#line 286
  return (__cil_tmp3);
}
}
#line 291
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 293
extern int ( /* missing proto */  __builtin_ia32_paddw)() ;
#line 291 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 293
  __cil_tmp3 = __builtin_ia32_paddw(__m1, __m2);
  }
#line 293
  return (__cil_tmp3);
}
}
#line 297
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddw)(__m64 __m1 , __m64 __m2 ) ;
#line 297 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 299
  __cil_tmp3 = _mm_add_pi16(__m1, __m2);
  }
#line 299
  return (__cil_tmp3);
}
}
#line 304
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 306
extern int ( /* missing proto */  __builtin_ia32_paddd)() ;
#line 304 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 306
  __cil_tmp3 = __builtin_ia32_paddd(__m1, __m2);
  }
#line 306
  return (__cil_tmp3);
}
}
#line 310
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddd)(__m64 __m1 , __m64 __m2 ) ;
#line 310 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 312
  __cil_tmp3 = _mm_add_pi32(__m1, __m2);
  }
#line 312
  return (__cil_tmp3);
}
}
#line 323
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 325
extern int ( /* missing proto */  __builtin_ia32_paddq)() ;
#line 323 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_add_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 325
  __cil_tmp3 = __builtin_ia32_paddq(__m1, __m2);
  }
#line 325
  return (__cil_tmp3);
}
}
#line 335
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 337
extern int ( /* missing proto */  __builtin_ia32_paddsb)() ;
#line 335 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 337
  __cil_tmp3 = __builtin_ia32_paddsb(__m1, __m2);
  }
#line 337
  return (__cil_tmp3);
}
}
#line 341
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsb)(__m64 __m1 , __m64 __m2 ) ;
#line 341 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 343
  __cil_tmp3 = _mm_adds_pi8(__m1, __m2);
  }
#line 343
  return (__cil_tmp3);
}
}
#line 349
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 351
extern int ( /* missing proto */  __builtin_ia32_paddsw)() ;
#line 349 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 351
  __cil_tmp3 = __builtin_ia32_paddsw(__m1, __m2);
  }
#line 351
  return (__cil_tmp3);
}
}
#line 355
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsw)(__m64 __m1 , __m64 __m2 ) ;
#line 355 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddsw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 357
  __cil_tmp3 = _mm_adds_pi16(__m1, __m2);
  }
#line 357
  return (__cil_tmp3);
}
}
#line 363
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 365
extern int ( /* missing proto */  __builtin_ia32_paddusb)() ;
#line 363 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 365
  __cil_tmp3 = __builtin_ia32_paddusb(__m1, __m2);
  }
#line 365
  return (__cil_tmp3);
}
}
#line 369
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusb)(__m64 __m1 , __m64 __m2 ) ;
#line 369 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 371
  __cil_tmp3 = _mm_adds_pu8(__m1, __m2);
  }
#line 371
  return (__cil_tmp3);
}
}
#line 377
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 379
extern int ( /* missing proto */  __builtin_ia32_paddusw)() ;
#line 377 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_adds_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 379
  __cil_tmp3 = __builtin_ia32_paddusw(__m1, __m2);
  }
#line 379
  return (__cil_tmp3);
}
}
#line 383
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusw)(__m64 __m1 , __m64 __m2 ) ;
#line 383 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_paddusw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 385
  __cil_tmp3 = _mm_adds_pu16(__m1, __m2);
  }
#line 385
  return (__cil_tmp3);
}
}
#line 390
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 392
extern int ( /* missing proto */  __builtin_ia32_psubb)() ;
#line 390 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi8)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 392
  __cil_tmp3 = __builtin_ia32_psubb(__m1, __m2);
  }
#line 392
  return (__cil_tmp3);
}
}
#line 396
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubb)(__m64 __m1 , __m64 __m2 ) ;
#line 396 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 398
  __cil_tmp3 = _mm_sub_pi8(__m1, __m2);
  }
#line 398
  return (__cil_tmp3);
}
}
#line 403
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 405
extern int ( /* missing proto */  __builtin_ia32_psubw)() ;
#line 403 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi16)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 405
  __cil_tmp3 = __builtin_ia32_psubw(__m1, __m2);
  }
#line 405
  return (__cil_tmp3);
}
}
#line 409
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubw)(__m64 __m1 , __m64 __m2 ) ;
#line 409 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 411
  __cil_tmp3 = _mm_sub_pi16(__m1, __m2);
  }
#line 411
  return (__cil_tmp3);
}
}
#line 416
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 418
extern int ( /* missing proto */  __builtin_ia32_psubd)() ;
#line 416 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_pi32)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 418
  __cil_tmp3 = __builtin_ia32_psubd(__m1, __m2);
  }
#line 418
  return (__cil_tmp3);
}
}
#line 422
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubd)(__m64 __m1 , __m64 __m2 ) ;
#line 422 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 424
  __cil_tmp3 = _mm_sub_pi32(__m1, __m2);
  }
#line 424
  return (__cil_tmp3);
}
}
#line 435
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 437
extern int ( /* missing proto */  __builtin_ia32_psubq)() ;
#line 435 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sub_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 437
  __cil_tmp3 = __builtin_ia32_psubq(__m1, __m2);
  }
#line 437
  return (__cil_tmp3);
}
}
#line 447
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 449
extern int ( /* missing proto */  __builtin_ia32_psubsb)() ;
#line 447 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 449
  __cil_tmp3 = __builtin_ia32_psubsb(__m1, __m2);
  }
#line 449
  return (__cil_tmp3);
}
}
#line 453
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsb)(__m64 __m1 , __m64 __m2 ) ;
#line 453 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = _mm_subs_pi8(__m1, __m2);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 461
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 463
extern int ( /* missing proto */  __builtin_ia32_psubsw)() ;
#line 461 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 463
  __cil_tmp3 = __builtin_ia32_psubsw(__m1, __m2);
  }
#line 463
  return (__cil_tmp3);
}
}
#line 467
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsw)(__m64 __m1 , __m64 __m2 ) ;
#line 467 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubsw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 469
  __cil_tmp3 = _mm_subs_pi16(__m1, __m2);
  }
#line 469
  return (__cil_tmp3);
}
}
#line 475
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 477
extern int ( /* missing proto */  __builtin_ia32_psubusb)() ;
#line 475 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu8)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 477
  __cil_tmp3 = __builtin_ia32_psubusb(__m1, __m2);
  }
#line 477
  return (__cil_tmp3);
}
}
#line 481
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusb)(__m64 __m1 , __m64 __m2 ) ;
#line 481 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 483
  __cil_tmp3 = _mm_subs_pu8(__m1, __m2);
  }
#line 483
  return (__cil_tmp3);
}
}
#line 489
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 491
extern int ( /* missing proto */  __builtin_ia32_psubusw)() ;
#line 489 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_subs_pu16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 491
  __cil_tmp3 = __builtin_ia32_psubusw(__m1, __m2);
  }
#line 491
  return (__cil_tmp3);
}
}
#line 495
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusw)(__m64 __m1 , __m64 __m2 ) ;
#line 495 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psubusw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 497
  __cil_tmp3 = _mm_subs_pu16(__m1, __m2);
  }
#line 497
  return (__cil_tmp3);
}
}
#line 504
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_madd_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 506
extern int ( /* missing proto */  __builtin_ia32_pmaddwd)() ;
#line 504 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_madd_pi16)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 506
  __cil_tmp3 = __builtin_ia32_pmaddwd(__m1, __m2);
  }
#line 506
  return (__cil_tmp3);
}
}
#line 510
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaddwd)(__m64 __m1 , __m64 __m2 ) ;
#line 510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaddwd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 512
  __cil_tmp3 = _mm_madd_pi16(__m1, __m2);
  }
#line 512
  return (__cil_tmp3);
}
}
#line 518
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 520
extern int ( /* missing proto */  __builtin_ia32_pmulhw)() ;
#line 518 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 520
  __cil_tmp3 = __builtin_ia32_pmulhw(__m1, __m2);
  }
#line 520
  return (__cil_tmp3);
}
}
#line 524
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhw)(__m64 __m1 , __m64 __m2 ) ;
#line 524 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 526
  __cil_tmp3 = _mm_mulhi_pi16(__m1, __m2);
  }
#line 526
  return (__cil_tmp3);
}
}
#line 532
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mullo_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 534
extern int ( /* missing proto */  __builtin_ia32_pmullw)() ;
#line 532 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mullo_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 534
  __cil_tmp3 = __builtin_ia32_pmullw(__m1, __m2);
  }
#line 534
  return (__cil_tmp3);
}
}
#line 538
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmullw)(__m64 __m1 , __m64 __m2 ) ;
#line 538 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmullw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 540
  __cil_tmp3 = _mm_mullo_pi16(__m1, __m2);
  }
#line 540
  return (__cil_tmp3);
}
}
#line 545
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 547
extern int ( /* missing proto */  __builtin_ia32_psllw)() ;
#line 545 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 547
  __cil_tmp3 = __builtin_ia32_psllw(__m, __count);
  }
#line 547
  return (__cil_tmp3);
}
}
#line 551
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllw)(__m64 __m , __m64 __count ) ;
#line 551 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 553
  __cil_tmp3 = _mm_sll_pi16(__m, __count);
  }
#line 553
  return (__cil_tmp3);
}
}
#line 557
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 559
extern int ( /* missing proto */  __builtin_ia32_psllwi)() ;
#line 557 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 559
  __cil_tmp3 = __builtin_ia32_psllwi(__m, __count);
  }
#line 559
  return (__cil_tmp3);
}
}
#line 563
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllwi)(__m64 __m , int __count ) ;
#line 563 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllwi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 565
  __cil_tmp3 = _mm_slli_pi16(__m, __count);
  }
#line 565
  return (__cil_tmp3);
}
}
#line 570
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 572
extern int ( /* missing proto */  __builtin_ia32_pslld)() ;
#line 570 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 572
  __cil_tmp3 = __builtin_ia32_pslld(__m, __count);
  }
#line 572
  return (__cil_tmp3);
}
}
#line 576
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslld)(__m64 __m , __m64 __count ) ;
#line 576 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslld)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 578
  __cil_tmp3 = _mm_sll_pi32(__m, __count);
  }
#line 578
  return (__cil_tmp3);
}
}
#line 582
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 584
extern int ( /* missing proto */  __builtin_ia32_pslldi)() ;
#line 582 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 584
  __cil_tmp3 = __builtin_ia32_pslldi(__m, __count);
  }
#line 584
  return (__cil_tmp3);
}
}
#line 588
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslldi)(__m64 __m , int __count ) ;
#line 588 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pslldi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 590
  __cil_tmp3 = _mm_slli_pi32(__m, __count);
  }
#line 590
  return (__cil_tmp3);
}
}
#line 595
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_si64)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 597
extern int ( /* missing proto */  __builtin_ia32_psllq)() ;
#line 595 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sll_si64)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 597
  __cil_tmp3 = __builtin_ia32_psllq(__m, __count);
  }
#line 597
  return (__cil_tmp3);
}
}
#line 601
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllq)(__m64 __m , __m64 __count ) ;
#line 601 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllq)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 603
  __cil_tmp3 = _mm_sll_si64(__m, __count);
  }
#line 603
  return (__cil_tmp3);
}
}
#line 607
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_si64)(__m64 __m ,
                                                                       int __count ) ;
#line 609
extern int ( /* missing proto */  __builtin_ia32_psllqi)() ;
#line 607 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_slli_si64)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 609
  __cil_tmp3 = __builtin_ia32_psllqi(__m, __count);
  }
#line 609
  return (__cil_tmp3);
}
}
#line 613
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllqi)(__m64 __m , int __count ) ;
#line 613 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psllqi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 615
  __cil_tmp3 = _mm_slli_si64(__m, __count);
  }
#line 615
  return (__cil_tmp3);
}
}
#line 620
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 622
extern int ( /* missing proto */  __builtin_ia32_psraw)() ;
#line 620 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 622
  __cil_tmp3 = __builtin_ia32_psraw(__m, __count);
  }
#line 622
  return (__cil_tmp3);
}
}
#line 626
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psraw)(__m64 __m , __m64 __count ) ;
#line 626 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psraw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 628
  __cil_tmp3 = _mm_sra_pi16(__m, __count);
  }
#line 628
  return (__cil_tmp3);
}
}
#line 632
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 634
extern int ( /* missing proto */  __builtin_ia32_psrawi)() ;
#line 632 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 634
  __cil_tmp3 = __builtin_ia32_psrawi(__m, __count);
  }
#line 634
  return (__cil_tmp3);
}
}
#line 638
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrawi)(__m64 __m , int __count ) ;
#line 638 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrawi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 640
  __cil_tmp3 = _mm_srai_pi16(__m, __count);
  }
#line 640
  return (__cil_tmp3);
}
}
#line 645
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 647
extern int ( /* missing proto */  __builtin_ia32_psrad)() ;
#line 645 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sra_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 647
  __cil_tmp3 = __builtin_ia32_psrad(__m, __count);
  }
#line 647
  return (__cil_tmp3);
}
}
#line 651
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrad)(__m64 __m , __m64 __count ) ;
#line 651 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrad)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 653
  __cil_tmp3 = _mm_sra_pi32(__m, __count);
  }
#line 653
  return (__cil_tmp3);
}
}
#line 657
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 659
extern int ( /* missing proto */  __builtin_ia32_psradi)() ;
#line 657 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srai_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 659
  __cil_tmp3 = __builtin_ia32_psradi(__m, __count);
  }
#line 659
  return (__cil_tmp3);
}
}
#line 663
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psradi)(__m64 __m , int __count ) ;
#line 663 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psradi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 665
  __cil_tmp3 = _mm_srai_pi32(__m, __count);
  }
#line 665
  return (__cil_tmp3);
}
}
#line 670
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi16)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 672
extern int ( /* missing proto */  __builtin_ia32_psrlw)() ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi16)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 672
  __cil_tmp3 = __builtin_ia32_psrlw(__m, __count);
  }
#line 672
  return (__cil_tmp3);
}
}
#line 676
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlw)(__m64 __m , __m64 __count ) ;
#line 676 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlw)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 678
  __cil_tmp3 = _mm_srl_pi16(__m, __count);
  }
#line 678
  return (__cil_tmp3);
}
}
#line 682
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi16)(__m64 __m ,
                                                                       int __count ) ;
#line 684
extern int ( /* missing proto */  __builtin_ia32_psrlwi)() ;
#line 682 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi16)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 684
  __cil_tmp3 = __builtin_ia32_psrlwi(__m, __count);
  }
#line 684
  return (__cil_tmp3);
}
}
#line 688
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlwi)(__m64 __m , int __count ) ;
#line 688 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlwi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 690
  __cil_tmp3 = _mm_srli_pi16(__m, __count);
  }
#line 690
  return (__cil_tmp3);
}
}
#line 695
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi32)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 697
extern int ( /* missing proto */  __builtin_ia32_psrld)() ;
#line 695 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_pi32)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 697
  __cil_tmp3 = __builtin_ia32_psrld(__m, __count);
  }
#line 697
  return (__cil_tmp3);
}
}
#line 701
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrld)(__m64 __m , __m64 __count ) ;
#line 701 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrld)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 703
  __cil_tmp3 = _mm_srl_pi32(__m, __count);
  }
#line 703
  return (__cil_tmp3);
}
}
#line 707
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi32)(__m64 __m ,
                                                                       int __count ) ;
#line 709
extern int ( /* missing proto */  __builtin_ia32_psrldi)() ;
#line 707 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_pi32)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 709
  __cil_tmp3 = __builtin_ia32_psrldi(__m, __count);
  }
#line 709
  return (__cil_tmp3);
}
}
#line 713
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrldi)(__m64 __m , int __count ) ;
#line 713 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrldi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 715
  __cil_tmp3 = _mm_srli_pi32(__m, __count);
  }
#line 715
  return (__cil_tmp3);
}
}
#line 720
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_si64)(__m64 __m ,
                                                                      __m64 __count ) ;
#line 722
extern int ( /* missing proto */  __builtin_ia32_psrlq)() ;
#line 720 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srl_si64)(__m64 __m ,
                                                                      __m64 __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 722
  __cil_tmp3 = __builtin_ia32_psrlq(__m, __count);
  }
#line 722
  return (__cil_tmp3);
}
}
#line 726
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlq)(__m64 __m , __m64 __count ) ;
#line 726 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlq)(__m64 __m , __m64 __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 728
  __cil_tmp3 = _mm_srl_si64(__m, __count);
  }
#line 728
  return (__cil_tmp3);
}
}
#line 732
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_si64)(__m64 __m ,
                                                                       int __count ) ;
#line 734
extern int ( /* missing proto */  __builtin_ia32_psrlqi)() ;
#line 732 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_srli_si64)(__m64 __m ,
                                                                       int __count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 734
  __cil_tmp3 = __builtin_ia32_psrlqi(__m, __count);
  }
#line 734
  return (__cil_tmp3);
}
}
#line 738
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlqi)(__m64 __m , int __count ) ;
#line 738 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psrlqi)(__m64 __m , int __count ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 740
  __cil_tmp3 = _mm_srli_si64(__m, __count);
  }
#line 740
  return (__cil_tmp3);
}
}
#line 745
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_and_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 747
extern int ( /* missing proto */  __builtin_ia32_pand)() ;
#line 745 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_and_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 747
  __cil_tmp3 = __builtin_ia32_pand(__m1, __m2);
  }
#line 747
  return (__cil_tmp3);
}
}
#line 751
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pand)(__m64 __m1 , __m64 __m2 ) ;
#line 751 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pand)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 753
  __cil_tmp3 = _mm_and_si64(__m1, __m2);
  }
#line 753
  return (__cil_tmp3);
}
}
#line 759
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_andnot_si64)(__m64 __m1 ,
                                                                         __m64 __m2 ) ;
#line 761
extern int ( /* missing proto */  __builtin_ia32_pandn)() ;
#line 759 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_andnot_si64)(__m64 __m1 ,
                                                                         __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 761
  __cil_tmp3 = __builtin_ia32_pandn(__m1, __m2);
  }
#line 761
  return (__cil_tmp3);
}
}
#line 765
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pandn)(__m64 __m1 , __m64 __m2 ) ;
#line 765 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pandn)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 767
  __cil_tmp3 = _mm_andnot_si64(__m1, __m2);
  }
#line 767
  return (__cil_tmp3);
}
}
#line 772
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_or_si64)(__m64 __m1 ,
                                                                     __m64 __m2 ) ;
#line 774
extern int ( /* missing proto */  __builtin_ia32_por)() ;
#line 772 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_or_si64)(__m64 __m1 ,
                                                                     __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 774
  __cil_tmp3 = __builtin_ia32_por(__m1, __m2);
  }
#line 774
  return (__cil_tmp3);
}
}
#line 778
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_por)(__m64 __m1 , __m64 __m2 ) ;
#line 778 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_por)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 780
  __cil_tmp3 = _mm_or_si64(__m1, __m2);
  }
#line 780
  return (__cil_tmp3);
}
}
#line 785
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_xor_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) ;
#line 787
extern int ( /* missing proto */  __builtin_ia32_pxor)() ;
#line 785 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_xor_si64)(__m64 __m1 ,
                                                                      __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 787
  __cil_tmp3 = __builtin_ia32_pxor(__m1, __m2);
  }
#line 787
  return (__cil_tmp3);
}
}
#line 791
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pxor)(__m64 __m1 , __m64 __m2 ) ;
#line 791 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pxor)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 793
  __cil_tmp3 = _mm_xor_si64(__m1, __m2);
  }
#line 793
  return (__cil_tmp3);
}
}
#line 799
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 801
extern int ( /* missing proto */  __builtin_ia32_pcmpeqb)() ;
#line 799 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 801
  __cil_tmp3 = __builtin_ia32_pcmpeqb(__m1, __m2);
  }
#line 801
  return (__cil_tmp3);
}
}
#line 805
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqb)(__m64 __m1 , __m64 __m2 ) ;
#line 805 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 807
  __cil_tmp3 = _mm_cmpeq_pi8(__m1, __m2);
  }
#line 807
  return (__cil_tmp3);
}
}
#line 811
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) ;
#line 813
extern int ( /* missing proto */  __builtin_ia32_pcmpgtb)() ;
#line 811 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi8)(__m64 __m1 ,
                                                                       __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 813
  __cil_tmp3 = __builtin_ia32_pcmpgtb(__m1, __m2);
  }
#line 813
  return (__cil_tmp3);
}
}
#line 817
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtb)(__m64 __m1 , __m64 __m2 ) ;
#line 817 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtb)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 819
  __cil_tmp3 = _mm_cmpgt_pi8(__m1, __m2);
  }
#line 819
  return (__cil_tmp3);
}
}
#line 825
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 827
extern int ( /* missing proto */  __builtin_ia32_pcmpeqw)() ;
#line 825 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 827
  __cil_tmp3 = __builtin_ia32_pcmpeqw(__m1, __m2);
  }
#line 827
  return (__cil_tmp3);
}
}
#line 831
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqw)(__m64 __m1 , __m64 __m2 ) ;
#line 831 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 833
  __cil_tmp3 = _mm_cmpeq_pi16(__m1, __m2);
  }
#line 833
  return (__cil_tmp3);
}
}
#line 837
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 839
extern int ( /* missing proto */  __builtin_ia32_pcmpgtw)() ;
#line 837 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi16)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 839
  __cil_tmp3 = __builtin_ia32_pcmpgtw(__m1, __m2);
  }
#line 839
  return (__cil_tmp3);
}
}
#line 843
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtw)(__m64 __m1 , __m64 __m2 ) ;
#line 843 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtw)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 845
  __cil_tmp3 = _mm_cmpgt_pi16(__m1, __m2);
  }
#line 845
  return (__cil_tmp3);
}
}
#line 851
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 853
extern int ( /* missing proto */  __builtin_ia32_pcmpeqd)() ;
#line 851 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpeq_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 853
  __cil_tmp3 = __builtin_ia32_pcmpeqd(__m1, __m2);
  }
#line 853
  return (__cil_tmp3);
}
}
#line 857
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqd)(__m64 __m1 , __m64 __m2 ) ;
#line 857 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpeqd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 859
  __cil_tmp3 = _mm_cmpeq_pi32(__m1, __m2);
  }
#line 859
  return (__cil_tmp3);
}
}
#line 863
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) ;
#line 865
extern int ( /* missing proto */  __builtin_ia32_pcmpgtd)() ;
#line 863 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cmpgt_pi32)(__m64 __m1 ,
                                                                        __m64 __m2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 865
  __cil_tmp3 = __builtin_ia32_pcmpgtd(__m1, __m2);
  }
#line 865
  return (__cil_tmp3);
}
}
#line 869
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtd)(__m64 __m1 , __m64 __m2 ) ;
#line 869 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pcmpgtd)(__m64 __m1 , __m64 __m2 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 871
  __cil_tmp3 = _mm_cmpgt_pi32(__m1, __m2);
  }
#line 871
  return (__cil_tmp3);
}
}
#line 876
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setzero_si64)(void) ;
#line 876 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setzero_si64)(void) 
{ 


  {
#line 878
  return ((__m64 )0LL);
}
}
#line 883
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi32)(int __i1 , int __i0 ) ;
#line 883 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi32)(int __i1 , int __i0 ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 885
  __cil_tmp3 = __builtin_ia32_vec_init_v2si(__i0, __i1);
  }
#line 885
  return (__cil_tmp3);
}
}
#line 890
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi16)(short __w3 ,
                                                                      short __w2 ,
                                                                      short __w1 ,
                                                                      short __w0 ) ;
#line 892
extern int ( /* missing proto */  __builtin_ia32_vec_init_v4hi)() ;
#line 890 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi16)(short __w3 ,
                                                                      short __w2 ,
                                                                      short __w1 ,
                                                                      short __w0 ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 892
  __cil_tmp5 = __builtin_ia32_vec_init_v4hi((int )__w0, (int )__w1, (int )__w2, (int )__w3);
  }
#line 892
  return (__cil_tmp5);
}
}
#line 897
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi8)(char __b7 , char __b6 ,
                                                                     char __b5 , char __b4 ,
                                                                     char __b3 , char __b2 ,
                                                                     char __b1 , char __b0 ) ;
#line 900
extern int ( /* missing proto */  __builtin_ia32_vec_init_v8qi)() ;
#line 897 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set_pi8)(char __b7 , char __b6 ,
                                                                     char __b5 , char __b4 ,
                                                                     char __b3 , char __b2 ,
                                                                     char __b1 , char __b0 ) 
{ 
  int __cil_tmp9 ;

  {
  {
#line 900
  __cil_tmp9 = __builtin_ia32_vec_init_v8qi((int )__b0, (int )__b1, (int )__b2, (int )__b3,
                                            (int )__b4, (int )__b5, (int )__b6, (int )__b7);
  }
#line 900
  return (__cil_tmp9);
}
}
#line 906
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi32)(int __i0 ,
                                                                       int __i1 ) ;
#line 906 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi32)(int __i0 ,
                                                                       int __i1 ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 908
  __cil_tmp3 = _mm_set_pi32(__i1, __i0);
  }
#line 908
  return (__cil_tmp3);
}
}
#line 912
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi16)(short __w0 ,
                                                                       short __w1 ,
                                                                       short __w2 ,
                                                                       short __w3 ) ;
#line 912 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi16)(short __w0 ,
                                                                       short __w1 ,
                                                                       short __w2 ,
                                                                       short __w3 ) 
{ 
  __m64 __cil_tmp5 ;

  {
  {
#line 914
  __cil_tmp5 = _mm_set_pi16(__w3, __w2, __w1, __w0);
  }
#line 914
  return (__cil_tmp5);
}
}
#line 918
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi8)(char __b0 ,
                                                                      char __b1 ,
                                                                      char __b2 ,
                                                                      char __b3 ,
                                                                      char __b4 ,
                                                                      char __b5 ,
                                                                      char __b6 ,
                                                                      char __b7 ) ;
#line 918 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_setr_pi8)(char __b0 ,
                                                                      char __b1 ,
                                                                      char __b2 ,
                                                                      char __b3 ,
                                                                      char __b4 ,
                                                                      char __b5 ,
                                                                      char __b6 ,
                                                                      char __b7 ) 
{ 
  __m64 __cil_tmp9 ;

  {
  {
#line 921
  __cil_tmp9 = _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
  }
#line 921
  return (__cil_tmp9);
}
}
#line 926
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi32)(int __i ) ;
#line 926 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi32)(int __i ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 928
  __cil_tmp2 = _mm_set_pi32(__i, __i);
  }
#line 928
  return (__cil_tmp2);
}
}
#line 933
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi16)(short __w ) ;
#line 933 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi16)(short __w ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 935
  __cil_tmp2 = _mm_set_pi16(__w, __w, __w, __w);
  }
#line 935
  return (__cil_tmp2);
}
}
#line 940
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi8)(char __b ) ;
#line 940 "/usr/lib/gcc/x86_64-linux-gnu/8/include/mmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_set1_pi8)(char __b ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 942
  __cil_tmp2 = _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
  }
#line 942
  return (__cil_tmp2);
}
}
#line 52 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_prefetch)(void const   *__P ,
                                                                     enum _mm_hint __I ) ;
#line 52 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_prefetch)(void const   *__P ,
                                                                     enum _mm_hint __I ) 
{ 


  {
#line 57
  return;
}
}
#line 110
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_undefined_ps)(void) ;
#line 110 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_undefined_ps)(void) 
{ 
  __m128 __Y ;

  {
#line 112
  __Y = __Y;
#line 113
  return (__Y);
}
}
#line 118
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_setzero_ps)(void) ;
#line 118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_setzero_ps)(void) 
{ 
  __m128 tmp ;

  {
#line 120
  return (tmp);
}
}
#line 128
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 128 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 133
  return;
}
}
#line 152
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ss)(__m128 __A ) ;
#line 154
extern int ( /* missing proto */  __builtin_ia32_sqrtss)() ;
#line 152 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 154
  __cil_tmp2 = __builtin_ia32_sqrtss(__A);
  }
#line 154
  return (__cil_tmp2);
}
}
#line 158
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ss)(__m128 __A ) ;
#line 160
extern int ( /* missing proto */  __builtin_ia32_rcpss)() ;
#line 158 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 160
  __cil_tmp2 = __builtin_ia32_rcpss(__A);
  }
#line 160
  return (__cil_tmp2);
}
}
#line 164
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ss)(__m128 __A ) ;
#line 166
extern int ( /* missing proto */  __builtin_ia32_rsqrtss)() ;
#line 164 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ss)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 166
  __cil_tmp2 = __builtin_ia32_rsqrtss(__A);
  }
#line 166
  return (__cil_tmp2);
}
}
#line 170
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 172
extern int ( /* missing proto */  __builtin_ia32_minss)() ;
#line 170 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 172
  __cil_tmp3 = __builtin_ia32_minss(__A, __B);
  }
#line 172
  return (__cil_tmp3);
}
}
#line 176
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 178
extern int ( /* missing proto */  __builtin_ia32_maxss)() ;
#line 176 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 178
  __cil_tmp3 = __builtin_ia32_maxss(__A, __B);
  }
#line 178
  return (__cil_tmp3);
}
}
#line 184
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 184 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_add_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 186
  return (__A + __B);
}
}
#line 190
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sub_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 190 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sub_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 192
  return (__A - __B);
}
}
#line 196
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_mul_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 196 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_mul_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 198
  return (__A * __B);
}
}
#line 202
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_div_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 202 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_div_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 


  {
#line 204
  return (__A / __B);
}
}
#line 208
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ps)(__m128 __A ) ;
#line 210
extern int ( /* missing proto */  __builtin_ia32_sqrtps)() ;
#line 208 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_sqrt_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 210
  __cil_tmp2 = __builtin_ia32_sqrtps(__A);
  }
#line 210
  return (__cil_tmp2);
}
}
#line 214
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ps)(__m128 __A ) ;
#line 216
extern int ( /* missing proto */  __builtin_ia32_rcpps)() ;
#line 214 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rcp_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 216
  __cil_tmp2 = __builtin_ia32_rcpps(__A);
  }
#line 216
  return (__cil_tmp2);
}
}
#line 220
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ps)(__m128 __A ) ;
#line 222
extern int ( /* missing proto */  __builtin_ia32_rsqrtps)() ;
#line 220 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_rsqrt_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 222
  __cil_tmp2 = __builtin_ia32_rsqrtps(__A);
  }
#line 222
  return (__cil_tmp2);
}
}
#line 226
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 228
extern int ( /* missing proto */  __builtin_ia32_minps)() ;
#line 226 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_min_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 228
  __cil_tmp3 = __builtin_ia32_minps(__A, __B);
  }
#line 228
  return (__cil_tmp3);
}
}
#line 232
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ps)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_max_ps)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  float __attribute__((__vector_size__(16)))  __cil_tmp3 ;
  float __attribute__((____vector_size____(16)))  tmp ;

  {
  {
#line 234
  tmp = __builtin_ia32_maxps((float __attribute__((____vector_size____(16)))  )__A,
                             (float __attribute__((____vector_size____(16)))  )__B);
#line 234
  __cil_tmp3 = (float __attribute__((__vector_size__(16)))  )tmp;
  }
#line 234
  return ((__m128 )__cil_tmp3);
}
}
#line 268
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 270
extern int ( /* missing proto */  __builtin_ia32_cmpeqss)() ;
#line 268 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 270
  __cil_tmp3 = __builtin_ia32_cmpeqss(__A, __B);
  }
#line 270
  return (__cil_tmp3);
}
}
#line 274
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 276
extern int ( /* missing proto */  __builtin_ia32_cmpltss)() ;
#line 274 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 276
  __cil_tmp3 = __builtin_ia32_cmpltss(__A, __B);
  }
#line 276
  return (__cil_tmp3);
}
}
#line 280
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 282
extern int ( /* missing proto */  __builtin_ia32_cmpless)() ;
#line 280 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 282
  __cil_tmp3 = __builtin_ia32_cmpless(__A, __B);
  }
#line 282
  return (__cil_tmp3);
}
}
#line 306
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 308
extern int ( /* missing proto */  __builtin_ia32_cmpneqss)() ;
#line 306 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 308
  __cil_tmp3 = __builtin_ia32_cmpneqss(__A, __B);
  }
#line 308
  return (__cil_tmp3);
}
}
#line 312
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 314
extern int ( /* missing proto */  __builtin_ia32_cmpnltss)() ;
#line 312 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 314
  __cil_tmp3 = __builtin_ia32_cmpnltss(__A, __B);
  }
#line 314
  return (__cil_tmp3);
}
}
#line 318
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 320
extern int ( /* missing proto */  __builtin_ia32_cmpnless)() ;
#line 318 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 320
  __cil_tmp3 = __builtin_ia32_cmpnless(__A, __B);
  }
#line 320
  return (__cil_tmp3);
}
}
#line 344
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ss)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 346
extern int ( /* missing proto */  __builtin_ia32_cmpordss)() ;
#line 344 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ss)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_ia32_cmpordss(__A, __B);
  }
#line 346
  return (__cil_tmp3);
}
}
#line 350
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ss)(__m128 __A ,
                                                                          __m128 __B ) ;
#line 352
extern int ( /* missing proto */  __builtin_ia32_cmpunordss)() ;
#line 350 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ss)(__m128 __A ,
                                                                          __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 352
  __cil_tmp3 = __builtin_ia32_cmpunordss(__A, __B);
  }
#line 352
  return (__cil_tmp3);
}
}
#line 360
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 362
extern int ( /* missing proto */  __builtin_ia32_cmpeqps)() ;
#line 360 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpeq_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 362
  __cil_tmp3 = __builtin_ia32_cmpeqps(__A, __B);
  }
#line 362
  return (__cil_tmp3);
}
}
#line 366
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 368
extern int ( /* missing proto */  __builtin_ia32_cmpltps)() ;
#line 366 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmplt_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 368
  __cil_tmp3 = __builtin_ia32_cmpltps(__A, __B);
  }
#line 368
  return (__cil_tmp3);
}
}
#line 372
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ps)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 374
extern int ( /* missing proto */  __builtin_ia32_cmpleps)() ;
#line 372 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmple_ps)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 374
  __cil_tmp3 = __builtin_ia32_cmpleps(__A, __B);
  }
#line 374
  return (__cil_tmp3);
}
}
#line 390
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 392
extern int ( /* missing proto */  __builtin_ia32_cmpneqps)() ;
#line 390 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpneq_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 392
  __cil_tmp3 = __builtin_ia32_cmpneqps(__A, __B);
  }
#line 392
  return (__cil_tmp3);
}
}
#line 396
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 398
extern int ( /* missing proto */  __builtin_ia32_cmpnltps)() ;
#line 396 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnlt_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 398
  __cil_tmp3 = __builtin_ia32_cmpnltps(__A, __B);
  }
#line 398
  return (__cil_tmp3);
}
}
#line 402
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 404
extern int ( /* missing proto */  __builtin_ia32_cmpnleps)() ;
#line 402 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpnle_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 404
  __cil_tmp3 = __builtin_ia32_cmpnleps(__A, __B);
  }
#line 404
  return (__cil_tmp3);
}
}
#line 420
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ps)(__m128 __A ,
                                                                        __m128 __B ) ;
#line 422
extern int ( /* missing proto */  __builtin_ia32_cmpordps)() ;
#line 420 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpord_ps)(__m128 __A ,
                                                                        __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 422
  __cil_tmp3 = __builtin_ia32_cmpordps(__A, __B);
  }
#line 422
  return (__cil_tmp3);
}
}
#line 426
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ps)(__m128 __A ,
                                                                          __m128 __B ) ;
#line 428
extern int ( /* missing proto */  __builtin_ia32_cmpunordps)() ;
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cmpunord_ps)(__m128 __A ,
                                                                          __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 428
  __cil_tmp3 = __builtin_ia32_cmpunordps(__A, __B);
  }
#line 428
  return (__cil_tmp3);
}
}
#line 435
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 437
extern int ( /* missing proto */  __builtin_ia32_comieq)() ;
#line 435 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 437
  __cil_tmp3 = __builtin_ia32_comieq(__A, __B);
  }
#line 437
  return (__cil_tmp3);
}
}
#line 441
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 443
extern int ( /* missing proto */  __builtin_ia32_comilt)() ;
#line 441 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 443
  __cil_tmp3 = __builtin_ia32_comilt(__A, __B);
  }
#line 443
  return (__cil_tmp3);
}
}
#line 447
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 449
extern int ( /* missing proto */  __builtin_ia32_comile)() ;
#line 447 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 449
  __cil_tmp3 = __builtin_ia32_comile(__A, __B);
  }
#line 449
  return (__cil_tmp3);
}
}
#line 453
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 455
extern int ( /* missing proto */  __builtin_ia32_comigt)() ;
#line 453 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = __builtin_ia32_comigt(__A, __B);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 459
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_ss)(__m128 __A ,
                                                                     __m128 __B ) ;
#line 461
extern int ( /* missing proto */  __builtin_ia32_comige)() ;
#line 459 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_ss)(__m128 __A ,
                                                                     __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 461
  __cil_tmp3 = __builtin_ia32_comige(__A, __B);
  }
#line 461
  return (__cil_tmp3);
}
}
#line 465
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 467
extern int ( /* missing proto */  __builtin_ia32_comineq)() ;
#line 465 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 467
  __cil_tmp3 = __builtin_ia32_comineq(__A, __B);
  }
#line 467
  return (__cil_tmp3);
}
}
#line 471
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 473
extern int ( /* missing proto */  __builtin_ia32_ucomieq)() ;
#line 471 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 473
  __cil_tmp3 = __builtin_ia32_ucomieq(__A, __B);
  }
#line 473
  return (__cil_tmp3);
}
}
#line 477
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 479
extern int ( /* missing proto */  __builtin_ia32_ucomilt)() ;
#line 477 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 479
  __cil_tmp3 = __builtin_ia32_ucomilt(__A, __B);
  }
#line 479
  return (__cil_tmp3);
}
}
#line 483
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 485
extern int ( /* missing proto */  __builtin_ia32_ucomile)() ;
#line 483 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 485
  __cil_tmp3 = __builtin_ia32_ucomile(__A, __B);
  }
#line 485
  return (__cil_tmp3);
}
}
#line 489
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 491
extern int ( /* missing proto */  __builtin_ia32_ucomigt)() ;
#line 489 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 491
  __cil_tmp3 = __builtin_ia32_ucomigt(__A, __B);
  }
#line 491
  return (__cil_tmp3);
}
}
#line 495
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_ss)(__m128 __A ,
                                                                      __m128 __B ) ;
#line 497
extern int ( /* missing proto */  __builtin_ia32_ucomige)() ;
#line 495 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_ss)(__m128 __A ,
                                                                      __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 497
  __cil_tmp3 = __builtin_ia32_ucomige(__A, __B);
  }
#line 497
  return (__cil_tmp3);
}
}
#line 501
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_ss)(__m128 __A ,
                                                                       __m128 __B ) ;
#line 503
extern int ( /* missing proto */  __builtin_ia32_ucomineq)() ;
#line 501 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_ss)(__m128 __A ,
                                                                       __m128 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 503
  __cil_tmp3 = __builtin_ia32_ucomineq(__A, __B);
  }
#line 503
  return (__cil_tmp3);
}
}
#line 509
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtss_si32)(__m128 __A ) ;
#line 511
extern int ( /* missing proto */  __builtin_ia32_cvtss2si)() ;
#line 509 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtss_si32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 511
  __cil_tmp2 = __builtin_ia32_cvtss2si(__A);
  }
#line 511
  return (__cil_tmp2);
}
}
#line 515
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvt_ss2si)(__m128 __A ) ;
#line 515 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvt_ss2si)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 517
  __cil_tmp2 = _mm_cvtss_si32(__A);
  }
#line 517
  return (__cil_tmp2);
}
}
#line 526
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtss_si64)(__m128 __A ) ;
#line 528
extern int ( /* missing proto */  __builtin_ia32_cvtss2si64)() ;
#line 526 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtss_si64)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 528
  __cil_tmp2 = __builtin_ia32_cvtss2si64(__A);
  }
#line 528
  return ((long long )__cil_tmp2);
}
}
#line 542
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi32)(__m128 __A ) ;
#line 544
extern int ( /* missing proto */  __builtin_ia32_cvtps2pi)() ;
#line 542 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 544
  __cil_tmp2 = __builtin_ia32_cvtps2pi(__A);
  }
#line 544
  return (__cil_tmp2);
}
}
#line 548
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvt_ps2pi)(__m128 __A ) ;
#line 548 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvt_ps2pi)(__m128 __A ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 550
  __cil_tmp2 = _mm_cvtps_pi32(__A);
  }
#line 550
  return (__cil_tmp2);
}
}
#line 555
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttss_si32)(__m128 __A ) ;
#line 557
extern int ( /* missing proto */  __builtin_ia32_cvttss2si)() ;
#line 555 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttss_si32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 557
  __cil_tmp2 = __builtin_ia32_cvttss2si(__A);
  }
#line 557
  return (__cil_tmp2);
}
}
#line 561
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtt_ss2si)(__m128 __A ) ;
#line 561 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtt_ss2si)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 563
  __cil_tmp2 = _mm_cvttss_si32(__A);
  }
#line 563
  return (__cil_tmp2);
}
}
#line 571
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttss_si64)(__m128 __A ) ;
#line 573
extern int ( /* missing proto */  __builtin_ia32_cvttss2si64)() ;
#line 571 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttss_si64)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 573
  __cil_tmp2 = __builtin_ia32_cvttss2si64(__A);
  }
#line 573
  return ((long long )__cil_tmp2);
}
}
#line 587
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttps_pi32)(__m128 __A ) ;
#line 589
extern int ( /* missing proto */  __builtin_ia32_cvttps2pi)() ;
#line 587 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttps_pi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 589
  __cil_tmp2 = __builtin_ia32_cvttps2pi(__A);
  }
#line 589
  return (__cil_tmp2);
}
}
#line 593
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtt_ps2pi)(__m128 __A ) ;
#line 593 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtt_ps2pi)(__m128 __A ) 
{ 
  __m64 __cil_tmp2 ;

  {
  {
#line 595
  __cil_tmp2 = _mm_cvttps_pi32(__A);
  }
#line 595
  return (__cil_tmp2);
}
}
#line 600
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_ss)(__m128 __A ,
                                                                         int __B ) ;
#line 600 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi32_ss)(__m128 __A ,
                                                                         int __B ) 
{ 


  {
#line 605
  return;
}
}
#line 606
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_si2ss)(__m128 __A ,
                                                                        int __B ) ;
#line 606 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_si2ss)(__m128 __A ,
                                                                        int __B ) 
{ 
  __m128 __cil_tmp3 ;

  {
  {
#line 608
  __cil_tmp3 = _mm_cvtsi32_ss(__A, __B);
  }
#line 608
  return (__cil_tmp3);
}
}
#line 616
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi64_ss)(__m128 __A ,
                                                                         long long __B ) ;
#line 616 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsi64_ss)(__m128 __A ,
                                                                         long long __B ) 
{ 


  {
#line 621
  return;
}
}
#line 632
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32_ps)(__m128 __A ,
                                                                         __m64 __B ) ;
#line 634
extern int ( /* missing proto */  __builtin_ia32_cvtpi2ps)() ;
#line 632 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32_ps)(__m128 __A ,
                                                                         __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 634
  __cil_tmp3 = __builtin_ia32_cvtpi2ps(__A, __B);
  }
#line 634
  return (__cil_tmp3);
}
}
#line 638
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_pi2ps)(__m128 __A ,
                                                                        __m64 __B ) ;
#line 638 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvt_pi2ps)(__m128 __A ,
                                                                        __m64 __B ) 
{ 
  __m128 __cil_tmp3 ;

  {
  {
#line 640
  __cil_tmp3 = _mm_cvtpi32_ps(__A, __B);
  }
#line 640
  return (__cil_tmp3);
}
}
#line 645
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi16_ps)(__m64 __A ) ;
#line 645 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi16_ps)(__m64 __A ) 
{ 
  __v4hi __sign ;
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  __m128 __cil_tmp11 ;

  {
  {
#line 654
  __sign = __builtin_ia32_pcmpgtw((__v4hi )0LL, __A);
#line 657
  __cil_tmp9 = __builtin_ia32_punpcklwd(__A, __sign);
#line 657
  __losi = __cil_tmp9;
#line 658
  __cil_tmp10 = __builtin_ia32_punpckhwd(__A, __sign);
#line 658
  __hisi = __cil_tmp10;
#line 661
  __cil_tmp11 = _mm_setzero_ps();
#line 661
  __zero = __cil_tmp11;
#line 662
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
#line 663
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  }
#line 665
  return;
}
}
#line 670
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu16_ps)(__m64 __A ) ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu16_ps)(__m64 __A ) 
{ 
  __v2si __hisi ;
  __v2si __losi ;
  __v4sf __zero ;
  __v4sf __ra ;
  __v4sf __rb ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  __m128 __cil_tmp9 ;

  {
  {
#line 676
  __cil_tmp7 = __builtin_ia32_punpcklwd(__A, (__v4hi )0LL);
#line 676
  __losi = __cil_tmp7;
#line 677
  __cil_tmp8 = __builtin_ia32_punpckhwd(__A, (__v4hi )0LL);
#line 677
  __hisi = __cil_tmp8;
#line 680
  __cil_tmp9 = _mm_setzero_ps();
#line 680
  __zero = __cil_tmp9;
#line 681
  __ra = __builtin_ia32_cvtpi2ps(__zero, __losi);
#line 682
  __rb = __builtin_ia32_cvtpi2ps(__ra, __hisi);
  }
#line 684
  return;
}
}
#line 689
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi8_ps)(__m64 __A ) ;
#line 689 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi8_ps)(__m64 __A ) 
{ 
  __v8qi __sign ;
  int __cil_tmp4 ;
  __m128 __cil_tmp5 ;

  {
  {
#line 696
  __sign = __builtin_ia32_pcmpgtb((__v8qi )0LL, __A);
#line 699
  __cil_tmp4 = __builtin_ia32_punpcklbw(__A, __sign);
#line 699
  __A = __cil_tmp4;
#line 701
  __cil_tmp5 = _mm_cvtpi16_ps(__A);
  }
#line 701
  return (__cil_tmp5);
}
}
#line 706
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu8_ps)(__m64 __A ) ;
#line 706 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpu8_ps)(__m64 __A ) 
{ 
  int __cil_tmp2 ;
  __m128 __cil_tmp3 ;

  {
  {
#line 708
  __cil_tmp2 = __builtin_ia32_punpcklbw(__A, (__v8qi )0LL);
#line 708
  __A = __cil_tmp2;
#line 709
  __cil_tmp3 = _mm_cvtpu16_ps(__A);
  }
#line 709
  return (__cil_tmp3);
}
}
#line 714
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32x2_ps)(__m64 __A ,
                                                                           __m64 __B ) ;
#line 714 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpi32x2_ps)(__m64 __A ,
                                                                           __m64 __B ) 
{ 
  __v4sf __zero ;
  __m128 __cil_tmp4 ;
  __v4sf __sfa ;
  int __cil_tmp6 ;
  __v4sf __sfb ;
  int __cil_tmp8 ;

  {
  {
#line 716
  __cil_tmp4 = _mm_setzero_ps();
#line 716
  __zero = __cil_tmp4;
#line 717
  __cil_tmp6 = __builtin_ia32_cvtpi2ps(__zero, __A);
#line 717
  __sfa = __cil_tmp6;
#line 718
  __cil_tmp8 = __builtin_ia32_cvtpi2ps(__sfa, __B);
#line 718
  __sfb = __cil_tmp8;
  }
#line 720
  return;
}
}
#line 724
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi16)(__m128 __A ) ;
#line 724 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi16)(__m128 __A ) 
{ 
  __v4sf __hisf ;
  __v4sf __losf ;
  __v2si __hisi ;
  int __cil_tmp5 ;
  __v2si __losi ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 726
  __hisf = __A;
#line 727
  __losf = 0;
#line 728
  __cil_tmp5 = __builtin_ia32_cvtps2pi(__hisf);
#line 728
  __hisi = __cil_tmp5;
#line 729
  __cil_tmp7 = __builtin_ia32_cvtps2pi(__losf);
#line 729
  __losi = __cil_tmp7;
#line 730
  __cil_tmp8 = __builtin_ia32_packssdw(__hisi, __losi);
  }
#line 730
  return (__cil_tmp8);
}
}
#line 735
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi8)(__m128 __A ) ;
#line 735 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtps_pi8)(__m128 __A ) 
{ 
  __v4hi __tmp ;
  __m64 __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 737
  __cil_tmp3 = _mm_cvtps_pi16(__A);
#line 737
  __tmp = __cil_tmp3;
#line 738
  __cil_tmp4 = __builtin_ia32_packsswb(__tmp, (__v4hi )0LL);
  }
#line 738
  return (__cil_tmp4);
}
}
#line 744
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_shuffle_ps)(__m128 __A ,
                                                                         __m128 __B ,
                                                                         int __mask ) ;
#line 744 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_shuffle_ps)(__m128 __A ,
                                                                         __m128 __B ,
                                                                         int __mask ) 
{ 


  {
#line 746
  return (0);
}
}
#line 771
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadh_pi)(__m128 __A ,
                                                                       __m64 *__P ) ;
#line 771 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadh_pi)(__m128 __A ,
                                                                       __m64 *__P ) 
{ 


  {
#line 776
  return;
}
}
#line 778
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeh_pi)(__m64 *__P ,
                                                                      __m128 __A ) ;
#line 780
extern int ( /* missing proto */  __builtin_ia32_storehps)() ;
#line 778 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeh_pi)(__m64 *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 780
  __builtin_ia32_storehps(__P, __A);
  }
#line 782
  return;
}
}
#line 807
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pi)(__m64 *__P ,
                                                                      __m128 __A ) ;
#line 809
extern int ( /* missing proto */  __builtin_ia32_storelps)() ;
#line 807 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pi)(__m64 *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 809
  __builtin_ia32_storelps(__P, __A);
  }
#line 811
  return;
}
}
#line 814
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_ps)(__m128 __A ) ;
#line 816
extern int ( /* missing proto */  __builtin_ia32_movmskps)() ;
#line 814 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_ps)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 816
  __cil_tmp2 = __builtin_ia32_movmskps(__A);
  }
#line 816
  return (__cil_tmp2);
}
}
#line 821
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) ;
#line 823
extern int ( /* missing proto */  __builtin_ia32_stmxcsr)() ;
#line 821
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) ;
#line 821 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _mm_getcsr)(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 823
  __cil_tmp1 = __builtin_ia32_stmxcsr();
  }
#line 823
  return ((unsigned int )__cil_tmp1);
}
}
#line 828
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _MM_GET_EXCEPTION_STATE)(void) ;
#line 828 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) _MM_GET_EXCEPTION_STATE)(void) 
{ 


  {
#line 833
  return (0U);
}
}
#line 853
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) ;
#line 855
extern int ( /* missing proto */  __builtin_ia32_ldmxcsr)() ;
#line 853
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) ;
#line 853 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_setcsr)(unsigned int __I ) 
{ 


  {
  {
#line 855
  __builtin_ia32_ldmxcsr(__I);
  }
#line 857
  return;
}
}
#line 860
__inline extern void ( __attribute__((__gnu_inline__)) _MM_SET_EXCEPTION_STATE)(unsigned int __mask ) ;
#line 860 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _MM_SET_EXCEPTION_STATE)(unsigned int __mask ) 
{ 


  {
#line 865
  return;
}
}
#line 885
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ss)(float __F ) ;
#line 885 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ss)(float __F ) 
{ 
  __v4sf tmp ;

  {
#line 887
  return (tmp);
}
}
#line 898
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps1)(float __F ) ;
#line 898 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps1)(float __F ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 900
  __cil_tmp2 = _mm_set_ss(__F);
  }
#line 900
  return (__cil_tmp2);
}
}
#line 905
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ss)(float const   *__P ) ;
#line 905 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ss)(float const   *__P ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 907
  __cil_tmp2 = _mm_set_ss((float )*__P);
  }
#line 907
  return (__cil_tmp2);
}
}
#line 918
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps1)(float const   *__P ) ;
#line 918 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps1)(float const   *__P ) 
{ 
  __m128 __cil_tmp2 ;

  {
  {
#line 920
  __cil_tmp2 = _mm_load_ss(__P);
  }
#line 920
  return (__cil_tmp2);
}
}
#line 925
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps)(float const   *__P ) ;
#line 925 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_load_ps)(float const   *__P ) 
{ 


  {
#line 927
  return (*((__m128 *)__P));
}
}
#line 932
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadu_ps)(float const   *__P ) ;
#line 932 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadu_ps)(float const   *__P ) 
{ 


  {
#line 934
  return (*((__m128_u *)__P));
}
}
#line 939
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadr_ps)(float const   *__P ) ;
#line 942
extern int ( /* missing proto */  __builtin_ia32_shufps)() ;
#line 939 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_loadr_ps)(float const   *__P ) 
{ 
  __v4sf __tmp ;
  int __cil_tmp3 ;

  {
  {
#line 941
  __tmp = *((__v4sf *)__P);
#line 942
  __cil_tmp3 = __builtin_ia32_shufps(__tmp, __tmp, ((1 << 4) | (2 << 2)) | 3);
  }
#line 942
  return (__cil_tmp3);
}
}
#line 947
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps)(float __Z , float __Y ,
                                                                     float __X , float __W ) ;
#line 947 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_set_ps)(float __Z , float __Y ,
                                                                     float __X , float __W ) 
{ 
  __v4sf tmp ;

  {
#line 949
  return (tmp);
}
}
#line 961
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ss)(float *__P ,
                                                                     __m128 __A ) ;
#line 961 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ss)(float *__P ,
                                                                     __m128 __A ) 
{ 
  int __cil_tmp3 ;

  {
#line 963
  *__P = (float )__cil_tmp3;
#line 964
  return;
}
}
#line 967
__inline extern float ( __attribute__((__gnu_inline__)) _mm_cvtss_f32)(__m128 __A ) ;
#line 967 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern float ( __attribute__((__gnu_inline__)) _mm_cvtss_f32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 969
  return ((float )__cil_tmp2);
}
}
#line 974
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps)(float *__P ,
                                                                     __m128 __A ) ;
#line 974 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps)(float *__P ,
                                                                     __m128 __A ) 
{ 


  {
#line 976
  *((__m128 *)__P) = __A;
#line 977
  return;
}
}
#line 981
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 981 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
#line 983
  *((__m128_u *)__P) = __A;
#line 984
  return;
}
}
#line 988
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 988 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int __cil_tmp5 ;

  {
  {
#line 990
  __va = __A;
#line 991
  __cil_tmp5 = __builtin_ia32_shufps(__va, __va, 0);
#line 991
  __tmp = __cil_tmp5;
#line 992
  _mm_storeu_ps(__P, __tmp);
  }
#line 994
  return;
}
}
#line 996
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps1)(float *__P ,
                                                                      __m128 __A ) ;
#line 996 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_ps1)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 998
  _mm_store1_ps(__P, __A);
  }
#line 1000
  return;
}
}
#line 1003
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 1003 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 
  __v4sf __va ;
  __v4sf __tmp ;
  int __cil_tmp5 ;

  {
  {
#line 1005
  __va = __A;
#line 1006
  __cil_tmp5 = __builtin_ia32_shufps(__va, __va, ((1 << 4) | (2 << 2)) | 3);
#line 1006
  __tmp = __cil_tmp5;
#line 1007
  _mm_store_ps(__P, __tmp);
  }
#line 1009
  return;
}
}
#line 1020
__inline extern int ( __attribute__((__gnu_inline__)) _mm_extract_pi16)(__m64 __A ,
                                                                        int __N ) ;
#line 1020 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_extract_pi16)(__m64 __A ,
                                                                        int __N ) 
{ 


  {
#line 1022
  return (0);
}
}
#line 1026
__inline extern int ( __attribute__((__gnu_inline__)) _m_pextrw)(__m64 __A , int __N ) ;
#line 1026 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _m_pextrw)(__m64 __A , int __N ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1028
  __cil_tmp3 = _mm_extract_pi16(__A, __N);
  }
#line 1028
  return (__cil_tmp3);
}
}
#line 1041
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_insert_pi16)(__m64 __A ,
                                                                         int __D ,
                                                                         int __N ) ;
#line 1041 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_insert_pi16)(__m64 __A ,
                                                                         int __D ,
                                                                         int __N ) 
{ 


  {
#line 1043
  return (0);
}
}
#line 1047
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pinsrw)(__m64 __A , int __D ,
                                                                   int __N ) ;
#line 1047 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pinsrw)(__m64 __A , int __D ,
                                                                   int __N ) 
{ 
  __m64 __cil_tmp4 ;

  {
  {
#line 1049
  __cil_tmp4 = _mm_insert_pi16(__A, __D, __N);
  }
#line 1049
  return (__cil_tmp4);
}
}
#line 1061
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pi16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1063
extern int ( /* missing proto */  __builtin_ia32_pmaxsw)() ;
#line 1061 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pi16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1063
  __cil_tmp3 = __builtin_ia32_pmaxsw(__A, __B);
  }
#line 1063
  return (__cil_tmp3);
}
}
#line 1067
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxsw)(__m64 __A , __m64 __B ) ;
#line 1067 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxsw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1069
  __cil_tmp3 = _mm_max_pi16(__A, __B);
  }
#line 1069
  return (__cil_tmp3);
}
}
#line 1074
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pu8)(__m64 __A , __m64 __B ) ;
#line 1076
extern int ( /* missing proto */  __builtin_ia32_pmaxub)() ;
#line 1074 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_max_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1076
  __cil_tmp3 = __builtin_ia32_pmaxub(__A, __B);
  }
#line 1076
  return (__cil_tmp3);
}
}
#line 1080
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxub)(__m64 __A , __m64 __B ) ;
#line 1080 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmaxub)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1082
  __cil_tmp3 = _mm_max_pu8(__A, __B);
  }
#line 1082
  return (__cil_tmp3);
}
}
#line 1087
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pi16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1089
extern int ( /* missing proto */  __builtin_ia32_pminsw)() ;
#line 1087 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pi16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1089
  __cil_tmp3 = __builtin_ia32_pminsw(__A, __B);
  }
#line 1089
  return (__cil_tmp3);
}
}
#line 1093
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminsw)(__m64 __A , __m64 __B ) ;
#line 1093 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminsw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1095
  __cil_tmp3 = _mm_min_pi16(__A, __B);
  }
#line 1095
  return (__cil_tmp3);
}
}
#line 1100
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pu8)(__m64 __A , __m64 __B ) ;
#line 1102
extern int ( /* missing proto */  __builtin_ia32_pminub)() ;
#line 1100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_min_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1102
  __cil_tmp3 = __builtin_ia32_pminub(__A, __B);
  }
#line 1102
  return (__cil_tmp3);
}
}
#line 1106
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminub)(__m64 __A , __m64 __B ) ;
#line 1106 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pminub)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1108
  __cil_tmp3 = _mm_min_pu8(__A, __B);
  }
#line 1108
  return (__cil_tmp3);
}
}
#line 1113
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pi8)(__m64 __A ) ;
#line 1115
extern int ( /* missing proto */  __builtin_ia32_pmovmskb)() ;
#line 1113 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pi8)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1115
  __cil_tmp2 = __builtin_ia32_pmovmskb(__A);
  }
#line 1115
  return (__cil_tmp2);
}
}
#line 1119
__inline extern int ( __attribute__((__gnu_inline__)) _m_pmovmskb)(__m64 __A ) ;
#line 1119 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _m_pmovmskb)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1121
  __cil_tmp2 = _mm_movemask_pi8(__A);
  }
#line 1121
  return (__cil_tmp2);
}
}
#line 1127
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pu16)(__m64 __A ,
                                                                        __m64 __B ) ;
#line 1129
extern int ( /* missing proto */  __builtin_ia32_pmulhuw)() ;
#line 1127 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mulhi_pu16)(__m64 __A ,
                                                                        __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1129
  __cil_tmp3 = __builtin_ia32_pmulhuw(__A, __B);
  }
#line 1129
  return (__cil_tmp3);
}
}
#line 1133
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhuw)(__m64 __A , __m64 __B ) ;
#line 1133 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pmulhuw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1135
  __cil_tmp3 = _mm_mulhi_pu16(__A, __B);
  }
#line 1135
  return (__cil_tmp3);
}
}
#line 1142
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_shuffle_pi16)(__m64 __A ,
                                                                          int __N ) ;
#line 1142 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_shuffle_pi16)(__m64 __A ,
                                                                          int __N ) 
{ 


  {
#line 1144
  return (0);
}
}
#line 1148
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pshufw)(__m64 __A , int __N ) ;
#line 1148 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pshufw)(__m64 __A , int __N ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1150
  __cil_tmp3 = _mm_shuffle_pi16(__A, __N);
  }
#line 1150
  return (__cil_tmp3);
}
}
#line 1163
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmove_si64)(__m64 __A ,
                                                                          __m64 __N ,
                                                                          char *__P ) ;
#line 1165
extern int ( /* missing proto */  __builtin_ia32_maskmovq)() ;
#line 1163 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmove_si64)(__m64 __A ,
                                                                          __m64 __N ,
                                                                          char *__P ) 
{ 


  {
  {
#line 1165
  __builtin_ia32_maskmovq(__A, __N, __P);
  }
#line 1167
  return;
}
}
#line 1169
__inline extern void ( __attribute__((__gnu_inline__)) _m_maskmovq)(__m64 __A , __m64 __N ,
                                                                    char *__P ) ;
#line 1169 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _m_maskmovq)(__m64 __A , __m64 __N ,
                                                                    char *__P ) 
{ 


  {
  {
#line 1171
  _mm_maskmove_si64(__A, __N, __P);
  }
#line 1173
  return;
}
}
#line 1176
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu8)(__m64 __A , __m64 __B ) ;
#line 1178
extern int ( /* missing proto */  __builtin_ia32_pavgb)() ;
#line 1176 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1178
  __cil_tmp3 = __builtin_ia32_pavgb(__A, __B);
  }
#line 1178
  return (__cil_tmp3);
}
}
#line 1182
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgb)(__m64 __A , __m64 __B ) ;
#line 1182 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgb)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1184
  __cil_tmp3 = _mm_avg_pu8(__A, __B);
  }
#line 1184
  return (__cil_tmp3);
}
}
#line 1189
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu16)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1191
extern int ( /* missing proto */  __builtin_ia32_pavgw)() ;
#line 1189 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_avg_pu16)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1191
  __cil_tmp3 = __builtin_ia32_pavgw(__A, __B);
  }
#line 1191
  return (__cil_tmp3);
}
}
#line 1195
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgw)(__m64 __A , __m64 __B ) ;
#line 1195 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_pavgw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1197
  __cil_tmp3 = _mm_avg_pu16(__A, __B);
  }
#line 1197
  return (__cil_tmp3);
}
}
#line 1204
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sad_pu8)(__m64 __A , __m64 __B ) ;
#line 1206
extern int ( /* missing proto */  __builtin_ia32_psadbw)() ;
#line 1204 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_sad_pu8)(__m64 __A , __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1206
  __cil_tmp3 = __builtin_ia32_psadbw(__A, __B);
  }
#line 1206
  return (__cil_tmp3);
}
}
#line 1210
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psadbw)(__m64 __A , __m64 __B ) ;
#line 1210 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _m_psadbw)(__m64 __A , __m64 __B ) 
{ 
  __m64 __cil_tmp3 ;

  {
  {
#line 1212
  __cil_tmp3 = _mm_sad_pu8(__A, __B);
  }
#line 1212
  return (__cil_tmp3);
}
}
#line 1217
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pi)(__m64 *__P ,
                                                                      __m64 __A ) ;
#line 1217 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pi)(__m64 *__P ,
                                                                      __m64 __A ) 
{ 


  {
#line 1222
  return;
}
}
#line 1224
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_ps)(float *__P ,
                                                                      __m128 __A ) ;
#line 1226
extern int ( /* missing proto */  __builtin_ia32_movntps)() ;
#line 1224 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_ps)(float *__P ,
                                                                      __m128 __A ) 
{ 


  {
  {
#line 1226
  __builtin_ia32_movntps(__P, __A);
  }
#line 1228
  return;
}
}
#line 1232
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) ;
#line 1234
extern int ( /* missing proto */  __builtin_ia32_sfence)() ;
#line 1232
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) ;
#line 1232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_sfence)(void) 
{ 


  {
  {
#line 1234
  __builtin_ia32_sfence();
  }
#line 1236
  return;
}
}
#line 1265
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_pause)(void) ;
#line 1267
extern int ( /* missing proto */  __builtin_ia32_pause)() ;
#line 1265
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_pause)(void) ;
#line 1265 "/usr/lib/gcc/x86_64-linux-gnu/8/include/xmmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_pause)(void) 
{ 


  {
  {
#line 1267
  __builtin_ia32_pause();
  }
#line 1269
  return;
}
}
#line 66 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_sd)(double __F ) ;
#line 66 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_sd)(double __F ) 
{ 
  __m128d tmp ;

  {
#line 68
  return (tmp);
}
}
#line 79
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd1)(double __F ) ;
#line 79 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd1)(double __F ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 81
  __cil_tmp2 = _mm_set_sd(__F);
  }
#line 81
  return (__cil_tmp2);
}
}
#line 86
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd)(double __W ,
                                                                      double __X ) ;
#line 86 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_set_pd)(double __W ,
                                                                      double __X ) 
{ 
  __m128d tmp ;

  {
#line 88
  return (tmp);
}
}
#line 100
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_undefined_pd)(void) ;
#line 100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_undefined_pd)(void) 
{ 
  __m128d __Y ;

  {
#line 102
  __Y = __Y;
#line 103
  return (__Y);
}
}
#line 108
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_setzero_pd)(void) ;
#line 108 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_setzero_pd)(void) 
{ 
  __m128d tmp ;

  {
#line 110
  return (tmp);
}
}
#line 115
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_move_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 115 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_move_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 


  {
#line 120
  return;
}
}
#line 122
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd)(double const   *__P ) ;
#line 122 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd)(double const   *__P ) 
{ 


  {
#line 124
  return (*((__m128d *)__P));
}
}
#line 129
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadu_pd)(double const   *__P ) ;
#line 129 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadu_pd)(double const   *__P ) 
{ 


  {
#line 131
  return (*((__m128d_u *)__P));
}
}
#line 136
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load1_pd)(double const   *__P ) ;
#line 136 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load1_pd)(double const   *__P ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 138
  __cil_tmp2 = _mm_set_sd((double )*__P);
  }
#line 138
  return (__cil_tmp2);
}
}
#line 149
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd1)(double const   *__P ) ;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_load_pd1)(double const   *__P ) 
{ 
  __m128d __cil_tmp2 ;

  {
  {
#line 151
  __cil_tmp2 = _mm_load1_pd(__P);
  }
#line 151
  return (__cil_tmp2);
}
}
#line 156
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadr_pd)(double const   *__P ) ;
#line 159
extern int ( /* missing proto */  __builtin_ia32_shufpd)() ;
#line 156 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadr_pd)(double const   *__P ) 
{ 
  __m128d __tmp ;
  __m128d __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 158
  __cil_tmp3 = _mm_load_pd(__P);
#line 158
  __tmp = __cil_tmp3;
#line 159
  __cil_tmp4 = __builtin_ia32_shufpd(__tmp, __tmp, 1);
  }
#line 159
  return (__cil_tmp4);
}
}
#line 164
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd)(double *__P ,
                                                                     __m128d __A ) ;
#line 164 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd)(double *__P ,
                                                                     __m128d __A ) 
{ 


  {
#line 166
  *((__m128d *)__P) = __A;
#line 167
  return;
}
}
#line 171
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 171 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
#line 173
  *((__m128d_u *)__P) = __A;
#line 174
  return;
}
}
#line 178
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_sd)(double *__P ,
                                                                     __m128d __A ) ;
#line 178 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_sd)(double *__P ,
                                                                     __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
#line 180
  *__P = (double )__cil_tmp3;
#line 181
  return;
}
}
#line 184
__inline extern double ( __attribute__((__gnu_inline__)) _mm_cvtsd_f64)(__m128d __A ) ;
#line 184 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern double ( __attribute__((__gnu_inline__)) _mm_cvtsd_f64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 186
  return ((double )__cil_tmp2);
}
}
#line 190
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 190 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
  {
#line 192
  _mm_store_sd(__P, __A);
  }
#line 194
  return;
}
}
#line 205
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 205 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store1_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 207
  __cil_tmp3 = __builtin_ia32_shufpd(__A, __A, 0);
#line 207
  _mm_store_pd(__P, __cil_tmp3);
  }
#line 209
  return;
}
}
#line 211
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd1)(double *__P ,
                                                                      __m128d __A ) ;
#line 211 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_pd1)(double *__P ,
                                                                      __m128d __A ) 
{ 


  {
  {
#line 213
  _mm_store1_pd(__P, __A);
  }
#line 215
  return;
}
}
#line 218
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_pd)(double *__P ,
                                                                      __m128d __A ) ;
#line 218 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storer_pd)(double *__P ,
                                                                      __m128d __A ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 220
  __cil_tmp3 = __builtin_ia32_shufpd(__A, __A, 1);
#line 220
  _mm_store_pd(__P, __cil_tmp3);
  }
#line 222
  return;
}
}
#line 224
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si32)(__m128i __A ) ;
#line 226
extern int ( /* missing proto */  __builtin_ia32_vec_ext_v4si)() ;
#line 224 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si32)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 226
  __cil_tmp2 = __builtin_ia32_vec_ext_v4si(__A, 0);
  }
#line 226
  return (__cil_tmp2);
}
}
#line 232
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si64)(__m128i __A ) ;
#line 232 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsi128_si64)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
#line 234
  return ((long long )__cil_tmp2);
}
}
#line 246
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_add_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 246 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_add_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 248
  return (__A + __B);
}
}
#line 258
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sub_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 258 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sub_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 260
  return (__A - __B);
}
}
#line 270
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_mul_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 270 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_mul_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 272
  return (__A * __B);
}
}
#line 282
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_div_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 282 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_div_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 


  {
#line 284
  return (__A / __B);
}
}
#line 294
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_pd)(__m128d __A ) ;
#line 296
extern int ( /* missing proto */  __builtin_ia32_sqrtpd)() ;
#line 294 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_pd)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 296
  __cil_tmp2 = __builtin_ia32_sqrtpd(__A);
  }
#line 296
  return (__cil_tmp2);
}
}
#line 301
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 304
extern int ( /* missing proto */  __builtin_ia32_sqrtsd)() ;
#line 301 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_sqrt_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 
  __v2df __tmp ;
  int __cil_tmp4 ;

  {
  {
#line 303
  __tmp = 0;
#line 304
  __cil_tmp4 = __builtin_ia32_sqrtsd(__tmp);
  }
#line 304
  return (__cil_tmp4);
}
}
#line 308
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 310
extern int ( /* missing proto */  __builtin_ia32_minpd)() ;
#line 308 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 310
  __cil_tmp3 = __builtin_ia32_minpd(__A, __B);
  }
#line 310
  return (__cil_tmp3);
}
}
#line 314
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 316
extern int ( /* missing proto */  __builtin_ia32_minsd)() ;
#line 314 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_min_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 316
  __cil_tmp3 = __builtin_ia32_minsd(__A, __B);
  }
#line 316
  return (__cil_tmp3);
}
}
#line 320
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_pd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 322
extern int ( /* missing proto */  __builtin_ia32_maxpd)() ;
#line 320 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_pd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 322
  __cil_tmp3 = __builtin_ia32_maxpd(__A, __B);
  }
#line 322
  return (__cil_tmp3);
}
}
#line 326
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 328
extern int ( /* missing proto */  __builtin_ia32_maxsd)() ;
#line 326 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_max_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 328
  __cil_tmp3 = __builtin_ia32_maxsd(__A, __B);
  }
#line 328
  return (__cil_tmp3);
}
}
#line 356
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 358
extern int ( /* missing proto */  __builtin_ia32_cmpeqpd)() ;
#line 356 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 358
  __cil_tmp3 = __builtin_ia32_cmpeqpd(__A, __B);
  }
#line 358
  return (__cil_tmp3);
}
}
#line 362
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 364
extern int ( /* missing proto */  __builtin_ia32_cmpltpd)() ;
#line 362 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 364
  __cil_tmp3 = __builtin_ia32_cmpltpd(__A, __B);
  }
#line 364
  return (__cil_tmp3);
}
}
#line 368
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_pd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 370
extern int ( /* missing proto */  __builtin_ia32_cmplepd)() ;
#line 368 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_pd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 370
  __cil_tmp3 = __builtin_ia32_cmplepd(__A, __B);
  }
#line 370
  return (__cil_tmp3);
}
}
#line 386
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 388
extern int ( /* missing proto */  __builtin_ia32_cmpneqpd)() ;
#line 386 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 388
  __cil_tmp3 = __builtin_ia32_cmpneqpd(__A, __B);
  }
#line 388
  return (__cil_tmp3);
}
}
#line 392
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 394
extern int ( /* missing proto */  __builtin_ia32_cmpnltpd)() ;
#line 392 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 394
  __cil_tmp3 = __builtin_ia32_cmpnltpd(__A, __B);
  }
#line 394
  return (__cil_tmp3);
}
}
#line 398
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 400
extern int ( /* missing proto */  __builtin_ia32_cmpnlepd)() ;
#line 398 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 400
  __cil_tmp3 = __builtin_ia32_cmpnlepd(__A, __B);
  }
#line 400
  return (__cil_tmp3);
}
}
#line 416
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_pd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 418
extern int ( /* missing proto */  __builtin_ia32_cmpordpd)() ;
#line 416 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_pd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 418
  __cil_tmp3 = __builtin_ia32_cmpordpd(__A, __B);
  }
#line 418
  return (__cil_tmp3);
}
}
#line 422
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_pd)(__m128d __A ,
                                                                           __m128d __B ) ;
#line 424
extern int ( /* missing proto */  __builtin_ia32_cmpunordpd)() ;
#line 422 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_pd)(__m128d __A ,
                                                                           __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 424
  __cil_tmp3 = __builtin_ia32_cmpunordpd(__A, __B);
  }
#line 424
  return (__cil_tmp3);
}
}
#line 428
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 430
extern int ( /* missing proto */  __builtin_ia32_cmpeqsd)() ;
#line 428 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpeq_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 430
  __cil_tmp3 = __builtin_ia32_cmpeqsd(__A, __B);
  }
#line 430
  return (__cil_tmp3);
}
}
#line 434
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 436
extern int ( /* missing proto */  __builtin_ia32_cmpltsd)() ;
#line 434 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmplt_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 436
  __cil_tmp3 = __builtin_ia32_cmpltsd(__A, __B);
  }
#line 436
  return (__cil_tmp3);
}
}
#line 440
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_sd)(__m128d __A ,
                                                                        __m128d __B ) ;
#line 442
extern int ( /* missing proto */  __builtin_ia32_cmplesd)() ;
#line 440 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmple_sd)(__m128d __A ,
                                                                        __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 442
  __cil_tmp3 = __builtin_ia32_cmplesd(__A, __B);
  }
#line 442
  return (__cil_tmp3);
}
}
#line 466
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 468
extern int ( /* missing proto */  __builtin_ia32_cmpneqsd)() ;
#line 466 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpneq_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 468
  __cil_tmp3 = __builtin_ia32_cmpneqsd(__A, __B);
  }
#line 468
  return (__cil_tmp3);
}
}
#line 472
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 474
extern int ( /* missing proto */  __builtin_ia32_cmpnltsd)() ;
#line 472 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnlt_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 474
  __cil_tmp3 = __builtin_ia32_cmpnltsd(__A, __B);
  }
#line 474
  return (__cil_tmp3);
}
}
#line 478
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 480
extern int ( /* missing proto */  __builtin_ia32_cmpnlesd)() ;
#line 478 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpnle_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 480
  __cil_tmp3 = __builtin_ia32_cmpnlesd(__A, __B);
  }
#line 480
  return (__cil_tmp3);
}
}
#line 504
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_sd)(__m128d __A ,
                                                                         __m128d __B ) ;
#line 506
extern int ( /* missing proto */  __builtin_ia32_cmpordsd)() ;
#line 504 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpord_sd)(__m128d __A ,
                                                                         __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 506
  __cil_tmp3 = __builtin_ia32_cmpordsd(__A, __B);
  }
#line 506
  return (__cil_tmp3);
}
}
#line 510
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_sd)(__m128d __A ,
                                                                           __m128d __B ) ;
#line 512
extern int ( /* missing proto */  __builtin_ia32_cmpunordsd)() ;
#line 510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cmpunord_sd)(__m128d __A ,
                                                                           __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 512
  __cil_tmp3 = __builtin_ia32_cmpunordsd(__A, __B);
  }
#line 512
  return (__cil_tmp3);
}
}
#line 516
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 518
extern int ( /* missing proto */  __builtin_ia32_comisdeq)() ;
#line 516 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comieq_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 518
  __cil_tmp3 = __builtin_ia32_comisdeq(__A, __B);
  }
#line 518
  return (__cil_tmp3);
}
}
#line 522
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 524
extern int ( /* missing proto */  __builtin_ia32_comisdlt)() ;
#line 522 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comilt_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 524
  __cil_tmp3 = __builtin_ia32_comisdlt(__A, __B);
  }
#line 524
  return (__cil_tmp3);
}
}
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 530
extern int ( /* missing proto */  __builtin_ia32_comisdle)() ;
#line 528 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comile_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 530
  __cil_tmp3 = __builtin_ia32_comisdle(__A, __B);
  }
#line 530
  return (__cil_tmp3);
}
}
#line 534
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 536
extern int ( /* missing proto */  __builtin_ia32_comisdgt)() ;
#line 534 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comigt_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 536
  __cil_tmp3 = __builtin_ia32_comisdgt(__A, __B);
  }
#line 536
  return (__cil_tmp3);
}
}
#line 540
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_sd)(__m128d __A ,
                                                                     __m128d __B ) ;
#line 542
extern int ( /* missing proto */  __builtin_ia32_comisdge)() ;
#line 540 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comige_sd)(__m128d __A ,
                                                                     __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 542
  __cil_tmp3 = __builtin_ia32_comisdge(__A, __B);
  }
#line 542
  return (__cil_tmp3);
}
}
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 548
extern int ( /* missing proto */  __builtin_ia32_comisdneq)() ;
#line 546 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_comineq_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 548
  __cil_tmp3 = __builtin_ia32_comisdneq(__A, __B);
  }
#line 548
  return (__cil_tmp3);
}
}
#line 552
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 554
extern int ( /* missing proto */  __builtin_ia32_ucomisdeq)() ;
#line 552 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomieq_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 554
  __cil_tmp3 = __builtin_ia32_ucomisdeq(__A, __B);
  }
#line 554
  return (__cil_tmp3);
}
}
#line 558
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 560
extern int ( /* missing proto */  __builtin_ia32_ucomisdlt)() ;
#line 558 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomilt_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 560
  __cil_tmp3 = __builtin_ia32_ucomisdlt(__A, __B);
  }
#line 560
  return (__cil_tmp3);
}
}
#line 564
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 566
extern int ( /* missing proto */  __builtin_ia32_ucomisdle)() ;
#line 564 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomile_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 566
  __cil_tmp3 = __builtin_ia32_ucomisdle(__A, __B);
  }
#line 566
  return (__cil_tmp3);
}
}
#line 570
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 572
extern int ( /* missing proto */  __builtin_ia32_ucomisdgt)() ;
#line 570 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomigt_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 572
  __cil_tmp3 = __builtin_ia32_ucomisdgt(__A, __B);
  }
#line 572
  return (__cil_tmp3);
}
}
#line 576
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_sd)(__m128d __A ,
                                                                      __m128d __B ) ;
#line 578
extern int ( /* missing proto */  __builtin_ia32_ucomisdge)() ;
#line 576 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomige_sd)(__m128d __A ,
                                                                      __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 578
  __cil_tmp3 = __builtin_ia32_ucomisdge(__A, __B);
  }
#line 578
  return (__cil_tmp3);
}
}
#line 582
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_sd)(__m128d __A ,
                                                                       __m128d __B ) ;
#line 584
extern int ( /* missing proto */  __builtin_ia32_ucomisdneq)() ;
#line 582 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_ucomineq_sd)(__m128d __A ,
                                                                       __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 584
  __cil_tmp3 = __builtin_ia32_ucomisdneq(__A, __B);
  }
#line 584
  return (__cil_tmp3);
}
}
#line 590
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64x)(long long __q1 ,
                                                                          long long __q0 ) ;
#line 590 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64x)(long long __q1 ,
                                                                          long long __q0 ) 
{ 
  __v2di tmp ;

  {
#line 592
  return (tmp);
}
}
#line 596
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64)(__m64 __q1 ,
                                                                         __m64 __q0 ) ;
#line 596 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi64)(__m64 __q1 ,
                                                                         __m64 __q0 ) 
{ 
  __m128i __cil_tmp3 ;

  {
  {
#line 598
  __cil_tmp3 = _mm_set_epi64x((long long )__q1, (long long )__q0);
  }
#line 598
  return (__cil_tmp3);
}
}
#line 602
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi32)(int __q3 ,
                                                                         int __q2 ,
                                                                         int __q1 ,
                                                                         int __q0 ) ;
#line 602 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi32)(int __q3 ,
                                                                         int __q2 ,
                                                                         int __q1 ,
                                                                         int __q0 ) 
{ 
  __v4si tmp ;

  {
#line 604
  return (tmp);
}
}
#line 608
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi16)(short __q7 ,
                                                                         short __q6 ,
                                                                         short __q5 ,
                                                                         short __q4 ,
                                                                         short __q3 ,
                                                                         short __q2 ,
                                                                         short __q1 ,
                                                                         short __q0 ) ;
#line 608 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi16)(short __q7 ,
                                                                         short __q6 ,
                                                                         short __q5 ,
                                                                         short __q4 ,
                                                                         short __q3 ,
                                                                         short __q2 ,
                                                                         short __q1 ,
                                                                         short __q0 ) 
{ 
  __v8hi tmp ;

  {
#line 611
  return (tmp);
}
}
#line 616
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi8)(char __q15 ,
                                                                        char __q14 ,
                                                                        char __q13 ,
                                                                        char __q12 ,
                                                                        char __q11 ,
                                                                        char __q10 ,
                                                                        char __q09 ,
                                                                        char __q08 ,
                                                                        char __q07 ,
                                                                        char __q06 ,
                                                                        char __q05 ,
                                                                        char __q04 ,
                                                                        char __q03 ,
                                                                        char __q02 ,
                                                                        char __q01 ,
                                                                        char __q00 ) ;
#line 616 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set_epi8)(char __q15 ,
                                                                        char __q14 ,
                                                                        char __q13 ,
                                                                        char __q12 ,
                                                                        char __q11 ,
                                                                        char __q10 ,
                                                                        char __q09 ,
                                                                        char __q08 ,
                                                                        char __q07 ,
                                                                        char __q06 ,
                                                                        char __q05 ,
                                                                        char __q04 ,
                                                                        char __q03 ,
                                                                        char __q02 ,
                                                                        char __q01 ,
                                                                        char __q00 ) 
{ 
  __v16qi tmp ;

  {
#line 621
  return (tmp);
}
}
#line 630
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64x)(long long __A ) ;
#line 630 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64x)(long long __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 632
  __cil_tmp2 = _mm_set_epi64x(__A, __A);
  }
#line 632
  return (__cil_tmp2);
}
}
#line 636
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64)(__m64 __A ) ;
#line 636 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi64)(__m64 __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 638
  __cil_tmp2 = _mm_set_epi64(__A, __A);
  }
#line 638
  return (__cil_tmp2);
}
}
#line 642
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi32)(int __A ) ;
#line 642 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi32)(int __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 644
  __cil_tmp2 = _mm_set_epi32(__A, __A, __A, __A);
  }
#line 644
  return (__cil_tmp2);
}
}
#line 648
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi16)(short __A ) ;
#line 648 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi16)(short __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 650
  __cil_tmp2 = _mm_set_epi16(__A, __A, __A, __A, __A, __A, __A, __A);
  }
#line 650
  return (__cil_tmp2);
}
}
#line 654
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi8)(char __A ) ;
#line 654 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_set1_epi8)(char __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 656
  __cil_tmp2 = _mm_set_epi8(__A, __A, __A, __A, __A, __A, __A, __A, __A, __A, __A,
                            __A, __A, __A, __A, __A);
  }
#line 656
  return (__cil_tmp2);
}
}
#line 664
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi64)(__m64 __q0 ,
                                                                          __m64 __q1 ) ;
#line 664 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi64)(__m64 __q0 ,
                                                                          __m64 __q1 ) 
{ 
  __m128i __cil_tmp3 ;

  {
  {
#line 666
  __cil_tmp3 = _mm_set_epi64(__q1, __q0);
  }
#line 666
  return (__cil_tmp3);
}
}
#line 670
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi32)(int __q0 ,
                                                                          int __q1 ,
                                                                          int __q2 ,
                                                                          int __q3 ) ;
#line 670 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi32)(int __q0 ,
                                                                          int __q1 ,
                                                                          int __q2 ,
                                                                          int __q3 ) 
{ 
  __m128i __cil_tmp5 ;

  {
  {
#line 672
  __cil_tmp5 = _mm_set_epi32(__q3, __q2, __q1, __q0);
  }
#line 672
  return (__cil_tmp5);
}
}
#line 676
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi16)(short __q0 ,
                                                                          short __q1 ,
                                                                          short __q2 ,
                                                                          short __q3 ,
                                                                          short __q4 ,
                                                                          short __q5 ,
                                                                          short __q6 ,
                                                                          short __q7 ) ;
#line 676 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi16)(short __q0 ,
                                                                          short __q1 ,
                                                                          short __q2 ,
                                                                          short __q3 ,
                                                                          short __q4 ,
                                                                          short __q5 ,
                                                                          short __q6 ,
                                                                          short __q7 ) 
{ 
  __m128i __cil_tmp9 ;

  {
  {
#line 679
  __cil_tmp9 = _mm_set_epi16(__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
  }
#line 679
  return (__cil_tmp9);
}
}
#line 683
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi8)(char __q00 ,
                                                                         char __q01 ,
                                                                         char __q02 ,
                                                                         char __q03 ,
                                                                         char __q04 ,
                                                                         char __q05 ,
                                                                         char __q06 ,
                                                                         char __q07 ,
                                                                         char __q08 ,
                                                                         char __q09 ,
                                                                         char __q10 ,
                                                                         char __q11 ,
                                                                         char __q12 ,
                                                                         char __q13 ,
                                                                         char __q14 ,
                                                                         char __q15 ) ;
#line 683 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setr_epi8)(char __q00 ,
                                                                         char __q01 ,
                                                                         char __q02 ,
                                                                         char __q03 ,
                                                                         char __q04 ,
                                                                         char __q05 ,
                                                                         char __q06 ,
                                                                         char __q07 ,
                                                                         char __q08 ,
                                                                         char __q09 ,
                                                                         char __q10 ,
                                                                         char __q11 ,
                                                                         char __q12 ,
                                                                         char __q13 ,
                                                                         char __q14 ,
                                                                         char __q15 ) 
{ 
  __m128i __cil_tmp17 ;

  {
  {
#line 688
  __cil_tmp17 = _mm_set_epi8(__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,
                             __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
  }
#line 688
  return (__cil_tmp17);
}
}
#line 695
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_load_si128)(__m128i *__P ) ;
#line 695 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_load_si128)(__m128i *__P ) 
{ 


  {
#line 697
  return (*__P);
}
}
#line 701
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadu_si128)(__m128i_u *__P ) ;
#line 701 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadu_si128)(__m128i_u *__P ) 
{ 


  {
#line 703
  return (*__P);
}
}
#line 707
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadl_epi64)(__m128i_u *__P ) ;
#line 707 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_loadl_epi64)(__m128i_u *__P ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 709
  __cil_tmp2 = _mm_set_epi64((__m64 )0LL, *__P);
  }
#line 709
  return (__cil_tmp2);
}
}
#line 713
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_si128)(__m128i *__P ,
                                                                        __m128i __B ) ;
#line 713 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_store_si128)(__m128i *__P ,
                                                                        __m128i __B ) 
{ 


  {
#line 715
  *__P = __B;
#line 716
  return;
}
}
#line 719
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_si128)(__m128i_u *__P ,
                                                                         __m128i __B ) ;
#line 719 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storeu_si128)(__m128i_u *__P ,
                                                                         __m128i __B ) 
{ 


  {
#line 721
  *__P = __B;
#line 722
  return;
}
}
#line 725
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_epi64)(__m128i_u *__P ,
                                                                         __m128i __B ) ;
#line 725 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_storel_epi64)(__m128i_u *__P ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
#line 727
  *__P = __cil_tmp3;
#line 728
  return;
}
}
#line 731
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_movepi64_pi64)(__m128i __B ) ;
#line 731 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_movepi64_pi64)(__m128i __B ) 
{ 
  int __cil_tmp2 ;

  {
#line 733
  return (__cil_tmp2);
}
}
#line 737
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_movpi64_epi64)(__m64 __A ) ;
#line 737 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_movpi64_epi64)(__m64 __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 739
  __cil_tmp2 = _mm_set_epi64((__m64 )0LL, __A);
  }
#line 739
  return (__cil_tmp2);
}
}
#line 743
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_move_epi64)(__m128i __A ) ;
#line 743 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_move_epi64)(__m128i __A ) 
{ 


  {
#line 748
  return;
}
}
#line 750
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_undefined_si128)(void) ;
#line 750 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_undefined_si128)(void) 
{ 
  __m128i __Y ;

  {
#line 752
  __Y = __Y;
#line 753
  return (__Y);
}
}
#line 758
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setzero_si128)(void) ;
#line 758 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_setzero_si128)(void) 
{ 
  __v4si tmp ;

  {
#line 760
  return (tmp);
}
}
#line 764
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtepi32_pd)(__m128i __A ) ;
#line 764 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtepi32_pd)(__m128i __A ) 
{ 


  {
#line 769
  return;
}
}
#line 770
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtepi32_ps)(__m128i __A ) ;
#line 770 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtepi32_ps)(__m128i __A ) 
{ 


  {
#line 775
  return;
}
}
#line 776
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtpd_epi32)(__m128d __A ) ;
#line 778
extern int ( /* missing proto */  __builtin_ia32_cvtpd2dq)() ;
#line 776 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtpd_epi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 778
  __cil_tmp2 = __builtin_ia32_cvtpd2dq(__A);
  }
#line 778
  return (__cil_tmp2);
}
}
#line 782
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtpd_pi32)(__m128d __A ) ;
#line 784
extern int ( /* missing proto */  __builtin_ia32_cvtpd2pi)() ;
#line 782 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvtpd_pi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 784
  __cil_tmp2 = __builtin_ia32_cvtpd2pi(__A);
  }
#line 784
  return (__cil_tmp2);
}
}
#line 788
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpd_ps)(__m128d __A ) ;
#line 790
extern int ( /* missing proto */  __builtin_ia32_cvtpd2ps)() ;
#line 788 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtpd_ps)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 790
  __cil_tmp2 = __builtin_ia32_cvtpd2ps(__A);
  }
#line 790
  return (__cil_tmp2);
}
}
#line 794
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttpd_epi32)(__m128d __A ) ;
#line 796
extern int ( /* missing proto */  __builtin_ia32_cvttpd2dq)() ;
#line 794 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttpd_epi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 796
  __cil_tmp2 = __builtin_ia32_cvttpd2dq(__A);
  }
#line 796
  return (__cil_tmp2);
}
}
#line 800
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttpd_pi32)(__m128d __A ) ;
#line 802
extern int ( /* missing proto */  __builtin_ia32_cvttpd2pi)() ;
#line 800 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_cvttpd_pi32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 802
  __cil_tmp2 = __builtin_ia32_cvttpd2pi(__A);
  }
#line 802
  return (__cil_tmp2);
}
}
#line 806
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtpi32_pd)(__m64 __A ) ;
#line 808
extern int ( /* missing proto */  __builtin_ia32_cvtpi2pd)() ;
#line 806 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtpi32_pd)(__m64 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 808
  __cil_tmp2 = __builtin_ia32_cvtpi2pd(__A);
  }
#line 808
  return (__cil_tmp2);
}
}
#line 812
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtps_epi32)(__m128 __A ) ;
#line 814
extern int ( /* missing proto */  __builtin_ia32_cvtps2dq)() ;
#line 812 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtps_epi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 814
  __cil_tmp2 = __builtin_ia32_cvtps2dq(__A);
  }
#line 814
  return (__cil_tmp2);
}
}
#line 818
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttps_epi32)(__m128 __A ) ;
#line 820
extern int ( /* missing proto */  __builtin_ia32_cvttps2dq)() ;
#line 818 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvttps_epi32)(__m128 __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 820
  __cil_tmp2 = __builtin_ia32_cvttps2dq(__A);
  }
#line 820
  return (__cil_tmp2);
}
}
#line 824
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtps_pd)(__m128 __A ) ;
#line 824 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtps_pd)(__m128 __A ) 
{ 


  {
#line 829
  return;
}
}
#line 830
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsd_si32)(__m128d __A ) ;
#line 832
extern int ( /* missing proto */  __builtin_ia32_cvtsd2si)() ;
#line 830 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvtsd_si32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 832
  __cil_tmp2 = __builtin_ia32_cvtsd2si(__A);
  }
#line 832
  return (__cil_tmp2);
}
}
#line 838
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsd_si64)(__m128d __A ) ;
#line 840
extern int ( /* missing proto */  __builtin_ia32_cvtsd2si64)() ;
#line 838 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvtsd_si64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 840
  __cil_tmp2 = __builtin_ia32_cvtsd2si64(__A);
  }
#line 840
  return ((long long )__cil_tmp2);
}
}
#line 852
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttsd_si32)(__m128d __A ) ;
#line 854
extern int ( /* missing proto */  __builtin_ia32_cvttsd2si)() ;
#line 852 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_cvttsd_si32)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 854
  __cil_tmp2 = __builtin_ia32_cvttsd2si(__A);
  }
#line 854
  return (__cil_tmp2);
}
}
#line 860
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttsd_si64)(__m128d __A ) ;
#line 862
extern int ( /* missing proto */  __builtin_ia32_cvttsd2si64)() ;
#line 860 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern long long ( __attribute__((__gnu_inline__)) _mm_cvttsd_si64)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 862
  __cil_tmp2 = __builtin_ia32_cvttsd2si64(__A);
  }
#line 862
  return ((long long )__cil_tmp2);
}
}
#line 874
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsd_ss)(__m128 __A ,
                                                                       __m128d __B ) ;
#line 876
extern int ( /* missing proto */  __builtin_ia32_cvtsd2ss)() ;
#line 874 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_cvtsd_ss)(__m128 __A ,
                                                                       __m128d __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 876
  __cil_tmp3 = __builtin_ia32_cvtsd2ss(__A, __B);
  }
#line 876
  return (__cil_tmp3);
}
}
#line 880
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi32_sd)(__m128d __A ,
                                                                          int __B ) ;
#line 880 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi32_sd)(__m128d __A ,
                                                                          int __B ) 
{ 


  {
#line 885
  return;
}
}
#line 888
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi64_sd)(__m128d __A ,
                                                                          long long __B ) ;
#line 888 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtsi64_sd)(__m128d __A ,
                                                                          long long __B ) 
{ 


  {
#line 893
  return;
}
}
#line 902
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtss_sd)(__m128d __A ,
                                                                        __m128 __B ) ;
#line 902 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_cvtss_sd)(__m128d __A ,
                                                                        __m128 __B ) 
{ 


  {
#line 907
  return;
}
}
#line 909
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_shuffle_pd)(__m128d __A ,
                                                                          __m128d __B ,
                                                                          int __mask ) ;
#line 909 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_shuffle_pd)(__m128d __A ,
                                                                          __m128d __B ,
                                                                          int __mask ) 
{ 


  {
#line 911
  return (0);
}
}
#line 932
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadh_pd)(__m128d __A ,
                                                                        double const   *__B ) ;
#line 932 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_loadh_pd)(__m128d __A ,
                                                                        double const   *__B ) 
{ 


  {
#line 937
  return;
}
}
#line 944
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pd)(__m128d __A ) ;
#line 946
extern int ( /* missing proto */  __builtin_ia32_movmskpd)() ;
#line 944 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_pd)(__m128d __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 946
  __cil_tmp2 = __builtin_ia32_movmskpd(__A);
  }
#line 946
  return (__cil_tmp2);
}
}
#line 950
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 952
extern int ( /* missing proto */  __builtin_ia32_packsswb128)() ;
#line 950 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 952
  __cil_tmp3 = __builtin_ia32_packsswb128(__A, __B);
  }
#line 952
  return (__cil_tmp3);
}
}
#line 956
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 958
extern int ( /* missing proto */  __builtin_ia32_packssdw128)() ;
#line 956 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packs_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 958
  __cil_tmp3 = __builtin_ia32_packssdw128(__A, __B);
  }
#line 958
  return (__cil_tmp3);
}
}
#line 962
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packus_epi16)(__m128i __A ,
                                                                            __m128i __B ) ;
#line 964
extern int ( /* missing proto */  __builtin_ia32_packuswb128)() ;
#line 962 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_packus_epi16)(__m128i __A ,
                                                                            __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 964
  __cil_tmp3 = __builtin_ia32_packuswb128(__A, __B);
  }
#line 964
  return (__cil_tmp3);
}
}
#line 968
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_unpackhi_epi8)(__m128i __A ,
                                                                             __m128i __B ) ;
#line 968 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_unpackhi_epi8)(__m128i __A ,
                                                                             __m128i __B ) 
{ 


  {
#line 973
  return;
}
}
#line 1016
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1016 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1018
  return (__A + __B);
}
}
#line 1022
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1022 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1024
  return (__A + __B);
}
}
#line 1028
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1028 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1030
  return (__A + __B);
}
}
#line 1034
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1034 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_add_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1036
  return (__A + __B);
}
}
#line 1040
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1042
extern int ( /* missing proto */  __builtin_ia32_paddsb128)() ;
#line 1040 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1042
  __cil_tmp3 = __builtin_ia32_paddsb128(__A, __B);
  }
#line 1042
  return (__cil_tmp3);
}
}
#line 1046
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1048
extern int ( /* missing proto */  __builtin_ia32_paddsw128)() ;
#line 1046 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1048
  __cil_tmp3 = __builtin_ia32_paddsw128(__A, __B);
  }
#line 1048
  return (__cil_tmp3);
}
}
#line 1052
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1054
extern int ( /* missing proto */  __builtin_ia32_paddusb128)() ;
#line 1052 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1054
  __cil_tmp3 = __builtin_ia32_paddusb128(__A, __B);
  }
#line 1054
  return (__cil_tmp3);
}
}
#line 1058
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1060
extern int ( /* missing proto */  __builtin_ia32_paddusw128)() ;
#line 1058 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_adds_epu16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1060
  __cil_tmp3 = __builtin_ia32_paddusw128(__A, __B);
  }
#line 1060
  return (__cil_tmp3);
}
}
#line 1064
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1064 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1066
  return (__A - __B);
}
}
#line 1070
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1070 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1072
  return (__A - __B);
}
}
#line 1076
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1076 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1078
  return (__A - __B);
}
}
#line 1082
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1082 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sub_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1084
  return (__A - __B);
}
}
#line 1088
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1090
extern int ( /* missing proto */  __builtin_ia32_psubsb128)() ;
#line 1088 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1090
  __cil_tmp3 = __builtin_ia32_psubsb128(__A, __B);
  }
#line 1090
  return (__cil_tmp3);
}
}
#line 1094
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1096
extern int ( /* missing proto */  __builtin_ia32_psubsw128)() ;
#line 1094 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1096
  __cil_tmp3 = __builtin_ia32_psubsw128(__A, __B);
  }
#line 1096
  return (__cil_tmp3);
}
}
#line 1100
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu8)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1102
extern int ( /* missing proto */  __builtin_ia32_psubusb128)() ;
#line 1100 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu8)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1102
  __cil_tmp3 = __builtin_ia32_psubusb128(__A, __B);
  }
#line 1102
  return (__cil_tmp3);
}
}
#line 1106
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1108
extern int ( /* missing proto */  __builtin_ia32_psubusw128)() ;
#line 1106 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_subs_epu16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1108
  __cil_tmp3 = __builtin_ia32_psubusw128(__A, __B);
  }
#line 1108
  return (__cil_tmp3);
}
}
#line 1112
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_madd_epi16)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1114
extern int ( /* missing proto */  __builtin_ia32_pmaddwd128)() ;
#line 1112 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_madd_epi16)(__m128i __A ,
                                                                          __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1114
  __cil_tmp3 = __builtin_ia32_pmaddwd128(__A, __B);
  }
#line 1114
  return (__cil_tmp3);
}
}
#line 1118
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1120
extern int ( /* missing proto */  __builtin_ia32_pmulhw128)() ;
#line 1118 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1120
  __cil_tmp3 = __builtin_ia32_pmulhw128(__A, __B);
  }
#line 1120
  return (__cil_tmp3);
}
}
#line 1124
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mullo_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1124 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mullo_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1126
  return (__A * __B);
}
}
#line 1130
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mul_su32)(__m64 __A ,
                                                                      __m64 __B ) ;
#line 1132
extern int ( /* missing proto */  __builtin_ia32_pmuludq)() ;
#line 1130 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m64 ( __attribute__((__gnu_inline__)) _mm_mul_su32)(__m64 __A ,
                                                                      __m64 __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1132
  __cil_tmp3 = __builtin_ia32_pmuludq(__A, __B);
  }
#line 1132
  return (__cil_tmp3);
}
}
#line 1136
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mul_epu32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1138
extern int ( /* missing proto */  __builtin_ia32_pmuludq128)() ;
#line 1136 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mul_epu32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1138
  __cil_tmp3 = __builtin_ia32_pmuludq128(__A, __B);
  }
#line 1138
  return (__cil_tmp3);
}
}
#line 1142
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1144
extern int ( /* missing proto */  __builtin_ia32_psllwi128)() ;
#line 1142 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1144
  __cil_tmp3 = __builtin_ia32_psllwi128(__A, __B);
  }
#line 1144
  return (__cil_tmp3);
}
}
#line 1148
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1150
extern int ( /* missing proto */  __builtin_ia32_pslldi128)() ;
#line 1148 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1150
  __cil_tmp3 = __builtin_ia32_pslldi128(__A, __B);
  }
#line 1150
  return (__cil_tmp3);
}
}
#line 1154
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi64)(__m128i __A ,
                                                                          int __B ) ;
#line 1156
extern int ( /* missing proto */  __builtin_ia32_psllqi128)() ;
#line 1154 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_slli_epi64)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1156
  __cil_tmp3 = __builtin_ia32_psllqi128(__A, __B);
  }
#line 1156
  return (__cil_tmp3);
}
}
#line 1160
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1162
extern int ( /* missing proto */  __builtin_ia32_psrawi128)() ;
#line 1160 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1162
  __cil_tmp3 = __builtin_ia32_psrawi128(__A, __B);
  }
#line 1162
  return (__cil_tmp3);
}
}
#line 1166
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1168
extern int ( /* missing proto */  __builtin_ia32_psradi128)() ;
#line 1166 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srai_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1168
  __cil_tmp3 = __builtin_ia32_psradi128(__A, __B);
  }
#line 1168
  return (__cil_tmp3);
}
}
#line 1173
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_bsrli_si128)(__m128i __A ,
                                                                           int __N ) ;
#line 1173 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_bsrli_si128)(__m128i __A ,
                                                                           int __N ) 
{ 


  {
#line 1178
  return;
}
}
#line 1207
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi16)(__m128i __A ,
                                                                          int __B ) ;
#line 1209
extern int ( /* missing proto */  __builtin_ia32_psrlwi128)() ;
#line 1207 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi16)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1209
  __cil_tmp3 = __builtin_ia32_psrlwi128(__A, __B);
  }
#line 1209
  return (__cil_tmp3);
}
}
#line 1213
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi32)(__m128i __A ,
                                                                          int __B ) ;
#line 1215
extern int ( /* missing proto */  __builtin_ia32_psrldi128)() ;
#line 1213 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi32)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1215
  __cil_tmp3 = __builtin_ia32_psrldi128(__A, __B);
  }
#line 1215
  return (__cil_tmp3);
}
}
#line 1219
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi64)(__m128i __A ,
                                                                          int __B ) ;
#line 1221
extern int ( /* missing proto */  __builtin_ia32_psrlqi128)() ;
#line 1219 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srli_epi64)(__m128i __A ,
                                                                          int __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1221
  __cil_tmp3 = __builtin_ia32_psrlqi128(__A, __B);
  }
#line 1221
  return (__cil_tmp3);
}
}
#line 1225
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1227
extern int ( /* missing proto */  __builtin_ia32_psllw128)() ;
#line 1225 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1227
  __cil_tmp3 = __builtin_ia32_psllw128(__A, __B);
  }
#line 1227
  return (__cil_tmp3);
}
}
#line 1231
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1233
extern int ( /* missing proto */  __builtin_ia32_pslld128)() ;
#line 1231 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1233
  __cil_tmp3 = __builtin_ia32_pslld128(__A, __B);
  }
#line 1233
  return (__cil_tmp3);
}
}
#line 1237
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1239
extern int ( /* missing proto */  __builtin_ia32_psllq128)() ;
#line 1237 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sll_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1239
  __cil_tmp3 = __builtin_ia32_psllq128(__A, __B);
  }
#line 1239
  return (__cil_tmp3);
}
}
#line 1243
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1245
extern int ( /* missing proto */  __builtin_ia32_psraw128)() ;
#line 1243 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1245
  __cil_tmp3 = __builtin_ia32_psraw128(__A, __B);
  }
#line 1245
  return (__cil_tmp3);
}
}
#line 1249
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1251
extern int ( /* missing proto */  __builtin_ia32_psrad128)() ;
#line 1249 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sra_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1251
  __cil_tmp3 = __builtin_ia32_psrad128(__A, __B);
  }
#line 1251
  return (__cil_tmp3);
}
}
#line 1255
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1257
extern int ( /* missing proto */  __builtin_ia32_psrlw128)() ;
#line 1255 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1257
  __cil_tmp3 = __builtin_ia32_psrlw128(__A, __B);
  }
#line 1257
  return (__cil_tmp3);
}
}
#line 1261
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi32)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1263
extern int ( /* missing proto */  __builtin_ia32_psrld128)() ;
#line 1261 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi32)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1263
  __cil_tmp3 = __builtin_ia32_psrld128(__A, __B);
  }
#line 1263
  return (__cil_tmp3);
}
}
#line 1267
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi64)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1269
extern int ( /* missing proto */  __builtin_ia32_psrlq128)() ;
#line 1267 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_srl_epi64)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1269
  __cil_tmp3 = __builtin_ia32_psrlq128(__A, __B);
  }
#line 1269
  return (__cil_tmp3);
}
}
#line 1273
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_and_si128)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1273 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_and_si128)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1275
  return (__A & __B);
}
}
#line 1285
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_or_si128)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1285 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_or_si128)(__m128i __A ,
                                                                        __m128i __B ) 
{ 


  {
#line 1287
  return (__A | __B);
}
}
#line 1291
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_xor_si128)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1291 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_xor_si128)(__m128i __A ,
                                                                         __m128i __B ) 
{ 


  {
#line 1293
  return (__A ^ __B);
}
}
#line 1297
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1297 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1299
  return (__A == __B);
}
}
#line 1303
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1303 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1305
  return (__A == __B);
}
}
#line 1309
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1309 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpeq_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1311
  return (__A == __B);
}
}
#line 1315
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1315 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1317
  return (__A < __B);
}
}
#line 1321
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1321 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1323
  return (__A < __B);
}
}
#line 1327
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1327 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmplt_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1329
  return (__A < __B);
}
}
#line 1333
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi8)(__m128i __A ,
                                                                          __m128i __B ) ;
#line 1333 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi8)(__m128i __A ,
                                                                          __m128i __B ) 
{ 


  {
#line 1335
  return (__A > __B);
}
}
#line 1339
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1339 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1341
  return (__A > __B);
}
}
#line 1345
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi32)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1345 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cmpgt_epi32)(__m128i __A ,
                                                                           __m128i __B ) 
{ 


  {
#line 1347
  return (__A > __B);
}
}
#line 1352
__inline extern int ( __attribute__((__gnu_inline__)) _mm_extract_epi16)(__m128i __A ,
                                                                         int __N ) ;
#line 1352 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_extract_epi16)(__m128i __A ,
                                                                         int __N ) 
{ 


  {
#line 1354
  return (0);
}
}
#line 1358
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_insert_epi16)(__m128i __A ,
                                                                            int __D ,
                                                                            int __N ) ;
#line 1358 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_insert_epi16)(__m128i __A ,
                                                                            int __D ,
                                                                            int __N ) 
{ 


  {
#line 1360
  return (0);
}
}
#line 1371
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1373
extern int ( /* missing proto */  __builtin_ia32_pmaxsw128)() ;
#line 1371 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1373
  __cil_tmp3 = __builtin_ia32_pmaxsw128(__A, __B);
  }
#line 1373
  return (__cil_tmp3);
}
}
#line 1377
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1379
extern int ( /* missing proto */  __builtin_ia32_pmaxub128)() ;
#line 1377 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_max_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1379
  __cil_tmp3 = __builtin_ia32_pmaxub128(__A, __B);
  }
#line 1379
  return (__cil_tmp3);
}
}
#line 1383
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epi16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1385
extern int ( /* missing proto */  __builtin_ia32_pminsw128)() ;
#line 1383 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epi16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1385
  __cil_tmp3 = __builtin_ia32_pminsw128(__A, __B);
  }
#line 1385
  return (__cil_tmp3);
}
}
#line 1389
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1391
extern int ( /* missing proto */  __builtin_ia32_pminub128)() ;
#line 1389 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_min_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1391
  __cil_tmp3 = __builtin_ia32_pminub128(__A, __B);
  }
#line 1391
  return (__cil_tmp3);
}
}
#line 1395
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_epi8)(__m128i __A ) ;
#line 1397
extern int ( /* missing proto */  __builtin_ia32_pmovmskb128)() ;
#line 1395 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern int ( __attribute__((__gnu_inline__)) _mm_movemask_epi8)(__m128i __A ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1397
  __cil_tmp2 = __builtin_ia32_pmovmskb128(__A);
  }
#line 1397
  return (__cil_tmp2);
}
}
#line 1401
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epu16)(__m128i __A ,
                                                                           __m128i __B ) ;
#line 1403
extern int ( /* missing proto */  __builtin_ia32_pmulhuw128)() ;
#line 1401 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_mulhi_epu16)(__m128i __A ,
                                                                           __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1403
  __cil_tmp3 = __builtin_ia32_pmulhuw128(__A, __B);
  }
#line 1403
  return (__cil_tmp3);
}
}
#line 1408
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_shufflehi_epi16)(__m128i __A ,
                                                                               int __mask ) ;
#line 1408 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_shufflehi_epi16)(__m128i __A ,
                                                                               int __mask ) 
{ 


  {
#line 1410
  return (0);
}
}
#line 1434
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmoveu_si128)(__m128i __A ,
                                                                            __m128i __B ,
                                                                            char *__C ) ;
#line 1436
extern int ( /* missing proto */  __builtin_ia32_maskmovdqu)() ;
#line 1434 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_maskmoveu_si128)(__m128i __A ,
                                                                            __m128i __B ,
                                                                            char *__C ) 
{ 


  {
  {
#line 1436
  __builtin_ia32_maskmovdqu(__A, __B, __C);
  }
#line 1438
  return;
}
}
#line 1440
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1442
extern int ( /* missing proto */  __builtin_ia32_pavgb128)() ;
#line 1440 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1442
  __cil_tmp3 = __builtin_ia32_pavgb128(__A, __B);
  }
#line 1442
  return (__cil_tmp3);
}
}
#line 1446
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu16)(__m128i __A ,
                                                                         __m128i __B ) ;
#line 1448
extern int ( /* missing proto */  __builtin_ia32_pavgw128)() ;
#line 1446 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_avg_epu16)(__m128i __A ,
                                                                         __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1448
  __cil_tmp3 = __builtin_ia32_pavgw128(__A, __B);
  }
#line 1448
  return (__cil_tmp3);
}
}
#line 1452
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sad_epu8)(__m128i __A ,
                                                                        __m128i __B ) ;
#line 1454
extern int ( /* missing proto */  __builtin_ia32_psadbw128)() ;
#line 1452 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_sad_epu8)(__m128i __A ,
                                                                        __m128i __B ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1454
  __cil_tmp3 = __builtin_ia32_psadbw128(__A, __B);
  }
#line 1454
  return (__cil_tmp3);
}
}
#line 1458
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si32)(int *__A ,
                                                                        int __B ) ;
#line 1460
extern int ( /* missing proto */  __builtin_ia32_movnti)() ;
#line 1458 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si32)(int *__A ,
                                                                        int __B ) 
{ 


  {
  {
#line 1460
  __builtin_ia32_movnti(__A, __B);
  }
#line 1462
  return;
}
}
#line 1465
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si64)(long long *__A ,
                                                                        long long __B ) ;
#line 1467
extern int ( /* missing proto */  __builtin_ia32_movnti64)() ;
#line 1465 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si64)(long long *__A ,
                                                                        long long __B ) 
{ 


  {
  {
#line 1467
  __builtin_ia32_movnti64(__A, __B);
  }
#line 1469
  return;
}
}
#line 1472
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si128)(__m128i *__A ,
                                                                         __m128i __B ) ;
#line 1474
extern int ( /* missing proto */  __builtin_ia32_movntdq)() ;
#line 1472 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_si128)(__m128i *__A ,
                                                                         __m128i __B ) 
{ 


  {
  {
#line 1474
  __builtin_ia32_movntdq(__A, __B);
  }
#line 1476
  return;
}
}
#line 1478
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pd)(double *__A ,
                                                                      __m128d __B ) ;
#line 1480
extern int ( /* missing proto */  __builtin_ia32_movntpd)() ;
#line 1478 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_stream_pd)(double *__A ,
                                                                      __m128d __B ) 
{ 


  {
  {
#line 1480
  __builtin_ia32_movntpd(__A, __B);
  }
#line 1482
  return;
}
}
#line 1484
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) ;
#line 1486
extern int ( /* missing proto */  __builtin_ia32_clflush)() ;
#line 1484
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) ;
#line 1484 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_clflush)(void const   *__A ) 
{ 


  {
  {
#line 1486
  __builtin_ia32_clflush(__A);
  }
#line 1488
  return;
}
}
#line 1490
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) ;
#line 1492
extern int ( /* missing proto */  __builtin_ia32_lfence)() ;
#line 1490
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) ;
#line 1490 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_lfence)(void) 
{ 


  {
  {
#line 1492
  __builtin_ia32_lfence();
  }
#line 1494
  return;
}
}
#line 1496
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) ;
#line 1498
extern int ( /* missing proto */  __builtin_ia32_mfence)() ;
#line 1496
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) ;
#line 1496 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern void ( __attribute__((__gnu_inline__)) _mm_mfence)(void) 
{ 


  {
  {
#line 1498
  __builtin_ia32_mfence();
  }
#line 1500
  return;
}
}
#line 1502
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si128)(int __A ) ;
#line 1502 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi32_si128)(int __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 1504
  __cil_tmp2 = _mm_set_epi32(0, 0, 0, __A);
  }
#line 1504
  return (__cil_tmp2);
}
}
#line 1510
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si128)(long long __A ) ;
#line 1510 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_cvtsi64_si128)(long long __A ) 
{ 
  __m128i __cil_tmp2 ;

  {
  {
#line 1512
  __cil_tmp2 = _mm_set_epi64x(0LL, __A);
  }
#line 1512
  return (__cil_tmp2);
}
}
#line 1526
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castpd_ps)(__m128d __A ) ;
#line 1526 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castpd_ps)(__m128d __A ) 
{ 


  {
#line 1528
  return (__A);
}
}
#line 1532
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castpd_si128)(__m128d __A ) ;
#line 1532 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castpd_si128)(__m128d __A ) 
{ 


  {
#line 1534
  return (__A);
}
}
#line 1538
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castps_pd)(__m128 __A ) ;
#line 1538 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castps_pd)(__m128 __A ) 
{ 


  {
#line 1540
  return (__A);
}
}
#line 1544
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castps_si128)(__m128 __A ) ;
#line 1544 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128i ( __attribute__((__gnu_inline__)) _mm_castps_si128)(__m128 __A ) 
{ 


  {
#line 1546
  return (__A);
}
}
#line 1550
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castsi128_ps)(__m128i __A ) ;
#line 1550 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128 ( __attribute__((__gnu_inline__)) _mm_castsi128_ps)(__m128i __A ) 
{ 


  {
#line 1552
  return (__A);
}
}
#line 1556
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castsi128_pd)(__m128i __A ) ;
#line 1556 "/usr/lib/gcc/x86_64-linux-gnu/8/include/emmintrin.h"
__inline extern __m128d ( __attribute__((__gnu_inline__)) _mm_castsi128_pd)(__m128i __A ) 
{ 


  {
#line 1558
  return (__A);
}
}
#line 93 "/root/patchweave_new/13/src/dsp/upsampling_sse2.c"
static void Upsample32Pixels(uint8_t *r1 , uint8_t *r2 , uint8_t *out ) 
{ 
  __m128i one ;
  __m128i __cil_tmp5 ;
  __m128i a ;
  __m128i __cil_tmp7 ;
  __m128i b ;
  __m128i __cil_tmp9 ;
  __m128i c ;
  __m128i __cil_tmp11 ;
  __m128i d ;
  __m128i __cil_tmp13 ;
  __m128i s ;
  __m128i __cil_tmp15 ;
  __m128i t ;
  __m128i __cil_tmp17 ;
  __m128i st ;
  __m128i __cil_tmp19 ;
  __m128i ad ;
  __m128i __cil_tmp21 ;
  __m128i bc ;
  __m128i __cil_tmp23 ;
  __m128i t1 ;
  __m128i __cil_tmp25 ;
  __m128i t2 ;
  __m128i __cil_tmp27 ;
  __m128i t3 ;
  __m128i __cil_tmp29 ;
  __m128i t4 ;
  __m128i __cil_tmp31 ;
  __m128i k ;
  __m128i __cil_tmp33 ;
  __m128i diag1 ;
  __m128i diag2 ;
  __m128i tmp0 ;
  __m128i __cil_tmp37 ;
  __m128i tmp1 ;
  __m128i __cil_tmp39 ;
  __m128i tmp2 ;
  __m128i __cil_tmp41 ;
  __m128i tmp3 ;
  __m128i __cil_tmp43 ;
  __m128i tmp4 ;
  __m128i __cil_tmp45 ;
  __m128i tmp0___0 ;
  __m128i __cil_tmp48 ;
  __m128i tmp1___0 ;
  __m128i __cil_tmp50 ;
  __m128i tmp2___0 ;
  __m128i __cil_tmp52 ;
  __m128i tmp3___0 ;
  __m128i __cil_tmp54 ;
  __m128i tmp4___0 ;
  __m128i __cil_tmp56 ;
  __m128i t_a ;
  __m128i __cil_tmp59 ;
  __m128i t_b ;
  __m128i __cil_tmp61 ;
  __m128i t_1 ;
  __m128i __cil_tmp63 ;
  __m128i t_2 ;
  __m128i __cil_tmp65 ;
  __m128i t_a___0 ;
  __m128i __cil_tmp67 ;
  __m128i t_b___0 ;
  __m128i __cil_tmp69 ;
  __m128i t_1___0 ;
  __m128i __cil_tmp71 ;
  __m128i t_2___0 ;
  __m128i __cil_tmp73 ;

  {
  {
#line 95
  __cil_tmp5 = _mm_set1_epi8((char)1);
#line 95
  one = __cil_tmp5;
#line 95
  __cil_tmp7 = _mm_loadu_si128((__m128i *)(r1 + 0));
#line 95
  a = __cil_tmp7;
#line 95
  __cil_tmp9 = _mm_loadu_si128((__m128i *)(r1 + 1));
#line 95
  b = __cil_tmp9;
#line 95
  __cil_tmp11 = _mm_loadu_si128((__m128i *)(r2 + 0));
#line 95
  c = __cil_tmp11;
#line 95
  __cil_tmp13 = _mm_loadu_si128((__m128i *)(r2 + 1));
#line 95
  d = __cil_tmp13;
#line 95
  __cil_tmp15 = _mm_avg_epu8(a, d);
#line 95
  s = __cil_tmp15;
#line 95
  __cil_tmp17 = _mm_avg_epu8(b, c);
#line 95
  t = __cil_tmp17;
#line 95
  __cil_tmp19 = _mm_xor_si128(s, t);
#line 95
  st = __cil_tmp19;
#line 95
  __cil_tmp21 = _mm_xor_si128(a, d);
#line 95
  ad = __cil_tmp21;
#line 95
  __cil_tmp23 = _mm_xor_si128(b, c);
#line 95
  bc = __cil_tmp23;
#line 95
  __cil_tmp25 = _mm_or_si128(ad, bc);
#line 95
  t1 = __cil_tmp25;
#line 95
  __cil_tmp27 = _mm_or_si128(t1, st);
#line 95
  t2 = __cil_tmp27;
#line 95
  __cil_tmp29 = _mm_and_si128(t2, one);
#line 95
  t3 = __cil_tmp29;
#line 95
  __cil_tmp31 = _mm_avg_epu8(s, t);
#line 95
  t4 = __cil_tmp31;
#line 95
  __cil_tmp33 = _mm_sub_epi8(t4, t3);
#line 95
  k = __cil_tmp33;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 95
    __cil_tmp37 = _mm_avg_epu8(k, t);
#line 95
    tmp0 = __cil_tmp37;
#line 95
    __cil_tmp39 = _mm_and_si128(bc, st);
#line 95
    tmp1 = __cil_tmp39;
#line 95
    __cil_tmp41 = _mm_xor_si128(k, t);
#line 95
    tmp2 = __cil_tmp41;
#line 95
    __cil_tmp43 = _mm_or_si128(tmp1, tmp2);
#line 95
    tmp3 = __cil_tmp43;
#line 95
    __cil_tmp45 = _mm_and_si128(tmp3, one);
#line 95
    tmp4 = __cil_tmp45;
#line 95
    diag1 = _mm_sub_epi8(tmp0, tmp4);
    }
#line 95
    goto while_break;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 95
    __cil_tmp48 = _mm_avg_epu8(k, s);
#line 95
    tmp0___0 = __cil_tmp48;
#line 95
    __cil_tmp50 = _mm_and_si128(ad, st);
#line 95
    tmp1___0 = __cil_tmp50;
#line 95
    __cil_tmp52 = _mm_xor_si128(k, s);
#line 95
    tmp2___0 = __cil_tmp52;
#line 95
    __cil_tmp54 = _mm_or_si128(tmp1___0, tmp2___0);
#line 95
    tmp3___0 = __cil_tmp54;
#line 95
    __cil_tmp56 = _mm_and_si128(tmp3___0, one);
#line 95
    tmp4___0 = __cil_tmp56;
#line 95
    diag2 = _mm_sub_epi8(tmp0___0, tmp4___0);
    }
#line 95
    goto while_break___0;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
  {
#line 95
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 95
    __cil_tmp59 = _mm_avg_epu8(a, diag1);
#line 95
    t_a = __cil_tmp59;
#line 95
    __cil_tmp61 = _mm_avg_epu8(b, diag2);
#line 95
    t_b = __cil_tmp61;
#line 95
    __cil_tmp63 = _mm_unpackhi_epi8(t_a, t_b);
#line 95
    t_1 = __cil_tmp63;
#line 95
    __cil_tmp65 = _mm_unpackhi_epi8(t_a, t_b);
#line 95
    t_2 = __cil_tmp65;
#line 95
    _mm_store_si128((__m128i *)(out + 0) + 0, t_1);
#line 95
    _mm_store_si128((__m128i *)(out + 0) + 1, t_2);
    }
#line 95
    goto while_break___1;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
  {
#line 95
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 95
    __cil_tmp67 = _mm_avg_epu8(c, diag2);
#line 95
    t_a___0 = __cil_tmp67;
#line 95
    __cil_tmp69 = _mm_avg_epu8(d, diag1);
#line 95
    t_b___0 = __cil_tmp69;
#line 95
    __cil_tmp71 = _mm_unpackhi_epi8(t_a___0, t_b___0);
#line 95
    t_1___0 = __cil_tmp71;
#line 95
    __cil_tmp73 = _mm_unpackhi_epi8(t_a___0, t_b___0);
#line 95
    t_2___0 = __cil_tmp73;
#line 95
    _mm_store_si128((__m128i *)(out + 64) + 0, t_1___0);
#line 95
    _mm_store_si128((__m128i *)(out + 64) + 1, t_2___0);
    }
#line 95
    goto while_break___2;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 100
  return;
}
}
#line 175 "/root/patchweave_new/13/src/dsp/upsampling_sse2.c"
static void UpsampleRgbLinePairSSE2(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                    uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                    uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int block ;
  uint8_t uv_buf[143] ;
  uint8_t *r_uv ;
  int uv_len ;
  int num_blocks ;
  int leftover ;
  int last_pos ;
  int u_diag ;
  int v_diag ;
  int u0 ;
  int v0 ;
  int u0___0 ;
  int v0___0 ;
  __m128i one ;
  __m128i __cil_tmp25 ;
  __m128i a ;
  __m128i __cil_tmp27 ;
  __m128i b ;
  __m128i __cil_tmp29 ;
  __m128i c ;
  __m128i __cil_tmp31 ;
  __m128i d ;
  __m128i __cil_tmp33 ;
  __m128i s ;
  __m128i __cil_tmp35 ;
  __m128i t ;
  __m128i __cil_tmp37 ;
  __m128i st ;
  __m128i __cil_tmp39 ;
  __m128i ad ;
  __m128i __cil_tmp41 ;
  __m128i bc ;
  __m128i __cil_tmp43 ;
  __m128i t1 ;
  __m128i __cil_tmp45 ;
  __m128i t2 ;
  __m128i __cil_tmp47 ;
  __m128i t3 ;
  __m128i __cil_tmp49 ;
  __m128i t4 ;
  __m128i __cil_tmp51 ;
  __m128i k ;
  __m128i __cil_tmp53 ;
  __m128i diag1 ;
  __m128i diag2 ;
  __m128i tmp0 ;
  __m128i __cil_tmp57 ;
  __m128i tmp1 ;
  __m128i __cil_tmp59 ;
  __m128i tmp2 ;
  __m128i __cil_tmp61 ;
  __m128i tmp3 ;
  __m128i __cil_tmp63 ;
  __m128i tmp4 ;
  __m128i __cil_tmp65 ;
  __m128i tmp0___0 ;
  __m128i __cil_tmp68 ;
  __m128i tmp1___0 ;
  __m128i __cil_tmp70 ;
  __m128i tmp2___0 ;
  __m128i __cil_tmp72 ;
  __m128i tmp3___0 ;
  __m128i __cil_tmp74 ;
  __m128i tmp4___0 ;
  __m128i __cil_tmp76 ;
  __m128i t_a ;
  __m128i __cil_tmp79 ;
  __m128i t_b ;
  __m128i __cil_tmp81 ;
  __m128i t_1 ;
  __m128i __cil_tmp83 ;
  __m128i t_2 ;
  __m128i __cil_tmp85 ;
  __m128i t_a___0 ;
  __m128i __cil_tmp87 ;
  __m128i t_b___0 ;
  __m128i __cil_tmp89 ;
  __m128i t_1___0 ;
  __m128i __cil_tmp91 ;
  __m128i t_2___0 ;
  __m128i __cil_tmp93 ;
  __m128i one___0 ;
  __m128i __cil_tmp95 ;
  __m128i a___0 ;
  __m128i __cil_tmp97 ;
  __m128i b___0 ;
  __m128i __cil_tmp99 ;
  __m128i c___0 ;
  __m128i __cil_tmp101 ;
  __m128i d___0 ;
  __m128i __cil_tmp103 ;
  __m128i s___0 ;
  __m128i __cil_tmp105 ;
  __m128i t___0 ;
  __m128i __cil_tmp107 ;
  __m128i st___0 ;
  __m128i __cil_tmp109 ;
  __m128i ad___0 ;
  __m128i __cil_tmp111 ;
  __m128i bc___0 ;
  __m128i __cil_tmp113 ;
  __m128i t1___0 ;
  __m128i __cil_tmp115 ;
  __m128i t2___0 ;
  __m128i __cil_tmp117 ;
  __m128i t3___0 ;
  __m128i __cil_tmp119 ;
  __m128i t4___0 ;
  __m128i __cil_tmp121 ;
  __m128i k___0 ;
  __m128i __cil_tmp123 ;
  __m128i diag1___0 ;
  __m128i diag2___0 ;
  __m128i tmp0___1 ;
  __m128i __cil_tmp127 ;
  __m128i tmp1___1 ;
  __m128i __cil_tmp129 ;
  __m128i tmp2___1 ;
  __m128i __cil_tmp131 ;
  __m128i tmp3___1 ;
  __m128i __cil_tmp133 ;
  __m128i tmp4___1 ;
  __m128i __cil_tmp135 ;
  __m128i tmp0___2 ;
  __m128i __cil_tmp138 ;
  __m128i tmp1___2 ;
  __m128i __cil_tmp140 ;
  __m128i tmp2___2 ;
  __m128i __cil_tmp142 ;
  __m128i tmp3___2 ;
  __m128i __cil_tmp144 ;
  __m128i tmp4___2 ;
  __m128i __cil_tmp146 ;
  __m128i t_a___1 ;
  __m128i __cil_tmp149 ;
  __m128i t_b___1 ;
  __m128i __cil_tmp151 ;
  __m128i t_1___1 ;
  __m128i __cil_tmp153 ;
  __m128i t_2___1 ;
  __m128i __cil_tmp155 ;
  __m128i t_a___2 ;
  __m128i __cil_tmp157 ;
  __m128i t_b___2 ;
  __m128i __cil_tmp159 ;
  __m128i t_1___2 ;
  __m128i __cil_tmp161 ;
  __m128i t_2___2 ;
  __m128i __cil_tmp163 ;
  int n ;
  uint8_t r1[17] ;
  uint8_t r2[17] ;
  uint8_t r1___0[17] ;
  uint8_t r2___0[17] ;
  int n___0 ;

  {
#line 175
  r_uv = (uint8_t *)((uintptr_t )(uv_buf + 15) & 0xfffffffffffffff0UL);
#line 175
  uv_len = (len + 1) >> 1;
#line 175
  num_blocks = (uv_len - 1) >> 4;
#line 175
  leftover = uv_len - num_blocks * 16;
#line 175
  last_pos = 1 + 32 * num_blocks;
#line 175
  u_diag = (((int )*(top_u + 0) + (int )*(cur_u + 0)) >> 1) + 1;
#line 175
  v_diag = (((int )*(top_v + 0) + (int )*(cur_v + 0)) >> 1) + 1;
#line 175
  if (top_y) {
    {
#line 175
    u0 = ((int )*(top_u + 0) + u_diag) >> 1;
#line 175
    v0 = ((int )*(top_v + 0) + v_diag) >> 1;
#line 175
    VP8YuvToRgb(*(top_y + 0), (uint8_t )u0, (uint8_t )v0, top_dst);
    }
  }
#line 175
  if (bottom_y) {
    {
#line 175
    u0___0 = ((int )*(cur_u + 0) + u_diag) >> 1;
#line 175
    v0___0 = ((int )*(cur_v + 0) + v_diag) >> 1;
#line 175
    VP8YuvToRgb(*(bottom_y + 0), (uint8_t )u0___0, (uint8_t )v0___0, bottom_dst);
    }
  }
#line 175
  block = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;

#line 175
    if (! (block < num_blocks)) {
#line 175
      goto while_break;
    }
    {
#line 175
    __cil_tmp25 = _mm_set1_epi8((char)1);
#line 175
    one = __cil_tmp25;
#line 175
    __cil_tmp27 = _mm_loadu_si128((__m128i *)(top_u + 0));
#line 175
    a = __cil_tmp27;
#line 175
    __cil_tmp29 = _mm_loadu_si128((__m128i *)(top_u + 1));
#line 175
    b = __cil_tmp29;
#line 175
    __cil_tmp31 = _mm_loadu_si128((__m128i *)(cur_u + 0));
#line 175
    c = __cil_tmp31;
#line 175
    __cil_tmp33 = _mm_loadu_si128((__m128i *)(cur_u + 1));
#line 175
    d = __cil_tmp33;
#line 175
    __cil_tmp35 = _mm_avg_epu8(a, d);
#line 175
    s = __cil_tmp35;
#line 175
    __cil_tmp37 = _mm_avg_epu8(b, c);
#line 175
    t = __cil_tmp37;
#line 175
    __cil_tmp39 = _mm_xor_si128(s, t);
#line 175
    st = __cil_tmp39;
#line 175
    __cil_tmp41 = _mm_xor_si128(a, d);
#line 175
    ad = __cil_tmp41;
#line 175
    __cil_tmp43 = _mm_xor_si128(b, c);
#line 175
    bc = __cil_tmp43;
#line 175
    __cil_tmp45 = _mm_or_si128(ad, bc);
#line 175
    t1 = __cil_tmp45;
#line 175
    __cil_tmp47 = _mm_or_si128(t1, st);
#line 175
    t2 = __cil_tmp47;
#line 175
    __cil_tmp49 = _mm_and_si128(t2, one);
#line 175
    t3 = __cil_tmp49;
#line 175
    __cil_tmp51 = _mm_avg_epu8(s, t);
#line 175
    t4 = __cil_tmp51;
#line 175
    __cil_tmp53 = _mm_sub_epi8(t4, t3);
#line 175
    k = __cil_tmp53;
    }
    {
#line 175
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 175
      __cil_tmp57 = _mm_avg_epu8(k, t);
#line 175
      tmp0 = __cil_tmp57;
#line 175
      __cil_tmp59 = _mm_and_si128(bc, st);
#line 175
      tmp1 = __cil_tmp59;
#line 175
      __cil_tmp61 = _mm_xor_si128(k, t);
#line 175
      tmp2 = __cil_tmp61;
#line 175
      __cil_tmp63 = _mm_or_si128(tmp1, tmp2);
#line 175
      tmp3 = __cil_tmp63;
#line 175
      __cil_tmp65 = _mm_and_si128(tmp3, one);
#line 175
      tmp4 = __cil_tmp65;
#line 175
      diag1 = _mm_sub_epi8(tmp0, tmp4);
      }
#line 175
      goto while_break___0;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___0: ;
    {
#line 175
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 175
      __cil_tmp68 = _mm_avg_epu8(k, s);
#line 175
      tmp0___0 = __cil_tmp68;
#line 175
      __cil_tmp70 = _mm_and_si128(ad, st);
#line 175
      tmp1___0 = __cil_tmp70;
#line 175
      __cil_tmp72 = _mm_xor_si128(k, s);
#line 175
      tmp2___0 = __cil_tmp72;
#line 175
      __cil_tmp74 = _mm_or_si128(tmp1___0, tmp2___0);
#line 175
      tmp3___0 = __cil_tmp74;
#line 175
      __cil_tmp76 = _mm_and_si128(tmp3___0, one);
#line 175
      tmp4___0 = __cil_tmp76;
#line 175
      diag2 = _mm_sub_epi8(tmp0___0, tmp4___0);
      }
#line 175
      goto while_break___1;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___1: ;
    {
#line 175
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 175
      __cil_tmp79 = _mm_avg_epu8(a, diag1);
#line 175
      t_a = __cil_tmp79;
#line 175
      __cil_tmp81 = _mm_avg_epu8(b, diag2);
#line 175
      t_b = __cil_tmp81;
#line 175
      __cil_tmp83 = _mm_unpackhi_epi8(t_a, t_b);
#line 175
      t_1 = __cil_tmp83;
#line 175
      __cil_tmp85 = _mm_unpackhi_epi8(t_a, t_b);
#line 175
      t_2 = __cil_tmp85;
#line 175
      _mm_store_si128((__m128i *)((r_uv + 0) + 0) + 0, t_1);
#line 175
      _mm_store_si128((__m128i *)((r_uv + 0) + 0) + 1, t_2);
      }
#line 175
      goto while_break___2;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___2: ;
    {
#line 175
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 175
      __cil_tmp87 = _mm_avg_epu8(c, diag2);
#line 175
      t_a___0 = __cil_tmp87;
#line 175
      __cil_tmp89 = _mm_avg_epu8(d, diag1);
#line 175
      t_b___0 = __cil_tmp89;
#line 175
      __cil_tmp91 = _mm_unpackhi_epi8(t_a___0, t_b___0);
#line 175
      t_1___0 = __cil_tmp91;
#line 175
      __cil_tmp93 = _mm_unpackhi_epi8(t_a___0, t_b___0);
#line 175
      t_2___0 = __cil_tmp93;
#line 175
      _mm_store_si128((__m128i *)((r_uv + 0) + 64) + 0, t_1___0);
#line 175
      _mm_store_si128((__m128i *)((r_uv + 0) + 64) + 1, t_2___0);
      }
#line 175
      goto while_break___3;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___3: 
    {
#line 175
    __cil_tmp95 = _mm_set1_epi8((char)1);
#line 175
    one___0 = __cil_tmp95;
#line 175
    __cil_tmp97 = _mm_loadu_si128((__m128i *)(top_v + 0));
#line 175
    a___0 = __cil_tmp97;
#line 175
    __cil_tmp99 = _mm_loadu_si128((__m128i *)(top_v + 1));
#line 175
    b___0 = __cil_tmp99;
#line 175
    __cil_tmp101 = _mm_loadu_si128((__m128i *)(cur_v + 0));
#line 175
    c___0 = __cil_tmp101;
#line 175
    __cil_tmp103 = _mm_loadu_si128((__m128i *)(cur_v + 1));
#line 175
    d___0 = __cil_tmp103;
#line 175
    __cil_tmp105 = _mm_avg_epu8(a___0, d___0);
#line 175
    s___0 = __cil_tmp105;
#line 175
    __cil_tmp107 = _mm_avg_epu8(b___0, c___0);
#line 175
    t___0 = __cil_tmp107;
#line 175
    __cil_tmp109 = _mm_xor_si128(s___0, t___0);
#line 175
    st___0 = __cil_tmp109;
#line 175
    __cil_tmp111 = _mm_xor_si128(a___0, d___0);
#line 175
    ad___0 = __cil_tmp111;
#line 175
    __cil_tmp113 = _mm_xor_si128(b___0, c___0);
#line 175
    bc___0 = __cil_tmp113;
#line 175
    __cil_tmp115 = _mm_or_si128(ad___0, bc___0);
#line 175
    t1___0 = __cil_tmp115;
#line 175
    __cil_tmp117 = _mm_or_si128(t1___0, st___0);
#line 175
    t2___0 = __cil_tmp117;
#line 175
    __cil_tmp119 = _mm_and_si128(t2___0, one___0);
#line 175
    t3___0 = __cil_tmp119;
#line 175
    __cil_tmp121 = _mm_avg_epu8(s___0, t___0);
#line 175
    t4___0 = __cil_tmp121;
#line 175
    __cil_tmp123 = _mm_sub_epi8(t4___0, t3___0);
#line 175
    k___0 = __cil_tmp123;
    }
    {
#line 175
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 175
      __cil_tmp127 = _mm_avg_epu8(k___0, t___0);
#line 175
      tmp0___1 = __cil_tmp127;
#line 175
      __cil_tmp129 = _mm_and_si128(bc___0, st___0);
#line 175
      tmp1___1 = __cil_tmp129;
#line 175
      __cil_tmp131 = _mm_xor_si128(k___0, t___0);
#line 175
      tmp2___1 = __cil_tmp131;
#line 175
      __cil_tmp133 = _mm_or_si128(tmp1___1, tmp2___1);
#line 175
      tmp3___1 = __cil_tmp133;
#line 175
      __cil_tmp135 = _mm_and_si128(tmp3___1, one___0);
#line 175
      tmp4___1 = __cil_tmp135;
#line 175
      diag1___0 = _mm_sub_epi8(tmp0___1, tmp4___1);
      }
#line 175
      goto while_break___4;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___4: ;
    {
#line 175
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 175
      __cil_tmp138 = _mm_avg_epu8(k___0, s___0);
#line 175
      tmp0___2 = __cil_tmp138;
#line 175
      __cil_tmp140 = _mm_and_si128(ad___0, st___0);
#line 175
      tmp1___2 = __cil_tmp140;
#line 175
      __cil_tmp142 = _mm_xor_si128(k___0, s___0);
#line 175
      tmp2___2 = __cil_tmp142;
#line 175
      __cil_tmp144 = _mm_or_si128(tmp1___2, tmp2___2);
#line 175
      tmp3___2 = __cil_tmp144;
#line 175
      __cil_tmp146 = _mm_and_si128(tmp3___2, one___0);
#line 175
      tmp4___2 = __cil_tmp146;
#line 175
      diag2___0 = _mm_sub_epi8(tmp0___2, tmp4___2);
      }
#line 175
      goto while_break___5;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___5: ;
    {
#line 175
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 175
      __cil_tmp149 = _mm_avg_epu8(a___0, diag1___0);
#line 175
      t_a___1 = __cil_tmp149;
#line 175
      __cil_tmp151 = _mm_avg_epu8(b___0, diag2___0);
#line 175
      t_b___1 = __cil_tmp151;
#line 175
      __cil_tmp153 = _mm_unpackhi_epi8(t_a___1, t_b___1);
#line 175
      t_1___1 = __cil_tmp153;
#line 175
      __cil_tmp155 = _mm_unpackhi_epi8(t_a___1, t_b___1);
#line 175
      t_2___1 = __cil_tmp155;
#line 175
      _mm_store_si128((__m128i *)((r_uv + 32) + 0) + 0, t_1___1);
#line 175
      _mm_store_si128((__m128i *)((r_uv + 32) + 0) + 1, t_2___1);
      }
#line 175
      goto while_break___6;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___6: ;
    {
#line 175
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 175
      __cil_tmp157 = _mm_avg_epu8(c___0, diag2___0);
#line 175
      t_a___2 = __cil_tmp157;
#line 175
      __cil_tmp159 = _mm_avg_epu8(d___0, diag1___0);
#line 175
      t_b___2 = __cil_tmp159;
#line 175
      __cil_tmp161 = _mm_unpackhi_epi8(t_a___2, t_b___2);
#line 175
      t_1___2 = __cil_tmp161;
#line 175
      __cil_tmp163 = _mm_unpackhi_epi8(t_a___2, t_b___2);
#line 175
      t_2___2 = __cil_tmp163;
#line 175
      _mm_store_si128((__m128i *)((r_uv + 32) + 64) + 0, t_1___2);
#line 175
      _mm_store_si128((__m128i *)((r_uv + 32) + 64) + 1, t_2___2);
      }
#line 175
      goto while_break___7;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___7: ;
#line 175
    if (top_y) {
#line 175
      n = 0;
      {
#line 175
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 175
        if (! (n < 32)) {
#line 175
          goto while_break___8;
        }
        {
#line 175
        VP8YuvToRgb(*(top_y + ((32 * block + 1) + n)), *(r_uv + n), *(r_uv + (32 + n)),
                    top_dst + ((32 * block + 1) + n) * 3);
#line 175
        n ++;
        }
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___8: ;
    }
#line 175
    if (bottom_y) {
#line 175
      n = 0;
      {
#line 175
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 175
        if (! (n < 32)) {
#line 175
          goto while_break___9;
        }
        {
#line 175
        VP8YuvToRgb(*(bottom_y + ((32 * block + 1) + n)), *(r_uv + (64 + n)), *(r_uv + (96 + n)),
                    bottom_dst + ((32 * block + 1) + n) * 3);
#line 175
        n ++;
        }
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___9: ;
    }
#line 175
    top_u += 16;
#line 175
    cur_u += 16;
#line 175
    top_v += 16;
#line 175
    cur_v += 16;
#line 175
    block ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break: 
  {
#line 175
  memcpy((void *)(r1), (void const   *)top_u, (unsigned long )leftover);
#line 175
  memcpy((void *)(r2), (void const   *)cur_u, (unsigned long )leftover);
#line 175
  memset((void *)(r1 + leftover), (int )r1[leftover - 1], (unsigned long )(17 - leftover));
#line 175
  memset((void *)(r2 + leftover), (int )r2[leftover - 1], (unsigned long )(17 - leftover));
#line 175
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:175)":);
#line 175
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:175)":);
#line 175
  Upsample32Pixels((uint8_t *)0, (uint8_t *)0, r_uv + 0);
#line 175
  memcpy((void *)(r1___0), (void const   *)top_v, (unsigned long )leftover);
#line 175
  memcpy((void *)(r2___0), (void const   *)cur_v, (unsigned long )leftover);
#line 175
  memset((void *)(r1___0 + leftover), (int )r1___0[leftover - 1], (unsigned long )(17 - leftover));
#line 175
  memset((void *)(r2___0 + leftover), (int )r2___0[leftover - 1], (unsigned long )(17 - leftover));
#line 175
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:175)":);
#line 175
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:175)":);
#line 175
  Upsample32Pixels((uint8_t *)0, (uint8_t *)0, r_uv + 32);
  }
#line 175
  if (top_y) {
#line 175
    n___0 = 0;
    {
#line 175
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 175
      if (! (n___0 < len - last_pos)) {
#line 175
        goto while_break___10;
      }
      {
#line 175
      VP8YuvToRgb(*(top_y + (last_pos + n___0)), *(r_uv + n___0), *(r_uv + (32 + n___0)),
                  top_dst + (last_pos + n___0) * 3);
#line 175
      n___0 ++;
      }
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break___10: ;
  }
#line 175
  if (bottom_y) {
#line 175
    n___0 = 0;
    {
#line 175
    while (1) {
      while_continue___11: /* CIL Label */ ;

#line 175
      if (! (n___0 < len - last_pos)) {
#line 175
        goto while_break___11;
      }
      {
#line 175
      VP8YuvToRgb(*(bottom_y + (last_pos + n___0)), *(r_uv + (64 + n___0)), *(r_uv + (96 + n___0)),
                  bottom_dst + (last_pos + n___0) * 3);
#line 175
      n___0 ++;
      }
    }
    while_break___24: /* CIL Label */ ;
    }
    while_break___11: ;
  }
#line 181
  return;
}
}
#line 176 "/root/patchweave_new/13/src/dsp/upsampling_sse2.c"
static void UpsampleBgrLinePairSSE2(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                    uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                    uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int block ;
  uint8_t uv_buf[143] ;
  uint8_t *r_uv ;
  int uv_len ;
  int num_blocks ;
  int leftover ;
  int last_pos ;
  int u_diag ;
  int v_diag ;
  int u0 ;
  int v0 ;
  int u0___0 ;
  int v0___0 ;
  __m128i one ;
  __m128i __cil_tmp25 ;
  __m128i a ;
  __m128i __cil_tmp27 ;
  __m128i b ;
  __m128i __cil_tmp29 ;
  __m128i c ;
  __m128i __cil_tmp31 ;
  __m128i d ;
  __m128i __cil_tmp33 ;
  __m128i s ;
  __m128i __cil_tmp35 ;
  __m128i t ;
  __m128i __cil_tmp37 ;
  __m128i st ;
  __m128i __cil_tmp39 ;
  __m128i ad ;
  __m128i __cil_tmp41 ;
  __m128i bc ;
  __m128i __cil_tmp43 ;
  __m128i t1 ;
  __m128i __cil_tmp45 ;
  __m128i t2 ;
  __m128i __cil_tmp47 ;
  __m128i t3 ;
  __m128i __cil_tmp49 ;
  __m128i t4 ;
  __m128i __cil_tmp51 ;
  __m128i k ;
  __m128i __cil_tmp53 ;
  __m128i diag1 ;
  __m128i diag2 ;
  __m128i tmp0 ;
  __m128i __cil_tmp57 ;
  __m128i tmp1 ;
  __m128i __cil_tmp59 ;
  __m128i tmp2 ;
  __m128i __cil_tmp61 ;
  __m128i tmp3 ;
  __m128i __cil_tmp63 ;
  __m128i tmp4 ;
  __m128i __cil_tmp65 ;
  __m128i tmp0___0 ;
  __m128i __cil_tmp68 ;
  __m128i tmp1___0 ;
  __m128i __cil_tmp70 ;
  __m128i tmp2___0 ;
  __m128i __cil_tmp72 ;
  __m128i tmp3___0 ;
  __m128i __cil_tmp74 ;
  __m128i tmp4___0 ;
  __m128i __cil_tmp76 ;
  __m128i t_a ;
  __m128i __cil_tmp79 ;
  __m128i t_b ;
  __m128i __cil_tmp81 ;
  __m128i t_1 ;
  __m128i __cil_tmp83 ;
  __m128i t_2 ;
  __m128i __cil_tmp85 ;
  __m128i t_a___0 ;
  __m128i __cil_tmp87 ;
  __m128i t_b___0 ;
  __m128i __cil_tmp89 ;
  __m128i t_1___0 ;
  __m128i __cil_tmp91 ;
  __m128i t_2___0 ;
  __m128i __cil_tmp93 ;
  __m128i one___0 ;
  __m128i __cil_tmp95 ;
  __m128i a___0 ;
  __m128i __cil_tmp97 ;
  __m128i b___0 ;
  __m128i __cil_tmp99 ;
  __m128i c___0 ;
  __m128i __cil_tmp101 ;
  __m128i d___0 ;
  __m128i __cil_tmp103 ;
  __m128i s___0 ;
  __m128i __cil_tmp105 ;
  __m128i t___0 ;
  __m128i __cil_tmp107 ;
  __m128i st___0 ;
  __m128i __cil_tmp109 ;
  __m128i ad___0 ;
  __m128i __cil_tmp111 ;
  __m128i bc___0 ;
  __m128i __cil_tmp113 ;
  __m128i t1___0 ;
  __m128i __cil_tmp115 ;
  __m128i t2___0 ;
  __m128i __cil_tmp117 ;
  __m128i t3___0 ;
  __m128i __cil_tmp119 ;
  __m128i t4___0 ;
  __m128i __cil_tmp121 ;
  __m128i k___0 ;
  __m128i __cil_tmp123 ;
  __m128i diag1___0 ;
  __m128i diag2___0 ;
  __m128i tmp0___1 ;
  __m128i __cil_tmp127 ;
  __m128i tmp1___1 ;
  __m128i __cil_tmp129 ;
  __m128i tmp2___1 ;
  __m128i __cil_tmp131 ;
  __m128i tmp3___1 ;
  __m128i __cil_tmp133 ;
  __m128i tmp4___1 ;
  __m128i __cil_tmp135 ;
  __m128i tmp0___2 ;
  __m128i __cil_tmp138 ;
  __m128i tmp1___2 ;
  __m128i __cil_tmp140 ;
  __m128i tmp2___2 ;
  __m128i __cil_tmp142 ;
  __m128i tmp3___2 ;
  __m128i __cil_tmp144 ;
  __m128i tmp4___2 ;
  __m128i __cil_tmp146 ;
  __m128i t_a___1 ;
  __m128i __cil_tmp149 ;
  __m128i t_b___1 ;
  __m128i __cil_tmp151 ;
  __m128i t_1___1 ;
  __m128i __cil_tmp153 ;
  __m128i t_2___1 ;
  __m128i __cil_tmp155 ;
  __m128i t_a___2 ;
  __m128i __cil_tmp157 ;
  __m128i t_b___2 ;
  __m128i __cil_tmp159 ;
  __m128i t_1___2 ;
  __m128i __cil_tmp161 ;
  __m128i t_2___2 ;
  __m128i __cil_tmp163 ;
  int n ;
  uint8_t r1[17] ;
  uint8_t r2[17] ;
  uint8_t r1___0[17] ;
  uint8_t r2___0[17] ;
  int n___0 ;

  {
#line 176
  r_uv = (uint8_t *)((uintptr_t )(uv_buf + 15) & 0xfffffffffffffff0UL);
#line 176
  uv_len = (len + 1) >> 1;
#line 176
  num_blocks = (uv_len - 1) >> 4;
#line 176
  leftover = uv_len - num_blocks * 16;
#line 176
  last_pos = 1 + 32 * num_blocks;
#line 176
  u_diag = (((int )*(top_u + 0) + (int )*(cur_u + 0)) >> 1) + 1;
#line 176
  v_diag = (((int )*(top_v + 0) + (int )*(cur_v + 0)) >> 1) + 1;
#line 176
  if (top_y) {
    {
#line 176
    u0 = ((int )*(top_u + 0) + u_diag) >> 1;
#line 176
    v0 = ((int )*(top_v + 0) + v_diag) >> 1;
#line 176
    VP8YuvToBgr(*(top_y + 0), (uint8_t )u0, (uint8_t )v0, top_dst);
    }
  }
#line 176
  if (bottom_y) {
    {
#line 176
    u0___0 = ((int )*(cur_u + 0) + u_diag) >> 1;
#line 176
    v0___0 = ((int )*(cur_v + 0) + v_diag) >> 1;
#line 176
    VP8YuvToBgr(*(bottom_y + 0), (uint8_t )u0___0, (uint8_t )v0___0, bottom_dst);
    }
  }
#line 176
  block = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;

#line 176
    if (! (block < num_blocks)) {
#line 176
      goto while_break;
    }
    {
#line 176
    __cil_tmp25 = _mm_set1_epi8((char)1);
#line 176
    one = __cil_tmp25;
#line 176
    __cil_tmp27 = _mm_loadu_si128((__m128i *)(top_u + 0));
#line 176
    a = __cil_tmp27;
#line 176
    __cil_tmp29 = _mm_loadu_si128((__m128i *)(top_u + 1));
#line 176
    b = __cil_tmp29;
#line 176
    __cil_tmp31 = _mm_loadu_si128((__m128i *)(cur_u + 0));
#line 176
    c = __cil_tmp31;
#line 176
    __cil_tmp33 = _mm_loadu_si128((__m128i *)(cur_u + 1));
#line 176
    d = __cil_tmp33;
#line 176
    __cil_tmp35 = _mm_avg_epu8(a, d);
#line 176
    s = __cil_tmp35;
#line 176
    __cil_tmp37 = _mm_avg_epu8(b, c);
#line 176
    t = __cil_tmp37;
#line 176
    __cil_tmp39 = _mm_xor_si128(s, t);
#line 176
    st = __cil_tmp39;
#line 176
    __cil_tmp41 = _mm_xor_si128(a, d);
#line 176
    ad = __cil_tmp41;
#line 176
    __cil_tmp43 = _mm_xor_si128(b, c);
#line 176
    bc = __cil_tmp43;
#line 176
    __cil_tmp45 = _mm_or_si128(ad, bc);
#line 176
    t1 = __cil_tmp45;
#line 176
    __cil_tmp47 = _mm_or_si128(t1, st);
#line 176
    t2 = __cil_tmp47;
#line 176
    __cil_tmp49 = _mm_and_si128(t2, one);
#line 176
    t3 = __cil_tmp49;
#line 176
    __cil_tmp51 = _mm_avg_epu8(s, t);
#line 176
    t4 = __cil_tmp51;
#line 176
    __cil_tmp53 = _mm_sub_epi8(t4, t3);
#line 176
    k = __cil_tmp53;
    }
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 176
      __cil_tmp57 = _mm_avg_epu8(k, t);
#line 176
      tmp0 = __cil_tmp57;
#line 176
      __cil_tmp59 = _mm_and_si128(bc, st);
#line 176
      tmp1 = __cil_tmp59;
#line 176
      __cil_tmp61 = _mm_xor_si128(k, t);
#line 176
      tmp2 = __cil_tmp61;
#line 176
      __cil_tmp63 = _mm_or_si128(tmp1, tmp2);
#line 176
      tmp3 = __cil_tmp63;
#line 176
      __cil_tmp65 = _mm_and_si128(tmp3, one);
#line 176
      tmp4 = __cil_tmp65;
#line 176
      diag1 = _mm_sub_epi8(tmp0, tmp4);
      }
#line 176
      goto while_break___0;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___0: ;
    {
#line 176
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 176
      __cil_tmp68 = _mm_avg_epu8(k, s);
#line 176
      tmp0___0 = __cil_tmp68;
#line 176
      __cil_tmp70 = _mm_and_si128(ad, st);
#line 176
      tmp1___0 = __cil_tmp70;
#line 176
      __cil_tmp72 = _mm_xor_si128(k, s);
#line 176
      tmp2___0 = __cil_tmp72;
#line 176
      __cil_tmp74 = _mm_or_si128(tmp1___0, tmp2___0);
#line 176
      tmp3___0 = __cil_tmp74;
#line 176
      __cil_tmp76 = _mm_and_si128(tmp3___0, one);
#line 176
      tmp4___0 = __cil_tmp76;
#line 176
      diag2 = _mm_sub_epi8(tmp0___0, tmp4___0);
      }
#line 176
      goto while_break___1;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___1: ;
    {
#line 176
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 176
      __cil_tmp79 = _mm_avg_epu8(a, diag1);
#line 176
      t_a = __cil_tmp79;
#line 176
      __cil_tmp81 = _mm_avg_epu8(b, diag2);
#line 176
      t_b = __cil_tmp81;
#line 176
      __cil_tmp83 = _mm_unpackhi_epi8(t_a, t_b);
#line 176
      t_1 = __cil_tmp83;
#line 176
      __cil_tmp85 = _mm_unpackhi_epi8(t_a, t_b);
#line 176
      t_2 = __cil_tmp85;
#line 176
      _mm_store_si128((__m128i *)((r_uv + 0) + 0) + 0, t_1);
#line 176
      _mm_store_si128((__m128i *)((r_uv + 0) + 0) + 1, t_2);
      }
#line 176
      goto while_break___2;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___2: ;
    {
#line 176
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 176
      __cil_tmp87 = _mm_avg_epu8(c, diag2);
#line 176
      t_a___0 = __cil_tmp87;
#line 176
      __cil_tmp89 = _mm_avg_epu8(d, diag1);
#line 176
      t_b___0 = __cil_tmp89;
#line 176
      __cil_tmp91 = _mm_unpackhi_epi8(t_a___0, t_b___0);
#line 176
      t_1___0 = __cil_tmp91;
#line 176
      __cil_tmp93 = _mm_unpackhi_epi8(t_a___0, t_b___0);
#line 176
      t_2___0 = __cil_tmp93;
#line 176
      _mm_store_si128((__m128i *)((r_uv + 0) + 64) + 0, t_1___0);
#line 176
      _mm_store_si128((__m128i *)((r_uv + 0) + 64) + 1, t_2___0);
      }
#line 176
      goto while_break___3;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___3: 
    {
#line 176
    __cil_tmp95 = _mm_set1_epi8((char)1);
#line 176
    one___0 = __cil_tmp95;
#line 176
    __cil_tmp97 = _mm_loadu_si128((__m128i *)(top_v + 0));
#line 176
    a___0 = __cil_tmp97;
#line 176
    __cil_tmp99 = _mm_loadu_si128((__m128i *)(top_v + 1));
#line 176
    b___0 = __cil_tmp99;
#line 176
    __cil_tmp101 = _mm_loadu_si128((__m128i *)(cur_v + 0));
#line 176
    c___0 = __cil_tmp101;
#line 176
    __cil_tmp103 = _mm_loadu_si128((__m128i *)(cur_v + 1));
#line 176
    d___0 = __cil_tmp103;
#line 176
    __cil_tmp105 = _mm_avg_epu8(a___0, d___0);
#line 176
    s___0 = __cil_tmp105;
#line 176
    __cil_tmp107 = _mm_avg_epu8(b___0, c___0);
#line 176
    t___0 = __cil_tmp107;
#line 176
    __cil_tmp109 = _mm_xor_si128(s___0, t___0);
#line 176
    st___0 = __cil_tmp109;
#line 176
    __cil_tmp111 = _mm_xor_si128(a___0, d___0);
#line 176
    ad___0 = __cil_tmp111;
#line 176
    __cil_tmp113 = _mm_xor_si128(b___0, c___0);
#line 176
    bc___0 = __cil_tmp113;
#line 176
    __cil_tmp115 = _mm_or_si128(ad___0, bc___0);
#line 176
    t1___0 = __cil_tmp115;
#line 176
    __cil_tmp117 = _mm_or_si128(t1___0, st___0);
#line 176
    t2___0 = __cil_tmp117;
#line 176
    __cil_tmp119 = _mm_and_si128(t2___0, one___0);
#line 176
    t3___0 = __cil_tmp119;
#line 176
    __cil_tmp121 = _mm_avg_epu8(s___0, t___0);
#line 176
    t4___0 = __cil_tmp121;
#line 176
    __cil_tmp123 = _mm_sub_epi8(t4___0, t3___0);
#line 176
    k___0 = __cil_tmp123;
    }
    {
#line 176
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 176
      __cil_tmp127 = _mm_avg_epu8(k___0, t___0);
#line 176
      tmp0___1 = __cil_tmp127;
#line 176
      __cil_tmp129 = _mm_and_si128(bc___0, st___0);
#line 176
      tmp1___1 = __cil_tmp129;
#line 176
      __cil_tmp131 = _mm_xor_si128(k___0, t___0);
#line 176
      tmp2___1 = __cil_tmp131;
#line 176
      __cil_tmp133 = _mm_or_si128(tmp1___1, tmp2___1);
#line 176
      tmp3___1 = __cil_tmp133;
#line 176
      __cil_tmp135 = _mm_and_si128(tmp3___1, one___0);
#line 176
      tmp4___1 = __cil_tmp135;
#line 176
      diag1___0 = _mm_sub_epi8(tmp0___1, tmp4___1);
      }
#line 176
      goto while_break___4;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___4: ;
    {
#line 176
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 176
      __cil_tmp138 = _mm_avg_epu8(k___0, s___0);
#line 176
      tmp0___2 = __cil_tmp138;
#line 176
      __cil_tmp140 = _mm_and_si128(ad___0, st___0);
#line 176
      tmp1___2 = __cil_tmp140;
#line 176
      __cil_tmp142 = _mm_xor_si128(k___0, s___0);
#line 176
      tmp2___2 = __cil_tmp142;
#line 176
      __cil_tmp144 = _mm_or_si128(tmp1___2, tmp2___2);
#line 176
      tmp3___2 = __cil_tmp144;
#line 176
      __cil_tmp146 = _mm_and_si128(tmp3___2, one___0);
#line 176
      tmp4___2 = __cil_tmp146;
#line 176
      diag2___0 = _mm_sub_epi8(tmp0___2, tmp4___2);
      }
#line 176
      goto while_break___5;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___5: ;
    {
#line 176
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 176
      __cil_tmp149 = _mm_avg_epu8(a___0, diag1___0);
#line 176
      t_a___1 = __cil_tmp149;
#line 176
      __cil_tmp151 = _mm_avg_epu8(b___0, diag2___0);
#line 176
      t_b___1 = __cil_tmp151;
#line 176
      __cil_tmp153 = _mm_unpackhi_epi8(t_a___1, t_b___1);
#line 176
      t_1___1 = __cil_tmp153;
#line 176
      __cil_tmp155 = _mm_unpackhi_epi8(t_a___1, t_b___1);
#line 176
      t_2___1 = __cil_tmp155;
#line 176
      _mm_store_si128((__m128i *)((r_uv + 32) + 0) + 0, t_1___1);
#line 176
      _mm_store_si128((__m128i *)((r_uv + 32) + 0) + 1, t_2___1);
      }
#line 176
      goto while_break___6;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___6: ;
    {
#line 176
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 176
      __cil_tmp157 = _mm_avg_epu8(c___0, diag2___0);
#line 176
      t_a___2 = __cil_tmp157;
#line 176
      __cil_tmp159 = _mm_avg_epu8(d___0, diag1___0);
#line 176
      t_b___2 = __cil_tmp159;
#line 176
      __cil_tmp161 = _mm_unpackhi_epi8(t_a___2, t_b___2);
#line 176
      t_1___2 = __cil_tmp161;
#line 176
      __cil_tmp163 = _mm_unpackhi_epi8(t_a___2, t_b___2);
#line 176
      t_2___2 = __cil_tmp163;
#line 176
      _mm_store_si128((__m128i *)((r_uv + 32) + 64) + 0, t_1___2);
#line 176
      _mm_store_si128((__m128i *)((r_uv + 32) + 64) + 1, t_2___2);
      }
#line 176
      goto while_break___7;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___7: ;
#line 176
    if (top_y) {
#line 176
      n = 0;
      {
#line 176
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 176
        if (! (n < 32)) {
#line 176
          goto while_break___8;
        }
        {
#line 176
        VP8YuvToBgr(*(top_y + ((32 * block + 1) + n)), *(r_uv + n), *(r_uv + (32 + n)),
                    top_dst + ((32 * block + 1) + n) * 3);
#line 176
        n ++;
        }
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___8: ;
    }
#line 176
    if (bottom_y) {
#line 176
      n = 0;
      {
#line 176
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 176
        if (! (n < 32)) {
#line 176
          goto while_break___9;
        }
        {
#line 176
        VP8YuvToBgr(*(bottom_y + ((32 * block + 1) + n)), *(r_uv + (64 + n)), *(r_uv + (96 + n)),
                    bottom_dst + ((32 * block + 1) + n) * 3);
#line 176
        n ++;
        }
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___9: ;
    }
#line 176
    top_u += 16;
#line 176
    cur_u += 16;
#line 176
    top_v += 16;
#line 176
    cur_v += 16;
#line 176
    block ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break: 
  {
#line 176
  memcpy((void *)(r1), (void const   *)top_u, (unsigned long )leftover);
#line 176
  memcpy((void *)(r2), (void const   *)cur_u, (unsigned long )leftover);
#line 176
  memset((void *)(r1 + leftover), (int )r1[leftover - 1], (unsigned long )(17 - leftover));
#line 176
  memset((void *)(r2 + leftover), (int )r2[leftover - 1], (unsigned long )(17 - leftover));
#line 176
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:176)":);
#line 176
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:176)":);
#line 176
  Upsample32Pixels((uint8_t *)0, (uint8_t *)0, r_uv + 0);
#line 176
  memcpy((void *)(r1___0), (void const   *)top_v, (unsigned long )leftover);
#line 176
  memcpy((void *)(r2___0), (void const   *)cur_v, (unsigned long )leftover);
#line 176
  memset((void *)(r1___0 + leftover), (int )r1___0[leftover - 1], (unsigned long )(17 - leftover));
#line 176
  memset((void *)(r2___0 + leftover), (int )r2___0[leftover - 1], (unsigned long )(17 - leftover));
#line 176
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:176)":);
#line 176
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:176)":);
#line 176
  Upsample32Pixels((uint8_t *)0, (uint8_t *)0, r_uv + 32);
  }
#line 176
  if (top_y) {
#line 176
    n___0 = 0;
    {
#line 176
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 176
      if (! (n___0 < len - last_pos)) {
#line 176
        goto while_break___10;
      }
      {
#line 176
      VP8YuvToBgr(*(top_y + (last_pos + n___0)), *(r_uv + n___0), *(r_uv + (32 + n___0)),
                  top_dst + (last_pos + n___0) * 3);
#line 176
      n___0 ++;
      }
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break___10: ;
  }
#line 176
  if (bottom_y) {
#line 176
    n___0 = 0;
    {
#line 176
    while (1) {
      while_continue___11: /* CIL Label */ ;

#line 176
      if (! (n___0 < len - last_pos)) {
#line 176
        goto while_break___11;
      }
      {
#line 176
      VP8YuvToBgr(*(bottom_y + (last_pos + n___0)), *(r_uv + (64 + n___0)), *(r_uv + (96 + n___0)),
                  bottom_dst + (last_pos + n___0) * 3);
#line 176
      n___0 ++;
      }
    }
    while_break___24: /* CIL Label */ ;
    }
    while_break___11: ;
  }
#line 182
  return;
}
}
#line 177 "/root/patchweave_new/13/src/dsp/upsampling_sse2.c"
static void UpsampleRgbaLinePairSSE2(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                     uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                     uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int block ;
  uint8_t uv_buf[143] ;
  uint8_t *r_uv ;
  int uv_len ;
  int num_blocks ;
  int leftover ;
  int last_pos ;
  int u_diag ;
  int v_diag ;
  int u0 ;
  int v0 ;
  int u0___0 ;
  int v0___0 ;
  __m128i one ;
  __m128i __cil_tmp25 ;
  __m128i a ;
  __m128i __cil_tmp27 ;
  __m128i b ;
  __m128i __cil_tmp29 ;
  __m128i c ;
  __m128i __cil_tmp31 ;
  __m128i d ;
  __m128i __cil_tmp33 ;
  __m128i s ;
  __m128i __cil_tmp35 ;
  __m128i t ;
  __m128i __cil_tmp37 ;
  __m128i st ;
  __m128i __cil_tmp39 ;
  __m128i ad ;
  __m128i __cil_tmp41 ;
  __m128i bc ;
  __m128i __cil_tmp43 ;
  __m128i t1 ;
  __m128i __cil_tmp45 ;
  __m128i t2 ;
  __m128i __cil_tmp47 ;
  __m128i t3 ;
  __m128i __cil_tmp49 ;
  __m128i t4 ;
  __m128i __cil_tmp51 ;
  __m128i k ;
  __m128i __cil_tmp53 ;
  __m128i diag1 ;
  __m128i diag2 ;
  __m128i tmp0 ;
  __m128i __cil_tmp57 ;
  __m128i tmp1 ;
  __m128i __cil_tmp59 ;
  __m128i tmp2 ;
  __m128i __cil_tmp61 ;
  __m128i tmp3 ;
  __m128i __cil_tmp63 ;
  __m128i tmp4 ;
  __m128i __cil_tmp65 ;
  __m128i tmp0___0 ;
  __m128i __cil_tmp68 ;
  __m128i tmp1___0 ;
  __m128i __cil_tmp70 ;
  __m128i tmp2___0 ;
  __m128i __cil_tmp72 ;
  __m128i tmp3___0 ;
  __m128i __cil_tmp74 ;
  __m128i tmp4___0 ;
  __m128i __cil_tmp76 ;
  __m128i t_a ;
  __m128i __cil_tmp79 ;
  __m128i t_b ;
  __m128i __cil_tmp81 ;
  __m128i t_1 ;
  __m128i __cil_tmp83 ;
  __m128i t_2 ;
  __m128i __cil_tmp85 ;
  __m128i t_a___0 ;
  __m128i __cil_tmp87 ;
  __m128i t_b___0 ;
  __m128i __cil_tmp89 ;
  __m128i t_1___0 ;
  __m128i __cil_tmp91 ;
  __m128i t_2___0 ;
  __m128i __cil_tmp93 ;
  __m128i one___0 ;
  __m128i __cil_tmp95 ;
  __m128i a___0 ;
  __m128i __cil_tmp97 ;
  __m128i b___0 ;
  __m128i __cil_tmp99 ;
  __m128i c___0 ;
  __m128i __cil_tmp101 ;
  __m128i d___0 ;
  __m128i __cil_tmp103 ;
  __m128i s___0 ;
  __m128i __cil_tmp105 ;
  __m128i t___0 ;
  __m128i __cil_tmp107 ;
  __m128i st___0 ;
  __m128i __cil_tmp109 ;
  __m128i ad___0 ;
  __m128i __cil_tmp111 ;
  __m128i bc___0 ;
  __m128i __cil_tmp113 ;
  __m128i t1___0 ;
  __m128i __cil_tmp115 ;
  __m128i t2___0 ;
  __m128i __cil_tmp117 ;
  __m128i t3___0 ;
  __m128i __cil_tmp119 ;
  __m128i t4___0 ;
  __m128i __cil_tmp121 ;
  __m128i k___0 ;
  __m128i __cil_tmp123 ;
  __m128i diag1___0 ;
  __m128i diag2___0 ;
  __m128i tmp0___1 ;
  __m128i __cil_tmp127 ;
  __m128i tmp1___1 ;
  __m128i __cil_tmp129 ;
  __m128i tmp2___1 ;
  __m128i __cil_tmp131 ;
  __m128i tmp3___1 ;
  __m128i __cil_tmp133 ;
  __m128i tmp4___1 ;
  __m128i __cil_tmp135 ;
  __m128i tmp0___2 ;
  __m128i __cil_tmp138 ;
  __m128i tmp1___2 ;
  __m128i __cil_tmp140 ;
  __m128i tmp2___2 ;
  __m128i __cil_tmp142 ;
  __m128i tmp3___2 ;
  __m128i __cil_tmp144 ;
  __m128i tmp4___2 ;
  __m128i __cil_tmp146 ;
  __m128i t_a___1 ;
  __m128i __cil_tmp149 ;
  __m128i t_b___1 ;
  __m128i __cil_tmp151 ;
  __m128i t_1___1 ;
  __m128i __cil_tmp153 ;
  __m128i t_2___1 ;
  __m128i __cil_tmp155 ;
  __m128i t_a___2 ;
  __m128i __cil_tmp157 ;
  __m128i t_b___2 ;
  __m128i __cil_tmp159 ;
  __m128i t_1___2 ;
  __m128i __cil_tmp161 ;
  __m128i t_2___2 ;
  __m128i __cil_tmp163 ;
  int n ;
  uint8_t r1[17] ;
  uint8_t r2[17] ;
  uint8_t r1___0[17] ;
  uint8_t r2___0[17] ;
  int n___0 ;

  {
#line 177
  r_uv = (uint8_t *)((uintptr_t )(uv_buf + 15) & 0xfffffffffffffff0UL);
#line 177
  uv_len = (len + 1) >> 1;
#line 177
  num_blocks = (uv_len - 1) >> 4;
#line 177
  leftover = uv_len - num_blocks * 16;
#line 177
  last_pos = 1 + 32 * num_blocks;
#line 177
  u_diag = (((int )*(top_u + 0) + (int )*(cur_u + 0)) >> 1) + 1;
#line 177
  v_diag = (((int )*(top_v + 0) + (int )*(cur_v + 0)) >> 1) + 1;
#line 177
  if (top_y) {
    {
#line 177
    u0 = ((int )*(top_u + 0) + u_diag) >> 1;
#line 177
    v0 = ((int )*(top_v + 0) + v_diag) >> 1;
#line 177
    VP8YuvToRgba(*(top_y + 0), (uint8_t )u0, (uint8_t )v0, top_dst);
    }
  }
#line 177
  if (bottom_y) {
    {
#line 177
    u0___0 = ((int )*(cur_u + 0) + u_diag) >> 1;
#line 177
    v0___0 = ((int )*(cur_v + 0) + v_diag) >> 1;
#line 177
    VP8YuvToRgba(*(bottom_y + 0), (uint8_t )u0___0, (uint8_t )v0___0, bottom_dst);
    }
  }
#line 177
  block = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;

#line 177
    if (! (block < num_blocks)) {
#line 177
      goto while_break;
    }
    {
#line 177
    __cil_tmp25 = _mm_set1_epi8((char)1);
#line 177
    one = __cil_tmp25;
#line 177
    __cil_tmp27 = _mm_loadu_si128((__m128i *)(top_u + 0));
#line 177
    a = __cil_tmp27;
#line 177
    __cil_tmp29 = _mm_loadu_si128((__m128i *)(top_u + 1));
#line 177
    b = __cil_tmp29;
#line 177
    __cil_tmp31 = _mm_loadu_si128((__m128i *)(cur_u + 0));
#line 177
    c = __cil_tmp31;
#line 177
    __cil_tmp33 = _mm_loadu_si128((__m128i *)(cur_u + 1));
#line 177
    d = __cil_tmp33;
#line 177
    __cil_tmp35 = _mm_avg_epu8(a, d);
#line 177
    s = __cil_tmp35;
#line 177
    __cil_tmp37 = _mm_avg_epu8(b, c);
#line 177
    t = __cil_tmp37;
#line 177
    __cil_tmp39 = _mm_xor_si128(s, t);
#line 177
    st = __cil_tmp39;
#line 177
    __cil_tmp41 = _mm_xor_si128(a, d);
#line 177
    ad = __cil_tmp41;
#line 177
    __cil_tmp43 = _mm_xor_si128(b, c);
#line 177
    bc = __cil_tmp43;
#line 177
    __cil_tmp45 = _mm_or_si128(ad, bc);
#line 177
    t1 = __cil_tmp45;
#line 177
    __cil_tmp47 = _mm_or_si128(t1, st);
#line 177
    t2 = __cil_tmp47;
#line 177
    __cil_tmp49 = _mm_and_si128(t2, one);
#line 177
    t3 = __cil_tmp49;
#line 177
    __cil_tmp51 = _mm_avg_epu8(s, t);
#line 177
    t4 = __cil_tmp51;
#line 177
    __cil_tmp53 = _mm_sub_epi8(t4, t3);
#line 177
    k = __cil_tmp53;
    }
    {
#line 177
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 177
      __cil_tmp57 = _mm_avg_epu8(k, t);
#line 177
      tmp0 = __cil_tmp57;
#line 177
      __cil_tmp59 = _mm_and_si128(bc, st);
#line 177
      tmp1 = __cil_tmp59;
#line 177
      __cil_tmp61 = _mm_xor_si128(k, t);
#line 177
      tmp2 = __cil_tmp61;
#line 177
      __cil_tmp63 = _mm_or_si128(tmp1, tmp2);
#line 177
      tmp3 = __cil_tmp63;
#line 177
      __cil_tmp65 = _mm_and_si128(tmp3, one);
#line 177
      tmp4 = __cil_tmp65;
#line 177
      diag1 = _mm_sub_epi8(tmp0, tmp4);
      }
#line 177
      goto while_break___0;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___0: ;
    {
#line 177
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 177
      __cil_tmp68 = _mm_avg_epu8(k, s);
#line 177
      tmp0___0 = __cil_tmp68;
#line 177
      __cil_tmp70 = _mm_and_si128(ad, st);
#line 177
      tmp1___0 = __cil_tmp70;
#line 177
      __cil_tmp72 = _mm_xor_si128(k, s);
#line 177
      tmp2___0 = __cil_tmp72;
#line 177
      __cil_tmp74 = _mm_or_si128(tmp1___0, tmp2___0);
#line 177
      tmp3___0 = __cil_tmp74;
#line 177
      __cil_tmp76 = _mm_and_si128(tmp3___0, one);
#line 177
      tmp4___0 = __cil_tmp76;
#line 177
      diag2 = _mm_sub_epi8(tmp0___0, tmp4___0);
      }
#line 177
      goto while_break___1;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___1: ;
    {
#line 177
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 177
      __cil_tmp79 = _mm_avg_epu8(a, diag1);
#line 177
      t_a = __cil_tmp79;
#line 177
      __cil_tmp81 = _mm_avg_epu8(b, diag2);
#line 177
      t_b = __cil_tmp81;
#line 177
      __cil_tmp83 = _mm_unpackhi_epi8(t_a, t_b);
#line 177
      t_1 = __cil_tmp83;
#line 177
      __cil_tmp85 = _mm_unpackhi_epi8(t_a, t_b);
#line 177
      t_2 = __cil_tmp85;
#line 177
      _mm_store_si128((__m128i *)((r_uv + 0) + 0) + 0, t_1);
#line 177
      _mm_store_si128((__m128i *)((r_uv + 0) + 0) + 1, t_2);
      }
#line 177
      goto while_break___2;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___2: ;
    {
#line 177
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 177
      __cil_tmp87 = _mm_avg_epu8(c, diag2);
#line 177
      t_a___0 = __cil_tmp87;
#line 177
      __cil_tmp89 = _mm_avg_epu8(d, diag1);
#line 177
      t_b___0 = __cil_tmp89;
#line 177
      __cil_tmp91 = _mm_unpackhi_epi8(t_a___0, t_b___0);
#line 177
      t_1___0 = __cil_tmp91;
#line 177
      __cil_tmp93 = _mm_unpackhi_epi8(t_a___0, t_b___0);
#line 177
      t_2___0 = __cil_tmp93;
#line 177
      _mm_store_si128((__m128i *)((r_uv + 0) + 64) + 0, t_1___0);
#line 177
      _mm_store_si128((__m128i *)((r_uv + 0) + 64) + 1, t_2___0);
      }
#line 177
      goto while_break___3;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___3: 
    {
#line 177
    __cil_tmp95 = _mm_set1_epi8((char)1);
#line 177
    one___0 = __cil_tmp95;
#line 177
    __cil_tmp97 = _mm_loadu_si128((__m128i *)(top_v + 0));
#line 177
    a___0 = __cil_tmp97;
#line 177
    __cil_tmp99 = _mm_loadu_si128((__m128i *)(top_v + 1));
#line 177
    b___0 = __cil_tmp99;
#line 177
    __cil_tmp101 = _mm_loadu_si128((__m128i *)(cur_v + 0));
#line 177
    c___0 = __cil_tmp101;
#line 177
    __cil_tmp103 = _mm_loadu_si128((__m128i *)(cur_v + 1));
#line 177
    d___0 = __cil_tmp103;
#line 177
    __cil_tmp105 = _mm_avg_epu8(a___0, d___0);
#line 177
    s___0 = __cil_tmp105;
#line 177
    __cil_tmp107 = _mm_avg_epu8(b___0, c___0);
#line 177
    t___0 = __cil_tmp107;
#line 177
    __cil_tmp109 = _mm_xor_si128(s___0, t___0);
#line 177
    st___0 = __cil_tmp109;
#line 177
    __cil_tmp111 = _mm_xor_si128(a___0, d___0);
#line 177
    ad___0 = __cil_tmp111;
#line 177
    __cil_tmp113 = _mm_xor_si128(b___0, c___0);
#line 177
    bc___0 = __cil_tmp113;
#line 177
    __cil_tmp115 = _mm_or_si128(ad___0, bc___0);
#line 177
    t1___0 = __cil_tmp115;
#line 177
    __cil_tmp117 = _mm_or_si128(t1___0, st___0);
#line 177
    t2___0 = __cil_tmp117;
#line 177
    __cil_tmp119 = _mm_and_si128(t2___0, one___0);
#line 177
    t3___0 = __cil_tmp119;
#line 177
    __cil_tmp121 = _mm_avg_epu8(s___0, t___0);
#line 177
    t4___0 = __cil_tmp121;
#line 177
    __cil_tmp123 = _mm_sub_epi8(t4___0, t3___0);
#line 177
    k___0 = __cil_tmp123;
    }
    {
#line 177
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 177
      __cil_tmp127 = _mm_avg_epu8(k___0, t___0);
#line 177
      tmp0___1 = __cil_tmp127;
#line 177
      __cil_tmp129 = _mm_and_si128(bc___0, st___0);
#line 177
      tmp1___1 = __cil_tmp129;
#line 177
      __cil_tmp131 = _mm_xor_si128(k___0, t___0);
#line 177
      tmp2___1 = __cil_tmp131;
#line 177
      __cil_tmp133 = _mm_or_si128(tmp1___1, tmp2___1);
#line 177
      tmp3___1 = __cil_tmp133;
#line 177
      __cil_tmp135 = _mm_and_si128(tmp3___1, one___0);
#line 177
      tmp4___1 = __cil_tmp135;
#line 177
      diag1___0 = _mm_sub_epi8(tmp0___1, tmp4___1);
      }
#line 177
      goto while_break___4;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___4: ;
    {
#line 177
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 177
      __cil_tmp138 = _mm_avg_epu8(k___0, s___0);
#line 177
      tmp0___2 = __cil_tmp138;
#line 177
      __cil_tmp140 = _mm_and_si128(ad___0, st___0);
#line 177
      tmp1___2 = __cil_tmp140;
#line 177
      __cil_tmp142 = _mm_xor_si128(k___0, s___0);
#line 177
      tmp2___2 = __cil_tmp142;
#line 177
      __cil_tmp144 = _mm_or_si128(tmp1___2, tmp2___2);
#line 177
      tmp3___2 = __cil_tmp144;
#line 177
      __cil_tmp146 = _mm_and_si128(tmp3___2, one___0);
#line 177
      tmp4___2 = __cil_tmp146;
#line 177
      diag2___0 = _mm_sub_epi8(tmp0___2, tmp4___2);
      }
#line 177
      goto while_break___5;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___5: ;
    {
#line 177
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 177
      __cil_tmp149 = _mm_avg_epu8(a___0, diag1___0);
#line 177
      t_a___1 = __cil_tmp149;
#line 177
      __cil_tmp151 = _mm_avg_epu8(b___0, diag2___0);
#line 177
      t_b___1 = __cil_tmp151;
#line 177
      __cil_tmp153 = _mm_unpackhi_epi8(t_a___1, t_b___1);
#line 177
      t_1___1 = __cil_tmp153;
#line 177
      __cil_tmp155 = _mm_unpackhi_epi8(t_a___1, t_b___1);
#line 177
      t_2___1 = __cil_tmp155;
#line 177
      _mm_store_si128((__m128i *)((r_uv + 32) + 0) + 0, t_1___1);
#line 177
      _mm_store_si128((__m128i *)((r_uv + 32) + 0) + 1, t_2___1);
      }
#line 177
      goto while_break___6;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___6: ;
    {
#line 177
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 177
      __cil_tmp157 = _mm_avg_epu8(c___0, diag2___0);
#line 177
      t_a___2 = __cil_tmp157;
#line 177
      __cil_tmp159 = _mm_avg_epu8(d___0, diag1___0);
#line 177
      t_b___2 = __cil_tmp159;
#line 177
      __cil_tmp161 = _mm_unpackhi_epi8(t_a___2, t_b___2);
#line 177
      t_1___2 = __cil_tmp161;
#line 177
      __cil_tmp163 = _mm_unpackhi_epi8(t_a___2, t_b___2);
#line 177
      t_2___2 = __cil_tmp163;
#line 177
      _mm_store_si128((__m128i *)((r_uv + 32) + 64) + 0, t_1___2);
#line 177
      _mm_store_si128((__m128i *)((r_uv + 32) + 64) + 1, t_2___2);
      }
#line 177
      goto while_break___7;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___7: ;
#line 177
    if (top_y) {
#line 177
      n = 0;
      {
#line 177
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 177
        if (! (n < 32)) {
#line 177
          goto while_break___8;
        }
        {
#line 177
        VP8YuvToRgba(*(top_y + ((32 * block + 1) + n)), *(r_uv + n), *(r_uv + (32 + n)),
                     top_dst + ((32 * block + 1) + n) * 4);
#line 177
        n ++;
        }
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___8: ;
    }
#line 177
    if (bottom_y) {
#line 177
      n = 0;
      {
#line 177
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 177
        if (! (n < 32)) {
#line 177
          goto while_break___9;
        }
        {
#line 177
        VP8YuvToRgba(*(bottom_y + ((32 * block + 1) + n)), *(r_uv + (64 + n)), *(r_uv + (96 + n)),
                     bottom_dst + ((32 * block + 1) + n) * 4);
#line 177
        n ++;
        }
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___9: ;
    }
#line 177
    top_u += 16;
#line 177
    cur_u += 16;
#line 177
    top_v += 16;
#line 177
    cur_v += 16;
#line 177
    block ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break: 
  {
#line 177
  memcpy((void *)(r1), (void const   *)top_u, (unsigned long )leftover);
#line 177
  memcpy((void *)(r2), (void const   *)cur_u, (unsigned long )leftover);
#line 177
  memset((void *)(r1 + leftover), (int )r1[leftover - 1], (unsigned long )(17 - leftover));
#line 177
  memset((void *)(r2 + leftover), (int )r2[leftover - 1], (unsigned long )(17 - leftover));
#line 177
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:177)":);
#line 177
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:177)":);
#line 177
  Upsample32Pixels((uint8_t *)0, (uint8_t *)0, r_uv + 0);
#line 177
  memcpy((void *)(r1___0), (void const   *)top_v, (unsigned long )leftover);
#line 177
  memcpy((void *)(r2___0), (void const   *)cur_v, (unsigned long )leftover);
#line 177
  memset((void *)(r1___0 + leftover), (int )r1___0[leftover - 1], (unsigned long )(17 - leftover));
#line 177
  memset((void *)(r2___0 + leftover), (int )r2___0[leftover - 1], (unsigned long )(17 - leftover));
#line 177
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:177)":);
#line 177
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:177)":);
#line 177
  Upsample32Pixels((uint8_t *)0, (uint8_t *)0, r_uv + 32);
  }
#line 177
  if (top_y) {
#line 177
    n___0 = 0;
    {
#line 177
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 177
      if (! (n___0 < len - last_pos)) {
#line 177
        goto while_break___10;
      }
      {
#line 177
      VP8YuvToRgba(*(top_y + (last_pos + n___0)), *(r_uv + n___0), *(r_uv + (32 + n___0)),
                   top_dst + (last_pos + n___0) * 4);
#line 177
      n___0 ++;
      }
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break___10: ;
  }
#line 177
  if (bottom_y) {
#line 177
    n___0 = 0;
    {
#line 177
    while (1) {
      while_continue___11: /* CIL Label */ ;

#line 177
      if (! (n___0 < len - last_pos)) {
#line 177
        goto while_break___11;
      }
      {
#line 177
      VP8YuvToRgba(*(bottom_y + (last_pos + n___0)), *(r_uv + (64 + n___0)), *(r_uv + (96 + n___0)),
                   bottom_dst + (last_pos + n___0) * 4);
#line 177
      n___0 ++;
      }
    }
    while_break___24: /* CIL Label */ ;
    }
    while_break___11: ;
  }
#line 183
  return;
}
}
#line 178 "/root/patchweave_new/13/src/dsp/upsampling_sse2.c"
static void UpsampleBgraLinePairSSE2(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                     uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                     uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int block ;
  uint8_t uv_buf[143] ;
  uint8_t *r_uv ;
  int uv_len ;
  int num_blocks ;
  int leftover ;
  int last_pos ;
  int u_diag ;
  int v_diag ;
  int u0 ;
  int v0 ;
  int u0___0 ;
  int v0___0 ;
  __m128i one ;
  __m128i __cil_tmp25 ;
  __m128i a ;
  __m128i __cil_tmp27 ;
  __m128i b ;
  __m128i __cil_tmp29 ;
  __m128i c ;
  __m128i __cil_tmp31 ;
  __m128i d ;
  __m128i __cil_tmp33 ;
  __m128i s ;
  __m128i __cil_tmp35 ;
  __m128i t ;
  __m128i __cil_tmp37 ;
  __m128i st ;
  __m128i __cil_tmp39 ;
  __m128i ad ;
  __m128i __cil_tmp41 ;
  __m128i bc ;
  __m128i __cil_tmp43 ;
  __m128i t1 ;
  __m128i __cil_tmp45 ;
  __m128i t2 ;
  __m128i __cil_tmp47 ;
  __m128i t3 ;
  __m128i __cil_tmp49 ;
  __m128i t4 ;
  __m128i __cil_tmp51 ;
  __m128i k ;
  __m128i __cil_tmp53 ;
  __m128i diag1 ;
  __m128i diag2 ;
  __m128i tmp0 ;
  __m128i __cil_tmp57 ;
  __m128i tmp1 ;
  __m128i __cil_tmp59 ;
  __m128i tmp2 ;
  __m128i __cil_tmp61 ;
  __m128i tmp3 ;
  __m128i __cil_tmp63 ;
  __m128i tmp4 ;
  __m128i __cil_tmp65 ;
  __m128i tmp0___0 ;
  __m128i __cil_tmp68 ;
  __m128i tmp1___0 ;
  __m128i __cil_tmp70 ;
  __m128i tmp2___0 ;
  __m128i __cil_tmp72 ;
  __m128i tmp3___0 ;
  __m128i __cil_tmp74 ;
  __m128i tmp4___0 ;
  __m128i __cil_tmp76 ;
  __m128i t_a ;
  __m128i __cil_tmp79 ;
  __m128i t_b ;
  __m128i __cil_tmp81 ;
  __m128i t_1 ;
  __m128i __cil_tmp83 ;
  __m128i t_2 ;
  __m128i __cil_tmp85 ;
  __m128i t_a___0 ;
  __m128i __cil_tmp87 ;
  __m128i t_b___0 ;
  __m128i __cil_tmp89 ;
  __m128i t_1___0 ;
  __m128i __cil_tmp91 ;
  __m128i t_2___0 ;
  __m128i __cil_tmp93 ;
  __m128i one___0 ;
  __m128i __cil_tmp95 ;
  __m128i a___0 ;
  __m128i __cil_tmp97 ;
  __m128i b___0 ;
  __m128i __cil_tmp99 ;
  __m128i c___0 ;
  __m128i __cil_tmp101 ;
  __m128i d___0 ;
  __m128i __cil_tmp103 ;
  __m128i s___0 ;
  __m128i __cil_tmp105 ;
  __m128i t___0 ;
  __m128i __cil_tmp107 ;
  __m128i st___0 ;
  __m128i __cil_tmp109 ;
  __m128i ad___0 ;
  __m128i __cil_tmp111 ;
  __m128i bc___0 ;
  __m128i __cil_tmp113 ;
  __m128i t1___0 ;
  __m128i __cil_tmp115 ;
  __m128i t2___0 ;
  __m128i __cil_tmp117 ;
  __m128i t3___0 ;
  __m128i __cil_tmp119 ;
  __m128i t4___0 ;
  __m128i __cil_tmp121 ;
  __m128i k___0 ;
  __m128i __cil_tmp123 ;
  __m128i diag1___0 ;
  __m128i diag2___0 ;
  __m128i tmp0___1 ;
  __m128i __cil_tmp127 ;
  __m128i tmp1___1 ;
  __m128i __cil_tmp129 ;
  __m128i tmp2___1 ;
  __m128i __cil_tmp131 ;
  __m128i tmp3___1 ;
  __m128i __cil_tmp133 ;
  __m128i tmp4___1 ;
  __m128i __cil_tmp135 ;
  __m128i tmp0___2 ;
  __m128i __cil_tmp138 ;
  __m128i tmp1___2 ;
  __m128i __cil_tmp140 ;
  __m128i tmp2___2 ;
  __m128i __cil_tmp142 ;
  __m128i tmp3___2 ;
  __m128i __cil_tmp144 ;
  __m128i tmp4___2 ;
  __m128i __cil_tmp146 ;
  __m128i t_a___1 ;
  __m128i __cil_tmp149 ;
  __m128i t_b___1 ;
  __m128i __cil_tmp151 ;
  __m128i t_1___1 ;
  __m128i __cil_tmp153 ;
  __m128i t_2___1 ;
  __m128i __cil_tmp155 ;
  __m128i t_a___2 ;
  __m128i __cil_tmp157 ;
  __m128i t_b___2 ;
  __m128i __cil_tmp159 ;
  __m128i t_1___2 ;
  __m128i __cil_tmp161 ;
  __m128i t_2___2 ;
  __m128i __cil_tmp163 ;
  int n ;
  uint8_t r1[17] ;
  uint8_t r2[17] ;
  uint8_t r1___0[17] ;
  uint8_t r2___0[17] ;
  int n___0 ;

  {
#line 178
  r_uv = (uint8_t *)((uintptr_t )(uv_buf + 15) & 0xfffffffffffffff0UL);
#line 178
  uv_len = (len + 1) >> 1;
#line 178
  num_blocks = (uv_len - 1) >> 4;
#line 178
  leftover = uv_len - num_blocks * 16;
#line 178
  last_pos = 1 + 32 * num_blocks;
#line 178
  u_diag = (((int )*(top_u + 0) + (int )*(cur_u + 0)) >> 1) + 1;
#line 178
  v_diag = (((int )*(top_v + 0) + (int )*(cur_v + 0)) >> 1) + 1;
#line 178
  if (top_y) {
    {
#line 178
    u0 = ((int )*(top_u + 0) + u_diag) >> 1;
#line 178
    v0 = ((int )*(top_v + 0) + v_diag) >> 1;
#line 178
    VP8YuvToBgra(*(top_y + 0), (uint8_t )u0, (uint8_t )v0, top_dst);
    }
  }
#line 178
  if (bottom_y) {
    {
#line 178
    u0___0 = ((int )*(cur_u + 0) + u_diag) >> 1;
#line 178
    v0___0 = ((int )*(cur_v + 0) + v_diag) >> 1;
#line 178
    VP8YuvToBgra(*(bottom_y + 0), (uint8_t )u0___0, (uint8_t )v0___0, bottom_dst);
    }
  }
#line 178
  block = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;

#line 178
    if (! (block < num_blocks)) {
#line 178
      goto while_break;
    }
    {
#line 178
    __cil_tmp25 = _mm_set1_epi8((char)1);
#line 178
    one = __cil_tmp25;
#line 178
    __cil_tmp27 = _mm_loadu_si128((__m128i *)(top_u + 0));
#line 178
    a = __cil_tmp27;
#line 178
    __cil_tmp29 = _mm_loadu_si128((__m128i *)(top_u + 1));
#line 178
    b = __cil_tmp29;
#line 178
    __cil_tmp31 = _mm_loadu_si128((__m128i *)(cur_u + 0));
#line 178
    c = __cil_tmp31;
#line 178
    __cil_tmp33 = _mm_loadu_si128((__m128i *)(cur_u + 1));
#line 178
    d = __cil_tmp33;
#line 178
    __cil_tmp35 = _mm_avg_epu8(a, d);
#line 178
    s = __cil_tmp35;
#line 178
    __cil_tmp37 = _mm_avg_epu8(b, c);
#line 178
    t = __cil_tmp37;
#line 178
    __cil_tmp39 = _mm_xor_si128(s, t);
#line 178
    st = __cil_tmp39;
#line 178
    __cil_tmp41 = _mm_xor_si128(a, d);
#line 178
    ad = __cil_tmp41;
#line 178
    __cil_tmp43 = _mm_xor_si128(b, c);
#line 178
    bc = __cil_tmp43;
#line 178
    __cil_tmp45 = _mm_or_si128(ad, bc);
#line 178
    t1 = __cil_tmp45;
#line 178
    __cil_tmp47 = _mm_or_si128(t1, st);
#line 178
    t2 = __cil_tmp47;
#line 178
    __cil_tmp49 = _mm_and_si128(t2, one);
#line 178
    t3 = __cil_tmp49;
#line 178
    __cil_tmp51 = _mm_avg_epu8(s, t);
#line 178
    t4 = __cil_tmp51;
#line 178
    __cil_tmp53 = _mm_sub_epi8(t4, t3);
#line 178
    k = __cil_tmp53;
    }
    {
#line 178
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 178
      __cil_tmp57 = _mm_avg_epu8(k, t);
#line 178
      tmp0 = __cil_tmp57;
#line 178
      __cil_tmp59 = _mm_and_si128(bc, st);
#line 178
      tmp1 = __cil_tmp59;
#line 178
      __cil_tmp61 = _mm_xor_si128(k, t);
#line 178
      tmp2 = __cil_tmp61;
#line 178
      __cil_tmp63 = _mm_or_si128(tmp1, tmp2);
#line 178
      tmp3 = __cil_tmp63;
#line 178
      __cil_tmp65 = _mm_and_si128(tmp3, one);
#line 178
      tmp4 = __cil_tmp65;
#line 178
      diag1 = _mm_sub_epi8(tmp0, tmp4);
      }
#line 178
      goto while_break___0;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___0: ;
    {
#line 178
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 178
      __cil_tmp68 = _mm_avg_epu8(k, s);
#line 178
      tmp0___0 = __cil_tmp68;
#line 178
      __cil_tmp70 = _mm_and_si128(ad, st);
#line 178
      tmp1___0 = __cil_tmp70;
#line 178
      __cil_tmp72 = _mm_xor_si128(k, s);
#line 178
      tmp2___0 = __cil_tmp72;
#line 178
      __cil_tmp74 = _mm_or_si128(tmp1___0, tmp2___0);
#line 178
      tmp3___0 = __cil_tmp74;
#line 178
      __cil_tmp76 = _mm_and_si128(tmp3___0, one);
#line 178
      tmp4___0 = __cil_tmp76;
#line 178
      diag2 = _mm_sub_epi8(tmp0___0, tmp4___0);
      }
#line 178
      goto while_break___1;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___1: ;
    {
#line 178
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 178
      __cil_tmp79 = _mm_avg_epu8(a, diag1);
#line 178
      t_a = __cil_tmp79;
#line 178
      __cil_tmp81 = _mm_avg_epu8(b, diag2);
#line 178
      t_b = __cil_tmp81;
#line 178
      __cil_tmp83 = _mm_unpackhi_epi8(t_a, t_b);
#line 178
      t_1 = __cil_tmp83;
#line 178
      __cil_tmp85 = _mm_unpackhi_epi8(t_a, t_b);
#line 178
      t_2 = __cil_tmp85;
#line 178
      _mm_store_si128((__m128i *)((r_uv + 0) + 0) + 0, t_1);
#line 178
      _mm_store_si128((__m128i *)((r_uv + 0) + 0) + 1, t_2);
      }
#line 178
      goto while_break___2;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___2: ;
    {
#line 178
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 178
      __cil_tmp87 = _mm_avg_epu8(c, diag2);
#line 178
      t_a___0 = __cil_tmp87;
#line 178
      __cil_tmp89 = _mm_avg_epu8(d, diag1);
#line 178
      t_b___0 = __cil_tmp89;
#line 178
      __cil_tmp91 = _mm_unpackhi_epi8(t_a___0, t_b___0);
#line 178
      t_1___0 = __cil_tmp91;
#line 178
      __cil_tmp93 = _mm_unpackhi_epi8(t_a___0, t_b___0);
#line 178
      t_2___0 = __cil_tmp93;
#line 178
      _mm_store_si128((__m128i *)((r_uv + 0) + 64) + 0, t_1___0);
#line 178
      _mm_store_si128((__m128i *)((r_uv + 0) + 64) + 1, t_2___0);
      }
#line 178
      goto while_break___3;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___3: 
    {
#line 178
    __cil_tmp95 = _mm_set1_epi8((char)1);
#line 178
    one___0 = __cil_tmp95;
#line 178
    __cil_tmp97 = _mm_loadu_si128((__m128i *)(top_v + 0));
#line 178
    a___0 = __cil_tmp97;
#line 178
    __cil_tmp99 = _mm_loadu_si128((__m128i *)(top_v + 1));
#line 178
    b___0 = __cil_tmp99;
#line 178
    __cil_tmp101 = _mm_loadu_si128((__m128i *)(cur_v + 0));
#line 178
    c___0 = __cil_tmp101;
#line 178
    __cil_tmp103 = _mm_loadu_si128((__m128i *)(cur_v + 1));
#line 178
    d___0 = __cil_tmp103;
#line 178
    __cil_tmp105 = _mm_avg_epu8(a___0, d___0);
#line 178
    s___0 = __cil_tmp105;
#line 178
    __cil_tmp107 = _mm_avg_epu8(b___0, c___0);
#line 178
    t___0 = __cil_tmp107;
#line 178
    __cil_tmp109 = _mm_xor_si128(s___0, t___0);
#line 178
    st___0 = __cil_tmp109;
#line 178
    __cil_tmp111 = _mm_xor_si128(a___0, d___0);
#line 178
    ad___0 = __cil_tmp111;
#line 178
    __cil_tmp113 = _mm_xor_si128(b___0, c___0);
#line 178
    bc___0 = __cil_tmp113;
#line 178
    __cil_tmp115 = _mm_or_si128(ad___0, bc___0);
#line 178
    t1___0 = __cil_tmp115;
#line 178
    __cil_tmp117 = _mm_or_si128(t1___0, st___0);
#line 178
    t2___0 = __cil_tmp117;
#line 178
    __cil_tmp119 = _mm_and_si128(t2___0, one___0);
#line 178
    t3___0 = __cil_tmp119;
#line 178
    __cil_tmp121 = _mm_avg_epu8(s___0, t___0);
#line 178
    t4___0 = __cil_tmp121;
#line 178
    __cil_tmp123 = _mm_sub_epi8(t4___0, t3___0);
#line 178
    k___0 = __cil_tmp123;
    }
    {
#line 178
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 178
      __cil_tmp127 = _mm_avg_epu8(k___0, t___0);
#line 178
      tmp0___1 = __cil_tmp127;
#line 178
      __cil_tmp129 = _mm_and_si128(bc___0, st___0);
#line 178
      tmp1___1 = __cil_tmp129;
#line 178
      __cil_tmp131 = _mm_xor_si128(k___0, t___0);
#line 178
      tmp2___1 = __cil_tmp131;
#line 178
      __cil_tmp133 = _mm_or_si128(tmp1___1, tmp2___1);
#line 178
      tmp3___1 = __cil_tmp133;
#line 178
      __cil_tmp135 = _mm_and_si128(tmp3___1, one___0);
#line 178
      tmp4___1 = __cil_tmp135;
#line 178
      diag1___0 = _mm_sub_epi8(tmp0___1, tmp4___1);
      }
#line 178
      goto while_break___4;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___4: ;
    {
#line 178
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 178
      __cil_tmp138 = _mm_avg_epu8(k___0, s___0);
#line 178
      tmp0___2 = __cil_tmp138;
#line 178
      __cil_tmp140 = _mm_and_si128(ad___0, st___0);
#line 178
      tmp1___2 = __cil_tmp140;
#line 178
      __cil_tmp142 = _mm_xor_si128(k___0, s___0);
#line 178
      tmp2___2 = __cil_tmp142;
#line 178
      __cil_tmp144 = _mm_or_si128(tmp1___2, tmp2___2);
#line 178
      tmp3___2 = __cil_tmp144;
#line 178
      __cil_tmp146 = _mm_and_si128(tmp3___2, one___0);
#line 178
      tmp4___2 = __cil_tmp146;
#line 178
      diag2___0 = _mm_sub_epi8(tmp0___2, tmp4___2);
      }
#line 178
      goto while_break___5;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___5: ;
    {
#line 178
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 178
      __cil_tmp149 = _mm_avg_epu8(a___0, diag1___0);
#line 178
      t_a___1 = __cil_tmp149;
#line 178
      __cil_tmp151 = _mm_avg_epu8(b___0, diag2___0);
#line 178
      t_b___1 = __cil_tmp151;
#line 178
      __cil_tmp153 = _mm_unpackhi_epi8(t_a___1, t_b___1);
#line 178
      t_1___1 = __cil_tmp153;
#line 178
      __cil_tmp155 = _mm_unpackhi_epi8(t_a___1, t_b___1);
#line 178
      t_2___1 = __cil_tmp155;
#line 178
      _mm_store_si128((__m128i *)((r_uv + 32) + 0) + 0, t_1___1);
#line 178
      _mm_store_si128((__m128i *)((r_uv + 32) + 0) + 1, t_2___1);
      }
#line 178
      goto while_break___6;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___6: ;
    {
#line 178
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 178
      __cil_tmp157 = _mm_avg_epu8(c___0, diag2___0);
#line 178
      t_a___2 = __cil_tmp157;
#line 178
      __cil_tmp159 = _mm_avg_epu8(d___0, diag1___0);
#line 178
      t_b___2 = __cil_tmp159;
#line 178
      __cil_tmp161 = _mm_unpackhi_epi8(t_a___2, t_b___2);
#line 178
      t_1___2 = __cil_tmp161;
#line 178
      __cil_tmp163 = _mm_unpackhi_epi8(t_a___2, t_b___2);
#line 178
      t_2___2 = __cil_tmp163;
#line 178
      _mm_store_si128((__m128i *)((r_uv + 32) + 64) + 0, t_1___2);
#line 178
      _mm_store_si128((__m128i *)((r_uv + 32) + 64) + 1, t_2___2);
      }
#line 178
      goto while_break___7;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___7: ;
#line 178
    if (top_y) {
#line 178
      n = 0;
      {
#line 178
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 178
        if (! (n < 32)) {
#line 178
          goto while_break___8;
        }
        {
#line 178
        VP8YuvToBgra(*(top_y + ((32 * block + 1) + n)), *(r_uv + n), *(r_uv + (32 + n)),
                     top_dst + ((32 * block + 1) + n) * 4);
#line 178
        n ++;
        }
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___8: ;
    }
#line 178
    if (bottom_y) {
#line 178
      n = 0;
      {
#line 178
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 178
        if (! (n < 32)) {
#line 178
          goto while_break___9;
        }
        {
#line 178
        VP8YuvToBgra(*(bottom_y + ((32 * block + 1) + n)), *(r_uv + (64 + n)), *(r_uv + (96 + n)),
                     bottom_dst + ((32 * block + 1) + n) * 4);
#line 178
        n ++;
        }
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___9: ;
    }
#line 178
    top_u += 16;
#line 178
    cur_u += 16;
#line 178
    top_v += 16;
#line 178
    cur_v += 16;
#line 178
    block ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break: 
  {
#line 178
  memcpy((void *)(r1), (void const   *)top_u, (unsigned long )leftover);
#line 178
  memcpy((void *)(r2), (void const   *)cur_u, (unsigned long )leftover);
#line 178
  memset((void *)(r1 + leftover), (int )r1[leftover - 1], (unsigned long )(17 - leftover));
#line 178
  memset((void *)(r2 + leftover), (int )r2[leftover - 1], (unsigned long )(17 - leftover));
#line 178
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:178)":);
#line 178
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:178)":);
#line 178
  Upsample32Pixels((uint8_t *)0, (uint8_t *)0, r_uv + 0);
#line 178
  memcpy((void *)(r1___0), (void const   *)top_v, (unsigned long )leftover);
#line 178
  memcpy((void *)(r2___0), (void const   *)cur_v, (unsigned long )leftover);
#line 178
  memset((void *)(r1___0 + leftover), (int )r1___0[leftover - 1], (unsigned long )(17 - leftover));
#line 178
  memset((void *)(r2___0 + leftover), (int )r2___0[leftover - 1], (unsigned long )(17 - leftover));
#line 178
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:178)":);
#line 178
  __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/upsampling_sse2.c:178)":);
#line 178
  Upsample32Pixels((uint8_t *)0, (uint8_t *)0, r_uv + 32);
  }
#line 178
  if (top_y) {
#line 178
    n___0 = 0;
    {
#line 178
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 178
      if (! (n___0 < len - last_pos)) {
#line 178
        goto while_break___10;
      }
      {
#line 178
      VP8YuvToBgra(*(top_y + (last_pos + n___0)), *(r_uv + n___0), *(r_uv + (32 + n___0)),
                   top_dst + (last_pos + n___0) * 4);
#line 178
      n___0 ++;
      }
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break___10: ;
  }
#line 178
  if (bottom_y) {
#line 178
    n___0 = 0;
    {
#line 178
    while (1) {
      while_continue___11: /* CIL Label */ ;

#line 178
      if (! (n___0 < len - last_pos)) {
#line 178
        goto while_break___11;
      }
      {
#line 178
      VP8YuvToBgra(*(bottom_y + (last_pos + n___0)), *(r_uv + (64 + n___0)), *(r_uv + (96 + n___0)),
                   bottom_dst + (last_pos + n___0) * 4);
#line 178
      n___0 ++;
      }
    }
    while_break___24: /* CIL Label */ ;
    }
    while_break___11: ;
  }
#line 184
  return;
}
}
#line 195 "/root/patchweave_new/13/src/dsp/upsampling_sse2.c"
void WebPInitUpsamplersSSE2(void) 
{ 


  {
#line 197
  WebPUpsamplers[0] = & UpsampleRgbLinePairSSE2;
#line 198
  WebPUpsamplers[1] = & UpsampleRgbaLinePairSSE2;
#line 199
  WebPUpsamplers[2] = & UpsampleBgrLinePairSSE2;
#line 200
  WebPUpsamplers[3] = & UpsampleBgraLinePairSSE2;
#line 201
  return;
}
}
#line 204 "/root/patchweave_new/13/src/dsp/upsampling_sse2.c"
void WebPInitPremultiplySSE2(void) 
{ 


  {
#line 206
  WebPUpsamplers[7] = & UpsampleRgbaLinePairSSE2;
#line 207
  WebPUpsamplers[8] = & UpsampleBgraLinePairSSE2;
#line 208
  return;
}
}
#line 274 "/root/patchweave_new/13/src/dsp/upsampling_neon.c"
void WebPInitUpsamplersNEON(void) 
{ 


  {
#line 279
  return;
}
}
#line 283 "/root/patchweave_new/13/src/dsp/upsampling_neon.c"
void WebPInitPremultiplyNEON(void) 
{ 


  {
#line 288
  return;
}
}
#line 95 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void UpsampleRgbLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 95
  last_pixel_pair = (len - 1) >> 1;
#line 95
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 95
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 95
  if (top_y) {
    {
#line 95
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 95
    VP8YuvToRgb(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 95
  if (bottom_y) {
    {
#line 95
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 95
    VP8YuvToRgb(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                bottom_dst);
    }
  }
#line 95
  x = 1;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;

#line 95
    if (! (x <= last_pixel_pair)) {
#line 95
      goto while_break;
    }
#line 95
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 95
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 95
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 95
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 95
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 95
    if (top_y) {
      {
#line 95
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 95
      uv1 = (diag_03 + t_uv) >> 1;
#line 95
      VP8YuvToRgb(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                  top_dst + (2 * x - 1) * 3);
#line 95
      VP8YuvToRgb(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                  top_dst + (2 * x) * 3);
      }
    }
#line 95
    if (bottom_y) {
      {
#line 95
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 95
      uv1___0 = (diag_12 + uv) >> 1;
#line 95
      VP8YuvToRgb(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                  bottom_dst + (2 * x - 1) * 3);
#line 95
      VP8YuvToRgb(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                  bottom_dst + (2 * x) * 3);
      }
    }
#line 95
    tl_uv = t_uv;
#line 95
    l_uv = uv;
#line 95
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 95
  if (! (len & 1)) {
#line 95
    if (top_y) {
      {
#line 95
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 95
      VP8YuvToRgb(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                  top_dst + (len - 1) * 3);
      }
    }
#line 95
    if (bottom_y) {
      {
#line 95
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 95
      VP8YuvToRgb(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                  bottom_dst + (len - 1) * 3);
      }
    }
  }
#line 100
  return;
}
}
#line 96 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void UpsampleBgrLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 96
  last_pixel_pair = (len - 1) >> 1;
#line 96
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 96
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 96
  if (top_y) {
    {
#line 96
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 96
    VP8YuvToBgr(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 96
  if (bottom_y) {
    {
#line 96
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 96
    VP8YuvToBgr(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                bottom_dst);
    }
  }
#line 96
  x = 1;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;

#line 96
    if (! (x <= last_pixel_pair)) {
#line 96
      goto while_break;
    }
#line 96
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 96
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 96
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 96
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 96
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 96
    if (top_y) {
      {
#line 96
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 96
      uv1 = (diag_03 + t_uv) >> 1;
#line 96
      VP8YuvToBgr(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                  top_dst + (2 * x - 1) * 3);
#line 96
      VP8YuvToBgr(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                  top_dst + (2 * x) * 3);
      }
    }
#line 96
    if (bottom_y) {
      {
#line 96
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 96
      uv1___0 = (diag_12 + uv) >> 1;
#line 96
      VP8YuvToBgr(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                  bottom_dst + (2 * x - 1) * 3);
#line 96
      VP8YuvToBgr(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                  bottom_dst + (2 * x) * 3);
      }
    }
#line 96
    tl_uv = t_uv;
#line 96
    l_uv = uv;
#line 96
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 96
  if (! (len & 1)) {
#line 96
    if (top_y) {
      {
#line 96
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 96
      VP8YuvToBgr(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                  top_dst + (len - 1) * 3);
      }
    }
#line 96
    if (bottom_y) {
      {
#line 96
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 96
      VP8YuvToBgr(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                  bottom_dst + (len - 1) * 3);
      }
    }
  }
#line 101
  return;
}
}
#line 97 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void UpsampleRgbaLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                 uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                 uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 97
  last_pixel_pair = (len - 1) >> 1;
#line 97
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 97
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 97
  if (top_y) {
    {
#line 97
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 97
    VP8YuvToRgba(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 97
  if (bottom_y) {
    {
#line 97
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 97
    VP8YuvToRgba(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                 bottom_dst);
    }
  }
#line 97
  x = 1;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;

#line 97
    if (! (x <= last_pixel_pair)) {
#line 97
      goto while_break;
    }
#line 97
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 97
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 97
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 97
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 97
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 97
    if (top_y) {
      {
#line 97
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 97
      uv1 = (diag_03 + t_uv) >> 1;
#line 97
      VP8YuvToRgba(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                   top_dst + (2 * x - 1) * 4);
#line 97
      VP8YuvToRgba(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                   top_dst + (2 * x) * 4);
      }
    }
#line 97
    if (bottom_y) {
      {
#line 97
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 97
      uv1___0 = (diag_12 + uv) >> 1;
#line 97
      VP8YuvToRgba(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                   bottom_dst + (2 * x - 1) * 4);
#line 97
      VP8YuvToRgba(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                   bottom_dst + (2 * x) * 4);
      }
    }
#line 97
    tl_uv = t_uv;
#line 97
    l_uv = uv;
#line 97
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 97
  if (! (len & 1)) {
#line 97
    if (top_y) {
      {
#line 97
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 97
      VP8YuvToRgba(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                   top_dst + (len - 1) * 4);
      }
    }
#line 97
    if (bottom_y) {
      {
#line 97
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 97
      VP8YuvToRgba(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                   bottom_dst + (len - 1) * 4);
      }
    }
  }
#line 102
  return;
}
}
#line 98 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void UpsampleBgraLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                 uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                 uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 98
  last_pixel_pair = (len - 1) >> 1;
#line 98
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 98
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 98
  if (top_y) {
    {
#line 98
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 98
    VP8YuvToBgra(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 98
  if (bottom_y) {
    {
#line 98
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 98
    VP8YuvToBgra(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                 bottom_dst);
    }
  }
#line 98
  x = 1;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;

#line 98
    if (! (x <= last_pixel_pair)) {
#line 98
      goto while_break;
    }
#line 98
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 98
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 98
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 98
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 98
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 98
    if (top_y) {
      {
#line 98
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 98
      uv1 = (diag_03 + t_uv) >> 1;
#line 98
      VP8YuvToBgra(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                   top_dst + (2 * x - 1) * 4);
#line 98
      VP8YuvToBgra(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                   top_dst + (2 * x) * 4);
      }
    }
#line 98
    if (bottom_y) {
      {
#line 98
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 98
      uv1___0 = (diag_12 + uv) >> 1;
#line 98
      VP8YuvToBgra(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                   bottom_dst + (2 * x - 1) * 4);
#line 98
      VP8YuvToBgra(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                   bottom_dst + (2 * x) * 4);
      }
    }
#line 98
    tl_uv = t_uv;
#line 98
    l_uv = uv;
#line 98
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 98
  if (! (len & 1)) {
#line 98
    if (top_y) {
      {
#line 98
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 98
      VP8YuvToBgra(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                   top_dst + (len - 1) * 4);
      }
    }
#line 98
    if (bottom_y) {
      {
#line 98
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 98
      VP8YuvToBgra(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                   bottom_dst + (len - 1) * 4);
      }
    }
  }
#line 103
  return;
}
}
#line 99 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void UpsampleArgbLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                 uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                 uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 99
  last_pixel_pair = (len - 1) >> 1;
#line 99
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 99
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 99
  if (top_y) {
    {
#line 99
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 99
    VP8YuvToArgb(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 99
  if (bottom_y) {
    {
#line 99
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 99
    VP8YuvToArgb(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                 bottom_dst);
    }
  }
#line 99
  x = 1;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;

#line 99
    if (! (x <= last_pixel_pair)) {
#line 99
      goto while_break;
    }
#line 99
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 99
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 99
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 99
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 99
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 99
    if (top_y) {
      {
#line 99
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 99
      uv1 = (diag_03 + t_uv) >> 1;
#line 99
      VP8YuvToArgb(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                   top_dst + (2 * x - 1) * 4);
#line 99
      VP8YuvToArgb(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                   top_dst + (2 * x) * 4);
      }
    }
#line 99
    if (bottom_y) {
      {
#line 99
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 99
      uv1___0 = (diag_12 + uv) >> 1;
#line 99
      VP8YuvToArgb(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                   bottom_dst + (2 * x - 1) * 4);
#line 99
      VP8YuvToArgb(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                   bottom_dst + (2 * x) * 4);
      }
    }
#line 99
    tl_uv = t_uv;
#line 99
    l_uv = uv;
#line 99
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 99
  if (! (len & 1)) {
#line 99
    if (top_y) {
      {
#line 99
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 99
      VP8YuvToArgb(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                   top_dst + (len - 1) * 4);
      }
    }
#line 99
    if (bottom_y) {
      {
#line 99
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 99
      VP8YuvToArgb(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                   bottom_dst + (len - 1) * 4);
      }
    }
  }
#line 104
  return;
}
}
#line 100 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void UpsampleRgba4444LinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                     uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                     uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 100
  last_pixel_pair = (len - 1) >> 1;
#line 100
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 100
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 100
  if (top_y) {
    {
#line 100
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 100
    VP8YuvToRgba4444(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16),
                     top_dst);
    }
  }
#line 100
  if (bottom_y) {
    {
#line 100
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 100
    VP8YuvToRgba4444(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                     bottom_dst);
    }
  }
#line 100
  x = 1;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;

#line 100
    if (! (x <= last_pixel_pair)) {
#line 100
      goto while_break;
    }
#line 100
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 100
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 100
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 100
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 100
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 100
    if (top_y) {
      {
#line 100
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 100
      uv1 = (diag_03 + t_uv) >> 1;
#line 100
      VP8YuvToRgba4444(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                       top_dst + (2 * x - 1) * 2);
#line 100
      VP8YuvToRgba4444(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                       top_dst + (2 * x) * 2);
      }
    }
#line 100
    if (bottom_y) {
      {
#line 100
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 100
      uv1___0 = (diag_12 + uv) >> 1;
#line 100
      VP8YuvToRgba4444(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                       bottom_dst + (2 * x - 1) * 2);
#line 100
      VP8YuvToRgba4444(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                       bottom_dst + (2 * x) * 2);
      }
    }
#line 100
    tl_uv = t_uv;
#line 100
    l_uv = uv;
#line 100
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 100
  if (! (len & 1)) {
#line 100
    if (top_y) {
      {
#line 100
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 100
      VP8YuvToRgba4444(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                       top_dst + (len - 1) * 2);
      }
    }
#line 100
    if (bottom_y) {
      {
#line 100
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 100
      VP8YuvToRgba4444(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                       bottom_dst + (len - 1) * 2);
      }
    }
  }
#line 105
  return;
}
}
#line 101 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void UpsampleRgb565LinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                   uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                   uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 101
  last_pixel_pair = (len - 1) >> 1;
#line 101
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 101
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 101
  if (top_y) {
    {
#line 101
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 101
    VP8YuvToRgb565(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 101
  if (bottom_y) {
    {
#line 101
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 101
    VP8YuvToRgb565(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                   bottom_dst);
    }
  }
#line 101
  x = 1;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;

#line 101
    if (! (x <= last_pixel_pair)) {
#line 101
      goto while_break;
    }
#line 101
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 101
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 101
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 101
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 101
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 101
    if (top_y) {
      {
#line 101
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 101
      uv1 = (diag_03 + t_uv) >> 1;
#line 101
      VP8YuvToRgb565(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                     top_dst + (2 * x - 1) * 2);
#line 101
      VP8YuvToRgb565(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                     top_dst + (2 * x) * 2);
      }
    }
#line 101
    if (bottom_y) {
      {
#line 101
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 101
      uv1___0 = (diag_12 + uv) >> 1;
#line 101
      VP8YuvToRgb565(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                     bottom_dst + (2 * x - 1) * 2);
#line 101
      VP8YuvToRgb565(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                     bottom_dst + (2 * x) * 2);
      }
    }
#line 101
    tl_uv = t_uv;
#line 101
    l_uv = uv;
#line 101
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 101
  if (! (len & 1)) {
#line 101
    if (top_y) {
      {
#line 101
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 101
      VP8YuvToRgb565(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                     top_dst + (len - 1) * 2);
      }
    }
#line 101
    if (bottom_y) {
      {
#line 101
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 101
      VP8YuvToRgb565(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                     bottom_dst + (len - 1) * 2);
      }
    }
  }
#line 106
  return;
}
}
#line 135 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void SampleRgbLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u , uint8_t *v ,
                              uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int i ;

  {
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;

#line 135
    if (! (i < len - 1)) {
#line 135
      goto while_break;
    }
    {
#line 135
    VP8YuvToRgb(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 135
    VP8YuvToRgb(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 3);
#line 135
    VP8YuvToRgb(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 135
    VP8YuvToRgb(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 3);
#line 135
    top_y += 2;
#line 135
    bottom_y += 2;
#line 135
    u ++;
#line 135
    v ++;
#line 135
    top_dst += 6;
#line 135
    bottom_dst += 6;
#line 135
    i += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 135
  if (i == len - 1) {
    {
#line 135
    VP8YuvToRgb(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 135
    VP8YuvToRgb(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
#line 138
  return;
}
}
#line 136 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void SampleBgrLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u , uint8_t *v ,
                              uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int i ;

  {
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;

#line 136
    if (! (i < len - 1)) {
#line 136
      goto while_break;
    }
    {
#line 136
    VP8YuvToBgr(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 136
    VP8YuvToBgr(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 3);
#line 136
    VP8YuvToBgr(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 136
    VP8YuvToBgr(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 3);
#line 136
    top_y += 2;
#line 136
    bottom_y += 2;
#line 136
    u ++;
#line 136
    v ++;
#line 136
    top_dst += 6;
#line 136
    bottom_dst += 6;
#line 136
    i += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 136
  if (i == len - 1) {
    {
#line 136
    VP8YuvToBgr(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 136
    VP8YuvToBgr(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
#line 139
  return;
}
}
#line 137 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void SampleRgbaLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u , uint8_t *v ,
                               uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int i ;

  {
#line 137
  i = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;

#line 137
    if (! (i < len - 1)) {
#line 137
      goto while_break;
    }
    {
#line 137
    VP8YuvToRgba(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 137
    VP8YuvToRgba(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 4);
#line 137
    VP8YuvToRgba(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 137
    VP8YuvToRgba(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 4);
#line 137
    top_y += 2;
#line 137
    bottom_y += 2;
#line 137
    u ++;
#line 137
    v ++;
#line 137
    top_dst += 8;
#line 137
    bottom_dst += 8;
#line 137
    i += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 137
  if (i == len - 1) {
    {
#line 137
    VP8YuvToRgba(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 137
    VP8YuvToRgba(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
#line 140
  return;
}
}
#line 138 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void SampleBgraLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u , uint8_t *v ,
                               uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int i ;

  {
#line 138
  i = 0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;

#line 138
    if (! (i < len - 1)) {
#line 138
      goto while_break;
    }
    {
#line 138
    VP8YuvToBgra(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 138
    VP8YuvToBgra(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 4);
#line 138
    VP8YuvToBgra(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 138
    VP8YuvToBgra(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 4);
#line 138
    top_y += 2;
#line 138
    bottom_y += 2;
#line 138
    u ++;
#line 138
    v ++;
#line 138
    top_dst += 8;
#line 138
    bottom_dst += 8;
#line 138
    i += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 138
  if (i == len - 1) {
    {
#line 138
    VP8YuvToBgra(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 138
    VP8YuvToBgra(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
#line 141
  return;
}
}
#line 139 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void SampleArgbLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u , uint8_t *v ,
                               uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int i ;

  {
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;

#line 139
    if (! (i < len - 1)) {
#line 139
      goto while_break;
    }
    {
#line 139
    VP8YuvToArgb(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 139
    VP8YuvToArgb(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 4);
#line 139
    VP8YuvToArgb(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 139
    VP8YuvToArgb(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 4);
#line 139
    top_y += 2;
#line 139
    bottom_y += 2;
#line 139
    u ++;
#line 139
    v ++;
#line 139
    top_dst += 8;
#line 139
    bottom_dst += 8;
#line 139
    i += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 139
  if (i == len - 1) {
    {
#line 139
    VP8YuvToArgb(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 139
    VP8YuvToArgb(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
#line 142
  return;
}
}
#line 140 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void SampleRgba4444LinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u ,
                                   uint8_t *v , uint8_t *top_dst , uint8_t *bottom_dst ,
                                   int len ) 
{ 
  int i ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;

#line 140
    if (! (i < len - 1)) {
#line 140
      goto while_break;
    }
    {
#line 140
    VP8YuvToRgba4444(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 140
    VP8YuvToRgba4444(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 2);
#line 140
    VP8YuvToRgba4444(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 140
    VP8YuvToRgba4444(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 2);
#line 140
    top_y += 2;
#line 140
    bottom_y += 2;
#line 140
    u ++;
#line 140
    v ++;
#line 140
    top_dst += 4;
#line 140
    bottom_dst += 4;
#line 140
    i += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 140
  if (i == len - 1) {
    {
#line 140
    VP8YuvToRgba4444(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 140
    VP8YuvToRgba4444(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
#line 143
  return;
}
}
#line 141 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void SampleRgb565LinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u ,
                                 uint8_t *v , uint8_t *top_dst , uint8_t *bottom_dst ,
                                 int len ) 
{ 
  int i ;

  {
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;

#line 141
    if (! (i < len - 1)) {
#line 141
      goto while_break;
    }
    {
#line 141
    VP8YuvToRgb565(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 141
    VP8YuvToRgb565(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 2);
#line 141
    VP8YuvToRgb565(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 141
    VP8YuvToRgb565(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 2);
#line 141
    top_y += 2;
#line 141
    bottom_y += 2;
#line 141
    u ++;
#line 141
    v ++;
#line 141
    top_dst += 4;
#line 141
    bottom_dst += 4;
#line 141
    i += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 141
  if (i == len - 1) {
    {
#line 141
    VP8YuvToRgb565(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 141
    VP8YuvToRgb565(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
#line 144
  return;
}
}
#line 145 "/root/patchweave_new/13/src/dsp/upsampling.c"
WebPSampleLinePairFunc WebPSamplers[13]  = 
#line 145
  {      & SampleRgbLinePair,      & SampleRgbaLinePair,      & SampleBgrLinePair,      & SampleBgraLinePair, 
        & SampleArgbLinePair,      & SampleRgba4444LinePair,      & SampleRgb565LinePair,      & SampleRgbaLinePair, 
        & SampleBgraLinePair,      & SampleArgbLinePair,      & SampleRgba4444LinePair};
#line 191 "/root/patchweave_new/13/src/dsp/upsampling.c"
WebPUpsampleLinePairFunc WebPGetLinePairConverter(int alpha_is_last ) 
{ 
  int tmp ;

  {
  {
#line 192
  WebPInitUpsamplers();
#line 193
  VP8YUVInit();
  }
#line 195
  if (alpha_is_last) {
#line 195
    tmp = 3;
  } else {
#line 195
    tmp = 4;
  }
#line 195
  return (WebPUpsamplers[tmp]);
}
}
#line 211 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void Yuv444ToRgb(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 211
  i = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;

#line 211
    if (! (i < len)) {
#line 211
      goto while_break;
    }
    {
#line 211
    VP8YuvToRgb(*(y + i), *(u + i), *(v + i), dst + i * 3);
#line 211
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 215
  return;
}
}
#line 212 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void Yuv444ToBgr(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 212
  i = 0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;

#line 212
    if (! (i < len)) {
#line 212
      goto while_break;
    }
    {
#line 212
    VP8YuvToBgr(*(y + i), *(u + i), *(v + i), dst + i * 3);
#line 212
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 216
  return;
}
}
#line 213 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void Yuv444ToRgba(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;

#line 213
    if (! (i < len)) {
#line 213
      goto while_break;
    }
    {
#line 213
    VP8YuvToRgba(*(y + i), *(u + i), *(v + i), dst + i * 4);
#line 213
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 217
  return;
}
}
#line 214 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void Yuv444ToBgra(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 214
  i = 0;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;

#line 214
    if (! (i < len)) {
#line 214
      goto while_break;
    }
    {
#line 214
    VP8YuvToBgra(*(y + i), *(u + i), *(v + i), dst + i * 4);
#line 214
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 218
  return;
}
}
#line 215 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void Yuv444ToArgb(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;

#line 215
    if (! (i < len)) {
#line 215
      goto while_break;
    }
    {
#line 215
    VP8YuvToArgb(*(y + i), *(u + i), *(v + i), dst + i * 4);
#line 215
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 219
  return;
}
}
#line 216 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void Yuv444ToRgba4444(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ,
                             int len ) 
{ 
  int i ;

  {
#line 216
  i = 0;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;

#line 216
    if (! (i < len)) {
#line 216
      goto while_break;
    }
    {
#line 216
    VP8YuvToRgba4444(*(y + i), *(u + i), *(v + i), dst + i * 2);
#line 216
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 220
  return;
}
}
#line 217 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void Yuv444ToRgb565(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;

#line 217
    if (! (i < len)) {
#line 217
      goto while_break;
    }
    {
#line 217
    VP8YuvToRgb565(*(y + i), *(u + i), *(v + i), dst + i * 2);
#line 217
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 221
  return;
}
}
#line 221 "/root/patchweave_new/13/src/dsp/upsampling.c"
WebPYUV444Converter WebPYUV444Converters[13]  = 
#line 221
  {      & Yuv444ToRgb,      & Yuv444ToRgba,      & Yuv444ToBgr,      & Yuv444ToBgra, 
        & Yuv444ToArgb,      & Yuv444ToRgba4444,      & Yuv444ToRgb565,      & Yuv444ToRgba, 
        & Yuv444ToBgra,      & Yuv444ToArgb,      & Yuv444ToRgba4444};
#line 251 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void ApplyAlphaMultiply(uint8_t *rgba , int alpha_first , int w , int h , int stride ) 
{ 
  int __cil_tmp6 ;
  uint8_t *rgb ;
  int tmp ;
  uint8_t *alpha ;
  int tmp___0 ;
  int i ;
  uint32_t a ;
  uint32_t mult ;

  {
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    __cil_tmp6 = h;
#line 253
    h --;
#line 253
    if (! (__cil_tmp6 > 0)) {
#line 253
      goto while_break;
    }
#line 254
    if (alpha_first) {
#line 254
      tmp = 1;
    } else {
#line 254
      tmp = 0;
    }
#line 254
    rgb = rgba + tmp;
#line 255
    if (alpha_first) {
#line 255
      tmp___0 = 0;
    } else {
#line 255
      tmp___0 = 3;
    }
#line 255
    alpha = rgba + tmp___0;
#line 257
    i = 0;
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 257
      if (! (i < w)) {
#line 257
        goto while_break___0;
      }
#line 258
      a = (uint32_t )*(alpha + 4 * i);
#line 259
      if (a != 255U) {
#line 260
        mult = (uint32_t )((unsigned long )a * 32897UL);
#line 261
        *(rgb + 4 * i) = (uint8_t )((unsigned int )*(rgb + 4 * i) * mult >> 23);
#line 262
        *(rgb + (4 * i + 1)) = (uint8_t )((unsigned int )*(rgb + (4 * i + 1)) * mult >> 23);
#line 263
        *(rgb + (4 * i + 2)) = (uint8_t )((unsigned int )*(rgb + (4 * i + 2)) * mult >> 23);
      }
#line 257
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 266
    rgba += stride;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 270
  return;
}
}
#line 276 "/root/patchweave_new/13/src/dsp/upsampling.c"
__inline static uint8_t dither_hi(uint8_t x ) 
{ 


  {
#line 277
  return ((uint8_t )(((int )x & 240) | ((int )x >> 4)));
}
}
#line 280 "/root/patchweave_new/13/src/dsp/upsampling.c"
__inline static uint8_t dither_lo(uint8_t x ) 
{ 


  {
#line 281
  return ((uint8_t )(((int )x & 15) | ((int )x << 4)));
}
}
#line 284 "/root/patchweave_new/13/src/dsp/upsampling.c"
__inline static uint8_t multiply(uint8_t x , uint32_t m ) 
{ 


  {
#line 285
  return ((uint8_t )((unsigned int )x * m >> 16));
}
}
#line 288 "/root/patchweave_new/13/src/dsp/upsampling.c"
static void ApplyAlphaMultiply4444(uint8_t *rgba4444 , int w , int h , int stride ) 
{ 
  int __cil_tmp5 ;
  int i ;
  uint8_t a ;
  uint32_t mult ;
  uint8_t r ;
  uint8_t __cil_tmp10 ;
  uint8_t __cil_tmp11 ;
  uint8_t g ;
  uint8_t __cil_tmp13 ;
  uint8_t __cil_tmp14 ;
  uint8_t b ;
  uint8_t __cil_tmp16 ;
  uint8_t __cil_tmp17 ;

  {
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    __cil_tmp5 = h;
#line 290
    h --;
#line 290
    if (! (__cil_tmp5 > 0)) {
#line 290
      goto while_break;
    }
#line 292
    i = 0;
    {
#line 292
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 292
      if (! (i < w)) {
#line 292
        goto while_break___0;
      }
      {
#line 293
      a = (uint8_t )((int )*(rgba4444 + (2 * i + 1)) & 15);
#line 294
      mult = (uint32_t )((int )a * 4369);
#line 295
      __cil_tmp10 = dither_hi(*(rgba4444 + 2 * i));
#line 295
      __cil_tmp11 = multiply(__cil_tmp10, mult);
#line 295
      r = __cil_tmp11;
#line 296
      __cil_tmp13 = dither_lo(*(rgba4444 + 2 * i));
#line 296
      __cil_tmp14 = multiply(__cil_tmp13, mult);
#line 296
      g = __cil_tmp14;
#line 297
      __cil_tmp16 = dither_hi(*(rgba4444 + (2 * i + 1)));
#line 297
      __cil_tmp17 = multiply(__cil_tmp16, mult);
#line 297
      b = __cil_tmp17;
#line 298
      *(rgba4444 + 2 * i) = (uint8_t )(((int )r & 240) | (((int )g >> 4) & 15));
#line 299
      *(rgba4444 + (2 * i + 1)) = (uint8_t )(((int )b & 240) | (int )a);
#line 292
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 301
    rgba4444 += stride;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 305
  return;
}
}
#line 306 "/root/patchweave_new/13/src/dsp/upsampling.c"
void (*WebPApplyAlphaMultiply)(uint8_t * , int  , int  , int  , int  )  =    & ApplyAlphaMultiply;
#line 308 "/root/patchweave_new/13/src/dsp/upsampling.c"
void (*WebPApplyAlphaMultiply4444)(uint8_t * , int  , int  , int  )  =    & ApplyAlphaMultiply4444;
#line 314 "/root/patchweave_new/13/src/dsp/upsampling.c"
void WebPInitUpsamplers(void) 
{ 
  int __cil_tmp1 ;

  {
#line 316
  WebPUpsamplers[0] = & UpsampleRgbLinePair;
#line 317
  WebPUpsamplers[1] = & UpsampleRgbaLinePair;
#line 318
  WebPUpsamplers[2] = & UpsampleBgrLinePair;
#line 319
  WebPUpsamplers[3] = & UpsampleBgraLinePair;
#line 320
  WebPUpsamplers[4] = & UpsampleArgbLinePair;
#line 321
  WebPUpsamplers[5] = & UpsampleRgba4444LinePair;
#line 322
  WebPUpsamplers[6] = & UpsampleRgb565LinePair;
#line 325
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 327
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 327
    if (__cil_tmp1) {
      {
#line 328
      WebPInitUpsamplersSSE2();
      }
    }
  }
#line 332
  return;
}
}
#line 340 "/root/patchweave_new/13/src/dsp/upsampling.c"
void WebPInitPremultiply(void) 
{ 
  int __cil_tmp1 ;

  {
#line 341
  WebPApplyAlphaMultiply = & ApplyAlphaMultiply;
#line 342
  WebPApplyAlphaMultiply4444 = & ApplyAlphaMultiply4444;
#line 345
  WebPUpsamplers[7] = & UpsampleRgbaLinePair;
#line 346
  WebPUpsamplers[8] = & UpsampleBgraLinePair;
#line 347
  WebPUpsamplers[9] = & UpsampleArgbLinePair;
#line 348
  WebPUpsamplers[10] = & UpsampleRgba4444LinePair;
#line 350
  if ((unsigned long )VP8GetCPUInfo != (unsigned long )((void *)0)) {
    {
#line 352
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 352
    if (__cil_tmp1) {
      {
#line 353
      WebPInitPremultiplySSE2();
      }
    }
  }
#line 357
  return;
}
}
#line 46 "/root/patchweave_new/13/src/dsp/../dec/./webpi.h"
void WebPResetDecParams(WebPDecParams *params ) ;
#line 69
enum VP8StatusCode WebPParseHeaders(WebPHeaderStructure *headers ) ;
#line 76
void WebPInitCustomIo(WebPDecParams *params , VP8Io *io ) ;
#line 80
int WebPIoInitFromOptions(WebPDecoderOptions *options , VP8Io *io , enum WEBP_CSP_MODE src_colorspace ) ;
#line 94
enum VP8StatusCode WebPAllocateDecBuffer(int w , int h , WebPDecoderOptions *options ,
                                         WebPDecBuffer *out ) ;
#line 100
void WebPCopyDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) ;
#line 104
void WebPGrabDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) ;
#line 95 "/root/patchweave_new/13/src/dsp/../dec/vp8li.h"
int VP8LDecodeAlphaImageStream(int width , int height , uint8_t *data , size_t data_size ,
                               uint8_t *output ) ;
#line 99
VP8LDecoder *VP8LNew(void) ;
#line 102
int VP8LDecodeHeader(VP8LDecoder *dec , VP8Io *io ) ;
#line 106
int VP8LDecodeImage(VP8LDecoder *dec ) ;
#line 110
void VP8LClear(VP8LDecoder *dec ) ;
#line 113
void VP8LDelete(VP8LDecoder *dec ) ;
#line 38 "/root/patchweave_new/13/src/dsp/lossless.c"
float const   kLog2Table[256]  = 
#line 38 "/root/patchweave_new/13/src/dsp/lossless.c"
  {      (float const   )0.f,      (float const   )0.f,      (float const   )1.f,      (float const   )1.58496248723f, 
        (float const   )2.f,      (float const   )2.3219280243f,      (float const   )2.58496260644f,      (float const   )2.80735492707f, 
        (float const   )3.f,      (float const   )3.16992497445f,      (float const   )3.3219280243f,      (float const   )3.45943164826f, 
        (float const   )3.58496260644f,      (float const   )3.70043969155f,      (float const   )3.80735492707f,      (float const   )3.90689063073f, 
        (float const   )4.f,      (float const   )4.08746290207f,      (float const   )4.16992521287f,      (float const   )4.24792766572f, 
        (float const   )4.3219280243f,      (float const   )4.39231729508f,      (float const   )4.45943164826f,      (float const   )4.5235619545f, 
        (float const   )4.58496236802f,      (float const   )4.64385604859f,      (float const   )4.70043992997f,      (float const   )4.75488758088f, 
        (float const   )4.80735492707f,      (float const   )4.85798120499f,      (float const   )4.90689039231f,      (float const   )4.9541964531f, 
        (float const   )5.f,      (float const   )5.04439401627f,      (float const   )5.08746290207f,      (float const   )5.12928295136f, 
        (float const   )5.16992521287f,      (float const   )5.20945358277f,      (float const   )5.24792766572f,      (float const   )5.28540229798f, 
        (float const   )5.3219280243f,      (float const   )5.35755205155f,      (float const   )5.39231729508f,      (float const   )5.42626476288f, 
        (float const   )5.45943164826f,      (float const   )5.49185323716f,      (float const   )5.5235619545f,      (float const   )5.55458879471f, 
        (float const   )5.58496236802f,      (float const   )5.61470985413f,      (float const   )5.64385604859f,      (float const   )5.67242527009f, 
        (float const   )5.70043992997f,      (float const   )5.72792053223f,      (float const   )5.75488758088f,      (float const   )5.78135967255f, 
        (float const   )5.80735492707f,      (float const   )5.83289003373f,      (float const   )5.85798120499f,      (float const   )5.88264322281f, 
        (float const   )5.90689039231f,      (float const   )5.93073749543f,      (float const   )5.9541964531f,      (float const   )5.97728013993f, 
        (float const   )6.f,      (float const   )6.02236795426f,      (float const   )6.04439401627f,      (float const   )6.06608915329f, 
        (float const   )6.08746290207f,      (float const   )6.10852432251f,      (float const   )6.12928295136f,      (float const   )6.14974689484f, 
        (float const   )6.16992521287f,      (float const   )6.18982458115f,      (float const   )6.20945358277f,      (float const   )6.22881889344f, 
        (float const   )6.24792766572f,      (float const   )6.26678657532f,      (float const   )6.28540229798f,      (float const   )6.30378055573f, 
        (float const   )6.3219280243f,      (float const   )6.33984994889f,      (float const   )6.35755205155f,      (float const   )6.37503957749f, 
        (float const   )6.39231729508f,      (float const   )6.40939092637f,      (float const   )6.42626476288f,      (float const   )6.442943573f, 
        (float const   )6.45943164826f,      (float const   )6.47573328019f,      (float const   )6.49185323716f,      (float const   )6.50779485703f, 
        (float const   )6.5235619545f,      (float const   )6.53915882111f,      (float const   )6.55458879471f,      (float const   )6.56985569001f, 
        (float const   )6.58496236802f,      (float const   )6.59991264344f,      (float const   )6.61470985413f,      (float const   )6.62935638428f, 
        (float const   )6.64385604859f,      (float const   )6.65821170807f,      (float const   )6.67242527009f,      (float const   )6.68650054932f, 
        (float const   )6.70043992997f,      (float const   )6.71424531937f,      (float const   )6.72792053223f,      (float const   )6.74146699906f, 
        (float const   )6.75488758088f,      (float const   )6.76818418503f,      (float const   )6.78135967255f,      (float const   )6.79441595078f, 
        (float const   )6.80735492707f,      (float const   )6.8201789856f,      (float const   )6.83289003373f,      (float const   )6.8454899788f, 
        (float const   )6.85798120499f,      (float const   )6.87036466599f,      (float const   )6.88264322281f,      (float const   )6.89481782914f, 
        (float const   )6.90689039231f,      (float const   )6.91886329651f,      (float const   )6.93073749543f,      (float const   )6.94251441956f, 
        (float const   )6.9541964531f,      (float const   )6.96578407288f,      (float const   )6.97728013993f,      (float const   )6.98868465424f, 
        (float const   )7.f,      (float const   )7.01122713089f,      (float const   )7.02236795426f,      (float const   )7.03342294693f, 
        (float const   )7.04439401627f,      (float const   )7.05528259278f,      (float const   )7.06608915329f,      (float const   )7.07681560517f, 
        (float const   )7.08746290207f,      (float const   )7.09803199769f,      (float const   )7.10852432251f,      (float const   )7.11894130707f, 
        (float const   )7.12928295136f,      (float const   )7.13955116272f,      (float const   )7.14974689484f,      (float const   )7.15987110138f, 
        (float const   )7.16992521287f,      (float const   )7.17990922928f,      (float const   )7.18982458115f,      (float const   )7.19967222214f, 
        (float const   )7.20945358277f,      (float const   )7.21916866303f,      (float const   )7.22881889344f,      (float const   )7.23840475083f, 
        (float const   )7.24792766572f,      (float const   )7.2573876381f,      (float const   )7.26678657532f,      (float const   )7.27612447739f, 
        (float const   )7.28540229798f,      (float const   )7.29462051392f,      (float const   )7.30378055573f,      (float const   )7.31288290024f, 
        (float const   )7.3219280243f,      (float const   )7.33091688157f,      (float const   )7.33984994889f,      (float const   )7.34872817994f, 
        (float const   )7.35755205155f,      (float const   )7.36632204056f,      (float const   )7.37503957749f,      (float const   )7.38370418549f, 
        (float const   )7.39231729508f,      (float const   )7.40087938309f,      (float const   )7.40939092637f,      (float const   )7.41785240174f, 
        (float const   )7.42626476288f,      (float const   )7.4346280098f,      (float const   )7.442943573f,      (float const   )7.45121097565f, 
        (float const   )7.45943164826f,      (float const   )7.46760559083f,      (float const   )7.47573328019f,      (float const   )7.48381567002f, 
        (float const   )7.49185323716f,      (float const   )7.4998459816f,      (float const   )7.50779485703f,      (float const   )7.51569986344f, 
        (float const   )7.5235619545f,      (float const   )7.53138160706f,      (float const   )7.53915882111f,      (float const   )7.54689455033f, 
        (float const   )7.55458879471f,      (float const   )7.56224250794f,      (float const   )7.56985569001f,      (float const   )7.57742881775f, 
        (float const   )7.58496236802f,      (float const   )7.59245681763f,      (float const   )7.59991264344f,      (float const   )7.60733032227f, 
        (float const   )7.61470985413f,      (float const   )7.62205171586f,      (float const   )7.62935638428f,      (float const   )7.63662481308f, 
        (float const   )7.64385604859f,      (float const   )7.65105152131f,      (float const   )7.65821170807f,      (float const   )7.66533613205f, 
        (float const   )7.67242527009f,      (float const   )7.67948007584f,      (float const   )7.68650054932f,      (float const   )7.69348716736f, 
        (float const   )7.70043992997f,      (float const   )7.70735931397f,      (float const   )7.71424531937f,      (float const   )7.72109937668f, 
        (float const   )7.72792053223f,      (float const   )7.73470973969f,      (float const   )7.74146699906f,      (float const   )7.74819278718f, 
        (float const   )7.75488758088f,      (float const   )7.76155138016f,      (float const   )7.76818418503f,      (float const   )7.77478694916f, 
        (float const   )7.78135967255f,      (float const   )7.7879023552f,      (float const   )7.79441595078f,      (float const   )7.80089998246f, 
        (float const   )7.80735492707f,      (float const   )7.81378126145f,      (float const   )7.8201789856f,      (float const   )7.82654857636f, 
        (float const   )7.83289003373f,      (float const   )7.83920383454f,      (float const   )7.8454899788f,      (float const   )7.85174894333f, 
        (float const   )7.85798120499f,      (float const   )7.86418628693f,      (float const   )7.87036466599f,      (float const   )7.87651681901f, 
        (float const   )7.88264322281f,      (float const   )7.88874340058f,      (float const   )7.89481782914f,      (float const   )7.90086698533f, 
        (float const   )7.90689039231f,      (float const   )7.9128894806f,      (float const   )7.91886329651f,      (float const   )7.9248123169f, 
        (float const   )7.93073749543f,      (float const   )7.93663787842f,      (float const   )7.94251441956f,      (float const   )7.94836711884f, 
        (float const   )7.9541964531f,      (float const   )7.9600019455f,      (float const   )7.96578407288f,      (float const   )7.97154378891f, 
        (float const   )7.97728013993f,      (float const   )7.98299360276f,      (float const   )7.98868465424f,      (float const   )7.99435329438f};
#line 169 "/root/patchweave_new/13/src/dsp/lossless.c"
float const   kSLog2Table[256]  = 
#line 169
  {      (float const   )0.f,      (float const   )0.f,      (float const   )2.f,      (float const   )4.75488758088f, 
        (float const   )8.f,      (float const   )11.6096401215f,      (float const   )15.5097751618f,      (float const   )19.6514835358f, 
        (float const   )24.f,      (float const   )28.5293254853f,      (float const   )33.219280243f,      (float const   )38.0537490845f, 
        (float const   )43.0195503235f,      (float const   )48.1057167054f,      (float const   )53.3029670716f,      (float const   )58.6033592225f, 
        (float const   )64.f,      (float const   )69.4868698121f,      (float const   )75.0586471558f,      (float const   )80.7106246949f, 
        (float const   )86.4385604859f,      (float const   )92.2386627198f,      (float const   )98.107498169f,      (float const   )104.041923523f, 
        (float const   )110.039100647f,      (float const   )116.09640503f,      (float const   )122.211433411f,      (float const   )128.381958008f, 
        (float const   )134.605941773f,      (float const   )140.881454468f,      (float const   )147.206710816f,      (float const   )153.580078125f, 
        (float const   )160.f,      (float const   )166.465011597f,      (float const   )172.973739625f,      (float const   )179.524902344f, 
        (float const   )186.117294312f,      (float const   )192.749771119f,      (float const   )199.42124939f,      (float const   )206.130691529f, 
        (float const   )212.877120972f,      (float const   )219.659637452f,      (float const   )226.47732544f,      (float const   )233.32939148f, 
        (float const   )240.214996338f,      (float const   )247.133392334f,      (float const   )254.083847046f,      (float const   )261.065673829f, 
        (float const   )268.078186036f,      (float const   )275.120788575f,      (float const   )282.192810059f,      (float const   )289.293701172f, 
        (float const   )296.422851563f,      (float const   )303.57977295f,      (float const   )310.763916016f,      (float const   )317.974792481f, 
        (float const   )325.211883545f,      (float const   )332.474731446f,      (float const   )339.762908936f,      (float const   )347.075927735f, 
        (float const   )354.413421631f,      (float const   )361.774963379f,      (float const   )369.16015625f,      (float const   )376.568634034f, 
        (float const   )384.f,      (float const   )391.453918458f,      (float const   )398.930023194f,      (float const   )406.427978516f, 
        (float const   )413.947479249f,      (float const   )421.488189698f,      (float const   )429.049804688f,      (float const   )436.632049561f, 
        (float const   )444.234588624f,      (float const   )451.857177735f,      (float const   )459.499542237f,      (float const   )467.161407471f, 
        (float const   )474.84249878f,      (float const   )482.542572022f,      (float const   )490.261383057f,      (float const   )497.998687745f, 
        (float const   )505.754241944f,      (float const   )513.527832032f,      (float const   )521.319274903f,      (float const   )529.128295899f, 
        (float const   )536.954650879f,      (float const   )544.798217774f,      (float const   )552.658752442f,      (float const   )560.536071778f, 
        (float const   )568.429992676f,      (float const   )576.340270997f,      (float const   )584.266784668f,      (float const   )592.209289551f, 
        (float const   )600.16772461f,      (float const   )608.141784668f,      (float const   )616.131347657f,      (float const   )624.136291504f, 
        (float const   )632.156372071f,      (float const   )640.191528321f,      (float const   )648.241577149f,      (float const   )656.30633545f, 
        (float const   )664.385620118f,      (float const   )672.479370118f,      (float const   )680.587402344f,      (float const   )688.709533692f, 
        (float const   )696.845703125f,      (float const   )704.995788575f,      (float const   )713.159545899f,      (float const   )721.336975098f, 
        (float const   )729.527832032f,      (float const   )737.7321167f,      (float const   )745.949584961f,      (float const   )754.180175782f, 
        (float const   )762.42376709f,      (float const   )770.680236817f,      (float const   )778.949462891f,      (float const   )787.231384278f, 
        (float const   )795.525817872f,      (float const   )803.832702637f,      (float const   )812.151855469f,      (float const   )820.483337403f, 
        (float const   )828.826843262f,      (float const   )837.182434083f,      (float const   )845.549926758f,      (float const   )853.929260254f, 
        (float const   )862.3203125f,      (float const   )870.723022461f,      (float const   )879.137268067f,      (float const   )887.562927247f, 
        (float const   )896.f,      (float const   )904.448303223f,      (float const   )912.907836915f,      (float const   )921.378417969f, 
        (float const   )929.860046387f,      (float const   )938.352539063f,      (float const   )946.855957032f,      (float const   )955.370117188f, 
        (float const   )963.894958497f,      (float const   )972.430419922f,      (float const   )980.976379395f,      (float const   )989.532836915f, 
        (float const   )998.099609375f,      (float const   )1006.67675782f,      (float const   )1015.26409913f,      (float const   )1023.86157227f, 
        (float const   )1032.46923829f,      (float const   )1041.086792f,      (float const   )1049.71435547f,      (float const   )1058.35180665f, 
        (float const   )1066.99914551f,      (float const   )1075.65612793f,      (float const   )1084.32275391f,      (float const   )1092.99914551f, 
        (float const   )1101.68493653f,      (float const   )1110.3803711f,      (float const   )1119.08508301f,      (float const   )1127.79931641f, 
        (float const   )1136.52270508f,      (float const   )1145.25549317f,      (float const   )1153.99731446f,      (float const   )1162.74841309f, 
        (float const   )1171.50854493f,      (float const   )1180.2775879f,      (float const   )1189.05566407f,      (float const   )1197.84265137f, 
        (float const   )1206.63854981f,      (float const   )1215.44311524f,      (float const   )1224.2565918f,      (float const   )1233.07861329f, 
        (float const   )1241.90930176f,      (float const   )1250.74865723f,      (float const   )1259.59643555f,      (float const   )1268.45275879f, 
        (float const   )1277.31750489f,      (float const   )1286.19067383f,      (float const   )1295.07214356f,      (float const   )1303.96191407f, 
        (float const   )1312.85998536f,      (float const   )1321.76623536f,      (float const   )1330.680542f,      (float const   )1339.60302735f, 
        (float const   )1348.53356934f,      (float const   )1357.4720459f,      (float const   )1366.41857911f,      (float const   )1375.37304688f, 
        (float const   )1384.33544922f,      (float const   )1393.305542f,      (float const   )1402.28356934f,      (float const   )1411.26928711f, 
        (float const   )1420.26269532f,      (float const   )1429.26379395f,      (float const   )1438.27258301f,      (float const   )1447.28894043f, 
        (float const   )1456.31274415f,      (float const   )1465.34423829f,      (float const   )1474.38305665f,      (float const   )1483.42944336f, 
        (float const   )1492.4831543f,      (float const   )1501.54418946f,      (float const   )1510.6126709f,      (float const   )1519.6883545f, 
        (float const   )1528.77124024f,      (float const   )1537.8614502f,      (float const   )1546.95874024f,      (float const   )1556.06323243f, 
        (float const   )1565.17480469f,      (float const   )1574.29345704f,      (float const   )1583.41906739f,      (float const   )1592.55175782f, 
        (float const   )1601.69140625f,      (float const   )1610.8380127f,      (float const   )1619.99157715f,      (float const   )1629.15197754f, 
        (float const   )1638.3190918f,      (float const   )1647.49316407f,      (float const   )1656.6739502f,      (float const   )1665.8614502f, 
        (float const   )1675.05566407f,      (float const   )1684.2565918f,      (float const   )1693.4642334f,      (float const   )1702.67834473f, 
        (float const   )1711.89916993f,      (float const   )1721.12646485f,      (float const   )1730.36035157f,      (float const   )1739.60070801f, 
        (float const   )1748.84753418f,      (float const   )1758.10070801f,      (float const   )1767.36047364f,      (float const   )1776.62646485f, 
        (float const   )1785.89892579f,      (float const   )1795.17761231f,      (float const   )1804.46276856f,      (float const   )1813.75402833f, 
        (float const   )1823.05163575f,      (float const   )1832.35534668f,      (float const   )1841.66540528f,      (float const   )1850.98144532f, 
        (float const   )1860.30371094f,      (float const   )1869.63220215f,      (float const   )1878.96667481f,      (float const   )1888.30712891f, 
        (float const   )1897.65368653f,      (float const   )1907.00634766f,      (float const   )1916.36486817f,      (float const   )1925.72949219f, 
        (float const   )1935.09985352f,      (float const   )1944.47631836f,      (float const   )1953.85852051f,      (float const   )1963.24670411f, 
        (float const   )1972.640625f,      (float const   )1982.04052735f,      (float const   )1991.44604493f,      (float const   )2000.85742188f, 
        (float const   )2010.27453614f,      (float const   )2019.6973877f,      (float const   )2029.1258545f,      (float const   )2038.56018067f};
#line 236 "/root/patchweave_new/13/src/dsp/lossless.c"
float VP8LFastSLog2Slow(int v ) 
{ 
  int log_cnt ;
  float v_f ;
  double __cil_tmp5 ;

  {
#line 238
  if (v < 4096) {
#line 239
    log_cnt = 0;
#line 240
    v_f = (float )v;
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;

#line 241
      if (! (v >= 256)) {
#line 241
        goto while_break;
      }
#line 242
      log_cnt ++;
#line 243
      v >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 245
    return (v_f * (float )(kLog2Table[v] + (float const   )((float )log_cnt)));
  } else {
    {
#line 247
    __cil_tmp5 = log((double )v);
    }
#line 247
    return ((float )((1.44269504089 * (double )v) * __cil_tmp5));
  }
}
}
#line 251 "/root/patchweave_new/13/src/dsp/lossless.c"
float VP8LFastLog2Slow(int v ) 
{ 
  int log_cnt ;
  double __cil_tmp4 ;

  {
#line 253
  if (v < 4096) {
#line 254
    log_cnt = 0;
    {
#line 255
    while (1) {
      while_continue: /* CIL Label */ ;

#line 255
      if (! (v >= 256)) {
#line 255
        goto while_break;
      }
#line 256
      log_cnt ++;
#line 257
      v >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
#line 259
    return ((float )(kLog2Table[v] + (float const   )((float )log_cnt)));
  } else {
    {
#line 261
    __cil_tmp4 = log((double )v);
    }
#line 261
    return ((float )(1.44269504089 * __cil_tmp4));
  }
}
}
#line 269 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static void AddPixelsEq(uint32_t *a , uint32_t b ) 
{ 
  uint32_t alpha_and_green ;
  uint32_t red_and_blue ;

  {
#line 270
  alpha_and_green = (*a & 4278255360U) + (b & 4278255360U);
#line 271
  red_and_blue = (*a & 16711935U) + (b & 16711935U);
#line 272
  *a = (alpha_and_green & 4278255360U) | (red_and_blue & 16711935U);
#line 273
  return;
}
}
#line 275 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint32_t Average2(uint32_t a0 , uint32_t a1 ) 
{ 


  {
#line 276
  return ((uint32_t )((((long )(a0 ^ a1) & 4278124286L) >> 1) + (long )(a0 & a1)));
}
}
#line 279 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint32_t Average3(uint32_t a0 , uint32_t a1 , uint32_t a2 ) 
{ 
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;

  {
  {
#line 280
  __cil_tmp4 = Average2(a0, a2);
#line 280
  __cil_tmp5 = Average2(__cil_tmp4, a1);
  }
#line 280
  return (__cil_tmp5);
}
}
#line 283 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint32_t Average4(uint32_t a0 , uint32_t a1 , uint32_t a2 , uint32_t a3 ) 
{ 
  uint32_t __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;

  {
  {
#line 285
  __cil_tmp5 = Average2(a0, a1);
#line 285
  __cil_tmp6 = Average2(a2, a3);
#line 285
  __cil_tmp7 = Average2(__cil_tmp5, __cil_tmp6);
  }
#line 285
  return (__cil_tmp7);
}
}
#line 343 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint32_t Clip255(uint32_t a ) 
{ 


  {
#line 344
  if (a < 256U) {
#line 345
    return (a);
  }
#line 349
  return (~ a >> 24);
}
}
#line 352 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static int AddSubtractComponentFull(int a , int b , int c ) 
{ 
  uint32_t __cil_tmp4 ;

  {
  {
#line 353
  __cil_tmp4 = Clip255((uint32_t )((a + b) - c));
  }
#line 353
  return ((int )__cil_tmp4);
}
}
#line 356 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint32_t ClampedAddSubtractFull(uint32_t c0 , uint32_t c1 , uint32_t c2 ) 
{ 
  int a ;
  int __cil_tmp5 ;
  int r ;
  int __cil_tmp7 ;
  int g ;
  int __cil_tmp9 ;
  int b ;
  int __cil_tmp11 ;

  {
  {
#line 358
  __cil_tmp5 = AddSubtractComponentFull((int )(c0 >> 24), (int )(c1 >> 24), (int )(c2 >> 24));
#line 358
  a = __cil_tmp5;
#line 359
  __cil_tmp7 = AddSubtractComponentFull((int )((c0 >> 16) & 255U), (int )((c1 >> 16) & 255U),
                                        (int )((c2 >> 16) & 255U));
#line 359
  r = __cil_tmp7;
#line 362
  __cil_tmp9 = AddSubtractComponentFull((int )((c0 >> 8) & 255U), (int )((c1 >> 8) & 255U),
                                        (int )((c2 >> 8) & 255U));
#line 362
  g = __cil_tmp9;
#line 365
  __cil_tmp11 = AddSubtractComponentFull((int )(c0 & 255U), (int )(c1 & 255U), (int )(c2 & 255U));
#line 365
  b = __cil_tmp11;
  }
#line 366
  return ((uint32_t )((((a << 24) | (r << 16)) | (g << 8)) | b));
}
}
#line 369 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static int AddSubtractComponentHalf(int a , int b ) 
{ 
  uint32_t __cil_tmp3 ;

  {
  {
#line 370
  __cil_tmp3 = Clip255((uint32_t )(a + (a - b) / 2));
  }
#line 370
  return ((int )__cil_tmp3);
}
}
#line 373 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint32_t ClampedAddSubtractHalf(uint32_t c0 , uint32_t c1 , uint32_t c2 ) 
{ 
  uint32_t ave ;
  uint32_t __cil_tmp5 ;
  int a ;
  int __cil_tmp7 ;
  int r ;
  int __cil_tmp9 ;
  int g ;
  int __cil_tmp11 ;
  int b ;
  int __cil_tmp13 ;

  {
  {
#line 375
  __cil_tmp5 = Average2(c0, c1);
#line 375
  ave = __cil_tmp5;
#line 376
  __cil_tmp7 = AddSubtractComponentHalf((int )(ave >> 24), (int )(c2 >> 24));
#line 376
  a = __cil_tmp7;
#line 377
  __cil_tmp9 = AddSubtractComponentHalf((int )((ave >> 16) & 255U), (int )((c2 >> 16) & 255U));
#line 377
  r = __cil_tmp9;
#line 378
  __cil_tmp11 = AddSubtractComponentHalf((int )((ave >> 8) & 255U), (int )((c2 >> 8) & 255U));
#line 378
  g = __cil_tmp11;
#line 379
  __cil_tmp13 = AddSubtractComponentHalf((int )(ave & 255U), (int )(c2 & 255U));
#line 379
  b = __cil_tmp13;
  }
#line 380
  return ((uint32_t )((((a << 24) | (r << 16)) | (g << 8)) | b));
}
}
#line 383 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static int Sub3(int a , int b , int c ) 
{ 
  int pb ;
  int pa ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 384
  pb = b - c;
#line 385
  pa = a - c;
#line 386
  __cil_tmp7 = abs(pa);
#line 386
  __cil_tmp6 = abs(pb);
  }
#line 386
  return (__cil_tmp6 - __cil_tmp7);
}
}
#line 389 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint32_t Select(uint32_t a , uint32_t b , uint32_t c ) 
{ 
  int pa_minus_pb ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  uint32_t tmp ;

  {
  {
#line 390
  __cil_tmp8 = Sub3((int )(a & 255U), (int )(b & 255U), (int )(c & 255U));
#line 390
  __cil_tmp7 = Sub3((int )((a >> 8) & 255U), (int )((b >> 8) & 255U), (int )((c >> 8) & 255U));
#line 390
  __cil_tmp6 = Sub3((int )((a >> 16) & 255U), (int )((b >> 16) & 255U), (int )((c >> 16) & 255U));
#line 390
  __cil_tmp5 = Sub3((int )(a >> 24), (int )(b >> 24), (int )(c >> 24));
#line 390
  pa_minus_pb = ((__cil_tmp5 + __cil_tmp6) + __cil_tmp7) + __cil_tmp8;
  }
#line 395
  if (pa_minus_pb <= 0) {
#line 395
    tmp = a;
  } else {
#line 395
    tmp = b;
  }
#line 395
  return (tmp);
}
}
#line 402 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor0(uint32_t left , uint32_t *top ) 
{ 


  {
#line 405
  return (4278190080U);
}
}
#line 407 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor1(uint32_t left , uint32_t *top ) 
{ 


  {
#line 409
  return (left);
}
}
#line 411 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor2(uint32_t left , uint32_t *top ) 
{ 


  {
#line 413
  return (*(top + 0));
}
}
#line 415 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor3(uint32_t left , uint32_t *top ) 
{ 


  {
#line 417
  return (*(top + 1));
}
}
#line 419 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor4(uint32_t left , uint32_t *top ) 
{ 


  {
#line 421
  return (*(top + -1));
}
}
#line 423 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor5(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 424
  __cil_tmp4 = Average3(left, *(top + 0), *(top + 1));
#line 424
  pred = __cil_tmp4;
  }
#line 425
  return (pred);
}
}
#line 427 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor6(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 428
  __cil_tmp4 = Average2(left, *(top + -1));
#line 428
  pred = __cil_tmp4;
  }
#line 429
  return (pred);
}
}
#line 431 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor7(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 432
  __cil_tmp4 = Average2(left, *(top + 0));
#line 432
  pred = __cil_tmp4;
  }
#line 433
  return (pred);
}
}
#line 435 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor8(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 436
  __cil_tmp4 = Average2(*(top + -1), *(top + 0));
#line 436
  pred = __cil_tmp4;
  }
#line 438
  return (pred);
}
}
#line 440 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor9(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 441
  __cil_tmp4 = Average2(*(top + 0), *(top + 1));
#line 441
  pred = __cil_tmp4;
  }
#line 443
  return (pred);
}
}
#line 445 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor10(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 446
  __cil_tmp4 = Average4(left, *(top + -1), *(top + 0), *(top + 1));
#line 446
  pred = __cil_tmp4;
  }
#line 447
  return (pred);
}
}
#line 449 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor11(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 450
  __cil_tmp4 = Select(*(top + 0), left, *(top + -1));
#line 450
  pred = __cil_tmp4;
  }
#line 451
  return (pred);
}
}
#line 453 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor12(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 454
  __cil_tmp4 = ClampedAddSubtractFull(left, *(top + 0), *(top + -1));
#line 454
  pred = __cil_tmp4;
  }
#line 455
  return (pred);
}
}
#line 457 "/root/patchweave_new/13/src/dsp/lossless.c"
static uint32_t Predictor13(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 458
  __cil_tmp4 = ClampedAddSubtractHalf(left, *(top + 0), *(top + -1));
#line 458
  pred = __cil_tmp4;
  }
#line 459
  return (pred);
}
}
#line 463 "/root/patchweave_new/13/src/dsp/lossless.c"
static PredictorFunc kPredictors[16]  = 
#line 463
  {      (PredictorFunc )(& Predictor0),      (PredictorFunc )(& Predictor1),      (PredictorFunc )(& Predictor2),      (PredictorFunc )(& Predictor3), 
        (PredictorFunc )(& Predictor4),      (PredictorFunc )(& Predictor5),      (PredictorFunc )(& Predictor6),      (PredictorFunc )(& Predictor7), 
        (PredictorFunc )(& Predictor8),      (PredictorFunc )(& Predictor9),      (PredictorFunc )(& Predictor10),      (PredictorFunc )(& Predictor11), 
        (PredictorFunc )(& Predictor12),      (PredictorFunc )(& Predictor13),      (PredictorFunc )(& Predictor0),      (PredictorFunc )(& Predictor0)};
#line 472 "/root/patchweave_new/13/src/dsp/lossless.c"
static float PredictionCostSpatial(int const   *counts , int weight_0 , double exp_val ) 
{ 
  int significant_symbols ;
  double exp_decay_factor ;
  double bits ;
  int i ;

  {
#line 474
  significant_symbols = 16;
#line 475
  exp_decay_factor = 0.6;
#line 476
  bits = (double )(weight_0 * (int )*(counts + 0));
#line 478
  i = 1;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;

#line 478
    if (! (i < significant_symbols)) {
#line 478
      goto while_break;
    }
#line 479
    bits += exp_val * (double )(*(counts + i) + *(counts + (256 - i)));
#line 480
    exp_val *= exp_decay_factor;
#line 478
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 482
  return ((float )(- 0.100000000001 * bits));
}
}
#line 486 "/root/patchweave_new/13/src/dsp/lossless.c"
static float CombinedShannonEntropy(int const   *X , int const   *Y , int n ) 
{ 
  int i ;
  double retval ;
  int sumX ;
  int sumXY ;
  int x ;
  int xy ;
  float __cil_tmp10 ;
  float __cil_tmp11 ;
  float __cil_tmp12 ;
  float __cil_tmp13 ;

  {
#line 489
  retval = 0.;
#line 490
  sumX = 0;
#line 490
  sumXY = 0;
#line 491
  i = 0;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;

#line 491
    if (! (i < n)) {
#line 491
      goto while_break;
    }
#line 492
    x = (int )*(X + i);
#line 493
    xy = (int )(*(X + i) + *(Y + i));
#line 494
    if (x != 0) {
      {
#line 495
      sumX += x;
#line 496
      __cil_tmp10 = VP8LFastSLog2(x);
#line 496
      retval -= (double )__cil_tmp10;
      }
    }
#line 498
    if (xy != 0) {
      {
#line 499
      sumXY += xy;
#line 500
      __cil_tmp11 = VP8LFastSLog2(xy);
#line 500
      retval -= (double )__cil_tmp11;
      }
    }
#line 491
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 503
  __cil_tmp13 = VP8LFastSLog2(sumXY);
#line 503
  __cil_tmp12 = VP8LFastSLog2(sumX);
#line 503
  retval += (double )(__cil_tmp12 + __cil_tmp13);
  }
#line 504
  return ((float )retval);
}
}
#line 507 "/root/patchweave_new/13/src/dsp/lossless.c"
static float PredictionCostSpatialHistogram(int (*accumulated)[256] , int (*tile)[256] ) 
{ 
  int i ;
  double retval ;
  double kExpValue ;
  float __cil_tmp6 ;
  float __cil_tmp7 ;

  {
#line 510
  retval = (double )0;
#line 511
  i = 0;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;

#line 511
    if (! (i < 4)) {
#line 511
      goto while_break;
    }
    {
#line 512
    kExpValue = 0.94;
#line 513
    __cil_tmp6 = PredictionCostSpatial((int const   *)(*(tile + i)), 1, kExpValue);
#line 513
    retval += (double )__cil_tmp6;
#line 514
    __cil_tmp7 = CombinedShannonEntropy((int const   *)(*(tile + i)), (int const   *)(*(accumulated + i)),
                                        256);
#line 514
    retval += (double )__cil_tmp7;
#line 511
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 516
  return ((float )retval);
}
}
#line 519 "/root/patchweave_new/13/src/dsp/lossless.c"
static int GetBestPredictorForTile(int width , int height , int tile_x , int tile_y ,
                                   int bits , int (*accumulated)[256] , uint32_t *argb_scratch ) 
{ 
  int kNumPredModes ;
  int col_start ;
  int row_start ;
  int tile_size ;
  int ymax ;
  int tmp ;
  int xmax ;
  int tmp___0 ;
  int histo[4][256] ;
  float best_diff ;
  int best_mode ;
  int mode ;
  uint32_t *current_row ;
  uint32_t (*pred_func)(uint32_t  , uint32_t * const   ) ;
  float cur_diff ;
  int y ;
  int x ;
  int row ;
  uint32_t *upper_row ;
  int col ;
  uint32_t predict ;
  uint32_t predict_diff ;
  unsigned int tmp___1 ;

  {
#line 523
  kNumPredModes = 14;
#line 524
  col_start = tile_x << bits;
#line 525
  row_start = tile_y << bits;
#line 526
  tile_size = 1 << bits;
#line 527
  if (tile_size <= height - row_start) {
#line 527
    tmp = tile_size;
  } else {
#line 527
    tmp = height - row_start;
  }
#line 527
  ymax = tmp;
#line 529
  if (tile_size <= width - col_start) {
#line 529
    tmp___0 = tile_size;
  } else {
#line 529
    tmp___0 = width - col_start;
  }
#line 529
  xmax = tmp___0;
#line 532
  best_diff = 1.00000001505e+30f;
#line 533
  best_mode = 0;
#line 536
  mode = 0;
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;

#line 536
    if (! (mode < kNumPredModes)) {
#line 536
      goto while_break;
    }
    {
#line 537
    current_row = argb_scratch;
#line 538
    pred_func = kPredictors[mode];
#line 541
    memset((void *)(& histo[0][0]), 0, sizeof(histo));
#line 542
    y = 0;
    }
    {
#line 542
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 542
      if (! (y < ymax)) {
#line 542
        goto while_break___0;
      }
#line 544
      row = row_start + y;
#line 545
      upper_row = current_row;
#line 546
      current_row = upper_row + width;
#line 547
      x = 0;
      {
#line 547
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 547
        if (! (x < xmax)) {
#line 547
          goto while_break___1;
        }
#line 548
        col = col_start + x;
#line 551
        if (row == 0) {
#line 552
          if (col == 0) {
#line 552
            tmp___1 = 4278190080U;
          } else {
#line 552
            tmp___1 = *(current_row + (col - 1));
          }
#line 552
          predict = tmp___1;
        } else
#line 553
        if (col == 0) {
#line 554
          predict = *(upper_row + col);
        } else {
          {
#line 556
          predict = (*pred_func)(*(current_row + (col - 1)), (uint32_t */* const  */)(upper_row + col));
          }
        }
        {
#line 558
        predict_diff = VP8LSubPixels(*(current_row + col), predict);
#line 559
        (histo[0][predict_diff >> 24]) ++;
#line 560
        (histo[1][(predict_diff >> 16) & 255U]) ++;
#line 561
        (histo[2][(predict_diff >> 8) & 255U]) ++;
#line 562
        (histo[3][predict_diff & 255U]) ++;
#line 547
        x ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 542
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 565
    cur_diff = PredictionCostSpatialHistogram(accumulated, (int (*)[256])(histo));
    }
#line 566
    if (cur_diff < best_diff) {
#line 567
      best_diff = cur_diff;
#line 568
      best_mode = mode;
    }
#line 536
    mode ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 572
  return (best_mode);
}
}
#line 575 "/root/patchweave_new/13/src/dsp/lossless.c"
static void CopyTileWithPrediction(int width , int height , int tile_x , int tile_y ,
                                   int bits , int mode , uint32_t *argb_scratch ,
                                   uint32_t *argb ) 
{ 
  int col_start ;
  int row_start ;
  int tile_size ;
  int ymax ;
  int tmp ;
  int xmax ;
  int tmp___0 ;
  uint32_t (*pred_func)(uint32_t  , uint32_t * const   ) ;
  uint32_t *current_row ;
  int y ;
  int x ;
  int row ;
  uint32_t *upper_row ;
  int col ;
  int pix ;
  uint32_t predict ;
  unsigned int tmp___1 ;

  {
#line 579
  col_start = tile_x << bits;
#line 580
  row_start = tile_y << bits;
#line 581
  tile_size = 1 << bits;
#line 582
  if (tile_size <= height - row_start) {
#line 582
    tmp = tile_size;
  } else {
#line 582
    tmp = height - row_start;
  }
#line 582
  ymax = tmp;
#line 584
  if (tile_size <= width - col_start) {
#line 584
    tmp___0 = tile_size;
  } else {
#line 584
    tmp___0 = width - col_start;
  }
#line 584
  xmax = tmp___0;
#line 586
  pred_func = kPredictors[mode];
#line 587
  current_row = argb_scratch;
#line 590
  y = 0;
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;

#line 590
    if (! (y < ymax)) {
#line 590
      goto while_break;
    }
#line 592
    row = row_start + y;
#line 593
    upper_row = current_row;
#line 594
    current_row = upper_row + width;
#line 595
    x = 0;
    {
#line 595
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 595
      if (! (x < xmax)) {
#line 595
        goto while_break___0;
      }
#line 596
      col = col_start + x;
#line 597
      pix = row * width + col;
#line 599
      if (row == 0) {
#line 600
        if (col == 0) {
#line 600
          tmp___1 = 4278190080U;
        } else {
#line 600
          tmp___1 = *(current_row + (col - 1));
        }
#line 600
        predict = tmp___1;
      } else
#line 601
      if (col == 0) {
#line 602
        predict = *(upper_row + col);
      } else {
        {
#line 604
        predict = (*pred_func)(*(current_row + (col - 1)), (uint32_t */* const  */)(upper_row + col));
        }
      }
      {
#line 606
      *(argb + pix) = VP8LSubPixels(*(current_row + col), predict);
#line 595
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 590
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 594
  return;
}
}
#line 611 "/root/patchweave_new/13/src/dsp/lossless.c"
void VP8LResidualImage(int width , int height , int bits , uint32_t *argb , uint32_t *argb_scratch ,
                       uint32_t *image ) 
{ 
  int max_tile_size ;
  int tiles_per_row ;
  uint32_t __cil_tmp9 ;
  int tiles_per_col ;
  uint32_t __cil_tmp11 ;
  uint32_t *upper_row ;
  uint32_t *current_tile_rows ;
  int tile_y ;
  int histo[4][256] ;
  int tile_y_offset ;
  int this_tile_height ;
  int tmp ;
  int tile_x ;
  int pred ;
  int y ;
  int tile_x_offset ;
  int all_x_max ;
  int ix ;
  int all_x ;
  int all_y ;
  uint32_t a ;

  {
  {
#line 614
  max_tile_size = 1 << bits;
#line 615
  __cil_tmp9 = VP8LSubSampleSize((uint32_t )width, (uint32_t )bits);
#line 615
  tiles_per_row = (int )__cil_tmp9;
#line 616
  __cil_tmp11 = VP8LSubSampleSize((uint32_t )height, (uint32_t )bits);
#line 616
  tiles_per_col = (int )__cil_tmp11;
#line 617
  upper_row = argb_scratch;
#line 618
  current_tile_rows = argb_scratch + width;
#line 621
  memset((void *)(histo), 0, sizeof(histo));
#line 622
  tile_y = 0;
  }
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;

#line 622
    if (! (tile_y < tiles_per_col)) {
#line 622
      goto while_break;
    }
#line 623
    tile_y_offset = tile_y * max_tile_size;
#line 624
    if (tile_y < tiles_per_col - 1) {
#line 624
      tmp = max_tile_size;
    } else {
#line 624
      tmp = height - tile_y_offset;
    }
#line 624
    this_tile_height = tmp;
#line 627
    if (tile_y > 0) {
      {
#line 628
      memcpy((void *)upper_row, (void const   *)(current_tile_rows + (max_tile_size - 1) * width),
             (unsigned long )width * sizeof(*upper_row));
      }
    }
    {
#line 631
    memcpy((void *)current_tile_rows, (void const   *)(argb + tile_y_offset * width),
           (unsigned long )(this_tile_height * width) * sizeof(*current_tile_rows));
#line 633
    tile_x = 0;
    }
    {
#line 633
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 633
      if (! (tile_x < tiles_per_row)) {
#line 633
        goto while_break___0;
      }
#line 636
      tile_x_offset = tile_x * max_tile_size;
#line 637
      all_x_max = tile_x_offset + max_tile_size;
#line 638
      if (all_x_max > width) {
#line 639
        all_x_max = width;
      }
      {
#line 641
      pred = GetBestPredictorForTile(width, height, tile_x, tile_y, bits, (int (*)[256])(histo),
                                     argb_scratch);
#line 643
      *(image + (tile_y * tiles_per_row + tile_x)) = 4278190080U | (unsigned int )(pred << 8);
#line 644
      CopyTileWithPrediction(width, height, tile_x, tile_y, bits, pred, argb_scratch,
                             argb);
#line 646
      y = 0;
      }
      {
#line 646
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 646
        if (! (y < max_tile_size)) {
#line 646
          goto while_break___1;
        }
#line 649
        all_y = tile_y_offset + y;
#line 650
        if (all_y >= height) {
#line 651
          goto while_break___1;
        }
#line 653
        ix = all_y * width + tile_x_offset;
#line 654
        all_x = tile_x_offset;
        {
#line 654
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 654
          if (! (all_x < all_x_max)) {
#line 654
            goto while_break___2;
          }
#line 655
          a = *(argb + ix);
#line 656
          (histo[0][a >> 24]) ++;
#line 657
          (histo[1][(a >> 16) & 255U]) ++;
#line 658
          (histo[2][(a >> 8) & 255U]) ++;
#line 659
          (histo[3][a & 255U]) ++;
#line 654
          ix ++;
#line 654
          all_x ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 646
        y ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 633
      tile_x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 622
    tile_y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 626
  return;
}
}
#line 667 "/root/patchweave_new/13/src/dsp/lossless.c"
static void PredictorInverseTransform(VP8LTransform *transform , int y_start , int y_end ,
                                      uint32_t *data ) 
{ 
  int width ;
  int x ;
  uint32_t pred0 ;
  uint32_t __cil_tmp8 ;
  uint32_t pred1 ;
  uint32_t __cil_tmp10 ;
  int y ;
  int mask ;
  int tiles_per_row ;
  uint32_t __cil_tmp14 ;
  uint32_t *pred_mode_base ;
  int x___0 ;
  uint32_t pred2 ;
  uint32_t __cil_tmp18 ;
  uint32_t *pred_mode_src ;
  uint32_t (*pred_func)(uint32_t  , uint32_t * const   ) ;
  uint32_t *__cil_tmp21 ;
  uint32_t pred ;
  uint32_t *__cil_tmp23 ;

  {
#line 669
  width = transform->xsize_;
#line 670
  if (y_start == 0) {
    {
#line 672
    __cil_tmp8 = Predictor0(*(data + -1), (uint32_t *)((void *)0));
#line 672
    pred0 = __cil_tmp8;
#line 673
    AddPixelsEq(data, pred0);
#line 674
    x = 1;
    }
    {
#line 674
    while (1) {
      while_continue: /* CIL Label */ ;

#line 674
      if (! (x < width)) {
#line 674
        goto while_break;
      }
      {
#line 675
      __cil_tmp10 = Predictor1(*(data + (x - 1)), (uint32_t *)((void *)0));
#line 675
      pred1 = __cil_tmp10;
#line 676
      AddPixelsEq(data + x, pred1);
#line 674
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
#line 678
    data += width;
#line 679
    y_start ++;
  }
  {
#line 683
  y = y_start;
#line 684
  mask = (1 << transform->bits_) - 1;
#line 685
  __cil_tmp14 = VP8LSubSampleSize((uint32_t )width, (uint32_t )transform->bits_);
#line 685
  tiles_per_row = (int )__cil_tmp14;
#line 686
  pred_mode_base = transform->data_ + (y >> transform->bits_) * tiles_per_row;
  }
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 689
    if (! (y < y_end)) {
#line 689
      goto while_break___0;
    }
    {
#line 691
    __cil_tmp18 = Predictor2(*(data + -1), data - width);
#line 691
    pred2 = __cil_tmp18;
#line 692
    pred_mode_src = pred_mode_base;
#line 696
    AddPixelsEq(data, pred2);
#line 699
    __cil_tmp21 = pred_mode_src;
#line 699
    pred_mode_src ++;
#line 699
    pred_func = kPredictors[(*__cil_tmp21 >> 8) & 15U];
#line 700
    x___0 = 1;
    }
    {
#line 700
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 700
      if (! (x___0 < width)) {
#line 700
        goto while_break___1;
      }
#line 702
      if ((x___0 & mask) == 0) {
#line 703
        __cil_tmp23 = pred_mode_src;
#line 703
        pred_mode_src ++;
#line 703
        pred_func = kPredictors[(*__cil_tmp23 >> 8) & 15U];
      }
      {
#line 705
      pred = (*pred_func)(*(data + (x___0 - 1)), (uint32_t */* const  */)((data + x___0) - width));
#line 706
      AddPixelsEq(data + x___0, pred);
#line 700
      x___0 ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 708
    data += width;
#line 709
    y ++;
#line 710
    if ((y & mask) == 0) {
#line 711
      pred_mode_base += tiles_per_row;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 716
  return;
}
}
#line 717 "/root/patchweave_new/13/src/dsp/lossless.c"
void VP8LSubtractGreenFromBlueAndRed(uint32_t *argb_data , int num_pixs ) 
{ 
  int i ;
  uint32_t argb ;
  uint32_t green ;
  uint32_t new_r ;
  uint32_t new_b ;

  {
#line 718
  i = 0;
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;

#line 732
    if (! (i < num_pixs)) {
#line 732
      goto while_break;
    }
#line 733
    argb = *(argb_data + i);
#line 734
    green = (argb >> 8) & 255U;
#line 735
    new_r = (((argb >> 16) & 255U) - green) & 255U;
#line 736
    new_b = ((argb & 255U) - green) & 255U;
#line 737
    *(argb_data + i) = ((argb & 4278255360U) | (new_r << 16)) | new_b;
#line 732
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 736
  return;
}
}
#line 743 "/root/patchweave_new/13/src/dsp/lossless.c"
static void AddGreenToBlueAndRed(VP8LTransform *transform , int y_start , int y_end ,
                                 uint32_t *data ) 
{ 
  int width ;
  uint32_t *data_end ;
  uint32_t argb ;
  uint32_t green ;
  uint32_t red_blue ;
  uint32_t *__cil_tmp10 ;

  {
#line 745
  width = transform->xsize_;
#line 746
  data_end = data + (y_end - y_start) * width;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;

#line 760
    if (! ((unsigned long )data < (unsigned long )data_end)) {
#line 760
      goto while_break;
    }
#line 761
    argb = *data;
#line 762
    green = (argb >> 8) & 255U;
#line 763
    red_blue = argb & 16711935U;
#line 764
    red_blue += (green << 16) | green;
#line 765
    red_blue &= 16711935U;
#line 766
    __cil_tmp10 = data;
#line 766
    data ++;
#line 766
    *__cil_tmp10 = (argb & 4278255360U) | red_blue;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 770
  return;
}
}
#line 778 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static void MultipliersClear(Multipliers *m ) 
{ 


  {
#line 779
  m->green_to_red_ = (uint8_t )0;
#line 780
  m->green_to_blue_ = (uint8_t )0;
#line 781
  m->red_to_blue_ = (uint8_t )0;
#line 782
  return;
}
}
#line 784 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint32_t ColorTransformDelta(int8_t color_pred , int8_t color ) 
{ 


  {
#line 786
  return ((uint32_t )((int )color_pred * (int )color) >> 5);
}
}
#line 789 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static void ColorCodeToMultipliers(uint32_t color_code , Multipliers *m ) 
{ 


  {
#line 791
  m->green_to_red_ = (uint8_t )(color_code & 255U);
#line 792
  m->green_to_blue_ = (uint8_t )((color_code >> 8) & 255U);
#line 793
  m->red_to_blue_ = (uint8_t )((color_code >> 16) & 255U);
#line 794
  return;
}
}
#line 796 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint32_t MultipliersToColorCode(Multipliers *m ) 
{ 


  {
#line 797
  return (((4278190080U | ((uint32_t )m->red_to_blue_ << 16)) | ((uint32_t )m->green_to_blue_ << 8)) | (unsigned int )m->green_to_red_);
}
}
#line 803 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint32_t TransformColor(Multipliers *m , uint32_t argb , int inverse ) 
{ 
  uint32_t green ;
  uint32_t red ;
  uint32_t new_red ;
  uint32_t new_blue ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;

  {
#line 805
  green = argb >> 8;
#line 806
  red = argb >> 16;
#line 807
  new_red = red;
#line 808
  new_blue = argb;
#line 810
  if (inverse) {
    {
#line 811
    __cil_tmp8 = ColorTransformDelta((int8_t )m->green_to_red_, (int8_t )green);
#line 811
    new_red += __cil_tmp8;
#line 812
    new_red &= 255U;
#line 813
    __cil_tmp9 = ColorTransformDelta((int8_t )m->green_to_blue_, (int8_t )green);
#line 813
    new_blue += __cil_tmp9;
#line 814
    __cil_tmp10 = ColorTransformDelta((int8_t )m->red_to_blue_, (int8_t )new_red);
#line 814
    new_blue += __cil_tmp10;
#line 815
    new_blue &= 255U;
    }
  } else {
    {
#line 817
    __cil_tmp11 = ColorTransformDelta((int8_t )m->green_to_red_, (int8_t )green);
#line 817
    new_red -= __cil_tmp11;
#line 818
    new_red &= 255U;
#line 819
    __cil_tmp12 = ColorTransformDelta((int8_t )m->green_to_blue_, (int8_t )green);
#line 819
    new_blue -= __cil_tmp12;
#line 820
    __cil_tmp13 = ColorTransformDelta((int8_t )m->red_to_blue_, (int8_t )red);
#line 820
    new_blue -= __cil_tmp13;
#line 821
    new_blue &= 255U;
    }
  }
#line 823
  return (((argb & 4278255360U) | (new_red << 16)) | new_blue);
}
}
#line 826 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint8_t TransformColorRed(uint8_t green_to_red , uint32_t argb ) 
{ 
  uint32_t green ;
  uint32_t new_red ;
  uint32_t __cil_tmp5 ;

  {
  {
#line 828
  green = argb >> 8;
#line 829
  new_red = argb >> 16;
#line 830
  __cil_tmp5 = ColorTransformDelta((int8_t )green_to_red, (int8_t )green);
#line 830
  new_red -= __cil_tmp5;
  }
#line 831
  return ((uint8_t )(new_red & 255U));
}
}
#line 834 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static uint8_t TransformColorBlue(uint8_t green_to_blue , uint8_t red_to_blue ,
                                           uint32_t argb ) 
{ 
  uint32_t green ;
  uint32_t red ;
  uint8_t new_blue ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;

  {
  {
#line 837
  green = argb >> 8;
#line 838
  red = argb >> 16;
#line 839
  new_blue = (uint8_t )argb;
#line 840
  __cil_tmp7 = ColorTransformDelta((int8_t )green_to_blue, (int8_t )green);
#line 840
  new_blue = (uint8_t )((uint32_t )new_blue - __cil_tmp7);
#line 841
  __cil_tmp8 = ColorTransformDelta((int8_t )red_to_blue, (int8_t )red);
#line 841
  new_blue = (uint8_t )((uint32_t )new_blue - __cil_tmp8);
  }
#line 842
  return ((uint8_t )((int )new_blue & 255));
}
}
#line 845 "/root/patchweave_new/13/src/dsp/lossless.c"
__inline static int SkipRepeatedPixels(uint32_t *argb , int ix , int xsize ) 
{ 
  uint32_t v ;
  int tmp ;
  int tmp___0 ;

  {
#line 847
  v = *(argb + ix);
#line 848
  if (ix >= xsize + 3) {
#line 849
    if (v == *(argb + (ix - xsize))) {
#line 849
      if (*(argb + (ix - 1)) == *(argb + ((ix - xsize) - 1))) {
#line 849
        if (*(argb + (ix - 2)) == *(argb + ((ix - xsize) - 2))) {
#line 849
          if (*(argb + (ix - 3)) == *(argb + ((ix - xsize) - 3))) {
#line 853
            return (1);
          }
        }
      }
    }
#line 855
    if (v == *(argb + (ix - 3))) {
#line 855
      if (v == *(argb + (ix - 2))) {
#line 855
        if (v == *(argb + (ix - 1))) {
#line 855
          tmp = 1;
        } else {
#line 855
          tmp = 0;
        }
      } else {
#line 855
        tmp = 0;
      }
    } else {
#line 855
      tmp = 0;
    }
#line 855
    return (tmp);
  } else
#line 856
  if (ix >= 3) {
#line 857
    if (v == *(argb + (ix - 3))) {
#line 857
      if (v == *(argb + (ix - 2))) {
#line 857
        if (v == *(argb + (ix - 1))) {
#line 857
          tmp___0 = 1;
        } else {
#line 857
          tmp___0 = 0;
        }
      } else {
#line 857
        tmp___0 = 0;
      }
    } else {
#line 857
      tmp___0 = 0;
    }
#line 857
    return (tmp___0);
  }
#line 859
  return (0);
}
}
#line 864 "/root/patchweave_new/13/src/dsp/lossless.c"
static double kExpValue  ;
#line 862 "/root/patchweave_new/13/src/dsp/lossless.c"
static float PredictionCostCrossColor(int const   *accumulated , int const   *counts ) 
{ 
  float __cil_tmp4 ;
  float __cil_tmp5 ;

  {
  {
#line 866
  kExpValue = 2.4;
#line 867
  __cil_tmp5 = PredictionCostSpatial((int const   *)counts, 3, kExpValue);
#line 867
  __cil_tmp4 = CombinedShannonEntropy((int const   *)counts, (int const   *)accumulated,
                                      256);
  }
#line 867
  return (__cil_tmp4 + __cil_tmp5);
}
}
#line 871 "/root/patchweave_new/13/src/dsp/lossless.c"
static Multipliers GetBestColorTransformForTile(int tile_x , int tile_y , int bits ,
                                                Multipliers prevX , Multipliers prevY ,
                                                int step , int xsize , int ysize ,
                                                int *accumulated_red_histo , int *accumulated_blue_histo ,
                                                uint32_t *argb ) 
{ 
  float best_diff ;
  float cur_diff ;
  int halfstep ;
  int max_tile_size ;
  int tile_y_offset ;
  int tile_x_offset ;
  int green_to_red ;
  int green_to_blue ;
  int red_to_blue ;
  int all_x_max ;
  int all_y_max ;
  Multipliers best_tx ;
  int histo[256] ;
  unsigned int tmp ;
  int all_y ;
  int ix ;
  int all_x ;
  int __cil_tmp29 ;
  uint8_t __cil_tmp30 ;
  int all_y___0 ;
  int histo___0[256] ;
  unsigned int tmp___0 ;
  int all_x___0 ;
  int ix___0 ;
  int __cil_tmp37 ;
  uint8_t __cil_tmp38 ;

  {
  {
#line 879
  best_diff = 1.00000001505e+30f;
#line 881
  halfstep = step / 2;
#line 882
  max_tile_size = 1 << bits;
#line 883
  tile_y_offset = tile_y * max_tile_size;
#line 884
  tile_x_offset = tile_x * max_tile_size;
#line 888
  all_x_max = tile_x_offset + max_tile_size;
#line 889
  all_y_max = tile_y_offset + max_tile_size;
#line 891
  MultipliersClear(& best_tx);
  }
#line 892
  if (all_x_max > xsize) {
#line 893
    all_x_max = xsize;
  }
#line 895
  if (all_y_max > ysize) {
#line 896
    all_y_max = ysize;
  }
#line 899
  green_to_red = -64;
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;

#line 899
    if (! (green_to_red <= 64)) {
#line 899
      goto while_break;
    }
#line 900
    histo[0] = 0;
#line 900
    tmp = 1U;
    {
#line 900
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 900
      if (tmp >= 256U) {
#line 900
        goto while_break___0;
      }
#line 900
      histo[tmp] = 0;
#line 900
      tmp ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: 
#line 903
    all_y = tile_y_offset;
    {
#line 903
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 903
      if (! (all_y < all_y_max)) {
#line 903
        goto while_break___1;
      }
#line 904
      ix = all_y * xsize + tile_x_offset;
#line 906
      all_x = tile_x_offset;
      {
#line 906
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___2: ;
#line 906
        if (! (all_x < all_x_max)) {
#line 906
          goto while_break___2;
        }
        {
#line 907
        __cil_tmp29 = SkipRepeatedPixels(argb, ix, xsize);
        }
#line 907
        if (__cil_tmp29) {
#line 908
          goto while_continue___2;
        }
        {
#line 910
        __cil_tmp30 = TransformColorRed((uint8_t )green_to_red, *(argb + ix));
#line 910
        (histo[__cil_tmp30]) ++;
#line 906
        ix ++;
#line 906
        all_x ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___2: 
#line 903
      all_y ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 913
    __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/lossless.c:913)":);
#line 913
    __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/lossless.c:913)":);
#line 913
    cur_diff = PredictionCostCrossColor((int const   *)0, (int const   *)0);
    }
#line 914
    if ((int )((uint8_t )green_to_red) == (int )prevX.green_to_red_) {
#line 915
      cur_diff -= (float )3;
    }
#line 917
    if ((int )((uint8_t )green_to_red) == (int )prevY.green_to_red_) {
#line 918
      cur_diff -= (float )3;
    }
#line 920
    if (green_to_red == 0) {
#line 921
      cur_diff -= (float )3;
    }
#line 923
    if (cur_diff < best_diff) {
#line 924
      best_diff = cur_diff;
#line 925
      best_tx.green_to_red_ = (uint8_t )green_to_red;
    }
#line 899
    green_to_red += halfstep;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: 
#line 928
  best_diff = 1.00000001505e+30f;
#line 929
  green_to_blue = -32;
  {
#line 929
  while (1) {
    while_continue___11: /* CIL Label */ ;

#line 929
    if (! (green_to_blue <= 32)) {
#line 929
      goto while_break___3;
    }
#line 930
    red_to_blue = -32;
    {
#line 930
    while (1) {
      while_continue___12: /* CIL Label */ ;

#line 930
      if (! (red_to_blue <= 32)) {
#line 930
        goto while_break___4;
      }
#line 932
      histo___0[0] = 0;
#line 932
      tmp___0 = 1U;
      {
#line 932
      while (1) {
        while_continue___13: /* CIL Label */ ;

#line 932
        if (tmp___0 >= 256U) {
#line 932
          goto while_break___5;
        }
#line 932
        histo___0[tmp___0] = 0;
#line 932
        tmp___0 ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___5: 
#line 933
      all_y___0 = tile_y_offset;
      {
#line 933
      while (1) {
        while_continue___14: /* CIL Label */ ;

#line 933
        if (! (all_y___0 < all_y_max)) {
#line 933
          goto while_break___6;
        }
#line 935
        ix___0 = all_y___0 * xsize + tile_x_offset;
#line 936
        all_x___0 = tile_x_offset;
        {
#line 936
        while (1) {
          while_continue___15: /* CIL Label */ ;
          while_continue___7: ;
#line 936
          if (! (all_x___0 < all_x_max)) {
#line 936
            goto while_break___7;
          }
          {
#line 937
          __cil_tmp37 = SkipRepeatedPixels(argb, ix___0, xsize);
          }
#line 937
          if (__cil_tmp37) {
#line 938
            goto while_continue___7;
          }
          {
#line 940
          __cil_tmp38 = TransformColorBlue((uint8_t )green_to_blue, (uint8_t )red_to_blue,
                                           *(argb + ix___0));
#line 940
          (histo___0[__cil_tmp38]) ++;
#line 936
          ix___0 ++;
#line 936
          all_x___0 ++;
          }
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___7: 
#line 933
        all_y___0 ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___6: 
      {
#line 943
      __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/lossless.c:943)":);
#line 943
      __asm__  ("booo_exp(/root/patchweave_new/13/src/dsp/lossless.c:943)":);
#line 943
      cur_diff = PredictionCostCrossColor((int const   *)0, (int const   *)0);
      }
#line 945
      if ((int )((uint8_t )green_to_blue) == (int )prevX.green_to_blue_) {
#line 946
        cur_diff -= (float )3;
      }
#line 948
      if ((int )((uint8_t )green_to_blue) == (int )prevY.green_to_blue_) {
#line 949
        cur_diff -= (float )3;
      }
#line 951
      if ((int )((uint8_t )red_to_blue) == (int )prevX.red_to_blue_) {
#line 952
        cur_diff -= (float )3;
      }
#line 954
      if ((int )((uint8_t )red_to_blue) == (int )prevY.red_to_blue_) {
#line 955
        cur_diff -= (float )3;
      }
#line 957
      if (green_to_blue == 0) {
#line 958
        cur_diff -= (float )3;
      }
#line 960
      if (red_to_blue == 0) {
#line 961
        cur_diff -= (float )3;
      }
#line 963
      if (cur_diff < best_diff) {
#line 964
        best_diff = cur_diff;
#line 965
        best_tx.green_to_blue_ = (uint8_t )green_to_blue;
#line 966
        best_tx.red_to_blue_ = (uint8_t )red_to_blue;
      }
#line 930
      red_to_blue += step;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: 
#line 929
    green_to_blue += step;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___3: ;
#line 970
  return (best_tx);
}
}
#line 973 "/root/patchweave_new/13/src/dsp/lossless.c"
static void CopyTileWithColorTransform(int xsize , int ysize , int tile_x , int tile_y ,
                                       int bits , Multipliers color_transform , uint32_t *argb ) 
{ 
  int y ;
  int xscan ;
  int yscan ;
  int ix ;
  int end_ix ;

  {
#line 978
  xscan = 1 << bits;
#line 979
  yscan = 1 << bits;
#line 980
  tile_x <<= bits;
#line 981
  tile_y <<= bits;
#line 982
  if (xscan > xsize - tile_x) {
#line 983
    xscan = xsize - tile_x;
  }
#line 985
  if (yscan > ysize - tile_y) {
#line 986
    yscan = ysize - tile_y;
  }
#line 988
  yscan += tile_y;
#line 989
  y = tile_y;
  {
#line 989
  while (1) {
    while_continue: /* CIL Label */ ;

#line 989
    if (! (y < yscan)) {
#line 989
      goto while_break;
    }
#line 990
    ix = y * xsize + tile_x;
#line 991
    end_ix = ix + xscan;
    {
#line 992
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 992
      if (! (ix < end_ix)) {
#line 992
        goto while_break___0;
      }
      {
#line 993
      *(argb + ix) = TransformColor(& color_transform, *(argb + ix), 0);
#line 992
      ix ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 989
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 993
  return;
}
}
#line 998 "/root/patchweave_new/13/src/dsp/lossless.c"
void VP8LColorSpaceTransform(int width , int height , int bits , int step , uint32_t *argb ,
                             uint32_t *image ) 
{ 
  int max_tile_size ;
  int tile_xsize ;
  uint32_t __cil_tmp9 ;
  int tile_ysize ;
  uint32_t __cil_tmp11 ;
  int accumulated_red_histo[256] ;
  unsigned int tmp ;
  int accumulated_blue_histo[256] ;
  unsigned int tmp___0 ;
  int tile_y ;
  int tile_x ;
  Multipliers prevX ;
  Multipliers prevY ;
  Multipliers color_transform ;
  int all_x_max ;
  int y ;
  int tile_y_offset ;
  int tile_x_offset ;
  int ix ;
  int all_x ;
  int all_y ;

  {
  {
#line 1000
  max_tile_size = 1 << bits;
#line 1001
  __cil_tmp9 = VP8LSubSampleSize((uint32_t )width, (uint32_t )bits);
#line 1001
  tile_xsize = (int )__cil_tmp9;
#line 1002
  __cil_tmp11 = VP8LSubSampleSize((uint32_t )height, (uint32_t )bits);
#line 1002
  tile_ysize = (int )__cil_tmp11;
#line 1003
  accumulated_red_histo[0] = 0;
#line 1003
  tmp = 1U;
  }
  {
#line 1003
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1003
    if (tmp >= 256U) {
#line 1003
      goto while_break;
    }
#line 1003
    accumulated_red_histo[tmp] = 0;
#line 1003
    tmp ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
#line 1004
  accumulated_blue_histo[0] = 0;
#line 1004
  tmp___0 = 1U;
  {
#line 1004
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 1004
    if (tmp___0 >= 256U) {
#line 1004
      goto while_break___0;
    }
#line 1004
    accumulated_blue_histo[tmp___0] = 0;
#line 1004
    tmp___0 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1009
  MultipliersClear(& prevY);
#line 1010
  MultipliersClear(& prevX);
#line 1011
  tile_y = 0;
  }
  {
#line 1011
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 1011
    if (! (tile_y < tile_ysize)) {
#line 1011
      goto while_break___1;
    }
#line 1012
    tile_x = 0;
    {
#line 1012
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 1012
      if (! (tile_x < tile_xsize)) {
#line 1012
        goto while_break___2;
      }
#line 1016
      tile_y_offset = tile_y * max_tile_size;
#line 1017
      tile_x_offset = tile_x * max_tile_size;
#line 1018
      if (tile_y != 0) {
        {
#line 1019
        ColorCodeToMultipliers(*(image + ((tile_y * tile_xsize + tile_x) - 1)), & prevX);
#line 1020
        ColorCodeToMultipliers(*(image + ((tile_y - 1) * tile_xsize + tile_x)), & prevY);
        }
      } else
#line 1022
      if (tile_x != 0) {
        {
#line 1023
        ColorCodeToMultipliers(*(image + ((tile_y * tile_xsize + tile_x) - 1)), & prevX);
        }
      }
      {
#line 1025
      color_transform = GetBestColorTransformForTile(tile_x, tile_y, bits, prevX,
                                                     prevY, step, width, height, & accumulated_red_histo[0],
                                                     & accumulated_blue_histo[0],
                                                     argb);
#line 1032
      *(image + (tile_y * tile_xsize + tile_x)) = MultipliersToColorCode(& color_transform);
#line 1034
      CopyTileWithColorTransform(width, height, tile_x, tile_y, bits, color_transform,
                                 argb);
#line 1038
      all_x_max = tile_x_offset + max_tile_size;
      }
#line 1039
      if (all_x_max > width) {
#line 1040
        all_x_max = width;
      }
#line 1042
      y = 0;
      {
#line 1042
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 1042
        if (! (y < max_tile_size)) {
#line 1042
          goto while_break___3;
        }
#line 1045
        all_y = tile_y_offset + y;
#line 1046
        if (all_y >= height) {
#line 1047
          goto while_break___3;
        }
#line 1049
        ix = all_y * width + tile_x_offset;
#line 1050
        all_x = tile_x_offset;
        {
#line 1050
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___4: ;
#line 1050
          if (! (all_x < all_x_max)) {
#line 1050
            goto while_break___4;
          }
#line 1051
          if (ix >= 2) {
#line 1051
            if (*(argb + ix) == *(argb + (ix - 2))) {
#line 1051
              if (*(argb + ix) == *(argb + (ix - 1))) {
#line 1054
                goto while_continue___4;
              }
            }
          }
#line 1056
          if (ix >= width + 2) {
#line 1056
            if (*(argb + (ix - 2)) == *(argb + ((ix - width) - 2))) {
#line 1056
              if (*(argb + (ix - 1)) == *(argb + ((ix - width) - 1))) {
#line 1056
                if (*(argb + ix) == *(argb + (ix - width))) {
#line 1060
                  goto while_continue___4;
                }
              }
            }
          }
#line 1062
          (accumulated_red_histo[(*(argb + ix) >> 16) & 255U]) ++;
#line 1063
          (accumulated_blue_histo[*(argb + ix) & 255U]) ++;
#line 1050
          ix ++;
#line 1050
          all_x ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: 
#line 1042
        y ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: 
#line 1012
      tile_x ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
#line 1011
    tile_y ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: ;
#line 1015
  return;
}
}
#line 1071 "/root/patchweave_new/13/src/dsp/lossless.c"
static void ColorSpaceInverseTransform(VP8LTransform *transform , int y_start , int y_end ,
                                       uint32_t *data ) 
{ 
  int width ;
  int mask ;
  int tiles_per_row ;
  uint32_t __cil_tmp8 ;
  int y ;
  uint32_t *pred_row ;
  uint32_t *pred ;
  Multipliers m ;
  int x ;
  uint32_t *__cil_tmp14 ;

  {
  {
#line 1073
  width = transform->xsize_;
#line 1074
  mask = (1 << transform->bits_) - 1;
#line 1075
  __cil_tmp8 = VP8LSubSampleSize((uint32_t )width, (uint32_t )transform->bits_);
#line 1075
  tiles_per_row = (int )__cil_tmp8;
#line 1076
  y = y_start;
#line 1077
  pred_row = transform->data_ + (y >> transform->bits_) * tiles_per_row;
  }
  {
#line 1080
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1080
    if (! (y < y_end)) {
#line 1080
      goto while_break;
    }
#line 1081
    pred = pred_row;
#line 1082
    m.green_to_red_ = (uint8_t )0;
#line 1082
    m.green_to_blue_ = (uint8_t )0;
#line 1082
    m.red_to_blue_ = (uint8_t )0;
#line 1085
    x = 0;
    {
#line 1085
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1085
      if (! (x < width)) {
#line 1085
        goto while_break___0;
      }
#line 1086
      if ((x & mask) == 0) {
        {
#line 1086
        __cil_tmp14 = pred;
#line 1086
        pred ++;
#line 1086
        ColorCodeToMultipliers(*__cil_tmp14, & m);
        }
      }
      {
#line 1087
      *(data + x) = TransformColor(& m, *(data + x), 1);
#line 1085
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 1089
    data += width;
#line 1090
    y ++;
#line 1091
    if ((y & mask) == 0) {
#line 1091
      pred_row += tiles_per_row;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1097
  return;
}
}
#line 1096 "/root/patchweave_new/13/src/dsp/lossless.c"
static void ColorIndexInverseTransform(VP8LTransform *transform , int y_start , int y_end ,
                                       uint32_t *src , uint32_t *dst ) 
{ 
  int y ;
  int bits_per_pixel ;
  int width ;
  uint32_t *color_map ;
  int pixels_per_byte ;
  int count_mask ;
  uint32_t bit_mask ;
  uint32_t packed_pixels ;
  int x ;
  uint32_t *__cil_tmp15 ;
  uint32_t *__cil_tmp16 ;
  int x___0 ;
  uint32_t *__cil_tmp18 ;
  uint32_t *__cil_tmp19 ;

  {
#line 1100
  bits_per_pixel = 8 >> transform->bits_;
#line 1101
  width = transform->xsize_;
#line 1102
  color_map = transform->data_;
#line 1103
  if (bits_per_pixel < 8) {
#line 1104
    pixels_per_byte = 1 << transform->bits_;
#line 1105
    count_mask = pixels_per_byte - 1;
#line 1106
    bit_mask = (uint32_t )((1 << bits_per_pixel) - 1);
#line 1107
    y = y_start;
    {
#line 1107
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1107
      if (! (y < y_end)) {
#line 1107
        goto while_break;
      }
#line 1108
      packed_pixels = (uint32_t )0;
#line 1110
      x = 0;
      {
#line 1110
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1110
        if (! (x < width)) {
#line 1110
          goto while_break___0;
        }
#line 1114
        if ((x & count_mask) == 0) {
#line 1114
          __cil_tmp15 = src;
#line 1114
          src ++;
#line 1114
          packed_pixels = (*__cil_tmp15 >> 8) & 255U;
        }
#line 1115
        __cil_tmp16 = dst;
#line 1115
        dst ++;
#line 1115
        *__cil_tmp16 = *(color_map + (packed_pixels & bit_mask));
#line 1116
        packed_pixels >>= bits_per_pixel;
#line 1110
        x ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
#line 1107
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 1120
    y = y_start;
    {
#line 1120
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1120
      if (! (y < y_end)) {
#line 1120
        goto while_break___1;
      }
#line 1122
      x___0 = 0;
      {
#line 1122
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1122
        if (! (x___0 < width)) {
#line 1122
          goto while_break___2;
        }
#line 1123
        __cil_tmp19 = src;
#line 1123
        src ++;
#line 1123
        __cil_tmp18 = dst;
#line 1123
        dst ++;
#line 1123
        *__cil_tmp18 = *(color_map + ((*__cil_tmp19 >> 8) & 255U));
#line 1122
        x___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 1120
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 1125
  return;
}
}
#line 1129 "/root/patchweave_new/13/src/dsp/lossless.c"
void VP8LInverseTransform(VP8LTransform *transform , int row_start , int row_end ,
                          uint32_t *in , uint32_t *out ) 
{ 
  int width ;
  int out_stride ;
  int in_stride ;
  uint32_t __cil_tmp11 ;
  uint32_t *src ;

  {
#line 1135
  if ((unsigned int )transform->type_ == 2U) {
#line 1135
    goto case_2;
  }
#line 1138
  if ((unsigned int )transform->type_ == 0U) {
#line 1138
    goto case_0;
  }
#line 1148
  if ((unsigned int )transform->type_ == 1U) {
#line 1148
    goto case_1;
  }
#line 1151
  if ((unsigned int )transform->type_ == 3U) {
#line 1151
    goto case_3;
  }
#line 1134
  goto switch_break;
  case_2: 
  {
#line 1136
  AddGreenToBlueAndRed(transform, row_start, row_end, out);
  }
#line 1137
  goto switch_break;
  case_0: 
  {
#line 1139
  PredictorInverseTransform(transform, row_start, row_end, out);
  }
#line 1140
  if (row_end != transform->ysize_) {
    {
#line 1143
    width = transform->xsize_;
#line 1144
    memcpy((void *)(out - width), (void const   *)(out + ((row_end - row_start) - 1) * width),
           (unsigned long )width * sizeof(*out));
    }
  }
#line 1147
  goto switch_break;
  case_1: 
  {
#line 1149
  ColorSpaceInverseTransform(transform, row_start, row_end, out);
  }
#line 1150
  goto switch_break;
  case_3: 
#line 1152
  if ((unsigned long )in == (unsigned long )out) {
#line 1152
    if (transform->bits_ > 0) {
      {
#line 1158
      out_stride = (row_end - row_start) * transform->xsize_;
#line 1159
      __cil_tmp11 = VP8LSubSampleSize((uint32_t )transform->xsize_, (uint32_t )transform->bits_);
#line 1159
      in_stride = (int )((unsigned int )(row_end - row_start) * __cil_tmp11);
#line 1161
      src = (out + out_stride) - in_stride;
#line 1162
      memmove((void *)src, (void const   *)out, (unsigned long )in_stride * sizeof(*src));
#line 1163
      ColorIndexInverseTransform(transform, row_start, row_end, src, out);
      }
    } else {
      {
#line 1165
      ColorIndexInverseTransform(transform, row_start, row_end, in, out);
      }
    }
  } else {
    {
#line 1165
    ColorIndexInverseTransform(transform, row_start, row_end, in, out);
    }
  }
#line 1167
  goto switch_break;
  switch_break: ;
#line 1170
  return;
}
}
#line 1176 "/root/patchweave_new/13/src/dsp/lossless.c"
static union __anonunion_609 tmp  ;
#line 1174 "/root/patchweave_new/13/src/dsp/lossless.c"
static int is_big_endian(void) 
{ 


  {
#line 1175
  tmp.w = (uint16_t )1;
#line 1179
  return ((int )tmp.b[0] != 1);
}
}
#line 1182 "/root/patchweave_new/13/src/dsp/lossless.c"
static void ConvertBGRAToRGB(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t *__cil_tmp7 ;
  uint8_t *__cil_tmp8 ;
  uint8_t *__cil_tmp9 ;

  {
#line 1184
  src_end = src + num_pixels;
  {
#line 1185
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1185
    if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 1185
      goto while_break;
    }
#line 1186
    __cil_tmp6 = src;
#line 1186
    src ++;
#line 1186
    argb = *__cil_tmp6;
#line 1187
    __cil_tmp7 = dst;
#line 1187
    dst ++;
#line 1187
    *__cil_tmp7 = (uint8_t )((argb >> 16) & 255U);
#line 1188
    __cil_tmp8 = dst;
#line 1188
    dst ++;
#line 1188
    *__cil_tmp8 = (uint8_t )((argb >> 8) & 255U);
#line 1189
    __cil_tmp9 = dst;
#line 1189
    dst ++;
#line 1189
    *__cil_tmp9 = (uint8_t )(argb & 255U);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1193
  return;
}
}
#line 1193 "/root/patchweave_new/13/src/dsp/lossless.c"
static void ConvertBGRAToRGBA(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t *__cil_tmp7 ;
  uint8_t *__cil_tmp8 ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 1195
  src_end = src + num_pixels;
  {
#line 1196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1196
    if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 1196
      goto while_break;
    }
#line 1197
    __cil_tmp6 = src;
#line 1197
    src ++;
#line 1197
    argb = *__cil_tmp6;
#line 1198
    __cil_tmp7 = dst;
#line 1198
    dst ++;
#line 1198
    *__cil_tmp7 = (uint8_t )((argb >> 16) & 255U);
#line 1199
    __cil_tmp8 = dst;
#line 1199
    dst ++;
#line 1199
    *__cil_tmp8 = (uint8_t )((argb >> 8) & 255U);
#line 1200
    __cil_tmp9 = dst;
#line 1200
    dst ++;
#line 1200
    *__cil_tmp9 = (uint8_t )(argb & 255U);
#line 1201
    __cil_tmp10 = dst;
#line 1201
    dst ++;
#line 1201
    *__cil_tmp10 = (uint8_t )((argb >> 24) & 255U);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1205
  return;
}
}
#line 1205 "/root/patchweave_new/13/src/dsp/lossless.c"
static void ConvertBGRAToRGBA4444(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t rg ;
  uint8_t ba ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 1207
  src_end = src + num_pixels;
  {
#line 1208
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1208
    if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 1208
      goto while_break;
    }
#line 1209
    __cil_tmp6 = src;
#line 1209
    src ++;
#line 1209
    argb = *__cil_tmp6;
#line 1210
    rg = (uint8_t )(((argb >> 16) & 240U) | ((argb >> 12) & 15U));
#line 1211
    ba = (uint8_t )((argb & 240U) | ((argb >> 28) & 15U));
#line 1216
    __cil_tmp9 = dst;
#line 1216
    dst ++;
#line 1216
    *__cil_tmp9 = rg;
#line 1217
    __cil_tmp10 = dst;
#line 1217
    dst ++;
#line 1217
    *__cil_tmp10 = ba;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1221
  return;
}
}
#line 1222 "/root/patchweave_new/13/src/dsp/lossless.c"
static void ConvertBGRAToRGB565(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t rg ;
  uint8_t gb ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 1224
  src_end = src + num_pixels;
  {
#line 1225
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1225
    if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 1225
      goto while_break;
    }
#line 1226
    __cil_tmp6 = src;
#line 1226
    src ++;
#line 1226
    argb = *__cil_tmp6;
#line 1227
    rg = (uint8_t )(((argb >> 16) & 248U) | ((argb >> 13) & 7U));
#line 1228
    gb = (uint8_t )(((argb >> 5) & 224U) | ((argb >> 3) & 31U));
#line 1233
    __cil_tmp9 = dst;
#line 1233
    dst ++;
#line 1233
    *__cil_tmp9 = rg;
#line 1234
    __cil_tmp10 = dst;
#line 1234
    dst ++;
#line 1234
    *__cil_tmp10 = gb;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1238
  return;
}
}
#line 1239 "/root/patchweave_new/13/src/dsp/lossless.c"
static void ConvertBGRAToBGR(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t *__cil_tmp7 ;
  uint8_t *__cil_tmp8 ;
  uint8_t *__cil_tmp9 ;

  {
#line 1241
  src_end = src + num_pixels;
  {
#line 1242
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1242
    if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 1242
      goto while_break;
    }
#line 1243
    __cil_tmp6 = src;
#line 1243
    src ++;
#line 1243
    argb = *__cil_tmp6;
#line 1244
    __cil_tmp7 = dst;
#line 1244
    dst ++;
#line 1244
    *__cil_tmp7 = (uint8_t )(argb & 255U);
#line 1245
    __cil_tmp8 = dst;
#line 1245
    dst ++;
#line 1245
    *__cil_tmp8 = (uint8_t )((argb >> 8) & 255U);
#line 1246
    __cil_tmp9 = dst;
#line 1246
    dst ++;
#line 1246
    *__cil_tmp9 = (uint8_t )((argb >> 16) & 255U);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1250
  return;
}
}
#line 1250 "/root/patchweave_new/13/src/dsp/lossless.c"
static void CopyOrSwap(uint32_t *src , int num_pixels , uint8_t *dst , int swap_on_big_endian ) 
{ 
  int __cil_tmp5 ;
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp8 ;

  {
  {
#line 1252
  __cil_tmp5 = is_big_endian();
  }
#line 1252
  if (__cil_tmp5 == swap_on_big_endian) {
#line 1253
    src_end = src + num_pixels;
    {
#line 1254
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1254
      if (! ((unsigned long )src < (unsigned long )src_end)) {
#line 1254
        goto while_break;
      }
#line 1255
      __cil_tmp8 = src;
#line 1255
      src ++;
#line 1255
      argb = *__cil_tmp8;
#line 1256
      __asm__  ("asm":);
#line 1260
      *((uint32_t *)dst) = argb;
#line 1276
      dst += sizeof(argb);
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 1279
    memcpy((void *)dst, (void const   *)src, (unsigned long )num_pixels * sizeof(*src));
    }
  }
#line 1282
  return;
}
}
#line 1283 "/root/patchweave_new/13/src/dsp/lossless.c"
void VP8LConvertFromBGRA(uint32_t *in_data , int num_pixels , enum WEBP_CSP_MODE out_colorspace ,
                         uint8_t *rgba ) 
{ 


  {
#line 1286
  if ((unsigned int )out_colorspace == 0U) {
#line 1286
    goto case_0;
  }
#line 1289
  if ((unsigned int )out_colorspace == 1U) {
#line 1289
    goto case_1;
  }
#line 1292
  if ((unsigned int )out_colorspace == 7U) {
#line 1292
    goto case_7;
  }
#line 1296
  if ((unsigned int )out_colorspace == 2U) {
#line 1296
    goto case_2;
  }
#line 1299
  if ((unsigned int )out_colorspace == 3U) {
#line 1299
    goto case_3;
  }
#line 1302
  if ((unsigned int )out_colorspace == 8U) {
#line 1302
    goto case_8;
  }
#line 1306
  if ((unsigned int )out_colorspace == 4U) {
#line 1306
    goto case_4;
  }
#line 1309
  if ((unsigned int )out_colorspace == 9U) {
#line 1309
    goto case_9;
  }
#line 1313
  if ((unsigned int )out_colorspace == 5U) {
#line 1313
    goto case_5;
  }
#line 1316
  if ((unsigned int )out_colorspace == 10U) {
#line 1316
    goto case_10;
  }
#line 1320
  if ((unsigned int )out_colorspace == 6U) {
#line 1320
    goto case_6;
  }
#line 1285
  goto switch_break;
  case_0: 
  {
#line 1287
  ConvertBGRAToRGB(in_data, num_pixels, rgba);
  }
#line 1288
  goto switch_break;
  case_1: 
  {
#line 1290
  ConvertBGRAToRGBA(in_data, num_pixels, rgba);
  }
#line 1291
  goto switch_break;
  case_7: 
  {
#line 1293
  ConvertBGRAToRGBA(in_data, num_pixels, rgba);
#line 1294
  (*WebPApplyAlphaMultiply)(rgba, 0, num_pixels, 1, 0);
  }
#line 1295
  goto switch_break;
  case_2: 
  {
#line 1297
  ConvertBGRAToBGR(in_data, num_pixels, rgba);
  }
#line 1298
  goto switch_break;
  case_3: 
  {
#line 1300
  CopyOrSwap(in_data, num_pixels, rgba, 1);
  }
#line 1301
  goto switch_break;
  case_8: 
  {
#line 1303
  CopyOrSwap(in_data, num_pixels, rgba, 1);
#line 1304
  (*WebPApplyAlphaMultiply)(rgba, 0, num_pixels, 1, 0);
  }
#line 1305
  goto switch_break;
  case_4: 
  {
#line 1307
  CopyOrSwap(in_data, num_pixels, rgba, 0);
  }
#line 1308
  goto switch_break;
  case_9: 
  {
#line 1310
  CopyOrSwap(in_data, num_pixels, rgba, 0);
#line 1311
  (*WebPApplyAlphaMultiply)(rgba, 1, num_pixels, 1, 0);
  }
#line 1312
  goto switch_break;
  case_5: 
  {
#line 1314
  ConvertBGRAToRGBA4444(in_data, num_pixels, rgba);
  }
#line 1315
  goto switch_break;
  case_10: 
  {
#line 1317
  ConvertBGRAToRGBA4444(in_data, num_pixels, rgba);
#line 1318
  (*WebPApplyAlphaMultiply4444)(rgba, num_pixels, 1, 0);
  }
#line 1319
  goto switch_break;
  case_6: 
  {
#line 1321
  ConvertBGRAToRGB565(in_data, num_pixels, rgba);
  }
#line 1322
  goto switch_break;
  switch_break: ;
#line 1325
  return;
}
}
#line 57 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static void CollectHistogramSSE2(uint8_t *ref , uint8_t *pred , int start_block ,
                                 int end_block , VP8Histogram *histo ) 
{ 
  __m128i max_coeff_thresh ;
  __m128i __cil_tmp7 ;
  int j ;
  int16_t out[16] ;
  int k ;
  __m128i out0 ;
  __m128i __cil_tmp12 ;
  __m128i out1 ;
  __m128i __cil_tmp14 ;
  __m128i sign0 ;
  __m128i __cil_tmp16 ;
  __m128i sign1 ;
  __m128i __cil_tmp18 ;
  __m128i xor0 ;
  __m128i __cil_tmp20 ;
  __m128i xor1 ;
  __m128i __cil_tmp22 ;
  __m128i abs0___1 ;
  __m128i __cil_tmp24 ;
  __m128i abs1___1 ;
  __m128i __cil_tmp26 ;
  __m128i v0 ;
  __m128i __cil_tmp28 ;
  __m128i v1 ;
  __m128i __cil_tmp30 ;
  __m128i bin0 ;
  __m128i __cil_tmp32 ;
  __m128i bin1 ;
  __m128i __cil_tmp34 ;

  {
  {
#line 60
  __cil_tmp7 = _mm_set1_epi16((short)31);
#line 60
  max_coeff_thresh = __cil_tmp7;
#line 62
  j = start_block;
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;

#line 62
    if (! (j < end_block)) {
#line 62
      goto while_break;
    }
    {
#line 66
    (*VP8FTransform)(ref + VP8DspScan[j], pred + VP8DspScan[j], out);
#line 71
    __cil_tmp12 = _mm_loadu_si128((__m128i *)(& out[0]));
#line 71
    out0 = __cil_tmp12;
#line 72
    __cil_tmp14 = _mm_loadu_si128((__m128i *)(& out[8]));
#line 72
    out1 = __cil_tmp14;
#line 74
    __cil_tmp16 = _mm_srai_epi16(out0, 15);
#line 74
    sign0 = __cil_tmp16;
#line 75
    __cil_tmp18 = _mm_srai_epi16(out1, 15);
#line 75
    sign1 = __cil_tmp18;
#line 77
    __cil_tmp20 = _mm_xor_si128(out0, sign0);
#line 77
    xor0 = __cil_tmp20;
#line 78
    __cil_tmp22 = _mm_xor_si128(out1, sign1);
#line 78
    xor1 = __cil_tmp22;
#line 79
    __cil_tmp24 = _mm_sub_epi16(xor0, sign0);
#line 79
    abs0___1 = __cil_tmp24;
#line 80
    __cil_tmp26 = _mm_sub_epi16(xor1, sign1);
#line 80
    abs1___1 = __cil_tmp26;
#line 82
    __cil_tmp28 = _mm_srai_epi16(abs0___1, 3);
#line 82
    v0 = __cil_tmp28;
#line 83
    __cil_tmp30 = _mm_srai_epi16(abs1___1, 3);
#line 83
    v1 = __cil_tmp30;
#line 85
    __cil_tmp32 = _mm_min_epi16(v0, max_coeff_thresh);
#line 85
    bin0 = __cil_tmp32;
#line 86
    __cil_tmp34 = _mm_min_epi16(v1, max_coeff_thresh);
#line 86
    bin1 = __cil_tmp34;
#line 88
    _mm_storeu_si128((__m128i *)(& out[0]), bin0);
#line 89
    _mm_storeu_si128((__m128i *)(& out[8]), bin1);
#line 93
    k = 0;
    }
    {
#line 93
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 93
      if (! (k < 16)) {
#line 93
        goto while_break___0;
      }
#line 94
      (histo->distribution[out[k]]) ++;
#line 93
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 62
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 66
  return;
}
}
#line 103 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static void ITransformSSE2(uint8_t *ref , int16_t *in , uint8_t *dst , int do_two ) 
{ 
  __m128i k1 ;
  __m128i __cil_tmp6 ;
  __m128i k2 ;
  __m128i __cil_tmp8 ;
  __m128i T0 ;
  __m128i T1 ;
  __m128i T2 ;
  __m128i T3 ;
  __m128i in0 ;
  __m128i in1 ;
  __m128i in2 ;
  __m128i in3 ;
  __m128i inB0 ;
  __m128i __cil_tmp22 ;
  __m128i inB1 ;
  __m128i __cil_tmp24 ;
  __m128i inB2 ;
  __m128i __cil_tmp26 ;
  __m128i inB3 ;
  __m128i __cil_tmp28 ;
  __m128i a ;
  __m128i __cil_tmp34 ;
  __m128i b ;
  __m128i __cil_tmp36 ;
  __m128i c1 ;
  __m128i __cil_tmp38 ;
  __m128i c2 ;
  __m128i __cil_tmp40 ;
  __m128i c3 ;
  __m128i __cil_tmp42 ;
  __m128i c4 ;
  __m128i __cil_tmp44 ;
  __m128i c ;
  __m128i __cil_tmp46 ;
  __m128i d1 ;
  __m128i __cil_tmp48 ;
  __m128i d2 ;
  __m128i __cil_tmp50 ;
  __m128i d3 ;
  __m128i __cil_tmp52 ;
  __m128i d4 ;
  __m128i __cil_tmp54 ;
  __m128i d ;
  __m128i __cil_tmp56 ;
  __m128i tmp0 ;
  __m128i __cil_tmp58 ;
  __m128i tmp1 ;
  __m128i __cil_tmp60 ;
  __m128i tmp2 ;
  __m128i __cil_tmp62 ;
  __m128i tmp3 ;
  __m128i __cil_tmp64 ;
  __m128i transpose0_0 ;
  __m128i __cil_tmp66 ;
  __m128i transpose0_1 ;
  __m128i __cil_tmp68 ;
  __m128i transpose0_2 ;
  __m128i __cil_tmp70 ;
  __m128i transpose0_3 ;
  __m128i __cil_tmp72 ;
  __m128i transpose1_0 ;
  __m128i __cil_tmp74 ;
  __m128i transpose1_1 ;
  __m128i __cil_tmp76 ;
  __m128i transpose1_2 ;
  __m128i __cil_tmp78 ;
  __m128i transpose1_3 ;
  __m128i __cil_tmp80 ;
  __m128i four ;
  __m128i __cil_tmp86 ;
  __m128i dc ;
  __m128i __cil_tmp88 ;
  __m128i a___0 ;
  __m128i __cil_tmp90 ;
  __m128i b___0 ;
  __m128i __cil_tmp92 ;
  __m128i c1___0 ;
  __m128i __cil_tmp94 ;
  __m128i c2___0 ;
  __m128i __cil_tmp96 ;
  __m128i c3___0 ;
  __m128i __cil_tmp98 ;
  __m128i c4___0 ;
  __m128i __cil_tmp100 ;
  __m128i c___0 ;
  __m128i __cil_tmp102 ;
  __m128i d1___0 ;
  __m128i __cil_tmp104 ;
  __m128i d2___0 ;
  __m128i __cil_tmp106 ;
  __m128i d3___0 ;
  __m128i __cil_tmp108 ;
  __m128i d4___0 ;
  __m128i __cil_tmp110 ;
  __m128i d___0 ;
  __m128i __cil_tmp112 ;
  __m128i tmp0___0 ;
  __m128i __cil_tmp114 ;
  __m128i tmp1___0 ;
  __m128i __cil_tmp116 ;
  __m128i tmp2___0 ;
  __m128i __cil_tmp118 ;
  __m128i tmp3___0 ;
  __m128i __cil_tmp120 ;
  __m128i shifted0 ;
  __m128i __cil_tmp122 ;
  __m128i shifted1 ;
  __m128i __cil_tmp124 ;
  __m128i shifted2 ;
  __m128i __cil_tmp126 ;
  __m128i shifted3 ;
  __m128i __cil_tmp128 ;
  __m128i transpose0_0___0 ;
  __m128i __cil_tmp130 ;
  __m128i transpose0_1___0 ;
  __m128i __cil_tmp132 ;
  __m128i transpose0_2___0 ;
  __m128i __cil_tmp134 ;
  __m128i transpose0_3___0 ;
  __m128i __cil_tmp136 ;
  __m128i transpose1_0___0 ;
  __m128i __cil_tmp138 ;
  __m128i transpose1_1___0 ;
  __m128i __cil_tmp140 ;
  __m128i transpose1_2___0 ;
  __m128i __cil_tmp142 ;
  __m128i transpose1_3___0 ;
  __m128i __cil_tmp144 ;
  __m128i zero ;
  __m128i __cil_tmp150 ;
  __m128i ref0 ;
  __m128i ref1 ;
  __m128i ref2 ;
  __m128i ref3 ;

  {
  {
#line 121
  __cil_tmp6 = _mm_set1_epi16((short)20091);
#line 121
  k1 = __cil_tmp6;
#line 122
  __cil_tmp8 = _mm_set1_epi16((short)-30068);
#line 122
  k2 = __cil_tmp8;
#line 131
  in0 = _mm_loadl_epi64((__m128i *)(in + 0));
#line 132
  in1 = _mm_loadl_epi64((__m128i *)(in + 4));
#line 133
  in2 = _mm_loadl_epi64((__m128i *)(in + 8));
#line 134
  in3 = _mm_loadl_epi64((__m128i *)(in + 12));
  }
#line 139
  if (do_two) {
    {
#line 140
    __cil_tmp22 = _mm_loadl_epi64((__m128i *)(in + 16));
#line 140
    inB0 = __cil_tmp22;
#line 141
    __cil_tmp24 = _mm_loadl_epi64((__m128i *)(in + 20));
#line 141
    inB1 = __cil_tmp24;
#line 142
    __cil_tmp26 = _mm_loadl_epi64((__m128i *)(in + 24));
#line 142
    inB2 = __cil_tmp26;
#line 143
    __cil_tmp28 = _mm_loadl_epi64((__m128i *)(in + 28));
#line 143
    inB3 = __cil_tmp28;
#line 144
    in0 = _mm_unpackhi_epi8(in0, inB0);
#line 145
    in1 = _mm_unpackhi_epi8(in1, inB1);
#line 146
    in2 = _mm_unpackhi_epi8(in2, inB2);
#line 147
    in3 = _mm_unpackhi_epi8(in3, inB3);
    }
  }
  {
#line 159
  __cil_tmp34 = _mm_add_epi16(in0, in2);
#line 159
  a = __cil_tmp34;
#line 160
  __cil_tmp36 = _mm_sub_epi16(in0, in2);
#line 160
  b = __cil_tmp36;
#line 162
  __cil_tmp38 = _mm_mulhi_epi16(in1, k2);
#line 162
  c1 = __cil_tmp38;
#line 163
  __cil_tmp40 = _mm_mulhi_epi16(in3, k1);
#line 163
  c2 = __cil_tmp40;
#line 164
  __cil_tmp42 = _mm_sub_epi16(in1, in3);
#line 164
  c3 = __cil_tmp42;
#line 165
  __cil_tmp44 = _mm_sub_epi16(c1, c2);
#line 165
  c4 = __cil_tmp44;
#line 166
  __cil_tmp46 = _mm_add_epi16(c3, c4);
#line 166
  c = __cil_tmp46;
#line 168
  __cil_tmp48 = _mm_mulhi_epi16(in1, k1);
#line 168
  d1 = __cil_tmp48;
#line 169
  __cil_tmp50 = _mm_mulhi_epi16(in3, k2);
#line 169
  d2 = __cil_tmp50;
#line 170
  __cil_tmp52 = _mm_add_epi16(in1, in3);
#line 170
  d3 = __cil_tmp52;
#line 171
  __cil_tmp54 = _mm_add_epi16(d1, d2);
#line 171
  d4 = __cil_tmp54;
#line 172
  __cil_tmp56 = _mm_add_epi16(d3, d4);
#line 172
  d = __cil_tmp56;
#line 175
  __cil_tmp58 = _mm_add_epi16(a, d);
#line 175
  tmp0 = __cil_tmp58;
#line 176
  __cil_tmp60 = _mm_add_epi16(b, c);
#line 176
  tmp1 = __cil_tmp60;
#line 177
  __cil_tmp62 = _mm_sub_epi16(b, c);
#line 177
  tmp2 = __cil_tmp62;
#line 178
  __cil_tmp64 = _mm_sub_epi16(a, d);
#line 178
  tmp3 = __cil_tmp64;
#line 185
  __cil_tmp66 = _mm_unpackhi_epi8(tmp0, tmp1);
#line 185
  transpose0_0 = __cil_tmp66;
#line 186
  __cil_tmp68 = _mm_unpackhi_epi8(tmp2, tmp3);
#line 186
  transpose0_1 = __cil_tmp68;
#line 187
  __cil_tmp70 = _mm_unpackhi_epi8(tmp0, tmp1);
#line 187
  transpose0_2 = __cil_tmp70;
#line 188
  __cil_tmp72 = _mm_unpackhi_epi8(tmp2, tmp3);
#line 188
  transpose0_3 = __cil_tmp72;
#line 193
  __cil_tmp74 = _mm_unpackhi_epi8(transpose0_0, transpose0_1);
#line 193
  transpose1_0 = __cil_tmp74;
#line 194
  __cil_tmp76 = _mm_unpackhi_epi8(transpose0_2, transpose0_3);
#line 194
  transpose1_1 = __cil_tmp76;
#line 195
  __cil_tmp78 = _mm_unpackhi_epi8(transpose0_0, transpose0_1);
#line 195
  transpose1_2 = __cil_tmp78;
#line 196
  __cil_tmp80 = _mm_unpackhi_epi8(transpose0_2, transpose0_3);
#line 196
  transpose1_3 = __cil_tmp80;
#line 201
  T0 = _mm_unpackhi_epi8(transpose1_0, transpose1_1);
#line 202
  T1 = _mm_unpackhi_epi8(transpose1_0, transpose1_1);
#line 203
  T2 = _mm_unpackhi_epi8(transpose1_2, transpose1_3);
#line 204
  T3 = _mm_unpackhi_epi8(transpose1_2, transpose1_3);
#line 215
  __cil_tmp86 = _mm_set1_epi16((short)4);
#line 215
  four = __cil_tmp86;
#line 216
  __cil_tmp88 = _mm_add_epi16(T0, four);
#line 216
  dc = __cil_tmp88;
#line 217
  __cil_tmp90 = _mm_add_epi16(dc, T2);
#line 217
  a___0 = __cil_tmp90;
#line 218
  __cil_tmp92 = _mm_sub_epi16(dc, T2);
#line 218
  b___0 = __cil_tmp92;
#line 220
  __cil_tmp94 = _mm_mulhi_epi16(T1, k2);
#line 220
  c1___0 = __cil_tmp94;
#line 221
  __cil_tmp96 = _mm_mulhi_epi16(T3, k1);
#line 221
  c2___0 = __cil_tmp96;
#line 222
  __cil_tmp98 = _mm_sub_epi16(T1, T3);
#line 222
  c3___0 = __cil_tmp98;
#line 223
  __cil_tmp100 = _mm_sub_epi16(c1___0, c2___0);
#line 223
  c4___0 = __cil_tmp100;
#line 224
  __cil_tmp102 = _mm_add_epi16(c3___0, c4___0);
#line 224
  c___0 = __cil_tmp102;
#line 226
  __cil_tmp104 = _mm_mulhi_epi16(T1, k1);
#line 226
  d1___0 = __cil_tmp104;
#line 227
  __cil_tmp106 = _mm_mulhi_epi16(T3, k2);
#line 227
  d2___0 = __cil_tmp106;
#line 228
  __cil_tmp108 = _mm_add_epi16(T1, T3);
#line 228
  d3___0 = __cil_tmp108;
#line 229
  __cil_tmp110 = _mm_add_epi16(d1___0, d2___0);
#line 229
  d4___0 = __cil_tmp110;
#line 230
  __cil_tmp112 = _mm_add_epi16(d3___0, d4___0);
#line 230
  d___0 = __cil_tmp112;
#line 233
  __cil_tmp114 = _mm_add_epi16(a___0, d___0);
#line 233
  tmp0___0 = __cil_tmp114;
#line 234
  __cil_tmp116 = _mm_add_epi16(b___0, c___0);
#line 234
  tmp1___0 = __cil_tmp116;
#line 235
  __cil_tmp118 = _mm_sub_epi16(b___0, c___0);
#line 235
  tmp2___0 = __cil_tmp118;
#line 236
  __cil_tmp120 = _mm_sub_epi16(a___0, d___0);
#line 236
  tmp3___0 = __cil_tmp120;
#line 237
  __cil_tmp122 = _mm_srai_epi16(tmp0___0, 3);
#line 237
  shifted0 = __cil_tmp122;
#line 238
  __cil_tmp124 = _mm_srai_epi16(tmp1___0, 3);
#line 238
  shifted1 = __cil_tmp124;
#line 239
  __cil_tmp126 = _mm_srai_epi16(tmp2___0, 3);
#line 239
  shifted2 = __cil_tmp126;
#line 240
  __cil_tmp128 = _mm_srai_epi16(tmp3___0, 3);
#line 240
  shifted3 = __cil_tmp128;
#line 247
  __cil_tmp130 = _mm_unpackhi_epi8(shifted0, shifted1);
#line 247
  transpose0_0___0 = __cil_tmp130;
#line 248
  __cil_tmp132 = _mm_unpackhi_epi8(shifted2, shifted3);
#line 248
  transpose0_1___0 = __cil_tmp132;
#line 249
  __cil_tmp134 = _mm_unpackhi_epi8(shifted0, shifted1);
#line 249
  transpose0_2___0 = __cil_tmp134;
#line 250
  __cil_tmp136 = _mm_unpackhi_epi8(shifted2, shifted3);
#line 250
  transpose0_3___0 = __cil_tmp136;
#line 255
  __cil_tmp138 = _mm_unpackhi_epi8(transpose0_0___0, transpose0_1___0);
#line 255
  transpose1_0___0 = __cil_tmp138;
#line 256
  __cil_tmp140 = _mm_unpackhi_epi8(transpose0_2___0, transpose0_3___0);
#line 256
  transpose1_1___0 = __cil_tmp140;
#line 257
  __cil_tmp142 = _mm_unpackhi_epi8(transpose0_0___0, transpose0_1___0);
#line 257
  transpose1_2___0 = __cil_tmp142;
#line 258
  __cil_tmp144 = _mm_unpackhi_epi8(transpose0_2___0, transpose0_3___0);
#line 258
  transpose1_3___0 = __cil_tmp144;
#line 263
  T0 = _mm_unpackhi_epi8(transpose1_0___0, transpose1_1___0);
#line 264
  T1 = _mm_unpackhi_epi8(transpose1_0___0, transpose1_1___0);
#line 265
  T2 = _mm_unpackhi_epi8(transpose1_2___0, transpose1_3___0);
#line 266
  T3 = _mm_unpackhi_epi8(transpose1_2___0, transpose1_3___0);
#line 275
  __cil_tmp150 = _mm_setzero_si128();
#line 275
  zero = __cil_tmp150;
  }
#line 278
  if (do_two) {
    {
#line 280
    ref0 = _mm_loadl_epi64((__m128i *)(ref + 0));
#line 281
    ref1 = _mm_loadl_epi64((__m128i *)(ref + 16));
#line 282
    ref2 = _mm_loadl_epi64((__m128i *)(ref + 32));
#line 283
    ref3 = _mm_loadl_epi64((__m128i *)(ref + 48));
    }
  } else {
    {
#line 286
    ref0 = _mm_cvtsi32_si128(*((int *)(ref + 0)));
#line 287
    ref1 = _mm_cvtsi32_si128(*((int *)(ref + 16)));
#line 288
    ref2 = _mm_cvtsi32_si128(*((int *)(ref + 32)));
#line 289
    ref3 = _mm_cvtsi32_si128(*((int *)(ref + 48)));
    }
  }
  {
#line 292
  ref0 = _mm_unpackhi_epi8(ref0, zero);
#line 293
  ref1 = _mm_unpackhi_epi8(ref1, zero);
#line 294
  ref2 = _mm_unpackhi_epi8(ref2, zero);
#line 295
  ref3 = _mm_unpackhi_epi8(ref3, zero);
#line 297
  ref0 = _mm_add_epi16(ref0, T0);
#line 298
  ref1 = _mm_add_epi16(ref1, T1);
#line 299
  ref2 = _mm_add_epi16(ref2, T2);
#line 300
  ref3 = _mm_add_epi16(ref3, T3);
#line 302
  ref0 = _mm_packus_epi16(ref0, ref0);
#line 303
  ref1 = _mm_packus_epi16(ref1, ref1);
#line 304
  ref2 = _mm_packus_epi16(ref2, ref2);
#line 305
  ref3 = _mm_packus_epi16(ref3, ref3);
  }
#line 307
  if (do_two) {
    {
#line 309
    _mm_storel_epi64((__m128i *)(dst + 0), ref0);
#line 310
    _mm_storel_epi64((__m128i *)(dst + 16), ref1);
#line 311
    _mm_storel_epi64((__m128i *)(dst + 32), ref2);
#line 312
    _mm_storel_epi64((__m128i *)(dst + 48), ref3);
    }
  } else {
    {
#line 315
    *((int32_t *)(dst + 0)) = _mm_cvtsi128_si32(ref0);
#line 316
    *((int32_t *)(dst + 16)) = _mm_cvtsi128_si32(ref1);
#line 317
    *((int32_t *)(dst + 32)) = _mm_cvtsi128_si32(ref2);
#line 318
    *((int32_t *)(dst + 48)) = _mm_cvtsi128_si32(ref3);
    }
  }
#line 321
  return;
}
}
#line 323 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static void FTransformSSE2(uint8_t *src , uint8_t *ref , int16_t *out ) 
{ 
  __m128i zero ;
  __m128i __cil_tmp5 ;
  __m128i seven ;
  __m128i __cil_tmp7 ;
  __m128i k937 ;
  __m128i __cil_tmp9 ;
  __m128i k1812 ;
  __m128i __cil_tmp11 ;
  __m128i k51000 ;
  __m128i __cil_tmp13 ;
  __m128i k12000_plus_one ;
  __m128i __cil_tmp15 ;
  __m128i k5352_2217 ;
  __m128i __cil_tmp17 ;
  __m128i k2217_5352 ;
  __m128i __cil_tmp19 ;
  __m128i k88p ;
  __m128i __cil_tmp21 ;
  __m128i k88m ;
  __m128i __cil_tmp23 ;
  __m128i k5352_2217p ;
  __m128i __cil_tmp25 ;
  __m128i k5352_2217m ;
  __m128i __cil_tmp27 ;
  __m128i v01 ;
  __m128i v32 ;
  __m128i src0 ;
  __m128i __cil_tmp31 ;
  __m128i src1 ;
  __m128i __cil_tmp33 ;
  __m128i src2 ;
  __m128i __cil_tmp35 ;
  __m128i src3 ;
  __m128i __cil_tmp37 ;
  __m128i src_0 ;
  __m128i __cil_tmp39 ;
  __m128i src_1 ;
  __m128i __cil_tmp41 ;
  __m128i src_2 ;
  __m128i __cil_tmp43 ;
  __m128i src_3 ;
  __m128i __cil_tmp45 ;
  __m128i ref0 ;
  __m128i __cil_tmp47 ;
  __m128i ref1 ;
  __m128i __cil_tmp49 ;
  __m128i ref2 ;
  __m128i __cil_tmp51 ;
  __m128i ref3 ;
  __m128i __cil_tmp53 ;
  __m128i ref_0 ;
  __m128i __cil_tmp55 ;
  __m128i ref_1 ;
  __m128i __cil_tmp57 ;
  __m128i ref_2 ;
  __m128i __cil_tmp59 ;
  __m128i ref_3 ;
  __m128i __cil_tmp61 ;
  __m128i diff0 ;
  __m128i __cil_tmp63 ;
  __m128i diff1 ;
  __m128i __cil_tmp65 ;
  __m128i diff2 ;
  __m128i __cil_tmp67 ;
  __m128i diff3 ;
  __m128i __cil_tmp69 ;
  __m128i shuf01 ;
  __m128i __cil_tmp71 ;
  __m128i shuf23 ;
  __m128i __cil_tmp73 ;
  __m128i shuf01_p ;
  __m128i __cil_tmp75 ;
  __m128i shuf23_p ;
  __m128i __cil_tmp77 ;
  __m128i s01 ;
  __m128i __cil_tmp79 ;
  __m128i s32 ;
  __m128i __cil_tmp81 ;
  __m128i a01 ;
  __m128i __cil_tmp83 ;
  __m128i a32 ;
  __m128i __cil_tmp85 ;
  __m128i tmp0 ;
  __m128i __cil_tmp87 ;
  __m128i tmp2 ;
  __m128i __cil_tmp89 ;
  __m128i tmp1_1 ;
  __m128i __cil_tmp91 ;
  __m128i tmp3_1 ;
  __m128i __cil_tmp93 ;
  __m128i tmp1_2 ;
  __m128i __cil_tmp95 ;
  __m128i tmp3_2 ;
  __m128i __cil_tmp97 ;
  __m128i tmp1 ;
  __m128i __cil_tmp99 ;
  __m128i tmp3 ;
  __m128i __cil_tmp101 ;
  __m128i s03 ;
  __m128i __cil_tmp103 ;
  __m128i s12 ;
  __m128i __cil_tmp105 ;
  __m128i s_lo ;
  __m128i __cil_tmp107 ;
  __m128i s_hi ;
  __m128i __cil_tmp109 ;
  __m128i v23 ;
  __m128i __cil_tmp111 ;
  __m128i a01___0 ;
  __m128i __cil_tmp115 ;
  __m128i a32___0 ;
  __m128i __cil_tmp117 ;
  __m128i a11 ;
  __m128i __cil_tmp119 ;
  __m128i a22 ;
  __m128i __cil_tmp121 ;
  __m128i a01_plus_7 ;
  __m128i __cil_tmp123 ;
  __m128i c0 ;
  __m128i __cil_tmp125 ;
  __m128i c2 ;
  __m128i __cil_tmp127 ;
  __m128i d0 ;
  __m128i __cil_tmp129 ;
  __m128i d2 ;
  __m128i __cil_tmp131 ;
  __m128i b23 ;
  __m128i __cil_tmp133 ;
  __m128i c1 ;
  __m128i __cil_tmp135 ;
  __m128i c3 ;
  __m128i __cil_tmp137 ;
  __m128i d1 ;
  __m128i __cil_tmp139 ;
  __m128i d3 ;
  __m128i __cil_tmp141 ;
  __m128i e1 ;
  __m128i __cil_tmp143 ;
  __m128i e3 ;
  __m128i __cil_tmp145 ;
  __m128i f1 ;
  __m128i __cil_tmp147 ;
  __m128i f3 ;
  __m128i __cil_tmp149 ;
  __m128i g1 ;
  __m128i __cil_tmp151 ;
  __m128i __cil_tmp152 ;

  {
  {
#line 325
  __cil_tmp5 = _mm_setzero_si128();
#line 325
  zero = __cil_tmp5;
#line 326
  __cil_tmp7 = _mm_set1_epi16((short)7);
#line 326
  seven = __cil_tmp7;
#line 327
  __cil_tmp9 = _mm_set1_epi32(937);
#line 327
  k937 = __cil_tmp9;
#line 328
  __cil_tmp11 = _mm_set1_epi32(1812);
#line 328
  k1812 = __cil_tmp11;
#line 329
  __cil_tmp13 = _mm_set1_epi32(51000);
#line 329
  k51000 = __cil_tmp13;
#line 330
  __cil_tmp15 = _mm_set1_epi32(12000 + (1 << 16));
#line 330
  k12000_plus_one = __cil_tmp15;
#line 331
  __cil_tmp17 = _mm_set_epi16((short)5352, (short)2217, (short)5352, (short)2217,
                              (short)5352, (short)2217, (short)5352, (short)2217);
#line 331
  k5352_2217 = __cil_tmp17;
#line 333
  __cil_tmp19 = _mm_set_epi16((short)2217, (short)-5352, (short)2217, (short)-5352,
                              (short)2217, (short)-5352, (short)2217, (short)-5352);
#line 333
  k2217_5352 = __cil_tmp19;
#line 335
  __cil_tmp21 = _mm_set_epi16((short)8, (short)8, (short)8, (short)8, (short)8, (short)8,
                              (short)8, (short)8);
#line 335
  k88p = __cil_tmp21;
#line 336
  __cil_tmp23 = _mm_set_epi16((short)-8, (short)8, (short)-8, (short)8, (short)-8,
                              (short)8, (short)-8, (short)8);
#line 336
  k88m = __cil_tmp23;
#line 337
  __cil_tmp25 = _mm_set_epi16((short)2217, (short)5352, (short)2217, (short)5352,
                              (short)2217, (short)5352, (short)2217, (short)5352);
#line 337
  k5352_2217p = __cil_tmp25;
#line 339
  __cil_tmp27 = _mm_set_epi16((short)-5352, (short)2217, (short)-5352, (short)2217,
                              (short)-5352, (short)2217, (short)-5352, (short)2217);
#line 339
  k5352_2217m = __cil_tmp27;
#line 347
  __cil_tmp31 = _mm_loadl_epi64((__m128i *)(src + 0));
#line 347
  src0 = __cil_tmp31;
#line 348
  __cil_tmp33 = _mm_loadl_epi64((__m128i *)(src + 16));
#line 348
  src1 = __cil_tmp33;
#line 349
  __cil_tmp35 = _mm_loadl_epi64((__m128i *)(src + 32));
#line 349
  src2 = __cil_tmp35;
#line 350
  __cil_tmp37 = _mm_loadl_epi64((__m128i *)(src + 48));
#line 350
  src3 = __cil_tmp37;
#line 351
  __cil_tmp39 = _mm_unpackhi_epi8(src0, zero);
#line 351
  src_0 = __cil_tmp39;
#line 352
  __cil_tmp41 = _mm_unpackhi_epi8(src1, zero);
#line 352
  src_1 = __cil_tmp41;
#line 353
  __cil_tmp43 = _mm_unpackhi_epi8(src2, zero);
#line 353
  src_2 = __cil_tmp43;
#line 354
  __cil_tmp45 = _mm_unpackhi_epi8(src3, zero);
#line 354
  src_3 = __cil_tmp45;
#line 356
  __cil_tmp47 = _mm_loadl_epi64((__m128i *)(ref + 0));
#line 356
  ref0 = __cil_tmp47;
#line 357
  __cil_tmp49 = _mm_loadl_epi64((__m128i *)(ref + 16));
#line 357
  ref1 = __cil_tmp49;
#line 358
  __cil_tmp51 = _mm_loadl_epi64((__m128i *)(ref + 32));
#line 358
  ref2 = __cil_tmp51;
#line 359
  __cil_tmp53 = _mm_loadl_epi64((__m128i *)(ref + 48));
#line 359
  ref3 = __cil_tmp53;
#line 360
  __cil_tmp55 = _mm_unpackhi_epi8(ref0, zero);
#line 360
  ref_0 = __cil_tmp55;
#line 361
  __cil_tmp57 = _mm_unpackhi_epi8(ref1, zero);
#line 361
  ref_1 = __cil_tmp57;
#line 362
  __cil_tmp59 = _mm_unpackhi_epi8(ref2, zero);
#line 362
  ref_2 = __cil_tmp59;
#line 363
  __cil_tmp61 = _mm_unpackhi_epi8(ref3, zero);
#line 363
  ref_3 = __cil_tmp61;
#line 365
  __cil_tmp63 = _mm_sub_epi16(src_0, ref_0);
#line 365
  diff0 = __cil_tmp63;
#line 366
  __cil_tmp65 = _mm_sub_epi16(src_1, ref_1);
#line 366
  diff1 = __cil_tmp65;
#line 367
  __cil_tmp67 = _mm_sub_epi16(src_2, ref_2);
#line 367
  diff2 = __cil_tmp67;
#line 368
  __cil_tmp69 = _mm_sub_epi16(src_3, ref_3);
#line 368
  diff3 = __cil_tmp69;
#line 376
  __cil_tmp71 = _mm_unpackhi_epi8(diff0, diff1);
#line 376
  shuf01 = __cil_tmp71;
#line 377
  __cil_tmp73 = _mm_unpackhi_epi8(diff2, diff3);
#line 377
  shuf23 = __cil_tmp73;
#line 380
  __cil_tmp75 = _mm_shufflehi_epi16(shuf01, ((2 << 6) | (3 << 4)) | 1);
#line 380
  shuf01_p = __cil_tmp75;
#line 382
  __cil_tmp77 = _mm_shufflehi_epi16(shuf23, ((2 << 6) | (3 << 4)) | 1);
#line 382
  shuf23_p = __cil_tmp77;
#line 386
  __cil_tmp79 = _mm_unpackhi_epi8(shuf01_p, shuf23_p);
#line 386
  s01 = __cil_tmp79;
#line 387
  __cil_tmp81 = _mm_unpackhi_epi8(shuf01_p, shuf23_p);
#line 387
  s32 = __cil_tmp81;
#line 390
  __cil_tmp83 = _mm_add_epi16(s01, s32);
#line 390
  a01 = __cil_tmp83;
#line 391
  __cil_tmp85 = _mm_sub_epi16(s01, s32);
#line 391
  a32 = __cil_tmp85;
#line 395
  __cil_tmp87 = _mm_madd_epi16(a01, k88p);
#line 395
  tmp0 = __cil_tmp87;
#line 396
  __cil_tmp89 = _mm_madd_epi16(a01, k88m);
#line 396
  tmp2 = __cil_tmp89;
#line 397
  __cil_tmp91 = _mm_madd_epi16(a32, k5352_2217p);
#line 397
  tmp1_1 = __cil_tmp91;
#line 398
  __cil_tmp93 = _mm_madd_epi16(a32, k5352_2217m);
#line 398
  tmp3_1 = __cil_tmp93;
#line 399
  __cil_tmp95 = _mm_add_epi32(tmp1_1, k1812);
#line 399
  tmp1_2 = __cil_tmp95;
#line 400
  __cil_tmp97 = _mm_add_epi32(tmp3_1, k937);
#line 400
  tmp3_2 = __cil_tmp97;
#line 401
  __cil_tmp99 = _mm_srai_epi32(tmp1_2, 9);
#line 401
  tmp1 = __cil_tmp99;
#line 402
  __cil_tmp101 = _mm_srai_epi32(tmp3_2, 9);
#line 402
  tmp3 = __cil_tmp101;
#line 403
  __cil_tmp103 = _mm_packs_epi32(tmp0, tmp2);
#line 403
  s03 = __cil_tmp103;
#line 404
  __cil_tmp105 = _mm_packs_epi32(tmp1, tmp3);
#line 404
  s12 = __cil_tmp105;
#line 405
  __cil_tmp107 = _mm_unpackhi_epi8(s03, s12);
#line 405
  s_lo = __cil_tmp107;
#line 406
  __cil_tmp109 = _mm_unpackhi_epi8(s03, s12);
#line 406
  s_hi = __cil_tmp109;
#line 407
  __cil_tmp111 = _mm_unpackhi_epi8(s_lo, s_hi);
#line 407
  v23 = __cil_tmp111;
#line 408
  v01 = _mm_unpackhi_epi8(s_lo, s_hi);
#line 409
  v32 = _mm_shufflehi_epi16(v23, ((1 << 6) | (3 << 2)) | 2);
#line 419
  __cil_tmp115 = _mm_add_epi16(v01, v32);
#line 419
  a01___0 = __cil_tmp115;
#line 420
  __cil_tmp117 = _mm_sub_epi16(v01, v32);
#line 420
  a32___0 = __cil_tmp117;
#line 421
  __cil_tmp119 = _mm_unpackhi_epi8(a01___0, a01___0);
#line 421
  a11 = __cil_tmp119;
#line 422
  __cil_tmp121 = _mm_unpackhi_epi8(a32___0, a32___0);
#line 422
  a22 = __cil_tmp121;
#line 423
  __cil_tmp123 = _mm_add_epi16(a01___0, seven);
#line 423
  a01_plus_7 = __cil_tmp123;
#line 427
  __cil_tmp125 = _mm_add_epi16(a01_plus_7, a11);
#line 427
  c0 = __cil_tmp125;
#line 428
  __cil_tmp127 = _mm_sub_epi16(a01_plus_7, a11);
#line 428
  c2 = __cil_tmp127;
#line 429
  __cil_tmp129 = _mm_srai_epi16(c0, 4);
#line 429
  d0 = __cil_tmp129;
#line 430
  __cil_tmp131 = _mm_srai_epi16(c2, 4);
#line 430
  d2 = __cil_tmp131;
#line 434
  __cil_tmp133 = _mm_unpackhi_epi8(a22, a32___0);
#line 434
  b23 = __cil_tmp133;
#line 435
  __cil_tmp135 = _mm_madd_epi16(b23, k5352_2217);
#line 435
  c1 = __cil_tmp135;
#line 436
  __cil_tmp137 = _mm_madd_epi16(b23, k2217_5352);
#line 436
  c3 = __cil_tmp137;
#line 437
  __cil_tmp139 = _mm_add_epi32(c1, k12000_plus_one);
#line 437
  d1 = __cil_tmp139;
#line 438
  __cil_tmp141 = _mm_add_epi32(c3, k51000);
#line 438
  d3 = __cil_tmp141;
#line 439
  __cil_tmp143 = _mm_srai_epi32(d1, 16);
#line 439
  e1 = __cil_tmp143;
#line 440
  __cil_tmp145 = _mm_srai_epi32(d3, 16);
#line 440
  e3 = __cil_tmp145;
#line 441
  __cil_tmp147 = _mm_packs_epi32(e1, e1);
#line 441
  f1 = __cil_tmp147;
#line 442
  __cil_tmp149 = _mm_packs_epi32(e3, e3);
#line 442
  f3 = __cil_tmp149;
#line 447
  __cil_tmp151 = _mm_cmpeq_epi16(a32___0, zero);
#line 447
  __cil_tmp152 = _mm_add_epi16(f1, __cil_tmp151);
#line 447
  g1 = __cil_tmp152;
#line 449
  _mm_storel_epi64((__m128i *)(out + 0), d0);
#line 450
  _mm_storel_epi64((__m128i *)(out + 4), g1);
#line 451
  _mm_storel_epi64((__m128i *)(out + 8), d2);
#line 452
  _mm_storel_epi64((__m128i *)(out + 12), f3);
  }
#line 454
  return;
}
}
#line 459 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static int SSE_Nx4SSE2(uint8_t *a , uint8_t *b , int num_quads , int do_16 ) 
{ 
  __m128i zero ;
  __m128i __cil_tmp6 ;
  __m128i sum1 ;
  __m128i sum2 ;
  int __cil_tmp9 ;
  __m128i a0 ;
  __m128i __cil_tmp11 ;
  __m128i a1 ;
  __m128i __cil_tmp13 ;
  __m128i a2 ;
  __m128i __cil_tmp15 ;
  __m128i a3 ;
  __m128i __cil_tmp17 ;
  __m128i b0 ;
  __m128i __cil_tmp19 ;
  __m128i b1 ;
  __m128i __cil_tmp21 ;
  __m128i b2 ;
  __m128i __cil_tmp23 ;
  __m128i b3 ;
  __m128i __cil_tmp25 ;
  __m128i a0p ;
  __m128i __cil_tmp27 ;
  __m128i a0m ;
  __m128i __cil_tmp29 ;
  __m128i a1p ;
  __m128i __cil_tmp31 ;
  __m128i a1m ;
  __m128i __cil_tmp33 ;
  __m128i a2p ;
  __m128i __cil_tmp35 ;
  __m128i a2m ;
  __m128i __cil_tmp37 ;
  __m128i a3p ;
  __m128i __cil_tmp39 ;
  __m128i a3m ;
  __m128i __cil_tmp41 ;
  __m128i diff0 ;
  __m128i __cil_tmp43 ;
  __m128i diff1 ;
  __m128i __cil_tmp45 ;
  __m128i diff2 ;
  __m128i __cil_tmp47 ;
  __m128i diff3 ;
  __m128i __cil_tmp49 ;
  __m128i low0 ;
  __m128i __cil_tmp51 ;
  __m128i low1 ;
  __m128i __cil_tmp53 ;
  __m128i low2 ;
  __m128i __cil_tmp55 ;
  __m128i low3 ;
  __m128i __cil_tmp57 ;
  __m128i low_madd0 ;
  __m128i __cil_tmp59 ;
  __m128i low_madd1 ;
  __m128i __cil_tmp61 ;
  __m128i low_madd2 ;
  __m128i __cil_tmp63 ;
  __m128i low_madd3 ;
  __m128i __cil_tmp65 ;
  __m128i low_sum0 ;
  __m128i __cil_tmp67 ;
  __m128i low_sum1 ;
  __m128i __cil_tmp69 ;
  __m128i hi0 ;
  __m128i __cil_tmp73 ;
  __m128i hi1 ;
  __m128i __cil_tmp75 ;
  __m128i hi2 ;
  __m128i __cil_tmp77 ;
  __m128i hi3 ;
  __m128i __cil_tmp79 ;
  __m128i hi_madd0 ;
  __m128i __cil_tmp81 ;
  __m128i hi_madd1 ;
  __m128i __cil_tmp83 ;
  __m128i hi_madd2 ;
  __m128i __cil_tmp85 ;
  __m128i hi_madd3 ;
  __m128i __cil_tmp87 ;
  __m128i hi_sum0 ;
  __m128i __cil_tmp89 ;
  __m128i hi_sum1 ;
  __m128i __cil_tmp91 ;
  int32_t tmp___0[4] ;
  __m128i sum ;
  __m128i __cil_tmp96 ;

  {
  {
#line 461
  __cil_tmp6 = _mm_setzero_si128();
#line 461
  zero = __cil_tmp6;
#line 462
  sum1 = zero;
#line 463
  sum2 = zero;
  }
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    __cil_tmp9 = num_quads;
#line 465
    num_quads --;
#line 465
    if (! (__cil_tmp9 > 0)) {
#line 465
      goto while_break;
    }
    {
#line 468
    __cil_tmp11 = _mm_loadu_si128((__m128i *)(a + 0));
#line 468
    a0 = __cil_tmp11;
#line 469
    __cil_tmp13 = _mm_loadu_si128((__m128i *)(a + 16));
#line 469
    a1 = __cil_tmp13;
#line 470
    __cil_tmp15 = _mm_loadu_si128((__m128i *)(a + 32));
#line 470
    a2 = __cil_tmp15;
#line 471
    __cil_tmp17 = _mm_loadu_si128((__m128i *)(a + 48));
#line 471
    a3 = __cil_tmp17;
#line 472
    __cil_tmp19 = _mm_loadu_si128((__m128i *)(b + 0));
#line 472
    b0 = __cil_tmp19;
#line 473
    __cil_tmp21 = _mm_loadu_si128((__m128i *)(b + 16));
#line 473
    b1 = __cil_tmp21;
#line 474
    __cil_tmp23 = _mm_loadu_si128((__m128i *)(b + 32));
#line 474
    b2 = __cil_tmp23;
#line 475
    __cil_tmp25 = _mm_loadu_si128((__m128i *)(b + 48));
#line 475
    b3 = __cil_tmp25;
#line 478
    __cil_tmp27 = _mm_subs_epu8(a0, b0);
#line 478
    a0p = __cil_tmp27;
#line 479
    __cil_tmp29 = _mm_subs_epu8(b0, a0);
#line 479
    a0m = __cil_tmp29;
#line 480
    __cil_tmp31 = _mm_subs_epu8(a1, b1);
#line 480
    a1p = __cil_tmp31;
#line 481
    __cil_tmp33 = _mm_subs_epu8(b1, a1);
#line 481
    a1m = __cil_tmp33;
#line 482
    __cil_tmp35 = _mm_subs_epu8(a2, b2);
#line 482
    a2p = __cil_tmp35;
#line 483
    __cil_tmp37 = _mm_subs_epu8(b2, a2);
#line 483
    a2m = __cil_tmp37;
#line 484
    __cil_tmp39 = _mm_subs_epu8(a3, b3);
#line 484
    a3p = __cil_tmp39;
#line 485
    __cil_tmp41 = _mm_subs_epu8(b3, a3);
#line 485
    a3m = __cil_tmp41;
#line 488
    __cil_tmp43 = _mm_or_si128(a0p, a0m);
#line 488
    diff0 = __cil_tmp43;
#line 489
    __cil_tmp45 = _mm_or_si128(a1p, a1m);
#line 489
    diff1 = __cil_tmp45;
#line 490
    __cil_tmp47 = _mm_or_si128(a2p, a2m);
#line 490
    diff2 = __cil_tmp47;
#line 491
    __cil_tmp49 = _mm_or_si128(a3p, a3m);
#line 491
    diff3 = __cil_tmp49;
#line 494
    __cil_tmp51 = _mm_unpackhi_epi8(diff0, zero);
#line 494
    low0 = __cil_tmp51;
#line 495
    __cil_tmp53 = _mm_unpackhi_epi8(diff1, zero);
#line 495
    low1 = __cil_tmp53;
#line 496
    __cil_tmp55 = _mm_unpackhi_epi8(diff2, zero);
#line 496
    low2 = __cil_tmp55;
#line 497
    __cil_tmp57 = _mm_unpackhi_epi8(diff3, zero);
#line 497
    low3 = __cil_tmp57;
#line 500
    __cil_tmp59 = _mm_madd_epi16(low0, low0);
#line 500
    low_madd0 = __cil_tmp59;
#line 501
    __cil_tmp61 = _mm_madd_epi16(low1, low1);
#line 501
    low_madd1 = __cil_tmp61;
#line 502
    __cil_tmp63 = _mm_madd_epi16(low2, low2);
#line 502
    low_madd2 = __cil_tmp63;
#line 503
    __cil_tmp65 = _mm_madd_epi16(low3, low3);
#line 503
    low_madd3 = __cil_tmp65;
#line 506
    __cil_tmp67 = _mm_add_epi32(low_madd0, low_madd1);
#line 506
    low_sum0 = __cil_tmp67;
#line 507
    __cil_tmp69 = _mm_add_epi32(low_madd2, low_madd3);
#line 507
    low_sum1 = __cil_tmp69;
#line 508
    sum1 = _mm_add_epi32(sum1, low_sum0);
#line 509
    sum2 = _mm_add_epi32(sum2, low_sum1);
    }
#line 511
    if (do_16) {
      {
#line 512
      __cil_tmp73 = _mm_unpackhi_epi8(diff0, zero);
#line 512
      hi0 = __cil_tmp73;
#line 513
      __cil_tmp75 = _mm_unpackhi_epi8(diff1, zero);
#line 513
      hi1 = __cil_tmp75;
#line 514
      __cil_tmp77 = _mm_unpackhi_epi8(diff2, zero);
#line 514
      hi2 = __cil_tmp77;
#line 515
      __cil_tmp79 = _mm_unpackhi_epi8(diff3, zero);
#line 515
      hi3 = __cil_tmp79;
#line 517
      __cil_tmp81 = _mm_madd_epi16(hi0, hi0);
#line 517
      hi_madd0 = __cil_tmp81;
#line 518
      __cil_tmp83 = _mm_madd_epi16(hi1, hi1);
#line 518
      hi_madd1 = __cil_tmp83;
#line 519
      __cil_tmp85 = _mm_madd_epi16(hi2, hi2);
#line 519
      hi_madd2 = __cil_tmp85;
#line 520
      __cil_tmp87 = _mm_madd_epi16(hi3, hi3);
#line 520
      hi_madd3 = __cil_tmp87;
#line 521
      __cil_tmp89 = _mm_add_epi32(hi_madd0, hi_madd1);
#line 521
      hi_sum0 = __cil_tmp89;
#line 522
      __cil_tmp91 = _mm_add_epi32(hi_madd2, hi_madd3);
#line 522
      hi_sum1 = __cil_tmp91;
#line 523
      sum1 = _mm_add_epi32(sum1, hi_sum0);
#line 524
      sum2 = _mm_add_epi32(sum2, hi_sum1);
      }
    }
#line 526
    a += 64;
#line 527
    b += 64;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 531
  __cil_tmp96 = _mm_add_epi32(sum1, sum2);
#line 531
  sum = __cil_tmp96;
#line 532
  _mm_storeu_si128(tmp___0, sum);
  }
#line 533
  return (((tmp___0[3] + tmp___0[2]) + tmp___0[1]) + tmp___0[0]);
}
}
#line 537 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static int SSE16x16SSE2(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 538
  __cil_tmp3 = SSE_Nx4SSE2(a, b, 4, 1);
  }
#line 538
  return (__cil_tmp3);
}
}
#line 541 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static int SSE16x8SSE2(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 542
  __cil_tmp3 = SSE_Nx4SSE2(a, b, 2, 1);
  }
#line 542
  return (__cil_tmp3);
}
}
#line 545 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static int SSE8x8SSE2(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 546
  __cil_tmp3 = SSE_Nx4SSE2(a, b, 2, 0);
  }
#line 546
  return (__cil_tmp3);
}
}
#line 549 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static int SSE4x4SSE2(uint8_t *a , uint8_t *b ) 
{ 
  __m128i zero ;
  __m128i __cil_tmp4 ;
  __m128i a0 ;
  __m128i __cil_tmp6 ;
  __m128i a1 ;
  __m128i __cil_tmp8 ;
  __m128i a2 ;
  __m128i __cil_tmp10 ;
  __m128i a3 ;
  __m128i __cil_tmp12 ;
  __m128i b0 ;
  __m128i __cil_tmp14 ;
  __m128i b1 ;
  __m128i __cil_tmp16 ;
  __m128i b2 ;
  __m128i __cil_tmp18 ;
  __m128i b3 ;
  __m128i __cil_tmp20 ;
  __m128i a01 ;
  __m128i __cil_tmp22 ;
  __m128i a23 ;
  __m128i __cil_tmp24 ;
  __m128i b01 ;
  __m128i __cil_tmp26 ;
  __m128i b23 ;
  __m128i __cil_tmp28 ;
  __m128i a01s ;
  __m128i __cil_tmp30 ;
  __m128i a23s ;
  __m128i __cil_tmp32 ;
  __m128i b01s ;
  __m128i __cil_tmp34 ;
  __m128i b23s ;
  __m128i __cil_tmp36 ;
  __m128i d0 ;
  __m128i __cil_tmp38 ;
  __m128i d1 ;
  __m128i __cil_tmp40 ;
  __m128i d2 ;
  __m128i __cil_tmp42 ;
  __m128i d3 ;
  __m128i __cil_tmp44 ;
  __m128i madd0 ;
  __m128i __cil_tmp46 ;
  __m128i madd1 ;
  __m128i __cil_tmp48 ;
  __m128i madd2 ;
  __m128i __cil_tmp50 ;
  __m128i madd3 ;
  __m128i __cil_tmp52 ;
  __m128i sum0 ;
  __m128i __cil_tmp54 ;
  __m128i sum1 ;
  __m128i __cil_tmp56 ;
  __m128i sum2 ;
  __m128i __cil_tmp58 ;
  int32_t tmp___0[4] ;

  {
  {
#line 550
  __cil_tmp4 = _mm_setzero_si128();
#line 550
  zero = __cil_tmp4;
#line 554
  __cil_tmp6 = _mm_loadl_epi64((__m128i *)(a + 0));
#line 554
  a0 = __cil_tmp6;
#line 555
  __cil_tmp8 = _mm_loadl_epi64((__m128i *)(a + 16));
#line 555
  a1 = __cil_tmp8;
#line 556
  __cil_tmp10 = _mm_loadl_epi64((__m128i *)(a + 32));
#line 556
  a2 = __cil_tmp10;
#line 557
  __cil_tmp12 = _mm_loadl_epi64((__m128i *)(a + 48));
#line 557
  a3 = __cil_tmp12;
#line 558
  __cil_tmp14 = _mm_loadl_epi64((__m128i *)(b + 0));
#line 558
  b0 = __cil_tmp14;
#line 559
  __cil_tmp16 = _mm_loadl_epi64((__m128i *)(b + 16));
#line 559
  b1 = __cil_tmp16;
#line 560
  __cil_tmp18 = _mm_loadl_epi64((__m128i *)(b + 32));
#line 560
  b2 = __cil_tmp18;
#line 561
  __cil_tmp20 = _mm_loadl_epi64((__m128i *)(b + 48));
#line 561
  b3 = __cil_tmp20;
#line 564
  __cil_tmp22 = _mm_unpackhi_epi8(a0, a1);
#line 564
  a01 = __cil_tmp22;
#line 565
  __cil_tmp24 = _mm_unpackhi_epi8(a2, a3);
#line 565
  a23 = __cil_tmp24;
#line 566
  __cil_tmp26 = _mm_unpackhi_epi8(b0, b1);
#line 566
  b01 = __cil_tmp26;
#line 567
  __cil_tmp28 = _mm_unpackhi_epi8(b2, b3);
#line 567
  b23 = __cil_tmp28;
#line 568
  __cil_tmp30 = _mm_unpackhi_epi8(a01, zero);
#line 568
  a01s = __cil_tmp30;
#line 569
  __cil_tmp32 = _mm_unpackhi_epi8(a23, zero);
#line 569
  a23s = __cil_tmp32;
#line 570
  __cil_tmp34 = _mm_unpackhi_epi8(b01, zero);
#line 570
  b01s = __cil_tmp34;
#line 571
  __cil_tmp36 = _mm_unpackhi_epi8(b23, zero);
#line 571
  b23s = __cil_tmp36;
#line 578
  __cil_tmp38 = _mm_subs_epu8(a01s, b01s);
#line 578
  d0 = __cil_tmp38;
#line 579
  __cil_tmp40 = _mm_subs_epu8(b01s, a01s);
#line 579
  d1 = __cil_tmp40;
#line 580
  __cil_tmp42 = _mm_subs_epu8(a23s, b23s);
#line 580
  d2 = __cil_tmp42;
#line 581
  __cil_tmp44 = _mm_subs_epu8(b23s, a23s);
#line 581
  d3 = __cil_tmp44;
#line 584
  __cil_tmp46 = _mm_madd_epi16(d0, d0);
#line 584
  madd0 = __cil_tmp46;
#line 585
  __cil_tmp48 = _mm_madd_epi16(d1, d1);
#line 585
  madd1 = __cil_tmp48;
#line 586
  __cil_tmp50 = _mm_madd_epi16(d2, d2);
#line 586
  madd2 = __cil_tmp50;
#line 587
  __cil_tmp52 = _mm_madd_epi16(d3, d3);
#line 587
  madd3 = __cil_tmp52;
#line 588
  __cil_tmp54 = _mm_add_epi32(madd0, madd1);
#line 588
  sum0 = __cil_tmp54;
#line 589
  __cil_tmp56 = _mm_add_epi32(madd2, madd3);
#line 589
  sum1 = __cil_tmp56;
#line 590
  __cil_tmp58 = _mm_add_epi32(sum0, sum1);
#line 590
  sum2 = __cil_tmp58;
#line 593
  _mm_storeu_si128(tmp___0, sum2);
  }
#line 594
  return (((tmp___0[3] + tmp___0[2]) + tmp___0[1]) + tmp___0[0]);
}
}
#line 606 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static int TTransformSSE2(uint8_t *inA , uint8_t *inB , uint16_t *w ) 
{ 
  int32_t sum[4] ;
  __m128i tmp_0 ;
  __m128i tmp_1 ;
  __m128i tmp_2 ;
  __m128i tmp_3 ;
  __m128i zero ;
  __m128i __cil_tmp10 ;
  __m128i inA_0 ;
  __m128i __cil_tmp12 ;
  __m128i inA_1 ;
  __m128i __cil_tmp14 ;
  __m128i inA_2 ;
  __m128i __cil_tmp16 ;
  __m128i inA_3 ;
  __m128i __cil_tmp18 ;
  __m128i inB_0 ;
  __m128i __cil_tmp20 ;
  __m128i inB_1 ;
  __m128i __cil_tmp22 ;
  __m128i inB_2 ;
  __m128i __cil_tmp24 ;
  __m128i inB_3 ;
  __m128i __cil_tmp26 ;
  __m128i inAB_0 ;
  __m128i __cil_tmp28 ;
  __m128i inAB_1 ;
  __m128i __cil_tmp30 ;
  __m128i inAB_2 ;
  __m128i __cil_tmp32 ;
  __m128i inAB_3 ;
  __m128i __cil_tmp34 ;
  __m128i transpose0_0 ;
  __m128i __cil_tmp36 ;
  __m128i transpose0_1 ;
  __m128i __cil_tmp38 ;
  __m128i transpose1_0 ;
  __m128i __cil_tmp40 ;
  __m128i transpose1_1 ;
  __m128i __cil_tmp42 ;
  __m128i a0 ;
  __m128i __cil_tmp48 ;
  __m128i a1 ;
  __m128i __cil_tmp50 ;
  __m128i a2 ;
  __m128i __cil_tmp52 ;
  __m128i a3 ;
  __m128i __cil_tmp54 ;
  __m128i b0 ;
  __m128i __cil_tmp56 ;
  __m128i b1 ;
  __m128i __cil_tmp58 ;
  __m128i b2 ;
  __m128i __cil_tmp60 ;
  __m128i b3 ;
  __m128i __cil_tmp62 ;
  __m128i transpose0_0___0 ;
  __m128i __cil_tmp64 ;
  __m128i transpose0_1___0 ;
  __m128i __cil_tmp66 ;
  __m128i transpose0_2 ;
  __m128i __cil_tmp68 ;
  __m128i transpose0_3 ;
  __m128i __cil_tmp70 ;
  __m128i transpose1_0___0 ;
  __m128i __cil_tmp72 ;
  __m128i transpose1_1___0 ;
  __m128i __cil_tmp74 ;
  __m128i transpose1_2 ;
  __m128i __cil_tmp76 ;
  __m128i transpose1_3 ;
  __m128i __cil_tmp78 ;
  __m128i w_0 ;
  __m128i __cil_tmp84 ;
  __m128i w_8 ;
  __m128i __cil_tmp86 ;
  __m128i a0___0 ;
  __m128i __cil_tmp88 ;
  __m128i a1___0 ;
  __m128i __cil_tmp90 ;
  __m128i a2___0 ;
  __m128i __cil_tmp92 ;
  __m128i a3___0 ;
  __m128i __cil_tmp94 ;
  __m128i b0___0 ;
  __m128i __cil_tmp96 ;
  __m128i b1___0 ;
  __m128i __cil_tmp98 ;
  __m128i b2___0 ;
  __m128i __cil_tmp100 ;
  __m128i b3___0 ;
  __m128i __cil_tmp102 ;
  __m128i A_b0 ;
  __m128i __cil_tmp104 ;
  __m128i A_b2 ;
  __m128i __cil_tmp106 ;
  __m128i B_b0 ;
  __m128i __cil_tmp108 ;
  __m128i B_b2 ;
  __m128i __cil_tmp110 ;
  __m128i sign_A_b0 ;
  __m128i __cil_tmp112 ;
  __m128i sign_A_b2 ;
  __m128i __cil_tmp114 ;
  __m128i sign_B_b0 ;
  __m128i __cil_tmp116 ;
  __m128i sign_B_b2 ;
  __m128i __cil_tmp118 ;

  {
  {
#line 610
  __cil_tmp10 = _mm_setzero_si128();
#line 610
  zero = __cil_tmp10;
#line 614
  __cil_tmp12 = _mm_loadl_epi64((__m128i *)(inA + 0));
#line 614
  inA_0 = __cil_tmp12;
#line 615
  __cil_tmp14 = _mm_loadl_epi64((__m128i *)(inA + 16));
#line 615
  inA_1 = __cil_tmp14;
#line 616
  __cil_tmp16 = _mm_loadl_epi64((__m128i *)(inA + 32));
#line 616
  inA_2 = __cil_tmp16;
#line 617
  __cil_tmp18 = _mm_loadl_epi64((__m128i *)(inA + 48));
#line 617
  inA_3 = __cil_tmp18;
#line 618
  __cil_tmp20 = _mm_loadl_epi64((__m128i *)(inB + 0));
#line 618
  inB_0 = __cil_tmp20;
#line 619
  __cil_tmp22 = _mm_loadl_epi64((__m128i *)(inB + 16));
#line 619
  inB_1 = __cil_tmp22;
#line 620
  __cil_tmp24 = _mm_loadl_epi64((__m128i *)(inB + 32));
#line 620
  inB_2 = __cil_tmp24;
#line 621
  __cil_tmp26 = _mm_loadl_epi64((__m128i *)(inB + 48));
#line 621
  inB_3 = __cil_tmp26;
#line 624
  __cil_tmp28 = _mm_unpackhi_epi8(inA_0, inB_0);
#line 624
  inAB_0 = __cil_tmp28;
#line 625
  __cil_tmp30 = _mm_unpackhi_epi8(inA_1, inB_1);
#line 625
  inAB_1 = __cil_tmp30;
#line 626
  __cil_tmp32 = _mm_unpackhi_epi8(inA_2, inB_2);
#line 626
  inAB_2 = __cil_tmp32;
#line 627
  __cil_tmp34 = _mm_unpackhi_epi8(inA_3, inB_3);
#line 627
  inAB_3 = __cil_tmp34;
#line 634
  __cil_tmp36 = _mm_unpackhi_epi8(inAB_0, inAB_2);
#line 634
  transpose0_0 = __cil_tmp36;
#line 635
  __cil_tmp38 = _mm_unpackhi_epi8(inAB_1, inAB_3);
#line 635
  transpose0_1 = __cil_tmp38;
#line 638
  __cil_tmp40 = _mm_unpackhi_epi8(transpose0_0, transpose0_1);
#line 638
  transpose1_0 = __cil_tmp40;
#line 639
  __cil_tmp42 = _mm_unpackhi_epi8(transpose0_0, transpose0_1);
#line 639
  transpose1_1 = __cil_tmp42;
#line 644
  tmp_0 = _mm_unpackhi_epi8(transpose1_0, zero);
#line 645
  tmp_1 = _mm_unpackhi_epi8(transpose1_0, zero);
#line 646
  tmp_2 = _mm_unpackhi_epi8(transpose1_1, zero);
#line 647
  tmp_3 = _mm_unpackhi_epi8(transpose1_1, zero);
#line 657
  __cil_tmp48 = _mm_add_epi16(tmp_0, tmp_2);
#line 657
  a0 = __cil_tmp48;
#line 658
  __cil_tmp50 = _mm_add_epi16(tmp_1, tmp_3);
#line 658
  a1 = __cil_tmp50;
#line 659
  __cil_tmp52 = _mm_sub_epi16(tmp_1, tmp_3);
#line 659
  a2 = __cil_tmp52;
#line 660
  __cil_tmp54 = _mm_sub_epi16(tmp_0, tmp_2);
#line 660
  a3 = __cil_tmp54;
#line 661
  __cil_tmp56 = _mm_add_epi16(a0, a1);
#line 661
  b0 = __cil_tmp56;
#line 662
  __cil_tmp58 = _mm_add_epi16(a3, a2);
#line 662
  b1 = __cil_tmp58;
#line 663
  __cil_tmp60 = _mm_sub_epi16(a3, a2);
#line 663
  b2 = __cil_tmp60;
#line 664
  __cil_tmp62 = _mm_sub_epi16(a0, a1);
#line 664
  b3 = __cil_tmp62;
#line 671
  __cil_tmp64 = _mm_unpackhi_epi8(b0, b1);
#line 671
  transpose0_0___0 = __cil_tmp64;
#line 672
  __cil_tmp66 = _mm_unpackhi_epi8(b2, b3);
#line 672
  transpose0_1___0 = __cil_tmp66;
#line 673
  __cil_tmp68 = _mm_unpackhi_epi8(b0, b1);
#line 673
  transpose0_2 = __cil_tmp68;
#line 674
  __cil_tmp70 = _mm_unpackhi_epi8(b2, b3);
#line 674
  transpose0_3 = __cil_tmp70;
#line 679
  __cil_tmp72 = _mm_unpackhi_epi8(transpose0_0___0, transpose0_1___0);
#line 679
  transpose1_0___0 = __cil_tmp72;
#line 680
  __cil_tmp74 = _mm_unpackhi_epi8(transpose0_2, transpose0_3);
#line 680
  transpose1_1___0 = __cil_tmp74;
#line 681
  __cil_tmp76 = _mm_unpackhi_epi8(transpose0_0___0, transpose0_1___0);
#line 681
  transpose1_2 = __cil_tmp76;
#line 682
  __cil_tmp78 = _mm_unpackhi_epi8(transpose0_2, transpose0_3);
#line 682
  transpose1_3 = __cil_tmp78;
#line 687
  tmp_0 = _mm_unpackhi_epi8(transpose1_0___0, transpose1_1___0);
#line 688
  tmp_1 = _mm_unpackhi_epi8(transpose1_0___0, transpose1_1___0);
#line 689
  tmp_2 = _mm_unpackhi_epi8(transpose1_2, transpose1_3);
#line 690
  tmp_3 = _mm_unpackhi_epi8(transpose1_2, transpose1_3);
#line 702
  __cil_tmp84 = _mm_loadu_si128((__m128i *)(w + 0));
#line 702
  w_0 = __cil_tmp84;
#line 703
  __cil_tmp86 = _mm_loadu_si128((__m128i *)(w + 8));
#line 703
  w_8 = __cil_tmp86;
#line 706
  __cil_tmp88 = _mm_add_epi16(tmp_0, tmp_2);
#line 706
  a0___0 = __cil_tmp88;
#line 707
  __cil_tmp90 = _mm_add_epi16(tmp_1, tmp_3);
#line 707
  a1___0 = __cil_tmp90;
#line 708
  __cil_tmp92 = _mm_sub_epi16(tmp_1, tmp_3);
#line 708
  a2___0 = __cil_tmp92;
#line 709
  __cil_tmp94 = _mm_sub_epi16(tmp_0, tmp_2);
#line 709
  a3___0 = __cil_tmp94;
#line 710
  __cil_tmp96 = _mm_add_epi16(a0___0, a1___0);
#line 710
  b0___0 = __cil_tmp96;
#line 711
  __cil_tmp98 = _mm_add_epi16(a3___0, a2___0);
#line 711
  b1___0 = __cil_tmp98;
#line 712
  __cil_tmp100 = _mm_sub_epi16(a3___0, a2___0);
#line 712
  b2___0 = __cil_tmp100;
#line 713
  __cil_tmp102 = _mm_sub_epi16(a0___0, a1___0);
#line 713
  b3___0 = __cil_tmp102;
#line 716
  __cil_tmp104 = _mm_unpackhi_epi8(b0___0, b1___0);
#line 716
  A_b0 = __cil_tmp104;
#line 717
  __cil_tmp106 = _mm_unpackhi_epi8(b2___0, b3___0);
#line 717
  A_b2 = __cil_tmp106;
#line 718
  __cil_tmp108 = _mm_unpackhi_epi8(b0___0, b1___0);
#line 718
  B_b0 = __cil_tmp108;
#line 719
  __cil_tmp110 = _mm_unpackhi_epi8(b2___0, b3___0);
#line 719
  B_b2 = __cil_tmp110;
#line 723
  __cil_tmp112 = _mm_srai_epi16(A_b0, 15);
#line 723
  sign_A_b0 = __cil_tmp112;
#line 724
  __cil_tmp114 = _mm_srai_epi16(A_b2, 15);
#line 724
  sign_A_b2 = __cil_tmp114;
#line 725
  __cil_tmp116 = _mm_srai_epi16(B_b0, 15);
#line 725
  sign_B_b0 = __cil_tmp116;
#line 726
  __cil_tmp118 = _mm_srai_epi16(B_b2, 15);
#line 726
  sign_B_b2 = __cil_tmp118;
#line 729
  A_b0 = _mm_xor_si128(A_b0, sign_A_b0);
#line 730
  A_b2 = _mm_xor_si128(A_b2, sign_A_b2);
#line 731
  B_b0 = _mm_xor_si128(B_b0, sign_B_b0);
#line 732
  B_b2 = _mm_xor_si128(B_b2, sign_B_b2);
#line 733
  A_b0 = _mm_sub_epi16(A_b0, sign_A_b0);
#line 734
  A_b2 = _mm_sub_epi16(A_b2, sign_A_b2);
#line 735
  B_b0 = _mm_sub_epi16(B_b0, sign_B_b0);
#line 736
  B_b2 = _mm_sub_epi16(B_b2, sign_B_b2);
#line 740
  A_b0 = _mm_madd_epi16(A_b0, w_0);
#line 741
  A_b2 = _mm_madd_epi16(A_b2, w_8);
#line 742
  B_b0 = _mm_madd_epi16(B_b0, w_0);
#line 743
  B_b2 = _mm_madd_epi16(B_b2, w_8);
#line 744
  A_b0 = _mm_add_epi32(A_b0, A_b2);
#line 745
  B_b0 = _mm_add_epi32(B_b0, B_b2);
#line 748
  A_b0 = _mm_sub_epi32(A_b0, B_b0);
#line 749
  _mm_storeu_si128(& sum[0], A_b0);
  }
#line 751
  return (((sum[0] + sum[1]) + sum[2]) + sum[3]);
}
}
#line 754 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static int Disto4x4SSE2(uint8_t *a , uint8_t *b , uint16_t *w ) 
{ 
  int diff_sum ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 756
  __cil_tmp5 = TTransformSSE2(a, b, w);
#line 756
  diff_sum = __cil_tmp5;
#line 757
  __cil_tmp6 = abs(diff_sum);
  }
#line 757
  return (__cil_tmp6 >> 5);
}
}
#line 760 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static int Disto16x16SSE2(uint8_t *a , uint8_t *b , uint16_t *w ) 
{ 
  int D ;
  int x ;
  int y ;
  int __cil_tmp7 ;

  {
#line 762
  D = 0;
#line 764
  y = 0;
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;

#line 764
    if (! (y < 256)) {
#line 764
      goto while_break;
    }
#line 765
    x = 0;
    {
#line 765
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 765
      if (! (x < 16)) {
#line 765
        goto while_break___0;
      }
      {
#line 766
      __cil_tmp7 = Disto4x4SSE2((a + x) + y, (b + x) + y, w);
#line 766
      D += __cil_tmp7;
#line 765
      x += 4;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 764
    y += 64;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 769
  return (D);
}
}
#line 777 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
static int QuantizeBlockSSE2(int16_t *in , int16_t *out , int n , VP8Matrix *mtx ) 
{ 
  __m128i max_coeff_2047 ;
  __m128i __cil_tmp6 ;
  __m128i zero ;
  __m128i __cil_tmp8 ;
  __m128i coeff0 ;
  __m128i coeff8 ;
  __m128i out0 ;
  __m128i out8 ;
  __m128i packed_out ;
  __m128i in0 ;
  __m128i __cil_tmp15 ;
  __m128i in8 ;
  __m128i __cil_tmp17 ;
  __m128i sharpen0 ;
  __m128i __cil_tmp19 ;
  __m128i sharpen8 ;
  __m128i __cil_tmp21 ;
  __m128i iq0 ;
  __m128i __cil_tmp23 ;
  __m128i iq8 ;
  __m128i __cil_tmp25 ;
  __m128i bias0 ;
  __m128i __cil_tmp27 ;
  __m128i bias8 ;
  __m128i __cil_tmp29 ;
  __m128i q0 ;
  __m128i __cil_tmp31 ;
  __m128i q8 ;
  __m128i __cil_tmp33 ;
  __m128i zthresh0 ;
  __m128i __cil_tmp35 ;
  __m128i zthresh8 ;
  __m128i __cil_tmp37 ;
  __m128i sign0 ;
  __m128i __cil_tmp39 ;
  __m128i sign8 ;
  __m128i __cil_tmp41 ;
  __m128i coeff_iQ0H ;
  __m128i __cil_tmp49 ;
  __m128i coeff_iQ0L ;
  __m128i __cil_tmp51 ;
  __m128i coeff_iQ8H ;
  __m128i __cil_tmp53 ;
  __m128i coeff_iQ8L ;
  __m128i __cil_tmp55 ;
  __m128i out_00 ;
  __m128i __cil_tmp57 ;
  __m128i out_04 ;
  __m128i __cil_tmp59 ;
  __m128i out_08 ;
  __m128i __cil_tmp61 ;
  __m128i out_12 ;
  __m128i __cil_tmp63 ;
  __m128i bias_00 ;
  __m128i __cil_tmp65 ;
  __m128i bias_04 ;
  __m128i __cil_tmp67 ;
  __m128i bias_08 ;
  __m128i __cil_tmp69 ;
  __m128i bias_12 ;
  __m128i __cil_tmp71 ;
  __m128i cmp0 ;
  __m128i __cil_tmp91 ;
  __m128i cmp8 ;
  __m128i __cil_tmp93 ;
  __m128i outZ0 ;
  __m128i outZ8 ;
  int16_t outZ_12 ;
  int16_t outZ_3 ;
  int32_t tmp___0[4] ;
  int tmp___1 ;

  {
  {
#line 779
  __cil_tmp6 = _mm_set1_epi16((short)2047);
#line 779
  max_coeff_2047 = __cil_tmp6;
#line 780
  __cil_tmp8 = _mm_setzero_si128();
#line 780
  zero = __cil_tmp8;
#line 788
  __cil_tmp15 = _mm_loadu_si128((__m128i *)(in + 0));
#line 788
  in0 = __cil_tmp15;
#line 789
  __cil_tmp17 = _mm_loadu_si128((__m128i *)(in + 8));
#line 789
  in8 = __cil_tmp17;
#line 790
  __cil_tmp19 = _mm_loadu_si128((__m128i *)(& mtx->sharpen_[0]));
#line 790
  sharpen0 = __cil_tmp19;
#line 791
  __cil_tmp21 = _mm_loadu_si128((__m128i *)(& mtx->sharpen_[8]));
#line 791
  sharpen8 = __cil_tmp21;
#line 792
  __cil_tmp23 = _mm_loadu_si128((__m128i *)(& mtx->iq_[0]));
#line 792
  iq0 = __cil_tmp23;
#line 793
  __cil_tmp25 = _mm_loadu_si128((__m128i *)(& mtx->iq_[8]));
#line 793
  iq8 = __cil_tmp25;
#line 794
  __cil_tmp27 = _mm_loadu_si128((__m128i *)(& mtx->bias_[0]));
#line 794
  bias0 = __cil_tmp27;
#line 795
  __cil_tmp29 = _mm_loadu_si128((__m128i *)(& mtx->bias_[8]));
#line 795
  bias8 = __cil_tmp29;
#line 796
  __cil_tmp31 = _mm_loadu_si128((__m128i *)(& mtx->q_[0]));
#line 796
  q0 = __cil_tmp31;
#line 797
  __cil_tmp33 = _mm_loadu_si128((__m128i *)(& mtx->q_[8]));
#line 797
  q8 = __cil_tmp33;
#line 798
  __cil_tmp35 = _mm_loadu_si128((__m128i *)(& mtx->zthresh_[0]));
#line 798
  zthresh0 = __cil_tmp35;
#line 799
  __cil_tmp37 = _mm_loadu_si128((__m128i *)(& mtx->zthresh_[8]));
#line 799
  zthresh8 = __cil_tmp37;
#line 802
  __cil_tmp39 = _mm_srai_epi16(in0, 15);
#line 802
  sign0 = __cil_tmp39;
#line 803
  __cil_tmp41 = _mm_srai_epi16(in8, 15);
#line 803
  sign8 = __cil_tmp41;
#line 806
  coeff0 = _mm_xor_si128(in0, sign0);
#line 807
  coeff8 = _mm_xor_si128(in8, sign8);
#line 808
  coeff0 = _mm_sub_epi16(coeff0, sign0);
#line 809
  coeff8 = _mm_sub_epi16(coeff8, sign8);
#line 812
  coeff0 = _mm_add_epi16(coeff0, sharpen0);
#line 813
  coeff8 = _mm_add_epi16(coeff8, sharpen8);
#line 819
  __cil_tmp49 = _mm_mulhi_epu16(coeff0, iq0);
#line 819
  coeff_iQ0H = __cil_tmp49;
#line 820
  __cil_tmp51 = _mm_mullo_epi16(coeff0, iq0);
#line 820
  coeff_iQ0L = __cil_tmp51;
#line 821
  __cil_tmp53 = _mm_mulhi_epu16(coeff8, iq8);
#line 821
  coeff_iQ8H = __cil_tmp53;
#line 822
  __cil_tmp55 = _mm_mullo_epi16(coeff8, iq8);
#line 822
  coeff_iQ8L = __cil_tmp55;
#line 823
  __cil_tmp57 = _mm_unpackhi_epi8(coeff_iQ0L, coeff_iQ0H);
#line 823
  out_00 = __cil_tmp57;
#line 824
  __cil_tmp59 = _mm_unpackhi_epi8(coeff_iQ0L, coeff_iQ0H);
#line 824
  out_04 = __cil_tmp59;
#line 825
  __cil_tmp61 = _mm_unpackhi_epi8(coeff_iQ8L, coeff_iQ8H);
#line 825
  out_08 = __cil_tmp61;
#line 826
  __cil_tmp63 = _mm_unpackhi_epi8(coeff_iQ8L, coeff_iQ8H);
#line 826
  out_12 = __cil_tmp63;
#line 828
  __cil_tmp65 = _mm_unpackhi_epi8(bias0, zero);
#line 828
  bias_00 = __cil_tmp65;
#line 829
  __cil_tmp67 = _mm_unpackhi_epi8(bias0, zero);
#line 829
  bias_04 = __cil_tmp67;
#line 830
  __cil_tmp69 = _mm_unpackhi_epi8(bias8, zero);
#line 830
  bias_08 = __cil_tmp69;
#line 831
  __cil_tmp71 = _mm_unpackhi_epi8(bias8, zero);
#line 831
  bias_12 = __cil_tmp71;
#line 833
  out_00 = _mm_add_epi32(out_00, bias_00);
#line 834
  out_04 = _mm_add_epi32(out_04, bias_04);
#line 835
  out_08 = _mm_add_epi32(out_08, bias_08);
#line 836
  out_12 = _mm_add_epi32(out_12, bias_12);
#line 838
  out_00 = _mm_srai_epi32(out_00, 17);
#line 839
  out_04 = _mm_srai_epi32(out_04, 17);
#line 840
  out_08 = _mm_srai_epi32(out_08, 17);
#line 841
  out_12 = _mm_srai_epi32(out_12, 17);
#line 844
  out0 = _mm_packs_epi32(out_00, out_04);
#line 845
  out8 = _mm_packs_epi32(out_08, out_12);
#line 848
  out0 = _mm_min_epi16(out0, max_coeff_2047);
#line 849
  out8 = _mm_min_epi16(out8, max_coeff_2047);
#line 853
  out0 = _mm_xor_si128(out0, sign0);
#line 854
  out8 = _mm_xor_si128(out8, sign8);
#line 855
  out0 = _mm_sub_epi16(out0, sign0);
#line 856
  out8 = _mm_sub_epi16(out8, sign8);
#line 859
  in0 = _mm_mullo_epi16(out0, q0);
#line 860
  in8 = _mm_mullo_epi16(out8, q8);
#line 864
  __cil_tmp91 = _mm_cmpgt_epi16(coeff0, zthresh0);
#line 864
  cmp0 = __cil_tmp91;
#line 865
  __cil_tmp93 = _mm_cmpgt_epi16(coeff8, zthresh8);
#line 865
  cmp8 = __cil_tmp93;
#line 866
  in0 = _mm_and_si128(in0, cmp0);
#line 867
  in8 = _mm_and_si128(in8, cmp8);
#line 868
  _mm_storeu_si128((__m128i *)(in + 0), in0);
#line 869
  _mm_storeu_si128((__m128i *)(in + 8), in8);
#line 870
  out0 = _mm_and_si128(out0, cmp0);
#line 871
  out8 = _mm_and_si128(out8, cmp8);
#line 881
  outZ0 = _mm_shufflehi_epi16(out0, ((2 << 6) | (1 << 4)) | (3 << 2));
#line 882
  outZ0 = _mm_shufflehi_epi16(outZ0, ((3 << 6) | (1 << 4)) | (2 << 2));
#line 883
  outZ0 = _mm_shufflehi_epi16(outZ0, ((3 << 6) | (1 << 4)) | 2);
#line 884
  outZ8 = _mm_shufflehi_epi16(out8, ((3 << 6) | (2 << 2)) | 1);
#line 885
  outZ8 = _mm_shufflehi_epi16(outZ8, ((3 << 6) | (1 << 4)) | (2 << 2));
#line 886
  outZ8 = _mm_shufflehi_epi16(outZ8, ((1 << 6) | (3 << 4)) | (2 << 2));
#line 887
  _mm_storeu_si128((__m128i *)(out + 0), outZ0);
#line 888
  _mm_storeu_si128((__m128i *)(out + 8), outZ8);
#line 889
  packed_out = _mm_packs_epi16(outZ0, outZ8);
#line 892
  outZ_12 = *(out + 12);
#line 893
  outZ_3 = *(out + 3);
#line 894
  *(out + 3) = outZ_12;
#line 895
  *(out + 12) = outZ_3;
#line 901
  _mm_storeu_si128(tmp___0, packed_out);
  }
#line 902
  if (n) {
#line 903
    tmp___0[0] &= -256;
  }
#line 905
  if (tmp___0[3]) {
#line 905
    tmp___1 = 1;
  } else
#line 905
  if (tmp___0[2]) {
#line 905
    tmp___1 = 1;
  } else
#line 905
  if (tmp___0[1]) {
#line 905
    tmp___1 = 1;
  } else
#line 905
  if (tmp___0[0]) {
#line 905
    tmp___1 = 1;
  } else {
#line 905
    tmp___1 = 0;
  }
#line 905
  return (tmp___1);
}
}
#line 914
void VP8EncDspInitSSE2(void) ;
#line 916 "/root/patchweave_new/13/src/dsp/enc_sse2.c"
void VP8EncDspInitSSE2(void) 
{ 


  {
#line 918
  VP8CollectHistogram = (void (*)(uint8_t * , uint8_t * , int  , int  , struct VP8Histogram * const   ))(& CollectHistogramSSE2);
#line 919
  VP8EncQuantizeBlock = (int (*)(int16_t * , int16_t * , int  , struct VP8Matrix * const   ))(& QuantizeBlockSSE2);
#line 920
  VP8ITransform = & ITransformSSE2;
#line 921
  VP8FTransform = & FTransformSSE2;
#line 922
  VP8SSE16x16 = & SSE16x16SSE2;
#line 923
  VP8SSE16x8 = & SSE16x8SSE2;
#line 924
  VP8SSE8x8 = & SSE8x8SSE2;
#line 925
  VP8SSE4x4 = & SSE4x4SSE2;
#line 926
  VP8TDisto4x4 = (int (*)(uint8_t * , uint8_t * , uint16_t * const   ))(& Disto4x4SSE2);
#line 927
  VP8TDisto16x16 = (int (*)(uint8_t * , uint8_t * , uint16_t * const   ))(& Disto16x16SSE2);
#line 928
  return;
}
}
#line 644 "/root/patchweave_new/13/src/dsp/enc_neon.c"
void VP8EncDspInitNEON(void) ;
#line 646 "/root/patchweave_new/13/src/dsp/enc_neon.c"
void VP8EncDspInitNEON(void) 
{ 


  {
#line 651
  return;
}
}
#line 20 "/root/patchweave_new/13/src/dsp/enc.c"
__inline static uint8_t clip_8b(int v ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 21
  if (! (v & -256)) {
#line 21
    tmp___1 = v;
  } else {
#line 21
    if (v < 0) {
#line 21
      tmp___0 = 0;
    } else {
#line 21
      tmp___0 = 255;
    }
#line 21
    tmp___1 = tmp___0;
  }
#line 21
  return ((uint8_t )tmp___1);
}
}
#line 24 "/root/patchweave_new/13/src/dsp/enc.c"
__inline static int clip_max(int v , int max ) 
{ 
  int tmp___0 ;

  {
#line 25
  if (v > max) {
#line 25
    tmp___0 = max;
  } else {
#line 25
    tmp___0 = v;
  }
#line 25
  return (tmp___0);
}
}
#line 32 "/root/patchweave_new/13/src/dsp/enc.c"
int const   VP8DspScan[24]  = 
#line 32
  {      (int const   )0,      (int const   )4,      (int const   )8,      (int const   )12, 
        (int const   )64,      (int const   )68,      (int const   )72,      (int const   )76, 
        (int const   )128,      (int const   )132,      (int const   )136,      (int const   )140, 
        (int const   )192,      (int const   )196,      (int const   )200,      (int const   )204, 
        (int const   )0,      (int const   )4,      (int const   )64,      (int const   )68, 
        (int const   )8,      (int const   )12,      (int const   )72,      (int const   )76};
#line 43 "/root/patchweave_new/13/src/dsp/enc.c"
static void CollectHistogram(uint8_t *ref , uint8_t *pred , int start_block , int end_block ,
                             VP8Histogram *histo ) 
{ 
  int j ;
  int k ;
  int16_t out[16] ;
  int v ;
  int __cil_tmp10 ;
  int clipped_value ;
  int __cil_tmp12 ;

  {
#line 47
  j = start_block;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;

#line 47
    if (! (j < end_block)) {
#line 47
      goto while_break;
    }
    {
#line 51
    (*VP8FTransform)(ref + VP8DspScan[j], pred + VP8DspScan[j], out);
#line 54
    k = 0;
    }
    {
#line 54
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 54
      if (! (k < 16)) {
#line 54
        goto while_break___0;
      }
      {
#line 55
      __cil_tmp10 = abs((int )out[k]);
#line 55
      v = __cil_tmp10 >> 3;
#line 56
      __cil_tmp12 = clip_max(v, 31);
#line 56
      clipped_value = __cil_tmp12;
#line 57
      (histo->distribution[clipped_value]) ++;
#line 54
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 47
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 51
  return;
}
}
#line 65 "/root/patchweave_new/13/src/dsp/enc.c"
static uint8_t clip1___0[766]  ;
#line 69 "/root/patchweave_new/13/src/dsp/enc.c"
static int tables_ok___0  =    0;
#line 71 "/root/patchweave_new/13/src/dsp/enc.c"
static void InitTables___0(void) 
{ 
  int i ;

  {
#line 72
  if (! tables_ok___0) {
#line 74
    i = -255;
    {
#line 74
    while (1) {
      while_continue: /* CIL Label */ ;

#line 74
      if (! (i <= 510)) {
#line 74
        goto while_break;
      }
      {
#line 75
      clip1___0[255 + i] = clip_8b(i);
#line 74
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 77
    tables_ok___0 = 1;
  }
#line 79
  return;
}
}
#line 88 "/root/patchweave_new/13/src/dsp/enc.c"
static int const   kC1  =    (int const   )(20091 + (1 << 16));
#line 89 "/root/patchweave_new/13/src/dsp/enc.c"
static int const   kC2  =    (int const   )35468;
#line 92 "/root/patchweave_new/13/src/dsp/enc.c"
__inline static void ITransformOne(uint8_t *ref , int16_t *in , uint8_t *dst ) 
{ 
  int C[16] ;
  int *tmp___0 ;
  int i ;
  int a ;
  int b ;
  int c ;
  int d ;
  int dc ;
  int a___0 ;
  int b___0 ;
  int c___0 ;
  int d___0 ;

  {
#line 96
  tmp___0 = C;
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;

#line 97
    if (! (i < 4)) {
#line 97
      goto while_break;
    }
#line 98
    a = (int )*(in + 0) + (int )*(in + 8);
#line 99
    b = (int )*(in + 0) - (int )*(in + 8);
#line 100
    c = ((int )*(in + 4) * (int )kC2 >> 16) - ((int )*(in + 12) * (int )kC1 >> 16);
#line 101
    d = ((int )*(in + 4) * (int )kC1 >> 16) + ((int )*(in + 12) * (int )kC2 >> 16);
#line 102
    *(tmp___0 + 0) = a + d;
#line 103
    *(tmp___0 + 1) = b + c;
#line 104
    *(tmp___0 + 2) = b - c;
#line 105
    *(tmp___0 + 3) = a - d;
#line 106
    tmp___0 += 4;
#line 107
    in ++;
#line 97
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 110
  tmp___0 = C;
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 111
    if (! (i < 4)) {
#line 111
      goto while_break___0;
    }
    {
#line 112
    dc = *(tmp___0 + 0) + 4;
#line 113
    a___0 = dc + *(tmp___0 + 8);
#line 114
    b___0 = dc - *(tmp___0 + 8);
#line 115
    c___0 = (*(tmp___0 + 4) * (int )kC2 >> 16) - (*(tmp___0 + 12) * (int )kC1 >> 16);
#line 116
    d___0 = (*(tmp___0 + 4) * (int )kC1 >> 16) + (*(tmp___0 + 12) * (int )kC2 >> 16);
#line 117
    *(dst + i * 16) = clip_8b((int )*(ref + i * 16) + ((a___0 + d___0) >> 3));
#line 118
    *(dst + (1 + i * 16)) = clip_8b((int )*(ref + (1 + i * 16)) + ((b___0 + c___0) >> 3));
#line 119
    *(dst + (2 + i * 16)) = clip_8b((int )*(ref + (2 + i * 16)) + ((b___0 - c___0) >> 3));
#line 120
    *(dst + (3 + i * 16)) = clip_8b((int )*(ref + (3 + i * 16)) + ((a___0 - d___0) >> 3));
#line 121
    tmp___0 ++;
#line 111
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 115
  return;
}
}
#line 125 "/root/patchweave_new/13/src/dsp/enc.c"
static void ITransform(uint8_t *ref , int16_t *in , uint8_t *dst , int do_two ) 
{ 


  {
  {
#line 127
  ITransformOne(ref, in, dst);
  }
#line 128
  if (do_two) {
    {
#line 129
    ITransformOne(ref + 4, in + 16, dst + 4);
    }
  }
#line 132
  return;
}
}
#line 133 "/root/patchweave_new/13/src/dsp/enc.c"
static void FTransform(uint8_t *src , uint8_t *ref , int16_t *out ) 
{ 
  int i ;
  int tmp___0[16] ;
  int d0 ;
  int d1 ;
  int d2 ;
  int d3 ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;

  {
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;

#line 136
    if (! (i < 4)) {
#line 136
      goto while_break;
    }
#line 137
    d0 = (int )*(src + 0) - (int )*(ref + 0);
#line 138
    d1 = (int )*(src + 1) - (int )*(ref + 1);
#line 139
    d2 = (int )*(src + 2) - (int )*(ref + 2);
#line 140
    d3 = (int )*(src + 3) - (int )*(ref + 3);
#line 141
    a0 = d0 + d3;
#line 142
    a1 = d1 + d2;
#line 143
    a2 = d1 - d2;
#line 144
    a3 = d0 - d3;
#line 145
    tmp___0[i * 4] = (a0 + a1) << 3;
#line 146
    tmp___0[1 + i * 4] = ((a2 * 2217 + a3 * 5352) + 1812) >> 9;
#line 147
    tmp___0[2 + i * 4] = (a0 - a1) << 3;
#line 148
    tmp___0[3 + i * 4] = ((a3 * 2217 - a2 * 5352) + 937) >> 9;
#line 136
    ref += 16;
#line 136
    src += 16;
#line 136
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 150
    if (! (i < 4)) {
#line 150
      goto while_break___0;
    }
#line 151
    a0___0 = tmp___0[i] + tmp___0[12 + i];
#line 152
    a1___0 = tmp___0[4 + i] + tmp___0[8 + i];
#line 153
    a2___0 = tmp___0[4 + i] - tmp___0[8 + i];
#line 154
    a3___0 = tmp___0[i] - tmp___0[12 + i];
#line 155
    *(out + i) = (int16_t )(((a0___0 + a1___0) + 7) >> 4);
#line 156
    *(out + (4 + i)) = (int16_t )((((a2___0 * 2217 + a3___0 * 5352) + 12000) >> 16) + (a3___0 != 0));
#line 157
    *(out + (8 + i)) = (int16_t )(((a0___0 - a1___0) + 7) >> 4);
#line 158
    *(out + (12 + i)) = (int16_t )(((a3___0 * 2217 - a2___0 * 5352) + 51000) >> 16);
#line 150
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 154
  return;
}
}
#line 162 "/root/patchweave_new/13/src/dsp/enc.c"
static void ITransformWHT(int16_t *in , int16_t *out ) 
{ 
  int tmp___0[16] ;
  int i ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int dc ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;

  {
#line 165
  i = 0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;

#line 165
    if (! (i < 4)) {
#line 165
      goto while_break;
    }
#line 166
    a0 = (int )*(in + i) + (int )*(in + (12 + i));
#line 167
    a1 = (int )*(in + (4 + i)) + (int )*(in + (8 + i));
#line 168
    a2 = (int )*(in + (4 + i)) - (int )*(in + (8 + i));
#line 169
    a3 = (int )*(in + i) - (int )*(in + (12 + i));
#line 170
    tmp___0[i] = a0 + a1;
#line 171
    tmp___0[8 + i] = a0 - a1;
#line 172
    tmp___0[4 + i] = a3 + a2;
#line 173
    tmp___0[12 + i] = a3 - a2;
#line 165
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 175
    if (! (i < 4)) {
#line 175
      goto while_break___0;
    }
#line 176
    dc = tmp___0[i * 4] + 3;
#line 177
    a0___0 = dc + tmp___0[3 + i * 4];
#line 178
    a1___0 = tmp___0[1 + i * 4] + tmp___0[2 + i * 4];
#line 179
    a2___0 = tmp___0[1 + i * 4] - tmp___0[2 + i * 4];
#line 180
    a3___0 = dc - tmp___0[3 + i * 4];
#line 181
    *(out + 0) = (int16_t )((a0___0 + a1___0) >> 3);
#line 182
    *(out + 16) = (int16_t )((a3___0 + a2___0) >> 3);
#line 183
    *(out + 32) = (int16_t )((a0___0 - a1___0) >> 3);
#line 184
    *(out + 48) = (int16_t )((a3___0 - a2___0) >> 3);
#line 185
    out += 64;
#line 175
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 179
  return;
}
}
#line 189 "/root/patchweave_new/13/src/dsp/enc.c"
static void FTransformWHT(int16_t *in , int16_t *out ) 
{ 
  int tmp___0[16] ;
  int i ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;
  int b0 ;
  int b1 ;
  int b2 ;
  int b3 ;

  {
#line 192
  i = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;

#line 192
    if (! (i < 4)) {
#line 192
      goto while_break;
    }
#line 193
    a0 = ((int )*(in + 0) + (int )*(in + 32)) << 2;
#line 194
    a1 = ((int )*(in + 16) + (int )*(in + 48)) << 2;
#line 195
    a2 = ((int )*(in + 16) - (int )*(in + 48)) << 2;
#line 196
    a3 = ((int )*(in + 0) - (int )*(in + 32)) << 2;
#line 197
    tmp___0[i * 4] = (a0 + a1) + (a0 != 0);
#line 198
    tmp___0[1 + i * 4] = a3 + a2;
#line 199
    tmp___0[2 + i * 4] = a3 - a2;
#line 200
    tmp___0[3 + i * 4] = a0 - a1;
#line 192
    in += 64;
#line 192
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 202
  i = 0;
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 202
    if (! (i < 4)) {
#line 202
      goto while_break___0;
    }
#line 203
    a0___0 = tmp___0[i] + tmp___0[8 + i];
#line 204
    a1___0 = tmp___0[4 + i] + tmp___0[12 + i];
#line 205
    a2___0 = tmp___0[4 + i] - tmp___0[12 + i];
#line 206
    a3___0 = tmp___0[i] - tmp___0[8 + i];
#line 207
    b0 = a0___0 + a1___0;
#line 208
    b1 = a3___0 + a2___0;
#line 209
    b2 = a3___0 - a2___0;
#line 210
    b3 = a0___0 - a1___0;
#line 211
    *(out + i) = (int16_t )(((b0 + (b0 > 0)) + 3) >> 3);
#line 212
    *(out + (4 + i)) = (int16_t )(((b1 + (b1 > 0)) + 3) >> 3);
#line 213
    *(out + (8 + i)) = (int16_t )(((b2 + (b2 > 0)) + 3) >> 3);
#line 214
    *(out + (12 + i)) = (int16_t )(((b3 + (b3 > 0)) + 3) >> 3);
#line 202
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 206
  return;
}
}
#line 226 "/root/patchweave_new/13/src/dsp/enc.c"
__inline static void Fill(uint8_t *dst , int value , int size ) 
{ 
  int j ;

  {
#line 228
  j = 0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;

#line 228
    if (! (j < size)) {
#line 228
      goto while_break;
    }
    {
#line 229
    memset((void *)(dst + j * 16), value, (unsigned long )size);
#line 228
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 232
  return;
}
}
#line 233 "/root/patchweave_new/13/src/dsp/enc.c"
__inline static void VerticalPred(uint8_t *dst , uint8_t *top , int size ) 
{ 
  int j ;

  {
#line 236
  if (top) {
#line 237
    j = 0;
    {
#line 237
    while (1) {
      while_continue: /* CIL Label */ ;

#line 237
      if (! (j < size)) {
#line 237
        goto while_break;
      }
      {
#line 237
      memcpy((void *)(dst + j * 16), (void const   *)top, (unsigned long )size);
#line 237
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 239
    Fill(dst, 127, size);
    }
  }
#line 242
  return;
}
}
#line 243 "/root/patchweave_new/13/src/dsp/enc.c"
__inline static void HorizontalPred(uint8_t *dst , uint8_t *left , int size ) 
{ 
  int j ;

  {
#line 245
  if (left) {
#line 247
    j = 0;
    {
#line 247
    while (1) {
      while_continue: /* CIL Label */ ;

#line 247
      if (! (j < size)) {
#line 247
        goto while_break;
      }
      {
#line 248
      memset((void *)(dst + j * 16), (int )*(left + j), (unsigned long )size);
#line 247
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 251
    Fill(dst, 129, size);
    }
  }
#line 254
  return;
}
}
#line 255 "/root/patchweave_new/13/src/dsp/enc.c"
__inline static void TrueMotion(uint8_t *dst , uint8_t *left , uint8_t *top , int size ) 
{ 
  int y ;
  uint8_t *clip___3 ;
  uint8_t *clip_table ;
  int x ;

  {
#line 258
  if (left) {
#line 259
    if (top) {
#line 260
      clip___3 = (clip1___0 + 255) - (int )*(left + -1);
#line 261
      y = 0;
      {
#line 261
      while (1) {
        while_continue: /* CIL Label */ ;

#line 261
        if (! (y < size)) {
#line 261
          goto while_break;
        }
#line 262
        clip_table = clip___3 + (int )*(left + y);
#line 264
        x = 0;
        {
#line 264
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 264
          if (! (x < size)) {
#line 264
            goto while_break___0;
          }
#line 265
          *(dst + x) = *(clip_table + (int )*(top + x));
#line 264
          x ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: 
#line 267
        dst += 16;
#line 261
        y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: ;
    } else {
      {
#line 270
      HorizontalPred(dst, left, size);
      }
    }
  } else
#line 277
  if (top) {
    {
#line 278
    VerticalPred(dst, top, size);
    }
  } else {
    {
#line 280
    Fill(dst, 129, size);
    }
  }
#line 283
  return;
}
}
#line 285 "/root/patchweave_new/13/src/dsp/enc.c"
__inline static void DCMode(uint8_t *dst , uint8_t *left , uint8_t *top , int size ,
                            int round___0 , int shift ) 
{ 
  int DC ;
  int j ;

  {
#line 288
  DC = 0;
#line 290
  if (top) {
#line 291
    j = 0;
    {
#line 291
    while (1) {
      while_continue: /* CIL Label */ ;

#line 291
      if (! (j < size)) {
#line 291
        goto while_break;
      }
#line 291
      DC += (int )*(top + j);
#line 291
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
#line 292
    if (left) {
#line 293
      j = 0;
      {
#line 293
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 293
        if (! (j < size)) {
#line 293
          goto while_break___0;
        }
#line 293
        DC += (int )*(left + j);
#line 293
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 295
      DC += DC;
    }
#line 297
    DC = (DC + round___0) >> shift;
  } else
#line 298
  if (left) {
#line 299
    j = 0;
    {
#line 299
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 299
      if (! (j < size)) {
#line 299
        goto while_break___1;
      }
#line 299
      DC += (int )*(left + j);
#line 299
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 300
    DC += DC;
#line 301
    DC = (DC + round___0) >> shift;
  } else {
#line 303
    DC = 128;
  }
  {
#line 305
  Fill(dst, DC, size);
  }
#line 307
  return;
}
}
#line 311 "/root/patchweave_new/13/src/dsp/enc.c"
static void IntraChromaPreds(uint8_t *dst , uint8_t *left , uint8_t *top ) 
{ 


  {
  {
#line 314
  DCMode(dst + 1024, left, top, 8, 8, 4);
#line 315
  VerticalPred(dst + 1280, top, 8);
#line 316
  HorizontalPred(dst + 1408, left, 8);
#line 317
  TrueMotion(dst + 1152, left, top, 8);
#line 319
  dst += 8;
  }
#line 320
  if (top) {
#line 320
    top += 8;
  }
#line 321
  if (left) {
#line 321
    left += 16;
  }
  {
#line 322
  DCMode(dst + 1024, left, top, 8, 8, 4);
#line 323
  VerticalPred(dst + 1280, top, 8);
#line 324
  HorizontalPred(dst + 1408, left, 8);
#line 325
  TrueMotion(dst + 1152, left, top, 8);
  }
#line 327
  return;
}
}
#line 331 "/root/patchweave_new/13/src/dsp/enc.c"
static void Intra16Preds(uint8_t *dst , uint8_t *left , uint8_t *top ) 
{ 


  {
  {
#line 333
  DCMode(dst + 0, left, top, 16, 16, 5);
#line 334
  VerticalPred(dst + 512, top, 16);
#line 335
  HorizontalPred(dst + 768, left, 16);
#line 336
  TrueMotion(dst + 256, left, top, 16);
  }
#line 338
  return;
}
}
#line 345 "/root/patchweave_new/13/src/dsp/enc.c"
static void VE4(uint8_t *dst , uint8_t *top ) 
{ 
  uint8_t vals[4] ;
  int i ;

  {
#line 346
  vals[0] = (uint8_t )(((((int )*(top + -1) + 2 * (int )*(top + 0)) + (int )*(top + 1)) + 2) >> 2);
#line 346
  vals[1] = (uint8_t )(((((int )*(top + 0) + 2 * (int )*(top + 1)) + (int )*(top + 2)) + 2) >> 2);
#line 346
  vals[2] = (uint8_t )(((((int )*(top + 1) + 2 * (int )*(top + 2)) + (int )*(top + 3)) + 2) >> 2);
#line 346
  vals[3] = (uint8_t )(((((int )*(top + 2) + 2 * (int )*(top + 3)) + (int )*(top + 4)) + 2) >> 2);
#line 353
  i = 0;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;

#line 353
    if (! (i < 4)) {
#line 353
      goto while_break;
    }
    {
#line 354
    memcpy((void *)(dst + i * 16), (void const   *)(vals), 4UL);
#line 353
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 357
  return;
}
}
#line 358 "/root/patchweave_new/13/src/dsp/enc.c"
static void HE4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int L ;

  {
#line 359
  X = (int )*(top + -1);
#line 360
  I = (int )*(top + -2);
#line 361
  J = (int )*(top + -3);
#line 362
  K = (int )*(top + -4);
#line 363
  L = (int )*(top + -5);
#line 364
  *((uint32_t *)(dst + 0)) = 16843009U * (unsigned int )((((X + 2 * I) + J) + 2) >> 2);
#line 365
  *((uint32_t *)(dst + 16)) = 16843009U * (unsigned int )((((I + 2 * J) + K) + 2) >> 2);
#line 366
  *((uint32_t *)(dst + 32)) = 16843009U * (unsigned int )((((J + 2 * K) + L) + 2) >> 2);
#line 367
  *((uint32_t *)(dst + 48)) = 16843009U * (unsigned int )((((K + 2 * L) + L) + 2) >> 2);
#line 368
  return;
}
}
#line 370 "/root/patchweave_new/13/src/dsp/enc.c"
static void DC4(uint8_t *dst , uint8_t *top ) 
{ 
  uint32_t dc ;
  int i ;

  {
#line 371
  dc = (uint32_t )4;
#line 373
  i = 0;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;

#line 373
    if (! (i < 4)) {
#line 373
      goto while_break;
    }
#line 373
    dc += (unsigned int )((int )*(top + i) + (int )*(top + (-5 + i)));
#line 373
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 374
  Fill(dst, (int )(dc >> 3), 4);
  }
#line 376
  return;
}
}
#line 377 "/root/patchweave_new/13/src/dsp/enc.c"
static void RD4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int L ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 378
  X = (int )*(top + -1);
#line 379
  I = (int )*(top + -2);
#line 380
  J = (int )*(top + -3);
#line 381
  K = (int )*(top + -4);
#line 382
  L = (int )*(top + -5);
#line 383
  A = (int )*(top + 0);
#line 384
  B = (int )*(top + 1);
#line 385
  C = (int )*(top + 2);
#line 386
  D = (int )*(top + 3);
#line 387
  *(dst + 48) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 388
  *(dst + 49) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 388
  *(dst + 32) = *(dst + 49);
#line 389
  *(dst + 50) = (uint8_t )((((X + 2 * I) + J) + 2) >> 2);
#line 389
  *(dst + 33) = *(dst + 50);
#line 389
  *(dst + 16) = *(dst + 33);
#line 390
  *(dst + 51) = (uint8_t )((((A + 2 * X) + I) + 2) >> 2);
#line 390
  *(dst + 34) = *(dst + 51);
#line 390
  *(dst + 17) = *(dst + 34);
#line 390
  *(dst + 0) = *(dst + 17);
#line 391
  *(dst + 35) = (uint8_t )((((B + 2 * A) + X) + 2) >> 2);
#line 391
  *(dst + 18) = *(dst + 35);
#line 391
  *(dst + 1) = *(dst + 18);
#line 392
  *(dst + 19) = (uint8_t )((((C + 2 * B) + A) + 2) >> 2);
#line 392
  *(dst + 2) = *(dst + 19);
#line 393
  *(dst + 3) = (uint8_t )((((D + 2 * C) + B) + 2) >> 2);
#line 394
  return;
}
}
#line 396 "/root/patchweave_new/13/src/dsp/enc.c"
static void LD4(uint8_t *dst , uint8_t *top ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 397
  A = (int )*(top + 0);
#line 398
  B = (int )*(top + 1);
#line 399
  C = (int )*(top + 2);
#line 400
  D = (int )*(top + 3);
#line 401
  E = (int )*(top + 4);
#line 402
  F = (int )*(top + 5);
#line 403
  G = (int )*(top + 6);
#line 404
  H = (int )*(top + 7);
#line 405
  *(dst + 0) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 406
  *(dst + 16) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 406
  *(dst + 1) = *(dst + 16);
#line 407
  *(dst + 32) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 407
  *(dst + 17) = *(dst + 32);
#line 407
  *(dst + 2) = *(dst + 17);
#line 408
  *(dst + 48) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 408
  *(dst + 33) = *(dst + 48);
#line 408
  *(dst + 18) = *(dst + 33);
#line 408
  *(dst + 3) = *(dst + 18);
#line 409
  *(dst + 49) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 409
  *(dst + 34) = *(dst + 49);
#line 409
  *(dst + 19) = *(dst + 34);
#line 410
  *(dst + 50) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
#line 410
  *(dst + 35) = *(dst + 50);
#line 411
  *(dst + 51) = (uint8_t )((((G + 2 * H) + H) + 2) >> 2);
#line 412
  return;
}
}
#line 414 "/root/patchweave_new/13/src/dsp/enc.c"
static void VR4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 415
  X = (int )*(top + -1);
#line 416
  I = (int )*(top + -2);
#line 417
  J = (int )*(top + -3);
#line 418
  K = (int )*(top + -4);
#line 419
  A = (int )*(top + 0);
#line 420
  B = (int )*(top + 1);
#line 421
  C = (int )*(top + 2);
#line 422
  D = (int )*(top + 3);
#line 423
  *(dst + 33) = (uint8_t )(((X + A) + 1) >> 1);
#line 423
  *(dst + 0) = *(dst + 33);
#line 424
  *(dst + 34) = (uint8_t )(((A + B) + 1) >> 1);
#line 424
  *(dst + 1) = *(dst + 34);
#line 425
  *(dst + 35) = (uint8_t )(((B + C) + 1) >> 1);
#line 425
  *(dst + 2) = *(dst + 35);
#line 426
  *(dst + 3) = (uint8_t )(((C + D) + 1) >> 1);
#line 428
  *(dst + 48) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 429
  *(dst + 32) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 430
  *(dst + 49) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 430
  *(dst + 16) = *(dst + 49);
#line 431
  *(dst + 50) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 431
  *(dst + 17) = *(dst + 50);
#line 432
  *(dst + 51) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 432
  *(dst + 18) = *(dst + 51);
#line 433
  *(dst + 19) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 434
  return;
}
}
#line 436 "/root/patchweave_new/13/src/dsp/enc.c"
static void VL4(uint8_t *dst , uint8_t *top ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 437
  A = (int )*(top + 0);
#line 438
  B = (int )*(top + 1);
#line 439
  C = (int )*(top + 2);
#line 440
  D = (int )*(top + 3);
#line 441
  E = (int )*(top + 4);
#line 442
  F = (int )*(top + 5);
#line 443
  G = (int )*(top + 6);
#line 444
  H = (int )*(top + 7);
#line 445
  *(dst + 0) = (uint8_t )(((A + B) + 1) >> 1);
#line 446
  *(dst + 32) = (uint8_t )(((B + C) + 1) >> 1);
#line 446
  *(dst + 1) = *(dst + 32);
#line 447
  *(dst + 33) = (uint8_t )(((C + D) + 1) >> 1);
#line 447
  *(dst + 2) = *(dst + 33);
#line 448
  *(dst + 34) = (uint8_t )(((D + E) + 1) >> 1);
#line 448
  *(dst + 3) = *(dst + 34);
#line 450
  *(dst + 16) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 451
  *(dst + 48) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 451
  *(dst + 17) = *(dst + 48);
#line 452
  *(dst + 49) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 452
  *(dst + 18) = *(dst + 49);
#line 453
  *(dst + 50) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 453
  *(dst + 19) = *(dst + 50);
#line 454
  *(dst + 35) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 455
  *(dst + 51) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
#line 456
  return;
}
}
#line 458 "/root/patchweave_new/13/src/dsp/enc.c"
static void HU4(uint8_t *dst , uint8_t *top ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;

  {
#line 459
  I = (int )*(top + -2);
#line 460
  J = (int )*(top + -3);
#line 461
  K = (int )*(top + -4);
#line 462
  L = (int )*(top + -5);
#line 463
  *(dst + 0) = (uint8_t )(((I + J) + 1) >> 1);
#line 464
  *(dst + 16) = (uint8_t )(((J + K) + 1) >> 1);
#line 464
  *(dst + 2) = *(dst + 16);
#line 465
  *(dst + 32) = (uint8_t )(((K + L) + 1) >> 1);
#line 465
  *(dst + 18) = *(dst + 32);
#line 466
  *(dst + 1) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 467
  *(dst + 17) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 467
  *(dst + 3) = *(dst + 17);
#line 468
  *(dst + 33) = (uint8_t )((((K + 2 * L) + L) + 2) >> 2);
#line 468
  *(dst + 19) = *(dst + 33);
#line 469
  *(dst + 51) = (uint8_t )L;
#line 469
  *(dst + 50) = *(dst + 51);
#line 469
  *(dst + 49) = *(dst + 50);
#line 469
  *(dst + 48) = *(dst + 49);
#line 469
  *(dst + 34) = *(dst + 48);
#line 469
  *(dst + 35) = *(dst + 34);
#line 470
  return;
}
}
#line 473 "/root/patchweave_new/13/src/dsp/enc.c"
static void HD4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int L ;
  int A ;
  int B ;
  int C ;

  {
#line 474
  X = (int )*(top + -1);
#line 475
  I = (int )*(top + -2);
#line 476
  J = (int )*(top + -3);
#line 477
  K = (int )*(top + -4);
#line 478
  L = (int )*(top + -5);
#line 479
  A = (int )*(top + 0);
#line 480
  B = (int )*(top + 1);
#line 481
  C = (int )*(top + 2);
#line 483
  *(dst + 18) = (uint8_t )(((I + X) + 1) >> 1);
#line 483
  *(dst + 0) = *(dst + 18);
#line 484
  *(dst + 34) = (uint8_t )(((J + I) + 1) >> 1);
#line 484
  *(dst + 16) = *(dst + 34);
#line 485
  *(dst + 50) = (uint8_t )(((K + J) + 1) >> 1);
#line 485
  *(dst + 32) = *(dst + 50);
#line 486
  *(dst + 48) = (uint8_t )(((L + K) + 1) >> 1);
#line 488
  *(dst + 3) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 489
  *(dst + 2) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 490
  *(dst + 19) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 490
  *(dst + 1) = *(dst + 19);
#line 491
  *(dst + 35) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 491
  *(dst + 17) = *(dst + 35);
#line 492
  *(dst + 51) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 492
  *(dst + 33) = *(dst + 51);
#line 493
  *(dst + 49) = (uint8_t )((((L + 2 * K) + J) + 2) >> 2);
#line 494
  return;
}
}
#line 496 "/root/patchweave_new/13/src/dsp/enc.c"
static void TM4(uint8_t *dst , uint8_t *top ) 
{ 
  int x ;
  int y ;
  uint8_t *clip___3 ;
  uint8_t *clip_table ;

  {
#line 498
  clip___3 = (clip1___0 + 255) - (int )*(top + -1);
#line 499
  y = 0;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;

#line 499
    if (! (y < 4)) {
#line 499
      goto while_break;
    }
#line 500
    clip_table = clip___3 + (int )*(top + (-2 - y));
#line 501
    x = 0;
    {
#line 501
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 501
      if (! (x < 4)) {
#line 501
        goto while_break___0;
      }
#line 502
      *(dst + x) = *(clip_table + (int )*(top + x));
#line 501
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 504
    dst += 16;
#line 499
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 503
  return;
}
}
#line 514 "/root/patchweave_new/13/src/dsp/enc.c"
static void Intra4Preds(uint8_t *dst , uint8_t *top ) 
{ 


  {
  {
#line 515
  DC4(dst + 1536, top);
#line 516
  TM4(dst + 1540, top);
#line 517
  VE4(dst + 1544, top);
#line 518
  HE4(dst + 1548, top);
#line 519
  RD4(dst + 1600, top);
#line 520
  VR4(dst + 1604, top);
#line 521
  LD4(dst + 1608, top);
#line 522
  VL4(dst + 1612, top);
#line 523
  HD4(dst + 1664, top);
#line 524
  HU4(dst + 1668, top);
  }
#line 526
  return;
}
}
#line 530 "/root/patchweave_new/13/src/dsp/enc.c"
__inline static int GetSSE(uint8_t *a , uint8_t *b , int w , int h ) 
{ 
  int count ;
  int y ;
  int x ;
  int diff ;

  {
#line 532
  count = 0;
#line 534
  y = 0;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;

#line 534
    if (! (y < h)) {
#line 534
      goto while_break;
    }
#line 535
    x = 0;
    {
#line 535
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 535
      if (! (x < w)) {
#line 535
        goto while_break___0;
      }
#line 536
      diff = (int )*(a + x) - (int )*(b + x);
#line 537
      count += diff * diff;
#line 535
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 539
    a += 16;
#line 540
    b += 16;
#line 534
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 542
  return (count);
}
}
#line 545 "/root/patchweave_new/13/src/dsp/enc.c"
static int SSE16x16(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 546
  __cil_tmp3 = GetSSE(a, b, 16, 16);
  }
#line 546
  return (__cil_tmp3);
}
}
#line 548 "/root/patchweave_new/13/src/dsp/enc.c"
static int SSE16x8(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 549
  __cil_tmp3 = GetSSE(a, b, 16, 8);
  }
#line 549
  return (__cil_tmp3);
}
}
#line 551 "/root/patchweave_new/13/src/dsp/enc.c"
static int SSE8x8(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 552
  __cil_tmp3 = GetSSE(a, b, 8, 8);
  }
#line 552
  return (__cil_tmp3);
}
}
#line 554 "/root/patchweave_new/13/src/dsp/enc.c"
static int SSE4x4(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 555
  __cil_tmp3 = GetSSE(a, b, 4, 4);
  }
#line 555
  return (__cil_tmp3);
}
}
#line 566 "/root/patchweave_new/13/src/dsp/enc.c"
static int TTransform(uint8_t *in , uint16_t *w ) 
{ 
  int sum ;
  int tmp___0[16] ;
  int i ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;
  int b0 ;
  int b1 ;
  int b2 ;
  int b3 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;

  {
#line 567
  sum = 0;
#line 571
  i = 0;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;

#line 571
    if (! (i < 4)) {
#line 571
      goto while_break;
    }
#line 572
    a0 = (int )*(in + 0) + (int )*(in + 2);
#line 573
    a1 = (int )*(in + 1) + (int )*(in + 3);
#line 574
    a2 = (int )*(in + 1) - (int )*(in + 3);
#line 575
    a3 = (int )*(in + 0) - (int )*(in + 2);
#line 576
    tmp___0[i * 4] = a0 + a1;
#line 577
    tmp___0[1 + i * 4] = a3 + a2;
#line 578
    tmp___0[2 + i * 4] = a3 - a2;
#line 579
    tmp___0[3 + i * 4] = a0 - a1;
#line 571
    in += 16;
#line 571
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 582
  i = 0;
  {
#line 582
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 582
    if (! (i < 4)) {
#line 582
      goto while_break___0;
    }
    {
#line 583
    a0___0 = tmp___0[i] + tmp___0[8 + i];
#line 584
    a1___0 = tmp___0[4 + i] + tmp___0[12 + i];
#line 585
    a2___0 = tmp___0[4 + i] - tmp___0[12 + i];
#line 586
    a3___0 = tmp___0[i] - tmp___0[8 + i];
#line 587
    b0 = a0___0 + a1___0;
#line 588
    b1 = a3___0 + a2___0;
#line 589
    b2 = a3___0 - a2___0;
#line 590
    b3 = a0___0 - a1___0;
#line 592
    __cil_tmp18 = abs(b0);
#line 592
    sum += (int )*(w + 0) * __cil_tmp18;
#line 593
    __cil_tmp19 = abs(b1);
#line 593
    sum += (int )*(w + 4) * __cil_tmp19;
#line 594
    __cil_tmp20 = abs(b2);
#line 594
    sum += (int )*(w + 8) * __cil_tmp20;
#line 595
    __cil_tmp21 = abs(b3);
#line 595
    sum += (int )*(w + 12) * __cil_tmp21;
#line 582
    w ++;
#line 582
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 597
  return (sum);
}
}
#line 600 "/root/patchweave_new/13/src/dsp/enc.c"
static int Disto4x4(uint8_t *a , uint8_t *b , uint16_t *w ) 
{ 
  int sum1 ;
  int __cil_tmp5 ;
  int sum2 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 602
  __cil_tmp5 = TTransform(a, w);
#line 602
  sum1 = __cil_tmp5;
#line 603
  __cil_tmp7 = TTransform(b, w);
#line 603
  sum2 = __cil_tmp7;
#line 604
  __cil_tmp8 = abs(sum2 - sum1);
  }
#line 604
  return (__cil_tmp8 >> 5);
}
}
#line 607 "/root/patchweave_new/13/src/dsp/enc.c"
static int Disto16x16(uint8_t *a , uint8_t *b , uint16_t *w ) 
{ 
  int D ;
  int x ;
  int y ;
  int __cil_tmp7 ;

  {
#line 609
  D = 0;
#line 611
  y = 0;
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;

#line 611
    if (! (y < 256)) {
#line 611
      goto while_break;
    }
#line 612
    x = 0;
    {
#line 612
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 612
      if (! (x < 16)) {
#line 612
        goto while_break___0;
      }
      {
#line 613
      __cil_tmp7 = Disto4x4((a + x) + y, (b + x) + y, w);
#line 613
      D += __cil_tmp7;
#line 612
      x += 4;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 611
    y += 64;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 616
  return (D);
}
}
#line 623 "/root/patchweave_new/13/src/dsp/enc.c"
static uint8_t kZigzag___0[16]  = 
#line 623
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )4,      (uint8_t )8, 
        (uint8_t )5,      (uint8_t )2,      (uint8_t )3,      (uint8_t )6, 
        (uint8_t )9,      (uint8_t )12,      (uint8_t )13,      (uint8_t )10, 
        (uint8_t )7,      (uint8_t )11,      (uint8_t )14,      (uint8_t )15};
#line 628 "/root/patchweave_new/13/src/dsp/enc.c"
static int QuantizeBlock(int16_t *in , int16_t *out , int n , VP8Matrix *mtx ) 
{ 
  int last ;
  int j ;
  int sign ;
  int coeff ;
  int tmp___0 ;
  int Q ;
  int iQ ;
  int B ;
  int __cil_tmp13 ;

  {
#line 630
  last = -1;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;

#line 631
    if (! (n < 16)) {
#line 631
      goto while_break;
    }
#line 632
    j = (int )kZigzag___0[n];
#line 633
    sign = (int )*(in + j) < 0;
#line 634
    if (sign) {
#line 634
      tmp___0 = - ((int )*(in + j));
    } else {
#line 634
      tmp___0 = (int )*(in + j);
    }
#line 634
    coeff = tmp___0 + (int )mtx->sharpen_[j];
#line 635
    if (coeff > (int )mtx->zthresh_[j]) {
      {
#line 636
      Q = (int )mtx->q_[j];
#line 637
      iQ = (int )mtx->iq_[j];
#line 638
      B = (int )mtx->bias_[j];
#line 639
      __cil_tmp13 = QUANTDIV(coeff, iQ, B);
#line 639
      *(out + n) = (int16_t )__cil_tmp13;
      }
#line 640
      if ((int )*(out + n) > 2047) {
#line 640
        *(out + n) = (int16_t )2047;
      }
#line 641
      if (sign) {
#line 641
        *(out + n) = (int16_t )(- ((int )*(out + n)));
      }
#line 642
      *(in + j) = (int16_t )((int )*(out + n) * Q);
#line 643
      if (*(out + n)) {
#line 643
        last = n;
      }
    } else {
#line 645
      *(out + n) = (int16_t )0;
#line 646
      *(in + j) = (int16_t )0;
    }
#line 631
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 649
  return (last >= 0);
}
}
#line 655 "/root/patchweave_new/13/src/dsp/enc.c"
__inline static void Copy(uint8_t *src , uint8_t *dst , int size ) 
{ 
  int y ;

  {
#line 657
  y = 0;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;

#line 657
    if (! (y < size)) {
#line 657
      goto while_break;
    }
    {
#line 658
    memcpy((void *)dst, (void const   *)src, (unsigned long )size);
#line 659
    src += 16;
#line 660
    dst += 16;
#line 657
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 661
  return;
}
}
#line 664 "/root/patchweave_new/13/src/dsp/enc.c"
static void Copy4x4(uint8_t *src , uint8_t *dst ) 
{ 


  {
  {
#line 664
  Copy(src, dst, 4);
  }
#line 666
  return;
}
}
#line 691 "/root/patchweave_new/13/src/dsp/enc.c"
void VP8EncDspInit(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 692
  InitTables___0();
#line 695
  VP8CollectHistogram = (void (*)(uint8_t * , uint8_t * , int  , int  , struct VP8Histogram * const   ))(& CollectHistogram);
#line 696
  VP8ITransform = & ITransform;
#line 697
  VP8FTransform = & FTransform;
#line 698
  VP8ITransformWHT = & ITransformWHT;
#line 699
  VP8FTransformWHT = & FTransformWHT;
#line 700
  VP8EncPredLuma4 = & Intra4Preds;
#line 701
  VP8EncPredLuma16 = & Intra16Preds;
#line 702
  VP8EncPredChroma8 = & IntraChromaPreds;
#line 703
  VP8SSE16x16 = & SSE16x16;
#line 704
  VP8SSE8x8 = & SSE8x8;
#line 705
  VP8SSE16x8 = & SSE16x8;
#line 706
  VP8SSE4x4 = & SSE4x4;
#line 707
  VP8TDisto4x4 = (int (*)(uint8_t * , uint8_t * , uint16_t * const   ))(& Disto4x4);
#line 708
  VP8TDisto16x16 = (int (*)(uint8_t * , uint8_t * , uint16_t * const   ))(& Disto16x16);
#line 709
  VP8EncQuantizeBlock = (int (*)(int16_t * , int16_t * , int  , struct VP8Matrix * const   ))(& QuantizeBlock);
#line 710
  VP8Copy4x4 = & Copy4x4;
  }
#line 713
  if (VP8GetCPUInfo) {
    {
#line 715
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 715
    if (__cil_tmp1) {
      {
#line 716
      VP8EncDspInitSSE2();
      }
    }
  }
#line 720
  return;
}
}
#line 291 "/root/patchweave_new/13/src/dsp/../dec/vp8i.h"
int VP8SetError(VP8Decoder *dec , enum VP8StatusCode error , char const   *msg ) ;
#line 295
void VP8ResetProba(VP8Proba___0 *proba ) ;
#line 296
void VP8ParseProba(VP8BitReader *br , VP8Decoder *dec ) ;
#line 297
void VP8ParseIntraMode(VP8BitReader *br , VP8Decoder *dec ) ;
#line 300
void VP8ParseQuant(VP8Decoder *dec ) ;
#line 303
int VP8InitFrame(VP8Decoder *dec , VP8Io *io ) ;
#line 305
void VP8ReconstructBlock(VP8Decoder *dec ) ;
#line 310
enum VP8StatusCode VP8EnterCritical(VP8Decoder *dec , VP8Io *io ) ;
#line 313
int VP8ExitCritical(VP8Decoder *dec , VP8Io *io ) ;
#line 315
int VP8ProcessRow(VP8Decoder *dec , VP8Io *io ) ;
#line 317
void VP8InitScanline(VP8Decoder *dec ) ;
#line 319
int VP8DecodeMB(VP8Decoder *dec , VP8BitReader *token_br ) ;
#line 322
uint8_t *VP8DecompressAlphaRows(VP8Decoder *dec , int row , int num_rows ) ;
#line 326
int VP8DecodeLayer(VP8Decoder *dec ) ;
#line 27 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void TransformSSE2(int16_t *in , uint8_t *dst , int do_two ) 
{ 
  __m128i k1 ;
  __m128i __cil_tmp5 ;
  __m128i k2 ;
  __m128i __cil_tmp7 ;
  __m128i T0 ;
  __m128i T1 ;
  __m128i T2 ;
  __m128i T3 ;
  __m128i in0 ;
  __m128i in1 ;
  __m128i in2 ;
  __m128i in3 ;
  __m128i inB0 ;
  __m128i __cil_tmp21 ;
  __m128i inB1 ;
  __m128i __cil_tmp23 ;
  __m128i inB2 ;
  __m128i __cil_tmp25 ;
  __m128i inB3 ;
  __m128i __cil_tmp27 ;
  __m128i a ;
  __m128i __cil_tmp33 ;
  __m128i b ;
  __m128i __cil_tmp35 ;
  __m128i c1 ;
  __m128i __cil_tmp37 ;
  __m128i c2 ;
  __m128i __cil_tmp39 ;
  __m128i c3 ;
  __m128i __cil_tmp41 ;
  __m128i c4 ;
  __m128i __cil_tmp43 ;
  __m128i c ;
  __m128i __cil_tmp45 ;
  __m128i d1 ;
  __m128i __cil_tmp47 ;
  __m128i d2 ;
  __m128i __cil_tmp49 ;
  __m128i d3 ;
  __m128i __cil_tmp51 ;
  __m128i d4 ;
  __m128i __cil_tmp53 ;
  __m128i d ;
  __m128i __cil_tmp55 ;
  __m128i tmp0 ;
  __m128i __cil_tmp57 ;
  __m128i tmp1 ;
  __m128i __cil_tmp59 ;
  __m128i tmp2 ;
  __m128i __cil_tmp61 ;
  __m128i tmp3 ;
  __m128i __cil_tmp63 ;
  __m128i transpose0_0 ;
  __m128i __cil_tmp65 ;
  __m128i transpose0_1 ;
  __m128i __cil_tmp67 ;
  __m128i transpose0_2 ;
  __m128i __cil_tmp69 ;
  __m128i transpose0_3 ;
  __m128i __cil_tmp71 ;
  __m128i transpose1_0 ;
  __m128i __cil_tmp73 ;
  __m128i transpose1_1 ;
  __m128i __cil_tmp75 ;
  __m128i transpose1_2 ;
  __m128i __cil_tmp77 ;
  __m128i transpose1_3 ;
  __m128i __cil_tmp79 ;
  __m128i four ;
  __m128i __cil_tmp85 ;
  __m128i dc ;
  __m128i __cil_tmp87 ;
  __m128i a___0 ;
  __m128i __cil_tmp89 ;
  __m128i b___0 ;
  __m128i __cil_tmp91 ;
  __m128i c1___0 ;
  __m128i __cil_tmp93 ;
  __m128i c2___0 ;
  __m128i __cil_tmp95 ;
  __m128i c3___0 ;
  __m128i __cil_tmp97 ;
  __m128i c4___0 ;
  __m128i __cil_tmp99 ;
  __m128i c___0 ;
  __m128i __cil_tmp101 ;
  __m128i d1___0 ;
  __m128i __cil_tmp103 ;
  __m128i d2___0 ;
  __m128i __cil_tmp105 ;
  __m128i d3___0 ;
  __m128i __cil_tmp107 ;
  __m128i d4___0 ;
  __m128i __cil_tmp109 ;
  __m128i d___0 ;
  __m128i __cil_tmp111 ;
  __m128i tmp0___0 ;
  __m128i __cil_tmp113 ;
  __m128i tmp1___0 ;
  __m128i __cil_tmp115 ;
  __m128i tmp2___0 ;
  __m128i __cil_tmp117 ;
  __m128i tmp3___0 ;
  __m128i __cil_tmp119 ;
  __m128i shifted0 ;
  __m128i __cil_tmp121 ;
  __m128i shifted1 ;
  __m128i __cil_tmp123 ;
  __m128i shifted2 ;
  __m128i __cil_tmp125 ;
  __m128i shifted3 ;
  __m128i __cil_tmp127 ;
  __m128i transpose0_0___0 ;
  __m128i __cil_tmp129 ;
  __m128i transpose0_1___0 ;
  __m128i __cil_tmp131 ;
  __m128i transpose0_2___0 ;
  __m128i __cil_tmp133 ;
  __m128i transpose0_3___0 ;
  __m128i __cil_tmp135 ;
  __m128i transpose1_0___0 ;
  __m128i __cil_tmp137 ;
  __m128i transpose1_1___0 ;
  __m128i __cil_tmp139 ;
  __m128i transpose1_2___0 ;
  __m128i __cil_tmp141 ;
  __m128i transpose1_3___0 ;
  __m128i __cil_tmp143 ;
  __m128i zero ;
  __m128i __cil_tmp149 ;
  __m128i dst0 ;
  __m128i dst1 ;
  __m128i dst2 ;
  __m128i dst3 ;

  {
  {
#line 44
  __cil_tmp5 = _mm_set1_epi16((short)20091);
#line 44
  k1 = __cil_tmp5;
#line 45
  __cil_tmp7 = _mm_set1_epi16((short)-30068);
#line 45
  k2 = __cil_tmp7;
#line 53
  in0 = _mm_loadl_epi64((__m128i *)(in + 0));
#line 54
  in1 = _mm_loadl_epi64((__m128i *)(in + 4));
#line 55
  in2 = _mm_loadl_epi64((__m128i *)(in + 8));
#line 56
  in3 = _mm_loadl_epi64((__m128i *)(in + 12));
  }
#line 61
  if (do_two) {
    {
#line 62
    __cil_tmp21 = _mm_loadl_epi64((__m128i *)(in + 16));
#line 62
    inB0 = __cil_tmp21;
#line 63
    __cil_tmp23 = _mm_loadl_epi64((__m128i *)(in + 20));
#line 63
    inB1 = __cil_tmp23;
#line 64
    __cil_tmp25 = _mm_loadl_epi64((__m128i *)(in + 24));
#line 64
    inB2 = __cil_tmp25;
#line 65
    __cil_tmp27 = _mm_loadl_epi64((__m128i *)(in + 28));
#line 65
    inB3 = __cil_tmp27;
#line 66
    in0 = _mm_unpackhi_epi8(in0, inB0);
#line 67
    in1 = _mm_unpackhi_epi8(in1, inB1);
#line 68
    in2 = _mm_unpackhi_epi8(in2, inB2);
#line 69
    in3 = _mm_unpackhi_epi8(in3, inB3);
    }
  }
  {
#line 81
  __cil_tmp33 = _mm_add_epi16(in0, in2);
#line 81
  a = __cil_tmp33;
#line 82
  __cil_tmp35 = _mm_sub_epi16(in0, in2);
#line 82
  b = __cil_tmp35;
#line 84
  __cil_tmp37 = _mm_mulhi_epi16(in1, k2);
#line 84
  c1 = __cil_tmp37;
#line 85
  __cil_tmp39 = _mm_mulhi_epi16(in3, k1);
#line 85
  c2 = __cil_tmp39;
#line 86
  __cil_tmp41 = _mm_sub_epi16(in1, in3);
#line 86
  c3 = __cil_tmp41;
#line 87
  __cil_tmp43 = _mm_sub_epi16(c1, c2);
#line 87
  c4 = __cil_tmp43;
#line 88
  __cil_tmp45 = _mm_add_epi16(c3, c4);
#line 88
  c = __cil_tmp45;
#line 90
  __cil_tmp47 = _mm_mulhi_epi16(in1, k1);
#line 90
  d1 = __cil_tmp47;
#line 91
  __cil_tmp49 = _mm_mulhi_epi16(in3, k2);
#line 91
  d2 = __cil_tmp49;
#line 92
  __cil_tmp51 = _mm_add_epi16(in1, in3);
#line 92
  d3 = __cil_tmp51;
#line 93
  __cil_tmp53 = _mm_add_epi16(d1, d2);
#line 93
  d4 = __cil_tmp53;
#line 94
  __cil_tmp55 = _mm_add_epi16(d3, d4);
#line 94
  d = __cil_tmp55;
#line 97
  __cil_tmp57 = _mm_add_epi16(a, d);
#line 97
  tmp0 = __cil_tmp57;
#line 98
  __cil_tmp59 = _mm_add_epi16(b, c);
#line 98
  tmp1 = __cil_tmp59;
#line 99
  __cil_tmp61 = _mm_sub_epi16(b, c);
#line 99
  tmp2 = __cil_tmp61;
#line 100
  __cil_tmp63 = _mm_sub_epi16(a, d);
#line 100
  tmp3 = __cil_tmp63;
#line 107
  __cil_tmp65 = _mm_unpackhi_epi8(tmp0, tmp1);
#line 107
  transpose0_0 = __cil_tmp65;
#line 108
  __cil_tmp67 = _mm_unpackhi_epi8(tmp2, tmp3);
#line 108
  transpose0_1 = __cil_tmp67;
#line 109
  __cil_tmp69 = _mm_unpackhi_epi8(tmp0, tmp1);
#line 109
  transpose0_2 = __cil_tmp69;
#line 110
  __cil_tmp71 = _mm_unpackhi_epi8(tmp2, tmp3);
#line 110
  transpose0_3 = __cil_tmp71;
#line 115
  __cil_tmp73 = _mm_unpackhi_epi8(transpose0_0, transpose0_1);
#line 115
  transpose1_0 = __cil_tmp73;
#line 116
  __cil_tmp75 = _mm_unpackhi_epi8(transpose0_2, transpose0_3);
#line 116
  transpose1_1 = __cil_tmp75;
#line 117
  __cil_tmp77 = _mm_unpackhi_epi8(transpose0_0, transpose0_1);
#line 117
  transpose1_2 = __cil_tmp77;
#line 118
  __cil_tmp79 = _mm_unpackhi_epi8(transpose0_2, transpose0_3);
#line 118
  transpose1_3 = __cil_tmp79;
#line 123
  T0 = _mm_unpackhi_epi8(transpose1_0, transpose1_1);
#line 124
  T1 = _mm_unpackhi_epi8(transpose1_0, transpose1_1);
#line 125
  T2 = _mm_unpackhi_epi8(transpose1_2, transpose1_3);
#line 126
  T3 = _mm_unpackhi_epi8(transpose1_2, transpose1_3);
#line 137
  __cil_tmp85 = _mm_set1_epi16((short)4);
#line 137
  four = __cil_tmp85;
#line 138
  __cil_tmp87 = _mm_add_epi16(T0, four);
#line 138
  dc = __cil_tmp87;
#line 139
  __cil_tmp89 = _mm_add_epi16(dc, T2);
#line 139
  a___0 = __cil_tmp89;
#line 140
  __cil_tmp91 = _mm_sub_epi16(dc, T2);
#line 140
  b___0 = __cil_tmp91;
#line 142
  __cil_tmp93 = _mm_mulhi_epi16(T1, k2);
#line 142
  c1___0 = __cil_tmp93;
#line 143
  __cil_tmp95 = _mm_mulhi_epi16(T3, k1);
#line 143
  c2___0 = __cil_tmp95;
#line 144
  __cil_tmp97 = _mm_sub_epi16(T1, T3);
#line 144
  c3___0 = __cil_tmp97;
#line 145
  __cil_tmp99 = _mm_sub_epi16(c1___0, c2___0);
#line 145
  c4___0 = __cil_tmp99;
#line 146
  __cil_tmp101 = _mm_add_epi16(c3___0, c4___0);
#line 146
  c___0 = __cil_tmp101;
#line 148
  __cil_tmp103 = _mm_mulhi_epi16(T1, k1);
#line 148
  d1___0 = __cil_tmp103;
#line 149
  __cil_tmp105 = _mm_mulhi_epi16(T3, k2);
#line 149
  d2___0 = __cil_tmp105;
#line 150
  __cil_tmp107 = _mm_add_epi16(T1, T3);
#line 150
  d3___0 = __cil_tmp107;
#line 151
  __cil_tmp109 = _mm_add_epi16(d1___0, d2___0);
#line 151
  d4___0 = __cil_tmp109;
#line 152
  __cil_tmp111 = _mm_add_epi16(d3___0, d4___0);
#line 152
  d___0 = __cil_tmp111;
#line 155
  __cil_tmp113 = _mm_add_epi16(a___0, d___0);
#line 155
  tmp0___0 = __cil_tmp113;
#line 156
  __cil_tmp115 = _mm_add_epi16(b___0, c___0);
#line 156
  tmp1___0 = __cil_tmp115;
#line 157
  __cil_tmp117 = _mm_sub_epi16(b___0, c___0);
#line 157
  tmp2___0 = __cil_tmp117;
#line 158
  __cil_tmp119 = _mm_sub_epi16(a___0, d___0);
#line 158
  tmp3___0 = __cil_tmp119;
#line 159
  __cil_tmp121 = _mm_srai_epi16(tmp0___0, 3);
#line 159
  shifted0 = __cil_tmp121;
#line 160
  __cil_tmp123 = _mm_srai_epi16(tmp1___0, 3);
#line 160
  shifted1 = __cil_tmp123;
#line 161
  __cil_tmp125 = _mm_srai_epi16(tmp2___0, 3);
#line 161
  shifted2 = __cil_tmp125;
#line 162
  __cil_tmp127 = _mm_srai_epi16(tmp3___0, 3);
#line 162
  shifted3 = __cil_tmp127;
#line 169
  __cil_tmp129 = _mm_unpackhi_epi8(shifted0, shifted1);
#line 169
  transpose0_0___0 = __cil_tmp129;
#line 170
  __cil_tmp131 = _mm_unpackhi_epi8(shifted2, shifted3);
#line 170
  transpose0_1___0 = __cil_tmp131;
#line 171
  __cil_tmp133 = _mm_unpackhi_epi8(shifted0, shifted1);
#line 171
  transpose0_2___0 = __cil_tmp133;
#line 172
  __cil_tmp135 = _mm_unpackhi_epi8(shifted2, shifted3);
#line 172
  transpose0_3___0 = __cil_tmp135;
#line 177
  __cil_tmp137 = _mm_unpackhi_epi8(transpose0_0___0, transpose0_1___0);
#line 177
  transpose1_0___0 = __cil_tmp137;
#line 178
  __cil_tmp139 = _mm_unpackhi_epi8(transpose0_2___0, transpose0_3___0);
#line 178
  transpose1_1___0 = __cil_tmp139;
#line 179
  __cil_tmp141 = _mm_unpackhi_epi8(transpose0_0___0, transpose0_1___0);
#line 179
  transpose1_2___0 = __cil_tmp141;
#line 180
  __cil_tmp143 = _mm_unpackhi_epi8(transpose0_2___0, transpose0_3___0);
#line 180
  transpose1_3___0 = __cil_tmp143;
#line 185
  T0 = _mm_unpackhi_epi8(transpose1_0___0, transpose1_1___0);
#line 186
  T1 = _mm_unpackhi_epi8(transpose1_0___0, transpose1_1___0);
#line 187
  T2 = _mm_unpackhi_epi8(transpose1_2___0, transpose1_3___0);
#line 188
  T3 = _mm_unpackhi_epi8(transpose1_2___0, transpose1_3___0);
#line 197
  __cil_tmp149 = _mm_setzero_si128();
#line 197
  zero = __cil_tmp149;
  }
#line 200
  if (do_two) {
    {
#line 202
    dst0 = _mm_loadl_epi64((__m128i *)(dst + 0));
#line 203
    dst1 = _mm_loadl_epi64((__m128i *)(dst + 32));
#line 204
    dst2 = _mm_loadl_epi64((__m128i *)(dst + 64));
#line 205
    dst3 = _mm_loadl_epi64((__m128i *)(dst + 96));
    }
  } else {
    {
#line 208
    dst0 = _mm_cvtsi32_si128(*((int *)(dst + 0)));
#line 209
    dst1 = _mm_cvtsi32_si128(*((int *)(dst + 32)));
#line 210
    dst2 = _mm_cvtsi32_si128(*((int *)(dst + 64)));
#line 211
    dst3 = _mm_cvtsi32_si128(*((int *)(dst + 96)));
    }
  }
  {
#line 214
  dst0 = _mm_unpackhi_epi8(dst0, zero);
#line 215
  dst1 = _mm_unpackhi_epi8(dst1, zero);
#line 216
  dst2 = _mm_unpackhi_epi8(dst2, zero);
#line 217
  dst3 = _mm_unpackhi_epi8(dst3, zero);
#line 219
  dst0 = _mm_add_epi16(dst0, T0);
#line 220
  dst1 = _mm_add_epi16(dst1, T1);
#line 221
  dst2 = _mm_add_epi16(dst2, T2);
#line 222
  dst3 = _mm_add_epi16(dst3, T3);
#line 224
  dst0 = _mm_packus_epi16(dst0, dst0);
#line 225
  dst1 = _mm_packus_epi16(dst1, dst1);
#line 226
  dst2 = _mm_packus_epi16(dst2, dst2);
#line 227
  dst3 = _mm_packus_epi16(dst3, dst3);
  }
#line 229
  if (do_two) {
    {
#line 231
    _mm_storel_epi64((__m128i *)(dst + 0), dst0);
#line 232
    _mm_storel_epi64((__m128i *)(dst + 32), dst1);
#line 233
    _mm_storel_epi64((__m128i *)(dst + 64), dst2);
#line 234
    _mm_storel_epi64((__m128i *)(dst + 96), dst3);
    }
  } else {
    {
#line 237
    *((int32_t *)(dst + 0)) = _mm_cvtsi128_si32(dst0);
#line 238
    *((int32_t *)(dst + 32)) = _mm_cvtsi128_si32(dst1);
#line 239
    *((int32_t *)(dst + 64)) = _mm_cvtsi128_si32(dst2);
#line 240
    *((int32_t *)(dst + 96)) = _mm_cvtsi128_si32(dst3);
    }
  }
#line 243
  return;
}
}
#line 326 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void NeedsFilter(__m128i *p1 , __m128i *p0 , __m128i *q0 , __m128i *q1 , int thresh ,
                        __m128i *mask ) 
{ 
  __m128i t1 ;
  __m128i __cil_tmp8 ;
  __m128i __cil_tmp9 ;
  __m128i __cil_tmp10 ;
  __m128i __cil_tmp14 ;
  __m128i __cil_tmp15 ;
  __m128i __cil_tmp16 ;
  __m128i __cil_tmp21 ;
  __m128i __cil_tmp22 ;

  {
  {
#line 328
  __cil_tmp8 = _mm_subs_epu8(*q1, *p1);
#line 328
  __cil_tmp9 = _mm_subs_epu8(*p1, *q1);
#line 328
  __cil_tmp10 = _mm_or_si128(__cil_tmp8, __cil_tmp9);
#line 328
  t1 = __cil_tmp10;
#line 329
  *mask = _mm_set1_epi8((char)-2);
#line 330
  t1 = _mm_and_si128(t1, *mask);
#line 331
  t1 = _mm_srli_epi16(t1, 1);
#line 333
  __cil_tmp14 = _mm_subs_epu8(*q0, *p0);
#line 333
  __cil_tmp15 = _mm_subs_epu8(*p0, *q0);
#line 333
  __cil_tmp16 = _mm_or_si128(__cil_tmp14, __cil_tmp15);
#line 333
  *mask = __cil_tmp16;
#line 334
  *mask = _mm_adds_epu8(*mask, *mask);
#line 335
  *mask = _mm_adds_epu8(*mask, t1);
#line 337
  t1 = _mm_set1_epi8((char )thresh);
#line 338
  *mask = _mm_subs_epu8(*mask, t1);
#line 339
  __cil_tmp21 = _mm_setzero_si128();
#line 339
  __cil_tmp22 = _mm_cmpeq_epi8(*mask, __cil_tmp21);
#line 339
  *mask = __cil_tmp22;
  }
#line 341
  return;
}
}
#line 346 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
__inline static void DoFilter2(__m128i *p1 , __m128i *p0 , __m128i *q0 , __m128i *q1 ,
                               int thresh ) 
{ 
  __m128i a ;
  __m128i mask ;
  __m128i sign_bit ;
  __m128i __cil_tmp9 ;
  __m128i p1s ;
  __m128i __cil_tmp11 ;
  __m128i q1s ;
  __m128i __cil_tmp13 ;
  __m128i qp0 ;
  __m128i __cil_tmp17 ;
  __m128i three ;
  __m128i __cil_tmp24 ;
  __m128i four ;
  __m128i __cil_tmp26 ;
  __m128i v3 ;
  __m128i __cil_tmp28 ;
  __m128i v4 ;
  __m128i __cil_tmp30 ;
  __m128i t ;
  __m128i t___0 ;

  {
  {
#line 349
  __cil_tmp9 = _mm_set1_epi8((char)-128);
#line 349
  sign_bit = __cil_tmp9;
#line 350
  __cil_tmp11 = _mm_xor_si128(*p1, sign_bit);
#line 350
  p1s = __cil_tmp11;
#line 351
  __cil_tmp13 = _mm_xor_si128(*q1, sign_bit);
#line 351
  q1s = __cil_tmp13;
#line 353
  NeedsFilter(p1, p0, q0, q1, thresh, & mask);
#line 356
  *p0 = _mm_xor_si128(*p0, sign_bit);
#line 356
  *q0 = _mm_xor_si128(*q0, sign_bit);
#line 358
  __cil_tmp17 = _mm_subs_epi8(*q0, *p0);
#line 358
  qp0 = __cil_tmp17;
#line 358
  a = _mm_subs_epi8(p1s, q1s);
#line 358
  a = _mm_adds_epi8(a, qp0);
#line 358
  a = _mm_adds_epi8(a, qp0);
#line 358
  a = _mm_adds_epi8(a, qp0);
#line 359
  a = _mm_and_si128(a, mask);
#line 360
  __cil_tmp24 = _mm_set1_epi8((char)3);
#line 360
  three = __cil_tmp24;
#line 360
  __cil_tmp26 = _mm_set1_epi8((char)4);
#line 360
  four = __cil_tmp26;
#line 360
  __cil_tmp28 = _mm_adds_epi8(a, three);
#line 360
  v3 = __cil_tmp28;
#line 360
  __cil_tmp30 = _mm_adds_epi8(a, four);
#line 360
  v4 = __cil_tmp30;
#line 360
  t = v4;
#line 360
  t = _mm_slli_epi16(t, 8);
#line 360
  t = _mm_srai_epi16(t, 3);
#line 360
  t = _mm_srli_epi16(t, 8);
#line 360
  v4 = _mm_srai_epi16(v4, 11);
#line 360
  v4 = _mm_slli_epi16(v4, 8);
#line 360
  v4 = _mm_or_si128(t, v4);
#line 360
  *q0 = _mm_subs_epi8(*q0, v4);
#line 360
  t___0 = v3;
#line 360
  t___0 = _mm_slli_epi16(t___0, 8);
#line 360
  t___0 = _mm_srai_epi16(t___0, 3);
#line 360
  t___0 = _mm_srli_epi16(t___0, 8);
#line 360
  v3 = _mm_srai_epi16(v3, 11);
#line 360
  v3 = _mm_slli_epi16(v3, 8);
#line 360
  v3 = _mm_or_si128(t___0, v3);
#line 360
  *p0 = _mm_adds_epi8(*p0, v3);
#line 363
  *p0 = _mm_xor_si128(*p0, sign_bit);
#line 363
  *q0 = _mm_xor_si128(*q0, sign_bit);
  }
#line 365
  return;
}
}
#line 367 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
__inline static void DoFilter4(__m128i *p1 , __m128i *p0 , __m128i *q0 , __m128i *q1 ,
                               __m128i *mask , int hev_thresh ) 
{ 
  __m128i not_hev ;
  __m128i t1 ;
  __m128i t2 ;
  __m128i t3 ;
  __m128i sign_bit ;
  __m128i __cil_tmp12 ;
  __m128i zero ;
  __m128i __cil_tmp14 ;
  __m128i t_1 ;
  __m128i __cil_tmp16 ;
  __m128i __cil_tmp17 ;
  __m128i __cil_tmp18 ;
  __m128i t_2 ;
  __m128i __cil_tmp20 ;
  __m128i __cil_tmp21 ;
  __m128i __cil_tmp22 ;
  __m128i h ;
  __m128i __cil_tmp24 ;
  __m128i t_3 ;
  __m128i __cil_tmp26 ;
  __m128i t_4 ;
  __m128i __cil_tmp28 ;
  __m128i t ;
  __m128i t___0 ;
  __m128i t___1 ;

  {
  {
#line 372
  __cil_tmp12 = _mm_set1_epi8((char)-128);
#line 372
  sign_bit = __cil_tmp12;
#line 375
  __cil_tmp14 = _mm_setzero_si128();
#line 375
  zero = __cil_tmp14;
#line 375
  __cil_tmp16 = _mm_subs_epu8(*p0, *p1);
#line 375
  __cil_tmp17 = _mm_subs_epu8(*p1, *p0);
#line 375
  __cil_tmp18 = _mm_or_si128(__cil_tmp16, __cil_tmp17);
#line 375
  t_1 = __cil_tmp18;
#line 375
  __cil_tmp20 = _mm_subs_epu8(*q0, *q1);
#line 375
  __cil_tmp21 = _mm_subs_epu8(*q1, *q0);
#line 375
  __cil_tmp22 = _mm_or_si128(__cil_tmp20, __cil_tmp21);
#line 375
  t_2 = __cil_tmp22;
#line 375
  __cil_tmp24 = _mm_set1_epi8((char )hev_thresh);
#line 375
  h = __cil_tmp24;
#line 375
  __cil_tmp26 = _mm_subs_epu8(t_1, h);
#line 375
  t_3 = __cil_tmp26;
#line 375
  __cil_tmp28 = _mm_subs_epu8(t_2, h);
#line 375
  t_4 = __cil_tmp28;
#line 375
  not_hev = _mm_or_si128(t_3, t_4);
#line 375
  not_hev = _mm_cmpeq_epi8(not_hev, zero);
#line 378
  *p1 = _mm_xor_si128(*p1, sign_bit);
#line 378
  *p0 = _mm_xor_si128(*p0, sign_bit);
#line 378
  *q0 = _mm_xor_si128(*q0, sign_bit);
#line 378
  *q1 = _mm_xor_si128(*q1, sign_bit);
#line 380
  t1 = _mm_subs_epi8(*p1, *q1);
#line 381
  t1 = _mm_unpackhi_epi8(not_hev, t1);
#line 382
  t2 = _mm_subs_epi8(*q0, *p0);
#line 383
  t1 = _mm_adds_epi8(t1, t2);
#line 384
  t1 = _mm_adds_epi8(t1, t2);
#line 385
  t1 = _mm_adds_epi8(t1, t2);
#line 386
  t1 = _mm_and_si128(t1, *mask);
#line 389
  t2 = _mm_set1_epi8((char)4);
#line 390
  t2 = _mm_adds_epi8(t1, t2);
#line 391
  t = t2;
#line 391
  t = _mm_slli_epi16(t, 8);
#line 391
  t = _mm_srai_epi16(t, 3);
#line 391
  t = _mm_srli_epi16(t, 8);
#line 391
  t2 = _mm_srai_epi16(t2, 11);
#line 391
  t2 = _mm_slli_epi16(t2, 8);
#line 391
  t2 = _mm_or_si128(t, t2);
#line 392
  t3 = t2;
#line 393
  *q0 = _mm_subs_epi8(*q0, t2);
#line 396
  t2 = _mm_set1_epi8((char)3);
#line 397
  t2 = _mm_adds_epi8(t1, t2);
#line 398
  t___0 = t2;
#line 398
  t___0 = _mm_slli_epi16(t___0, 8);
#line 398
  t___0 = _mm_srai_epi16(t___0, 3);
#line 398
  t___0 = _mm_srli_epi16(t___0, 8);
#line 398
  t2 = _mm_srai_epi16(t2, 11);
#line 398
  t2 = _mm_slli_epi16(t2, 8);
#line 398
  t2 = _mm_or_si128(t___0, t2);
#line 399
  *p0 = _mm_adds_epi8(*p0, t2);
#line 401
  t2 = _mm_set1_epi8((char)1);
#line 402
  t3 = _mm_adds_epi8(t3, t2);
#line 403
  t___1 = t3;
#line 403
  t___1 = _mm_slli_epi16(t___1, 8);
#line 403
  t___1 = _mm_srai_epi16(t___1, 1);
#line 403
  t___1 = _mm_srli_epi16(t___1, 8);
#line 403
  t3 = _mm_srai_epi16(t3, 9);
#line 403
  t3 = _mm_slli_epi16(t3, 8);
#line 403
  t3 = _mm_or_si128(t___1, t3);
#line 405
  t3 = _mm_and_si128(not_hev, t3);
#line 406
  *q1 = _mm_subs_epi8(*q1, t3);
#line 407
  *p1 = _mm_adds_epi8(*p1, t3);
#line 410
  *p1 = _mm_xor_si128(*p1, sign_bit);
#line 410
  *p0 = _mm_xor_si128(*p0, sign_bit);
#line 410
  *q0 = _mm_xor_si128(*q0, sign_bit);
#line 410
  *q1 = _mm_xor_si128(*q1, sign_bit);
  }
#line 412
  return;
}
}
#line 414 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
__inline static void DoFilter6(__m128i *p2 , __m128i *p1 , __m128i *p0 , __m128i *q0 ,
                               __m128i *q1 , __m128i *q2 , __m128i *mask , int hev_thresh ) 
{ 
  __m128i a ;
  __m128i not_hev ;
  __m128i sign_bit ;
  __m128i __cil_tmp12 ;
  __m128i zero ;
  __m128i __cil_tmp14 ;
  __m128i t_1 ;
  __m128i __cil_tmp16 ;
  __m128i __cil_tmp17 ;
  __m128i __cil_tmp18 ;
  __m128i t_2 ;
  __m128i __cil_tmp20 ;
  __m128i __cil_tmp21 ;
  __m128i __cil_tmp22 ;
  __m128i h ;
  __m128i __cil_tmp24 ;
  __m128i t_3 ;
  __m128i __cil_tmp26 ;
  __m128i t_4 ;
  __m128i __cil_tmp28 ;
  __m128i qp0 ;
  __m128i __cil_tmp38 ;
  __m128i m ;
  __m128i __cil_tmp44 ;
  __m128i f ;
  __m128i __cil_tmp46 ;
  __m128i three ;
  __m128i __cil_tmp48 ;
  __m128i four ;
  __m128i __cil_tmp50 ;
  __m128i v3 ;
  __m128i __cil_tmp52 ;
  __m128i v4 ;
  __m128i __cil_tmp54 ;
  __m128i t ;
  __m128i t___0 ;
  __m128i zero___0 ;
  __m128i __cil_tmp72 ;
  __m128i nine ;
  __m128i __cil_tmp74 ;
  __m128i sixty_three ;
  __m128i __cil_tmp76 ;
  __m128i m___0 ;
  __m128i __cil_tmp78 ;
  __m128i f___0 ;
  __m128i __cil_tmp80 ;
  __m128i f_lo ;
  __m128i __cil_tmp82 ;
  __m128i f_hi ;
  __m128i __cil_tmp84 ;
  __m128i f9_lo ;
  __m128i __cil_tmp86 ;
  __m128i f9_hi ;
  __m128i __cil_tmp88 ;
  __m128i f18_lo ;
  __m128i __cil_tmp90 ;
  __m128i f18_hi ;
  __m128i __cil_tmp92 ;
  __m128i a2_lo ;
  __m128i __cil_tmp94 ;
  __m128i a2_hi ;
  __m128i __cil_tmp96 ;
  __m128i a1_lo ;
  __m128i __cil_tmp98 ;
  __m128i a1_hi ;
  __m128i __cil_tmp100 ;
  __m128i a0_lo ;
  __m128i __cil_tmp102 ;
  __m128i a0_hi ;
  __m128i __cil_tmp104 ;
  __m128i a_lo7 ;
  __m128i __cil_tmp106 ;
  __m128i a_hi7 ;
  __m128i __cil_tmp108 ;
  __m128i delta ;
  __m128i __cil_tmp110 ;
  __m128i a_lo7___0 ;
  __m128i __cil_tmp114 ;
  __m128i a_hi7___0 ;
  __m128i __cil_tmp116 ;
  __m128i delta___0 ;
  __m128i __cil_tmp118 ;
  __m128i a_lo7___1 ;
  __m128i __cil_tmp122 ;
  __m128i a_hi7___1 ;
  __m128i __cil_tmp124 ;
  __m128i delta___1 ;
  __m128i __cil_tmp126 ;

  {
  {
#line 418
  __cil_tmp12 = _mm_set1_epi8((char)-128);
#line 418
  sign_bit = __cil_tmp12;
#line 421
  __cil_tmp14 = _mm_setzero_si128();
#line 421
  zero = __cil_tmp14;
#line 421
  __cil_tmp16 = _mm_subs_epu8(*p0, *p1);
#line 421
  __cil_tmp17 = _mm_subs_epu8(*p1, *p0);
#line 421
  __cil_tmp18 = _mm_or_si128(__cil_tmp16, __cil_tmp17);
#line 421
  t_1 = __cil_tmp18;
#line 421
  __cil_tmp20 = _mm_subs_epu8(*q0, *q1);
#line 421
  __cil_tmp21 = _mm_subs_epu8(*q1, *q0);
#line 421
  __cil_tmp22 = _mm_or_si128(__cil_tmp20, __cil_tmp21);
#line 421
  t_2 = __cil_tmp22;
#line 421
  __cil_tmp24 = _mm_set1_epi8((char )hev_thresh);
#line 421
  h = __cil_tmp24;
#line 421
  __cil_tmp26 = _mm_subs_epu8(t_1, h);
#line 421
  t_3 = __cil_tmp26;
#line 421
  __cil_tmp28 = _mm_subs_epu8(t_2, h);
#line 421
  t_4 = __cil_tmp28;
#line 421
  not_hev = _mm_or_si128(t_3, t_4);
#line 421
  not_hev = _mm_cmpeq_epi8(not_hev, zero);
#line 424
  *p1 = _mm_xor_si128(*p1, sign_bit);
#line 424
  *p0 = _mm_xor_si128(*p0, sign_bit);
#line 424
  *q0 = _mm_xor_si128(*q0, sign_bit);
#line 424
  *q1 = _mm_xor_si128(*q1, sign_bit);
#line 425
  *p2 = _mm_xor_si128(*p2, sign_bit);
#line 425
  *q2 = _mm_xor_si128(*q2, sign_bit);
#line 427
  __cil_tmp38 = _mm_subs_epi8(*q0, *p0);
#line 427
  qp0 = __cil_tmp38;
#line 427
  a = _mm_subs_epi8(*p1, *q1);
#line 427
  a = _mm_adds_epi8(a, qp0);
#line 427
  a = _mm_adds_epi8(a, qp0);
#line 427
  a = _mm_adds_epi8(a, qp0);
#line 430
  __cil_tmp44 = _mm_unpackhi_epi8(not_hev, *mask);
#line 430
  m = __cil_tmp44;
#line 431
  __cil_tmp46 = _mm_and_si128(a, m);
#line 431
  f = __cil_tmp46;
#line 432
  __cil_tmp48 = _mm_set1_epi8((char)3);
#line 432
  three = __cil_tmp48;
#line 432
  __cil_tmp50 = _mm_set1_epi8((char)4);
#line 432
  four = __cil_tmp50;
#line 432
  __cil_tmp52 = _mm_adds_epi8(f, three);
#line 432
  v3 = __cil_tmp52;
#line 432
  __cil_tmp54 = _mm_adds_epi8(f, four);
#line 432
  v4 = __cil_tmp54;
#line 432
  t = v4;
#line 432
  t = _mm_slli_epi16(t, 8);
#line 432
  t = _mm_srai_epi16(t, 3);
#line 432
  t = _mm_srli_epi16(t, 8);
#line 432
  v4 = _mm_srai_epi16(v4, 11);
#line 432
  v4 = _mm_slli_epi16(v4, 8);
#line 432
  v4 = _mm_or_si128(t, v4);
#line 432
  *q0 = _mm_subs_epi8(*q0, v4);
#line 432
  t___0 = v3;
#line 432
  t___0 = _mm_slli_epi16(t___0, 8);
#line 432
  t___0 = _mm_srai_epi16(t___0, 3);
#line 432
  t___0 = _mm_srli_epi16(t___0, 8);
#line 432
  v3 = _mm_srai_epi16(v3, 11);
#line 432
  v3 = _mm_slli_epi16(v3, 8);
#line 432
  v3 = _mm_or_si128(t___0, v3);
#line 432
  *p0 = _mm_adds_epi8(*p0, v3);
#line 435
  __cil_tmp72 = _mm_setzero_si128();
#line 435
  zero___0 = __cil_tmp72;
#line 436
  __cil_tmp74 = _mm_set1_epi16((short)2304);
#line 436
  nine = __cil_tmp74;
#line 437
  __cil_tmp76 = _mm_set1_epi16((short)63);
#line 437
  sixty_three = __cil_tmp76;
#line 439
  __cil_tmp78 = _mm_and_si128(not_hev, *mask);
#line 439
  m___0 = __cil_tmp78;
#line 440
  __cil_tmp80 = _mm_and_si128(a, m___0);
#line 440
  f___0 = __cil_tmp80;
#line 441
  __cil_tmp82 = _mm_unpackhi_epi8(zero___0, f___0);
#line 441
  f_lo = __cil_tmp82;
#line 442
  __cil_tmp84 = _mm_unpackhi_epi8(zero___0, f___0);
#line 442
  f_hi = __cil_tmp84;
#line 444
  __cil_tmp86 = _mm_mulhi_epi16(f_lo, nine);
#line 444
  f9_lo = __cil_tmp86;
#line 445
  __cil_tmp88 = _mm_mulhi_epi16(f_hi, nine);
#line 445
  f9_hi = __cil_tmp88;
#line 446
  __cil_tmp90 = _mm_add_epi16(f9_lo, f9_lo);
#line 446
  f18_lo = __cil_tmp90;
#line 447
  __cil_tmp92 = _mm_add_epi16(f9_hi, f9_hi);
#line 447
  f18_hi = __cil_tmp92;
#line 449
  __cil_tmp94 = _mm_add_epi16(f9_lo, sixty_three);
#line 449
  a2_lo = __cil_tmp94;
#line 450
  __cil_tmp96 = _mm_add_epi16(f9_hi, sixty_three);
#line 450
  a2_hi = __cil_tmp96;
#line 452
  __cil_tmp98 = _mm_add_epi16(f18_lo, sixty_three);
#line 452
  a1_lo = __cil_tmp98;
#line 453
  __cil_tmp100 = _mm_add_epi16(f18_hi, sixty_three);
#line 453
  a1_hi = __cil_tmp100;
#line 455
  __cil_tmp102 = _mm_add_epi16(f18_lo, a2_lo);
#line 455
  a0_lo = __cil_tmp102;
#line 456
  __cil_tmp104 = _mm_add_epi16(f18_hi, a2_hi);
#line 456
  a0_hi = __cil_tmp104;
#line 458
  __cil_tmp106 = _mm_srai_epi16(a2_lo, 7);
#line 458
  a_lo7 = __cil_tmp106;
#line 458
  __cil_tmp108 = _mm_srai_epi16(a2_hi, 7);
#line 458
  a_hi7 = __cil_tmp108;
#line 458
  __cil_tmp110 = _mm_packs_epi16(a_lo7, a_hi7);
#line 458
  delta = __cil_tmp110;
#line 458
  *p2 = _mm_adds_epi8(*p2, delta);
#line 458
  *q2 = _mm_subs_epi8(*q2, delta);
#line 459
  __cil_tmp114 = _mm_srai_epi16(a1_lo, 7);
#line 459
  a_lo7___0 = __cil_tmp114;
#line 459
  __cil_tmp116 = _mm_srai_epi16(a1_hi, 7);
#line 459
  a_hi7___0 = __cil_tmp116;
#line 459
  __cil_tmp118 = _mm_packs_epi16(a_lo7___0, a_hi7___0);
#line 459
  delta___0 = __cil_tmp118;
#line 459
  *p1 = _mm_adds_epi8(*p1, delta___0);
#line 459
  *q1 = _mm_subs_epi8(*q1, delta___0);
#line 460
  __cil_tmp122 = _mm_srai_epi16(a0_lo, 7);
#line 460
  a_lo7___1 = __cil_tmp122;
#line 460
  __cil_tmp124 = _mm_srai_epi16(a0_hi, 7);
#line 460
  a_hi7___1 = __cil_tmp124;
#line 460
  __cil_tmp126 = _mm_packs_epi16(a_lo7___1, a_hi7___1);
#line 460
  delta___1 = __cil_tmp126;
#line 460
  *p0 = _mm_adds_epi8(*p0, delta___1);
#line 460
  *q0 = _mm_subs_epi8(*q0, delta___1);
#line 464
  *p1 = _mm_xor_si128(*p1, sign_bit);
#line 464
  *p0 = _mm_xor_si128(*p0, sign_bit);
#line 464
  *q0 = _mm_xor_si128(*q0, sign_bit);
#line 464
  *q1 = _mm_xor_si128(*q1, sign_bit);
#line 465
  *p2 = _mm_xor_si128(*p2, sign_bit);
#line 465
  *q2 = _mm_xor_si128(*q2, sign_bit);
  }
#line 467
  return;
}
}
#line 472 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
__inline static void Load8x4(uint8_t *b , int stride , __m128i *p , __m128i *q ) 
{ 
  __m128i t1 ;
  __m128i t2 ;
  __m128i r0 ;
  __m128i __cil_tmp8 ;
  __m128i r1 ;
  __m128i __cil_tmp10 ;
  __m128i r4 ;
  __m128i __cil_tmp12 ;
  __m128i r5 ;
  __m128i __cil_tmp14 ;

  {
  {
#line 477
  __cil_tmp8 = _mm_cvtsi32_si128(*((int *)(b + 0)));
#line 477
  r0 = __cil_tmp8;
#line 478
  __cil_tmp10 = _mm_cvtsi32_si128(*((int *)(b + stride)));
#line 478
  r1 = __cil_tmp10;
#line 479
  __cil_tmp12 = _mm_cvtsi32_si128(*((int *)(b + 4 * stride)));
#line 479
  r4 = __cil_tmp12;
#line 480
  __cil_tmp14 = _mm_cvtsi32_si128(*((int *)(b + 5 * stride)));
#line 480
  r5 = __cil_tmp14;
#line 482
  r0 = _mm_unpackhi_epi8(r0, r4);
#line 483
  r1 = _mm_unpackhi_epi8(r1, r5);
#line 486
  t1 = _mm_unpackhi_epi8(r0, r1);
#line 489
  r0 = _mm_cvtsi32_si128(*((int *)(b + 2 * stride)));
#line 490
  r1 = _mm_cvtsi32_si128(*((int *)(b + 3 * stride)));
#line 491
  r4 = _mm_cvtsi32_si128(*((int *)(b + 6 * stride)));
#line 492
  r5 = _mm_cvtsi32_si128(*((int *)(b + 7 * stride)));
#line 494
  r0 = _mm_unpackhi_epi8(r0, r4);
#line 495
  r1 = _mm_unpackhi_epi8(r1, r5);
#line 498
  t2 = _mm_unpackhi_epi8(r0, r1);
#line 502
  r0 = t1;
#line 503
  t1 = _mm_unpackhi_epi8(t1, t2);
#line 504
  t2 = _mm_unpackhi_epi8(r0, t2);
#line 508
  *p = _mm_unpackhi_epi8(t1, t2);
#line 509
  *q = _mm_unpackhi_epi8(t1, t2);
  }
#line 511
  return;
}
}
#line 512 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
__inline static void Load16x4(uint8_t *r0 , uint8_t *r8 , int stride , __m128i *p1 ,
                              __m128i *p0 , __m128i *q0 , __m128i *q1 ) 
{ 
  __m128i t1 ;
  __m128i t2 ;

  {
  {
#line 532
  Load8x4(r0, stride, p1, q0);
#line 533
  Load8x4(r8, stride, p0, q1);
#line 535
  t1 = *p1;
#line 536
  t2 = *q0;
#line 541
  *p1 = _mm_unpackhi_epi8(t1, *p0);
#line 542
  *p0 = _mm_unpackhi_epi8(t1, *p0);
#line 543
  *q0 = _mm_unpackhi_epi8(t2, *q1);
#line 544
  *q1 = _mm_unpackhi_epi8(t2, *q1);
  }
#line 546
  return;
}
}
#line 547 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
__inline static void Store4x4(__m128i *x , uint8_t *dst , int stride ) 
{ 
  int i ;

  {
#line 549
  i = 0;
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;

#line 549
    if (! (i < 4)) {
#line 549
      goto while_break;
    }
    {
#line 550
    *((int32_t *)dst) = _mm_cvtsi128_si32(*x);
#line 551
    *x = _mm_bsrli_si128(*x, 4);
#line 549
    dst += stride;
#line 549
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 553
  return;
}
}
#line 556 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
__inline static void Store16x4(uint8_t *r0 , uint8_t *r8 , int stride , __m128i *p1 ,
                               __m128i *p0 , __m128i *q0 , __m128i *q1 ) 
{ 
  __m128i t1 ;

  {
  {
#line 563
  t1 = *p0;
#line 564
  *p0 = _mm_unpackhi_epi8(*p1, t1);
#line 565
  *p1 = _mm_unpackhi_epi8(*p1, t1);
#line 569
  t1 = *q0;
#line 570
  *q0 = _mm_unpackhi_epi8(t1, *q1);
#line 571
  *q1 = _mm_unpackhi_epi8(t1, *q1);
#line 575
  t1 = *p0;
#line 576
  *p0 = _mm_unpackhi_epi8(t1, *q0);
#line 577
  *q0 = _mm_unpackhi_epi8(t1, *q0);
#line 581
  t1 = *p1;
#line 582
  *p1 = _mm_unpackhi_epi8(t1, *q1);
#line 583
  *q1 = _mm_unpackhi_epi8(t1, *q1);
#line 585
  Store4x4(p0, r0, stride);
#line 586
  r0 += 4 * stride;
#line 587
  Store4x4(q0, r0, stride);
#line 589
  Store4x4(p1, r8, stride);
#line 590
  r8 += 4 * stride;
#line 591
  Store4x4(q1, r8, stride);
  }
#line 593
  return;
}
}
#line 597 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void SimpleVFilter16SSE2(uint8_t *p , int stride , int thresh ) 
{ 
  __m128i p1 ;
  __m128i __cil_tmp5 ;
  __m128i p0 ;
  __m128i __cil_tmp7 ;
  __m128i q0 ;
  __m128i __cil_tmp9 ;
  __m128i q1 ;
  __m128i __cil_tmp11 ;

  {
  {
#line 599
  __cil_tmp5 = _mm_loadu_si128((__m128i *)(p + -2 * stride));
#line 599
  p1 = __cil_tmp5;
#line 600
  __cil_tmp7 = _mm_loadu_si128((__m128i *)(p + - stride));
#line 600
  p0 = __cil_tmp7;
#line 601
  __cil_tmp9 = _mm_loadu_si128((__m128i *)(p + 0));
#line 601
  q0 = __cil_tmp9;
#line 602
  __cil_tmp11 = _mm_loadu_si128((__m128i *)(p + stride));
#line 602
  q1 = __cil_tmp11;
#line 604
  DoFilter2(& p1, & p0, & q0, & q1, thresh);
#line 607
  _mm_storeu_si128((__m128i *)(p + - stride), p0);
#line 608
  _mm_storeu_si128((__m128i *)p, q0);
  }
#line 610
  return;
}
}
#line 611 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void SimpleHFilter16SSE2(uint8_t *p , int stride , int thresh ) 
{ 
  __m128i p1 ;
  __m128i p0 ;
  __m128i q0 ;
  __m128i q1 ;

  {
  {
#line 614
  p -= 2;
#line 616
  Load16x4(p, p + 8 * stride, stride, & p1, & p0, & q0, & q1);
#line 617
  DoFilter2(& p1, & p0, & q0, & q1, thresh);
#line 618
  Store16x4(p, p + 8 * stride, stride, & p1, & p0, & q0, & q1);
  }
#line 620
  return;
}
}
#line 621 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void SimpleVFilter16iSSE2(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 623
  k = 3;
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;

#line 623
    if (! (k > 0)) {
#line 623
      goto while_break;
    }
    {
#line 624
    p += 4 * stride;
#line 625
    SimpleVFilter16SSE2(p, stride, thresh);
#line 623
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 627
  return;
}
}
#line 629 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void SimpleHFilter16iSSE2(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 631
  k = 3;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;

#line 631
    if (! (k > 0)) {
#line 631
      goto while_break;
    }
    {
#line 632
    p += 4;
#line 633
    SimpleHFilter16SSE2(p, stride, thresh);
#line 631
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 635
  return;
}
}
#line 687 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void VFilter16SSE2(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  __m128i t1 ;
  __m128i mask ;
  __m128i p2 ;
  __m128i p1 ;
  __m128i p0 ;
  __m128i q0 ;
  __m128i q1 ;
  __m128i q2 ;
  __m128i __cil_tmp18 ;
  __m128i __cil_tmp19 ;
  __m128i __cil_tmp20 ;
  __m128i __cil_tmp21 ;
  __m128i __cil_tmp22 ;
  __m128i __cil_tmp23 ;
  __m128i __cil_tmp24 ;
  __m128i __cil_tmp25 ;
  __m128i __cil_tmp26 ;
  __m128i __cil_tmp27 ;
  __m128i __cil_tmp28 ;
  __m128i __cil_tmp33 ;
  __m128i __cil_tmp34 ;
  __m128i __cil_tmp35 ;
  __m128i __cil_tmp36 ;
  __m128i __cil_tmp37 ;
  __m128i __cil_tmp38 ;
  __m128i __cil_tmp39 ;
  __m128i __cil_tmp40 ;
  __m128i __cil_tmp41 ;
  __m128i __cil_tmp42 ;
  __m128i __cil_tmp43 ;
  __m128i __cil_tmp44 ;
  __m128i fl_yes ;
  __m128i it ;
  __m128i __cil_tmp47 ;
  __m128i __cil_tmp49 ;
  __m128i __cil_tmp50 ;

  {
  {
#line 694
  t1 = _mm_loadu_si128((__m128i *)((p - 4 * stride) + 0));
#line 694
  p2 = _mm_loadu_si128((__m128i *)((p - 4 * stride) + stride));
#line 694
  p1 = _mm_loadu_si128((__m128i *)((p - 4 * stride) + 2 * stride));
#line 694
  p0 = _mm_loadu_si128((__m128i *)((p - 4 * stride) + 3 * stride));
#line 695
  __cil_tmp18 = _mm_subs_epu8(p2, t1);
#line 695
  __cil_tmp19 = _mm_subs_epu8(t1, p2);
#line 695
  __cil_tmp20 = _mm_or_si128(__cil_tmp18, __cil_tmp19);
#line 695
  mask = __cil_tmp20;
#line 695
  __cil_tmp21 = _mm_subs_epu8(p1, p2);
#line 695
  __cil_tmp22 = _mm_subs_epu8(p2, p1);
#line 695
  __cil_tmp23 = _mm_or_si128(__cil_tmp21, __cil_tmp22);
#line 695
  __cil_tmp24 = _mm_max_epu8(mask, __cil_tmp23);
#line 695
  mask = __cil_tmp24;
#line 695
  __cil_tmp25 = _mm_subs_epu8(p0, p1);
#line 695
  __cil_tmp26 = _mm_subs_epu8(p1, p0);
#line 695
  __cil_tmp27 = _mm_or_si128(__cil_tmp25, __cil_tmp26);
#line 695
  __cil_tmp28 = _mm_max_epu8(mask, __cil_tmp27);
#line 695
  mask = __cil_tmp28;
#line 698
  q0 = _mm_loadu_si128((__m128i *)(p + 0));
#line 698
  q1 = _mm_loadu_si128((__m128i *)(p + stride));
#line 698
  q2 = _mm_loadu_si128((__m128i *)(p + 2 * stride));
#line 698
  t1 = _mm_loadu_si128((__m128i *)(p + 3 * stride));
#line 699
  __cil_tmp33 = _mm_subs_epu8(q2, t1);
#line 699
  __cil_tmp34 = _mm_subs_epu8(t1, q2);
#line 699
  __cil_tmp35 = _mm_or_si128(__cil_tmp33, __cil_tmp34);
#line 699
  __cil_tmp36 = _mm_max_epu8(mask, __cil_tmp35);
#line 699
  mask = __cil_tmp36;
#line 699
  __cil_tmp37 = _mm_subs_epu8(q1, q2);
#line 699
  __cil_tmp38 = _mm_subs_epu8(q2, q1);
#line 699
  __cil_tmp39 = _mm_or_si128(__cil_tmp37, __cil_tmp38);
#line 699
  __cil_tmp40 = _mm_max_epu8(mask, __cil_tmp39);
#line 699
  mask = __cil_tmp40;
#line 699
  __cil_tmp41 = _mm_subs_epu8(q0, q1);
#line 699
  __cil_tmp42 = _mm_subs_epu8(q1, q0);
#line 699
  __cil_tmp43 = _mm_or_si128(__cil_tmp41, __cil_tmp42);
#line 699
  __cil_tmp44 = _mm_max_epu8(mask, __cil_tmp43);
#line 699
  mask = __cil_tmp44;
#line 701
  __cil_tmp47 = _mm_set1_epi8((char )ithresh);
#line 701
  it = __cil_tmp47;
#line 701
  mask = _mm_subs_epu8(mask, it);
#line 701
  __cil_tmp49 = _mm_setzero_si128();
#line 701
  __cil_tmp50 = _mm_cmpeq_epi8(mask, __cil_tmp49);
#line 701
  mask = __cil_tmp50;
#line 701
  NeedsFilter(& p1, & p0, & q0, & q1, thresh, & fl_yes);
#line 701
  mask = _mm_and_si128(mask, fl_yes);
#line 702
  DoFilter6(& p2, & p1, & p0, & q0, & q1, & q2, & mask, hev_thresh);
#line 705
  _mm_storeu_si128((__m128i *)(p + -3 * stride), p2);
#line 706
  _mm_storeu_si128((__m128i *)(p + -2 * stride), p1);
#line 707
  _mm_storeu_si128((__m128i *)(p + -1 * stride), p0);
#line 708
  _mm_storeu_si128((__m128i *)(p + 0), q0);
#line 709
  _mm_storeu_si128((__m128i *)(p + stride), q1);
#line 710
  _mm_storeu_si128((__m128i *)(p + 2 * stride), q2);
  }
#line 712
  return;
}
}
#line 713 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void HFilter16SSE2(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  __m128i mask ;
  __m128i p3 ;
  __m128i p2 ;
  __m128i p1 ;
  __m128i p0 ;
  __m128i q0 ;
  __m128i q1 ;
  __m128i q2 ;
  __m128i q3 ;
  uint8_t *b ;
  __m128i __cil_tmp16 ;
  __m128i __cil_tmp17 ;
  __m128i __cil_tmp18 ;
  __m128i __cil_tmp19 ;
  __m128i __cil_tmp20 ;
  __m128i __cil_tmp21 ;
  __m128i __cil_tmp22 ;
  __m128i __cil_tmp23 ;
  __m128i __cil_tmp24 ;
  __m128i __cil_tmp25 ;
  __m128i __cil_tmp26 ;
  __m128i __cil_tmp27 ;
  __m128i __cil_tmp28 ;
  __m128i __cil_tmp29 ;
  __m128i __cil_tmp30 ;
  __m128i __cil_tmp31 ;
  __m128i __cil_tmp32 ;
  __m128i __cil_tmp33 ;
  __m128i __cil_tmp34 ;
  __m128i __cil_tmp35 ;
  __m128i __cil_tmp36 ;
  __m128i __cil_tmp37 ;
  __m128i __cil_tmp38 ;
  __m128i fl_yes ;
  __m128i it ;
  __m128i __cil_tmp41 ;
  __m128i __cil_tmp43 ;
  __m128i __cil_tmp44 ;

  {
  {
#line 718
  b = p - 4;
#line 719
  Load16x4(b, b + 8 * stride, stride, & p3, & p2, & p1, & p0);
#line 720
  __cil_tmp16 = _mm_subs_epu8(p2, p3);
#line 720
  __cil_tmp17 = _mm_subs_epu8(p3, p2);
#line 720
  __cil_tmp18 = _mm_or_si128(__cil_tmp16, __cil_tmp17);
#line 720
  mask = __cil_tmp18;
#line 720
  __cil_tmp19 = _mm_subs_epu8(p1, p2);
#line 720
  __cil_tmp20 = _mm_subs_epu8(p2, p1);
#line 720
  __cil_tmp21 = _mm_or_si128(__cil_tmp19, __cil_tmp20);
#line 720
  __cil_tmp22 = _mm_max_epu8(mask, __cil_tmp21);
#line 720
  mask = __cil_tmp22;
#line 720
  __cil_tmp23 = _mm_subs_epu8(p0, p1);
#line 720
  __cil_tmp24 = _mm_subs_epu8(p1, p0);
#line 720
  __cil_tmp25 = _mm_or_si128(__cil_tmp23, __cil_tmp24);
#line 720
  __cil_tmp26 = _mm_max_epu8(mask, __cil_tmp25);
#line 720
  mask = __cil_tmp26;
#line 722
  Load16x4(p, p + 8 * stride, stride, & q0, & q1, & q2, & q3);
#line 723
  __cil_tmp27 = _mm_subs_epu8(q2, q3);
#line 723
  __cil_tmp28 = _mm_subs_epu8(q3, q2);
#line 723
  __cil_tmp29 = _mm_or_si128(__cil_tmp27, __cil_tmp28);
#line 723
  __cil_tmp30 = _mm_max_epu8(mask, __cil_tmp29);
#line 723
  mask = __cil_tmp30;
#line 723
  __cil_tmp31 = _mm_subs_epu8(q1, q2);
#line 723
  __cil_tmp32 = _mm_subs_epu8(q2, q1);
#line 723
  __cil_tmp33 = _mm_or_si128(__cil_tmp31, __cil_tmp32);
#line 723
  __cil_tmp34 = _mm_max_epu8(mask, __cil_tmp33);
#line 723
  mask = __cil_tmp34;
#line 723
  __cil_tmp35 = _mm_subs_epu8(q0, q1);
#line 723
  __cil_tmp36 = _mm_subs_epu8(q1, q0);
#line 723
  __cil_tmp37 = _mm_or_si128(__cil_tmp35, __cil_tmp36);
#line 723
  __cil_tmp38 = _mm_max_epu8(mask, __cil_tmp37);
#line 723
  mask = __cil_tmp38;
#line 725
  __cil_tmp41 = _mm_set1_epi8((char )ithresh);
#line 725
  it = __cil_tmp41;
#line 725
  mask = _mm_subs_epu8(mask, it);
#line 725
  __cil_tmp43 = _mm_setzero_si128();
#line 725
  __cil_tmp44 = _mm_cmpeq_epi8(mask, __cil_tmp43);
#line 725
  mask = __cil_tmp44;
#line 725
  NeedsFilter(& p1, & p0, & q0, & q1, thresh, & fl_yes);
#line 725
  mask = _mm_and_si128(mask, fl_yes);
#line 726
  DoFilter6(& p2, & p1, & p0, & q0, & q1, & q2, & mask, hev_thresh);
#line 728
  Store16x4(b, b + 8 * stride, stride, & p3, & p2, & p1, & p0);
#line 729
  Store16x4(p, p + 8 * stride, stride, & q0, & q1, & q2, & q3);
  }
#line 731
  return;
}
}
#line 733 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void VFilter16iSSE2(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;
  __m128i mask ;
  __m128i t1 ;
  __m128i t2 ;
  __m128i p1 ;
  __m128i p0 ;
  __m128i q0 ;
  __m128i q1 ;
  __m128i __cil_tmp18 ;
  __m128i __cil_tmp19 ;
  __m128i __cil_tmp20 ;
  __m128i __cil_tmp21 ;
  __m128i __cil_tmp22 ;
  __m128i __cil_tmp23 ;
  __m128i __cil_tmp24 ;
  __m128i __cil_tmp25 ;
  __m128i __cil_tmp26 ;
  __m128i __cil_tmp27 ;
  __m128i __cil_tmp28 ;
  __m128i __cil_tmp33 ;
  __m128i __cil_tmp34 ;
  __m128i __cil_tmp35 ;
  __m128i __cil_tmp36 ;
  __m128i __cil_tmp37 ;
  __m128i __cil_tmp38 ;
  __m128i __cil_tmp39 ;
  __m128i __cil_tmp40 ;
  __m128i __cil_tmp41 ;
  __m128i __cil_tmp42 ;
  __m128i __cil_tmp43 ;
  __m128i __cil_tmp44 ;
  __m128i fl_yes ;
  __m128i it ;
  __m128i __cil_tmp47 ;
  __m128i __cil_tmp49 ;
  __m128i __cil_tmp50 ;

  {
#line 739
  k = 3;
  {
#line 739
  while (1) {
    while_continue: /* CIL Label */ ;

#line 739
    if (! (k > 0)) {
#line 739
      goto while_break;
    }
    {
#line 741
    t2 = _mm_loadu_si128((__m128i *)(p + 0));
#line 741
    t1 = _mm_loadu_si128((__m128i *)(p + stride));
#line 741
    p1 = _mm_loadu_si128((__m128i *)(p + 2 * stride));
#line 741
    p0 = _mm_loadu_si128((__m128i *)(p + 3 * stride));
#line 742
    __cil_tmp18 = _mm_subs_epu8(t1, t2);
#line 742
    __cil_tmp19 = _mm_subs_epu8(t2, t1);
#line 742
    __cil_tmp20 = _mm_or_si128(__cil_tmp18, __cil_tmp19);
#line 742
    mask = __cil_tmp20;
#line 742
    __cil_tmp21 = _mm_subs_epu8(p1, t1);
#line 742
    __cil_tmp22 = _mm_subs_epu8(t1, p1);
#line 742
    __cil_tmp23 = _mm_or_si128(__cil_tmp21, __cil_tmp22);
#line 742
    __cil_tmp24 = _mm_max_epu8(mask, __cil_tmp23);
#line 742
    mask = __cil_tmp24;
#line 742
    __cil_tmp25 = _mm_subs_epu8(p0, p1);
#line 742
    __cil_tmp26 = _mm_subs_epu8(p1, p0);
#line 742
    __cil_tmp27 = _mm_or_si128(__cil_tmp25, __cil_tmp26);
#line 742
    __cil_tmp28 = _mm_max_epu8(mask, __cil_tmp27);
#line 742
    mask = __cil_tmp28;
#line 744
    p += 4 * stride;
#line 747
    q0 = _mm_loadu_si128((__m128i *)(p + 0));
#line 747
    q1 = _mm_loadu_si128((__m128i *)(p + stride));
#line 747
    t1 = _mm_loadu_si128((__m128i *)(p + 2 * stride));
#line 747
    t2 = _mm_loadu_si128((__m128i *)(p + 3 * stride));
#line 748
    __cil_tmp33 = _mm_subs_epu8(t1, t2);
#line 748
    __cil_tmp34 = _mm_subs_epu8(t2, t1);
#line 748
    __cil_tmp35 = _mm_or_si128(__cil_tmp33, __cil_tmp34);
#line 748
    __cil_tmp36 = _mm_max_epu8(mask, __cil_tmp35);
#line 748
    mask = __cil_tmp36;
#line 748
    __cil_tmp37 = _mm_subs_epu8(q1, t1);
#line 748
    __cil_tmp38 = _mm_subs_epu8(t1, q1);
#line 748
    __cil_tmp39 = _mm_or_si128(__cil_tmp37, __cil_tmp38);
#line 748
    __cil_tmp40 = _mm_max_epu8(mask, __cil_tmp39);
#line 748
    mask = __cil_tmp40;
#line 748
    __cil_tmp41 = _mm_subs_epu8(q0, q1);
#line 748
    __cil_tmp42 = _mm_subs_epu8(q1, q0);
#line 748
    __cil_tmp43 = _mm_or_si128(__cil_tmp41, __cil_tmp42);
#line 748
    __cil_tmp44 = _mm_max_epu8(mask, __cil_tmp43);
#line 748
    mask = __cil_tmp44;
#line 750
    __cil_tmp47 = _mm_set1_epi8((char )ithresh);
#line 750
    it = __cil_tmp47;
#line 750
    mask = _mm_subs_epu8(mask, it);
#line 750
    __cil_tmp49 = _mm_setzero_si128();
#line 750
    __cil_tmp50 = _mm_cmpeq_epi8(mask, __cil_tmp49);
#line 750
    mask = __cil_tmp50;
#line 750
    NeedsFilter(& p1, & p0, & q0, & q1, thresh, & fl_yes);
#line 750
    mask = _mm_and_si128(mask, fl_yes);
#line 751
    DoFilter4(& p1, & p0, & q0, & q1, & mask, hev_thresh);
#line 754
    _mm_storeu_si128((__m128i *)(p + -2 * stride), p1);
#line 755
    _mm_storeu_si128((__m128i *)(p + -1 * stride), p0);
#line 756
    _mm_storeu_si128((__m128i *)(p + 0), q0);
#line 757
    _mm_storeu_si128((__m128i *)(p + stride), q1);
#line 739
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 743
  return;
}
}
#line 761 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void HFilter16iSSE2(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;
  uint8_t *b ;
  __m128i mask ;
  __m128i t1 ;
  __m128i t2 ;
  __m128i p1 ;
  __m128i p0 ;
  __m128i q0 ;
  __m128i q1 ;
  __m128i __cil_tmp15 ;
  __m128i __cil_tmp16 ;
  __m128i __cil_tmp17 ;
  __m128i __cil_tmp18 ;
  __m128i __cil_tmp19 ;
  __m128i __cil_tmp20 ;
  __m128i __cil_tmp21 ;
  __m128i __cil_tmp22 ;
  __m128i __cil_tmp23 ;
  __m128i __cil_tmp24 ;
  __m128i __cil_tmp25 ;
  __m128i __cil_tmp26 ;
  __m128i __cil_tmp27 ;
  __m128i __cil_tmp28 ;
  __m128i __cil_tmp29 ;
  __m128i __cil_tmp30 ;
  __m128i __cil_tmp31 ;
  __m128i __cil_tmp32 ;
  __m128i __cil_tmp33 ;
  __m128i __cil_tmp34 ;
  __m128i __cil_tmp35 ;
  __m128i __cil_tmp36 ;
  __m128i __cil_tmp37 ;
  __m128i fl_yes ;
  __m128i it ;
  __m128i __cil_tmp40 ;
  __m128i __cil_tmp42 ;
  __m128i __cil_tmp43 ;

  {
#line 768
  k = 3;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;

#line 768
    if (! (k > 0)) {
#line 768
      goto while_break;
    }
    {
#line 769
    b = p;
#line 770
    Load16x4(b, b + 8 * stride, stride, & t2, & t1, & p1, & p0);
#line 771
    __cil_tmp15 = _mm_subs_epu8(t1, t2);
#line 771
    __cil_tmp16 = _mm_subs_epu8(t2, t1);
#line 771
    __cil_tmp17 = _mm_or_si128(__cil_tmp15, __cil_tmp16);
#line 771
    mask = __cil_tmp17;
#line 771
    __cil_tmp18 = _mm_subs_epu8(p1, t1);
#line 771
    __cil_tmp19 = _mm_subs_epu8(t1, p1);
#line 771
    __cil_tmp20 = _mm_or_si128(__cil_tmp18, __cil_tmp19);
#line 771
    __cil_tmp21 = _mm_max_epu8(mask, __cil_tmp20);
#line 771
    mask = __cil_tmp21;
#line 771
    __cil_tmp22 = _mm_subs_epu8(p0, p1);
#line 771
    __cil_tmp23 = _mm_subs_epu8(p1, p0);
#line 771
    __cil_tmp24 = _mm_or_si128(__cil_tmp22, __cil_tmp23);
#line 771
    __cil_tmp25 = _mm_max_epu8(mask, __cil_tmp24);
#line 771
    mask = __cil_tmp25;
#line 773
    b += 4;
#line 774
    Load16x4(b, b + 8 * stride, stride, & q0, & q1, & t1, & t2);
#line 775
    __cil_tmp26 = _mm_subs_epu8(t1, t2);
#line 775
    __cil_tmp27 = _mm_subs_epu8(t2, t1);
#line 775
    __cil_tmp28 = _mm_or_si128(__cil_tmp26, __cil_tmp27);
#line 775
    __cil_tmp29 = _mm_max_epu8(mask, __cil_tmp28);
#line 775
    mask = __cil_tmp29;
#line 775
    __cil_tmp30 = _mm_subs_epu8(q1, t1);
#line 775
    __cil_tmp31 = _mm_subs_epu8(t1, q1);
#line 775
    __cil_tmp32 = _mm_or_si128(__cil_tmp30, __cil_tmp31);
#line 775
    __cil_tmp33 = _mm_max_epu8(mask, __cil_tmp32);
#line 775
    mask = __cil_tmp33;
#line 775
    __cil_tmp34 = _mm_subs_epu8(q0, q1);
#line 775
    __cil_tmp35 = _mm_subs_epu8(q1, q0);
#line 775
    __cil_tmp36 = _mm_or_si128(__cil_tmp34, __cil_tmp35);
#line 775
    __cil_tmp37 = _mm_max_epu8(mask, __cil_tmp36);
#line 775
    mask = __cil_tmp37;
#line 777
    __cil_tmp40 = _mm_set1_epi8((char )ithresh);
#line 777
    it = __cil_tmp40;
#line 777
    mask = _mm_subs_epu8(mask, it);
#line 777
    __cil_tmp42 = _mm_setzero_si128();
#line 777
    __cil_tmp43 = _mm_cmpeq_epi8(mask, __cil_tmp42);
#line 777
    mask = __cil_tmp43;
#line 777
    NeedsFilter(& p1, & p0, & q0, & q1, thresh, & fl_yes);
#line 777
    mask = _mm_and_si128(mask, fl_yes);
#line 778
    DoFilter4(& p1, & p0, & q0, & q1, & mask, hev_thresh);
#line 780
    b -= 2;
#line 781
    Store16x4(b, b + 8 * stride, stride, & p1, & p0, & q0, & q1);
#line 783
    p += 4;
#line 768
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 772
  return;
}
}
#line 788 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void VFilter8SSE2(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                         int hev_thresh ) 
{ 
  __m128i mask ;
  __m128i t1 ;
  __m128i p2 ;
  __m128i p1 ;
  __m128i p0 ;
  __m128i q0 ;
  __m128i q1 ;
  __m128i q2 ;
  __m128i __cil_tmp16 ;
  __m128i __cil_tmp17 ;
  __m128i __cil_tmp19 ;
  __m128i __cil_tmp20 ;
  __m128i __cil_tmp22 ;
  __m128i __cil_tmp23 ;
  __m128i __cil_tmp25 ;
  __m128i __cil_tmp26 ;
  __m128i __cil_tmp27 ;
  __m128i __cil_tmp28 ;
  __m128i __cil_tmp29 ;
  __m128i __cil_tmp30 ;
  __m128i __cil_tmp31 ;
  __m128i __cil_tmp32 ;
  __m128i __cil_tmp33 ;
  __m128i __cil_tmp34 ;
  __m128i __cil_tmp35 ;
  __m128i __cil_tmp36 ;
  __m128i __cil_tmp37 ;
  __m128i __cil_tmp39 ;
  __m128i __cil_tmp40 ;
  __m128i __cil_tmp42 ;
  __m128i __cil_tmp43 ;
  __m128i __cil_tmp45 ;
  __m128i __cil_tmp46 ;
  __m128i __cil_tmp48 ;
  __m128i __cil_tmp49 ;
  __m128i __cil_tmp50 ;
  __m128i __cil_tmp51 ;
  __m128i __cil_tmp52 ;
  __m128i __cil_tmp53 ;
  __m128i __cil_tmp54 ;
  __m128i __cil_tmp55 ;
  __m128i __cil_tmp56 ;
  __m128i __cil_tmp57 ;
  __m128i __cil_tmp58 ;
  __m128i __cil_tmp59 ;
  __m128i __cil_tmp60 ;
  __m128i __cil_tmp61 ;
  __m128i fl_yes ;
  __m128i it ;
  __m128i __cil_tmp64 ;
  __m128i __cil_tmp66 ;
  __m128i __cil_tmp67 ;

  {
  {
#line 794
  t1 = _mm_loadl_epi64((__m128i *)((u - 4 * stride) + 0));
#line 794
  __cil_tmp16 = _mm_loadl_epi64((__m128i *)((v - 4 * stride) + 0));
#line 794
  __cil_tmp17 = _mm_unpackhi_epi8(t1, __cil_tmp16);
#line 794
  t1 = __cil_tmp17;
#line 794
  p2 = _mm_loadl_epi64((__m128i *)((u - 4 * stride) + stride));
#line 794
  __cil_tmp19 = _mm_loadl_epi64((__m128i *)((v - 4 * stride) + stride));
#line 794
  __cil_tmp20 = _mm_unpackhi_epi8(p2, __cil_tmp19);
#line 794
  p2 = __cil_tmp20;
#line 794
  p1 = _mm_loadl_epi64((__m128i *)((u - 4 * stride) + 2 * stride));
#line 794
  __cil_tmp22 = _mm_loadl_epi64((__m128i *)((v - 4 * stride) + 2 * stride));
#line 794
  __cil_tmp23 = _mm_unpackhi_epi8(p1, __cil_tmp22);
#line 794
  p1 = __cil_tmp23;
#line 794
  p0 = _mm_loadl_epi64((__m128i *)((u - 4 * stride) + 3 * stride));
#line 794
  __cil_tmp25 = _mm_loadl_epi64((__m128i *)((v - 4 * stride) + 3 * stride));
#line 794
  __cil_tmp26 = _mm_unpackhi_epi8(p0, __cil_tmp25);
#line 794
  p0 = __cil_tmp26;
#line 795
  __cil_tmp27 = _mm_subs_epu8(p2, t1);
#line 795
  __cil_tmp28 = _mm_subs_epu8(t1, p2);
#line 795
  __cil_tmp29 = _mm_or_si128(__cil_tmp27, __cil_tmp28);
#line 795
  mask = __cil_tmp29;
#line 795
  __cil_tmp30 = _mm_subs_epu8(p1, p2);
#line 795
  __cil_tmp31 = _mm_subs_epu8(p2, p1);
#line 795
  __cil_tmp32 = _mm_or_si128(__cil_tmp30, __cil_tmp31);
#line 795
  __cil_tmp33 = _mm_max_epu8(mask, __cil_tmp32);
#line 795
  mask = __cil_tmp33;
#line 795
  __cil_tmp34 = _mm_subs_epu8(p0, p1);
#line 795
  __cil_tmp35 = _mm_subs_epu8(p1, p0);
#line 795
  __cil_tmp36 = _mm_or_si128(__cil_tmp34, __cil_tmp35);
#line 795
  __cil_tmp37 = _mm_max_epu8(mask, __cil_tmp36);
#line 795
  mask = __cil_tmp37;
#line 798
  q0 = _mm_loadl_epi64((__m128i *)(u + 0));
#line 798
  __cil_tmp39 = _mm_loadl_epi64((__m128i *)(v + 0));
#line 798
  __cil_tmp40 = _mm_unpackhi_epi8(q0, __cil_tmp39);
#line 798
  q0 = __cil_tmp40;
#line 798
  q1 = _mm_loadl_epi64((__m128i *)(u + stride));
#line 798
  __cil_tmp42 = _mm_loadl_epi64((__m128i *)(v + stride));
#line 798
  __cil_tmp43 = _mm_unpackhi_epi8(q1, __cil_tmp42);
#line 798
  q1 = __cil_tmp43;
#line 798
  q2 = _mm_loadl_epi64((__m128i *)(u + 2 * stride));
#line 798
  __cil_tmp45 = _mm_loadl_epi64((__m128i *)(v + 2 * stride));
#line 798
  __cil_tmp46 = _mm_unpackhi_epi8(q2, __cil_tmp45);
#line 798
  q2 = __cil_tmp46;
#line 798
  t1 = _mm_loadl_epi64((__m128i *)(u + 3 * stride));
#line 798
  __cil_tmp48 = _mm_loadl_epi64((__m128i *)(v + 3 * stride));
#line 798
  __cil_tmp49 = _mm_unpackhi_epi8(t1, __cil_tmp48);
#line 798
  t1 = __cil_tmp49;
#line 799
  __cil_tmp50 = _mm_subs_epu8(q2, t1);
#line 799
  __cil_tmp51 = _mm_subs_epu8(t1, q2);
#line 799
  __cil_tmp52 = _mm_or_si128(__cil_tmp50, __cil_tmp51);
#line 799
  __cil_tmp53 = _mm_max_epu8(mask, __cil_tmp52);
#line 799
  mask = __cil_tmp53;
#line 799
  __cil_tmp54 = _mm_subs_epu8(q1, q2);
#line 799
  __cil_tmp55 = _mm_subs_epu8(q2, q1);
#line 799
  __cil_tmp56 = _mm_or_si128(__cil_tmp54, __cil_tmp55);
#line 799
  __cil_tmp57 = _mm_max_epu8(mask, __cil_tmp56);
#line 799
  mask = __cil_tmp57;
#line 799
  __cil_tmp58 = _mm_subs_epu8(q0, q1);
#line 799
  __cil_tmp59 = _mm_subs_epu8(q1, q0);
#line 799
  __cil_tmp60 = _mm_or_si128(__cil_tmp58, __cil_tmp59);
#line 799
  __cil_tmp61 = _mm_max_epu8(mask, __cil_tmp60);
#line 799
  mask = __cil_tmp61;
#line 801
  __cil_tmp64 = _mm_set1_epi8((char )ithresh);
#line 801
  it = __cil_tmp64;
#line 801
  mask = _mm_subs_epu8(mask, it);
#line 801
  __cil_tmp66 = _mm_setzero_si128();
#line 801
  __cil_tmp67 = _mm_cmpeq_epi8(mask, __cil_tmp66);
#line 801
  mask = __cil_tmp67;
#line 801
  NeedsFilter(& p1, & p0, & q0, & q1, thresh, & fl_yes);
#line 801
  mask = _mm_and_si128(mask, fl_yes);
#line 802
  DoFilter6(& p2, & p1, & p0, & q0, & q1, & q2, & mask, hev_thresh);
#line 805
  _mm_storel_epi64((__m128i *)(u + -3 * stride), p2);
#line 805
  p2 = _mm_bsrli_si128(p2, 8);
#line 805
  _mm_storel_epi64((__m128i *)(v + -3 * stride), p2);
#line 806
  _mm_storel_epi64((__m128i *)(u + -2 * stride), p1);
#line 806
  p1 = _mm_bsrli_si128(p1, 8);
#line 806
  _mm_storel_epi64((__m128i *)(v + -2 * stride), p1);
#line 807
  _mm_storel_epi64((__m128i *)(u + -1 * stride), p0);
#line 807
  p0 = _mm_bsrli_si128(p0, 8);
#line 807
  _mm_storel_epi64((__m128i *)(v + -1 * stride), p0);
#line 808
  _mm_storel_epi64((__m128i *)(u + 0), q0);
#line 808
  q0 = _mm_bsrli_si128(q0, 8);
#line 808
  _mm_storel_epi64((__m128i *)(v + 0), q0);
#line 809
  _mm_storel_epi64((__m128i *)(u + stride), q1);
#line 809
  q1 = _mm_bsrli_si128(q1, 8);
#line 809
  _mm_storel_epi64((__m128i *)(v + stride), q1);
#line 810
  _mm_storel_epi64((__m128i *)(u + 2 * stride), q2);
#line 810
  q2 = _mm_bsrli_si128(q2, 8);
#line 810
  _mm_storel_epi64((__m128i *)(v + 2 * stride), q2);
  }
#line 812
  return;
}
}
#line 813 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void HFilter8SSE2(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                         int hev_thresh ) 
{ 
  __m128i mask ;
  __m128i p3 ;
  __m128i p2 ;
  __m128i p1 ;
  __m128i p0 ;
  __m128i q0 ;
  __m128i q1 ;
  __m128i q2 ;
  __m128i q3 ;
  uint8_t *tu ;
  uint8_t *tv ;
  __m128i __cil_tmp18 ;
  __m128i __cil_tmp19 ;
  __m128i __cil_tmp20 ;
  __m128i __cil_tmp21 ;
  __m128i __cil_tmp22 ;
  __m128i __cil_tmp23 ;
  __m128i __cil_tmp24 ;
  __m128i __cil_tmp25 ;
  __m128i __cil_tmp26 ;
  __m128i __cil_tmp27 ;
  __m128i __cil_tmp28 ;
  __m128i __cil_tmp29 ;
  __m128i __cil_tmp30 ;
  __m128i __cil_tmp31 ;
  __m128i __cil_tmp32 ;
  __m128i __cil_tmp33 ;
  __m128i __cil_tmp34 ;
  __m128i __cil_tmp35 ;
  __m128i __cil_tmp36 ;
  __m128i __cil_tmp37 ;
  __m128i __cil_tmp38 ;
  __m128i __cil_tmp39 ;
  __m128i __cil_tmp40 ;
  __m128i fl_yes ;
  __m128i it ;
  __m128i __cil_tmp43 ;
  __m128i __cil_tmp45 ;
  __m128i __cil_tmp46 ;

  {
  {
#line 818
  tu = u - 4;
#line 819
  tv = v - 4;
#line 820
  Load16x4(tu, tv, stride, & p3, & p2, & p1, & p0);
#line 821
  __cil_tmp18 = _mm_subs_epu8(p2, p3);
#line 821
  __cil_tmp19 = _mm_subs_epu8(p3, p2);
#line 821
  __cil_tmp20 = _mm_or_si128(__cil_tmp18, __cil_tmp19);
#line 821
  mask = __cil_tmp20;
#line 821
  __cil_tmp21 = _mm_subs_epu8(p1, p2);
#line 821
  __cil_tmp22 = _mm_subs_epu8(p2, p1);
#line 821
  __cil_tmp23 = _mm_or_si128(__cil_tmp21, __cil_tmp22);
#line 821
  __cil_tmp24 = _mm_max_epu8(mask, __cil_tmp23);
#line 821
  mask = __cil_tmp24;
#line 821
  __cil_tmp25 = _mm_subs_epu8(p0, p1);
#line 821
  __cil_tmp26 = _mm_subs_epu8(p1, p0);
#line 821
  __cil_tmp27 = _mm_or_si128(__cil_tmp25, __cil_tmp26);
#line 821
  __cil_tmp28 = _mm_max_epu8(mask, __cil_tmp27);
#line 821
  mask = __cil_tmp28;
#line 823
  Load16x4(u, v, stride, & q0, & q1, & q2, & q3);
#line 824
  __cil_tmp29 = _mm_subs_epu8(q2, q3);
#line 824
  __cil_tmp30 = _mm_subs_epu8(q3, q2);
#line 824
  __cil_tmp31 = _mm_or_si128(__cil_tmp29, __cil_tmp30);
#line 824
  __cil_tmp32 = _mm_max_epu8(mask, __cil_tmp31);
#line 824
  mask = __cil_tmp32;
#line 824
  __cil_tmp33 = _mm_subs_epu8(q1, q2);
#line 824
  __cil_tmp34 = _mm_subs_epu8(q2, q1);
#line 824
  __cil_tmp35 = _mm_or_si128(__cil_tmp33, __cil_tmp34);
#line 824
  __cil_tmp36 = _mm_max_epu8(mask, __cil_tmp35);
#line 824
  mask = __cil_tmp36;
#line 824
  __cil_tmp37 = _mm_subs_epu8(q0, q1);
#line 824
  __cil_tmp38 = _mm_subs_epu8(q1, q0);
#line 824
  __cil_tmp39 = _mm_or_si128(__cil_tmp37, __cil_tmp38);
#line 824
  __cil_tmp40 = _mm_max_epu8(mask, __cil_tmp39);
#line 824
  mask = __cil_tmp40;
#line 826
  __cil_tmp43 = _mm_set1_epi8((char )ithresh);
#line 826
  it = __cil_tmp43;
#line 826
  mask = _mm_subs_epu8(mask, it);
#line 826
  __cil_tmp45 = _mm_setzero_si128();
#line 826
  __cil_tmp46 = _mm_cmpeq_epi8(mask, __cil_tmp45);
#line 826
  mask = __cil_tmp46;
#line 826
  NeedsFilter(& p1, & p0, & q0, & q1, thresh, & fl_yes);
#line 826
  mask = _mm_and_si128(mask, fl_yes);
#line 827
  DoFilter6(& p2, & p1, & p0, & q0, & q1, & q2, & mask, hev_thresh);
#line 829
  Store16x4(tu, tv, stride, & p3, & p2, & p1, & p0);
#line 830
  Store16x4(u, v, stride, & q0, & q1, & q2, & q3);
  }
#line 832
  return;
}
}
#line 833 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void VFilter8iSSE2(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                          int hev_thresh ) 
{ 
  __m128i mask ;
  __m128i t1 ;
  __m128i t2 ;
  __m128i p1 ;
  __m128i p0 ;
  __m128i q0 ;
  __m128i q1 ;
  __m128i __cil_tmp15 ;
  __m128i __cil_tmp16 ;
  __m128i __cil_tmp18 ;
  __m128i __cil_tmp19 ;
  __m128i __cil_tmp21 ;
  __m128i __cil_tmp22 ;
  __m128i __cil_tmp24 ;
  __m128i __cil_tmp25 ;
  __m128i __cil_tmp26 ;
  __m128i __cil_tmp27 ;
  __m128i __cil_tmp28 ;
  __m128i __cil_tmp29 ;
  __m128i __cil_tmp30 ;
  __m128i __cil_tmp31 ;
  __m128i __cil_tmp32 ;
  __m128i __cil_tmp33 ;
  __m128i __cil_tmp34 ;
  __m128i __cil_tmp35 ;
  __m128i __cil_tmp36 ;
  __m128i __cil_tmp38 ;
  __m128i __cil_tmp39 ;
  __m128i __cil_tmp41 ;
  __m128i __cil_tmp42 ;
  __m128i __cil_tmp44 ;
  __m128i __cil_tmp45 ;
  __m128i __cil_tmp47 ;
  __m128i __cil_tmp48 ;
  __m128i __cil_tmp49 ;
  __m128i __cil_tmp50 ;
  __m128i __cil_tmp51 ;
  __m128i __cil_tmp52 ;
  __m128i __cil_tmp53 ;
  __m128i __cil_tmp54 ;
  __m128i __cil_tmp55 ;
  __m128i __cil_tmp56 ;
  __m128i __cil_tmp57 ;
  __m128i __cil_tmp58 ;
  __m128i __cil_tmp59 ;
  __m128i __cil_tmp60 ;
  __m128i fl_yes ;
  __m128i it ;
  __m128i __cil_tmp63 ;
  __m128i __cil_tmp65 ;
  __m128i __cil_tmp66 ;

  {
  {
#line 839
  t2 = _mm_loadl_epi64((__m128i *)(u + 0));
#line 839
  __cil_tmp15 = _mm_loadl_epi64((__m128i *)(v + 0));
#line 839
  __cil_tmp16 = _mm_unpackhi_epi8(t2, __cil_tmp15);
#line 839
  t2 = __cil_tmp16;
#line 839
  t1 = _mm_loadl_epi64((__m128i *)(u + stride));
#line 839
  __cil_tmp18 = _mm_loadl_epi64((__m128i *)(v + stride));
#line 839
  __cil_tmp19 = _mm_unpackhi_epi8(t1, __cil_tmp18);
#line 839
  t1 = __cil_tmp19;
#line 839
  p1 = _mm_loadl_epi64((__m128i *)(u + 2 * stride));
#line 839
  __cil_tmp21 = _mm_loadl_epi64((__m128i *)(v + 2 * stride));
#line 839
  __cil_tmp22 = _mm_unpackhi_epi8(p1, __cil_tmp21);
#line 839
  p1 = __cil_tmp22;
#line 839
  p0 = _mm_loadl_epi64((__m128i *)(u + 3 * stride));
#line 839
  __cil_tmp24 = _mm_loadl_epi64((__m128i *)(v + 3 * stride));
#line 839
  __cil_tmp25 = _mm_unpackhi_epi8(p0, __cil_tmp24);
#line 839
  p0 = __cil_tmp25;
#line 840
  __cil_tmp26 = _mm_subs_epu8(t1, t2);
#line 840
  __cil_tmp27 = _mm_subs_epu8(t2, t1);
#line 840
  __cil_tmp28 = _mm_or_si128(__cil_tmp26, __cil_tmp27);
#line 840
  mask = __cil_tmp28;
#line 840
  __cil_tmp29 = _mm_subs_epu8(p1, t1);
#line 840
  __cil_tmp30 = _mm_subs_epu8(t1, p1);
#line 840
  __cil_tmp31 = _mm_or_si128(__cil_tmp29, __cil_tmp30);
#line 840
  __cil_tmp32 = _mm_max_epu8(mask, __cil_tmp31);
#line 840
  mask = __cil_tmp32;
#line 840
  __cil_tmp33 = _mm_subs_epu8(p0, p1);
#line 840
  __cil_tmp34 = _mm_subs_epu8(p1, p0);
#line 840
  __cil_tmp35 = _mm_or_si128(__cil_tmp33, __cil_tmp34);
#line 840
  __cil_tmp36 = _mm_max_epu8(mask, __cil_tmp35);
#line 840
  mask = __cil_tmp36;
#line 842
  u += 4 * stride;
#line 843
  v += 4 * stride;
#line 846
  q0 = _mm_loadl_epi64((__m128i *)(u + 0));
#line 846
  __cil_tmp38 = _mm_loadl_epi64((__m128i *)(v + 0));
#line 846
  __cil_tmp39 = _mm_unpackhi_epi8(q0, __cil_tmp38);
#line 846
  q0 = __cil_tmp39;
#line 846
  q1 = _mm_loadl_epi64((__m128i *)(u + stride));
#line 846
  __cil_tmp41 = _mm_loadl_epi64((__m128i *)(v + stride));
#line 846
  __cil_tmp42 = _mm_unpackhi_epi8(q1, __cil_tmp41);
#line 846
  q1 = __cil_tmp42;
#line 846
  t1 = _mm_loadl_epi64((__m128i *)(u + 2 * stride));
#line 846
  __cil_tmp44 = _mm_loadl_epi64((__m128i *)(v + 2 * stride));
#line 846
  __cil_tmp45 = _mm_unpackhi_epi8(t1, __cil_tmp44);
#line 846
  t1 = __cil_tmp45;
#line 846
  t2 = _mm_loadl_epi64((__m128i *)(u + 3 * stride));
#line 846
  __cil_tmp47 = _mm_loadl_epi64((__m128i *)(v + 3 * stride));
#line 846
  __cil_tmp48 = _mm_unpackhi_epi8(t2, __cil_tmp47);
#line 846
  t2 = __cil_tmp48;
#line 847
  __cil_tmp49 = _mm_subs_epu8(t1, t2);
#line 847
  __cil_tmp50 = _mm_subs_epu8(t2, t1);
#line 847
  __cil_tmp51 = _mm_or_si128(__cil_tmp49, __cil_tmp50);
#line 847
  __cil_tmp52 = _mm_max_epu8(mask, __cil_tmp51);
#line 847
  mask = __cil_tmp52;
#line 847
  __cil_tmp53 = _mm_subs_epu8(q1, t1);
#line 847
  __cil_tmp54 = _mm_subs_epu8(t1, q1);
#line 847
  __cil_tmp55 = _mm_or_si128(__cil_tmp53, __cil_tmp54);
#line 847
  __cil_tmp56 = _mm_max_epu8(mask, __cil_tmp55);
#line 847
  mask = __cil_tmp56;
#line 847
  __cil_tmp57 = _mm_subs_epu8(q0, q1);
#line 847
  __cil_tmp58 = _mm_subs_epu8(q1, q0);
#line 847
  __cil_tmp59 = _mm_or_si128(__cil_tmp57, __cil_tmp58);
#line 847
  __cil_tmp60 = _mm_max_epu8(mask, __cil_tmp59);
#line 847
  mask = __cil_tmp60;
#line 849
  __cil_tmp63 = _mm_set1_epi8((char )ithresh);
#line 849
  it = __cil_tmp63;
#line 849
  mask = _mm_subs_epu8(mask, it);
#line 849
  __cil_tmp65 = _mm_setzero_si128();
#line 849
  __cil_tmp66 = _mm_cmpeq_epi8(mask, __cil_tmp65);
#line 849
  mask = __cil_tmp66;
#line 849
  NeedsFilter(& p1, & p0, & q0, & q1, thresh, & fl_yes);
#line 849
  mask = _mm_and_si128(mask, fl_yes);
#line 850
  DoFilter4(& p1, & p0, & q0, & q1, & mask, hev_thresh);
#line 853
  _mm_storel_epi64((__m128i *)(u + -2 * stride), p1);
#line 853
  p1 = _mm_bsrli_si128(p1, 8);
#line 853
  _mm_storel_epi64((__m128i *)(v + -2 * stride), p1);
#line 854
  _mm_storel_epi64((__m128i *)(u + -1 * stride), p0);
#line 854
  p0 = _mm_bsrli_si128(p0, 8);
#line 854
  _mm_storel_epi64((__m128i *)(v + -1 * stride), p0);
#line 855
  _mm_storel_epi64((__m128i *)(u + 0), q0);
#line 855
  q0 = _mm_bsrli_si128(q0, 8);
#line 855
  _mm_storel_epi64((__m128i *)(v + 0), q0);
#line 856
  _mm_storel_epi64((__m128i *)(u + stride), q1);
#line 856
  q1 = _mm_bsrli_si128(q1, 8);
#line 856
  _mm_storel_epi64((__m128i *)(v + stride), q1);
  }
#line 858
  return;
}
}
#line 859 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
static void HFilter8iSSE2(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                          int hev_thresh ) 
{ 
  __m128i mask ;
  __m128i t1 ;
  __m128i t2 ;
  __m128i p1 ;
  __m128i p0 ;
  __m128i q0 ;
  __m128i q1 ;
  __m128i __cil_tmp14 ;
  __m128i __cil_tmp15 ;
  __m128i __cil_tmp16 ;
  __m128i __cil_tmp17 ;
  __m128i __cil_tmp18 ;
  __m128i __cil_tmp19 ;
  __m128i __cil_tmp20 ;
  __m128i __cil_tmp21 ;
  __m128i __cil_tmp22 ;
  __m128i __cil_tmp23 ;
  __m128i __cil_tmp24 ;
  __m128i __cil_tmp25 ;
  __m128i __cil_tmp26 ;
  __m128i __cil_tmp27 ;
  __m128i __cil_tmp28 ;
  __m128i __cil_tmp29 ;
  __m128i __cil_tmp30 ;
  __m128i __cil_tmp31 ;
  __m128i __cil_tmp32 ;
  __m128i __cil_tmp33 ;
  __m128i __cil_tmp34 ;
  __m128i __cil_tmp35 ;
  __m128i __cil_tmp36 ;
  __m128i fl_yes ;
  __m128i it ;
  __m128i __cil_tmp39 ;
  __m128i __cil_tmp41 ;
  __m128i __cil_tmp42 ;

  {
  {
#line 863
  Load16x4(u, v, stride, & t2, & t1, & p1, & p0);
#line 864
  __cil_tmp14 = _mm_subs_epu8(t1, t2);
#line 864
  __cil_tmp15 = _mm_subs_epu8(t2, t1);
#line 864
  __cil_tmp16 = _mm_or_si128(__cil_tmp14, __cil_tmp15);
#line 864
  mask = __cil_tmp16;
#line 864
  __cil_tmp17 = _mm_subs_epu8(p1, t1);
#line 864
  __cil_tmp18 = _mm_subs_epu8(t1, p1);
#line 864
  __cil_tmp19 = _mm_or_si128(__cil_tmp17, __cil_tmp18);
#line 864
  __cil_tmp20 = _mm_max_epu8(mask, __cil_tmp19);
#line 864
  mask = __cil_tmp20;
#line 864
  __cil_tmp21 = _mm_subs_epu8(p0, p1);
#line 864
  __cil_tmp22 = _mm_subs_epu8(p1, p0);
#line 864
  __cil_tmp23 = _mm_or_si128(__cil_tmp21, __cil_tmp22);
#line 864
  __cil_tmp24 = _mm_max_epu8(mask, __cil_tmp23);
#line 864
  mask = __cil_tmp24;
#line 866
  u += 4;
#line 867
  v += 4;
#line 868
  Load16x4(u, v, stride, & q0, & q1, & t1, & t2);
#line 869
  __cil_tmp25 = _mm_subs_epu8(t1, t2);
#line 869
  __cil_tmp26 = _mm_subs_epu8(t2, t1);
#line 869
  __cil_tmp27 = _mm_or_si128(__cil_tmp25, __cil_tmp26);
#line 869
  __cil_tmp28 = _mm_max_epu8(mask, __cil_tmp27);
#line 869
  mask = __cil_tmp28;
#line 869
  __cil_tmp29 = _mm_subs_epu8(q1, t1);
#line 869
  __cil_tmp30 = _mm_subs_epu8(t1, q1);
#line 869
  __cil_tmp31 = _mm_or_si128(__cil_tmp29, __cil_tmp30);
#line 869
  __cil_tmp32 = _mm_max_epu8(mask, __cil_tmp31);
#line 869
  mask = __cil_tmp32;
#line 869
  __cil_tmp33 = _mm_subs_epu8(q0, q1);
#line 869
  __cil_tmp34 = _mm_subs_epu8(q1, q0);
#line 869
  __cil_tmp35 = _mm_or_si128(__cil_tmp33, __cil_tmp34);
#line 869
  __cil_tmp36 = _mm_max_epu8(mask, __cil_tmp35);
#line 869
  mask = __cil_tmp36;
#line 871
  __cil_tmp39 = _mm_set1_epi8((char )ithresh);
#line 871
  it = __cil_tmp39;
#line 871
  mask = _mm_subs_epu8(mask, it);
#line 871
  __cil_tmp41 = _mm_setzero_si128();
#line 871
  __cil_tmp42 = _mm_cmpeq_epi8(mask, __cil_tmp41);
#line 871
  mask = __cil_tmp42;
#line 871
  NeedsFilter(& p1, & p0, & q0, & q1, thresh, & fl_yes);
#line 871
  mask = _mm_and_si128(mask, fl_yes);
#line 872
  DoFilter4(& p1, & p0, & q0, & q1, & mask, hev_thresh);
#line 874
  u -= 2;
#line 875
  v -= 2;
#line 876
  Store16x4(u, v, stride, & p1, & p0, & q0, & q1);
  }
#line 878
  return;
}
}
#line 884
void VP8DspInitSSE2(void) ;
#line 886 "/root/patchweave_new/13/src/dsp/dec_sse2.c"
void VP8DspInitSSE2(void) 
{ 


  {
#line 888
  VP8Transform = & TransformSSE2;
#line 890
  VP8VFilter16 = & VFilter16SSE2;
#line 891
  VP8HFilter16 = & HFilter16SSE2;
#line 892
  VP8VFilter8 = & VFilter8SSE2;
#line 893
  VP8HFilter8 = & HFilter8SSE2;
#line 894
  VP8VFilter16i = & VFilter16iSSE2;
#line 895
  VP8HFilter16i = & HFilter16iSSE2;
#line 896
  VP8VFilter8i = & VFilter8iSSE2;
#line 897
  VP8HFilter8i = & HFilter8iSSE2;
#line 899
  VP8SimpleVFilter16 = & SimpleVFilter16SSE2;
#line 900
  VP8SimpleHFilter16 = & SimpleHFilter16SSE2;
#line 901
  VP8SimpleVFilter16i = & SimpleVFilter16iSSE2;
#line 902
  VP8SimpleHFilter16i = & SimpleHFilter16iSSE2;
#line 903
  return;
}
}
#line 389 "/root/patchweave_new/13/src/dsp/dec_neon.c"
void VP8DspInitNEON(void) ;
#line 391 "/root/patchweave_new/13/src/dsp/dec_neon.c"
void VP8DspInitNEON(void) 
{ 


  {
#line 396
  return;
}
}
#line 22 "/root/patchweave_new/13/src/dsp/dec.c"
static uint8_t abs0___0[511]  ;
#line 23 "/root/patchweave_new/13/src/dsp/dec.c"
static uint8_t abs1___0[511]  ;
#line 24 "/root/patchweave_new/13/src/dsp/dec.c"
static int8_t sclip1___0[2041]  ;
#line 25 "/root/patchweave_new/13/src/dsp/dec.c"
static int8_t sclip2___0[225]  ;
#line 26 "/root/patchweave_new/13/src/dsp/dec.c"
static uint8_t clip1___1[766]  ;
#line 30 "/root/patchweave_new/13/src/dsp/dec.c"
static int tables_ok___1  =    0;
#line 32 "/root/patchweave_new/13/src/dsp/dec.c"
static void DspInitTables(void) 
{ 
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 33
  if (! tables_ok___1) {
#line 35
    i = -255;
    {
#line 35
    while (1) {
      while_continue: /* CIL Label */ ;

#line 35
      if (! (i <= 255)) {
#line 35
        goto while_break;
      }
#line 36
      if (i < 0) {
#line 36
        tmp___0 = - i;
      } else {
#line 36
        tmp___0 = i;
      }
#line 36
      abs0___0[255 + i] = (uint8_t )tmp___0;
#line 37
      abs1___0[255 + i] = (uint8_t )((int )abs0___0[255 + i] >> 1);
#line 35
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: 
#line 39
    i = -1020;
    {
#line 39
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 39
      if (! (i <= 1020)) {
#line 39
        goto while_break___0;
      }
#line 40
      if (i < -128) {
#line 40
        tmp___2 = -128;
      } else {
#line 40
        if (i > 127) {
#line 40
          tmp___1 = 127;
        } else {
#line 40
          tmp___1 = i;
        }
#line 40
        tmp___2 = tmp___1;
      }
#line 40
      sclip1___0[1020 + i] = (int8_t )tmp___2;
#line 39
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 42
    i = -112;
    {
#line 42
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 42
      if (! (i <= 112)) {
#line 42
        goto while_break___1;
      }
#line 43
      if (i < -16) {
#line 43
        tmp___4 = -16;
      } else {
#line 43
        if (i > 15) {
#line 43
          tmp___3 = 15;
        } else {
#line 43
          tmp___3 = i;
        }
#line 43
        tmp___4 = tmp___3;
      }
#line 43
      sclip2___0[112 + i] = (int8_t )tmp___4;
#line 42
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 45
    i = -255;
    {
#line 45
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 45
      if (! (i <= 510)) {
#line 45
        goto while_break___2;
      }
#line 46
      if (i < 0) {
#line 46
        tmp___6 = 0;
      } else {
#line 46
        if (i > 255) {
#line 46
          tmp___5 = 255;
        } else {
#line 46
          tmp___5 = i;
        }
#line 46
        tmp___6 = tmp___5;
      }
#line 46
      clip1___1[255 + i] = (uint8_t )tmp___6;
#line 45
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 48
    tables_ok___1 = 1;
  }
#line 50
  return;
}
}
#line 62 "/root/patchweave_new/13/src/dsp/dec.c"
static int const   kC1___0  =    (int const   )(20091 + (1 << 16));
#line 63 "/root/patchweave_new/13/src/dsp/dec.c"
static int const   kC2___0  =    (int const   )35468;
#line 66 "/root/patchweave_new/13/src/dsp/dec.c"
static void TransformOne(int16_t *in , uint8_t *dst ) 
{ 
  int C[16] ;
  int *tmp___0 ;
  int i ;
  int a ;
  int b ;
  int c ;
  int d ;
  int dc ;
  int a___0 ;
  int b___0 ;
  int c___0 ;
  int d___0 ;

  {
#line 69
  tmp___0 = C;
#line 70
  i = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;

#line 70
    if (! (i < 4)) {
#line 70
      goto while_break;
    }
#line 71
    a = (int )*(in + 0) + (int )*(in + 8);
#line 72
    b = (int )*(in + 0) - (int )*(in + 8);
#line 73
    c = ((int )*(in + 4) * (int )kC2___0 >> 16) - ((int )*(in + 12) * (int )kC1___0 >> 16);
#line 74
    d = ((int )*(in + 4) * (int )kC1___0 >> 16) + ((int )*(in + 12) * (int )kC2___0 >> 16);
#line 75
    *(tmp___0 + 0) = a + d;
#line 76
    *(tmp___0 + 1) = b + c;
#line 77
    *(tmp___0 + 2) = b - c;
#line 78
    *(tmp___0 + 3) = a - d;
#line 79
    tmp___0 += 4;
#line 80
    in ++;
#line 70
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 89
  tmp___0 = C;
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 90
    if (! (i < 4)) {
#line 90
      goto while_break___0;
    }
    {
#line 91
    dc = *(tmp___0 + 0) + 4;
#line 92
    a___0 = dc + *(tmp___0 + 8);
#line 93
    b___0 = dc - *(tmp___0 + 8);
#line 94
    c___0 = (*(tmp___0 + 4) * (int )kC2___0 >> 16) - (*(tmp___0 + 12) * (int )kC1___0 >> 16);
#line 95
    d___0 = (*(tmp___0 + 4) * (int )kC1___0 >> 16) + (*(tmp___0 + 12) * (int )kC2___0 >> 16);
#line 96
    *(dst + 0) = clip_8b((int )*(dst + 0) + ((a___0 + d___0) >> 3));
#line 97
    *(dst + 1) = clip_8b((int )*(dst + 1) + ((b___0 + c___0) >> 3));
#line 98
    *(dst + 2) = clip_8b((int )*(dst + 2) + ((b___0 - c___0) >> 3));
#line 99
    *(dst + 3) = clip_8b((int )*(dst + 3) + ((a___0 - d___0) >> 3));
#line 100
    tmp___0 ++;
#line 101
    dst += 32;
#line 90
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 94
  return;
}
}
#line 106 "/root/patchweave_new/13/src/dsp/dec.c"
static void TransformTwo(int16_t *in , uint8_t *dst , int do_two ) 
{ 


  {
  {
#line 107
  TransformOne(in, dst);
  }
#line 108
  if (do_two) {
    {
#line 109
    TransformOne(in + 16, dst + 4);
    }
  }
#line 112
  return;
}
}
#line 113 "/root/patchweave_new/13/src/dsp/dec.c"
static void TransformUV(int16_t *in , uint8_t *dst ) 
{ 


  {
  {
#line 114
  (*VP8Transform)(in + 0, dst, 1);
#line 115
  (*VP8Transform)(in + 32, dst + 128, 1);
  }
#line 117
  return;
}
}
#line 118 "/root/patchweave_new/13/src/dsp/dec.c"
static void TransformDC(int16_t *in , uint8_t *dst ) 
{ 
  int DC ;
  int i ;
  int j ;

  {
#line 119
  DC = (int )*(in + 0) + 4;
#line 121
  j = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;

#line 121
    if (! (j < 4)) {
#line 121
      goto while_break;
    }
#line 122
    i = 0;
    {
#line 122
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 122
      if (! (i < 4)) {
#line 122
        goto while_break___0;
      }
      {
#line 123
      *(dst + (i + j * 32)) = clip_8b((int )*(dst + (i + j * 32)) + (DC >> 3));
#line 122
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 121
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 125
  return;
}
}
#line 128 "/root/patchweave_new/13/src/dsp/dec.c"
static void TransformDCUV(int16_t *in , uint8_t *dst ) 
{ 


  {
#line 129
  if (*(in + 0)) {
    {
#line 129
    TransformDC(in + 0, dst);
    }
  }
#line 130
  if (*(in + 16)) {
    {
#line 130
    TransformDC(in + 16, dst + 4);
    }
  }
#line 131
  if (*(in + 32)) {
    {
#line 131
    TransformDC(in + 32, dst + 128);
    }
  }
#line 132
  if (*(in + 48)) {
    {
#line 132
    TransformDC(in + 48, (dst + 128) + 4);
    }
  }
#line 135
  return;
}
}
#line 140 "/root/patchweave_new/13/src/dsp/dec.c"
static void TransformWHT(int16_t *in , int16_t *out ) 
{ 
  int tmp___0[16] ;
  int i ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int dc ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;

  {
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;

#line 143
    if (! (i < 4)) {
#line 143
      goto while_break;
    }
#line 144
    a0 = (int )*(in + i) + (int )*(in + (12 + i));
#line 145
    a1 = (int )*(in + (4 + i)) + (int )*(in + (8 + i));
#line 146
    a2 = (int )*(in + (4 + i)) - (int )*(in + (8 + i));
#line 147
    a3 = (int )*(in + i) - (int )*(in + (12 + i));
#line 148
    tmp___0[i] = a0 + a1;
#line 149
    tmp___0[8 + i] = a0 - a1;
#line 150
    tmp___0[4 + i] = a3 + a2;
#line 151
    tmp___0[12 + i] = a3 - a2;
#line 143
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 153
  i = 0;
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 153
    if (! (i < 4)) {
#line 153
      goto while_break___0;
    }
#line 154
    dc = tmp___0[i * 4] + 3;
#line 155
    a0___0 = dc + tmp___0[3 + i * 4];
#line 156
    a1___0 = tmp___0[1 + i * 4] + tmp___0[2 + i * 4];
#line 157
    a2___0 = tmp___0[1 + i * 4] - tmp___0[2 + i * 4];
#line 158
    a3___0 = dc - tmp___0[3 + i * 4];
#line 159
    *(out + 0) = (int16_t )((a0___0 + a1___0) >> 3);
#line 160
    *(out + 16) = (int16_t )((a3___0 + a2___0) >> 3);
#line 161
    *(out + 32) = (int16_t )((a0___0 - a1___0) >> 3);
#line 162
    *(out + 48) = (int16_t )((a3___0 - a2___0) >> 3);
#line 163
    out += 64;
#line 153
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 157
  return;
}
}
#line 167 "/root/patchweave_new/13/src/dsp/dec.c"
void (*VP8TransformWHT)(int16_t * , int16_t * )  =    & TransformWHT;
#line 174 "/root/patchweave_new/13/src/dsp/dec.c"
__inline static void TrueMotion___0(uint8_t *dst , int size ) 
{ 
  uint8_t *top ;
  uint8_t *clip0 ;
  int y ;
  uint8_t *clip___3 ;
  int x ;

  {
#line 175
  top = dst - 32;
#line 176
  clip0 = (clip1___1 + 255) - (int )*(top + -1);
#line 178
  y = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;

#line 178
    if (! (y < size)) {
#line 178
      goto while_break;
    }
#line 179
    clip___3 = clip0 + (int )*(dst + -1);
#line 181
    x = 0;
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 181
      if (! (x < size)) {
#line 181
        goto while_break___0;
      }
#line 182
      *(dst + x) = *(clip___3 + (int )*(top + x));
#line 181
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 184
    dst += 32;
#line 178
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 182
  return;
}
}
#line 187 "/root/patchweave_new/13/src/dsp/dec.c"
static void TM4___0(uint8_t *dst ) 
{ 


  {
  {
#line 187
  TrueMotion___0(dst, 4);
  }
#line 189
  return;
}
}
#line 188 "/root/patchweave_new/13/src/dsp/dec.c"
static void TM8uv(uint8_t *dst ) 
{ 


  {
  {
#line 188
  TrueMotion___0(dst, 8);
  }
#line 190
  return;
}
}
#line 189 "/root/patchweave_new/13/src/dsp/dec.c"
static void TM16(uint8_t *dst ) 
{ 


  {
  {
#line 189
  TrueMotion___0(dst, 16);
  }
#line 191
  return;
}
}
#line 194 "/root/patchweave_new/13/src/dsp/dec.c"
static void VE16(uint8_t *dst ) 
{ 
  int j ;

  {
#line 196
  j = 0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 196
    if (! (j < 16)) {
#line 196
      goto while_break;
    }
    {
#line 197
    memcpy((void *)(dst + j * 32), (void const   *)(dst - 32), 16UL);
#line 196
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 200
  return;
}
}
#line 201 "/root/patchweave_new/13/src/dsp/dec.c"
static void HE16(uint8_t *dst ) 
{ 
  int j ;

  {
#line 203
  j = 16;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;

#line 203
    if (! (j > 0)) {
#line 203
      goto while_break;
    }
    {
#line 204
    memset((void *)dst, (int )*(dst + -1), 16UL);
#line 205
    dst += 32;
#line 203
    j --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 207
  return;
}
}
#line 209 "/root/patchweave_new/13/src/dsp/dec.c"
__inline static void Put16(int v , uint8_t *dst ) 
{ 
  int j ;

  {
#line 211
  j = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;

#line 211
    if (! (j < 16)) {
#line 211
      goto while_break;
    }
    {
#line 212
    memset((void *)(dst + j * 32), v, 16UL);
#line 211
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 215
  return;
}
}
#line 216 "/root/patchweave_new/13/src/dsp/dec.c"
static void DC16(uint8_t *dst ) 
{ 
  int DC ;
  int j ;

  {
#line 217
  DC = 16;
#line 219
  j = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;

#line 219
    if (! (j < 16)) {
#line 219
      goto while_break;
    }
#line 220
    DC += (int )*(dst + (-1 + j * 32)) + (int )*(dst + (j - 32));
#line 219
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 222
  Put16(DC >> 5, dst);
  }
#line 224
  return;
}
}
#line 225 "/root/patchweave_new/13/src/dsp/dec.c"
static void DC16NoTop(uint8_t *dst ) 
{ 
  int DC ;
  int j ;

  {
#line 226
  DC = 8;
#line 228
  j = 0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;

#line 228
    if (! (j < 16)) {
#line 228
      goto while_break;
    }
#line 229
    DC += (int )*(dst + (-1 + j * 32));
#line 228
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 231
  Put16(DC >> 4, dst);
  }
#line 233
  return;
}
}
#line 234 "/root/patchweave_new/13/src/dsp/dec.c"
static void DC16NoLeft(uint8_t *dst ) 
{ 
  int DC ;
  int i ;

  {
#line 235
  DC = 8;
#line 237
  i = 0;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;

#line 237
    if (! (i < 16)) {
#line 237
      goto while_break;
    }
#line 238
    DC += (int )*(dst + (i - 32));
#line 237
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 240
  Put16(DC >> 4, dst);
  }
#line 242
  return;
}
}
#line 243 "/root/patchweave_new/13/src/dsp/dec.c"
static void DC16NoTopLeft(uint8_t *dst ) 
{ 


  {
  {
#line 244
  Put16(128, dst);
  }
#line 246
  return;
}
}
#line 253 "/root/patchweave_new/13/src/dsp/dec.c"
static void VE4___0(uint8_t *dst ) 
{ 
  uint8_t *top ;
  uint8_t vals[4] ;
  int i ;

  {
#line 254
  top = dst - 32;
#line 255
  vals[0] = (uint8_t )(((((int )*(top + -1) + 2 * (int )*(top + 0)) + (int )*(top + 1)) + 2) >> 2);
#line 255
  vals[1] = (uint8_t )(((((int )*(top + 0) + 2 * (int )*(top + 1)) + (int )*(top + 2)) + 2) >> 2);
#line 255
  vals[2] = (uint8_t )(((((int )*(top + 1) + 2 * (int )*(top + 2)) + (int )*(top + 3)) + 2) >> 2);
#line 255
  vals[3] = (uint8_t )(((((int )*(top + 2) + 2 * (int )*(top + 3)) + (int )*(top + 4)) + 2) >> 2);
#line 262
  i = 0;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;

#line 262
    if (! (i < 4)) {
#line 262
      goto while_break;
    }
    {
#line 263
    memcpy((void *)(dst + i * 32), (void const   *)(vals), sizeof(vals));
#line 262
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 266
  return;
}
}
#line 267 "/root/patchweave_new/13/src/dsp/dec.c"
static void HE4___0(uint8_t *dst ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;

  {
#line 268
  A = (int )*(dst + -33);
#line 269
  B = (int )*(dst + -1);
#line 270
  C = (int )*(dst + 31);
#line 271
  D = (int )*(dst + 63);
#line 272
  E = (int )*(dst + 95);
#line 273
  *((uint32_t *)(dst + 0)) = 16843009U * (unsigned int )((((A + 2 * B) + C) + 2) >> 2);
#line 274
  *((uint32_t *)(dst + 32)) = 16843009U * (unsigned int )((((B + 2 * C) + D) + 2) >> 2);
#line 275
  *((uint32_t *)(dst + 64)) = 16843009U * (unsigned int )((((C + 2 * D) + E) + 2) >> 2);
#line 276
  *((uint32_t *)(dst + 96)) = 16843009U * (unsigned int )((((D + 2 * E) + E) + 2) >> 2);
#line 277
  return;
}
}
#line 279 "/root/patchweave_new/13/src/dsp/dec.c"
static void DC4___0(uint8_t *dst ) 
{ 
  uint32_t dc ;
  int i ;

  {
#line 280
  dc = (uint32_t )4;
#line 282
  i = 0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;

#line 282
    if (! (i < 4)) {
#line 282
      goto while_break;
    }
#line 282
    dc += (unsigned int )((int )*(dst + (i - 32)) + (int )*(dst + (-1 + i * 32)));
#line 282
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 283
  dc >>= 3;
#line 284
  i = 0;
  {
#line 284
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 284
    if (! (i < 4)) {
#line 284
      goto while_break___0;
    }
    {
#line 284
    memset((void *)(dst + i * 32), (int )dc, 4UL);
#line 284
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 288
  return;
}
}
#line 287 "/root/patchweave_new/13/src/dsp/dec.c"
static void RD4___0(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;
  int X ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 288
  I = (int )*(dst + -1);
#line 289
  J = (int )*(dst + 31);
#line 290
  K = (int )*(dst + 63);
#line 291
  L = (int )*(dst + 95);
#line 292
  X = (int )*(dst + -33);
#line 293
  A = (int )*(dst + -32);
#line 294
  B = (int )*(dst + -31);
#line 295
  C = (int )*(dst + -30);
#line 296
  D = (int )*(dst + -29);
#line 297
  *(dst + 96) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 298
  *(dst + 97) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 298
  *(dst + 64) = *(dst + 97);
#line 299
  *(dst + 98) = (uint8_t )((((X + 2 * I) + J) + 2) >> 2);
#line 299
  *(dst + 65) = *(dst + 98);
#line 299
  *(dst + 32) = *(dst + 65);
#line 300
  *(dst + 99) = (uint8_t )((((A + 2 * X) + I) + 2) >> 2);
#line 300
  *(dst + 66) = *(dst + 99);
#line 300
  *(dst + 33) = *(dst + 66);
#line 300
  *(dst + 0) = *(dst + 33);
#line 301
  *(dst + 67) = (uint8_t )((((B + 2 * A) + X) + 2) >> 2);
#line 301
  *(dst + 34) = *(dst + 67);
#line 301
  *(dst + 1) = *(dst + 34);
#line 302
  *(dst + 35) = (uint8_t )((((C + 2 * B) + A) + 2) >> 2);
#line 302
  *(dst + 2) = *(dst + 35);
#line 303
  *(dst + 3) = (uint8_t )((((D + 2 * C) + B) + 2) >> 2);
#line 304
  return;
}
}
#line 306 "/root/patchweave_new/13/src/dsp/dec.c"
static void LD4___0(uint8_t *dst ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 307
  A = (int )*(dst + -32);
#line 308
  B = (int )*(dst + -31);
#line 309
  C = (int )*(dst + -30);
#line 310
  D = (int )*(dst + -29);
#line 311
  E = (int )*(dst + -28);
#line 312
  F = (int )*(dst + -27);
#line 313
  G = (int )*(dst + -26);
#line 314
  H = (int )*(dst + -25);
#line 315
  *(dst + 0) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 316
  *(dst + 32) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 316
  *(dst + 1) = *(dst + 32);
#line 317
  *(dst + 64) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 317
  *(dst + 33) = *(dst + 64);
#line 317
  *(dst + 2) = *(dst + 33);
#line 318
  *(dst + 96) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 318
  *(dst + 65) = *(dst + 96);
#line 318
  *(dst + 34) = *(dst + 65);
#line 318
  *(dst + 3) = *(dst + 34);
#line 319
  *(dst + 97) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 319
  *(dst + 66) = *(dst + 97);
#line 319
  *(dst + 35) = *(dst + 66);
#line 320
  *(dst + 98) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
#line 320
  *(dst + 67) = *(dst + 98);
#line 321
  *(dst + 99) = (uint8_t )((((G + 2 * H) + H) + 2) >> 2);
#line 322
  return;
}
}
#line 324 "/root/patchweave_new/13/src/dsp/dec.c"
static void VR4___0(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int X ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 325
  I = (int )*(dst + -1);
#line 326
  J = (int )*(dst + 31);
#line 327
  K = (int )*(dst + 63);
#line 328
  X = (int )*(dst + -33);
#line 329
  A = (int )*(dst + -32);
#line 330
  B = (int )*(dst + -31);
#line 331
  C = (int )*(dst + -30);
#line 332
  D = (int )*(dst + -29);
#line 333
  *(dst + 65) = (uint8_t )(((X + A) + 1) >> 1);
#line 333
  *(dst + 0) = *(dst + 65);
#line 334
  *(dst + 66) = (uint8_t )(((A + B) + 1) >> 1);
#line 334
  *(dst + 1) = *(dst + 66);
#line 335
  *(dst + 67) = (uint8_t )(((B + C) + 1) >> 1);
#line 335
  *(dst + 2) = *(dst + 67);
#line 336
  *(dst + 3) = (uint8_t )(((C + D) + 1) >> 1);
#line 338
  *(dst + 96) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 339
  *(dst + 64) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 340
  *(dst + 97) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 340
  *(dst + 32) = *(dst + 97);
#line 341
  *(dst + 98) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 341
  *(dst + 33) = *(dst + 98);
#line 342
  *(dst + 99) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 342
  *(dst + 34) = *(dst + 99);
#line 343
  *(dst + 35) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 344
  return;
}
}
#line 346 "/root/patchweave_new/13/src/dsp/dec.c"
static void VL4___0(uint8_t *dst ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 347
  A = (int )*(dst + -32);
#line 348
  B = (int )*(dst + -31);
#line 349
  C = (int )*(dst + -30);
#line 350
  D = (int )*(dst + -29);
#line 351
  E = (int )*(dst + -28);
#line 352
  F = (int )*(dst + -27);
#line 353
  G = (int )*(dst + -26);
#line 354
  H = (int )*(dst + -25);
#line 355
  *(dst + 0) = (uint8_t )(((A + B) + 1) >> 1);
#line 356
  *(dst + 64) = (uint8_t )(((B + C) + 1) >> 1);
#line 356
  *(dst + 1) = *(dst + 64);
#line 357
  *(dst + 65) = (uint8_t )(((C + D) + 1) >> 1);
#line 357
  *(dst + 2) = *(dst + 65);
#line 358
  *(dst + 66) = (uint8_t )(((D + E) + 1) >> 1);
#line 358
  *(dst + 3) = *(dst + 66);
#line 360
  *(dst + 32) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 361
  *(dst + 96) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 361
  *(dst + 33) = *(dst + 96);
#line 362
  *(dst + 97) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 362
  *(dst + 34) = *(dst + 97);
#line 363
  *(dst + 98) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 363
  *(dst + 35) = *(dst + 98);
#line 364
  *(dst + 67) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 365
  *(dst + 99) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
#line 366
  return;
}
}
#line 368 "/root/patchweave_new/13/src/dsp/dec.c"
static void HU4___0(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;

  {
#line 369
  I = (int )*(dst + -1);
#line 370
  J = (int )*(dst + 31);
#line 371
  K = (int )*(dst + 63);
#line 372
  L = (int )*(dst + 95);
#line 373
  *(dst + 0) = (uint8_t )(((I + J) + 1) >> 1);
#line 374
  *(dst + 32) = (uint8_t )(((J + K) + 1) >> 1);
#line 374
  *(dst + 2) = *(dst + 32);
#line 375
  *(dst + 64) = (uint8_t )(((K + L) + 1) >> 1);
#line 375
  *(dst + 34) = *(dst + 64);
#line 376
  *(dst + 1) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 377
  *(dst + 33) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 377
  *(dst + 3) = *(dst + 33);
#line 378
  *(dst + 65) = (uint8_t )((((K + 2 * L) + L) + 2) >> 2);
#line 378
  *(dst + 35) = *(dst + 65);
#line 379
  *(dst + 99) = (uint8_t )L;
#line 379
  *(dst + 98) = *(dst + 99);
#line 379
  *(dst + 97) = *(dst + 98);
#line 379
  *(dst + 96) = *(dst + 97);
#line 379
  *(dst + 66) = *(dst + 96);
#line 379
  *(dst + 67) = *(dst + 66);
#line 380
  return;
}
}
#line 383 "/root/patchweave_new/13/src/dsp/dec.c"
static void HD4___0(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;
  int X ;
  int A ;
  int B ;
  int C ;

  {
#line 384
  I = (int )*(dst + -1);
#line 385
  J = (int )*(dst + 31);
#line 386
  K = (int )*(dst + 63);
#line 387
  L = (int )*(dst + 95);
#line 388
  X = (int )*(dst + -33);
#line 389
  A = (int )*(dst + -32);
#line 390
  B = (int )*(dst + -31);
#line 391
  C = (int )*(dst + -30);
#line 393
  *(dst + 34) = (uint8_t )(((I + X) + 1) >> 1);
#line 393
  *(dst + 0) = *(dst + 34);
#line 394
  *(dst + 66) = (uint8_t )(((J + I) + 1) >> 1);
#line 394
  *(dst + 32) = *(dst + 66);
#line 395
  *(dst + 98) = (uint8_t )(((K + J) + 1) >> 1);
#line 395
  *(dst + 64) = *(dst + 98);
#line 396
  *(dst + 96) = (uint8_t )(((L + K) + 1) >> 1);
#line 398
  *(dst + 3) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 399
  *(dst + 2) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 400
  *(dst + 35) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 400
  *(dst + 1) = *(dst + 35);
#line 401
  *(dst + 67) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 401
  *(dst + 33) = *(dst + 67);
#line 402
  *(dst + 99) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 402
  *(dst + 65) = *(dst + 99);
#line 403
  *(dst + 97) = (uint8_t )((((L + 2 * K) + J) + 2) >> 2);
#line 404
  return;
}
}
#line 413 "/root/patchweave_new/13/src/dsp/dec.c"
static void VE8uv(uint8_t *dst ) 
{ 
  int j ;

  {
#line 415
  j = 0;
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;

#line 415
    if (! (j < 8)) {
#line 415
      goto while_break;
    }
    {
#line 416
    memcpy((void *)(dst + j * 32), (void const   *)(dst - 32), 8UL);
#line 415
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 419
  return;
}
}
#line 420 "/root/patchweave_new/13/src/dsp/dec.c"
static void HE8uv(uint8_t *dst ) 
{ 
  int j ;

  {
#line 422
  j = 0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;

#line 422
    if (! (j < 8)) {
#line 422
      goto while_break;
    }
    {
#line 423
    memset((void *)dst, (int )*(dst + -1), 8UL);
#line 424
    dst += 32;
#line 422
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 426
  return;
}
}
#line 429 "/root/patchweave_new/13/src/dsp/dec.c"
__inline static void Put8x8uv(uint8_t value , uint8_t *dst ) 
{ 
  int j ;
  uint64_t v ;

  {
#line 432
  v = (uint64_t )((unsigned long long )((uint64_t )value) * 72340172838076673ULL);
#line 433
  j = 0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;

#line 433
    if (! (j < 8)) {
#line 433
      goto while_break;
    }
#line 434
    *((uint64_t *)(dst + j * 32)) = v;
#line 433
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 437
  return;
}
}
#line 441 "/root/patchweave_new/13/src/dsp/dec.c"
static void DC8uv(uint8_t *dst ) 
{ 
  int dc0 ;
  int i ;

  {
#line 442
  dc0 = 8;
#line 444
  i = 0;
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;

#line 444
    if (! (i < 8)) {
#line 444
      goto while_break;
    }
#line 445
    dc0 += (int )*(dst + (i - 32)) + (int )*(dst + (-1 + i * 32));
#line 444
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 447
  Put8x8uv((uint8_t )(dc0 >> 4), dst);
  }
#line 449
  return;
}
}
#line 450 "/root/patchweave_new/13/src/dsp/dec.c"
static void DC8uvNoLeft(uint8_t *dst ) 
{ 
  int dc0 ;
  int i ;

  {
#line 451
  dc0 = 4;
#line 453
  i = 0;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;

#line 453
    if (! (i < 8)) {
#line 453
      goto while_break;
    }
#line 454
    dc0 += (int )*(dst + (i - 32));
#line 453
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 456
  Put8x8uv((uint8_t )(dc0 >> 3), dst);
  }
#line 458
  return;
}
}
#line 459 "/root/patchweave_new/13/src/dsp/dec.c"
static void DC8uvNoTop(uint8_t *dst ) 
{ 
  int dc0 ;
  int i ;

  {
#line 460
  dc0 = 4;
#line 462
  i = 0;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;

#line 462
    if (! (i < 8)) {
#line 462
      goto while_break;
    }
#line 463
    dc0 += (int )*(dst + (-1 + i * 32));
#line 462
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 465
  Put8x8uv((uint8_t )(dc0 >> 3), dst);
  }
#line 467
  return;
}
}
#line 468 "/root/patchweave_new/13/src/dsp/dec.c"
static void DC8uvNoTopLeft(uint8_t *dst ) 
{ 


  {
  {
#line 469
  Put8x8uv((uint8_t )128, dst);
  }
#line 471
  return;
}
}
#line 475 "/root/patchweave_new/13/src/dsp/dec.c"
VP8PredFunc VP8PredLuma4[10]  = 
#line 475
  {      & DC4___0,      & TM4___0,      & VE4___0,      & HE4___0, 
        & RD4___0,      & VR4___0,      & LD4___0,      & VL4___0, 
        & HD4___0,      & HU4___0};
#line 479 "/root/patchweave_new/13/src/dsp/dec.c"
VP8PredFunc VP8PredLuma16[7]  = {      & DC16,      & TM16,      & VE16,      & HE16, 
        & DC16NoTop,      & DC16NoLeft,      & DC16NoTopLeft};
#line 484 "/root/patchweave_new/13/src/dsp/dec.c"
VP8PredFunc VP8PredChroma8[7]  = {      & DC8uv,      & TM8uv,      & VE8uv,      & HE8uv, 
        & DC8uvNoTop,      & DC8uvNoLeft,      & DC8uvNoTopLeft};
#line 493 "/root/patchweave_new/13/src/dsp/dec.c"
__inline static void do_filter2___0(uint8_t *p , int step ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int a ;
  int a1 ;
  int a2 ;

  {
#line 494
  p1 = (int )*(p + -2 * step);
#line 494
  p0 = (int )*(p + - step);
#line 494
  q0 = (int )*(p + 0);
#line 494
  q1 = (int )*(p + step);
#line 495
  a = 3 * (q0 - p0) + (int )sclip1___0[(1020 + p1) - q1];
#line 496
  a1 = (int )sclip2___0[112 + ((a + 4) >> 3)];
#line 497
  a2 = (int )sclip2___0[112 + ((a + 3) >> 3)];
#line 498
  *(p + - step) = clip1___1[(255 + p0) + a2];
#line 499
  *(p + 0) = clip1___1[(255 + q0) - a1];
#line 500
  return;
}
}
#line 503 "/root/patchweave_new/13/src/dsp/dec.c"
__inline static void do_filter4___0(uint8_t *p , int step ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int a ;
  int a1 ;
  int a2 ;
  int a3 ;

  {
#line 504
  p1 = (int )*(p + -2 * step);
#line 504
  p0 = (int )*(p + - step);
#line 504
  q0 = (int )*(p + 0);
#line 504
  q1 = (int )*(p + step);
#line 505
  a = 3 * (q0 - p0);
#line 506
  a1 = (int )sclip2___0[112 + ((a + 4) >> 3)];
#line 507
  a2 = (int )sclip2___0[112 + ((a + 3) >> 3)];
#line 508
  a3 = (a1 + 1) >> 1;
#line 509
  *(p + -2 * step) = clip1___1[(255 + p1) + a3];
#line 510
  *(p + - step) = clip1___1[(255 + p0) + a2];
#line 511
  *(p + 0) = clip1___1[(255 + q0) - a1];
#line 512
  *(p + step) = clip1___1[(255 + q1) - a3];
#line 513
  return;
}
}
#line 516 "/root/patchweave_new/13/src/dsp/dec.c"
__inline static void do_filter6(uint8_t *p , int step ) 
{ 
  int p2 ;
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int q2 ;
  int a ;
  int a1 ;
  int a2 ;
  int a3 ;

  {
#line 517
  p2 = (int )*(p + -3 * step);
#line 517
  p1 = (int )*(p + -2 * step);
#line 517
  p0 = (int )*(p + - step);
#line 518
  q0 = (int )*(p + 0);
#line 518
  q1 = (int )*(p + step);
#line 518
  q2 = (int )*(p + 2 * step);
#line 519
  a = (int )sclip1___0[(1020 + 3 * (q0 - p0)) + (int )sclip1___0[(1020 + p1) - q1]];
#line 520
  a1 = (27 * a + 63) >> 7;
#line 521
  a2 = (18 * a + 63) >> 7;
#line 522
  a3 = (9 * a + 63) >> 7;
#line 523
  *(p + -3 * step) = clip1___1[(255 + p2) + a3];
#line 524
  *(p + -2 * step) = clip1___1[(255 + p1) + a2];
#line 525
  *(p + - step) = clip1___1[(255 + p0) + a1];
#line 526
  *(p + 0) = clip1___1[(255 + q0) - a1];
#line 527
  *(p + step) = clip1___1[(255 + q1) - a2];
#line 528
  *(p + 2 * step) = clip1___1[(255 + q2) - a3];
#line 529
  return;
}
}
#line 531 "/root/patchweave_new/13/src/dsp/dec.c"
__inline static int hev___0(uint8_t *p , int step , int thresh ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int tmp___0 ;

  {
#line 532
  p1 = (int )*(p + -2 * step);
#line 532
  p0 = (int )*(p + - step);
#line 532
  q0 = (int )*(p + 0);
#line 532
  q1 = (int )*(p + step);
#line 533
  if ((int )abs0___0[(255 + p1) - p0] > thresh) {
#line 533
    tmp___0 = 1;
  } else
#line 533
  if ((int )abs0___0[(255 + q1) - q0] > thresh) {
#line 533
    tmp___0 = 1;
  } else {
#line 533
    tmp___0 = 0;
  }
#line 533
  return (tmp___0);
}
}
#line 536 "/root/patchweave_new/13/src/dsp/dec.c"
__inline static int needs_filter___0(uint8_t *p , int step , int thresh ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;

  {
#line 537
  p1 = (int )*(p + -2 * step);
#line 537
  p0 = (int )*(p + - step);
#line 537
  q0 = (int )*(p + 0);
#line 537
  q1 = (int )*(p + step);
#line 538
  return (2 * (int )abs0___0[(255 + p0) - q0] + (int )abs1___0[(255 + p1) - q1] <= thresh);
}
}
#line 541 "/root/patchweave_new/13/src/dsp/dec.c"
__inline static int needs_filter2___0(uint8_t *p , int step , int t , int it ) 
{ 
  int p3 ;
  int p2 ;
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int q2 ;
  int q3 ;
  int tmp___0 ;

  {
#line 543
  p3 = (int )*(p + -4 * step);
#line 543
  p2 = (int )*(p + -3 * step);
#line 543
  p1 = (int )*(p + -2 * step);
#line 543
  p0 = (int )*(p + - step);
#line 544
  q0 = (int )*(p + 0);
#line 544
  q1 = (int )*(p + step);
#line 544
  q2 = (int )*(p + 2 * step);
#line 544
  q3 = (int )*(p + 3 * step);
#line 545
  if (2 * (int )abs0___0[(255 + p0) - q0] + (int )abs1___0[(255 + p1) - q1] > t) {
#line 546
    return (0);
  }
#line 547
  if ((int )abs0___0[(255 + p3) - p2] <= it) {
#line 547
    if ((int )abs0___0[(255 + p2) - p1] <= it) {
#line 547
      if ((int )abs0___0[(255 + p1) - p0] <= it) {
#line 547
        if ((int )abs0___0[(255 + q3) - q2] <= it) {
#line 547
          if ((int )abs0___0[(255 + q2) - q1] <= it) {
#line 547
            if ((int )abs0___0[(255 + q1) - q0] <= it) {
#line 547
              tmp___0 = 1;
            } else {
#line 547
              tmp___0 = 0;
            }
          } else {
#line 547
            tmp___0 = 0;
          }
        } else {
#line 547
          tmp___0 = 0;
        }
      } else {
#line 547
        tmp___0 = 0;
      }
    } else {
#line 547
      tmp___0 = 0;
    }
  } else {
#line 547
    tmp___0 = 0;
  }
#line 547
  return (tmp___0);
}
}
#line 555 "/root/patchweave_new/13/src/dsp/dec.c"
static void SimpleVFilter16___0(uint8_t *p , int stride , int thresh ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 557
  i = 0;
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;

#line 557
    if (! (i < 16)) {
#line 557
      goto while_break;
    }
    {
#line 558
    __cil_tmp5 = needs_filter___0(p + i, stride, thresh);
    }
#line 558
    if (__cil_tmp5) {
      {
#line 559
      do_filter2___0(p + i, stride);
      }
    }
#line 557
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 561
  return;
}
}
#line 564 "/root/patchweave_new/13/src/dsp/dec.c"
static void SimpleHFilter16___0(uint8_t *p , int stride , int thresh ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 566
  i = 0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;

#line 566
    if (! (i < 16)) {
#line 566
      goto while_break;
    }
    {
#line 567
    __cil_tmp5 = needs_filter___0(p + i * stride, 1, thresh);
    }
#line 567
    if (__cil_tmp5) {
      {
#line 568
      do_filter2___0(p + i * stride, 1);
      }
    }
#line 566
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 570
  return;
}
}
#line 573 "/root/patchweave_new/13/src/dsp/dec.c"
static void SimpleVFilter16i___0(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 575
  k = 3;
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;

#line 575
    if (! (k > 0)) {
#line 575
      goto while_break;
    }
    {
#line 576
    p += 4 * stride;
#line 577
    SimpleVFilter16___0(p, stride, thresh);
#line 575
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 579
  return;
}
}
#line 581 "/root/patchweave_new/13/src/dsp/dec.c"
static void SimpleHFilter16i___0(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 583
  k = 3;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;

#line 583
    if (! (k > 0)) {
#line 583
      goto while_break;
    }
    {
#line 584
    p += 4;
#line 585
    SimpleHFilter16___0(p, stride, thresh);
#line 583
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 587
  return;
}
}
#line 592 "/root/patchweave_new/13/src/dsp/dec.c"
__inline static void FilterLoop26(uint8_t *p , int hstride , int vstride , int size ,
                                  int thresh , int ithresh , int hev_thresh ) 
{ 
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    __cil_tmp8 = size;
#line 595
    size --;
#line 595
    if (! (__cil_tmp8 > 0)) {
#line 595
      goto while_break;
    }
    {
#line 596
    __cil_tmp9 = needs_filter2___0(p, hstride, thresh, ithresh);
    }
#line 596
    if (__cil_tmp9) {
      {
#line 597
      __cil_tmp10 = hev___0(p, hstride, hev_thresh);
      }
#line 597
      if (__cil_tmp10) {
        {
#line 598
        do_filter2___0(p, hstride);
        }
      } else {
        {
#line 600
        do_filter6(p, hstride);
        }
      }
    }
#line 603
    p += vstride;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 607
  return;
}
}
#line 607 "/root/patchweave_new/13/src/dsp/dec.c"
__inline static void FilterLoop24___0(uint8_t *p , int hstride , int vstride , int size ,
                                      int thresh , int ithresh , int hev_thresh ) 
{ 
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    __cil_tmp8 = size;
#line 610
    size --;
#line 610
    if (! (__cil_tmp8 > 0)) {
#line 610
      goto while_break;
    }
    {
#line 611
    __cil_tmp9 = needs_filter2___0(p, hstride, thresh, ithresh);
    }
#line 611
    if (__cil_tmp9) {
      {
#line 612
      __cil_tmp10 = hev___0(p, hstride, hev_thresh);
      }
#line 612
      if (__cil_tmp10) {
        {
#line 613
        do_filter2___0(p, hstride);
        }
      } else {
        {
#line 615
        do_filter4___0(p, hstride);
        }
      }
    }
#line 618
    p += vstride;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 622
  return;
}
}
#line 623 "/root/patchweave_new/13/src/dsp/dec.c"
static void VFilter16(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 


  {
  {
#line 625
  FilterLoop26(p, stride, 1, 16, thresh, ithresh, hev_thresh);
  }
#line 627
  return;
}
}
#line 628 "/root/patchweave_new/13/src/dsp/dec.c"
static void HFilter16(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 


  {
  {
#line 630
  FilterLoop26(p, 1, stride, 16, thresh, ithresh, hev_thresh);
  }
#line 632
  return;
}
}
#line 634 "/root/patchweave_new/13/src/dsp/dec.c"
static void VFilter16i___0(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;

  {
#line 637
  k = 3;
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;

#line 637
    if (! (k > 0)) {
#line 637
      goto while_break;
    }
    {
#line 638
    p += 4 * stride;
#line 639
    FilterLoop24___0(p, stride, 1, 16, thresh, ithresh, hev_thresh);
#line 637
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 641
  return;
}
}
#line 643 "/root/patchweave_new/13/src/dsp/dec.c"
static void HFilter16i___0(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;

  {
#line 646
  k = 3;
  {
#line 646
  while (1) {
    while_continue: /* CIL Label */ ;

#line 646
    if (! (k > 0)) {
#line 646
      goto while_break;
    }
    {
#line 647
    p += 4;
#line 648
    FilterLoop24___0(p, 1, stride, 16, thresh, ithresh, hev_thresh);
#line 646
    k --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 650
  return;
}
}
#line 653 "/root/patchweave_new/13/src/dsp/dec.c"
static void VFilter8(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                     int hev_thresh ) 
{ 


  {
  {
#line 655
  FilterLoop26(u, stride, 1, 8, thresh, ithresh, hev_thresh);
#line 656
  FilterLoop26(v, stride, 1, 8, thresh, ithresh, hev_thresh);
  }
#line 658
  return;
}
}
#line 659 "/root/patchweave_new/13/src/dsp/dec.c"
static void HFilter8(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                     int hev_thresh ) 
{ 


  {
  {
#line 661
  FilterLoop26(u, 1, stride, 8, thresh, ithresh, hev_thresh);
#line 662
  FilterLoop26(v, 1, stride, 8, thresh, ithresh, hev_thresh);
  }
#line 664
  return;
}
}
#line 665 "/root/patchweave_new/13/src/dsp/dec.c"
static void VFilter8i___0(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                          int hev_thresh ) 
{ 


  {
  {
#line 667
  FilterLoop24___0(u + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
#line 668
  FilterLoop24___0(v + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
  }
#line 670
  return;
}
}
#line 671 "/root/patchweave_new/13/src/dsp/dec.c"
static void HFilter8i___0(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                          int hev_thresh ) 
{ 


  {
  {
#line 673
  FilterLoop24___0(u + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
#line 674
  FilterLoop24___0(v + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
  }
#line 676
  return;
}
}
#line 700 "/root/patchweave_new/13/src/dsp/dec.c"
void VP8DspInit(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 701
  DspInitTables();
#line 703
  VP8Transform = & TransformTwo;
#line 704
  VP8TransformUV = & TransformUV;
#line 705
  VP8TransformDC = & TransformDC;
#line 706
  VP8TransformDCUV = & TransformDCUV;
#line 708
  VP8VFilter16 = & VFilter16;
#line 709
  VP8HFilter16 = & HFilter16;
#line 710
  VP8VFilter8 = & VFilter8;
#line 711
  VP8HFilter8 = & HFilter8;
#line 712
  VP8VFilter16i = & VFilter16i___0;
#line 713
  VP8HFilter16i = & HFilter16i___0;
#line 714
  VP8VFilter8i = & VFilter8i___0;
#line 715
  VP8HFilter8i = & HFilter8i___0;
#line 716
  VP8SimpleVFilter16 = & SimpleVFilter16___0;
#line 717
  VP8SimpleHFilter16 = & SimpleHFilter16___0;
#line 718
  VP8SimpleVFilter16i = & SimpleVFilter16i___0;
#line 719
  VP8SimpleHFilter16i = & SimpleHFilter16i___0;
  }
#line 722
  if (VP8GetCPUInfo) {
    {
#line 724
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 724
    if (__cil_tmp1) {
      {
#line 725
      VP8DspInitSSE2();
      }
    }
  }
#line 729
  return;
}
}
#line 37 "/root/patchweave_new/13/src/dsp/cpu.c"
__inline static void GetCPUInfo(int *cpu_info , int info_type ) 
{ 


  {
#line 42
  __asm__  ("asm":);
#line 43
  return;
}
}
#line 48 "/root/patchweave_new/13/src/dsp/cpu.c"
static int x86CPUInfo(CPUFeature feature ) 
{ 
  int cpu_info[4] ;

  {
  {
#line 50
  GetCPUInfo((int *)(cpu_info), 1);
  }
#line 51
  if ((unsigned int )feature == 0U) {
#line 52
    return (0 != (cpu_info[3] & 67108864));
  }
#line 54
  if ((unsigned int )feature == 1U) {
#line 55
    return (0 != (cpu_info[2] & 1));
  }
#line 57
  return (0);
}
}
#line 59 "/root/patchweave_new/13/src/dsp/cpu.c"
int (*VP8GetCPUInfo)(CPUFeature  )  =    & x86CPUInfo;
#line 48 "/root/patchweave_new/13/src/dec/webp.c"
__inline static uint32_t get_le24(uint8_t *data ) 
{ 


  {
#line 49
  return ((uint32_t )(((int )*(data + 0) | ((int )*(data + 1) << 8)) | ((int )*(data + 2) << 16)));
}
}
#line 52 "/root/patchweave_new/13/src/dec/webp.c"
__inline static uint32_t get_le32(uint8_t *data ) 
{ 
  uint32_t __cil_tmp2 ;

  {
  {
#line 53
  __cil_tmp2 = get_le24(data);
  }
#line 53
  return (__cil_tmp2 | (unsigned int )((int )*(data + 3) << 24));
}
}
#line 62 "/root/patchweave_new/13/src/dec/webp.c"
static enum VP8StatusCode ParseRIFF(uint8_t **data , size_t *data_size , size_t *riff_size ) 
{ 
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  uint32_t size ;
  uint32_t __cil_tmp10 ;

  {
  {
#line 69
  *riff_size = (size_t )0;
#line 70
  __cil_tmp7 = memcmp((void const   *)*data, (void const   *)"RIFF\210U", 4UL);
  }
#line 70
  if (*data_size >= 12UL) {
#line 70
    if (! __cil_tmp7) {
      {
#line 71
      __cil_tmp8 = memcmp((void const   *)(*data + 8), (void const   *)"WEBP", 4UL);
      }
#line 71
      if (__cil_tmp8) {
#line 72
        return ((enum VP8StatusCode )3);
      } else {
        {
#line 74
        __cil_tmp10 = get_le32(*data + 4);
#line 74
        size = __cil_tmp10;
        }
#line 76
        if (size < 12U) {
#line 77
          return ((enum VP8StatusCode )3);
        }
#line 79
        if (size > 4294967286U) {
#line 80
          return ((enum VP8StatusCode )3);
        }
#line 83
        *riff_size = (size_t )size;
#line 84
        *data += 12;
#line 85
        *data_size -= 12UL;
      }
    }
  }
#line 88
  return ((enum VP8StatusCode )0);
}
}
#line 98 "/root/patchweave_new/13/src/dec/webp.c"
static enum VP8StatusCode ParseVP8X(uint8_t **data , size_t *data_size , int *found_vp8x ,
                                    int *width_ptr , int *height_ptr , uint32_t *flags_ptr ) 
{ 
  uint32_t vp8x_size ;
  int __cil_tmp11 ;
  int width ;
  int height ;
  uint32_t flags ;
  uint32_t chunk_size ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp18 ;
  uint32_t __cil_tmp19 ;

  {
#line 103
  vp8x_size = (uint32_t )18;
#line 108
  *found_vp8x = 0;
#line 110
  if (*data_size < 8UL) {
#line 111
    return ((enum VP8StatusCode )7);
  }
  {
#line 114
  __cil_tmp11 = memcmp((void const   *)*data, (void const   *)"VP8X\210U", 4UL);
  }
#line 114
  if (! __cil_tmp11) {
    {
#line 117
    __cil_tmp16 = get_le32(*data + 4);
#line 117
    chunk_size = __cil_tmp16;
    }
#line 118
    if (chunk_size != 10U) {
#line 119
      return ((enum VP8StatusCode )3);
    }
#line 123
    if (*data_size < (unsigned long )vp8x_size) {
#line 124
      return ((enum VP8StatusCode )7);
    }
    {
#line 126
    flags = get_le32(*data + 8);
#line 127
    __cil_tmp18 = get_le24(*data + 12);
#line 127
    width = (int )(1U + __cil_tmp18);
#line 128
    __cil_tmp19 = get_le24(*data + 15);
#line 128
    height = (int )(1U + __cil_tmp19);
    }
#line 129
    if ((unsigned long long )((unsigned long )width * (uint64_t )height) >= 1ULL << 32) {
#line 130
      return ((enum VP8StatusCode )3);
    }
#line 133
    if ((unsigned long )flags_ptr != (unsigned long )((void *)0)) {
#line 133
      *flags_ptr = flags;
    }
#line 134
    if ((unsigned long )width_ptr != (unsigned long )((void *)0)) {
#line 134
      *width_ptr = width;
    }
#line 135
    if ((unsigned long )height_ptr != (unsigned long )((void *)0)) {
#line 135
      *height_ptr = height;
    }
#line 137
    *data += vp8x_size;
#line 138
    *data_size -= (unsigned long )vp8x_size;
#line 139
    *found_vp8x = 1;
  }
#line 141
  return ((enum VP8StatusCode )0);
}
}
#line 151 "/root/patchweave_new/13/src/dec/webp.c"
static enum VP8StatusCode ParseOptionalChunks(uint8_t **data , size_t *data_size ,
                                              size_t riff_size , uint8_t **alpha_data ,
                                              size_t *alpha_size ) 
{ 
  uint8_t *buf ;
  size_t buf_size ;
  uint32_t total_size ;
  uint32_t chunk_size ;
  uint32_t disk_chunk_size ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 158
  total_size = (uint32_t )22;
#line 163
  buf = *data;
#line 164
  buf_size = *data_size;
#line 168
  *alpha_data = (uint8_t *)((void *)0);
#line 169
  *alpha_size = (size_t )0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    *data = buf;
#line 176
    *data_size = buf_size;
#line 178
    if (buf_size < 8UL) {
#line 179
      return ((enum VP8StatusCode )7);
    }
    {
#line 182
    chunk_size = get_le32(buf + 4);
    }
#line 183
    if (chunk_size > 4294967286U) {
#line 184
      return ((enum VP8StatusCode )3);
    }
#line 187
    disk_chunk_size = ((8U + chunk_size) + 1U) & 4294967294U;
#line 188
    total_size += disk_chunk_size;
#line 191
    if (riff_size > 0UL) {
#line 191
      if ((unsigned long )total_size > riff_size) {
#line 192
        return ((enum VP8StatusCode )3);
      }
    }
    {
#line 199
    __cil_tmp17 = memcmp((void const   *)buf, (void const   *)"VP8L\315S\001", 4UL);
#line 199
    __cil_tmp16 = memcmp((void const   *)buf, (void const   *)"VP8 \317@\001", 4UL);
    }
#line 199
    if (! __cil_tmp16) {
#line 201
      return ((enum VP8StatusCode )0);
    } else
#line 199
    if (! __cil_tmp17) {
#line 201
      return ((enum VP8StatusCode )0);
    }
#line 204
    if (buf_size < (unsigned long )disk_chunk_size) {
#line 205
      return ((enum VP8StatusCode )7);
    }
    {
#line 208
    __cil_tmp18 = memcmp((void const   *)buf, (void const   *)"ALPH*p\001", 4UL);
    }
#line 208
    if (! __cil_tmp18) {
#line 209
      *alpha_data = buf + 8;
#line 210
      *alpha_size = (size_t )chunk_size;
    }
#line 214
    buf += disk_chunk_size;
#line 215
    buf_size -= (unsigned long )disk_chunk_size;
  }
  while_break: /* CIL Label */ ;
  }

#line 220
  return ((enum VP8StatusCode )0);
}
}
#line 227 "/root/patchweave_new/13/src/dec/webp.c"
static enum VP8StatusCode ParseVP8Header(uint8_t **data_ptr , size_t *data_size ,
                                         size_t riff_size , size_t *chunk_size , int *is_lossless ) 
{ 
  uint8_t *data ;
  int is_vp8 ;
  int __cil_tmp8 ;
  int is_vp8l ;
  int __cil_tmp10 ;
  uint32_t minimal_size ;
  uint32_t size ;
  uint32_t __cil_tmp17 ;

  {
  {
#line 232
  data = *data_ptr;
#line 233
  __cil_tmp8 = memcmp((void const   *)data, (void const   *)"VP8 ", 4UL);
#line 233
  is_vp8 = ! __cil_tmp8;
#line 234
  __cil_tmp10 = memcmp((void const   *)data, (void const   *)"VP8L", 4UL);
#line 234
  is_vp8l = ! __cil_tmp10;
#line 235
  minimal_size = (uint32_t )12;
  }
#line 243
  if (*data_size < 8UL) {
#line 244
    return ((enum VP8StatusCode )7);
  }
#line 247
  if (is_vp8) {
    _L: 
    {
#line 249
    __cil_tmp17 = get_le32(data + 4);
#line 249
    size = __cil_tmp17;
    }
#line 250
    if (riff_size >= (unsigned long )minimal_size) {
#line 250
      if ((unsigned long )size > riff_size - (unsigned long )minimal_size) {
#line 251
        return ((enum VP8StatusCode )3);
      }
    }
#line 254
    *chunk_size = (size_t )size;
#line 255
    *data_ptr += 8;
#line 256
    *data_size -= 8UL;
#line 257
    *is_lossless = is_vp8l;
  } else
#line 247
  if (is_vp8l) {
#line 247
    goto _L;
  } else {
    {
#line 260
    *is_lossless = VP8LCheckSignature(data, *data_size);
#line 261
    *chunk_size = *data_size;
    }
  }
#line 264
  return ((enum VP8StatusCode )0);
}
}
#line 280 "/root/patchweave_new/13/src/dec/webp.c"
static enum VP8StatusCode ParseHeadersInternal(uint8_t *data , size_t data_size ,
                                               int *width , int *height , int *has_alpha ,
                                               int *has_animation , WebPHeaderStructure *headers ) 
{ 
  int found_riff ;
  int found_vp8x ;
  enum VP8StatusCode status ;
  WebPHeaderStructure hdrs ;
  uint32_t flags ;
  int __cil_tmp15 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 287
  found_riff = 0;
#line 288
  found_vp8x = 0;
#line 292
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 293
    return ((enum VP8StatusCode )7);
  } else
#line 292
  if (data_size < 12UL) {
#line 293
    return ((enum VP8StatusCode )7);
  }
  {
#line 295
  memset((void *)(& hdrs), 0, sizeof(hdrs));
#line 296
  hdrs.data = data;
#line 297
  hdrs.data_size = data_size;
#line 300
  status = ParseRIFF(& data, & data_size, & hdrs.riff_size);
  }
#line 301
  if ((unsigned int )status != 0U) {
#line 302
    return (status);
  }
  {
#line 304
  found_riff = hdrs.riff_size > 0UL;
#line 308
  flags = (uint32_t )0;
#line 309
  status = ParseVP8X(& data, & data_size, & found_vp8x, width, height, & flags);
  }
#line 310
  if ((unsigned int )status != 0U) {
#line 311
    return (status);
  }
#line 313
  if (! found_riff) {
#line 313
    if (found_vp8x) {
#line 316
      return ((enum VP8StatusCode )3);
    }
  }
#line 318
  if ((unsigned long )has_alpha != (unsigned long )((void *)0)) {
#line 318
    *has_alpha = ! (! (flags & 16U));
  }
#line 319
  if ((unsigned long )has_animation != (unsigned long )((void *)0)) {
#line 319
    *has_animation = ! (! (flags & 2U));
  }
#line 320
  if ((unsigned long )headers == (unsigned long )((void *)0)) {
#line 320
    if (found_vp8x) {
#line 321
      return ((enum VP8StatusCode )0);
    }
  }
#line 325
  if (data_size < 4UL) {
#line 325
    return ((enum VP8StatusCode )7);
  }
  {
#line 328
  __cil_tmp15 = memcmp((void const   *)data, (void const   *)"ALPH\210U", 4UL);
  }
#line 328
  if (found_riff) {
#line 328
    if (found_vp8x) {
      _L: 
      {
#line 330
      status = ParseOptionalChunks(& data, & data_size, hdrs.riff_size, & hdrs.alpha_data,
                                   & hdrs.alpha_data_size);
      }
#line 332
      if ((unsigned int )status != 0U) {
#line 333
        return (status);
      }
    } else {
#line 328
      goto _L___14;
    }
  } else
  _L___14: 
#line 328
  if (! found_riff) {
#line 328
    if (! found_vp8x) {
#line 328
      if (! __cil_tmp15) {
#line 328
        goto _L;
      }
    }
  }
  {
#line 338
  status = ParseVP8Header(& data, & data_size, hdrs.riff_size, & hdrs.compressed_size,
                          & hdrs.is_lossless);
  }
#line 340
  if ((unsigned int )status != 0U) {
#line 341
    return (status);
  }
#line 343
  if (hdrs.compressed_size > 4294967286UL) {
#line 344
    return ((enum VP8StatusCode )3);
  }
#line 347
  if (! hdrs.is_lossless) {
#line 348
    if (data_size < 10UL) {
#line 349
      return ((enum VP8StatusCode )7);
    }
    {
#line 352
    __cil_tmp18 = VP8GetInfo(data, data_size, (size_t )((uint32_t )hdrs.compressed_size),
                             width, height);
    }
#line 352
    if (! __cil_tmp18) {
#line 354
      return ((enum VP8StatusCode )3);
    }
  } else {
#line 357
    if (data_size < 5UL) {
#line 358
      return ((enum VP8StatusCode )7);
    }
    {
#line 361
    __cil_tmp19 = VP8LGetInfo(data, data_size, width, height, has_alpha);
    }
#line 361
    if (! __cil_tmp19) {
#line 362
      return ((enum VP8StatusCode )3);
    }
  }
#line 366
  if ((unsigned long )has_alpha != (unsigned long )((void *)0)) {
#line 369
    *has_alpha |= (unsigned long )hdrs.alpha_data != (unsigned long )((void *)0);
  }
#line 371
  if ((unsigned long )headers != (unsigned long )((void *)0)) {
#line 372
    *headers = hdrs;
#line 373
    headers->offset = (size_t )(data - headers->data);
  }
#line 377
  return ((enum VP8StatusCode )0);
}
}
#line 380 "/root/patchweave_new/13/src/dec/webp.c"
enum VP8StatusCode WebPParseHeaders(WebPHeaderStructure *headers ) 
{ 
  enum VP8StatusCode status ;
  int has_animation ;

  {
  {
#line 382
  has_animation = 0;
#line 385
  status = ParseHeadersInternal(headers->data, headers->data_size, (int *)((void *)0),
                                (int *)((void *)0), (int *)((void *)0), & has_animation,
                                headers);
  }
#line 387
  if ((unsigned int )status == 0U) {
    _L: 
#line 389
    if (has_animation) {
#line 390
      status = (enum VP8StatusCode )4;
    }
  } else
#line 387
  if ((unsigned int )status == 7U) {
#line 387
    goto _L;
  }
#line 393
  return (status);
}
}
#line 399 "/root/patchweave_new/13/src/dec/webp.c"
void WebPResetDecParams(WebPDecParams *params ) 
{ 


  {
#line 400
  if (params) {
    {
#line 401
    memset((void *)params, 0, sizeof(*params));
    }
  }
#line 404
  return;
}
}
#line 409 "/root/patchweave_new/13/src/dec/webp.c"
static enum VP8StatusCode DecodeInto(uint8_t *data , size_t data_size , WebPDecParams *params ) 
{ 
  enum VP8StatusCode status ;
  VP8Io io ;
  WebPHeaderStructure headers ;
  VP8Decoder *dec ;
  VP8Decoder *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp13 ;
  VP8LDecoder *dec___0 ;
  VP8LDecoder *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  int tmp___1 ;

  {
  {
#line 415
  headers.data = data;
#line 416
  headers.data_size = data_size;
#line 417
  status = WebPParseHeaders(& headers);
  }
#line 418
  if ((unsigned int )status != 0U) {
#line 419
    return (status);
  }
  {
#line 423
  VP8InitIo(& io);
#line 424
  io.data = headers.data + headers.offset;
#line 425
  io.data_size = headers.data_size - headers.offset;
#line 426
  WebPInitCustomIo(params, & io);
  }
#line 428
  if (! headers.is_lossless) {
    {
#line 429
    __cil_tmp10 = VP8New();
#line 429
    dec = __cil_tmp10;
    }
#line 430
    if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 431
      return ((enum VP8StatusCode )1);
    }
#line 434
    if (params->options) {
#line 434
      if ((params->options)->use_threads > 0) {
#line 434
        tmp___1 = 1;
      } else {
#line 434
        tmp___1 = 0;
      }
    } else {
#line 434
      tmp___1 = 0;
    }
    {
#line 434
    dec->use_threads_ = tmp___1;
#line 438
    dec->alpha_data_ = headers.alpha_data;
#line 439
    dec->alpha_data_size_ = headers.alpha_data_size;
#line 442
    __cil_tmp11 = VP8GetHeaders(dec, & io);
    }
#line 442
    if (! __cil_tmp11) {
#line 443
      status = dec->status_;
    } else {
      {
#line 446
      status = WebPAllocateDecBuffer(io.width, io.height, params->options, params->output);
      }
#line 448
      if ((unsigned int )status == 0U) {
        {
#line 449
        __cil_tmp13 = VP8Decode(dec, & io);
        }
#line 449
        if (! __cil_tmp13) {
#line 450
          status = dec->status_;
        }
      }
    }
    {
#line 454
    VP8Delete(dec);
    }
  } else {
    {
#line 456
    __cil_tmp15 = VP8LNew();
#line 456
    dec___0 = __cil_tmp15;
    }
#line 457
    if ((unsigned long )dec___0 == (unsigned long )((void *)0)) {
#line 458
      return ((enum VP8StatusCode )1);
    }
    {
#line 460
    __cil_tmp16 = VP8LDecodeHeader(dec___0, & io);
    }
#line 460
    if (! __cil_tmp16) {
#line 461
      status = dec___0->status_;
    } else {
      {
#line 464
      status = WebPAllocateDecBuffer(io.width, io.height, params->options, params->output);
      }
#line 466
      if ((unsigned int )status == 0U) {
        {
#line 467
        __cil_tmp18 = VP8LDecodeImage(dec___0);
        }
#line 467
        if (! __cil_tmp18) {
#line 468
          status = dec___0->status_;
        }
      }
    }
    {
#line 472
    VP8LDelete(dec___0);
    }
  }
#line 475
  if ((unsigned int )status != 0U) {
    {
#line 476
    WebPFreeDecBuffer(params->output);
    }
  }
#line 478
  return (status);
}
}
#line 482 "/root/patchweave_new/13/src/dec/webp.c"
static uint8_t *DecodeIntoRGBABuffer(enum WEBP_CSP_MODE colorspace , uint8_t *data ,
                                     size_t data_size , uint8_t *rgba , int stride ,
                                     size_t size ) 
{ 
  WebPDecParams params ;
  WebPDecBuffer buf ;
  enum VP8StatusCode __cil_tmp9 ;

  {
#line 489
  if ((unsigned long )rgba == (unsigned long )((void *)0)) {
#line 490
    return ((uint8_t *)((void *)0));
  }
  {
#line 492
  WebPInitDecBuffer(& buf);
#line 493
  WebPResetDecParams(& params);
#line 494
  params.output = & buf;
#line 495
  buf.colorspace = (enum WEBP_CSP_MODE___0 )colorspace;
#line 496
  buf.u.RGBA.rgba = rgba;
#line 497
  buf.u.RGBA.stride = stride;
#line 498
  buf.u.RGBA.size = size;
#line 499
  buf.is_external_memory = 1;
#line 500
  __cil_tmp9 = DecodeInto(data, data_size, & params);
  }
#line 500
  if ((unsigned int )__cil_tmp9 != 0U) {
#line 501
    return ((uint8_t *)((void *)0));
  }
#line 503
  return (rgba);
}
}
#line 506 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeRGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 508
  __cil_tmp6 = DecodeIntoRGBABuffer((enum WEBP_CSP_MODE )0, data, data_size, output,
                                    stride, size);
  }
#line 508
  return (__cil_tmp6);
}
}
#line 511 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeRGBAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 513
  __cil_tmp6 = DecodeIntoRGBABuffer((enum WEBP_CSP_MODE )1, data, data_size, output,
                                    stride, size);
  }
#line 513
  return (__cil_tmp6);
}
}
#line 516 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeARGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 518
  __cil_tmp6 = DecodeIntoRGBABuffer((enum WEBP_CSP_MODE )4, data, data_size, output,
                                    stride, size);
  }
#line 518
  return (__cil_tmp6);
}
}
#line 521 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeBGRInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 523
  __cil_tmp6 = DecodeIntoRGBABuffer((enum WEBP_CSP_MODE )2, data, data_size, output,
                                    stride, size);
  }
#line 523
  return (__cil_tmp6);
}
}
#line 526 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeBGRAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 528
  __cil_tmp6 = DecodeIntoRGBABuffer((enum WEBP_CSP_MODE )3, data, data_size, output,
                                    stride, size);
  }
#line 528
  return (__cil_tmp6);
}
}
#line 531 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeYUVInto(uint8_t *data , size_t data_size , uint8_t *luma , size_t luma_size ,
                           int luma_stride , uint8_t *u , size_t u_size , int u_stride ,
                           uint8_t *v , size_t v_size , int v_stride ) 
{ 
  WebPDecParams params ;
  WebPDecBuffer output ;
  enum VP8StatusCode __cil_tmp14 ;

  {
#line 537
  if ((unsigned long )luma == (unsigned long )((void *)0)) {
#line 537
    return ((uint8_t *)((void *)0));
  }
  {
#line 538
  WebPInitDecBuffer(& output);
#line 539
  WebPResetDecParams(& params);
#line 540
  params.output = & output;
#line 541
  output.colorspace = (enum WEBP_CSP_MODE___0 )((enum WEBP_CSP_MODE )11);
#line 542
  output.u.YUVA.y = luma;
#line 543
  output.u.YUVA.y_stride = luma_stride;
#line 544
  output.u.YUVA.y_size = luma_size;
#line 545
  output.u.YUVA.u = u;
#line 546
  output.u.YUVA.u_stride = u_stride;
#line 547
  output.u.YUVA.u_size = u_size;
#line 548
  output.u.YUVA.v = v;
#line 549
  output.u.YUVA.v_stride = v_stride;
#line 550
  output.u.YUVA.v_size = v_size;
#line 551
  output.is_external_memory = 1;
#line 552
  __cil_tmp14 = DecodeInto(data, data_size, & params);
  }
#line 552
  if ((unsigned int )__cil_tmp14 != 0U) {
#line 553
    return ((uint8_t *)((void *)0));
  }
#line 555
  return (luma);
}
}
#line 560 "/root/patchweave_new/13/src/dec/webp.c"
static uint8_t *Decode(enum WEBP_CSP_MODE mode , uint8_t *data , size_t data_size ,
                       int *width , int *height , WebPDecBuffer *keep_info ) 
{ 
  WebPDecParams params ;
  WebPDecBuffer output ;
  int __cil_tmp9 ;
  enum VP8StatusCode __cil_tmp10 ;
  int __cil_tmp11 ;
  uint8_t *tmp___0 ;

  {
  {
#line 566
  WebPInitDecBuffer(& output);
#line 567
  WebPResetDecParams(& params);
#line 568
  params.output = & output;
#line 569
  output.colorspace = (enum WEBP_CSP_MODE___0 )mode;
#line 572
  __cil_tmp9 = WebPGetInfo(data, data_size, & output.width, & output.height);
  }
#line 572
  if (! __cil_tmp9) {
#line 573
    return ((uint8_t *)((void *)0));
  }
#line 575
  if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 575
    *width = output.width;
  }
#line 576
  if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 576
    *height = output.height;
  }
  {
#line 579
  __cil_tmp10 = DecodeInto(data, data_size, & params);
  }
#line 579
  if ((unsigned int )__cil_tmp10 != 0U) {
#line 580
    return ((uint8_t *)((void *)0));
  }
#line 582
  if ((unsigned long )keep_info != (unsigned long )((void *)0)) {
    {
#line 583
    WebPCopyDecBuffer(& output, keep_info);
    }
  }
  {
#line 586
  __cil_tmp11 = WebPIsRGBMode___0(mode);
  }
#line 586
  if (__cil_tmp11) {
#line 586
    tmp___0 = output.u.RGBA.rgba;
  } else {
#line 586
    tmp___0 = output.u.YUVA.y;
  }
#line 586
  return (tmp___0);
}
}
#line 589 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeRGB(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 591
  __cil_tmp5 = Decode((enum WEBP_CSP_MODE )0, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 591
  return (__cil_tmp5);
}
}
#line 594 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeRGBA(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 596
  __cil_tmp5 = Decode((enum WEBP_CSP_MODE )1, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 596
  return (__cil_tmp5);
}
}
#line 599 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeARGB(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 601
  __cil_tmp5 = Decode((enum WEBP_CSP_MODE )4, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 601
  return (__cil_tmp5);
}
}
#line 604 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeBGR(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 606
  __cil_tmp5 = Decode((enum WEBP_CSP_MODE )2, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 606
  return (__cil_tmp5);
}
}
#line 609 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeBGRA(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 611
  __cil_tmp5 = Decode((enum WEBP_CSP_MODE )3, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 611
  return (__cil_tmp5);
}
}
#line 614 "/root/patchweave_new/13/src/dec/webp.c"
uint8_t *WebPDecodeYUV(uint8_t *data , size_t data_size , int *width , int *height ,
                       uint8_t **u , uint8_t **v , int *stride , int *uv_stride ) 
{ 
  WebPDecBuffer output ;
  uint8_t *out ;
  uint8_t *__cil_tmp11 ;
  WebPYUVABuffer *buf ;

  {
  {
#line 618
  __cil_tmp11 = Decode((enum WEBP_CSP_MODE )11, data, data_size, width, height, & output);
#line 618
  out = __cil_tmp11;
  }
#line 621
  if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 622
    buf = & output.u.YUVA;
#line 623
    *u = buf->u;
#line 624
    *v = buf->v;
#line 625
    *stride = buf->y_stride;
#line 626
    *uv_stride = buf->u_stride;
  }
#line 629
  return (out);
}
}
#line 632 "/root/patchweave_new/13/src/dec/webp.c"
static void DefaultFeatures(WebPBitstreamFeatures *features ) 
{ 


  {
  {
#line 634
  memset((void *)features, 0, sizeof(*features));
#line 635
  features->bitstream_version = 0;
  }
#line 637
  return;
}
}
#line 638 "/root/patchweave_new/13/src/dec/webp.c"
static enum VP8StatusCode GetFeatures(uint8_t *data , size_t data_size , WebPBitstreamFeatures *features ) 
{ 
  enum VP8StatusCode __cil_tmp4 ;

  {
#line 640
  if ((unsigned long )features == (unsigned long )((void *)0)) {
#line 641
    return ((enum VP8StatusCode )2);
  } else
#line 640
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 641
    return ((enum VP8StatusCode )2);
  }
  {
#line 643
  DefaultFeatures(features);
#line 646
  __cil_tmp4 = ParseHeadersInternal(data, data_size, & features->width, & features->height,
                                    & features->has_alpha, & features->has_animation,
                                    (WebPHeaderStructure *)((void *)0));
  }
#line 646
  return (__cil_tmp4);
}
}
#line 655 "/root/patchweave_new/13/src/dec/webp.c"
int WebPGetInfo(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  WebPBitstreamFeatures features ;
  enum VP8StatusCode __cil_tmp6 ;

  {
  {
#line 659
  __cil_tmp6 = GetFeatures(data, data_size, & features);
  }
#line 659
  if ((unsigned int )__cil_tmp6 != 0U) {
#line 660
    return (0);
  }
#line 663
  if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 664
    *width = features.width;
  }
#line 666
  if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 667
    *height = features.height;
  }
#line 670
  return (1);
}
}
#line 676 "/root/patchweave_new/13/src/dec/webp.c"
int WebPInitDecoderConfigInternal(WebPDecoderConfig *config , int version ) 
{ 


  {
#line 678
  if (version >> 8 != 513 >> 8) {
#line 679
    return (0);
  }
#line 681
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 682
    return (0);
  }
  {
#line 684
  memset((void *)config, 0, sizeof(*config));
#line 685
  DefaultFeatures(& config->input);
#line 686
  WebPInitDecBuffer(& config->output);
  }
#line 687
  return (1);
}
}
#line 690 "/root/patchweave_new/13/src/dec/webp.c"
enum VP8StatusCode___0 WebPGetFeaturesInternal(uint8_t *data , size_t data_size ,
                                               WebPBitstreamFeatures *features , int version ) 
{ 
  enum VP8StatusCode __cil_tmp5 ;

  {
#line 693
  if (version >> 8 != 513 >> 8) {
#line 694
    return ((enum VP8StatusCode___0 )((enum VP8StatusCode )2));
  }
#line 696
  if ((unsigned long )features == (unsigned long )((void *)0)) {
#line 697
    return ((enum VP8StatusCode___0 )((enum VP8StatusCode )2));
  }
  {
#line 699
  __cil_tmp5 = GetFeatures(data, data_size, features);
  }
#line 699
  return ((enum VP8StatusCode___0 )__cil_tmp5);
}
}
#line 702 "/root/patchweave_new/13/src/dec/webp.c"
enum VP8StatusCode___0 WebPDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) 
{ 
  WebPDecParams params ;
  enum VP8StatusCode status ;

  {
#line 707
  if ((unsigned long )config == (unsigned long )((void *)0)) {
#line 708
    return ((enum VP8StatusCode___0 )((enum VP8StatusCode )2));
  }
  {
#line 711
  status = GetFeatures(data, data_size, & config->input);
  }
#line 712
  if ((unsigned int )status != 0U) {
#line 713
    if ((unsigned int )status == 7U) {
#line 714
      return ((enum VP8StatusCode___0 )((enum VP8StatusCode )3));
    }
#line 716
    return ((enum VP8StatusCode___0 )status);
  }
  {
#line 719
  WebPResetDecParams(& params);
#line 720
  params.output = & config->output;
#line 721
  params.options = & config->options;
#line 722
  status = DecodeInto(data, data_size, & params);
  }
#line 724
  return ((enum VP8StatusCode___0 )status);
}
}
#line 730 "/root/patchweave_new/13/src/dec/webp.c"
int WebPIoInitFromOptions(WebPDecoderOptions *options , VP8Io *io , enum WEBP_CSP_MODE src_colorspace ) 
{ 
  int W ;
  int H ;
  int x ;
  int y ;
  int w ;
  int h ;
  int __cil_tmp10 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 732
  W = io->width;
#line 733
  H = io->height;
#line 734
  x = 0;
#line 734
  y = 0;
#line 734
  w = W;
#line 734
  h = H;
#line 737
  if ((unsigned long )options != (unsigned long )((void *)0)) {
#line 737
    if (options->use_cropping > 0) {
#line 737
      tmp___0 = 1;
    } else {
#line 737
      tmp___0 = 0;
    }
  } else {
#line 737
    tmp___0 = 0;
  }
#line 737
  io->use_cropping = tmp___0;
#line 738
  if (io->use_cropping) {
    {
#line 739
    w = options->crop_width;
#line 740
    h = options->crop_height;
#line 741
    x = options->crop_left;
#line 742
    y = options->crop_top;
#line 743
    __cil_tmp10 = WebPIsRGBMode___0(src_colorspace);
    }
#line 743
    if (! __cil_tmp10) {
#line 744
      x &= -2;
#line 745
      y &= -2;
    }
#line 747
    if (x < 0) {
#line 748
      return (0);
    } else
#line 747
    if (y < 0) {
#line 748
      return (0);
    } else
#line 747
    if (w <= 0) {
#line 748
      return (0);
    } else
#line 747
    if (h <= 0) {
#line 748
      return (0);
    } else
#line 747
    if (x + w > W) {
#line 748
      return (0);
    } else
#line 747
    if (y + h > H) {
#line 748
      return (0);
    }
  }
#line 751
  io->crop_left = x;
#line 752
  io->crop_top = y;
#line 753
  io->crop_right = x + w;
#line 754
  io->crop_bottom = y + h;
#line 755
  io->mb_w = w;
#line 756
  io->mb_h = h;
#line 759
  if ((unsigned long )options != (unsigned long )((void *)0)) {
#line 759
    if (options->use_scaling > 0) {
#line 759
      tmp___1 = 1;
    } else {
#line 759
      tmp___1 = 0;
    }
  } else {
#line 759
    tmp___1 = 0;
  }
#line 759
  io->use_scaling = tmp___1;
#line 760
  if (io->use_scaling) {
#line 761
    if (options->scaled_width <= 0) {
#line 762
      return (0);
    } else
#line 761
    if (options->scaled_height <= 0) {
#line 762
      return (0);
    }
#line 764
    io->scaled_width = options->scaled_width;
#line 765
    io->scaled_height = options->scaled_height;
  }
#line 769
  if (options) {
#line 769
    if (options->bypass_filtering) {
#line 769
      tmp___2 = 1;
    } else {
#line 769
      tmp___2 = 0;
    }
  } else {
#line 769
    tmp___2 = 0;
  }
#line 769
  io->bypass_filtering = tmp___2;
#line 773
  if ((unsigned long )options == (unsigned long )((void *)0)) {
#line 773
    tmp___3 = 1;
  } else
#line 773
  if (! options->no_fancy_upsampling) {
#line 773
    tmp___3 = 1;
  } else {
#line 773
    tmp___3 = 0;
  }
#line 773
  io->fancy_upsampling = tmp___3;
#line 776
  if (io->use_scaling) {
#line 778
    if (io->scaled_width < (W * 3) / 4) {
#line 778
      if (io->scaled_height < (H * 3) / 4) {
#line 778
        tmp___4 = 1;
      } else {
#line 778
        tmp___4 = 0;
      }
    } else {
#line 778
      tmp___4 = 0;
    }
#line 778
    io->bypass_filtering = tmp___4;
#line 780
    io->fancy_upsampling = 0;
  }
#line 782
  return (1);
}
}
#line 28 "/root/patchweave_new/13/src/dec/./../utils/color_cache.h"
static uint32_t kHashMul___5  =    (uint32_t )506832829;
#line 36 "/root/patchweave_new/13/src/dec/./../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___5(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___5 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
#line 40
  return;
}
}
#line 27 "/root/patchweave_new/13/src/dec/vp8l.c"
static int const   kCodeLengthLiterals  =    (int const   )16;
#line 28 "/root/patchweave_new/13/src/dec/vp8l.c"
static int const   kCodeLengthRepeatCode  =    (int const   )16;
#line 29 "/root/patchweave_new/13/src/dec/vp8l.c"
static int const   kCodeLengthExtraBits[3]  = {      (int const   )2,      (int const   )3,      (int const   )7};
#line 30 "/root/patchweave_new/13/src/dec/vp8l.c"
static int const   kCodeLengthRepeatOffsets[3]  = {      (int const   )3,      (int const   )3,      (int const   )11};
#line 47 "/root/patchweave_new/13/src/dec/vp8l.c"
static uint16_t kAlphabetSize[5]  = {      (uint16_t )280,      (uint16_t )256,      (uint16_t )256,      (uint16_t )256, 
        (uint16_t )40};
#line 55 "/root/patchweave_new/13/src/dec/vp8l.c"
static uint8_t kCodeLengthCodeOrder[19]  = 
#line 55
  {      (uint8_t )17,      (uint8_t )18,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )2,      (uint8_t )3,      (uint8_t )4,      (uint8_t )5, 
        (uint8_t )16,      (uint8_t )6,      (uint8_t )7,      (uint8_t )8, 
        (uint8_t )9,      (uint8_t )10,      (uint8_t )11,      (uint8_t )12, 
        (uint8_t )13,      (uint8_t )14,      (uint8_t )15};
#line 60 "/root/patchweave_new/13/src/dec/vp8l.c"
static uint8_t code_to_plane_lut[120]  = 
#line 60
  {      (uint8_t )24,      (uint8_t )7,      (uint8_t )23,      (uint8_t )25, 
        (uint8_t )40,      (uint8_t )6,      (uint8_t )39,      (uint8_t )41, 
        (uint8_t )22,      (uint8_t )26,      (uint8_t )38,      (uint8_t )42, 
        (uint8_t )56,      (uint8_t )5,      (uint8_t )55,      (uint8_t )57, 
        (uint8_t )21,      (uint8_t )27,      (uint8_t )54,      (uint8_t )58, 
        (uint8_t )37,      (uint8_t )43,      (uint8_t )72,      (uint8_t )4, 
        (uint8_t )71,      (uint8_t )73,      (uint8_t )20,      (uint8_t )28, 
        (uint8_t )53,      (uint8_t )59,      (uint8_t )70,      (uint8_t )74, 
        (uint8_t )36,      (uint8_t )44,      (uint8_t )88,      (uint8_t )69, 
        (uint8_t )75,      (uint8_t )52,      (uint8_t )60,      (uint8_t )3, 
        (uint8_t )87,      (uint8_t )89,      (uint8_t )19,      (uint8_t )29, 
        (uint8_t )86,      (uint8_t )90,      (uint8_t )35,      (uint8_t )45, 
        (uint8_t )68,      (uint8_t )76,      (uint8_t )85,      (uint8_t )91, 
        (uint8_t )51,      (uint8_t )61,      (uint8_t )104,      (uint8_t )2, 
        (uint8_t )103,      (uint8_t )105,      (uint8_t )18,      (uint8_t )30, 
        (uint8_t )102,      (uint8_t )106,      (uint8_t )34,      (uint8_t )46, 
        (uint8_t )84,      (uint8_t )92,      (uint8_t )67,      (uint8_t )77, 
        (uint8_t )101,      (uint8_t )107,      (uint8_t )50,      (uint8_t )62, 
        (uint8_t )120,      (uint8_t )1,      (uint8_t )119,      (uint8_t )121, 
        (uint8_t )83,      (uint8_t )93,      (uint8_t )17,      (uint8_t )31, 
        (uint8_t )100,      (uint8_t )108,      (uint8_t )66,      (uint8_t )78, 
        (uint8_t )118,      (uint8_t )122,      (uint8_t )33,      (uint8_t )47, 
        (uint8_t )117,      (uint8_t )123,      (uint8_t )49,      (uint8_t )63, 
        (uint8_t )99,      (uint8_t )109,      (uint8_t )82,      (uint8_t )94, 
        (uint8_t )0,      (uint8_t )116,      (uint8_t )124,      (uint8_t )65, 
        (uint8_t )79,      (uint8_t )16,      (uint8_t )32,      (uint8_t )98, 
        (uint8_t )110,      (uint8_t )48,      (uint8_t )115,      (uint8_t )125, 
        (uint8_t )81,      (uint8_t )95,      (uint8_t )64,      (uint8_t )114, 
        (uint8_t )126,      (uint8_t )97,      (uint8_t )111,      (uint8_t )80, 
        (uint8_t )113,      (uint8_t )127,      (uint8_t )96,      (uint8_t )112};
#line 75
static int DecodeImageStream(int xsize , int ysize , int is_level0 , VP8LDecoder *dec ,
                             uint32_t **decoded_data ) ;
#line 82 "/root/patchweave_new/13/src/dec/vp8l.c"
int VP8LCheckSignature(uint8_t *data , size_t size ) 
{ 
  int tmp___0 ;

  {
#line 83
  if (size >= 1UL) {
#line 83
    if ((int )*(data + 0) == 47) {
#line 83
      tmp___0 = 1;
    } else {
#line 83
      tmp___0 = 0;
    }
  } else {
#line 83
    tmp___0 = 0;
  }
#line 83
  return (tmp___0);
}
}
#line 86 "/root/patchweave_new/13/src/dec/vp8l.c"
static int ReadImageInfo(VP8LBitReader *br , int *width , int *height , int *has_alpha ) 
{ 
  uint8_t signature ;
  uint32_t __cil_tmp6 ;
  int __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;

  {
  {
#line 89
  __cil_tmp6 = VP8LReadBits(br, 8);
#line 89
  signature = (uint8_t )__cil_tmp6;
#line 90
  __cil_tmp7 = VP8LCheckSignature(& signature, (size_t )1);
  }
#line 90
  if (! __cil_tmp7) {
#line 91
    return (0);
  }
  {
#line 93
  __cil_tmp8 = VP8LReadBits(br, 14);
#line 93
  *width = (int )(__cil_tmp8 + 1U);
#line 94
  __cil_tmp9 = VP8LReadBits(br, 14);
#line 94
  *height = (int )(__cil_tmp9 + 1U);
#line 95
  __cil_tmp10 = VP8LReadBits(br, 1);
#line 95
  *has_alpha = (int )__cil_tmp10;
#line 96
  VP8LReadBits(br, 3);
  }
#line 97
  return (1);
}
}
#line 100 "/root/patchweave_new/13/src/dec/vp8l.c"
int VP8LGetInfo(uint8_t *data , size_t data_size , int *width , int *height , int *has_alpha ) 
{ 
  int w ;
  int h ;
  int a ;
  VP8LBitReader br ;
  int __cil_tmp10 ;

  {
#line 102
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 103
    return (0);
  } else
#line 102
  if (data_size < 5UL) {
#line 103
    return (0);
  } else {
    {
#line 107
    VP8LInitBitReader(& br, data, data_size);
#line 108
    __cil_tmp10 = ReadImageInfo(& br, & w, & h, & a);
    }
#line 108
    if (! __cil_tmp10) {
#line 109
      return (0);
    }
#line 111
    if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 111
      *width = w;
    }
#line 112
    if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 112
      *height = h;
    }
#line 113
    if ((unsigned long )has_alpha != (unsigned long )((void *)0)) {
#line 113
      *has_alpha = a;
    }
#line 114
    return (1);
  }
}
}
#line 120 "/root/patchweave_new/13/src/dec/vp8l.c"
__inline static int GetCopyDistance(int distance_symbol , VP8LBitReader *br ) 
{ 
  int extra_bits ;
  int offset ;
  uint32_t __cil_tmp5 ;

  {
#line 123
  if (distance_symbol < 4) {
#line 124
    return (distance_symbol + 1);
  }
  {
#line 126
  extra_bits = (distance_symbol - 2) >> 1;
#line 127
  offset = (2 + (distance_symbol & 1)) << extra_bits;
#line 128
  __cil_tmp5 = VP8LReadBits(br, extra_bits);
  }
#line 128
  return ((int )(((unsigned int )offset + __cil_tmp5) + 1U));
}
}
#line 131 "/root/patchweave_new/13/src/dec/vp8l.c"
__inline static int GetCopyLength(int length_symbol , VP8LBitReader *br ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 134
  __cil_tmp3 = GetCopyDistance(length_symbol, br);
  }
#line 134
  return (__cil_tmp3);
}
}
#line 137 "/root/patchweave_new/13/src/dec/vp8l.c"
__inline static int PlaneCodeToDistance(int xsize , int plane_code ) 
{ 
  int dist_code ;
  int yoffset ;
  int xoffset ;
  int dist ;
  int tmp___0 ;

  {
#line 138
  if (plane_code > 120) {
#line 139
    return (plane_code - 120);
  } else {
#line 141
    dist_code = (int )code_to_plane_lut[plane_code - 1];
#line 142
    yoffset = dist_code >> 4;
#line 143
    xoffset = 8 - (dist_code & 15);
#line 144
    dist = yoffset * xsize + xoffset;
#line 145
    if (dist >= 1) {
#line 145
      tmp___0 = dist;
    } else {
#line 145
      tmp___0 = 1;
    }
#line 145
    return (tmp___0);
  }
}
}
#line 153 "/root/patchweave_new/13/src/dec/vp8l.c"
__inline static int ReadSymbol(HuffmanTree___0 *tree , VP8LBitReader *br ) 
{ 
  HuffmanTreeNode *node ;
  int num_bits ;
  uint32_t bits ;
  uint32_t __cil_tmp6 ;
  int __cil_tmp8 ;

  {
  {
#line 155
  node = tree->root_;
#line 156
  num_bits = 0;
#line 157
  __cil_tmp6 = VP8LPrefetchBits(br);
#line 157
  bits = __cil_tmp6;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    __cil_tmp8 = HuffmanTreeNodeIsLeaf(node);
    }
#line 159
    if (! (! __cil_tmp8)) {
#line 159
      goto while_break;
    }
    {
#line 160
    node = HuffmanTreeNextNode(node, (int )(bits & 1U));
#line 161
    bits >>= 1;
#line 162
    num_bits ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 164
  VP8LDiscardBits(br, num_bits);
  }
#line 165
  return (node->symbol_);
}
}
#line 168 "/root/patchweave_new/13/src/dec/vp8l.c"
static int ReadHuffmanCodeLengths(VP8LDecoder *dec , int const   *code_length_code_lengths ,
                                  int num_symbols , int *code_lengths ) 
{ 
  int ok ;
  VP8LBitReader *br ;
  int symbol ;
  int max_symbol ;
  int prev_code_len ;
  HuffmanTree___0 tree ;
  int __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  int length_nbits ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  int code_len ;
  int __cil_tmp17 ;
  int __cil_tmp19 ;
  int use_prev ;
  int slot ;
  int extra_bits ;
  int repeat_offset ;
  int repeat ;
  uint32_t __cil_tmp25 ;
  int length ;
  int tmp___0 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;

  {
  {
#line 171
  ok = 0;
#line 172
  br = & dec->br_;
#line 175
  prev_code_len = 8;
#line 178
  __cil_tmp11 = HuffmanTreeBuildImplicit(& tree, code_length_code_lengths, 19);
  }
#line 178
  if (! __cil_tmp11) {
#line 180
    dec->status_ = (enum VP8StatusCode )3;
#line 181
    return (0);
  }
  {
#line 184
  __cil_tmp12 = VP8LReadBits(br, 1);
  }
#line 184
  if (__cil_tmp12) {
    {
#line 185
    __cil_tmp14 = VP8LReadBits(br, 3);
#line 185
    length_nbits = (int )(2U + 2U * __cil_tmp14);
#line 186
    __cil_tmp15 = VP8LReadBits(br, length_nbits);
#line 186
    max_symbol = (int )(2U + __cil_tmp15);
    }
#line 187
    if (max_symbol > num_symbols) {
#line 188
      dec->status_ = (enum VP8StatusCode )3;
#line 189
      goto End;
    }
  } else {
#line 192
    max_symbol = num_symbols;
  }
#line 195
  symbol = 0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 196
    if (! (symbol < num_symbols)) {
#line 196
      goto while_break;
    }
#line 198
    __cil_tmp17 = max_symbol;
#line 198
    max_symbol --;
#line 198
    if (__cil_tmp17 == 0) {
#line 198
      goto while_break;
    }
    {
#line 199
    VP8LFillBitWindow(br);
#line 200
    code_len = ReadSymbol(& tree, br);
    }
#line 201
    if (code_len < (int )kCodeLengthLiterals) {
#line 202
      __cil_tmp19 = symbol;
#line 202
      symbol ++;
#line 202
      *(code_lengths + __cil_tmp19) = code_len;
#line 203
      if (code_len != 0) {
#line 203
        prev_code_len = code_len;
      }
    } else {
      {
#line 205
      use_prev = code_len == (int )kCodeLengthRepeatCode;
#line 206
      slot = code_len - (int )kCodeLengthLiterals;
#line 207
      extra_bits = (int )kCodeLengthExtraBits[slot];
#line 208
      repeat_offset = (int )kCodeLengthRepeatOffsets[slot];
#line 209
      __cil_tmp25 = VP8LReadBits(br, extra_bits);
#line 209
      repeat = (int )(__cil_tmp25 + (unsigned int )repeat_offset);
      }
#line 210
      if (symbol + repeat > num_symbols) {
#line 211
        dec->status_ = (enum VP8StatusCode )3;
#line 212
        goto End;
      } else {
#line 214
        if (use_prev) {
#line 214
          tmp___0 = prev_code_len;
        } else {
#line 214
          tmp___0 = 0;
        }
#line 214
        length = tmp___0;
        {
#line 215
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 215
          __cil_tmp28 = repeat;
#line 215
          repeat --;
#line 215
          if (! (__cil_tmp28 > 0)) {
#line 215
            goto while_break___0;
          }
#line 215
          __cil_tmp29 = symbol;
#line 215
          symbol ++;
#line 215
          *(code_lengths + __cil_tmp29) = length;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 219
  ok = 1;
  End: 
  {
#line 222
  HuffmanTreeRelease(& tree);
  }
#line 223
  return (ok);
}
}
#line 226 "/root/patchweave_new/13/src/dec/vp8l.c"
static int ReadHuffmanCode(int alphabet_size , VP8LDecoder *dec , HuffmanTree___0 *tree ) 
{ 
  int ok ;
  VP8LBitReader *br ;
  int simple_code ;
  uint32_t __cil_tmp7 ;
  int symbols[2] ;
  int codes[2] ;
  int code_lengths[2] ;
  int num_symbols ;
  uint32_t __cil_tmp12 ;
  int first_symbol_len_code ;
  uint32_t __cil_tmp14 ;
  int tmp___0 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  int *code_lengths___0 ;
  int i ;
  int code_length_code_lengths[19] ;
  unsigned int tmp___1 ;
  int num_codes ;
  uint32_t __cil_tmp24 ;
  void *__cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  int tmp___2 ;

  {
  {
#line 228
  ok = 0;
#line 229
  br = & dec->br_;
#line 230
  __cil_tmp7 = VP8LReadBits(br, 1);
#line 230
  simple_code = (int )__cil_tmp7;
  }
#line 232
  if (simple_code) {
    {
#line 236
    __cil_tmp12 = VP8LReadBits(br, 1);
#line 236
    num_symbols = (int )(__cil_tmp12 + 1U);
#line 237
    __cil_tmp14 = VP8LReadBits(br, 1);
#line 237
    first_symbol_len_code = (int )__cil_tmp14;
    }
#line 239
    if (first_symbol_len_code == 0) {
#line 239
      tmp___0 = 1;
    } else {
#line 239
      tmp___0 = 8;
    }
    {
#line 239
    __cil_tmp16 = VP8LReadBits(br, tmp___0);
#line 239
    symbols[0] = (int )__cil_tmp16;
#line 240
    codes[0] = 0;
#line 241
    code_lengths[0] = num_symbols - 1;
    }
#line 243
    if (num_symbols == 2) {
      {
#line 244
      __cil_tmp17 = VP8LReadBits(br, 8);
#line 244
      symbols[1] = (int )__cil_tmp17;
#line 245
      codes[1] = 1;
#line 246
      code_lengths[1] = num_symbols - 1;
      }
    }
    {
#line 248
    ok = HuffmanTreeBuildExplicit(tree, (int const   *)(code_lengths), (int const   *)(codes),
                                  (int const   *)(symbols), alphabet_size, num_symbols);
    }
  } else {
#line 251
    code_lengths___0 = (int *)((void *)0);
#line 253
    code_length_code_lengths[0] = 0;
#line 253
    tmp___1 = 1U;
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;

#line 253
      if (tmp___1 >= 19U) {
#line 253
        goto while_break;
      }
#line 253
      code_length_code_lengths[tmp___1] = 0;
#line 253
      tmp___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 254
    __cil_tmp24 = VP8LReadBits(br, 4);
#line 254
    num_codes = (int )(__cil_tmp24 + 4U);
    }
#line 255
    if (num_codes > 19) {
#line 256
      dec->status_ = (enum VP8StatusCode )3;
#line 257
      return (0);
    }
    {
#line 260
    __cil_tmp25 = WebPSafeCalloc((uint64_t )alphabet_size, sizeof(*code_lengths___0));
#line 260
    code_lengths___0 = (int *)__cil_tmp25;
    }
#line 262
    if ((unsigned long )code_lengths___0 == (unsigned long )((void *)0)) {
#line 263
      dec->status_ = (enum VP8StatusCode )1;
#line 264
      return (0);
    }
#line 267
    i = 0;
    {
#line 267
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 267
      if (! (i < num_codes)) {
#line 267
        goto while_break___0;
      }
      {
#line 268
      __cil_tmp26 = VP8LReadBits(br, 3);
#line 268
      code_length_code_lengths[kCodeLengthCodeOrder[i]] = (int )__cil_tmp26;
#line 267
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 270
    ok = ReadHuffmanCodeLengths(dec, (int const   *)(code_length_code_lengths), alphabet_size,
                                code_lengths___0);
    }
#line 272
    if (ok) {
      {
#line 273
      ok = HuffmanTreeBuildImplicit(tree, (int const   *)code_lengths___0, alphabet_size);
      }
    }
    {
#line 275
    free((void *)code_lengths___0);
    }
  }
#line 277
  if (ok) {
#line 277
    if (! br->error_) {
#line 277
      tmp___2 = 1;
    } else {
#line 277
      tmp___2 = 0;
    }
  } else {
#line 277
    tmp___2 = 0;
  }
#line 277
  ok = tmp___2;
#line 278
  if (! ok) {
#line 279
    dec->status_ = (enum VP8StatusCode )3;
#line 280
    return (0);
  }
#line 282
  return (1);
}
}
#line 285 "/root/patchweave_new/13/src/dec/vp8l.c"
static void DeleteHtreeGroups(HTreeGroup *htree_groups , int num_htree_groups ) 
{ 
  int i ;
  int j ;
  HuffmanTree___0 *htrees ;

  {
#line 286
  if ((unsigned long )htree_groups != (unsigned long )((void *)0)) {
#line 288
    i = 0;
    {
#line 288
    while (1) {
      while_continue: /* CIL Label */ ;

#line 288
      if (! (i < num_htree_groups)) {
#line 288
        goto while_break;
      }
#line 289
      htrees = (htree_groups + i)->htrees_;
#line 290
      j = 0;
      {
#line 290
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 290
        if (! (j < 5)) {
#line 290
          goto while_break___0;
        }
        {
#line 291
        HuffmanTreeRelease(htrees + j);
#line 290
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 288
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 294
    free((void *)htree_groups);
    }
  }
#line 297
  return;
}
}
#line 298 "/root/patchweave_new/13/src/dec/vp8l.c"
static int ReadHuffmanCodes(VP8LDecoder *dec , int xsize , int ysize , int color_cache_bits ,
                            int allow_recursion ) 
{ 
  int i ;
  int j ;
  VP8LBitReader *br ;
  VP8LMetadata *hdr ;
  uint32_t *huffman_image ;
  HTreeGroup *htree_groups ;
  int num_htree_groups ;
  uint32_t __cil_tmp13 ;
  int huffman_precision ;
  uint32_t __cil_tmp15 ;
  int huffman_xsize ;
  uint32_t __cil_tmp17 ;
  int huffman_ysize ;
  uint32_t __cil_tmp19 ;
  int huffman_pixs ;
  int __cil_tmp21 ;
  int group ;
  void *__cil_tmp24 ;
  HuffmanTree___0 *htrees ;
  int alphabet_size ;
  int __cil_tmp27 ;

  {
  {
#line 301
  br = & dec->br_;
#line 302
  hdr = & dec->hdr_;
#line 303
  huffman_image = (uint32_t *)((void *)0);
#line 304
  htree_groups = (HTreeGroup *)((void *)0);
#line 305
  num_htree_groups = 1;
#line 307
  __cil_tmp13 = VP8LReadBits(br, 1);
  }
#line 307
  if (allow_recursion) {
#line 307
    if (__cil_tmp13) {
      {
#line 309
      __cil_tmp15 = VP8LReadBits(br, 3);
#line 309
      huffman_precision = (int )(__cil_tmp15 + 2U);
#line 310
      __cil_tmp17 = VP8LSubSampleSize((uint32_t )xsize, (uint32_t )huffman_precision);
#line 310
      huffman_xsize = (int )__cil_tmp17;
#line 311
      __cil_tmp19 = VP8LSubSampleSize((uint32_t )ysize, (uint32_t )huffman_precision);
#line 311
      huffman_ysize = (int )__cil_tmp19;
#line 312
      huffman_pixs = huffman_xsize * huffman_ysize;
#line 313
      __cil_tmp21 = DecodeImageStream(huffman_xsize, huffman_ysize, 0, dec, & huffman_image);
      }
#line 313
      if (! __cil_tmp21) {
#line 315
        dec->status_ = (enum VP8StatusCode )3;
#line 316
        goto Error;
      }
#line 318
      hdr->huffman_subsample_bits_ = huffman_precision;
#line 319
      i = 0;
      {
#line 319
      while (1) {
        while_continue: /* CIL Label */ ;

#line 319
        if (! (i < huffman_pixs)) {
#line 319
          goto while_break;
        }
#line 321
        group = (int )((*(huffman_image + i) >> 8) & 65535U);
#line 322
        *(huffman_image + i) = (uint32_t )group;
#line 323
        if (group >= num_htree_groups) {
#line 324
          num_htree_groups = group + 1;
        }
#line 319
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: ;
    }
  }
#line 329
  if (br->error_) {
#line 329
    goto Error;
  }
  {
#line 332
  __cil_tmp24 = WebPSafeCalloc((uint64_t )num_htree_groups, sizeof(*htree_groups));
#line 332
  htree_groups = (HTreeGroup *)__cil_tmp24;
  }
#line 335
  if ((unsigned long )htree_groups == (unsigned long )((void *)0)) {
#line 336
    dec->status_ = (enum VP8StatusCode )1;
#line 337
    goto Error;
  }
#line 340
  i = 0;
  {
#line 340
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 340
    if (! (i < num_htree_groups)) {
#line 340
      goto while_break___0;
    }
#line 341
    htrees = (htree_groups + i)->htrees_;
#line 342
    j = 0;
    {
#line 342
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 342
      if (! (j < 5)) {
#line 342
        goto while_break___1;
      }
#line 343
      alphabet_size = (int )kAlphabetSize[j];
#line 344
      if (j == 0) {
#line 344
        if (color_cache_bits > 0) {
#line 345
          alphabet_size += 1 << color_cache_bits;
        }
      }
      {
#line 347
      __cil_tmp27 = ReadHuffmanCode(alphabet_size, dec, htrees + j);
      }
#line 347
      if (! __cil_tmp27) {
#line 347
        goto Error;
      }
#line 342
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 340
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 352
  hdr->huffman_image_ = huffman_image;
#line 353
  hdr->num_htree_groups_ = num_htree_groups;
#line 354
  hdr->htree_groups_ = htree_groups;
#line 355
  return (1);
  Error: 
  {
#line 358
  free((void *)huffman_image);
#line 359
  DeleteHtreeGroups(htree_groups, num_htree_groups);
  }
#line 360
  return (0);
}
}
#line 366 "/root/patchweave_new/13/src/dec/vp8l.c"
static int AllocateAndInitRescaler(VP8LDecoder *dec , VP8Io *io ) 
{ 
  int num_channels ;
  int in_width ;
  int out_width ;
  int in_height ;
  int out_height ;
  uint64_t work_size ;
  int32_t *work ;
  uint64_t scaled_data_size ;
  uint32_t *scaled_data ;
  uint64_t memory_size ;
  uint8_t *memory ;
  void *__cil_tmp14 ;

  {
  {
#line 367
  num_channels = 4;
#line 368
  in_width = io->mb_w;
#line 369
  out_width = io->scaled_width;
#line 370
  in_height = io->mb_h;
#line 371
  out_height = io->scaled_height;
#line 372
  work_size = (unsigned long )(2 * num_channels) * (uint64_t )out_width;
#line 374
  scaled_data_size = (unsigned long )num_channels * (uint64_t )out_width;
#line 376
  memory_size = (sizeof(*(dec->rescaler)) + work_size * sizeof(*work)) + scaled_data_size * sizeof(*scaled_data);
#line 379
  __cil_tmp14 = WebPSafeCalloc(memory_size, sizeof(*memory));
#line 379
  memory = (uint8_t *)__cil_tmp14;
  }
#line 380
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 381
    dec->status_ = (enum VP8StatusCode )1;
#line 382
    return (0);
  }
  {
#line 385
  dec->rescaler_memory = memory;
#line 387
  dec->rescaler = (WebPRescaler *)memory;
#line 388
  memory += sizeof(*(dec->rescaler));
#line 389
  work = (int32_t *)memory;
#line 390
  memory += work_size * sizeof(*work);
#line 391
  scaled_data = (uint32_t *)memory;
#line 393
  WebPRescalerInit(dec->rescaler, in_width, in_height, (uint8_t *)scaled_data, out_width,
                   out_height, 0, num_channels, in_width, out_width, in_height, out_height,
                   work);
  }
#line 396
  return (1);
}
}
#line 403 "/root/patchweave_new/13/src/dec/vp8l.c"
static int Export(WebPRescaler *rescaler , enum WEBP_CSP_MODE colorspace , int rgba_stride ,
                  uint8_t *rgba ) 
{ 
  uint32_t *src ;
  int dst_width ;
  int num_lines_out ;
  int __cil_tmp8 ;
  uint8_t *dst ;

  {
#line 405
  src = (uint32_t *)rescaler->dst;
#line 406
  dst_width = rescaler->dst_width;
#line 407
  num_lines_out = 0;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 408
    __cil_tmp8 = WebPRescalerHasPendingOutput(rescaler);
    }
#line 408
    if (! __cil_tmp8) {
#line 408
      goto while_break;
    }
    {
#line 409
    dst = rgba + num_lines_out * rgba_stride;
#line 410
    WebPRescalerExportRow(rescaler);
#line 411
    VP8LConvertFromBGRA(src, dst_width, colorspace, dst);
#line 412
    num_lines_out ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 414
  return (num_lines_out);
}
}
#line 418 "/root/patchweave_new/13/src/dec/vp8l.c"
static int EmitRescaledRows(VP8LDecoder *dec , uint32_t *data , int in_stride , int mb_h ,
                            uint8_t *out , int out_stride ) 
{ 
  enum WEBP_CSP_MODE colorspace ;
  uint8_t *in ;
  int num_lines_in ;
  int num_lines_out ;
  uint8_t *row_in ;
  uint8_t *row_out ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 421
  colorspace = (enum WEBP_CSP_MODE )(dec->output_)->colorspace;
#line 422
  in = (uint8_t *)data;
#line 423
  num_lines_in = 0;
#line 424
  num_lines_out = 0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;

#line 425
    if (! (num_lines_in < mb_h)) {
#line 425
      goto while_break;
    }
    {
#line 426
    row_in = in + num_lines_in * in_stride;
#line 427
    row_out = out + num_lines_out * out_stride;
#line 428
    __cil_tmp13 = WebPRescalerImport(dec->rescaler, mb_h - num_lines_in, row_in, in_stride);
#line 428
    num_lines_in += __cil_tmp13;
#line 430
    __cil_tmp14 = Export(dec->rescaler, colorspace, out_stride, row_out);
#line 430
    num_lines_out += __cil_tmp14;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 432
  return (num_lines_out);
}
}
#line 436 "/root/patchweave_new/13/src/dec/vp8l.c"
static int EmitRows(enum WEBP_CSP_MODE colorspace , uint32_t *data , int in_stride ,
                    int mb_w , int mb_h , uint8_t *out , int out_stride ) 
{ 
  int lines ;
  uint8_t *row_in ;
  uint8_t *row_out ;
  int __cil_tmp11 ;

  {
#line 440
  lines = mb_h;
#line 441
  row_in = (uint8_t *)data;
#line 442
  row_out = out;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    __cil_tmp11 = lines;
#line 443
    lines --;
#line 443
    if (! (__cil_tmp11 > 0)) {
#line 443
      goto while_break;
    }
    {
#line 444
    VP8LConvertFromBGRA((uint32_t *)row_in, mb_w, colorspace, row_out);
#line 445
    row_in += in_stride;
#line 446
    row_out += out_stride;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 448
  return (mb_h);
}
}
#line 454 "/root/patchweave_new/13/src/dec/vp8l.c"
static void ConvertToYUVA(uint32_t *src , int width , int y_pos , WebPDecBuffer *output ) 
{ 
  WebPYUVABuffer *buf ;
  int i ;
  uint8_t *y ;
  uint32_t p ;
  int __cil_tmp9 ;
  uint8_t *u ;
  uint8_t *v ;
  int uv_width ;
  int i___0 ;
  uint32_t v0 ;
  uint32_t v1 ;
  int r ;
  int g ;
  int b ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp_u ;
  int __cil_tmp22 ;
  int tmp_v ;
  int __cil_tmp24 ;
  uint32_t v0___0 ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int tmp_u___0 ;
  int __cil_tmp32 ;
  int tmp_v___0 ;
  int __cil_tmp34 ;
  int i___1 ;
  uint8_t *a ;

  {
#line 456
  buf = & output->u.YUVA;
#line 460
  y = buf->y + y_pos * buf->y_stride;
#line 461
  i = 0;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;

#line 461
    if (! (i < width)) {
#line 461
      goto while_break;
    }
    {
#line 462
    p = *(src + i);
#line 463
    __cil_tmp9 = VP8RGBToY((int )((p >> 16) & 255U), (int )((p >> 8) & 255U), (int )(p & 255U));
#line 463
    *(y + i) = (uint8_t )__cil_tmp9;
#line 461
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 469
  u = buf->u + (y_pos >> 1) * buf->u_stride;
#line 470
  v = buf->v + (y_pos >> 1) * buf->v_stride;
#line 471
  uv_width = width >> 1;
#line 473
  i___0 = 0;
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 473
    if (! (i___0 < uv_width)) {
#line 473
      goto while_break___0;
    }
#line 474
    v0 = *(src + 2 * i___0);
#line 475
    v1 = *(src + (2 * i___0 + 1));
#line 478
    r = (int )(((v0 >> 15) & 510U) + ((v1 >> 15) & 510U));
#line 479
    g = (int )(((v0 >> 7) & 510U) + ((v1 >> 7) & 510U));
#line 480
    b = (int )(((v0 << 1) & 510U) + ((v1 << 1) & 510U));
#line 481
    if (! (y_pos & 1)) {
      {
#line 482
      __cil_tmp19 = VP8RGBToU(r, g, b);
#line 482
      *(u + i___0) = (uint8_t )__cil_tmp19;
#line 483
      __cil_tmp20 = VP8RGBToV(r, g, b);
#line 483
      *(v + i___0) = (uint8_t )__cil_tmp20;
      }
    } else {
      {
#line 485
      __cil_tmp22 = VP8RGBToU(r, g, b);
#line 485
      tmp_u = __cil_tmp22;
#line 486
      __cil_tmp24 = VP8RGBToV(r, g, b);
#line 486
      tmp_v = __cil_tmp24;
#line 488
      *(u + i___0) = (uint8_t )((((int )*(u + i___0) + tmp_u) + 1) >> 1);
#line 489
      *(v + i___0) = (uint8_t )((((int )*(v + i___0) + tmp_v) + 1) >> 1);
      }
    }
#line 473
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 492
  if (width & 1) {
#line 493
    v0___0 = *(src + 2 * i___0);
#line 494
    r___0 = (int )((v0___0 >> 14) & 1020U);
#line 495
    g___0 = (int )((v0___0 >> 6) & 1020U);
#line 496
    b___0 = (int )((v0___0 << 2) & 1020U);
#line 497
    if (! (y_pos & 1)) {
      {
#line 498
      __cil_tmp29 = VP8RGBToU(r___0, g___0, b___0);
#line 498
      *(u + i___0) = (uint8_t )__cil_tmp29;
#line 499
      __cil_tmp30 = VP8RGBToV(r___0, g___0, b___0);
#line 499
      *(v + i___0) = (uint8_t )__cil_tmp30;
      }
    } else {
      {
#line 501
      __cil_tmp32 = VP8RGBToU(r___0, g___0, b___0);
#line 501
      tmp_u___0 = __cil_tmp32;
#line 502
      __cil_tmp34 = VP8RGBToV(r___0, g___0, b___0);
#line 502
      tmp_v___0 = __cil_tmp34;
#line 503
      *(u + i___0) = (uint8_t )((((int )*(u + i___0) + tmp_u___0) + 1) >> 1);
#line 504
      *(v + i___0) = (uint8_t )((((int )*(v + i___0) + tmp_v___0) + 1) >> 1);
      }
    }
  }
#line 509
  if ((unsigned long )buf->a != (unsigned long )((void *)0)) {
#line 511
    a = buf->a + y_pos * buf->a_stride;
#line 512
    i___1 = 0;
    {
#line 512
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 512
      if (! (i___1 < width)) {
#line 512
        goto while_break___1;
      }
#line 512
      *(a + i___1) = (uint8_t )(*(src + i___1) >> 24);
#line 512
      i___1 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 517
  return;
}
}
#line 516 "/root/patchweave_new/13/src/dec/vp8l.c"
static int ExportYUVA(VP8LDecoder *dec , int y_pos ) 
{ 
  WebPRescaler *rescaler ;
  uint32_t *src ;
  int dst_width ;
  int num_lines_out ;
  int __cil_tmp7 ;

  {
#line 517
  rescaler = dec->rescaler;
#line 518
  src = (uint32_t *)rescaler->dst;
#line 519
  dst_width = rescaler->dst_width;
#line 520
  num_lines_out = 0;
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 521
    __cil_tmp7 = WebPRescalerHasPendingOutput(rescaler);
    }
#line 521
    if (! __cil_tmp7) {
#line 521
      goto while_break;
    }
    {
#line 522
    WebPRescalerExportRow(rescaler);
#line 523
    ConvertToYUVA(src, dst_width, y_pos, dec->output_);
#line 524
    y_pos ++;
#line 525
    num_lines_out ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 527
  return (num_lines_out);
}
}
#line 530 "/root/patchweave_new/13/src/dec/vp8l.c"
static int EmitRescaledRowsYUVA(VP8LDecoder *dec , uint32_t *data , int in_stride ,
                                int mb_h ) 
{ 
  uint8_t *in ;
  int num_lines_in ;
  int y_pos ;
  uint8_t *row_in ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 533
  in = (uint8_t *)data;
#line 534
  num_lines_in = 0;
#line 535
  y_pos = dec->last_out_row_;
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;

#line 536
    if (! (num_lines_in < mb_h)) {
#line 536
      goto while_break;
    }
    {
#line 537
    row_in = in + num_lines_in * in_stride;
#line 538
    __cil_tmp9 = WebPRescalerImport(dec->rescaler, mb_h - num_lines_in, row_in, in_stride);
#line 538
    num_lines_in += __cil_tmp9;
#line 540
    __cil_tmp10 = ExportYUVA(dec, y_pos);
#line 540
    y_pos += __cil_tmp10;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 542
  return (y_pos);
}
}
#line 545 "/root/patchweave_new/13/src/dec/vp8l.c"
static int EmitRowsYUVA(VP8LDecoder *dec , uint32_t *data , int in_stride , int mb_w ,
                        int num_rows ) 
{ 
  int y_pos ;
  uint8_t *row_in ;
  int __cil_tmp8 ;

  {
#line 548
  y_pos = dec->last_out_row_;
#line 549
  row_in = (uint8_t *)data;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    __cil_tmp8 = num_rows;
#line 550
    num_rows --;
#line 550
    if (! (__cil_tmp8 > 0)) {
#line 550
      goto while_break;
    }
    {
#line 551
    ConvertToYUVA((uint32_t *)row_in, mb_w, y_pos, dec->output_);
#line 552
    row_in += in_stride;
#line 553
    y_pos ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 555
  return (y_pos);
}
}
#line 566 "/root/patchweave_new/13/src/dec/vp8l.c"
static int SetCropWindow(VP8Io *io , int y_start , int y_end , uint32_t **in_data ,
                         int pixel_stride ) 
{ 
  int delta ;

  {
#line 570
  if (y_end > io->crop_bottom) {
#line 571
    y_end = io->crop_bottom;
  }
#line 573
  if (y_start < io->crop_top) {
#line 574
    delta = io->crop_top - y_start;
#line 575
    y_start = io->crop_top;
#line 576
    *in_data += pixel_stride * delta;
  }
#line 578
  if (y_start >= y_end) {
#line 578
    return (0);
  }
#line 580
  *in_data += io->crop_left;
#line 582
  io->mb_y = y_start - io->crop_top;
#line 583
  io->mb_w = io->crop_right - io->crop_left;
#line 584
  io->mb_h = y_end - y_start;
#line 585
  return (1);
}
}
#line 590 "/root/patchweave_new/13/src/dec/vp8l.c"
__inline static int GetMetaIndex(uint32_t *image , int xsize , int bits , int x ,
                                 int y ) 
{ 


  {
#line 592
  if (bits == 0) {
#line 592
    return (0);
  }
#line 593
  return ((int )*(image + (xsize * (y >> bits) + (x >> bits))));
}
}
#line 596 "/root/patchweave_new/13/src/dec/vp8l.c"
__inline static HTreeGroup *GetHtreeGroupForPos(VP8LMetadata *hdr , int x , int y ) 
{ 
  int meta_index ;
  int __cil_tmp5 ;

  {
  {
#line 598
  __cil_tmp5 = GetMetaIndex(hdr->huffman_image_, hdr->huffman_xsize_, hdr->huffman_subsample_bits_,
                            x, y);
#line 598
  meta_index = __cil_tmp5;
  }
#line 601
  return (hdr->htree_groups_ + meta_index);
}
}
#line 609 "/root/patchweave_new/13/src/dec/vp8l.c"
static void ApplyInverseTransforms(VP8LDecoder *dec , int num_rows , uint32_t *rows ) 
{ 
  int n ;
  int cache_pixs ;
  int start_row ;
  int end_row ;
  uint32_t *rows_in ;
  uint32_t *rows_out ;
  int __cil_tmp10 ;
  VP8LTransform *transform ;

  {
  {
#line 611
  n = dec->next_transform_;
#line 612
  cache_pixs = dec->width_ * num_rows;
#line 613
  start_row = dec->last_row_;
#line 614
  end_row = start_row + num_rows;
#line 615
  rows_in = rows;
#line 616
  rows_out = dec->argb_cache_;
#line 620
  memcpy((void *)rows_out, (void const   *)rows_in, (unsigned long )cache_pixs * sizeof(*rows_out));
  }
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 621
    __cil_tmp10 = n;
#line 621
    n --;
#line 621
    if (! (__cil_tmp10 > 0)) {
#line 621
      goto while_break;
    }
    {
#line 622
    transform = & dec->transforms_[n];
#line 623
    VP8LInverseTransform(transform, start_row, end_row, rows_in, rows_out);
#line 624
    rows_in = rows_out;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 629
  return;
}
}
#line 630 "/root/patchweave_new/13/src/dec/vp8l.c"
static void ProcessRows(VP8LDecoder *dec , int row ) 
{ 
  uint32_t *rows ;
  int num_rows ;
  VP8Io *io ;
  uint32_t *rows_data ;
  int __cil_tmp7 ;
  WebPDecBuffer *output ;
  int in_stride ;
  WebPRGBABuffer *buf ;
  uint8_t *rgba ;
  int num_rows_out ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp___0 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp___1 ;

  {
#line 631
  rows = dec->argb_ + dec->width_ * dec->last_row_;
#line 632
  num_rows = row - dec->last_row_;
#line 634
  if (num_rows <= 0) {
#line 634
    return;
  }
  {
#line 635
  ApplyInverseTransforms(dec, num_rows, rows);
#line 639
  io = dec->io_;
#line 640
  rows_data = dec->argb_cache_;
#line 641
  __cil_tmp7 = SetCropWindow(io, dec->last_row_, row, & rows_data, io->width);
  }
#line 641
  if (! (! __cil_tmp7)) {
#line 644
    output = dec->output_;
#line 645
    in_stride = (int )((unsigned long )io->width * sizeof(*rows_data));
#line 646
    if ((unsigned int )output->colorspace < 11U) {
#line 647
      buf = & output->u.RGBA;
#line 648
      rgba = buf->rgba + dec->last_out_row_ * buf->stride;
#line 649
      if (io->use_scaling) {
        {
#line 649
        __cil_tmp13 = EmitRescaledRows(dec, rows_data, in_stride, io->mb_h, rgba,
                                       buf->stride);
#line 649
        tmp___0 = __cil_tmp13;
        }
      } else {
        {
#line 649
        __cil_tmp14 = EmitRows((enum WEBP_CSP_MODE )output->colorspace, rows_data,
                               in_stride, io->mb_w, io->mb_h, rgba, buf->stride);
#line 649
        tmp___0 = __cil_tmp14;
        }
      }
#line 649
      num_rows_out = tmp___0;
#line 655
      dec->last_out_row_ += num_rows_out;
    } else {
#line 657
      if (io->use_scaling) {
        {
#line 657
        __cil_tmp16 = EmitRescaledRowsYUVA(dec, rows_data, in_stride, io->mb_h);
#line 657
        tmp___1 = __cil_tmp16;
        }
      } else {
        {
#line 657
        __cil_tmp17 = EmitRowsYUVA(dec, rows_data, in_stride, io->mb_w, io->mb_h);
#line 657
        tmp___1 = __cil_tmp17;
        }
      }
#line 657
      dec->last_out_row_ = tmp___1;
    }
  }
#line 666
  dec->last_row_ = row;
#line 667
  return;
}
}
#line 670 "/root/patchweave_new/13/src/dec/vp8l.c"
static int DecodeImageData(VP8LDecoder *dec , uint32_t *data , int width , int height ,
                           void (*process_func)(VP8LDecoder * const   , int  ) ) 
{ 
  int ok ;
  int col ;
  int row ;
  VP8LBitReader *br ;
  VP8LMetadata *hdr ;
  HTreeGroup *htree_group ;
  uint32_t *src ;
  uint32_t *last_cached ;
  uint32_t *src_end ;
  int len_code_limit ;
  int color_cache_limit ;
  VP8LColorCache *color_cache ;
  VP8LColorCache *tmp___0 ;
  int mask ;
  int code ;
  int red ;
  int green ;
  int blue ;
  int alpha ;
  uint32_t *__cil_tmp31 ;
  int dist_code ;
  int dist ;
  int length_sym ;
  int length ;
  int __cil_tmp36 ;
  int dist_symbol ;
  int __cil_tmp38 ;
  int i ;
  uint32_t *__cil_tmp43 ;
  int key ;
  uint32_t *__cil_tmp46 ;
  int tmp___3 ;

  {
#line 673
  ok = 1;
#line 674
  col = 0;
#line 674
  row = 0;
#line 675
  br = & dec->br_;
#line 676
  hdr = & dec->hdr_;
#line 677
  htree_group = hdr->htree_groups_;
#line 678
  src = data;
#line 679
  last_cached = data;
#line 680
  src_end = data + width * height;
#line 681
  len_code_limit = 280;
#line 682
  color_cache_limit = len_code_limit + hdr->color_cache_size_;
#line 683
  if (hdr->color_cache_size_ > 0) {
#line 683
    tmp___0 = & hdr->color_cache_;
  } else {
#line 683
    tmp___0 = (VP8LColorCache *)((void *)0);
  }
#line 683
  color_cache = tmp___0;
#line 685
  mask = hdr->huffman_mask_;
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;

#line 689
    if ((unsigned long )src < (unsigned long )src_end) {
#line 689
      if (! (! br->eos_)) {
#line 689
        goto while_break;
      }
    } else {
#line 689
      goto while_break;
    }
#line 694
    if ((col & mask) == 0) {
      {
#line 695
      htree_group = GetHtreeGroupForPos(hdr, col, row);
      }
    }
    {
#line 697
    VP8LFillBitWindow(br);
#line 698
    code = ReadSymbol(& htree_group->htrees_[0], br);
    }
#line 699
    if (code < 256) {
      {
#line 701
      red = ReadSymbol(& htree_group->htrees_[1], br);
#line 702
      green = code;
#line 703
      VP8LFillBitWindow(br);
#line 704
      blue = ReadSymbol(& htree_group->htrees_[2], br);
#line 705
      alpha = ReadSymbol(& htree_group->htrees_[3], br);
#line 706
      *src = (uint32_t )((((alpha << 24) + (red << 16)) + (green << 8)) + blue);
      }
      AdvanceByOne: 
#line 708
      src ++;
#line 709
      col ++;
#line 710
      if (col >= width) {
#line 711
        col = 0;
#line 712
        row ++;
#line 713
        if ((unsigned long )process_func != (unsigned long )((void *)0)) {
#line 713
          if (row % 16 == 0) {
            {
#line 714
            (*process_func)((VP8LDecoder */* const  */)dec, row);
            }
          }
        }
#line 716
        if ((unsigned long )color_cache != (unsigned long )((void *)0)) {
          {
#line 717
          while (1) {
            while_continue___0: /* CIL Label */ ;

#line 717
            if (! ((unsigned long )last_cached < (unsigned long )src)) {
#line 717
              goto while_break___0;
            }
            {
#line 718
            __cil_tmp31 = last_cached;
#line 718
            last_cached ++;
#line 718
            VP8LColorCacheInsert___5(color_cache, *__cil_tmp31);
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          while_break___0: ;
        }
      }
    } else
#line 722
    if (code < len_code_limit) {
      {
#line 724
      length_sym = code - 256;
#line 725
      __cil_tmp36 = GetCopyLength(length_sym, br);
#line 725
      length = __cil_tmp36;
#line 726
      __cil_tmp38 = ReadSymbol(& htree_group->htrees_[4], br);
#line 726
      dist_symbol = __cil_tmp38;
#line 727
      VP8LFillBitWindow(br);
#line 728
      dist_code = GetCopyDistance(dist_symbol, br);
#line 729
      dist = PlaneCodeToDistance(width, dist_code);
      }
#line 730
      if (src - data < (long )dist) {
#line 731
        ok = 0;
#line 732
        goto End;
      } else
#line 730
      if (src_end - src < (long )length) {
#line 731
        ok = 0;
#line 732
        goto End;
      }
#line 736
      i = 0;
      {
#line 736
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 736
        if (! (i < length)) {
#line 736
          goto while_break___1;
        }
#line 736
        *(src + i) = *(src + (i - dist));
#line 736
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
#line 737
      src += length;
#line 739
      col += length;
      {
#line 740
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 740
        if (! (col >= width)) {
#line 740
          goto while_break___2;
        }
#line 741
        col -= width;
#line 742
        row ++;
#line 743
        if ((unsigned long )process_func != (unsigned long )((void *)0)) {
#line 743
          if (row % 16 == 0) {
            {
#line 744
            (*process_func)((VP8LDecoder */* const  */)dec, row);
            }
          }
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: ;
#line 747
      if ((unsigned long )src < (unsigned long )src_end) {
        {
#line 748
        htree_group = GetHtreeGroupForPos(hdr, col, row);
        }
#line 749
        if ((unsigned long )color_cache != (unsigned long )((void *)0)) {
          {
#line 750
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 750
            if (! ((unsigned long )last_cached < (unsigned long )src)) {
#line 750
              goto while_break___3;
            }
            {
#line 751
            __cil_tmp43 = last_cached;
#line 751
            last_cached ++;
#line 751
            VP8LColorCacheInsert___5(color_cache, *__cil_tmp43);
            }
          }
          while_break___9: /* CIL Label */ ;
          }
          while_break___3: ;
        }
      }
    } else
#line 755
    if (code < color_cache_limit) {
#line 756
      key = code - len_code_limit;
      {
#line 758
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 758
        if (! ((unsigned long )last_cached < (unsigned long )src)) {
#line 758
          goto while_break___4;
        }
        {
#line 759
        __cil_tmp46 = last_cached;
#line 759
        last_cached ++;
#line 759
        VP8LColorCacheInsert___5(color_cache, *__cil_tmp46);
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
      {
#line 761
      *src = VP8LColorCacheLookup(color_cache, (uint32_t )key);
      }
#line 762
      goto AdvanceByOne;
    } else {
#line 764
      ok = 0;
#line 765
      goto End;
    }
#line 767
    ok = ! br->error_;
#line 768
    if (! ok) {
#line 768
      goto End;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 771
  if ((unsigned long )process_func != (unsigned long )((void *)0)) {
    {
#line 771
    (*process_func)((VP8LDecoder */* const  */)dec, row);
    }
  }
  End: 
#line 774
  if ((unsigned long )src < (unsigned long )src_end) {
#line 774
    if (br->eos_) {
      _L: 
#line 775
      ok = 0;
#line 776
      if (! br->eos_) {
#line 776
        tmp___3 = 3;
      } else {
#line 776
        tmp___3 = 5;
      }
#line 776
      dec->status_ = (enum VP8StatusCode )tmp___3;
    } else {
#line 774
      goto _L___15;
    }
  } else
  _L___15: 
#line 774
  if (br->error_) {
#line 774
    goto _L;
  } else
#line 774
  if (! ok) {
#line 774
    goto _L;
  } else
#line 778
  if ((unsigned long )src == (unsigned long )src_end) {
#line 779
    dec->state_ = (VP8LDecodeState )0;
  }
#line 782
  return (ok);
}
}
#line 788 "/root/patchweave_new/13/src/dec/vp8l.c"
static void ClearTransform(VP8LTransform *transform ) 
{ 


  {
  {
#line 789
  free((void *)transform->data_);
#line 790
  transform->data_ = (uint32_t *)((void *)0);
  }
#line 792
  return;
}
}
#line 795 "/root/patchweave_new/13/src/dec/vp8l.c"
static int ExpandColorMap(int num_colors , VP8LTransform *transform ) 
{ 
  int i ;
  int final_num_colors ;
  uint32_t *new_color_map ;
  void *__cil_tmp6 ;
  uint8_t *data ;
  uint8_t *new_data ;

  {
  {
#line 797
  final_num_colors = 1 << (8 >> transform->bits_);
#line 798
  __cil_tmp6 = WebPSafeMalloc((uint64_t )final_num_colors, sizeof(*new_color_map));
#line 798
  new_color_map = (uint32_t *)__cil_tmp6;
  }
#line 801
  if ((unsigned long )new_color_map == (unsigned long )((void *)0)) {
#line 802
    return (0);
  } else {
#line 804
    data = (uint8_t *)transform->data_;
#line 805
    new_data = (uint8_t *)new_color_map;
#line 806
    *(new_color_map + 0) = *(transform->data_ + 0);
#line 807
    i = 4;
    {
#line 807
    while (1) {
      while_continue: /* CIL Label */ ;

#line 807
      if (! (i < 4 * num_colors)) {
#line 807
        goto while_break;
      }
#line 809
      *(new_data + i) = (uint8_t )(((int )*(data + i) + (int )*(new_data + (i - 4))) & 255);
#line 807
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
    {
#line 811
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 811
      if (! (i < 4 * final_num_colors)) {
#line 811
        goto while_break___0;
      }
#line 812
      *(new_data + i) = (uint8_t )0;
#line 811
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 813
    free((void *)transform->data_);
#line 814
    transform->data_ = new_color_map;
    }
  }
#line 816
  return (1);
}
}
#line 819 "/root/patchweave_new/13/src/dec/vp8l.c"
static int ReadTransform(int *xsize , int const   *ysize , VP8LDecoder *dec ) 
{ 
  int ok ;
  VP8LBitReader *br ;
  VP8LTransform *transform ;
  VP8LImageTransformType type ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int num_colors ;
  uint32_t __cil_tmp15 ;
  int bits ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uint32_t __cil_tmp20 ;
  int __cil_tmp22 ;
  int tmp___5 ;

  {
  {
#line 821
  ok = 1;
#line 822
  br = & dec->br_;
#line 823
  transform = & dec->transforms_[dec->next_transform_];
#line 824
  __cil_tmp8 = VP8LReadBits(br, 2);
#line 824
  type = (VP8LImageTransformType )__cil_tmp8;
  }
#line 828
  if (dec->transforms_seen_ & (1U << (unsigned int )type)) {
#line 829
    return (0);
  }
#line 831
  dec->transforms_seen_ |= 1U << (unsigned int )type;
#line 833
  transform->type_ = type;
#line 834
  transform->xsize_ = *xsize;
#line 835
  transform->ysize_ = (int )*ysize;
#line 836
  transform->data_ = (uint32_t *)((void *)0);
#line 837
  (dec->next_transform_) ++;
#line 842
  if ((unsigned int )type == 1U) {
#line 842
    goto case_1;
  }
#line 842
  if ((unsigned int )type == 0U) {
#line 842
    goto case_1;
  }
#line 850
  if ((unsigned int )type == 3U) {
#line 850
    goto case_3;
  }
#line 862
  if ((unsigned int )type == 2U) {
#line 862
    goto case_2;
  }
#line 840
  goto switch_break;
  case_1: 
  {
#line 843
  __cil_tmp10 = VP8LReadBits(br, 3);
#line 843
  transform->bits_ = (int )(__cil_tmp10 + 2U);
#line 844
  __cil_tmp11 = VP8LSubSampleSize((uint32_t )transform->xsize_, (uint32_t )transform->bits_);
#line 844
  __cil_tmp12 = VP8LSubSampleSize((uint32_t )transform->ysize_, (uint32_t )transform->bits_);
#line 844
  __cil_tmp13 = DecodeImageStream((int )__cil_tmp11, (int )__cil_tmp12, 0, dec, & transform->data_);
#line 844
  ok = __cil_tmp13;
  }
#line 849
  goto switch_break;
  case_3: 
  {
#line 851
  __cil_tmp15 = VP8LReadBits(br, 8);
#line 851
  num_colors = (int )(__cil_tmp15 + 1U);
  }
#line 852
  if (num_colors > 16) {
#line 852
    tmp___3 = 0;
  } else {
#line 852
    if (num_colors > 4) {
#line 852
      tmp___2 = 1;
    } else {
#line 852
      if (num_colors > 2) {
#line 852
        tmp___1 = 2;
      } else {
#line 852
        tmp___1 = 3;
      }
#line 852
      tmp___2 = tmp___1;
    }
#line 852
    tmp___3 = tmp___2;
  }
  {
#line 852
  bits = tmp___3;
#line 856
  __cil_tmp20 = VP8LSubSampleSize((uint32_t )transform->xsize_, (uint32_t )bits);
#line 856
  *xsize = (int )__cil_tmp20;
#line 857
  transform->bits_ = bits;
#line 858
  ok = DecodeImageStream(num_colors, 1, 0, dec, & transform->data_);
#line 859
  __cil_tmp22 = ExpandColorMap(num_colors, transform);
  }
#line 859
  if (ok) {
#line 859
    if (__cil_tmp22) {
#line 859
      tmp___5 = 1;
    } else {
#line 859
      tmp___5 = 0;
    }
  } else {
#line 859
    tmp___5 = 0;
  }
#line 859
  ok = tmp___5;
#line 860
  goto switch_break;
  case_2: 
#line 863
  goto switch_break;
#line 866
  goto switch_break;
  switch_break: ;
#line 869
  return (ok);
}
}
#line 875 "/root/patchweave_new/13/src/dec/vp8l.c"
static void InitMetadata(VP8LMetadata *hdr ) 
{ 


  {
  {
#line 877
  memset((void *)hdr, 0, sizeof(*hdr));
  }
#line 879
  return;
}
}
#line 880 "/root/patchweave_new/13/src/dec/vp8l.c"
static void ClearMetadata(VP8LMetadata *hdr ) 
{ 


  {
  {
#line 883
  free((void *)hdr->huffman_image_);
#line 884
  DeleteHtreeGroups(hdr->htree_groups_, hdr->num_htree_groups_);
#line 885
  VP8LColorCacheClear(& hdr->color_cache_);
#line 886
  InitMetadata(hdr);
  }
#line 888
  return;
}
}
#line 892 "/root/patchweave_new/13/src/dec/vp8l.c"
VP8LDecoder *VP8LNew(void) 
{ 
  VP8LDecoder *dec ;
  void *__cil_tmp2 ;

  {
  {
#line 893
  __cil_tmp2 = calloc(1UL, sizeof(*dec));
#line 893
  dec = (VP8LDecoder *)__cil_tmp2;
  }
#line 894
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 894
    return ((VP8LDecoder *)((void *)0));
  }
#line 895
  dec->status_ = (enum VP8StatusCode )0;
#line 896
  dec->action_ = (VP8LDecodeState )2;
#line 897
  dec->state_ = (VP8LDecodeState )2;
#line 898
  return (dec);
}
}
#line 901 "/root/patchweave_new/13/src/dec/vp8l.c"
void VP8LClear(VP8LDecoder *dec ) 
{ 
  int i ;

  {
#line 903
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 903
    return;
  }
  {
#line 904
  ClearMetadata(& dec->hdr_);
#line 906
  free((void *)dec->argb_);
#line 907
  dec->argb_ = (uint32_t *)((void *)0);
#line 908
  i = 0;
  }
  {
#line 908
  while (1) {
    while_continue: /* CIL Label */ ;

#line 908
    if (! (i < dec->next_transform_)) {
#line 908
      goto while_break;
    }
    {
#line 909
    ClearTransform(& dec->transforms_[i]);
#line 908
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 911
  dec->next_transform_ = 0;
#line 912
  dec->transforms_seen_ = (uint32_t )0;
#line 914
  free((void *)dec->rescaler_memory);
#line 915
  dec->rescaler_memory = (uint8_t *)((void *)0);
#line 917
  dec->output_ = (WebPDecBuffer *)((void *)0);
  }
#line 919
  return;
}
}
#line 920 "/root/patchweave_new/13/src/dec/vp8l.c"
void VP8LDelete(VP8LDecoder *dec ) 
{ 


  {
#line 921
  if ((unsigned long )dec != (unsigned long )((void *)0)) {
    {
#line 922
    VP8LClear(dec);
#line 923
    free((void *)dec);
    }
  }
#line 926
  return;
}
}
#line 927 "/root/patchweave_new/13/src/dec/vp8l.c"
static void UpdateDecoder(VP8LDecoder *dec , int width , int height ) 
{ 
  VP8LMetadata *hdr ;
  int num_bits ;
  uint32_t __cil_tmp6 ;
  int tmp___0 ;

  {
  {
#line 928
  hdr = & dec->hdr_;
#line 929
  num_bits = hdr->huffman_subsample_bits_;
#line 930
  dec->width_ = width;
#line 931
  dec->height_ = height;
#line 933
  __cil_tmp6 = VP8LSubSampleSize((uint32_t )width, (uint32_t )num_bits);
#line 933
  hdr->huffman_xsize_ = (int )__cil_tmp6;
  }
#line 934
  if (num_bits == 0) {
#line 934
    tmp___0 = ~ 0;
  } else {
#line 934
    tmp___0 = (1 << num_bits) - 1;
  }
#line 934
  hdr->huffman_mask_ = tmp___0;
#line 935
  return;
}
}
#line 937 "/root/patchweave_new/13/src/dec/vp8l.c"
static int DecodeImageStream(int xsize , int ysize , int is_level0 , VP8LDecoder *dec ,
                             uint32_t **decoded_data ) 
{ 
  int ok ;
  int transform_xsize ;
  int transform_ysize ;
  VP8LBitReader *br ;
  VP8LMetadata *hdr ;
  uint32_t *data ;
  int color_cache_bits ;
  uint32_t __cil_tmp13 ;
  uint32_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  uint64_t total_size ;
  void *__cil_tmp20 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 941
  ok = 1;
#line 942
  transform_xsize = xsize;
#line 943
  transform_ysize = ysize;
#line 944
  br = & dec->br_;
#line 945
  hdr = & dec->hdr_;
#line 946
  data = (uint32_t *)((void *)0);
#line 947
  color_cache_bits = 0;
#line 950
  if (is_level0) {
    {
#line 951
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 951
      __cil_tmp13 = VP8LReadBits(br, 1);
      }
#line 951
      if (ok) {
#line 951
        if (! __cil_tmp13) {
#line 951
          goto while_break;
        }
      } else {
#line 951
        goto while_break;
      }
      {
#line 952
      ok = ReadTransform(& transform_xsize, (int const   *)(& transform_ysize), dec);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 957
  __cil_tmp15 = VP8LReadBits(br, 1);
  }
#line 957
  if (ok) {
#line 957
    if (__cil_tmp15) {
      {
#line 958
      __cil_tmp16 = VP8LReadBits(br, 4);
#line 958
      color_cache_bits = (int )__cil_tmp16;
      }
#line 959
      if (color_cache_bits >= 1) {
#line 959
        if (color_cache_bits <= 11) {
#line 959
          tmp___2 = 1;
        } else {
#line 959
          tmp___2 = 0;
        }
      } else {
#line 959
        tmp___2 = 0;
      }
#line 959
      ok = tmp___2;
#line 960
      if (! ok) {
#line 961
        dec->status_ = (enum VP8StatusCode )3;
#line 962
        goto End;
      }
    }
  }
  {
#line 967
  __cil_tmp17 = ReadHuffmanCodes(dec, transform_xsize, transform_ysize, color_cache_bits,
                                 is_level0);
  }
#line 967
  if (ok) {
#line 967
    if (__cil_tmp17) {
#line 967
      tmp___3 = 1;
    } else {
#line 967
      tmp___3 = 0;
    }
  } else {
#line 967
    tmp___3 = 0;
  }
#line 967
  ok = tmp___3;
#line 969
  if (! ok) {
#line 970
    dec->status_ = (enum VP8StatusCode )3;
#line 971
    goto End;
  }
#line 975
  if (color_cache_bits > 0) {
    {
#line 976
    hdr->color_cache_size_ = 1 << color_cache_bits;
#line 977
    __cil_tmp18 = VP8LColorCacheInit(& hdr->color_cache_, color_cache_bits);
    }
#line 977
    if (! __cil_tmp18) {
#line 978
      dec->status_ = (enum VP8StatusCode )1;
#line 979
      ok = 0;
#line 980
      goto End;
    }
  } else {
#line 983
    hdr->color_cache_size_ = 0;
  }
  {
#line 985
  UpdateDecoder(dec, transform_xsize, transform_ysize);
  }
#line 987
  if (is_level0) {
#line 988
    dec->state_ = (VP8LDecodeState )1;
#line 989
    goto End;
  }
  {
#line 993
  total_size = (uint64_t )transform_xsize * (unsigned long )transform_ysize;
#line 994
  __cil_tmp20 = WebPSafeMalloc(total_size, sizeof(*data));
#line 994
  data = (uint32_t *)__cil_tmp20;
  }
#line 995
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 996
    dec->status_ = (enum VP8StatusCode )1;
#line 997
    ok = 0;
#line 998
    goto End;
  }
  {
#line 1003
  ok = DecodeImageData(dec, data, transform_xsize, transform_ysize, (void (*)(VP8LDecoder * const   ,
                                                                              int  ))((void *)0));
  }
#line 1004
  if (ok) {
#line 1004
    if (! br->error_) {
#line 1004
      tmp___4 = 1;
    } else {
#line 1004
      tmp___4 = 0;
    }
  } else {
#line 1004
    tmp___4 = 0;
  }
#line 1004
  ok = tmp___4;
  End: 
#line 1008
  if (! ok) {
    {
#line 1009
    free((void *)data);
#line 1010
    ClearMetadata(hdr);
    }
#line 1013
    if ((unsigned int )dec->status_ == 3U) {
#line 1013
      if (dec->br_.eos_) {
#line 1014
        dec->status_ = (enum VP8StatusCode )5;
      }
    }
  } else {
#line 1017
    if ((unsigned long )decoded_data != (unsigned long )((void *)0)) {
#line 1018
      *decoded_data = data;
    }
#line 1025
    if (! is_level0) {
      {
#line 1025
      ClearMetadata(hdr);
      }
    }
  }
#line 1027
  return (ok);
}
}
#line 1033 "/root/patchweave_new/13/src/dec/vp8l.c"
static int AllocateARGBBuffers(VP8LDecoder *dec , int final_width ) 
{ 
  uint64_t num_pixels ;
  uint64_t cache_top_pixels ;
  uint64_t cache_pixels ;
  uint64_t total_num_pixels ;
  void *__cil_tmp8 ;

  {
  {
#line 1034
  num_pixels = (uint64_t )dec->width_ * (unsigned long )dec->height_;
#line 1037
  cache_top_pixels = (uint64_t )final_width;
#line 1039
  cache_pixels = (uint64_t )final_width * 16UL;
#line 1040
  total_num_pixels = (num_pixels + cache_top_pixels) + cache_pixels;
#line 1044
  __cil_tmp8 = WebPSafeMalloc(total_num_pixels, sizeof(*(dec->argb_)));
#line 1044
  dec->argb_ = (uint32_t *)__cil_tmp8;
  }
#line 1045
  if ((unsigned long )dec->argb_ == (unsigned long )((void *)0)) {
#line 1046
    dec->argb_cache_ = (uint32_t *)((void *)0);
#line 1047
    dec->status_ = (enum VP8StatusCode )1;
#line 1048
    return (0);
  }
#line 1050
  dec->argb_cache_ = (dec->argb_ + num_pixels) + cache_top_pixels;
#line 1051
  return (1);
}
}
#line 1057 "/root/patchweave_new/13/src/dec/vp8l.c"
static void ExtractAlphaRows(VP8LDecoder *dec , int row ) 
{ 
  int num_rows ;
  uint32_t *in ;
  int width ;
  int cache_pixs ;
  uint8_t *dst ;
  uint32_t *src ;
  int i ;

  {
#line 1058
  num_rows = row - dec->last_row_;
#line 1059
  in = dec->argb_ + dec->width_ * dec->last_row_;
#line 1061
  if (num_rows <= 0) {
#line 1061
    return;
  }
  {
#line 1062
  ApplyInverseTransforms(dec, num_rows, in);
#line 1066
  width = (dec->io_)->width;
#line 1067
  cache_pixs = width * num_rows;
#line 1068
  dst = (uint8_t *)(dec->io_)->opaque + width * dec->last_row_;
#line 1069
  src = dec->argb_cache_;
#line 1071
  i = 0;
  }
  {
#line 1071
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1071
    if (! (i < cache_pixs)) {
#line 1071
      goto while_break;
    }
#line 1071
    *(dst + i) = (uint8_t )((*(src + i) >> 8) & 255U);
#line 1071
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1074
  dec->last_out_row_ = row;
#line 1074
  dec->last_row_ = dec->last_out_row_;
#line 1075
  return;
}
}
#line 1077 "/root/patchweave_new/13/src/dec/vp8l.c"
int VP8LDecodeAlphaImageStream(int width , int height , uint8_t *data , size_t data_size ,
                               uint8_t *output ) 
{ 
  VP8Io io ;
  int ok ;
  VP8LDecoder *dec ;
  VP8LDecoder *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1080
  ok = 0;
#line 1081
  __cil_tmp9 = VP8LNew();
#line 1081
  dec = __cil_tmp9;
  }
#line 1082
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 1082
    return (0);
  }
  {
#line 1084
  dec->width_ = width;
#line 1085
  dec->height_ = height;
#line 1086
  dec->io_ = & io;
#line 1088
  VP8InitIo(& io);
#line 1089
  WebPInitCustomIo((WebPDecParams *)((void *)0), & io);
#line 1090
  io.opaque = (void *)output;
#line 1091
  io.width = width;
#line 1092
  io.height = height;
#line 1094
  dec->status_ = (enum VP8StatusCode )0;
#line 1095
  VP8LInitBitReader(& dec->br_, data, data_size);
#line 1097
  dec->action_ = (VP8LDecodeState )1;
#line 1098
  __cil_tmp10 = DecodeImageStream(width, height, 1, dec, (uint32_t **)((void *)0));
  }
#line 1098
  if (! __cil_tmp10) {
#line 1098
    goto Err;
  }
  {
#line 1101
  __cil_tmp11 = AllocateARGBBuffers(dec, width);
  }
#line 1101
  if (! __cil_tmp11) {
#line 1101
    goto Err;
  }
  {
#line 1104
  dec->action_ = (VP8LDecodeState )0;
#line 1105
  ok = DecodeImageData(dec, dec->argb_, dec->width_, dec->height_, (void (*)(VP8LDecoder * const   ,
                                                                             int  ))(& ExtractAlphaRows));
  }
  Err: 
  {
#line 1109
  VP8LDelete(dec);
  }
#line 1110
  return (ok);
}
}
#line 1115 "/root/patchweave_new/13/src/dec/vp8l.c"
int VP8LDecodeHeader(VP8LDecoder *dec , VP8Io *io ) 
{ 
  int width ;
  int height ;
  int has_alpha ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 1118
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 1118
    return (0);
  }
#line 1119
  if ((unsigned long )io == (unsigned long )((void *)0)) {
#line 1120
    dec->status_ = (enum VP8StatusCode )2;
#line 1121
    return (0);
  }
  {
#line 1124
  dec->io_ = io;
#line 1125
  dec->status_ = (enum VP8StatusCode )0;
#line 1126
  VP8LInitBitReader(& dec->br_, io->data, io->data_size);
#line 1127
  __cil_tmp6 = ReadImageInfo(& dec->br_, & width, & height, & has_alpha);
  }
#line 1127
  if (! __cil_tmp6) {
#line 1128
    dec->status_ = (enum VP8StatusCode )3;
#line 1129
    goto Error;
  }
  {
#line 1131
  dec->state_ = (VP8LDecodeState )2;
#line 1132
  io->width = width;
#line 1133
  io->height = height;
#line 1135
  dec->action_ = (VP8LDecodeState )1;
#line 1136
  __cil_tmp7 = DecodeImageStream(width, height, 1, dec, (uint32_t **)((void *)0));
  }
#line 1136
  if (! __cil_tmp7) {
#line 1136
    goto Error;
  }
#line 1137
  return (1);
  Error: 
  {
#line 1140
  VP8LClear(dec);
  }
#line 1142
  return (0);
}
}
#line 1145 "/root/patchweave_new/13/src/dec/vp8l.c"
int VP8LDecodeImage(VP8LDecoder *dec ) 
{ 
  VP8Io *io ;
  WebPDecParams *params ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 1146
  io = (VP8Io *)((void *)0);
#line 1147
  params = (WebPDecParams *)((void *)0);
#line 1150
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 1150
    return (0);
  }
  {
#line 1152
  io = dec->io_;
#line 1154
  params = (WebPDecParams *)io->opaque;
#line 1156
  dec->output_ = params->output;
#line 1160
  __cil_tmp7 = WebPIoInitFromOptions(params->options, io, (enum WEBP_CSP_MODE )3);
  }
#line 1160
  if (! __cil_tmp7) {
#line 1161
    dec->status_ = (enum VP8StatusCode )2;
#line 1162
    goto Err;
  }
  {
#line 1165
  __cil_tmp8 = AllocateARGBBuffers(dec, io->width);
  }
#line 1165
  if (! __cil_tmp8) {
#line 1165
    goto Err;
  }
  {
#line 1167
  __cil_tmp9 = AllocateAndInitRescaler(dec, io);
  }
#line 1167
  if (io->use_scaling) {
#line 1167
    if (! __cil_tmp9) {
#line 1167
      goto Err;
    }
  }
  {
#line 1170
  dec->action_ = (VP8LDecodeState )0;
#line 1171
  __cil_tmp10 = DecodeImageData(dec, dec->argb_, dec->width_, dec->height_, (void (*)(VP8LDecoder * const   ,
                                                                                      int  ))(& ProcessRows));
  }
#line 1171
  if (! __cil_tmp10) {
#line 1173
    goto Err;
  }
  {
#line 1177
  params->last_y = dec->last_out_row_;
#line 1178
  VP8LClear(dec);
  }
#line 1179
  return (1);
  Err: 
  {
#line 1182
  VP8LClear(dec);
  }
#line 1184
  return (0);
}
}
#line 25 "/root/patchweave_new/13/src/dec/vp8.c"
int WebPGetDecoderVersion(void) 
{ 


  {
#line 26
  return (3 << 8);
}
}
#line 32 "/root/patchweave_new/13/src/dec/vp8.c"
static void SetOk(VP8Decoder *dec ) 
{ 


  {
  {
#line 33
  dec->status_ = (enum VP8StatusCode )0;
#line 34
  strcpy((char *)dec->error_msg_, "OK");
  }
#line 35
  return;
}
}
#line 37 "/root/patchweave_new/13/src/dec/vp8.c"
int VP8InitIoInternal(VP8Io *io , int version ) 
{ 


  {
#line 38
  if (version >> 8 != 513 >> 8) {
#line 39
    return (0);
  }
#line 41
  if ((unsigned long )io != (unsigned long )((void *)0)) {
    {
#line 42
    memset((void *)io, 0, sizeof(*io));
    }
  }
#line 44
  return (1);
}
}
#line 47 "/root/patchweave_new/13/src/dec/vp8.c"
VP8Decoder *VP8New(void) 
{ 
  VP8Decoder *dec ;
  void *__cil_tmp2 ;

  {
  {
#line 48
  __cil_tmp2 = calloc(1UL, sizeof(*dec));
#line 48
  dec = (VP8Decoder *)__cil_tmp2;
  }
#line 49
  if ((unsigned long )dec != (unsigned long )((void *)0)) {
    {
#line 50
    SetOk(dec);
#line 51
    WebPWorkerInit(& dec->worker_);
#line 52
    dec->ready_ = 0;
#line 53
    dec->num_parts_ = 1;
    }
  }
#line 55
  return (dec);
}
}
#line 58 "/root/patchweave_new/13/src/dec/vp8.c"
enum VP8StatusCode VP8Status(VP8Decoder *dec ) 
{ 


  {
#line 59
  if (! dec) {
#line 59
    return ((enum VP8StatusCode )2);
  }
#line 60
  return (dec->status_);
}
}
#line 63 "/root/patchweave_new/13/src/dec/vp8.c"
char const   *VP8StatusMessage(VP8Decoder *dec ) 
{ 


  {
#line 64
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 64
    return ("no object");
  }
#line 65
  if (! dec->error_msg_) {
#line 65
    return ("OK");
  }
#line 66
  return (dec->error_msg_);
}
}
#line 69 "/root/patchweave_new/13/src/dec/vp8.c"
void VP8Delete(VP8Decoder *dec ) 
{ 


  {
#line 70
  if ((unsigned long )dec != (unsigned long )((void *)0)) {
    {
#line 71
    VP8Clear(dec);
#line 72
    free((void *)dec);
    }
  }
#line 75
  return;
}
}
#line 76 "/root/patchweave_new/13/src/dec/vp8.c"
int VP8SetError(VP8Decoder *dec , enum VP8StatusCode error , char const   *msg ) 
{ 


  {
#line 82
  if ((unsigned int )dec->status_ == 0U) {
#line 83
    dec->status_ = error;
#line 84
    dec->error_msg_ = msg;
#line 85
    dec->ready_ = 0;
  }
#line 87
  return (0);
}
}
#line 92 "/root/patchweave_new/13/src/dec/vp8.c"
int VP8CheckSignature(uint8_t *data , size_t data_size ) 
{ 
  int tmp___0 ;

  {
#line 93
  if (data_size >= 3UL) {
#line 93
    if ((int )*(data + 0) == 157) {
#line 93
      if ((int )*(data + 1) == 1) {
#line 93
        if ((int )*(data + 2) == 42) {
#line 93
          tmp___0 = 1;
        } else {
#line 93
          tmp___0 = 0;
        }
      } else {
#line 93
        tmp___0 = 0;
      }
    } else {
#line 93
      tmp___0 = 0;
    }
  } else {
#line 93
    tmp___0 = 0;
  }
#line 93
  return (tmp___0);
}
}
#line 97 "/root/patchweave_new/13/src/dec/vp8.c"
int VP8GetInfo(uint8_t *data , size_t data_size , size_t chunk_size , int *width ,
               int *height ) 
{ 
  int __cil_tmp6 ;
  uint32_t bits ;
  int key_frame ;
  int w ;
  int h ;

  {
#line 99
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 100
    return (0);
  } else
#line 99
  if (data_size < 10UL) {
#line 100
    return (0);
  }
  {
#line 103
  __cil_tmp6 = VP8CheckSignature(data + 3, data_size - 3UL);
  }
#line 103
  if (! __cil_tmp6) {
#line 104
    return (0);
  } else {
#line 106
    bits = (uint32_t )(((int )*(data + 0) | ((int )*(data + 1) << 8)) | ((int )*(data + 2) << 16));
#line 107
    key_frame = ! (bits & 1U);
#line 108
    w = (((int )*(data + 7) << 8) | (int )*(data + 6)) & 16383;
#line 109
    h = (((int )*(data + 9) << 8) | (int )*(data + 8)) & 16383;
#line 111
    if (! key_frame) {
#line 112
      return (0);
    }
#line 115
    if (((bits >> 1) & 7U) > 3U) {
#line 116
      return (0);
    }
#line 118
    if (! ((bits >> 4) & 1U)) {
#line 119
      return (0);
    }
#line 121
    if ((unsigned long )(bits >> 5) >= chunk_size) {
#line 122
      return (0);
    }
#line 125
    if (width) {
#line 126
      *width = w;
    }
#line 128
    if (height) {
#line 129
      *height = h;
    }
#line 132
    return (1);
  }
}
}
#line 139 "/root/patchweave_new/13/src/dec/vp8.c"
static void ResetSegmentHeader___0(VP8SegmentHeader___0 *hdr ) 
{ 


  {
  {
#line 141
  hdr->use_segment_ = 0;
#line 142
  hdr->update_map_ = 0;
#line 143
  hdr->absolute_delta_ = 1;
#line 144
  memset((void *)(hdr->quantizer_), 0, sizeof(hdr->quantizer_));
#line 145
  memset((void *)(hdr->filter_strength_), 0, sizeof(hdr->filter_strength_));
  }
#line 147
  return;
}
}
#line 149 "/root/patchweave_new/13/src/dec/vp8.c"
static int ParseSegmentHeader(VP8BitReader *br , VP8SegmentHeader___0 *hdr , VP8Proba___0 *proba ) 
{ 
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  int s ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  int32_t __cil_tmp12 ;
  int32_t tmp___2 ;
  uint32_t __cil_tmp14 ;
  int32_t __cil_tmp15 ;
  int32_t tmp___3 ;
  int s___0 ;
  uint32_t __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  uint32_t tmp___4 ;

  {
  {
#line 153
  __cil_tmp6 = VP8Get(br);
#line 153
  hdr->use_segment_ = (int )__cil_tmp6;
  }
#line 154
  if (hdr->use_segment_) {
    {
#line 155
    __cil_tmp7 = VP8Get(br);
#line 155
    hdr->update_map_ = (int )__cil_tmp7;
#line 156
    __cil_tmp8 = VP8Get(br);
    }
#line 156
    if (__cil_tmp8) {
      {
#line 158
      __cil_tmp10 = VP8Get(br);
#line 158
      hdr->absolute_delta_ = (int )__cil_tmp10;
#line 159
      s = 0;
      }
      {
#line 159
      while (1) {
        while_continue: /* CIL Label */ ;

#line 159
        if (! (s < 4)) {
#line 159
          goto while_break;
        }
        {
#line 160
        __cil_tmp11 = VP8Get(br);
        }
#line 160
        if (__cil_tmp11) {
          {
#line 160
          __cil_tmp12 = VP8GetSignedValue(br, 7);
#line 160
          tmp___2 = __cil_tmp12;
          }
        } else {
#line 160
          tmp___2 = 0;
        }
#line 160
        hdr->quantizer_[s] = (int8_t )tmp___2;
#line 159
        s ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: 
#line 162
      s = 0;
      {
#line 162
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 162
        if (! (s < 4)) {
#line 162
          goto while_break___0;
        }
        {
#line 163
        __cil_tmp14 = VP8Get(br);
        }
#line 163
        if (__cil_tmp14) {
          {
#line 163
          __cil_tmp15 = VP8GetSignedValue(br, 6);
#line 163
          tmp___3 = __cil_tmp15;
          }
        } else {
#line 163
          tmp___3 = 0;
        }
#line 163
        hdr->filter_strength_[s] = (int8_t )tmp___3;
#line 162
        s ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 166
    if (hdr->update_map_) {
#line 168
      s___0 = 0;
      {
#line 168
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 168
        if (! (s___0 < 3)) {
#line 168
          goto while_break___1;
        }
        {
#line 169
        __cil_tmp18 = VP8Get(br);
        }
#line 169
        if (__cil_tmp18) {
          {
#line 169
          __cil_tmp19 = VP8GetValue(br, 8);
#line 169
          tmp___4 = __cil_tmp19;
          }
        } else {
#line 169
          tmp___4 = 255U;
        }
#line 169
        proba->segments_[s___0] = (uint8_t )tmp___4;
#line 168
        s___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
  } else {
#line 173
    hdr->update_map_ = 0;
  }
#line 175
  return (! br->eof_);
}
}
#line 187 "/root/patchweave_new/13/src/dec/vp8.c"
static enum VP8StatusCode ParsePartitions(VP8Decoder *dec , uint8_t *buf , size_t size ) 
{ 
  VP8BitReader *br ;
  uint8_t *sz ;
  uint8_t *buf_end ;
  uint8_t *part_start ;
  int last_part ;
  int p ;
  uint32_t __cil_tmp10 ;
  uint32_t psize ;
  uint8_t *part_end ;
  int tmp___0 ;

  {
  {
#line 189
  br = & dec->br_;
#line 190
  sz = buf;
#line 191
  buf_end = buf + size;
#line 196
  __cil_tmp10 = VP8GetValue(br, 2);
#line 196
  dec->num_parts_ = 1 << __cil_tmp10;
#line 197
  last_part = dec->num_parts_ - 1;
#line 198
  part_start = buf + last_part * 3;
  }
#line 199
  if ((unsigned long )buf_end < (unsigned long )part_start) {
#line 201
    return ((enum VP8StatusCode )7);
  }
#line 203
  p = 0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;

#line 203
    if (! (p < last_part)) {
#line 203
      goto while_break;
    }
#line 204
    psize = (uint32_t )(((int )*(sz + 0) | ((int )*(sz + 1) << 8)) | ((int )*(sz + 2) << 16));
#line 205
    part_end = part_start + psize;
#line 206
    if ((unsigned long )part_end > (unsigned long )buf_end) {
#line 206
      part_end = buf_end;
    }
    {
#line 207
    VP8InitBitReader(dec->parts_ + p, part_start, part_end);
#line 208
    part_start = part_end;
#line 209
    sz += 3;
#line 203
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 211
  VP8InitBitReader(dec->parts_ + last_part, part_start, buf_end);
  }
#line 212
  if ((unsigned long )part_start < (unsigned long )buf_end) {
#line 212
    tmp___0 = 0;
  } else {
#line 212
    tmp___0 = 5;
  }
#line 212
  return ((enum VP8StatusCode )tmp___0);
}
}
#line 217 "/root/patchweave_new/13/src/dec/vp8.c"
static int ParseFilterHeader(VP8BitReader *br , VP8Decoder *dec ) 
{ 
  VP8FilterHeader___0 *hdr ;
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  int i ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp12 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 218
  hdr = & dec->filter_hdr_;
#line 219
  __cil_tmp4 = VP8Get(br);
#line 219
  hdr->simple_ = (int )__cil_tmp4;
#line 220
  __cil_tmp5 = VP8GetValue(br, 6);
#line 220
  hdr->level_ = (int )__cil_tmp5;
#line 221
  __cil_tmp6 = VP8GetValue(br, 3);
#line 221
  hdr->sharpness_ = (int )__cil_tmp6;
#line 222
  __cil_tmp7 = VP8Get(br);
#line 222
  hdr->use_lf_delta_ = (int )__cil_tmp7;
  }
#line 223
  if (hdr->use_lf_delta_) {
    {
#line 224
    __cil_tmp8 = VP8Get(br);
    }
#line 224
    if (__cil_tmp8) {
#line 226
      i = 0;
      {
#line 226
      while (1) {
        while_continue: /* CIL Label */ ;

#line 226
        if (! (i < 4)) {
#line 226
          goto while_break;
        }
        {
#line 227
        __cil_tmp10 = VP8Get(br);
        }
#line 227
        if (__cil_tmp10) {
          {
#line 228
          hdr->ref_lf_delta_[i] = VP8GetSignedValue(br, 6);
          }
        }
#line 226
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: 
#line 231
      i = 0;
      {
#line 231
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 231
        if (! (i < 4)) {
#line 231
          goto while_break___0;
        }
        {
#line 232
        __cil_tmp12 = VP8Get(br);
        }
#line 232
        if (__cil_tmp12) {
          {
#line 233
          hdr->mode_lf_delta_[i] = VP8GetSignedValue(br, 6);
          }
        }
#line 231
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
  }
#line 238
  if (hdr->level_ == 0) {
#line 238
    tmp___1 = 0;
  } else {
#line 238
    if (hdr->simple_) {
#line 238
      tmp___0 = 1;
    } else {
#line 238
      tmp___0 = 2;
    }
#line 238
    tmp___1 = tmp___0;
  }
#line 238
  dec->filter_type_ = tmp___1;
#line 239
  return (! br->eof_);
}
}
#line 243 "/root/patchweave_new/13/src/dec/vp8.c"
int VP8GetHeaders(VP8Decoder *dec , VP8Io *io ) 
{ 
  uint8_t *buf ;
  size_t buf_size ;
  VP8FrameHeader *frm_hdr ;
  VP8PictureHeader *pic_hdr ;
  VP8BitReader *br ;
  enum VP8StatusCode status ;
  WebPHeaderStructure headers ;
  int __cil_tmp10 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp16 ;
  uint32_t bits ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 252
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 253
    return (0);
  }
  {
#line 255
  SetOk(dec);
  }
#line 256
  if ((unsigned long )io == (unsigned long )((void *)0)) {
    {
#line 257
    __cil_tmp10 = VP8SetError(dec, (enum VP8StatusCode )2, "null VP8Io passed to VP8GetHeaders()\210U");
    }
#line 257
    return (__cil_tmp10);
  }
  {
#line 262
  headers.data = io->data;
#line 263
  headers.data_size = io->data_size;
#line 264
  status = WebPParseHeaders(& headers);
  }
#line 265
  if ((unsigned int )status != 0U) {
    {
#line 266
    __cil_tmp12 = VP8SetError(dec, status, "Incorrect/incomplete header.\210U");
    }
#line 266
    return (__cil_tmp12);
  }
#line 268
  if (headers.is_lossless) {
    {
#line 269
    __cil_tmp13 = VP8SetError(dec, (enum VP8StatusCode )3, "Unexpected lossless format encountered.");
    }
#line 269
    return (__cil_tmp13);
  }
#line 273
  if ((unsigned long )dec->alpha_data_ == (unsigned long )((void *)0)) {
#line 279
    dec->alpha_data_ = headers.alpha_data;
#line 280
    dec->alpha_data_size_ = headers.alpha_data_size;
  }
#line 284
  buf = headers.data + headers.offset;
#line 285
  buf_size = headers.data_size - headers.offset;
#line 287
  if (buf_size < 4UL) {
    {
#line 288
    __cil_tmp16 = VP8SetError(dec, (enum VP8StatusCode )7, "Truncated header.");
    }
#line 288
    return (__cil_tmp16);
  }
#line 294
  bits = (uint32_t )(((int )*(buf + 0) | ((int )*(buf + 1) << 8)) | ((int )*(buf + 2) << 16));
#line 295
  frm_hdr = & dec->frm_hdr_;
#line 296
  frm_hdr->key_frame_ = (uint8_t )(! (bits & 1U));
#line 297
  frm_hdr->profile_ = (uint8_t )((bits >> 1) & 7U);
#line 298
  frm_hdr->show_ = (uint8_t )((bits >> 4) & 1U);
#line 299
  frm_hdr->partition_length_ = bits >> 5;
#line 300
  if ((int )frm_hdr->profile_ > 3) {
    {
#line 301
    __cil_tmp18 = VP8SetError(dec, (enum VP8StatusCode )3, "Incorrect keyframe parameters.");
    }
#line 301
    return (__cil_tmp18);
  }
#line 303
  if (! frm_hdr->show_) {
    {
#line 304
    __cil_tmp19 = VP8SetError(dec, (enum VP8StatusCode )4, "Frame not displayable.");
    }
#line 304
    return (__cil_tmp19);
  }
#line 306
  buf += 3;
#line 307
  buf_size -= 3UL;
#line 310
  pic_hdr = & dec->pic_hdr_;
#line 311
  if (frm_hdr->key_frame_) {
#line 313
    if (buf_size < 7UL) {
      {
#line 314
      __cil_tmp20 = VP8SetError(dec, (enum VP8StatusCode )7, "cannot parse picture header");
      }
#line 314
      return (__cil_tmp20);
    }
    {
#line 317
    __cil_tmp21 = VP8CheckSignature(buf, buf_size);
    }
#line 317
    if (! __cil_tmp21) {
      {
#line 318
      __cil_tmp22 = VP8SetError(dec, (enum VP8StatusCode )3, "Bad code word");
      }
#line 318
      return (__cil_tmp22);
    }
    {
#line 321
    pic_hdr->width_ = (uint16_t )((((int )*(buf + 4) << 8) | (int )*(buf + 3)) & 16383);
#line 322
    pic_hdr->xscale_ = (uint8_t )((int )*(buf + 4) >> 6);
#line 323
    pic_hdr->height_ = (uint16_t )((((int )*(buf + 6) << 8) | (int )*(buf + 5)) & 16383);
#line 324
    pic_hdr->yscale_ = (uint8_t )((int )*(buf + 6) >> 6);
#line 325
    buf += 7;
#line 326
    buf_size -= 7UL;
#line 328
    dec->mb_w_ = ((int )pic_hdr->width_ + 15) >> 4;
#line 329
    dec->mb_h_ = ((int )pic_hdr->height_ + 15) >> 4;
#line 331
    io->width = (int )pic_hdr->width_;
#line 332
    io->height = (int )pic_hdr->height_;
#line 333
    io->use_scaling = 0;
#line 334
    io->use_cropping = 0;
#line 335
    io->crop_top = 0;
#line 336
    io->crop_left = 0;
#line 337
    io->crop_right = io->width;
#line 338
    io->crop_bottom = io->height;
#line 339
    io->mb_w = io->width;
#line 340
    io->mb_h = io->height;
#line 342
    VP8ResetProba(& dec->proba_);
#line 343
    ResetSegmentHeader___0(& dec->segment_hdr_);
#line 344
    dec->segment_ = (uint8_t )0;
    }
  }
#line 349
  if ((unsigned long )frm_hdr->partition_length_ > buf_size) {
    {
#line 350
    __cil_tmp23 = VP8SetError(dec, (enum VP8StatusCode )7, "bad partition length");
    }
#line 350
    return (__cil_tmp23);
  }
  {
#line 354
  br = & dec->br_;
#line 355
  VP8InitBitReader(br, buf, buf + frm_hdr->partition_length_);
#line 356
  buf += frm_hdr->partition_length_;
#line 357
  buf_size -= (unsigned long )frm_hdr->partition_length_;
  }
#line 359
  if (frm_hdr->key_frame_) {
    {
#line 360
    __cil_tmp24 = VP8Get(br);
#line 360
    pic_hdr->colorspace_ = (uint8_t )__cil_tmp24;
#line 361
    __cil_tmp25 = VP8Get(br);
#line 361
    pic_hdr->clamp_type_ = (uint8_t )__cil_tmp25;
    }
  }
  {
#line 363
  __cil_tmp26 = ParseSegmentHeader(br, & dec->segment_hdr_, & dec->proba_);
  }
#line 363
  if (! __cil_tmp26) {
    {
#line 364
    __cil_tmp27 = VP8SetError(dec, (enum VP8StatusCode )3, "cannot parse segment header");
    }
#line 364
    return (__cil_tmp27);
  }
  {
#line 368
  __cil_tmp28 = ParseFilterHeader(br, dec);
  }
#line 368
  if (! __cil_tmp28) {
    {
#line 369
    __cil_tmp29 = VP8SetError(dec, (enum VP8StatusCode )3, "cannot parse filter header");
    }
#line 369
    return (__cil_tmp29);
  }
  {
#line 372
  status = ParsePartitions(dec, buf, buf_size);
  }
#line 373
  if ((unsigned int )status != 0U) {
    {
#line 374
    __cil_tmp31 = VP8SetError(dec, status, "cannot parse partitions");
    }
#line 374
    return (__cil_tmp31);
  }
  {
#line 378
  VP8ParseQuant(dec);
  }
#line 381
  if (! frm_hdr->key_frame_) {
    {
#line 395
    __cil_tmp32 = VP8SetError(dec, (enum VP8StatusCode )4, "Not a key frame.\220");
    }
#line 395
    return (__cil_tmp32);
  } else {
#line 399
    dec->buffer_flags_ = (uint32_t )259;
  }
  {
#line 412
  VP8Get(br);
#line 415
  VP8ParseProba(br, dec);
#line 440
  dec->ready_ = 1;
  }
#line 441
  return (1);
}
}
#line 447 "/root/patchweave_new/13/src/dec/vp8.c"
static int const   kBands[17]  = 
#line 447
  {      (int const   )0,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )6,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )6,      (int const   )6,      (int const   )6,      (int const   )6, 
        (int const   )6,      (int const   )6,      (int const   )6,      (int const   )7, 
        (int const   )0};
#line 452 "/root/patchweave_new/13/src/dec/vp8.c"
static uint8_t kCat3[4]  = {      (uint8_t )173,      (uint8_t )148,      (uint8_t )140,      (uint8_t )0};
#line 453 "/root/patchweave_new/13/src/dec/vp8.c"
static uint8_t kCat4[5]  = {      (uint8_t )176,      (uint8_t )155,      (uint8_t )140,      (uint8_t )135, 
        (uint8_t )0};
#line 454 "/root/patchweave_new/13/src/dec/vp8.c"
static uint8_t kCat5[6]  = {      (uint8_t )180,      (uint8_t )157,      (uint8_t )141,      (uint8_t )134, 
        (uint8_t )130,      (uint8_t )0};
#line 455 "/root/patchweave_new/13/src/dec/vp8.c"
static uint8_t kCat6[12]  = 
#line 455
  {      (uint8_t )254,      (uint8_t )254,      (uint8_t )243,      (uint8_t )230, 
        (uint8_t )196,      (uint8_t )177,      (uint8_t )153,      (uint8_t )140, 
        (uint8_t )133,      (uint8_t )130,      (uint8_t )129,      (uint8_t )0};
#line 457 "/root/patchweave_new/13/src/dec/vp8.c"
static uint8_t * const  kCat3456[4]  = {      (uint8_t */* const  */)(kCat3),      (uint8_t */* const  */)(kCat4),      (uint8_t */* const  */)(kCat5),      (uint8_t */* const  */)(kCat6)};
#line 458 "/root/patchweave_new/13/src/dec/vp8.c"
static uint8_t kZigzag___1[16]  = 
#line 458
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )4,      (uint8_t )8, 
        (uint8_t )5,      (uint8_t )2,      (uint8_t )3,      (uint8_t )6, 
        (uint8_t )9,      (uint8_t )12,      (uint8_t )13,      (uint8_t )10, 
        (uint8_t )7,      (uint8_t )11,      (uint8_t )14,      (uint8_t )15};
#line 466 "/root/patchweave_new/13/src/dec/vp8.c"
static int GetLargeValue(VP8BitReader *br , uint8_t *p ) 
{ 
  int v ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  uint8_t *tab ;
  int bit1 ;
  int __cil_tmp14 ;
  int bit0 ;
  int __cil_tmp16 ;
  int cat ;
  int __cil_tmp18 ;

  {
  {
#line 468
  __cil_tmp4 = VP8GetBit(br, (int )*(p + 3));
  }
#line 468
  if (! __cil_tmp4) {
    {
#line 469
    __cil_tmp5 = VP8GetBit(br, (int )*(p + 4));
    }
#line 469
    if (! __cil_tmp5) {
#line 470
      v = 2;
    } else {
      {
#line 472
      __cil_tmp6 = VP8GetBit(br, (int )*(p + 5));
#line 472
      v = 3 + __cil_tmp6;
      }
    }
  } else {
    {
#line 475
    __cil_tmp7 = VP8GetBit(br, (int )*(p + 6));
    }
#line 475
    if (! __cil_tmp7) {
      {
#line 476
      __cil_tmp8 = VP8GetBit(br, (int )*(p + 7));
      }
#line 476
      if (! __cil_tmp8) {
        {
#line 477
        __cil_tmp9 = VP8GetBit(br, 159);
#line 477
        v = 5 + __cil_tmp9;
        }
      } else {
        {
#line 479
        __cil_tmp10 = VP8GetBit(br, 165);
#line 479
        v = 7 + 2 * __cil_tmp10;
#line 480
        __cil_tmp11 = VP8GetBit(br, 145);
#line 480
        v += __cil_tmp11;
        }
      }
    } else {
      {
#line 484
      __cil_tmp14 = VP8GetBit(br, (int )*(p + 8));
#line 484
      bit1 = __cil_tmp14;
#line 485
      __cil_tmp16 = VP8GetBit(br, (int )*(p + (9 + bit1)));
#line 485
      bit0 = __cil_tmp16;
#line 486
      cat = 2 * bit1 + bit0;
#line 487
      v = 0;
#line 488
      tab = (uint8_t *)kCat3456[cat];
      }
      {
#line 488
      while (1) {
        while_continue: /* CIL Label */ ;

#line 488
        if (! *tab) {
#line 488
          goto while_break;
        }
        {
#line 489
        __cil_tmp18 = VP8GetBit(br, (int )*tab);
#line 489
        v += v + __cil_tmp18;
#line 488
        tab ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
#line 491
      v += 3 + (8 << cat);
    }
  }
#line 494
  return (v);
}
}
#line 499 "/root/patchweave_new/13/src/dec/vp8.c"
static int GetCoeffs(VP8BitReader *br , ProbaArray___0 prob , int ctx , int *dq ,
                     int n , int16_t *out ) 
{ 
  uint8_t *p ;
  int __cil_tmp8 ;
  ProbaCtxArray p_ctx ;
  int __cil_tmp10 ;
  int v ;
  int __cil_tmp12 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 502
  p = (*(prob + n))[ctx];
#line 503
  __cil_tmp8 = VP8GetBit(br, (int )*(p + 0));
  }
#line 503
  if (! __cil_tmp8) {
#line 504
    return (0);
  }
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;

#line 506
    if (! (n < 16)) {
#line 506
      goto while_break;
    }
    {
#line 507
    p_ctx = *(prob + kBands[n + 1]);
#line 508
    __cil_tmp10 = VP8GetBit(br, (int )*(p + 1));
    }
#line 508
    if (! __cil_tmp10) {
#line 509
      p = *(p_ctx + 0);
    } else {
      {
#line 512
      __cil_tmp12 = VP8GetBit(br, (int )*(p + 2));
      }
#line 512
      if (! __cil_tmp12) {
#line 513
        v = 1;
#line 514
        p = *(p_ctx + 1);
      } else {
        {
#line 516
        v = GetLargeValue(br, p);
#line 517
        p = *(p_ctx + 2);
        }
      }
      {
#line 519
      __cil_tmp14 = VP8GetSigned(br, v);
#line 519
      *(out + (int )kZigzag___1[n]) = (int16_t )(__cil_tmp14 * *(dq + (n > 0)));
#line 520
      __cil_tmp15 = VP8GetBit(br, (int )*(p + 0));
      }
#line 520
      if (n < 15) {
#line 520
        if (! __cil_tmp15) {
#line 521
          return (n + 1);
        }
      }
    }
#line 506
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 525
  return (16);
}
}
#line 535 "/root/patchweave_new/13/src/dec/vp8.c"
static PackedNz kUnpackTab[16]  = 
#line 535
  {      {{(uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0}}, 
        {{(uint8_t )1, (uint8_t )0, (uint8_t )0, (uint8_t )0}}, 
        {{(uint8_t )0, (uint8_t )1, (uint8_t )0, (uint8_t )0}}, 
        {{(uint8_t )1, (uint8_t )1, (uint8_t )0, (uint8_t )0}}, 
        {{(uint8_t )0, (uint8_t )0, (uint8_t )1, (uint8_t )0}}, 
        {{(uint8_t )1, (uint8_t )0, (uint8_t )1, (uint8_t )0}}, 
        {{(uint8_t )0, (uint8_t )1, (uint8_t )1, (uint8_t )0}}, 
        {{(uint8_t )1, (uint8_t )1, (uint8_t )1, (uint8_t )0}}, 
        {{(uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )1}}, 
        {{(uint8_t )1, (uint8_t )0, (uint8_t )0, (uint8_t )1}}, 
        {{(uint8_t )0, (uint8_t )1, (uint8_t )0, (uint8_t )1}}, 
        {{(uint8_t )1, (uint8_t )1, (uint8_t )0, (uint8_t )1}}, 
        {{(uint8_t )0, (uint8_t )0, (uint8_t )1, (uint8_t )1}}, 
        {{(uint8_t )1, (uint8_t )0, (uint8_t )1, (uint8_t )1}}, 
        {{(uint8_t )0, (uint8_t )1, (uint8_t )1, (uint8_t )1}}, 
        {{(uint8_t )1, (uint8_t )1, (uint8_t )1, (uint8_t )1}}};
#line 550 "/root/patchweave_new/13/src/dec/vp8.c"
static void ParseResiduals(VP8Decoder *dec , VP8MB *mb , VP8BitReader *token_br ) 
{ 
  int out_t_nz ;
  int out_l_nz ;
  int first ;
  ProbaArray___0 ac_prob ;
  VP8QuantMatrix *q ;
  int16_t *dst ;
  VP8MB *left_mb ;
  PackedNz nz_ac ;
  PackedNz nz_dc ;
  PackedNz tnz ;
  PackedNz lnz ;
  uint32_t non_zero_ac ;
  uint32_t non_zero_dc ;
  int x ;
  int y ;
  int ch ;
  int16_t dc[16] ;
  unsigned int tmp___0 ;
  int ctx ;
  int __cil_tmp23 ;
  int l ;
  int ctx___0 ;
  int nz ;
  int __cil_tmp27 ;
  int l___0 ;
  int ctx___1 ;
  int nz___0 ;
  int __cil_tmp31 ;

  {
  {
#line 554
  q = & dec->dqm_[dec->segment_];
#line 555
  dst = dec->coeffs_;
#line 556
  left_mb = dec->mb_info_ - 1;
#line 559
  non_zero_ac = (uint32_t )0;
#line 560
  non_zero_dc = (uint32_t )0;
#line 563
  nz_ac.i32 = (uint32_t )0;
#line 563
  nz_dc.i32 = nz_ac.i32;
#line 564
  memset((void *)dst, 0, 384UL * sizeof(*dst));
  }
#line 565
  if (! dec->is_i4x4_) {
#line 566
    dc[0] = (int16_t )0;
#line 566
    tmp___0 = 1U;
    {
#line 566
    while (1) {
      while_continue: /* CIL Label */ ;

#line 566
      if (tmp___0 >= 16U) {
#line 566
        goto while_break;
      }
#line 566
      dc[tmp___0] = (int16_t )0;
#line 566
      tmp___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: 
    {
#line 567
    ctx = (int )mb->dc_nz_ + (int )left_mb->dc_nz_;
#line 568
    __cil_tmp23 = GetCoeffs(token_br, dec->proba_.coeffs_[1], ctx, (int *)((int const   *)(q->y2_mat_)),
                            0, dc);
#line 568
    left_mb->dc_nz_ = (unsigned int )(__cil_tmp23 > 0);
#line 568
    mb->dc_nz_ = left_mb->dc_nz_;
#line 571
    first = 1;
#line 572
    ac_prob = dec->proba_.coeffs_[0];
#line 573
    (*VP8TransformWHT)(dc, dst);
    }
  } else {
#line 575
    first = 0;
#line 576
    ac_prob = dec->proba_.coeffs_[3];
  }
#line 579
  tnz = kUnpackTab[(int )mb->nz_ & 15];
#line 580
  lnz = kUnpackTab[(int )left_mb->nz_ & 15];
#line 581
  y = 0;
  {
#line 581
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 581
    if (! (y < 4)) {
#line 581
      goto while_break___0;
    }
#line 582
    l = (int )lnz.i8[y];
#line 583
    x = 0;
    {
#line 583
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 583
      if (! (x < 4)) {
#line 583
        goto while_break___1;
      }
      {
#line 584
      ctx___0 = l + (int )tnz.i8[x];
#line 585
      __cil_tmp27 = GetCoeffs(token_br, ac_prob, ctx___0, (int *)((int const   *)(q->y1_mat_)),
                              first, dst);
#line 585
      nz = __cil_tmp27;
#line 587
      l = nz > 0;
#line 587
      tnz.i8[x] = (uint8_t )l;
#line 588
      nz_dc.i8[x] = (uint8_t )((int )*(dst + 0) != 0);
#line 589
      nz_ac.i8[x] = (uint8_t )(nz > 1);
#line 590
      dst += 16;
#line 583
      x ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
#line 592
    lnz.i8[y] = (uint8_t )l;
#line 593
    non_zero_dc |= (nz_dc.i32 * 16909320U & 4278190080U) >> (24 - y * 4);
#line 594
    non_zero_ac |= (nz_ac.i32 * 16909320U & 4278190080U) >> (24 - y * 4);
#line 581
    y ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 596
  out_t_nz = (int )((tnz.i32 * 16909320U & 4278190080U) >> 24);
#line 597
  out_l_nz = (int )((lnz.i32 * 16909320U & 4278190080U) >> 24);
#line 599
  tnz = kUnpackTab[(int )mb->nz_ >> 4];
#line 600
  lnz = kUnpackTab[(int )left_mb->nz_ >> 4];
#line 601
  ch = 0;
  {
#line 601
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 601
    if (! (ch < 4)) {
#line 601
      goto while_break___2;
    }
#line 602
    y = 0;
    {
#line 602
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 602
      if (! (y < 2)) {
#line 602
        goto while_break___3;
      }
#line 603
      l___0 = (int )lnz.i8[ch + y];
#line 604
      x = 0;
      {
#line 604
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 604
        if (! (x < 2)) {
#line 604
          goto while_break___4;
        }
        {
#line 605
        ctx___1 = l___0 + (int )tnz.i8[ch + x];
#line 606
        __cil_tmp31 = GetCoeffs(token_br, dec->proba_.coeffs_[2], ctx___1, (int *)((int const   *)(q->uv_mat_)),
                                0, dst);
#line 606
        nz___0 = __cil_tmp31;
#line 609
        l___0 = nz___0 > 0;
#line 609
        tnz.i8[ch + x] = (uint8_t )l___0;
#line 610
        nz_dc.i8[y * 2 + x] = (uint8_t )((int )*(dst + 0) != 0);
#line 611
        nz_ac.i8[y * 2 + x] = (uint8_t )(nz___0 > 1);
#line 612
        dst += 16;
#line 604
        x ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 614
      lnz.i8[ch + y] = (uint8_t )l___0;
#line 602
      y ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 616
    non_zero_dc |= (nz_dc.i32 * 16909320U & 4278190080U) >> (8 - ch * 2);
#line 617
    non_zero_ac |= (nz_ac.i32 * 16909320U & 4278190080U) >> (8 - ch * 2);
#line 601
    ch += 2;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
#line 619
  out_t_nz = (int )((unsigned int )out_t_nz | ((tnz.i32 * 16909320U & 4278190080U) >> 20));
#line 620
  out_l_nz = (int )((unsigned int )out_l_nz | ((lnz.i32 * 16909320U & 4278190080U) >> 20));
#line 621
  mb->nz_ = (unsigned int )out_t_nz;
#line 622
  left_mb->nz_ = (unsigned int )out_l_nz;
#line 624
  dec->non_zero_ac_ = non_zero_ac;
#line 625
  dec->non_zero_ = non_zero_ac | non_zero_dc;
#line 626
  mb->skip_ = (unsigned int )(! dec->non_zero_);
#line 627
  return;
}
}
#line 633 "/root/patchweave_new/13/src/dec/vp8.c"
int VP8DecodeMB(VP8Decoder *dec , VP8BitReader *token_br ) 
{ 
  VP8BitReader *br ;
  VP8MB *left ;
  VP8MB *info ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp___0 ;
  int __cil_tmp10 ;
  int tmp___1 ;
  VP8FInfo *finfo ;
  int tmp___2 ;

  {
#line 634
  br = & dec->br_;
#line 635
  left = dec->mb_info_ - 1;
#line 636
  info = dec->mb_info_ + dec->mb_x_;
#line 640
  if (dec->segment_hdr_.update_map_) {
    {
#line 642
    __cil_tmp6 = VP8GetBit(br, (int )dec->proba_.segments_[0]);
    }
#line 642
    if (! __cil_tmp6) {
      {
#line 642
      __cil_tmp7 = VP8GetBit(br, (int )dec->proba_.segments_[1]);
#line 642
      tmp___0 = __cil_tmp7;
      }
    } else {
      {
#line 642
      __cil_tmp8 = VP8GetBit(br, (int )dec->proba_.segments_[2]);
#line 642
      tmp___0 = 2 + __cil_tmp8;
      }
    }
#line 642
    dec->segment_ = (uint8_t )tmp___0;
  }
#line 646
  if (dec->use_skip_proba_) {
    {
#line 646
    __cil_tmp10 = VP8GetBit(br, (int )dec->skip_p_);
#line 646
    tmp___1 = __cil_tmp10;
    }
  } else {
#line 646
    tmp___1 = 0;
  }
  {
#line 646
  info->skip_ = (unsigned int )tmp___1;
#line 648
  VP8ParseIntraMode(br, dec);
  }
#line 649
  if (br->eof_) {
#line 650
    return (0);
  }
#line 653
  if (! info->skip_) {
    {
#line 654
    ParseResiduals(dec, info, token_br);
    }
  } else {
#line 656
    info->nz_ = 0U;
#line 656
    left->nz_ = info->nz_;
#line 657
    if (! dec->is_i4x4_) {
#line 658
      info->dc_nz_ = 0U;
#line 658
      left->dc_nz_ = info->dc_nz_;
    }
#line 660
    dec->non_zero_ = (uint32_t )0;
#line 661
    dec->non_zero_ac_ = (uint32_t )0;
  }
#line 664
  if (dec->filter_type_ > 0) {
#line 665
    finfo = dec->f_info_ + dec->mb_x_;
#line 666
    *finfo = dec->fstrengths_[dec->segment_][dec->is_i4x4_];
#line 667
    if (! info->skip_) {
#line 667
      tmp___2 = 1;
    } else
#line 667
    if ((int )dec->is_i4x4_) {
#line 667
      tmp___2 = 1;
    } else {
#line 667
      tmp___2 = 0;
    }
#line 667
    finfo->f_inner_ = (unsigned int )tmp___2;
  }
#line 670
  return (! token_br->eof_);
}
}
#line 673 "/root/patchweave_new/13/src/dec/vp8.c"
void VP8InitScanline(VP8Decoder *dec ) 
{ 
  VP8MB *left ;
  int tmp___0 ;

  {
  {
#line 674
  left = dec->mb_info_ - 1;
#line 675
  left->nz_ = 0U;
#line 676
  left->dc_nz_ = 0U;
#line 677
  memset((void *)(dec->intra_l_), 0, sizeof(dec->intra_l_));
  }
#line 678
  if (dec->filter_type_ > 0) {
#line 678
    if (dec->mb_y_ >= dec->tl_mb_y_) {
#line 678
      if (dec->mb_y_ <= dec->br_mb_y_) {
#line 678
        tmp___0 = 1;
      } else {
#line 678
        tmp___0 = 0;
      }
    } else {
#line 678
      tmp___0 = 0;
    }
  } else {
#line 678
    tmp___0 = 0;
  }
#line 678
  dec->filter_row_ = tmp___0;
#line 680
  return;
}
}
#line 683 "/root/patchweave_new/13/src/dec/vp8.c"
static int ParseFrame(VP8Decoder *dec , VP8Io *io ) 
{ 
  VP8BitReader *token_br ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 684
  dec->mb_y_ = 0;
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;

#line 684
    if (! (dec->mb_y_ < dec->br_mb_y_)) {
#line 684
      goto while_break;
    }
    {
#line 685
    token_br = & dec->parts_[dec->mb_y_ & (dec->num_parts_ - 1)];
#line 687
    VP8InitScanline(dec);
#line 688
    dec->mb_x_ = 0;
    }
    {
#line 688
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 688
      if (! (dec->mb_x_ < dec->mb_w_)) {
#line 688
        goto while_break___0;
      }
      {
#line 689
      __cil_tmp4 = VP8DecodeMB(dec, token_br);
      }
#line 689
      if (! __cil_tmp4) {
        {
#line 690
        __cil_tmp5 = VP8SetError(dec, (enum VP8StatusCode )7, "Premature end-of-file encountered.");
        }
#line 690
        return (__cil_tmp5);
      }
      {
#line 694
      VP8ReconstructBlock(dec);
#line 688
      (dec->mb_x_) ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 696
    __cil_tmp7 = VP8ProcessRow(dec, io);
    }
#line 696
    if (! __cil_tmp7) {
      {
#line 697
      __cil_tmp8 = VP8SetError(dec, (enum VP8StatusCode )6, "Output aborted.");
      }
#line 697
      return (__cil_tmp8);
    }
#line 684
    (dec->mb_y_) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 700
  __cil_tmp9 = WebPWorkerSync(& dec->worker_);
  }
#line 700
  if (dec->use_threads_) {
#line 700
    if (! __cil_tmp9) {
#line 701
      return (0);
    }
  }
#line 719
  return (1);
}
}
#line 723 "/root/patchweave_new/13/src/dec/vp8.c"
int VP8Decode(VP8Decoder *dec , VP8Io *io ) 
{ 
  int ok ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  enum VP8StatusCode __cil_tmp7 ;
  int __cil_tmp10 ;

  {
#line 724
  ok = 0;
#line 725
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 726
    return (0);
  }
#line 728
  if ((unsigned long )io == (unsigned long )((void *)0)) {
    {
#line 729
    __cil_tmp4 = VP8SetError(dec, (enum VP8StatusCode )2, "NULL VP8Io parameter in VP8Decode().");
    }
#line 729
    return (__cil_tmp4);
  }
#line 733
  if (! dec->ready_) {
    {
#line 734
    __cil_tmp5 = VP8GetHeaders(dec, io);
    }
#line 734
    if (! __cil_tmp5) {
#line 735
      return (0);
    }
  }
  {
#line 741
  __cil_tmp7 = VP8EnterCritical(dec, io);
#line 741
  ok = (unsigned int )__cil_tmp7 == 0U;
  }
#line 742
  if (ok) {
#line 744
    if (ok) {
      {
#line 744
      ok = VP8InitFrame(dec, io);
      }
    }
#line 747
    if (ok) {
      {
#line 747
      ok = ParseFrame(dec, io);
      }
    }
    {
#line 750
    __cil_tmp10 = VP8ExitCritical(dec, io);
#line 750
    ok &= __cil_tmp10;
    }
  }
#line 753
  if (! ok) {
    {
#line 754
    VP8Clear(dec);
    }
#line 755
    return (0);
  }
#line 758
  dec->ready_ = 0;
#line 759
  return (ok);
}
}
#line 762 "/root/patchweave_new/13/src/dec/vp8.c"
void VP8Clear(VP8Decoder *dec ) 
{ 


  {
#line 763
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 764
    return;
  }
#line 766
  if (dec->use_threads_) {
    {
#line 767
    WebPWorkerEnd(& dec->worker_);
    }
  }
#line 769
  if (dec->mem_) {
    {
#line 770
    free(dec->mem_);
    }
  }
  {
#line 772
  dec->mem_ = (void *)0;
#line 773
  dec->mem_size_ = (size_t )0;
#line 774
  memset((void *)(& dec->br_), 0, sizeof(dec->br_));
#line 775
  dec->ready_ = 0;
  }
#line 777
  return;
}
}
#line 21 "/root/patchweave_new/13/src/dec/tree.c"
static int8_t kYModesIntra4[18]  = 
#line 21 "/root/patchweave_new/13/src/dec/tree.c"
  {      (int8_t )0,      (int8_t )1,      (int8_t )-1,      (int8_t )2, 
        (int8_t )-2,      (int8_t )3,      (int8_t )4,      (int8_t )6, 
        (int8_t )-3,      (int8_t )5,      (int8_t )-4,      (int8_t )-5, 
        (int8_t )-6,      (int8_t )7,      (int8_t )-7,      (int8_t )8, 
        (int8_t )-8,      (int8_t )-9};
#line 87 "/root/patchweave_new/13/src/dec/tree.c"
static uint8_t CoeffsProba0[4][8][3][11]  = { { { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )253,            (uint8_t )136,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )228,            (uint8_t )219,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )189,            (uint8_t )129,            (uint8_t )242,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )213,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )106,            (uint8_t )126,            (uint8_t )227,            (uint8_t )252, 
                    (uint8_t )214,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )98,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )226,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )181,            (uint8_t )133,            (uint8_t )238,            (uint8_t )254, 
                    (uint8_t )221,            (uint8_t )234,            (uint8_t )255,            (uint8_t )154, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )78,            (uint8_t )134,            (uint8_t )202,            (uint8_t )247, 
                    (uint8_t )198,            (uint8_t )180,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )185,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )243,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )150,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )77,            (uint8_t )110,            (uint8_t )216,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )230,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )101,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )241,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )170,            (uint8_t )139,            (uint8_t )241,            (uint8_t )252, 
                    (uint8_t )236,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )37,            (uint8_t )116,            (uint8_t )196,            (uint8_t )243, 
                    (uint8_t )228,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )204,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )245,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )207,            (uint8_t )160,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )238,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )102,            (uint8_t )103,            (uint8_t )231,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )171,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )152,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )240,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )177,            (uint8_t )135,            (uint8_t )243,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )225,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )80,            (uint8_t )129,            (uint8_t )211,            (uint8_t )255, 
                    (uint8_t )194,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )246,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )198,            (uint8_t )35,            (uint8_t )237,            (uint8_t )223, 
                    (uint8_t )193,            (uint8_t )187,            (uint8_t )162,            (uint8_t )160, 
                    (uint8_t )145,            (uint8_t )155,            (uint8_t )62}, 
       {            (uint8_t )131,            (uint8_t )45,            (uint8_t )198,            (uint8_t )221, 
                    (uint8_t )172,            (uint8_t )176,            (uint8_t )220,            (uint8_t )157, 
                    (uint8_t )252,            (uint8_t )221,            (uint8_t )1}, 
       {            (uint8_t )68,            (uint8_t )47,            (uint8_t )146,            (uint8_t )208, 
                    (uint8_t )149,            (uint8_t )167,            (uint8_t )221,            (uint8_t )162, 
                    (uint8_t )255,            (uint8_t )223,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )149,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )221,            (uint8_t )224,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )141,            (uint8_t )234,            (uint8_t )253, 
                    (uint8_t )222,            (uint8_t )220,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )81,            (uint8_t )99,            (uint8_t )181,            (uint8_t )242, 
                    (uint8_t )176,            (uint8_t )190,            (uint8_t )249,            (uint8_t )202, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )129,            (uint8_t )232,            (uint8_t )253, 
                    (uint8_t )214,            (uint8_t )197,            (uint8_t )242,            (uint8_t )196, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )99,            (uint8_t )121,            (uint8_t )210,            (uint8_t )250, 
                    (uint8_t )201,            (uint8_t )198,            (uint8_t )255,            (uint8_t )202, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )23,            (uint8_t )91,            (uint8_t )163,            (uint8_t )242, 
                    (uint8_t )170,            (uint8_t )187,            (uint8_t )247,            (uint8_t )210, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )200,            (uint8_t )246,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )109,            (uint8_t )178,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )231,            (uint8_t )245,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )44,            (uint8_t )130,            (uint8_t )201,            (uint8_t )253, 
                    (uint8_t )205,            (uint8_t )192,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )132,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )219,            (uint8_t )209,            (uint8_t )255,            (uint8_t )165, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )94,            (uint8_t )136,            (uint8_t )225,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )190,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )22,            (uint8_t )100,            (uint8_t )174,            (uint8_t )245, 
                    (uint8_t )186,            (uint8_t )161,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )232,            (uint8_t )235,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )143,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )234,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )35,            (uint8_t )77,            (uint8_t )181,            (uint8_t )251, 
                    (uint8_t )193,            (uint8_t )211,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )157,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )231,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )121,            (uint8_t )141,            (uint8_t )235,            (uint8_t )255, 
                    (uint8_t )225,            (uint8_t )227,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )45,            (uint8_t )99,            (uint8_t )188,            (uint8_t )251, 
                    (uint8_t )195,            (uint8_t )217,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )203,            (uint8_t )1,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )137,            (uint8_t )1,            (uint8_t )177,            (uint8_t )255, 
                    (uint8_t )224,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )253,            (uint8_t )9,            (uint8_t )248,            (uint8_t )251, 
                    (uint8_t )207,            (uint8_t )208,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )175,            (uint8_t )13,            (uint8_t )224,            (uint8_t )243, 
                    (uint8_t )193,            (uint8_t )185,            (uint8_t )249,            (uint8_t )198, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )73,            (uint8_t )17,            (uint8_t )171,            (uint8_t )221, 
                    (uint8_t )161,            (uint8_t )179,            (uint8_t )236,            (uint8_t )167, 
                    (uint8_t )255,            (uint8_t )234,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )95,            (uint8_t )247,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )183,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )239,            (uint8_t )90,            (uint8_t )244,            (uint8_t )250, 
                    (uint8_t )211,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )155,            (uint8_t )77,            (uint8_t )195,            (uint8_t )248, 
                    (uint8_t )188,            (uint8_t )195,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )24,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )219,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )201,            (uint8_t )51,            (uint8_t )219,            (uint8_t )255, 
                    (uint8_t )196,            (uint8_t )186,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )69,            (uint8_t )46,            (uint8_t )190,            (uint8_t )239, 
                    (uint8_t )201,            (uint8_t )218,            (uint8_t )255,            (uint8_t )228, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )191,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )223,            (uint8_t )165,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )124,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )16,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )190,            (uint8_t )36,            (uint8_t )230,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )226,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )247,            (uint8_t )192,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )240,            (uint8_t )128,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )134,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )213,            (uint8_t )62,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )55,            (uint8_t )93,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )202,            (uint8_t )24,            (uint8_t )213,            (uint8_t )235, 
                    (uint8_t )186,            (uint8_t )191,            (uint8_t )220,            (uint8_t )160, 
                    (uint8_t )240,            (uint8_t )175,            (uint8_t )255}, 
       {            (uint8_t )126,            (uint8_t )38,            (uint8_t )182,            (uint8_t )232, 
                    (uint8_t )169,            (uint8_t )184,            (uint8_t )228,            (uint8_t )174, 
                    (uint8_t )255,            (uint8_t )187,            (uint8_t )128}, 
       {            (uint8_t )61,            (uint8_t )46,            (uint8_t )138,            (uint8_t )219, 
                    (uint8_t )151,            (uint8_t )178,            (uint8_t )240,            (uint8_t )170, 
                    (uint8_t )255,            (uint8_t )216,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )112,            (uint8_t )230,            (uint8_t )250, 
                    (uint8_t )199,            (uint8_t )191,            (uint8_t )247,            (uint8_t )159, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )166,            (uint8_t )109,            (uint8_t )228,            (uint8_t )252, 
                    (uint8_t )211,            (uint8_t )215,            (uint8_t )255,            (uint8_t )174, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )39,            (uint8_t )77,            (uint8_t )162,            (uint8_t )232, 
                    (uint8_t )172,            (uint8_t )180,            (uint8_t )245,            (uint8_t )178, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )52,            (uint8_t )220,            (uint8_t )246, 
                    (uint8_t )198,            (uint8_t )199,            (uint8_t )249,            (uint8_t )220, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )74,            (uint8_t )191,            (uint8_t )243, 
                    (uint8_t )183,            (uint8_t )193,            (uint8_t )250,            (uint8_t )221, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )24,            (uint8_t )71,            (uint8_t )130,            (uint8_t )219, 
                    (uint8_t )154,            (uint8_t )170,            (uint8_t )243,            (uint8_t )182, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )225,            (uint8_t )249, 
                    (uint8_t )219,            (uint8_t )240,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )150,            (uint8_t )226,            (uint8_t )252, 
                    (uint8_t )216,            (uint8_t )205,            (uint8_t )255,            (uint8_t )171, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )28,            (uint8_t )108,            (uint8_t )170,            (uint8_t )242, 
                    (uint8_t )183,            (uint8_t )194,            (uint8_t )254,            (uint8_t )223, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )81,            (uint8_t )230,            (uint8_t )252, 
                    (uint8_t )204,            (uint8_t )203,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )123,            (uint8_t )102,            (uint8_t )209,            (uint8_t )247, 
                    (uint8_t )188,            (uint8_t )196,            (uint8_t )255,            (uint8_t )233, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )20,            (uint8_t )95,            (uint8_t )153,            (uint8_t )243, 
                    (uint8_t )164,            (uint8_t )173,            (uint8_t )255,            (uint8_t )203, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )222,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )216,            (uint8_t )213,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )168,            (uint8_t )175,            (uint8_t )246,            (uint8_t )252, 
                    (uint8_t )235,            (uint8_t )205,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )47,            (uint8_t )116,            (uint8_t )215,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )212,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )121,            (uint8_t )236,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )214,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )84,            (uint8_t )213,            (uint8_t )252, 
                    (uint8_t )201,            (uint8_t )202,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )42,            (uint8_t )80,            (uint8_t )160,            (uint8_t )240, 
                    (uint8_t )162,            (uint8_t )185,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )244,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )238,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}};
#line 224 "/root/patchweave_new/13/src/dec/tree.c"
static uint8_t kBModesProba___0[10][10][9]  = 
#line 224
  { { {          (uint8_t )231,          (uint8_t )120,          (uint8_t )48,          (uint8_t )89, 
                (uint8_t )115,          (uint8_t )113,          (uint8_t )120,          (uint8_t )152, 
                (uint8_t )112}, 
     {          (uint8_t )152,          (uint8_t )179,          (uint8_t )64,          (uint8_t )126, 
                (uint8_t )170,          (uint8_t )118,          (uint8_t )46,          (uint8_t )70, 
                (uint8_t )95}, 
     {          (uint8_t )175,          (uint8_t )69,          (uint8_t )143,          (uint8_t )80, 
                (uint8_t )85,          (uint8_t )82,          (uint8_t )72,          (uint8_t )155, 
                (uint8_t )103}, 
     {          (uint8_t )56,          (uint8_t )58,          (uint8_t )10,          (uint8_t )171, 
                (uint8_t )218,          (uint8_t )189,          (uint8_t )17,          (uint8_t )13, 
                (uint8_t )152}, 
     {          (uint8_t )114,          (uint8_t )26,          (uint8_t )17,          (uint8_t )163, 
                (uint8_t )44,          (uint8_t )195,          (uint8_t )21,          (uint8_t )10, 
                (uint8_t )173}, 
     {          (uint8_t )121,          (uint8_t )24,          (uint8_t )80,          (uint8_t )195, 
                (uint8_t )26,          (uint8_t )62,          (uint8_t )44,          (uint8_t )64, 
                (uint8_t )85}, 
     {          (uint8_t )144,          (uint8_t )71,          (uint8_t )10,          (uint8_t )38, 
                (uint8_t )171,          (uint8_t )213,          (uint8_t )144,          (uint8_t )34, 
                (uint8_t )26}, 
     {          (uint8_t )170,          (uint8_t )46,          (uint8_t )55,          (uint8_t )19, 
                (uint8_t )136,          (uint8_t )160,          (uint8_t )33,          (uint8_t )206, 
                (uint8_t )71}, 
     {          (uint8_t )63,          (uint8_t )20,          (uint8_t )8,          (uint8_t )114, 
                (uint8_t )114,          (uint8_t )208,          (uint8_t )12,          (uint8_t )9, 
                (uint8_t )226}, 
     {          (uint8_t )81,          (uint8_t )40,          (uint8_t )11,          (uint8_t )96, 
                (uint8_t )182,          (uint8_t )84,          (uint8_t )29,          (uint8_t )16, 
                (uint8_t )36}}, 
   { {          (uint8_t )134,          (uint8_t )183,          (uint8_t )89,          (uint8_t )137, 
                (uint8_t )98,          (uint8_t )101,          (uint8_t )106,          (uint8_t )165, 
                (uint8_t )148}, 
     {          (uint8_t )72,          (uint8_t )187,          (uint8_t )100,          (uint8_t )130, 
                (uint8_t )157,          (uint8_t )111,          (uint8_t )32,          (uint8_t )75, 
                (uint8_t )80}, 
     {          (uint8_t )66,          (uint8_t )102,          (uint8_t )167,          (uint8_t )99, 
                (uint8_t )74,          (uint8_t )62,          (uint8_t )40,          (uint8_t )234, 
                (uint8_t )128}, 
     {          (uint8_t )41,          (uint8_t )53,          (uint8_t )9,          (uint8_t )178, 
                (uint8_t )241,          (uint8_t )141,          (uint8_t )26,          (uint8_t )8, 
                (uint8_t )107}, 
     {          (uint8_t )74,          (uint8_t )43,          (uint8_t )26,          (uint8_t )146, 
                (uint8_t )73,          (uint8_t )166,          (uint8_t )49,          (uint8_t )23, 
                (uint8_t )157}, 
     {          (uint8_t )65,          (uint8_t )38,          (uint8_t )105,          (uint8_t )160, 
                (uint8_t )51,          (uint8_t )52,          (uint8_t )31,          (uint8_t )115, 
                (uint8_t )128}, 
     {          (uint8_t )104,          (uint8_t )79,          (uint8_t )12,          (uint8_t )27, 
                (uint8_t )217,          (uint8_t )255,          (uint8_t )87,          (uint8_t )17, 
                (uint8_t )7}, 
     {          (uint8_t )87,          (uint8_t )68,          (uint8_t )71,          (uint8_t )44, 
                (uint8_t )114,          (uint8_t )51,          (uint8_t )15,          (uint8_t )186, 
                (uint8_t )23}, 
     {          (uint8_t )47,          (uint8_t )41,          (uint8_t )14,          (uint8_t )110, 
                (uint8_t )182,          (uint8_t )183,          (uint8_t )21,          (uint8_t )17, 
                (uint8_t )194}, 
     {          (uint8_t )66,          (uint8_t )45,          (uint8_t )25,          (uint8_t )102, 
                (uint8_t )197,          (uint8_t )189,          (uint8_t )23,          (uint8_t )18, 
                (uint8_t )22}}, 
   { {          (uint8_t )88,          (uint8_t )88,          (uint8_t )147,          (uint8_t )150, 
                (uint8_t )42,          (uint8_t )46,          (uint8_t )45,          (uint8_t )196, 
                (uint8_t )205}, 
     {          (uint8_t )43,          (uint8_t )97,          (uint8_t )183,          (uint8_t )117, 
                (uint8_t )85,          (uint8_t )38,          (uint8_t )35,          (uint8_t )179, 
                (uint8_t )61}, 
     {          (uint8_t )39,          (uint8_t )53,          (uint8_t )200,          (uint8_t )87, 
                (uint8_t )26,          (uint8_t )21,          (uint8_t )43,          (uint8_t )232, 
                (uint8_t )171}, 
     {          (uint8_t )56,          (uint8_t )34,          (uint8_t )51,          (uint8_t )104, 
                (uint8_t )114,          (uint8_t )102,          (uint8_t )29,          (uint8_t )93, 
                (uint8_t )77}, 
     {          (uint8_t )39,          (uint8_t )28,          (uint8_t )85,          (uint8_t )171, 
                (uint8_t )58,          (uint8_t )165,          (uint8_t )90,          (uint8_t )98, 
                (uint8_t )64}, 
     {          (uint8_t )34,          (uint8_t )22,          (uint8_t )116,          (uint8_t )206, 
                (uint8_t )23,          (uint8_t )34,          (uint8_t )43,          (uint8_t )166, 
                (uint8_t )73}, 
     {          (uint8_t )107,          (uint8_t )54,          (uint8_t )32,          (uint8_t )26, 
                (uint8_t )51,          (uint8_t )1,          (uint8_t )81,          (uint8_t )43, 
                (uint8_t )31}, 
     {          (uint8_t )68,          (uint8_t )25,          (uint8_t )106,          (uint8_t )22, 
                (uint8_t )64,          (uint8_t )171,          (uint8_t )36,          (uint8_t )225, 
                (uint8_t )114}, 
     {          (uint8_t )34,          (uint8_t )19,          (uint8_t )21,          (uint8_t )102, 
                (uint8_t )132,          (uint8_t )188,          (uint8_t )16,          (uint8_t )76, 
                (uint8_t )124}, 
     {          (uint8_t )62,          (uint8_t )18,          (uint8_t )78,          (uint8_t )95, 
                (uint8_t )85,          (uint8_t )57,          (uint8_t )50,          (uint8_t )48, 
                (uint8_t )51}}, 
   { {          (uint8_t )193,          (uint8_t )101,          (uint8_t )35,          (uint8_t )159, 
                (uint8_t )215,          (uint8_t )111,          (uint8_t )89,          (uint8_t )46, 
                (uint8_t )111}, 
     {          (uint8_t )60,          (uint8_t )148,          (uint8_t )31,          (uint8_t )172, 
                (uint8_t )219,          (uint8_t )228,          (uint8_t )21,          (uint8_t )18, 
                (uint8_t )111}, 
     {          (uint8_t )112,          (uint8_t )113,          (uint8_t )77,          (uint8_t )85, 
                (uint8_t )179,          (uint8_t )255,          (uint8_t )38,          (uint8_t )120, 
                (uint8_t )114}, 
     {          (uint8_t )40,          (uint8_t )42,          (uint8_t )1,          (uint8_t )196, 
                (uint8_t )245,          (uint8_t )209,          (uint8_t )10,          (uint8_t )25, 
                (uint8_t )109}, 
     {          (uint8_t )88,          (uint8_t )43,          (uint8_t )29,          (uint8_t )140, 
                (uint8_t )166,          (uint8_t )213,          (uint8_t )37,          (uint8_t )43, 
                (uint8_t )154}, 
     {          (uint8_t )61,          (uint8_t )63,          (uint8_t )30,          (uint8_t )155, 
                (uint8_t )67,          (uint8_t )45,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )100,          (uint8_t )80,          (uint8_t )8,          (uint8_t )43, 
                (uint8_t )154,          (uint8_t )1,          (uint8_t )51,          (uint8_t )26, 
                (uint8_t )71}, 
     {          (uint8_t )142,          (uint8_t )78,          (uint8_t )78,          (uint8_t )16, 
                (uint8_t )255,          (uint8_t )128,          (uint8_t )34,          (uint8_t )197, 
                (uint8_t )171}, 
     {          (uint8_t )41,          (uint8_t )40,          (uint8_t )5,          (uint8_t )102, 
                (uint8_t )211,          (uint8_t )183,          (uint8_t )4,          (uint8_t )1, 
                (uint8_t )221}, 
     {          (uint8_t )51,          (uint8_t )50,          (uint8_t )17,          (uint8_t )168, 
                (uint8_t )209,          (uint8_t )192,          (uint8_t )23,          (uint8_t )25, 
                (uint8_t )82}}, 
   { {          (uint8_t )138,          (uint8_t )31,          (uint8_t )36,          (uint8_t )171, 
                (uint8_t )27,          (uint8_t )166,          (uint8_t )38,          (uint8_t )44, 
                (uint8_t )229}, 
     {          (uint8_t )67,          (uint8_t )87,          (uint8_t )58,          (uint8_t )169, 
                (uint8_t )82,          (uint8_t )115,          (uint8_t )26,          (uint8_t )59, 
                (uint8_t )179}, 
     {          (uint8_t )63,          (uint8_t )59,          (uint8_t )90,          (uint8_t )180, 
                (uint8_t )59,          (uint8_t )166,          (uint8_t )93,          (uint8_t )73, 
                (uint8_t )154}, 
     {          (uint8_t )40,          (uint8_t )40,          (uint8_t )21,          (uint8_t )116, 
                (uint8_t )143,          (uint8_t )209,          (uint8_t )34,          (uint8_t )39, 
                (uint8_t )175}, 
     {          (uint8_t )47,          (uint8_t )15,          (uint8_t )16,          (uint8_t )183, 
                (uint8_t )34,          (uint8_t )223,          (uint8_t )49,          (uint8_t )45, 
                (uint8_t )183}, 
     {          (uint8_t )46,          (uint8_t )17,          (uint8_t )33,          (uint8_t )183, 
                (uint8_t )6,          (uint8_t )98,          (uint8_t )15,          (uint8_t )32, 
                (uint8_t )183}, 
     {          (uint8_t )57,          (uint8_t )46,          (uint8_t )22,          (uint8_t )24, 
                (uint8_t )128,          (uint8_t )1,          (uint8_t )54,          (uint8_t )17, 
                (uint8_t )37}, 
     {          (uint8_t )65,          (uint8_t )32,          (uint8_t )73,          (uint8_t )115, 
                (uint8_t )28,          (uint8_t )128,          (uint8_t )23,          (uint8_t )128, 
                (uint8_t )205}, 
     {          (uint8_t )40,          (uint8_t )3,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )51,          (uint8_t )192,          (uint8_t )18,          (uint8_t )6, 
                (uint8_t )223}, 
     {          (uint8_t )87,          (uint8_t )37,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )59,          (uint8_t )77,          (uint8_t )64,          (uint8_t )21, 
                (uint8_t )47}}, 
   { {          (uint8_t )104,          (uint8_t )55,          (uint8_t )44,          (uint8_t )218, 
                (uint8_t )9,          (uint8_t )54,          (uint8_t )53,          (uint8_t )130, 
                (uint8_t )226}, 
     {          (uint8_t )64,          (uint8_t )90,          (uint8_t )70,          (uint8_t )205, 
                (uint8_t )40,          (uint8_t )41,          (uint8_t )23,          (uint8_t )26, 
                (uint8_t )57}, 
     {          (uint8_t )54,          (uint8_t )57,          (uint8_t )112,          (uint8_t )184, 
                (uint8_t )5,          (uint8_t )41,          (uint8_t )38,          (uint8_t )166, 
                (uint8_t )213}, 
     {          (uint8_t )30,          (uint8_t )34,          (uint8_t )26,          (uint8_t )133, 
                (uint8_t )152,          (uint8_t )116,          (uint8_t )10,          (uint8_t )32, 
                (uint8_t )134}, 
     {          (uint8_t )39,          (uint8_t )19,          (uint8_t )53,          (uint8_t )221, 
                (uint8_t )26,          (uint8_t )114,          (uint8_t )32,          (uint8_t )73, 
                (uint8_t )255}, 
     {          (uint8_t )31,          (uint8_t )9,          (uint8_t )65,          (uint8_t )234, 
                (uint8_t )2,          (uint8_t )15,          (uint8_t )1,          (uint8_t )118, 
                (uint8_t )73}, 
     {          (uint8_t )75,          (uint8_t )32,          (uint8_t )12,          (uint8_t )51, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )160,          (uint8_t )43, 
                (uint8_t )51}, 
     {          (uint8_t )88,          (uint8_t )31,          (uint8_t )35,          (uint8_t )67, 
                (uint8_t )102,          (uint8_t )85,          (uint8_t )55,          (uint8_t )186, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )23,          (uint8_t )111, 
                (uint8_t )59,          (uint8_t )205,          (uint8_t )45,          (uint8_t )37, 
                (uint8_t )192}, 
     {          (uint8_t )55,          (uint8_t )38,          (uint8_t )70,          (uint8_t )124, 
                (uint8_t )73,          (uint8_t )102,          (uint8_t )1,          (uint8_t )34, 
                (uint8_t )98}}, 
   { {          (uint8_t )125,          (uint8_t )98,          (uint8_t )42,          (uint8_t )88, 
                (uint8_t )104,          (uint8_t )85,          (uint8_t )117,          (uint8_t )175, 
                (uint8_t )82}, 
     {          (uint8_t )95,          (uint8_t )84,          (uint8_t )53,          (uint8_t )89, 
                (uint8_t )128,          (uint8_t )100,          (uint8_t )113,          (uint8_t )101, 
                (uint8_t )45}, 
     {          (uint8_t )75,          (uint8_t )79,          (uint8_t )123,          (uint8_t )47, 
                (uint8_t )51,          (uint8_t )128,          (uint8_t )81,          (uint8_t )171, 
                (uint8_t )1}, 
     {          (uint8_t )57,          (uint8_t )17,          (uint8_t )5,          (uint8_t )71, 
                (uint8_t )102,          (uint8_t )57,          (uint8_t )53,          (uint8_t )41, 
                (uint8_t )49}, 
     {          (uint8_t )38,          (uint8_t )33,          (uint8_t )13,          (uint8_t )121, 
                (uint8_t )57,          (uint8_t )73,          (uint8_t )26,          (uint8_t )1, 
                (uint8_t )85}, 
     {          (uint8_t )41,          (uint8_t )10,          (uint8_t )67,          (uint8_t )138, 
                (uint8_t )77,          (uint8_t )110,          (uint8_t )90,          (uint8_t )47, 
                (uint8_t )114}, 
     {          (uint8_t )115,          (uint8_t )21,          (uint8_t )2,          (uint8_t )10, 
                (uint8_t )102,          (uint8_t )255,          (uint8_t )166,          (uint8_t )23, 
                (uint8_t )6}, 
     {          (uint8_t )101,          (uint8_t )29,          (uint8_t )16,          (uint8_t )10, 
                (uint8_t )85,          (uint8_t )128,          (uint8_t )101,          (uint8_t )196, 
                (uint8_t )26}, 
     {          (uint8_t )57,          (uint8_t )18,          (uint8_t )10,          (uint8_t )102, 
                (uint8_t )102,          (uint8_t )213,          (uint8_t )34,          (uint8_t )20, 
                (uint8_t )43}, 
     {          (uint8_t )117,          (uint8_t )20,          (uint8_t )15,          (uint8_t )36, 
                (uint8_t )163,          (uint8_t )128,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )26}}, 
   { {          (uint8_t )102,          (uint8_t )61,          (uint8_t )71,          (uint8_t )37, 
                (uint8_t )34,          (uint8_t )53,          (uint8_t )31,          (uint8_t )243, 
                (uint8_t )192}, 
     {          (uint8_t )69,          (uint8_t )60,          (uint8_t )71,          (uint8_t )38, 
                (uint8_t )73,          (uint8_t )119,          (uint8_t )28,          (uint8_t )222, 
                (uint8_t )37}, 
     {          (uint8_t )68,          (uint8_t )45,          (uint8_t )128,          (uint8_t )34, 
                (uint8_t )1,          (uint8_t )47,          (uint8_t )11,          (uint8_t )245, 
                (uint8_t )171}, 
     {          (uint8_t )62,          (uint8_t )17,          (uint8_t )19,          (uint8_t )70, 
                (uint8_t )146,          (uint8_t )85,          (uint8_t )55,          (uint8_t )62, 
                (uint8_t )70}, 
     {          (uint8_t )37,          (uint8_t )43,          (uint8_t )37,          (uint8_t )154, 
                (uint8_t )100,          (uint8_t )163,          (uint8_t )85,          (uint8_t )160, 
                (uint8_t )1}, 
     {          (uint8_t )63,          (uint8_t )9,          (uint8_t )92,          (uint8_t )136, 
                (uint8_t )28,          (uint8_t )64,          (uint8_t )32,          (uint8_t )201, 
                (uint8_t )85}, 
     {          (uint8_t )75,          (uint8_t )15,          (uint8_t )9,          (uint8_t )9, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )184,          (uint8_t )119, 
                (uint8_t )16}, 
     {          (uint8_t )86,          (uint8_t )6,          (uint8_t )28,          (uint8_t )5, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )25,          (uint8_t )248, 
                (uint8_t )1}, 
     {          (uint8_t )56,          (uint8_t )8,          (uint8_t )17,          (uint8_t )132, 
                (uint8_t )137,          (uint8_t )255,          (uint8_t )55,          (uint8_t )116, 
                (uint8_t )128}, 
     {          (uint8_t )58,          (uint8_t )15,          (uint8_t )20,          (uint8_t )82, 
                (uint8_t )135,          (uint8_t )57,          (uint8_t )26,          (uint8_t )121, 
                (uint8_t )40}}, 
   { {          (uint8_t )164,          (uint8_t )50,          (uint8_t )31,          (uint8_t )137, 
                (uint8_t )154,          (uint8_t )133,          (uint8_t )25,          (uint8_t )35, 
                (uint8_t )218}, 
     {          (uint8_t )51,          (uint8_t )103,          (uint8_t )44,          (uint8_t )131, 
                (uint8_t )131,          (uint8_t )123,          (uint8_t )31,          (uint8_t )6, 
                (uint8_t )158}, 
     {          (uint8_t )86,          (uint8_t )40,          (uint8_t )64,          (uint8_t )135, 
                (uint8_t )148,          (uint8_t )224,          (uint8_t )45,          (uint8_t )183, 
                (uint8_t )128}, 
     {          (uint8_t )22,          (uint8_t )26,          (uint8_t )17,          (uint8_t )131, 
                (uint8_t )240,          (uint8_t )154,          (uint8_t )14,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )45,          (uint8_t )16,          (uint8_t )21,          (uint8_t )91, 
                (uint8_t )64,          (uint8_t )222,          (uint8_t )7,          (uint8_t )1, 
                (uint8_t )197}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )39,          (uint8_t )155, 
                (uint8_t )60,          (uint8_t )138,          (uint8_t )23,          (uint8_t )102, 
                (uint8_t )213}, 
     {          (uint8_t )83,          (uint8_t )12,          (uint8_t )13,          (uint8_t )54, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )68,          (uint8_t )47, 
                (uint8_t )28}, 
     {          (uint8_t )85,          (uint8_t )26,          (uint8_t )85,          (uint8_t )85, 
                (uint8_t )128,          (uint8_t )128,          (uint8_t )32,          (uint8_t )146, 
                (uint8_t )171}, 
     {          (uint8_t )18,          (uint8_t )11,          (uint8_t )7,          (uint8_t )63, 
                (uint8_t )144,          (uint8_t )171,          (uint8_t )4,          (uint8_t )4, 
                (uint8_t )246}, 
     {          (uint8_t )35,          (uint8_t )27,          (uint8_t )10,          (uint8_t )146, 
                (uint8_t )174,          (uint8_t )171,          (uint8_t )12,          (uint8_t )26, 
                (uint8_t )128}}, 
   { {          (uint8_t )190,          (uint8_t )80,          (uint8_t )35,          (uint8_t )99, 
                (uint8_t )180,          (uint8_t )80,          (uint8_t )126,          (uint8_t )54, 
                (uint8_t )45}, 
     {          (uint8_t )85,          (uint8_t )126,          (uint8_t )47,          (uint8_t )87, 
                (uint8_t )176,          (uint8_t )51,          (uint8_t )41,          (uint8_t )20, 
                (uint8_t )32}, 
     {          (uint8_t )101,          (uint8_t )75,          (uint8_t )128,          (uint8_t )139, 
                (uint8_t )118,          (uint8_t )146,          (uint8_t )116,          (uint8_t )128, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )41,          (uint8_t )15,          (uint8_t )176, 
                (uint8_t )236,          (uint8_t )85,          (uint8_t )37,          (uint8_t )9, 
                (uint8_t )62}, 
     {          (uint8_t )71,          (uint8_t )30,          (uint8_t )17,          (uint8_t )119, 
                (uint8_t )118,          (uint8_t )255,          (uint8_t )17,          (uint8_t )18, 
                (uint8_t )138}, 
     {          (uint8_t )101,          (uint8_t )38,          (uint8_t )60,          (uint8_t )138, 
                (uint8_t )55,          (uint8_t )70,          (uint8_t )43,          (uint8_t )26, 
                (uint8_t )142}, 
     {          (uint8_t )146,          (uint8_t )36,          (uint8_t )19,          (uint8_t )30, 
                (uint8_t )171,          (uint8_t )255,          (uint8_t )97,          (uint8_t )27, 
                (uint8_t )20}, 
     {          (uint8_t )138,          (uint8_t )45,          (uint8_t )61,          (uint8_t )62, 
                (uint8_t )219,          (uint8_t )1,          (uint8_t )81,          (uint8_t )188, 
                (uint8_t )64}, 
     {          (uint8_t )32,          (uint8_t )41,          (uint8_t )20,          (uint8_t )117, 
                (uint8_t )151,          (uint8_t )142,          (uint8_t )20,          (uint8_t )21, 
                (uint8_t )163}, 
     {          (uint8_t )112,          (uint8_t )19,          (uint8_t )12,          (uint8_t )61, 
                (uint8_t )195,          (uint8_t )128,          (uint8_t )48,          (uint8_t )4, 
                (uint8_t )24}}};
#line 327 "/root/patchweave_new/13/src/dec/tree.c"
void VP8ResetProba(VP8Proba___0 *proba ) 
{ 


  {
  {
#line 328
  memset((void *)(proba->segments_), 255, sizeof(proba->segments_));
#line 329
  memcpy((void *)(proba->coeffs_), (void const   *)(CoeffsProba0), sizeof(CoeffsProba0));
  }
#line 332
  return;
}
}
#line 337 "/root/patchweave_new/13/src/dec/tree.c"
void VP8ParseIntraMode(VP8BitReader *br , VP8Decoder *dec ) 
{ 
  uint8_t *top ;
  uint8_t *left ;
  int __cil_tmp5 ;
  int ymode ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp___0 ;
  int __cil_tmp10 ;
  int tmp___1 ;
  int tmp___2 ;
  uint8_t *modes ;
  int y ;
  int ymode___0 ;
  int x ;
  uint8_t *prob ;
  int i ;
  int __cil_tmp19 ;
  uint8_t *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 338
  top = dec->intra_t_ + 4 * dec->mb_x_;
#line 339
  left = dec->intra_l_;
#line 341
  __cil_tmp5 = VP8GetBit(br, 145);
#line 341
  dec->is_i4x4_ = (uint8_t )(! __cil_tmp5);
  }
#line 342
  if (! dec->is_i4x4_) {
    {
#line 343
    __cil_tmp7 = VP8GetBit(br, 156);
    }
#line 343
    if (__cil_tmp7) {
      {
#line 343
      __cil_tmp8 = VP8GetBit(br, 128);
      }
#line 343
      if (__cil_tmp8) {
#line 343
        tmp___0 = 1;
      } else {
#line 343
        tmp___0 = 3;
      }
#line 343
      tmp___2 = tmp___0;
    } else {
      {
#line 343
      __cil_tmp10 = VP8GetBit(br, 163);
      }
#line 343
      if (__cil_tmp10) {
#line 343
        tmp___1 = 2;
      } else {
#line 343
        tmp___1 = 0;
      }
#line 343
      tmp___2 = tmp___1;
    }
    {
#line 343
    ymode = tmp___2;
#line 346
    dec->imodes_[0] = (uint8_t )ymode;
#line 347
    memset((void *)top, ymode, 4UL * sizeof(*(top + 0)));
#line 348
    memset((void *)left, ymode, 4UL * sizeof(*(left + 0)));
    }
  } else {
#line 350
    modes = dec->imodes_;
#line 352
    y = 0;
    {
#line 352
    while (1) {
      while_continue: /* CIL Label */ ;

#line 352
      if (! (y < 4)) {
#line 352
        goto while_break;
      }
#line 353
      ymode___0 = (int )*(left + y);
#line 355
      x = 0;
      {
#line 355
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 355
        if (! (x < 4)) {
#line 355
          goto while_break___0;
        }
#line 356
        prob = kBModesProba___0[*(top + x)][ymode___0];
#line 359
        i = 0;
        {
#line 360
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 361
          __cil_tmp19 = VP8GetBit(br, (int )*(prob + i));
#line 361
          i = (int )kYModesIntra4[2 * i + __cil_tmp19];
          }
#line 360
          if (! (i > 0)) {
#line 360
            goto while_break___1;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: 
#line 363
        ymode___0 = - i;
#line 376
        *(top + x) = (uint8_t )ymode___0;
#line 377
        __cil_tmp20 = modes;
#line 377
        modes ++;
#line 377
        *__cil_tmp20 = (uint8_t )ymode___0;
#line 355
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: 
#line 379
      *(left + y) = (uint8_t )ymode___0;
#line 352
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 383
  __cil_tmp21 = VP8GetBit(br, 142);
  }
#line 383
  if (! __cil_tmp21) {
#line 383
    tmp___5 = 0;
  } else {
    {
#line 383
    __cil_tmp22 = VP8GetBit(br, 114);
    }
#line 383
    if (! __cil_tmp22) {
#line 383
      tmp___4 = 2;
    } else {
      {
#line 383
      __cil_tmp23 = VP8GetBit(br, 183);
      }
#line 383
      if (__cil_tmp23) {
#line 383
        tmp___3 = 1;
      } else {
#line 383
        tmp___3 = 3;
      }
#line 383
      tmp___4 = tmp___3;
    }
#line 383
    tmp___5 = tmp___4;
  }
#line 383
  dec->uvmode_ = (uint8_t )tmp___5;
#line 384
  return;
}
}
#line 392 "/root/patchweave_new/13/src/dec/tree.c"
static uint8_t CoeffsUpdateProba[4][8][3][11]  = { { { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )176,            (uint8_t )246,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )241,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )244,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )246,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )239,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )217,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )225,            (uint8_t )252,            (uint8_t )241,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )250,            (uint8_t )241,            (uint8_t )250, 
                    (uint8_t )253,            (uint8_t )255,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )238,            (uint8_t )253,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )247,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )186,            (uint8_t )251,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )251,            (uint8_t )244,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )251,            (uint8_t )243,            (uint8_t )253, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )236,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )253,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )248,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )254,            (uint8_t )252,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )249,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )246,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )254,            (uint8_t )251,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )245,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )252,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}};
#line 539 "/root/patchweave_new/13/src/dec/tree.c"
void VP8ParseProba(VP8BitReader *br , VP8Decoder *dec ) 
{ 
  VP8Proba___0 *proba ;
  int t ;
  int b ;
  int c ;
  int p ;
  int __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;

  {
#line 540
  proba = & dec->proba_;
#line 542
  t = 0;
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;

#line 542
    if (! (t < 4)) {
#line 542
      goto while_break;
    }
#line 543
    b = 0;
    {
#line 543
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 543
      if (! (b < 8)) {
#line 543
        goto while_break___0;
      }
#line 544
      c = 0;
      {
#line 544
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 544
        if (! (c < 3)) {
#line 544
          goto while_break___1;
        }
#line 545
        p = 0;
        {
#line 545
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 545
          if (! (p < 11)) {
#line 545
            goto while_break___2;
          }
          {
#line 546
          __cil_tmp8 = VP8GetBit(br, (int )CoeffsUpdateProba[t][b][c][p]);
          }
#line 546
          if (__cil_tmp8) {
            {
#line 547
            __cil_tmp9 = VP8GetValue(br, 8);
#line 547
            proba->coeffs_[t][b][c][p] = (uint8_t )__cil_tmp9;
            }
          }
#line 545
          p ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 544
        c ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 543
      b ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 542
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 553
  __cil_tmp10 = VP8Get(br);
#line 553
  dec->use_skip_proba_ = (int )__cil_tmp10;
  }
#line 554
  if (dec->use_skip_proba_) {
    {
#line 555
    __cil_tmp11 = VP8GetValue(br, 8);
#line 555
    dec->skip_p_ = (uint8_t )__cil_tmp11;
    }
  }
#line 558
  return;
}
}
#line 18 "/root/patchweave_new/13/src/dec/quant.c"
__inline static int clip___2(int v , int M ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 19
  if (v < 0) {
#line 19
    tmp___1 = 0;
  } else {
#line 19
    if (v > M) {
#line 19
      tmp___0 = M;
    } else {
#line 19
      tmp___0 = v;
    }
#line 19
    tmp___1 = tmp___0;
  }
#line 19
  return (tmp___1);
}
}
#line 23 "/root/patchweave_new/13/src/dec/quant.c"
static uint8_t kDcTable___0[128]  = 
#line 23
  {      (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )17, 
        (uint8_t )18,      (uint8_t )19,      (uint8_t )20,      (uint8_t )20, 
        (uint8_t )21,      (uint8_t )21,      (uint8_t )22,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )23,      (uint8_t )24,      (uint8_t )25, 
        (uint8_t )25,      (uint8_t )26,      (uint8_t )27,      (uint8_t )28, 
        (uint8_t )29,      (uint8_t )30,      (uint8_t )31,      (uint8_t )32, 
        (uint8_t )33,      (uint8_t )34,      (uint8_t )35,      (uint8_t )36, 
        (uint8_t )37,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )46, 
        (uint8_t )47,      (uint8_t )48,      (uint8_t )49,      (uint8_t )50, 
        (uint8_t )51,      (uint8_t )52,      (uint8_t )53,      (uint8_t )54, 
        (uint8_t )55,      (uint8_t )56,      (uint8_t )57,      (uint8_t )58, 
        (uint8_t )59,      (uint8_t )60,      (uint8_t )61,      (uint8_t )62, 
        (uint8_t )63,      (uint8_t )64,      (uint8_t )65,      (uint8_t )66, 
        (uint8_t )67,      (uint8_t )68,      (uint8_t )69,      (uint8_t )70, 
        (uint8_t )71,      (uint8_t )72,      (uint8_t )73,      (uint8_t )74, 
        (uint8_t )75,      (uint8_t )76,      (uint8_t )76,      (uint8_t )77, 
        (uint8_t )78,      (uint8_t )79,      (uint8_t )80,      (uint8_t )81, 
        (uint8_t )82,      (uint8_t )83,      (uint8_t )84,      (uint8_t )85, 
        (uint8_t )86,      (uint8_t )87,      (uint8_t )88,      (uint8_t )89, 
        (uint8_t )91,      (uint8_t )93,      (uint8_t )95,      (uint8_t )96, 
        (uint8_t )98,      (uint8_t )100,      (uint8_t )101,      (uint8_t )102, 
        (uint8_t )104,      (uint8_t )106,      (uint8_t )108,      (uint8_t )110, 
        (uint8_t )112,      (uint8_t )114,      (uint8_t )116,      (uint8_t )118, 
        (uint8_t )122,      (uint8_t )124,      (uint8_t )126,      (uint8_t )128, 
        (uint8_t )130,      (uint8_t )132,      (uint8_t )134,      (uint8_t )136, 
        (uint8_t )138,      (uint8_t )140,      (uint8_t )143,      (uint8_t )145, 
        (uint8_t )148,      (uint8_t )151,      (uint8_t )154,      (uint8_t )157};
#line 42 "/root/patchweave_new/13/src/dec/quant.c"
static uint16_t kAcTable___0[128]  = 
#line 42
  {      (uint16_t )4,      (uint16_t )5,      (uint16_t )6,      (uint16_t )7, 
        (uint16_t )8,      (uint16_t )9,      (uint16_t )10,      (uint16_t )11, 
        (uint16_t )12,      (uint16_t )13,      (uint16_t )14,      (uint16_t )15, 
        (uint16_t )16,      (uint16_t )17,      (uint16_t )18,      (uint16_t )19, 
        (uint16_t )20,      (uint16_t )21,      (uint16_t )22,      (uint16_t )23, 
        (uint16_t )24,      (uint16_t )25,      (uint16_t )26,      (uint16_t )27, 
        (uint16_t )28,      (uint16_t )29,      (uint16_t )30,      (uint16_t )31, 
        (uint16_t )32,      (uint16_t )33,      (uint16_t )34,      (uint16_t )35, 
        (uint16_t )36,      (uint16_t )37,      (uint16_t )38,      (uint16_t )39, 
        (uint16_t )40,      (uint16_t )41,      (uint16_t )42,      (uint16_t )43, 
        (uint16_t )44,      (uint16_t )45,      (uint16_t )46,      (uint16_t )47, 
        (uint16_t )48,      (uint16_t )49,      (uint16_t )50,      (uint16_t )51, 
        (uint16_t )52,      (uint16_t )53,      (uint16_t )54,      (uint16_t )55, 
        (uint16_t )56,      (uint16_t )57,      (uint16_t )58,      (uint16_t )60, 
        (uint16_t )62,      (uint16_t )64,      (uint16_t )66,      (uint16_t )68, 
        (uint16_t )70,      (uint16_t )72,      (uint16_t )74,      (uint16_t )76, 
        (uint16_t )78,      (uint16_t )80,      (uint16_t )82,      (uint16_t )84, 
        (uint16_t )86,      (uint16_t )88,      (uint16_t )90,      (uint16_t )92, 
        (uint16_t )94,      (uint16_t )96,      (uint16_t )98,      (uint16_t )100, 
        (uint16_t )102,      (uint16_t )104,      (uint16_t )106,      (uint16_t )108, 
        (uint16_t )110,      (uint16_t )112,      (uint16_t )114,      (uint16_t )116, 
        (uint16_t )119,      (uint16_t )122,      (uint16_t )125,      (uint16_t )128, 
        (uint16_t )131,      (uint16_t )134,      (uint16_t )137,      (uint16_t )140, 
        (uint16_t )143,      (uint16_t )146,      (uint16_t )149,      (uint16_t )152, 
        (uint16_t )155,      (uint16_t )158,      (uint16_t )161,      (uint16_t )164, 
        (uint16_t )167,      (uint16_t )170,      (uint16_t )173,      (uint16_t )177, 
        (uint16_t )181,      (uint16_t )185,      (uint16_t )189,      (uint16_t )193, 
        (uint16_t )197,      (uint16_t )201,      (uint16_t )205,      (uint16_t )209, 
        (uint16_t )213,      (uint16_t )217,      (uint16_t )221,      (uint16_t )225, 
        (uint16_t )229,      (uint16_t )234,      (uint16_t )239,      (uint16_t )245, 
        (uint16_t )249,      (uint16_t )254,      (uint16_t )259,      (uint16_t )264, 
        (uint16_t )269,      (uint16_t )274,      (uint16_t )279,      (uint16_t )284};
#line 64 "/root/patchweave_new/13/src/dec/quant.c"
void VP8ParseQuant(VP8Decoder *dec ) 
{ 
  VP8BitReader *br ;
  int base_q0 ;
  uint32_t __cil_tmp4 ;
  int dqy1_dc ;
  uint32_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int32_t tmp___0 ;
  int dqy2_dc ;
  uint32_t __cil_tmp10 ;
  int32_t __cil_tmp11 ;
  int32_t tmp___1 ;
  int dqy2_ac ;
  uint32_t __cil_tmp14 ;
  int32_t __cil_tmp15 ;
  int32_t tmp___2 ;
  int dquv_dc ;
  uint32_t __cil_tmp18 ;
  int32_t __cil_tmp19 ;
  int32_t tmp___3 ;
  int dquv_ac ;
  uint32_t __cil_tmp22 ;
  int32_t __cil_tmp23 ;
  int32_t tmp___4 ;
  VP8SegmentHeader___0 *hdr ;
  int i ;
  int q ;
  VP8QuantMatrix *m ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;

  {
  {
#line 65
  br = & dec->br_;
#line 66
  __cil_tmp4 = VP8GetValue(br, 7);
#line 66
  base_q0 = (int )__cil_tmp4;
#line 67
  __cil_tmp6 = VP8Get(br);
  }
#line 67
  if (__cil_tmp6) {
    {
#line 67
    __cil_tmp7 = VP8GetSignedValue(br, 4);
#line 67
    tmp___0 = __cil_tmp7;
    }
  } else {
#line 67
    tmp___0 = 0;
  }
  {
#line 67
  dqy1_dc = tmp___0;
#line 68
  __cil_tmp10 = VP8Get(br);
  }
#line 68
  if (__cil_tmp10) {
    {
#line 68
    __cil_tmp11 = VP8GetSignedValue(br, 4);
#line 68
    tmp___1 = __cil_tmp11;
    }
  } else {
#line 68
    tmp___1 = 0;
  }
  {
#line 68
  dqy2_dc = tmp___1;
#line 69
  __cil_tmp14 = VP8Get(br);
  }
#line 69
  if (__cil_tmp14) {
    {
#line 69
    __cil_tmp15 = VP8GetSignedValue(br, 4);
#line 69
    tmp___2 = __cil_tmp15;
    }
  } else {
#line 69
    tmp___2 = 0;
  }
  {
#line 69
  dqy2_ac = tmp___2;
#line 70
  __cil_tmp18 = VP8Get(br);
  }
#line 70
  if (__cil_tmp18) {
    {
#line 70
    __cil_tmp19 = VP8GetSignedValue(br, 4);
#line 70
    tmp___3 = __cil_tmp19;
    }
  } else {
#line 70
    tmp___3 = 0;
  }
  {
#line 70
  dquv_dc = tmp___3;
#line 71
  __cil_tmp22 = VP8Get(br);
  }
#line 71
  if (__cil_tmp22) {
    {
#line 71
    __cil_tmp23 = VP8GetSignedValue(br, 4);
#line 71
    tmp___4 = __cil_tmp23;
    }
  } else {
#line 71
    tmp___4 = 0;
  }
#line 71
  dquv_ac = tmp___4;
#line 73
  hdr = & dec->segment_hdr_;
#line 76
  i = 0;
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 76
    if (! (i < 4)) {
#line 76
      goto while_break;
    }
#line 78
    if (hdr->use_segment_) {
#line 79
      q = (int )hdr->quantizer_[i];
#line 80
      if (! hdr->absolute_delta_) {
#line 81
        q += base_q0;
      }
    } else
#line 84
    if (i > 0) {
#line 85
      dec->dqm_[i] = dec->dqm_[0];
#line 86
      goto while_continue;
    } else {
#line 88
      q = base_q0;
    }
    {
#line 92
    m = & dec->dqm_[i];
#line 93
    __cil_tmp29 = clip___2(q + dqy1_dc, 127);
#line 93
    m->y1_mat_[0] = (int )kDcTable___0[__cil_tmp29];
#line 94
    __cil_tmp30 = clip___2(q, 127);
#line 94
    m->y1_mat_[1] = (int )kAcTable___0[__cil_tmp30];
#line 96
    __cil_tmp31 = clip___2(q + dqy2_dc, 127);
#line 96
    m->y2_mat_[0] = (int )kDcTable___0[__cil_tmp31] * 2;
#line 100
    __cil_tmp32 = clip___2(q + dqy2_ac, 127);
#line 100
    m->y2_mat_[1] = (int )kAcTable___0[__cil_tmp32] * 101581 >> 16;
    }
#line 101
    if (m->y2_mat_[1] < 8) {
#line 101
      m->y2_mat_[1] = 8;
    }
    {
#line 103
    __cil_tmp33 = clip___2(q + dquv_dc, 117);
#line 103
    m->uv_mat_[0] = (int )kDcTable___0[__cil_tmp33];
#line 104
    __cil_tmp34 = clip___2(q + dquv_ac, 127);
#line 104
    m->uv_mat_[1] = (int )kAcTable___0[__cil_tmp34];
#line 76
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 80
  return;
}
}
#line 23 "/root/patchweave_new/13/src/dec/layer.c"
int VP8DecodeLayer(VP8Decoder *dec ) 
{ 


  {
#line 30
  return (1);
}
}
#line 26 "/root/patchweave_new/13/src/dec/io.c"
static int EmitYUV(VP8Io *io , WebPDecParams *p ) 
{ 
  WebPDecBuffer *output ;
  WebPYUVABuffer *buf ;
  uint8_t *y_dst ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  int mb_w ;
  int mb_h ;
  int uv_w ;
  int uv_h ;
  int j ;

  {
#line 27
  output = p->output;
#line 28
  buf = & output->u.YUVA;
#line 29
  y_dst = buf->y + io->mb_y * buf->y_stride;
#line 30
  u_dst = buf->u + (io->mb_y >> 1) * buf->u_stride;
#line 31
  v_dst = buf->v + (io->mb_y >> 1) * buf->v_stride;
#line 32
  mb_w = io->mb_w;
#line 33
  mb_h = io->mb_h;
#line 34
  uv_w = (mb_w + 1) / 2;
#line 35
  uv_h = (mb_h + 1) / 2;
#line 37
  j = 0;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;

#line 37
    if (! (j < mb_h)) {
#line 37
      goto while_break;
    }
    {
#line 38
    memcpy((void *)(y_dst + j * buf->y_stride), (void const   *)(io->y + j * io->y_stride),
           (unsigned long )mb_w);
#line 37
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 40
    if (! (j < uv_h)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    memcpy((void *)(u_dst + j * buf->u_stride), (void const   *)(io->u + j * io->uv_stride),
           (unsigned long )uv_w);
#line 42
    memcpy((void *)(v_dst + j * buf->v_stride), (void const   *)(io->v + j * io->uv_stride),
           (unsigned long )uv_w);
#line 40
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 44
  return (io->mb_h);
}
}
#line 48 "/root/patchweave_new/13/src/dec/io.c"
static int EmitSampledRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  WebPDecBuffer *output ;
  WebPRGBABuffer *buf ;
  uint8_t *dst ;
  uint8_t *y_src ;
  uint8_t *u_src ;
  uint8_t *v_src ;
  void (*sample)(uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                 int  ) ;
  int mb_w ;
  int last ;
  int j ;

  {
#line 49
  output = p->output;
#line 50
  buf = & output->u.RGBA;
#line 51
  dst = buf->rgba + io->mb_y * buf->stride;
#line 52
  y_src = io->y;
#line 53
  u_src = io->u;
#line 54
  v_src = io->v;
#line 55
  sample = WebPSamplers[output->colorspace];
#line 56
  mb_w = io->mb_w;
#line 57
  last = io->mb_h - 1;
#line 59
  j = 0;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;

#line 59
    if (! (j < last)) {
#line 59
      goto while_break;
    }
    {
#line 60
    (*sample)(y_src, y_src + io->y_stride, u_src, v_src, dst, dst + buf->stride, mb_w);
#line 62
    y_src += 2 * io->y_stride;
#line 63
    u_src += io->uv_stride;
#line 64
    v_src += io->uv_stride;
#line 65
    dst += 2 * buf->stride;
#line 59
    j += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 67
  if (j == last) {
    {
#line 68
    (*sample)(y_src, y_src, u_src, v_src, dst, dst, mb_w);
    }
  }
#line 70
  return (io->mb_h);
}
}
#line 103 "/root/patchweave_new/13/src/dec/io.c"
static int EmitFancyRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  int num_lines_out ;
  WebPRGBABuffer *buf ;
  uint8_t *dst ;
  void (*upsample)(uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                   uint8_t * , uint8_t * , int  ) ;
  uint8_t *cur_y ;
  uint8_t *cur_u ;
  uint8_t *cur_v ;
  uint8_t *top_u ;
  uint8_t *top_v ;
  int y ;
  int y_end ;
  int mb_w ;
  int uv_w ;
  int __cil_tmp16 ;

  {
#line 104
  num_lines_out = io->mb_h;
#line 105
  buf = & (p->output)->u.RGBA;
#line 106
  dst = buf->rgba + io->mb_y * buf->stride;
#line 107
  upsample = WebPUpsamplers[(p->output)->colorspace];
#line 108
  cur_y = io->y;
#line 109
  cur_u = io->u;
#line 110
  cur_v = io->v;
#line 111
  top_u = p->tmp_u;
#line 112
  top_v = p->tmp_v;
#line 113
  y = io->mb_y;
#line 114
  y_end = io->mb_y + io->mb_h;
#line 115
  mb_w = io->mb_w;
#line 116
  uv_w = (mb_w + 1) / 2;
#line 118
  if (y == 0) {
    {
#line 120
    (*upsample)((uint8_t *)((void *)0), cur_y, cur_u, cur_v, cur_u, cur_v, (uint8_t *)((void *)0),
                dst, mb_w);
    }
  } else {
    {
#line 123
    (*upsample)(p->tmp_y, cur_y, top_u, top_v, cur_u, cur_v, dst - buf->stride, dst,
                mb_w);
#line 125
    num_lines_out ++;
    }
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;

#line 128
    if (! (y + 2 < y_end)) {
#line 128
      goto while_break;
    }
    {
#line 129
    top_u = cur_u;
#line 130
    top_v = cur_v;
#line 131
    cur_u += io->uv_stride;
#line 132
    cur_v += io->uv_stride;
#line 133
    dst += 2 * buf->stride;
#line 134
    cur_y += 2 * io->y_stride;
#line 135
    (*upsample)(cur_y - io->y_stride, cur_y, top_u, top_v, cur_u, cur_v, dst - buf->stride,
                dst, mb_w);
#line 128
    y += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 140
  cur_y += io->y_stride;
#line 141
  if (io->crop_top + y_end < io->crop_bottom) {
    {
#line 143
    memcpy((void *)p->tmp_y, (void const   *)cur_y, (unsigned long )mb_w * sizeof(*(p->tmp_y)));
#line 144
    memcpy((void *)p->tmp_u, (void const   *)cur_u, (unsigned long )uv_w * sizeof(*(p->tmp_u)));
#line 145
    memcpy((void *)p->tmp_v, (void const   *)cur_v, (unsigned long )uv_w * sizeof(*(p->tmp_v)));
#line 148
    __cil_tmp16 = num_lines_out;
#line 148
    num_lines_out --;
    }
  } else
#line 151
  if (! (y_end & 1)) {
    {
#line 152
    (*upsample)(cur_y, (uint8_t *)((void *)0), cur_u, cur_v, cur_u, cur_v, dst + buf->stride,
                (uint8_t *)((void *)0), mb_w);
    }
  }
#line 156
  return (num_lines_out);
}
}
#line 163 "/root/patchweave_new/13/src/dec/io.c"
static int EmitAlphaYUV(VP8Io *io , WebPDecParams *p ) 
{ 
  uint8_t *alpha ;
  WebPYUVABuffer *buf ;
  int mb_w ;
  int mb_h ;
  uint8_t *dst ;
  int j ;

  {
#line 164
  alpha = io->a;
#line 165
  buf = & (p->output)->u.YUVA;
#line 166
  mb_w = io->mb_w;
#line 167
  mb_h = io->mb_h;
#line 168
  dst = buf->a + io->mb_y * buf->a_stride;
#line 171
  if ((unsigned long )alpha != (unsigned long )((void *)0)) {
#line 172
    j = 0;
    {
#line 172
    while (1) {
      while_continue: /* CIL Label */ ;

#line 172
      if (! (j < mb_h)) {
#line 172
        goto while_break;
      }
      {
#line 173
      memcpy((void *)dst, (void const   *)alpha, (unsigned long )mb_w * sizeof(*dst));
#line 174
      alpha += io->width;
#line 175
      dst += buf->a_stride;
#line 172
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else
#line 177
  if ((unsigned long )buf->a != (unsigned long )((void *)0)) {
#line 179
    j = 0;
    {
#line 179
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 179
      if (! (j < mb_h)) {
#line 179
        goto while_break___0;
      }
      {
#line 180
      memset((void *)dst, 255, (unsigned long )mb_w * sizeof(*dst));
#line 181
      dst += buf->a_stride;
#line 179
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 184
  return (0);
}
}
#line 187 "/root/patchweave_new/13/src/dec/io.c"
static int GetAlphaSourceRow(VP8Io *io , uint8_t **alpha , int *num_rows ) 
{ 
  int start_y ;

  {
#line 189
  start_y = io->mb_y;
#line 190
  *num_rows = io->mb_h;
#line 194
  if (io->fancy_upsampling) {
#line 195
    if (start_y == 0) {
#line 197
      (*num_rows) --;
    } else {
#line 199
      start_y --;
#line 203
      *alpha -= io->width;
    }
#line 205
    if ((io->crop_top + io->mb_y) + io->mb_h == io->crop_bottom) {
#line 207
      *num_rows = (io->crop_bottom - io->crop_top) - start_y;
    }
  }
#line 210
  return (start_y);
}
}
#line 213 "/root/patchweave_new/13/src/dec/io.c"
static int EmitAlphaRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  uint8_t *alpha ;
  int mb_w ;
  enum WEBP_CSP_MODE colorspace ;
  int alpha_first ;
  WebPRGBABuffer *buf ;
  int num_rows ;
  int start_y ;
  int __cil_tmp10 ;
  uint8_t *base_rgba ;
  uint8_t *dst ;
  int tmp___0 ;
  uint32_t alpha_mask ;
  int i ;
  int j ;
  uint32_t alpha_value ;
  int __cil_tmp18 ;
  int tmp___1 ;

  {
#line 214
  alpha = io->a;
#line 215
  if ((unsigned long )alpha != (unsigned long )((void *)0)) {
#line 216
    mb_w = io->mb_w;
#line 217
    colorspace = (enum WEBP_CSP_MODE )(p->output)->colorspace;
#line 218
    if ((unsigned int )colorspace == 4U) {
#line 218
      tmp___1 = 1;
    } else
#line 218
    if ((unsigned int )colorspace == 9U) {
#line 218
      tmp___1 = 1;
    } else {
#line 218
      tmp___1 = 0;
    }
    {
#line 218
    alpha_first = tmp___1;
#line 220
    buf = & (p->output)->u.RGBA;
#line 222
    __cil_tmp10 = GetAlphaSourceRow(io, & alpha, & num_rows);
#line 222
    start_y = __cil_tmp10;
#line 223
    base_rgba = buf->rgba + start_y * buf->stride;
    }
#line 224
    if (alpha_first) {
#line 224
      tmp___0 = 0;
    } else {
#line 224
      tmp___0 = 3;
    }
#line 224
    dst = base_rgba + tmp___0;
#line 225
    alpha_mask = (uint32_t )255;
#line 228
    j = 0;
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;

#line 228
      if (! (j < num_rows)) {
#line 228
        goto while_break;
      }
#line 229
      i = 0;
      {
#line 229
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 229
        if (! (i < mb_w)) {
#line 229
          goto while_break___0;
        }
#line 230
        alpha_value = (uint32_t )*(alpha + i);
#line 231
        *(dst + 4 * i) = (uint8_t )alpha_value;
#line 232
        alpha_mask &= alpha_value;
#line 229
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 234
      alpha += io->width;
#line 235
      dst += buf->stride;
#line 228
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 238
    __cil_tmp18 = WebPIsPremultipliedMode___0(colorspace);
    }
#line 238
    if (alpha_mask != 255U) {
#line 238
      if (__cil_tmp18) {
        {
#line 239
        (*WebPApplyAlphaMultiply)(base_rgba, alpha_first, mb_w, num_rows, buf->stride);
        }
      }
    }
  }
#line 243
  return (0);
}
}
#line 246 "/root/patchweave_new/13/src/dec/io.c"
static int EmitAlphaRGBA4444(VP8Io *io , WebPDecParams *p ) 
{ 
  uint8_t *alpha ;
  int mb_w ;
  enum WEBP_CSP_MODE colorspace ;
  WebPRGBABuffer *buf ;
  int num_rows ;
  int start_y ;
  int __cil_tmp9 ;
  uint8_t *base_rgba ;
  uint8_t *alpha_dst ;
  uint32_t alpha_mask ;
  int i ;
  int j ;
  uint32_t alpha_value ;
  int __cil_tmp16 ;

  {
#line 247
  alpha = io->a;
#line 248
  if ((unsigned long )alpha != (unsigned long )((void *)0)) {
    {
#line 249
    mb_w = io->mb_w;
#line 250
    colorspace = (enum WEBP_CSP_MODE )(p->output)->colorspace;
#line 251
    buf = & (p->output)->u.RGBA;
#line 253
    __cil_tmp9 = GetAlphaSourceRow(io, & alpha, & num_rows);
#line 253
    start_y = __cil_tmp9;
#line 254
    base_rgba = buf->rgba + start_y * buf->stride;
#line 255
    alpha_dst = base_rgba + 1;
#line 256
    alpha_mask = (uint32_t )15;
#line 259
    j = 0;
    }
    {
#line 259
    while (1) {
      while_continue: /* CIL Label */ ;

#line 259
      if (! (j < num_rows)) {
#line 259
        goto while_break;
      }
#line 260
      i = 0;
      {
#line 260
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 260
        if (! (i < mb_w)) {
#line 260
          goto while_break___0;
        }
#line 262
        alpha_value = (uint32_t )((int )*(alpha + i) >> 4);
#line 263
        *(alpha_dst + 2 * i) = (uint8_t )((unsigned int )((int )*(alpha_dst + 2 * i) & 240) | alpha_value);
#line 264
        alpha_mask &= alpha_value;
#line 260
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 266
      alpha += io->width;
#line 267
      alpha_dst += buf->stride;
#line 259
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 269
    __cil_tmp16 = WebPIsPremultipliedMode___0(colorspace);
    }
#line 269
    if (alpha_mask != 15U) {
#line 269
      if (__cil_tmp16) {
        {
#line 270
        (*WebPApplyAlphaMultiply4444)(base_rgba, mb_w, num_rows, buf->stride);
        }
      }
    }
  }
#line 273
  return (0);
}
}
#line 279 "/root/patchweave_new/13/src/dec/io.c"
static int Rescale(uint8_t *src , int src_stride , int new_lines , WebPRescaler *wrk ) 
{ 
  int num_lines_out ;
  int lines_in ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 281
  num_lines_out = 0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;

#line 282
    if (! (new_lines > 0)) {
#line 282
      goto while_break;
    }
    {
#line 283
    __cil_tmp7 = WebPRescalerImport(wrk, new_lines, src, src_stride);
#line 283
    lines_in = __cil_tmp7;
#line 284
    src += lines_in * src_stride;
#line 285
    new_lines -= lines_in;
#line 286
    __cil_tmp8 = WebPRescalerExport(wrk);
#line 286
    num_lines_out += __cil_tmp8;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 288
  return (num_lines_out);
}
}
#line 291 "/root/patchweave_new/13/src/dec/io.c"
static int EmitRescaledYUV(VP8Io *io , WebPDecParams *p ) 
{ 
  int mb_h ;
  int uv_mb_h ;
  int num_lines_out ;
  int __cil_tmp6 ;

  {
  {
#line 292
  mb_h = io->mb_h;
#line 293
  uv_mb_h = (mb_h + 1) >> 1;
#line 294
  __cil_tmp6 = Rescale(io->y, io->y_stride, mb_h, & p->scaler_y);
#line 294
  num_lines_out = __cil_tmp6;
#line 295
  Rescale(io->u, io->uv_stride, uv_mb_h, & p->scaler_u);
#line 296
  Rescale(io->v, io->uv_stride, uv_mb_h, & p->scaler_v);
  }
#line 297
  return (num_lines_out);
}
}
#line 300 "/root/patchweave_new/13/src/dec/io.c"
static int EmitRescaledAlphaYUV(VP8Io *io , WebPDecParams *p ) 
{ 


  {
#line 301
  if ((unsigned long )io->a != (unsigned long )((void *)0)) {
    {
#line 302
    Rescale(io->a, io->width, io->mb_h, & p->scaler_a);
    }
  }
#line 304
  return (0);
}
}
#line 307 "/root/patchweave_new/13/src/dec/io.c"
static int InitYUVRescaler(VP8Io *io , WebPDecParams *p ) 
{ 
  int has_alpha ;
  int __cil_tmp4 ;
  WebPYUVABuffer *buf ;
  int out_width ;
  int out_height ;
  int uv_out_width ;
  int uv_out_height ;
  int uv_in_width ;
  int uv_in_height ;
  size_t work_size ;
  size_t uv_work_size ;
  size_t tmp_size ;
  int32_t *work ;

  {
  {
#line 308
  __cil_tmp4 = WebPIsAlphaMode___0((enum WEBP_CSP_MODE )(p->output)->colorspace);
#line 308
  has_alpha = __cil_tmp4;
#line 309
  buf = & (p->output)->u.YUVA;
#line 310
  out_width = io->scaled_width;
#line 311
  out_height = io->scaled_height;
#line 312
  uv_out_width = (out_width + 1) >> 1;
#line 313
  uv_out_height = (out_height + 1) >> 1;
#line 314
  uv_in_width = (io->mb_w + 1) >> 1;
#line 315
  uv_in_height = (io->mb_h + 1) >> 1;
#line 316
  work_size = (size_t )(2 * out_width);
#line 317
  uv_work_size = (size_t )(2 * uv_out_width);
#line 321
  tmp_size = work_size + 2UL * uv_work_size;
  }
#line 322
  if (has_alpha) {
#line 323
    tmp_size += work_size;
  }
  {
#line 325
  p->memory = calloc(1UL, tmp_size * sizeof(*work));
  }
#line 326
  if ((unsigned long )p->memory == (unsigned long )((void *)0)) {
#line 327
    return (0);
  }
  {
#line 329
  work = (int32_t *)p->memory;
#line 330
  WebPRescalerInit(& p->scaler_y, io->mb_w, io->mb_h, buf->y, out_width, out_height,
                   buf->y_stride, 1, io->mb_w, out_width, io->mb_h, out_height, work);
#line 334
  WebPRescalerInit(& p->scaler_u, uv_in_width, uv_in_height, buf->u, uv_out_width,
                   uv_out_height, buf->u_stride, 1, uv_in_width, uv_out_width, uv_in_height,
                   uv_out_height, work + work_size);
#line 339
  WebPRescalerInit(& p->scaler_v, uv_in_width, uv_in_height, buf->v, uv_out_width,
                   uv_out_height, buf->v_stride, 1, uv_in_width, uv_out_width, uv_in_height,
                   uv_out_height, (work + work_size) + uv_work_size);
#line 344
  p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitRescaledYUV);
  }
#line 346
  if (has_alpha) {
    {
#line 347
    WebPRescalerInit(& p->scaler_a, io->mb_w, io->mb_h, buf->a, out_width, out_height,
                     buf->a_stride, 1, io->mb_w, out_width, io->mb_h, out_height,
                     (work + work_size) + 2UL * uv_work_size);
#line 351
    p->emit_alpha = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitRescaledAlphaYUV);
    }
  }
#line 353
  return (1);
}
}
#line 359 "/root/patchweave_new/13/src/dec/io.c"
static int ExportRGB(WebPDecParams *p , int y_pos ) 
{ 
  void (*convert)(uint8_t * , uint8_t * , uint8_t * , uint8_t * , int  ) ;
  WebPRGBABuffer *buf ;
  uint8_t *dst ;
  int num_lines_out ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 360
  convert = WebPYUV444Converters[(p->output)->colorspace];
#line 362
  buf = & (p->output)->u.RGBA;
#line 363
  dst = buf->rgba + (p->last_y + y_pos) * buf->stride;
#line 364
  num_lines_out = 0;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 367
    __cil_tmp8 = WebPRescalerHasPendingOutput(& p->scaler_u);
#line 367
    __cil_tmp7 = WebPRescalerHasPendingOutput(& p->scaler_y);
    }
#line 367
    if (__cil_tmp7) {
#line 367
      if (! __cil_tmp8) {
#line 367
        goto while_break;
      }
    } else {
#line 367
      goto while_break;
    }
    {
#line 371
    WebPRescalerExportRow(& p->scaler_y);
#line 372
    WebPRescalerExportRow(& p->scaler_u);
#line 373
    WebPRescalerExportRow(& p->scaler_v);
#line 374
    (*convert)(p->scaler_y.dst, p->scaler_u.dst, p->scaler_v.dst, dst, p->scaler_y.dst_width);
#line 376
    dst += buf->stride;
#line 377
    num_lines_out ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 379
  return (num_lines_out);
}
}
#line 382 "/root/patchweave_new/13/src/dec/io.c"
static int EmitRescaledRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  int mb_h ;
  int uv_mb_h ;
  int j ;
  int uv_j ;
  int num_lines_out ;
  int y_lines_in ;
  int __cil_tmp9 ;
  int u_lines_in ;
  int __cil_tmp11 ;
  int v_lines_in ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;

  {
#line 383
  mb_h = io->mb_h;
#line 384
  uv_mb_h = (mb_h + 1) >> 1;
#line 385
  j = 0;
#line 385
  uv_j = 0;
#line 386
  num_lines_out = 0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;

#line 387
    if (! (j < mb_h)) {
#line 387
      goto while_break;
    }
    {
#line 388
    __cil_tmp9 = WebPRescalerImport(& p->scaler_y, mb_h - j, io->y + j * io->y_stride,
                                    io->y_stride);
#line 388
    y_lines_in = __cil_tmp9;
#line 391
    __cil_tmp11 = WebPRescalerImport(& p->scaler_u, uv_mb_h - uv_j, io->u + uv_j * io->uv_stride,
                                     io->uv_stride);
#line 391
    u_lines_in = __cil_tmp11;
#line 394
    __cil_tmp13 = WebPRescalerImport(& p->scaler_v, uv_mb_h - uv_j, io->v + uv_j * io->uv_stride,
                                     io->uv_stride);
#line 394
    v_lines_in = __cil_tmp13;
#line 399
    j += y_lines_in;
#line 400
    uv_j += u_lines_in;
#line 401
    __cil_tmp15 = ExportRGB(p, num_lines_out);
#line 401
    num_lines_out += __cil_tmp15;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 403
  return (num_lines_out);
}
}
#line 406 "/root/patchweave_new/13/src/dec/io.c"
static int ExportAlpha(WebPDecParams *p , int y_pos ) 
{ 
  WebPRGBABuffer *buf ;
  uint8_t *base_rgba ;
  enum WEBP_CSP_MODE colorspace ;
  int alpha_first ;
  uint8_t *dst ;
  int tmp___0 ;
  int num_lines_out ;
  int is_premult_alpha ;
  int __cil_tmp11 ;
  uint32_t alpha_mask ;
  int width ;
  int __cil_tmp14 ;
  int i ;
  uint32_t alpha_value ;
  int tmp___2 ;

  {
#line 407
  buf = & (p->output)->u.RGBA;
#line 408
  base_rgba = buf->rgba + (p->last_y + y_pos) * buf->stride;
#line 409
  colorspace = (enum WEBP_CSP_MODE )(p->output)->colorspace;
#line 410
  if ((unsigned int )colorspace == 4U) {
#line 410
    tmp___2 = 1;
  } else
#line 410
  if ((unsigned int )colorspace == 9U) {
#line 410
    tmp___2 = 1;
  } else {
#line 410
    tmp___2 = 0;
  }
#line 410
  alpha_first = tmp___2;
#line 412
  if (alpha_first) {
#line 412
    tmp___0 = 0;
  } else {
#line 412
    tmp___0 = 3;
  }
  {
#line 412
  dst = base_rgba + tmp___0;
#line 413
  num_lines_out = 0;
#line 414
  __cil_tmp11 = WebPIsPremultipliedMode___0(colorspace);
#line 414
  is_premult_alpha = __cil_tmp11;
#line 415
  alpha_mask = (uint32_t )255;
#line 416
  width = p->scaler_a.dst_width;
  }
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 418
    __cil_tmp14 = WebPRescalerHasPendingOutput(& p->scaler_a);
    }
#line 418
    if (! __cil_tmp14) {
#line 418
      goto while_break;
    }
    {
#line 421
    WebPRescalerExportRow(& p->scaler_a);
#line 422
    i = 0;
    }
    {
#line 422
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 422
      if (! (i < width)) {
#line 422
        goto while_break___0;
      }
#line 423
      alpha_value = (uint32_t )*(p->scaler_a.dst + i);
#line 424
      *(dst + 4 * i) = (uint8_t )alpha_value;
#line 425
      alpha_mask &= alpha_value;
#line 422
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 427
    dst += buf->stride;
#line 428
    num_lines_out ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 430
  if (is_premult_alpha) {
#line 430
    if (alpha_mask != 255U) {
      {
#line 431
      (*WebPApplyAlphaMultiply)(base_rgba, alpha_first, width, num_lines_out, buf->stride);
      }
    }
  }
#line 434
  return (num_lines_out);
}
}
#line 437 "/root/patchweave_new/13/src/dec/io.c"
static int ExportAlphaRGBA4444(WebPDecParams *p , int y_pos ) 
{ 
  WebPRGBABuffer *buf ;
  uint8_t *base_rgba ;
  uint8_t *alpha_dst ;
  int num_lines_out ;
  enum WEBP_CSP_MODE colorspace ;
  int width ;
  int is_premult_alpha ;
  int __cil_tmp10 ;
  uint32_t alpha_mask ;
  int __cil_tmp12 ;
  int i ;
  uint32_t alpha_value ;

  {
  {
#line 438
  buf = & (p->output)->u.RGBA;
#line 439
  base_rgba = buf->rgba + (p->last_y + y_pos) * buf->stride;
#line 440
  alpha_dst = base_rgba + 1;
#line 441
  num_lines_out = 0;
#line 442
  colorspace = (enum WEBP_CSP_MODE )(p->output)->colorspace;
#line 443
  width = p->scaler_a.dst_width;
#line 444
  __cil_tmp10 = WebPIsPremultipliedMode___0(colorspace);
#line 444
  is_premult_alpha = __cil_tmp10;
#line 445
  alpha_mask = (uint32_t )15;
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 447
    __cil_tmp12 = WebPRescalerHasPendingOutput(& p->scaler_a);
    }
#line 447
    if (! __cil_tmp12) {
#line 447
      goto while_break;
    }
    {
#line 450
    WebPRescalerExportRow(& p->scaler_a);
#line 451
    i = 0;
    }
    {
#line 451
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 451
      if (! (i < width)) {
#line 451
        goto while_break___0;
      }
#line 453
      alpha_value = (uint32_t )((int )*(p->scaler_a.dst + i) >> 4);
#line 454
      *(alpha_dst + 2 * i) = (uint8_t )((unsigned int )((int )*(alpha_dst + 2 * i) & 240) | alpha_value);
#line 455
      alpha_mask &= alpha_value;
#line 451
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 457
    alpha_dst += buf->stride;
#line 458
    num_lines_out ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 460
  if (is_premult_alpha) {
#line 460
    if (alpha_mask != 15U) {
      {
#line 461
      (*WebPApplyAlphaMultiply4444)(base_rgba, width, num_lines_out, buf->stride);
      }
    }
  }
#line 463
  return (num_lines_out);
}
}
#line 466 "/root/patchweave_new/13/src/dec/io.c"
static int EmitRescaledAlphaRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  WebPRescaler *scaler ;
  int j ;
  int pos ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 467
  if ((unsigned long )io->a != (unsigned long )((void *)0)) {
#line 468
    scaler = & p->scaler_a;
#line 469
    j = 0;
#line 470
    pos = 0;
    {
#line 471
    while (1) {
      while_continue: /* CIL Label */ ;

#line 471
      if (! (j < io->mb_h)) {
#line 471
        goto while_break;
      }
      {
#line 472
      __cil_tmp6 = WebPRescalerImport(scaler, io->mb_h - j, io->a + j * io->width,
                                      io->width);
#line 472
      j += __cil_tmp6;
#line 474
      __cil_tmp7 = (*(p->emit_alpha_row))((WebPDecParams */* const  */)p, pos);
#line 474
      pos += __cil_tmp7;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 477
  return (0);
}
}
#line 480 "/root/patchweave_new/13/src/dec/io.c"
static int InitRGBRescaler(VP8Io *io , WebPDecParams *p ) 
{ 
  int has_alpha ;
  int __cil_tmp4 ;
  int out_width ;
  int out_height ;
  int uv_in_width ;
  int uv_in_height ;
  size_t work_size ;
  int32_t *work ;
  uint8_t *tmp___0 ;
  size_t tmp_size1 ;
  size_t tmp_size2 ;

  {
  {
#line 481
  __cil_tmp4 = WebPIsAlphaMode___0((enum WEBP_CSP_MODE )(p->output)->colorspace);
#line 481
  has_alpha = __cil_tmp4;
#line 482
  out_width = io->scaled_width;
#line 483
  out_height = io->scaled_height;
#line 484
  uv_in_width = (io->mb_w + 1) >> 1;
#line 485
  uv_in_height = (io->mb_h + 1) >> 1;
#line 486
  work_size = (size_t )(2 * out_width);
#line 491
  tmp_size1 = 3UL * work_size;
#line 492
  tmp_size2 = (size_t )(3 * out_width);
  }
#line 493
  if (has_alpha) {
#line 494
    tmp_size1 += work_size;
#line 495
    tmp_size2 += (unsigned long )out_width;
  }
  {
#line 497
  p->memory = calloc(1UL, tmp_size1 * sizeof(*work) + tmp_size2 * sizeof(*tmp___0));
  }
#line 498
  if ((unsigned long )p->memory == (unsigned long )((void *)0)) {
#line 499
    return (0);
  }
  {
#line 501
  work = (int32_t *)p->memory;
#line 502
  tmp___0 = (uint8_t *)(work + tmp_size1);
#line 503
  WebPRescalerInit(& p->scaler_y, io->mb_w, io->mb_h, tmp___0 + 0, out_width, out_height,
                   0, 1, io->mb_w, out_width, io->mb_h, out_height, work + 0UL);
#line 507
  WebPRescalerInit(& p->scaler_u, uv_in_width, uv_in_height, tmp___0 + out_width,
                   out_width, out_height, 0, 1, io->mb_w, 2 * out_width, io->mb_h,
                   2 * out_height, work + work_size);
#line 511
  WebPRescalerInit(& p->scaler_v, uv_in_width, uv_in_height, tmp___0 + 2 * out_width,
                   out_width, out_height, 0, 1, io->mb_w, 2 * out_width, io->mb_h,
                   2 * out_height, work + 2UL * work_size);
#line 515
  p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitRescaledRGB);
  }
#line 517
  if (has_alpha) {
    {
#line 518
    WebPRescalerInit(& p->scaler_a, io->mb_w, io->mb_h, tmp___0 + 3 * out_width, out_width,
                     out_height, 0, 1, io->mb_w, out_width, io->mb_h, out_height,
                     work + 3UL * work_size);
#line 522
    p->emit_alpha = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitRescaledAlphaRGB);
    }
#line 523
    if ((unsigned int )(p->output)->colorspace == 5U) {
#line 525
      p->emit_alpha_row = (int (*)(WebPDecParams * const   , int  ))(& ExportAlphaRGBA4444);
    } else
#line 523
    if ((unsigned int )(p->output)->colorspace == 10U) {
#line 525
      p->emit_alpha_row = (int (*)(WebPDecParams * const   , int  ))(& ExportAlphaRGBA4444);
    } else {
#line 527
      p->emit_alpha_row = (int (*)(WebPDecParams * const   , int  ))(& ExportAlpha);
    }
  }
#line 530
  return (1);
}
}
#line 536 "/root/patchweave_new/13/src/dec/io.c"
static int CustomSetup(VP8Io *io ) 
{ 
  WebPDecParams *p ;
  enum WEBP_CSP_MODE colorspace ;
  int is_rgb ;
  int __cil_tmp5 ;
  int is_alpha ;
  int __cil_tmp7 ;
  int tmp___0 ;
  int __cil_tmp9 ;
  int ok ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int tmp___1 ;
  int uv_width ;
  int __cil_tmp16 ;
  int (*tmp___2)(VP8Io * const  io , WebPDecParams * const  p ) ;
  int (*tmp___3)(VP8Io * const  io , WebPDecParams * const  p ) ;

  {
  {
#line 537
  p = (WebPDecParams *)io->opaque;
#line 538
  colorspace = (enum WEBP_CSP_MODE )(p->output)->colorspace;
#line 539
  __cil_tmp5 = WebPIsRGBMode___0(colorspace);
#line 539
  is_rgb = __cil_tmp5;
#line 540
  __cil_tmp7 = WebPIsAlphaMode___0(colorspace);
#line 540
  is_alpha = __cil_tmp7;
#line 542
  p->memory = (void *)0;
#line 543
  p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))((void *)0);
#line 544
  p->emit_alpha = (int (*)(VP8Io * const   , WebPDecParams * const   ))((void *)0);
#line 545
  p->emit_alpha_row = (int (*)(WebPDecParams * const   , int  ))((void *)0);
  }
#line 546
  if (is_alpha) {
#line 546
    tmp___0 = 11;
  } else {
#line 546
    tmp___0 = 12;
  }
  {
#line 546
  __cil_tmp9 = WebPIoInitFromOptions(p->options, io, (enum WEBP_CSP_MODE )tmp___0);
  }
#line 546
  if (! __cil_tmp9) {
#line 547
    return (0);
  }
#line 550
  if (io->use_scaling) {
#line 551
    if (is_rgb) {
      {
#line 551
      __cil_tmp11 = InitRGBRescaler(io, p);
#line 551
      tmp___1 = __cil_tmp11;
      }
    } else {
      {
#line 551
      __cil_tmp12 = InitYUVRescaler(io, p);
#line 551
      tmp___1 = __cil_tmp12;
      }
    }
#line 551
    ok = tmp___1;
#line 552
    if (! ok) {
#line 553
      return (0);
    }
  } else {
#line 556
    if (is_rgb) {
#line 557
      p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitSampledRGB);
#line 559
      if (io->fancy_upsampling) {
        {
#line 560
        uv_width = (io->mb_w + 1) >> 1;
#line 561
        p->memory = malloc((unsigned long )(io->mb_w + 2 * uv_width));
        }
#line 562
        if ((unsigned long )p->memory == (unsigned long )((void *)0)) {
#line 563
          return (0);
        }
        {
#line 565
        p->tmp_y = (uint8_t *)p->memory;
#line 566
        p->tmp_u = p->tmp_y + io->mb_w;
#line 567
        p->tmp_v = p->tmp_u + uv_width;
#line 568
        p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitFancyRGB);
#line 569
        WebPInitUpsamplers();
        }
      }
    } else {
#line 573
      p->emit = (int (*)(VP8Io * const   , WebPDecParams * const   ))(& EmitYUV);
    }
#line 575
    if (is_alpha) {
      {
#line 576
      __cil_tmp16 = WebPIsPremultipliedMode___0(colorspace);
      }
#line 576
      if (__cil_tmp16) {
        {
#line 576
        WebPInitPremultiply();
        }
      }
#line 577
      if ((unsigned int )colorspace == 5U) {
#line 577
        tmp___3 = (int (*)(VP8Io * const  io , WebPDecParams * const  p ))(& EmitAlphaRGBA4444);
      } else
#line 577
      if ((unsigned int )colorspace == 10U) {
#line 577
        tmp___3 = (int (*)(VP8Io * const  io , WebPDecParams * const  p ))(& EmitAlphaRGBA4444);
      } else {
#line 577
        if (is_rgb) {
#line 577
          tmp___2 = (int (*)(VP8Io * const  io , WebPDecParams * const  p ))(& EmitAlphaRGB);
        } else {
#line 577
          tmp___2 = (int (*)(VP8Io * const  io , WebPDecParams * const  p ))(& EmitAlphaYUV);
        }
#line 577
        tmp___3 = tmp___2;
      }
#line 577
      p->emit_alpha = tmp___3;
    }
  }
#line 585
  if (is_rgb) {
    {
#line 586
    VP8YUVInit();
    }
  }
#line 588
  return (1);
}
}
#line 593 "/root/patchweave_new/13/src/dec/io.c"
static int CustomPut(VP8Io *io ) 
{ 
  WebPDecParams *p ;
  int mb_w ;
  int mb_h ;
  int num_lines_out ;

  {
#line 594
  p = (WebPDecParams *)io->opaque;
#line 595
  mb_w = io->mb_w;
#line 596
  mb_h = io->mb_h;
#line 600
  if (mb_w <= 0) {
#line 601
    return (0);
  } else
#line 600
  if (mb_h <= 0) {
#line 601
    return (0);
  }
  {
#line 603
  num_lines_out = (*(p->emit))((VP8Io */* const  */)io, (WebPDecParams */* const  */)p);
  }
#line 604
  if (p->emit_alpha) {
    {
#line 605
    (*(p->emit_alpha))((VP8Io */* const  */)io, (WebPDecParams */* const  */)p);
    }
  }
#line 607
  p->last_y += num_lines_out;
#line 608
  return (1);
}
}
#line 613 "/root/patchweave_new/13/src/dec/io.c"
static void CustomTeardown(VP8Io *io ) 
{ 
  WebPDecParams *p ;

  {
  {
#line 614
  p = (WebPDecParams *)io->opaque;
#line 615
  free(p->memory);
#line 616
  p->memory = (void *)0;
  }
#line 618
  return;
}
}
#line 622 "/root/patchweave_new/13/src/dec/io.c"
void WebPInitCustomIo(WebPDecParams *params , VP8Io *io ) 
{ 


  {
#line 623
  io->put = & CustomPut;
#line 624
  io->setup = & CustomSetup;
#line 625
  io->teardown = & CustomTeardown;
#line 626
  io->opaque = (void *)params;
#line 627
  return;
}
}
#line 89 "/root/patchweave_new/13/src/dec/idec.c"
static void RemapBitReader(VP8BitReader *br , ptrdiff_t offset ) 
{ 


  {
#line 90
  if ((unsigned long )br->buf_ != (unsigned long )((void *)0)) {
#line 91
    br->buf_ += offset;
#line 92
    br->buf_end_ += offset;
  }
#line 94
  return;
}
}
#line 96 "/root/patchweave_new/13/src/dec/idec.c"
__inline static size_t MemDataSize(MemBuffer *mem ) 
{ 


  {
#line 97
  return (mem->end_ - mem->start_);
}
}
#line 102 "/root/patchweave_new/13/src/dec/idec.c"
static int NeedCompressedAlpha(WebPIDecoder *idec ) 
{ 
  VP8Decoder *dec ;
  int tmp___1 ;

  {
#line 103
  if ((unsigned int )idec->state_ == 0U) {
#line 106
    return (0);
  }
#line 108
  if (idec->is_lossless_) {
#line 109
    return (0);
  } else {
#line 111
    dec = (VP8Decoder *)idec->dec_;
#line 113
    if ((unsigned long )dec->alpha_data_ != (unsigned long )((void *)0)) {
#line 113
      if (! dec->is_alpha_decoded_) {
#line 113
        tmp___1 = 1;
      } else {
#line 113
        tmp___1 = 0;
      }
    } else {
#line 113
      tmp___1 = 0;
    }
#line 113
    return (tmp___1);
  }
}
}
#line 117 "/root/patchweave_new/13/src/dec/idec.c"
static void DoRemap(WebPIDecoder *idec , ptrdiff_t offset ) 
{ 
  MemBuffer *mem ;
  uint8_t *new_base ;
  VP8Decoder *dec ;
  int last_part ;
  int p ;
  int __cil_tmp10 ;
  VP8LDecoder *dec___0 ;
  size_t __cil_tmp12 ;

  {
  {
#line 118
  mem = & idec->mem_;
#line 119
  new_base = mem->buf_ + mem->start_;
#line 122
  idec->io_.data = new_base;
#line 123
  idec->io_.data_size = MemDataSize(mem);
  }
#line 125
  if ((unsigned long )idec->dec_ != (unsigned long )((void *)0)) {
#line 126
    if (! idec->is_lossless_) {
#line 127
      dec = (VP8Decoder *)idec->dec_;
#line 128
      last_part = dec->num_parts_ - 1;
#line 129
      if (offset != 0L) {
#line 131
        p = 0;
        {
#line 131
        while (1) {
          while_continue: /* CIL Label */ ;

#line 131
          if (! (p <= last_part)) {
#line 131
            goto while_break;
          }
          {
#line 132
          RemapBitReader(dec->parts_ + p, offset);
#line 131
          p ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        while_break: ;
#line 136
        if ((unsigned int )mem->mode_ == 2U) {
          {
#line 137
          RemapBitReader(& dec->br_, offset);
          }
        }
      }
      {
#line 141
      dec->parts_[last_part].buf_end_ = mem->buf_ + mem->end_;
#line 142
      __cil_tmp10 = NeedCompressedAlpha(idec);
      }
#line 142
      if (__cil_tmp10) {
#line 142
        dec->alpha_data_ += offset;
      }
    } else {
      {
#line 144
      dec___0 = (VP8LDecoder *)idec->dec_;
#line 145
      __cil_tmp12 = MemDataSize(mem);
#line 145
      VP8LBitReaderSetBuffer(& dec___0->br_, new_base, __cil_tmp12);
      }
    }
  }
#line 149
  return;
}
}
#line 152 "/root/patchweave_new/13/src/dec/idec.c"
static int AppendToMemBuffer(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  VP8Decoder *dec ;
  MemBuffer *mem ;
  int need_compressed_alpha ;
  int __cil_tmp7 ;
  uint8_t *old_start ;
  uint8_t *old_base ;
  uint8_t *tmp___0 ;
  size_t new_mem_start ;
  size_t current_size ;
  size_t __cil_tmp14 ;
  uint64_t new_size ;
  uint64_t extra_size ;
  uint8_t *new_buf ;
  void *__cil_tmp18 ;

  {
  {
#line 154
  dec = (VP8Decoder *)idec->dec_;
#line 155
  mem = & idec->mem_;
#line 156
  __cil_tmp7 = NeedCompressedAlpha(idec);
#line 156
  need_compressed_alpha = __cil_tmp7;
#line 157
  old_start = mem->buf_ + mem->start_;
  }
#line 158
  if (need_compressed_alpha) {
#line 158
    tmp___0 = dec->alpha_data_;
  } else {
#line 158
    tmp___0 = old_start;
  }
#line 158
  old_base = tmp___0;
#line 161
  if (data_size > 4294967286UL) {
#line 164
    return (0);
  }
#line 167
  if (mem->end_ + data_size > mem->buf_size_) {
    {
#line 168
    new_mem_start = (size_t )(old_start - old_base);
#line 169
    __cil_tmp14 = MemDataSize(mem);
#line 169
    current_size = __cil_tmp14 + new_mem_start;
#line 170
    new_size = current_size + data_size;
#line 171
    extra_size = ((new_size + 4096UL) - 1UL) & 0xfffffffffffff000UL;
#line 172
    __cil_tmp18 = WebPSafeMalloc(extra_size, sizeof(*new_buf));
#line 172
    new_buf = (uint8_t *)__cil_tmp18;
    }
#line 174
    if ((unsigned long )new_buf == (unsigned long )((void *)0)) {
#line 174
      return (0);
    }
    {
#line 175
    memcpy((void *)new_buf, (void const   *)old_base, current_size);
#line 176
    free((void *)mem->buf_);
#line 177
    mem->buf_ = new_buf;
#line 178
    mem->buf_size_ = extra_size;
#line 179
    mem->start_ = new_mem_start;
#line 180
    mem->end_ = current_size;
    }
  }
  {
#line 183
  memcpy((void *)(mem->buf_ + mem->end_), (void const   *)data, data_size);
#line 184
  mem->end_ += data_size;
#line 187
  DoRemap(idec, (mem->buf_ + mem->start_) - old_start);
  }
#line 188
  return (1);
}
}
#line 191 "/root/patchweave_new/13/src/dec/idec.c"
static int RemapMemBuffer(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  MemBuffer *mem ;
  uint8_t *old_buf ;
  uint8_t *old_start ;

  {
#line 193
  mem = & idec->mem_;
#line 194
  old_buf = mem->buf_;
#line 195
  old_start = old_buf + mem->start_;
#line 198
  if (data_size < mem->buf_size_) {
#line 198
    return (0);
  }
  {
#line 200
  mem->buf_ = data;
#line 201
  mem->buf_size_ = data_size;
#line 201
  mem->end_ = mem->buf_size_;
#line 203
  DoRemap(idec, (mem->buf_ + mem->start_) - old_start);
  }
#line 204
  return (1);
}
}
#line 207 "/root/patchweave_new/13/src/dec/idec.c"
static void InitMemBuffer(MemBuffer *mem ) 
{ 


  {
#line 208
  mem->mode_ = (MemBufferMode )0;
#line 209
  mem->buf_ = (uint8_t *)((void *)0);
#line 210
  mem->buf_size_ = (size_t )0;
#line 211
  mem->part0_buf_ = (uint8_t *)((void *)0);
#line 212
  mem->part0_size_ = (size_t )0;
#line 213
  return;
}
}
#line 215 "/root/patchweave_new/13/src/dec/idec.c"
static void ClearMemBuffer(MemBuffer *mem ) 
{ 


  {
#line 217
  if ((unsigned int )mem->mode_ == 1U) {
    {
#line 218
    free((void *)mem->buf_);
#line 219
    free((void *)mem->part0_buf_);
    }
  }
#line 222
  return;
}
}
#line 223 "/root/patchweave_new/13/src/dec/idec.c"
static int CheckMemBufferMode(MemBuffer *mem , MemBufferMode expected ) 
{ 


  {
#line 224
  if ((unsigned int )mem->mode_ == 0U) {
#line 225
    mem->mode_ = expected;
  } else
#line 226
  if ((unsigned int )mem->mode_ != (unsigned int )expected) {
#line 227
    return (0);
  }
#line 230
  return (1);
}
}
#line 236 "/root/patchweave_new/13/src/dec/idec.c"
static void SaveContext(VP8Decoder *dec , VP8BitReader *token_br , MBContext *context ) 
{ 
  VP8BitReader *br ;
  VP8MB *left ;
  VP8MB *info ;

  {
  {
#line 238
  br = & dec->br_;
#line 239
  left = dec->mb_info_ - 1;
#line 240
  info = dec->mb_info_ + dec->mb_x_;
#line 242
  context->left_ = *left;
#line 243
  context->info_ = *info;
#line 244
  context->br_ = *br;
#line 245
  context->token_br_ = *token_br;
#line 246
  memcpy((void *)(context->intra_t_), (void const   *)(dec->intra_t_ + 4 * dec->mb_x_),
         4UL);
#line 247
  memcpy((void *)(context->intra_l_), (void const   *)(dec->intra_l_), 4UL);
  }
#line 249
  return;
}
}
#line 250 "/root/patchweave_new/13/src/dec/idec.c"
static void RestoreContext(MBContext *context , VP8Decoder *dec , VP8BitReader *token_br ) 
{ 
  VP8BitReader *br ;
  VP8MB *left ;
  VP8MB *info ;

  {
  {
#line 252
  br = & dec->br_;
#line 253
  left = dec->mb_info_ - 1;
#line 254
  info = dec->mb_info_ + dec->mb_x_;
#line 256
  *left = context->left_;
#line 257
  *info = context->info_;
#line 258
  *br = context->br_;
#line 259
  *token_br = context->token_br_;
#line 260
  memcpy((void *)(dec->intra_t_ + 4 * dec->mb_x_), (void const   *)(context->intra_t_),
         4UL);
#line 261
  memcpy((void *)(dec->intra_l_), (void const   *)(context->intra_l_), 4UL);
  }
#line 263
  return;
}
}
#line 266 "/root/patchweave_new/13/src/dec/idec.c"
static enum VP8StatusCode IDecError(WebPIDecoder *idec , enum VP8StatusCode error ) 
{ 
  VP8Io *io ;

  {
#line 267
  if ((unsigned int )idec->state_ == 3U) {
#line 268
    io = & idec->io_;
#line 269
    if (io->teardown) {
      {
#line 270
      (*(io->teardown))(io);
      }
    }
  }
#line 273
  idec->state_ = (DecState )7;
#line 274
  return (error);
}
}
#line 277 "/root/patchweave_new/13/src/dec/idec.c"
static void ChangeState(WebPIDecoder *idec , DecState new_state , size_t consumed_bytes ) 
{ 
  MemBuffer *mem ;

  {
  {
#line 279
  mem = & idec->mem_;
#line 280
  idec->state_ = new_state;
#line 281
  mem->start_ += consumed_bytes;
#line 283
  idec->io_.data = mem->buf_ + mem->start_;
#line 284
  idec->io_.data_size = MemDataSize(mem);
  }
#line 286
  return;
}
}
#line 288 "/root/patchweave_new/13/src/dec/idec.c"
static enum VP8StatusCode DecodeWebPHeaders(WebPIDecoder *idec ) 
{ 
  MemBuffer *mem ;
  uint8_t *data ;
  size_t curr_size ;
  size_t __cil_tmp5 ;
  enum VP8StatusCode status ;
  WebPHeaderStructure headers ;
  enum VP8StatusCode __cil_tmp9 ;
  VP8Decoder *dec ;
  VP8Decoder *__cil_tmp11 ;
  VP8LDecoder *dec___0 ;
  VP8LDecoder *__cil_tmp13 ;
  int tmp___0 ;

  {
  {
#line 289
  mem = & idec->mem_;
#line 290
  data = mem->buf_ + mem->start_;
#line 291
  __cil_tmp5 = MemDataSize(mem);
#line 291
  curr_size = __cil_tmp5;
#line 295
  headers.data = data;
#line 296
  headers.data_size = curr_size;
#line 297
  status = WebPParseHeaders(& headers);
  }
#line 298
  if ((unsigned int )status == 7U) {
#line 299
    return ((enum VP8StatusCode )5);
  } else
#line 300
  if ((unsigned int )status != 0U) {
    {
#line 301
    __cil_tmp9 = IDecError(idec, status);
    }
#line 301
    return (__cil_tmp9);
  }
#line 304
  idec->chunk_size_ = headers.compressed_size;
#line 305
  idec->is_lossless_ = headers.is_lossless;
#line 306
  if (! idec->is_lossless_) {
    {
#line 307
    __cil_tmp11 = VP8New();
#line 307
    dec = __cil_tmp11;
    }
#line 308
    if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 309
      return ((enum VP8StatusCode )1);
    }
#line 311
    idec->dec_ = (void *)dec;
#line 313
    if ((unsigned long )idec->params_.options != (unsigned long )((void *)0)) {
#line 313
      if ((idec->params_.options)->use_threads > 0) {
#line 313
        tmp___0 = 1;
      } else {
#line 313
        tmp___0 = 0;
      }
    } else {
#line 313
      tmp___0 = 0;
    }
    {
#line 313
    dec->use_threads_ = tmp___0;
#line 318
    dec->alpha_data_ = headers.alpha_data;
#line 319
    dec->alpha_data_size_ = headers.alpha_data_size;
#line 320
    ChangeState(idec, (DecState )1, headers.offset);
    }
  } else {
    {
#line 322
    __cil_tmp13 = VP8LNew();
#line 322
    dec___0 = __cil_tmp13;
    }
#line 323
    if ((unsigned long )dec___0 == (unsigned long )((void *)0)) {
#line 324
      return ((enum VP8StatusCode )1);
    }
    {
#line 326
    idec->dec_ = (void *)dec___0;
#line 327
    ChangeState(idec, (DecState )4, headers.offset);
    }
  }
#line 329
  return ((enum VP8StatusCode )0);
}
}
#line 332 "/root/patchweave_new/13/src/dec/idec.c"
static enum VP8StatusCode DecodeVP8FrameHeader(WebPIDecoder *idec ) 
{ 
  uint8_t *data ;
  size_t curr_size ;
  size_t __cil_tmp4 ;
  uint32_t bits ;
  int __cil_tmp6 ;
  enum VP8StatusCode __cil_tmp7 ;

  {
  {
#line 333
  data = idec->mem_.buf_ + idec->mem_.start_;
#line 334
  __cil_tmp4 = MemDataSize(& idec->mem_);
#line 334
  curr_size = __cil_tmp4;
  }
#line 337
  if (curr_size < 10UL) {
#line 339
    return ((enum VP8StatusCode )5);
  }
  {
#line 341
  __cil_tmp6 = VP8GetInfo(data, curr_size, idec->chunk_size_, (int *)((void *)0),
                          (int *)((void *)0));
  }
#line 341
  if (! __cil_tmp6) {
    {
#line 342
    __cil_tmp7 = IDecError(idec, (enum VP8StatusCode )3);
    }
#line 342
    return (__cil_tmp7);
  }
#line 345
  bits = (uint32_t )(((int )*(data + 0) | ((int )*(data + 1) << 8)) | ((int )*(data + 2) << 16));
#line 346
  idec->mem_.part0_size_ = (size_t )((bits >> 5) + 10U);
#line 348
  idec->io_.data = data;
#line 349
  idec->io_.data_size = curr_size;
#line 350
  idec->state_ = (DecState )2;
#line 351
  return ((enum VP8StatusCode )0);
}
}
#line 355 "/root/patchweave_new/13/src/dec/idec.c"
static int CopyParts0Data(WebPIDecoder *idec ) 
{ 
  VP8Decoder *dec ;
  VP8BitReader *br ;
  size_t psize ;
  MemBuffer *mem ;
  uint8_t *part0_buf ;
  void *__cil_tmp11 ;

  {
#line 356
  dec = (VP8Decoder *)idec->dec_;
#line 357
  br = & dec->br_;
#line 358
  psize = (size_t )(br->buf_end_ - br->buf_);
#line 359
  mem = & idec->mem_;
#line 364
  if ((unsigned int )mem->mode_ == 1U) {
    {
#line 366
    __cil_tmp11 = malloc(psize);
#line 366
    part0_buf = (uint8_t *)__cil_tmp11;
    }
#line 367
    if ((unsigned long )part0_buf == (unsigned long )((void *)0)) {
#line 368
      return (0);
    }
    {
#line 370
    memcpy((void *)part0_buf, (void const   *)br->buf_, psize);
#line 371
    mem->part0_buf_ = part0_buf;
#line 372
    br->buf_ = part0_buf;
#line 373
    br->buf_end_ = part0_buf + psize;
    }
  }
#line 377
  mem->start_ += psize;
#line 378
  return (1);
}
}
#line 381 "/root/patchweave_new/13/src/dec/idec.c"
static enum VP8StatusCode DecodePartition0(WebPIDecoder *idec ) 
{ 
  VP8Decoder *dec ;
  VP8Io *io ;
  WebPDecParams *params ;
  WebPDecBuffer *output ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  enum VP8StatusCode status ;
  enum VP8StatusCode __cil_tmp9 ;
  enum VP8StatusCode __cil_tmp11 ;
  int __cil_tmp12 ;
  enum VP8StatusCode __cil_tmp13 ;
  enum VP8StatusCode __cil_tmp14 ;
  enum VP8StatusCode __cil_tmp15 ;
  int __cil_tmp16 ;
  enum VP8StatusCode __cil_tmp17 ;

  {
  {
#line 382
  dec = (VP8Decoder *)idec->dec_;
#line 383
  io = & idec->io_;
#line 384
  params = & idec->params_;
#line 385
  output = params->output;
#line 388
  __cil_tmp6 = MemDataSize(& idec->mem_);
  }
#line 388
  if (__cil_tmp6 < idec->mem_.part0_size_) {
#line 389
    return ((enum VP8StatusCode )5);
  }
  {
#line 392
  __cil_tmp7 = VP8GetHeaders(dec, io);
  }
#line 392
  if (! __cil_tmp7) {
#line 393
    status = dec->status_;
#line 394
    if ((unsigned int )status == 5U) {
#line 397
      return ((enum VP8StatusCode )5);
    } else
#line 394
    if ((unsigned int )status == 7U) {
#line 397
      return ((enum VP8StatusCode )5);
    }
    {
#line 399
    __cil_tmp9 = IDecError(idec, status);
    }
#line 399
    return (__cil_tmp9);
  }
  {
#line 403
  dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options, output);
  }
#line 405
  if ((unsigned int )dec->status_ != 0U) {
    {
#line 406
    __cil_tmp11 = IDecError(idec, dec->status_);
    }
#line 406
    return (__cil_tmp11);
  }
  {
#line 409
  __cil_tmp12 = CopyParts0Data(idec);
  }
#line 409
  if (! __cil_tmp12) {
    {
#line 410
    __cil_tmp13 = IDecError(idec, (enum VP8StatusCode )1);
    }
#line 410
    return (__cil_tmp13);
  }
  {
#line 414
  __cil_tmp14 = VP8EnterCritical(dec, io);
  }
#line 414
  if ((unsigned int )__cil_tmp14 != 0U) {
    {
#line 415
    __cil_tmp15 = IDecError(idec, dec->status_);
    }
#line 415
    return (__cil_tmp15);
  }
  {
#line 420
  idec->state_ = (DecState )3;
#line 422
  __cil_tmp16 = VP8InitFrame(dec, io);
  }
#line 422
  if (! __cil_tmp16) {
    {
#line 423
    __cil_tmp17 = IDecError(idec, dec->status_);
    }
#line 423
    return (__cil_tmp17);
  }
#line 425
  return ((enum VP8StatusCode )0);
}
}
#line 429 "/root/patchweave_new/13/src/dec/idec.c"
static enum VP8StatusCode DecodeRemaining(WebPIDecoder *idec ) 
{ 
  VP8Decoder *dec ;
  VP8Io *io ;
  VP8BitReader *token_br ;
  MBContext context ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;
  enum VP8StatusCode __cil_tmp9 ;
  int __cil_tmp12 ;
  enum VP8StatusCode __cil_tmp13 ;
  int __cil_tmp14 ;
  enum VP8StatusCode __cil_tmp15 ;

  {
#line 430
  dec = (VP8Decoder *)idec->dec_;
#line 431
  io = & idec->io_;
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;

#line 435
    if (! (dec->mb_y_ < dec->mb_h_)) {
#line 435
      goto while_break;
    }
#line 436
    token_br = & dec->parts_[dec->mb_y_ & (dec->num_parts_ - 1)];
#line 437
    if (dec->mb_x_ == 0) {
      {
#line 438
      VP8InitScanline(dec);
      }
    }
    {
#line 440
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 440
      if (! (dec->mb_x_ < dec->mb_w_)) {
#line 440
        goto while_break___0;
      }
      {
#line 442
      SaveContext(dec, token_br, & context);
#line 444
      __cil_tmp7 = VP8DecodeMB(dec, token_br);
      }
#line 444
      if (! __cil_tmp7) {
        {
#line 445
        RestoreContext(& context, dec, token_br);
#line 447
        __cil_tmp8 = MemDataSize(& idec->mem_);
        }
#line 447
        if (dec->num_parts_ == 1) {
#line 447
          if (__cil_tmp8 > 4096UL) {
            {
#line 448
            __cil_tmp9 = IDecError(idec, (enum VP8StatusCode )3);
            }
#line 448
            return (__cil_tmp9);
          }
        }
#line 450
        return ((enum VP8StatusCode )5);
      }
      {
#line 453
      VP8ReconstructBlock(dec);
      }
#line 456
      if (dec->num_parts_ == 1) {
#line 457
        idec->mem_.start_ = (size_t )(token_br->buf_ - idec->mem_.buf_);
      }
#line 440
      (dec->mb_x_) ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 461
    __cil_tmp12 = VP8ProcessRow(dec, io);
    }
#line 461
    if (! __cil_tmp12) {
      {
#line 462
      __cil_tmp13 = IDecError(idec, (enum VP8StatusCode )6);
      }
#line 462
      return (__cil_tmp13);
    }
#line 464
    dec->mb_x_ = 0;
#line 435
    (dec->mb_y_) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 467
  __cil_tmp14 = VP8ExitCritical(dec, io);
  }
#line 467
  if (! __cil_tmp14) {
    {
#line 468
    __cil_tmp15 = IDecError(idec, (enum VP8StatusCode )6);
    }
#line 468
    return (__cil_tmp15);
  }
#line 470
  dec->ready_ = 0;
#line 471
  idec->state_ = (DecState )6;
#line 473
  return ((enum VP8StatusCode )0);
}
}
#line 476 "/root/patchweave_new/13/src/dec/idec.c"
static int ErrorStatusLossless(WebPIDecoder *idec , enum VP8StatusCode status ) 
{ 
  enum VP8StatusCode __cil_tmp3 ;

  {
#line 477
  if ((unsigned int )status == 5U) {
#line 478
    return (5);
  } else
#line 477
  if ((unsigned int )status == 7U) {
#line 478
    return (5);
  }
  {
#line 480
  __cil_tmp3 = IDecError(idec, status);
  }
#line 480
  return ((int )__cil_tmp3);
}
}
#line 483 "/root/patchweave_new/13/src/dec/idec.c"
static enum VP8StatusCode DecodeVP8LHeader(WebPIDecoder *idec ) 
{ 
  VP8Io *io ;
  VP8LDecoder *dec ;
  WebPDecParams *params ;
  WebPDecBuffer *output ;
  size_t curr_size ;
  size_t __cil_tmp7 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  enum VP8StatusCode __cil_tmp12 ;

  {
  {
#line 484
  io = & idec->io_;
#line 485
  dec = (VP8LDecoder *)idec->dec_;
#line 486
  params = & idec->params_;
#line 487
  output = params->output;
#line 488
  __cil_tmp7 = MemDataSize(& idec->mem_);
#line 488
  curr_size = __cil_tmp7;
  }
#line 492
  if (curr_size < idec->chunk_size_ >> 3) {
#line 493
    return ((enum VP8StatusCode )5);
  }
  {
#line 495
  __cil_tmp9 = VP8LDecodeHeader(dec, io);
  }
#line 495
  if (! __cil_tmp9) {
    {
#line 496
    __cil_tmp10 = ErrorStatusLossless(idec, dec->status_);
    }
#line 496
    return ((enum VP8StatusCode )__cil_tmp10);
  }
  {
#line 499
  dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options, output);
  }
#line 501
  if ((unsigned int )dec->status_ != 0U) {
    {
#line 502
    __cil_tmp12 = IDecError(idec, dec->status_);
    }
#line 502
    return (__cil_tmp12);
  }
#line 505
  idec->state_ = (DecState )5;
#line 506
  return ((enum VP8StatusCode )0);
}
}
#line 509 "/root/patchweave_new/13/src/dec/idec.c"
static enum VP8StatusCode DecodeVP8LData(WebPIDecoder *idec ) 
{ 
  VP8LDecoder *dec ;
  size_t curr_size ;
  size_t __cil_tmp4 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 510
  dec = (VP8LDecoder *)idec->dec_;
#line 511
  __cil_tmp4 = MemDataSize(& idec->mem_);
#line 511
  curr_size = __cil_tmp4;
  }
#line 516
  if (curr_size < idec->chunk_size_) {
#line 517
    return ((enum VP8StatusCode )5);
  }
  {
#line 520
  __cil_tmp6 = VP8LDecodeImage(dec);
  }
#line 520
  if (! __cil_tmp6) {
    {
#line 521
    __cil_tmp7 = ErrorStatusLossless(idec, dec->status_);
    }
#line 521
    return ((enum VP8StatusCode )__cil_tmp7);
  }
#line 524
  idec->state_ = (DecState )6;
#line 526
  return ((enum VP8StatusCode )0);
}
}
#line 530 "/root/patchweave_new/13/src/dec/idec.c"
static enum VP8StatusCode IDecode(WebPIDecoder *idec ) 
{ 
  enum VP8StatusCode status ;

  {
#line 531
  status = (enum VP8StatusCode )5;
#line 533
  if ((unsigned int )idec->state_ == 0U) {
    {
#line 534
    status = DecodeWebPHeaders(idec);
    }
  } else
#line 536
  if ((unsigned long )idec->dec_ == (unsigned long )((void *)0)) {
#line 537
    return ((enum VP8StatusCode )5);
  }
#line 540
  if ((unsigned int )idec->state_ == 1U) {
    {
#line 541
    status = DecodeVP8FrameHeader(idec);
    }
  }
#line 543
  if ((unsigned int )idec->state_ == 2U) {
    {
#line 544
    status = DecodePartition0(idec);
    }
  }
#line 546
  if ((unsigned int )idec->state_ == 3U) {
    {
#line 547
    status = DecodeRemaining(idec);
    }
  }
#line 549
  if ((unsigned int )idec->state_ == 4U) {
    {
#line 550
    status = DecodeVP8LHeader(idec);
    }
  }
#line 552
  if ((unsigned int )idec->state_ == 5U) {
    {
#line 553
    status = DecodeVP8LData(idec);
    }
  }
#line 555
  return (status);
}
}
#line 561 "/root/patchweave_new/13/src/dec/idec.c"
WebPIDecoder *WebPINewDecoder(WebPDecBuffer *output_buffer ) 
{ 
  WebPIDecoder *idec ;
  void *__cil_tmp3 ;
  WebPDecBuffer *tmp___0 ;

  {
  {
#line 562
  __cil_tmp3 = calloc(1UL, sizeof(*idec));
#line 562
  idec = (WebPIDecoder *)__cil_tmp3;
  }
#line 563
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 564
    return ((WebPIDecoder *)((void *)0));
  }
  {
#line 567
  idec->state_ = (DecState )0;
#line 568
  idec->chunk_size_ = (size_t )0;
#line 570
  InitMemBuffer(& idec->mem_);
#line 571
  WebPInitDecBuffer(& idec->output_);
#line 572
  VP8InitIo(& idec->io_);
#line 574
  WebPResetDecParams(& idec->params_);
  }
#line 575
  if (output_buffer) {
#line 575
    tmp___0 = output_buffer;
  } else {
#line 575
    tmp___0 = & idec->output_;
  }
  {
#line 575
  idec->params_.output = tmp___0;
#line 576
  WebPInitCustomIo(& idec->params_, & idec->io_);
  }
#line 578
  return (idec);
}
}
#line 581 "/root/patchweave_new/13/src/dec/idec.c"
WebPIDecoder *WebPIDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) 
{ 
  WebPIDecoder *idec ;
  enum VP8StatusCode __cil_tmp5 ;
  WebPDecBuffer *tmp___0 ;
  WebPIDecoder *__cil_tmp7 ;

  {
#line 586
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 586
    if (data_size > 0UL) {
#line 586
      if ((unsigned long )config != (unsigned long )((void *)0)) {
        {
#line 587
        __cil_tmp5 = WebPGetFeatures___0(data, data_size, & config->input);
        }
#line 587
        if ((unsigned int )__cil_tmp5 != 0U) {
#line 588
          return ((WebPIDecoder *)((void *)0));
        }
      }
    }
  }
#line 592
  if (config) {
#line 592
    tmp___0 = & config->output;
  } else {
#line 592
    tmp___0 = (WebPDecBuffer *)((void *)0);
  }
  {
#line 592
  __cil_tmp7 = WebPINewDecoder(tmp___0);
#line 592
  idec = __cil_tmp7;
  }
#line 593
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 594
    return ((WebPIDecoder *)((void *)0));
  }
#line 597
  if ((unsigned long )config != (unsigned long )((void *)0)) {
#line 598
    idec->params_.options = & config->options;
  }
#line 600
  return (idec);
}
}
#line 603 "/root/patchweave_new/13/src/dec/idec.c"
void WebPIDelete(WebPIDecoder *idec ) 
{ 


  {
#line 604
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 604
    return;
  }
#line 605
  if ((unsigned long )idec->dec_ != (unsigned long )((void *)0)) {
#line 606
    if (! idec->is_lossless_) {
      {
#line 607
      VP8Delete((VP8Decoder *)idec->dec_);
      }
    } else {
      {
#line 609
      VP8LDelete((VP8LDecoder *)idec->dec_);
      }
    }
  }
  {
#line 612
  ClearMemBuffer(& idec->mem_);
#line 613
  WebPFreeDecBuffer(& idec->output_);
#line 614
  free((void *)idec);
  }
#line 616
  return;
}
}
#line 620 "/root/patchweave_new/13/src/dec/idec.c"
WebPIDecoder *WebPINewRGB(enum WEBP_CSP_MODE mode , uint8_t *output_buffer , size_t output_buffer_size ,
                          int output_stride ) 
{ 
  int is_external_memory ;
  WebPIDecoder *idec ;

  {
#line 622
  is_external_memory = (unsigned long )output_buffer != (unsigned long )((void *)0);
#line 625
  if ((unsigned int )mode >= 11U) {
#line 625
    return ((WebPIDecoder *)((void *)0));
  }
#line 626
  if (! is_external_memory) {
#line 627
    output_buffer_size = (size_t )0;
#line 628
    output_stride = 0;
  } else
#line 630
  if (output_stride == 0) {
#line 631
    return ((WebPIDecoder *)((void *)0));
  } else
#line 630
  if (output_buffer_size == 0UL) {
#line 631
    return ((WebPIDecoder *)((void *)0));
  }
  {
#line 634
  idec = WebPINewDecoder((WebPDecBuffer *)((void *)0));
  }
#line 635
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 635
    return ((WebPIDecoder *)((void *)0));
  }
#line 636
  idec->output_.colorspace = (enum WEBP_CSP_MODE___0 )mode;
#line 637
  idec->output_.is_external_memory = is_external_memory;
#line 638
  idec->output_.u.RGBA.rgba = output_buffer;
#line 639
  idec->output_.u.RGBA.stride = output_stride;
#line 640
  idec->output_.u.RGBA.size = output_buffer_size;
#line 641
  return (idec);
}
}
#line 644 "/root/patchweave_new/13/src/dec/idec.c"
WebPIDecoder *WebPINewYUVA(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                           size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                           int v_stride , uint8_t *a , size_t a_size , int a_stride ) 
{ 
  int is_external_memory ;
  WebPIDecoder *idec ;
  enum WEBP_CSP_MODE colorspace ;
  int tmp___0 ;

  {
#line 648
  is_external_memory = (unsigned long )luma != (unsigned long )((void *)0);
#line 652
  if (! is_external_memory) {
#line 653
    a_size = (size_t )0;
#line 653
    v_size = a_size;
#line 653
    u_size = v_size;
#line 653
    luma_size = u_size;
#line 654
    a_stride = 0;
#line 654
    v_stride = a_stride;
#line 654
    u_stride = v_stride;
#line 654
    luma_stride = u_stride;
#line 655
    a = (uint8_t *)((void *)0);
#line 655
    v = a;
#line 655
    u = v;
#line 656
    colorspace = (enum WEBP_CSP_MODE )12;
  } else {
#line 658
    if ((unsigned long )u == (unsigned long )((void *)0)) {
#line 658
      return ((WebPIDecoder *)((void *)0));
    } else
#line 658
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 658
      return ((WebPIDecoder *)((void *)0));
    }
#line 659
    if (luma_size == 0UL) {
#line 659
      return ((WebPIDecoder *)((void *)0));
    } else
#line 659
    if (u_size == 0UL) {
#line 659
      return ((WebPIDecoder *)((void *)0));
    } else
#line 659
    if (v_size == 0UL) {
#line 659
      return ((WebPIDecoder *)((void *)0));
    }
#line 660
    if (luma_stride == 0) {
#line 660
      return ((WebPIDecoder *)((void *)0));
    } else
#line 660
    if (u_stride == 0) {
#line 660
      return ((WebPIDecoder *)((void *)0));
    } else
#line 660
    if (v_stride == 0) {
#line 660
      return ((WebPIDecoder *)((void *)0));
    }
#line 661
    if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 662
      if (a_size == 0UL) {
#line 662
        return ((WebPIDecoder *)((void *)0));
      } else
#line 662
      if (a_stride == 0) {
#line 662
        return ((WebPIDecoder *)((void *)0));
      }
    }
#line 664
    if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 664
      tmp___0 = 11;
    } else {
#line 664
      tmp___0 = 12;
    }
#line 664
    colorspace = (enum WEBP_CSP_MODE )tmp___0;
  }
  {
#line 667
  idec = WebPINewDecoder((WebPDecBuffer *)((void *)0));
  }
#line 668
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 668
    return ((WebPIDecoder *)((void *)0));
  }
#line 670
  idec->output_.colorspace = (enum WEBP_CSP_MODE___0 )colorspace;
#line 671
  idec->output_.is_external_memory = is_external_memory;
#line 672
  idec->output_.u.YUVA.y = luma;
#line 673
  idec->output_.u.YUVA.y_stride = luma_stride;
#line 674
  idec->output_.u.YUVA.y_size = luma_size;
#line 675
  idec->output_.u.YUVA.u = u;
#line 676
  idec->output_.u.YUVA.u_stride = u_stride;
#line 677
  idec->output_.u.YUVA.u_size = u_size;
#line 678
  idec->output_.u.YUVA.v = v;
#line 679
  idec->output_.u.YUVA.v_stride = v_stride;
#line 680
  idec->output_.u.YUVA.v_size = v_size;
#line 681
  idec->output_.u.YUVA.a = a;
#line 682
  idec->output_.u.YUVA.a_stride = a_stride;
#line 683
  idec->output_.u.YUVA.a_size = a_size;
#line 684
  return (idec);
}
}
#line 687 "/root/patchweave_new/13/src/dec/idec.c"
WebPIDecoder *WebPINewYUV(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                          size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                          int v_stride ) 
{ 
  WebPIDecoder *__cil_tmp10 ;

  {
  {
#line 690
  __cil_tmp10 = WebPINewYUVA(luma, luma_size, luma_stride, u, u_size, u_stride, v,
                             v_size, v_stride, (uint8_t *)((void *)0), (size_t )0,
                             0);
  }
#line 690
  return (__cil_tmp10);
}
}
#line 698 "/root/patchweave_new/13/src/dec/idec.c"
static enum VP8StatusCode IDecCheckStatus(WebPIDecoder *idec ) 
{ 


  {
#line 700
  if ((unsigned int )idec->state_ == 7U) {
#line 701
    return ((enum VP8StatusCode )3);
  }
#line 703
  if ((unsigned int )idec->state_ == 6U) {
#line 704
    return ((enum VP8StatusCode )0);
  }
#line 706
  return ((enum VP8StatusCode )5);
}
}
#line 709 "/root/patchweave_new/13/src/dec/idec.c"
enum VP8StatusCode___0 WebPIAppend(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  enum VP8StatusCode status ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  enum VP8StatusCode __cil_tmp8 ;

  {
#line 712
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 713
    return ((enum VP8StatusCode___0 )((enum VP8StatusCode )2));
  } else
#line 712
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 713
    return ((enum VP8StatusCode___0 )((enum VP8StatusCode )2));
  }
  {
#line 715
  status = IDecCheckStatus(idec);
  }
#line 716
  if ((unsigned int )status != 5U) {
#line 717
    return ((enum VP8StatusCode___0 )status);
  }
  {
#line 720
  __cil_tmp6 = CheckMemBufferMode(& idec->mem_, (MemBufferMode )1);
  }
#line 720
  if (! __cil_tmp6) {
#line 721
    return ((enum VP8StatusCode___0 )((enum VP8StatusCode )2));
  }
  {
#line 724
  __cil_tmp7 = AppendToMemBuffer(idec, data, data_size);
  }
#line 724
  if (! __cil_tmp7) {
#line 725
    return ((enum VP8StatusCode___0 )((enum VP8StatusCode )1));
  }
  {
#line 727
  __cil_tmp8 = IDecode(idec);
  }
#line 727
  return ((enum VP8StatusCode___0 )__cil_tmp8);
}
}
#line 730 "/root/patchweave_new/13/src/dec/idec.c"
enum VP8StatusCode___0 WebPIUpdate(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  enum VP8StatusCode status ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  enum VP8StatusCode __cil_tmp8 ;

  {
#line 733
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 734
    return ((enum VP8StatusCode___0 )((enum VP8StatusCode )2));
  } else
#line 733
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 734
    return ((enum VP8StatusCode___0 )((enum VP8StatusCode )2));
  }
  {
#line 736
  status = IDecCheckStatus(idec);
  }
#line 737
  if ((unsigned int )status != 5U) {
#line 738
    return ((enum VP8StatusCode___0 )status);
  }
  {
#line 741
  __cil_tmp6 = CheckMemBufferMode(& idec->mem_, (MemBufferMode )2);
  }
#line 741
  if (! __cil_tmp6) {
#line 742
    return ((enum VP8StatusCode___0 )((enum VP8StatusCode )2));
  }
  {
#line 745
  __cil_tmp7 = RemapMemBuffer(idec, data, data_size);
  }
#line 745
  if (! __cil_tmp7) {
#line 746
    return ((enum VP8StatusCode___0 )((enum VP8StatusCode )2));
  }
  {
#line 748
  __cil_tmp8 = IDecode(idec);
  }
#line 748
  return ((enum VP8StatusCode___0 )__cil_tmp8);
}
}
#line 753 "/root/patchweave_new/13/src/dec/idec.c"
static WebPDecBuffer *GetOutputBuffer(WebPIDecoder *idec ) 
{ 


  {
#line 754
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 755
    return ((WebPDecBuffer *)((void *)0));
  } else
#line 754
  if ((unsigned long )idec->dec_ == (unsigned long )((void *)0)) {
#line 755
    return ((WebPDecBuffer *)((void *)0));
  }
#line 757
  if ((unsigned int )idec->state_ <= 2U) {
#line 758
    return ((WebPDecBuffer *)((void *)0));
  }
#line 760
  return (idec->params_.output);
}
}
#line 763 "/root/patchweave_new/13/src/dec/idec.c"
WebPDecBuffer *WebPIDecodedArea(WebPIDecoder *idec , int *left , int *top , int *width ,
                                int *height ) 
{ 
  WebPDecBuffer *src ;
  WebPDecBuffer *__cil_tmp7 ;

  {
  {
#line 766
  __cil_tmp7 = GetOutputBuffer(idec);
#line 766
  src = __cil_tmp7;
  }
#line 767
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 767
    *left = 0;
  }
#line 768
  if ((unsigned long )top != (unsigned long )((void *)0)) {
#line 768
    *top = 0;
  }
#line 770
  if (src) {
#line 771
    if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 771
      *width = src->width;
    }
#line 772
    if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 772
      *height = idec->params_.last_y;
    }
  } else {
#line 774
    if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 774
      *width = 0;
    }
#line 775
    if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 775
      *height = 0;
    }
  }
#line 777
  return (src);
}
}
#line 780 "/root/patchweave_new/13/src/dec/idec.c"
uint8_t *WebPIDecGetRGB(WebPIDecoder *idec , int *last_y , int *width , int *height ,
                        int *stride ) 
{ 
  WebPDecBuffer *src ;
  WebPDecBuffer *__cil_tmp7 ;

  {
  {
#line 782
  __cil_tmp7 = GetOutputBuffer(idec);
#line 782
  src = __cil_tmp7;
  }
#line 783
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 783
    return ((uint8_t *)((void *)0));
  }
#line 784
  if ((unsigned int )src->colorspace >= 11U) {
#line 785
    return ((uint8_t *)((void *)0));
  }
#line 788
  if ((unsigned long )last_y != (unsigned long )((void *)0)) {
#line 788
    *last_y = idec->params_.last_y;
  }
#line 789
  if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 789
    *width = src->width;
  }
#line 790
  if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 790
    *height = src->height;
  }
#line 791
  if ((unsigned long )stride != (unsigned long )((void *)0)) {
#line 791
    *stride = src->u.RGBA.stride;
  }
#line 793
  return (src->u.RGBA.rgba);
}
}
#line 796 "/root/patchweave_new/13/src/dec/idec.c"
uint8_t *WebPIDecGetYUVA(WebPIDecoder *idec , int *last_y , uint8_t **u , uint8_t **v ,
                         uint8_t **a , int *width , int *height , int *stride , int *uv_stride ,
                         int *a_stride ) 
{ 
  WebPDecBuffer *src ;
  WebPDecBuffer *__cil_tmp12 ;

  {
  {
#line 800
  __cil_tmp12 = GetOutputBuffer(idec);
#line 800
  src = __cil_tmp12;
  }
#line 801
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 801
    return ((uint8_t *)((void *)0));
  }
#line 802
  if ((unsigned int )src->colorspace < 11U) {
#line 803
    return ((uint8_t *)((void *)0));
  }
#line 806
  if ((unsigned long )last_y != (unsigned long )((void *)0)) {
#line 806
    *last_y = idec->params_.last_y;
  }
#line 807
  if ((unsigned long )u != (unsigned long )((void *)0)) {
#line 807
    *u = src->u.YUVA.u;
  }
#line 808
  if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 808
    *v = src->u.YUVA.v;
  }
#line 809
  if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 809
    *a = src->u.YUVA.a;
  }
#line 810
  if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 810
    *width = src->width;
  }
#line 811
  if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 811
    *height = src->height;
  }
#line 812
  if ((unsigned long )stride != (unsigned long )((void *)0)) {
#line 812
    *stride = src->u.YUVA.y_stride;
  }
#line 813
  if ((unsigned long )uv_stride != (unsigned long )((void *)0)) {
#line 813
    *uv_stride = src->u.YUVA.u_stride;
  }
#line 814
  if ((unsigned long )a_stride != (unsigned long )((void *)0)) {
#line 814
    *a_stride = src->u.YUVA.a_stride;
  }
#line 816
  return (src->u.YUVA.y);
}
}
#line 819 "/root/patchweave_new/13/src/dec/idec.c"
int WebPISetIOHooks(WebPIDecoder *idec , int (*put)(VP8Io * ) , int (*setup)(VP8Io * ) ,
                    void (*teardown)(VP8Io * ) , void *user_data ) 
{ 


  {
#line 824
  if ((unsigned long )idec == (unsigned long )((void *)0)) {
#line 825
    return (0);
  } else
#line 824
  if ((unsigned int )idec->state_ > 0U) {
#line 825
    return (0);
  }
#line 828
  idec->io_.put = put;
#line 829
  idec->io_.setup = setup;
#line 830
  idec->io_.teardown = teardown;
#line 831
  idec->io_.opaque = user_data;
#line 833
  return (1);
}
}
#line 30 "/root/patchweave_new/13/src/dec/frame.c"
static uint8_t kFilterExtraRows[3]  = {      (uint8_t )0,      (uint8_t )2,      (uint8_t )8};
#line 32 "/root/patchweave_new/13/src/dec/frame.c"
__inline static int hev_thresh_from_level(int level , int keyframe ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 33
  if (keyframe) {
#line 34
    if (level >= 40) {
#line 34
      tmp___1 = 2;
    } else {
#line 34
      if (level >= 15) {
#line 34
        tmp___0 = 1;
      } else {
#line 34
        tmp___0 = 0;
      }
#line 34
      tmp___1 = tmp___0;
    }
#line 34
    return (tmp___1);
  } else {
#line 36
    if (level >= 40) {
#line 36
      tmp___4 = 3;
    } else {
#line 36
      if (level >= 20) {
#line 36
        tmp___3 = 2;
      } else {
#line 36
        if (level >= 15) {
#line 36
          tmp___2 = 1;
        } else {
#line 36
          tmp___2 = 0;
        }
#line 36
        tmp___3 = tmp___2;
      }
#line 36
      tmp___4 = tmp___3;
    }
#line 36
    return (tmp___4);
  }
}
}
#line 40 "/root/patchweave_new/13/src/dec/frame.c"
static void DoFilter___0(VP8Decoder *dec , int mb_x , int mb_y ) 
{ 
  VP8ThreadContext *ctx ;
  int y_bps ;
  VP8FInfo *f_info ;
  uint8_t *y_dst ;
  int level ;
  int ilevel ;
  int limit ;
  int uv_bps ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  int hev_thresh ;
  int __cil_tmp15 ;

  {
#line 41
  ctx = & dec->thread_ctx_;
#line 42
  y_bps = dec->cache_y_stride_;
#line 43
  f_info = ctx->f_info_ + mb_x;
#line 44
  y_dst = (dec->cache_y_ + (ctx->id_ * 16) * y_bps) + mb_x * 16;
#line 45
  level = (int )f_info->f_level_;
#line 46
  ilevel = (int )f_info->f_ilevel_;
#line 47
  limit = 2 * level + ilevel;
#line 48
  if (level == 0) {
#line 49
    return;
  }
#line 51
  if (dec->filter_type_ == 1) {
#line 52
    if (mb_x > 0) {
      {
#line 53
      (*VP8SimpleHFilter16)(y_dst, y_bps, limit + 4);
      }
    }
#line 55
    if (f_info->f_inner_) {
      {
#line 56
      (*VP8SimpleHFilter16i)(y_dst, y_bps, limit);
      }
    }
#line 58
    if (mb_y > 0) {
      {
#line 59
      (*VP8SimpleVFilter16)(y_dst, y_bps, limit + 4);
      }
    }
#line 61
    if (f_info->f_inner_) {
      {
#line 62
      (*VP8SimpleVFilter16i)(y_dst, y_bps, limit);
      }
    }
  } else {
    {
#line 65
    uv_bps = dec->cache_uv_stride_;
#line 66
    u_dst = (dec->cache_u_ + (ctx->id_ * 8) * uv_bps) + mb_x * 8;
#line 67
    v_dst = (dec->cache_v_ + (ctx->id_ * 8) * uv_bps) + mb_x * 8;
#line 68
    __cil_tmp15 = hev_thresh_from_level(level, (int )dec->frm_hdr_.key_frame_);
#line 68
    hev_thresh = __cil_tmp15;
    }
#line 70
    if (mb_x > 0) {
      {
#line 71
      (*VP8HFilter16)(y_dst, y_bps, limit + 4, ilevel, hev_thresh);
#line 72
      (*VP8HFilter8)(u_dst, v_dst, uv_bps, limit + 4, ilevel, hev_thresh);
      }
    }
#line 74
    if (f_info->f_inner_) {
      {
#line 75
      (*VP8HFilter16i)(y_dst, y_bps, limit, ilevel, hev_thresh);
#line 76
      (*VP8HFilter8i)(u_dst, v_dst, uv_bps, limit, ilevel, hev_thresh);
      }
    }
#line 78
    if (mb_y > 0) {
      {
#line 79
      (*VP8VFilter16)(y_dst, y_bps, limit + 4, ilevel, hev_thresh);
#line 80
      (*VP8VFilter8)(u_dst, v_dst, uv_bps, limit + 4, ilevel, hev_thresh);
      }
    }
#line 82
    if (f_info->f_inner_) {
      {
#line 83
      (*VP8VFilter16i)(y_dst, y_bps, limit, ilevel, hev_thresh);
#line 84
      (*VP8VFilter8i)(u_dst, v_dst, uv_bps, limit, ilevel, hev_thresh);
      }
    }
  }
#line 88
  return;
}
}
#line 90 "/root/patchweave_new/13/src/dec/frame.c"
static void FilterRow(VP8Decoder *dec ) 
{ 
  int mb_x ;
  int mb_y ;

  {
#line 92
  mb_y = dec->thread_ctx_.mb_y_;
#line 94
  mb_x = dec->tl_mb_x_;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;

#line 94
    if (! (mb_x < dec->br_mb_x_)) {
#line 94
      goto while_break;
    }
    {
#line 95
    DoFilter___0(dec, mb_x, mb_y);
#line 94
    mb_x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 98
  return;
}
}
#line 102 "/root/patchweave_new/13/src/dec/frame.c"
static void PrecomputeFilterStrengths(VP8Decoder *dec ) 
{ 
  int s ;
  VP8FilterHeader___0 *hdr ;
  int i4x4 ;
  int base_level ;
  VP8FInfo *info ;
  int level ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 103
  if (dec->filter_type_ > 0) {
#line 105
    hdr = & dec->filter_hdr_;
#line 106
    s = 0;
    {
#line 106
    while (1) {
      while_continue: /* CIL Label */ ;

#line 106
      if (! (s < 4)) {
#line 106
        goto while_break;
      }
#line 110
      if (dec->segment_hdr_.use_segment_) {
#line 111
        base_level = (int )dec->segment_hdr_.filter_strength_[s];
#line 112
        if (! dec->segment_hdr_.absolute_delta_) {
#line 113
          base_level += hdr->level_;
        }
      } else {
#line 116
        base_level = hdr->level_;
      }
#line 118
      i4x4 = 0;
      {
#line 118
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 118
        if (! (i4x4 <= 1)) {
#line 118
          goto while_break___0;
        }
#line 119
        info = & dec->fstrengths_[s][i4x4];
#line 120
        level = base_level;
#line 121
        if (hdr->use_lf_delta_) {
#line 123
          level += hdr->ref_lf_delta_[0];
#line 124
          if (i4x4) {
#line 125
            level += hdr->mode_lf_delta_[0];
          }
        }
#line 128
        if (level < 0) {
#line 128
          tmp___1 = 0;
        } else {
#line 128
          if (level > 63) {
#line 128
            tmp___0 = 63;
          } else {
#line 128
            tmp___0 = level;
          }
#line 128
          tmp___1 = tmp___0;
        }
#line 128
        level = tmp___1;
#line 129
        info->f_level_ = (unsigned int )level;
#line 131
        if (hdr->sharpness_ > 0) {
#line 132
          if (hdr->sharpness_ > 4) {
#line 133
            level >>= 2;
          } else {
#line 135
            level >>= 1;
          }
#line 137
          if (level > 9 - hdr->sharpness_) {
#line 138
            level = 9 - hdr->sharpness_;
          }
        }
#line 141
        if (level < 1) {
#line 141
          tmp___2 = 1;
        } else {
#line 141
          tmp___2 = level;
        }
#line 141
        info->f_ilevel_ = (unsigned int )tmp___2;
#line 142
        info->f_inner_ = 0U;
#line 118
        i4x4 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
#line 106
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 111
  return;
}
}
#line 162 "/root/patchweave_new/13/src/dec/frame.c"
static int FinishRow(VP8Decoder *dec , VP8Io *io ) 
{ 
  int ok ;
  VP8ThreadContext *ctx ;
  int extra_y_rows ;
  int ysize ;
  int uvsize ;
  int y_offset ;
  int uv_offset ;
  uint8_t *ydst ;
  uint8_t *udst ;
  uint8_t *vdst ;
  int first_row ;
  int last_row ;
  int y_start ;
  int y_end ;
  int __cil_tmp18 ;
  int delta_y ;

  {
#line 163
  ok = 1;
#line 164
  ctx = & dec->thread_ctx_;
#line 165
  extra_y_rows = (int )kFilterExtraRows[dec->filter_type_];
#line 166
  ysize = extra_y_rows * dec->cache_y_stride_;
#line 167
  uvsize = (extra_y_rows / 2) * dec->cache_uv_stride_;
#line 168
  y_offset = (ctx->id_ * 16) * dec->cache_y_stride_;
#line 169
  uv_offset = (ctx->id_ * 8) * dec->cache_uv_stride_;
#line 170
  ydst = (dec->cache_y_ - ysize) + y_offset;
#line 171
  udst = (dec->cache_u_ - uvsize) + uv_offset;
#line 172
  vdst = (dec->cache_v_ - uvsize) + uv_offset;
#line 173
  first_row = ctx->mb_y_ == 0;
#line 174
  last_row = ctx->mb_y_ >= dec->br_mb_y_ - 1;
#line 175
  y_start = ctx->mb_y_ * 16;
#line 176
  y_end = (ctx->mb_y_ + 1) * 16;
#line 178
  if (ctx->filter_row_) {
    {
#line 179
    FilterRow(dec);
    }
  }
#line 182
  if (io->put) {
#line 183
    if (! first_row) {
#line 184
      y_start -= extra_y_rows;
#line 185
      io->y = ydst;
#line 186
      io->u = udst;
#line 187
      io->v = vdst;
    } else {
#line 189
      io->y = dec->cache_y_ + y_offset;
#line 190
      io->u = dec->cache_u_ + uv_offset;
#line 191
      io->v = dec->cache_v_ + uv_offset;
    }
#line 194
    if (! last_row) {
#line 195
      y_end -= extra_y_rows;
    }
#line 197
    if (y_end > io->crop_bottom) {
#line 198
      y_end = io->crop_bottom;
    }
#line 200
    io->a = (uint8_t *)((void *)0);
#line 201
    if ((unsigned long )dec->alpha_data_ != (unsigned long )((void *)0)) {
#line 201
      if (y_start < y_end) {
        {
#line 207
        io->a = VP8DecompressAlphaRows(dec, y_start, y_end - y_start);
        }
#line 208
        if ((unsigned long )io->a == (unsigned long )((void *)0)) {
          {
#line 209
          __cil_tmp18 = VP8SetError(dec, (enum VP8StatusCode )3, "Could not decode alpha data.");
          }
#line 209
          return (__cil_tmp18);
        }
      }
    }
#line 213
    if (y_start < io->crop_top) {
#line 214
      delta_y = io->crop_top - y_start;
#line 215
      y_start = io->crop_top;
#line 217
      io->y += dec->cache_y_stride_ * delta_y;
#line 218
      io->u += dec->cache_uv_stride_ * (delta_y >> 1);
#line 219
      io->v += dec->cache_uv_stride_ * (delta_y >> 1);
#line 220
      if ((unsigned long )io->a != (unsigned long )((void *)0)) {
#line 221
        io->a += io->width * delta_y;
      }
    }
#line 224
    if (y_start < y_end) {
#line 225
      io->y += io->crop_left;
#line 226
      io->u += io->crop_left >> 1;
#line 227
      io->v += io->crop_left >> 1;
#line 228
      if ((unsigned long )io->a != (unsigned long )((void *)0)) {
#line 229
        io->a += io->crop_left;
      }
      {
#line 231
      io->mb_y = y_start - io->crop_top;
#line 232
      io->mb_w = io->crop_right - io->crop_left;
#line 233
      io->mb_h = y_end - y_start;
#line 234
      ok = (*(io->put))(io);
      }
    }
  }
#line 238
  if (ctx->id_ + 1 == dec->num_caches_) {
#line 239
    if (! last_row) {
      {
#line 240
      memcpy((void *)(dec->cache_y_ - ysize), (void const   *)(ydst + 16 * dec->cache_y_stride_),
             (unsigned long )ysize);
#line 241
      memcpy((void *)(dec->cache_u_ - uvsize), (void const   *)(udst + 8 * dec->cache_uv_stride_),
             (unsigned long )uvsize);
#line 242
      memcpy((void *)(dec->cache_v_ - uvsize), (void const   *)(vdst + 8 * dec->cache_uv_stride_),
             (unsigned long )uvsize);
      }
    }
  }
#line 246
  return (ok);
}
}
#line 253 "/root/patchweave_new/13/src/dec/frame.c"
int VP8ProcessRow(VP8Decoder *dec , VP8Io *io ) 
{ 
  int ok ;
  VP8ThreadContext *ctx ;
  WebPWorker *worker ;
  int __cil_tmp7 ;
  VP8FInfo *tmp___1 ;

  {
#line 254
  ok = 1;
#line 255
  ctx = & dec->thread_ctx_;
#line 256
  if (! dec->use_threads_) {
    {
#line 258
    ctx->mb_y_ = dec->mb_y_;
#line 259
    ctx->filter_row_ = dec->filter_row_;
#line 260
    ok = FinishRow(dec, io);
    }
  } else {
    {
#line 262
    worker = & dec->worker_;
#line 264
    __cil_tmp7 = WebPWorkerSync(worker);
#line 264
    ok &= __cil_tmp7;
    }
#line 266
    if (ok) {
#line 267
      ctx->io_ = *io;
#line 268
      ctx->id_ = dec->cache_id_;
#line 269
      ctx->mb_y_ = dec->mb_y_;
#line 270
      ctx->filter_row_ = dec->filter_row_;
#line 271
      if (ctx->filter_row_) {
#line 272
        tmp___1 = ctx->f_info_;
#line 273
        ctx->f_info_ = dec->f_info_;
#line 274
        dec->f_info_ = tmp___1;
      }
      {
#line 276
      WebPWorkerLaunch(worker);
#line 277
      (dec->cache_id_) ++;
      }
#line 277
      if (dec->cache_id_ == dec->num_caches_) {
#line 278
        dec->cache_id_ = 0;
      }
    }
  }
#line 282
  return (ok);
}
}
#line 288 "/root/patchweave_new/13/src/dec/frame.c"
enum VP8StatusCode VP8EnterCritical(VP8Decoder *dec , VP8Io *io ) 
{ 
  int __cil_tmp3 ;
  int extra_pixels ;

  {
  {
#line 291
  __cil_tmp3 = (*(io->setup))(io);
  }
#line 291
  if (io->setup) {
#line 291
    if (! __cil_tmp3) {
      {
#line 292
      VP8SetError(dec, (enum VP8StatusCode )6, "Frame setup failed\350}\210U");
      }
#line 293
      return (dec->status_);
    }
  }
#line 297
  if (io->bypass_filtering) {
#line 298
    dec->filter_type_ = 0;
  }
#line 314
  extra_pixels = (int )kFilterExtraRows[dec->filter_type_];
#line 315
  if (dec->filter_type_ == 2) {
#line 317
    dec->tl_mb_x_ = 0;
#line 318
    dec->tl_mb_y_ = 0;
  } else {
#line 324
    dec->tl_mb_x_ = (io->crop_left - extra_pixels) >> 4;
#line 325
    dec->tl_mb_y_ = (io->crop_top - extra_pixels) >> 4;
#line 326
    if (dec->tl_mb_x_ < 0) {
#line 326
      dec->tl_mb_x_ = 0;
    }
#line 327
    if (dec->tl_mb_y_ < 0) {
#line 327
      dec->tl_mb_y_ = 0;
    }
  }
#line 330
  dec->br_mb_y_ = ((io->crop_bottom + 15) + extra_pixels) >> 4;
#line 331
  dec->br_mb_x_ = ((io->crop_right + 15) + extra_pixels) >> 4;
#line 332
  if (dec->br_mb_x_ > dec->mb_w_) {
#line 333
    dec->br_mb_x_ = dec->mb_w_;
  }
#line 335
  if (dec->br_mb_y_ > dec->mb_h_) {
#line 336
    dec->br_mb_y_ = dec->mb_h_;
  }
  {
#line 339
  PrecomputeFilterStrengths(dec);
  }
#line 340
  return ((enum VP8StatusCode )0);
}
}
#line 343 "/root/patchweave_new/13/src/dec/frame.c"
int VP8ExitCritical(VP8Decoder *dec , VP8Io *io ) 
{ 
  int ok ;

  {
#line 344
  ok = 1;
#line 345
  if (dec->use_threads_) {
    {
#line 346
    ok = WebPWorkerSync(& dec->worker_);
    }
  }
#line 349
  if (io->teardown) {
    {
#line 350
    (*(io->teardown))(io);
    }
  }
#line 352
  return (ok);
}
}
#line 383 "/root/patchweave_new/13/src/dec/frame.c"
static int InitThreadContext(VP8Decoder *dec ) 
{ 
  WebPWorker *worker ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int tmp___0 ;

  {
#line 384
  dec->cache_id_ = 0;
#line 385
  if (dec->use_threads_) {
    {
#line 386
    worker = & dec->worker_;
#line 387
    __cil_tmp3 = WebPWorkerReset(worker);
    }
#line 387
    if (! __cil_tmp3) {
      {
#line 388
      __cil_tmp4 = VP8SetError(dec, (enum VP8StatusCode )1, "thread initialization failed.U");
      }
#line 388
      return (__cil_tmp4);
    }
#line 391
    worker->data1 = (void *)dec;
#line 392
    worker->data2 = (void *)(& dec->thread_ctx_.io_);
#line 393
    worker->hook = (int (*)(void * , void * ))(& FinishRow);
#line 394
    if (dec->filter_type_ > 0) {
#line 394
      tmp___0 = 3;
    } else {
#line 394
      tmp___0 = 2;
    }
#line 394
    dec->num_caches_ = tmp___0;
  } else {
#line 397
    dec->num_caches_ = 1;
  }
#line 399
  return (1);
}
}
#line 408 "/root/patchweave_new/13/src/dec/frame.c"
static int AllocateMemory(VP8Decoder *dec ) 
{ 
  int num_caches ;
  int mb_w ;
  size_t intra_pred_mode_size ;
  size_t top_size ;
  size_t mb_info_size ;
  size_t f_info_size ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  size_t yuv_size ;
  size_t coeffs_size ;
  size_t cache_height ;
  size_t cache_size ;
  uint64_t alpha_size ;
  unsigned long long tmp___2 ;
  uint64_t needed ;
  uint8_t *mem ;
  int __cil_tmp19 ;
  VP8FInfo *tmp___3 ;
  int extra_rows ;
  int extra_y ;
  int extra_uv ;
  uint8_t *tmp___5 ;

  {
#line 409
  num_caches = dec->num_caches_;
#line 410
  mb_w = dec->mb_w_;
#line 412
  intra_pred_mode_size = (unsigned long )(4 * mb_w) * sizeof(uint8_t );
#line 413
  top_size = (size_t )(32 * mb_w);
#line 414
  mb_info_size = (unsigned long )(mb_w + 1) * sizeof(VP8MB );
#line 415
  if (dec->filter_type_ > 0) {
#line 415
    if (dec->use_threads_) {
#line 415
      tmp___0 = 2;
    } else {
#line 415
      tmp___0 = 1;
    }
#line 415
    tmp___1 = (unsigned long )(mb_w * tmp___0) * sizeof(VP8FInfo );
  } else {
#line 415
    tmp___1 = 0UL;
  }
#line 415
  f_info_size = tmp___1;
#line 419
  yuv_size = 832UL * sizeof(*(dec->yuv_b_));
#line 420
  coeffs_size = 384UL * sizeof(*(dec->coeffs_));
#line 421
  cache_height = (size_t )(((16 * num_caches + (int )kFilterExtraRows[dec->filter_type_]) * 3) / 2);
#line 423
  cache_size = top_size * cache_height;
#line 425
  if ((unsigned long )dec->alpha_data_ != (unsigned long )((void *)0)) {
#line 425
    tmp___2 = (unsigned long long )((uint64_t )dec->pic_hdr_.width_ * (unsigned long )dec->pic_hdr_.height_);
  } else {
#line 425
    tmp___2 = 0ULL;
  }
#line 425
  alpha_size = (uint64_t )tmp___2;
#line 427
  needed = (((((((intra_pred_mode_size + top_size) + mb_info_size) + f_info_size) + yuv_size) + coeffs_size) + cache_size) + alpha_size) + 31UL;
#line 433
  if (needed != needed) {
#line 433
    return (0);
  }
#line 434
  if (needed > dec->mem_size_) {
    {
#line 435
    free(dec->mem_);
#line 436
    dec->mem_size_ = (size_t )0;
#line 437
    dec->mem_ = WebPSafeMalloc(needed, sizeof(uint8_t ));
    }
#line 438
    if ((unsigned long )dec->mem_ == (unsigned long )((void *)0)) {
      {
#line 439
      __cil_tmp19 = VP8SetError(dec, (enum VP8StatusCode )1, "no memory during frame initialization.");
      }
#line 439
      return (__cil_tmp19);
    }
#line 443
    dec->mem_size_ = needed;
  }
#line 446
  mem = (uint8_t *)dec->mem_;
#line 447
  dec->intra_t_ = mem;
#line 448
  mem += intra_pred_mode_size;
#line 450
  dec->y_t_ = mem;
#line 451
  mem += 16 * mb_w;
#line 452
  dec->u_t_ = mem;
#line 453
  mem += 8 * mb_w;
#line 454
  dec->v_t_ = mem;
#line 455
  mem += 8 * mb_w;
#line 457
  dec->mb_info_ = (VP8MB *)mem + 1;
#line 458
  mem += mb_info_size;
#line 460
  if (f_info_size) {
#line 460
    tmp___3 = (VP8FInfo *)mem;
  } else {
#line 460
    tmp___3 = (VP8FInfo *)((void *)0);
  }
#line 460
  dec->f_info_ = tmp___3;
#line 461
  mem += f_info_size;
#line 462
  dec->thread_ctx_.id_ = 0;
#line 463
  dec->thread_ctx_.f_info_ = dec->f_info_;
#line 464
  if (dec->use_threads_) {
#line 468
    dec->thread_ctx_.f_info_ += mb_w;
  }
#line 471
  mem = (uint8_t *)((uintptr_t )(mem + 31) & 0xffffffffffffffe0UL);
#line 473
  dec->yuv_b_ = mem;
#line 474
  mem += yuv_size;
#line 476
  dec->coeffs_ = (int16_t *)mem;
#line 477
  mem += coeffs_size;
#line 479
  dec->cache_y_stride_ = 16 * mb_w;
#line 480
  dec->cache_uv_stride_ = 8 * mb_w;
#line 482
  extra_rows = (int )kFilterExtraRows[dec->filter_type_];
#line 483
  extra_y = extra_rows * dec->cache_y_stride_;
#line 484
  extra_uv = (extra_rows / 2) * dec->cache_uv_stride_;
#line 485
  dec->cache_y_ = mem + extra_y;
#line 486
  dec->cache_u_ = (dec->cache_y_ + (16 * num_caches) * dec->cache_y_stride_) + extra_uv;
#line 488
  dec->cache_v_ = (dec->cache_u_ + (8 * num_caches) * dec->cache_uv_stride_) + extra_uv;
#line 490
  dec->cache_id_ = 0;
#line 492
  mem += cache_size;
#line 495
  if (alpha_size) {
#line 495
    tmp___5 = mem;
  } else {
#line 495
    tmp___5 = (uint8_t *)((void *)0);
  }
  {
#line 495
  dec->alpha_plane_ = tmp___5;
#line 496
  mem += alpha_size;
#line 500
  memset((void *)(dec->mb_info_ - 1), 0, mb_info_size);
#line 503
  memset((void *)dec->intra_t_, 0, intra_pred_mode_size);
  }
#line 505
  return (1);
}
}
#line 508 "/root/patchweave_new/13/src/dec/frame.c"
static void InitIo(VP8Decoder *dec , VP8Io *io ) 
{ 


  {
#line 510
  io->mb_y = 0;
#line 511
  io->y = dec->cache_y_;
#line 512
  io->u = dec->cache_u_;
#line 513
  io->v = dec->cache_v_;
#line 514
  io->y_stride = dec->cache_y_stride_;
#line 515
  io->uv_stride = dec->cache_uv_stride_;
#line 516
  io->a = (uint8_t *)((void *)0);
#line 517
  return;
}
}
#line 519 "/root/patchweave_new/13/src/dec/frame.c"
int VP8InitFrame(VP8Decoder *dec , VP8Io *io ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 520
  __cil_tmp3 = InitThreadContext(dec);
  }
#line 520
  if (! __cil_tmp3) {
#line 520
    return (0);
  }
  {
#line 521
  __cil_tmp4 = AllocateMemory(dec);
  }
#line 521
  if (! __cil_tmp4) {
#line 521
    return (0);
  }
  {
#line 522
  InitIo(dec, io);
#line 523
  VP8DspInit();
  }
#line 524
  return (1);
}
}
#line 530 "/root/patchweave_new/13/src/dec/frame.c"
static int const   kScan[16]  = 
#line 530
  {      (int const   )0,      (int const   )4,      (int const   )8,      (int const   )12, 
        (int const   )128,      (int const   )132,      (int const   )136,      (int const   )140, 
        (int const   )256,      (int const   )260,      (int const   )264,      (int const   )268, 
        (int const   )384,      (int const   )388,      (int const   )392,      (int const   )396};
#line 537 "/root/patchweave_new/13/src/dec/frame.c"
__inline static int CheckMode(VP8Decoder *dec , int mode ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 538
  if (mode == 0) {
#line 539
    if (dec->mb_x_ == 0) {
#line 540
      if (dec->mb_y_ == 0) {
#line 540
        tmp___0 = 6;
      } else {
#line 540
        tmp___0 = 5;
      }
#line 540
      return (tmp___0);
    } else {
#line 542
      if (dec->mb_y_ == 0) {
#line 542
        tmp___1 = 4;
      } else {
#line 542
        tmp___1 = 0;
      }
#line 542
      return (tmp___1);
    }
  }
#line 545
  return (mode);
}
}
#line 548 "/root/patchweave_new/13/src/dec/frame.c"
__inline static void Copy32b(uint8_t *dst , uint8_t *src ) 
{ 


  {
#line 549
  *((uint32_t *)dst) = *((uint32_t *)src);
#line 550
  return;
}
}
#line 552 "/root/patchweave_new/13/src/dec/frame.c"
void VP8ReconstructBlock(VP8Decoder *dec ) 
{ 
  int j ;
  uint8_t *y_dst ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  uint8_t *top_y ;
  uint8_t *top_u ;
  uint8_t *top_v ;
  int16_t *coeffs ;
  int n ;
  uint32_t *top_right ;
  uint8_t *dst ;
  int pred_func ;
  int __cil_tmp15 ;
  uint8_t *dst___0 ;
  int pred_func___0 ;
  int __cil_tmp19 ;
  int16_t *u_coeffs ;
  int16_t *v_coeffs ;
  int y_offset ;
  int uv_offset ;
  uint8_t *y_out ;
  uint8_t *u_out ;
  uint8_t *v_out ;

  {
#line 554
  y_dst = dec->yuv_b_ + 40;
#line 555
  u_dst = dec->yuv_b_ + 584;
#line 556
  v_dst = dec->yuv_b_ + 600;
#line 560
  if (dec->mb_x_ > 0) {
#line 561
    j = -1;
    {
#line 561
    while (1) {
      while_continue: /* CIL Label */ ;

#line 561
      if (! (j < 16)) {
#line 561
        goto while_break;
      }
      {
#line 562
      Copy32b(y_dst + (j * 32 - 4), y_dst + (j * 32 + 12));
#line 561
      j ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: 
#line 564
    j = -1;
    {
#line 564
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 564
      if (! (j < 8)) {
#line 564
        goto while_break___0;
      }
      {
#line 565
      Copy32b(u_dst + (j * 32 - 4), u_dst + (j * 32 + 4));
#line 566
      Copy32b(v_dst + (j * 32 - 4), v_dst + (j * 32 + 4));
#line 564
      j ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: ;
  } else {
#line 569
    j = 0;
    {
#line 569
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 569
      if (! (j < 16)) {
#line 569
        goto while_break___1;
      }
#line 570
      *(y_dst + (j * 32 - 1)) = (uint8_t )129;
#line 569
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___1: 
#line 572
    j = 0;
    {
#line 572
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 572
      if (! (j < 8)) {
#line 572
        goto while_break___2;
      }
#line 573
      *(u_dst + (j * 32 - 1)) = (uint8_t )129;
#line 574
      *(v_dst + (j * 32 - 1)) = (uint8_t )129;
#line 572
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: ;
#line 577
    if (dec->mb_y_ > 0) {
#line 578
      *(v_dst + -33) = (uint8_t )129;
#line 578
      *(u_dst + -33) = *(v_dst + -33);
#line 578
      *(y_dst + -33) = *(u_dst + -33);
    }
  }
#line 583
  top_y = dec->y_t_ + dec->mb_x_ * 16;
#line 584
  top_u = dec->u_t_ + dec->mb_x_ * 8;
#line 585
  top_v = dec->v_t_ + dec->mb_x_ * 8;
#line 586
  coeffs = dec->coeffs_;
#line 589
  if (dec->mb_y_ > 0) {
    {
#line 590
    memcpy((void *)(y_dst - 32), (void const   *)top_y, 16UL);
#line 591
    memcpy((void *)(u_dst - 32), (void const   *)top_u, 8UL);
#line 592
    memcpy((void *)(v_dst - 32), (void const   *)top_v, 8UL);
    }
  } else
#line 593
  if (dec->mb_x_ == 0) {
    {
#line 596
    memset((void *)((y_dst - 32) - 1), 127, 21UL);
#line 597
    memset((void *)((u_dst - 32) - 1), 127, 9UL);
#line 598
    memset((void *)((v_dst - 32) - 1), 127, 9UL);
    }
  }
#line 603
  if (dec->is_i4x4_) {
#line 604
    top_right = (uint32_t *)((y_dst - 32) + 16);
#line 606
    if (dec->mb_y_ > 0) {
#line 607
      if (dec->mb_x_ >= dec->mb_w_ - 1) {
#line 608
        *(top_right + 0) = (unsigned int )*(top_y + 15) * 16843009U;
      } else {
        {
#line 610
        memcpy((void *)top_right, (void const   *)(top_y + 16), sizeof(*top_right));
        }
      }
    }
#line 614
    *(top_right + 96) = *(top_right + 0);
#line 614
    *(top_right + 64) = *(top_right + 96);
#line 614
    *(top_right + 32) = *(top_right + 64);
#line 617
    n = 0;
    {
#line 617
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 617
      if (! (n < 16)) {
#line 617
        goto while_break___3;
      }
      {
#line 618
      dst = y_dst + kScan[n];
#line 619
      (*(VP8PredLuma4[dec->imodes_[n]]))(dst);
      }
#line 620
      if (dec->non_zero_ac_ & (unsigned int )(1 << n)) {
        {
#line 621
        (*VP8Transform)(coeffs + n * 16, dst, 0);
        }
      } else
#line 622
      if (dec->non_zero_ & (unsigned int )(1 << n)) {
        {
#line 623
        (*VP8TransformDC)(coeffs + n * 16, dst);
        }
      }
#line 617
      n ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: ;
  } else {
    {
#line 627
    __cil_tmp15 = CheckMode(dec, (int )dec->imodes_[0]);
#line 627
    pred_func = __cil_tmp15;
#line 628
    (*(VP8PredLuma16[pred_func]))(y_dst);
    }
#line 629
    if (dec->non_zero_) {
#line 630
      n = 0;
      {
#line 630
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 630
        if (! (n < 16)) {
#line 630
          goto while_break___4;
        }
#line 631
        dst___0 = y_dst + kScan[n];
#line 632
        if (dec->non_zero_ac_ & (unsigned int )(1 << n)) {
          {
#line 633
          (*VP8Transform)(coeffs + n * 16, dst___0, 0);
          }
        } else
#line 634
        if (dec->non_zero_ & (unsigned int )(1 << n)) {
          {
#line 635
          (*VP8TransformDC)(coeffs + n * 16, dst___0);
          }
        }
#line 630
        n ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: ;
    }
  }
  {
#line 642
  __cil_tmp19 = CheckMode(dec, (int )dec->uvmode_);
#line 642
  pred_func___0 = __cil_tmp19;
#line 643
  (*(VP8PredChroma8[pred_func___0]))(u_dst);
#line 644
  (*(VP8PredChroma8[pred_func___0]))(v_dst);
  }
#line 646
  if (dec->non_zero_ & 983040U) {
#line 647
    u_coeffs = dec->coeffs_ + 256;
#line 648
    if (dec->non_zero_ac_ & 983040U) {
      {
#line 649
      (*VP8TransformUV)(u_coeffs, u_dst);
      }
    } else {
      {
#line 651
      (*VP8TransformDCUV)(u_coeffs, u_dst);
      }
    }
  }
#line 654
  if (dec->non_zero_ & 15728640U) {
#line 655
    v_coeffs = dec->coeffs_ + 320;
#line 656
    if (dec->non_zero_ac_ & 15728640U) {
      {
#line 657
      (*VP8TransformUV)(v_coeffs, v_dst);
      }
    } else {
      {
#line 659
      (*VP8TransformDCUV)(v_coeffs, v_dst);
      }
    }
  }
#line 664
  if (dec->mb_y_ < dec->mb_h_ - 1) {
    {
#line 665
    memcpy((void *)top_y, (void const   *)(y_dst + 480), 16UL);
#line 666
    memcpy((void *)top_u, (void const   *)(u_dst + 224), 8UL);
#line 667
    memcpy((void *)top_v, (void const   *)(v_dst + 224), 8UL);
    }
  }
#line 673
  y_offset = (dec->cache_id_ * 16) * dec->cache_y_stride_;
#line 674
  uv_offset = (dec->cache_id_ * 8) * dec->cache_uv_stride_;
#line 675
  y_out = (dec->cache_y_ + dec->mb_x_ * 16) + y_offset;
#line 676
  u_out = (dec->cache_u_ + dec->mb_x_ * 8) + uv_offset;
#line 677
  v_out = (dec->cache_v_ + dec->mb_x_ * 8) + uv_offset;
#line 678
  j = 0;
  {
#line 678
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 678
    if (! (j < 16)) {
#line 678
      goto while_break___5;
    }
    {
#line 679
    memcpy((void *)(y_out + j * dec->cache_y_stride_), (void const   *)(y_dst + j * 32),
           16UL);
#line 678
    j ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: 
#line 681
  j = 0;
  {
#line 681
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 681
    if (! (j < 8)) {
#line 681
      goto while_break___6;
    }
    {
#line 682
    memcpy((void *)(u_out + j * dec->cache_uv_stride_), (void const   *)(u_dst + j * 32),
           8UL);
#line 683
    memcpy((void *)(v_out + j * dec->cache_uv_stride_), (void const   *)(v_dst + j * 32),
           8UL);
#line 681
    j ++;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___6: ;
#line 685
  return;
}
}
#line 26 "/root/patchweave_new/13/src/dec/buffer.c"
static int const   kModeBpp[13]  = 
#line 26 "/root/patchweave_new/13/src/dec/buffer.c"
  {      (int const   )3,      (int const   )4,      (int const   )3,      (int const   )4, 
        (int const   )4,      (int const   )2,      (int const   )2,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )2,      (int const   )1, 
        (int const   )1};
#line 34 "/root/patchweave_new/13/src/dec/buffer.c"
static int IsValidColorspace(int webp_csp_mode ) 
{ 
  int tmp___0 ;

  {
#line 35
  if (webp_csp_mode >= 0) {
#line 35
    if (webp_csp_mode < 13) {
#line 35
      tmp___0 = 1;
    } else {
#line 35
      tmp___0 = 0;
    }
  } else {
#line 35
    tmp___0 = 0;
  }
#line 35
  return (tmp___0);
}
}
#line 38 "/root/patchweave_new/13/src/dec/buffer.c"
static enum VP8StatusCode CheckDecBuffer(WebPDecBuffer *buffer ) 
{ 
  int ok ;
  enum WEBP_CSP_MODE mode ;
  int width ;
  int height ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  WebPYUVABuffer *buf ;
  uint64_t y_size ;
  uint64_t u_size ;
  uint64_t v_size ;
  uint64_t a_size ;
  WebPRGBABuffer *buf___0 ;
  uint64_t size ;
  int tmp___0 ;

  {
  {
#line 39
  ok = 1;
#line 40
  mode = (enum WEBP_CSP_MODE )buffer->colorspace;
#line 41
  width = buffer->width;
#line 42
  height = buffer->height;
#line 43
  __cil_tmp6 = IsValidColorspace((int )mode);
  }
#line 43
  if (! __cil_tmp6) {
#line 44
    ok = 0;
  } else {
    {
#line 45
    __cil_tmp7 = WebPIsRGBMode___0(mode);
    }
#line 45
    if (! __cil_tmp7) {
#line 46
      buf = & buffer->u.YUVA;
#line 47
      y_size = (uint64_t )buf->y_stride * (unsigned long )height;
#line 48
      u_size = (uint64_t )buf->u_stride * (unsigned long )((height + 1) / 2);
#line 49
      v_size = (uint64_t )buf->v_stride * (unsigned long )((height + 1) / 2);
#line 50
      a_size = (uint64_t )buf->a_stride * (unsigned long )height;
#line 51
      ok &= y_size <= buf->y_size;
#line 52
      ok &= u_size <= buf->u_size;
#line 53
      ok &= v_size <= buf->v_size;
#line 54
      ok &= buf->y_stride >= width;
#line 55
      ok &= buf->u_stride >= (width + 1) / 2;
#line 56
      ok &= buf->v_stride >= (width + 1) / 2;
#line 57
      ok &= (unsigned long )buf->y != (unsigned long )((void *)0);
#line 58
      ok &= (unsigned long )buf->u != (unsigned long )((void *)0);
#line 59
      ok &= (unsigned long )buf->v != (unsigned long )((void *)0);
#line 60
      if ((unsigned int )mode == 12U) {
#line 61
        ok &= buf->a_stride >= width;
#line 62
        ok &= a_size <= buf->a_size;
#line 63
        ok &= (unsigned long )buf->a != (unsigned long )((void *)0);
      }
    } else {
#line 66
      buf___0 = & buffer->u.RGBA;
#line 67
      size = (uint64_t )buf___0->stride * (unsigned long )height;
#line 68
      ok &= size <= buf___0->size;
#line 69
      ok &= buf___0->stride >= width * (int )kModeBpp[mode];
#line 70
      ok &= (unsigned long )buf___0->rgba != (unsigned long )((void *)0);
    }
  }
#line 72
  if (ok) {
#line 72
    tmp___0 = 0;
  } else {
#line 72
    tmp___0 = 2;
  }
#line 72
  return ((enum VP8StatusCode )tmp___0);
}
}
#line 75 "/root/patchweave_new/13/src/dec/buffer.c"
static enum VP8StatusCode AllocateBuffer(WebPDecBuffer *buffer ) 
{ 
  int w ;
  int h ;
  enum WEBP_CSP_MODE mode ;
  int __cil_tmp5 ;
  uint8_t *output ;
  int uv_stride ;
  int a_stride ;
  uint64_t uv_size ;
  uint64_t a_size ;
  uint64_t total_size ;
  int stride ;
  uint64_t size ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  WebPYUVABuffer *buf ;
  WebPRGBABuffer *buf___0 ;
  enum VP8StatusCode __cil_tmp19 ;

  {
  {
#line 76
  w = buffer->width;
#line 77
  h = buffer->height;
#line 78
  mode = (enum WEBP_CSP_MODE )buffer->colorspace;
#line 80
  __cil_tmp5 = IsValidColorspace((int )mode);
  }
#line 80
  if (w <= 0) {
#line 81
    return ((enum VP8StatusCode )2);
  } else
#line 80
  if (h <= 0) {
#line 81
    return ((enum VP8StatusCode )2);
  } else
#line 80
  if (! __cil_tmp5) {
#line 81
    return ((enum VP8StatusCode )2);
  }
#line 84
  if ((unsigned long )buffer->private_memory == (unsigned long )((void *)0)) {
#line 84
    if (! buffer->is_external_memory) {
      {
#line 86
      uv_stride = 0;
#line 86
      a_stride = 0;
#line 87
      uv_size = (uint64_t )0;
#line 87
      a_size = (uint64_t )0;
#line 90
      stride = w * (int )kModeBpp[mode];
#line 91
      size = (uint64_t )stride * (unsigned long )h;
#line 93
      __cil_tmp14 = WebPIsRGBMode___0(mode);
      }
#line 93
      if (! __cil_tmp14) {
#line 94
        uv_stride = (w + 1) / 2;
#line 95
        uv_size = (uint64_t )uv_stride * (unsigned long )((h + 1) / 2);
#line 96
        if ((unsigned int )mode == 12U) {
#line 97
          a_stride = w;
#line 98
          a_size = (uint64_t )a_stride * (unsigned long )h;
        }
      }
      {
#line 101
      total_size = (size + 2UL * uv_size) + a_size;
#line 104
      __cil_tmp15 = WebPSafeMalloc(total_size, sizeof(*output));
#line 104
      output = (uint8_t *)__cil_tmp15;
      }
#line 105
      if ((unsigned long )output == (unsigned long )((void *)0)) {
#line 106
        return ((enum VP8StatusCode )1);
      }
      {
#line 108
      buffer->private_memory = output;
#line 110
      __cil_tmp16 = WebPIsRGBMode___0(mode);
      }
#line 110
      if (! __cil_tmp16) {
#line 111
        buf = & buffer->u.YUVA;
#line 112
        buf->y = output;
#line 113
        buf->y_stride = stride;
#line 114
        buf->y_size = size;
#line 115
        buf->u = output + size;
#line 116
        buf->u_stride = uv_stride;
#line 117
        buf->u_size = uv_size;
#line 118
        buf->v = (output + size) + uv_size;
#line 119
        buf->v_stride = uv_stride;
#line 120
        buf->v_size = uv_size;
#line 121
        if ((unsigned int )mode == 12U) {
#line 122
          buf->a = (output + size) + 2UL * uv_size;
        }
#line 124
        buf->a_size = a_size;
#line 125
        buf->a_stride = a_stride;
      } else {
#line 127
        buf___0 = & buffer->u.RGBA;
#line 128
        buf___0->rgba = output;
#line 129
        buf___0->stride = stride;
#line 130
        buf___0->size = size;
      }
    }
  }
  {
#line 133
  __cil_tmp19 = CheckDecBuffer(buffer);
  }
#line 133
  return (__cil_tmp19);
}
}
#line 136 "/root/patchweave_new/13/src/dec/buffer.c"
enum VP8StatusCode WebPAllocateDecBuffer(int w , int h , WebPDecoderOptions *options ,
                                         WebPDecBuffer *out ) 
{ 
  int cw ;
  int ch ;
  int x ;
  int y ;
  enum VP8StatusCode __cil_tmp9 ;

  {
#line 139
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 140
    return ((enum VP8StatusCode )2);
  } else
#line 139
  if (w <= 0) {
#line 140
    return ((enum VP8StatusCode )2);
  } else
#line 139
  if (h <= 0) {
#line 140
    return ((enum VP8StatusCode )2);
  }
#line 142
  if ((unsigned long )options != (unsigned long )((void *)0)) {
#line 143
    if (options->use_cropping) {
#line 144
      cw = options->crop_width;
#line 145
      ch = options->crop_height;
#line 146
      x = options->crop_left & -2;
#line 147
      y = options->crop_top & -2;
#line 148
      if (x < 0) {
#line 149
        return ((enum VP8StatusCode )2);
      } else
#line 148
      if (y < 0) {
#line 149
        return ((enum VP8StatusCode )2);
      } else
#line 148
      if (cw <= 0) {
#line 149
        return ((enum VP8StatusCode )2);
      } else
#line 148
      if (ch <= 0) {
#line 149
        return ((enum VP8StatusCode )2);
      } else
#line 148
      if (x + cw > w) {
#line 149
        return ((enum VP8StatusCode )2);
      } else
#line 148
      if (y + ch > h) {
#line 149
        return ((enum VP8StatusCode )2);
      }
#line 151
      w = cw;
#line 152
      h = ch;
    }
#line 154
    if (options->use_scaling) {
#line 155
      if (options->scaled_width <= 0) {
#line 156
        return ((enum VP8StatusCode )2);
      } else
#line 155
      if (options->scaled_height <= 0) {
#line 156
        return ((enum VP8StatusCode )2);
      }
#line 158
      w = options->scaled_width;
#line 159
      h = options->scaled_height;
    }
  }
  {
#line 162
  out->width = w;
#line 163
  out->height = h;
#line 166
  __cil_tmp9 = AllocateBuffer(out);
  }
#line 166
  return (__cil_tmp9);
}
}
#line 172 "/root/patchweave_new/13/src/dec/buffer.c"
int WebPInitDecBufferInternal(WebPDecBuffer *buffer , int version ) 
{ 


  {
#line 173
  if (version >> 8 != 513 >> 8) {
#line 174
    return (0);
  }
#line 176
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 176
    return (0);
  }
  {
#line 177
  memset((void *)buffer, 0, sizeof(*buffer));
  }
#line 178
  return (1);
}
}
#line 181 "/root/patchweave_new/13/src/dec/buffer.c"
void WebPFreeDecBuffer(WebPDecBuffer *buffer ) 
{ 


  {
#line 182
  if ((unsigned long )buffer != (unsigned long )((void *)0)) {
#line 183
    if (! buffer->is_external_memory) {
      {
#line 184
      free((void *)buffer->private_memory);
      }
    }
#line 185
    buffer->private_memory = (uint8_t *)((void *)0);
  }
#line 187
  return;
}
}
#line 189 "/root/patchweave_new/13/src/dec/buffer.c"
void WebPCopyDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) 
{ 


  {
#line 191
  if ((unsigned long )src != (unsigned long )((void *)0)) {
#line 191
    if ((unsigned long )dst != (unsigned long )((void *)0)) {
#line 192
      *dst = *src;
#line 193
      if ((unsigned long )src->private_memory != (unsigned long )((void *)0)) {
#line 194
        dst->is_external_memory = 1;
#line 195
        dst->private_memory = (uint8_t *)((void *)0);
      }
    }
  }
#line 199
  return;
}
}
#line 201 "/root/patchweave_new/13/src/dec/buffer.c"
void WebPGrabDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) 
{ 


  {
#line 202
  if ((unsigned long )src != (unsigned long )((void *)0)) {
#line 202
    if ((unsigned long )dst != (unsigned long )((void *)0)) {
#line 203
      *dst = *src;
#line 204
      if ((unsigned long )src->private_memory != (unsigned long )((void *)0)) {
#line 205
        src->is_external_memory = 1;
#line 206
        src->private_memory = (uint8_t *)((void *)0);
      }
    }
  }
#line 210
  return;
}
}
#line 24 "/root/patchweave_new/13/src/dec/alpha.c"
static void CopyPlane___1(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                          int width , int height ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    __cil_tmp7 = height;
#line 26
    height --;
#line 26
    if (! (__cil_tmp7 > 0)) {
#line 26
      goto while_break;
    }
    {
#line 27
    memcpy((void *)dst, (void const   *)src, (unsigned long )width);
#line 28
    src += src_stride;
#line 29
    dst += dst_stride;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 34
  return;
}
}
#line 43 "/root/patchweave_new/13/src/dec/alpha.c"
static int DecodeAlpha(uint8_t *data , size_t data_size , int width , int height ,
                       int stride , uint8_t *output ) 
{ 
  uint8_t *decoded_data ;
  size_t decoded_size ;
  WEBP_FILTER_TYPE filter ;
  int pre_processing ;
  int rsrv ;
  int ok ;
  int method ;
  void *__cil_tmp16 ;
  void (*unfilter_func)(int  , int  , int  , uint8_t * ) ;

  {
#line 45
  decoded_data = (uint8_t *)((void *)0);
#line 46
  decoded_size = (size_t )(height * width);
#line 50
  ok = 0;
#line 56
  if (data_size <= 1UL) {
#line 57
    return (0);
  }
#line 60
  method = (int )*(data + 0) & 3;
#line 61
  filter = (WEBP_FILTER_TYPE )(((int )*(data + 0) >> 2) & 3);
#line 62
  pre_processing = ((int )*(data + 0) >> 4) & 3;
#line 63
  rsrv = ((int )*(data + 0) >> 6) & 3;
#line 64
  if (method < 0) {
#line 69
    return (0);
  } else
#line 64
  if (method > 1) {
#line 69
    return (0);
  } else
#line 64
  if ((unsigned int )filter >= 4U) {
#line 69
    return (0);
  } else
#line 64
  if (pre_processing > 1) {
#line 69
    return (0);
  } else
#line 64
  if (rsrv != 0) {
#line 69
    return (0);
  }
#line 72
  if (method == 0) {
#line 73
    ok = data_size >= decoded_size;
#line 74
    decoded_data = data + 1;
  } else {
    {
#line 76
    __cil_tmp16 = malloc(decoded_size);
#line 76
    decoded_data = (uint8_t *)__cil_tmp16;
    }
#line 77
    if ((unsigned long )decoded_data == (unsigned long )((void *)0)) {
#line 77
      return (0);
    }
    {
#line 78
    ok = VP8LDecodeAlphaImageStream(width, height, data + 1, data_size - 1UL, decoded_data);
    }
  }
#line 84
  if (ok) {
#line 85
    unfilter_func = WebPUnfilters[filter];
#line 86
    if ((unsigned long )unfilter_func != (unsigned long )((void *)0)) {
      {
#line 89
      (*unfilter_func)(width, height, width, decoded_data);
      }
    }
    {
#line 92
    CopyPlane___1(decoded_data, width, output, stride, width, height);
    }
#line 93
    if (pre_processing == 1) {
      {
#line 94
      ok = DequantizeLevels(decoded_data, width, height);
      }
    }
  }
#line 98
  if (method != 0) {
    {
#line 99
    free((void *)decoded_data);
    }
  }
#line 101
  return (ok);
}
}
#line 106 "/root/patchweave_new/13/src/dec/alpha.c"
uint8_t *VP8DecompressAlphaRows(VP8Decoder *dec , int row , int num_rows ) 
{ 
  int stride ;
  int __cil_tmp6 ;

  {
#line 108
  stride = (int )dec->pic_hdr_.width_;
#line 110
  if (row < 0) {
#line 111
    return ((uint8_t *)((void *)0));
  } else
#line 110
  if (num_rows < 0) {
#line 111
    return ((uint8_t *)((void *)0));
  } else
#line 110
  if (row + num_rows > (int )dec->pic_hdr_.height_) {
#line 111
    return ((uint8_t *)((void *)0));
  }
#line 114
  if (row == 0) {
    {
#line 117
    __cil_tmp6 = DecodeAlpha(dec->alpha_data_, dec->alpha_data_size_, (int )dec->pic_hdr_.width_,
                             (int )dec->pic_hdr_.height_, stride, dec->alpha_plane_);
    }
#line 117
    if (! __cil_tmp6) {
#line 120
      return ((uint8_t *)((void *)0));
    }
#line 122
    dec->is_alpha_decoded_ = 1;
  }
#line 126
  return (dec->alpha_plane_ + row * stride);
}
}
#line 24 "/root/patchweave_new/13/examples/./wicdec.h"
int ReadPictureWithWIC(char const   *filename , struct WebPPicture *pic , int keep_alpha ,
                       struct Metadata *metadata ) ;
#line 332 "/root/patchweave_new/13/examples/wicdec.c"
int ReadPictureWithWIC(char const   *filename , struct WebPPicture *pic , int keep_alpha ,
                       struct Metadata *metadata ) 
{ 


  {
  {
#line 339
  fprintf(stderr, "Windows Imaging Component (WIC) support not compiled. Visual Studio and mingw-w64 builds support WIC. Make sure wincodec.h detection is working correctly if using autoconf and HAVE_WINCODEC_H is defined before building.\n\220");
  }
#line 343
  return (0);
}
}
#line 24 "/root/patchweave_new/13/examples/./tiffdec.h"
int ReadTIFF(char const   *filename , WebPPicture *pic , int keep_alpha , Metadata *metadata ) ;
#line 293 "/usr/include/x86_64-linux-gnu/tiffio.h"
extern void *_TIFFmalloc(tmsize_t s ) ;
#line 299
extern void _TIFFfree(void *p ) ;
#line 343
extern void TIFFClose(TIFF *tif ) ;
#line 346
extern int TIFFGetField(TIFF *tif , uint32 tag  , ...) ;
#line 391
extern uint16 TIFFNumberOfDirectories(TIFF * ) ;
#line 429
extern int TIFFReadRGBAImageOriented(TIFF * , uint32  , uint32  , uint32 * , int  ,
                                     int  ) ;
#line 440
extern TIFF *TIFFOpen(char const   * , char const   * ) ;
#line 33 "/root/patchweave_new/13/examples/./metadata.h"
void MetadataInit(Metadata *metadata ) ;
#line 34
void MetadataPayloadDelete(MetadataPayload *payload ) ;
#line 35
void MetadataFree(Metadata *metadata ) ;
#line 38
int MetadataCopy(char const   *metadata , size_t metadata_len , MetadataPayload *payload ) ;
#line 27 "/root/patchweave_new/13/examples/tiffdec.c"
static struct __anonstruct_1014 kTIFFMetadataMap[3]  = {      {(ttag_t )34675, (size_t )0}, 
        {(ttag_t )700, (size_t )0}, 
        {(ttag_t )0, (size_t )0}};
#line 35 "/root/patchweave_new/13/examples/tiffdec.c"
static int ExtractMetadataFromTIFF(TIFF *tif , Metadata *metadata ) 
{ 
  int i ;
  toff_t exif_ifd_offset ;
  MetadataPayload *payload ;
  void *tag_data ;
  uint32 tag_data_len ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 39
  i = 0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;

#line 39
    if (! (kTIFFMetadataMap[i].tag != 0U)) {
#line 39
      goto while_break;
    }
    {
#line 40
    payload = (MetadataPayload *)((uint8_t *)metadata + kTIFFMetadataMap[i].storage_offset);
#line 46
    __cil_tmp9 = MetadataCopy((char const   *)tag_data, (size_t )tag_data_len, payload);
#line 46
    __cil_tmp8 = TIFFGetField(tif, kTIFFMetadataMap[i].tag, & tag_data_len, & tag_data);
    }
#line 46
    if (__cil_tmp8) {
#line 46
      if (! __cil_tmp9) {
#line 48
        return (0);
      }
    }
#line 39
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 58
  __cil_tmp10 = TIFFGetField(tif, (uint32 )34665, & exif_ifd_offset);
  }
#line 58
  if (__cil_tmp10) {
    {
#line 59
    fprintf(stderr, "Warning: EXIF extraction from TIFF is unsupported.\n");
    }
  }
#line 61
  return (1);
}
}
#line 64 "/root/patchweave_new/13/examples/tiffdec.c"
int ReadTIFF(char const   *filename , WebPPicture *pic , int keep_alpha , Metadata *metadata ) 
{ 
  TIFF *tif ;
  TIFF *__cil_tmp6 ;
  uint32 width ;
  uint32 height ;
  uint32 *raster ;
  int ok ;
  tdir_t dircount ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  int stride ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp___0 ;

  {
  {
#line 67
  __cil_tmp6 = TIFFOpen(filename, "r");
#line 67
  tif = __cil_tmp6;
#line 70
  ok = 0;
  }
#line 73
  if ((unsigned long )tif == (unsigned long )((void *)0)) {
    {
#line 74
    fprintf(stderr, "Error! Cannot open TIFF file \'%s\'\n0~\210U", filename);
    }
#line 75
    return (0);
  }
  {
#line 78
  dircount = TIFFNumberOfDirectories(tif);
  }
#line 79
  if ((int )dircount > 1) {
    {
#line 80
    fprintf(stderr, "Warning: multi-directory TIFF files are not supported.\nOnly the first will be used, %d will be ignored.\n",
            (int )dircount - 1);
    }
  }
  {
#line 85
  __cil_tmp14 = TIFFGetField(tif, (uint32 )257, & height);
#line 85
  __cil_tmp13 = TIFFGetField(tif, (uint32 )256, & width);
  }
#line 85
  if (__cil_tmp13) {
#line 85
    if (! __cil_tmp14) {
      {
#line 87
      fprintf(stderr, "Error! Cannot retrieve TIFF image dimensions.\n");
      }
#line 88
      return (0);
    }
  } else {
    {
#line 87
    fprintf(stderr, "Error! Cannot retrieve TIFF image dimensions.\n");
    }
#line 88
    return (0);
  }
  {
#line 90
  __cil_tmp15 = _TIFFmalloc((tmsize_t )((unsigned long )(width * height) * sizeof(*raster)));
#line 90
  raster = (uint32 *)__cil_tmp15;
  }
#line 91
  if ((unsigned long )raster != (unsigned long )((void *)0)) {
    {
#line 92
    __cil_tmp16 = TIFFReadRGBAImageOriented(tif, width, height, raster, 1, 1);
    }
#line 92
    if (__cil_tmp16) {
#line 94
      stride = (int )((unsigned long )width * sizeof(*raster));
#line 95
      pic->width = (int )width;
#line 96
      pic->height = (int )height;
#line 101
      pic->use_argb = 1;
#line 102
      if (keep_alpha) {
        {
#line 102
        __cil_tmp18 = WebPPictureImportRGBA(pic, (uint8_t *)raster, stride);
#line 102
        tmp___0 = __cil_tmp18;
        }
      } else {
        {
#line 102
        __cil_tmp19 = WebPPictureImportRGBX(pic, (uint8_t *)raster, stride);
#line 102
        tmp___0 = __cil_tmp19;
        }
      }
#line 102
      ok = tmp___0;
    }
    {
#line 106
    _TIFFfree((void *)raster);
    }
  } else {
    {
#line 108
    fprintf(stderr, "Error allocating TIFF RGBA memory!\n");
    }
  }
#line 111
  if (ok) {
#line 112
    if ((unsigned long )metadata != (unsigned long )((void *)0)) {
      {
#line 113
      ok = ExtractMetadataFromTIFF(tif, metadata);
      }
#line 114
      if (! ok) {
        {
#line 115
        fprintf(stderr, "Error extracting TIFF metadata!\n\220");
#line 116
        MetadataFree(metadata);
#line 117
        WebPPictureFree(pic);
        }
      }
    }
  }
  {
#line 122
  TIFFClose(tif);
  }
#line 123
  return (ok);
}
}
#line 26 "/root/patchweave_new/13/examples/./pngdec.h"
int ReadPNG(FILE *in_file , WebPPicture *pic , int keep_alpha , Metadata *metadata ) ;
#line 58 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 67
extern  __attribute__((__nothrow__)) void longjmp(struct __jmp_buf_tag *__env , int __val ) ;
#line 945 "/usr/include/libpng16/png.h"
extern png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                          void (*error_fn)(png_structp  , png_const_charp  ) ,
                                          void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 973
extern jmp_buf *png_set_longjmp_fn(png_structrp png_ptr , void (*longjmp_fn)(struct __jmp_buf_tag * ,
                                                                             int  ) ,
                                   size_t jmp_buf_size ) ;
#line 1027
extern png_infop png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1045
extern void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1075
extern void png_set_expand_gray_1_2_4_to_8(png_structrp png_ptr ) ;
#line 1076
extern void png_set_palette_to_rgb(png_structrp png_ptr ) ;
#line 1077
extern void png_set_tRNS_to_alpha(png_structrp png_ptr ) ;
#line 1094
extern void png_set_gray_to_rgb(png_structrp png_ptr ) ;
#line 1253
extern void png_set_strip_alpha(png_structrp png_ptr ) ;
#line 1285
extern void png_set_packing(png_structrp png_ptr ) ;
#line 1308
extern int png_set_interlace_handling(png_structrp png_ptr ) ;
#line 1344
extern void png_set_strip_16(png_structrp png_ptr ) ;
#line 1390
extern void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1395
extern void png_read_rows(png_structrp png_ptr , png_bytepp row , png_bytepp display_row ,
                          png_uint_32 num_rows ) ;
#line 1431
extern void png_read_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1439
extern void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                                    png_infopp end_info_ptr_ptr ) ;
#line 1583
extern void png_init_io(png_structrp png_ptr , png_FILE_p fp ) ;
#line 1594
extern void png_set_error_fn(png_structrp png_ptr , png_voidp error_ptr , void (*error_fn)(png_structp  ,
                                                                                           png_const_charp  ) ,
                             void (*warning_fn)(png_structp  , png_const_charp  ) ) ;
#line 1861
extern png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                 png_uint_32 flag ) ;
#line 2038
extern png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                                int *color_type , int *interlace_method , int *compression_method ,
                                int *filter_method ) ;
#line 2113
extern png_uint_32 png_get_iCCP(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_charpp name , int *compression_type , png_bytepp profile ,
                                png_uint_32 *proflen ) ;
#line 2136
extern int png_get_text(png_const_structrp png_ptr , png_inforp info_ptr , png_textp *text_ptr ,
                        int *num_text ) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                                                char *__resolved ) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__gnu_inline__)) realpath)(char const   *__name ,
                                                                  char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size((void *)__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp4 = __builtin_object_size((void *)__resolved, 1);
    }
#line 42
    if (__cil_tmp4 < 4096UL) {
      {
#line 43
      __cil_tmp5 = __builtin_object_size((void *)__resolved, 1);
#line 43
      __cil_tmp6 = __realpath_chk_warn(__name, __resolved, __cil_tmp5);
      }
#line 43
      return (__cil_tmp6);
    }
    {
#line 45
    __cil_tmp7 = __builtin_object_size((void *)__resolved, 1);
#line 45
    __cil_tmp8 = __realpath_chk(__name, __resolved, __cil_tmp7);
    }
#line 45
    return (__cil_tmp8);
  }
  {
#line 48
  __cil_tmp9 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp9);
}
}
#line 26 "/root/patchweave_new/13/examples/pngdec.c"
static void error_function(png_structp png , png_const_charp dummy ) 
{ 
  jmp_buf *__cil_tmp3 ;

  {
  {
#line 28
  __cil_tmp3 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 28
  longjmp((struct __jmp_buf_tag *)(*__cil_tmp3), 1);
  }
#line 30
  return;
}
}
#line 40 "/root/patchweave_new/13/examples/pngdec.c"
static uint8_t *HexStringToBytes(char const   *hexstring , size_t expected_length ) 
{ 
  char const   *src ;
  size_t actual_length ;
  uint8_t *raw_data ;
  void *__cil_tmp6 ;
  uint8_t *dst ;
  char *end ;
  char val[3] ;
  char const   *__cil_tmp10 ;
  uint8_t *__cil_tmp11 ;
  long __cil_tmp12 ;

  {
  {
#line 42
  src = hexstring;
#line 43
  actual_length = (size_t )0;
#line 44
  __cil_tmp6 = malloc(expected_length);
#line 44
  raw_data = (uint8_t *)__cil_tmp6;
  }
#line 47
  if ((unsigned long )raw_data == (unsigned long )((void *)0)) {
#line 47
    return ((uint8_t *)((void *)0));
  }
#line 49
  dst = raw_data;
  {
#line 49
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 49
    if (actual_length < expected_length) {
#line 49
      if (! ((int )*src != 0)) {
#line 49
        goto while_break;
      }
    } else {
#line 49
      goto while_break;
    }
#line 52
    if ((int )*src == 10) {
#line 52
      goto while_continue;
    }
    {
#line 53
    __cil_tmp10 = src;
#line 53
    src ++;
#line 53
    val[0] = (char )*__cil_tmp10;
#line 54
    val[1] = (char )*src;
#line 55
    val[2] = (char )'\000';
#line 56
    __cil_tmp12 = strtol((char const   *)(val), & end, 16);
#line 56
    __cil_tmp11 = dst;
#line 56
    dst ++;
#line 56
    *__cil_tmp11 = (uint8_t )__cil_tmp12;
    }
#line 57
    if ((unsigned long )end != (unsigned long )(val + 2)) {
#line 57
      goto while_break;
    }
#line 58
    actual_length ++;
#line 49
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 61
  if (actual_length != expected_length) {
    {
#line 62
    free((void *)raw_data);
    }
#line 63
    return ((uint8_t *)((void *)0));
  }
#line 65
  return (raw_data);
}
}
#line 68 "/root/patchweave_new/13/examples/pngdec.c"
static int ProcessRawProfile(char const   *profile , size_t profile_len , MetadataPayload *payload ) 
{ 
  char const   *src ;
  char *end ;
  int expected_length ;
  char const   *__cil_tmp7 ;
  long __cil_tmp8 ;

  {
#line 70
  src = profile;
#line 74
  if ((unsigned long )profile == (unsigned long )((void *)0)) {
#line 74
    return (0);
  } else
#line 74
  if (profile_len == 0UL) {
#line 74
    return (0);
  }
#line 78
  if ((int )*src != 10) {
    {
#line 79
    fprintf(stderr, "Malformed raw profile, expected \'\\n\' got \'\\x%.2X\'\n", (int )*src);
    }
#line 81
    return (0);
  }
#line 83
  src ++;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    __cil_tmp7 = src;
#line 85
    src ++;
#line 85
    if ((int )*src != 0) {
#line 85
      if (! ((int )*__cil_tmp7 != 10)) {
#line 85
        goto while_break;
      }
    } else {
#line 85
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 86
  __cil_tmp8 = strtol(src, & end, 10);
#line 86
  expected_length = (int )__cil_tmp8;
  }
#line 87
  if ((int )*end != 10) {
    {
#line 88
    fprintf(stderr, "Malformed raw profile, expected \'\\n\' got \'\\x%.2X\'\n", (int )*end);
    }
#line 90
    return (0);
  }
  {
#line 92
  end ++;
#line 95
  payload->bytes = HexStringToBytes((char const   *)end, (size_t )expected_length);
  }
#line 96
  if ((unsigned long )payload->bytes == (unsigned long )((void *)0)) {
#line 96
    return (0);
  }
#line 97
  payload->size = (size_t )expected_length;
#line 98
  return (1);
}
}
#line 106 "/root/patchweave_new/13/examples/pngdec.c"
static struct __anonstruct_1036 kPNGMetadataMap[4]  = {      {"Raw profile type exifU", (int (*)(char const   * , size_t  , MetadataPayload * const   ))(& ProcessRawProfile),
      (size_t )0}, 
        {"Raw profile type xmp", (int (*)(char const   * , size_t  , MetadataPayload * const   ))(& ProcessRawProfile),
      (size_t )0}, 
        {"XML:com.adobe.xmpCG~\210U", (int (*)(char const   * , size_t  , MetadataPayload * const   ))(& MetadataCopy),
      (size_t )0}, 
        {(char const   *)((void *)0), (int (*)(char const   * , size_t  , MetadataPayload * const   ))((void *)0),
      (size_t )0}};
#line 120 "/root/patchweave_new/13/examples/pngdec.c"
static int ExtractMetadataFromPNG(png_structp png , png_infop head_info , png_infop end_info ,
                                  Metadata *metadata ) 
{ 
  int p ;
  png_infop info ;
  png_infop tmp___0 ;
  png_textp text ;
  int num ;
  int __cil_tmp10 ;
  int i ;
  int j ;
  int __cil_tmp13 ;
  MetadataPayload *payload ;
  png_size_t text_length ;
  int __cil_tmp16 ;
  png_charp name ;
  int comp_type ;
  png_bytep profile ;
  png_uint_32 len ;
  png_uint_32 __cil_tmp21 ;
  int __cil_tmp22 ;

  {
#line 126
  p = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;

#line 126
    if (! (p < 2)) {
#line 126
      goto while_break;
    }
#line 127
    if (p == 0) {
#line 127
      tmp___0 = head_info;
    } else {
#line 127
      tmp___0 = end_info;
    }
    {
#line 127
    info = tmp___0;
#line 128
    text = (png_textp )((void *)0);
#line 129
    __cil_tmp10 = png_get_text(png, info, & text, (int *)((void *)0));
#line 129
    num = __cil_tmp10;
#line 132
    i = 0;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 132
      if (! (i < num)) {
#line 132
        goto while_break___0;
      }
#line 134
      j = 0;
      {
#line 134
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 134
        if (! ((unsigned long )kPNGMetadataMap[j].name != (unsigned long )((void *)0))) {
#line 134
          goto while_break___1;
        }
        {
#line 135
        __cil_tmp13 = strcmp((char const   *)text->key, kPNGMetadataMap[j].name);
        }
#line 135
        if (! __cil_tmp13) {
#line 136
          payload = (MetadataPayload *)((uint8_t *)metadata + kPNGMetadataMap[j].storage_offset);
#line 143
          if (text->compression == 2) {
#line 143
            goto case_2;
          }
#line 143
          if (text->compression == 1) {
#line 143
            goto case_2;
          }
#line 149
          goto switch_default;
          case_2: 
#line 144
          text_length = text->itxt_length;
#line 145
          goto switch_break;
          switch_default: 
#line 150
          text_length = text->text_length;
#line 151
          goto switch_break;
          switch_break: ;
#line 153
          if ((unsigned long )payload->bytes != (unsigned long )((void *)0)) {
            {
#line 154
            fprintf(stderr, "Ignoring additional \'%s\'\n", text->key);
            }
          } else {
            {
#line 155
            __cil_tmp16 = (*(kPNGMetadataMap[j].process))((char const   *)text->text,
                                                          text_length, (MetadataPayload */* const  */)payload);
            }
#line 155
            if (! __cil_tmp16) {
              {
#line 157
              fprintf(stderr, "Failed to process: \'%s\'\n\230\001", text->key);
              }
#line 158
              return (0);
            }
          }
#line 160
          goto while_break___1;
        }
#line 134
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 132
      text ++;
#line 132
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 176
    __cil_tmp21 = png_get_iCCP(png, info, & name, & comp_type, & profile, & len);
    }
#line 176
    if (__cil_tmp21 == 4096U) {
      {
#line 178
      __cil_tmp22 = MetadataCopy((char const   *)profile, (size_t )len, & metadata->iccp);
      }
#line 178
      if (! __cil_tmp22) {
#line 178
        return (0);
      }
    }
#line 126
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 183
  return (1);
}
}
#line 186 "/root/patchweave_new/13/examples/pngdec.c"
int ReadPNG(FILE *in_file , WebPPicture *pic , int keep_alpha , Metadata *metadata ) 
{ 
  png_structp png ;
  png_infop info ;
  png_infop end_info ;
  int color_type ;
  int bit_depth ;
  int interlaced ;
  int has_alpha ;
  int num_passes ;
  int p ;
  int ok ;
  png_uint_32 width ;
  png_uint_32 height ;
  png_uint_32 y ;
  int stride ;
  uint8_t *rgb ;
  jmp_buf *__cil_tmp21 ;
  int __cil_tmp22 ;
  png_uint_32 __cil_tmp25 ;
  png_uint_32 __cil_tmp26 ;
  int tmp___0 ;
  void *__cil_tmp29 ;
  png_bytep row ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int tmp___1 ;

  {
  {
#line 189
  info = (png_infop )((void *)0);
#line 190
  end_info = (png_infop )((void *)0);
#line 195
  ok = 0;
#line 198
  rgb = (uint8_t *)((void *)0);
#line 200
  png = png_create_read_struct("1.6.37", (png_voidp )0, (void (*)(png_structp  , png_const_charp  ))0,
                               (void (*)(png_structp  , png_const_charp  ))0);
  }
#line 201
  if ((unsigned long )png == (unsigned long )((void *)0)) {
#line 202
    goto End;
  }
  {
#line 205
  png_set_error_fn(png, (png_voidp )0, & error_function, (void (*)(png_structp  ,
                                                                   png_const_charp  ))((void *)0));
#line 206
  __cil_tmp21 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 206
  __cil_tmp22 = _setjmp((struct __jmp_buf_tag *)(*__cil_tmp21));
  }
#line 206
  if (__cil_tmp22) {
    Error: 
    {
#line 208
    MetadataFree(metadata);
#line 209
    png_destroy_read_struct(& png, & info, & end_info);
    }
#line 210
    goto End;
  }
  {
#line 213
  info = png_create_info_struct(png);
  }
#line 214
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 214
    goto Error;
  }
  {
#line 215
  end_info = png_create_info_struct(png);
  }
#line 216
  if ((unsigned long )end_info == (unsigned long )((void *)0)) {
#line 216
    goto Error;
  }
  {
#line 218
  png_init_io(png, in_file);
#line 219
  png_read_info(png, info);
#line 220
  __cil_tmp25 = png_get_IHDR(png, info, & width, & height, & bit_depth, & color_type,
                             & interlaced, (int *)((void *)0), (int *)((void *)0));
  }
#line 220
  if (! __cil_tmp25) {
#line 222
    goto Error;
  }
  {
#line 224
  png_set_strip_16(png);
#line 225
  png_set_packing(png);
  }
#line 226
  if (color_type == 3) {
    {
#line 226
    png_set_palette_to_rgb(png);
    }
  }
#line 227
  if (color_type == 0) {
    _L: 
#line 229
    if (bit_depth < 8) {
      {
#line 230
      png_set_expand_gray_1_2_4_to_8(png);
      }
    }
    {
#line 232
    png_set_gray_to_rgb(png);
    }
  } else
#line 227
  if (color_type == 4) {
#line 227
    goto _L;
  }
  {
#line 234
  __cil_tmp26 = png_get_valid(png, info, 16U);
  }
#line 234
  if (__cil_tmp26) {
    {
#line 235
    png_set_tRNS_to_alpha(png);
#line 236
    has_alpha = 1;
    }
  } else {
#line 238
    has_alpha = ! (! (color_type & 4));
  }
#line 241
  if (! keep_alpha) {
    {
#line 242
    png_set_strip_alpha(png);
#line 243
    has_alpha = 0;
    }
  }
  {
#line 246
  num_passes = png_set_interlace_handling(png);
#line 247
  png_read_update_info(png, info);
  }
#line 248
  if (has_alpha) {
#line 248
    tmp___0 = 4;
  } else {
#line 248
    tmp___0 = 3;
  }
  {
#line 248
  stride = (int )((unsigned long )((unsigned int )tmp___0 * width) * sizeof(*rgb));
#line 249
  __cil_tmp29 = malloc((unsigned long )((unsigned int )stride * height));
#line 249
  rgb = (uint8_t *)__cil_tmp29;
  }
#line 250
  if ((unsigned long )rgb == (unsigned long )((void *)0)) {
#line 250
    goto Error;
  }
#line 251
  p = 0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;

#line 251
    if (! (p < num_passes)) {
#line 251
      goto while_break;
    }
#line 252
    y = (png_uint_32 )0;
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 252
      if (! (y < height)) {
#line 252
        goto while_break___0;
      }
      {
#line 253
      row = rgb + y * (unsigned int )stride;
#line 254
      png_read_rows(png, & row, (png_bytepp )((void *)0), (png_uint_32 )1);
#line 252
      y ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 251
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 257
  png_read_end(png, end_info);
#line 259
  __cil_tmp31 = ExtractMetadataFromPNG(png, info, end_info, metadata);
  }
#line 259
  if ((unsigned long )metadata != (unsigned long )((void *)0)) {
#line 259
    if (! __cil_tmp31) {
      {
#line 261
      fprintf(stderr, "Error extracting PNG metadata!\n");
      }
#line 262
      goto Error;
    }
  }
  {
#line 265
  png_destroy_read_struct(& png, & info, & end_info);
#line 267
  pic->width = (int )width;
#line 268
  pic->height = (int )height;
#line 269
  pic->use_argb = 1;
  }
#line 270
  if (has_alpha) {
    {
#line 270
    __cil_tmp32 = WebPPictureImportRGBA(pic, rgb, stride);
#line 270
    tmp___1 = __cil_tmp32;
    }
  } else {
    {
#line 270
    __cil_tmp33 = WebPPictureImportRGB(pic, rgb, stride);
#line 270
    tmp___1 = __cil_tmp33;
    }
  }
#line 270
  ok = tmp___1;
#line 273
  if (! ok) {
#line 274
    goto Error;
  }
  End: 
  {
#line 278
  free((void *)rgb);
  }
#line 279
  return (ok);
}
}
#line 26 "/root/patchweave_new/13/examples/./jpegdec.h"
int ReadJPEG(FILE *in_file , WebPPicture *pic , Metadata *metadata ) ;
#line 891 "/usr/include/jpeglib.h"
extern struct jpeg_error_mgr *jpeg_std_error(struct jpeg_error_mgr *err ) ;
#line 908
extern void jpeg_CreateDecompress(j_decompress_ptr cinfo , int version , size_t structsize ) ;
#line 912
extern void jpeg_destroy_decompress(j_decompress_ptr cinfo ) ;
#line 917
extern void jpeg_stdio_src(j_decompress_ptr cinfo , FILE *infile ) ;
#line 985
extern int jpeg_read_header(j_decompress_ptr cinfo , boolean require_image ) ;
#line 997
extern boolean jpeg_start_decompress(j_decompress_ptr cinfo ) ;
#line 998
extern JDIMENSION jpeg_read_scanlines(j_decompress_ptr cinfo , JSAMPARRAY scanlines ,
                                      JDIMENSION max_lines ) ;
#line 1005
extern boolean jpeg_finish_decompress(j_decompress_ptr cinfo ) ;
#line 1032
extern void jpeg_save_markers(j_decompress_ptr cinfo , int marker_code , unsigned int length_limit ) ;
#line 43 "/root/patchweave_new/13/examples/jpegdec.c"
static void SaveMetadataMarkers(j_decompress_ptr dinfo ) 
{ 
  unsigned int max_marker_length ;

  {
  {
#line 44
  max_marker_length = 65535U;
#line 45
  jpeg_save_markers(dinfo, 225, max_marker_length);
#line 46
  jpeg_save_markers(dinfo, 226, max_marker_length);
  }
#line 48
  return;
}
}
#line 49 "/root/patchweave_new/13/examples/jpegdec.c"
static int CompareICCPSegments(void const   *a , void const   *b ) 
{ 
  ICCPSegment *s1 ;
  ICCPSegment *s2 ;

  {
#line 50
  s1 = (ICCPSegment *)a;
#line 51
  s2 = (ICCPSegment *)b;
#line 52
  return (s1->seq - s2->seq);
}
}
#line 60 "/root/patchweave_new/13/examples/jpegdec.c"
static char const   kICCPSignature[12]  ;
#line 61 "/root/patchweave_new/13/examples/jpegdec.c"
static size_t kICCPSignatureLength  ;
#line 62 "/root/patchweave_new/13/examples/jpegdec.c"
static size_t kICCPSkipLength  ;
#line 58 "/root/patchweave_new/13/examples/jpegdec.c"
static int StoreICCP(j_decompress_ptr dinfo , MetadataPayload *iccp ) 
{ 
  int expected_count ;
  int actual_count ;
  int seq_max ;
  size_t total_size ;
  ICCPSegment iccp_segments[255] ;
  jpeg_saved_marker_ptr marker ;
  int __cil_tmp12 ;
  int seq ;
  int count ;
  size_t segment_size ;
  ICCPSegment *segment ;
  void *__cil_tmp17 ;
  int i ;
  size_t offset ;

  {
  {
#line 60
  strcpy((char *)(kICCPSignature), "ICC_PROFILE");
#line 61
  kICCPSignatureLength = (size_t )12;
#line 62
  kICCPSkipLength = (size_t )14;
#line 63
  expected_count = 0;
#line 64
  actual_count = 0;
#line 65
  seq_max = 0;
#line 66
  total_size = (size_t )0;
#line 70
  memset((void *)(iccp_segments), 0, sizeof(iccp_segments));
#line 71
  marker = dinfo->marker_list;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;

#line 71
    if (! ((unsigned long )marker != (unsigned long )((void *)0))) {
#line 71
      goto while_break;
    }
    {
#line 72
    __cil_tmp12 = memcmp((void const   *)marker->data, (void const   *)(kICCPSignature),
                         kICCPSignatureLength);
    }
#line 72
    if ((int )marker->marker == 226) {
#line 72
      if ((unsigned long )marker->data_length > kICCPSkipLength) {
#line 72
        if (! __cil_tmp12) {
#line 76
          seq = (int )*(marker->data + kICCPSignatureLength);
#line 77
          count = (int )*(marker->data + (kICCPSignatureLength + 1UL));
#line 78
          segment_size = (unsigned long )marker->data_length - kICCPSkipLength;
#line 81
          if (segment_size == 0UL) {
            {
#line 82
            fprintf(stderr, "[ICCP] size (%d) / count (%d) / sequence number (%d) cannot be 0!\n",
                    (int )segment_size, seq, count);
            }
#line 85
            return (0);
          } else
#line 81
          if (count == 0) {
            {
#line 82
            fprintf(stderr, "[ICCP] size (%d) / count (%d) / sequence number (%d) cannot be 0!\n",
                    (int )segment_size, seq, count);
            }
#line 85
            return (0);
          } else
#line 81
          if (seq == 0) {
            {
#line 82
            fprintf(stderr, "[ICCP] size (%d) / count (%d) / sequence number (%d) cannot be 0!\n",
                    (int )segment_size, seq, count);
            }
#line 85
            return (0);
          }
#line 88
          if (expected_count == 0) {
#line 89
            expected_count = count;
          } else
#line 90
          if (expected_count != count) {
            {
#line 91
            fprintf(stderr, "[ICCP] Inconsistent segment count (%d / %d)!\n", expected_count,
                    count);
            }
#line 93
            return (0);
          }
#line 96
          segment = (iccp_segments + seq) - 1;
#line 97
          if (segment->data_length != 0UL) {
            {
#line 98
            fprintf(stderr, "[ICCP] Duplicate segment number (%d)!\n", seq);
            }
#line 99
            return (0);
          }
#line 102
          segment->data = marker->data + kICCPSkipLength;
#line 103
          segment->data_length = segment_size;
#line 104
          segment->seq = seq;
#line 105
          total_size += segment_size;
#line 106
          if (seq > seq_max) {
#line 106
            seq_max = seq;
          }
#line 107
          actual_count ++;
        }
      }
    }
#line 71
    marker = marker->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 111
  if (actual_count == 0) {
#line 111
    return (1);
  }
#line 112
  if (seq_max != actual_count) {
    {
#line 113
    fprintf(stderr, "[ICCP] Discontinuous segments, expected: %d actual: %d!\n", actual_count,
            seq_max);
    }
#line 115
    return (0);
  }
#line 117
  if (expected_count != actual_count) {
    {
#line 118
    fprintf(stderr, "[ICCP] Segment count: %d does not match expected: %d!\n", actual_count,
            expected_count);
    }
#line 120
    return (0);
  }
  {
#line 125
  qsort((void *)(iccp_segments), (size_t )actual_count, sizeof(iccp_segments[0]),
        & CompareICCPSegments);
#line 128
  __cil_tmp17 = malloc(total_size);
#line 128
  iccp->bytes = (uint8_t *)__cil_tmp17;
  }
#line 129
  if ((unsigned long )iccp->bytes == (unsigned long )((void *)0)) {
#line 129
    return (0);
  }
#line 130
  iccp->size = total_size;
#line 134
  offset = (size_t )0;
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 135
    if (! (i < seq_max)) {
#line 135
      goto while_break___0;
    }
    {
#line 136
    memcpy((void *)(iccp->bytes + offset), (void const   *)iccp_segments[i].data,
           iccp_segments[i].data_length);
#line 138
    offset += iccp_segments[i].data_length;
#line 135
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 141
  return (1);
}
}
#line 148 "/root/patchweave_new/13/examples/jpegdec.c"
static struct __anonstruct_1064 kJPEGMetadataMap[3]  ;
#line 146 "/root/patchweave_new/13/examples/jpegdec.c"
static int ExtractMetadataFromJPEG(j_decompress_ptr dinfo , Metadata *metadata ) 
{ 
  jpeg_saved_marker_ptr marker ;
  int __cil_tmp5 ;
  int i ;
  int __cil_tmp7 ;
  MetadataPayload *payload ;
  char const   *marker_data ;
  size_t marker_data_length ;
  int __cil_tmp11 ;

  {
  {
#line 148
  kJPEGMetadataMap[0].marker = 225;
#line 148
  strcpy((char *)kJPEGMetadataMap[0].signature, "Exif");
#line 148
  kJPEGMetadataMap[0].signature_length = (size_t )6;
#line 148
  kJPEGMetadataMap[0].storage_offset = (size_t )0;
#line 148
  kJPEGMetadataMap[1].marker = 225;
#line 148
  strcpy((char *)kJPEGMetadataMap[1].signature, "http://ns.adobe.com/xap/1.0/");
#line 148
  kJPEGMetadataMap[1].signature_length = (size_t )29;
#line 148
  kJPEGMetadataMap[1].storage_offset = (size_t )0;
#line 148
  kJPEGMetadataMap[2].marker = 0;
#line 148
  kJPEGMetadataMap[2].signature = (char const   *)((void *)0);
#line 148
  kJPEGMetadataMap[2].signature_length = (size_t )0;
#line 148
  kJPEGMetadataMap[2].storage_offset = (size_t )0;
#line 163
  __cil_tmp5 = StoreICCP(dinfo, & metadata->iccp);
  }
#line 163
  if (! __cil_tmp5) {
#line 163
    return (0);
  }
#line 165
  marker = dinfo->marker_list;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;

#line 165
    if (! ((unsigned long )marker != (unsigned long )((void *)0))) {
#line 165
      goto while_break;
    }
#line 167
    i = 0;
    {
#line 167
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 167
      if (! (kJPEGMetadataMap[i].marker != 0)) {
#line 167
        goto while_break___0;
      }
      {
#line 168
      __cil_tmp7 = memcmp((void const   *)marker->data, (void const   *)kJPEGMetadataMap[i].signature,
                          kJPEGMetadataMap[i].signature_length);
      }
#line 168
      if ((int )marker->marker == kJPEGMetadataMap[i].marker) {
#line 168
        if ((unsigned long )marker->data_length > kJPEGMetadataMap[i].signature_length) {
#line 168
          if (! __cil_tmp7) {
#line 172
            payload = (MetadataPayload *)((uint8_t *)metadata + kJPEGMetadataMap[i].storage_offset);
#line 176
            if ((unsigned long )payload->bytes == (unsigned long )((void *)0)) {
              {
#line 177
              marker_data = (char const   *)marker->data + kJPEGMetadataMap[i].signature_length;
#line 179
              marker_data_length = (unsigned long )marker->data_length - kJPEGMetadataMap[i].signature_length;
#line 181
              __cil_tmp11 = MetadataCopy(marker_data, marker_data_length, payload);
              }
#line 181
              if (! __cil_tmp11) {
#line 181
                return (0);
              }
            } else {
              {
#line 183
              fprintf(stderr, "Ignoring additional \'%s\' marker\n\230\001", kJPEGMetadataMap[i].signature);
              }
            }
          }
        }
      }
#line 167
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 165
    marker = marker->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 189
  return (1);
}
}
#line 203 "/root/patchweave_new/13/examples/jpegdec.c"
static void my_error_exit(j_common_ptr dinfo ) 
{ 
  struct my_error_mgr *myerr ;

  {
  {
#line 204
  myerr = (struct my_error_mgr *)dinfo->err;
#line 205
  (*((dinfo->err)->output_message))(dinfo);
#line 206
  longjmp((struct __jmp_buf_tag *)(myerr->setjmp_buffer), 1);
  }
#line 208
  return;
}
}
#line 209 "/root/patchweave_new/13/examples/jpegdec.c"
int ReadJPEG(FILE *in_file , WebPPicture *pic , Metadata *metadata ) 
{ 
  int ok ;
  int stride ;
  int width ;
  int height ;
  struct jpeg_decompress_struct dinfo ;
  struct my_error_mgr jerr ;
  uint8_t *rgb ;
  JSAMPROW buffer[1] ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  JDIMENSION __cil_tmp15 ;

  {
  {
#line 210
  ok = 0;
#line 214
  rgb = (uint8_t *)((void *)0);
#line 217
  dinfo.err = jpeg_std_error(& jerr.pub);
#line 218
  jerr.pub.error_exit = & my_error_exit;
#line 220
  __cil_tmp13 = _setjmp((struct __jmp_buf_tag *)(jerr.setjmp_buffer));
  }
#line 220
  if (__cil_tmp13) {
    Error: 
    {
#line 222
    MetadataFree(metadata);
#line 223
    jpeg_destroy_decompress(& dinfo);
    }
#line 224
    goto End;
  }
  {
#line 227
  jpeg_CreateDecompress(& dinfo, 80, sizeof(struct jpeg_decompress_struct ));
#line 228
  jpeg_stdio_src(& dinfo, in_file);
  }
#line 229
  if ((unsigned long )metadata != (unsigned long )((void *)0)) {
    {
#line 229
    SaveMetadataMarkers(& dinfo);
    }
  }
  {
#line 230
  jpeg_read_header(& dinfo, 1);
#line 232
  dinfo.out_color_space = (J_COLOR_SPACE )2;
#line 233
  dinfo.dct_method = (J_DCT_METHOD )1;
#line 234
  dinfo.do_fancy_upsampling = 1;
#line 236
  jpeg_start_decompress(& dinfo);
  }
#line 238
  if (dinfo.output_components != 3) {
#line 239
    goto Error;
  }
  {
#line 242
  width = (int )dinfo.output_width;
#line 243
  height = (int )dinfo.output_height;
#line 244
  stride = (int )((unsigned long )(dinfo.output_width * (unsigned int )dinfo.output_components) * sizeof(*rgb));
#line 246
  __cil_tmp14 = malloc((unsigned long )(stride * height));
#line 246
  rgb = (uint8_t *)__cil_tmp14;
  }
#line 247
  if ((unsigned long )rgb == (unsigned long )((void *)0)) {
#line 248
    goto End;
  }
#line 250
  buffer[0] = rgb;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;

#line 252
    if (! (dinfo.output_scanline < dinfo.output_height)) {
#line 252
      goto while_break;
    }
    {
#line 253
    __cil_tmp15 = jpeg_read_scanlines(& dinfo, buffer, (JDIMENSION )1);
    }
#line 253
    if (__cil_tmp15 != 1U) {
#line 254
      goto End;
    }
#line 256
    buffer[0] += stride;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 259
  if ((unsigned long )metadata != (unsigned long )((void *)0)) {
    {
#line 260
    ok = ExtractMetadataFromJPEG(& dinfo, metadata);
    }
#line 261
    if (! ok) {
      {
#line 262
      fprintf(stderr, "Error extracting JPEG metadata!\n\220");
      }
#line 263
      goto Error;
    }
  }
  {
#line 267
  jpeg_finish_decompress(& dinfo);
#line 268
  jpeg_destroy_decompress(& dinfo);
#line 271
  pic->width = width;
#line 272
  pic->height = height;
#line 273
  ok = WebPPictureImportRGB(pic, rgb, stride);
  }
#line 274
  if (! ok) {
#line 274
    goto Error;
  }
  End: 
  {
#line 277
  free((void *)rgb);
  }
#line 278
  return (ok);
}
}
#line 18 "/root/patchweave_new/13/examples/metadata.c"
void MetadataInit(Metadata *metadata ) 
{ 


  {
#line 19
  if ((unsigned long )metadata == (unsigned long )((void *)0)) {
#line 19
    return;
  }
  {
#line 20
  memset((void *)metadata, 0, sizeof(*metadata));
  }
#line 22
  return;
}
}
#line 23 "/root/patchweave_new/13/examples/metadata.c"
void MetadataPayloadDelete(MetadataPayload *payload ) 
{ 


  {
#line 24
  if ((unsigned long )payload == (unsigned long )((void *)0)) {
#line 24
    return;
  }
  {
#line 25
  free((void *)payload->bytes);
#line 26
  payload->bytes = (uint8_t *)((void *)0);
#line 27
  payload->size = (size_t )0;
  }
#line 29
  return;
}
}
#line 30 "/root/patchweave_new/13/examples/metadata.c"
void MetadataFree(Metadata *metadata ) 
{ 


  {
#line 31
  if ((unsigned long )metadata == (unsigned long )((void *)0)) {
#line 31
    return;
  }
  {
#line 32
  MetadataPayloadDelete(& metadata->exif);
#line 33
  MetadataPayloadDelete(& metadata->iccp);
#line 34
  MetadataPayloadDelete(& metadata->xmp);
  }
#line 36
  return;
}
}
#line 37 "/root/patchweave_new/13/examples/metadata.c"
int MetadataCopy(char const   *metadata , size_t metadata_len , MetadataPayload *payload ) 
{ 
  void *__cil_tmp4 ;

  {
#line 39
  if ((unsigned long )metadata == (unsigned long )((void *)0)) {
#line 39
    return (0);
  } else
#line 39
  if (metadata_len == 0UL) {
#line 39
    return (0);
  } else
#line 39
  if ((unsigned long )payload == (unsigned long )((void *)0)) {
#line 39
    return (0);
  }
  {
#line 40
  __cil_tmp4 = malloc(metadata_len);
#line 40
  payload->bytes = (uint8_t *)__cil_tmp4;
  }
#line 41
  if ((unsigned long )payload->bytes == (unsigned long )((void *)0)) {
#line 41
    return (0);
  }
  {
#line 42
  payload->size = metadata_len;
#line 43
  memcpy((void *)payload->bytes, (void const   *)metadata, metadata_len);
  }
#line 44
  return (1);
}
}
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 38 "/root/patchweave_new/13/examples/./stopwatch.h"
__inline static double StopwatchReadAndReset(Stopwatch *watch ) 
{ 
  struct timeval old_value ;

  {
  {
#line 39
  old_value = *watch;
#line 40
  gettimeofday(watch, (void *)0);
  }
#line 41
  return ((double )(watch->tv_sec - old_value.tv_sec) + (double )(watch->tv_usec - old_value.tv_usec) / 1000000.);
}
}
#line 45 "/root/patchweave_new/13/examples/cwebp.c"
static int verbose  =    0;
#line 47 "/root/patchweave_new/13/examples/cwebp.c"
static int ReadYUV(FILE *in_file , WebPPicture *pic ) 
{ 
  int use_argb ;
  int uv_width ;
  int uv_height ;
  int y ;
  int ok ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;

  {
  {
#line 48
  use_argb = pic->use_argb;
#line 49
  uv_width = (pic->width + 1) / 2;
#line 50
  uv_height = (pic->height + 1) / 2;
#line 52
  ok = 0;
#line 54
  pic->use_argb = 0;
#line 55
  __cil_tmp8 = WebPPictureAlloc(pic);
  }
#line 55
  if (! __cil_tmp8) {
#line 55
    return (ok);
  }
#line 57
  y = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;

#line 57
    if (! (y < pic->height)) {
#line 57
      goto while_break;
    }
    {
#line 58
    __cil_tmp9 = fread((void *)(pic->y + y * pic->y_stride), (unsigned long )pic->width,
                       1UL, in_file);
    }
#line 58
    if (__cil_tmp9 != 1UL) {
#line 59
      goto End;
    }
#line 57
    y ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 62
  y = 0;
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 62
    if (! (y < uv_height)) {
#line 62
      goto while_break___0;
    }
    {
#line 63
    __cil_tmp10 = fread((void *)(pic->u + y * pic->uv_stride), (unsigned long )uv_width,
                        1UL, in_file);
    }
#line 63
    if (__cil_tmp10 != 1UL) {
#line 64
      goto End;
    }
#line 62
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 66
  y = 0;
  {
#line 66
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 66
    if (! (y < uv_height)) {
#line 66
      goto while_break___1;
    }
    {
#line 67
    __cil_tmp11 = fread((void *)(pic->v + y * pic->uv_stride), (unsigned long )uv_width,
                        1UL, in_file);
    }
#line 67
    if (__cil_tmp11 != 1UL) {
#line 68
      goto End;
    }
#line 66
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
#line 70
  ok = 1;
#line 71
  if (use_argb) {
    {
#line 71
    ok = WebPPictureYUVAToARGB(pic);
    }
  }
  End: 
#line 74
  return (ok);
}
}
#line 110 "/root/patchweave_new/13/examples/cwebp.c"
static InputFileFormat GetImageType(FILE *in_file ) 
{ 
  InputFileFormat format ;
  uint32_t magic ;
  uint8_t buf[4] ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 111
  format = (InputFileFormat )3;
#line 115
  __cil_tmp6 = fseek(in_file, 0L, 0);
#line 115
  __cil_tmp5 = fread((void *)(& buf[0]), 4UL, 1UL, in_file);
  }
#line 115
  if (__cil_tmp5 != 1UL) {
#line 117
    return (format);
  } else
#line 115
  if (__cil_tmp6 != 0) {
#line 117
    return (format);
  }
#line 120
  magic = (((uint32_t )((int )buf[0] << 24) | (unsigned int )((int )buf[1] << 16)) | (unsigned int )((int )buf[2] << 8)) | (unsigned int )buf[3];
#line 121
  if (magic == 2303741511U) {
#line 122
    format = (InputFileFormat )0;
  } else
#line 123
  if (magic >= 4292411136U) {
#line 123
    if (magic <= 4292411391U) {
#line 124
      format = (InputFileFormat )1;
    } else {
#line 123
      goto _L;
    }
  } else
  _L: 
#line 125
  if (magic == 1229531648U) {
#line 126
    format = (InputFileFormat )2;
  } else
#line 125
  if (magic == 1296891946U) {
#line 126
    format = (InputFileFormat )2;
  }
#line 128
  return (format);
}
}
#line 131 "/root/patchweave_new/13/examples/cwebp.c"
static int ReadPicture(char const   *filename , WebPPicture *pic , int keep_alpha ,
                       Metadata *metadata ) 
{ 
  int ok ;
  FILE *in_file ;
  FILE *__cil_tmp7 ;
  InputFileFormat format ;
  InputFileFormat __cil_tmp9 ;

  {
  {
#line 133
  ok = 0;
#line 134
  __cil_tmp7 = fopen(filename, "rb~~\210U");
#line 134
  in_file = __cil_tmp7;
  }
#line 135
  if ((unsigned long )in_file == (unsigned long )((void *)0)) {
    {
#line 136
    fprintf(stderr, "Error! Cannot open input file \'%s\'\n", filename);
    }
#line 137
    return (ok);
  }
#line 140
  if (pic->width == 0) {
    _L: 
    {
#line 142
    __cil_tmp9 = GetImageType(in_file);
#line 142
    format = __cil_tmp9;
    }
#line 143
    if ((unsigned int )format == 0U) {
      {
#line 144
      ok = ReadPNG(in_file, pic, keep_alpha, metadata);
      }
    } else
#line 145
    if ((unsigned int )format == 1U) {
      {
#line 146
      ok = ReadJPEG(in_file, pic, metadata);
      }
    } else
#line 147
    if ((unsigned int )format == 2U) {
      {
#line 148
      ok = ReadTIFF(filename, pic, keep_alpha, metadata);
      }
    }
  } else
#line 140
  if (pic->height == 0) {
#line 140
    goto _L;
  } else {
    {
#line 152
    ok = ReadYUV(in_file, pic);
    }
  }
#line 154
  if (! ok) {
    {
#line 155
    fprintf(stderr, "Error! Could not process file %s\n\217~~\210U", filename);
    }
  }
  {
#line 158
  fclose(in_file);
  }
#line 159
  return (ok);
}
}
#line 164 "/root/patchweave_new/13/examples/cwebp.c"
static void AllocExtraInfo(WebPPicture *pic ) 
{ 
  int mb_w ;
  int mb_h ;
  void *__cil_tmp4 ;

  {
  {
#line 165
  mb_w = (pic->width + 15) / 16;
#line 166
  mb_h = (pic->height + 15) / 16;
#line 167
  __cil_tmp4 = malloc((unsigned long )(mb_w * mb_h) * sizeof(*(pic->extra_info)));
#line 167
  pic->extra_info = (uint8_t *)__cil_tmp4;
  }
#line 169
  return;
}
}
#line 170 "/root/patchweave_new/13/examples/cwebp.c"
static void PrintByteCount(int const   *bytes , int total_size , int *totals ) 
{ 
  int s ;
  int total ;

  {
#line 173
  total = 0;
#line 174
  s = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;

#line 174
    if (! (s < 4)) {
#line 174
      goto while_break;
    }
    {
#line 175
    fprintf(stderr, "| %7d ", *(bytes + s));
#line 176
    total += (int )*(bytes + s);
    }
#line 177
    if (totals) {
#line 177
      *(totals + s) += (int )*(bytes + s);
    }
#line 174
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 179
  fprintf(stderr, "| %7d  (%.1f%%)\n\230\001", total, (double )((100.f * (float )total) / (float )total_size));
  }
#line 181
  return;
}
}
#line 182 "/root/patchweave_new/13/examples/cwebp.c"
static void PrintPercents(int const   *counts , int total ) 
{ 
  int s ;

  {
#line 184
  s = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;

#line 184
    if (! (s < 4)) {
#line 184
      goto while_break;
    }
    {
#line 185
    fprintf(stderr, "|      %2d%%", (100 * (int )*(counts + s)) / total);
#line 184
    s ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 187
  fprintf(stderr, "| %7d\n", total);
  }
#line 189
  return;
}
}
#line 190 "/root/patchweave_new/13/examples/cwebp.c"
static void PrintValues(int const   *values ) 
{ 
  int s ;

  {
#line 192
  s = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;

#line 192
    if (! (s < 4)) {
#line 192
      goto while_break;
    }
    {
#line 193
    fprintf(stderr, "| %7d ", *(values + s));
#line 192
    s ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 195
  fprintf(stderr, "|\n");
  }
#line 197
  return;
}
}
#line 198 "/root/patchweave_new/13/examples/cwebp.c"
static void PrintFullLosslessInfo(WebPAuxStats *stats , char const   *description ) 
{ 


  {
  {
#line 200
  fprintf(stderr, "Lossless-%s compressed size: %d bytes\n", description, stats->lossless_size);
  }
#line 202
  if (stats->lossless_features) {
    {
#line 203
    fprintf(stderr, "  * Lossless features used:~\210U");
    }
#line 204
    if (stats->lossless_features & 1U) {
      {
#line 204
      fprintf(stderr, " PREDICTION");
      }
    }
#line 205
    if (stats->lossless_features & 2U) {
      {
#line 205
      fprintf(stderr, " CROSS-COLOR-TRANSFORM");
      }
    }
#line 206
    if (stats->lossless_features & 4U) {
      {
#line 206
      fprintf(stderr, " SUBTRACT-GREEN");
      }
    }
#line 207
    if (stats->lossless_features & 8U) {
      {
#line 207
      fprintf(stderr, " PALETTE\220");
      }
    }
    {
#line 208
    fprintf(stderr, "\n");
    }
  }
  {
#line 210
  fprintf(stderr, "  * Precision Bits: histogram=%d transform=%d cache=%d\n", stats->histogram_bits,
          stats->transform_bits, stats->cache_bits);
  }
#line 212
  if (stats->palette_size > 0) {
    {
#line 213
    fprintf(stderr, "  * Palette size:   %d\n", stats->palette_size);
    }
  }
#line 216
  return;
}
}
#line 217 "/root/patchweave_new/13/examples/cwebp.c"
static void PrintExtraInfoLossless(WebPPicture *pic , int short_output , char const   *file_name ) 
{ 
  WebPAuxStats *stats ;

  {
#line 220
  stats = pic->stats;
#line 221
  if (short_output) {
    {
#line 222
    fprintf(stderr, "%7d %2.2f\n", stats->coded_size, (double )stats->PSNR[3]);
    }
  } else {
    {
#line 224
    fprintf(stderr, "File:      %s\n", file_name);
#line 225
    fprintf(stderr, "Dimension: %d x %d\n", pic->width, pic->height);
#line 226
    fprintf(stderr, "Output:    %d bytes\n", stats->coded_size);
#line 227
    PrintFullLosslessInfo(stats, "ARGB");
    }
  }
#line 230
  return;
}
}
#line 231 "/root/patchweave_new/13/examples/cwebp.c"
static void PrintExtraInfoLossy(WebPPicture *pic , int short_output , int full_details ,
                                char const   *file_name ) 
{ 
  WebPAuxStats *stats ;
  int num_i4 ;
  int num_i16 ;
  int num_skip ;
  int total ;
  char const   *tmp___0 ;
  int totals[4] ;
  int mb_w ;
  int mb_h ;
  int type ;
  int x ;
  int y ;
  int c ;

  {
#line 234
  stats = pic->stats;
#line 235
  if (short_output) {
    {
#line 236
    fprintf(stderr, "%7d %2.2f\n", stats->coded_size, (double )stats->PSNR[3]);
    }
  } else {
    {
#line 238
    num_i4 = stats->block_count[0];
#line 239
    num_i16 = stats->block_count[1];
#line 240
    num_skip = stats->block_count[2];
#line 241
    total = num_i4 + num_i16;
#line 242
    fprintf(stderr, "File:      %s\n", file_name);
    }
#line 243
    if (stats->alpha_data_size) {
      {
#line 243
      strcpy((char *)tmp___0, " (with alpha)");
      }
    } else {
      {
#line 243
      strcpy((char *)tmp___0, "\220");
      }
    }
    {
#line 243
    fprintf(stderr, "Dimension: %d x %d%s\n", pic->width, pic->height, tmp___0);
#line 246
    fprintf(stderr, "Output:    %d bytes Y-U-V-All-PSNR %2.2f %2.2f %2.2f   %2.2f dB\n",
            stats->coded_size, (double )stats->PSNR[0], (double )stats->PSNR[1], (double )stats->PSNR[2],
            (double )stats->PSNR[3]);
    }
#line 250
    if (total > 0) {
      {
#line 251
      totals[0] = 0;
#line 251
      totals[1] = 0;
#line 251
      totals[2] = 0;
#line 251
      totals[3] = 0;
#line 252
      fprintf(stderr, "block count:  intra4: %d\n              intra16: %d  (-> %.2f%%)\n",
              num_i4, num_i16, (double )((100.f * (float )num_i16) / (float )total));
#line 255
      fprintf(stderr, "              skipped block: %d (%.2f%%)\n", num_skip, (double )((100.f * (float )num_skip) / (float )total));
#line 257
      fprintf(stderr, "bytes used:  header:         %6d  (%.1f%%)\n             mode-partition: %6d  (%.1f%%)\n",
              stats->header_bytes[0], (double )((100.f * (float )stats->header_bytes[0]) / (float )stats->coded_size),
              stats->header_bytes[1], (double )((100.f * (float )stats->header_bytes[1]) / (float )stats->coded_size));
      }
#line 263
      if (stats->alpha_data_size > 0) {
        {
#line 264
        fprintf(stderr, "             transparency:   %6d (%.1f dB)\n", stats->alpha_data_size,
                (double )stats->PSNR[4]);
        }
      }
#line 267
      if (stats->layer_data_size) {
        {
#line 268
        fprintf(stderr, "             enhancement:    %6d\n", stats->layer_data_size);
        }
      }
      {
#line 271
      fprintf(stderr, " Residuals bytes  |segment 1|segment 2|segment 3|segment 4|  total\n");
      }
#line 274
      if (full_details) {
        {
#line 275
        fprintf(stderr, "  intra4-coeffs:  ");
#line 276
        PrintByteCount((int const   *)((int const   *)(stats->residual_bytes[0])),
                       stats->coded_size, totals);
#line 277
        fprintf(stderr, " intra16-coeffs:  ");
#line 278
        PrintByteCount((int const   *)((int const   *)(stats->residual_bytes[1])),
                       stats->coded_size, totals);
#line 279
        fprintf(stderr, "  chroma coeffs:  ");
#line 280
        PrintByteCount((int const   *)((int const   *)(stats->residual_bytes[2])),
                       stats->coded_size, totals);
        }
      }
      {
#line 282
      fprintf(stderr, "    macroblocks:  ");
#line 283
      PrintPercents((int const   *)((int const   *)(stats->segment_size)), total);
#line 284
      fprintf(stderr, "      quantizer:  ");
#line 285
      PrintValues((int const   *)((int const   *)(stats->segment_quant)));
#line 286
      fprintf(stderr, "   filter level:  ");
#line 287
      PrintValues((int const   *)((int const   *)(stats->segment_level)));
      }
#line 288
      if (full_details) {
        {
#line 289
        fprintf(stderr, "------------------+---------");
#line 290
        fprintf(stderr, "+---------+---------+---------+-----------------\n");
#line 291
        fprintf(stderr, " segments total:  ");
#line 292
        __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:292)":);
#line 292
        PrintByteCount((int const   *)0, stats->coded_size, (int *)((void *)0));
        }
      }
    }
#line 295
    if (stats->lossless_size > 0) {
      {
#line 296
      PrintFullLosslessInfo(stats, "alpha");
      }
    }
  }
#line 299
  if ((unsigned long )pic->extra_info != (unsigned long )((void *)0)) {
#line 300
    mb_w = (pic->width + 15) / 16;
#line 301
    mb_h = (pic->height + 15) / 16;
#line 302
    type = pic->extra_info_type;
#line 304
    y = 0;
    {
#line 304
    while (1) {
      while_continue: /* CIL Label */ ;

#line 304
      if (! (y < mb_h)) {
#line 304
        goto while_break;
      }
#line 305
      x = 0;
      {
#line 305
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 305
        if (! (x < mb_w)) {
#line 305
          goto while_break___0;
        }
#line 306
        c = (int )*(pic->extra_info + (x + y * mb_w));
#line 307
        if (type == 1) {
          {
#line 308
          printf("%c", (int )*("+." + c));
          }
        } else
#line 309
        if (type == 2) {
          {
#line 310
          printf("%c", (int )*(".-*X" + c));
          }
        } else
#line 311
        if (type == 3) {
          {
#line 312
          printf("%.2d ", c);
          }
        } else
#line 313
        if (type == 6) {
          {
#line 314
          printf("%3d ", c);
          }
        } else
#line 313
        if (type == 7) {
          {
#line 314
          printf("%3d ", c);
          }
        } else {
          {
#line 316
          printf("0x%.2x ", c);
          }
        }
#line 305
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 319
      printf("\n");
#line 304
      y ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 309
  return;
}
}
#line 326 "/root/patchweave_new/13/examples/cwebp.c"
static int MyWriter(uint8_t *data , size_t data_size , WebPPicture *pic ) 
{ 
  FILE *out ;
  unsigned long __cil_tmp5 ;
  unsigned long tmp___0 ;

  {
#line 328
  out = (FILE *)pic->custom_ptr;
#line 329
  if (data_size) {
    {
#line 329
    __cil_tmp5 = fwrite((void const   *)data, data_size, 1UL, out);
#line 329
    tmp___0 = (unsigned long )(__cil_tmp5 == 1UL);
    }
  } else {
#line 329
    tmp___0 = 1UL;
  }
#line 329
  return ((int )tmp___0);
}
}
#line 333 "/root/patchweave_new/13/examples/cwebp.c"
static int DumpPicture(WebPPicture *picture , char const   *PGM_name ) 
{ 
  int y ;
  int uv_width ;
  int uv_height ;
  int stride ;
  int alpha_height ;
  int __cil_tmp8 ;
  int tmp___0 ;
  int height ;
  FILE *f ;
  FILE *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;

  {
  {
#line 335
  uv_width = (picture->width + 1) / 2;
#line 336
  uv_height = (picture->height + 1) / 2;
#line 337
  stride = (picture->width + 1) & -2;
#line 338
  __cil_tmp8 = WebPPictureHasTransparency(picture);
  }
#line 338
  if (__cil_tmp8) {
#line 338
    tmp___0 = picture->height;
  } else {
#line 338
    tmp___0 = 0;
  }
  {
#line 338
  alpha_height = tmp___0;
#line 340
  height = (picture->height + uv_height) + alpha_height;
#line 341
  __cil_tmp12 = fopen(PGM_name, "wb");
#line 341
  f = __cil_tmp12;
  }
#line 342
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 342
    return (0);
  }
  {
#line 343
  fprintf(f, "P5\n%d %d\n255\n", stride, height);
#line 344
  y = 0;
  }
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;

#line 344
    if (! (y < picture->height)) {
#line 344
      goto while_break;
    }
    {
#line 345
    __cil_tmp13 = fwrite((void const   *)(picture->y + y * picture->y_stride), (unsigned long )picture->width,
                         1UL, f);
    }
#line 345
    if (__cil_tmp13 != 1UL) {
#line 346
      return (0);
    }
#line 347
    if (picture->width & 1) {
      {
#line 347
      fputc(0, f);
      }
    }
#line 344
    y ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 349
  y = 0;
  {
#line 349
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 349
    if (! (y < uv_height)) {
#line 349
      goto while_break___0;
    }
    {
#line 350
    __cil_tmp14 = fwrite((void const   *)(picture->u + y * picture->uv_stride), (unsigned long )uv_width,
                         1UL, f);
    }
#line 350
    if (__cil_tmp14 != 1UL) {
#line 351
      return (0);
    }
    {
#line 352
    __cil_tmp15 = fwrite((void const   *)(picture->v + y * picture->uv_stride), (unsigned long )uv_width,
                         1UL, f);
    }
#line 352
    if (__cil_tmp15 != 1UL) {
#line 353
      return (0);
    }
#line 349
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 355
  y = 0;
  {
#line 355
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 355
    if (! (y < alpha_height)) {
#line 355
      goto while_break___1;
    }
    {
#line 356
    __cil_tmp16 = fwrite((void const   *)(picture->a + y * picture->a_stride), (unsigned long )picture->width,
                         1UL, f);
    }
#line 356
    if (__cil_tmp16 != 1UL) {
#line 357
      return (0);
    }
#line 358
    if (picture->width & 1) {
      {
#line 358
      fputc(0, f);
      }
    }
#line 355
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 360
  fclose(f);
  }
#line 361
  return (1);
}
}
#line 374 "/root/patchweave_new/13/examples/cwebp.c"
static int const   kChunkHeaderSize  =    (int const   )8;
#line 375 "/root/patchweave_new/13/examples/cwebp.c"
static int const   kTagSize  =    (int const   )4;
#line 377 "/root/patchweave_new/13/examples/cwebp.c"
static void PrintMetadataInfo(Metadata *metadata , int metadata_written ) 
{ 


  {
#line 379
  if ((unsigned long )metadata == (unsigned long )((void *)0)) {
#line 379
    return;
  } else
#line 379
  if (metadata_written == 0) {
#line 379
    return;
  }
  {
#line 381
  fprintf(stderr, "Metadata:\nl~\210U");
  }
#line 382
  if (metadata_written & 2) {
    {
#line 383
    fprintf(stderr, "  * ICC profile:  %6d bytes\n\210U", (int )metadata->iccp.size);
    }
  }
#line 385
  if (metadata_written & 1) {
    {
#line 386
    fprintf(stderr, "  * EXIF data:    %6d bytes\n", (int )metadata->exif.size);
    }
  }
#line 388
  if (metadata_written & 4) {
    {
#line 389
    fprintf(stderr, "  * XMP data:     %6d bytes\n", (int )metadata->xmp.size);
    }
  }
#line 392
  return;
}
}
#line 394 "/root/patchweave_new/13/examples/cwebp.c"
static int WriteLE(FILE *out , uint32_t val , int num ) 
{ 
  uint8_t buf[4] ;
  int i ;
  unsigned long __cil_tmp6 ;

  {
#line 397
  i = 0;
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;

#line 397
    if (! (i < num)) {
#line 397
      goto while_break;
    }
#line 398
    buf[i] = (uint8_t )(val & 255U);
#line 399
    val >>= 8;
#line 397
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 401
  __cil_tmp6 = fwrite((void const   *)(buf), (unsigned long )num, 1UL, out);
  }
#line 401
  return (__cil_tmp6 == 1UL);
}
}
#line 404 "/root/patchweave_new/13/examples/cwebp.c"
static int WriteLE24(FILE *out , uint32_t val ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 405
  __cil_tmp3 = WriteLE(out, val, 3);
  }
#line 405
  return (__cil_tmp3);
}
}
#line 408 "/root/patchweave_new/13/examples/cwebp.c"
static int WriteLE32(FILE *out , uint32_t val ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 409
  __cil_tmp3 = WriteLE(out, val, 4);
  }
#line 409
  return (__cil_tmp3);
}
}
#line 412 "/root/patchweave_new/13/examples/cwebp.c"
static int WriteMetadataChunk(FILE *out , char const   *fourcc , MetadataPayload *payload ) 
{ 
  uint8_t zero ;
  size_t need_padding ;
  int ok ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 414
  zero = (uint8_t )0;
#line 415
  need_padding = payload->size & 1UL;
#line 416
  __cil_tmp7 = fwrite((void const   *)fourcc, (unsigned long )kTagSize, 1UL, out);
#line 416
  ok = __cil_tmp7 == 1UL;
#line 417
  __cil_tmp8 = WriteLE32(out, (uint32_t )payload->size);
  }
#line 417
  if (ok) {
#line 417
    if (__cil_tmp8) {
#line 417
      tmp___0 = 1;
    } else {
#line 417
      tmp___0 = 0;
    }
  } else {
#line 417
    tmp___0 = 0;
  }
  {
#line 417
  ok = tmp___0;
#line 418
  __cil_tmp9 = fwrite((void const   *)payload->bytes, payload->size, 1UL, out);
  }
#line 418
  if (ok) {
#line 418
    if (__cil_tmp9 == 1UL) {
#line 418
      tmp___1 = 1;
    } else {
#line 418
      tmp___1 = 0;
    }
  } else {
#line 418
    tmp___1 = 0;
  }
  {
#line 418
  ok = tmp___1;
#line 419
  __cil_tmp10 = fwrite((void const   *)(& zero), need_padding, need_padding, out);
  }
#line 419
  if (ok) {
#line 419
    if (__cil_tmp10 == need_padding) {
#line 419
      tmp___2 = 1;
    } else {
#line 419
      tmp___2 = 0;
    }
  } else {
#line 419
    tmp___2 = 0;
  }
#line 419
  return (tmp___2);
}
}
#line 424 "/root/patchweave_new/13/examples/cwebp.c"
static int UpdateFlagsAndSize(MetadataPayload *payload , int keep , int flag , uint32_t *vp8x_flags ,
                              uint64_t *metadata_size ) 
{ 


  {
#line 427
  if ((unsigned long )payload->bytes != (unsigned long )((void *)0)) {
#line 427
    if (keep) {
#line 427
      if (payload->size > 0UL) {
#line 428
        *vp8x_flags |= (unsigned int )flag;
#line 429
        *metadata_size += ((unsigned long )kChunkHeaderSize + payload->size) + (payload->size & 1UL);
#line 430
        return (1);
      }
    }
  }
#line 432
  return (0);
}
}
#line 439 "/root/patchweave_new/13/examples/cwebp.c"
static int WriteWebPWithMetadata(FILE *out , WebPPicture *picture , WebPMemoryWriter *memory_writer ,
                                 Metadata *metadata , int keep_metadata , int *metadata_written ) 
{ 
  char kVP8XHeader[9] ;
  int kAlphaFlag ;
  int kEXIFFlag ;
  int kICCPFlag ;
  int kXMPFlag ;
  size_t kRiffHeaderSize ;
  size_t kMaxChunkPayload ;
  size_t kMinSize ;
  uint32_t flags ;
  uint64_t metadata_size ;
  int write_exif ;
  int __cil_tmp18 ;
  int write_iccp ;
  int __cil_tmp20 ;
  int write_xmp ;
  int __cil_tmp22 ;
  uint8_t *webp ;
  size_t webp_size ;
  int kVP8XChunkSize ;
  int has_vp8x ;
  int __cil_tmp27 ;
  uint32_t riff_size ;
  int tmp___0 ;
  int ok ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int is_lossless ;
  int __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 445
  strcpy(kVP8XHeader, "VP8X\n");
#line 446
  kAlphaFlag = 16;
#line 447
  kEXIFFlag = 8;
#line 448
  kICCPFlag = 32;
#line 449
  kXMPFlag = 4;
#line 450
  kRiffHeaderSize = (size_t )12;
#line 451
  kMaxChunkPayload = (size_t )((-1 - (int )kChunkHeaderSize) - 1);
#line 452
  kMinSize = kRiffHeaderSize + (unsigned long )kChunkHeaderSize;
#line 453
  flags = (uint32_t )0;
#line 454
  metadata_size = (uint64_t )0;
#line 455
  __cil_tmp18 = UpdateFlagsAndSize(& metadata->exif, ! (! (keep_metadata & 1)), kEXIFFlag,
                                   & flags, & metadata_size);
#line 455
  write_exif = __cil_tmp18;
#line 458
  __cil_tmp20 = UpdateFlagsAndSize(& metadata->iccp, ! (! (keep_metadata & 2)), kICCPFlag,
                                   & flags, & metadata_size);
#line 458
  write_iccp = __cil_tmp20;
#line 461
  __cil_tmp22 = UpdateFlagsAndSize(& metadata->xmp, ! (! (keep_metadata & 4)), kXMPFlag,
                                   & flags, & metadata_size);
#line 461
  write_xmp = __cil_tmp22;
#line 464
  webp = memory_writer->mem;
#line 465
  webp_size = memory_writer->size;
#line 467
  *metadata_written = 0;
  }
#line 469
  if (webp_size < kMinSize) {
#line 469
    return (0);
  }
#line 470
  if ((webp_size - (unsigned long )kChunkHeaderSize) + metadata_size > kMaxChunkPayload) {
    {
#line 471
    fprintf(stderr, "Error! Addition of metadata would exceed container size limit.\n");
    }
#line 473
    return (0);
  }
#line 476
  if (metadata_size > 0UL) {
    {
#line 477
    kVP8XChunkSize = 18;
#line 478
    __cil_tmp27 = memcmp((void const   *)(webp + kRiffHeaderSize), (void const   *)"VP8X",
                         (unsigned long )kTagSize);
#line 478
    has_vp8x = ! __cil_tmp27;
    }
#line 479
    if (has_vp8x) {
#line 479
      tmp___0 = 0;
    } else {
#line 479
      tmp___0 = kVP8XChunkSize;
    }
    {
#line 479
    riff_size = (uint32_t )(((webp_size - (unsigned long )kChunkHeaderSize) + (unsigned long )tmp___0) + metadata_size);
#line 483
    __cil_tmp31 = fwrite((void const   *)webp, (unsigned long )kTagSize, 1UL, out);
#line 483
    ok = __cil_tmp31 == 1UL;
#line 485
    __cil_tmp32 = WriteLE32(out, riff_size);
    }
#line 485
    if (ok) {
#line 485
      if (__cil_tmp32) {
#line 485
        tmp___1 = 1;
      } else {
#line 485
        tmp___1 = 0;
      }
    } else {
#line 485
      tmp___1 = 0;
    }
    {
#line 485
    ok = tmp___1;
#line 486
    webp += kChunkHeaderSize;
#line 487
    webp_size -= (unsigned long )kChunkHeaderSize;
#line 489
    __cil_tmp33 = fwrite((void const   *)webp, (unsigned long )kTagSize, 1UL, out);
    }
#line 489
    if (ok) {
#line 489
      if (__cil_tmp33 == 1UL) {
#line 489
        tmp___2 = 1;
      } else {
#line 489
        tmp___2 = 0;
      }
    } else {
#line 489
      tmp___2 = 0;
    }
#line 489
    ok = tmp___2;
#line 490
    webp += kTagSize;
#line 491
    webp_size -= (unsigned long )kTagSize;
#line 492
    if (has_vp8x) {
      {
#line 493
      *(webp + kChunkHeaderSize) = (uint8_t )((int )*(webp + kChunkHeaderSize) | (int )((uint8_t )(flags & 255U)));
#line 494
      __cil_tmp34 = fwrite((void const   *)webp, (unsigned long )kVP8XChunkSize, 1UL,
                           out);
      }
#line 494
      if (ok) {
#line 494
        if (__cil_tmp34 == 1UL) {
#line 494
          tmp___3 = 1;
        } else {
#line 494
          tmp___3 = 0;
        }
      } else {
#line 494
        tmp___3 = 0;
      }
#line 494
      ok = tmp___3;
#line 495
      webp_size -= (unsigned long )kVP8XChunkSize;
    } else {
      {
#line 497
      __cil_tmp36 = memcmp((void const   *)webp, (void const   *)"VP8L", (unsigned long )kTagSize);
#line 497
      is_lossless = ! __cil_tmp36;
      }
#line 499
      if (is_lossless) {
#line 499
        flags |= (unsigned int )kAlphaFlag;
      }
      {
#line 500
      __cil_tmp37 = fwrite((void const   *)((char const   *)(kVP8XHeader)), (unsigned long )kChunkHeaderSize,
                           1UL, out);
      }
#line 500
      if (ok) {
#line 500
        if (__cil_tmp37 == 1UL) {
#line 500
          tmp___4 = 1;
        } else {
#line 500
          tmp___4 = 0;
        }
      } else {
#line 500
        tmp___4 = 0;
      }
      {
#line 500
      ok = tmp___4;
#line 501
      __cil_tmp38 = WriteLE32(out, flags);
      }
#line 501
      if (ok) {
#line 501
        if (__cil_tmp38) {
#line 501
          tmp___5 = 1;
        } else {
#line 501
          tmp___5 = 0;
        }
      } else {
#line 501
        tmp___5 = 0;
      }
      {
#line 501
      ok = tmp___5;
#line 502
      __cil_tmp39 = WriteLE24(out, (uint32_t )(picture->width - 1));
      }
#line 502
      if (ok) {
#line 502
        if (__cil_tmp39) {
#line 502
          tmp___6 = 1;
        } else {
#line 502
          tmp___6 = 0;
        }
      } else {
#line 502
        tmp___6 = 0;
      }
      {
#line 502
      ok = tmp___6;
#line 503
      __cil_tmp40 = WriteLE24(out, (uint32_t )(picture->height - 1));
      }
#line 503
      if (ok) {
#line 503
        if (__cil_tmp40) {
#line 503
          tmp___7 = 1;
        } else {
#line 503
          tmp___7 = 0;
        }
      } else {
#line 503
        tmp___7 = 0;
      }
#line 503
      ok = tmp___7;
    }
#line 505
    if (write_iccp) {
      {
#line 506
      __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:506)":);
#line 506
      __cil_tmp41 = WriteMetadataChunk(out, (char const   *)0, & metadata->iccp);
      }
#line 506
      if (ok) {
#line 506
        if (__cil_tmp41) {
#line 506
          tmp___8 = 1;
        } else {
#line 506
          tmp___8 = 0;
        }
      } else {
#line 506
        tmp___8 = 0;
      }
#line 506
      ok = tmp___8;
#line 507
      *metadata_written |= 2;
    }
    {
#line 510
    __cil_tmp42 = fwrite((void const   *)webp, webp_size, 1UL, out);
    }
#line 510
    if (ok) {
#line 510
      if (__cil_tmp42 == 1UL) {
#line 510
        tmp___9 = 1;
      } else {
#line 510
        tmp___9 = 0;
      }
    } else {
#line 510
      tmp___9 = 0;
    }
#line 510
    ok = tmp___9;
#line 511
    if (write_exif) {
      {
#line 512
      __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:512)":);
#line 512
      __cil_tmp43 = WriteMetadataChunk(out, (char const   *)0, & metadata->exif);
      }
#line 512
      if (ok) {
#line 512
        if (__cil_tmp43) {
#line 512
          tmp___10 = 1;
        } else {
#line 512
          tmp___10 = 0;
        }
      } else {
#line 512
        tmp___10 = 0;
      }
#line 512
      ok = tmp___10;
#line 513
      *metadata_written |= 1;
    }
#line 515
    if (write_xmp) {
      {
#line 516
      __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:516)":);
#line 516
      __cil_tmp44 = WriteMetadataChunk(out, (char const   *)0, & metadata->xmp);
      }
#line 516
      if (ok) {
#line 516
        if (__cil_tmp44) {
#line 516
          tmp___11 = 1;
        } else {
#line 516
          tmp___11 = 0;
        }
      } else {
#line 516
        tmp___11 = 0;
      }
#line 516
      ok = tmp___11;
#line 517
      *metadata_written |= 4;
    }
#line 519
    return (ok);
  } else {
    {
#line 522
    __cil_tmp45 = fwrite((void const   *)webp, webp_size, 1UL, out);
    }
#line 522
    return (__cil_tmp45 == 1UL);
  }
}
}
#line 528 "/root/patchweave_new/13/examples/cwebp.c"
static int ProgressReport(int percent , WebPPicture *picture ) 
{ 


  {
  {
#line 529
  printf("[%s]: %3d %%      \r", (char *)picture->user_data, percent);
#line 531
  fflush(stdout);
  }
#line 532
  return (1);
}
}
#line 537 "/root/patchweave_new/13/examples/cwebp.c"
static void HelpShort(void) 
{ 


  {
  {
#line 538
  printf("Usage:\n\n\220");
#line 539
  printf("   cwebp [options] -q quality input.png -o output.webp\n\n\220");
#line 540
  printf("where quality is between 0 (poor) to 100 (very good).\n");
#line 541
  printf("Typical value is around 80.\n\n");
#line 542
  printf("Try -longhelp for an exhaustive list of advanced options.\n");
  }
#line 544
  return;
}
}
#line 545 "/root/patchweave_new/13/examples/cwebp.c"
static void HelpLong(void) 
{ 


  {
  {
#line 546
  printf("Usage:\n");
#line 547
  printf(" cwebp [-preset <...>] [options] in_file [-o out_file]\n\n\220");
#line 548
  printf("If input size (-s) for an image is not specified, it is assumed to be a PNG, JPEG or TIFF file.\n\210U");
#line 553
  printf("options:\n");
#line 554
  printf("  -h / -help  ............ short help\n");
#line 555
  printf("  -H / -longhelp  ........ long help\nU");
#line 556
  printf("  -q <float> ............. quality factor (0:small..100:big)\nU");
#line 557
  printf("  -alpha_q <int> ......... Transparency-compression quality (0..100).\n");
#line 559
  printf("  -preset <string> ....... Preset setting, one of:\n");
#line 560
  printf("                            default, photo, picture,\n");
#line 561
  printf("                            drawing, icon, text\n\220");
#line 562
  printf("     -preset must come first, as it overwrites other parameters.\220");
#line 563
  printf("\n");
#line 564
  printf("  -m <int> ............... compression method (0=fast, 6=slowest)\n");
#line 565
  printf("  -segments <int> ........ number of segments to use (1..4)\n\210U");
#line 566
  printf("  -size <int> ............ Target size (in bytes)\n\200~\210U");
#line 567
  printf("  -psnr <float> .......... Target PSNR (in dB. typically: 42)\n");
#line 568
  printf("\n");
#line 569
  printf("  -s <int> <int> ......... Input size (width x height) for YUV\n");
#line 570
  printf("  -sns <int> ............. Spatial Noise Shaping (0:off, 100:max)\n");
#line 571
  printf("  -f <int> ............... filter strength (0=off..100)\n\220");
#line 572
  printf("  -sharpness <int> ....... filter sharpness (0:most .. 7:least sharp)\n");
#line 574
  printf("  -strong ................ use strong filter instead of simple (default).\n");
#line 576
  printf("  -nostrong .............. use simple filter instead of strong.\n\220");
#line 577
  printf("  -partition_limit <int> . limit quality to fit the 512k limit on\n");
#line 578
  printf("                           the first partition (0=no degradation ... 100=full)\n~\210U");
#line 580
  printf("  -pass <int> ............ analysis pass number (1..10)\n\220");
#line 581
  printf("  -crop <x> <y> <w> <h> .. crop picture with the given rectangle\n\262\200~\210U");
#line 582
  printf("  -resize <w> <h> ........ resize picture (after any cropping)\n");
#line 583
  printf("  -mt .................... use multi-threading if available\n");
#line 584
  printf("  -low_memory ............ reduce memory usage (slower encoding)\n\271\200~\210U");
#line 588
  printf("  -map <int> ............. print map of extra info.\n");
#line 589
  printf("  -print_psnr ............ prints averaged PSNR distortion.\n\210U");
#line 590
  printf("  -print_ssim ............ prints averaged SSIM distortion.\n\210U");
#line 591
  printf("  -print_lsim ............ prints local-similarity distortion.\n");
#line 592
  printf("  -d <file.pgm> .......... dump the compressed output (PGM file).\n\200~\210U");
#line 593
  printf("  -alpha_method <int> .... Transparency-compression method (0..1)\n");
#line 594
  printf("  -alpha_filter <string> . predictive filtering for alpha plane.\n");
#line 595
  printf("                           One of: none, fast (default) or best.\na\200~\210U");
#line 596
  printf("  -alpha_cleanup ......... Clean RGB values in transparent area.\n`\200~\210U");
#line 597
  printf("  -blend_alpha <hex> ..... Blend colors against background color\n                           expressed as RGB values written in\n                           hexadecimal, e.g. 0xc0e0d0 for red=0xc0\n                           green=0xe0 and blue=0xd0.\n~\210U");
#line 601
  printf("  -noalpha ............... discard any transparency information.\n");
#line 602
  printf("  -lossless .............. Encode image losslessly.\n\210U");
#line 603
  printf("  -hint <string> ......... Specify image characteristics hint.\n");
#line 604
  printf("                           One of: photo, picture or graph\n");
#line 606
  printf("\n");
#line 607
  printf("  -metadata <string> ..... comma separated list of metadata to\n");
#line 608
  printf("                           ");
#line 609
  printf("copy from the input to the output if present.\n");
#line 610
  printf("                           Valid values: all, none (default), exif, icc, xmp\n");
#line 613
  printf("\n");
#line 614
  printf("  -short ................. condense printed message\n");
#line 615
  printf("  -quiet ................. don\'t print anything.\nU\200~\210U");
#line 616
  printf("  -version ............... print version number and exit.\n");
#line 618
  printf("  -noasm ................. disable all assembly optimizations.\n");
#line 620
  printf("  -v ..................... verbose, e.g. print encoding/decoding times\n~\210U");
#line 622
  printf("  -progress .............. report encoding progress\n");
#line 623
  printf("\nby~\210U");
#line 624
  printf("Experimental Options:\n");
#line 625
  printf("  -jpeg_like ............. Roughly match expected JPEG size.\n");
#line 626
  printf("  -af .................... auto-adjust filter strength.\n\220");
#line 627
  printf("  -pre <int> ............. pre-processing filter\n");
#line 628
  printf("\n");
  }
#line 630
  return;
}
}
#line 634 "/root/patchweave_new/13/examples/cwebp.c"
static char const   * const  kErrorMessages[11]  = 
#line 634
  {      (char const   */* const  */)"OK\200~\210U",      (char const   */* const  */)"OUT_OF_MEMORY: Out of memory allocating objects",      (char const   */* const  */)"BITSTREAM_OUT_OF_MEMORY: Out of memory re-allocating byte buffer\323\001 ~\001",      (char const   */* const  */)"NULL_PARAMETER: NULL parameter passed to function\356\200~\210U", 
        (char const   */* const  */)"INVALID_CONFIGURATION: configuration is invalid",      (char const   */* const  */)"BAD_DIMENSION: Bad picture dimension. Maximum width and height allowed is 16383 pixels.",      (char const   */* const  */)"PARTITION0_OVERFLOW: Partition #0 is too big to fit 512k.\nTo reduce the size of this partition, try using less segments with the -segments option, and eventually reduce the number of header bits using -partition_limit. More details are available in the manual (`man cwebp`)K\200~\210U",      (char const   */* const  */)"PARTITION_OVERFLOW: Partition is too big to fit 16M~\210U", 
        (char const   */* const  */)"BAD_WRITE: Picture writer returned an I/O error",      (char const   */* const  */)"FILE_TOO_BIG: File would be too big to fit in 4G\001",      (char const   */* const  */)"USER_ABORT: encoding abort requested by user"};
#line 775 "/root/patchweave_new/13/examples/cwebp.c"
static struct __anonstruct_1085 kTokens[5]  ;
#line 801 "/root/patchweave_new/13/examples/cwebp.c"
static char const   *distortion_names[3]  ;
#line 655 "/root/patchweave_new/13/examples/cwebp.c"
int main(int argc , char const   **argv ) 
{ 
  int return_value ;
  char const   *in_file ;
  char const   *out_file ;
  char const   *dump_file ;
  FILE *out ;
  int c ;
  int short_output ;
  int quiet ;
  int keep_alpha ;
  int blend_alpha ;
  uint32_t background_color ;
  int crop ;
  int crop_x ;
  int crop_y ;
  int crop_w ;
  int crop_h ;
  int resize_w ;
  int resize_h ;
  int show_progress ;
  int keep_metadata ;
  int metadata_written ;
  WebPPicture picture ;
  int print_distortion ;
  WebPPicture original_picture ;
  WebPConfig config ;
  WebPAuxStats stats ;
  WebPMemoryWriter memory_writer ;
  Metadata metadata ;
  Stopwatch stop_watch ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  long __cil_tmp48 ;
  int __cil_tmp49 ;
  long __cil_tmp50 ;
  int __cil_tmp51 ;
  double __cil_tmp52 ;
  int __cil_tmp53 ;
  long __cil_tmp54 ;
  int __cil_tmp55 ;
  long __cil_tmp56 ;
  int __cil_tmp57 ;
  int tmp___0 ;
  int __cil_tmp59 ;
  long __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  long __cil_tmp72 ;
  int __cil_tmp73 ;
  double __cil_tmp74 ;
  int __cil_tmp75 ;
  long __cil_tmp76 ;
  int __cil_tmp77 ;
  long __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  long __cil_tmp86 ;
  int __cil_tmp87 ;
  long __cil_tmp88 ;
  int __cil_tmp89 ;
  long __cil_tmp90 ;
  int __cil_tmp91 ;
  long __cil_tmp92 ;
  int __cil_tmp93 ;
  long __cil_tmp94 ;
  int __cil_tmp95 ;
  long __cil_tmp96 ;
  int __cil_tmp97 ;
  long __cil_tmp98 ;
  long __cil_tmp99 ;
  long __cil_tmp100 ;
  long __cil_tmp101 ;
  int __cil_tmp102 ;
  long __cil_tmp103 ;
  long __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int version ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  enum WebPPreset preset ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  int __cil_tmp118 ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;
  size_t kNumTokens ;
  char const   *start ;
  char const   *end ;
  unsigned long __cil_tmp125 ;
  size_t i ;
  char const   *token ;
  char *__cil_tmp128 ;
  unsigned long __cil_tmp129 ;
  unsigned long __cil_tmp130 ;
  int __cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  Metadata *tmp___1 ;
  int __cil_tmp135 ;
  int (*tmp___2)(int percent , WebPPicture * const  picture ) ;
  double read_time ;
  double __cil_tmp138 ;
  int __cil_tmp140 ;
  int __cil_tmp141 ;
  int __cil_tmp142 ;
  double encode_time ;
  double __cil_tmp144 ;
  int __cil_tmp145 ;
  int __cil_tmp146 ;
  float values[5] ;

  {
  {
#line 656
  return_value = -1;
#line 657
  in_file = (char const   *)((void *)0);
#line 657
  out_file = (char const   *)((void *)0);
#line 657
  dump_file = (char const   *)((void *)0);
#line 658
  out = (FILE *)((void *)0);
#line 660
  short_output = 0;
#line 661
  quiet = 0;
#line 662
  keep_alpha = 1;
#line 663
  blend_alpha = 0;
#line 664
  background_color = 16777215U;
#line 665
  crop = 0;
#line 665
  crop_x = 0;
#line 665
  crop_y = 0;
#line 665
  crop_w = 0;
#line 665
  crop_h = 0;
#line 666
  resize_w = 0;
#line 666
  resize_h = 0;
#line 667
  show_progress = 0;
#line 668
  keep_metadata = 0;
#line 669
  metadata_written = 0;
#line 671
  print_distortion = -1;
#line 679
  MetadataInit(& metadata);
#line 680
  WebPMemoryWriterInit(& memory_writer);
#line 681
  __cil_tmp34 = WebPConfigInit___0(& config);
#line 681
  __cil_tmp33 = WebPPictureInit(& original_picture);
#line 681
  __cil_tmp32 = WebPPictureInit(& picture);
  }
#line 681
  if (! __cil_tmp32) {
    {
#line 684
    fprintf(stderr, "Error! Version mismatch!\n");
    }
#line 685
    return (-1);
  } else
#line 681
  if (! __cil_tmp33) {
    {
#line 684
    fprintf(stderr, "Error! Version mismatch!\n");
    }
#line 685
    return (-1);
  } else
#line 681
  if (! __cil_tmp34) {
    {
#line 684
    fprintf(stderr, "Error! Version mismatch!\n");
    }
#line 685
    return (-1);
  }
#line 688
  if (argc == 1) {
    {
#line 689
    HelpShort();
    }
#line 690
    return (0);
  }
#line 693
  c = 1;
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;

#line 693
    if (! (c < argc)) {
#line 693
      goto while_break;
    }
    {
#line 694
    __cil_tmp36 = strcmp(*(argv + c), "-help");
#line 694
    __cil_tmp35 = strcmp(*(argv + c), "-h");
    }
#line 694
    if (! __cil_tmp35) {
      {
#line 695
      HelpShort();
      }
#line 696
      return (0);
    } else
#line 694
    if (! __cil_tmp36) {
      {
#line 695
      HelpShort();
      }
#line 696
      return (0);
    } else {
      {
#line 697
      __cil_tmp38 = strcmp(*(argv + c), "-longhelp");
#line 697
      __cil_tmp37 = strcmp(*(argv + c), "-H");
      }
#line 697
      if (! __cil_tmp37) {
        {
#line 698
        HelpLong();
        }
#line 699
        return (0);
      } else
#line 697
      if (! __cil_tmp38) {
        {
#line 698
        HelpLong();
        }
#line 699
        return (0);
      } else {
        {
#line 700
        __cil_tmp39 = strcmp(*(argv + c), "-o");
        }
#line 700
        if (! __cil_tmp39) {
#line 700
          if (c < argc - 1) {
#line 701
            c ++;
#line 701
            out_file = *(argv + c);
          } else {
#line 700
            goto _L___38;
          }
        } else {
          _L___38: 
          {
#line 702
          __cil_tmp40 = strcmp(*(argv + c), "-d");
          }
#line 702
          if (! __cil_tmp40) {
#line 702
            if (c < argc - 1) {
#line 703
              c ++;
#line 703
              dump_file = *(argv + c);
#line 704
              config.show_compressed = 1;
            } else {
#line 702
              goto _L___37;
            }
          } else {
            _L___37: 
            {
#line 705
            __cil_tmp41 = strcmp(*(argv + c), "-print_psnr");
            }
#line 705
            if (! __cil_tmp41) {
#line 706
              config.show_compressed = 1;
#line 707
              print_distortion = 0;
            } else {
              {
#line 708
              __cil_tmp42 = strcmp(*(argv + c), "-print_ssim");
              }
#line 708
              if (! __cil_tmp42) {
#line 709
                config.show_compressed = 1;
#line 710
                print_distortion = 1;
              } else {
                {
#line 711
                __cil_tmp43 = strcmp(*(argv + c), "-print_lsim");
                }
#line 711
                if (! __cil_tmp43) {
#line 712
                  config.show_compressed = 1;
#line 713
                  print_distortion = 2;
                } else {
                  {
#line 714
                  __cil_tmp44 = strcmp(*(argv + c), "-short");
                  }
#line 714
                  if (! __cil_tmp44) {
#line 715
                    short_output ++;
                  } else {
                    {
#line 716
                    __cil_tmp46 = strcmp(*(argv + c), "-s");
                    }
#line 716
                    if (! __cil_tmp46) {
#line 716
                      if (c < argc - 2) {
                        {
#line 717
                        c ++;
#line 717
                        __cil_tmp47 = strtol(*(argv + c), (char **)((void *)0), 0);
#line 717
                        picture.width = (int )__cil_tmp47;
#line 718
                        c ++;
#line 718
                        __cil_tmp48 = strtol(*(argv + c), (char **)((void *)0), 0);
#line 718
                        picture.height = (int )__cil_tmp48;
                        }
                      } else {
#line 716
                        goto _L___36;
                      }
                    } else {
                      _L___36: 
                      {
#line 719
                      __cil_tmp49 = strcmp(*(argv + c), "-m");
                      }
#line 719
                      if (! __cil_tmp49) {
#line 719
                        if (c < argc - 1) {
                          {
#line 720
                          c ++;
#line 720
                          __cil_tmp50 = strtol(*(argv + c), (char **)((void *)0),
                                               0);
#line 720
                          config.method = (int )__cil_tmp50;
                          }
                        } else {
#line 719
                          goto _L___35;
                        }
                      } else {
                        _L___35: 
                        {
#line 721
                        __cil_tmp51 = strcmp(*(argv + c), "-q");
                        }
#line 721
                        if (! __cil_tmp51) {
#line 721
                          if (c < argc - 1) {
                            {
#line 722
                            c ++;
#line 722
                            __cil_tmp52 = strtod(*(argv + c), (char **)((void *)0));
#line 722
                            config.quality = (float )__cil_tmp52;
                            }
                          } else {
#line 721
                            goto _L___34;
                          }
                        } else {
                          _L___34: 
                          {
#line 723
                          __cil_tmp53 = strcmp(*(argv + c), "-alpha_q\220");
                          }
#line 723
                          if (! __cil_tmp53) {
#line 723
                            if (c < argc - 1) {
                              {
#line 724
                              c ++;
#line 724
                              __cil_tmp54 = strtol(*(argv + c), (char **)((void *)0),
                                                   0);
#line 724
                              config.alpha_quality = (int )__cil_tmp54;
                              }
                            } else {
#line 723
                              goto _L___33;
                            }
                          } else {
                            _L___33: 
                            {
#line 725
                            __cil_tmp55 = strcmp(*(argv + c), "-alpha_method");
                            }
#line 725
                            if (! __cil_tmp55) {
#line 725
                              if (c < argc - 1) {
                                {
#line 726
                                c ++;
#line 726
                                __cil_tmp56 = strtol(*(argv + c), (char **)((void *)0),
                                                     0);
#line 726
                                config.alpha_compression = (int )__cil_tmp56;
                                }
                              } else {
#line 725
                                goto _L___32;
                              }
                            } else {
                              _L___32: 
                              {
#line 727
                              __cil_tmp57 = strcmp(*(argv + c), "-alpha_cleanup");
                              }
#line 727
                              if (! __cil_tmp57) {
#line 728
                                if (keep_alpha) {
#line 728
                                  tmp___0 = 2;
                                } else {
#line 728
                                  tmp___0 = 0;
                                }
#line 728
                                keep_alpha = tmp___0;
                              } else {
                                {
#line 729
                                __cil_tmp59 = strcmp(*(argv + c), "-blend_alpha");
                                }
#line 729
                                if (! __cil_tmp59) {
#line 729
                                  if (c < argc - 1) {
                                    {
#line 730
                                    blend_alpha = 1;
#line 731
                                    c ++;
#line 731
                                    __cil_tmp60 = strtol(*(argv + c), (char **)((void *)0),
                                                         16);
#line 731
                                    background_color = (uint32_t )__cil_tmp60;
#line 732
                                    background_color &= 16777215U;
                                    }
                                  } else {
#line 729
                                    goto _L___31;
                                  }
                                } else {
                                  _L___31: 
                                  {
#line 733
                                  __cil_tmp61 = strcmp(*(argv + c), "-alpha_filter");
                                  }
#line 733
                                  if (! __cil_tmp61) {
#line 733
                                    if (c < argc - 1) {
                                      {
#line 734
                                      c ++;
#line 735
                                      __cil_tmp62 = strcmp(*(argv + c), "none");
                                      }
#line 735
                                      if (! __cil_tmp62) {
#line 736
                                        config.alpha_filtering = 0;
                                      } else {
                                        {
#line 737
                                        __cil_tmp63 = strcmp(*(argv + c), "fast");
                                        }
#line 737
                                        if (! __cil_tmp63) {
#line 738
                                          config.alpha_filtering = 1;
                                        } else {
                                          {
#line 739
                                          __cil_tmp64 = strcmp(*(argv + c), "best");
                                          }
#line 739
                                          if (! __cil_tmp64) {
#line 740
                                            config.alpha_filtering = 2;
                                          } else {
                                            {
#line 742
                                            fprintf(stderr, "Error! Unrecognized alpha filter: %s\n",
                                                    *(argv + c));
                                            }
#line 743
                                            goto Error;
                                          }
                                        }
                                      }
                                    } else {
#line 733
                                      goto _L___30;
                                    }
                                  } else {
                                    _L___30: 
                                    {
#line 745
                                    __cil_tmp65 = strcmp(*(argv + c), "-noalpha\220");
                                    }
#line 745
                                    if (! __cil_tmp65) {
#line 746
                                      keep_alpha = 0;
                                    } else {
                                      {
#line 747
                                      __cil_tmp66 = strcmp(*(argv + c), "-lossless");
                                      }
#line 747
                                      if (! __cil_tmp66) {
#line 748
                                        config.lossless = 1;
                                      } else {
                                        {
#line 749
                                        __cil_tmp67 = strcmp(*(argv + c), "-hint");
                                        }
#line 749
                                        if (! __cil_tmp67) {
#line 749
                                          if (c < argc - 1) {
                                            {
#line 750
                                            c ++;
#line 751
                                            __cil_tmp68 = strcmp(*(argv + c), "photo");
                                            }
#line 751
                                            if (! __cil_tmp68) {
#line 752
                                              config.image_hint = (enum WebPImageHint___0 )((enum WebPImageHint )2);
                                            } else {
                                              {
#line 753
                                              __cil_tmp69 = strcmp(*(argv + c), "picture");
                                              }
#line 753
                                              if (! __cil_tmp69) {
#line 754
                                                config.image_hint = (enum WebPImageHint___0 )((enum WebPImageHint )1);
                                              } else {
                                                {
#line 755
                                                __cil_tmp70 = strcmp(*(argv + c),
                                                                     "graph");
                                                }
#line 755
                                                if (! __cil_tmp70) {
#line 756
                                                  config.image_hint = (enum WebPImageHint___0 )((enum WebPImageHint )3);
                                                } else {
                                                  {
#line 758
                                                  fprintf(stderr, "Error! Unrecognized image hint: %s\n",
                                                          *(argv + c));
                                                  }
#line 759
                                                  goto Error;
                                                }
                                              }
                                            }
                                          } else {
#line 749
                                            goto _L___29;
                                          }
                                        } else {
                                          _L___29: 
                                          {
#line 761
                                          __cil_tmp71 = strcmp(*(argv + c), "-size");
                                          }
#line 761
                                          if (! __cil_tmp71) {
#line 761
                                            if (c < argc - 1) {
                                              {
#line 762
                                              c ++;
#line 762
                                              __cil_tmp72 = strtol(*(argv + c), (char **)((void *)0),
                                                                   0);
#line 762
                                              config.target_size = (int )__cil_tmp72;
                                              }
                                            } else {
#line 761
                                              goto _L___28;
                                            }
                                          } else {
                                            _L___28: 
                                            {
#line 763
                                            __cil_tmp73 = strcmp(*(argv + c), "-psnr");
                                            }
#line 763
                                            if (! __cil_tmp73) {
#line 763
                                              if (c < argc - 1) {
                                                {
#line 764
                                                c ++;
#line 764
                                                __cil_tmp74 = strtod(*(argv + c),
                                                                     (char **)((void *)0));
#line 764
                                                config.target_PSNR = (float )__cil_tmp74;
                                                }
                                              } else {
#line 763
                                                goto _L___27;
                                              }
                                            } else {
                                              _L___27: 
                                              {
#line 765
                                              __cil_tmp75 = strcmp(*(argv + c), "-sns");
                                              }
#line 765
                                              if (! __cil_tmp75) {
#line 765
                                                if (c < argc - 1) {
                                                  {
#line 766
                                                  c ++;
#line 766
                                                  __cil_tmp76 = strtol(*(argv + c),
                                                                       (char **)((void *)0),
                                                                       0);
#line 766
                                                  config.sns_strength = (int )__cil_tmp76;
                                                  }
                                                } else {
#line 765
                                                  goto _L___26;
                                                }
                                              } else {
                                                _L___26: 
                                                {
#line 767
                                                __cil_tmp77 = strcmp(*(argv + c),
                                                                     "-f");
                                                }
#line 767
                                                if (! __cil_tmp77) {
#line 767
                                                  if (c < argc - 1) {
                                                    {
#line 768
                                                    c ++;
#line 768
                                                    __cil_tmp78 = strtol(*(argv + c),
                                                                         (char **)((void *)0),
                                                                         0);
#line 768
                                                    config.filter_strength = (int )__cil_tmp78;
                                                    }
                                                  } else {
#line 767
                                                    goto _L___25;
                                                  }
                                                } else {
                                                  _L___25: 
                                                  {
#line 769
                                                  __cil_tmp79 = strcmp(*(argv + c),
                                                                       "-af");
                                                  }
#line 769
                                                  if (! __cil_tmp79) {
#line 770
                                                    config.autofilter = 1;
                                                  } else {
                                                    {
#line 771
                                                    __cil_tmp80 = strcmp(*(argv + c),
                                                                         "-jpeg_like");
                                                    }
#line 771
                                                    if (! __cil_tmp80) {
#line 772
                                                      config.emulate_jpeg_size = 1;
                                                    } else {
                                                      {
#line 773
                                                      __cil_tmp81 = strcmp(*(argv + c),
                                                                           "-mt");
                                                      }
#line 773
                                                      if (! __cil_tmp81) {
#line 774
                                                        (config.thread_level) ++;
                                                      } else {
                                                        {
#line 775
                                                        __cil_tmp82 = strcmp(*(argv + c),
                                                                             "-low_memory");
                                                        }
#line 775
                                                        if (! __cil_tmp82) {
#line 776
                                                          config.low_memory = 1;
                                                        } else {
                                                          {
#line 777
                                                          __cil_tmp83 = strcmp(*(argv + c),
                                                                               "-strong");
                                                          }
#line 777
                                                          if (! __cil_tmp83) {
#line 778
                                                            config.filter_type = 1;
                                                          } else {
                                                            {
#line 779
                                                            __cil_tmp84 = strcmp(*(argv + c),
                                                                                 "-nostrong");
                                                            }
#line 779
                                                            if (! __cil_tmp84) {
#line 780
                                                              config.filter_type = 0;
                                                            } else {
                                                              {
#line 781
                                                              __cil_tmp85 = strcmp(*(argv + c),
                                                                                   "-sharpness");
                                                              }
#line 781
                                                              if (! __cil_tmp85) {
#line 781
                                                                if (c < argc - 1) {
                                                                  {
#line 782
                                                                  c ++;
#line 782
                                                                  __cil_tmp86 = strtol(*(argv + c),
                                                                                       (char **)((void *)0),
                                                                                       0);
#line 782
                                                                  config.filter_sharpness = (int )__cil_tmp86;
                                                                  }
                                                                } else {
#line 781
                                                                  goto _L___24;
                                                                }
                                                              } else {
                                                                _L___24: 
                                                                {
#line 783
                                                                __cil_tmp87 = strcmp(*(argv + c),
                                                                                     "-pass");
                                                                }
#line 783
                                                                if (! __cil_tmp87) {
#line 783
                                                                  if (c < argc - 1) {
                                                                    {
#line 784
                                                                    c ++;
#line 784
                                                                    __cil_tmp88 = strtol(*(argv + c),
                                                                                         (char **)((void *)0),
                                                                                         0);
#line 784
                                                                    config.pass = (int )__cil_tmp88;
                                                                    }
                                                                  } else {
#line 783
                                                                    goto _L___23;
                                                                  }
                                                                } else {
                                                                  _L___23: 
                                                                  {
#line 785
                                                                  __cil_tmp89 = strcmp(*(argv + c),
                                                                                       "-pre");
                                                                  }
#line 785
                                                                  if (! __cil_tmp89) {
#line 785
                                                                    if (c < argc - 1) {
                                                                      {
#line 786
                                                                      c ++;
#line 786
                                                                      __cil_tmp90 = strtol(*(argv + c),
                                                                                           (char **)((void *)0),
                                                                                           0);
#line 786
                                                                      config.preprocessing = (int )__cil_tmp90;
                                                                      }
                                                                    } else {
#line 785
                                                                      goto _L___22;
                                                                    }
                                                                  } else {
                                                                    _L___22: 
                                                                    {
#line 787
                                                                    __cil_tmp91 = strcmp(*(argv + c),
                                                                                         "-segments");
                                                                    }
#line 787
                                                                    if (! __cil_tmp91) {
#line 787
                                                                      if (c < argc - 1) {
                                                                        {
#line 788
                                                                        c ++;
#line 788
                                                                        __cil_tmp92 = strtol(*(argv + c),
                                                                                             (char **)((void *)0),
                                                                                             0);
#line 788
                                                                        config.segments = (int )__cil_tmp92;
                                                                        }
                                                                      } else {
#line 787
                                                                        goto _L___21;
                                                                      }
                                                                    } else {
                                                                      _L___21: 
                                                                      {
#line 789
                                                                      __cil_tmp93 = strcmp(*(argv + c),
                                                                                           "-partition_limit\220");
                                                                      }
#line 789
                                                                      if (! __cil_tmp93) {
#line 789
                                                                        if (c < argc - 1) {
                                                                          {
#line 790
                                                                          c ++;
#line 790
                                                                          __cil_tmp94 = strtol(*(argv + c),
                                                                                               (char **)((void *)0),
                                                                                               0);
#line 790
                                                                          config.partition_limit = (int )__cil_tmp94;
                                                                          }
                                                                        } else {
#line 789
                                                                          goto _L___20;
                                                                        }
                                                                      } else {
                                                                        _L___20: 
                                                                        {
#line 791
                                                                        __cil_tmp95 = strcmp(*(argv + c),
                                                                                             "-map");
                                                                        }
#line 791
                                                                        if (! __cil_tmp95) {
#line 791
                                                                          if (c < argc - 1) {
                                                                            {
#line 792
                                                                            c ++;
#line 792
                                                                            __cil_tmp96 = strtol(*(argv + c),
                                                                                                 (char **)((void *)0),
                                                                                                 0);
#line 792
                                                                            picture.extra_info_type = (int )__cil_tmp96;
                                                                            }
                                                                          } else {
#line 791
                                                                            goto _L___19;
                                                                          }
                                                                        } else {
                                                                          _L___19: 
                                                                          {
#line 801
                                                                          __cil_tmp97 = strcmp(*(argv + c),
                                                                                               "-crop");
                                                                          }
#line 801
                                                                          if (! __cil_tmp97) {
#line 801
                                                                            if (c < argc - 4) {
                                                                              {
#line 802
                                                                              crop = 1;
#line 803
                                                                              c ++;
#line 803
                                                                              __cil_tmp98 = strtol(*(argv + c),
                                                                                                   (char **)((void *)0),
                                                                                                   0);
#line 803
                                                                              crop_x = (int )__cil_tmp98;
#line 804
                                                                              c ++;
#line 804
                                                                              __cil_tmp99 = strtol(*(argv + c),
                                                                                                   (char **)((void *)0),
                                                                                                   0);
#line 804
                                                                              crop_y = (int )__cil_tmp99;
#line 805
                                                                              c ++;
#line 805
                                                                              __cil_tmp100 = strtol(*(argv + c),
                                                                                                    (char **)((void *)0),
                                                                                                    0);
#line 805
                                                                              crop_w = (int )__cil_tmp100;
#line 806
                                                                              c ++;
#line 806
                                                                              __cil_tmp101 = strtol(*(argv + c),
                                                                                                    (char **)((void *)0),
                                                                                                    0);
#line 806
                                                                              crop_h = (int )__cil_tmp101;
                                                                              }
                                                                            } else {
#line 801
                                                                              goto _L___18;
                                                                            }
                                                                          } else {
                                                                            _L___18: 
                                                                            {
#line 807
                                                                            __cil_tmp102 = strcmp(*(argv + c),
                                                                                                  "-resize");
                                                                            }
#line 807
                                                                            if (! __cil_tmp102) {
#line 807
                                                                              if (c < argc - 2) {
                                                                                {
#line 808
                                                                                c ++;
#line 808
                                                                                __cil_tmp103 = strtol(*(argv + c),
                                                                                                      (char **)((void *)0),
                                                                                                      0);
#line 808
                                                                                resize_w = (int )__cil_tmp103;
#line 809
                                                                                c ++;
#line 809
                                                                                __cil_tmp104 = strtol(*(argv + c),
                                                                                                      (char **)((void *)0),
                                                                                                      0);
#line 809
                                                                                resize_h = (int )__cil_tmp104;
                                                                                }
                                                                              } else {
#line 807
                                                                                goto _L___17;
                                                                              }
                                                                            } else {
                                                                              _L___17: 
                                                                              {
#line 811
                                                                              __cil_tmp105 = strcmp(*(argv + c),
                                                                                                    "-noasm");
                                                                              }
#line 811
                                                                              if (! __cil_tmp105) {
#line 812
                                                                                VP8GetCPUInfo = (int (*)(CPUFeature  ))((void *)0);
                                                                              } else {
                                                                                {
#line 814
                                                                                __cil_tmp106 = strcmp(*(argv + c),
                                                                                                      "-version\220");
                                                                                }
#line 814
                                                                                if (! __cil_tmp106) {
                                                                                  {
#line 815
                                                                                  __cil_tmp108 = WebPGetEncoderVersion();
#line 815
                                                                                  version = __cil_tmp108;
#line 816
                                                                                  printf("%d.%d.%d\n",
                                                                                         (version >> 16) & 255,
                                                                                         (version >> 8) & 255,
                                                                                         version & 255);
                                                                                  }
#line 818
                                                                                  return (0);
                                                                                } else {
                                                                                  {
#line 819
                                                                                  __cil_tmp109 = strcmp(*(argv + c),
                                                                                                        "-progress");
                                                                                  }
#line 819
                                                                                  if (! __cil_tmp109) {
#line 820
                                                                                    show_progress = 1;
                                                                                  } else {
                                                                                    {
#line 821
                                                                                    __cil_tmp110 = strcmp(*(argv + c),
                                                                                                          "-quiet");
                                                                                    }
#line 821
                                                                                    if (! __cil_tmp110) {
#line 822
                                                                                      quiet = 1;
                                                                                    } else {
                                                                                      {
#line 823
                                                                                      __cil_tmp111 = strcmp(*(argv + c),
                                                                                                            "-preset");
                                                                                      }
#line 823
                                                                                      if (! __cil_tmp111) {
#line 823
                                                                                        if (c < argc - 1) {
                                                                                          {
#line 825
                                                                                          c ++;
#line 826
                                                                                          __cil_tmp113 = strcmp(*(argv + c),
                                                                                                                "default");
                                                                                          }
#line 826
                                                                                          if (! __cil_tmp113) {
#line 827
                                                                                            preset = (enum WebPPreset )0;
                                                                                          } else {
                                                                                            {
#line 828
                                                                                            __cil_tmp114 = strcmp(*(argv + c),
                                                                                                                  "photo");
                                                                                            }
#line 828
                                                                                            if (! __cil_tmp114) {
#line 829
                                                                                              preset = (enum WebPPreset )2;
                                                                                            } else {
                                                                                              {
#line 830
                                                                                              __cil_tmp115 = strcmp(*(argv + c),
                                                                                                                    "picture");
                                                                                              }
#line 830
                                                                                              if (! __cil_tmp115) {
#line 831
                                                                                                preset = (enum WebPPreset )1;
                                                                                              } else {
                                                                                                {
#line 832
                                                                                                __cil_tmp116 = strcmp(*(argv + c),
                                                                                                                      "drawing");
                                                                                                }
#line 832
                                                                                                if (! __cil_tmp116) {
#line 833
                                                                                                  preset = (enum WebPPreset )3;
                                                                                                } else {
                                                                                                  {
#line 834
                                                                                                  __cil_tmp117 = strcmp(*(argv + c),
                                                                                                                        "icon");
                                                                                                  }
#line 834
                                                                                                  if (! __cil_tmp117) {
#line 835
                                                                                                    preset = (enum WebPPreset )4;
                                                                                                  } else {
                                                                                                    {
#line 836
                                                                                                    __cil_tmp118 = strcmp(*(argv + c),
                                                                                                                          "text");
                                                                                                    }
#line 836
                                                                                                    if (! __cil_tmp118) {
#line 837
                                                                                                      preset = (enum WebPPreset )5;
                                                                                                    } else {
                                                                                                      {
#line 839
                                                                                                      fprintf(stderr,
                                                                                                              "Error! Unrecognized preset: %s\n",
                                                                                                              *(argv + c));
                                                                                                      }
#line 840
                                                                                                      goto Error;
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                          {
#line 842
                                                                                          __cil_tmp119 = WebPConfigPreset___0(& config,
                                                                                                                              preset,
                                                                                                                              config.quality);
                                                                                          }
#line 842
                                                                                          if (! __cil_tmp119) {
                                                                                            {
#line 843
                                                                                            fprintf(stderr,
                                                                                                    "Error! Could initialize configuration with preset.\n");
                                                                                            }
#line 844
                                                                                            goto Error;
                                                                                          }
                                                                                        } else {
#line 823
                                                                                          goto _L___16;
                                                                                        }
                                                                                      } else {
                                                                                        _L___16: 
                                                                                        {
#line 846
                                                                                        __cil_tmp120 = strcmp(*(argv + c),
                                                                                                              "-metadata");
                                                                                        }
#line 846
                                                                                        if (! __cil_tmp120) {
#line 846
                                                                                          if (c < argc - 1) {
                                                                                            {
#line 847
                                                                                            __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:847)":);
#line 847
                                                                                            strcpy((char *)0,
                                                                                                   "all");
#line 847
                                                                                            __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:847)":);
#line 847
                                                                                            __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:847)":);
#line 847
                                                                                            strcpy((char *)0,
                                                                                                   "none");
#line 847
                                                                                            __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:847)":);
#line 847
                                                                                            __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:847)":);
#line 847
                                                                                            strcpy((char *)0,
                                                                                                   "exif");
#line 847
                                                                                            __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:847)":);
#line 847
                                                                                            __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:847)":);
#line 847
                                                                                            strcpy((char *)0,
                                                                                                   "icc");
#line 847
                                                                                            __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:847)":);
#line 847
                                                                                            __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:847)":);
#line 847
                                                                                            strcpy((char *)0,
                                                                                                   "xmp");
#line 847
                                                                                            __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:847)":);
#line 857
                                                                                            kNumTokens = sizeof(kTokens) / sizeof(kTokens[0]);
#line 858
                                                                                            c ++;
#line 858
                                                                                            start = *(argv + c);
#line 859
                                                                                            __cil_tmp125 = strlen(start);
#line 859
                                                                                            end = start + __cil_tmp125;
                                                                                            }
                                                                                            {
#line 861
                                                                                            while (1) {
                                                                                              while_continue___0: /* CIL Label */ ;

#line 861
                                                                                              if (! ((unsigned long )start < (unsigned long )end)) {
#line 861
                                                                                                goto while_break___0;
                                                                                              }
                                                                                              {
#line 863
                                                                                              __cil_tmp128 = strchr(start,
                                                                                                                    ',');
#line 863
                                                                                              token = (char const   *)__cil_tmp128;
                                                                                              }
#line 864
                                                                                              if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 864
                                                                                                token = end;
                                                                                              }
#line 866
                                                                                              i = (size_t )0;
                                                                                              {
#line 866
                                                                                              while (1) {
                                                                                                while_continue___1: /* CIL Label */ ;

#line 866
                                                                                                if (! (i < kNumTokens)) {
#line 866
                                                                                                  goto while_break___1;
                                                                                                }
                                                                                                {
#line 867
                                                                                                __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:867)":);
#line 867
                                                                                                __cil_tmp130 = strlen((char const   *)0);
#line 867
                                                                                                __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:867)":);
#line 867
                                                                                                __cil_tmp131 = strncmp(start,
                                                                                                                       (char const   *)0,
                                                                                                                       __cil_tmp130);
#line 867
                                                                                                __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:867)":);
#line 867
                                                                                                __cil_tmp129 = strlen((char const   *)0);
                                                                                                }
#line 867
                                                                                                if ((size_t )(token - start) == __cil_tmp129) {
#line 867
                                                                                                  if (! __cil_tmp131) {
#line 869
                                                                                                    __asm__  ("booo_exp(/root/patchweave_new/13/examples/cwebp.c:869)":);
#line 872
                                                                                                    keep_metadata = 0;
#line 874
                                                                                                    goto while_break___1;
                                                                                                  }
                                                                                                }
#line 866
                                                                                                i ++;
                                                                                              }
                                                                                              while_break___4: /* CIL Label */ ;
                                                                                              }
                                                                                              while_break___1: ;
#line 877
                                                                                              if (i == kNumTokens) {
                                                                                                {
#line 878
                                                                                                fprintf(stderr,
                                                                                                        "Error! Unknown metadata type \'%.*s\'\n",
                                                                                                        (int )(token - start),
                                                                                                        start);
#line 880
                                                                                                HelpLong();
                                                                                                }
#line 881
                                                                                                return (-1);
                                                                                              }
#line 883
                                                                                              start = token + 1;
                                                                                            }
                                                                                            while_break___3: /* CIL Label */ ;
                                                                                            }
                                                                                            while_break___0: ;
                                                                                          } else {
#line 846
                                                                                            goto _L;
                                                                                          }
                                                                                        } else {
                                                                                          _L: 
                                                                                          {
#line 892
                                                                                          __cil_tmp132 = strcmp(*(argv + c),
                                                                                                                "-v");
                                                                                          }
#line 892
                                                                                          if (! __cil_tmp132) {
#line 893
                                                                                            verbose = 1;
                                                                                          } else
#line 894
                                                                                          if ((int )*(*(argv + c) + 0) == 45) {
                                                                                            {
#line 895
                                                                                            fprintf(stderr,
                                                                                                    "Error! Unknown option \'%s\'\n",
                                                                                                    *(argv + c));
#line 896
                                                                                            HelpLong();
                                                                                            }
#line 897
                                                                                            return (-1);
                                                                                          } else {
#line 899
                                                                                            in_file = *(argv + c);
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 693
    c ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 902
  if ((unsigned long )in_file == (unsigned long )((void *)0)) {
    {
#line 903
    fprintf(stderr, "No input file specified!\n");
#line 904
    HelpShort();
    }
#line 905
    goto Error;
  }
#line 910
  if (! quiet) {
#line 910
    if (config.lossless == 1) {
#line 911
      if (config.target_size > 0) {
        {
#line 912
        fprintf(stderr, "Encoding for specified size or PSNR is not supported for lossless encoding. Ignoring such option(s)!\n");
        }
      } else
#line 911
      if (config.target_PSNR > (float )0) {
        {
#line 912
        fprintf(stderr, "Encoding for specified size or PSNR is not supported for lossless encoding. Ignoring such option(s)!\n");
        }
      }
#line 915
      if (config.partition_limit > 0) {
        {
#line 916
        fprintf(stderr, "Partition limit option is not required for lossless encoding. Ignoring this option!\n\220");
        }
      }
    }
  }
  {
#line 921
  __cil_tmp133 = WebPValidateConfig(& config);
  }
#line 921
  if (! __cil_tmp133) {
    {
#line 922
    fprintf(stderr, "Error! Invalid configuration.\n");
    }
#line 923
    goto Error;
  }
#line 927
  if (verbose) {
    {
#line 928
    StopwatchReadAndReset(& stop_watch);
    }
  }
#line 930
  if (keep_metadata == 0) {
#line 930
    tmp___1 = (Metadata *)((void *)0);
  } else {
#line 930
    tmp___1 = & metadata;
  }
  {
#line 930
  __cil_tmp135 = ReadPicture(in_file, & picture, keep_alpha, tmp___1);
  }
#line 930
  if (! __cil_tmp135) {
    {
#line 932
    fprintf(stderr, "Error! Cannot read input picture file \'%s\'\n", in_file);
    }
#line 933
    goto Error;
  }
#line 935
  if (show_progress) {
#line 935
    if (! quiet) {
#line 935
      tmp___2 = (int (*)(int percent , WebPPicture * const  picture ))(& ProgressReport);
    } else {
#line 935
      tmp___2 = (int (*)(int  , WebPPicture * const   ))((void *)0);
    }
  } else {
#line 935
    tmp___2 = (int (*)(int  , WebPPicture * const   ))((void *)0);
  }
#line 935
  picture.progress_hook = (int (*)(int  , WebPPicture * ))tmp___2;
#line 937
  if (blend_alpha) {
    {
#line 938
    WebPBlendAlpha(& picture, background_color);
    }
  }
#line 941
  if (keep_alpha == 2) {
    {
#line 942
    WebPCleanupTransparentArea(& picture);
    }
  }
#line 945
  if (verbose) {
    {
#line 946
    __cil_tmp138 = StopwatchReadAndReset(& stop_watch);
#line 946
    read_time = __cil_tmp138;
#line 947
    fprintf(stderr, "Time to read input: %.3fs\n", read_time);
    }
  }
#line 951
  if (out_file) {
    {
#line 952
    out = fopen(out_file, "wb");
    }
#line 953
    if ((unsigned long )out == (unsigned long )((void *)0)) {
      {
#line 954
      fprintf(stderr, "Error! Cannot open output file \'%s\'\n", out_file);
      }
#line 955
      goto Error;
    } else
#line 957
    if (! short_output) {
#line 957
      if (! quiet) {
        {
#line 958
        fprintf(stderr, "Saving file \'%s\'\n", out_file);
        }
      }
    }
#line 961
    if (keep_metadata == 0) {
#line 962
      picture.writer = & MyWriter;
#line 963
      picture.custom_ptr = (void *)out;
    } else {
#line 965
      picture.writer = & WebPMemoryWrite;
#line 966
      picture.custom_ptr = (void *)(& memory_writer);
    }
  } else {
#line 969
    out = (FILE *)((void *)0);
#line 970
    if (! quiet) {
#line 970
      if (! short_output) {
        {
#line 971
        fprintf(stderr, "No output file specified (no -o flag). Encoding will\n");
#line 972
        fprintf(stderr, "be performed, but its results discarded.\n\n");
        }
      }
    }
  }
#line 975
  if (! quiet) {
#line 976
    picture.stats = & stats;
#line 977
    picture.user_data = (void *)in_file;
  }
#line 981
  if (verbose) {
    {
#line 982
    StopwatchReadAndReset(& stop_watch);
    }
  }
#line 984
  if (crop != 0) {
    {
#line 986
    __cil_tmp140 = WebPPictureView(& picture, crop_x, crop_y, crop_w, crop_h, & picture);
    }
#line 986
    if (! __cil_tmp140) {
      {
#line 987
      fprintf(stderr, "Error! Cannot crop picture\n");
      }
#line 988
      goto Error;
    }
  }
#line 991
  if ((resize_w | resize_h) > 0) {
    {
#line 992
    __cil_tmp141 = WebPPictureRescale(& picture, resize_w, resize_h);
    }
#line 992
    if (! __cil_tmp141) {
      {
#line 993
      fprintf(stderr, "Error! Cannot resize picture\n");
      }
#line 994
      goto Error;
    }
  }
#line 997
  if (picture.extra_info_type > 0) {
    {
#line 998
    AllocExtraInfo(& picture);
    }
  }
#line 1000
  if (print_distortion >= 0) {
    {
#line 1001
    WebPPictureCopy(& picture, & original_picture);
    }
  }
  {
#line 1003
  __cil_tmp142 = WebPEncode(& config, & picture);
  }
#line 1003
  if (! __cil_tmp142) {
    {
#line 1004
    fprintf(stderr, "Error! Cannot encode picture as WebP\n");
#line 1005
    fprintf(stderr, "Error code: %d (%s)\n", (unsigned int )picture.error_code, kErrorMessages[picture.error_code]);
    }
#line 1007
    goto Error;
  }
#line 1009
  if (verbose) {
    {
#line 1010
    __cil_tmp144 = StopwatchReadAndReset(& stop_watch);
#line 1010
    encode_time = __cil_tmp144;
#line 1011
    fprintf(stderr, "Time to encode picture: %.3fs\n", encode_time);
    }
  }
#line 1015
  if (dump_file) {
#line 1016
    if (picture.use_argb) {
      {
#line 1017
      fprintf(stderr, "Warning: can\'t dump file (-d option) in lossless mode.");
      }
    } else {
      {
#line 1018
      __cil_tmp145 = DumpPicture(& picture, dump_file);
      }
#line 1018
      if (! __cil_tmp145) {
        {
#line 1019
        fprintf(stderr, "Warning, couldn\'t dump picture %s\n", dump_file);
        }
      }
    }
  }
#line 1023
  if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 1023
    if (keep_metadata != 0) {
      {
#line 1024
      __cil_tmp146 = WriteWebPWithMetadata(out, & picture, & memory_writer, & metadata,
                                           keep_metadata, & metadata_written);
      }
#line 1024
      if (! __cil_tmp146) {
        {
#line 1026
        fprintf(stderr, "Error writing WebP file with metadata!\n");
        }
#line 1027
        goto Error;
      }
    }
  }
#line 1031
  if (! quiet) {
#line 1032
    if (config.lossless) {
      {
#line 1033
      PrintExtraInfoLossless(& picture, short_output, in_file);
      }
    } else {
      {
#line 1035
      PrintExtraInfoLossy(& picture, short_output, config.low_memory, in_file);
      }
    }
#line 1037
    if (! short_output) {
      {
#line 1038
      PrintMetadataInfo(& metadata, metadata_written);
      }
    }
  }
#line 1041
  if (! quiet) {
#line 1041
    if (! short_output) {
#line 1041
      if (print_distortion >= 0) {
        {
#line 1042
        strcpy((char *)distortion_names[0], "PSNR");
#line 1042
        strcpy((char *)distortion_names[1], "SSIM");
#line 1042
        strcpy((char *)distortion_names[2], "LSIM");
#line 1044
        WebPPictureDistortion(& picture, & original_picture, print_distortion, (float *)(values));
#line 1046
        fprintf(stderr, "%s: Y:%.2f U:%.2f V:%.2f A:%.2f  Total:%.2f\n", distortion_names[print_distortion],
                (double )values[0], (double )values[1], (double )values[2], (double )values[3],
                (double )values[4]);
        }
      }
    }
  }
#line 1050
  return_value = 0;
  Error: 
  {
#line 1053
  free((void *)memory_writer.mem);
#line 1054
  free((void *)picture.extra_info);
#line 1055
  MetadataFree(& metadata);
#line 1056
  WebPPictureFree(& picture);
#line 1057
  WebPPictureFree(& original_picture);
  }
#line 1058
  if ((unsigned long )out != (unsigned long )((void *)0)) {
    {
#line 1059
    fclose(out);
    }
  }
#line 1062
  return (return_value);
}
}
